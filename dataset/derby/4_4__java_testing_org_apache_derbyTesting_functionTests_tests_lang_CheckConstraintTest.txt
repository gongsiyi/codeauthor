26:dc56246: 
1:dc56246: /*
1:dc56246: Derby - Class org.apache.derbyTesting.functionTests.tests.lang.CheckConstraintTest
1:dc56246: 
1:dc56246: Licensed to the Apache Software Foundation (ASF) under one or more
1:dc56246: contributor license agreements.  See the NOTICE file distributed with
1:dc56246: this work for additional information regarding copyright ownership.
1:dc56246: The ASF licenses this file to You under the Apache License, Version 2.0
1:dc56246: (the "License"); you may not use this file except in compliance with
1:dc56246: the License.  You may obtain a copy of the License at
1:dc56246: 
1:dc56246: http://www.apache.org/licenses/LICENSE-2.0
1:dc56246: 
1:dc56246: Unless required by applicable law or agreed to in writing, software
1:dc56246: distributed under the License is distributed on an "AS IS" BASIS,
1:dc56246: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:dc56246: See the License for the specific language governing permissions and
1:dc56246: limitations under the License.
1:dc56246: 
2:dc56246:  */
1:dc56246: 
1:dc56246: package org.apache.derbyTesting.functionTests.tests.lang;
1:dc56246: 
1:dc56246: import java.sql.PreparedStatement;
1:dc56246: import java.sql.ResultSet;
1:1ae02c9: import java.sql.ResultSetMetaData;
1:dc56246: import java.sql.SQLException;
1:1ae02c9: import java.sql.Statement;
1:dc56246: import junit.framework.Test;
1:dc56246: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.JDBC;
1:f167762: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:dc56246: import org.apache.derbyTesting.junit.TestConfiguration;
1:dc56246: 
1:dc56246: public final class CheckConstraintTest extends BaseJDBCTestCase {
1:dc56246: 
1:f167762:     // poached from GeneratedColumnsTest
1:f167762:     private static  final   String  IMPORT_FILE_NAME = "t_bi_1.dat";
1:f167762: 
1:dc56246:     /**
1:dc56246:      * Public constructor required for running test as standalone JUnit.
1:dc56246:      */
1:dc56246:     public CheckConstraintTest(String name)
4:dc56246:     {
1:dc56246:         super(name);
2:dc56246:     }
1:dc56246: 
1:dc56246:     public static Test suite()
1:dc56246:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("checkConstraint Test");
1:dc56246:         suite.addTest(TestConfiguration.defaultSuite(CheckConstraintTest.class));
1:f167762: 
1:f167762:         return new SupportFilesSetup(
1:f167762:              suite,
1:f167762:              new String [] { "functionTests/tests/lang/" + IMPORT_FILE_NAME });
1:dc56246:     }
1:dc56246:     
1:dc56246:     public void testNotAllowedInCheckConstraints() throws Exception
1:dc56246:     {
1:dc56246:         
1:fd2f1f7:         Statement st = createStatement();
1:fd2f1f7:         setAutoCommit(false);
1:dc56246:         
1:dc56246:         // negative The following are not allowed in check 
1:dc56246:         // constraints:	?, subquery, datetime functions
1:dc56246:         
1:dc56246:         assertStatementError("42Y39", st,
1:dc56246:             "create table neg1(c1 int check(?))");
1:dc56246:         
1:dc56246:         assertStatementError("42Y39", st,
1:dc56246:             " create table neg1(c1 int check(c1 in (select c1 "
1:dc56246:             + "from neg1)))");
1:dc56246:         
1:dc56246:         assertStatementError("42Y39", st,
1:dc56246:             " create table neg1(c1 int check(CURRENT_DATE = "
1:dc56246:             + "CURRENT_DATE))");
1:dc56246:         
1:dc56246:         assertStatementError("42Y39", st,
1:dc56246:             " create table neg1(c1 int check(CURRENT_TIME = "
1:dc56246:             + "CURRENT_TIME))");
1:dc56246:         
1:dc56246:         assertStatementError("42Y39", st,
1:dc56246:             " create table neg1(c1 int check(CURRENT_TIMESTAMP = "
1:dc56246:             + "CURRENT_TIMESTAMP))");
1:dc56246:         
1:dc56246:         // The check constraint definition must evaluate to a boolean
1:dc56246:         
1:dc56246:         assertStatementError("42X19", st,
1:dc56246:             "create table neg1(c1 int check(c1))");
1:dc56246:         
1:dc56246:         assertStatementError("42X19", st,
1:dc56246:             " create table neg1(c1 int check(1))");
1:dc56246:         
1:dc56246:         assertStatementError("42X19", st,
1:dc56246:             " create table neg1(c1 int check(c1+c1))");
1:dc56246:         
1:dc56246:         // All column references are to target table
1:dc56246:         
1:dc56246:         assertStatementError("42X04", st,
1:dc56246:             "create table neg1(c1 int check((c2 = 1)))");
1:dc56246:         
1:dc56246:         // verify that a check constraint can't be used as an 
1:dc56246:         // optimizer override
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "create table t1(c1 int constraint asdf check(c1 = 1))");
1:dc56246:         
1:dc56246:         assertStatementError("42Y48", st,
1:dc56246:             " select * from t1 --derby-properties constraint = asdf ");
1:dc56246:         
1:dc56246:         // alter table t1 drop constraint asdf
1:dc56246:         
1:fd2f1f7:         rollback();
1:dc56246:         
1:dc56246:         // alter table t1 drop constraint asdf forward references 
1:dc56246:         // should fail
1:dc56246:         
1:dc56246:         assertStatementError("42621", st,
1:dc56246:             "create table neg1(c1 int check(c2 = 1), c2 int)");
1:dc56246:         
1:dc56246:         assertStatementError("42621", st,
1:dc56246:             " create table neg2(c1 int constraint asdf check(c2 "
1:dc56246:             + "= 1), c2 int)");
1:dc56246:         
1:fd2f1f7:         rollback();
1:dc56246:     }
1:dc56246:     public void testCheckConstraints() throws SQLException{
1:dc56246:         
1:fd2f1f7:         Statement st = createStatement();
1:fd2f1f7:         setAutoCommit(false);
1:dc56246:         
1:dc56246:         // positive multiple check constraints on same table
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "create table pos1(c1 int check(c1 > 0), constraint "
1:dc56246:             + "asdf check(c1 < 10))");
1:dc56246:         
1:dc56246:         // verify both constraints are enforced
1:dc56246:         
2:dc56246:         assertStatementError("23513", st,
1:dc56246:             "insert into pos1 values 0");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " insert into pos1 values 1");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " insert into pos1 values 9");
1:dc56246:         
1:dc56246:         assertStatementError("23513", st,
1:dc56246:             " insert into pos1 values 10");
1:dc56246:         
1:fd2f1f7:         ResultSet rs = st.executeQuery("select * from pos1");
1:dc56246:         
1:fd2f1f7:         String[] expColNames = {"C1"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:fd2f1f7:         String[][] expRS = {
1:dc56246:             {"1"},
1:dc56246:             {"9"}
4:dc56246:         };
1:dc56246:         
2:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
1:dc56246:         // verify constraint violation rolls back entire statement
1:dc56246:         
1:dc56246:         assertStatementError("23513", st,
1:dc56246:             "update pos1 set c1 = c1 + 1");
1:dc56246:         
3:dc56246:         rs = st.executeQuery(
2:dc56246:             " select * from pos1");
1:dc56246:         
3:dc56246:         expColNames = new String [] {"C1"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
4:dc56246:         expRS = new String [][]
1:dc56246:         {
1:dc56246:             {"1"},
1:dc56246:             {"9"}
1:dc56246:         };
1:dc56246:         
1:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
1:dc56246:         assertStatementError("23513", st,
1:dc56246:             " update pos1 set c1 = c1 - 1");
1:dc56246:         
1:dc56246:         rs = st.executeQuery(
1:dc56246:             " select * from pos1");
1:dc56246:         
1:dc56246:         expColNames = new String [] {"C1"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:dc56246:         expRS = new String [][]
1:dc56246:         {
1:dc56246:             {"1"},
1:dc56246:             {"9"}
1:dc56246:         };
1:dc56246:         
1:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
1:fd2f1f7:         rollback();
1:dc56246:         
1:dc56246:         // conflicting constraints, should fail
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "create table negcks(c1 int constraint ck1st "
1:dc56246:             + "check(c1 > 4), c2 int constraint ck2nd check(c2 > "
1:dc56246:             + "2), c3 int, constraint ckLast check(c2 > c1))");
1:dc56246:         
1:dc56246:         // constraint ck1st fails
1:dc56246:         
1:dc56246:         assertStatementError("23513", st,
1:dc56246:             "insert into negcks values (1, 3, 3)");
1:dc56246:         
1:dc56246:         // constraint ckLast fails (ck2nd fails too)
1:dc56246:         
1:dc56246:         assertStatementError("23513", st,
1:dc56246:             "insert into negcks values (5, 1, 3)");
1:dc56246:         
1:dc56246:         // constraint ck1st fails (ckLast fails too)
1:dc56246:         
1:dc56246:         assertStatementError("23513", st,
1:dc56246:             "insert into negcks values (2, 3, 3)");
1:dc56246:         
1:fd2f1f7:         rollback();
1:dc56246:         
1:dc56246:         // same source and target tables
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "create table pos1(c1 int, c2 int, constraint ck1 "
1:dc56246:             + "check (c1 < c2))");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " insert into pos1 values (1, 2), (2, 3), (3, 4)");
1:dc56246:         
1:fd2f1f7:         commit();
1:dc56246:         // these should work
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "insert into pos1 select * from pos1");
1:dc56246:         
1:dc56246:         rs = st.executeQuery(
1:dc56246:             " select count(*) from pos1");
1:dc56246:         
1:dc56246:         expColNames = new String [] {"1"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:dc56246:         expRS = new String [][]
1:dc56246:         {
1:dc56246:             {"6"}
1:dc56246:         };
1:dc56246:         
1:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
1:dc56246:         assertUpdateCount(st, 6,
1:dc56246:             " update pos1 set c2 = (select max(c1) from pos1), "
1:dc56246:             + "c1 = (select min(c2) from pos1)");
1:dc56246:         
1:dc56246:         rs = st.executeQuery(
1:dc56246:             " select * from pos1");
1:dc56246:         
2:dc56246:         expColNames = new String [] {"C1", "C2"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:dc56246:         expRS = new String [][]
1:dc56246:         {
1:dc56246:             {"2", "3"},
1:dc56246:             {"2", "3"},
1:dc56246:             {"2", "3"},
1:dc56246:             {"2", "3"},
1:dc56246:             {"2", "3"},
1:dc56246:             {"2", "3"}
1:dc56246:         };
1:dc56246:         
1:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
1:fd2f1f7:         rollback();
1:dc56246:         
1:dc56246:         // these should fail
1:dc56246:         
1:dc56246:         assertStatementError("23513", st,
1:dc56246:             "insert into pos1 select c2, c1 from pos1");
1:dc56246:         
1:dc56246:         rs = st.executeQuery(
1:dc56246:             " select count(*) from pos1");
1:dc56246:         
1:dc56246:         expColNames = new String [] {"1"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:dc56246:         expRS = new String [][]
1:dc56246:         {
1:dc56246:             {"3"}
1:dc56246:         };
1:dc56246:         
1:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
1:dc56246:         assertStatementError("23513", st,
1:dc56246:             " update pos1 set c2 = (select min(c1) from pos1), "
1:dc56246:             + "c1 = (select max(c2) from pos1)");
1:dc56246:         
1:dc56246:         rs = st.executeQuery(
1:dc56246:             " select * from pos1");
1:dc56246:         
1:dc56246:         expColNames = new String [] {"C1", "C2"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:dc56246:         expRS = new String [][]
1:dc56246:         {
1:dc56246:             {"1", "2"},
1:dc56246:             {"2", "3"},
1:dc56246:             {"3", "4"}
1:dc56246:         };
1:dc56246:         
1:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " drop table pos1");
1:dc56246:         
1:fd2f1f7:         commit();
1:dc56246:         // union under insert
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "create table t1(c1 int, c2 int, constraint ck1 "
1:dc56246:             + "check(c1 = c2))");
1:dc56246:         
1:dc56246:         assertStatementError("23513", st,
1:dc56246:             " insert into t1 values (1, 1), (2, 1)");
1:dc56246:         
1:dc56246:         rs = st.executeQuery(
2:dc56246:             " select * from t1");
1:dc56246:         
1:dc56246:         expColNames = new String [] {"C1", "C2"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         JDBC.assertDrainResults(rs, 0);
1:dc56246:         
1:dc56246:         // normalize result set under insert/update
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "insert into t1 values (1.0, 1)");
1:dc56246:         
1:dc56246:         assertStatementError("23513", st,
1:dc56246:             " insert into t1 values (2.0, 1)");
1:dc56246:         
1:dc56246:         rs = st.executeQuery(
1:dc56246:             " select * from t1");
1:dc56246:         
1:dc56246:         expColNames = new String [] {"C1", "C2"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:dc56246:         expRS = new String [][]
1:dc56246:         {
1:dc56246:             {"1", "1"}
1:dc56246:         };
1:dc56246:         
1:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
3:dc56246:         assertUpdateCount(st, 1,
1:dc56246:             " update t1 set c2 = 1.0");
1:dc56246:         
1:dc56246:         assertStatementError("23513", st,
1:dc56246:             " update t1 set c2 = 2.0");
1:dc56246:         
1:dc56246:         rs = st.executeQuery(
1:dc56246:             " select * from t1");
1:dc56246:         
1:dc56246:         expColNames = new String [] {"C1", "C2"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:dc56246:         expRS = new String [][]
1:dc56246:         {
1:dc56246:             {"1", "1"}
1:dc56246:         };
1:dc56246:         
1:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
1:dc56246:         assertUpdateCount(st, 1,
1:dc56246:             " update t1 set c1 = 3.0, c2 = 3.0");
1:dc56246:         
1:dc56246:         rs = st.executeQuery(
1:dc56246:             " select * from t1");
1:dc56246:         
1:dc56246:         expColNames = new String [] {"C1", "C2"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:dc56246:         expRS = new String [][]
1:dc56246:         {
1:dc56246:             {"3", "3"}
1:dc56246:         };
1:dc56246:         
1:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
1:fd2f1f7:         rollback();
1:dc56246:     }
1:dc56246:     
1:dc56246:     public void testPositionalUpdate() throws SQLException{
1:dc56246:         
1:fd2f1f7:         Statement st = createStatement();
1:fd2f1f7:         setAutoCommit(false);
1:dc56246:         
1:dc56246:         // positioned update
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "create table t1(c1 int, c2 int, constraint ck1 "
1:dc56246:             + "check(c1 = c2), constraint ck2 check(c2=c1))");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " insert into t1 values (1, 1), (2, 2), (3, 3), (4, 4)");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " create index i1 on t1(c1)");
1:dc56246:         
1:fd2f1f7:         Statement st1 = createStatement();
1:37f8861:         st1.setCursorName("c1");
1:37f8861:         ResultSet rs1 = st1.executeQuery(
1:37f8861:                 "select * from t1 where c2=2 for update of C1");
1:37f8861:         rs1.next();   
1:37f8861:         setAutoCommit(false);
1:dc56246:         
1:37f8861:         // this update should succeed
1:37f8861:         assertUpdateCount(st,1,
1:37f8861:                 "update t1 set c1 = c1 where current of \"c1\"");
1:dc56246:         
1:37f8861:         // this update should fail
1:37f8861:         assertStatementError("23513", st,
1:37f8861:             "update t1 set c1 = c1 + 1 where current of \"c1\"");
1:37f8861:         st1.close();
1:37f8861:         rs1.close();
1:dc56246:         
1:fd2f1f7:         Statement st2 = createStatement();
1:37f8861:         st2.setCursorName("c2");
1:37f8861:         ResultSet rs2 = st2.executeQuery(
1:37f8861:                 "select * from t1 where c1 = 2 for update of c2");
1:37f8861:         rs2.next();   
1:dc56246:         setAutoCommit(false);
2:dc56246:         // this update should succeed
1:37f8861:         assertUpdateCount(st,1,
1:37f8861:                 "update t1 set c2 = c2 where current of \"c2\"");
1:dc56246:         
2:dc56246:         // this update should fail
1:dc56246:         assertStatementError("23513", st,
1:37f8861:             "update t1 set c2 = c2 + 1 where current of \"c2\"");
1:37f8861:         st2.close();
1:37f8861:         rs2.close();
1:dc56246:         
1:fd2f1f7:         Statement st3 = createStatement();
1:37f8861:         st3.setCursorName("c3");
1:37f8861:         ResultSet rs3 = st3.executeQuery(
1:37f8861:                 "select * from t1 where c1 = 2 for update of c1, c2");
1:37f8861:         rs3.next();   
1:37f8861:         setAutoCommit(false);
1:dc56246:         
1:dc56246:         // this update should succeed
1:dc56246:         assertUpdateCount(st, 1,
1:37f8861:             "update t1 set c2 = c1, c1 = c2 where current of \"c3\"");
1:dc56246:         
1:dc56246:         // this update should fail
1:dc56246:         assertStatementError("23513", st,
1:37f8861:             "update t1 set c2 = c2 + 1, c1 = c1 + 3 where current of \"c3\"");
1:dc56246:         
1:dc56246:         // this update should succeed
1:dc56246:         assertUpdateCount(st, 1,
1:37f8861:             "update t1 set c2 = c1 + 3, c1 = c2 + 3 where current of \"c3\"");
1:37f8861:         st3.close();
1:37f8861:         rs3.close();
1:dc56246:         
1:fd2f1f7:         ResultSet rs = st.executeQuery("select * from t1");
1:dc56246:         
1:fd2f1f7:         String[] expColNames = {"C1", "C2"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:fd2f1f7:         String[][] expRS = {
1:dc56246:             {"1", "1"},
1:dc56246:             {"5", "5"},
1:dc56246:             {"3", "3"},
1:dc56246:             {"4", "4"}
1:dc56246:         };
1:dc56246:         
1:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
1:fd2f1f7:         rollback();
1:dc56246:         
1:dc56246:         // complex expressions
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "create table t1(c1 int check((c1 + c1) = (c1 * c1) "
1:dc56246:             + "or (c1 + c1)/2 = (c1 * c1)), c2 int)");
1:dc56246:         
1:dc56246:         // this insert should succeed
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "insert into t1 values (1, 9), (2, 10)");
1:dc56246:         
1:dc56246:         // these updates should succeed
1:dc56246:         
1:dc56246:         assertUpdateCount(st, 2,
1:dc56246:             "update t1 set c2 = c2 * c2");
1:dc56246:         
1:dc56246:         assertUpdateCount(st, 1,
1:dc56246:             " update t1 set c1 = 2 where c1 = 1");
1:dc56246:         
1:dc56246:         assertUpdateCount(st, 2,
1:dc56246:             " update t1 set c1 = 1 where c1 = 2");
1:dc56246:         
1:dc56246:         // this update should fail
1:dc56246:         
1:dc56246:         assertStatementError("23513", st,
1:dc56246:             "update t1 set c1 = c2");
1:dc56246:         
1:dc56246:         rs = st.executeQuery(
1:dc56246:             " select * from t1");
1:dc56246:         
1:dc56246:         expColNames = new String [] {"C1", "C2"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:dc56246:         expRS = new String [][]
1:dc56246:         {
1:dc56246:             {"1", "81"},
1:dc56246:             {"1", "100"}
1:dc56246:         };
1:dc56246:         
1:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
1:fd2f1f7:         rollback();
1:dc56246:     }
1:dc56246:     
1:dc56246:     public void testBuiltInFunctions() throws SQLException{
1:dc56246:         
1:fd2f1f7:         Statement st = createStatement();
1:fd2f1f7:         setAutoCommit(false);
1:dc56246:         
1:dc56246:         // built-in functions in a check constraint
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "create table charTab (c1 char(4) check(CHAR(c1) = c1))");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " insert into charTab values 'asdf'");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " insert into charTab values 'fdsa'");
1:dc56246:         
1:dc56246:         // beetle 5805 - support built-in function INT should fail 
1:dc56246:         // until beetle 5805 is implemented
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "create table intTab (c1 int check(INT(1) = c1))");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " insert into intTab values 1");
1:dc56246:         
1:dc56246:         // this insert should fail, does not satisfy check constraint
1:dc56246:         
1:dc56246:         assertStatementError("23513", st,
1:dc56246:             "insert into intTab values 2");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " create table maxIntTab (c1 int check(INT(2147483647) > c1))");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " insert into maxIntTab values 1");
1:dc56246:         
1:dc56246:         // this insert should fail, does not satisfy check constraint
1:dc56246:         
1:dc56246:         assertStatementError("23513", st,
1:dc56246:             "insert into maxIntTab values 2147483647");
1:dc56246:         
1:fd2f1f7:         rollback();
1:dc56246:         
1:dc56246:         // verify that inserts, updates and statements with forced 
1:dc56246:         // constraints are indeed dependent on the constraints
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "create table t1(c1 int not null constraint asdf primary key)");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " insert into t1 values 1, 2, 3, 4, 5");
1:dc56246:         
1:fd2f1f7:         commit();
1:dc56246:         
1:dc56246:         PreparedStatement pSt1 = prepareStatement(
1:dc56246:             "insert into t1 values 1");
1:dc56246:         
1:dc56246:         PreparedStatement pSt2 = prepareStatement(
1:dc56246:             "update t1 set c1 = 3 where c1 = 4");
1:dc56246:         
1:dc56246:         PreparedStatement pSt3 = prepareStatement(
1:dc56246:             "select * from t1");
1:dc56246:         
1:dc56246:         // the insert and update should fail, select should succeed
1:dc56246:         
1:dc56246:         assertStatementError("23505", pSt1);
1:dc56246:         
1:dc56246:         assertStatementError("23505", pSt2);
1:dc56246: 
1:dc56246:         
1:fd2f1f7:         ResultSet rs = pSt3.executeQuery();
1:dc56246:         
1:fd2f1f7:         String[] expColNames = {"C1"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:fd2f1f7:         String[][] expRS = {
1:dc56246:             {"1"},
1:dc56246:             {"2"},
1:dc56246:             {"3"},
1:dc56246:             {"4"},
1:dc56246:             {"5"}
1:dc56246:         };
1:dc56246:         
1:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " alter table t1 drop constraint asdf");
1:dc56246:         
1:dc56246:         // rollback and verify that constraints are enforced and 
1:dc56246:         // select succeeds
1:dc56246:         
1:fd2f1f7:         rollback();
1:dc56246:         
1:dc56246:         assertStatementError("23505", pSt1);
1:dc56246:         
1:dc56246:         assertStatementError("23505", pSt2);
1:dc56246:         
2:dc56246:         rs = pSt3.executeQuery();
1:dc56246:         expColNames = new String [] {"C1"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:dc56246:         expRS = new String [][]
1:dc56246:         {
1:dc56246:             {"1"},
1:dc56246:             {"2"},
1:dc56246:             {"3"},
1:dc56246:             {"4"},
1:dc56246:             {"5"}
1:dc56246:         };
1:dc56246:         
1:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
1:dc56246:         
1:dc56246:         
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " drop table t1");
1:dc56246:         
1:dc56246:         // check constraints with parameters
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "create table t1(c1 int constraint asdf check(c1 = 1))");
1:dc56246:         
1:fd2f1f7:         PreparedStatement pSt = prepareStatement(
1:dc56246:             "insert into t1 values (?)");
1:dc56246:         
1:dc56246:         rs = st.executeQuery(
1:dc56246:             "values (1)");
1:dc56246:         
1:dc56246:         rs.next();
1:fd2f1f7:         ResultSetMetaData rsmd = rs.getMetaData();
1:dc56246:         for (int i = 1; i <= rsmd.getColumnCount(); i++)
1:dc56246:             pSt.setObject(i, rs.getObject(i));
1:dc56246:         
1:dc56246:         assertUpdateCount(pSt, 1);
1:dc56246:         
1:dc56246:         // clean up
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "drop table t1");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " create table t1(active_flag char(2) "
1:dc56246:             + "check(active_flag IN ('Y', 'N')), "
1:dc56246:             + "araccount_active_flag char(2) "
1:dc56246:             + "check(araccount_active_flag IN ('Y', 'N')), "
1:dc56246:             + "automatic_refill_flag char(2) "
1:dc56246:             + "check(automatic_refill_flag IN ('Y', 'N')), "
1:dc56246:             + "call_when_ready_flag char(2) "
1:dc56246:             + "check(call_when_ready_flag IN ('Y', 'N')), "
1:dc56246:             + "compliance_flag char(2) check(compliance_flag IN "
1:dc56246:             + "('Y', 'N')), delivery_flag char(2) "
1:dc56246:             + "check(delivery_flag IN ('Y', 'N')), "
1:dc56246:             + "double_count_flag char(2) check(double_count_flag "
1:dc56246:             + "IN ('Y', 'N')), gender_ind char(2) check(gender_ind "
1:dc56246:             + "IN ('M', 'F', 'U')), geriatric_flag char(2) "
1:dc56246:             + "check(geriatric_flag IN ('Y', 'N')), "
1:dc56246:             + "refuse_inquiry_flag char(2) "
1:dc56246:             + "check(refuse_inquiry_flag IN ('Y', 'N')), "
1:dc56246:             + "animal_flag char(2) check(animal_flag IN ('Y', "
1:dc56246:             + "'N')), terminal_flag char(2) check(terminal_flag IN "
1:dc56246:             + "('Y', 'N')), unit_flag char(2) check(unit_flag IN "
1:dc56246:             + "('Y', 'N')), VIP_flag char(2) check(VIP_flag IN "
1:dc56246:             + "('Y', 'N')), snap_cap_flag char(2) "
1:dc56246:             + "check(snap_cap_flag IN ('Y', 'N')), "
1:dc56246:             + "consent_on_file_flag char(2) "
1:dc56246:             + "check(consent_on_file_flag IN ('Y', 'N')), "
1:dc56246:             + "enlarged_SIG_flag char(2) check(enlarged_SIG_flag "
1:dc56246:             + "IN ('Y', 'N')),aquired_patient_flag char(2) "
1:dc56246:             + "check(aquired_patient_flag IN ('Y', 'N')))");
1:dc56246:         
1:dc56246:         // bug 5622 - internal generated constraint names are 
1:dc56246:         // re-worked to match db2's naming convention.
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "drop table t1");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " create table t1 (c1 int not null primary key, c2 "
1:dc56246:             + "int not null unique, c3 int check (c3>=0))");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " alter table t1 add column c4 int not null default 1");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " alter table t1 add constraint c4_unique UNIQUE(c4)");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " alter table t1 add column c5 int check(c5 >= 0)");
1:dc56246:         
1:dc56246:         rs = st.executeQuery(
1:dc56246:             " select  c.type from "
1:dc56246:             + "sys.sysconstraints c, sys.systables t where "
1:dc56246:             + "c.tableid = t.tableid and tablename='T1'");
1:dc56246:         
1:dc56246:         expColNames = new String [] {"TYPE"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:dc56246:         expRS = new String [][]
1:dc56246:         {
1:dc56246:             {"P"},
1:dc56246:             {"U"},
1:dc56246:             {"C"},
1:dc56246:             {"U"},
1:dc56246:             {"C"}
1:dc56246:         };
1:dc56246:         
1:583afe5:         JDBC.assertUnorderedResultSet(rs, expRS, true);
1:dc56246:         
1:dc56246:         assertStatementError("42Y55", st,
1:dc56246:             " drop table t2");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " create table t2 (c21 int references t1)");
1:dc56246:         
1:dc56246:         rs = st.executeQuery(
1:dc56246:             " select c.type from "
1:dc56246:             + "sys.sysconstraints c, sys.systables t where "
1:dc56246:             + "c.tableid = t.tableid and tablename='T2'");
1:dc56246:         
1:dc56246:         expColNames = new String [] {"TYPE"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:dc56246:         expRS = new String [][]
1:dc56246:         {
1:dc56246:             {"F"}
1:dc56246:         };
1:dc56246:         
1:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
1:dc56246:         assertStatementError("42Y55", st,
1:dc56246:             " drop table t3");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " create table t3 (c1 int check (c1 >= 0), c2 int "
1:dc56246:             + "check (c2 >= 0), c3 int check (c3 >= 0), c4 int "
1:dc56246:             + "check (c4 >= 0), c5 int check (c5 >= 0), c6 int "
1:dc56246:             + "check (c6 >= 0), c7 int check (c7 >= 0), c8 int "
1:dc56246:             + "check (c8 >= 0), c9 int check (c9 >= 0), c10 int "
1:dc56246:             + "check (c10 >= 0), c11 int check (c11 >= 0), c12 int "
1:dc56246:             + "check (c12 >= 0), c13 int check (c13 >= 0))");
1:dc56246:         
1:dc56246:         rs = st.executeQuery(
1:dc56246:             " select c.type from "
1:dc56246:             + "sys.sysconstraints c, sys.systables t where "
1:dc56246:             + "c.tableid = t.tableid and tablename='T3'");
1:dc56246:         
1:dc56246:         expColNames = new String [] {"TYPE"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:dc56246:         expRS = new String [][]
1:dc56246:         {
1:dc56246:             {"C"},
1:dc56246:             {"C"},
1:dc56246:             {"C"},
1:dc56246:             {"C"},
1:dc56246:             {"C"},
1:dc56246:             {"C"},
1:dc56246:             {"C"},
1:dc56246:             {"C"},
1:dc56246:             {"C"},
1:dc56246:             {"C"},
1:dc56246:             {"C"},
1:dc56246:             {"C"},
1:dc56246:             {"C"}
1:dc56246:         };
1:dc56246:         
1:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
1:dc56246:         assertStatementError("42Y55", st,
1:dc56246:             " drop table t4");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " create table t4(c11 int not null, c12 int not "
1:dc56246:             + "null, primary key (c11, c12))");
1:dc56246:         
1:dc56246:         rs = st.executeQuery(
1:dc56246:             " select c.type from "
1:dc56246:             + "sys.sysconstraints c, sys.systables t where "
1:dc56246:             + "c.tableid = t.tableid and tablename='T4'");
1:dc56246:         
1:dc56246:         expColNames = new String [] {"TYPE"};
1:dc56246:         JDBC.assertColumnNames(rs, expColNames);
1:dc56246:         
1:dc56246:         expRS = new String [][]
1:dc56246:         {
1:dc56246:             {"P"}
1:dc56246:         };
1:dc56246:         
1:dc56246:         JDBC.assertFullResultSet(rs, expRS, true);
1:dc56246:         
1:3b91e3b:         // Cleanup:
1:3b91e3b:         st.executeUpdate("drop table t4");
1:3b91e3b:         st.executeUpdate("drop table t3");
1:3b91e3b:         st.executeUpdate("drop table t2");
1:3b91e3b:         st.executeUpdate("drop table t1");
1:fd2f1f7:         commit();
1:dc56246:         
1:dc56246:         // DERBY-2989
1:dc56246:     }
1:dc56246:     public void testJira2989() throws SQLException{
1:dc56246:         
1:fd2f1f7:         Statement st = createStatement();
1:fd2f1f7:         setAutoCommit(false);
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             "CREATE TABLE \"indicator\" (c CHAR(1) DEFAULT 'N')");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " ALTER TABLE  \"indicator\" ADD CONSTRAINT "
1:dc56246:             + "my_constraint CHECK ((c IN ('Y','N')))");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " INSERT INTO  \"indicator\" VALUES ('N')");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " ALTER TABLE  \"indicator\" DROP CONSTRAINT my_constraint");
1:dc56246:         
1:dc56246:         st.executeUpdate(
1:dc56246:             " DROP TABLE   \"indicator\"");
1:dc56246:              
1:dc56246:         getConnection().rollback();
1:dc56246:         st.close();
1:dc56246:     }
1:37f8861:     public void testJira4282() throws SQLException
1:37f8861:     {
1:37f8861:         // This test doesnt work properly in the embedded configuration.
1:37f8861:         // The intent of the test is to expose the DERBY-4282 problem, and
1:37f8861:         // this test case does do that in the client/server configuration, so
1:37f8861:         // we only run the test in that configuration. In the embedded
1:37f8861:         // configuration, the UPDATE statement unexpectedly gets a 
1:37f8861:         // "no current row" exception.
1:37f8861:         //
1:37f8861:         if (usingEmbedded())
1:37f8861:             return;
1:37f8861: 
1:fd2f1f7:         Statement st = createStatement();
1:37f8861: 
1:37f8861:         st.executeUpdate(
1:37f8861:             "create table t4282(c1 int, c2 int, constraint ck1 "
1:37f8861:             + "check(c1 = c2), constraint ck2 check(c2=c1))");
1:37f8861: 
1:37f8861:         st.executeUpdate("insert into t4282 values (1,1),(2,2),(3,3),(4,4)");
1:37f8861: 
1:37f8861:         Statement st1 = createStatement();
1:37f8861:         st1.setCursorName("c1");
1:37f8861:         ResultSet rs = st1.executeQuery("select * from t4282 for update");
1:37f8861:         assertTrue("Failed to retrieve row for update", rs.next());
1:37f8861:         // DERBY-4282 causes the next statement to fail with:
1:37f8861:         //
1:37f8861:         // Column 'C2' is either not in any table in the FROM list or
1:37f8861:         // appears within a join specification and is outside the scope
1:37f8861:         // of the join specification or appears in a HAVING clause and
1:37f8861:         // is not in the GROUP BY list. If this is a CREATE or ALTER TABLE
1:37f8861:         // statement then 'C2' is not a column in the target table. 
1:37f8861:         st.executeUpdate("update t4282 set c1 = c1 where current of \"c1\"");
1:37f8861: 
1:37f8861:         // If we get here, all is well, and DERBY-4282 did not occur.
1:37f8861:         st1.close();
1:37f8861:         st.close();
1:e1fc30c: 
1:e1fc30c:         dropTable("t4282");
1:37f8861:     }
1:e594ab0:     // This test verifies that if the PRIMARY KEY constraint mentions a
1:e594ab0:     // column which is potentially large, then Derby will automatically
1:e594ab0:     // choose a large pagesize for the index's conglomerate (DERBY-3947)
1:e594ab0:     //
1:e594ab0:     public void testPrimaryKeyPageSizeDerby3947()
1:e594ab0:         throws SQLException
1:e594ab0:     {
1:fd2f1f7:         Statement st = createStatement();
1:e594ab0:         st.executeUpdate("create table d3947 (x varchar(1000) primary key)");
1:e594ab0:         char[] chars = new char[994];
1:e594ab0:         PreparedStatement ps = prepareStatement("insert into d3947 values (?)");
1:e594ab0:         ps.setString(1, new String(chars));
1:e594ab0:         ps.executeUpdate();
1:e594ab0:         ps.close();
1:e594ab0:         checkLargePageSize(st, "D3947");
1:e594ab0:         st.executeUpdate("drop table d3947");
1:e594ab0: 
1:e594ab0:         // A second variation is to add the PK constraint using ALTER TABLE;
1:e594ab0:         // A third variation is to add a FK constraint
1:e594ab0:         st.executeUpdate("create table d3947 (x varchar(1000) not null, " +
1:e594ab0:                 " y varchar(1000))");
1:e594ab0:         st.executeUpdate("alter table d3947 add constraint " +
1:e594ab0:                 "constraint1 primary key (x)");
1:e594ab0:         st.executeUpdate("alter table d3947 add constraint " +
1:e594ab0:                 "constraint2 foreign key (y) references d3947(x)");
1:e594ab0:         checkLargePageSize(st, "D3947");
1:e594ab0:         // Ensure we still get the right error message when col doesn't exist:
1:e594ab0:         assertStatementError("42X14", st,
1:e594ab0:                 "alter table d3947 add constraint " +
1:e594ab0:                 "constraint3 foreign key (z) references d3947(x)");
1:e594ab0:         st.executeUpdate("drop table d3947");
1:e594ab0: 
1:e594ab0:         st.close();
1:e594ab0:     }
1:e594ab0:     private void checkLargePageSize(Statement st, String tblName)
1:e594ab0:         throws SQLException
1:e594ab0:     {
1:e594ab0:         ResultSet rs = st.executeQuery(
1:e594ab0:             "select * from TABLE(SYSCS_DIAG.SPACE_TABLE('"+tblName+"')) T");
1:e594ab0:         while (rs.next())
1:e594ab0:         {
1:e594ab0:             if ("1".equals(rs.getString("isindex")))
1:e594ab0:                 assertEquals(32768, rs.getInt("pagesize"));
1:e594ab0:             else
1:e594ab0:                 assertEquals(4096, rs.getInt("pagesize"));
1:e594ab0: 
1:e594ab0:             //System.out.println(rs.getString("conglomeratename") +
1:e594ab0:             //        ","+rs.getString("isindex")+
1:e594ab0:             //        ","+rs.getString("pagesize"));
1:e594ab0:         }
1:e594ab0:         rs.close();
1:e594ab0:     }
1:9d9f6dd: 
1:9d9f6dd:     /**
1:9d9f6dd:      * Test that CHECK constraint works if it contains unqualified names and
1:9d9f6dd:      * the current schema when the constraint is defined is different from the
1:9d9f6dd:      * schema in which the table lives. Regression test case for DERBY-6362.
1:9d9f6dd:      */
1:9d9f6dd:     public void testDerby6362() throws SQLException {
1:9d9f6dd:         setAutoCommit(false);
1:9d9f6dd:         Statement s = createStatement();
1:9d9f6dd:         s.execute("create schema d6362_s1");
1:9d9f6dd:         s.execute("create schema d6362_s2");
1:9d9f6dd: 
1:9d9f6dd:         s.execute("set schema d6362_s1");
1:9d9f6dd:         s.execute("create function f(x int) returns int deterministic "
1:9d9f6dd:                 + "language java  parameter style java external name "
1:9d9f6dd:                 + "'java.lang.Math.abs' no sql");
1:9d9f6dd:         s.execute("create type typ "
1:9d9f6dd:                 + "external name 'java.util.ArrayList' language java");
1:9d9f6dd: 
1:9d9f6dd:         // Create the table with the constraints in a different schema than
1:9d9f6dd:         // the current schema. Before DERBY-6362, unqualified names would be
1:9d9f6dd:         // resolved to the current schema at definition time and to the
1:9d9f6dd:         // table's schema during execution, which made them behave unreliably
1:9d9f6dd:         // if the schemas differed.
1:9d9f6dd:         s.execute("create table d6362_s2.t(x int, "
1:9d9f6dd:                 + "constraint c001 check(f(x) < 3))");
1:9d9f6dd:         s.execute("alter table d6362_s2.t "
1:9d9f6dd:                 + "add constraint c002 check(f(x) >= 0)");
1:9d9f6dd:         s.execute("alter table d6362_s2.t "
1:9d9f6dd:                 + "add constraint c003 check(cast(null as typ) is null)");
1:9d9f6dd: 
1:9d9f6dd:         // Use a function that lives in the SYSFUN schema.
1:9d9f6dd:         s.execute("alter table d6362_s2.t add constraint c004 "
1:9d9f6dd:                 + "check(f(x) > cos(pi()))");
1:9d9f6dd: 
1:9d9f6dd:         // ABS is an operator, not a function, so it will not be qualified.
1:9d9f6dd:         s.execute("alter table d6362_s2.t add constraint c005 "
1:9d9f6dd:                 + "check(abs(f(x)) < pi())");
1:9d9f6dd: 
1:9d9f6dd:         // Add some constraints that reference the table. See that table
1:9d9f6dd:         // names are qualified. Unqualified column names will not be qualified
1:9d9f6dd:         // with schema and table.
1:9d9f6dd:         s.execute("set schema d6362_s2");
1:9d9f6dd:         s.execute("alter table t add constraint c101 check(x < 3)");
1:9d9f6dd:         s.execute("alter table t add constraint c102 check(t.x < 4)");
1:9d9f6dd:         s.execute("alter table t add constraint c103 "
1:9d9f6dd:                 + "check(x <= d6362_s1.f(t.x))");
1:9d9f6dd: 
1:9d9f6dd:         // Add some fully qualified names to see that they still work.
1:9d9f6dd:         s.execute("alter table t add constraint c201 check(d6362_s2.t.x < 5)");
1:9d9f6dd:         s.execute("alter table t add constraint c202 check(d6362_s1.f(x) < 5)");
1:9d9f6dd:         s.execute("alter table t add constraint c203 "
1:9d9f6dd:                 + "check(cast(null as d6362_s1.typ) is null)");
1:9d9f6dd: 
1:9d9f6dd:         // Verify that the constraints were stored with fully qualified names.
1:9d9f6dd:         String[][] expectedConstraints = {
1:9d9f6dd:             {"C001", "(\"D6362_S1\".\"F\"(x) < 3)"},
1:9d9f6dd:             {"C002", "(\"D6362_S1\".\"F\"(x) >= 0)"},
1:9d9f6dd:             {"C003", "(cast(null as \"D6362_S1\".\"TYP\") is null)"},
1:9d9f6dd:             {"C004", "(\"D6362_S1\".\"F\"(x) > \"SYSFUN\".\"COS\"(\"SYSFUN\".\"PI\"()))"},
1:9d9f6dd:             {"C005", "(abs(\"D6362_S1\".\"F\"(x)) < \"SYSFUN\".\"PI\"())"},
1:9d9f6dd:             {"C101", "(x < 3)"},
1:9d9f6dd:             {"C102", "(\"D6362_S2\".\"T\".x < 4)"},
1:9d9f6dd:             {"C103", "(x <= \"D6362_S1\".\"F\"(\"D6362_S2\".\"T\".x))"},
1:9d9f6dd:             {"C201", "(\"D6362_S2\".\"T\".x < 5)"},
1:9d9f6dd:             {"C202", "(\"D6362_S1\".\"F\"(x) < 5)"},
1:9d9f6dd:             {"C203", "(cast(null as \"D6362_S1\".\"TYP\") is null)"},
1:9d9f6dd:         };
1:9d9f6dd: 
1:9d9f6dd:         JDBC.assertFullResultSet(
1:9d9f6dd:             s.executeQuery(
1:9d9f6dd:                 "select constraintname, checkdefinition from sys.syschecks "
1:9d9f6dd:                 + "natural join sys.sysconstraints natural join sys.sysschemas "
1:9d9f6dd:                 + "where schemaname = 'D6362_S2' and type = 'C' "
1:9d9f6dd:                 + "order by constraintname"),
1:9d9f6dd:             expectedConstraints);
1:9d9f6dd: 
1:9d9f6dd:         // Verify that constraints can be executed. Used to fail because
1:9d9f6dd:         // unqualified functions and types were resolved to the table's schema
1:9d9f6dd:         // instead of the current schema at the time the constraint was defined.
1:9d9f6dd:         s.execute("insert into t values 1,2");
1:9d9f6dd:         assertStatementError("23513", s, "insert into t values -10");
1:9d9f6dd:         assertStatementError("23513", s, "insert into t values 10");
1:9d9f6dd:     }
1:f167762: 
1:f167762:     private void setupForBulkInsert(Statement s, int limit)
1:f167762:             throws SQLException {
1:f167762:         s.executeUpdate(
1:f167762:             "create table t_bi_1( a int, b int check (b < " + limit + "))");
1:f167762: 
1:f167762:         s.executeUpdate(
1:f167762:             "create function func () returns int " + 
1:f167762:             "    language java parameter style java deterministic no sql " +
1:f167762:             "    external name '" + this.getClass().getName() + ".func'");
1:f167762:     }
1:f167762: 
1:f167762:     /**
1:f167762:      * DERBY-6453. Exercise hitherto untested code path in
1:f167762:      * InsertResultSet (call to evaluateCheckConstraints from
1:f167762:      * preprocessSourceRow used by bulkInsert) and verify IMPORT with
1:f167762:      * trigger (which would a priori mandate bulk insert, but is
1:f167762:      * changed due to normal inserts due to the presence of a
1:f167762:      * trigger).
1:f167762:      */
1:f167762:     public void testbulkInsert() throws SQLException {
1:f167762: 
1:f167762:         setAutoCommit(false);
1:f167762:         Statement s = createStatement();
1:f167762: 
1:f167762:         setupForBulkInsert(s, 0);
1:f167762: 
1:f167762:         assertStatementError(
1:f167762:             "23513", s,
1:f167762:             "call syscs_util.syscs_import_data( " + 
1:f167762:             "    null, " + 
1:f167762:             "    'T_BI_1', " + 
1:f167762:             "    'A, B', " + 
1:f167762:             "    '1, 2', " + 
1:f167762:             "    'extin/" + IMPORT_FILE_NAME + "', " + 
1:f167762:             "    null, null, null, 0 )");
1:f167762: 
1:f167762:         setupForBulkInsert(s, 10);
1:f167762: 
1:f167762:         s.executeUpdate(
1:f167762:             "create trigger dagstrigger no cascade before insert on t_bi_1 " +
1:f167762:             "    values func() ");
1:f167762: 
1:f167762:         funcWasCalled = false;
1:f167762: 
1:f167762:         s.executeUpdate(
1:f167762:             "call syscs_util.syscs_import_data( " + 
1:f167762:             "    null, " + 
1:f167762:             "    'T_BI_1', " + 
1:f167762:             "    'A, B', " + 
1:f167762:             "    '1, 2', " + 
1:f167762:             "    'extin/" + IMPORT_FILE_NAME + "', " + 
1:f167762:             "    null, null, null, 0 )");
1:f167762: 
1:f167762:         assertTrue(funcWasCalled);
1:f167762:     }
1:f167762: 
1:f167762:     static boolean funcWasCalled;
1:f167762:     
1:f167762:     public static int func()
1:f167762:     {
1:f167762:         funcWasCalled = true;
1:f167762:         return 0;
1:f167762:     }
1:f167762: 
1:37f8861: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSetMetaData;
1: import java.sql.Statement;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("checkConstraint Test");
commit:f167762
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:     // poached from GeneratedColumnsTest
1:     private static  final   String  IMPORT_FILE_NAME = "t_bi_1.dat";
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         return new SupportFilesSetup(
1:              suite,
1:              new String [] { "functionTests/tests/lang/" + IMPORT_FILE_NAME });
/////////////////////////////////////////////////////////////////////////
1: 
1:     private void setupForBulkInsert(Statement s, int limit)
1:             throws SQLException {
1:         s.executeUpdate(
1:             "create table t_bi_1( a int, b int check (b < " + limit + "))");
1: 
1:         s.executeUpdate(
1:             "create function func () returns int " + 
1:             "    language java parameter style java deterministic no sql " +
1:             "    external name '" + this.getClass().getName() + ".func'");
1:     }
1: 
1:     /**
1:      * DERBY-6453. Exercise hitherto untested code path in
1:      * InsertResultSet (call to evaluateCheckConstraints from
1:      * preprocessSourceRow used by bulkInsert) and verify IMPORT with
1:      * trigger (which would a priori mandate bulk insert, but is
1:      * changed due to normal inserts due to the presence of a
1:      * trigger).
1:      */
1:     public void testbulkInsert() throws SQLException {
1: 
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1: 
1:         setupForBulkInsert(s, 0);
1: 
1:         assertStatementError(
1:             "23513", s,
1:             "call syscs_util.syscs_import_data( " + 
1:             "    null, " + 
1:             "    'T_BI_1', " + 
1:             "    'A, B', " + 
1:             "    '1, 2', " + 
1:             "    'extin/" + IMPORT_FILE_NAME + "', " + 
1:             "    null, null, null, 0 )");
1: 
1:         setupForBulkInsert(s, 10);
1: 
1:         s.executeUpdate(
1:             "create trigger dagstrigger no cascade before insert on t_bi_1 " +
1:             "    values func() ");
1: 
1:         funcWasCalled = false;
1: 
1:         s.executeUpdate(
1:             "call syscs_util.syscs_import_data( " + 
1:             "    null, " + 
1:             "    'T_BI_1', " + 
1:             "    'A, B', " + 
1:             "    '1, 2', " + 
1:             "    'extin/" + IMPORT_FILE_NAME + "', " + 
1:             "    null, null, null, 0 )");
1: 
1:         assertTrue(funcWasCalled);
1:     }
1: 
1:     static boolean funcWasCalled;
1:     
1:     public static int func()
1:     {
1:         funcWasCalled = true;
1:         return 0;
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9d9f6dd
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that CHECK constraint works if it contains unqualified names and
1:      * the current schema when the constraint is defined is different from the
1:      * schema in which the table lives. Regression test case for DERBY-6362.
1:      */
1:     public void testDerby6362() throws SQLException {
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1:         s.execute("create schema d6362_s1");
1:         s.execute("create schema d6362_s2");
1: 
1:         s.execute("set schema d6362_s1");
1:         s.execute("create function f(x int) returns int deterministic "
1:                 + "language java  parameter style java external name "
1:                 + "'java.lang.Math.abs' no sql");
1:         s.execute("create type typ "
1:                 + "external name 'java.util.ArrayList' language java");
1: 
1:         // Create the table with the constraints in a different schema than
1:         // the current schema. Before DERBY-6362, unqualified names would be
1:         // resolved to the current schema at definition time and to the
1:         // table's schema during execution, which made them behave unreliably
1:         // if the schemas differed.
1:         s.execute("create table d6362_s2.t(x int, "
1:                 + "constraint c001 check(f(x) < 3))");
1:         s.execute("alter table d6362_s2.t "
1:                 + "add constraint c002 check(f(x) >= 0)");
1:         s.execute("alter table d6362_s2.t "
1:                 + "add constraint c003 check(cast(null as typ) is null)");
1: 
1:         // Use a function that lives in the SYSFUN schema.
1:         s.execute("alter table d6362_s2.t add constraint c004 "
1:                 + "check(f(x) > cos(pi()))");
1: 
1:         // ABS is an operator, not a function, so it will not be qualified.
1:         s.execute("alter table d6362_s2.t add constraint c005 "
1:                 + "check(abs(f(x)) < pi())");
1: 
1:         // Add some constraints that reference the table. See that table
1:         // names are qualified. Unqualified column names will not be qualified
1:         // with schema and table.
1:         s.execute("set schema d6362_s2");
1:         s.execute("alter table t add constraint c101 check(x < 3)");
1:         s.execute("alter table t add constraint c102 check(t.x < 4)");
1:         s.execute("alter table t add constraint c103 "
1:                 + "check(x <= d6362_s1.f(t.x))");
1: 
1:         // Add some fully qualified names to see that they still work.
1:         s.execute("alter table t add constraint c201 check(d6362_s2.t.x < 5)");
1:         s.execute("alter table t add constraint c202 check(d6362_s1.f(x) < 5)");
1:         s.execute("alter table t add constraint c203 "
1:                 + "check(cast(null as d6362_s1.typ) is null)");
1: 
1:         // Verify that the constraints were stored with fully qualified names.
1:         String[][] expectedConstraints = {
1:             {"C001", "(\"D6362_S1\".\"F\"(x) < 3)"},
1:             {"C002", "(\"D6362_S1\".\"F\"(x) >= 0)"},
1:             {"C003", "(cast(null as \"D6362_S1\".\"TYP\") is null)"},
1:             {"C004", "(\"D6362_S1\".\"F\"(x) > \"SYSFUN\".\"COS\"(\"SYSFUN\".\"PI\"()))"},
1:             {"C005", "(abs(\"D6362_S1\".\"F\"(x)) < \"SYSFUN\".\"PI\"())"},
1:             {"C101", "(x < 3)"},
1:             {"C102", "(\"D6362_S2\".\"T\".x < 4)"},
1:             {"C103", "(x <= \"D6362_S1\".\"F\"(\"D6362_S2\".\"T\".x))"},
1:             {"C201", "(\"D6362_S2\".\"T\".x < 5)"},
1:             {"C202", "(\"D6362_S1\".\"F\"(x) < 5)"},
1:             {"C203", "(cast(null as \"D6362_S1\".\"TYP\") is null)"},
1:         };
1: 
1:         JDBC.assertFullResultSet(
1:             s.executeQuery(
1:                 "select constraintname, checkdefinition from sys.syschecks "
1:                 + "natural join sys.sysconstraints natural join sys.sysschemas "
1:                 + "where schemaname = 'D6362_S2' and type = 'C' "
1:                 + "order by constraintname"),
1:             expectedConstraints);
1: 
1:         // Verify that constraints can be executed. Used to fail because
1:         // unqualified functions and types were resolved to the table's schema
1:         // instead of the current schema at the time the constraint was defined.
1:         s.execute("insert into t values 1,2");
1:         assertStatementError("23513", s, "insert into t values -10");
1:         assertStatementError("23513", s, "insert into t values 10");
1:     }
commit:fd2f1f7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Statement st = createStatement();
1:         setAutoCommit(false);
/////////////////////////////////////////////////////////////////////////
1:         rollback();
/////////////////////////////////////////////////////////////////////////
1:         rollback();
1:         Statement st = createStatement();
1:         setAutoCommit(false);
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs = st.executeQuery("select * from pos1");
1:         String[] expColNames = {"C1"};
1:         String[][] expRS = {
/////////////////////////////////////////////////////////////////////////
1:         rollback();
/////////////////////////////////////////////////////////////////////////
1:         rollback();
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         rollback();
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         rollback();
1:         Statement st = createStatement();
1:         setAutoCommit(false);
/////////////////////////////////////////////////////////////////////////
1:         Statement st1 = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         Statement st2 = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         Statement st3 = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs = st.executeQuery("select * from t1");
1:         String[] expColNames = {"C1", "C2"};
1:         String[][] expRS = {
/////////////////////////////////////////////////////////////////////////
1:         rollback();
/////////////////////////////////////////////////////////////////////////
1:         rollback();
1:         Statement st = createStatement();
1:         setAutoCommit(false);
/////////////////////////////////////////////////////////////////////////
1:         rollback();
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs = pSt3.executeQuery();
1:         String[] expColNames = {"C1"};
1:         String[][] expRS = {
/////////////////////////////////////////////////////////////////////////
1:         rollback();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement pSt = prepareStatement(
1:         ResultSetMetaData rsmd = rs.getMetaData();
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:         Statement st = createStatement();
1:         setAutoCommit(false);
/////////////////////////////////////////////////////////////////////////
1:         Statement st = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         Statement st = createStatement();
commit:e1fc30c
/////////////////////////////////////////////////////////////////////////
1: 
1:         dropTable("t4282");
commit:583afe5
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertUnorderedResultSet(rs, expRS, true);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:e594ab0
/////////////////////////////////////////////////////////////////////////
1:     // This test verifies that if the PRIMARY KEY constraint mentions a
1:     // column which is potentially large, then Derby will automatically
1:     // choose a large pagesize for the index's conglomerate (DERBY-3947)
1:     //
1:     public void testPrimaryKeyPageSizeDerby3947()
1:         throws SQLException
1:     {
0:         st = createStatement();
1:         st.executeUpdate("create table d3947 (x varchar(1000) primary key)");
1:         char[] chars = new char[994];
1:         PreparedStatement ps = prepareStatement("insert into d3947 values (?)");
1:         ps.setString(1, new String(chars));
1:         ps.executeUpdate();
1:         ps.close();
1:         checkLargePageSize(st, "D3947");
1:         st.executeUpdate("drop table d3947");
1: 
1:         // A second variation is to add the PK constraint using ALTER TABLE;
1:         // A third variation is to add a FK constraint
1:         st.executeUpdate("create table d3947 (x varchar(1000) not null, " +
1:                 " y varchar(1000))");
1:         st.executeUpdate("alter table d3947 add constraint " +
1:                 "constraint1 primary key (x)");
1:         st.executeUpdate("alter table d3947 add constraint " +
1:                 "constraint2 foreign key (y) references d3947(x)");
1:         checkLargePageSize(st, "D3947");
1:         // Ensure we still get the right error message when col doesn't exist:
1:         assertStatementError("42X14", st,
1:                 "alter table d3947 add constraint " +
1:                 "constraint3 foreign key (z) references d3947(x)");
1:         st.executeUpdate("drop table d3947");
1: 
1:         st.close();
1:     }
1:     private void checkLargePageSize(Statement st, String tblName)
1:         throws SQLException
1:     {
1:         ResultSet rs = st.executeQuery(
1:             "select * from TABLE(SYSCS_DIAG.SPACE_TABLE('"+tblName+"')) T");
1:         while (rs.next())
1:         {
1:             if ("1".equals(rs.getString("isindex")))
1:                 assertEquals(32768, rs.getInt("pagesize"));
1:             else
1:                 assertEquals(4096, rs.getInt("pagesize"));
1: 
1:             //System.out.println(rs.getString("conglomeratename") +
1:             //        ","+rs.getString("isindex")+
1:             //        ","+rs.getString("pagesize"));
1:         }
1:         rs.close();
1:     }
commit:37f8861
/////////////////////////////////////////////////////////////////////////
0:         Statement st1 = conn.createStatement();
1:         st1.setCursorName("c1");
1:         ResultSet rs1 = st1.executeQuery(
1:                 "select * from t1 where c2=2 for update of C1");
1:         rs1.next();   
1:         setAutoCommit(false);
1:         // this update should succeed
1:         assertUpdateCount(st,1,
1:                 "update t1 set c1 = c1 where current of \"c1\"");
1:         // this update should fail
1:         assertStatementError("23513", st,
1:             "update t1 set c1 = c1 + 1 where current of \"c1\"");
1:         st1.close();
1:         rs1.close();
0:         Statement st2 = conn.createStatement();
1:         st2.setCursorName("c2");
1:         ResultSet rs2 = st2.executeQuery(
1:                 "select * from t1 where c1 = 2 for update of c2");
1:         rs2.next();   
1:         assertUpdateCount(st,1,
1:                 "update t1 set c2 = c2 where current of \"c2\"");
1:             "update t1 set c2 = c2 + 1 where current of \"c2\"");
1:         st2.close();
1:         rs2.close();
0:         Statement st3 = conn.createStatement();
1:         st3.setCursorName("c3");
1:         ResultSet rs3 = st3.executeQuery(
1:                 "select * from t1 where c1 = 2 for update of c1, c2");
1:         rs3.next();   
1:         setAutoCommit(false);
1:             "update t1 set c2 = c1, c1 = c2 where current of \"c3\"");
1:             "update t1 set c2 = c2 + 1, c1 = c1 + 3 where current of \"c3\"");
1:             "update t1 set c2 = c1 + 3, c1 = c2 + 3 where current of \"c3\"");
1:         st3.close();
1:         rs3.close();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testJira4282() throws SQLException
1:     {
1:         // This test doesnt work properly in the embedded configuration.
1:         // The intent of the test is to expose the DERBY-4282 problem, and
1:         // this test case does do that in the client/server configuration, so
1:         // we only run the test in that configuration. In the embedded
1:         // configuration, the UPDATE statement unexpectedly gets a 
1:         // "no current row" exception.
1:         //
1:         if (usingEmbedded())
1:             return;
1: 
0:         st = createStatement();
1: 
1:         st.executeUpdate(
1:             "create table t4282(c1 int, c2 int, constraint ck1 "
1:             + "check(c1 = c2), constraint ck2 check(c2=c1))");
1: 
1:         st.executeUpdate("insert into t4282 values (1,1),(2,2),(3,3),(4,4)");
1: 
1:         Statement st1 = createStatement();
1:         st1.setCursorName("c1");
1:         ResultSet rs = st1.executeQuery("select * from t4282 for update");
1:         assertTrue("Failed to retrieve row for update", rs.next());
1:         // DERBY-4282 causes the next statement to fail with:
1:         //
1:         // Column 'C2' is either not in any table in the FROM list or
1:         // appears within a join specification and is outside the scope
1:         // of the join specification or appears in a HAVING clause and
1:         // is not in the GROUP BY list. If this is a CREATE or ALTER TABLE
1:         // statement then 'C2' is not a column in the target table. 
1:         st.executeUpdate("update t4282 set c1 = c1 where current of \"c1\"");
1: 
1:         // If we get here, all is well, and DERBY-4282 did not occur.
1:         st1.close();
1:         st.close();
1:     }
1: }
commit:dc56246
/////////////////////////////////////////////////////////////////////////
1: 
1: /*
1: Derby - Class org.apache.derbyTesting.functionTests.tests.lang.CheckConstraintTest
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1: http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import java.sql.ResultSetMetaData;
0: import java.sql.Statement;
0: import java.sql.CallableStatement;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
0: import java.sql.SQLWarning;
0: import java.sql.Connection;
1: 
1: 
1: import java.sql.SQLException;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: public final class CheckConstraintTest extends BaseJDBCTestCase {
1: 
1:     /**
1:      * Public constructor required for running test as standalone JUnit.
1:      */
1:     public CheckConstraintTest(String name)
1:     {
1:         super(name);
1:     }
1: 
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite("checkConstraint Test");
1:         suite.addTest(TestConfiguration.defaultSuite(CheckConstraintTest.class));
0:         return suite;
1:     }
1:     
0:         ResultSet rs = null;
0:         ResultSetMetaData rsmd;
0:         SQLWarning sqlWarn = null;
1: 
0:         PreparedStatement pSt;
0:         CallableStatement cSt;
0:         Statement st;
1: 
0:         String [][] expRS;
0:         String [] expColNames;
0:         Connection conn;
1: 
1:     public void testNotAllowedInCheckConstraints() throws Exception
1:     {
1:         
0:         st = createStatement();
0:         conn=getConnection();       
0:         conn.setAutoCommit(false);
1:         
1:         // negative The following are not allowed in check 
1:         // constraints:	?, subquery, datetime functions
1:         
1:         assertStatementError("42Y39", st,
1:             "create table neg1(c1 int check(?))");
1:         
1:         assertStatementError("42Y39", st,
1:             " create table neg1(c1 int check(c1 in (select c1 "
1:             + "from neg1)))");
1:         
1:         assertStatementError("42Y39", st,
1:             " create table neg1(c1 int check(CURRENT_DATE = "
1:             + "CURRENT_DATE))");
1:         
1:         assertStatementError("42Y39", st,
1:             " create table neg1(c1 int check(CURRENT_TIME = "
1:             + "CURRENT_TIME))");
1:         
1:         assertStatementError("42Y39", st,
1:             " create table neg1(c1 int check(CURRENT_TIMESTAMP = "
1:             + "CURRENT_TIMESTAMP))");
1:         
1:         // The check constraint definition must evaluate to a boolean
1:         
1:         assertStatementError("42X19", st,
1:             "create table neg1(c1 int check(c1))");
1:         
1:         assertStatementError("42X19", st,
1:             " create table neg1(c1 int check(1))");
1:         
1:         assertStatementError("42X19", st,
1:             " create table neg1(c1 int check(c1+c1))");
1:         
1:         // All column references are to target table
1:         
1:         assertStatementError("42X04", st,
1:             "create table neg1(c1 int check((c2 = 1)))");
1:         
1:         // verify that a check constraint can't be used as an 
1:         // optimizer override
1:         
1:         st.executeUpdate(
1:             "create table t1(c1 int constraint asdf check(c1 = 1))");
1:         
1:         assertStatementError("42Y48", st,
1:             " select * from t1 --derby-properties constraint = asdf ");
1:         
1:         // alter table t1 drop constraint asdf
1:         
0:         conn.rollback();
1:         
1:         // alter table t1 drop constraint asdf forward references 
1:         // should fail
1:         
1:         assertStatementError("42621", st,
1:             "create table neg1(c1 int check(c2 = 1), c2 int)");
1:         
1:         assertStatementError("42621", st,
1:             " create table neg2(c1 int constraint asdf check(c2 "
1:             + "= 1), c2 int)");
1:         
0:         conn.rollback();
1:     }
1:     public void testCheckConstraints() throws SQLException{
1:         
0:         st = createStatement();
0:         conn=getConnection();       
0:         conn.setAutoCommit(false);
1:         
1:         // positive multiple check constraints on same table
1:         
1:         st.executeUpdate(
1:             "create table pos1(c1 int check(c1 > 0), constraint "
1:             + "asdf check(c1 < 10))");
1:         
1:         // verify both constraints are enforced
1:         
1:         assertStatementError("23513", st,
1:             "insert into pos1 values 0");
1:         
1:         st.executeUpdate(
1:             " insert into pos1 values 1");
1:         
1:         st.executeUpdate(
1:             " insert into pos1 values 9");
1:         
1:         assertStatementError("23513", st,
1:             " insert into pos1 values 10");
1:         
1:         rs = st.executeQuery(
1:             " select * from pos1");
1:         
1:         expColNames = new String [] {"C1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1"},
1:             {"9"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // verify constraint violation rolls back entire statement
1:         
1:         assertStatementError("23513", st,
1:             "update pos1 set c1 = c1 + 1");
1:         
1:         rs = st.executeQuery(
1:             " select * from pos1");
1:         
1:         expColNames = new String [] {"C1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1"},
1:             {"9"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         assertStatementError("23513", st,
1:             " update pos1 set c1 = c1 - 1");
1:         
1:         rs = st.executeQuery(
1:             " select * from pos1");
1:         
1:         expColNames = new String [] {"C1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1"},
1:             {"9"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
0:         conn.rollback();
1:         
1:         // conflicting constraints, should fail
1:         
1:         st.executeUpdate(
1:             "create table negcks(c1 int constraint ck1st "
1:             + "check(c1 > 4), c2 int constraint ck2nd check(c2 > "
1:             + "2), c3 int, constraint ckLast check(c2 > c1))");
1:         
1:         // constraint ck1st fails
1:         
1:         assertStatementError("23513", st,
1:             "insert into negcks values (1, 3, 3)");
1:         
1:         // constraint ckLast fails (ck2nd fails too)
1:         
1:         assertStatementError("23513", st,
1:             "insert into negcks values (5, 1, 3)");
1:         
1:         // constraint ck1st fails (ckLast fails too)
1:         
1:         assertStatementError("23513", st,
1:             "insert into negcks values (2, 3, 3)");
1:         
0:         conn.rollback();
1:         
1:         // same source and target tables
1:         
1:         st.executeUpdate(
1:             "create table pos1(c1 int, c2 int, constraint ck1 "
1:             + "check (c1 < c2))");
1:         
1:         st.executeUpdate(
1:             " insert into pos1 values (1, 2), (2, 3), (3, 4)");
1:         
0:         conn.commit();
1:         // these should work
1:         
1:         st.executeUpdate(
1:             "insert into pos1 select * from pos1");
1:         
1:         rs = st.executeQuery(
1:             " select count(*) from pos1");
1:         
1:         expColNames = new String [] {"1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"6"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         assertUpdateCount(st, 6,
1:             " update pos1 set c2 = (select max(c1) from pos1), "
1:             + "c1 = (select min(c2) from pos1)");
1:         
1:         rs = st.executeQuery(
1:             " select * from pos1");
1:         
1:         expColNames = new String [] {"C1", "C2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"2", "3"},
1:             {"2", "3"},
1:             {"2", "3"},
1:             {"2", "3"},
1:             {"2", "3"},
1:             {"2", "3"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
0:         conn.rollback();
1:         
1:         // these should fail
1:         
1:         assertStatementError("23513", st,
1:             "insert into pos1 select c2, c1 from pos1");
1:         
1:         rs = st.executeQuery(
1:             " select count(*) from pos1");
1:         
1:         expColNames = new String [] {"1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"3"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         assertStatementError("23513", st,
1:             " update pos1 set c2 = (select min(c1) from pos1), "
1:             + "c1 = (select max(c2) from pos1)");
1:         
1:         rs = st.executeQuery(
1:             " select * from pos1");
1:         
1:         expColNames = new String [] {"C1", "C2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "2"},
1:             {"2", "3"},
1:             {"3", "4"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         st.executeUpdate(
1:             " drop table pos1");
1:         
0:         conn.commit();
1:         // union under insert
1:         
1:         st.executeUpdate(
1:             "create table t1(c1 int, c2 int, constraint ck1 "
1:             + "check(c1 = c2))");
1:         
1:         assertStatementError("23513", st,
1:             " insert into t1 values (1, 1), (2, 1)");
1:         
1:         rs = st.executeQuery(
1:             " select * from t1");
1:         
1:         expColNames = new String [] {"C1", "C2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         JDBC.assertDrainResults(rs, 0);
1:         
1:         // normalize result set under insert/update
1:         
1:         st.executeUpdate(
1:             "insert into t1 values (1.0, 1)");
1:         
1:         assertStatementError("23513", st,
1:             " insert into t1 values (2.0, 1)");
1:         
1:         rs = st.executeQuery(
1:             " select * from t1");
1:         
1:         expColNames = new String [] {"C1", "C2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "1"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         assertUpdateCount(st, 1,
1:             " update t1 set c2 = 1.0");
1:         
1:         assertStatementError("23513", st,
1:             " update t1 set c2 = 2.0");
1:         
1:         rs = st.executeQuery(
1:             " select * from t1");
1:         
1:         expColNames = new String [] {"C1", "C2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "1"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         assertUpdateCount(st, 1,
1:             " update t1 set c1 = 3.0, c2 = 3.0");
1:         
1:         rs = st.executeQuery(
1:             " select * from t1");
1:         
1:         expColNames = new String [] {"C1", "C2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"3", "3"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
0:         conn.rollback();
1:     }
1:     
1:     public void testPositionalUpdate() throws SQLException{
1:         
0:         st = createStatement();
0:         conn=getConnection();       
0:         conn.setAutoCommit(false);
1:         
1:         // positioned update
1:         
1:         st.executeUpdate(
1:             "create table t1(c1 int, c2 int, constraint ck1 "
1:             + "check(c1 = c2), constraint ck2 check(c2=c1))");
1:         
1:         st.executeUpdate(
1:             " insert into t1 values (1, 1), (2, 2), (3, 3), (4, 4)");
1:         
1:         st.executeUpdate(
1:             " create index i1 on t1(c1)");
1:         
0:         /* DERBY-4282  after fixing the issue DERBY-4282 this commented
0:          * part can be uncomment
1:            
0:         PreparedStatement ps_c1 = prepareStatement(
0:             "select * from t1 where c2 = 2 for update of c1");
1:         
0:         ResultSet c1 = ps_c1.executeQuery();
1:         
0:         //c1.next();  
1:         
0:         expRS=new String[][]{
0:             {"2","2"}
1:         };
0:         JDBC.assertFullResultSet(c1, expRS);
1: 
1:         setAutoCommit(false);
1:         // this update should succeed
1:              
1:         assertUpdateCount(st, 1,  
0:             "update t1 set c1 = c1 where current of c1");
0:         //setAutoCommit(true);        
1:         // this update should fail
1:         
1:         assertStatementError("23513", st,
0:             "update t1 set c1 = c1 + 1 where current of c1");
1:         
0:         c1.close();
0:         ps_c1.close();
1:         
0:         PreparedStatement ps_c2 = prepareStatement(
0:             "select * from t1 where c1 = 2 for update of c2");
1:         
0:         ResultSet c2 = ps_c2.executeQuery();
1:         
0:         c2.next(); 
1:         
0:         expRS=new String[][]{
0:             {"2","2"}
1:         };
0:         JDBC.assertFullResultSet(c2, expRS);
1: 
1:         
1:         // this update should succeed
1:         
1:         assertUpdateCount(st, 1,
0:             "update t1 set c2 = c2 where current of c2");
1:         
1:         // this update should fail
1:         
1:         assertStatementError("23513", st,
0:             "update t1 set c2 = c2 + 1 where current of c2");
1:         
0:         c2.close();
0:         ps_c2.close();
1:         
0:         PreparedStatement ps_c3 = prepareStatement(
0:             "select * from t1 where c1 = 2 for update of c1, c2");
1:         
0:         ResultSet c3 = ps_c3.executeQuery();
1:         
0:         c3.next(); 
1:         
0:         expRS=new String[][]{
0:             {"2","2"}
1:         };
0:         JDBC.assertFullResultSet(c3, expRS);
1: 
1:         
1:         // this update should succeed
1:         
1:         assertUpdateCount(st, 1,
0:             "update t1 set c2 = c1, c1 = c2 where current of c3");
1:         
1:         // this update should fail
1:         
1:         assertStatementError("23513", st,
0:             "update t1 set c2 = c2 + 1, c1 = c1 + 3 where current of c3");
1:         
1:         // this update should succeed
1:         
1:         assertUpdateCount(st, 1,
0:             "update t1 set c2 = c1 + 3, c1 = c2 + 3 where current of c3");
1:         
1:         rs = st.executeQuery(
1:             " select * from t1");
1:         
1:         expColNames = new String [] {"C1", "C2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "1"},
1:             {"5", "5"},
1:             {"3", "3"},
1:             {"4", "4"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
0:         c3.close();
0:         ps_c3.close();
1: */       
0:         conn.rollback();
1:         
1:         // complex expressions
1:         
1:         st.executeUpdate(
1:             "create table t1(c1 int check((c1 + c1) = (c1 * c1) "
1:             + "or (c1 + c1)/2 = (c1 * c1)), c2 int)");
1:         
1:         // this insert should succeed
1:         
1:         st.executeUpdate(
1:             "insert into t1 values (1, 9), (2, 10)");
1:         
1:         // these updates should succeed
1:         
1:         assertUpdateCount(st, 2,
1:             "update t1 set c2 = c2 * c2");
1:         
1:         assertUpdateCount(st, 1,
1:             " update t1 set c1 = 2 where c1 = 1");
1:         
1:         assertUpdateCount(st, 2,
1:             " update t1 set c1 = 1 where c1 = 2");
1:         
1:         // this update should fail
1:         
1:         assertStatementError("23513", st,
1:             "update t1 set c1 = c2");
1:         
1:         rs = st.executeQuery(
1:             " select * from t1");
1:         
1:         expColNames = new String [] {"C1", "C2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "81"},
1:             {"1", "100"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
0:         conn.rollback();
1:     }
1:     
1:     public void testBuiltInFunctions() throws SQLException{
1:         
0:         st = createStatement();
0:         conn=getConnection();       
0:         conn.setAutoCommit(false);
1:         
1:         // built-in functions in a check constraint
1:         
1:         st.executeUpdate(
1:             "create table charTab (c1 char(4) check(CHAR(c1) = c1))");
1:         
1:         st.executeUpdate(
1:             " insert into charTab values 'asdf'");
1:         
1:         st.executeUpdate(
1:             " insert into charTab values 'fdsa'");
1:         
1:         // beetle 5805 - support built-in function INT should fail 
1:         // until beetle 5805 is implemented
1:         
1:         st.executeUpdate(
1:             "create table intTab (c1 int check(INT(1) = c1))");
1:         
1:         st.executeUpdate(
1:             " insert into intTab values 1");
1:         
1:         // this insert should fail, does not satisfy check constraint
1:         
1:         assertStatementError("23513", st,
1:             "insert into intTab values 2");
1:         
1:         st.executeUpdate(
1:             " create table maxIntTab (c1 int check(INT(2147483647) > c1))");
1:         
1:         st.executeUpdate(
1:             " insert into maxIntTab values 1");
1:         
1:         // this insert should fail, does not satisfy check constraint
1:         
1:         assertStatementError("23513", st,
1:             "insert into maxIntTab values 2147483647");
1:         
0:         conn.rollback();
1:         
1:         // verify that inserts, updates and statements with forced 
1:         // constraints are indeed dependent on the constraints
1:         
1:         st.executeUpdate(
1:             "create table t1(c1 int not null constraint asdf primary key)");
1:         
1:         st.executeUpdate(
1:             " insert into t1 values 1, 2, 3, 4, 5");
1:         
0:         conn.commit();
1:         
1:         PreparedStatement pSt1 = prepareStatement(
1:             "insert into t1 values 1");
1:         
1:         PreparedStatement pSt2 = prepareStatement(
1:             "update t1 set c1 = 3 where c1 = 4");
1:         
1:         PreparedStatement pSt3 = prepareStatement(
1:             "select * from t1");
1:         
1:         // the insert and update should fail, select should succeed
1:         
1:         assertStatementError("23505", pSt1);
1:         
1:         assertStatementError("23505", pSt2);
1: 
1:         
1:         rs = pSt3.executeQuery();
1:         
1:         expColNames = new String [] {"C1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1"},
1:             {"2"},
1:             {"3"},
1:             {"4"},
1:             {"5"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         st.executeUpdate(
1:             " alter table t1 drop constraint asdf");
1:         
1:         // rollback and verify that constraints are enforced and 
1:         // select succeeds
1:         
0:         conn.rollback();
1:         
1:         assertStatementError("23505", pSt1);
1:         
1:         assertStatementError("23505", pSt2);
1:         
1:         rs = pSt3.executeQuery();
1:         expColNames = new String [] {"C1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1"},
1:             {"2"},
1:             {"3"},
1:             {"4"},
1:             {"5"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         
1:         
1:         
1:         st.executeUpdate(
1:             " drop table t1");
1:         
1:         // check constraints with parameters
1:         
1:         st.executeUpdate(
1:             "create table t1(c1 int constraint asdf check(c1 = 1))");
1:         
0:         pSt = prepareStatement(
1:             "insert into t1 values (?)");
1:         
1:         rs = st.executeQuery(
1:             "values (1)");
1:         
1:         rs.next();
0:         rsmd = rs.getMetaData();
1:         for (int i = 1; i <= rsmd.getColumnCount(); i++)
1:             pSt.setObject(i, rs.getObject(i));
1:         
1:         assertUpdateCount(pSt, 1);
1:         
1:         // clean up
1:         
1:         st.executeUpdate(
1:             "drop table t1");
1:         
1:         st.executeUpdate(
1:             " create table t1(active_flag char(2) "
1:             + "check(active_flag IN ('Y', 'N')), "
1:             + "araccount_active_flag char(2) "
1:             + "check(araccount_active_flag IN ('Y', 'N')), "
1:             + "automatic_refill_flag char(2) "
1:             + "check(automatic_refill_flag IN ('Y', 'N')), "
1:             + "call_when_ready_flag char(2) "
1:             + "check(call_when_ready_flag IN ('Y', 'N')), "
1:             + "compliance_flag char(2) check(compliance_flag IN "
1:             + "('Y', 'N')), delivery_flag char(2) "
1:             + "check(delivery_flag IN ('Y', 'N')), "
1:             + "double_count_flag char(2) check(double_count_flag "
1:             + "IN ('Y', 'N')), gender_ind char(2) check(gender_ind "
1:             + "IN ('M', 'F', 'U')), geriatric_flag char(2) "
1:             + "check(geriatric_flag IN ('Y', 'N')), "
1:             + "refuse_inquiry_flag char(2) "
1:             + "check(refuse_inquiry_flag IN ('Y', 'N')), "
1:             + "animal_flag char(2) check(animal_flag IN ('Y', "
1:             + "'N')), terminal_flag char(2) check(terminal_flag IN "
1:             + "('Y', 'N')), unit_flag char(2) check(unit_flag IN "
1:             + "('Y', 'N')), VIP_flag char(2) check(VIP_flag IN "
1:             + "('Y', 'N')), snap_cap_flag char(2) "
1:             + "check(snap_cap_flag IN ('Y', 'N')), "
1:             + "consent_on_file_flag char(2) "
1:             + "check(consent_on_file_flag IN ('Y', 'N')), "
1:             + "enlarged_SIG_flag char(2) check(enlarged_SIG_flag "
1:             + "IN ('Y', 'N')),aquired_patient_flag char(2) "
1:             + "check(aquired_patient_flag IN ('Y', 'N')))");
1:         
1:         // bug 5622 - internal generated constraint names are 
1:         // re-worked to match db2's naming convention.
1:         
1:         st.executeUpdate(
1:             "drop table t1");
1:         
1:         st.executeUpdate(
1:             " create table t1 (c1 int not null primary key, c2 "
1:             + "int not null unique, c3 int check (c3>=0))");
1:         
1:         st.executeUpdate(
1:             " alter table t1 add column c4 int not null default 1");
1:         
1:         st.executeUpdate(
1:             " alter table t1 add constraint c4_unique UNIQUE(c4)");
1:         
1:         st.executeUpdate(
1:             " alter table t1 add column c5 int check(c5 >= 0)");
1:         
1:         rs = st.executeQuery(
1:             " select  c.type from "
1:             + "sys.sysconstraints c, sys.systables t where "
1:             + "c.tableid = t.tableid and tablename='T1'");
1:         
1:         expColNames = new String [] {"TYPE"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"P"},
1:             {"U"},
1:             {"C"},
1:             {"U"},
1:             {"C"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         assertStatementError("42Y55", st,
1:             " drop table t2");
1:         
1:         st.executeUpdate(
1:             " create table t2 (c21 int references t1)");
1:         
1:         rs = st.executeQuery(
1:             " select c.type from "
1:             + "sys.sysconstraints c, sys.systables t where "
1:             + "c.tableid = t.tableid and tablename='T2'");
1:         
1:         expColNames = new String [] {"TYPE"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"F"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         assertStatementError("42Y55", st,
1:             " drop table t3");
1:         
1:         st.executeUpdate(
1:             " create table t3 (c1 int check (c1 >= 0), c2 int "
1:             + "check (c2 >= 0), c3 int check (c3 >= 0), c4 int "
1:             + "check (c4 >= 0), c5 int check (c5 >= 0), c6 int "
1:             + "check (c6 >= 0), c7 int check (c7 >= 0), c8 int "
1:             + "check (c8 >= 0), c9 int check (c9 >= 0), c10 int "
1:             + "check (c10 >= 0), c11 int check (c11 >= 0), c12 int "
1:             + "check (c12 >= 0), c13 int check (c13 >= 0))");
1:         
1:         rs = st.executeQuery(
1:             " select c.type from "
1:             + "sys.sysconstraints c, sys.systables t where "
1:             + "c.tableid = t.tableid and tablename='T3'");
1:         
1:         expColNames = new String [] {"TYPE"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"C"},
1:             {"C"},
1:             {"C"},
1:             {"C"},
1:             {"C"},
1:             {"C"},
1:             {"C"},
1:             {"C"},
1:             {"C"},
1:             {"C"},
1:             {"C"},
1:             {"C"},
1:             {"C"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         assertStatementError("42Y55", st,
1:             " drop table t4");
1:         
1:         st.executeUpdate(
1:             " create table t4(c11 int not null, c12 int not "
1:             + "null, primary key (c11, c12))");
1:         
1:         rs = st.executeQuery(
1:             " select c.type from "
1:             + "sys.sysconstraints c, sys.systables t where "
1:             + "c.tableid = t.tableid and tablename='T4'");
1:         
1:         expColNames = new String [] {"TYPE"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"P"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // DERBY-2989
1:     }
1:     public void testJira2989() throws SQLException{
1:         
0:         st = createStatement();
0:         conn=getConnection();       
0:         conn.setAutoCommit(false);
1:         
1:         st.executeUpdate(
1:             "CREATE TABLE \"indicator\" (c CHAR(1) DEFAULT 'N')");
1:         
1:         st.executeUpdate(
1:             " ALTER TABLE  \"indicator\" ADD CONSTRAINT "
1:             + "my_constraint CHECK ((c IN ('Y','N')))");
1:         
1:         st.executeUpdate(
1:             " INSERT INTO  \"indicator\" VALUES ('N')");
1:         
1:         st.executeUpdate(
1:             " ALTER TABLE  \"indicator\" DROP CONSTRAINT my_constraint");
1:         
1:         st.executeUpdate(
1:             " DROP TABLE   \"indicator\"");
1:              
1:         getConnection().rollback();
1:         st.close();
1:     }
1: }
author:Ole Solberg
-------------------------------------------------------------------------------
commit:3b91e3b
/////////////////////////////////////////////////////////////////////////
1:         // Cleanup:
1:         st.executeUpdate("drop table t4");
1:         st.executeUpdate("drop table t3");
1:         st.executeUpdate("drop table t2");
1:         st.executeUpdate("drop table t1");
0:         conn.commit();
0:         
============================================================================