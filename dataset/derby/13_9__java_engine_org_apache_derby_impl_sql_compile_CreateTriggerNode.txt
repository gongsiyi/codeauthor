1:a6f9586: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.CreateTriggerNode
1:a6f9586: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
1:1198ab7:  */
1:7952562: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
64:eac0369: 
1:d9878ca: import java.util.ArrayList;
1:ccb1894: import java.util.Comparator;
1:234a2b6: import java.util.HashSet;
1:c0a807c: import java.util.List;
1:0cefeda: import java.util.SortedSet;
1:0cefeda: import java.util.TreeSet;
1:4fb136d: import org.apache.derby.catalog.UUID;
1:4fb136d: import org.apache.derby.iapi.error.StandardException;
1:4fb136d: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:4fb136d: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:d9878ca: import org.apache.derby.iapi.sql.compile.Visitable;
1:69f8afa: import org.apache.derby.iapi.sql.compile.Visitor;
1:4fb136d: import org.apache.derby.iapi.sql.conn.Authorizer;
1:4fb136d: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:cc67949: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:cc67949: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1:cc67949: import org.apache.derby.iapi.sql.depend.ProviderList;
1:4fb136d: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:e735448: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1:4fb136d: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:4fb136d: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:4fb136d: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:4fb136d: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
1:4fb136d: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:4fb136d: 
2:eac0369: /**
1:eac0369:  * A CreateTriggerNode is the root of a QueryTree 
1:eac0369:  * that represents a CREATE TRIGGER
1:eac0369:  * statement.
3:eac0369:  *
19:eac0369:  */
1:eac0369: 
1:3bb140c: class CreateTriggerNode extends DDLStatementNode
1:a6f9586: {
1:eac0369: 	private	TableName			triggerName;
1:eac0369: 	private	TableName			tableName;
1:eac0369: 	private	int					triggerEventMask;
1:eac0369: 	private ResultColumnList	triggerCols;
1:eac0369: 	private	boolean				isBefore;
1:eac0369: 	private	boolean				isRow;
1:eac0369: 	private	boolean				isEnabled;
1:3bb140c:     private List<TriggerReferencingStruct> refClause;
1:8a93440: 	private	ValueNode		    whenClause;
1:eac0369: 	private	String				whenText;
1:eac0369: 	private	StatementNode		actionNode;
1:eac0369: 	private	String				actionText;
1:0cefeda:     private String              originalWhenText;
1:0cefeda:     private String              originalActionText;
1:cc67949:     private ProviderInfo[]      providerInfo;
1:0b63f40: 
1:eac0369: 	private SchemaDescriptor	triggerSchemaDescriptor;
1:eac0369: 	private SchemaDescriptor	compSchemaDescriptor;
1:a6f9586: 	
1:0b63f40: 	/*
1:a6f9586: 	 * The following arrary will include columns that will cause the trigger to
1:a6f9586: 	 * fire. This information will get saved in SYSTRIGGERS.
1:a6f9586: 	 * 
1:a6f9586: 	 * The array will be null for all kinds of insert and delete triggers but
1:a6f9586: 	 * it will be non-null for a subset of update triggers.
1:a6f9586: 	 *  
1:a6f9586: 	 * For update triggers, the array will be null if no column list is 
1:a6f9586: 	 * supplied in the CREATE TRIGGER trigger column clause as shown below.
1:a6f9586: 	 * The UPDATE trigger below will fire no matter which column in table1
1:a6f9586: 	 * gets updated.
1:a6f9586: 	 * eg
1:a6f9586: 	 * CREATE TRIGGER tr1 AFTER UPDATE ON table1 
1:a6f9586: 	 *    REFERENCING OLD AS oldt NEW AS newt
1:a6f9586: 	 *    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
1:a6f9586: 	 * 
1:a6f9586: 	 * For update triggers, this array will be non-null if specific trigger
1:a6f9586: 	 * column(s) has been specified in the CREATE TRIGGER sql. The UPDATE
1:a6f9586: 	 * trigger below will fire when an update happens on column c12 in table1.
1:a6f9586: 	 * eg
1:a6f9586: 	 * CREATE TRIGGER tr1 AFTER UPDATE OF c12 ON table1 
1:a6f9586: 	 *    REFERENCING OLD AS oldt NEW AS newt
1:a6f9586: 	 *    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
1:a6f9586: 	 * 
1:a6f9586: 	 * Array referencedColInts along with referencedColsInTriggerAction will 
1:a6f9586: 	 * be used to determine which columns from the triggering table need to 
1:a6f9586: 	 * be read in when the trigger fires, thus making sure that we do not
1:a6f9586: 	 * read the columns from the trigger table that are not required for
1:a6f9586: 	 * trigger execution.
1:a6f9586: 	 */
1:eac0369: 	private int[]				referencedColInts;
1:a6f9586: 	
1:a6f9586: 	/*
1:a6f9586: 	 * The following array (which was added as part of DERBY-1482) will 
1:a6f9586: 	 * include columns referenced in the trigger action through the 
1:a6f9586: 	 * REFERENCING clause(old/new transition variables), in other trigger
1:a6f9586: 	 * action columns. This information will get saved in SYSTRIGGERS
1:a6f9586: 	 * (with the exception of triggers created in pre-10.7 dbs. For 
1:a6f9586: 	 * pre-10.7 dbs, this information will not get saved in SYSTRIGGERS
1:a6f9586: 	 * in order to maintain backward compatibility.
1:a6f9586: 	 * 
1:a6f9586: 	 * Unlike referencedColInts, this array can be non-null for all 3 types
1:a6f9586: 	 * of triggers, namely, INSERT, UPDATE AND DELETE triggers. This array
1:a6f9586: 	 * will be null if no columns in the trigger action are referencing
1:a6f9586: 	 * old/new transition variables
1:a6f9586: 	 * 
1:a6f9586: 	 * eg of a trigger in 10.7 and higher dbs which will cause 
1:a6f9586: 	 * referencedColsInTriggerAction to be null
1:a6f9586: 	 * CREATE TRIGGER tr1 NO CASCADE BEFORE UPDATE of c12 ON table1
1:a6f9586: 	 *    SELECT c24 FROM table2 WHERE table2.c21 = 1
1:a6f9586: 	 * 
1:a6f9586: 	 * eg of a trigger in 10.7 and higher dbs which will cause 
1:a6f9586: 	 * referencedColsInTriggerAction to be non-null
1:a6f9586: 	 * For the trigger below, old value of column c14 from trigger table is
1:a6f9586: 	 * used in the trigger action through old/new transition variables. A
1:a6f9586: 	 * note of this requirement to read c14 will be made in
1:a6f9586: 	 * referencedColsInTriggerAction array.
1:a6f9586: 	 * eg
1:a6f9586: 	 * CREATE TRIGGER tr1 AFTER UPDATE ON table1 
1:a6f9586: 	 *    REFERENCING OLD AS oldt NEW AS newt
1:a6f9586: 	 *    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
1:a6f9586: 	 * 
1:a6f9586: 	 * The exception to the rules above for trigger action columns information
1:a6f9586: 	 * in referencedColsInTriggerAction is a trigger that was created with
1:a6f9586: 	 * pre-10.7 release. Prior to 10.7, we did not collect any information
1:a6f9586: 	 * about trigger action columns. So, any of the 2 kinds of trigger shown
1:a6f9586: 	 * above prior to 10.7 will not have any trigger action column info on
1:a6f9586: 	 * them in SYSTRIGGERS table. In order to cover the pre-existing pre-10.7
1:a6f9586: 	 * triggers and all the other kinds of triggers, we will follow following
1:a6f9586: 	 * 4 rules during trigger execution.
1:a6f9586: 	 *   Rule1)If trigger column information is null, then read all the
1:a6f9586: 	 *   columns from trigger table into memory irrespective of whether
1:a6f9586: 	 *   there is any trigger action column information. 2 egs of such
1:a6f9586: 	 *   triggers
1:a6f9586: 	 *      create trigger tr1 after update on t1 for each row values(1);
1:a6f9586: 	 *      create trigger tr1 after update on t1 referencing old as oldt
1:a6f9586: 	 *      	for each row insert into t2 values(2,oldt.j,-2);
1:a6f9586: 	 *   Rule2)If trigger column information is available but no trigger
1:a6f9586: 	 *   action column information is found and no REFERENCES clause is
1:a6f9586: 	 *   used for the trigger, then only read the columns identified by
1:a6f9586: 	 *   the trigger column. eg
1:a6f9586: 	 *      create trigger tr1 after update of c1 on t1 
1:a6f9586: 	 *      	for each row values(1);
1:a6f9586: 	 *   Rule3)If trigger column information and trigger action column
1:a6f9586: 	 *   information both are not null, then only those columns will be
1:a6f9586: 	 *   read into memory. This is possible only for triggers created in
1:a6f9586: 	 *   release 10.7 or higher. Because prior to that we did not collect
1:a6f9586: 	 *   trigger action column informatoin. eg
1:a6f9586: 	 *      create trigger tr1 after update of c1 on t1
1:a6f9586: 	 *      	referencing old as oldt for each row
1:a6f9586: 	 *      	insert into t2 values(2,oldt.j,-2);
1:a6f9586: 	 *   Rule4)If trigger column information is available but no trigger
1:a6f9586: 	 *   action column information is found but REFERENCES clause is used
1:a6f9586: 	 *   for the trigger, then read all the columns from the trigger
1:a6f9586: 	 *   table. This will cover soft-upgrade and hard-upgrade scenario
1:a6f9586: 	 *   for triggers created pre-10.7. This rule prevents us from having
1:a6f9586: 	 *   special logic for soft-upgrade. Additionally, this logic makes
1:a6f9586: 	 *   invalidation of existing triggers unnecessary during
1:a6f9586: 	 *   hard-upgrade. The pre-10.7 created triggers will work just fine
1:a6f9586: 	 *   even though for some triggers, they would have trigger action
1:a6f9586: 	 *   columns missing from SYSTRIGGERS. A user can choose to drop and
1:a6f9586: 	 *   recreate such triggers to take advantage of Rule 3 which will
1:a6f9586: 	 *   avoid unnecessary column reads during trigger execution.
1:a6f9586: 	 *   eg trigger created prior to 10.7
1:a6f9586: 	 *      create trigger tr1 after update of c1 on t1
1:a6f9586: 	 *      	referencing old as oldt for each row
1:a6f9586: 	 *      	insert into t2 values(2,oldt.j,-2);
1:a6f9586: 	 *   To reiterate, Rule4) is there to cover triggers created with
1:a6f9586: 	 *   pre-10,7 releases but now that database has been
1:a6f9586: 	 *   hard/soft-upgraded to 10.7 or higher version. Prior to 10.7,
1:a6f9586: 	 *   we did not collect any information about trigger action columns.
1:a6f9586: 	 *   
1:a6f9586: 	 *   The only place we will need special code for soft-upgrade is during
1:a6f9586: 	 *   trigger creation. If we are in soft-upgrade mode, we want to make sure
1:a6f9586: 	 *   that we do not save information about trigger action columns in
1:a6f9586: 	 *   SYSTRIGGERS because the releases prior to 10.7 do not understand
1:a6f9586: 	 *   trigger action column information.
1:a6f9586: 	 *   
1:a6f9586: 	 * Array referencedColInts along with referencedColsInTriggerAction will 
1:a6f9586: 	 * be used to determine which columns from the triggering table needs to 
1:a6f9586: 	 * be read in when the trigger fires, thus making sure that we do not
1:a6f9586: 	 * read the columns from the trigger table that are not required for
1:a6f9586: 	 * trigger execution.
1:a6f9586: 	 */
1:a6f9586: 	private int[]				referencedColsInTriggerAction;
1:eac0369: 	private TableDescriptor		triggerTableDescriptor;
1:a6f9586: 
1:a6f9586: 	/*
1:eac0369: 	** Names of old and new table.  By default we have
1:eac0369: 	** OLD/old and NEW/new.  The casing is dependent on 
1:eac0369: 	** the language connection context casing as the rest
1:eac0369:     ** of other code. Therefore we will set the value of the 
1:eac0369:     ** String at the init() time.
1:eac0369:     ** However, if there is a referencing clause
1:eac0369: 	** we will reset these values to be whatever the user
1:eac0369: 	** wants.
1:a6f9586: 	*/
1:eac0369: 	private String oldTableName;
1:eac0369: 	private String newTableName;
1:1198ab7: 
1:eac0369: 	private boolean oldTableInReferencingClause;
1:eac0369: 	private boolean newTableInReferencingClause;
1:1198ab7: 
1:0cefeda:     /**
1:0cefeda:      * <p>
1:0cefeda:      * A list that describes how the original SQL text of the trigger action
1:0cefeda:      * statement was modified when transition tables and transition variables
1:0cefeda:      * were replaced by VTI calls. Each element in the list contains four
1:0cefeda:      * integers describing positions where modifications have happened. The
1:0cefeda:      * first two integers are begin and end positions of a transition table
1:0cefeda:      * or transition variable in {@link #originalActionText the original SQL
1:0cefeda:      * text}. The last two integers are begin and end positions of the
1:0cefeda:      * corresponding replacement in {@link #actionText the transformed SQL
1:0cefeda:      * text}.
1:0cefeda:      * </p>
1:0cefeda:      *
1:0cefeda:      * <p>
1:0cefeda:      * Begin positions are inclusive and end positions are exclusive.
1:0cefeda:      * </p>
1:0cefeda:      */
1:0cefeda:     private final ArrayList<int[]>
1:0cefeda:             actionTransformations = new ArrayList<int[]>();
1:0cefeda: 
1:0cefeda:     /**
1:0cefeda:      * Structure that has the same shape as {@code actionTransformations},
1:0cefeda:      * except that it describes the transformations in the WHEN clause.
1:0cefeda:      */
1:0cefeda:     private final ArrayList<int[]>
1:0cefeda:             whenClauseTransformations = new ArrayList<int[]>();
1:1198ab7: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for a CreateTriggerNode
1:eac0369: 	 *
1:eac0369: 	 * @param triggerName			name of the trigger	
1:eac0369: 	 * @param tableName				name of the table which the trigger is declared upon	
1:eac0369: 	 * @param triggerEventMask		TriggerDescriptor.TRIGGER_EVENT_XXX
1:eac0369: 	 * @param triggerCols			columns trigger is to fire upon.  Valid
1:eac0369: 	 *								for UPDATE case only.
1:eac0369: 	 * @param isBefore				is before trigger (false for after)
1:eac0369: 	 * @param isRow					true for row trigger, false for statement
1:eac0369: 	 * @param isEnabled				true if enabled
1:eac0369: 	 * @param refClause				the referencing clause
1:eac0369: 	 * @param whenClause			the WHEN clause tree
1:eac0369: 	 * @param whenText				the text of the WHEN clause
1:eac0369: 	 * @param actionNode			the trigger action tree
1:eac0369: 	 * @param actionText			the text of the trigger action
1:3bb140c:      * @param cm                    context manager
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:1198ab7: 	 */
1:3bb140c:     CreateTriggerNode
2:eac0369: 	(
1:3bb140c:         TableName       triggerName,
1:3bb140c:         TableName       tableName,
1:3bb140c:         int             triggerEventMask,
1:3bb140c:         ResultColumnList triggerCols,
1:3bb140c:         boolean         isBefore,
1:3bb140c:         boolean         isRow,
1:3bb140c:         boolean         isEnabled,
1:3bb140c:         List<TriggerReferencingStruct> refClause,
1:3bb140c:         ValueNode       whenClause,
1:3bb140c:         String          whenText,
1:3bb140c:         StatementNode   actionNode,
1:3bb140c:         String          actionText,
1:3bb140c:         ContextManager  cm
2:eac0369: 	) throws StandardException
1:a6f9586: 	{
1:3bb140c:         super(triggerName, cm);
1:2706d1f: 
1:3bb140c:         this.triggerName = triggerName;
1:3bb140c:         this.tableName = tableName;
1:3bb140c:         this.triggerEventMask = triggerEventMask;
1:3bb140c:         this.triggerCols = triggerCols;
1:3bb140c:         this.isBefore = isBefore;
1:3bb140c:         this.isRow = isRow;
1:3bb140c:         this.isEnabled = isEnabled;
1:3bb140c:         this.refClause = refClause;
1:3bb140c:         this.whenClause = whenClause;
1:d9878ca:         this.originalWhenText = whenText;
1:d9878ca:         this.whenText = (whenText == null) ? null : whenText.trim();
1:3bb140c:         this.actionNode = actionNode;
1:3bb140c:         this.originalActionText = actionText;
1:d9878ca:         this.actionText = (actionText == null) ? null : actionText.trim();
1:3bb140c:         this.implicitCreateSchema = true;
1:a6f9586: 	}
1:a6f9586: 
1:3bb140c:     String statementToString()
1:179e593: 	{
1:eac0369: 		return "CREATE TRIGGER";
1:179e593: 	}
1:a6f9586: 
1:ccb1894: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:69f8afa:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:a6f9586: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:1198ab7: 		{
1:eac0369: 			super.printSubNodes(depth);
1:1198ab7: 
1:eac0369: 			if (triggerCols != null)
1:1198ab7: 			{
1:eac0369: 				printLabel(depth, "triggerColumns: ");
1:eac0369: 				triggerCols.treePrint(depth + 1);
1:a6f9586: 			}
1:eac0369: 			if (whenClause != null)
28:eac0369: 			{
1:eac0369: 				printLabel(depth, "whenClause: ");
1:eac0369: 				whenClause.treePrint(depth + 1);
1:1198ab7: 			}
1:eac0369: 			if (actionNode != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "actionNode: ");
1:eac0369: 				actionNode.treePrint(depth + 1);
37:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	// accessors
1:eac0369: 
1:eac0369: 
1:eac0369: 	// We inherit the generate() method from DDLStatementNode.
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this CreateTriggerNode.  This means doing any static error
1:eac0369: 	 * checking that can be done before actually creating the table.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:cc770d8: 	public void bindStatement() throws StandardException
1:eac0369: 	{
1:eac0369: 		CompilerContext compilerContext = getCompilerContext();
1:eac0369: 		DataDictionary	dd = getDataDictionary();
1:e735448: 		/*
1:eac0369: 		** Grab the current schema.  We will use that for
1:eac0369: 		** sps compilation
1:eac0369: 		*/
2:eac0369: 		LanguageConnectionContext lcc = getLanguageConnectionContext();
1:eac0369: 		compSchemaDescriptor = lcc.getDefaultSchema();
1:eac0369: 
1:1198ab7: 		/*
1:eac0369: 		** Get and check the schema descriptor for this
1:eac0369: 		** trigger.  This check will throw the proper exception
1:eac0369: 		** if someone tries to create a trigger in the SYS
1:eac0369: 		** schema.
1:eac0369: 		*/
1:eac0369: 		triggerSchemaDescriptor = getSchemaDescriptor();
1:eac0369: 
13:eac0369: 		/*
1:eac0369: 		** Get the trigger table.
1:eac0369: 		*/
1:eac0369: 		triggerTableDescriptor = getTableDescriptor(tableName);
1:eac0369: 
1:eac0369: 		//throw an exception if user is attempting to create a trigger on a temporary table
1:eac0369: 		if (isSessionSchema(triggerTableDescriptor.getSchemaDescriptor()))
1:eac0369: 		{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
1:eac0369: 		}
1:2d2e717: 		if (isPrivilegeCollectionRequired())
1:2d2e717: 		{
1:2d2e717: 			compilerContext.pushCurrentPrivType(Authorizer.TRIGGER_PRIV);
1:2d2e717: 			compilerContext.addRequiredTablePriv(triggerTableDescriptor);
1:2d2e717: 			compilerContext.popCurrentPrivType();			
1:2d2e717: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Regenerates the actionText and actionNode if necessary.
1:eac0369: 		*/
1:eac0369: 		boolean needInternalSQL = bindReferencesClause(dd);
1:eac0369: 
1:0cefeda:         // Get all the names of SQL objects referenced by the triggered
1:0cefeda:         // SQL statement and the WHEN clause. Since some of the TableName
1:0cefeda:         // nodes may be eliminated from the node tree during the bind phase,
1:0cefeda:         // we collect the nodes before the nodes have been bound. The
1:0cefeda:         // names will be used later when we normalize the trigger text
1:0cefeda:         // that will be stored in the system tables.
1:0cefeda:         SortedSet<TableName> actionNames =
1:0cefeda:                 actionNode.getOffsetOrderedNodes(TableName.class);
1:0cefeda:         SortedSet<TableName> whenNames = (whenClause != null)
1:0cefeda:                 ? whenClause.getOffsetOrderedNodes(TableName.class)
1:0cefeda:                 : null;
1:0cefeda: 
1:cc67949:         ProviderList prevAPL =
1:cc67949:                 compilerContext.getCurrentAuxiliaryProviderList();
1:cc67949:         ProviderList apl = new ProviderList();
1:cc67949: 
1:eac0369: 		lcc.pushTriggerTable(triggerTableDescriptor);
2:eac0369: 		try
1:eac0369: 		{	
1:cc67949:             compilerContext.setCurrentAuxiliaryProviderList(apl);
1:cc67949: 
1:eac0369: 			/*
1:eac0369: 			** Bind the trigger action and the trigger
1:eac0369: 			** when clause to make sure that they are
1:eac0369: 			** ok.  Note that we have already substituted 
1:eac0369: 			** in various replacements for OLD/NEW transition
1:eac0369: 			** tables/variables and reparsed if necessary.
1:eac0369: 			*/
1:eac0369: 			if (needInternalSQL)
1:eac0369: 				compilerContext.setReliability(CompilerContext.INTERNAL_SQL_LEGAL);
1:3b1291b: 			
1:3b1291b: 			// For before triggers, the action statement cannot contain calls
1:3b1291b: 			// to procedures that modify SQL data. If the action statement 
1:3b1291b: 			// contains a procedure call, this reliability will be used during
1:3b1291b: 			// bind of the call statement node. 
1:3b1291b: 			if(isBefore)
1:3b1291b: 				compilerContext.setReliability(CompilerContext.MODIFIES_SQL_DATA_PROCEDURE_ILLEGAL);
1:3b1291b: 					
1:8a93440: 			actionNode.bindStatement();
1:eac0369: 
1:eac0369: 			if (whenClause != null)
1:eac0369: 			{
1:d9878ca:                 ContextManager cm = getContextManager();
1:d9878ca:                 whenClause = whenClause.bindExpression(
1:d9878ca:                         new FromList(cm), new SubqueryList(cm),
1:d9878ca:                         new ArrayList<AggregateNode>(0));
1:df73e36: 
1:df73e36:                 // The WHEN clause must be a BOOLEAN expression.
1:df73e36:                 whenClause.checkIsBoolean();
1:eac0369: 			}
1:eac0369: 		}
2:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			lcc.popTriggerTable(triggerTableDescriptor);
1:cc67949:             compilerContext.setCurrentAuxiliaryProviderList(prevAPL);
1:eac0369: 		}
1:eac0369: 
1:0cefeda:         // Qualify identifiers before storing them (DERBY-5901/DERBY-6370).
1:0cefeda:         qualifyNames(actionNames, whenNames);
1:0cefeda: 
1:eac0369: 		/* 
1:eac0369: 		** Statement is dependent on the TableDescriptor 
1:8a93440: 		*/
1:eac0369: 		compilerContext.createDependency(triggerTableDescriptor);
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** If there is a list of columns, then no duplicate columns,
1:eac0369: 		** and all columns must be found.
1:eac0369: 		*/
1:eac0369: 		if (triggerCols != null && triggerCols.size() != 0)
1:eac0369: 		{
1:9d5bd0e:             HashSet<String> columnNames = new HashSet<String>();
1:e1f49ca: 
1:e1f49ca:             for (ResultColumn rc : triggerCols)
1:eac0369: 			{
1:234a2b6: 				if (!columnNames.add(rc.getName()))
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_DUPLICATE_COLUMN_IN_TRIGGER_UPDATE, 
2:eac0369: 											rc.getName(), 
1:eac0369: 											triggerName);
1:eac0369: 				}
1:eac0369: 
1:a6f9586: 				ColumnDescriptor cd = triggerTableDescriptor.getColumnDescriptor(rc.getName());
1:a6f9586: 				if (cd == null)
1:eac0369: 				{
1:a6f9586: 					throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, 
1:a6f9586: 																rc.getName(),
1:a6f9586: 																tableName);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:51f910f:         // Throw an exception if the WHEN clause or the triggered SQL
1:51f910f:         // statement references a table in the SESSION schema.
1:51f910f:         if (referencesSessionSchema()) {
1:eac0369: 			throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
1:51f910f:         }
1:cc67949: 
1:cc67949:         DependencyManager dm = dd.getDependencyManager();
1:cc67949:         providerInfo = dm.getPersistentProviderInfos(apl);
1:cc67949:         dm.clearColumnInfoInProviders(apl);
1:cc67949: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1:eac0369: 	 *
1:eac0369: 	 * @return	true if references SESSION schema tables, else false
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public boolean referencesSessionSchema()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		//If create trigger is part of create statement and the trigger is defined on or it references SESSION schema tables,
1:eac0369: 		//it will get caught in the bind phase of trigger and exception will be thrown by the trigger bind. 
1:51f910f:         return isSessionSchema(triggerTableDescriptor.getSchemaName())
1:51f910f:                 || actionNode.referencesSessionSchema()
1:51f910f:                 || (whenClause != null && whenClause.referencesSessionSchema());
1:eac0369: 	}
1:e735448: 
1:eac0369:     /**
1:ccb1894:      * Comparator that can be used for sorting lists of FromBaseTables
1:ccb1894:      * on the position they have in the SQL query string.
1:ccb1894:      */
1:9d5bd0e:     private static final Comparator<FromBaseTable> OFFSET_COMPARATOR = new Comparator<FromBaseTable>() {
1:9d5bd0e:         public int compare(FromBaseTable o1, FromBaseTable o2) {
1:ccb1894:             // Return negative int, zero, or positive int if the offset of the
1:ccb1894:             // first table is less than, equal to, or greater than the offset
1:ccb1894:             // of the second table.
1:9d5bd0e:             return o1.getTableNameField().getBeginOffset() -
1:9d5bd0e:                     o2.getTableNameField().getBeginOffset();
1:ccb1894:         }
1:ccb1894:     };
1:ccb1894: 
1:eac0369: 	/*
1:a6f9586: 	** BIND OLD/NEW TRANSITION TABLES/VARIABLES AND collect TRIGGER ACTION
1:a6f9586: 	** COLUMNS referenced through REFERECING CLAUSE in CREATE TRIGGER statement
1:0b63f40: 	**
1:eac0369: 	** 1) validate the referencing clause (if any)
1:0b63f40: 	**
1:d9878ca:     ** 2) convert trigger action text and WHEN clause text.  e.g.
1:179e593: 	**	DELETE FROM t WHERE c = old.c
1:eac0369: 	** turns into
1:179e593: 	**	DELETE FROM t WHERE c = org.apache.derby.iapi.db.Factory::
1:179e593: 	**		getTriggerExecutionContext().getOldRow().
1:179e593: 	**      getInt(columnNumberFor'C'inRuntimeResultset);
1:eac0369: 	** or
1:179e593: 	**	DELETE FROM t WHERE c in (SELECT c FROM OLD)
1:eac0369: 	** turns into
1:179e593: 	**	DELETE FROM t WHERE c in (
1:179e593: 	**      SELECT c FROM new TriggerOldTransitionTable OLD)
1:a6f9586: 	**
1:eac0369: 	** 3) check all column references against new/old transition 
1:eac0369: 	**	variables (since they are no longer 'normal' column references
1:eac0369: 	** 	that will be checked during bind)
1:a6f9586: 	**
1:a6f9586: 	** 4) collect all column references in trigger action through new/old 
1:a6f9586: 	** transition variables. Information about them will be saved in
1:a6f9586: 	** SYSTRIGGERS table DERBY-1482(if we are dealing with pre-10.7 db, then we
1:a6f9586: 	** will not put any information about trigger action columns in the system
1:a6f9586: 	** table to ensure backward compatibility). This information along with the
1:a6f9586: 	** trigger columns will decide what columns from the trigger table will be
1:a6f9586: 	** fetched into memory during trigger execution.
1:a6f9586: 	**
1:a6f9586: 	** 5) reparse the new action text
2:a6f9586: 	**
1:eac0369: 	** You might be wondering why we regenerate the text and reparse
1:eac0369: 	** instead of just reworking the tree to have the nodes we want.
1:eac0369: 	** Well, the primary reason is that if we screwed with the tree,
1:eac0369: 	** then we would have a major headache if this trigger action
1:eac0369: 	** was ever recompiled -- spses don't really know that they are
1:eac0369: 	** triggers so it would be quite arduous to figure out that an
1:eac0369: 	** sps is a trigger and munge up its query tree after figuring
1:eac0369: 	** out what its OLD/NEW tables are, etc.  Also, it is just plain
1:a6f9586: 	** easier to just generate the sql and rebind.
1:a6f9586: 	**
1:0b63f40: 	*/
1:eac0369: 	private boolean bindReferencesClause(DataDictionary dd) throws StandardException
1:0b63f40: 	{
1:eac0369: 		validateReferencesClause(dd);
1:a6f9586: 
1:e735448:         // the actions of before triggers may not reference generated columns
1:e735448:         if ( isBefore ) { forbidActionsOnGenCols(); }
1:a6f9586: 
1:179e593: 		String transformedActionText;
1:d9878ca:         String transformedWhenText = null;
1:179e593: 		if (triggerCols != null && triggerCols.size() != 0) {
1:179e593: 			//If the trigger is defined on speific columns, then collect
1:179e593: 			//their column positions and ensure that those columns do
1:179e593: 			//indeed exist in the trigger table.
1:179e593: 			referencedColInts = new int[triggerCols.size()];
1:a6f9586: 
1:179e593: 			//This is the most interesting case for us. If we are here, 
1:374d58f: 			//then it means that a set of trigger columns are specified
1:374d58f: 			//in the CREATE TRIGGER statement. This can only happen for
1:374d58f: 			//an UPDATE trigger.
1:179e593: 			//eg
1:179e593: 			//CREATE TRIGGER tr1 AFTER UPDATE OF c12 ON table1 
1:179e593: 			//    REFERENCING OLD AS oldt NEW AS newt
1:179e593: 			//    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
1:179e593: 			
1:179e593: 			for (int i=0; i < triggerCols.size(); i++){
1:e1f49ca:                 ResultColumn rc = triggerCols.elementAt(i);
1:e1f49ca:                 ColumnDescriptor cd =
1:e1f49ca:                     triggerTableDescriptor.getColumnDescriptor(rc.getName());
1:179e593: 				//Following will catch the case where an invalid trigger column
1:179e593: 				//has been specified in CREATE TRIGGER statement.
1:179e593: 				//CREATE TRIGGER tr1 AFTER UPDATE OF c1678 ON table1 
1:179e593: 				//    REFERENCING OLD AS oldt NEW AS newt
1:179e593: 				//    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
1:179e593: 				if (cd == null)
1:179e593: 				{
1:179e593: 					throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, 
1:179e593: 																rc.getName(),
1:179e593: 																tableName);
1:179e593: 				}
1:179e593: 				referencedColInts[i] = cd.getPosition();
1:179e593: 			}
1:179e593: 			// sort the list
1:179e593: 			java.util.Arrays.sort(referencedColInts);
1:179e593: 		}
1:179e593: 		
2:eac0369: 		if (isRow)
1:eac0369: 		{
1:179e593: 			//Create an array for column positions of columns referenced in 
1:179e593: 			//trigger action. Initialize it to -1. The call to 
1:179e593: 			//DataDictoinary.getTriggerActionSPS will find out the actual 
1:179e593: 			//columns, if any, referenced in the trigger action and put their
1:179e593: 			//column positions in the array.
1:179e593: 			referencedColsInTriggerAction = new int[triggerTableDescriptor.getNumberOfColumns()];
1:179e593: 			java.util.Arrays.fill(referencedColsInTriggerAction, -1);
1:54844c3: 
1:54844c3: 			int[] cols;
1:54844c3: 
1:54844c3: 			cols = getDataDictionary().examineTriggerNodeAndCols(actionNode,
1:54844c3: 					oldTableName,
1:54844c3: 					newTableName,
1:54844c3: 					originalActionText,
1:54844c3: 					referencedColInts,
1:54844c3: 					referencedColsInTriggerAction,
1:54844c3:                     actionNode.getBeginOffset(),
1:54844c3: 					triggerTableDescriptor,
1:54844c3: 					triggerEventMask,
1:54844c3:                     true,
1:54844c3:                     actionTransformations);
1:54844c3: 
1:54844c3:     		if (whenClause != null)
1:54844c3:     		{
1:54844c3:         		cols = getDataDictionary().examineTriggerNodeAndCols(whenClause,
1:54844c3:         			oldTableName,
1:54844c3: 					newTableName,
1:54844c3: 					originalActionText,
1:54844c3: 					referencedColInts,
1:54844c3: 					referencedColsInTriggerAction,
1:54844c3:                     actionNode.getBeginOffset(),
1:54844c3: 					triggerTableDescriptor,
1:54844c3: 					triggerEventMask,
1:54844c3:                     true,
1:54844c3:                     actionTransformations);
1:54844c3:     		}
1:54844c3: 
1:54844c3: 
1:179e593: 			//Now that we have verified that are no invalid column references
1:179e593: 			//for trigger columns, let's go ahead and transform the OLD/NEW
1:179e593: 			//transient table references in the trigger action sql.
1:179e593: 			transformedActionText = getDataDictionary().getTriggerActionString(actionNode, 
1:179e593: 					oldTableName,
1:179e593: 					newTableName,
1:179e593: 					originalActionText,
1:179e593: 					referencedColInts,
1:179e593: 					referencedColsInTriggerAction,
1:0342a82:                     actionNode.getBeginOffset(),
1:179e593: 					triggerTableDescriptor,
1:179e593: 					triggerEventMask,
1:0cefeda:                     true,
1:54844c3:                     actionTransformations, cols);
1:d9878ca: 
1:d9878ca:             // If there is a WHEN clause, we need to transform its text too.
1:d9878ca:             if (whenClause != null) {
1:d9878ca:                 transformedWhenText =
1:d9878ca:                     getDataDictionary().getTriggerActionString(
1:d9878ca:                             whenClause, oldTableName, newTableName,
1:d9878ca:                             originalWhenText, referencedColInts,
1:0342a82:                             referencedColsInTriggerAction,
1:0342a82:                             whenClause.getBeginOffset(),
1:0cefeda:                             triggerTableDescriptor, triggerEventMask, true,
1:54844c3:                             whenClauseTransformations, cols);
1:6a17f80:             }
1:d9878ca: 
1:179e593: 			//Now that we know what columns we need for REFERENCEd columns in
1:179e593: 			//trigger action, we can get rid of -1 entries for the remaining 
1:179e593: 			//columns from trigger table. This information will be saved in
1:179e593: 			//SYSTRIGGERS and will be used at trigger execution time to decide 
1:179e593: 			//which columns need to be read into memory for trigger action
1:179e593: 			referencedColsInTriggerAction = justTheRequiredColumns(
1:179e593: 					referencedColsInTriggerAction);
1:eac0369: 		}
1:1198ab7: 		else
1:eac0369: 		{
1:179e593: 			//This is a table level trigger	        
1:d9878ca:             transformedActionText = transformStatementTriggerText(
1:0342a82:                     actionNode, originalActionText, actionTransformations);
1:d9878ca:             if (whenClause != null) {
1:d9878ca:                 transformedWhenText = transformStatementTriggerText(
1:0342a82:                         whenClause, originalWhenText,
1:0cefeda:                         whenClauseTransformations);
1:d9878ca:             }
1:1198ab7: 		}
1:e1f49ca: 
1:a6f9586: 		if (referencedColsInTriggerAction != null)
1:a6f9586: 			java.util.Arrays.sort(referencedColsInTriggerAction);
1:a6f9586: 
1:eac0369: 		/*
1:eac0369: 		** Parse the new action text with the substitutions.
1:eac0369: 		** Also, we reset the actionText to this new value.  This
1:eac0369: 		** is what we are going to stick in the system tables.
1:1198ab7: 		*/
1:179e593: 		boolean regenNode = false;
1:179e593: 		if (!transformedActionText.equals(actionText))
1:eac0369: 		{
1:179e593: 			regenNode = true;
1:179e593: 			actionText = transformedActionText;
1:be0b54f: 			actionNode = parseStatement(actionText, true);
1:a6f9586: 		}
1:e735448: 
1:d9878ca:         if (whenClause != null && !transformedWhenText.equals(whenText)) {
1:d9878ca:             regenNode = true;
1:d9878ca:             whenText = transformedWhenText;
1:d9878ca:             whenClause = parseSearchCondition(whenText, true);
1:d9878ca:         }
1:d9878ca: 
1:eac0369: 		return regenNode;
1:eac0369: 	}
1:1198ab7: 
1:0cefeda:     /**
1:0cefeda:      * Make sure all references to SQL schema objects (such as tables and
1:0cefeda:      * functions) in the SQL fragments that will be stored in the SPS and
1:0cefeda:      * in the trigger descriptor, are fully qualified with a schema name.
1:0cefeda:      *
1:0cefeda:      * @param actionNames all the TableName nodes found in the triggered
1:0cefeda:      *                    SQL statement
1:0cefeda:      * @param whenNames   all the Table Name nodes found in the WHEN clause
1:0cefeda:      */
1:0cefeda:     private void qualifyNames(SortedSet<TableName> actionNames,
1:0cefeda:                               SortedSet<TableName> whenNames)
1:0cefeda:             throws StandardException {
1:0cefeda: 
1:0cefeda:         StringBuilder original = new StringBuilder();
1:0cefeda:         StringBuilder transformed = new StringBuilder();
1:0cefeda: 
1:0cefeda:         // Qualify the names in the action text.
1:0cefeda:         qualifyNames(actionNode, actionNames, originalActionText, actionText,
1:0cefeda:                      actionTransformations, original, transformed);
1:0cefeda:         originalActionText = original.toString();
1:0cefeda:         actionText = transformed.toString();
1:0cefeda: 
1:0cefeda:         // Do the same for the WHEN clause, if there is one.
1:0cefeda:         if (whenClause != null) {
1:0cefeda:             original.setLength(0);
1:0cefeda:             transformed.setLength(0);
1:0cefeda:             qualifyNames(whenClause, whenNames, originalWhenText, whenText,
1:0cefeda:                          whenClauseTransformations, original, transformed);
1:0cefeda:             originalWhenText = original.toString();
1:0cefeda:             whenText = transformed.toString();
1:0cefeda:         }
1:0cefeda:     }
1:0cefeda: 
1:0cefeda:     /**
1:0cefeda:      * Qualify all names SQL object names in original and transformed SQL
1:0cefeda:      * text for an action or a WHEN clause.
1:0cefeda:      *
1:0cefeda:      * @param node the query tree node for the transformed version of the
1:0cefeda:      *   SQL text, in a bound state
1:0cefeda:      * @param tableNames all the TableName nodes in the transformed text,
1:0cefeda:      *   in the order in which they appear in the SQL text
1:0cefeda:      * @param originalText the original SQL text
1:0cefeda:      * @param transformedText the transformed SQL text (with VTI calls for
1:0cefeda:      *   transition tables or transition variables)
1:0cefeda:      * @param replacements a data structure that describes how {@code
1:0cefeda:      *   originalText} was transformed into {@code transformedText}
1:0cefeda:      * @param newOriginal where to store the normalized version of the
1:0cefeda:      *   original text
1:0cefeda:      * @param newTransformed where to store the normalized version of the
1:0cefeda:      *   transformed text
1:0cefeda:      */
1:0cefeda:     private void qualifyNames(
1:0cefeda:             QueryTreeNode node,
1:0cefeda:             SortedSet<TableName> tableNames,
1:0cefeda:             String originalText,
1:0cefeda:             String transformedText,
1:0cefeda:             List<int[]> replacements,
1:0cefeda:             StringBuilder newOriginal,
1:0cefeda:             StringBuilder newTransformed) throws StandardException {
1:0cefeda: 
1:0cefeda:         int originalPos = 0;
1:0cefeda:         int transformedPos = 0;
1:0cefeda: 
1:0cefeda:         for (TableName name : tableNames) {
1:0cefeda: 
1:0cefeda:             String qualifiedName = name.getFullSQLName();
1:0cefeda: 
1:0cefeda:             int beginOffset = name.getBeginOffset() - node.getBeginOffset();
1:0cefeda:             int tokenLength = name.getEndOffset() + 1 - name.getBeginOffset();
1:0cefeda: 
1:0cefeda:             // For the transformed text, use the positions from the node.
1:0cefeda:             newTransformed.append(transformedText, transformedPos, beginOffset);
1:0cefeda:             newTransformed.append(qualifiedName);
1:0cefeda:             transformedPos = beginOffset + tokenLength;
1:0cefeda: 
1:0cefeda:             // For the original text, we need to adjust the positions to
1:0cefeda:             // compensate for the changes in the transformed text.
1:0cefeda:             Integer origBeginOffset =
1:0cefeda:                     getOriginalPosition(replacements, beginOffset);
1:0cefeda:             if (origBeginOffset != null) {
1:0cefeda:                 newOriginal.append(originalText, originalPos, origBeginOffset);
1:0cefeda:                 newOriginal.append(qualifiedName);
1:0cefeda:                 originalPos = origBeginOffset + tokenLength;
1:0cefeda:             }
1:0cefeda:         }
1:0cefeda: 
1:0cefeda:         newTransformed.append(
1:0cefeda:                 transformedText, transformedPos, transformedText.length());
1:0cefeda:         newOriginal.append(originalText, originalPos, originalText.length());
1:0cefeda:     }
1:0cefeda: 
1:0cefeda:     /**
1:0cefeda:      * Translate a position from the transformed trigger text
1:0cefeda:      * ({@link #actionText} or {@link #whenText}) to the corresponding
1:0cefeda:      * position in the original trigger text ({@link #originalActionText}
1:0cefeda:      * or {@link #originalWhenText}).
1:0cefeda:      *
1:0cefeda:      * @param replacements a data structure that describes the relationship
1:0cefeda:      *   between positions in the original and the transformed text
1:0cefeda:      * @param transformedPosition the position to translate
1:0cefeda:      * @return the position in the original text, or {@code null} if there
1:0cefeda:      *   is no corresponding position in the original text (for example if
1:0cefeda:      *   it points to a token that was added to the transformed text and
1:0cefeda:      *   does not exist in the original text)
1:0cefeda:      */
1:0cefeda:     private static Integer getOriginalPosition(
1:0cefeda:             List<int[]> replacements, int transformedPosition) {
1:0cefeda: 
1:0cefeda:         // Find the last change before the position we want to translate.
1:0cefeda:         for (int i = replacements.size() - 1; i >= 0; i--) {
1:0cefeda:             int[] offsets = replacements.get(i);
1:0cefeda: 
1:0cefeda:             // offset[0] is the begin offset of the replaced text
1:0cefeda:             // offset[1] is the end offset of the replaced text
1:0cefeda:             // offset[2] is the begin offset of the replacement text
1:0cefeda:             // offset[3] is the end offset of the replacement text
1:0cefeda: 
1:0cefeda:             // Skip those changes that come after the position we
1:0cefeda:             // want to translate.
1:0cefeda:             if (transformedPosition >= offsets[2]) {
1:0cefeda:                 if (transformedPosition < offsets[3]) {
1:0cefeda:                     // The position points inside a changed portion of the
1:0cefeda:                     // SQL text, so there's no corresponding position in the
1:0cefeda:                     // original text. Return null.
1:0cefeda:                     return null;
1:0cefeda:                 } else {
1:0cefeda:                     // The position points after the end of the changed text,
1:0cefeda:                     // which means it's in a portion that's common to the
1:0cefeda:                     // original and the transformed text. Translate between
1:0cefeda:                     // the two.
1:0cefeda:                     return offsets[1] + (transformedPosition - offsets[3]);
1:0cefeda:                 }
1:0cefeda:             }
1:0cefeda:         }
1:0cefeda: 
1:0cefeda:         // The position is before any of the transformations, so the position
1:0cefeda:         // is the same in the original and the transformed text.
1:0cefeda:         return transformedPosition;
1:0cefeda:     }
1:0cefeda: 
1:eac0369: 	/*
1:a6f9586: 	 * The arrary passed will have either -1 or a column position as it's 
1:a6f9586: 	 * elements. If the array only has -1 as for all it's elements, then
1:a6f9586: 	 * this method will return null. Otherwise, the method will create a
1:a6f9586: 	 * new arrary with all -1 entries removed from the original arrary.
1:a6f9586: 	 */
1:a6f9586: 	private int[] justTheRequiredColumns(int[] columnsArrary) {
1:a6f9586: 		int countOfColsRefedInArray = 0;
1:179e593: 		int numberOfColsInTriggerTable = triggerTableDescriptor.getNumberOfColumns();
1:a6f9586: 
1:a6f9586: 		//Count number of non -1 entries
1:a6f9586: 		for (int i=0; i < numberOfColsInTriggerTable; i++) {
1:a6f9586: 			if (columnsArrary[i] != -1)
1:a6f9586: 				countOfColsRefedInArray++;
1:a6f9586: 		}
1:a6f9586: 
1:a6f9586: 		if (countOfColsRefedInArray > 0){
1:a6f9586: 			int[] tempArrayOfNeededColumns = new int[countOfColsRefedInArray];
1:a6f9586: 			int j=0;
2:a6f9586: 			for (int i=0; i < numberOfColsInTriggerTable; i++) {
1:a6f9586: 				if (columnsArrary[i] != -1)
1:a6f9586: 					tempArrayOfNeededColumns[j++] = columnsArrary[i];
1:a6f9586: 			}
1:a6f9586: 			return tempArrayOfNeededColumns;
1:a6f9586: 		} else
1:a6f9586: 			return null;
1:a6f9586: 	}
1:179e593: 
1:d9878ca:     /**
1:d9878ca:      * Transform the WHEN clause or the triggered SQL statement of a
1:d9878ca:      * statement trigger from its original shape to internal syntax where
1:d9878ca:      * references to transition tables are replaced with VTIs that return
1:d9878ca:      * the before or after image of the changed rows.
1:d9878ca:      *
1:d9878ca:      * @param node the syntax tree of the WHEN clause or the triggered
1:d9878ca:      *   SQL statement
1:d9878ca:      * @param originalText the original text of the WHEN clause or the
1:d9878ca:      *   triggered SQL statement
1:0cefeda:      * @param replacements list that will be populated with int arrays that
1:0cefeda:      *   describe how the original text was transformed. The int arrays
1:0cefeda:      *   contain the begin (inclusive) and end (exclusive) positions of the
1:0cefeda:      *   original text that got replaced and of the replacement text, so that
1:0cefeda:      *   positions in the transformed text can be mapped to positions in the
1:0cefeda:      *   original text.
1:d9878ca:      * @return internal syntax for accessing before or after image of
1:d9878ca:      *   the changed rows
1:d9878ca:      * @throws StandardException if an error happens while performing the
1:d9878ca:      *   transformation
1:d9878ca:      */
1:d9878ca:     private String transformStatementTriggerText(
1:0342a82:             QueryTreeNode node, String originalText, List<int[]> replacements)
1:d9878ca:         throws StandardException
1:d9878ca:     {
1:0342a82:         final int offset = node.getBeginOffset();
1:d9878ca:         int start = 0;
1:d9878ca:         StringBuilder newText = new StringBuilder();
1:d9878ca: 
1:d9878ca:         // For a statement trigger, we find all FromBaseTable nodes. If
1:d9878ca:         // the from table is NEW or OLD (or user designated alternates
1:d9878ca:         // REFERENCING), we turn them into a trigger table VTI.
1:0cefeda:         for (FromBaseTable fromTable : getTransitionTables(node)) {
1:d9878ca:             String baseTableName = fromTable.getBaseTableName();
1:d9878ca:             int tokBeginOffset = fromTable.getTableNameField().getBeginOffset();
1:d9878ca:             int tokEndOffset = fromTable.getTableNameField().getEndOffset();
1:0cefeda:             int nextTokenStart = tokEndOffset - offset + 1;
1:d9878ca: 
1:d9878ca:             // Check if this transition table is allowed in this trigger type.
1:d9878ca:             checkInvalidTriggerReference(baseTableName);
1:d9878ca: 
1:0cefeda:             // The text up to the transition table name should be kept.
1:d9878ca:             newText.append(originalText, start, tokBeginOffset - offset);
1:0cefeda: 
1:0cefeda:             // Replace the transition table name with a VTI.
1:0cefeda:             final int replacementOffset = newText.length();
1:d9878ca:             newText.append(baseTableName.equals(oldTableName)
1:d9878ca:                 ? "new org.apache.derby.catalog.TriggerOldTransitionRows() "
1:d9878ca:                 : "new org.apache.derby.catalog.TriggerNewTransitionRows() ");
1:d9878ca: 
1:d9878ca:             // If the user supplied a correlation, then just
1:d9878ca:             // pick it up automatically; otherwise, supply
1:d9878ca:             // the default.
1:d9878ca:             if (fromTable.getCorrelationName() == null) {
1:d9878ca:                 newText.append(baseTableName).append(' ');
1:d9878ca:             }
1:a6f9586: 
1:0cefeda:             // Record that we have made a change.
1:0cefeda:             replacements.add(new int[] {
1:0cefeda:                 tokBeginOffset - offset,  // offset to original token
1:0cefeda:                 nextTokenStart,           // offset to next token
1:0cefeda:                 replacementOffset,        // offset to replacement
1:0cefeda:                 newText.length()          // offset to token after replacement
1:0cefeda:             });
1:0cefeda: 
1:0cefeda:             start = nextTokenStart;
1:a6f9586:         }
1:a6f9586: 
1:0cefeda:         // Finally, add everything found after the last transition table
1:0cefeda:         // unchanged.
1:d9878ca:         newText.append(originalText, start, originalText.length());
1:a6f9586: 
1:d9878ca:         return newText.toString();
1:a6f9586:     }
1:0cefeda: 
1:d8804a8:     /**
1:0cefeda:      * Get all transition tables referenced by a given node, sorted in the
1:0cefeda:      * order in which they appear in the SQL text.
1:0cefeda:      *
1:0cefeda:      * @param node the node in which to search for transition tables
1:0cefeda:      * @return a sorted set of {@code FromBaseTable}s that represent
1:0cefeda:      *   transition tables
1:0cefeda:      * @throws StandardException if an error occurs
1:0cefeda:      */
1:0cefeda:     private SortedSet<FromBaseTable> getTransitionTables(Visitable node)
1:0cefeda:             throws StandardException {
1:0cefeda: 
1:0cefeda:         CollectNodesVisitor<FromBaseTable> visitor =
1:0cefeda:                 new CollectNodesVisitor<FromBaseTable>(FromBaseTable.class);
1:0cefeda:         node.accept(visitor);
1:0cefeda: 
1:0cefeda:         TreeSet<FromBaseTable> tables =
1:0cefeda:                 new TreeSet<FromBaseTable>(OFFSET_COMPARATOR);
1:0cefeda: 
1:0cefeda:         for (FromBaseTable fbt : visitor.getList()) {
1:0cefeda:             if (!isTransitionTable(fbt)) {
1:0cefeda:                 // The from table is not the NEW or OLD table, so no need
1:0cefeda:                 // to do anything. Skip this table.
1:0b63f40:                 continue;
1:0b63f40:             }
1:0b63f40: 
1:0cefeda:             int tokBeginOffset = fbt.getTableNameField().getBeginOffset();
1:0cefeda:             if (tokBeginOffset == -1) {
1:0cefeda:                 // Unknown offset. Skip this table.
2:0cefeda:                 continue;
1:0cefeda:             }
1:0cefeda: 
1:0cefeda:             tables.add(fbt);
1:0cefeda:         }
1:0cefeda: 
1:0cefeda:         return tables;
1:0cefeda:     }
1:0cefeda: 
1:0cefeda:     /**
1:d8804a8:      * Check if a table represents one of the transition tables.
1:d8804a8:      *
1:d8804a8:      * @param fbt the table to check
1:d8804a8:      * @return {@code true} if {@code fbt} represents either the old or
1:d8804a8:      *   the new transition table, {@code false} otherwise
1:d8804a8:      */
1:d8804a8:     private boolean isTransitionTable(FromBaseTable fbt) {
1:d8804a8:         // DERBY-6540: It can only be a transition table if the name
1:d8804a8:         // is not schema qualified.
1:d8804a8:         if (!fbt.getOrigTableName().hasSchema()) {
1:d8804a8:             String baseTableName = fbt.getBaseTableName();
1:d8804a8:             if (baseTableName != null) {
1:d8804a8:                 return baseTableName.equals(oldTableName) ||
1:d8804a8:                         baseTableName.equals(newTableName);
1:0cefeda:             }
1:d8804a8:         }
1:d8804a8: 
1:d8804a8:         // Table name didn't match a transition table.
1:d8804a8:         return false;
1:d8804a8:     }
1:d8804a8: 
1:a6f9586:     /*
1:e735448:      * Forbid references to generated columns in the actions of BEFORE triggers.
1:e735448:      * This is DERBY-3948, enforcing the following section of the SQL standard:
1:e735448:      * part 2, section 11.39 (<trigger definition>), syntax rule 12c:
1:e735448:      *
1:e735448:      * <blockquote>
1:e735448:      *    12) If BEFORE is specified, then:
1:e735448:      * :
1:e735448:      * c) The <triggered action> shall not contain a <field reference> that
1:e735448:      * references a field in the new transition variable corresponding to a
1:e735448:      * generated column of T. 
1:e735448:      * </blockquote>
1:e735448:      */
1:e735448:     private void    forbidActionsOnGenCols()
1:e735448:         throws StandardException
1:a6f9586:     {
1:e735448:         ColumnDescriptorList    generatedColumns = triggerTableDescriptor.getGeneratedColumns();
1:e735448:         int                                 genColCount = generatedColumns.size();
1:d9878ca: 
1:e735448:         if ( genColCount == 0 ) { return; }
1:d9878ca: 
1:a6d25cd:         CollectNodesVisitor<ColumnReference> visitor =
1:a6d25cd:             new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
1:d9878ca: 
1:e735448:         actionNode.accept( visitor );
1:d9878ca: 
1:6a17f80:         if (whenClause != null) {
1:6a17f80:             whenClause.accept(visitor);
1:d8804a8:         }
1:6a17f80: 
1:a6d25cd:         for (ColumnReference cr : visitor.getList())
1:a6f9586:         {
1:e735448:             String  colRefName = cr.getColumnName();
1:e735448:             String  tabRefName = cr.getTableName();
1:d9878ca: 
1:e735448:             for ( int gc_idx = 0; gc_idx < genColCount; gc_idx++ )
1:e735448:             {
1:e735448:                 String  genColName = generatedColumns.elementAt( gc_idx ).getColumnName();
1:d9878ca: 
1:e735448:                 if ( genColName.equals( colRefName ) && equals( newTableName, tabRefName ) )
1:e735448:                 {
1:e735448:                     throw StandardException.newException( SQLState.LANG_GEN_COL_BEFORE_TRIG, genColName );
1:d9878ca:                 }
1:d9878ca:             }
1:d9878ca:         }
1:d9878ca:     }
1:a6f9586: 
1:e735448:     /*
1:e735448:      * Compare two strings.
1:e735448:      */
1:e735448:     private boolean equals( String left, String right )
1:e735448:     {
1:e735448:         if ( left == null ) { return (right == null); }
1:e735448:         else
1:e735448:         {
1:e735448:             return left.equals( right );
1:d9878ca:         }
1:a6f9586:     }
1:a6f9586: 
1:eac0369: 	/*
1:eac0369: 	** Check for illegal combinations here: insert & old or
1:eac0369: 	** delete and new
1:eac0369: 	*/
1:eac0369: 	private void checkInvalidTriggerReference(String tableName) throws StandardException
1:e735448: 	{
1:eac0369: 		if (tableName.equals(oldTableName) && 
1:eac0369: 			(triggerEventMask & TriggerDescriptor.TRIGGER_EVENT_INSERT) == TriggerDescriptor.TRIGGER_EVENT_INSERT)
1:e735448: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "INSERT", "new");
1:a6f9586: 		}
1:eac0369: 		else if (tableName.equals(newTableName) && 
1:eac0369: 			(triggerEventMask & TriggerDescriptor.TRIGGER_EVENT_DELETE) == TriggerDescriptor.TRIGGER_EVENT_DELETE)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "DELETE", "old");
1:a6f9586: 		}
1:a6f9586: 	}
1:179e593:     
1:eac0369: 	/*
1:eac0369: 	** Make sure that the referencing clause is legitimate.
1:eac0369: 	** While we are at it we set the new/oldTableName to
1:eac0369: 	** be whatever the user wants.
1:eac0369: 	*/
1:eac0369: 	private void validateReferencesClause(DataDictionary dd) throws StandardException
1:eac0369: 	{
1:47d4a4c: 		if ((refClause == null) || refClause.isEmpty())
1:eac0369: 		{
1:eac0369: 			return;
1:a6f9586: 		}
1:a6f9586: 
1:3bb140c:         for (TriggerReferencingStruct trn : refClause)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** 1) Make sure that we don't try to refer
1:eac0369: 			** to a table for a row trigger or a row for
1:eac0369: 			** a table trigger.
1:eac0369: 			*/
1:eac0369: 			if (isRow && !trn.isRow)
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "ROW", "row");
1:a6f9586: 			}
1:eac0369: 			else if (!isRow && trn.isRow) 
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "STATEMENT", "table");
1:e735448: 			}
1:a6f9586: 
1:eac0369: 			/*
1:eac0369: 			** 2) Make sure we have no dups
1:eac0369: 			*/
1:eac0369: 			if (trn.isNew)
1:eac0369: 			{
1:a6f9586: 
1:eac0369: 				if (newTableInReferencingClause) 
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_CLAUSE_DUPS);
1:e735448: 				}
1:a6f9586: 
1:eac0369: 				/*
1:eac0369: 				** 3a) No NEW reference in delete trigger
1:eac0369: 				*/
1:eac0369: 				if ((triggerEventMask & TriggerDescriptor.TRIGGER_EVENT_DELETE) == TriggerDescriptor.TRIGGER_EVENT_DELETE)
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "DELETE", "old");
1:e735448: 				}
1:eac0369: 				newTableName = trn.identifier;
1:eac0369: 				newTableInReferencingClause = true;
1:e735448: 			}
3:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				if (oldTableInReferencingClause)
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_CLAUSE_DUPS);
1:e735448: 				}
1:eac0369: 				/*
1:eac0369: 				** 3b) No OLD reference in insert trigger
1:eac0369: 				*/
1:eac0369: 				if ((triggerEventMask & TriggerDescriptor.TRIGGER_EVENT_INSERT) == TriggerDescriptor.TRIGGER_EVENT_INSERT)
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "INSERT", "new");
1:e735448: 				}
1:eac0369: 				oldTableName = trn.identifier;
1:eac0369: 				oldTableInReferencingClause = true;
1:eac0369: 			}
1:e735448: 
1:eac0369: 			/*
1:eac0369: 			** 4) Additional restriction on BEFORE triggers
1:eac0369: 			*/
1:eac0369: 			if (this.isBefore && !trn.isRow) {
1:925ae99: 			// OLD TABLE and NEW TABLE not allowed for BEFORE triggers.
1:eac0369: 				throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "BEFORE", "row");
1:eac0369: 			}
1:e735448: 
1:eac0369: 		}
1:e735448: 
1:eac0369: 	}				
1:e735448: 
1:e735448: 
1:eac0369: 	/**
1:eac0369: 	 * Create the Constant information that will drive the guts of Execution.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public ConstantAction makeConstantAction() throws StandardException
1:eac0369: 	{
1:eac0369: 		String oldReferencingName = (oldTableInReferencingClause) ? oldTableName : null;
1:eac0369: 		String newReferencingName = (newTableInReferencingClause) ? newTableName : null;
1:e735448: 
1:eac0369: 		return	getGenericConstantActionFactory().getCreateTriggerConstantAction(
1:eac0369: 											triggerSchemaDescriptor.getSchemaName(),
1:eac0369: 											getRelativeName(),
1:eac0369: 											triggerEventMask,
1:eac0369: 											isBefore,
1:eac0369: 											isRow,
1:eac0369: 											isEnabled,
1:eac0369: 											triggerTableDescriptor,	
1:eac0369: 											(UUID)null,			// when SPSID
1:eac0369: 											whenText,
1:eac0369: 											(UUID)null,			// action SPSid 
1:eac0369: 											actionText,
1:3bb140c:                                             compSchemaDescriptor.getUUID(),
1:eac0369: 											referencedColInts,
1:a6f9586: 											referencedColsInTriggerAction,
1:d9878ca:                                             originalWhenText,
1:eac0369: 											originalActionText,
1:eac0369: 											oldTableInReferencingClause,
1:eac0369: 											newTableInReferencingClause,
1:eac0369: 											oldReferencingName,
1:cc67949:                                             newReferencingName,
1:cc67949:                                             providerInfo
1:179e593: 											);
1:d9878ca: 	}
1:e735448: 
1:e735448: 
1:eac0369: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			String refString = "null";
1:eac0369: 			if (refClause != null)
1:eac0369: 			{
1:3bb140c:                 StringBuilder buf = new StringBuilder();
1:3bb140c:                 for (TriggerReferencingStruct trn : refClause)
1:eac0369: 				{
1:eac0369: 					buf.append("\t");
1:eac0369: 					buf.append(trn.toString());
1:eac0369: 					buf.append("\n");
1:eac0369: 				}
1:eac0369: 				refString = buf.toString();
1:eac0369: 			}
1:1198ab7: 
1:eac0369: 			return super.toString() +
1:eac0369: 				"tableName: "+tableName+		
1:eac0369: 				"\ntriggerEventMask: "+triggerEventMask+		
1:eac0369: 				"\nisBefore: "+isBefore+		
1:eac0369: 				"\nisRow: "+isRow+		
1:eac0369: 				"\nisEnabled: "+isEnabled+		
1:eac0369: 				"\nwhenText: "+whenText+
1:eac0369: 				"\nrefClause: "+refString+
1:eac0369: 				"\nactionText: "+actionText+
1:eac0369: 				"\n";
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:69f8afa:     void acceptChildren(Visitor v) throws StandardException {
1:69f8afa:         super.acceptChildren(v);
1:69f8afa: 
1:69f8afa:         if (triggerName != null) {
1:69f8afa:             triggerName = (TableName) triggerName.accept(v);
1:69f8afa:         }
1:69f8afa: 
1:69f8afa:         if (tableName != null) {
1:69f8afa:             tableName = (TableName) tableName.accept(v);
1:69f8afa:         }
1:69f8afa:     }
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:54844c3
/////////////////////////////////////////////////////////////////////////
1: 
1: 			int[] cols;
1: 
1: 			cols = getDataDictionary().examineTriggerNodeAndCols(actionNode,
1: 					oldTableName,
1: 					newTableName,
1: 					originalActionText,
1: 					referencedColInts,
1: 					referencedColsInTriggerAction,
1:                     actionNode.getBeginOffset(),
1: 					triggerTableDescriptor,
1: 					triggerEventMask,
1:                     true,
1:                     actionTransformations);
1: 
1:     		if (whenClause != null)
1:     		{
1:         		cols = getDataDictionary().examineTriggerNodeAndCols(whenClause,
1:         			oldTableName,
1: 					newTableName,
1: 					originalActionText,
1: 					referencedColInts,
1: 					referencedColsInTriggerAction,
1:                     actionNode.getBeginOffset(),
1: 					triggerTableDescriptor,
1: 					triggerEventMask,
1:                     true,
1:                     actionTransformations);
1:     		}
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                     actionTransformations, cols);
/////////////////////////////////////////////////////////////////////////
1:                             whenClauseTransformations, cols);
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:0b63f40
/////////////////////////////////////////////////////////////////////////
1: 				
1: 				/*
0: 				** Only occurrences of those OLD/NEW transition tables/variables 
0: 				** are of interest here.  There may be intermediate nodes in the 
0: 				** parse tree that have its own RCL which contains copy of 
0: 				** column references(CR) from other nodes. e.g.:  
1: 				**
0: 				** CREATE TRIGGER tt 
0: 				** AFTER INSERT ON x
0: 				** REFERENCING NEW AS n 
0: 				** FOR EACH ROW
0: 				**    INSERT INTO y VALUES (n.i), (999), (333);
1: 				** 
0: 				** The above trigger action will result in InsertNode that 
0: 				** contains a UnionNode of RowResultSetNodes.  The UnionNode
0: 				** will have a copy of the CRs from its left child and those CRs 
0: 				** will not have its beginOffset set which indicates they are 
0: 				** not relevant for the conversion processing here, so we can 
0: 				** safely skip them. 
1: 				*/
0: 				if (ref.getBeginOffset() == -1) 
1: 				{
1: 					continue;
1: 				}
1: 				
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:0342a82
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     actionNode.getBeginOffset(),
/////////////////////////////////////////////////////////////////////////
1:                             referencedColsInTriggerAction,
1:                             whenClause.getBeginOffset(),
/////////////////////////////////////////////////////////////////////////
1:                     actionNode, originalActionText, actionTransformations);
1:                         whenClause, originalWhenText,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             QueryTreeNode node, String originalText, List<int[]> replacements)
1:         final int offset = node.getBeginOffset();
commit:0cefeda
/////////////////////////////////////////////////////////////////////////
1: import java.util.SortedSet;
1: import java.util.TreeSet;
/////////////////////////////////////////////////////////////////////////
1:     private String              originalWhenText;
1:     private String              originalActionText;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * A list that describes how the original SQL text of the trigger action
1:      * statement was modified when transition tables and transition variables
1:      * were replaced by VTI calls. Each element in the list contains four
1:      * integers describing positions where modifications have happened. The
1:      * first two integers are begin and end positions of a transition table
1:      * or transition variable in {@link #originalActionText the original SQL
1:      * text}. The last two integers are begin and end positions of the
1:      * corresponding replacement in {@link #actionText the transformed SQL
1:      * text}.
1:      * </p>
1:      *
1:      * <p>
1:      * Begin positions are inclusive and end positions are exclusive.
1:      * </p>
1:      */
1:     private final ArrayList<int[]>
1:             actionTransformations = new ArrayList<int[]>();
1: 
1:     /**
1:      * Structure that has the same shape as {@code actionTransformations},
1:      * except that it describes the transformations in the WHEN clause.
1:      */
1:     private final ArrayList<int[]>
1:             whenClauseTransformations = new ArrayList<int[]>();
/////////////////////////////////////////////////////////////////////////
1:         // Get all the names of SQL objects referenced by the triggered
1:         // SQL statement and the WHEN clause. Since some of the TableName
1:         // nodes may be eliminated from the node tree during the bind phase,
1:         // we collect the nodes before the nodes have been bound. The
1:         // names will be used later when we normalize the trigger text
1:         // that will be stored in the system tables.
1:         SortedSet<TableName> actionNames =
1:                 actionNode.getOffsetOrderedNodes(TableName.class);
1:         SortedSet<TableName> whenNames = (whenClause != null)
1:                 ? whenClause.getOffsetOrderedNodes(TableName.class)
1:                 : null;
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Qualify identifiers before storing them (DERBY-5901/DERBY-6370).
1:         qualifyNames(actionNames, whenNames);
1: 
/////////////////////////////////////////////////////////////////////////
1:                     true,
0:                     actionTransformations);
/////////////////////////////////////////////////////////////////////////
1:                             triggerTableDescriptor, triggerEventMask, true,
1:                             whenClauseTransformations);
/////////////////////////////////////////////////////////////////////////
0:                     actionNode, originalActionText, actionOffset,
0:                     actionTransformations);
0:                         whenClause, originalWhenText, whenOffset,
0:                         whenClauseTransformations);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Make sure all references to SQL schema objects (such as tables and
1:      * functions) in the SQL fragments that will be stored in the SPS and
1:      * in the trigger descriptor, are fully qualified with a schema name.
1:      *
1:      * @param actionNames all the TableName nodes found in the triggered
1:      *                    SQL statement
1:      * @param whenNames   all the Table Name nodes found in the WHEN clause
1:      */
1:     private void qualifyNames(SortedSet<TableName> actionNames,
1:                               SortedSet<TableName> whenNames)
1:             throws StandardException {
1: 
1:         StringBuilder original = new StringBuilder();
1:         StringBuilder transformed = new StringBuilder();
1: 
1:         // Qualify the names in the action text.
1:         qualifyNames(actionNode, actionNames, originalActionText, actionText,
1:                      actionTransformations, original, transformed);
1:         originalActionText = original.toString();
1:         actionText = transformed.toString();
1: 
1:         // Do the same for the WHEN clause, if there is one.
1:         if (whenClause != null) {
1:             original.setLength(0);
1:             transformed.setLength(0);
1:             qualifyNames(whenClause, whenNames, originalWhenText, whenText,
1:                          whenClauseTransformations, original, transformed);
1:             originalWhenText = original.toString();
1:             whenText = transformed.toString();
1:         }
1:     }
1: 
1:     /**
1:      * Qualify all names SQL object names in original and transformed SQL
1:      * text for an action or a WHEN clause.
1:      *
1:      * @param node the query tree node for the transformed version of the
1:      *   SQL text, in a bound state
1:      * @param tableNames all the TableName nodes in the transformed text,
1:      *   in the order in which they appear in the SQL text
1:      * @param originalText the original SQL text
1:      * @param transformedText the transformed SQL text (with VTI calls for
1:      *   transition tables or transition variables)
1:      * @param replacements a data structure that describes how {@code
1:      *   originalText} was transformed into {@code transformedText}
1:      * @param newOriginal where to store the normalized version of the
1:      *   original text
1:      * @param newTransformed where to store the normalized version of the
1:      *   transformed text
1:      */
1:     private void qualifyNames(
1:             QueryTreeNode node,
1:             SortedSet<TableName> tableNames,
1:             String originalText,
1:             String transformedText,
1:             List<int[]> replacements,
1:             StringBuilder newOriginal,
1:             StringBuilder newTransformed) throws StandardException {
1: 
1:         int originalPos = 0;
1:         int transformedPos = 0;
1: 
1:         for (TableName name : tableNames) {
1: 
1:             String qualifiedName = name.getFullSQLName();
1: 
1:             int beginOffset = name.getBeginOffset() - node.getBeginOffset();
1:             int tokenLength = name.getEndOffset() + 1 - name.getBeginOffset();
1: 
1:             // For the transformed text, use the positions from the node.
1:             newTransformed.append(transformedText, transformedPos, beginOffset);
1:             newTransformed.append(qualifiedName);
1:             transformedPos = beginOffset + tokenLength;
1: 
1:             // For the original text, we need to adjust the positions to
1:             // compensate for the changes in the transformed text.
1:             Integer origBeginOffset =
1:                     getOriginalPosition(replacements, beginOffset);
1:             if (origBeginOffset != null) {
1:                 newOriginal.append(originalText, originalPos, origBeginOffset);
1:                 newOriginal.append(qualifiedName);
1:                 originalPos = origBeginOffset + tokenLength;
1:             }
1:         }
1: 
1:         newTransformed.append(
1:                 transformedText, transformedPos, transformedText.length());
1:         newOriginal.append(originalText, originalPos, originalText.length());
1:     }
1: 
1:     /**
1:      * Translate a position from the transformed trigger text
1:      * ({@link #actionText} or {@link #whenText}) to the corresponding
1:      * position in the original trigger text ({@link #originalActionText}
1:      * or {@link #originalWhenText}).
1:      *
1:      * @param replacements a data structure that describes the relationship
1:      *   between positions in the original and the transformed text
1:      * @param transformedPosition the position to translate
1:      * @return the position in the original text, or {@code null} if there
1:      *   is no corresponding position in the original text (for example if
1:      *   it points to a token that was added to the transformed text and
1:      *   does not exist in the original text)
1:      */
1:     private static Integer getOriginalPosition(
1:             List<int[]> replacements, int transformedPosition) {
1: 
1:         // Find the last change before the position we want to translate.
1:         for (int i = replacements.size() - 1; i >= 0; i--) {
1:             int[] offsets = replacements.get(i);
1: 
1:             // offset[0] is the begin offset of the replaced text
1:             // offset[1] is the end offset of the replaced text
1:             // offset[2] is the begin offset of the replacement text
1:             // offset[3] is the end offset of the replacement text
1: 
1:             // Skip those changes that come after the position we
1:             // want to translate.
1:             if (transformedPosition >= offsets[2]) {
1:                 if (transformedPosition < offsets[3]) {
1:                     // The position points inside a changed portion of the
1:                     // SQL text, so there's no corresponding position in the
1:                     // original text. Return null.
1:                     return null;
1:                 } else {
1:                     // The position points after the end of the changed text,
1:                     // which means it's in a portion that's common to the
1:                     // original and the transformed text. Translate between
1:                     // the two.
1:                     return offsets[1] + (transformedPosition - offsets[3]);
1:                 }
1:             }
1:         }
1: 
1:         // The position is before any of the transformations, so the position
1:         // is the same in the original and the transformed text.
1:         return transformedPosition;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @param replacements list that will be populated with int arrays that
1:      *   describe how the original text was transformed. The int arrays
1:      *   contain the begin (inclusive) and end (exclusive) positions of the
1:      *   original text that got replaced and of the replacement text, so that
1:      *   positions in the transformed text can be mapped to positions in the
1:      *   original text.
0:             Visitable node, String originalText, int offset,
0:             List<int[]> replacements)
/////////////////////////////////////////////////////////////////////////
1:         for (FromBaseTable fromTable : getTransitionTables(node)) {
1:             int nextTokenStart = tokEndOffset - offset + 1;
1:             // The text up to the transition table name should be kept.
1: 
1:             // Replace the transition table name with a VTI.
1:             final int replacementOffset = newText.length();
/////////////////////////////////////////////////////////////////////////
1:             // Record that we have made a change.
1:             replacements.add(new int[] {
1:                 tokBeginOffset - offset,  // offset to original token
1:                 nextTokenStart,           // offset to next token
1:                 replacementOffset,        // offset to replacement
1:                 newText.length()          // offset to token after replacement
1:             });
1: 
1:             start = nextTokenStart;
1:         // Finally, add everything found after the last transition table
1:         // unchanged.
1:      * Get all transition tables referenced by a given node, sorted in the
1:      * order in which they appear in the SQL text.
1:      *
1:      * @param node the node in which to search for transition tables
1:      * @return a sorted set of {@code FromBaseTable}s that represent
1:      *   transition tables
1:      * @throws StandardException if an error occurs
1:      */
1:     private SortedSet<FromBaseTable> getTransitionTables(Visitable node)
1:             throws StandardException {
1: 
1:         CollectNodesVisitor<FromBaseTable> visitor =
1:                 new CollectNodesVisitor<FromBaseTable>(FromBaseTable.class);
1:         node.accept(visitor);
1: 
1:         TreeSet<FromBaseTable> tables =
1:                 new TreeSet<FromBaseTable>(OFFSET_COMPARATOR);
1: 
1:         for (FromBaseTable fbt : visitor.getList()) {
1:             if (!isTransitionTable(fbt)) {
1:                 // The from table is not the NEW or OLD table, so no need
1:                 // to do anything. Skip this table.
1:                 continue;
1:             }
1: 
1:             int tokBeginOffset = fbt.getTableNameField().getBeginOffset();
1:             if (tokBeginOffset == -1) {
1:                 // Unknown offset. Skip this table.
1:                 continue;
1:             }
1: 
1:             tables.add(fbt);
1:         }
1: 
1:         return tables;
1:     }
1: 
1:     /**
commit:d8804a8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             if (!isTransitionTable(fromTable)) {
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check if a table represents one of the transition tables.
1:      *
1:      * @param fbt the table to check
1:      * @return {@code true} if {@code fbt} represents either the old or
1:      *   the new transition table, {@code false} otherwise
1:      */
1:     private boolean isTransitionTable(FromBaseTable fbt) {
1:         // DERBY-6540: It can only be a transition table if the name
1:         // is not schema qualified.
1:         if (!fbt.getOrigTableName().hasSchema()) {
1:             String baseTableName = fbt.getBaseTableName();
1:             if (baseTableName != null) {
1:                 return baseTableName.equals(oldTableName) ||
1:                         baseTableName.equals(newTableName);
1:             }
1:         }
1: 
1:         // Table name didn't match a transition table.
1:         return false;
1:     }
1: 
commit:6bd3847
/////////////////////////////////////////////////////////////////////////
commit:69f8afa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void acceptChildren(Visitor v) throws StandardException {
1:         super.acceptChildren(v);
1: 
1:         if (triggerName != null) {
1:             triggerName = (TableName) triggerName.accept(v);
1:         }
1: 
1:         if (tableName != null) {
1:             tableName = (TableName) tableName.accept(v);
1:         }
1:     }
commit:cc67949
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1: import org.apache.derby.iapi.sql.depend.ProviderList;
/////////////////////////////////////////////////////////////////////////
1:     private ProviderInfo[]      providerInfo;
/////////////////////////////////////////////////////////////////////////
1:         ProviderList prevAPL =
1:                 compilerContext.getCurrentAuxiliaryProviderList();
1:         ProviderList apl = new ProviderList();
1: 
1:             compilerContext.setCurrentAuxiliaryProviderList(apl);
1: 
/////////////////////////////////////////////////////////////////////////
1:             compilerContext.setCurrentAuxiliaryProviderList(prevAPL);
/////////////////////////////////////////////////////////////////////////
1: 
1:         DependencyManager dm = dd.getDependencyManager();
1:         providerInfo = dm.getPersistentProviderInfos(apl);
1:         dm.clearColumnInfoInProviders(apl);
1: 
/////////////////////////////////////////////////////////////////////////
1:                                             newReferencingName,
1:                                             providerInfo
commit:df73e36
/////////////////////////////////////////////////////////////////////////
1: 
1:                 // The WHEN clause must be a BOOLEAN expression.
1:                 whenClause.checkIsBoolean();
commit:51f910f
/////////////////////////////////////////////////////////////////////////
1:         // Throw an exception if the WHEN clause or the triggered SQL
1:         // statement references a table in the SESSION schema.
1:         if (referencesSessionSchema()) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         return isSessionSchema(triggerTableDescriptor.getSchemaName())
1:                 || actionNode.referencesSessionSchema()
1:                 || (whenClause != null && whenClause.referencesSessionSchema());
commit:6a17f80
/////////////////////////////////////////////////////////////////////////
1:         if (whenClause != null) {
1:             whenClause.accept(visitor);
1:         }
1: 
commit:d9878ca
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.Visitable;
/////////////////////////////////////////////////////////////////////////
0:     private final String        originalWhenText;
0:     private final String        originalActionText;
0:     private final int           whenOffset;
0:     private final int           actionOffset;
/////////////////////////////////////////////////////////////////////////
0:      * @param whenOffset            offset of start of WHEN clause
/////////////////////////////////////////////////////////////////////////
0:         int             whenOffset,
/////////////////////////////////////////////////////////////////////////
1:         this.originalWhenText = whenText;
1:         this.whenText = (whenText == null) ? null : whenText.trim();
0:         this.whenOffset = whenOffset;
1:         this.actionText = (actionText == null) ? null : actionText.trim();
/////////////////////////////////////////////////////////////////////////
1:                 ContextManager cm = getContextManager();
1:                 whenClause = whenClause.bindExpression(
1:                         new FromList(cm), new SubqueryList(cm),
1:                         new ArrayList<AggregateNode>(0));
/////////////////////////////////////////////////////////////////////////
1:     ** 2) convert trigger action text and WHEN clause text.  e.g.
/////////////////////////////////////////////////////////////////////////
1:         String transformedWhenText = null;
/////////////////////////////////////////////////////////////////////////
1: 
1:             // If there is a WHEN clause, we need to transform its text too.
1:             if (whenClause != null) {
1:                 transformedWhenText =
1:                     getDataDictionary().getTriggerActionString(
1:                             whenClause, oldTableName, newTableName,
1:                             originalWhenText, referencedColInts,
0:                             referencedColsInTriggerAction, whenOffset,
0:                             triggerTableDescriptor, triggerEventMask, true);
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:             transformedActionText = transformStatementTriggerText(
0:                     actionNode, originalActionText, actionOffset);
1:             if (whenClause != null) {
1:                 transformedWhenText = transformStatementTriggerText(
0:                         whenClause, originalWhenText, whenOffset);
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (whenClause != null && !transformedWhenText.equals(whenText)) {
1:             regenNode = true;
1:             whenText = transformedWhenText;
1:             whenClause = parseSearchCondition(whenText, true);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Transform the WHEN clause or the triggered SQL statement of a
1:      * statement trigger from its original shape to internal syntax where
1:      * references to transition tables are replaced with VTIs that return
1:      * the before or after image of the changed rows.
1:      *
1:      * @param node the syntax tree of the WHEN clause or the triggered
1:      *   SQL statement
1:      * @param originalText the original text of the WHEN clause or the
1:      *   triggered SQL statement
0:      * @param offset the offset of the WHEN clause or the triggered SQL
0:      *   statement within the CREATE TRIGGER statement
1:      * @return internal syntax for accessing before or after image of
1:      *   the changed rows
1:      * @throws StandardException if an error happens while performing the
1:      *   transformation
1:      */
1:     private String transformStatementTriggerText(
0:             Visitable node, String originalText, int offset)
1:         throws StandardException
1:     {
1:         int start = 0;
1:         StringBuilder newText = new StringBuilder();
1: 
1:         // For a statement trigger, we find all FromBaseTable nodes. If
1:         // the from table is NEW or OLD (or user designated alternates
1:         // REFERENCING), we turn them into a trigger table VTI.
0:         CollectNodesVisitor<FromBaseTable> visitor =
0:                 new CollectNodesVisitor<FromBaseTable>(FromBaseTable.class);
0:         node.accept(visitor);
0:         List<FromBaseTable> tabs = visitor.getList();
0:         Collections.sort(tabs, OFFSET_COMPARATOR);
0:         for (FromBaseTable fromTable : tabs) {
1:             String baseTableName = fromTable.getBaseTableName();
0:             if (baseTableName == null
0:                     || (!baseTableName.equals(oldTableName)
0:                             && !baseTableName.equals(newTableName))) {
0:                 // baseTableName is not the NEW or OLD table, so no need
0:                 // to do anything. Skip this table.
0:                 continue;
1:             }
1: 
1:             int tokBeginOffset = fromTable.getTableNameField().getBeginOffset();
1:             int tokEndOffset = fromTable.getTableNameField().getEndOffset();
0:             if (tokBeginOffset == -1) {
0:                 // Unknown offset. Skip this table.
0:                 continue;
1:             }
1: 
1:             // Check if this transition table is allowed in this trigger type.
1:             checkInvalidTriggerReference(baseTableName);
1: 
0:             // Replace the transition table name with a VTI.
1:             newText.append(originalText, start, tokBeginOffset - offset);
1:             newText.append(baseTableName.equals(oldTableName)
1:                 ? "new org.apache.derby.catalog.TriggerOldTransitionRows() "
1:                 : "new org.apache.derby.catalog.TriggerNewTransitionRows() ");
1: 
1:             // If the user supplied a correlation, then just
1:             // pick it up automatically; otherwise, supply
1:             // the default.
1:             if (fromTable.getCorrelationName() == null) {
1:                 newText.append(baseTableName).append(' ');
1:             }
1: 
0:             start = tokEndOffset - offset + 1;
1: 
0:             // If we are dealing with statement trigger, then we will read
0:             // all the columns from the trigger table since trigger will be
0:             // fired for any of the columns in the trigger table.
0:             int numberOfColsInTriggerTable =
0:                     triggerTableDescriptor.getNumberOfColumns();
0:             referencedColInts = new int[numberOfColsInTriggerTable];
0:             for (int j = 0; j < numberOfColsInTriggerTable; j++) {
0:                 referencedColInts[j] = j + 1;
1:             }
1:         }
1: 
1:         newText.append(originalText, start, originalText.length());
1: 
1:         return newText.toString();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                                             originalWhenText,
commit:29f8326
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 if (fromTable.getCorrelationName() == null)
commit:1725dd1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         this.whenText = (whenText == null) ? null : ("VALUES " + whenText);
0:         this.actionText = (actionText == null) ? null : actionText;
commit:a6d25cd
/////////////////////////////////////////////////////////////////////////
1:         CollectNodesVisitor<ColumnReference> visitor =
1:             new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
1:         for (ColumnReference cr : visitor.getList())
commit:234a2b6
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
0:             HashSet columnNames = new HashSet();
1: 				if (!columnNames.add(rc.getName()))
commit:47d4a4c
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
0: 	private	List				refClause;
/////////////////////////////////////////////////////////////////////////
0: 		this.refClause = (List) refClause;
/////////////////////////////////////////////////////////////////////////
1: 		if ((refClause == null) || refClause.isEmpty())
0: 		for (Iterator it = refClause.iterator(); it.hasNext(); )
0: 			TriggerReferencingStruct trn = (TriggerReferencingStruct) it.next();
/////////////////////////////////////////////////////////////////////////
0: 				for (Iterator it = refClause.iterator(); it.hasNext(); )
0: 							(TriggerReferencingStruct) it.next();
commit:c0a807c
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			List tabs = visitor.getList();
/////////////////////////////////////////////////////////////////////////
0:         List columnRefs = visitor.getList();
commit:ccb1894
/////////////////////////////////////////////////////////////////////////
0: import java.util.Collections;
1: import java.util.Comparator;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Comparator that can be used for sorting lists of FromBaseTables
1:      * on the position they have in the SQL query string.
1:      */
0:     private static final Comparator OFFSET_COMPARATOR = new Comparator() {
0:         public int compare(Object o1, Object o2) {
1:             // Return negative int, zero, or positive int if the offset of the
1:             // first table is less than, equal to, or greater than the offset
1:             // of the second table.
0:             return ((FromBaseTable) o1).getTableNameField().getBeginOffset() -
0:                     ((FromBaseTable) o2).getTableNameField().getBeginOffset();
1:         }
1:     };
1: 
/////////////////////////////////////////////////////////////////////////
0: 			Vector tabs = visitor.getList();
0: 			Collections.sort(tabs, OFFSET_COMPARATOR);
0: 			for (int i = 0; i < tabs.size(); i++)
0: 				FromBaseTable fromTable = (FromBaseTable) tabs.get(i);
/////////////////////////////////////////////////////////////////////////
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:374d58f
/////////////////////////////////////////////////////////////////////////
1: 			//then it means that a set of trigger columns are specified
1: 			//in the CREATE TRIGGER statement. This can only happen for
1: 			//an UPDATE trigger.
/////////////////////////////////////////////////////////////////////////
commit:179e593
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	**	DELETE FROM t WHERE c = old.c
1: 	**	DELETE FROM t WHERE c = org.apache.derby.iapi.db.Factory::
1: 	**		getTriggerExecutionContext().getOldRow().
1: 	**      getInt(columnNumberFor'C'inRuntimeResultset);
1: 	**	DELETE FROM t WHERE c in (SELECT c FROM OLD)
1: 	**	DELETE FROM t WHERE c in (
1: 	**      SELECT c FROM new TriggerOldTransitionTable OLD)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		String transformedActionText;
1: 		if (triggerCols != null && triggerCols.size() != 0) {
1: 			//If the trigger is defined on speific columns, then collect
1: 			//their column positions and ensure that those columns do
1: 			//indeed exist in the trigger table.
1: 			referencedColInts = new int[triggerCols.size()];
0: 			ResultColumn rc;
0: 			ColumnDescriptor cd;
1: 			//This is the most interesting case for us. If we are here, 
0: 			//then it means that the trigger is defined at the row level
0: 			//and a set of trigger columns are specified in the CREATE
0: 			//TRIGGER statement. This can only happen for an UPDATE
0: 			//trigger.
1: 			//eg
1: 			//CREATE TRIGGER tr1 AFTER UPDATE OF c12 ON table1 
1: 			//    REFERENCING OLD AS oldt NEW AS newt
1: 			//    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
1: 			
1: 			for (int i=0; i < triggerCols.size(); i++){
0: 				rc = (ResultColumn)triggerCols.elementAt(i);
0: 				cd = triggerTableDescriptor.getColumnDescriptor(rc.getName());
1: 				//Following will catch the case where an invalid trigger column
1: 				//has been specified in CREATE TRIGGER statement.
1: 				//CREATE TRIGGER tr1 AFTER UPDATE OF c1678 ON table1 
1: 				//    REFERENCING OLD AS oldt NEW AS newt
1: 				//    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
1: 				if (cd == null)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, 
1: 																rc.getName(),
1: 																tableName);
1: 				}
1: 				referencedColInts[i] = cd.getPosition();
1: 			}
1: 			// sort the list
1: 			java.util.Arrays.sort(referencedColInts);
1: 		}
1: 		
1: 			//Create an array for column positions of columns referenced in 
1: 			//trigger action. Initialize it to -1. The call to 
1: 			//DataDictoinary.getTriggerActionSPS will find out the actual 
1: 			//columns, if any, referenced in the trigger action and put their
1: 			//column positions in the array.
1: 			referencedColsInTriggerAction = new int[triggerTableDescriptor.getNumberOfColumns()];
1: 			java.util.Arrays.fill(referencedColsInTriggerAction, -1);
1: 			//Now that we have verified that are no invalid column references
1: 			//for trigger columns, let's go ahead and transform the OLD/NEW
1: 			//transient table references in the trigger action sql.
1: 			transformedActionText = getDataDictionary().getTriggerActionString(actionNode, 
1: 					oldTableName,
1: 					newTableName,
1: 					originalActionText,
1: 					referencedColInts,
1: 					referencedColsInTriggerAction,
0: 					actionOffset,
1: 					triggerTableDescriptor,
1: 					triggerEventMask,
0: 					true
1: 					);			
1: 			//Now that we know what columns we need for REFERENCEd columns in
1: 			//trigger action, we can get rid of -1 entries for the remaining 
1: 			//columns from trigger table. This information will be saved in
1: 			//SYSTRIGGERS and will be used at trigger execution time to decide 
1: 			//which columns need to be read into memory for trigger action
1: 			referencedColsInTriggerAction = justTheRequiredColumns(
1: 					referencedColsInTriggerAction);
1: 			//This is a table level trigger	        
0: 			//Total Number of columns in the trigger table
1: 			int numberOfColsInTriggerTable = triggerTableDescriptor.getNumberOfColumns();
0: 			StringBuffer newText = new StringBuffer();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			if (start < originalActionText.length())
1: 			{
0: 				newText.append(originalActionText.substring(start));
1: 			}
0: 			transformedActionText = newText.toString();
/////////////////////////////////////////////////////////////////////////
1: 		boolean regenNode = false;
1: 		if (!transformedActionText.equals(actionText))
1: 			regenNode = true;
1: 			actionText = transformedActionText;
/////////////////////////////////////////////////////////////////////////
1: 
0: 		QueryTreeNode[] sorted = (QueryTreeNode[]) refs.toArray(new QueryTreeNode[size]);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
commit:a6f9586
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/*
1: 	 * The following arrary will include columns that will cause the trigger to
1: 	 * fire. This information will get saved in SYSTRIGGERS.
1: 	 * 
1: 	 * The array will be null for all kinds of insert and delete triggers but
1: 	 * it will be non-null for a subset of update triggers.
1: 	 *  
1: 	 * For update triggers, the array will be null if no column list is 
1: 	 * supplied in the CREATE TRIGGER trigger column clause as shown below.
1: 	 * The UPDATE trigger below will fire no matter which column in table1
1: 	 * gets updated.
1: 	 * eg
1: 	 * CREATE TRIGGER tr1 AFTER UPDATE ON table1 
1: 	 *    REFERENCING OLD AS oldt NEW AS newt
1: 	 *    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
1: 	 * 
1: 	 * For update triggers, this array will be non-null if specific trigger
1: 	 * column(s) has been specified in the CREATE TRIGGER sql. The UPDATE
1: 	 * trigger below will fire when an update happens on column c12 in table1.
1: 	 * eg
1: 	 * CREATE TRIGGER tr1 AFTER UPDATE OF c12 ON table1 
1: 	 *    REFERENCING OLD AS oldt NEW AS newt
1: 	 *    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
1: 	 * 
1: 	 * Array referencedColInts along with referencedColsInTriggerAction will 
1: 	 * be used to determine which columns from the triggering table need to 
1: 	 * be read in when the trigger fires, thus making sure that we do not
1: 	 * read the columns from the trigger table that are not required for
1: 	 * trigger execution.
1: 	 */
1: 	
1: 	/*
1: 	 * The following array (which was added as part of DERBY-1482) will 
1: 	 * include columns referenced in the trigger action through the 
1: 	 * REFERENCING clause(old/new transition variables), in other trigger
1: 	 * action columns. This information will get saved in SYSTRIGGERS
1: 	 * (with the exception of triggers created in pre-10.7 dbs. For 
1: 	 * pre-10.7 dbs, this information will not get saved in SYSTRIGGERS
1: 	 * in order to maintain backward compatibility.
1: 	 * 
1: 	 * Unlike referencedColInts, this array can be non-null for all 3 types
1: 	 * of triggers, namely, INSERT, UPDATE AND DELETE triggers. This array
1: 	 * will be null if no columns in the trigger action are referencing
1: 	 * old/new transition variables
1: 	 * 
1: 	 * eg of a trigger in 10.7 and higher dbs which will cause 
1: 	 * referencedColsInTriggerAction to be null
1: 	 * CREATE TRIGGER tr1 NO CASCADE BEFORE UPDATE of c12 ON table1
1: 	 *    SELECT c24 FROM table2 WHERE table2.c21 = 1
1: 	 * 
1: 	 * eg of a trigger in 10.7 and higher dbs which will cause 
1: 	 * referencedColsInTriggerAction to be non-null
1: 	 * For the trigger below, old value of column c14 from trigger table is
1: 	 * used in the trigger action through old/new transition variables. A
1: 	 * note of this requirement to read c14 will be made in
1: 	 * referencedColsInTriggerAction array.
1: 	 * eg
1: 	 * CREATE TRIGGER tr1 AFTER UPDATE ON table1 
1: 	 *    REFERENCING OLD AS oldt NEW AS newt
1: 	 *    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
1: 	 * 
1: 	 * The exception to the rules above for trigger action columns information
1: 	 * in referencedColsInTriggerAction is a trigger that was created with
1: 	 * pre-10.7 release. Prior to 10.7, we did not collect any information
1: 	 * about trigger action columns. So, any of the 2 kinds of trigger shown
1: 	 * above prior to 10.7 will not have any trigger action column info on
1: 	 * them in SYSTRIGGERS table. In order to cover the pre-existing pre-10.7
1: 	 * triggers and all the other kinds of triggers, we will follow following
1: 	 * 4 rules during trigger execution.
1: 	 *   Rule1)If trigger column information is null, then read all the
1: 	 *   columns from trigger table into memory irrespective of whether
1: 	 *   there is any trigger action column information. 2 egs of such
1: 	 *   triggers
1: 	 *      create trigger tr1 after update on t1 for each row values(1);
1: 	 *      create trigger tr1 after update on t1 referencing old as oldt
1: 	 *      	for each row insert into t2 values(2,oldt.j,-2);
1: 	 *   Rule2)If trigger column information is available but no trigger
1: 	 *   action column information is found and no REFERENCES clause is
1: 	 *   used for the trigger, then only read the columns identified by
1: 	 *   the trigger column. eg
1: 	 *      create trigger tr1 after update of c1 on t1 
1: 	 *      	for each row values(1);
1: 	 *   Rule3)If trigger column information and trigger action column
1: 	 *   information both are not null, then only those columns will be
1: 	 *   read into memory. This is possible only for triggers created in
1: 	 *   release 10.7 or higher. Because prior to that we did not collect
1: 	 *   trigger action column informatoin. eg
1: 	 *      create trigger tr1 after update of c1 on t1
1: 	 *      	referencing old as oldt for each row
1: 	 *      	insert into t2 values(2,oldt.j,-2);
1: 	 *   Rule4)If trigger column information is available but no trigger
1: 	 *   action column information is found but REFERENCES clause is used
1: 	 *   for the trigger, then read all the columns from the trigger
1: 	 *   table. This will cover soft-upgrade and hard-upgrade scenario
1: 	 *   for triggers created pre-10.7. This rule prevents us from having
1: 	 *   special logic for soft-upgrade. Additionally, this logic makes
1: 	 *   invalidation of existing triggers unnecessary during
1: 	 *   hard-upgrade. The pre-10.7 created triggers will work just fine
1: 	 *   even though for some triggers, they would have trigger action
1: 	 *   columns missing from SYSTRIGGERS. A user can choose to drop and
1: 	 *   recreate such triggers to take advantage of Rule 3 which will
1: 	 *   avoid unnecessary column reads during trigger execution.
1: 	 *   eg trigger created prior to 10.7
1: 	 *      create trigger tr1 after update of c1 on t1
1: 	 *      	referencing old as oldt for each row
1: 	 *      	insert into t2 values(2,oldt.j,-2);
1: 	 *   To reiterate, Rule4) is there to cover triggers created with
1: 	 *   pre-10,7 releases but now that database has been
1: 	 *   hard/soft-upgraded to 10.7 or higher version. Prior to 10.7,
1: 	 *   we did not collect any information about trigger action columns.
1: 	 *   
1: 	 *   The only place we will need special code for soft-upgrade is during
1: 	 *   trigger creation. If we are in soft-upgrade mode, we want to make sure
1: 	 *   that we do not save information about trigger action columns in
1: 	 *   SYSTRIGGERS because the releases prior to 10.7 do not understand
1: 	 *   trigger action column information.
1: 	 *   
1: 	 * Array referencedColInts along with referencedColsInTriggerAction will 
1: 	 * be used to determine which columns from the triggering table needs to 
1: 	 * be read in when the trigger fires, thus making sure that we do not
1: 	 * read the columns from the trigger table that are not required for
1: 	 * trigger execution.
1: 	 */
1: 	private int[]				referencedColsInTriggerAction;
/////////////////////////////////////////////////////////////////////////
1: 	** BIND OLD/NEW TRANSITION TABLES/VARIABLES AND collect TRIGGER ACTION
1: 	** COLUMNS referenced through REFERECING CLAUSE in CREATE TRIGGER statement
/////////////////////////////////////////////////////////////////////////
1: 	** 4) collect all column references in trigger action through new/old 
1: 	** transition variables. Information about them will be saved in
1: 	** SYSTRIGGERS table DERBY-1482(if we are dealing with pre-10.7 db, then we
1: 	** will not put any information about trigger action columns in the system
1: 	** table to ensure backward compatibility). This information along with the
1: 	** trigger columns will decide what columns from the trigger table will be
1: 	** fetched into memory during trigger execution.
1: 	**
1: 	** 5) reparse the new action text
/////////////////////////////////////////////////////////////////////////
1: 	** easier to just generate the sql and rebind.
1: 	**
0: 	** More information on step 4 above. 
0: 	** DERBY-1482 One of the work done by this method for row level triggers
0: 	** is to find the columns which are referenced in the trigger action 
0: 	** through the REFERENCES clause ie thro old/new transition variables.
0: 	** This information will be saved in SYSTRIGGERS so it can be retrieved
0: 	** during the trigger execution time. The purpose of this is to recognize
0: 	** what columns from the trigger table should be read in during trigger
0: 	** execution. Before these code change, during trigger execution, Derby
0: 	** was opting to read all the columns from the trigger table even if they
0: 	** were not all referenced during the trigger execution. This caused Derby
0: 	** to run into OOM at times when it could really be avoided.
1: 	**
0: 	** We go through the trigger action text and collect the column positions
0: 	** of all the REFERENCEd columns through new/old transition variables. We
0: 	** keep that information in SYSTRIGGERS. At runtime, when the trigger is
0: 	** fired, we will look at this information along with trigger columns from
0: 	** the trigger definition and only fetch those columns into memory rather
0: 	** than all the columns from the trigger table.
0: 	** This is especially useful when the table has LOB columns and those
0: 	** columns are not referenced in the trigger action and are not recognized
0: 	** as trigger columns. For such cases, we can avoid reading large values of
0: 	** LOB columns into memory and thus avoiding possibly running into OOM 
0: 	** errors.
1: 	** 
0: 	** If there are no trigger columns defined on the trigger, we will read all
0: 	** the columns from the trigger table when the trigger fires because no
0: 	** specific columns were identified as trigger column by the user. The 
0: 	** other case where we will opt to read all the columns are when trigger
0: 	** columns and REFERENCING clause is identified for the trigger but there
0: 	** is no trigger action column information in SYSTRIGGERS. This can happen
0: 	** for triggers created prior to 10.7 release and later that database got
0: 	** hard/soft-upgraded to 10.7 or higher release.
/////////////////////////////////////////////////////////////////////////
0: 		//Total Number of columns in the trigger table
0: 		int numberOfColsInTriggerTable = triggerTableDescriptor.getNumberOfColumns();
1: 
0: 			ResultColumn rc;
1: 			
0: 			//The purpose of following array(triggerActionColsOnly) is to
0: 			//identify all the columns from the trigger action which are
0: 			//referenced though old/new transition variables(in other words,
0: 			//accessed through the REFERENCING clause section of
0: 			//CREATE TRIGGER sql). This array will be initialized to -1 at the
0: 			//beginning. By the end of this method, all the columns referenced
0: 			//by the trigger action through the REFERENCING clause will have
0: 			//their column positions in the trigger table noted in this array.
0: 			//eg
0: 			//CREATE TABLE table1 (c11 int, c12 int, c13 int, c14 int, c15 int);
0: 			//CREATE TABLE table2 (c21 int, c22 int, c23 int, c24 int, c25 int);
0: 			//CREATE TRIGGER tr1 AFTER UPDATE OF c12 ON table1 
0: 			//    REFERENCING OLD AS oldt NEW AS newt
0: 			//    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
0: 			//For the trigger above, triggerActionColsOnly will finally have 
0: 			//[-1,-1,-1,4,-1]. We will note all the entries for this array
0: 			//which are not -1 into SYSTRIGGERS(-1 indiciates columns with
0: 			//those column positions from the trigger table are not being
0: 			//referenced in the trigger action through the old/new transition
0: 			//variables.
0: 			int[] triggerActionColsOnly = new int[numberOfColsInTriggerTable];
0: 			for (int i=0; i < numberOfColsInTriggerTable; i++)
0: 				triggerActionColsOnly[i]=-1;
1: 			
0: 			//The purpose of following array(triggerColsAndTriggerActionCols)
0: 			//is to identify all the trigger columns and all the columns from
0: 			//the trigger action which are referenced though old/new 
0: 			//transition variables(in other words, accessed through the
0: 			//REFERENCING clause section of CREATE TRIGGER sql). This array 
0: 			//will be initialized to -1 at the beginning. By the end of this
0: 			//method, all the columns referenced by the trigger action 
0: 			//through the REFERENCING clause and all the trigger columns will
0: 			//have their column positions in the trigger table noted in this
0: 			//array.
0: 			//eg
0: 			//CREATE TRIGGER tr1 AFTER UPDATE OF c12 ON table1 
0: 			//    REFERENCING OLD AS oldt NEW AS newt
0: 			//    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
0: 			//For the trigger above, triggerColsAndTriggerActionCols will
0: 			//finally have [-1,2,-1,4,-1] This list will include all the
0: 			//columns that need to be fetched into memory during trigger
0: 			//execution. All the columns with their entries marked -1 will
0: 			//not be read into memory because they are not referenced in the
0: 			//trigger action through old/new transition variables and they are
0: 			//not recognized as trigger columns.
0: 			int[] triggerColsAndTriggerActionCols = new int[numberOfColsInTriggerTable];
0: 			for (int i=0; i < numberOfColsInTriggerTable; i++) 
0: 				triggerColsAndTriggerActionCols[i]=-1;
1: 			
0: 			if (triggerCols == null || triggerCols.size() == 0) {
0: 				//This means that even though the trigger is defined at row 
0: 				//level, it is either an INSERT/DELETE trigger. Or it is an
0: 				//UPDATE trigger with no specific column(s) identified as the
0: 				//trigger column(s). In these cases, Derby is going to read all
0: 				//the columns from the trigger table during trigger execution.
0: 				//eg of an UPDATE trigger with no specific trigger column(s) 
0: 				// CREATE TRIGGER tr1 AFTER UPDATE ON table1 
0: 				//    REFERENCING OLD AS oldt NEW AS newt
0: 				//    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
1: 				for (int i=0; i < numberOfColsInTriggerTable; i++) {
0: 					triggerColsAndTriggerActionCols[i]=i+1;
1: 				}
0: 			} else {
0: 				//This is the most interesting case for us. If we are here, 
0: 				//then it means that the trigger is defined at the row level
0: 				//and a set of trigger columns are specified in the CREATE
0: 				//TRIGGER statement. This can only happen for an UPDATE
0: 				//trigger.
0: 				//eg
0: 				//CREATE TRIGGER tr1 AFTER UPDATE OF c12 ON table1 
0: 				//    REFERENCING OLD AS oldt NEW AS newt
0: 				//    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
1: 				
0: 				for (int i=0; i < triggerCols.size(); i++){
0: 					rc = (ResultColumn)triggerCols.elementAt(i);
1: 					ColumnDescriptor cd = triggerTableDescriptor.getColumnDescriptor(rc.getName());
0: 					//Following will catch the case where an invalid trigger column
0: 					//has been specified in CREATE TRIGGER statement.
0: 					//CREATE TRIGGER tr1 AFTER UPDATE OF c1678 ON table1 
0: 					//    REFERENCING OLD AS oldt NEW AS newt
0: 					//    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
1: 					if (cd == null)
1: 					{
1: 						throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, 
1: 																	rc.getName(),
1: 																	tableName);
1: 					}
0: 					//Make a note of this trigger column's column position in
0: 					//triggerColsAndTriggerActionCols. This will tell us that 
0: 					//this column needs to be read in when the trigger fires.
0: 					//eg for the CREATE TRIGGER below, we will make a note of
0: 					//column c12's position in triggerColsAndTriggerActionCols
0: 					//eg
0: 					//CREATE TRIGGER tr1 AFTER UPDATE OF c12 ON table1 
0: 					//    REFERENCING OLD AS oldt NEW AS newt
0: 					//    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
0: 					triggerColsAndTriggerActionCols[cd.getPosition()-1]=cd.getPosition();				
1: 				}
1: 			}
0: 			//By this time, we have collected the positions of the trigger
0: 			//columns in array triggerColsAndTriggerActionCols. Now we need
0: 			//to start looking at the columns in trigger action to collect
0: 			//all the columns referenced through REFERENCES clause. These
0: 			//columns will be noted in triggerColsAndTriggerActionCols and
0: 			//triggerActionColsOnly arrays.
1: 
/////////////////////////////////////////////////////////////////////////
0: 			//At the end of the for loop below, we will have both arrays
0: 			//triggerColsAndTriggerActionCols & triggerActionColsOnly
0: 			//filled up with the column positions of the columns which are
0: 			//either trigger columns or triger action columns which are
0: 			//referenced through old/new transition variables. 
0: 			//eg
0: 			//CREATE TRIGGER tr1 AFTER UPDATE OF c12 ON table1 
0: 			//    REFERENCING OLD AS oldt NEW AS newt
0: 			//    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
0: 			//For the above trigger, before the for loop below, the contents
0: 			//of the 2 arrays will be as follows
0: 			//triggerActionColsOnly [-1,-1,-1,-1,-1]
0: 			//triggerColsAndTriggerActionCols [-1,2,-1,-1,-1]
0: 			//After the for loop below, the 2 arrays will look as follows
0: 			//triggerActionColsOnly [-1,-1,-1,4,-1]
0: 			//triggerColsAndTriggerActionCols [-1,2,-1,4,-1]
0: 			//If the database is at 10.6 or earlier version(meaning we are in
0: 			//soft-upgrade mode), then we do not want to collect any 
0: 			//information about trigger action columns. The collection and 
0: 			//usage of trigger action columns was introduced in 10.7 DERBY-1482
0: 			boolean in10_7_orHigherVersion =
0: 					getLanguageConnectionContext().getDataDictionary().checkVersion(
0: 							DataDictionary.DD_VERSION_DERBY_10_7,null);
0: 			for (int i = 0; i < cols.length; i++)
1: 			{
0: 				ColumnReference ref = (ColumnReference) cols[i];
1: 				/*
0: 				** Only occurrences of those OLD/NEW transition tables/variables 
0: 				** are of interest here.  There may be intermediate nodes in the 
0: 				** parse tree that have its own RCL which contains copy of 
0: 				** column references(CR) from other nodes. e.g.:  
1: 				**
0: 				** CREATE TRIGGER tt 
0: 				** AFTER INSERT ON x
0: 				** REFERENCING NEW AS n 
0: 				** FOR EACH ROW
0: 				**    INSERT INTO y VALUES (n.i), (999), (333);
1: 				** 
0: 				** The above trigger action will result in InsertNode that 
0: 				** contains a UnionNode of RowResultSetNodes.  The UnionNode
0: 				** will have a copy of the CRs from its left child and those CRs 
0: 				** will not have its beginOffset set which indicates they are 
0: 				** not relevant for the conversion processing here, so we can 
0: 				** safely skip them. 
1: 				*/
0: 				if (ref.getBeginOffset() == -1) 
1: 				{
0: 					continue;
1: 				}
1: 
0: 				TableName tableName = ref.getTableNameNode();
0: 				if ((tableName == null) ||
0: 					((oldTableName == null || !oldTableName.equals(tableName.getTableName())) &&
0: 					(newTableName == null || !newTableName.equals(tableName.getTableName()))))
1: 				{
0: 					continue;
1: 				}
1: 
0: 				if (tableName.getBeginOffset() == -1)
1: 				{
0: 					continue;
1: 				}
1: 
0: 				checkInvalidTriggerReference(tableName.getTableName());
0: 				String colName = ref.getColumnName();
1: 
0: 				ColumnDescriptor triggerColDesc;
0: 				//Following will catch the case where an invalid column is
0: 				//used in trigger action through the REFERENCING clause. The
0: 				//following tigger is trying to use oldt.c13 but there is no
0: 				//column c13 in trigger table table1
0: 				//CREATE TRIGGER tr1 AFTER UPDATE OF c12 ON table1 
0: 				//    REFERENCING OLD AS oldt NEW AS newt
0: 				//    FOR EACH ROW UPDATE table2 SET c24=oldt.c14567;
0: 				if ((triggerColDesc = triggerTableDescriptor.getColumnDescriptor(colName)) == 
0: 	                null) {
0: 					throw StandardException.newException(
0: 			                SQLState.LANG_COLUMN_NOT_FOUND, tableName+"."+colName);
1: 					}
1: 
0: 				if (in10_7_orHigherVersion) {
0: 					int triggerColDescPosition = triggerColDesc.getPosition();
0: 					triggerColsAndTriggerActionCols[triggerColDescPosition-1]=triggerColDescPosition;
0: 					triggerActionColsOnly[triggerColDescPosition-1]=triggerColDescPosition;
1: 				}
1: 			}
1: 
0: 			//Now that we know what columns we need for trigger columns and
0: 			//trigger action columns, we can get rid of remaining -1 entries
0: 			//for the remaining columns from trigger table.
0: 			//eg
0: 			//CREATE TRIGGER tr1 AFTER UPDATE OF c12 ON table1 
0: 			//    REFERENCING OLD AS oldt NEW AS newt
0: 			//    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
0: 			//For the above trigger, before the justTheRequiredColumns() call,
0: 			//the content of triggerColsAndTriggerActionCols array were as
0: 			//follows [-1, 2, -1, 4, -1]
0: 			//After the justTheRequiredColumns() call below, 
0: 			//triggerColsAndTriggerActionCols will have [2,4]. What this means
0: 			//that, at run time, during trigger execution, these are the only
0: 			//2 column positions that will be read into memory from the
0: 			//trigger table. The columns in other column positions are not
0: 			//needed for trigger execution.
0: 			triggerColsAndTriggerActionCols = justTheRequiredColumns(triggerColsAndTriggerActionCols);
1: 
/////////////////////////////////////////////////////////////////////////
0: 				int colPositionInRuntimeResultSet = -1;
0: 				ColumnDescriptor triggerColDesc = triggerTableDescriptor.getColumnDescriptor(colName);
0: 				int colPositionInTriggerTable = triggerColDesc.getPosition();
1: 
0: 				//This part of code is little tricky and following will help
0: 				//understand what mapping is happening here.
0: 				//eg
0: 				//CREATE TRIGGER tr1 AFTER UPDATE OF c12 ON table1 
0: 				//    REFERENCING OLD AS oldt NEW AS newt
0: 				//    FOR EACH ROW UPDATE table2 SET c24=oldt.c14;
0: 				//For the above trigger, triggerColsAndTriggerActionCols will 
0: 				//have [2,4]. What this means that, at run time, during trigger
0: 				//execution, these are the only 2 column positions that will be
0: 				//read into memory from the trigger table. The columns in other
0: 				//column positions are not needed for trigger execution. But
0: 				//even though column positions in original trigger table are 2
0: 				//and 4, their relative column positions in the columns read at
0: 				//execution time is really [1,2]. At run time, when the trigger
0: 				//gets fired, column position 2 from the trigger table will be
0: 				//read as the first column and column position 4 from the
0: 				//trigger table will be read as the second column. And those
0: 				//relative column positions at runtime is what should be used
0: 				//during trigger action conversion from
0: 				//UPDATE table2 SET c24=oldt.c14
0: 				//to
0: 				//UPDATE table2 SET c24=org.apache.derby.iapi.db.Factory::getTriggerExecutionContext().getOldRow().getInt(2)
0: 				//Note that the generated code above refers to column c14 from
0: 				//table1 by position 2 rather than position 4. Column c14's
0: 				//column position in table1 is 4 but in the relative columns
0: 				//that will be fetched during trigger execution, it's position
0: 				//is 2. That is what the following code is doing.
0: 				if (in10_7_orHigherVersion && triggerColsAndTriggerActionCols != null){
0: 					for (int j=0; j<triggerColsAndTriggerActionCols.length; j++){
0: 						if (triggerColsAndTriggerActionCols[j] == colPositionInTriggerTable)
0: 							colPositionInRuntimeResultSet=j+1;
1: 					}
1: 				} else
0: 					colPositionInRuntimeResultSet=colPositionInTriggerTable;
1: 
0: 				newText.append(genColumnReferenceSQL(dd, colName, 
0: 						tableName.getTableName(), 
0: 						tableName.getTableName().equals(oldTableName),
0: 						colPositionInRuntimeResultSet));
0: 			//By this point, we are finished transforming the trigger action if
0: 			//it has any references to old/new transition variables.
1: 
0: 			//Now that we know what columns we need for trigger action columns,
0: 			//we can get rid of -1 entries for the remaining columns from
0: 			//trigger table.
0: 			//The final step is to put all the column positions from the 
0: 			//trigger table of the columns which are referenced in the trigger
0: 			//action through old/new transition variables. This information
0: 			//will be saved in SYSTRIGGERS and will be used at trigger 
0: 			//execution time to decide which columns need to be read into
0: 			//memory for trigger action
0: 			referencedColsInTriggerAction = justTheRequiredColumns(triggerActionColsOnly);
/////////////////////////////////////////////////////////////////////////
0: 				//If we are dealing with statement trigger, then we will read 
0: 				//all the columns from the trigger table since trigger will be
0: 				//fired for any of the columns in the trigger table.
0: 				referencedColInts= new int[numberOfColsInTriggerTable];
0: 				for (int j=0; j < numberOfColsInTriggerTable; j++)
0: 					referencedColInts[j]=j+1;
1: 		if (referencedColsInTriggerAction != null)
1: 			java.util.Arrays.sort(referencedColsInTriggerAction);
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 * The arrary passed will have either -1 or a column position as it's 
1: 	 * elements. If the array only has -1 as for all it's elements, then
1: 	 * this method will return null. Otherwise, the method will create a
1: 	 * new arrary with all -1 entries removed from the original arrary.
1: 	 */
1: 	private int[] justTheRequiredColumns(int[] columnsArrary) {
1: 		int countOfColsRefedInArray = 0;
0: 		int numberOfColsInTriggerTable = triggerTableDescriptor.getNumberOfColumns();
1: 
1: 		//Count number of non -1 entries
1: 		for (int i=0; i < numberOfColsInTriggerTable; i++) {
1: 			if (columnsArrary[i] != -1)
1: 				countOfColsRefedInArray++;
1: 		}
1: 
1: 		if (countOfColsRefedInArray > 0){
1: 			int[] tempArrayOfNeededColumns = new int[countOfColsRefedInArray];
1: 			int j=0;
1: 			for (int i=0; i < numberOfColsInTriggerTable; i++) {
1: 				if (columnsArrary[i] != -1)
1: 					tempArrayOfNeededColumns[j++] = columnsArrary[i];
1: 			}
1: 			return tempArrayOfNeededColumns;
0: 		} else
1: 			return null;
1: 	}
1: 	/*
/////////////////////////////////////////////////////////////////////////
0: 		boolean			isOldTable,
0: 		int				colPositionInRuntimeResultSet
/////////////////////////////////////////////////////////////////////////
0:             methodCall.append(colPositionInRuntimeResultSet);
/////////////////////////////////////////////////////////////////////////
0:             methodCall.append(colPositionInRuntimeResultSet);
/////////////////////////////////////////////////////////////////////////
1: 											referencedColsInTriggerAction,
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1: 
1:             for (ResultColumn rc : triggerCols)
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                 ResultColumn rc = triggerCols.elementAt(i);
1:                 ColumnDescriptor cd =
1:                     triggerTableDescriptor.getColumnDescriptor(rc.getName());
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
/////////////////////////////////////////////////////////////////////////
1: class CreateTriggerNode extends DDLStatementNode
/////////////////////////////////////////////////////////////////////////
1:     private List<TriggerReferencingStruct> refClause;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a CreateTriggerNode
/////////////////////////////////////////////////////////////////////////
1:      * @param cm                    context manager
1:     CreateTriggerNode
1:         TableName       triggerName,
1:         TableName       tableName,
1:         int             triggerEventMask,
1:         ResultColumnList triggerCols,
1:         boolean         isBefore,
1:         boolean         isRow,
1:         boolean         isEnabled,
1:         List<TriggerReferencingStruct> refClause,
1:         ValueNode       whenClause,
1:         String          whenText,
0:         int             whenOffset,
1:         StatementNode   actionNode,
1:         String          actionText,
0:         int             actionOffset,
1:         ContextManager  cm
1:         super(triggerName, cm);
0:         setNodeType(C_NodeTypes.CREATE_TRIGGER_NODE);
1:         this.triggerName = triggerName;
1:         this.tableName = tableName;
1:         this.triggerEventMask = triggerEventMask;
1:         this.triggerCols = triggerCols;
1:         this.isBefore = isBefore;
1:         this.isRow = isRow;
1:         this.isEnabled = isEnabled;
1:         this.refClause = refClause;
1:         this.whenClause = whenClause;
0:         this.whenText = (whenText == null) ? null : whenText.trim();
1:         this.actionNode = actionNode;
1:         this.originalActionText = actionText;
0:         this.actionText = (actionText == null) ? null : actionText.trim();
0:         this.actionOffset = actionOffset;
1:         this.implicitCreateSchema = true;
1:     String statementToString()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:             StringBuilder newText = new StringBuilder();
/////////////////////////////////////////////////////////////////////////
1:         for (TriggerReferencingStruct trn : refClause)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                                             compSchemaDescriptor.getUUID(),
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 StringBuilder buf = new StringBuilder();
1:                 for (TriggerReferencingStruct trn : refClause)
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:9d5bd0e
/////////////////////////////////////////////////////////////////////////
1:             HashSet<String> columnNames = new HashSet<String>();
/////////////////////////////////////////////////////////////////////////
1:     private static final Comparator<FromBaseTable> OFFSET_COMPARATOR = new Comparator<FromBaseTable>() {
1:         public int compare(FromBaseTable o1, FromBaseTable o2) {
1:             return o1.getTableNameField().getBeginOffset() -
1:                     o2.getTableNameField().getBeginOffset();
/////////////////////////////////////////////////////////////////////////
0: 			CollectNodesVisitor<FromBaseTable> visitor = new CollectNodesVisitor<FromBaseTable>(FromBaseTable.class);
0: 			List<FromBaseTable> tabs = visitor.getList();
0: 				FromBaseTable fromTable = tabs.get(i);
commit:e735448
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
/////////////////////////////////////////////////////////////////////////
1:         // the actions of before triggers may not reference generated columns
1:         if ( isBefore ) { forbidActionsOnGenCols(); }
1:         
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * Forbid references to generated columns in the actions of BEFORE triggers.
1:      * This is DERBY-3948, enforcing the following section of the SQL standard:
1:      * part 2, section 11.39 (<trigger definition>), syntax rule 12c:
1:      *
1:      * <blockquote>
1:      *    12) If BEFORE is specified, then:
1:      * :
1:      * c) The <triggered action> shall not contain a <field reference> that
1:      * references a field in the new transition variable corresponding to a
1:      * generated column of T. 
1:      * </blockquote>
1:      */
1:     private void    forbidActionsOnGenCols()
1:         throws StandardException
1:     {
1:         ColumnDescriptorList    generatedColumns = triggerTableDescriptor.getGeneratedColumns();
1:         int                                 genColCount = generatedColumns.size();
1: 
1:         if ( genColCount == 0 ) { return; }
1: 
0:         CollectNodesVisitor     visitor = new CollectNodesVisitor( ColumnReference.class );
1: 
1:         actionNode.accept( visitor );
1: 
0:         Vector                   columnRefs = visitor.getList();
0:         int                             colRefCount = columnRefs.size();
1: 
0:         for ( int crf_idx = 0; crf_idx < colRefCount; crf_idx++ )
1:         {
0:             ColumnReference     cr = (ColumnReference) columnRefs.get( crf_idx );
1:             String  colRefName = cr.getColumnName();
1:             String  tabRefName = cr.getTableName();
1: 
1:             for ( int gc_idx = 0; gc_idx < genColCount; gc_idx++ )
1:             {
1:                 String  genColName = generatedColumns.elementAt( gc_idx ).getColumnName();
1: 
1:                 if ( genColName.equals( colRefName ) && equals( newTableName, tabRefName ) )
1:                 {
1:                     throw StandardException.newException( SQLState.LANG_GEN_COL_BEFORE_TRIG, genColName );
1:                 }
1:             }
1:         }
1:     }
1: 
1:     /*
1:      * Compare two strings.
1:      */
1:     private boolean equals( String left, String right )
1:     {
1:         if ( left == null ) { return (right == null); }
1:         else
1:         {
1:             return left.equals( right );
1:         }
1:     }
1:     
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:925ae99
/////////////////////////////////////////////////////////////////////////
1: 			// OLD TABLE and NEW TABLE not allowed for BEFORE triggers.
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:1198ab7
/////////////////////////////////////////////////////////////////////////
0: 		if ((colDesc = triggerTableDescriptor.getColumnDescriptor(colName)) == 
0:                 null)
0: 			throw StandardException.newException(
0:                 SQLState.LANG_COLUMN_NOT_FOUND, tabName+"."+colName);
0: 		** 		CAST (org.apache.derby.iapi.db.Factory::
/////////////////////////////////////////////////////////////////////////
0:         **
1:         */
0: 		DataTypeDescriptor  dts     = colDesc.getType();
0: 		TypeId              typeId  = dts.getTypeId();
0:         if (!typeId.isXMLTypeId())
1:         {
1: 
0:             StringBuffer methodCall = new StringBuffer();
0:             methodCall.append(
0:                 "CAST (org.apache.derby.iapi.db.Factory::getTriggerExecutionContext().");
0:             methodCall.append(isOldTable ? "getOldRow()" : "getNewRow()");
0:             methodCall.append(".getObject(");
0:             methodCall.append(colDesc.getPosition());
0:             methodCall.append(") AS ");
1: 
1:             /*
0:             ** getSQLString() returns <typeName> 
0:             ** for user types, so call getSQLTypeName in that
0:             ** case.
1:             */
0:             methodCall.append(
0:                 (typeId.userType() ? 
0:                      typeId.getSQLTypeName() : dts.getSQLstring()));
1:             
0:             methodCall.append(") ");
1: 
0:             return methodCall.toString();
1:         }
1:         else
1:         {
0:             /*  DERBY-2350
0:             **
0:             **  Triggers currently use jdbc 1.2 to access columns.  The default
0:             **  uses getObject() which is not supported for an XML type until
0:             **  jdbc 4.  In the meantime use getString() and then call 
0:             **  XMLPARSE() on the string to get the type.  See Derby issue and
0:             **  http://wiki.apache.org/db-derby/TriggerImplementation , for
0:             **  better long term solutions.  Long term I think changing the
0:             **  trigger architecture to not rely on jdbc, but instead on an
0:             **  internal direct access interface to execution nodes would be
0:             **  best future direction, but believe such a change appropriate
0:             **  for a major release, not a bug fix.
0:             **
0:             **  Rather than the above described code generation, use the 
0:             **  following for XML types to generate an XML column from the
0:             **  old or new row.
0:             ** 
0:             **          XMLPARSE(DOCUMENT
0:             **              CAST (org.apache.derby.iapi.db.Factory::
0:             **                  getTriggerExecutionContext().getNewRow().
0:             **                      getString(<colPosition>) AS CLOB)  
0:             **                        PRESERVE WHITESPACE)
1:             */
1: 
0:             StringBuffer methodCall = new StringBuffer();
0:             methodCall.append("XMLPARSE(DOCUMENT CAST( ");
0:             methodCall.append(
0:                 "org.apache.derby.iapi.db.Factory::getTriggerExecutionContext().");
0:             methodCall.append(isOldTable ? "getOldRow()" : "getNewRow()");
0:             methodCall.append(".getString(");
0:             methodCall.append(colDesc.getPosition());
0:             methodCall.append(") AS CLOB) PRESERVE WHITESPACE ) ");
1: 
0:             return methodCall.toString();
1:         }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4fb136d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.conn.Authorizer;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
1: 
commit:8a93440
/////////////////////////////////////////////////////////////////////////
1: 	private	ValueNode		    whenClause;
/////////////////////////////////////////////////////////////////////////
0: 		this.whenClause = (ValueNode) whenClause;
/////////////////////////////////////////////////////////////////////////
1: 			actionNode.bindStatement();
0: 			/* when clause is always null
1: 			*/
commit:be0b54f
/////////////////////////////////////////////////////////////////////////
1: 			actionNode = parseStatement(actionText, true);
/////////////////////////////////////////////////////////////////////////
commit:cc770d8
/////////////////////////////////////////////////////////////////////////
1: 	public void bindStatement() throws StandardException
/////////////////////////////////////////////////////////////////////////
commit:3b1291b
/////////////////////////////////////////////////////////////////////////
1: 			
1: 			// For before triggers, the action statement cannot contain calls
1: 			// to procedures that modify SQL data. If the action statement 
1: 			// contains a procedure call, this reliability will be used during
1: 			// bind of the call statement node. 
1: 			if(isBefore)
1: 				compilerContext.setReliability(CompilerContext.MODIFIES_SQL_DATA_PROCEDURE_ILLEGAL);
1: 					
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
1: 		if (isPrivilegeCollectionRequired())
1: 		{
1: 			compilerContext.pushCurrentPrivType(Authorizer.TRIGGER_PRIV);
1: 			compilerContext.addRequiredTablePriv(triggerTableDescriptor);
1: 			compilerContext.popCurrentPrivType();			
1: 		}
commit:7952562
/////////////////////////////////////////////////////////////////////////
0: 		**				getObject(<colPosition>) AS DECIMAL(6,2))
0:         **
0:         ** Column position is used to avoid the wrong column being
0:         ** selected problem (DERBY-1258) caused by the case insensitive
0:         ** JDBC rules for fetching a column by name.
/////////////////////////////////////////////////////////////////////////
0: 		methodCall.append("CAST (org.apache.derby.iapi.db.Factory::getTriggerExecutionContext().");
0: 		methodCall.append(".getObject(");
0:         methodCall.append(colDesc.getPosition());
0:         methodCall.append(") AS ");
/////////////////////////////////////////////////////////////////////////
0: 		  (typeId.userType() ? typeId.getSQLTypeName() : dts.getSQLstring()));
1:         
0:         methodCall.append(") ");
commit:0061383
/////////////////////////////////////////////////////////////////////////
0: public class CreateTriggerNode extends DDLStatementNode
commit:08d6ce2
/////////////////////////////////////////////////////////////////////////
0: 			actionNode = (StatementNode)reparseTriggerText();
/////////////////////////////////////////////////////////////////////////
0: 	private QueryTreeNode reparseTriggerText() throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 			return QueryTreeNode.parseQueryText(newCC, actionText, (Object[])null, lcc);
/////////////////////////////////////////////////////////////////////////
0: 		methodCall.append(
0: 		  (typeId.userType() ? typeId.getSQLTypeName() : dts.getSQLstring())
0: 				 + ") ");
commit:7f1493a
/////////////////////////////////////////////////////////////////////////
0: 				int tokBeginOffset = tableName.getBeginOffset();
0: 				int tokEndOffset = tableName.getEndOffset();
/////////////////////////////////////////////////////////////////////////
0: 				int columnLength = ref.getEndOffset() - ref.getBeginOffset() + 1;
/////////////////////////////////////////////////////////////////////////
0: 				int tokBeginOffset = fromTable.getTableNameField().getBeginOffset();
0: 				int tokEndOffset = fromTable.getTableNameField().getEndOffset();
/////////////////////////////////////////////////////////////////////////
0: 					 sorted[j].getBeginOffset() > 
0: 					 sorted[j+1].getBeginOffset()
0: 					 ((FromBaseTable) sorted[j]).getTableNameField().getBeginOffset() > 
0: 					 ((FromBaseTable) sorted[j+1]).getTableNameField().getBeginOffset()
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.CreateTriggerNode
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.Parser;
1: 
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.depend.Dependent;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: 
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.catalog.UUID;
0: import java.sql.Timestamp;
0: import java.sql.Types;
0: import java.util.Enumeration;
0: import java.util.Hashtable;
0: import java.util.Vector;
1: 
1: /**
1:  * A CreateTriggerNode is the root of a QueryTree 
1:  * that represents a CREATE TRIGGER
1:  * statement.
1:  *
0:  * @author jamie
1:  */
1: 
0: public class CreateTriggerNode extends CreateStatementNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	private	TableName			triggerName;
1: 	private	TableName			tableName;
1: 	private	int					triggerEventMask;
1: 	private ResultColumnList	triggerCols;
1: 	private	boolean				isBefore;
1: 	private	boolean				isRow;
1: 	private	boolean				isEnabled;
0: 	private	Vector				refClause;
0: 	private	QueryTreeNode		whenClause;
1: 	private	String				whenText;
0: 	private	int					whenOffset;
1: 	private	StatementNode		actionNode;
1: 	private	String				actionText;
0: 	private	String				originalActionText; // text w/o trim of spaces
0: 	private	int					actionOffset;
1: 
1: 	private SchemaDescriptor	triggerSchemaDescriptor;
1: 	private SchemaDescriptor	compSchemaDescriptor;
1: 	private int[]				referencedColInts;
1: 	private TableDescriptor		triggerTableDescriptor;
0: 	private	UUID				actionCompSchemaId;
1: 
1: 	/*
1: 	** Names of old and new table.  By default we have
1: 	** OLD/old and NEW/new.  The casing is dependent on 
1: 	** the language connection context casing as the rest
1:     ** of other code. Therefore we will set the value of the 
1:     ** String at the init() time.
1:     ** However, if there is a referencing clause
1: 	** we will reset these values to be whatever the user
1: 	** wants.
1: 	*/
1: 	private String oldTableName;
1: 	private String newTableName;
1: 
1: 	private boolean oldTableInReferencingClause;
1: 	private boolean newTableInReferencingClause;
1: 
1: 
1: 	/**
0: 	 * Initializer for a CreateTriggerNode
1: 	 *
1: 	 * @param triggerName			name of the trigger	
1: 	 * @param tableName				name of the table which the trigger is declared upon	
1: 	 * @param triggerEventMask		TriggerDescriptor.TRIGGER_EVENT_XXX
1: 	 * @param triggerCols			columns trigger is to fire upon.  Valid
1: 	 *								for UPDATE case only.
1: 	 * @param isBefore				is before trigger (false for after)
1: 	 * @param isRow					true for row trigger, false for statement
1: 	 * @param isEnabled				true if enabled
1: 	 * @param refClause				the referencing clause
1: 	 * @param whenClause			the WHEN clause tree
1: 	 * @param whenText				the text of the WHEN clause
0: 	 * @param whenOffset			offset of start of WHEN clause
1: 	 * @param actionNode			the trigger action tree
1: 	 * @param actionText			the text of the trigger action
0: 	 * @param actionOffset			offset of start of action clause
1: 	 *
0: 	 * @return	A CreateTriggerNode 
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init 
1: 	(
0: 		Object		triggerName,
0: 		Object		tableName,
0: 		Object				triggerEventMask,
0: 		Object triggerCols,
0: 		Object			isBefore,
0: 		Object			isRow,
0: 		Object			isEnabled,
0: 		Object			refClause,
0: 		Object	whenClause,
0: 		Object			whenText,
0: 		Object				whenOffset,
0: 		Object	actionNode,
0: 		Object			actionText,
0: 		Object				actionOffset
1: 	) throws StandardException
1: 	{
0: 		initAndCheck(triggerName);
0: 		this.triggerName = (TableName) triggerName;
0: 		this.tableName = (TableName) tableName;
0: 		this.triggerEventMask = ((Integer) triggerEventMask).intValue();
0: 		this.triggerCols = (ResultColumnList) triggerCols;
0: 		this.isBefore = ((Boolean) isBefore).booleanValue();
0: 		this.isRow = ((Boolean) isRow).booleanValue();
0: 		this.isEnabled = ((Boolean) isEnabled).booleanValue();
0: 		this.refClause = (Vector) refClause;	
0: 		this.whenClause = (QueryTreeNode) whenClause;
0: 		this.whenText = (whenText == null) ? null : ((String) whenText).trim();
0: 		this.whenOffset = ((Integer) whenOffset).intValue();
0: 		this.actionNode = (StatementNode) actionNode;
0: 		this.originalActionText = (String) actionText;
0: 		this.actionText =
0: 					(actionText == null) ? null : ((String) actionText).trim();
0: 		this.actionOffset = ((Integer) actionOffset).intValue();
1: 
0: 		implicitCreateSchema = true;
1: 	}
1: 
0: 	public String statementToString()
1: 	{
1: 		return "CREATE TRIGGER";
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (triggerCols != null)
1: 			{
1: 				printLabel(depth, "triggerColumns: ");
1: 				triggerCols.treePrint(depth + 1);
1: 			}
1: 			if (whenClause != null)
1: 			{
1: 				printLabel(depth, "whenClause: ");
1: 				whenClause.treePrint(depth + 1);
1: 			}
1: 			if (actionNode != null)
1: 			{
1: 				printLabel(depth, "actionNode: ");
1: 				actionNode.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 
1: 	// accessors
1: 
1: 
1: 	// We inherit the generate() method from DDLStatementNode.
1: 
1: 	/**
1: 	 * Bind this CreateTriggerNode.  This means doing any static error
1: 	 * checking that can be done before actually creating the table.
1: 	 *
0: 	 * @return	The bound query tree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public QueryTreeNode bind() throws StandardException
1: 	{
1: 		CompilerContext compilerContext = getCompilerContext();
1: 		DataDictionary	dd = getDataDictionary();
1: 		/*
1: 		** Grab the current schema.  We will use that for
1: 		** sps compilation
1: 		*/
1: 		LanguageConnectionContext lcc = getLanguageConnectionContext();
1: 		compSchemaDescriptor = lcc.getDefaultSchema();
1: 
1: 		/*
1: 		** Get and check the schema descriptor for this
1: 		** trigger.  This check will throw the proper exception
1: 		** if someone tries to create a trigger in the SYS
1: 		** schema.
1: 		*/
1: 		triggerSchemaDescriptor = getSchemaDescriptor();
1: 
1: 		/*
1: 		** Get the trigger table.
1: 		*/
1: 		triggerTableDescriptor = getTableDescriptor(tableName);
1: 
1: 		//throw an exception if user is attempting to create a trigger on a temporary table
1: 		if (isSessionSchema(triggerTableDescriptor.getSchemaDescriptor()))
1: 		{
1: 				throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
1: 		}
1: 
1: 		/*
1: 		** Regenerates the actionText and actionNode if necessary.
1: 		*/
1: 		boolean needInternalSQL = bindReferencesClause(dd);
1: 
1: 		lcc.pushTriggerTable(triggerTableDescriptor);
1: 		try
1: 		{	
1: 			/*
1: 			** Bind the trigger action and the trigger
1: 			** when clause to make sure that they are
1: 			** ok.  Note that we have already substituted 
1: 			** in various replacements for OLD/NEW transition
1: 			** tables/variables and reparsed if necessary.
1: 			*/
1: 			if (needInternalSQL)
1: 				compilerContext.setReliability(CompilerContext.INTERNAL_SQL_LEGAL);
1: 
0: 			actionNode.bind();
1: 
1: 			if (whenClause != null)
1: 			{
0: 				whenClause.bind();
1: 			}
1: 		}
1: 		finally
1: 		{
1: 			lcc.popTriggerTable(triggerTableDescriptor);
1: 		}
1: 
1: 		/* 
1: 		** Statement is dependent on the TableDescriptor 
1: 		*/
1: 		compilerContext.createDependency(triggerTableDescriptor);
1: 
1: 		/*
1: 		** If there is a list of columns, then no duplicate columns,
1: 		** and all columns must be found.
1: 		*/
1: 		if (triggerCols != null && triggerCols.size() != 0)
1: 		{
0: 			referencedColInts = new int[triggerCols.size()];
0: 			Hashtable columnNames = new Hashtable();
0: 			int tcSize = triggerCols.size();
0: 			for (int i = 0; i < tcSize; i++)
1: 			{
0: 				ResultColumn rc  = (ResultColumn) triggerCols.elementAt(i);
0: 				if (columnNames.put(rc.getName(), rc) != null)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_DUPLICATE_COLUMN_IN_TRIGGER_UPDATE, 
1: 											rc.getName(), 
1: 											triggerName);
1: 				}
1: 
0: 				ColumnDescriptor cd = triggerTableDescriptor.getColumnDescriptor(rc.getName());
0: 				if (cd == null)
1: 				{
0: 					throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, 
1: 																rc.getName(),
0: 																tableName);
1: 				}
1: 
0: 				referencedColInts[i] = cd.getPosition();
1: 			}
1:  
0: 			// sort the list
0: 			java.util.Arrays.sort(referencedColInts);
1: 		}
1: 
0: 		//If attempting to reference a SESSION schema table (temporary or permanent) in the trigger action, throw an exception
0: 		if (actionNode.referencesSessionSchema())
1: 			throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
1: 
0: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1: 	 *
1: 	 * @return	true if references SESSION schema tables, else false
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean referencesSessionSchema()
1: 		throws StandardException
1: 	{
1: 		//If create trigger is part of create statement and the trigger is defined on or it references SESSION schema tables,
1: 		//it will get caught in the bind phase of trigger and exception will be thrown by the trigger bind. 
0: 		return (isSessionSchema(triggerTableDescriptor.getSchemaName()) || actionNode.referencesSessionSchema());
1: 	}
1: 
1: 	/*
0: 	** BIND OLD/NEW TRANSITION TABLES/VARIABLES
0: 	**
1: 	** 1) validate the referencing clause (if any)
0: 	**
0: 	** 2) convert trigger action text.  e.g. 
0: 	**		DELETE FROM t WHERE c = old.c
1: 	** turns into
0: 	**		DELETE FROM t WHERE c = org.apache.derby.iapi.db.Factory::
0: 	**					getTriggerExecutionContext().getOldRow().getInt('C');
1: 	** or
0: 	**		DELETE FROM t WHERE c in (SELECT c FROM OLD)
1: 	** turns into
0: 	**		DELETE FROM t WHERE c in (SELECT c FROM new TriggerOldTransitionTable OLD)
0: 	**
1: 	** 3) check all column references against new/old transition 
1: 	**	variables (since they are no longer 'normal' column references
1: 	** 	that will be checked during bind)
0: 	**
0: 	** 4) reparse the new action text
0: 	**
1: 	** You might be wondering why we regenerate the text and reparse
1: 	** instead of just reworking the tree to have the nodes we want.
1: 	** Well, the primary reason is that if we screwed with the tree,
1: 	** then we would have a major headache if this trigger action
1: 	** was ever recompiled -- spses don't really know that they are
1: 	** triggers so it would be quite arduous to figure out that an
1: 	** sps is a trigger and munge up its query tree after figuring
1: 	** out what its OLD/NEW tables are, etc.  Also, it is just plain
0: 	** easier to just generate the sql and rebind.  
1: 	*/
1: 	private boolean bindReferencesClause(DataDictionary dd) throws StandardException
1: 	{
1: 		validateReferencesClause(dd);
1: 
0: 		StringBuffer newText = new StringBuffer();
0: 		boolean regenNode = false;
0: 		int start = 0;
1: 		if (isRow)
1: 		{
1: 			/*
0: 			** For a row trigger, we find all column references.  If
0: 			** they are referencing NEW or OLD we turn them into
0: 			** getTriggerExecutionContext().getOldRow().getInt('C');
1: 			*/
0: 			CollectNodesVisitor visitor = new CollectNodesVisitor(ColumnReference.class);
0: 			actionNode.accept(visitor);
0: 			Vector refs = visitor.getList();
0: 			/* we need to sort on position in string, beetle 4324
1: 			 */
0: 			QueryTreeNode[] cols = sortRefs(refs, true);
1: 
0: 			for (int i = 0; i < cols.length; i++)
1: 			{
0: 				ColumnReference ref = (ColumnReference) cols[i];
0: 				TableName tableName = ref.getTableNameNode();
0: 				if ((tableName == null) ||
0: 					((oldTableName == null || !oldTableName.equals(tableName.getTableName())) &&
0: 					(newTableName == null || !newTableName.equals(tableName.getTableName()))))
1: 				{
0: 					continue;
1: 				}
1: 					
0: 				int tokBeginOffset = tableName.getTokenBeginOffset();
0: 				int tokEndOffset = tableName.getTokenEndOffset();
0: 				if (tokBeginOffset == -1)
1: 				{
0: 					continue;
1: 				}
1: 
0: 				regenNode = true;
0: 				checkInvalidTriggerReference(tableName.getTableName());
0: 				String colName = ref.getColumnName();
0: 				int columnLength = ref.getTokenEndOffset() - ref.getTokenBeginOffset() + 1;
1: 
0: 				newText.append(originalActionText.substring(start, tokBeginOffset-actionOffset));
0: 				newText.append(genColumnReferenceSQL(dd, colName, tableName.getTableName(), tableName.getTableName().equals(oldTableName)));
0: 				start = tokEndOffset- actionOffset + columnLength + 2;
1: 			}
1: 		}
1: 		else
1: 		{
1: 			/*
0: 			** For a statement trigger, we find all FromBaseTable nodes.  If
0: 			** the from table is NEW or OLD (or user designated alternates
0: 			** REFERENCING), we turn them into a trigger table VTI.
1: 			*/
0: 			CollectNodesVisitor visitor = new CollectNodesVisitor(FromBaseTable.class);
0: 			actionNode.accept(visitor);
0: 			Vector refs = visitor.getList();
0: 			QueryTreeNode[] tabs = sortRefs(refs, false);
0: 			for (int i = 0; i < tabs.length; i++)
1: 			{
0: 				FromBaseTable fromTable = (FromBaseTable) tabs[i];
0: 				String refTableName = fromTable.getTableName().getTableName();
0: 				String baseTableName = fromTable.getBaseTableName();
0: 				if ((baseTableName == null) ||
0: 					((oldTableName == null || !oldTableName.equals(baseTableName)) &&
0: 					(newTableName == null || !newTableName.equals(baseTableName))))
1: 				{
0: 					continue;
1: 				}
0: 				int tokBeginOffset = fromTable.getTableNameField().getTokenBeginOffset();
0: 				int tokEndOffset = fromTable.getTableNameField().getTokenEndOffset();
0: 				if (tokBeginOffset == -1)
1: 				{
0: 					continue;
1: 				}
1: 
0: 				checkInvalidTriggerReference(baseTableName);
1: 
0: 				regenNode = true;
0: 				newText.append(originalActionText.substring(start, tokBeginOffset-actionOffset));
0: 				newText.append(baseTableName.equals(oldTableName) ?
0: 								"new org.apache.derby.catalog.TriggerOldTransitionRows() " :
0: 								"new org.apache.derby.catalog.TriggerNewTransitionRows() ");
1: 				/*
0: 				** If the user supplied a correlation, then just
0: 				** pick it up automatically; otherwise, supply
0: 				** the default.
1: 				*/
0: 				if (refTableName.equals(baseTableName))
1: 				{
0: 					newText.append(baseTableName).append(" ");
1: 				}
0: 				start=tokEndOffset-actionOffset+1;
1: 			}
1: 		}
1: 
1: 		/*
1: 		** Parse the new action text with the substitutions.
1: 		** Also, we reset the actionText to this new value.  This
1: 		** is what we are going to stick in the system tables.
1: 		*/
0: 		if (regenNode)
1: 		{
0: 			if (start < originalActionText.length())
1: 			{
0: 				newText.append(originalActionText.substring(start));
1: 			}
0: 			actionText = newText.toString();
0: 			actionNode = (StatementNode)reparseTriggerText(actionText);
1: 		}
1: 
1: 		return regenNode;
1: 	}
1: 
1: 	/*
0: 	** Sort the refs into array.
1: 	*/
0: 	private QueryTreeNode[] sortRefs(Vector refs, boolean isRow)
1: 	{
0: 		int size = refs.size();
0: 		QueryTreeNode[] sorted = new QueryTreeNode[size];
0: 		int i = 0;
0: 		for (Enumeration e = refs.elements(); e.hasMoreElements(); )
1: 		{
1: 			if (isRow)
0: 				sorted[i++] = (ColumnReference)e.nextElement();
1: 			else
0: 				sorted[i++] = (FromBaseTable)e.nextElement();
1: 		}
1: 
0: 		/* bubble sort
1: 		 */
0: 		QueryTreeNode temp;
0: 		for (i = 0; i < size - 1; i++)
1: 		{
0: 			temp = null;
0: 			for (int j = 0; j < size - i - 1; j++)
1: 			{
0: 				if ((isRow && 
0: 					 ((ColumnReference) sorted[j]).getTokenBeginOffset() > 
0: 					 ((ColumnReference) sorted[j+1]).getTokenBeginOffset()
0: 					) ||
0: 					(!isRow &&
0: 					 ((FromBaseTable) sorted[j]).getTableNameField().getTokenBeginOffset() > 
0: 					 ((FromBaseTable) sorted[j+1]).getTableNameField().getTokenBeginOffset()
0: 					))
1: 				{
0: 					temp = sorted[j];
0: 					sorted[j] = sorted[j+1];
0: 					sorted[j+1] = temp;
1: 				}
1: 			}
0: 			if (temp == null)		// sorted
0: 				break;
1: 		}
1: 
0: 		return sorted;
1: 	}
1: 
1: 	/*
0: 	** Parse the text and return the tree.
1: 	*/
0: 	private QueryTreeNode reparseTriggerText(String text) throws StandardException
1: 	{
1: 		/*
0: 		** Get a new compiler context, so the parsing of the text
0: 		** doesn't mess up anything in the current context 
1: 		*/
1: 		LanguageConnectionContext lcc = getLanguageConnectionContext();
0: 		CompilerContext newCC = lcc.pushCompilerContext();
0: 		newCC.setReliability(CompilerContext.INTERNAL_SQL_LEGAL);
1: 
1: 		try
1: 		{
0: 			return QueryTreeNode.parseQueryText(newCC, text, (Object[])null, lcc);
1: 		}
1: 
1: 		finally
1: 		{
0: 			lcc.popCompilerContext(newCC);
1: 		}
1: 	}
1: 	/*
0: 	** Make sure the given column name is found in the trigger
0: 	** target table.  Generate the appropriate SQL to get it.
0: 	**
0: 	** @return a string that is used to get the column using
0: 	** getObject() on the desired result set and CAST it back
0: 	** to the proper type in the SQL domain. 
0: 	**
0: 	** @exception StandardException on invalid column name
1: 	*/
0: 	private String genColumnReferenceSQL
1: 	(
0: 		DataDictionary	dd, 
0: 		String			colName, 
0: 		String			tabName,
0: 		boolean			isOldTable
1: 	) throws StandardException
1: 	{
0: 		ColumnDescriptor colDesc = null;
0: 		if ((colDesc = triggerTableDescriptor.getColumnDescriptor(colName)) == null)
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND, tabName+"."+colName);
1: 		}
1: 
1: 		/*
0: 		** Generate something like this:
0: 		**
0: 		** 		cast (org.apache.derby.iapi.db.Factory::
0: 		**			getTriggerExecutionContext().getNewRow().
0: 		**				getObject('<colName>') AS DECIMAL(6,2))
0: 		**
0: 		** The cast back to the SQL Domain may seem redundant
0: 		** but we need it to make the column reference appear
0: 		** EXACTLY like a regular column reference, so we need
0: 		** the object in the SQL Domain and we need to have the
0: 		** type information.  Thus a user should be able to do 
0: 		** something like
0: 		**
0: 		**		CREATE TRIGGER ... INSERT INTO T length(Column), ...
1: 		*/
0: 		StringBuffer methodCall = new StringBuffer();
0: 		methodCall.append("cast (org.apache.derby.iapi.db.Factory::getTriggerExecutionContext().");
0: 		methodCall.append(isOldTable ? "getOldRow()" : "getNewRow()");
0: 		methodCall.append(".getObject('"+colName+"') AS ");
0: 		DataTypeDescriptor dts = colDesc.getType();
0: 		TypeId typeId = dts.getTypeId();
1: 
1: 		/*
0: 		** getSQLString() returns <typeName> 
0: 		** for user types, so call getSQLTypeName in that
0: 		** case.
1: 		*/
0: 		methodCall.append((typeId.systemBuiltIn() ? 
0: 					dts.getSQLstring() :
0: 					typeId.getSQLTypeName()) + ") ");
1: 
0: 		return methodCall.toString();
1: 	}
1: 
1: 	/*
1: 	** Check for illegal combinations here: insert & old or
1: 	** delete and new
1: 	*/
1: 	private void checkInvalidTriggerReference(String tableName) throws StandardException
1: 	{
1: 		if (tableName.equals(oldTableName) && 
1: 			(triggerEventMask & TriggerDescriptor.TRIGGER_EVENT_INSERT) == TriggerDescriptor.TRIGGER_EVENT_INSERT)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "INSERT", "new");
1: 		}
1: 		else if (tableName.equals(newTableName) && 
1: 			(triggerEventMask & TriggerDescriptor.TRIGGER_EVENT_DELETE) == TriggerDescriptor.TRIGGER_EVENT_DELETE)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "DELETE", "old");
1: 		}
1: 	}
1: 
1: 	/*
1: 	** Make sure that the referencing clause is legitimate.
1: 	** While we are at it we set the new/oldTableName to
1: 	** be whatever the user wants.
1: 	*/
1: 	private void validateReferencesClause(DataDictionary dd) throws StandardException
1: 	{
0: 		if ((refClause == null) || (refClause.size() == 0))
1: 		{
1: 			return;
1: 		}
1: 
0: 		for (Enumeration e = refClause.elements(); e.hasMoreElements(); )
1: 		{
0: 			TriggerReferencingStruct trn = (TriggerReferencingStruct)e.nextElement();
1: 
1: 			/*
1: 			** 1) Make sure that we don't try to refer
1: 			** to a table for a row trigger or a row for
1: 			** a table trigger.
1: 			*/
1: 			if (isRow && !trn.isRow)
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "ROW", "row");
1: 			}
1: 			else if (!isRow && trn.isRow) 
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "STATEMENT", "table");
1: 			}
1: 
1: 			/*
1: 			** 2) Make sure we have no dups
1: 			*/
1: 			if (trn.isNew)
1: 			{
1: 
1: 				if (newTableInReferencingClause) 
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_CLAUSE_DUPS);
1: 				}
1: 
1: 				/*
1: 				** 3a) No NEW reference in delete trigger
1: 				*/
1: 				if ((triggerEventMask & TriggerDescriptor.TRIGGER_EVENT_DELETE) == TriggerDescriptor.TRIGGER_EVENT_DELETE)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "DELETE", "old");
1: 				}
1: 				newTableName = trn.identifier;
1: 				newTableInReferencingClause = true;
1: 			}
1: 			else
1: 			{
1: 				if (oldTableInReferencingClause)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_CLAUSE_DUPS);
1: 				}
1: 				/*
1: 				** 3b) No OLD reference in insert trigger
1: 				*/
1: 				if ((triggerEventMask & TriggerDescriptor.TRIGGER_EVENT_INSERT) == TriggerDescriptor.TRIGGER_EVENT_INSERT)
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "INSERT", "new");
1: 				}
1: 				oldTableName = trn.identifier;
1: 				oldTableInReferencingClause = true;
1: 			}
1: 
1: 			/*
1: 			** 4) Additional restriction on BEFORE triggers
1: 			*/
1: 			if (this.isBefore && !trn.isRow) {
0: 			// OLD_TABLE and NEW_TABLE not allowed for BEFORE triggers.
1: 				throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "BEFORE", "row");
1: 			}
1: 
1: 		}
1: 
1: 	}				
1: 
1: 
1: 	/**
1: 	 * Create the Constant information that will drive the guts of Execution.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
1: 	public ConstantAction makeConstantAction() throws StandardException
1: 	{
1: 		String oldReferencingName = (oldTableInReferencingClause) ? oldTableName : null;
1: 		String newReferencingName = (newTableInReferencingClause) ? newTableName : null;
1: 
1: 		return	getGenericConstantActionFactory().getCreateTriggerConstantAction(
1: 											triggerSchemaDescriptor.getSchemaName(),
1: 											getRelativeName(),
1: 											triggerEventMask,
1: 											isBefore,
1: 											isRow,
1: 											isEnabled,
1: 											triggerTableDescriptor,	
1: 											(UUID)null,			// when SPSID
1: 											whenText,
1: 											(UUID)null,			// action SPSid 
1: 											actionText,
0: 											(actionCompSchemaId == null) ?
0: 												compSchemaDescriptor.getUUID() :
0: 												actionCompSchemaId,
0: 											(Timestamp)null,	// creation time
1: 											referencedColInts,
1: 											originalActionText,
1: 											oldTableInReferencingClause,
1: 											newTableInReferencingClause,
1: 											oldReferencingName,
0: 											newReferencingName
0: 											);
1: 	}
1: 
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			String refString = "null";
1: 			if (refClause != null)
1: 			{
0: 				StringBuffer buf = new StringBuffer();
0: 				for (Enumeration e = refClause.elements(); e.hasMoreElements(); )
1: 				{
1: 					buf.append("\t");
0: 					TriggerReferencingStruct trn = 	
0: 							(TriggerReferencingStruct)e.nextElement();
1: 					buf.append(trn.toString());
1: 					buf.append("\n");
1: 				}
1: 				refString = buf.toString();
1: 			}
1: 
1: 			return super.toString() +
1: 				"tableName: "+tableName+		
1: 				"\ntriggerEventMask: "+triggerEventMask+		
1: 				"\nisBefore: "+isBefore+		
1: 				"\nisRow: "+isRow+		
1: 				"\nisEnabled: "+isEnabled+		
1: 				"\nwhenText: "+whenText+
1: 				"\nrefClause: "+refString+
1: 				"\nactionText: "+actionText+
1: 				"\n";
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:2579699
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.conn.Authorizer;
/////////////////////////////////////////////////////////////////////////
0: 		compilerContext.pushCurrentPrivType(Authorizer.TRIGGER_PRIV);
0: 		compilerContext.addRequiredTablePriv(triggerTableDescriptor);
0: 		compilerContext.popCurrentPrivType();
0: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.Parser;
0: 
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.catalog.UUID;
0: import java.sql.Timestamp;
0: import java.sql.Types;
0: import java.util.Enumeration;
0: import java.util.Hashtable;
0: import java.util.Vector;
0: 
0: /**
0:  * A CreateTriggerNode is the root of a QueryTree 
0:  * that represents a CREATE TRIGGER
0:  * statement.
0:  *
0:  * @author jamie
0:  */
0: 
0: public class CreateTriggerNode extends CreateStatementNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	private	TableName			triggerName;
0: 	private	TableName			tableName;
0: 	private	int					triggerEventMask;
0: 	private ResultColumnList	triggerCols;
0: 	private	boolean				isBefore;
0: 	private	boolean				isRow;
0: 	private	boolean				isEnabled;
0: 	private	Vector				refClause;
0: 	private	QueryTreeNode		whenClause;
0: 	private	String				whenText;
0: 	private	int					whenOffset;
0: 	private	StatementNode		actionNode;
0: 	private	String				actionText;
0: 	private	String				originalActionText; // text w/o trim of spaces
0: 	private	int					actionOffset;
0: 
0: 	private SchemaDescriptor	triggerSchemaDescriptor;
0: 	private SchemaDescriptor	compSchemaDescriptor;
0: 	private int[]				referencedColInts;
0: 	private TableDescriptor		triggerTableDescriptor;
0: 	private	UUID				actionCompSchemaId;
0: 
0: 	/*
0: 	** Names of old and new table.  By default we have
0: 	** OLD/old and NEW/new.  The casing is dependent on 
0: 	** the language connection context casing as the rest
0:     ** of other code. Therefore we will set the value of the 
0:     ** String at the init() time.
0:     ** However, if there is a referencing clause
0: 	** we will reset these values to be whatever the user
0: 	** wants.
0: 	*/
0: 	private String oldTableName;
0: 	private String newTableName;
0: 
0: 	private boolean oldTableInReferencingClause;
0: 	private boolean newTableInReferencingClause;
0: 
0: 
0: 	/**
0: 	 * Initializer for a CreateTriggerNode
0: 	 *
0: 	 * @param triggerName			name of the trigger	
0: 	 * @param tableName				name of the table which the trigger is declared upon	
0: 	 * @param triggerEventMask		TriggerDescriptor.TRIGGER_EVENT_XXX
0: 	 * @param triggerCols			columns trigger is to fire upon.  Valid
0: 	 *								for UPDATE case only.
0: 	 * @param isBefore				is before trigger (false for after)
0: 	 * @param isRow					true for row trigger, false for statement
0: 	 * @param isEnabled				true if enabled
0: 	 * @param refClause				the referencing clause
0: 	 * @param whenClause			the WHEN clause tree
0: 	 * @param whenText				the text of the WHEN clause
0: 	 * @param whenOffset			offset of start of WHEN clause
0: 	 * @param actionNode			the trigger action tree
0: 	 * @param actionText			the text of the trigger action
0: 	 * @param actionOffset			offset of start of action clause
0: 	 *
0: 	 * @return	A CreateTriggerNode 
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init 
0: 	(
0: 		Object		triggerName,
0: 		Object		tableName,
0: 		Object				triggerEventMask,
0: 		Object triggerCols,
0: 		Object			isBefore,
0: 		Object			isRow,
0: 		Object			isEnabled,
0: 		Object			refClause,
0: 		Object	whenClause,
0: 		Object			whenText,
0: 		Object				whenOffset,
0: 		Object	actionNode,
0: 		Object			actionText,
0: 		Object				actionOffset
0: 	) throws StandardException
0: 	{
0: 		initAndCheck(triggerName);
0: 		this.triggerName = (TableName) triggerName;
0: 		this.tableName = (TableName) tableName;
0: 		this.triggerEventMask = ((Integer) triggerEventMask).intValue();
0: 		this.triggerCols = (ResultColumnList) triggerCols;
0: 		this.isBefore = ((Boolean) isBefore).booleanValue();
0: 		this.isRow = ((Boolean) isRow).booleanValue();
0: 		this.isEnabled = ((Boolean) isEnabled).booleanValue();
0: 		this.refClause = (Vector) refClause;	
0: 		this.whenClause = (QueryTreeNode) whenClause;
0: 		this.whenText = (whenText == null) ? null : ((String) whenText).trim();
0: 		this.whenOffset = ((Integer) whenOffset).intValue();
0: 		this.actionNode = (StatementNode) actionNode;
0: 		this.originalActionText = (String) actionText;
0: 		this.actionText =
0: 					(actionText == null) ? null : ((String) actionText).trim();
0: 		this.actionOffset = ((Integer) actionOffset).intValue();
0: 
0: 		implicitCreateSchema = true;
0: 	}
0: 
0: 	public String statementToString()
0: 	{
0: 		return "CREATE TRIGGER";
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			if (triggerCols != null)
0: 			{
0: 				printLabel(depth, "triggerColumns: ");
0: 				triggerCols.treePrint(depth + 1);
0: 			}
0: 			if (whenClause != null)
0: 			{
0: 				printLabel(depth, "whenClause: ");
0: 				whenClause.treePrint(depth + 1);
0: 			}
0: 			if (actionNode != null)
0: 			{
0: 				printLabel(depth, "actionNode: ");
0: 				actionNode.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 
0: 	// accessors
0: 
0: 
0: 	// We inherit the generate() method from DDLStatementNode.
0: 
0: 	/**
0: 	 * Bind this CreateTriggerNode.  This means doing any static error
0: 	 * checking that can be done before actually creating the table.
0: 	 *
0: 	 * @return	The bound query tree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public QueryTreeNode bind() throws StandardException
0: 	{
0: 		CompilerContext compilerContext = getCompilerContext();
0: 		DataDictionary	dd = getDataDictionary();
0: 		/*
0: 		** Grab the current schema.  We will use that for
0: 		** sps compilation
0: 		*/
0: 		LanguageConnectionContext lcc = getLanguageConnectionContext();
0: 		compSchemaDescriptor = lcc.getDefaultSchema();
0: 
0: 		/*
0: 		** Get and check the schema descriptor for this
0: 		** trigger.  This check will throw the proper exception
0: 		** if someone tries to create a trigger in the SYS
0: 		** schema.
0: 		*/
0: 		triggerSchemaDescriptor = getSchemaDescriptor();
0: 
0: 		/*
0: 		** Get the trigger table.
0: 		*/
0: 		triggerTableDescriptor = getTableDescriptor(tableName);
0: 
0: 		//throw an exception if user is attempting to create a trigger on a temporary table
0: 		if (isSessionSchema(triggerTableDescriptor.getSchemaDescriptor()))
0: 		{
0: 				throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
0: 		}
0: 
0: 		/*
0: 		** Regenerates the actionText and actionNode if necessary.
0: 		*/
0: 		boolean needInternalSQL = bindReferencesClause(dd);
0: 
0: 		lcc.pushTriggerTable(triggerTableDescriptor);
0: 		try
0: 		{	
0: 			/*
0: 			** Bind the trigger action and the trigger
0: 			** when clause to make sure that they are
0: 			** ok.  Note that we have already substituted 
0: 			** in various replacements for OLD/NEW transition
0: 			** tables/variables and reparsed if necessary.
0: 			*/
0: 			if (needInternalSQL)
0: 				compilerContext.setReliability(CompilerContext.INTERNAL_SQL_LEGAL);
0: 
0: 			actionNode.bind();
0: 
0: 			if (whenClause != null)
0: 			{
0: 				whenClause.bind();
0: 			}
0: 		}
0: 		finally
0: 		{
0: 			lcc.popTriggerTable(triggerTableDescriptor);
0: 		}
0: 
0: 		/* 
0: 		** Statement is dependent on the TableDescriptor 
0: 		*/
0: 		compilerContext.createDependency(triggerTableDescriptor);
0: 
0: 		/*
0: 		** If there is a list of columns, then no duplicate columns,
0: 		** and all columns must be found.
0: 		*/
0: 		if (triggerCols != null && triggerCols.size() != 0)
0: 		{
0: 			referencedColInts = new int[triggerCols.size()];
0: 			Hashtable columnNames = new Hashtable();
0: 			int tcSize = triggerCols.size();
0: 			for (int i = 0; i < tcSize; i++)
0: 			{
0: 				ResultColumn rc  = (ResultColumn) triggerCols.elementAt(i);
0: 				if (columnNames.put(rc.getName(), rc) != null)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_DUPLICATE_COLUMN_IN_TRIGGER_UPDATE, 
0: 											rc.getName(), 
0: 											triggerName);
0: 				}
0: 
0: 				ColumnDescriptor cd = triggerTableDescriptor.getColumnDescriptor(rc.getName());
0: 				if (cd == null)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, 
0: 																rc.getName(),
0: 																tableName);
0: 				}
0: 
0: 				referencedColInts[i] = cd.getPosition();
0: 			}
0:  
0: 			// sort the list
0: 			java.util.Arrays.sort(referencedColInts);
0: 		}
0: 
0: 		//If attempting to reference a SESSION schema table (temporary or permanent) in the trigger action, throw an exception
0: 		if (actionNode.referencesSessionSchema())
0: 			throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
0: 	 *
0: 	 * @return	true if references SESSION schema tables, else false
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean referencesSessionSchema()
0: 		throws StandardException
0: 	{
0: 		//If create trigger is part of create statement and the trigger is defined on or it references SESSION schema tables,
0: 		//it will get caught in the bind phase of trigger and exception will be thrown by the trigger bind. 
0: 		return (isSessionSchema(triggerTableDescriptor.getSchemaName()) || actionNode.referencesSessionSchema());
0: 	}
0: 
0: 	/*
0: 	** BIND OLD/NEW TRANSITION TABLES/VARIABLES
0: 	**
0: 	** 1) validate the referencing clause (if any)
0: 	**
0: 	** 2) convert trigger action text.  e.g. 
0: 	**		DELETE FROM t WHERE c = old.c
0: 	** turns into
0: 	**		DELETE FROM t WHERE c = org.apache.derby.iapi.db.Factory::
0: 	**					getTriggerExecutionContext().getOldRow().getInt('C');
0: 	** or
0: 	**		DELETE FROM t WHERE c in (SELECT c FROM OLD)
0: 	** turns into
0: 	**		DELETE FROM t WHERE c in (SELECT c FROM new TriggerOldTransitionTable OLD)
0: 	**
0: 	** 3) check all column references against new/old transition 
0: 	**	variables (since they are no longer 'normal' column references
0: 	** 	that will be checked during bind)
0: 	**
0: 	** 4) reparse the new action text
0: 	**
0: 	** You might be wondering why we regenerate the text and reparse
0: 	** instead of just reworking the tree to have the nodes we want.
0: 	** Well, the primary reason is that if we screwed with the tree,
0: 	** then we would have a major headache if this trigger action
0: 	** was ever recompiled -- spses don't really know that they are
0: 	** triggers so it would be quite arduous to figure out that an
0: 	** sps is a trigger and munge up its query tree after figuring
0: 	** out what its OLD/NEW tables are, etc.  Also, it is just plain
0: 	** easier to just generate the sql and rebind.  
0: 	*/
0: 	private boolean bindReferencesClause(DataDictionary dd) throws StandardException
0: 	{
0: 		validateReferencesClause(dd);
0: 
0: 		StringBuffer newText = new StringBuffer();
0: 		boolean regenNode = false;
0: 		int start = 0;
0: 		if (isRow)
0: 		{
0: 			/*
0: 			** For a row trigger, we find all column references.  If
0: 			** they are referencing NEW or OLD we turn them into
0: 			** getTriggerExecutionContext().getOldRow().getInt('C');
0: 			*/
0: 			CollectNodesVisitor visitor = new CollectNodesVisitor(ColumnReference.class);
0: 			actionNode.accept(visitor);
0: 			Vector refs = visitor.getList();
0: 			/* we need to sort on position in string, beetle 4324
0: 			 */
0: 			QueryTreeNode[] cols = sortRefs(refs, true);
0: 
0: 			for (int i = 0; i < cols.length; i++)
0: 			{
0: 				ColumnReference ref = (ColumnReference) cols[i];
0: 				TableName tableName = ref.getTableNameNode();
0: 				if ((tableName == null) ||
0: 					((oldTableName == null || !oldTableName.equals(tableName.getTableName())) &&
0: 					(newTableName == null || !newTableName.equals(tableName.getTableName()))))
0: 				{
0: 					continue;
0: 				}
0: 					
0: 				int tokBeginOffset = tableName.getTokenBeginOffset();
0: 				int tokEndOffset = tableName.getTokenEndOffset();
0: 				if (tokBeginOffset == -1)
0: 				{
0: 					continue;
0: 				}
0: 
0: 				regenNode = true;
0: 				checkInvalidTriggerReference(tableName.getTableName());
0: 				String colName = ref.getColumnName();
0: 				int columnLength = ref.getTokenEndOffset() - ref.getTokenBeginOffset() + 1;
0: 
0: 				newText.append(originalActionText.substring(start, tokBeginOffset-actionOffset));
0: 				newText.append(genColumnReferenceSQL(dd, colName, tableName.getTableName(), tableName.getTableName().equals(oldTableName)));
0: 				start = tokEndOffset- actionOffset + columnLength + 2;
0: 			}
0: 		}
0: 		else
0: 		{
0: 			/*
0: 			** For a statement trigger, we find all FromBaseTable nodes.  If
0: 			** the from table is NEW or OLD (or user designated alternates
0: 			** REFERENCING), we turn them into a trigger table VTI.
0: 			*/
0: 			CollectNodesVisitor visitor = new CollectNodesVisitor(FromBaseTable.class);
0: 			actionNode.accept(visitor);
0: 			Vector refs = visitor.getList();
0: 			QueryTreeNode[] tabs = sortRefs(refs, false);
0: 			for (int i = 0; i < tabs.length; i++)
0: 			{
0: 				FromBaseTable fromTable = (FromBaseTable) tabs[i];
0: 				String refTableName = fromTable.getTableName().getTableName();
0: 				String baseTableName = fromTable.getBaseTableName();
0: 				if ((baseTableName == null) ||
0: 					((oldTableName == null || !oldTableName.equals(baseTableName)) &&
0: 					(newTableName == null || !newTableName.equals(baseTableName))))
0: 				{
0: 					continue;
0: 				}
0: 				int tokBeginOffset = fromTable.getTableNameField().getTokenBeginOffset();
0: 				int tokEndOffset = fromTable.getTableNameField().getTokenEndOffset();
0: 				if (tokBeginOffset == -1)
0: 				{
0: 					continue;
0: 				}
0: 
0: 				checkInvalidTriggerReference(baseTableName);
0: 
0: 				regenNode = true;
0: 				newText.append(originalActionText.substring(start, tokBeginOffset-actionOffset));
0: 				newText.append(baseTableName.equals(oldTableName) ?
0: 								"new org.apache.derby.catalog.TriggerOldTransitionRows() " :
0: 								"new org.apache.derby.catalog.TriggerNewTransitionRows() ");
0: 				/*
0: 				** If the user supplied a correlation, then just
0: 				** pick it up automatically; otherwise, supply
0: 				** the default.
0: 				*/
0: 				if (refTableName.equals(baseTableName))
0: 				{
0: 					newText.append(baseTableName).append(" ");
0: 				}
0: 				start=tokEndOffset-actionOffset+1;
0: 			}
0: 		}
0: 
0: 		/*
0: 		** Parse the new action text with the substitutions.
0: 		** Also, we reset the actionText to this new value.  This
0: 		** is what we are going to stick in the system tables.
0: 		*/
0: 		if (regenNode)
0: 		{
0: 			if (start < originalActionText.length())
0: 			{
0: 				newText.append(originalActionText.substring(start));
0: 			}
0: 			actionText = newText.toString();
0: 			actionNode = (StatementNode)reparseTriggerText(actionText);
0: 		}
0: 
0: 		return regenNode;
0: 	}
0: 
0: 	/*
0: 	** Sort the refs into array.
0: 	*/
0: 	private QueryTreeNode[] sortRefs(Vector refs, boolean isRow)
0: 	{
0: 		int size = refs.size();
0: 		QueryTreeNode[] sorted = new QueryTreeNode[size];
0: 		int i = 0;
0: 		for (Enumeration e = refs.elements(); e.hasMoreElements(); )
0: 		{
0: 			if (isRow)
0: 				sorted[i++] = (ColumnReference)e.nextElement();
0: 			else
0: 				sorted[i++] = (FromBaseTable)e.nextElement();
0: 		}
0: 
0: 		/* bubble sort
0: 		 */
0: 		QueryTreeNode temp;
0: 		for (i = 0; i < size - 1; i++)
0: 		{
0: 			temp = null;
0: 			for (int j = 0; j < size - i - 1; j++)
0: 			{
0: 				if ((isRow && 
0: 					 ((ColumnReference) sorted[j]).getTokenBeginOffset() > 
0: 					 ((ColumnReference) sorted[j+1]).getTokenBeginOffset()
0: 					) ||
0: 					(!isRow &&
0: 					 ((FromBaseTable) sorted[j]).getTableNameField().getTokenBeginOffset() > 
0: 					 ((FromBaseTable) sorted[j+1]).getTableNameField().getTokenBeginOffset()
0: 					))
0: 				{
0: 					temp = sorted[j];
0: 					sorted[j] = sorted[j+1];
0: 					sorted[j+1] = temp;
0: 				}
0: 			}
0: 			if (temp == null)		// sorted
0: 				break;
0: 		}
0: 
0: 		return sorted;
0: 	}
0: 
0: 	/*
0: 	** Parse the text and return the tree.
0: 	*/
0: 	private QueryTreeNode reparseTriggerText(String text) throws StandardException
0: 	{
0: 		/*
0: 		** Get a new compiler context, so the parsing of the text
0: 		** doesn't mess up anything in the current context 
0: 		*/
0: 		LanguageConnectionContext lcc = getLanguageConnectionContext();
0: 		CompilerContext newCC = lcc.pushCompilerContext();
0: 		newCC.setReliability(CompilerContext.INTERNAL_SQL_LEGAL);
0: 
0: 		try
0: 		{
0: 			return QueryTreeNode.parseQueryText(newCC, text, (Object[])null, lcc);
0: 		}
0: 
0: 		finally
0: 		{
0: 			lcc.popCompilerContext(newCC);
0: 		}
0: 	}
0: 	/*
0: 	** Make sure the given column name is found in the trigger
0: 	** target table.  Generate the appropriate SQL to get it.
0: 	**
0: 	** @return a string that is used to get the column using
0: 	** getObject() on the desired result set and CAST it back
0: 	** to the proper type in the SQL domain. 
0: 	**
0: 	** @exception StandardException on invalid column name
0: 	*/
0: 	private String genColumnReferenceSQL
0: 	(
0: 		DataDictionary	dd, 
0: 		String			colName, 
0: 		String			tabName,
0: 		boolean			isOldTable
0: 	) throws StandardException
0: 	{
0: 		ColumnDescriptor colDesc = null;
0: 		if ((colDesc = triggerTableDescriptor.getColumnDescriptor(colName)) == null)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND, tabName+"."+colName);
0: 		}
0: 
0: 		/*
0: 		** Generate something like this:
0: 		**
0: 		** 		cast (org.apache.derby.iapi.db.Factory::
0: 		**			getTriggerExecutionContext().getNewRow().
0: 		**				getObject('<colName>') AS DECIMAL(6,2))
0: 		**
0: 		** The cast back to the SQL Domain may seem redundant
0: 		** but we need it to make the column reference appear
0: 		** EXACTLY like a regular column reference, so we need
0: 		** the object in the SQL Domain and we need to have the
0: 		** type information.  Thus a user should be able to do 
0: 		** something like
0: 		**
0: 		**		CREATE TRIGGER ... INSERT INTO T length(Column), ...
0: 		*/
0: 		StringBuffer methodCall = new StringBuffer();
0: 		methodCall.append("cast (org.apache.derby.iapi.db.Factory::getTriggerExecutionContext().");
0: 		methodCall.append(isOldTable ? "getOldRow()" : "getNewRow()");
0: 		methodCall.append(".getObject('"+colName+"') AS ");
0: 		DataTypeDescriptor dts = colDesc.getType();
0: 		TypeId typeId = dts.getTypeId();
0: 
0: 		/*
0: 		** getSQLString() returns <typeName> 
0: 		** for user types, so call getSQLTypeName in that
0: 		** case.
0: 		*/
0: 		methodCall.append((typeId.systemBuiltIn() ? 
0: 					dts.getSQLstring() :
0: 					typeId.getSQLTypeName()) + ") ");
0: 
0: 		return methodCall.toString();
0: 	}
0: 
0: 	/*
0: 	** Check for illegal combinations here: insert & old or
0: 	** delete and new
0: 	*/
0: 	private void checkInvalidTriggerReference(String tableName) throws StandardException
0: 	{
0: 		if (tableName.equals(oldTableName) && 
0: 			(triggerEventMask & TriggerDescriptor.TRIGGER_EVENT_INSERT) == TriggerDescriptor.TRIGGER_EVENT_INSERT)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "INSERT", "new");
0: 		}
0: 		else if (tableName.equals(newTableName) && 
0: 			(triggerEventMask & TriggerDescriptor.TRIGGER_EVENT_DELETE) == TriggerDescriptor.TRIGGER_EVENT_DELETE)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "DELETE", "old");
0: 		}
0: 	}
0: 
0: 	/*
0: 	** Make sure that the referencing clause is legitimate.
0: 	** While we are at it we set the new/oldTableName to
0: 	** be whatever the user wants.
0: 	*/
0: 	private void validateReferencesClause(DataDictionary dd) throws StandardException
0: 	{
0: 		if ((refClause == null) || (refClause.size() == 0))
0: 		{
0: 			return;
0: 		}
0: 
0: 		for (Enumeration e = refClause.elements(); e.hasMoreElements(); )
0: 		{
0: 			TriggerReferencingStruct trn = (TriggerReferencingStruct)e.nextElement();
0: 
0: 			/*
0: 			** 1) Make sure that we don't try to refer
0: 			** to a table for a row trigger or a row for
0: 			** a table trigger.
0: 			*/
0: 			if (isRow && !trn.isRow)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "ROW", "row");
0: 			}
0: 			else if (!isRow && trn.isRow) 
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "STATEMENT", "table");
0: 			}
0: 
0: 			/*
0: 			** 2) Make sure we have no dups
0: 			*/
0: 			if (trn.isNew)
0: 			{
0: 
0: 				if (newTableInReferencingClause) 
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_CLAUSE_DUPS);
0: 				}
0: 
0: 				/*
0: 				** 3a) No NEW reference in delete trigger
0: 				*/
0: 				if ((triggerEventMask & TriggerDescriptor.TRIGGER_EVENT_DELETE) == TriggerDescriptor.TRIGGER_EVENT_DELETE)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "DELETE", "old");
0: 				}
0: 				newTableName = trn.identifier;
0: 				newTableInReferencingClause = true;
0: 			}
0: 			else
0: 			{
0: 				if (oldTableInReferencingClause)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_CLAUSE_DUPS);
0: 				}
0: 				/*
0: 				** 3b) No OLD reference in insert trigger
0: 				*/
0: 				if ((triggerEventMask & TriggerDescriptor.TRIGGER_EVENT_INSERT) == TriggerDescriptor.TRIGGER_EVENT_INSERT)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "INSERT", "new");
0: 				}
0: 				oldTableName = trn.identifier;
0: 				oldTableInReferencingClause = true;
0: 			}
0: 
0: 			/*
0: 			** 4) Additional restriction on BEFORE triggers
0: 			*/
0: 			if (this.isBefore && !trn.isRow) {
0: 			// OLD_TABLE and NEW_TABLE not allowed for BEFORE triggers.
0: 				throw StandardException.newException(SQLState.LANG_TRIGGER_BAD_REF_MISMATCH, "BEFORE", "row");
0: 			}
0: 
0: 		}
0: 
0: 	}				
0: 
0: 
0: 	/**
0: 	 * Create the Constant information that will drive the guts of Execution.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public ConstantAction makeConstantAction() throws StandardException
0: 	{
0: 		String oldReferencingName = (oldTableInReferencingClause) ? oldTableName : null;
0: 		String newReferencingName = (newTableInReferencingClause) ? newTableName : null;
0: 
0: 		return	getGenericConstantActionFactory().getCreateTriggerConstantAction(
0: 											triggerSchemaDescriptor.getSchemaName(),
0: 											getRelativeName(),
0: 											triggerEventMask,
0: 											isBefore,
0: 											isRow,
0: 											isEnabled,
0: 											triggerTableDescriptor,	
0: 											(UUID)null,			// when SPSID
0: 											whenText,
0: 											(UUID)null,			// action SPSid 
0: 											actionText,
0: 											(actionCompSchemaId == null) ?
0: 												compSchemaDescriptor.getUUID() :
0: 												actionCompSchemaId,
0: 											(Timestamp)null,	// creation time
0: 											referencedColInts,
0: 											originalActionText,
0: 											oldTableInReferencingClause,
0: 											newTableInReferencingClause,
0: 											oldReferencingName,
0: 											newReferencingName
0: 											);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			String refString = "null";
0: 			if (refClause != null)
0: 			{
0: 				StringBuffer buf = new StringBuffer();
0: 				for (Enumeration e = refClause.elements(); e.hasMoreElements(); )
0: 				{
0: 					buf.append("\t");
0: 					TriggerReferencingStruct trn = 	
0: 							(TriggerReferencingStruct)e.nextElement();
0: 					buf.append(trn.toString());
0: 					buf.append("\n");
0: 				}
0: 				refString = buf.toString();
0: 			}
0: 
0: 			return super.toString() +
0: 				"tableName: "+tableName+		
0: 				"\ntriggerEventMask: "+triggerEventMask+		
0: 				"\nisBefore: "+isBefore+		
0: 				"\nisRow: "+isRow+		
0: 				"\nisEnabled: "+isEnabled+		
0: 				"\nwhenText: "+whenText+
0: 				"\nrefClause: "+refString+
0: 				"\nactionText: "+actionText+
0: 				"\n";
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: }
============================================================================