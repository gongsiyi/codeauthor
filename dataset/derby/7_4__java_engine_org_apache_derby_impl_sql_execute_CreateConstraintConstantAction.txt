1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.CreateConstraintConstantAction
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
7:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1:eac0369: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DDUtils;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ForeignKeyConstraintDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ReferencedKeyConstraintDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:eac0369: import org.apache.derby.iapi.sql.depend.Provider;
1:eac0369: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.services.loader.ClassFactory;
1:09bee7d: import org.apache.derby.iapi.services.property.PropertyUtil;
1:09bee7d: import org.apache.derby.impl.sql.compile.ConstraintDefinitionNode;
1:eac0369: 
3:eac0369: /**
1:eac0369:  *	This class  describes actions that are ALWAYS performed for a
1:eac0369:  *	constraint creation at Execution time.
3:eac0369:  *
1:eac0369:  *	@version 0.1
1:eac0369:  */
1:eac0369: 
1:eac0369: public class CreateConstraintConstantAction extends ConstraintConstantAction
4:eac0369: {
1:68db840:     private final boolean forCreateTable;
1:68db840:     
1:68db840: 	private String[]		columnNames;
1:5b2f5de: 	private	String			constraintText;
1:eac0369: 
1:eac0369: 	private ConstraintInfo	otherConstraintInfo;
1:eac0369: 	private	ClassFactory	cf;
1:eac0369: 
1:eac0369: 	/*
1:09bee7d:     ** Is this constraint to be created as enforced or not.
1:eac0369: 	** The only way to create a disabled constraint is by
1:eac0369: 	** publishing a disabled constraint.
1:eac0369: 	*/
1:eac0369: 	private boolean			enabled;
1:eac0369: 
1:09bee7d:     // boolean[3]: {deferrable?, initiallyDeferred?, enforced?}
1:09bee7d:     private boolean[]       characteristics;
1:09bee7d: 
1:09bee7d:     private ProviderInfo[] providerInfo;
1:eac0369: 
1:eac0369: 	// CONSTRUCTORS
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Make one of these puppies.
1:eac0369: 	 *
1:eac0369: 	 *  @param constraintName	Constraint name.
1:eac0369: 	 *  @param constraintType	Constraint type.
1:09bee7d:      *  @param characteristics  Constraint characteristics
1:68db840:      *  @param forCreateTable   Constraint is being added for a CREATE TABLE
1:eac0369: 	 *  @param tableName		Table name.
1:eac0369: 	 *	@param tableId			UUID of table.
1:eac0369: 	 *  @param schemaName		the schema that table and constraint lives in.
1:eac0369: 	 *  @param columnNames		String[] for column names
1:eac0369: 	 *  @param indexAction		IndexConstantAction for constraint (if necessary)
1:eac0369: 	 *  @param constraintText	Text for check constraint
1:eac0369: 	 *	@param otherConstraint 	information about the constraint that this references
1:eac0369: 	 *  @param providerInfo Information on all the Providers
1:eac0369: 	 */
1:eac0369: 	CreateConstraintConstantAction(
1:eac0369: 		               String	constraintName,
1:eac0369: 					   int		constraintType,
1:09bee7d:                        boolean[] characteristics,
1:68db840:                        boolean  forCreateTable,
1:eac0369: 		               String	tableName,
1:eac0369: 					   UUID		tableId,
1:eac0369: 					   String	schemaName,
1:eac0369: 					   String[]	columnNames,
1:eac0369: 					   IndexConstantAction indexAction,
1:eac0369: 					   String	constraintText,
1:eac0369: 				       ConstraintInfo	otherConstraint,
1:eac0369: 					   ProviderInfo[] providerInfo)
1:eac0369: 	{
1:eac0369: 		super(constraintName, constraintType, tableName, 
1:eac0369: 			  tableId, schemaName, indexAction);
1:68db840:         this.forCreateTable = forCreateTable;
1:eac0369: 		this.columnNames = columnNames;
1:eac0369: 		this.constraintText = constraintText;
1:09bee7d:         this.characteristics = characteristics.clone();
1:eac0369: 		this.otherConstraintInfo = otherConstraint;
1:eac0369: 		this.providerInfo = providerInfo;
4:eac0369: 	}
1:eac0369: 
1:eac0369: 	// INTERFACE METHODS
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	This is the guts of the Execution-time logic for CREATE CONSTRAINT.
1:1429957: 	 *  <P>
1:1429957: 	 *  A constraint is represented as:
1:1429957: 	 *  <UL>
1:1429957: 	 *  <LI> ConstraintDescriptor.
1:1429957: 	 *  </UL>
1:1429957: 	 *  If a backing index is required then the index will
1:1429957: 	 *  be created through an CreateIndexConstantAction setup
1:1429957: 	 *  by the compiler.
1:1429957: 	 *  <BR>
1:1429957: 	 *  Dependencies are created as:
1:1429957: 	 *  <UL>
1:1429957: 	 *  <LI> ConstraintDescriptor depends on all the providers collected
1:1429957:      *  at compile time and passed into the constructor.
1:1429957: 	 *  <LI> For a FOREIGN KEY constraint ConstraintDescriptor depends
1:1429957:      *  on the ConstraintDescriptor for the referenced constraints
1:1429957:      *  and the privileges required to create the constraint.
1:1429957: 	 *  </UL>
1:1429957: 
1:1429957: 	 *  @see ConstraintDescriptor
1:1429957: 	 *  @see CreateIndexConstantAction
1:eac0369: 	 *	@see ConstantAction#executeConstantAction
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:eac0369: 	public void	executeConstantAction( Activation activation )
1:eac0369: 						throws StandardException
1:eac0369: 	{
1:eac0369: 		ConglomerateDescriptor		conglomDesc = null;
1:eac0369: 		ConglomerateDescriptor[]	conglomDescs = null;
1:eac0369: 		ConstraintDescriptor		conDesc = null;
1:eac0369: 		TableDescriptor				td = null;
1:eac0369: 		UUID						indexId = null;
1:eac0369: 		String						uniqueName;
1:eac0369: 		String						backingIndexName;
1:eac0369: 
1:eac0369: 		/* RESOLVE - blow off not null constraints for now (and probably for ever) */
1:eac0369: 		if (constraintType == DataDictionary.NOTNULL_CONSTRAINT)
1:eac0369: 		{
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
1:eac0369: 		DataDictionary dd = lcc.getDataDictionary();
1:eac0369: 		DependencyManager dm = dd.getDependencyManager();
1:eac0369: 		TransactionController tc = lcc.getTransactionExecute();
1:eac0369: 
1:eac0369: 		cf = lcc.getLanguageConnectionFactory().getClassFactory();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Inform the data dictionary that we are about to write to it.
1:eac0369: 		** There are several calls to data dictionary "get" methods here
1:eac0369: 		** that might be done in "read" mode in the data dictionary, but
1:eac0369: 		** it seemed safer to do this whole operation in "write" mode.
1:eac0369: 		**
1:eac0369: 		** We tell the data dictionary we're done writing at the end of
1:eac0369: 		** the transaction.
1:eac0369: 		*/
1:eac0369: 		dd.startWriting(lcc);
1:eac0369: 
1:eac0369: 		/* Table gets locked in AlterTableConstantAction */
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** If the schema descriptor is null, then
1:eac0369: 		** we must have just read ourselves in.  
1:eac0369: 		** So we will get the corresponding schema
1:eac0369: 		** descriptor from the data dictionary.
1:eac0369: 		*/
1:eac0369: 
1:eac0369: 		SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, tc, true);
1:eac0369: 		
1:eac0369: 		/* Try to get the TableDescriptor from
1:eac0369: 		 * the Activation. We will go to the
1:eac0369: 		 * DD if not there. (It should always be
1:eac0369: 		 * there except when in a target.)
1:eac0369: 		 */
1:eac0369: 		td = activation.getDDLTableDescriptor();
1:eac0369: 
1:eac0369: 		if (td == null)
1:eac0369: 		{
1:eac0369: 			/* tableId will be non-null if adding a
1:eac0369: 			 * constraint to an existing table.
1:eac0369: 			 */
1:eac0369: 			if (tableId != null)
1:eac0369: 			{
1:eac0369: 				td = dd.getTableDescriptor(tableId);
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:0978789: 				td = dd.getTableDescriptor(tableName, sd, tc);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (td == null)
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION, tableName);
1:eac0369: 			}
1:eac0369: 			activation.setDDLTableDescriptor(td);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Generate the UUID for the backing index.  This will become the
1:eac0369: 		 * constraint's name, if no name was specified.
1:eac0369: 		 */
1:eac0369: 		UUIDFactory uuidFactory = dd.getUUIDFactory();
1:1429957:         
1:f6d02c9:         UUID constrId = uuidFactory.createUUID();
1:f6d02c9: 
1:eac0369: 		/* Create the index, if there's one for this constraint */
1:eac0369: 		if (indexAction != null)
1:eac0369: 		{
1:eac0369: 			if ( indexAction.getIndexName() == null )
1:eac0369: 			{
1:eac0369: 				/* Set the index name */
1:eac0369: 				backingIndexName =  uuidFactory.createUUID().toString();
1:eac0369: 				indexAction.setIndexName(backingIndexName);
1:eac0369: 			}
1:eac0369: 			else { backingIndexName = indexAction.getIndexName(); }
1:1429957: 
1:f6d02c9:             indexAction.setConstraintID( constrId );
1:eac0369: 
1:eac0369: 			/* Create the index */
1:eac0369: 			indexAction.executeConstantAction(activation);
1:eac0369: 
1:eac0369: 			/* Get the conglomerate descriptor for the backing index */
1:eac0369: 			conglomDescs = td.getConglomerateDescriptors();
1:eac0369: 
1:eac0369: 			for (int index = 0; index < conglomDescs.length; index++)
1:eac0369: 			{
1:eac0369: 				conglomDesc = conglomDescs[index];
1:eac0369: 
1:eac0369: 				/* Check for conglomerate being an index first, since
1:eac0369: 				 * name is null for heap.
1:eac0369: 				 */
1:eac0369: 				if (conglomDesc.isIndex() && 
1:eac0369: 					backingIndexName.equals(conglomDesc.getConglomerateName()))
1:eac0369: 				{
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:09bee7d: 
2:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(conglomDesc != null,
1:eac0369: 					"conglomDesc is expected to be non-null after search for backing index");
1:eac0369: 				SanityManager.ASSERT(conglomDesc.isIndex(),
1:eac0369: 					"conglomDesc is expected to be indexable after search for backing index");
1:eac0369: 				SanityManager.ASSERT(conglomDesc.getConglomerateName().equals(backingIndexName),
1:eac0369: 			   "conglomDesc name expected to be the same as backing index name after search for backing index");
1:eac0369: 			}
1:09bee7d: 
1:eac0369: 			indexId = conglomDesc.getUUID();
1:eac0369: 		}
1:09bee7d: 
1:09bee7d:         boolean[] defaults = new boolean[]{
1:09bee7d:             ConstraintDefinitionNode.DEFERRABLE_DEFAULT,
1:09bee7d:             ConstraintDefinitionNode.INITIALLY_DEFERRED_DEFAULT,
1:09bee7d:             ConstraintDefinitionNode.ENFORCED_DEFAULT
1:09bee7d:         };
1:09bee7d: 
1:09bee7d:         for (int i=0; i < characteristics.length; i++) {
1:09bee7d:             if (characteristics[i] != defaults[i]) {
1:0c5bc3a:                 dd.checkVersion(DataDictionary.DD_VERSION_DERBY_10_11,
1:0c5bc3a:                                 "DEFERRED CONSTRAINTS");
1:0c5bc3a: 
1:4cc0287:                 if (constraintType == DataDictionary.NOTNULL_CONSTRAINT ||
1:831e54e:                     !characteristics[2] /* not enforced */) {
1:831e54e: 
1:831e54e:                     // Remove when feature DERBY-532 is completed
1:831e54e:                     if (!PropertyUtil.
1:831e54e:                             getSystemProperty("derby.constraintsTesting",
1:831e54e:                                               "false").equals("true")) {
1:831e54e:                         throw StandardException.newException(
1:831e54e:                             SQLState.NOT_IMPLEMENTED,
1:09bee7d:                             "non-default constraint characteristics");
1:831e54e:                     }
1:09bee7d:                 }
1:09bee7d:             }
1:09bee7d:         }
1:09bee7d: 
1:eac0369: 		/* Now, lets create the constraint descriptor */
1:eac0369: 		DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();
1:eac0369: 		switch (constraintType)
1:eac0369: 		{
1:eac0369: 			case DataDictionary.PRIMARYKEY_CONSTRAINT:
1:eac0369: 				conDesc = ddg.newPrimaryKeyConstraintDescriptor(
1:eac0369: 								td, constraintName,
1:09bee7d:                                 characteristics[0], //deferable,
1:09bee7d:                                 characteristics[1], //initiallyDeferred,
1:eac0369: 								genColumnPositions(td, false), //int[],
1:af1c18c:                                 constrId,
1:eac0369: 								indexId, 
1:eac0369: 								sd,
1:09bee7d:                                 characteristics[2],
1:eac0369: 								0				// referenceCount
1:eac0369: 								);
1:eac0369: 				dd.addConstraintDescriptor(conDesc, tc);
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			case DataDictionary.UNIQUE_CONSTRAINT:
1:eac0369: 				conDesc = ddg.newUniqueConstraintDescriptor(
1:eac0369: 								td, constraintName,
1:09bee7d:                                 characteristics[0], //deferable,
1:09bee7d:                                 characteristics[1], //initiallyDeferred,
1:eac0369: 								genColumnPositions(td, false), //int[],
1:af1c18c:                                 constrId,
1:eac0369: 								indexId, 
1:eac0369: 								sd,
1:09bee7d:                                 characteristics[2],
1:eac0369: 								0				// referenceCount
1:eac0369: 								);
1:eac0369: 				dd.addConstraintDescriptor(conDesc, tc);
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			case DataDictionary.CHECK_CONSTRAINT:
1:eac0369: 				conDesc = ddg.newCheckConstraintDescriptor(
1:eac0369: 								td, constraintName,
1:09bee7d:                                 characteristics[0], //deferable,
1:09bee7d:                                 characteristics[1], //initiallyDeferred,
1:af1c18c:                                 constrId,
1:eac0369: 								constraintText, 
1:eac0369: 								new ReferencedColumnsDescriptorImpl(genColumnPositions(td, false)), //int[],
1:eac0369: 								sd,
1:09bee7d:                                 characteristics[2]
1:eac0369: 								);
1:eac0369: 				dd.addConstraintDescriptor(conDesc, tc);
1:1a63d73: 				storeConstraintDependenciesOnPrivileges
1:8875d69: 					(activation, conDesc, null, providerInfo);
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			case DataDictionary.FOREIGNKEY_CONSTRAINT:
1:eac0369: 				ReferencedKeyConstraintDescriptor referencedConstraint = DDUtils.locateReferencedConstraint
1:eac0369: 					( dd, td, constraintName, columnNames, otherConstraintInfo );
1:eac0369: 				DDUtils.validateReferentialActions(dd, td, constraintName, otherConstraintInfo,columnNames);
1:eac0369: 				
1:eac0369: 				conDesc = ddg.newForeignKeyConstraintDescriptor(
1:eac0369: 								td, constraintName,
1:09bee7d:                                 characteristics[0], //deferable,
1:09bee7d:                                 characteristics[1], //initiallyDeferred,
1:eac0369: 								genColumnPositions(td, false), //int[],
1:af1c18c:                                 constrId,
1:eac0369: 								indexId,
1:eac0369: 								sd,
1:eac0369: 								referencedConstraint,
1:09bee7d:                                 characteristics[2],
1:eac0369: 								otherConstraintInfo.getReferentialActionDeleteRule(),
1:eac0369: 								otherConstraintInfo.getReferentialActionUpdateRule()
1:eac0369: 								);
1:eac0369: 
1:eac0369: 				// try to create the constraint first, because it
1:eac0369: 				// is expensive to do the bulk check, find obvious
1:eac0369: 				// errors first
1:eac0369: 				dd.addConstraintDescriptor(conDesc, tc);
1:eac0369: 
1:eac0369: 				/* No need to do check if we're creating a 
1:eac0369: 				 * table.
1:eac0369: 				 */
1:eac0369: 				if ( (! forCreateTable) && 
1:eac0369: 					 dd.activeConstraint( conDesc ) )
1:eac0369: 				{
1:4cc0287:                     validateFKConstraint(activation,
1:4cc0287:                                          tc,
1:eac0369: 										 dd, 
1:eac0369: 										 (ForeignKeyConstraintDescriptor)conDesc, 
1:eac0369: 										 referencedConstraint,
1:eac0369: 										 ((CreateIndexConstantAction)indexAction).getIndexTemplateRow());
1:eac0369: 				}
1:eac0369: 				
1:eac0369: 				/* Create stored dependency on the referenced constraint */
1:eac0369: 				dm.addDependency(conDesc, referencedConstraint, lcc.getContextManager());
1:2d2e717: 				//store constraint's dependency on REFERENCES privileges in the dependeny system
1:8875d69: 				storeConstraintDependenciesOnPrivileges
1:8875d69: 					(activation,
1:8875d69: 					 conDesc,
1:8875d69: 					 referencedConstraint.getTableId(),
1:8875d69: 					 providerInfo);
1:eac0369: 				break;
1:eac0369: 
1:09bee7d:             case DataDictionary.MODIFY_CONSTRAINT:
1:09bee7d:                 throw StandardException.newException(SQLState.NOT_IMPLEMENTED,
1:09bee7d:                        "ALTER CONSTRAINT");
1:09bee7d: 
1:eac0369: 			default:
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT("contraintType (" + constraintType + 
1:eac0369: 						") has unexpected value");
1:eac0369: 				}
1:eac0369: 				break;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 		/* Create stored dependencies for each provider */
1:eac0369: 		if (providerInfo != null)
1:eac0369: 		{
1:eac0369: 			for (int ix = 0; ix < providerInfo.length; ix++)
1:eac0369: 			{
1:eac0369: 				Provider provider = null;
1:eac0369: 	
1:eac0369: 				/* We should always be able to find the Provider */
1:eac0369: 					provider = (Provider) providerInfo[ix].
1:eac0369: 											getDependableFinder().
1:2bb479f: 												getDependable(dd, 
1:eac0369: 													providerInfo[ix].getObjectId());
1:2bb479f: 
1:eac0369: 				dm.addDependency(conDesc, provider, lcc.getContextManager());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Finally, invalidate off of the table descriptor(s)
1:eac0369: 		 * to ensure that any dependent statements get
1:eac0369: 		 * re-compiled.
1:eac0369: 		 */
1:eac0369: 		if (! forCreateTable)
1:eac0369: 		{
1:eac0369: 			dm.invalidateFor(td, DependencyManager.CREATE_CONSTRAINT, lcc);
1:eac0369: 		}
1:eac0369: 		if (constraintType == DataDictionary.FOREIGNKEY_CONSTRAINT)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(conDesc != null,
1:eac0369: 					"conDesc expected to be non-null");
1:eac0369: 
1:eac0369: 				if (! (conDesc instanceof ForeignKeyConstraintDescriptor))
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 						"conDesc expected to be instance of ForeignKeyConstraintDescriptor, not " +
1:eac0369: 						conDesc.getClass().getName());
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			dm.invalidateFor(
1:eac0369: 				((ForeignKeyConstraintDescriptor)conDesc).
1:eac0369: 					getReferencedConstraint().
1:eac0369: 						getTableDescriptor(),
1:eac0369: 				DependencyManager.CREATE_CONSTRAINT, lcc);
1:eac0369: 		}
1:af1c18c: 
1:af1c18c:         this.constraintId = constrId;
1:eac0369: 	}
1:2d2e717: 	
1:eac0369: 	/**
1:eac0369: 	 * Is the constant action for a foreign key
1:eac0369: 	 *
1:eac0369: 	 * @return true/false
1:eac0369: 	 */
1:1429957: 	boolean isForeignKeyConstraint()
1:eac0369: 	{ 
1:eac0369: 		return (constraintType == DataDictionary.FOREIGNKEY_CONSTRAINT);
1:eac0369: 	}
1:af1c18c: 
1:eac0369: 
1:af1c18c:     boolean isInitiallyDeferred() {
1:af1c18c:         return characteristics[1];
1:af1c18c:     }
1:af1c18c: 
1:eac0369: 	/**
1:eac0369: 	 * Generate an array of column positions for the column list in
1:eac0369: 	 * the constraint.
1:eac0369: 	 *
1:eac0369: 	 * @param td	The TableDescriptor for the table in question
1:eac0369: 	 * @param columnsMustBeOrderable	true for primaryKey and unique constraints
1:eac0369: 	 *
1:eac0369: 	 * @return int[]	The column positions.
1:eac0369: 	 */
1:eac0369: 	private int[] genColumnPositions(TableDescriptor td,
1:eac0369: 									 boolean columnsMustBeOrderable)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int[] baseColumnPositions;
1:eac0369: 
1:eac0369: 		// Translate the base column names to column positions
1:eac0369: 		baseColumnPositions = new int[columnNames.length];
1:eac0369: 		for (int i = 0; i < columnNames.length; i++)
1:eac0369: 		{
1:eac0369: 			ColumnDescriptor columnDescriptor;
1:eac0369: 
1:eac0369: 			// Look up the column in the data dictionary
1:eac0369: 			columnDescriptor = td.getColumnDescriptor(columnNames[i]);
1:eac0369: 			if (columnDescriptor == null)
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, 
1:eac0369: 															columnNames[i],
1:eac0369: 															tableName);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// Don't allow a column to be created on a non-orderable type
1:eac0369: 			// (for primaryKey and unique constraints)
1:eac0369: 			if ( columnsMustBeOrderable &&
1:eac0369: 				 ( ! columnDescriptor.getType().getTypeId().orderable(
1:eac0369: 															cf))
1:eac0369: 			   )
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_COLUMN_NOT_ORDERABLE_DURING_EXECUTION, 
1:eac0369: 					columnDescriptor.getType().getTypeId().getSQLTypeName());
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// Remember the position in the base table of each column
1:eac0369: 			baseColumnPositions[i] = columnDescriptor.getPosition();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return baseColumnPositions;
1:eac0369: 	}
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	ACCESSORS
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Get the text defining this constraint.
1:eac0369: 	  *
1:eac0369: 	  *	@return	constraint text
1:eac0369: 	  */
1:1429957:     String	getConstraintText() { return constraintText; }
1:eac0369: 
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		// Do not put this under SanityManager.DEBUG - it is needed for
1:eac0369: 		// error reporting.
1:eac0369: 		StringBuffer strbuf = new StringBuffer();
1:eac0369: 		strbuf.append( "CREATE CONSTRAINT " + constraintName );
1:eac0369: 		strbuf.append("\n=========================\n");
1:eac0369: 
1:eac0369: 		if (columnNames == null)
1:eac0369: 		{
1:eac0369: 			strbuf.append("columnNames == null\n");
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			for (int ix=0; ix < columnNames.length; ix++)
1:eac0369: 			{
1:eac0369: 				strbuf.append("\n\tcol["+ix+"]"+columnNames[ix].toString());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		strbuf.append("\n");
1:eac0369: 		strbuf.append(constraintText);
1:eac0369: 		strbuf.append("\n");
1:eac0369: 		if (otherConstraintInfo != null)
1:eac0369: 		{
1:eac0369: 			strbuf.append(otherConstraintInfo.toString());
1:eac0369: 		}
1:eac0369: 		strbuf.append("\n");
1:eac0369: 		return strbuf.toString();
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:f6d02c9
/////////////////////////////////////////////////////////////////////////
1:         UUID constrId = uuidFactory.createUUID();
1: 
/////////////////////////////////////////////////////////////////////////
1:             indexAction.setConstraintID( constrId );
/////////////////////////////////////////////////////////////////////////
commit:4cc0287
/////////////////////////////////////////////////////////////////////////
1:                 if (constraintType == DataDictionary.NOTNULL_CONSTRAINT ||
/////////////////////////////////////////////////////////////////////////
1:                     validateFKConstraint(activation,
1:                                          tc,
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
0:         UUID constrId=  uuidFactory.createUUID();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                                 constrId,
/////////////////////////////////////////////////////////////////////////
1:                                 constrId,
/////////////////////////////////////////////////////////////////////////
1:                                 constrId,
/////////////////////////////////////////////////////////////////////////
1:                                 constrId,
/////////////////////////////////////////////////////////////////////////
1: 
1:         this.constraintId = constrId;
/////////////////////////////////////////////////////////////////////////
1: 
1:     boolean isInitiallyDeferred() {
1:         return characteristics[1];
1:     }
1: 
commit:831e54e
/////////////////////////////////////////////////////////////////////////
0:                 if (constraintType == DataDictionary.FOREIGNKEY_CONSTRAINT ||
0:                     constraintType == DataDictionary.CHECK_CONSTRAINT ||
0:                     constraintType == DataDictionary.NOTNULL_CONSTRAINT ||
1:                     !characteristics[2] /* not enforced */) {
1: 
1:                     // Remove when feature DERBY-532 is completed
1:                     if (!PropertyUtil.
1:                             getSystemProperty("derby.constraintsTesting",
1:                                               "false").equals("true")) {
1:                         throw StandardException.newException(
1:                             SQLState.NOT_IMPLEMENTED,
1:                     }
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1:                 dd.checkVersion(DataDictionary.DD_VERSION_DERBY_10_11,
1:                                 "DEFERRED CONSTRAINTS");
1: 
0:                 if (!PropertyUtil.getSystemProperty(
0:                         "derby.constraintsTesting", "false").equals("true")) {
commit:09bee7d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.property.PropertyUtil;
1: import org.apache.derby.impl.sql.compile.ConstraintDefinitionNode;
/////////////////////////////////////////////////////////////////////////
1:     ** Is this constraint to be created as enforced or not.
1:     // boolean[3]: {deferrable?, initiallyDeferred?, enforced?}
1:     private boolean[]       characteristics;
1: 
1:     private ProviderInfo[] providerInfo;
/////////////////////////////////////////////////////////////////////////
1:      *  @param characteristics  Constraint characteristics
/////////////////////////////////////////////////////////////////////////
1:                        boolean[] characteristics,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         this.characteristics = characteristics.clone();
/////////////////////////////////////////////////////////////////////////
1:         boolean[] defaults = new boolean[]{
1:             ConstraintDefinitionNode.DEFERRABLE_DEFAULT,
1:             ConstraintDefinitionNode.INITIALLY_DEFERRED_DEFAULT,
1:             ConstraintDefinitionNode.ENFORCED_DEFAULT
1:         };
1: 
1:         for (int i=0; i < characteristics.length; i++) {
1:             if (characteristics[i] != defaults[i]) {
0:                 // Remove when feature DERBY-532 is completed
0:                 if (!PropertyUtil.getSystemProperty("derby.constraintsTesting",
0:                         tableName).equals("true")) {
1:                     throw StandardException.newException(SQLState.NOT_IMPLEMENTED,
1:                             "non-default constraint characteristics");
1:                 }
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:                                 characteristics[0], //deferable,
1:                                 characteristics[1], //initiallyDeferred,
1:                                 characteristics[2],
/////////////////////////////////////////////////////////////////////////
1:                                 characteristics[0], //deferable,
1:                                 characteristics[1], //initiallyDeferred,
1:                                 characteristics[2],
/////////////////////////////////////////////////////////////////////////
1:                                 characteristics[0], //deferable,
1:                                 characteristics[1], //initiallyDeferred,
1:                                 characteristics[2]
/////////////////////////////////////////////////////////////////////////
1:                                 characteristics[0], //deferable,
1:                                 characteristics[1], //initiallyDeferred,
1:                                 characteristics[2],
/////////////////////////////////////////////////////////////////////////
1:             case DataDictionary.MODIFY_CONSTRAINT:
0:                 throw StandardException.newException(SQLState.NOT_IMPLEMENTED,
1:                        "ALTER CONSTRAINT");
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 
commit:8875d69
/////////////////////////////////////////////////////////////////////////
1: 					(activation, conDesc, null, providerInfo);
/////////////////////////////////////////////////////////////////////////
1: 				storeConstraintDependenciesOnPrivileges
1: 					(activation,
1: 					 conDesc,
1: 					 referencedConstraint.getTableId(),
1: 					 providerInfo);
commit:1a63d73
/////////////////////////////////////////////////////////////////////////
1: 				storeConstraintDependenciesOnPrivileges
0: 					(activation, conDesc, null);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:0978789
/////////////////////////////////////////////////////////////////////////
1: 				td = dd.getTableDescriptor(tableName, sd, tc);
commit:68db840
/////////////////////////////////////////////////////////////////////////
1:     private final boolean forCreateTable;
1:     
1: 	private String[]		columnNames;
/////////////////////////////////////////////////////////////////////////
1:      *  @param forCreateTable   Constraint is being added for a CREATE TABLE
/////////////////////////////////////////////////////////////////////////
1:                        boolean  forCreateTable,
/////////////////////////////////////////////////////////////////////////
1:         this.forCreateTable = forCreateTable;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:1429957
/////////////////////////////////////////////////////////////////////////
1: 	 *  <P>
1: 	 *  A constraint is represented as:
1: 	 *  <UL>
1: 	 *  <LI> ConstraintDescriptor.
1: 	 *  </UL>
1: 	 *  If a backing index is required then the index will
1: 	 *  be created through an CreateIndexConstantAction setup
1: 	 *  by the compiler.
1: 	 *  <BR>
1: 	 *  Dependencies are created as:
1: 	 *  <UL>
1: 	 *  <LI> ConstraintDescriptor depends on all the providers collected
1:      *  at compile time and passed into the constructor.
1: 	 *  <LI> For a FOREIGN KEY constraint ConstraintDescriptor depends
1:      *  on the ConstraintDescriptor for the referenced constraints
1:      *  and the privileges required to create the constraint.
1: 	 *  </UL>
1: 
1: 	 *  @see ConstraintDescriptor
1: 	 *  @see CreateIndexConstantAction
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	boolean isForeignKeyConstraint()
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     String	getConstraintText() { return constraintText; }
commit:2bb479f
/////////////////////////////////////////////////////////////////////////
1: 												getDependable(dd, 
1: 
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				//store constraint's dependency on REFERENCES privileges in the dependeny system
0: 				storeConstraintDependenciesOnPrivileges(activation, conDesc, referencedConstraint.getTableId());				
/////////////////////////////////////////////////////////////////////////
1: 	
commit:5b2f5de
/////////////////////////////////////////////////////////////////////////
0: 	String[]		columnNames;
1: 	private	String			constraintText;
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.CreateConstraintConstantAction
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: 
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
1: import org.apache.derby.iapi.sql.dictionary.DDUtils;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
1: import org.apache.derby.iapi.sql.dictionary.ForeignKeyConstraintDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ReferencedKeyConstraintDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
0: import org.apache.derby.iapi.types.DataValueFactory;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: import org.apache.derby.iapi.sql.depend.Provider;
1: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1: 
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: 
1: import org.apache.derby.iapi.sql.Activation;
1: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.services.loader.ClassFactory;
1: 
1: /**
1:  *	This class  describes actions that are ALWAYS performed for a
1:  *	constraint creation at Execution time.
1:  *
1:  *	@version 0.1
0:  *	@author Jerry Brenner
1:  */
1: 
1: public class CreateConstraintConstantAction extends ConstraintConstantAction
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public	String[]		columnNames;
0: 	public	String			constraintText;
1: 
1: 	private ConstraintInfo	otherConstraintInfo;
1: 	private	ClassFactory	cf;
1: 
1: 	/*
0: 	** Is this constraint to be created as enabled or not.
1: 	** The only way to create a disabled constraint is by
1: 	** publishing a disabled constraint.
1: 	*/
1: 	private boolean			enabled;
1: 
0: 	private ProviderInfo[] providerInfo;
1: 
1: 	// CONSTRUCTORS
1: 
1: 	/**
1: 	 *	Make one of these puppies.
1: 	 *
1: 	 *  @param constraintName	Constraint name.
1: 	 *  @param constraintType	Constraint type.
1: 	 *  @param tableName		Table name.
1: 	 *	@param tableId			UUID of table.
1: 	 *  @param schemaName		the schema that table and constraint lives in.
1: 	 *  @param columnNames		String[] for column names
1: 	 *  @param indexAction		IndexConstantAction for constraint (if necessary)
1: 	 *  @param constraintText	Text for check constraint
0: 	 *  RESOLVE - the next parameter should go away once we use UUIDs
0: 	 *			  (Generated constraint names will be based off of uuids)
0: 	 *	@param enabled			Should the constraint be created as enabled 
0: 	 *							(enabled == true), or disabled (enabled == false).
1: 	 *	@param otherConstraint 	information about the constraint that this references
1: 	 *  @param providerInfo Information on all the Providers
1: 	 */
1: 	CreateConstraintConstantAction(
1: 		               String	constraintName,
1: 					   int		constraintType,
1: 		               String	tableName,
1: 					   UUID		tableId,
1: 					   String	schemaName,
1: 					   String[]	columnNames,
1: 					   IndexConstantAction indexAction,
1: 					   String	constraintText,
0: 					   boolean	enabled,
1: 				       ConstraintInfo	otherConstraint,
1: 					   ProviderInfo[] providerInfo)
1: 	{
1: 		super(constraintName, constraintType, tableName, 
1: 			  tableId, schemaName, indexAction);
1: 		this.columnNames = columnNames;
1: 		this.constraintText = constraintText;
0: 		this.enabled = enabled;
1: 		this.otherConstraintInfo = otherConstraint;
1: 		this.providerInfo = providerInfo;
1: 	}
1: 
1: 	// INTERFACE METHODS
1: 
1: 
1: 	/**
1: 	 *	This is the guts of the Execution-time logic for CREATE CONSTRAINT.
1: 	 *
1: 	 *	@see ConstantAction#executeConstantAction
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
1: 	public void	executeConstantAction( Activation activation )
1: 						throws StandardException
1: 	{
0: 		boolean						forCreateTable;
1: 		ConglomerateDescriptor		conglomDesc = null;
1: 		ConglomerateDescriptor[]	conglomDescs = null;
1: 		ConstraintDescriptor		conDesc = null;
1: 		TableDescriptor				td = null;
1: 		UUID						indexId = null;
1: 		String						uniqueName;
1: 		String						backingIndexName;
1: 
1: 		/* RESOLVE - blow off not null constraints for now (and probably for ever) */
1: 		if (constraintType == DataDictionary.NOTNULL_CONSTRAINT)
1: 		{
1: 			return;
1: 		}
1: 
1: 		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
1: 		DataDictionary dd = lcc.getDataDictionary();
1: 		DependencyManager dm = dd.getDependencyManager();
1: 		TransactionController tc = lcc.getTransactionExecute();
1: 
1: 		cf = lcc.getLanguageConnectionFactory().getClassFactory();
1: 
0: 		/* Remember whether or not we are doing a create table */
0: 		forCreateTable = activation.getForCreateTable();
1: 
1: 		/*
1: 		** Inform the data dictionary that we are about to write to it.
1: 		** There are several calls to data dictionary "get" methods here
1: 		** that might be done in "read" mode in the data dictionary, but
1: 		** it seemed safer to do this whole operation in "write" mode.
1: 		**
1: 		** We tell the data dictionary we're done writing at the end of
1: 		** the transaction.
1: 		*/
1: 		dd.startWriting(lcc);
1: 
1: 		/* Table gets locked in AlterTableConstantAction */
1: 
1: 		/*
1: 		** If the schema descriptor is null, then
1: 		** we must have just read ourselves in.  
1: 		** So we will get the corresponding schema
1: 		** descriptor from the data dictionary.
1: 		*/
1: 
1: 		SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, tc, true);
1: 		
1: 		/* Try to get the TableDescriptor from
1: 		 * the Activation. We will go to the
1: 		 * DD if not there. (It should always be
1: 		 * there except when in a target.)
1: 		 */
1: 		td = activation.getDDLTableDescriptor();
1: 
1: 		if (td == null)
1: 		{
1: 			/* tableId will be non-null if adding a
1: 			 * constraint to an existing table.
1: 			 */
1: 			if (tableId != null)
1: 			{
1: 				td = dd.getTableDescriptor(tableId);
1: 			}
1: 			else
1: 			{
0: 				td = dd.getTableDescriptor(tableName, sd);
1: 			}
1: 
1: 			if (td == null)
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION, tableName);
1: 			}
1: 			activation.setDDLTableDescriptor(td);
1: 		}
1: 
1: 		/* Generate the UUID for the backing index.  This will become the
1: 		 * constraint's name, if no name was specified.
1: 		 */
1: 		UUIDFactory uuidFactory = dd.getUUIDFactory();
1: 
1: 		/* Create the index, if there's one for this constraint */
1: 		if (indexAction != null)
1: 		{
1: 			if ( indexAction.getIndexName() == null )
1: 			{
1: 				/* Set the index name */
1: 				backingIndexName =  uuidFactory.createUUID().toString();
1: 				indexAction.setIndexName(backingIndexName);
1: 			}
1: 			else { backingIndexName = indexAction.getIndexName(); }
1: 
1: 			/* Create the index */
1: 			indexAction.executeConstantAction(activation);
1: 
1: 			/* Get the conglomerate descriptor for the backing index */
1: 			conglomDescs = td.getConglomerateDescriptors();
1: 
1: 			for (int index = 0; index < conglomDescs.length; index++)
1: 			{
1: 				conglomDesc = conglomDescs[index];
1: 
1: 				/* Check for conglomerate being an index first, since
1: 				 * name is null for heap.
1: 				 */
1: 				if (conglomDesc.isIndex() && 
1: 					backingIndexName.equals(conglomDesc.getConglomerateName()))
1: 				{
1: 					break;
1: 				}
1: 			}
1: 
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(conglomDesc != null,
1: 					"conglomDesc is expected to be non-null after search for backing index");
1: 				SanityManager.ASSERT(conglomDesc.isIndex(),
1: 					"conglomDesc is expected to be indexable after search for backing index");
1: 				SanityManager.ASSERT(conglomDesc.getConglomerateName().equals(backingIndexName),
1: 			   "conglomDesc name expected to be the same as backing index name after search for backing index");
1: 			}
1: 
1: 			indexId = conglomDesc.getUUID();
1: 		}
1: 
0: 		// if no constraintId was specified, we should generate one. this handles
0: 		// the two cases of Source creation and Target replication. At the source
0: 		// database, we allocate a new UUID. At the Target, we just use the UUID that
0: 		// the Source sent along.
0: 		UUID constraintId = uuidFactory.createUUID();
1: 
1: 		/* Now, lets create the constraint descriptor */
1: 		DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();
1: 		switch (constraintType)
1: 		{
1: 			case DataDictionary.PRIMARYKEY_CONSTRAINT:
1: 				conDesc = ddg.newPrimaryKeyConstraintDescriptor(
1: 								td, constraintName,
0: 								false, //deferable,
0: 								false, //initiallyDeferred,
1: 								genColumnPositions(td, false), //int[],
0: 								constraintId, 
1: 								indexId, 
1: 								sd,
0: 								enabled,
1: 								0				// referenceCount
1: 								);
1: 				dd.addConstraintDescriptor(conDesc, tc);
1: 				break;
1: 
1: 			case DataDictionary.UNIQUE_CONSTRAINT:
1: 				conDesc = ddg.newUniqueConstraintDescriptor(
1: 								td, constraintName,
0: 								false, //deferable,
0: 								false, //initiallyDeferred,
1: 								genColumnPositions(td, false), //int[],
0: 								constraintId, 
1: 								indexId, 
1: 								sd,
0: 								enabled,
1: 								0				// referenceCount
1: 								);
1: 				dd.addConstraintDescriptor(conDesc, tc);
1: 				break;
1: 
1: 			case DataDictionary.CHECK_CONSTRAINT:
1: 				conDesc = ddg.newCheckConstraintDescriptor(
1: 								td, constraintName,
0: 								false, //deferable,
0: 								false, //initiallyDeferred,
0: 								constraintId, 
1: 								constraintText, 
1: 								new ReferencedColumnsDescriptorImpl(genColumnPositions(td, false)), //int[],
1: 								sd,
0: 								enabled
1: 								);
1: 				dd.addConstraintDescriptor(conDesc, tc);
1: 				break;
1: 
1: 			case DataDictionary.FOREIGNKEY_CONSTRAINT:
1: 				ReferencedKeyConstraintDescriptor referencedConstraint = DDUtils.locateReferencedConstraint
1: 					( dd, td, constraintName, columnNames, otherConstraintInfo );
1: 				DDUtils.validateReferentialActions(dd, td, constraintName, otherConstraintInfo,columnNames);
1: 				
1: 				conDesc = ddg.newForeignKeyConstraintDescriptor(
1: 								td, constraintName,
0: 								false, //deferable,
0: 								false, //initiallyDeferred,
1: 								genColumnPositions(td, false), //int[],
0: 								constraintId,
1: 								indexId,
1: 								sd,
1: 								referencedConstraint,
0: 								enabled,
1: 								otherConstraintInfo.getReferentialActionDeleteRule(),
1: 								otherConstraintInfo.getReferentialActionUpdateRule()
1: 								);
1: 
1: 				// try to create the constraint first, because it
1: 				// is expensive to do the bulk check, find obvious
1: 				// errors first
1: 				dd.addConstraintDescriptor(conDesc, tc);
1: 
1: 				/* No need to do check if we're creating a 
1: 				 * table.
1: 				 */
1: 				if ( (! forCreateTable) && 
1: 					 dd.activeConstraint( conDesc ) )
1: 				{
0: 					validateFKConstraint(tc, 
1: 										 dd, 
1: 										 (ForeignKeyConstraintDescriptor)conDesc, 
1: 										 referencedConstraint,
1: 										 ((CreateIndexConstantAction)indexAction).getIndexTemplateRow());
1: 				}
1: 				
1: 				/* Create stored dependency on the referenced constraint */
1: 				dm.addDependency(conDesc, referencedConstraint, lcc.getContextManager());
1: 				break;
1: 
1: 			default:
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.THROWASSERT("contraintType (" + constraintType + 
1: 						") has unexpected value");
1: 				}
1: 				break;
1: 		}
1: 
1: 		/* Create stored dependencies for each provider */
1: 		if (providerInfo != null)
1: 		{
1: 			for (int ix = 0; ix < providerInfo.length; ix++)
1: 			{
1: 				Provider provider = null;
1: 	
1: 				/* We should always be able to find the Provider */
0: 				try 
1: 				{
1: 					provider = (Provider) providerInfo[ix].
1: 											getDependableFinder().
0: 												getDependable(
1: 													providerInfo[ix].getObjectId());
1: 				}
0: 				catch(java.sql.SQLException te)
1: 				{
1: 					if (SanityManager.DEBUG)
1: 					{
0: 						SanityManager.THROWASSERT("unexpected java.sql.SQLException - " + te);
1: 					}
1: 				}
1: 				dm.addDependency(conDesc, provider, lcc.getContextManager());
1: 			}
1: 		}
1: 
1: 		/* Finally, invalidate off of the table descriptor(s)
1: 		 * to ensure that any dependent statements get
1: 		 * re-compiled.
1: 		 */
1: 		if (! forCreateTable)
1: 		{
1: 			dm.invalidateFor(td, DependencyManager.CREATE_CONSTRAINT, lcc);
1: 		}
1: 		if (constraintType == DataDictionary.FOREIGNKEY_CONSTRAINT)
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(conDesc != null,
1: 					"conDesc expected to be non-null");
1: 
1: 				if (! (conDesc instanceof ForeignKeyConstraintDescriptor))
1: 				{
1: 					SanityManager.THROWASSERT(
1: 						"conDesc expected to be instance of ForeignKeyConstraintDescriptor, not " +
1: 						conDesc.getClass().getName());
1: 				}
1: 			}
1: 			dm.invalidateFor(
1: 				((ForeignKeyConstraintDescriptor)conDesc).
1: 					getReferencedConstraint().
1: 						getTableDescriptor(),
1: 				DependencyManager.CREATE_CONSTRAINT, lcc);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Is the constant action for a foreign key
1: 	 *
1: 	 * @return true/false
1: 	 */
0: 	public boolean isForeignKeyConstraint()
1: 	{ 
1: 		return (constraintType == DataDictionary.FOREIGNKEY_CONSTRAINT);
1: 	}
1: 
1: 	/**
1: 	 * Generate an array of column positions for the column list in
1: 	 * the constraint.
1: 	 *
1: 	 * @param td	The TableDescriptor for the table in question
1: 	 * @param columnsMustBeOrderable	true for primaryKey and unique constraints
1: 	 *
1: 	 * @return int[]	The column positions.
1: 	 */
1: 	private int[] genColumnPositions(TableDescriptor td,
1: 									 boolean columnsMustBeOrderable)
1: 		throws StandardException
1: 	{
1: 		int[] baseColumnPositions;
1: 
1: 		// Translate the base column names to column positions
1: 		baseColumnPositions = new int[columnNames.length];
1: 		for (int i = 0; i < columnNames.length; i++)
1: 		{
1: 			ColumnDescriptor columnDescriptor;
1: 
1: 			// Look up the column in the data dictionary
1: 			columnDescriptor = td.getColumnDescriptor(columnNames[i]);
1: 			if (columnDescriptor == null)
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, 
1: 															columnNames[i],
1: 															tableName);
1: 			}
1: 
1: 			// Don't allow a column to be created on a non-orderable type
1: 			// (for primaryKey and unique constraints)
1: 			if ( columnsMustBeOrderable &&
1: 				 ( ! columnDescriptor.getType().getTypeId().orderable(
1: 															cf))
1: 			   )
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_COLUMN_NOT_ORDERABLE_DURING_EXECUTION, 
1: 					columnDescriptor.getType().getTypeId().getSQLTypeName());
1: 			}
1: 
1: 			// Remember the position in the base table of each column
1: 			baseColumnPositions[i] = columnDescriptor.getPosition();
1: 		}
1: 
1: 		return baseColumnPositions;
1: 	}
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	ACCESSORS
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	  *	Get the names of the columns touched by this constraint.
1: 	  *
0: 	  *	@return	the array of touched column names.
1: 	  */
0:     public	String[]	getColumnNames() { return columnNames; }
1: 
1: 
1: 	/**
1: 	  *	Get the text defining this constraint.
1: 	  *
1: 	  *	@return	constraint text
1: 	  */
0:     public	String	getConstraintText() { return constraintText; }
1: 
1: 	public String toString()
1: 	{
1: 		// Do not put this under SanityManager.DEBUG - it is needed for
1: 		// error reporting.
1: 		StringBuffer strbuf = new StringBuffer();
1: 		strbuf.append( "CREATE CONSTRAINT " + constraintName );
1: 		strbuf.append("\n=========================\n");
1: 
1: 		if (columnNames == null)
1: 		{
1: 			strbuf.append("columnNames == null\n");
1: 		}
1: 		else
1: 		{
1: 			for (int ix=0; ix < columnNames.length; ix++)
1: 			{
1: 				strbuf.append("\n\tcol["+ix+"]"+columnNames[ix].toString());
1: 			}
1: 		}
1: 		
1: 		strbuf.append("\n");
1: 		strbuf.append(constraintText);
1: 		strbuf.append("\n");
1: 		if (otherConstraintInfo != null)
1: 		{
1: 			strbuf.append(otherConstraintInfo.toString());
1: 		}
1: 		strbuf.append("\n");
1: 		return strbuf.toString();
1: 	}
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: 
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DDUtils;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.ForeignKeyConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ReferencedKeyConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.sql.depend.ProviderInfo;
0: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: 
0: /**
0:  *	This class  describes actions that are ALWAYS performed for a
0:  *	constraint creation at Execution time.
0:  *
0:  *	@version 0.1
0:  *	@author Jerry Brenner
0:  */
0: 
0: public class CreateConstraintConstantAction extends ConstraintConstantAction
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public	String[]		columnNames;
0: 	public	String			constraintText;
0: 
0: 	private ConstraintInfo	otherConstraintInfo;
0: 	private	ClassFactory	cf;
0: 
0: 	/*
0: 	** Is this constraint to be created as enabled or not.
0: 	** The only way to create a disabled constraint is by
0: 	** publishing a disabled constraint.
0: 	*/
0: 	private boolean			enabled;
0: 
0: 	private ProviderInfo[] providerInfo;
0: 
0: 	// CONSTRUCTORS
0: 
0: 	/**
0: 	 *	Make one of these puppies.
0: 	 *
0: 	 *  @param constraintName	Constraint name.
0: 	 *  @param constraintType	Constraint type.
0: 	 *  @param tableName		Table name.
0: 	 *	@param tableId			UUID of table.
0: 	 *  @param schemaName		the schema that table and constraint lives in.
0: 	 *  @param columnNames		String[] for column names
0: 	 *  @param indexAction		IndexConstantAction for constraint (if necessary)
0: 	 *  @param constraintText	Text for check constraint
0: 	 *  RESOLVE - the next parameter should go away once we use UUIDs
0: 	 *			  (Generated constraint names will be based off of uuids)
0: 	 *	@param enabled			Should the constraint be created as enabled 
0: 	 *							(enabled == true), or disabled (enabled == false).
0: 	 *	@param otherConstraint 	information about the constraint that this references
0: 	 *  @param providerInfo Information on all the Providers
0: 	 */
0: 	CreateConstraintConstantAction(
0: 		               String	constraintName,
0: 					   int		constraintType,
0: 		               String	tableName,
0: 					   UUID		tableId,
0: 					   String	schemaName,
0: 					   String[]	columnNames,
0: 					   IndexConstantAction indexAction,
0: 					   String	constraintText,
0: 					   boolean	enabled,
0: 				       ConstraintInfo	otherConstraint,
0: 					   ProviderInfo[] providerInfo)
0: 	{
0: 		super(constraintName, constraintType, tableName, 
0: 			  tableId, schemaName, indexAction);
0: 		this.columnNames = columnNames;
0: 		this.constraintText = constraintText;
0: 		this.enabled = enabled;
0: 		this.otherConstraintInfo = otherConstraint;
0: 		this.providerInfo = providerInfo;
0: 	}
0: 
0: 	// INTERFACE METHODS
0: 
0: 
0: 	/**
0: 	 *	This is the guts of the Execution-time logic for CREATE CONSTRAINT.
0: 	 *
0: 	 *	@see ConstantAction#executeConstantAction
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public void	executeConstantAction( Activation activation )
0: 						throws StandardException
0: 	{
0: 		boolean						forCreateTable;
0: 		ConglomerateDescriptor		conglomDesc = null;
0: 		ConglomerateDescriptor[]	conglomDescs = null;
0: 		ConstraintDescriptor		conDesc = null;
0: 		TableDescriptor				td = null;
0: 		UUID						indexId = null;
0: 		String						uniqueName;
0: 		String						backingIndexName;
0: 
0: 		/* RESOLVE - blow off not null constraints for now (and probably for ever) */
0: 		if (constraintType == DataDictionary.NOTNULL_CONSTRAINT)
0: 		{
0: 			return;
0: 		}
0: 
0: 		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
0: 		DataDictionary dd = lcc.getDataDictionary();
0: 		DependencyManager dm = dd.getDependencyManager();
0: 		TransactionController tc = lcc.getTransactionExecute();
0: 
0: 		cf = lcc.getLanguageConnectionFactory().getClassFactory();
0: 
0: 		/* Remember whether or not we are doing a create table */
0: 		forCreateTable = activation.getForCreateTable();
0: 
0: 		/*
0: 		** Inform the data dictionary that we are about to write to it.
0: 		** There are several calls to data dictionary "get" methods here
0: 		** that might be done in "read" mode in the data dictionary, but
0: 		** it seemed safer to do this whole operation in "write" mode.
0: 		**
0: 		** We tell the data dictionary we're done writing at the end of
0: 		** the transaction.
0: 		*/
0: 		dd.startWriting(lcc);
0: 
0: 		/* Table gets locked in AlterTableConstantAction */
0: 
0: 		/*
0: 		** If the schema descriptor is null, then
0: 		** we must have just read ourselves in.  
0: 		** So we will get the corresponding schema
0: 		** descriptor from the data dictionary.
0: 		*/
0: 
0: 		SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, tc, true);
0: 		
0: 		/* Try to get the TableDescriptor from
0: 		 * the Activation. We will go to the
0: 		 * DD if not there. (It should always be
0: 		 * there except when in a target.)
0: 		 */
0: 		td = activation.getDDLTableDescriptor();
0: 
0: 		if (td == null)
0: 		{
0: 			/* tableId will be non-null if adding a
0: 			 * constraint to an existing table.
0: 			 */
0: 			if (tableId != null)
0: 			{
0: 				td = dd.getTableDescriptor(tableId);
0: 			}
0: 			else
0: 			{
0: 				td = dd.getTableDescriptor(tableName, sd);
0: 			}
0: 
0: 			if (td == null)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION, tableName);
0: 			}
0: 			activation.setDDLTableDescriptor(td);
0: 		}
0: 
0: 		/* Generate the UUID for the backing index.  This will become the
0: 		 * constraint's name, if no name was specified.
0: 		 */
0: 		UUIDFactory uuidFactory = dd.getUUIDFactory();
0: 
0: 		/* Create the index, if there's one for this constraint */
0: 		if (indexAction != null)
0: 		{
0: 			if ( indexAction.getIndexName() == null )
0: 			{
0: 				/* Set the index name */
0: 				backingIndexName =  uuidFactory.createUUID().toString();
0: 				indexAction.setIndexName(backingIndexName);
0: 			}
0: 			else { backingIndexName = indexAction.getIndexName(); }
0: 
0: 			/* Create the index */
0: 			indexAction.executeConstantAction(activation);
0: 
0: 			/* Get the conglomerate descriptor for the backing index */
0: 			conglomDescs = td.getConglomerateDescriptors();
0: 
0: 			for (int index = 0; index < conglomDescs.length; index++)
0: 			{
0: 				conglomDesc = conglomDescs[index];
0: 
0: 				/* Check for conglomerate being an index first, since
0: 				 * name is null for heap.
0: 				 */
0: 				if (conglomDesc.isIndex() && 
0: 					backingIndexName.equals(conglomDesc.getConglomerateName()))
0: 				{
0: 					break;
0: 				}
0: 			}
0: 
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(conglomDesc != null,
0: 					"conglomDesc is expected to be non-null after search for backing index");
0: 				SanityManager.ASSERT(conglomDesc.isIndex(),
0: 					"conglomDesc is expected to be indexable after search for backing index");
0: 				SanityManager.ASSERT(conglomDesc.getConglomerateName().equals(backingIndexName),
0: 			   "conglomDesc name expected to be the same as backing index name after search for backing index");
0: 			}
0: 
0: 			indexId = conglomDesc.getUUID();
0: 		}
0: 
0: 		// if no constraintId was specified, we should generate one. this handles
0: 		// the two cases of Source creation and Target replication. At the source
0: 		// database, we allocate a new UUID. At the Target, we just use the UUID that
0: 		// the Source sent along.
0: 		UUID constraintId = uuidFactory.createUUID();
0: 
0: 		/* Now, lets create the constraint descriptor */
0: 		DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();
0: 		switch (constraintType)
0: 		{
0: 			case DataDictionary.PRIMARYKEY_CONSTRAINT:
0: 				conDesc = ddg.newPrimaryKeyConstraintDescriptor(
0: 								td, constraintName,
0: 								false, //deferable,
0: 								false, //initiallyDeferred,
0: 								genColumnPositions(td, false), //int[],
0: 								constraintId, 
0: 								indexId, 
0: 								sd,
0: 								enabled,
0: 								0				// referenceCount
0: 								);
0: 				dd.addConstraintDescriptor(conDesc, tc);
0: 				break;
0: 
0: 			case DataDictionary.UNIQUE_CONSTRAINT:
0: 				conDesc = ddg.newUniqueConstraintDescriptor(
0: 								td, constraintName,
0: 								false, //deferable,
0: 								false, //initiallyDeferred,
0: 								genColumnPositions(td, false), //int[],
0: 								constraintId, 
0: 								indexId, 
0: 								sd,
0: 								enabled,
0: 								0				// referenceCount
0: 								);
0: 				dd.addConstraintDescriptor(conDesc, tc);
0: 				break;
0: 
0: 			case DataDictionary.CHECK_CONSTRAINT:
0: 				conDesc = ddg.newCheckConstraintDescriptor(
0: 								td, constraintName,
0: 								false, //deferable,
0: 								false, //initiallyDeferred,
0: 								constraintId, 
0: 								constraintText, 
0: 								new ReferencedColumnsDescriptorImpl(genColumnPositions(td, false)), //int[],
0: 								sd,
0: 								enabled
0: 								);
0: 				dd.addConstraintDescriptor(conDesc, tc);
0: 				break;
0: 
0: 			case DataDictionary.FOREIGNKEY_CONSTRAINT:
0: 				ReferencedKeyConstraintDescriptor referencedConstraint = DDUtils.locateReferencedConstraint
0: 					( dd, td, constraintName, columnNames, otherConstraintInfo );
0: 				DDUtils.validateReferentialActions(dd, td, constraintName, otherConstraintInfo,columnNames);
0: 				
0: 				conDesc = ddg.newForeignKeyConstraintDescriptor(
0: 								td, constraintName,
0: 								false, //deferable,
0: 								false, //initiallyDeferred,
0: 								genColumnPositions(td, false), //int[],
0: 								constraintId,
0: 								indexId,
0: 								sd,
0: 								referencedConstraint,
0: 								enabled,
0: 								otherConstraintInfo.getReferentialActionDeleteRule(),
0: 								otherConstraintInfo.getReferentialActionUpdateRule()
0: 								);
0: 
0: 				// try to create the constraint first, because it
0: 				// is expensive to do the bulk check, find obvious
0: 				// errors first
0: 				dd.addConstraintDescriptor(conDesc, tc);
0: 
0: 				/* No need to do check if we're creating a 
0: 				 * table.
0: 				 */
0: 				if ( (! forCreateTable) && 
0: 					 dd.activeConstraint( conDesc ) )
0: 				{
0: 					validateFKConstraint(tc, 
0: 										 dd, 
0: 										 (ForeignKeyConstraintDescriptor)conDesc, 
0: 										 referencedConstraint,
0: 										 ((CreateIndexConstantAction)indexAction).getIndexTemplateRow());
0: 				}
0: 				
0: 				/* Create stored dependency on the referenced constraint */
0: 				dm.addDependency(conDesc, referencedConstraint, lcc.getContextManager());
0: 				break;
0: 
0: 			default:
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT("contraintType (" + constraintType + 
0: 						") has unexpected value");
0: 				}
0: 				break;
0: 		}
0: 
0: 		/* Create stored dependencies for each provider */
0: 		if (providerInfo != null)
0: 		{
0: 			for (int ix = 0; ix < providerInfo.length; ix++)
0: 			{
0: 				Provider provider = null;
0: 	
0: 				/* We should always be able to find the Provider */
0: 				try 
0: 				{
0: 					provider = (Provider) providerInfo[ix].
0: 											getDependableFinder().
0: 												getDependable(
0: 													providerInfo[ix].getObjectId());
0: 				}
0: 				catch(java.sql.SQLException te)
0: 				{
0: 					if (SanityManager.DEBUG)
0: 					{
0: 						SanityManager.THROWASSERT("unexpected java.sql.SQLException - " + te);
0: 					}
0: 				}
0: 				dm.addDependency(conDesc, provider, lcc.getContextManager());
0: 			}
0: 		}
0: 
0: 		/* Finally, invalidate off of the table descriptor(s)
0: 		 * to ensure that any dependent statements get
0: 		 * re-compiled.
0: 		 */
0: 		if (! forCreateTable)
0: 		{
0: 			dm.invalidateFor(td, DependencyManager.CREATE_CONSTRAINT, lcc);
0: 		}
0: 		if (constraintType == DataDictionary.FOREIGNKEY_CONSTRAINT)
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(conDesc != null,
0: 					"conDesc expected to be non-null");
0: 
0: 				if (! (conDesc instanceof ForeignKeyConstraintDescriptor))
0: 				{
0: 					SanityManager.THROWASSERT(
0: 						"conDesc expected to be instance of ForeignKeyConstraintDescriptor, not " +
0: 						conDesc.getClass().getName());
0: 				}
0: 			}
0: 			dm.invalidateFor(
0: 				((ForeignKeyConstraintDescriptor)conDesc).
0: 					getReferencedConstraint().
0: 						getTableDescriptor(),
0: 				DependencyManager.CREATE_CONSTRAINT, lcc);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Is the constant action for a foreign key
0: 	 *
0: 	 * @return true/false
0: 	 */
0: 	public boolean isForeignKeyConstraint()
0: 	{ 
0: 		return (constraintType == DataDictionary.FOREIGNKEY_CONSTRAINT);
0: 	}
0: 
0: 	/**
0: 	 * Generate an array of column positions for the column list in
0: 	 * the constraint.
0: 	 *
0: 	 * @param td	The TableDescriptor for the table in question
0: 	 * @param columnsMustBeOrderable	true for primaryKey and unique constraints
0: 	 *
0: 	 * @return int[]	The column positions.
0: 	 */
0: 	private int[] genColumnPositions(TableDescriptor td,
0: 									 boolean columnsMustBeOrderable)
0: 		throws StandardException
0: 	{
0: 		int[] baseColumnPositions;
0: 
0: 		// Translate the base column names to column positions
0: 		baseColumnPositions = new int[columnNames.length];
0: 		for (int i = 0; i < columnNames.length; i++)
0: 		{
0: 			ColumnDescriptor columnDescriptor;
0: 
0: 			// Look up the column in the data dictionary
0: 			columnDescriptor = td.getColumnDescriptor(columnNames[i]);
0: 			if (columnDescriptor == null)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, 
0: 															columnNames[i],
0: 															tableName);
0: 			}
0: 
0: 			// Don't allow a column to be created on a non-orderable type
0: 			// (for primaryKey and unique constraints)
0: 			if ( columnsMustBeOrderable &&
0: 				 ( ! columnDescriptor.getType().getTypeId().orderable(
0: 															cf))
0: 			   )
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_COLUMN_NOT_ORDERABLE_DURING_EXECUTION, 
0: 					columnDescriptor.getType().getTypeId().getSQLTypeName());
0: 			}
0: 
0: 			// Remember the position in the base table of each column
0: 			baseColumnPositions[i] = columnDescriptor.getPosition();
0: 		}
0: 
0: 		return baseColumnPositions;
0: 	}
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	ACCESSORS
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	  *	Get the names of the columns touched by this constraint.
0: 	  *
0: 	  *	@return	the array of touched column names.
0: 	  */
0:     public	String[]	getColumnNames() { return columnNames; }
0: 
0: 
0: 	/**
0: 	  *	Get the text defining this constraint.
0: 	  *
0: 	  *	@return	constraint text
0: 	  */
0:     public	String	getConstraintText() { return constraintText; }
0: 
0: 	public String toString()
0: 	{
0: 		// Do not put this under SanityManager.DEBUG - it is needed for
0: 		// error reporting.
0: 		StringBuffer strbuf = new StringBuffer();
0: 		strbuf.append( "CREATE CONSTRAINT " + constraintName );
0: 		strbuf.append("\n=========================\n");
0: 
0: 		if (columnNames == null)
0: 		{
0: 			strbuf.append("columnNames == null\n");
0: 		}
0: 		else
0: 		{
0: 			for (int ix=0; ix < columnNames.length; ix++)
0: 			{
0: 				strbuf.append("\n\tcol["+ix+"]"+columnNames[ix].toString());
0: 			}
0: 		}
0: 		
0: 		strbuf.append("\n");
0: 		strbuf.append(constraintText);
0: 		strbuf.append("\n");
0: 		if (otherConstraintInfo != null)
0: 		{
0: 			strbuf.append(otherConstraintInfo.toString());
0: 		}
0: 		strbuf.append("\n");
0: 		return strbuf.toString();
0: 	}
0: }
============================================================================