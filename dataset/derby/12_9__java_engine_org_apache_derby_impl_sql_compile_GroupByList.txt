1:eac0369: /*
34:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.GroupByList
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
8:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:47d4a4c: import java.util.List;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:b1f84c1: import org.apache.derby.iapi.reference.Limits;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
5:eac0369: /**
1:eac0369:  * A GroupByList represents the list of expressions in a GROUP BY clause in
1:eac0369:  * a SELECT statement.
9:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:e1f49ca: class GroupByList extends OrderedColumnList<GroupByColumn>
19:eac0369: {
1:eac0369: 	int		numGroupingColsAdded = 0;
1:b5105f3: 	boolean         rollup = false;
1:eac0369: 
1:3bb140c:     public GroupByList(ContextManager cm) {
1:e1f49ca:         super(GroupByColumn.class, cm);
1:3bb140c:     }
1:3bb140c: 
1:3bb140c: 
1:eac0369: 	/**
1:eac0369: 		Add a column to the list
1:c9a1206: 
1:eac0369: 		@param column	The column to add to the list
1:eac0369: 	 */
1:3bb140c:     void addGroupByColumn(GroupByColumn column)
1:b5105f3: 	{
1:eac0369: 		addElement(column);
16:eac0369: 	}
1:01217c2: 
1:eac0369: 	/**
1:eac0369: 		Get a column from the list
1:eac0369: 
1:eac0369: 		@param position	The column to get from the list
1:eac0369: 	 */
1:3bb140c:     GroupByColumn getGroupByColumn(int position)
1:eac0369: 	{
6:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(position >=0 && position < size(),
1:eac0369: 					"position (" + position +
1:eac0369: 					") expected to be between 0 and " + size());
1:eac0369: 		}
1:e1f49ca:         return elementAt(position);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:3bb140c:     void setRollup()
1:eac0369: 	{
1:b5105f3: 		rollup = true;
1:b5105f3: 	}
1:3bb140c:     boolean isRollup()
1:b5105f3: 	{
1:b5105f3: 		return rollup;
1:b5105f3: 	}
1:b5105f3:                         
1:b5105f3: 
1:eac0369: 	/**
1:eac0369: 	 * Get the number of grouping columns that need to be added to the SELECT list.
1:eac0369: 	 *
1:eac0369: 	 * @return int	The number of grouping columns that need to be added to
1:eac0369: 	 *				the SELECT list.
1:eac0369: 	 */
1:3bb140c:     int getNumNeedToAddGroupingCols()
1:eac0369: 	{
1:eac0369: 		return numGroupingColsAdded;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *  Bind the group by list.  Verify:
1:eac0369: 	 *		o  Number of grouping columns matches number of non-aggregates in
1:eac0369: 	 *		   SELECT's RCL.
1:eac0369: 	 *		o  Names in the group by list are unique
1:eac0369: 	 *		o  Names of grouping columns match names of non-aggregate
1:eac0369: 	 *		   expressions in SELECT's RCL.
1:eac0369: 	 *
1:eac0369: 	 * @param select		The SelectNode
1:09c2697:      * @param aggregates    The aggregate list being built as we find AggregateNodes
1:eac0369: 	 *
3:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:71c8e86:     void bindGroupByColumns(SelectNode select, List<AggregateNode> aggregates)
2:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		FromList		 fromList = select.getFromList();
1:eac0369: 		ResultColumnList selectRCL = select.getResultColumns();
1:3bb140c:         SubqueryList dummySubqueryList = new SubqueryList(getContextManager());
1:eac0369: 		int				 numColsAddedHere = 0;
1:eac0369: 
1:eac0369: 		/* Only 32677 columns allowed in GROUP BY clause */
1:e1f49ca:         if (size() > Limits.DB2_MAX_ELEMENTS_IN_GROUP_BY)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_ELEMENTS);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Bind the grouping column */
1:e1f49ca:         for (GroupByColumn groupByCol : this)
1:eac0369: 		{
1:eac0369: 			groupByCol.bindExpression(fromList,
1:09c2697:                                       dummySubqueryList, aggregates);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		
1:01217c2: 		int				rclSize = selectRCL.size();
1:e1f49ca:         for (GroupByColumn groupingCol : this)
1:eac0369: 		{
1:eac0369: 			boolean				matchFound = false;
1:eac0369: 
1:eac0369: 			/* Verify that this entry in the GROUP BY list matches a
1:eac0369: 			 * grouping column in the select list.
1:eac0369: 			 */
1:eac0369: 			for (int inner = 0; inner < rclSize; inner++)
1:eac0369: 			{
1:e1f49ca:                 ResultColumn selectListRC = selectRCL.elementAt(inner);
1:01217c2: 				if (!(selectListRC.getExpression() instanceof ColumnReference)) {
2:eac0369: 					continue;
1:eac0369: 				}
1:01217c2: 				
1:01217c2: 				ColumnReference selectListCR = (ColumnReference) selectListRC.getExpression();
1:eac0369: 
1:01217c2: 				if (selectListCR.isEquivalent(groupingCol.getColumnExpression())) { 
1:eac0369: 					/* Column positions for grouping columns are 0-based */
1:eac0369: 					groupingCol.setColumnPosition(inner + 1);
1:eac0369: 
1:eac0369: 					/* Mark the RC in the SELECT list as a grouping column */
1:eac0369: 					selectListRC.markAsGroupingColumn();
1:eac0369: 					matchFound = true;
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			/* If no match found in the SELECT list, then add a matching
1:eac0369: 			 * ResultColumn/ColumnReference pair to the SelectNode's RCL.
1:8341295: 			 * However, don't add additional result columns if the query
1:8341295: 			 * specified DISTINCT, because distinct processing considers
1:8341295: 			 * the entire RCL and including extra columns could change the
1:8341295: 			 * results: e.g. select distinct a,b from t group by a,b,c
1:8341295: 			 * should not consider column c in distinct processing (DERBY-3613)
1:eac0369: 			 */
1:8341295: 			if (! matchFound && !select.hasDistinct() &&
1:01217c2: 			    groupingCol.getColumnExpression() instanceof ColumnReference) 
1:eac0369: 			{
1:01217c2: 			    	// only add matching columns for column references not 
1:01217c2: 			    	// expressions yet. See DERBY-883 for details. 
1:eac0369: 				ResultColumn newRC;
1:eac0369: 
1:eac0369: 				/* Get a new ResultColumn */
1:3bb140c:                 newRC = new ResultColumn(
1:3bb140c:                         groupingCol.getColumnName(),
1:3bb140c:                         groupingCol.getColumnExpression().getClone(),
1:3bb140c:                         getContextManager());
1:eac0369: 				newRC.setVirtualColumnId(selectRCL.size() + 1);
1:eac0369: 				newRC.markGenerated();
1:eac0369: 				newRC.markAsGroupingColumn();
1:eac0369: 
1:eac0369: 				/* Add the new RC/CR to the RCL */
1:eac0369: 				selectRCL.addElement(newRC);
1:eac0369: 
2:eac0369: 				/* Set the columnPosition in the GroupByColumn, now that it
2:eac0369: 				* has a matching entry in the SELECT list.
1:eac0369: 				*/
1:eac0369: 				groupingCol.setColumnPosition(selectRCL.size());
1:d5ef906: 				
1:d5ef906: 				// a new hidden or generated column is added to this RCL
1:d5ef906: 				// i.e. that the size() of the RCL != visibleSize(). 
1:d5ef906: 				// Error checking done later should be aware of this 
1:d5ef906: 				// special case.
1:d5ef906: 				selectRCL.setCountMismatchAllowed(true);
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** Track the number of columns that we have added
1:eac0369: 				** in this routine.  We track this separately
1:eac0369: 				** than the total number of columns added by this
1:eac0369: 				** object (numGroupingColsAdded) because we
1:eac0369: 				** might be bound (though not gagged) more than
1:eac0369: 				** once (in which case numGroupingColsAdded will
1:eac0369: 				** already be set).
1:eac0369: 				*/
1:eac0369: 				numColsAddedHere++;
1:eac0369: 			}
1:96e7da9: 			if (groupingCol.getColumnExpression() instanceof JavaToSQLValueNode) 
1:96e7da9: 			{
1:96e7da9: 				// disallow any expression which involves native java computation. 
1:96e7da9: 				// Not possible to consider java expressions for equivalence.
1:96e7da9: 				throw StandardException.newException(					
1:96e7da9: 						SQLState.LANG_INVALID_GROUPED_SELECT_LIST);
1:96e7da9: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Verify that no subqueries got added to the dummy list */
1:3e293c2:         if (dummySubqueryList.size() != 0) {
1:3e293c2:             throw StandardException.newException(
1:3e293c2:                     SQLState.LANG_SUBQUERY_IN_GROUPBY_LIST);
1:3e293c2:         }
1:eac0369: 
1:eac0369: 		numGroupingColsAdded+= numColsAddedHere;
1:eac0369: 	}
1:01217c2: 
1:eac0369: 	
1:eac0369: 
1:eac0369: 	/**
1:01217c2: 	 * Find the matching grouping column if any for the given expression
1:01217c2: 	 * 
1:01217c2: 	 * @param node an expression for which we are trying to find a match
1:01217c2: 	 * in the group by list.
1:01217c2: 	 * 
1:01217c2: 	 * @return the matching GroupByColumn if one exists, null otherwise.
1:01217c2: 	 * 
1:01217c2: 	 * @throws StandardException
1:eac0369: 	 */
1:3bb140c:     GroupByColumn findGroupingColumn(ValueNode node)
1:01217c2: 	        throws StandardException
1:eac0369: 	{
1:e1f49ca:         for (GroupByColumn gbc : this)
1:eac0369: 		{
1:01217c2: 			if (gbc.getColumnExpression().isEquivalent(node))
1:eac0369: 			{
1:01217c2: 				return gbc;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return null;
1:eac0369: 	}
1:01217c2: 	
1:eac0369: 	/**
1:eac0369: 	 * Remap all ColumnReferences in this tree to be clones of the
1:eac0369: 	 * underlying expression.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     void remapColumnReferencesToExpressions() throws StandardException
1:eac0369: 	{
1:e828232:         /* This method is called when flattening a FromTable. */
1:e1f49ca:         for (GroupByColumn gbc : this)
1:eac0369: 		{
1:e828232:             gbc.setColumnExpression(
1:e828232:                 gbc.getColumnExpression().remapColumnReferencesToExpressions());
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:c9a1206: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:c9a1206: 	 * for how this should be done for tree printing.
1:c9a1206: 	 *
1:c9a1206: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:c9a1206: 		if (SanityManager.DEBUG) {
1:c9a1206: 			return "numGroupingColsAdded: " + numGroupingColsAdded + "\n" +
1:c9a1206: 				super.toString();
1:c9a1206: 		} else {
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:c9a1206: 
1:01217c2: 
1:e1f49ca:     void preprocess(int numTables,
1:e1f49ca:                     FromList fromList,
1:e1f49ca:                     SubqueryList whereSubquerys,
1:e1f49ca:                     PredicateList wherePredicates) throws StandardException
1:01217c2: 	{
1:e1f49ca:         for (GroupByColumn gbc : this)
1:01217c2: 		{
1:e1f49ca:             gbc.setColumnExpression(
1:e1f49ca:                     gbc.getColumnExpression().preprocess(
1:01217c2: 							numTables, fromList, whereSubquerys, wherePredicates));
1:01217c2: 		}		
1:01217c2: 	}
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e828232
/////////////////////////////////////////////////////////////////////////
1:         /* This method is called when flattening a FromTable. */
1:             gbc.setColumnExpression(
1:                 gbc.getColumnExpression().remapColumnReferencesToExpressions());
commit:3e293c2
/////////////////////////////////////////////////////////////////////////
1:         if (dummySubqueryList.size() != 0) {
1:             throw StandardException.newException(
1:                     SQLState.LANG_SUBQUERY_IN_GROUPBY_LIST);
1:         }
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates    The aggregate list being built as we find AggregateNodes
0:     void bindGroupByColumns(SelectNode select, List aggregates)
/////////////////////////////////////////////////////////////////////////
1:                                       dummySubqueryList, aggregates);
commit:47d4a4c
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 	void bindGroupByColumns(SelectNode select, List aggregateVector)
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:b5105f3
/////////////////////////////////////////////////////////////////////////
1: 	boolean         rollup = false;
/////////////////////////////////////////////////////////////////////////
0: 	public void setRollup()
1: 	{
1: 		rollup = true;
1: 	}
0: 	public boolean isRollup()
1: 	{
1: 		return rollup;
1: 	}
1:                         
1: 
commit:8341295
/////////////////////////////////////////////////////////////////////////
1: 			 * However, don't add additional result columns if the query
1: 			 * specified DISTINCT, because distinct processing considers
1: 			 * the entire RCL and including extra columns could change the
1: 			 * results: e.g. select distinct a,b from t group by a,b,c
1: 			 * should not consider column c in distinct processing (DERBY-3613)
1: 			if (! matchFound && !select.hasDistinct() &&
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1: class GroupByList extends OrderedColumnList<GroupByColumn>
1:         super(GroupByColumn.class, cm);
/////////////////////////////////////////////////////////////////////////
1:         return elementAt(position);
/////////////////////////////////////////////////////////////////////////
1:         if (size() > Limits.DB2_MAX_ELEMENTS_IN_GROUP_BY)
1:         for (GroupByColumn groupByCol : this)
1:         for (GroupByColumn groupingCol : this)
1:                 ResultColumn selectListRC = selectRCL.elementAt(inner);
/////////////////////////////////////////////////////////////////////////
1:         for (GroupByColumn gbc : this)
/////////////////////////////////////////////////////////////////////////
1:         for (GroupByColumn gbc : this)
0:             ValueNode retVN =
0:                 gbc.getColumnExpression().remapColumnReferencesToExpressions();
/////////////////////////////////////////////////////////////////////////
1:     void preprocess(int numTables,
1:                     FromList fromList,
1:                     SubqueryList whereSubquerys,
1:                     PredicateList wherePredicates) throws StandardException
1:         for (GroupByColumn gbc : this)
1:             gbc.setColumnExpression(
1:                     gbc.getColumnExpression().preprocess(
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
/////////////////////////////////////////////////////////////////////////
0: class GroupByList extends OrderedColumnList
1:     public GroupByList(ContextManager cm) {
0:         super(cm);
0:         setNodeType(C_NodeTypes.GROUP_BY_LIST);
1:     }
1: 
1: 
1:     void addGroupByColumn(GroupByColumn column)
/////////////////////////////////////////////////////////////////////////
1:     GroupByColumn getGroupByColumn(int position)
/////////////////////////////////////////////////////////////////////////
1:     void setRollup()
1:     boolean isRollup()
/////////////////////////////////////////////////////////////////////////
1:     int getNumNeedToAddGroupingCols()
/////////////////////////////////////////////////////////////////////////
1:         SubqueryList dummySubqueryList = new SubqueryList(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                 newRC = new ResultColumn(
1:                         groupingCol.getColumnName(),
1:                         groupingCol.getColumnExpression().getClone(),
1:                         getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     GroupByColumn findGroupingColumn(ValueNode node)
/////////////////////////////////////////////////////////////////////////
1:     void remapColumnReferencesToExpressions() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:     void preprocess(
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 		if (SanityManager.DEBUG) {
1: 			return "numGroupingColsAdded: " + numGroupingColsAdded + "\n" +
1: 				super.toString();
1: 		} else {
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:     void bindGroupByColumns(SelectNode select, List<AggregateNode> aggregates)
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:96e7da9
/////////////////////////////////////////////////////////////////////////
1: 			if (groupingCol.getColumnExpression() instanceof JavaToSQLValueNode) 
1: 			{
1: 				// disallow any expression which involves native java computation. 
1: 				// Not possible to consider java expressions for equivalence.
1: 				throw StandardException.newException(					
1: 						SQLState.LANG_INVALID_GROUPED_SELECT_LIST);
1: 			}
author:Army
-------------------------------------------------------------------------------
commit:d5ef906
/////////////////////////////////////////////////////////////////////////
1: 				
1: 				// a new hidden or generated column is added to this RCL
1: 				// i.e. that the size() of the RCL != visibleSize(). 
1: 				// Error checking done later should be aware of this 
1: 				// special case.
1: 				selectRCL.setCountMismatchAllowed(true);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:01217c2
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		int				rclSize = selectRCL.size();
1: 				if (!(selectListRC.getExpression() instanceof ColumnReference)) {
1: 				
1: 				ColumnReference selectListCR = (ColumnReference) selectListRC.getExpression();
1: 				if (selectListCR.isEquivalent(groupingCol.getColumnExpression())) { 
/////////////////////////////////////////////////////////////////////////
0: 			if (! matchFound && 
1: 			    groupingCol.getColumnExpression() instanceof ColumnReference) 
1: 			    	// only add matching columns for column references not 
1: 			    	// expressions yet. See DERBY-883 for details. 
0: 								groupingCol.getColumnExpression().getClone(),
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	 * Find the matching grouping column if any for the given expression
1: 	 * 
1: 	 * @param node an expression for which we are trying to find a match
1: 	 * in the group by list.
1: 	 * 
1: 	 * @return the matching GroupByColumn if one exists, null otherwise.
1: 	 * 
1: 	 * @throws StandardException
0: 	public GroupByColumn findGroupingColumn(ValueNode node)
1: 	        throws StandardException
0: 		int sz = size();
0: 		for (int i = 0; i < sz; i++) 
0: 			GroupByColumn gbc = (GroupByColumn)elementAt(i);
1: 			if (gbc.getColumnExpression().isEquivalent(node))
1: 				return gbc;
1: 	
/////////////////////////////////////////////////////////////////////////
0: 			retVN = gbc.getColumnExpression().remapColumnReferencesToExpressions();
/////////////////////////////////////////////////////////////////////////
0: 			gbc.setColumnExpression(retVN);
/////////////////////////////////////////////////////////////////////////
1: 
0: 	public void preprocess(
0: 			int numTables, FromList fromList, SubqueryList whereSubquerys, 
0: 			PredicateList wherePredicates) throws StandardException 
1: 	{
0: 		for (int index = 0; index < size(); index++)
1: 		{
0: 			GroupByColumn	groupingCol = (GroupByColumn) elementAt(index);
0: 			groupingCol.setColumnExpression(
0: 					groupingCol.getColumnExpression().preprocess(
1: 							numTables, fromList, whereSubquerys, wherePredicates));
1: 		}		
1: 	}
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.GroupByList
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.DB2Limit;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
0: import org.apache.derby.iapi.util.ReuseFactory;
1: 
0: import java.util.Vector;
1: 
1: /**
1:  * A GroupByList represents the list of expressions in a GROUP BY clause in
1:  * a SELECT statement.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public class GroupByList extends OrderedColumnList
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	int		numGroupingColsAdded = 0;
1: 
1: 	/**
1: 		Add a column to the list
1: 
1: 		@param column	The column to add to the list
1: 	 */
0: 	public void addGroupByColumn(GroupByColumn column)
1: 	{
1: 		addElement(column);
1: 	}
1: 
1: 	/**
1: 		Get a column from the list
1: 
1: 		@param position	The column to get from the list
1: 	 */
0: 	public GroupByColumn getGroupByColumn(int position)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(position >=0 && position < size(),
1: 					"position (" + position +
1: 					") expected to be between 0 and " + size());
1: 		}
0: 		return (GroupByColumn) elementAt(position);
1: 	}
1: 
1: 	/**
0: 		Print the list.
1: 
0: 		@param depth		The depth at which to indent the sub-nodes
1: 	 */
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			for (int index = 0; index < size(); index++)
1: 			{
0: 				( (GroupByColumn) elementAt(index) ).treePrint(depth);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the number of grouping columns that need to be added to the SELECT list.
1: 	 *
1: 	 * @return int	The number of grouping columns that need to be added to
1: 	 *				the SELECT list.
1: 	 */
0: 	public int getNumNeedToAddGroupingCols()
1: 	{
1: 		return numGroupingColsAdded;
1: 	}
1: 
1: 	/**
1: 	 *  Bind the group by list.  Verify:
1: 	 *		o  Number of grouping columns matches number of non-aggregates in
1: 	 *		   SELECT's RCL.
1: 	 *		o  Names in the group by list are unique
1: 	 *		o  Names of grouping columns match names of non-aggregate
1: 	 *		   expressions in SELECT's RCL.
1: 	 *
1: 	 * @param select		The SelectNode
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void bindGroupByColumns(SelectNode select,
0: 								   Vector	aggregateVector)
1: 					throws StandardException
1: 	{
1: 		FromList		 fromList = select.getFromList();
1: 		ResultColumnList selectRCL = select.getResultColumns();
0: 		SubqueryList	 dummySubqueryList =
0: 									(SubqueryList) getNodeFactory().getNode(
0: 													C_NodeTypes.SUBQUERY_LIST,
0: 													getContextManager());
1: 		int				 numColsAddedHere = 0;
0: 		int				 size = size();
1: 
1: 		/* Only 32677 columns allowed in GROUP BY clause */
0: 		if (size > DB2Limit.DB2_MAX_ELEMENTS_IN_GROUP_BY)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_ELEMENTS);
1: 		}
1: 
1: 		/* Bind the grouping column */
0: 		for (int index = 0; index < size; index++)
1: 		{
0: 			GroupByColumn groupByCol = (GroupByColumn) elementAt(index);
1: 			groupByCol.bindExpression(fromList,
0: 									  dummySubqueryList, aggregateVector);
1: 		}
1: 
0: 		/* Verify that the columns in the GROUP BY list are unique.
0: 		 * (Unique on table number and source ResultColumn.)
1: 		 */
0: 		verifyUniqueGroupingColumns();
1: 
0: 		for (int index = 0; index < size; index++)
1: 		{
1: 			boolean				matchFound = false;
0: 			GroupByColumn		groupingCol = (GroupByColumn) elementAt(index);
0: 			String				curName = groupingCol.getColumnName();
1: 
1: 			/* Verify that this entry in the GROUP BY list matches a
1: 			 * grouping column in the select list.
1: 			 */
0: 			int				groupingColTableNum = groupingCol.getTableNumber();
0: 			ResultColumn	groupingSource = groupingCol.getSource();
0: 			int				rclSize = selectRCL.size();
1: 			for (int inner = 0; inner < rclSize; inner++)
1: 			{
0: 				ColumnReference selectListCR;
0: 				ResultColumn selectListRC = (ResultColumn) selectRCL.elementAt(inner);
1: 
0: 				if (! (selectListRC.getExpression() instanceof ColumnReference))
1: 				{
1: 					continue;
1: 				}
0: 				selectListCR = (ColumnReference) selectListRC.getExpression();
1: 
0: 				if (groupingColTableNum == selectListCR.getTableNumber() &&
0: 					groupingSource == selectListCR.getSource())
1: 				{
1: 					/* Column positions for grouping columns are 0-based */
1: 					groupingCol.setColumnPosition(inner + 1);
1: 
1: 					/* Mark the RC in the SELECT list as a grouping column */
1: 					selectListRC.markAsGroupingColumn();
1: 					matchFound = true;
1: 					break;
1: 				}
1: 			}
1: 
1: 			/* If no match found in the SELECT list, then add a matching
1: 			 * ResultColumn/ColumnReference pair to the SelectNode's RCL.
1: 			 */
0: 			if (! matchFound)
1: 			{
1: 				ResultColumn newRC;
1: 
1: 				/* Get a new ResultColumn */
0: 				newRC = (ResultColumn) getNodeFactory().getNode(
0: 								C_NodeTypes.RESULT_COLUMN,
0: 								groupingCol.getColumnName(),
0: 								groupingCol.getColumnReference().getClone(),
0: 								getContextManager());
1: 				newRC.setVirtualColumnId(selectRCL.size() + 1);
1: 				newRC.markGenerated();
1: 				newRC.markAsGroupingColumn();
1: 
1: 				/* Add the new RC/CR to the RCL */
1: 				selectRCL.addElement(newRC);
1: 
1: 				/* Set the columnPosition in the GroupByColumn, now that it
1: 				* has a matching entry in the SELECT list.
1: 				*/
1: 				groupingCol.setColumnPosition(selectRCL.size());
1: 
1: 				/*
1: 				** Track the number of columns that we have added
1: 				** in this routine.  We track this separately
1: 				** than the total number of columns added by this
1: 				** object (numGroupingColsAdded) because we
1: 				** might be bound (though not gagged) more than
1: 				** once (in which case numGroupingColsAdded will
1: 				** already be set).
1: 				*/
1: 				numColsAddedHere++;
1: 			}
1: 		}
1: 
1: 		/* Verify that no subqueries got added to the dummy list */
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(dummySubqueryList.size() == 0,
0: 				"dummySubqueryList.size() is expected to be 0");
1: 		}
1: 
1: 		numGroupingColsAdded+= numColsAddedHere;
1: 	}
1: 
1: 
1: 	/**
0: 	 * Check the uniqueness of the column names within a GROUP BY list.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void verifyUniqueGroupingColumns() throws StandardException
1: 	{
0: 		int				size = size();
0: 		String			colName;
1: 
0: 		for (int outer = 0; outer < size; outer++)
1: 		{
0: 			GroupByColumn		groupingCol = (GroupByColumn) elementAt(outer);
0: 			int					outerTabNum = groupingCol.getTableNumber();
0: 			ResultColumn		outerRC = groupingCol.getSource();
0: 			String				curName = groupingCol.getColumnName();
0: 			/* Verify that this column's name is unique within the list */
0: 			colName = groupingCol.getColumnName();
1: 
0: 			for (int inner = outer + 1; inner < size; inner++)
1: 			{
0: 				GroupByColumn		innerGBC = (GroupByColumn) elementAt(inner);
0: 				int					innerTabNum = innerGBC.getTableNumber();
0: 				ResultColumn		innerRC = innerGBC.getSource();
0: 				if (outerTabNum == innerTabNum &&
0: 					outerRC == innerRC)
1: 				{
0: 					throw StandardException.newException(SQLState.LANG_AMBIGUOUS_GROUPING_COLUMN, colName);
1: 				}
1: 			}
1: 		}
1: 
0: 		/* No duplicate column names */
1: 	}
1: 
1: 	/**
0: 	 * Add any grouping columns which are not already in the appropriate RCL
0: 	 * to the RCL.
0: 	 * NOTE: The RC/VCNs in the SELECT list will point to the same pool of
0: 	 *		 ResultColumns as the GroupByColumns in this list.
1: 	 *
0: 	 * @param selectNode	The SelectNode whose RCL we add to.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void addNewGroupingColumnsToRCL(SelectNode selectNode)
1: 		throws StandardException
1: 	{
0: 		FromList			fromList = selectNode.getFromList();
0: 		int					size = size();
0: 		ResultColumnList	rcl = selectNode.getResultColumns();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(selectNode.getGroupByList() == this,
0: 				"selectNode.getGroupByList() expected to equal this");
1: 		}
1: 
0: 		for (int index = 0; index < size; index++)
1: 		{
0: 			GroupByColumn		gbc = (GroupByColumn) elementAt(index);
0: 			ResultColumn		newRC;
0: 			VirtualColumnNode	newVCN;
1: 
0: 			/* Skip over GBCs which have a match */
0: 			if (gbc.getColumnPosition() != GroupByColumn.UNMATCHEDPOSITION)
1: 			{
1: 				continue;
1: 			}
1: 
0: 			/* Get and bind a new VCN */
0: 			newVCN = (VirtualColumnNode) getNodeFactory().getNode(
0: 							C_NodeTypes.VIRTUAL_COLUMN_NODE,
0: 							fromList.getFromTableByResultColumn(gbc.getSource()),
0: 							gbc.getSource(),
0: 							ReuseFactory.getInteger(rcl.size() + 2),
0: 							getContextManager());
0: 			newVCN.setType(gbc.getColumnReference().getTypeServices());
1: 
0: 			/* Get and bind a new ResultColumn */
0: 			newRC = (ResultColumn) getNodeFactory().getNode(
0: 							C_NodeTypes.RESULT_COLUMN,
0: 							gbc.getColumnName(),
0: 							newVCN,
0: 							getContextManager());
0: 			newRC.setType(newVCN.getTypeServices());
0: 			newRC.setVirtualColumnId(rcl.size() + 2);
1: 
0: 			/* Add the new RC/VCN to the RCL */
0: 			rcl.addElement(newRC);
1: 
1: 			/* Set the columnPosition in the GroupByColumn, now that it
1: 			 * has a matching entry in the SELECT list.
1: 			 */
0: 			gbc.setColumnPosition(rcl.size());
1: 		}
1: 	}
1: 
1: 	/**
1: 	 *
1: 	 */
0: 	public GroupByColumn containsColumnReference(ColumnReference cr)
1: 	{
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
1: 		{
0: 			GroupByColumn		groupingCol = (GroupByColumn) elementAt(index);
1: 
0: 			if (groupingCol.getSource() == cr.getSource() &&
0: 				groupingCol.getTableNumber() == cr.getTableNumber())
1: 			{
0: 				return groupingCol;
1: 			}
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Remap all ColumnReferences in this tree to be clones of the
1: 	 * underlying expression.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public void remapColumnReferencesToExpressions() throws StandardException
1: 	{
0: 		GroupByColumn	gbc;
0: 		int				size = size();
1: 
0: 		/* This method is called when flattening a FromTable.  We should
0: 		 * not be flattening a FromTable if the underlying expression that
0: 		 * will get returned out, after chopping out the redundant ResultColumns,
0: 		 * is not a ColumnReference.  (See ASSERT below.)
1: 		 */
0: 		for (int index = 0; index < size; index++)
1: 		{
0: 			ValueNode	retVN;
0: 			gbc = (GroupByColumn) elementAt(index);
1: 
0: 			retVN = gbc.getColumnReference().remapColumnReferencesToExpressions();
1: 
1: 			if (SanityManager.DEBUG)
1: 			{
0: 				SanityManager.ASSERT(retVN instanceof ColumnReference,
0: 					"retVN expected to be instanceof ColumnReference, not " +
0: 					retVN.getClass().getName());
1: 			}
1: 
0: 			gbc.setColumnReference((ColumnReference) retVN);
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Print it out, baby
1: 	 */
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			StringBuffer	buf = new StringBuffer();
1: 
0: 			for (int index = 0; index < size(); index++)
1: 			{
0: 				GroupByColumn	groupingCol = (GroupByColumn) elementAt(index);
1: 
0: 				buf.append(groupingCol.toString());
1: 			}
0: 			return buf.toString();
1: 		}
0: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
0: 		if (size > Limits.DB2_MAX_ELEMENTS_IN_GROUP_BY)
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.DB2Limit;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import org.apache.derby.iapi.util.ReuseFactory;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * A GroupByList represents the list of expressions in a GROUP BY clause in
0:  * a SELECT statement.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public class GroupByList extends OrderedColumnList
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	int		numGroupingColsAdded = 0;
0: 
0: 	/**
0: 		Add a column to the list
0: 
0: 		@param column	The column to add to the list
0: 	 */
0: 	public void addGroupByColumn(GroupByColumn column)
0: 	{
0: 		addElement(column);
0: 	}
0: 
0: 	/**
0: 		Get a column from the list
0: 
0: 		@param position	The column to get from the list
0: 	 */
0: 	public GroupByColumn getGroupByColumn(int position)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(position >=0 && position < size(),
0: 					"position (" + position +
0: 					") expected to be between 0 and " + size());
0: 		}
0: 		return (GroupByColumn) elementAt(position);
0: 	}
0: 
0: 	/**
0: 		Print the list.
0: 
0: 		@param depth		The depth at which to indent the sub-nodes
0: 	 */
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			for (int index = 0; index < size(); index++)
0: 			{
0: 				( (GroupByColumn) elementAt(index) ).treePrint(depth);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the number of grouping columns that need to be added to the SELECT list.
0: 	 *
0: 	 * @return int	The number of grouping columns that need to be added to
0: 	 *				the SELECT list.
0: 	 */
0: 	public int getNumNeedToAddGroupingCols()
0: 	{
0: 		return numGroupingColsAdded;
0: 	}
0: 
0: 	/**
0: 	 *  Bind the group by list.  Verify:
0: 	 *		o  Number of grouping columns matches number of non-aggregates in
0: 	 *		   SELECT's RCL.
0: 	 *		o  Names in the group by list are unique
0: 	 *		o  Names of grouping columns match names of non-aggregate
0: 	 *		   expressions in SELECT's RCL.
0: 	 *
0: 	 * @param select		The SelectNode
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void bindGroupByColumns(SelectNode select,
0: 								   Vector	aggregateVector)
0: 					throws StandardException
0: 	{
0: 		FromList		 fromList = select.getFromList();
0: 		ResultColumnList selectRCL = select.getResultColumns();
0: 		SubqueryList	 dummySubqueryList =
0: 									(SubqueryList) getNodeFactory().getNode(
0: 													C_NodeTypes.SUBQUERY_LIST,
0: 													getContextManager());
0: 		int				 numColsAddedHere = 0;
0: 		int				 size = size();
0: 
0: 		/* Only 32677 columns allowed in GROUP BY clause */
0: 		if (size > DB2Limit.DB2_MAX_ELEMENTS_IN_GROUP_BY)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_ELEMENTS);
0: 		}
0: 
0: 		/* Bind the grouping column */
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			GroupByColumn groupByCol = (GroupByColumn) elementAt(index);
0: 			groupByCol.bindExpression(fromList,
0: 									  dummySubqueryList, aggregateVector);
0: 		}
0: 
0: 		/* Verify that the columns in the GROUP BY list are unique.
0: 		 * (Unique on table number and source ResultColumn.)
0: 		 */
0: 		verifyUniqueGroupingColumns();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			boolean				matchFound = false;
0: 			GroupByColumn		groupingCol = (GroupByColumn) elementAt(index);
0: 			String				curName = groupingCol.getColumnName();
0: 
0: 			/* Verify that this entry in the GROUP BY list matches a
0: 			 * grouping column in the select list.
0: 			 */
0: 			int				groupingColTableNum = groupingCol.getTableNumber();
0: 			ResultColumn	groupingSource = groupingCol.getSource();
0: 			int				rclSize = selectRCL.size();
0: 			for (int inner = 0; inner < rclSize; inner++)
0: 			{
0: 				ColumnReference selectListCR;
0: 				ResultColumn selectListRC = (ResultColumn) selectRCL.elementAt(inner);
0: 
0: 				if (! (selectListRC.getExpression() instanceof ColumnReference))
0: 				{
0: 					continue;
0: 				}
0: 				selectListCR = (ColumnReference) selectListRC.getExpression();
0: 
0: 				if (groupingColTableNum == selectListCR.getTableNumber() &&
0: 					groupingSource == selectListCR.getSource())
0: 				{
0: 					/* Column positions for grouping columns are 0-based */
0: 					groupingCol.setColumnPosition(inner + 1);
0: 
0: 					/* Mark the RC in the SELECT list as a grouping column */
0: 					selectListRC.markAsGroupingColumn();
0: 					matchFound = true;
0: 					break;
0: 				}
0: 			}
0: 
0: 			/* If no match found in the SELECT list, then add a matching
0: 			 * ResultColumn/ColumnReference pair to the SelectNode's RCL.
0: 			 */
0: 			if (! matchFound)
0: 			{
0: 				ResultColumn newRC;
0: 
0: 				/* Get a new ResultColumn */
0: 				newRC = (ResultColumn) getNodeFactory().getNode(
0: 								C_NodeTypes.RESULT_COLUMN,
0: 								groupingCol.getColumnName(),
0: 								groupingCol.getColumnReference().getClone(),
0: 								getContextManager());
0: 				newRC.setVirtualColumnId(selectRCL.size() + 1);
0: 				newRC.markGenerated();
0: 				newRC.markAsGroupingColumn();
0: 
0: 				/* Add the new RC/CR to the RCL */
0: 				selectRCL.addElement(newRC);
0: 
0: 				/* Set the columnPosition in the GroupByColumn, now that it
0: 				* has a matching entry in the SELECT list.
0: 				*/
0: 				groupingCol.setColumnPosition(selectRCL.size());
0: 
0: 				/*
0: 				** Track the number of columns that we have added
0: 				** in this routine.  We track this separately
0: 				** than the total number of columns added by this
0: 				** object (numGroupingColsAdded) because we
0: 				** might be bound (though not gagged) more than
0: 				** once (in which case numGroupingColsAdded will
0: 				** already be set).
0: 				*/
0: 				numColsAddedHere++;
0: 			}
0: 		}
0: 
0: 		/* Verify that no subqueries got added to the dummy list */
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(dummySubqueryList.size() == 0,
0: 				"dummySubqueryList.size() is expected to be 0");
0: 		}
0: 
0: 		numGroupingColsAdded+= numColsAddedHere;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Check the uniqueness of the column names within a GROUP BY list.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void verifyUniqueGroupingColumns() throws StandardException
0: 	{
0: 		int				size = size();
0: 		String			colName;
0: 
0: 		for (int outer = 0; outer < size; outer++)
0: 		{
0: 			GroupByColumn		groupingCol = (GroupByColumn) elementAt(outer);
0: 			int					outerTabNum = groupingCol.getTableNumber();
0: 			ResultColumn		outerRC = groupingCol.getSource();
0: 			String				curName = groupingCol.getColumnName();
0: 			/* Verify that this column's name is unique within the list */
0: 			colName = groupingCol.getColumnName();
0: 
0: 			for (int inner = outer + 1; inner < size; inner++)
0: 			{
0: 				GroupByColumn		innerGBC = (GroupByColumn) elementAt(inner);
0: 				int					innerTabNum = innerGBC.getTableNumber();
0: 				ResultColumn		innerRC = innerGBC.getSource();
0: 				if (outerTabNum == innerTabNum &&
0: 					outerRC == innerRC)
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_AMBIGUOUS_GROUPING_COLUMN, colName);
0: 				}
0: 			}
0: 		}
0: 
0: 		/* No duplicate column names */
0: 	}
0: 
0: 	/**
0: 	 * Add any grouping columns which are not already in the appropriate RCL
0: 	 * to the RCL.
0: 	 * NOTE: The RC/VCNs in the SELECT list will point to the same pool of
0: 	 *		 ResultColumns as the GroupByColumns in this list.
0: 	 *
0: 	 * @param selectNode	The SelectNode whose RCL we add to.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void addNewGroupingColumnsToRCL(SelectNode selectNode)
0: 		throws StandardException
0: 	{
0: 		FromList			fromList = selectNode.getFromList();
0: 		int					size = size();
0: 		ResultColumnList	rcl = selectNode.getResultColumns();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(selectNode.getGroupByList() == this,
0: 				"selectNode.getGroupByList() expected to equal this");
0: 		}
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			GroupByColumn		gbc = (GroupByColumn) elementAt(index);
0: 			ResultColumn		newRC;
0: 			VirtualColumnNode	newVCN;
0: 
0: 			/* Skip over GBCs which have a match */
0: 			if (gbc.getColumnPosition() != GroupByColumn.UNMATCHEDPOSITION)
0: 			{
0: 				continue;
0: 			}
0: 
0: 			/* Get and bind a new VCN */
0: 			newVCN = (VirtualColumnNode) getNodeFactory().getNode(
0: 							C_NodeTypes.VIRTUAL_COLUMN_NODE,
0: 							fromList.getFromTableByResultColumn(gbc.getSource()),
0: 							gbc.getSource(),
0: 							ReuseFactory.getInteger(rcl.size() + 2),
0: 							getContextManager());
0: 			newVCN.setType(gbc.getColumnReference().getTypeServices());
0: 
0: 			/* Get and bind a new ResultColumn */
0: 			newRC = (ResultColumn) getNodeFactory().getNode(
0: 							C_NodeTypes.RESULT_COLUMN,
0: 							gbc.getColumnName(),
0: 							newVCN,
0: 							getContextManager());
0: 			newRC.setType(newVCN.getTypeServices());
0: 			newRC.setVirtualColumnId(rcl.size() + 2);
0: 
0: 			/* Add the new RC/VCN to the RCL */
0: 			rcl.addElement(newRC);
0: 
0: 			/* Set the columnPosition in the GroupByColumn, now that it
0: 			 * has a matching entry in the SELECT list.
0: 			 */
0: 			gbc.setColumnPosition(rcl.size());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 *
0: 	 */
0: 	public GroupByColumn containsColumnReference(ColumnReference cr)
0: 	{
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			GroupByColumn		groupingCol = (GroupByColumn) elementAt(index);
0: 
0: 			if (groupingCol.getSource() == cr.getSource() &&
0: 				groupingCol.getTableNumber() == cr.getTableNumber())
0: 			{
0: 				return groupingCol;
0: 			}
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Remap all ColumnReferences in this tree to be clones of the
0: 	 * underlying expression.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public void remapColumnReferencesToExpressions() throws StandardException
0: 	{
0: 		GroupByColumn	gbc;
0: 		int				size = size();
0: 
0: 		/* This method is called when flattening a FromTable.  We should
0: 		 * not be flattening a FromTable if the underlying expression that
0: 		 * will get returned out, after chopping out the redundant ResultColumns,
0: 		 * is not a ColumnReference.  (See ASSERT below.)
0: 		 */
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			ValueNode	retVN;
0: 			gbc = (GroupByColumn) elementAt(index);
0: 
0: 			retVN = gbc.getColumnReference().remapColumnReferencesToExpressions();
0: 
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(retVN instanceof ColumnReference,
0: 					"retVN expected to be instanceof ColumnReference, not " +
0: 					retVN.getClass().getName());
0: 			}
0: 
0: 			gbc.setColumnReference((ColumnReference) retVN);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Print it out, baby
0: 	 */
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			StringBuffer	buf = new StringBuffer();
0: 
0: 			for (int index = 0; index < size(); index++)
0: 			{
0: 				GroupByColumn	groupingCol = (GroupByColumn) elementAt(index);
0: 
0: 				buf.append(groupingCol.toString());
0: 			}
0: 			return buf.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: }
============================================================================