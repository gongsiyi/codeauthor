6:448ecb0: /*
5:712b41b:  
1:448ecb0:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.StatementEventsTest
1:407e52d:  
1:6e3dbab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6e3dbab:    contributor license agreements.  See the NOTICE file distributed with
1:6e3dbab:    this work for additional information regarding copyright ownership.
1:6e3dbab:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6e3dbab:    (the "License"); you may not use this file except in compliance with
1:6e3dbab:    the License.  You may obtain a copy of the License at
1:407e52d:  
1:448ecb0:       http://www.apache.org/licenses/LICENSE-2.0
1:712b41b:  
1:448ecb0:    Unless required by applicable law or agreed to in writing, software
1:448ecb0:    distributed under the License is distributed on an "AS IS" BASIS,
1:448ecb0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:448ecb0:    See the License for the specific language governing permissions and
1:448ecb0:    limitations under the License.
1:712b41b:  
7:448ecb0:  */
1:407e52d: 
1:448ecb0: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:712b41b: 
1:1ae02c9: import java.sql.Connection;
1:1ae02c9: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.SQLNonTransientConnectionException;
1:1ae02c9: import java.sql.Statement;
1:431eec8: import java.util.Arrays;
1:1ae02c9: import java.util.Enumeration;
1:1ae02c9: import javax.sql.ConnectionPoolDataSource;
1:1ae02c9: import javax.sql.PooledConnection;
1:1ae02c9: import javax.sql.StatementEvent;
1:1ae02c9: import javax.sql.StatementEventListener;
1:1ae02c9: import javax.sql.XADataSource;
1:1ae02c9: import junit.framework.Test;
1:3bd1dd8: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:8ed08b2: import org.apache.derbyTesting.junit.J2EEDataSource;
1:ec5ae26: import org.apache.derbyTesting.junit.TestConfiguration;
1:712b41b: 
1:448ecb0: /*
1:448ecb0:     This class is used to test the JDBC4 statement event 
1:448ecb0:     support 
1:448ecb0: */
1:4f9187e: public class StatementEventsTest extends BaseJDBCTestCase {
1:4f9187e: 
1:4f9187e:     /**
1:4f9187e:      * Type of data source to use. If <code>true</code>, use
1:4f9187e:      * <code>XADataSource</code>; otherwise, use
1:4f9187e:      * <code>ConnectionPoolDataSource</code>.
1:4f9187e:      */
1:4f9187e:     private boolean xa;
1:4f9187e:     /**
1:4f9187e:      * Type of statement to use. If <code>true</code>, use
1:4f9187e:      * <code>CallableStatement</code>; otherwise, use
1:4f9187e:      * <code>PreparedStatement</code>.
1:4f9187e:      */
1:4f9187e:     private boolean callable;
1:4f9187e: 
1:4f9187e:     /** The statement that caused the last statementClosed event. */
1:4f9187e:     private Statement closedStatement;
1:4f9187e:     /** Number of times statementClosed events have been raised. */
1:4f9187e:     private int closedCount;
1:4f9187e:     /** The statement that caused the last statementError event. */
1:4f9187e:     private Statement errorStatement;
1:4f9187e:     /** Number of times statementError events have been raised. */
1:4f9187e:     private int errorCount;
1:4f9187e: 
1:4f9187e:     /**
1:4f9187e:      * The pooled connection to use in the test (could also be an XA
1:4f9187e:      * connection).
1:4f9187e:      */
1:4f9187e:     private PooledConnection pooledConnection;
1:4f9187e:     /** The connection object to use in the test. */
1:4f9187e:     private Connection connection;
1:4f9187e: 
3:448ecb0:     /**
1:448ecb0:      * Create a test with the given name.
5:448ecb0:      *
1:448ecb0:      * @param name name of the test.
1:448ecb0:      */
1:448ecb0:     public StatementEventsTest(String name) {
1:448ecb0:         super(name);
9:712b41b:     }
1:4f9187e: 
1:077d16c:     /**
1:4f9187e:      * Set whether the test should use <code>XADataSource</code> or
1:4f9187e:      * <code>ConnectionPoolDataSource</code>.
1:712b41b:      *
1:4f9187e:      * @param xa if <code>true</code>, use XA
1:4f9187e:      */
1:4f9187e:     private void setXA(boolean xa) {
1:4f9187e:         this.xa = xa;
1:4f9187e:     }
1:4f9187e: 
1:4f9187e:     /**
1:4f9187e:      * Set whether the test should use <code>CallableStatement</code> or
1:4f9187e:      * <code>PreparedStatement</code>.
1:712b41b:      *
1:4f9187e:      * @param callable if <code>true</code>, use callable statement; otherwise,
1:4f9187e:      * use prepared statement
1:4f9187e:      */
1:4f9187e:     private void setCallable(boolean callable) {
1:4f9187e:         this.callable = callable;
1:4f9187e:     }
1:4f9187e: 
1:4f9187e:     /**
1:4f9187e:      * Return the name of the test.
1:4f9187e:      *
1:4f9187e:      * @return name of the test
1:4f9187e:      */
1:4f9187e:     public String getName() {
1:4f9187e:         return super.getName() + (xa ? "_xa" : "_pooled") +
1:4f9187e:             (callable ? "_callable" : "_prepared");
1:4f9187e:     }
1:4f9187e: 
1:4f9187e:     // TEST SETUP
1:4f9187e: 
1:4f9187e:     /**
1:4f9187e:      * Set up the connection to the database and register a statement event
1:4f9187e:      * listener.
1:4f9187e:      *
2:4f9187e:      * @exception SQLException if a database error occurs
1:448ecb0:      */
1:448ecb0:     public void setUp() throws SQLException {
1:4f9187e:         if (xa) {
1:8ed08b2:             XADataSource ds = J2EEDataSource.getXADataSource();
1:7fe51c3:             J2EEDataSource.setBeanProperty(ds, "createDatabase", "create");
1:4f9187e:             pooledConnection = ds.getXAConnection();
1:4f9187e:         } else {
1:4f9187e:             ConnectionPoolDataSource ds =
1:8ed08b2:                 J2EEDataSource.getConnectionPoolDataSource();
1:7fe51c3:             J2EEDataSource.setBeanProperty(ds, "createDatabase", "create");
1:4f9187e:             pooledConnection = ds.getPooledConnection();
1:712b41b:         }
1:4f9187e:         StatementEventListener listener = new StatementEventListener() {
1:4f9187e:                 public void statementClosed(StatementEvent event) {
1:4f9187e:                     closedStatement = event.getStatement();
1:4f9187e:                     closedCount++;
1:4f9187e:                 }
1:4f9187e:                 public void statementErrorOccurred(StatementEvent event) {
1:4f9187e:                     errorStatement = event.getStatement();
1:4f9187e:                     errorCount++;
1:4f9187e:                 }
1:4f9187e:             };
1:4f9187e:         pooledConnection.addStatementEventListener(listener);
1:4f9187e:         connection = pooledConnection.getConnection();
1:407e52d:     }
1:407e52d: 
1:712b41b:     /**
1:4f9187e:      * Free resources used in the test.
1:712b41b:      *
1:ec5ae26:      * @exception Exception if an error occurs
1:448ecb0:      */
1:ec5ae26:     protected void tearDown() throws Exception {
1:4f9187e:         connection.close();
1:4f9187e:         pooledConnection.close();
1:ec5ae26:         connection = null;
1:ec5ae26:         pooledConnection = null;
1:ec5ae26:         closedStatement = null;
1:ec5ae26:         errorStatement = null;
1:ec5ae26:         super.tearDown();
1:712b41b:     }
1:4f9187e: 
1:712b41b:     /**
1:4f9187e:      * Return suite with all tests of the class for all combinations of
1:4f9187e:      * pooled/xa connection and prepared/callable statement.
1:712b41b:      *
1:ec5ae26:      * @param name name of the test suite
1:4f9187e:      * @return a test suite
1:712b41b:      */
1:ec5ae26:     private static Test baseSuite(String name) {
1:1ae02c9:         BaseTestSuite suites = new BaseTestSuite(name);
1:4f9187e:         boolean[] truefalse = new boolean[] { true, false };
1:4f9187e:         for (boolean xa : truefalse) {
1:4f9187e:             for (boolean callable : truefalse) {
1:4f9187e:                 suites.addTest(new Suite(xa, callable));
1:4f9187e:             }
1:4f9187e:         }
1:4f9187e:         return suites;
1:4f9187e:     }
1:4f9187e: 
1:ec5ae26:     /** Create a test suite with all tests in the class. */
1:ec5ae26:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("StatementEventsTest suite");
1:ec5ae26:         suite.addTest(baseSuite("StatementEventsTest:embedded"));
1:8ed08b2:         suite.addTest(TestConfiguration.clientServerDecorator(
1:8ed08b2:               baseSuite("StatementEventsTest:client")));
1:ec5ae26:         return suite;
1:ec5ae26:     }
1:ec5ae26: 
1:4f9187e:     /**
1:4f9187e:      * Test suite class which contains all test cases in
1:4f9187e:      * <code>StatementEventsTest</code> for a given configuration.
1:4f9187e:      */
1:1ae02c9:     private static class Suite extends BaseTestSuite {
1:4f9187e:         private Suite(boolean xa, boolean callable) {
1:4f9187e:             super(StatementEventsTest.class);
1:1ae02c9: 
1:1ae02c9:             // Iterate over the sorted fixtures and tinker with them
1:1ae02c9:             for (Enumeration<?> i = tests(); i.hasMoreElements(); ) {
1:4f9187e:                 StatementEventsTest test =
1:1ae02c9:                         (StatementEventsTest) i.nextElement();
1:4f9187e:                 test.setXA(xa);
1:4f9187e:                 test.setCallable(callable);
1:4f9187e:             }
1:4f9187e:         }
1:4f9187e:     }
1:4f9187e: 
1:4f9187e:     // UTILITIES
1:4f9187e: 
1:4f9187e:     /**
1:4f9187e:      * Prepare a statement.
1:4f9187e:      *
1:4f9187e:      * @param sql SQL text
1:4f9187e:      * @return a <code>PreparedStatement</code> or
1:4f9187e:      * <code>CallableStatement</code> object
1:4f9187e:      * @exception SQLException if a database error occurs
1:4f9187e:      */
1:4f9187e:     private PreparedStatement prepare(String sql) throws SQLException {
1:4f9187e:         if (callable) {
1:4f9187e:             return connection.prepareCall(sql);
1:4f9187e:         }
1:4f9187e:         return connection.prepareStatement(sql);
1:4f9187e:     }
1:4f9187e: 
1:4f9187e:     // TEST CASES
1:4f9187e: 
1:4f9187e:     /**
1:4f9187e:      * Test that a close event is raised when a statement is closed.
1:4f9187e:      *
1:4f9187e:      * @exception SQLException if a database error occurs
1:4f9187e:      */
1:4f9187e:     public void testCloseEvent() throws SQLException {
1:4f9187e:         PreparedStatement ps = prepare("VALUES (1)");
1:4f9187e:         ps.close();
1:4f9187e:         assertSame("Close event raised on wrong statement.",
1:4f9187e:                    ps, closedStatement);
1:4f9187e:         assertEquals("Incorrect close count.", 1, closedCount);
1:4f9187e:     }
1:4f9187e: 
1:4f9187e:     /**
1:8a4e363:      * Test that you don't get a NullPointerException when the listeners are
1:8a4e363:      * triggered and one of them is null. DERBY-3695
1:8a4e363:      */
1:077d16c:     public void testAddNullListener() throws SQLException {
1:8a4e363:         pooledConnection.addStatementEventListener(null);
1:8a4e363:         PreparedStatement ps = prepare("VALUES (1)");
1:8a4e363:         ps.close(); // trigger close event
1:8a4e363:         assertEquals(1, closedCount);
1:8a4e363:         assertEquals(0, errorCount);
1:8a4e363:         ps = prepare("VALUES (1)");
1:8a4e363:         connection.close();
1:8a4e363:         try {
1:8a4e363:             ps.execute();
1:8a4e363:             fail("Execute should fail on closed connection");
1:8a4e363:         } catch (SQLNonTransientConnectionException e) {
1:8a4e363:             assertSQLState("08003", e);
1:8a4e363:         }
1:8a4e363:         assertEquals(1, errorCount);
1:8a4e363:     }
1:8a4e363: 
1:8a4e363:     /**
1:8a4e363:      * Test that you can call {@code removeStatementEventListener()} with a
1:8a4e363:      * {@code null} argument.
1:8a4e363:      */
1:077d16c:     public void testRemoveNullListener() throws SQLException {
1:8a4e363:         pooledConnection.removeStatementEventListener(null);
1:8a4e363:     }
1:8a4e363: 
1:8a4e363:     /**
1:077d16c:      * Test how the listener behaves if it is added twice.
1:077d16c:      */
1:077d16c:     public void testDoubleAddListener() throws SQLException {
1:077d16c:         SimpleListener listener = new SimpleListener();
1:077d16c:         pooledConnection.addStatementEventListener(listener);
1:077d16c:         pooledConnection.addStatementEventListener(listener);
1:077d16c: 
1:077d16c:         // Generate a close event.
1:077d16c:         prepare("VALUES (1)").close();
1:077d16c: 
1:077d16c:         // The listener will have been invoked twice.
1:077d16c:         assertEquals(2, listener.getCloseCount());
1:077d16c:         assertEquals(0, listener.getErrorCount());
1:077d16c: 
1:077d16c:         listener.resetCounts();
1:077d16c: 
1:077d16c:         // Generate an error event.
1:077d16c:         PreparedStatement ps = prepare("VALUES (1)");
1:077d16c:         connection.close();
1:077d16c:         assertStatementError("08003", ps);
1:077d16c: 
1:077d16c:         // The listener will have been invoked twice with an error event.
1:077d16c:         // On the client, it will also have been invoked twice with a close
1:077d16c:         // event - see DERBY-3851.
1:077d16c:         assertEquals(2, listener.getErrorCount());
1:077d16c:         assertEquals(usingDerbyNetClient() ? 2 : 0, listener.getCloseCount());
1:077d16c:     }
1:077d16c: 
1:077d16c:     /**
1:4f9187e:      * Test whether a close event is raised when a connection is
1:4f9187e:      * closed. (Client should raise a close event since the connection calls
1:4f9187e:      * <code>close()</code> on its statements. Embedded should not raise a
1:4f9187e:      * close event since the connection does not call <code>close()</code> on
1:4f9187e:      * its statements.)
1:4f9187e:      *
1:4f9187e:      * @exception SQLException if a database error occurs
1:4f9187e:      */
1:4f9187e:     public void testCloseEventOnClosedConnection() throws SQLException {
1:4f9187e:         PreparedStatement ps = prepare("VALUES (1)");
1:4f9187e:         connection.close();
1:4f9187e:         if (usingDerbyNetClient()) {
1:4f9187e:             assertSame("Close event raised on wrong statement.",
1:4f9187e:                        ps, closedStatement);
1:4f9187e:             assertEquals("Incorrect close count.", 1, closedCount);
1:4f9187e:         } else if (usingEmbedded()) {
1:4f9187e:             assertNull("Didn't expect close event.", closedStatement);
1:4f9187e:             assertEquals("Incorrect close count.", 0, closedCount);
1:4f9187e:         } else {
1:4f9187e:             fail("Unknown framework.");
1:4f9187e:         }
1:4f9187e:     }
1:4f9187e: 
1:4f9187e:     /**
1:4f9187e:      * Test that an error event is raised when <code>execute()</code> fails
1:4f9187e:      * because the connection is closed.
1:4f9187e:      *
1:4f9187e:      * @exception SQLException if a database error occurs
1:4f9187e:      */
1:4f9187e:     public void testErrorEventOnClosedConnection() throws SQLException {
1:4f9187e:         PreparedStatement ps = prepare("VALUES (1)");
1:4f9187e:         connection.close();
1:4f9187e:         try {
1:4f9187e:             ps.execute();
1:4f9187e:             fail("No exception thrown.");
1:4f9187e:         } catch (SQLException e) {
1:4f9187e:             assertSQLState("Unexpected SQL state.", "08003", e);
1:4f9187e:             assertSame("Error event raised on wrong statement.",
1:4f9187e:                        ps, errorStatement);
1:4f9187e:             assertEquals("Incorrect error count.", 1, errorCount);
1:4f9187e:         }
1:712b41b:     }
1:431eec8: 
1:431eec8:     /**
1:431eec8:      * Test that removing a listener from a listener works. (DERBY-3401)
1:431eec8:      */
1:431eec8:     public void testRemoveListenerFromListener() throws SQLException {
1:431eec8: 
1:431eec8:         // First element is number of times the close listeners below have
1:431eec8:         // been triggered, second element is number of times the error
1:431eec8:         // listeners have been triggered.
1:431eec8:         final int[] counters = new int[2];
1:431eec8: 
1:431eec8:         // Add some listeners that remove themselves
1:431eec8:         for (int i = 0; i < 5; i++) {
1:431eec8:             StatementEventListener close = new StatementEventListener() {
1:431eec8: 
1:431eec8:                 public void statementClosed(StatementEvent event) {
1:431eec8:                     pooledConnection.removeStatementEventListener(this);
1:431eec8:                     counters[0]++;
1:431eec8:                 }
1:431eec8: 
1:431eec8:                 public void statementErrorOccurred(StatementEvent event) {
1:431eec8:                 }
1:431eec8:             };
1:431eec8:             pooledConnection.addStatementEventListener(close);
1:431eec8: 
1:431eec8:             StatementEventListener error = new StatementEventListener() {
1:431eec8: 
1:431eec8:                 public void statementClosed(StatementEvent event) {
1:431eec8:                 }
1:431eec8: 
1:431eec8:                 public void statementErrorOccurred(StatementEvent event) {
1:431eec8:                     pooledConnection.removeStatementEventListener(this);
1:431eec8:                     counters[1]++;
1:431eec8:                 }
1:431eec8:             };
1:431eec8:             pooledConnection.addStatementEventListener(error);
1:431eec8:         }
1:431eec8: 
1:431eec8:         // Generate close event twice. The close listeners remove themselves
1:431eec8:         // in the first iteration, so no updates of the counters are expected
1:431eec8:         // in the second iteration.
1:431eec8:         for (int i = 0; i < 2; i++) {
1:431eec8:             prepare("VALUES (1)").close();
1:431eec8:             assertEquals("unexpected number of close events", 5, counters[0]);
1:431eec8:             assertEquals("unexpected number of error events", 0, counters[1]);
1:431eec8:         }
1:431eec8: 
1:431eec8:         // reset counters
1:431eec8:         Arrays.fill(counters, 0);
1:431eec8: 
1:431eec8:         // Generate error event twice. Only expect counters to be updated in
1:431eec8:         // the first iteration since the listeners remove themselves.
1:431eec8:         for (int i = 0; i < 2; i++) {
1:431eec8:             PreparedStatement ps = prepare("VALUES (1)");
1:431eec8:             connection.close();
1:431eec8:             try {
1:431eec8:                 ps.execute();
1:431eec8:                 fail("Execute on closed connection should fail");
1:431eec8:             } catch (SQLNonTransientConnectionException e) {
1:431eec8:                 assertSQLState("08003", e);
1:431eec8:             }
1:431eec8:             assertEquals("unexpected number of close events", 0, counters[0]);
1:431eec8:             assertEquals("unexpected number of error events", 5, counters[1]);
1:431eec8:             connection = pooledConnection.getConnection();
1:431eec8:         }
1:431eec8: 
1:431eec8:         // The listeners that are automatically added for all test cases have
1:431eec8:         // been active all the time.
1:431eec8:         assertEquals("Incorrect error count", 2, errorCount);
1:431eec8:         // Embedded doesn't receive close events when the connection is
1:431eec8:         // closed, whereas the client driver does. This is therefore an
1:431eec8:         // expected difference.
1:431eec8:         if (usingEmbedded()) {
1:431eec8:             assertEquals("Incorrect close count", 2, closedCount);
1:431eec8:         } else if (usingDerbyNetClient()) {
1:431eec8:             assertEquals("Incorrect close count", 4, closedCount);
1:431eec8:         } else {
1:431eec8:             fail("unknown framework");
1:431eec8:         }
1:431eec8:     }
1:431eec8: 
1:431eec8:     /**
1:431eec8:      * Test that adding a listener from a listener works. (DERBY-3401)
1:431eec8:      */
1:431eec8:     public void testAddListenerFromListener() throws SQLException {
1:431eec8: 
1:431eec8:         // First element is number of times the close listeners below have
1:431eec8:         // been triggered, second element is number of times the error
1:431eec8:         // listeners have been triggered. Third element is the number of
1:431eec8:         // times listeners added by close listeners have been triggered,
1:431eec8:         // fourth element is the number of times listeners added by error
1:431eec8:         // listeners have been triggered.
1:431eec8:         final int[] counters = new int[4];
1:431eec8: 
1:431eec8:         // Add some listeners that add another listener
1:431eec8:         for (int i = 0; i < 5; i++) {
1:431eec8:             StatementEventListener close = new StatementEventListener() {
1:431eec8: 
1:431eec8:                 public void statementClosed(StatementEvent event) {
1:431eec8:                     counters[0]++;
1:431eec8:                     pooledConnection.addStatementEventListener(
1:431eec8:                             new StatementEventListener() {
1:431eec8:                         public void statementClosed(StatementEvent e) {
1:431eec8:                             counters[2]++;
1:431eec8:                         }
1:431eec8:                         public void statementErrorOccurred(StatementEvent e) {
1:431eec8:                             counters[2]++;
1:431eec8:                         }
1:431eec8:                     });
1:431eec8:                 }
1:431eec8: 
1:431eec8:                 public void statementErrorOccurred(StatementEvent event) {
1:431eec8:                 }
1:431eec8:             };
1:431eec8: 
1:431eec8:             pooledConnection.addStatementEventListener(close);
1:431eec8: 
1:431eec8:             StatementEventListener error = new StatementEventListener() {
1:431eec8: 
1:431eec8:                 public void statementClosed(StatementEvent event) {
1:431eec8:                 }
1:431eec8: 
1:431eec8:                 public void statementErrorOccurred(StatementEvent event) {
1:431eec8:                     counters[1]++;
1:431eec8:                     pooledConnection.addStatementEventListener(
1:431eec8:                             new StatementEventListener() {
1:431eec8:                         public void statementClosed(StatementEvent e) {
1:431eec8:                             counters[3]++;
1:431eec8:                         }
1:431eec8:                         public void statementErrorOccurred(StatementEvent e) {
1:431eec8:                             counters[3]++;
1:431eec8:                         }
1:431eec8:                     });
1:431eec8:                 }
1:431eec8:             };
1:431eec8: 
1:431eec8:             pooledConnection.addStatementEventListener(error);
1:431eec8:         }
1:431eec8: 
1:431eec8:         // Generate close event
1:431eec8:         prepare("VALUES (1)").close();
1:431eec8:         assertEquals("unexpected number of close events", 5, counters[0]);
1:431eec8:         assertEquals("unexpected number of error events", 0, counters[1]);
1:431eec8:         assertEquals("unexpected number of added close listeners triggered",
1:431eec8:                      0, counters[2]);
1:431eec8:         assertEquals("unexpected number of added error listeners triggered",
1:431eec8:                      0, counters[3]);
1:431eec8: 
1:431eec8:         // Generate another close event
1:431eec8:         prepare("VALUES (1)").close();
1:431eec8:         assertEquals("unexpected number of close events", 10, counters[0]);
1:431eec8:         assertEquals("unexpected number of error events", 0, counters[1]);
1:431eec8:         assertEquals("unexpected number of added close listeners triggered",
1:431eec8:                      5, counters[2]);
1:431eec8:         assertEquals("unexpected number of added error listeners triggered",
1:431eec8:                      0, counters[3]);
1:431eec8: 
1:431eec8:         // Generate a statement that doesn't work
1:431eec8:         PreparedStatement ps = prepare("VALUES (1)");
1:431eec8:         connection.close();
1:431eec8:         // reset counters
1:431eec8:         Arrays.fill(counters, 0);
1:431eec8: 
1:431eec8:         // Generate an error event
1:431eec8:         try {
1:431eec8:             ps.execute();
1:431eec8:             fail("Execute on closed connection should fail");
1:431eec8:         } catch (SQLNonTransientConnectionException e) {
1:431eec8:             assertSQLState("08003", e);
1:431eec8:         }
1:431eec8: 
1:431eec8:         assertEquals("unexpected number of close events", 0, counters[0]);
1:431eec8:         assertEquals("unexpected number of error events", 5, counters[1]);
1:431eec8:         // difference between embedded and client because client gets
1:431eec8:         // statement-closed event when the connection is closed, whereas
1:431eec8:         // embedded doesn't
1:431eec8:         assertEquals("unexpected number of added close listeners triggered",
1:431eec8:                      usingEmbedded() ? 10 : 15, counters[2]);
1:431eec8:         assertEquals("unexpected number of added error listeners triggered",
1:431eec8:                      0, counters[3]);
1:431eec8: 
1:431eec8:         // reset counters
1:431eec8:         Arrays.fill(counters, 0);
1:431eec8: 
1:431eec8:         // Generate another error event, now with more listeners active
1:431eec8:         try {
1:431eec8:             ps.execute();
1:431eec8:             fail("Execute on closed connection should fail");
1:431eec8:         } catch (SQLNonTransientConnectionException e) {
1:431eec8:             assertSQLState("08003", e);
1:431eec8:         }
1:431eec8: 
1:431eec8:         assertEquals("unexpected number of close events", 0, counters[0]);
1:431eec8:         assertEquals("unexpected number of error events", 5, counters[1]);
1:431eec8:         // difference between embedded and client because client gets
1:431eec8:         // statement-closed event when the connection is closed, whereas
1:431eec8:         // embedded doesn't
1:431eec8:         assertEquals("unexpected number of added close listeners triggered",
1:431eec8:                      usingEmbedded() ? 10 : 15, counters[2]);
1:431eec8:         assertEquals("unexpected number of added error listeners triggered",
1:431eec8:                      5, counters[3]);
1:431eec8: 
1:431eec8:         // The listeners that are automatically added for all test cases have
1:431eec8:         // been active all the time.
1:431eec8:         assertEquals("Incorrect error count", 2, errorCount);
1:431eec8:         // Embedded doesn't receive close events when the connection is
1:431eec8:         // closed, whereas the client driver does. This is therefore an
1:431eec8:         // expected difference.
1:431eec8:         if (usingEmbedded()) {
1:431eec8:             assertEquals("Incorrect close count", 2, closedCount);
1:431eec8:         } else if (usingDerbyNetClient()) {
1:431eec8:             assertEquals("Incorrect close count", 3, closedCount);
1:431eec8:         } else {
1:431eec8:             fail("unknown framework");
1:431eec8:         }
1:431eec8:     }
1:431eec8: 
1:448ecb0:     /**
1:077d16c:      * Test how {@code addStatementEventListener()} and
1:077d16c:      * {@code removeStatementEventListener()} behave when they are called
1:077d16c:      * on a closed {@code PooledConnection} or {@code XAConnection}.
1:077d16c:      */
1:077d16c:     public void testAddRemoveListenerOnClosedObject() throws SQLException {
1:077d16c:         // Add a listener that we can try to remove later after closing.
1:077d16c:         SimpleListener listener = new SimpleListener();
1:077d16c:         pooledConnection.addStatementEventListener(listener);
1:077d16c: 
1:077d16c:         // Close the PooledConnection or XAConnection.
1:077d16c:         pooledConnection.close();
1:077d16c: 
1:077d16c:         // Remove the listener and add a new one. No exception is thrown.
1:077d16c:         pooledConnection.removeStatementEventListener(listener);
1:077d16c:         pooledConnection.addStatementEventListener(new SimpleListener());
1:077d16c:     }
1:077d16c: 
1:077d16c:     /**
1:077d16c:      * Test that removing a listener that hasn't been added first, doesn't
1:077d16c:      * cause any errors.
1:077d16c:      */
1:077d16c:     public void testRemoveListenerNotAddedFirst() throws SQLException {
1:077d16c:         pooledConnection.removeStatementEventListener(new SimpleListener());
1:077d16c: 
1:077d16c:         // Verify that the listener that was there (added in setUp()) is
1:077d16c:         // still there.
1:077d16c:         prepare("VALUES (1)").close();
1:077d16c:         assertEquals(1, closedCount);
1:077d16c:         assertEquals(0, errorCount);
1:077d16c:     }
1:077d16c: 
1:077d16c:     /**
1:077d16c:      * A simple {@code StatementEventListener} that counts the number of
1:077d16c:      * times it has been triggered.
1:077d16c:      */
1:077d16c:     private static class SimpleListener implements StatementEventListener {
1:077d16c:         private int closeCount;
1:077d16c:         private int errorCount;
1:077d16c: 
1:077d16c:         @Override
1:077d16c:         public void statementClosed(StatementEvent event) {
1:077d16c:             closeCount++;
1:077d16c:         }
1:077d16c: 
1:077d16c:         @Override
1:077d16c:         public void statementErrorOccurred(StatementEvent event) {
1:077d16c:             errorCount++;
1:077d16c:         }
1:077d16c: 
1:077d16c:         private int getCloseCount() {
1:077d16c:             return closeCount;
1:077d16c:         }
1:077d16c: 
1:077d16c:         private int getErrorCount() {
1:077d16c:             return errorCount;
1:077d16c:         }
1:077d16c: 
1:077d16c:         private void resetCounts() {
1:077d16c:             closeCount = 0;
1:077d16c:             errorCount = 0;
1:077d16c:         }
1:077d16c:     }
1:712b41b: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
1: import java.sql.SQLNonTransientConnectionException;
1: import java.sql.Statement;
1: import java.util.Enumeration;
1: import javax.sql.ConnectionPoolDataSource;
1: import javax.sql.PooledConnection;
1: import javax.sql.StatementEvent;
1: import javax.sql.StatementEventListener;
1: import javax.sql.XADataSource;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suites = new BaseTestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("StatementEventsTest suite");
/////////////////////////////////////////////////////////////////////////
1:     private static class Suite extends BaseTestSuite {
1: 
1:             // Iterate over the sorted fixtures and tinker with them
1:             for (Enumeration<?> i = tests(); i.hasMoreElements(); ) {
1:                         (StatementEventsTest) i.nextElement();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:077d16c
/////////////////////////////////////////////////////////////////////////
1:     public void testAddNullListener() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void testRemoveNullListener() throws SQLException {
1:      * Test how the listener behaves if it is added twice.
1:      */
1:     public void testDoubleAddListener() throws SQLException {
1:         SimpleListener listener = new SimpleListener();
1:         pooledConnection.addStatementEventListener(listener);
1:         pooledConnection.addStatementEventListener(listener);
1: 
1:         // Generate a close event.
1:         prepare("VALUES (1)").close();
1: 
1:         // The listener will have been invoked twice.
1:         assertEquals(2, listener.getCloseCount());
1:         assertEquals(0, listener.getErrorCount());
1: 
1:         listener.resetCounts();
1: 
1:         // Generate an error event.
1:         PreparedStatement ps = prepare("VALUES (1)");
1:         connection.close();
1:         assertStatementError("08003", ps);
1: 
1:         // The listener will have been invoked twice with an error event.
1:         // On the client, it will also have been invoked twice with a close
1:         // event - see DERBY-3851.
1:         assertEquals(2, listener.getErrorCount());
1:         assertEquals(usingDerbyNetClient() ? 2 : 0, listener.getCloseCount());
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test how {@code addStatementEventListener()} and
1:      * {@code removeStatementEventListener()} behave when they are called
1:      * on a closed {@code PooledConnection} or {@code XAConnection}.
1:      */
1:     public void testAddRemoveListenerOnClosedObject() throws SQLException {
1:         // Add a listener that we can try to remove later after closing.
1:         SimpleListener listener = new SimpleListener();
1:         pooledConnection.addStatementEventListener(listener);
1: 
1:         // Close the PooledConnection or XAConnection.
1:         pooledConnection.close();
1: 
1:         // Remove the listener and add a new one. No exception is thrown.
1:         pooledConnection.removeStatementEventListener(listener);
1:         pooledConnection.addStatementEventListener(new SimpleListener());
1:     }
1: 
1:     /**
1:      * Test that removing a listener that hasn't been added first, doesn't
1:      * cause any errors.
1:      */
1:     public void testRemoveListenerNotAddedFirst() throws SQLException {
1:         pooledConnection.removeStatementEventListener(new SimpleListener());
1: 
1:         // Verify that the listener that was there (added in setUp()) is
1:         // still there.
1:         prepare("VALUES (1)").close();
1:         assertEquals(1, closedCount);
1:         assertEquals(0, errorCount);
1:     }
1: 
1:     /**
1:      * A simple {@code StatementEventListener} that counts the number of
1:      * times it has been triggered.
1:      */
1:     private static class SimpleListener implements StatementEventListener {
1:         private int closeCount;
1:         private int errorCount;
1: 
1:         @Override
1:         public void statementClosed(StatementEvent event) {
1:             closeCount++;
1:         }
1: 
1:         @Override
1:         public void statementErrorOccurred(StatementEvent event) {
1:             errorCount++;
1:         }
1: 
1:         private int getCloseCount() {
1:             return closeCount;
1:         }
1: 
1:         private int getErrorCount() {
1:             return errorCount;
1:         }
1: 
1:         private void resetCounts() {
1:             closeCount = 0;
1:             errorCount = 0;
1:         }
1:     }
commit:8a4e363
/////////////////////////////////////////////////////////////////////////
1:      * Test that you don't get a NullPointerException when the listeners are
1:      * triggered and one of them is null. DERBY-3695
1:      */
0:     public void testAddNullEvent() throws SQLException {
1:         pooledConnection.addStatementEventListener(null);
1:         PreparedStatement ps = prepare("VALUES (1)");
1:         ps.close(); // trigger close event
1:         assertEquals(1, closedCount);
1:         assertEquals(0, errorCount);
1:         ps = prepare("VALUES (1)");
1:         connection.close();
1:         try {
1:             ps.execute();
1:             fail("Execute should fail on closed connection");
1:         } catch (SQLNonTransientConnectionException e) {
1:             assertSQLState("08003", e);
1:         }
1:         assertEquals(1, errorCount);
1:     }
1: 
1:     /**
1:      * Test that you can call {@code removeStatementEventListener()} with a
1:      * {@code null} argument.
1:      */
0:     public void testRemoveNullEvent() throws SQLException {
1:         pooledConnection.removeStatementEventListener(null);
1:     }
1: 
1:     /**
commit:431eec8
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that removing a listener from a listener works. (DERBY-3401)
1:      */
1:     public void testRemoveListenerFromListener() throws SQLException {
1: 
1:         // First element is number of times the close listeners below have
1:         // been triggered, second element is number of times the error
1:         // listeners have been triggered.
1:         final int[] counters = new int[2];
1: 
1:         // Add some listeners that remove themselves
1:         for (int i = 0; i < 5; i++) {
1:             StatementEventListener close = new StatementEventListener() {
1: 
1:                 public void statementClosed(StatementEvent event) {
1:                     pooledConnection.removeStatementEventListener(this);
1:                     counters[0]++;
1:                 }
1: 
1:                 public void statementErrorOccurred(StatementEvent event) {
1:                 }
1:             };
1:             pooledConnection.addStatementEventListener(close);
1: 
1:             StatementEventListener error = new StatementEventListener() {
1: 
1:                 public void statementClosed(StatementEvent event) {
1:                 }
1: 
1:                 public void statementErrorOccurred(StatementEvent event) {
1:                     pooledConnection.removeStatementEventListener(this);
1:                     counters[1]++;
1:                 }
1:             };
1:             pooledConnection.addStatementEventListener(error);
1:         }
1: 
1:         // Generate close event twice. The close listeners remove themselves
1:         // in the first iteration, so no updates of the counters are expected
1:         // in the second iteration.
1:         for (int i = 0; i < 2; i++) {
1:             prepare("VALUES (1)").close();
1:             assertEquals("unexpected number of close events", 5, counters[0]);
1:             assertEquals("unexpected number of error events", 0, counters[1]);
1:         }
1: 
1:         // reset counters
1:         Arrays.fill(counters, 0);
1: 
1:         // Generate error event twice. Only expect counters to be updated in
1:         // the first iteration since the listeners remove themselves.
1:         for (int i = 0; i < 2; i++) {
1:             PreparedStatement ps = prepare("VALUES (1)");
1:             connection.close();
1:             try {
1:                 ps.execute();
1:                 fail("Execute on closed connection should fail");
1:             } catch (SQLNonTransientConnectionException e) {
1:                 assertSQLState("08003", e);
1:             }
1:             assertEquals("unexpected number of close events", 0, counters[0]);
1:             assertEquals("unexpected number of error events", 5, counters[1]);
1:             connection = pooledConnection.getConnection();
1:         }
1: 
1:         // The listeners that are automatically added for all test cases have
1:         // been active all the time.
1:         assertEquals("Incorrect error count", 2, errorCount);
1:         // Embedded doesn't receive close events when the connection is
1:         // closed, whereas the client driver does. This is therefore an
1:         // expected difference.
1:         if (usingEmbedded()) {
1:             assertEquals("Incorrect close count", 2, closedCount);
1:         } else if (usingDerbyNetClient()) {
1:             assertEquals("Incorrect close count", 4, closedCount);
1:         } else {
1:             fail("unknown framework");
1:         }
1:     }
1: 
1:     /**
1:      * Test that adding a listener from a listener works. (DERBY-3401)
1:      */
1:     public void testAddListenerFromListener() throws SQLException {
1: 
1:         // First element is number of times the close listeners below have
1:         // been triggered, second element is number of times the error
1:         // listeners have been triggered. Third element is the number of
1:         // times listeners added by close listeners have been triggered,
1:         // fourth element is the number of times listeners added by error
1:         // listeners have been triggered.
1:         final int[] counters = new int[4];
1: 
1:         // Add some listeners that add another listener
1:         for (int i = 0; i < 5; i++) {
1:             StatementEventListener close = new StatementEventListener() {
1: 
1:                 public void statementClosed(StatementEvent event) {
1:                     counters[0]++;
1:                     pooledConnection.addStatementEventListener(
1:                             new StatementEventListener() {
1:                         public void statementClosed(StatementEvent e) {
1:                             counters[2]++;
1:                         }
1:                         public void statementErrorOccurred(StatementEvent e) {
1:                             counters[2]++;
1:                         }
1:                     });
1:                 }
1: 
1:                 public void statementErrorOccurred(StatementEvent event) {
1:                 }
1:             };
1: 
1:             pooledConnection.addStatementEventListener(close);
1: 
1:             StatementEventListener error = new StatementEventListener() {
1: 
1:                 public void statementClosed(StatementEvent event) {
1:                 }
1: 
1:                 public void statementErrorOccurred(StatementEvent event) {
1:                     counters[1]++;
1:                     pooledConnection.addStatementEventListener(
1:                             new StatementEventListener() {
1:                         public void statementClosed(StatementEvent e) {
1:                             counters[3]++;
1:                         }
1:                         public void statementErrorOccurred(StatementEvent e) {
1:                             counters[3]++;
1:                         }
1:                     });
1:                 }
1:             };
1: 
1:             pooledConnection.addStatementEventListener(error);
1:         }
1: 
1:         // Generate close event
1:         prepare("VALUES (1)").close();
1:         assertEquals("unexpected number of close events", 5, counters[0]);
1:         assertEquals("unexpected number of error events", 0, counters[1]);
1:         assertEquals("unexpected number of added close listeners triggered",
1:                      0, counters[2]);
1:         assertEquals("unexpected number of added error listeners triggered",
1:                      0, counters[3]);
1: 
1:         // Generate another close event
1:         prepare("VALUES (1)").close();
1:         assertEquals("unexpected number of close events", 10, counters[0]);
1:         assertEquals("unexpected number of error events", 0, counters[1]);
1:         assertEquals("unexpected number of added close listeners triggered",
1:                      5, counters[2]);
1:         assertEquals("unexpected number of added error listeners triggered",
1:                      0, counters[3]);
1: 
1:         // Generate a statement that doesn't work
1:         PreparedStatement ps = prepare("VALUES (1)");
1:         connection.close();
1:         // reset counters
1:         Arrays.fill(counters, 0);
1: 
1:         // Generate an error event
1:         try {
1:             ps.execute();
1:             fail("Execute on closed connection should fail");
1:         } catch (SQLNonTransientConnectionException e) {
1:             assertSQLState("08003", e);
1:         }
1: 
1:         assertEquals("unexpected number of close events", 0, counters[0]);
1:         assertEquals("unexpected number of error events", 5, counters[1]);
1:         // difference between embedded and client because client gets
1:         // statement-closed event when the connection is closed, whereas
1:         // embedded doesn't
1:         assertEquals("unexpected number of added close listeners triggered",
1:                      usingEmbedded() ? 10 : 15, counters[2]);
1:         assertEquals("unexpected number of added error listeners triggered",
1:                      0, counters[3]);
1: 
1:         // reset counters
1:         Arrays.fill(counters, 0);
1: 
1:         // Generate another error event, now with more listeners active
1:         try {
1:             ps.execute();
1:             fail("Execute on closed connection should fail");
1:         } catch (SQLNonTransientConnectionException e) {
1:             assertSQLState("08003", e);
1:         }
1: 
1:         assertEquals("unexpected number of close events", 0, counters[0]);
1:         assertEquals("unexpected number of error events", 5, counters[1]);
1:         // difference between embedded and client because client gets
1:         // statement-closed event when the connection is closed, whereas
1:         // embedded doesn't
1:         assertEquals("unexpected number of added close listeners triggered",
1:                      usingEmbedded() ? 10 : 15, counters[2]);
1:         assertEquals("unexpected number of added error listeners triggered",
1:                      5, counters[3]);
1: 
1:         // The listeners that are automatically added for all test cases have
1:         // been active all the time.
1:         assertEquals("Incorrect error count", 2, errorCount);
1:         // Embedded doesn't receive close events when the connection is
1:         // closed, whereas the client driver does. This is therefore an
1:         // expected difference.
1:         if (usingEmbedded()) {
1:             assertEquals("Incorrect close count", 2, closedCount);
1:         } else if (usingDerbyNetClient()) {
1:             assertEquals("Incorrect close count", 3, closedCount);
1:         } else {
1:             fail("unknown framework");
1:         }
1:     }
1: 
commit:ec5ae26
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:      * @exception Exception if an error occurs
1:     protected void tearDown() throws Exception {
1:         connection = null;
1:         pooledConnection = null;
1:         closedStatement = null;
1:         errorStatement = null;
1:         super.tearDown();
1:      * @param name name of the test suite
1:     private static Test baseSuite(String name) {
0:         TestSuite suites = new TestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:     /** Create a test suite with all tests in the class. */
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("StatementEventsTest suite");
1:         suite.addTest(baseSuite("StatementEventsTest:embedded"));
0:         // This test will fail in client/server mode until DERBY-2047 is fixed.
0:         //suite.addTest(TestConfiguration.clientServerDecorator(
0:         //    baseSuite("StatementEventsTest:client")));
1:         return suite;
1:     }
1: 
commit:4f9187e
/////////////////////////////////////////////////////////////////////////
0: import java.util.Enumeration;
1: public class StatementEventsTest extends BaseJDBCTestCase {
1: 
1:     /**
1:      * Type of data source to use. If <code>true</code>, use
1:      * <code>XADataSource</code>; otherwise, use
1:      * <code>ConnectionPoolDataSource</code>.
1:      */
1:     private boolean xa;
1:     /**
1:      * Type of statement to use. If <code>true</code>, use
1:      * <code>CallableStatement</code>; otherwise, use
1:      * <code>PreparedStatement</code>.
1:      */
1:     private boolean callable;
1: 
1:     /** The statement that caused the last statementClosed event. */
1:     private Statement closedStatement;
1:     /** Number of times statementClosed events have been raised. */
1:     private int closedCount;
1:     /** The statement that caused the last statementError event. */
1:     private Statement errorStatement;
1:     /** Number of times statementError events have been raised. */
1:     private int errorCount;
1: 
1:     /**
1:      * The pooled connection to use in the test (could also be an XA
1:      * connection).
1:      */
1:     private PooledConnection pooledConnection;
1:     /** The connection object to use in the test. */
1:     private Connection connection;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:      * Set whether the test should use <code>XADataSource</code> or
1:      * <code>ConnectionPoolDataSource</code>.
1:      * @param xa if <code>true</code>, use XA
1:      */
1:     private void setXA(boolean xa) {
1:         this.xa = xa;
1:     }
1: 
1:     /**
1:      * Set whether the test should use <code>CallableStatement</code> or
1:      * <code>PreparedStatement</code>.
1:      * @param callable if <code>true</code>, use callable statement; otherwise,
1:      * use prepared statement
1:      */
1:     private void setCallable(boolean callable) {
1:         this.callable = callable;
1:     }
1: 
1:     /**
1:      * Return the name of the test.
1:      *
1:      * @return name of the test
1:      */
1:     public String getName() {
1:         return super.getName() + (xa ? "_xa" : "_pooled") +
1:             (callable ? "_callable" : "_prepared");
1:     }
1: 
1:     // TEST SETUP
1: 
1:     /**
1:      * Set up the connection to the database and register a statement event
1:      * listener.
1:      *
1:      * @exception SQLException if a database error occurs
1:         if (xa) {
0:             XADataSource ds = TestDataSourceFactory.getXADataSource();
1:             pooledConnection = ds.getXAConnection();
1:         } else {
1:             ConnectionPoolDataSource ds =
0:                 TestDataSourceFactory.getConnectionPoolDataSource();
1:             pooledConnection = ds.getPooledConnection();
1:         StatementEventListener listener = new StatementEventListener() {
1:                 public void statementClosed(StatementEvent event) {
1:                     closedStatement = event.getStatement();
1:                     closedCount++;
1:                 }
1:                 public void statementErrorOccurred(StatementEvent event) {
1:                     errorStatement = event.getStatement();
1:                     errorCount++;
1:                 }
1:             };
1:         pooledConnection.addStatementEventListener(listener);
1:         connection = pooledConnection.getConnection();
1:      * Free resources used in the test.
1:      * @exception SQLException if a database error occurs
0:     public void tearDown() throws SQLException {
1:         connection.close();
1:         pooledConnection.close();
1: 
1:      * Return suite with all tests of the class for all combinations of
1:      * pooled/xa connection and prepared/callable statement.
1:      * @return a test suite
0:         TestSuite suites = new TestSuite();
1:         boolean[] truefalse = new boolean[] { true, false };
1:         for (boolean xa : truefalse) {
1:             for (boolean callable : truefalse) {
1:                 suites.addTest(new Suite(xa, callable));
1:             }
1:         }
1:         return suites;
1:     }
1: 
1:     /**
1:      * Test suite class which contains all test cases in
1:      * <code>StatementEventsTest</code> for a given configuration.
1:      */
0:     private static class Suite extends TestSuite {
1:         private Suite(boolean xa, boolean callable) {
1:             super(StatementEventsTest.class);
0:             for (Enumeration e = tests(); e.hasMoreElements(); ) {
1:                 StatementEventsTest test =
0:                     (StatementEventsTest) e.nextElement();
1:                 test.setXA(xa);
1:                 test.setCallable(callable);
1:             }
1:         }
1:     }
1: 
1:     // UTILITIES
1: 
1:     /**
1:      * Prepare a statement.
1:      *
1:      * @param sql SQL text
1:      * @return a <code>PreparedStatement</code> or
1:      * <code>CallableStatement</code> object
1:      * @exception SQLException if a database error occurs
1:      */
1:     private PreparedStatement prepare(String sql) throws SQLException {
1:         if (callable) {
1:             return connection.prepareCall(sql);
1:         }
1:         return connection.prepareStatement(sql);
1:     }
1: 
1:     // TEST CASES
1: 
1:     /**
1:      * Test that a close event is raised when a statement is closed.
1:      *
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testCloseEvent() throws SQLException {
1:         PreparedStatement ps = prepare("VALUES (1)");
1:         ps.close();
1:         assertSame("Close event raised on wrong statement.",
1:                    ps, closedStatement);
1:         assertEquals("Incorrect close count.", 1, closedCount);
1:     }
1: 
1:     /**
1:      * Test whether a close event is raised when a connection is
1:      * closed. (Client should raise a close event since the connection calls
1:      * <code>close()</code> on its statements. Embedded should not raise a
1:      * close event since the connection does not call <code>close()</code> on
1:      * its statements.)
1:      *
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testCloseEventOnClosedConnection() throws SQLException {
1:         PreparedStatement ps = prepare("VALUES (1)");
1:         connection.close();
1:         if (usingDerbyNetClient()) {
1:             assertSame("Close event raised on wrong statement.",
1:                        ps, closedStatement);
1:             assertEquals("Incorrect close count.", 1, closedCount);
1:         } else if (usingEmbedded()) {
1:             assertNull("Didn't expect close event.", closedStatement);
1:             assertEquals("Incorrect close count.", 0, closedCount);
1:         } else {
1:             fail("Unknown framework.");
1:         }
1:     }
1: 
1:     /**
1:      * Test that an error event is raised when <code>execute()</code> fails
1:      * because the connection is closed.
1:      *
1:      * @exception SQLException if a database error occurs
1:      */
1:     public void testErrorEventOnClosedConnection() throws SQLException {
1:         PreparedStatement ps = prepare("VALUES (1)");
1:         connection.close();
1:         try {
1:             ps.execute();
1:             fail("No exception thrown.");
1:         } catch (SQLException e) {
1:             assertSQLState("Unexpected SQL state.", "08003", e);
1:             assertSame("Error event raised on wrong statement.",
1:                        ps, errorStatement);
1:             assertEquals("Incorrect error count.", 1, errorCount);
1:         }
commit:57efc3c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.TestDataSourceFactory;
/////////////////////////////////////////////////////////////////////////
0:         XADataSource xadatasource = TestDataSourceFactory.getXADataSource();
0:         ConnectionPoolDataSource cpds = TestDataSourceFactory.getConnectionPoolDataSource();
commit:407e52d
/////////////////////////////////////////////////////////////////////////
0:     //In the case of the client driver when the connection is closed then 
0:     //the prepared statements associated with the connection are also closed
0:     //this would raise closed events for corresponding prepared statements
1:     
0:     //using a flag to identify the occurrence of the error event in the
0:     //network client which can also cause the close event to be raised
0:     boolean client_ErrorEvent=false;
1:     
/////////////////////////////////////////////////////////////////////////
0:             //mark the falg to indicate that we are raising a error event 
0:             //on the client framework
0:             if(usingDerbyNetClient())            
0:                 client_ErrorEvent = true;
1:             
/////////////////////////////////////////////////////////////////////////
0:         //If the event was caused by ps_close and not
0:         //by ps_error. In this case client_ErrorEvent
0:         //will be false.
0:         //In this case check if the StatementEvent
0:         //has a proper reference to ps_close
0:         //which is the actual prepared statement
0:         //that caused the error event.
0:         if(!client_ErrorEvent && (ps_close==null || 
0:             !event.getStatement().equals(ps_close))) {
0:             System.out.println("The statement event has the wrong reference " +
0:                 "of PreparedStatement");
1:         }
1:         
0:         //If it is caused by the error occurred event on the 
0:         //Network client side. upon doing a Connection.close()
0:         //the Prepared Statements associated with the 
0:         //Connection are automatically marked closed
0:         //check if the StatementEvent has a proper reference to ps_error
0:         if(client_ErrorEvent && (ps_error==null || 
0:             !event.getStatement().equals(ps_error))) {
0:             System.out.println("The statement event has the wrong reference" +
0:                 " of PreparedStatement");
commit:712b41b
/////////////////////////////////////////////////////////////////////////
0:     //used to test StatementEvents raised from PooledConnection
0:     //used to test StatementEvents raised from XAConnection
0:     XAConnection xaconnection;
1:     
/////////////////////////////////////////////////////////////////////////
0:         XADataSource xadatasource = getXADataSource();
1:         
0:         xaconnection = xadatasource.getXAConnection();
0:         //registering as a listener for the 
0:         //PooledConnection object
0:         //registering as a listener for the 
0:         //XAConnection
0:         xaconnection.addStatementEventListener(this);
/////////////////////////////////////////////////////////////////////////
0:             ps_close = conn.prepareStatement("values 1");
/////////////////////////////////////////////////////////////////////////
0:             ps_error = conn.prepareStatement("values 1");
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      *
0:      * Check to see if the events were properly raised during execution.
0:      * raise the close and the error event for the PooledConnection and
0:      * check if they occur properly.
1:      * 
0:      * @throws java.sql.SQLException 
1:      *
0:     public void testIfEventOccurredInPooledConnection() throws SQLException {
0:         //Get a connection from the PooledConnection object
0:         conn = pooledConnection.getConnection();
1:         
0:         //reset the flags to enable it to be used for 
0:         //both the cases of XAConnection and PooledConnection
0:         else {
0:             statementCloseEventOccurred = false;
1:         }
1:             
0:         else {
0:             statementErrorEventOccurred = false;
1:         }
1:         
0:         //close the used prepared statements and connections
0:         //for the PooledConnection StatementEventListener tests
0:         //so that if tests on PooledConnection is the first instance of the 
0:         //tests that are run then we can run the same for
0:         //XAConnection.
0:         if(ps_close != null && !ps_close.isClosed()) {
0:             ps_close.close();
1:         }
0:         if(ps_error != null && !ps_error.isClosed()) {
0:             ps_error.close();
1:         }
0:         if(conn != null && !conn.isClosed()) {
0:             conn.rollback();
0:             conn.close();
1:         }
0:         if(pooledConnection != null)
0:             pooledConnection.close();
1:     }
1:     
1:     /**
0:      * Check to see if the events were properly raised during execution.
0:      * Raise the close and the error event for the XAConnection and check if 
0:      * if they occur properly.
1:      *
0:      * @throws java.sql.SQLExeption
1:      */
0:     public void testIfEventOccurredInXAConnection() throws SQLException {
0:         //Get a connection from the XAConnection object
0:         conn = xaconnection.getConnection();
0:         raiseCloseEvent();
0:         raiseErrorEvent();
1:         
0:         //reset the flags to enable it to be used for 
0:         //both the cases of XAConnection and PooledConnection
0:         if(statementCloseEventOccurred != true) {
0:             System.out.println("The Close Event did not occur");
1:         }
0:         else {
0:             statementCloseEventOccurred = false;
1:         }
1:         
0:         if(statementErrorEventOccurred != true) {
0:             System.out.println("The Error Event did not occur");
1:         }
0:         else {
0:             statementErrorEventOccurred = false;
1:         }
1:         
0:         //close the used prepared statements and connections
0:         //for the XAConnection StatementEventListener tests
0:         //so that if tests on XAConnection is the first instance of the 
0:         //tests that are run then we can run the same for
0:         //PooledConnection.
0:         if(ps_close != null) {
0:             ps_close.close();
1:         }
0:         if(ps_error != null) {
0:             ps_error.close();
1:         }
0:         if(conn != null && !conn.isClosed()) {
0:             conn.rollback();
0:             conn.close();
1:         }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:7fe51c3
/////////////////////////////////////////////////////////////////////////
1:             J2EEDataSource.setBeanProperty(ds, "createDatabase", "create");
1:             J2EEDataSource.setBeanProperty(ds, "createDatabase", "create");
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:8ed08b2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.J2EEDataSource;
/////////////////////////////////////////////////////////////////////////
1:             XADataSource ds = J2EEDataSource.getXADataSource();
1:                 J2EEDataSource.getConnectionPoolDataSource();
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(TestConfiguration.clientServerDecorator(
1:               baseSuite("StatementEventsTest:client")));
commit:2f625cd
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suites = new TestSuite("StatementEventsTest suite");
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:6e3dbab
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:448ecb0
/////////////////////////////////////////////////////////////////////////
1: /*
0:  
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.StatementEventsTest
0:  
0:    Copyright 2006 The Apache Software Foundation or its licensors, as applicable.
0:  
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0:  
1:       http://www.apache.org/licenses/LICENSE-2.0
0:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
0:  
1:  */
0: 
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
0: 
0: import java.sql.*;
0: import javax.sql.*;
0: import junit.framework.*;
0: 
0: import org.apache.derbyTesting.functionTests.util.BaseJDBCTestCase;
0: 
1: /*
1:     This class is used to test the JDBC4 statement event 
1:     support 
1: */
0: public class StatementEventsTest extends BaseJDBCTestCase 
0:         implements StatementEventListener {
0:     
0:     PooledConnection pooledConnection;
0:     Connection conn;
0:     PreparedStatement ps_close;
0:     PreparedStatement ps_error;
0:     boolean statementCloseEventOccurred=false;
0:     boolean statementErrorEventOccurred=false;
0:     
0:     
1:     /**
1:      * Create a test with the given name.
1:      *
1:      * @param name name of the test.
1:      */
1:     public StatementEventsTest(String name) {
1:         super(name);
0:     }
0:     
1:     /**
1:      *
0:      * get a connection object from which the PreparedStatement objects
0:      * that will be used to raise the events will be created
1:      *
1:      */
1:     public void setUp() throws SQLException {
0:         ConnectionPoolDataSource cpds = getConnectionPoolDataSource();
0:         pooledConnection = cpds.getPooledConnection();
0:         //register this class as a event listener for the
0:         //statement events
0:         pooledConnection.addStatementEventListener(this);
0:         
0:         //Get a connection from the PooledConnection object
0:         conn = pooledConnection.getConnection();
0:     }
0:     
1:     /**
1:      *
0:      * Close the PooledConnection object and the connection and the 
0:      * statements obtained from it.
1:      * 
1:      */
0:     
0:     public void tearDown() throws SQLException {
0:         if(ps_close != null && !ps_close.isClosed()) {
0:             ps_close.close();
0:         }
0:         if(ps_error != null && !ps_error.isClosed()) {
0:             ps_error.close();
0:         }
0:         if(conn != null && !conn.isClosed()) {
0:             conn.rollback();
0:             conn.close();
0:         }
0:         if(pooledConnection != null)
0:             pooledConnection.close();
0:     }
0:     
1:     /*
0:         The method closes a created Prepared Statement
0:         to raise a closed event  
1:     */
0:     void raiseCloseEvent() {
0:         try {
0:             ps_close = conn.prepareStatement("create table temp(n int)");
0: 
0:             //call the close method on this prepared statement object
0:             //this should result in a statement event being generated 
0:             //control is transferred to the sattementCLosed function
0:             ps_close.close();
0:         } catch(SQLException e) {
0:             e.printStackTrace();
0:         } catch (Exception ex) {
0:             ex.printStackTrace();
0:         }
0:     }
0: 
1:     /*
0:         This method closes a connection and then tries to close the prepared 
0:         statement associated with the connection causing an error
0:         event
1:     */
0:     void raiseErrorEvent() {
0:         try {
0:             ps_error = conn.prepareStatement("create table temp(n int)");
0:             
0:             //close the connection associated with this prepared statement
0:             conn.close();
0:             //Now execute the prepared statement this should cause an error
0:             ps_error.execute();
0:             
0:         } catch(SQLException e) {
1:             /*  
0:                 Throw an exception only if the exception does not have a
0:                 state of 08003 which is the state of the SqlException
0:                 got when the connection associated with the PreparedStatement
0:                 is closed before doing a execute on the PreparedStatement 
1:             */
0:             if(!(e.getSQLState().compareTo("08003") == 0)) {
0:                 e.printStackTrace();
0:             }
0:         } catch (Exception ex) {
0:             ex.printStackTrace();
0:         }
0:     }
0: 
1:     /*
0:         implementations of methods in interface 
0:         javax.sql.StatementEventListener
1:     */
0:     
0:     public void statementClosed(StatementEvent event) {
0:         statementCloseEventOccurred = true;
0:         if(ps_close==null || !event.getStatement().equals(ps_close)) {
0:             System.out.println("The statement event has the wrong reference +  of PreparedStatement");
0:         }
0:     }
0: 
0:     public void statementErrorOccurred(StatementEvent event) {
0:         statementErrorEventOccurred = true;
0:         if(ps_error==null || !event.getStatement().equals(ps_error)) {
0:             System.out.println("The statement event has the wrong reference +  of PreparedStatement");
0:         }
0:     }
0:     
1:     /*
0:         Check to see if the events were properly raised during execution
1:      */
0:     public void testIfEventOccurred() {
0:         raiseCloseEvent();
0:         raiseErrorEvent();
0:         if(statementCloseEventOccurred != true) {
0:             System.out.println("The Close Event did not occur");
0:         }
0:         if(statementErrorEventOccurred != true) {
0:             System.out.println("The Error Event did not occur");
0:         }
0:     }
0:     
1:     /**
0:      * Return suite with all tests of the class.
1:      */
0:     public static Test suite() {
0:         return (new TestSuite(StatementEventsTest.class,
0:                               "StatementEventsTest suite"));
0:     }
0: }
============================================================================