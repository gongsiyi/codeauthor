1:fe77ca5: /*
3:fe77ca5: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.TernaryOperatorNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
1:fe77ca5:  */
1:fe77ca5: 
1:fe77ca5: package	org.apache.derby.impl.sql.compile;
1:fe77ca5: 
1:3bb140c: import java.lang.reflect.Modifier;
1:3bb140c: import java.sql.Types;
1:f33fbaf: import java.util.List;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:fe77ca5: import org.apache.derby.iapi.services.compiler.LocalField;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:fe77ca5: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:fe77ca5: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:fe77ca5: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:fe77ca5: import org.apache.derby.iapi.util.JBitSet;
1:fe77ca5: 
1:fe77ca5: /**
1:fe77ca5:  * A TernaryOperatorNode represents a built-in ternary operators.
1:3bb140c:  * This covers  built-in functions like {@code substr()}.
1:fe77ca5:  * Java operators are not represented here: the JSQL language allows Java
1:fe77ca5:  * methods to be called from expressions, but not Java operators.
1:fe77ca5:  *
1:fe77ca5:  */
1:fe77ca5: 
1:3bb140c: class TernaryOperatorNode extends OperatorNode
1:fe77ca5: {
1:2706d1f: 
1:2706d1f:     // Allowed kinds
1:2706d1f:     final static int K_TRIM = 0;
1:2706d1f:     final static int K_LOCATE = 1;
1:2706d1f:     final static int K_SUBSTRING = 2;
1:2706d1f:     final static int K_LIKE = 3;
1:2706d1f:     final static int K_TIMESTAMPADD = 4;
1:2706d1f:     final static int K_TIMESTAMPDIFF = 5;
1:2706d1f: 
1:2706d1f:     /**
1:2706d1f:      * This class is used to hold logically different objects for
1:2706d1f:      * space efficiency. {@code kind} represents the logical object
1:2706d1f:      * type. See also {@link ValueNode#isSameNodeKind}.
1:2706d1f:      */
1:2706d1f:     final int kind;
1:2706d1f: 
1:2706d1f: 
1:fe77ca5: 	String		operator;
1:fe77ca5: 	String		methodName;
1:fe77ca5: 	ValueNode	receiver; 
1:fe77ca5: 
1:fe77ca5: 	ValueNode	leftOperand;
1:fe77ca5: 	ValueNode	rightOperand;
1:fe77ca5: 
1:fe77ca5: 	String		resultInterfaceType;
1:fe77ca5: 	String		receiverInterfaceType;
1:fe77ca5: 	String		leftInterfaceType;
1:fe77ca5: 	String		rightInterfaceType;
1:fe77ca5: 	int			trimType;
1:fe77ca5: 
1:d365a22: 	static final String[] TernaryOperators = {"trim", "LOCATE", "substring", "like", "TIMESTAMPADD", "TIMESTAMPDIFF"};
1:fb3b060: 	static final String[] TernaryMethodNames = {"ansiTrim", "locate", "substring", "like", "timestampAdd", "timestampDiff"};
1:fe77ca5: 	static final String[] TernaryResultType = {ClassName.StringDataValue, 
1:fe77ca5: 			ClassName.NumberDataValue,
1:fe77ca5: 			ClassName.ConcatableDataValue,
1:d365a22: 			ClassName.BooleanDataValue,
1:d365a22:             ClassName.DateTimeDataValue, 
1:d365a22: 			ClassName.NumberDataValue};
1:fe77ca5: 	static final String[][] TernaryArgType = {
1:fe77ca5: 	{ClassName.StringDataValue, ClassName.StringDataValue, "java.lang.Integer"},
1:fe77ca5: 	{ClassName.StringDataValue, ClassName.StringDataValue, ClassName.NumberDataValue},
1:fe77ca5: 	{ClassName.ConcatableDataValue, ClassName.NumberDataValue, ClassName.NumberDataValue},
1:d365a22: 	{ClassName.DataValueDescriptor, ClassName.DataValueDescriptor, ClassName.DataValueDescriptor},
1:d365a22:     {ClassName.DateTimeDataValue, "java.lang.Integer", ClassName.NumberDataValue}, // time.timestampadd( interval, count)
1:d365a22:     {ClassName.DateTimeDataValue, "java.lang.Integer", ClassName.DateTimeDataValue}// time2.timestampDiff( interval, time1)
1:fe77ca5: 	};
1:fe77ca5: 
1:fe77ca5: 	/**
1:3bb140c:      * Constructor for a TernaryOperatorNode
1:fe77ca5: 	 *
1:3bb140c:      * @param receiver      The receiver (e.g., string being operated on in
1:3bb140c:      *                      {@code substr()})
1:fe77ca5: 	 * @param leftOperand	The left operand of the node
1:fe77ca5: 	 * @param rightOperand	The right operand of the node
1:2706d1f:      * @param kind          The kind of the operand
1:3bb140c:      * @param cm            The context manager
1:3bb140c:      */
1:3bb140c:     TernaryOperatorNode(
2:3bb140c:                     ValueNode receiver,
1:3bb140c:                     ValueNode leftOperand,
1:3bb140c:                     ValueNode rightOperand,
1:2706d1f:                     int kind,
1:3bb140c:                     ContextManager cm)
1:3bb140c:     {
1:3bb140c:         super(cm);
1:2706d1f:         this.kind = kind;
1:3bb140c:         constructorMinion(
1:2706d1f:                 receiver, leftOperand, rightOperand, -1);
1:3bb140c:     }
1:fe77ca5: 
1:3bb140c:     /**
1:3bb140c:      * Constructor for a TernaryOperatorNode
1:3bb140c:      *
1:3bb140c:      * @param receiver      The receiver (e.g., string being operated on in
1:3bb140c:      *                      {@code substr()})
1:3bb140c:      * @param leftOperand   The left operand of the node
1:3bb140c:      * @param rightOperand  The right operand of the node
1:2706d1f:      * @param kind          The kind of the operand
1:2706d1f:      * @param trimType      The trim type
1:3bb140c:      * @param cm            The context manager
1:3bb140c:      */
1:2706d1f:     TernaryOperatorNode(ValueNode receiver,
1:3bb140c:                         ValueNode leftOperand,
1:3bb140c:                         ValueNode rightOperand,
1:2706d1f:                         int kind,
2:3bb140c:                         int trimType,
1:3bb140c:                         ContextManager cm)
1:3bb140c:     {
1:3bb140c:         super(cm);
1:2706d1f:         this.kind = kind;
1:3bb140c:         constructorMinion(
1:2706d1f:                 receiver, leftOperand, rightOperand, trimType);
1:3bb140c:     }
1:3bb140c: 
1:3bb140c:     private void constructorMinion(ValueNode receiver,
1:3bb140c:                                    ValueNode leftOperand,
1:3bb140c:                                    ValueNode rightOperand,
1:3bb140c:                                    int trimType) {
1:3bb140c:         this.receiver = receiver;
1:3bb140c:         this.leftOperand = leftOperand;
1:3bb140c:         this.rightOperand = rightOperand;
1:2706d1f:         this.operator = TernaryOperators[this.kind];
1:2706d1f:         this.methodName = TernaryMethodNames[this.kind];
1:2706d1f:         this.resultInterfaceType = TernaryResultType[this.kind];
1:2706d1f:         this.receiverInterfaceType = TernaryArgType[this.kind][0];
1:2706d1f:         this.leftInterfaceType = TernaryArgType[this.kind][1];
1:2706d1f:         this.rightInterfaceType = TernaryArgType[this.kind][2];
1:3bb140c: 
1:3bb140c:         if (trimType != -1) {
1:3bb140c:             this.trimType = trimType;
1:3bb140c:         }
1:3bb140c:     }
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:fe77ca5: 	 * for how this should be done for tree printing.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	This object as a String
1:fe77ca5: 	 */
1:fe77ca5: 
1:3bb140c:     @Override
1:fe77ca5: 	public String toString()
1:01217c2: 	{
1:fe77ca5: 		if (SanityManager.DEBUG)
1:fe77ca5: 		{
1:fe77ca5: 			return "operator: " + operator + "\n" +
1:fe77ca5: 				"methodName: " + methodName + "\n" + 
1:fe77ca5: 				"resultInterfaceType: " + resultInterfaceType + "\n" + 
1:fe77ca5: 				"receiverInterfaceType: " + receiverInterfaceType + "\n" + 
1:fe77ca5: 				"leftInterfaceType: " + leftInterfaceType + "\n" + 
1:fe77ca5: 				"rightInterfaceType: " + rightInterfaceType + "\n" + 
1:fe77ca5: 				super.toString();
1:fe77ca5: 		}
1:fe77ca5: 		else
1:fe77ca5: 		{
1:fe77ca5: 			return "";
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:fe77ca5: 	 * how tree printing is supposed to work.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param depth		The depth of this node in the tree
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:fe77ca5: 	{
1:fe77ca5: 		if (SanityManager.DEBUG)
1:fe77ca5: 		{
1:fe77ca5: 			super.printSubNodes(depth);
1:fe77ca5: 
1:fe77ca5: 			if (receiver != null)
1:fe77ca5: 			{
1:fe77ca5: 				printLabel(depth, "receiver: ");
1:fe77ca5: 				receiver.treePrint(depth + 1);
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			if (leftOperand != null)
1:fe77ca5: 			{
1:fe77ca5: 				printLabel(depth, "leftOperand: ");
1:fe77ca5: 				leftOperand.treePrint(depth + 1);
1:fe77ca5: 			}
1:fe77ca5: 
2:fe77ca5: 			if (rightOperand != null)
1:fe77ca5: 			{
1:fe77ca5: 				printLabel(depth, "rightOperand: ");
1:fe77ca5: 				rightOperand.treePrint(depth + 1);
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Bind this expression.  This means binding the sub-expressions,
1:fe77ca5: 	 * as well as figuring out what the return type is for this expression.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param fromList		The FROM list for the query this
1:fe77ca5: 	 *				expression is in, for binding columns.
1:fe77ca5: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
1:09c2697:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	The new top of the expression tree.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:71c8e86:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
1:fe77ca5: 			throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		receiver = receiver.bindExpression(fromList, subqueryList, 
1:09c2697:             aggregates);
1:fe77ca5: 
1:fe77ca5: 		leftOperand = leftOperand.bindExpression(fromList, subqueryList,
1:09c2697:                 aggregates);
1:fe77ca5: 
1:fe77ca5: 		if (rightOperand != null)
1:fe77ca5: 		{
1:fe77ca5: 			rightOperand = rightOperand.bindExpression(fromList, subqueryList, 
1:09c2697:                 aggregates);
1:fe77ca5: 		}
1:2706d1f: 
1:2706d1f:         if (kind == K_TRIM) {
1:fe77ca5: 			trimBind();
1:2706d1f:         } else if (kind == K_LOCATE) {
1:fe77ca5: 			locateBind();
1:2706d1f:         } else if (kind == K_SUBSTRING) {
1:fe77ca5: 			substrBind();
1:2706d1f:         } else if (kind == K_TIMESTAMPADD) {
1:d365a22:             timestampAddBind();
1:2706d1f:         } else if (kind == K_TIMESTAMPDIFF) {
1:d365a22:             timestampDiffBind();
1:2706d1f:         }
1:fe77ca5: 
1:fe77ca5: 		return this;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Preprocess an expression tree.  We do a number of transformations
1:fe77ca5: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1:fe77ca5: 	 * subquery flattening.
1:fe77ca5: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param	numTables			Number of tables in the DML Statement
1:fe77ca5: 	 * @param	outerFromList		FromList from outer query block
1:fe77ca5: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1:fe77ca5: 	 * @param	outerPredicateList	PredicateList from outer query block
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return		The modified expression
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode preprocess(int numTables,
1:fe77ca5: 								FromList outerFromList,
1:fe77ca5: 								SubqueryList outerSubqueryList,
1:fe77ca5: 								PredicateList outerPredicateList) 
1:fe77ca5: 					throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		receiver = receiver.preprocess(numTables,
1:fe77ca5: 											 outerFromList, outerSubqueryList,
1:fe77ca5: 											 outerPredicateList);
1:fe77ca5: 
1:fe77ca5: 		leftOperand = leftOperand.preprocess(numTables,
1:fe77ca5: 											 outerFromList, outerSubqueryList,
1:fe77ca5: 											 outerPredicateList);
1:fe77ca5: 		if (rightOperand != null)
1:fe77ca5: 		{
1:fe77ca5: 			rightOperand = rightOperand.preprocess(numTables,
1:fe77ca5: 												   outerFromList, outerSubqueryList,
1:fe77ca5: 												   outerPredicateList);
1:fe77ca5: 		}
1:fe77ca5: 		return this;
1:fe77ca5: 	}
1:fe77ca5: 	/**
1:fe77ca5: 	 * Do code generation for this ternary operator.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1:fe77ca5: 	 * @param mb	The method the expression will go into
1:fe77ca5: 	 *
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		int nargs = 0;
1:fe77ca5: 		String receiverType = null;
1:fe77ca5: 
1:fe77ca5: 		/* Allocate an object for re-use to hold the result of the operator */
1:fe77ca5: 		LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, resultInterfaceType);
1:fe77ca5: 
1:fe77ca5: 		receiver.generateExpression(acb, mb);
1:2706d1f:         if (kind == K_TRIM)
1:fe77ca5: 		{
1:fe77ca5: 			mb.push(trimType);
1:fb3b060: 			leftOperand.generateExpression(acb, mb);
1:2278311: 			mb.cast(leftInterfaceType);
1:fe77ca5: 
1:fe77ca5: 			mb.getField(field);
1:fb3b060: 			nargs = 3;
1:fe77ca5: 			receiverType = receiverInterfaceType;
1:fe77ca5: 		}
1:2706d1f:         else if (kind == K_LOCATE)
1:fe77ca5: 		{
1:fe77ca5: 			leftOperand.generateExpression(acb, mb); 
1:fe77ca5: 			mb.upCast(leftInterfaceType);
1:fe77ca5: 			rightOperand.generateExpression(acb, mb);
1:fe77ca5: 			mb.upCast(rightInterfaceType);
1:fe77ca5: 			mb.getField(field);
1:fe77ca5: 			nargs = 3;
1:fe77ca5: 		
1:fe77ca5: 		}
1:2706d1f:         else if (kind == K_SUBSTRING)
1:fe77ca5: 		{
1:fe77ca5: 			leftOperand.generateExpression(acb, mb); 
1:fe77ca5: 			mb.upCast(leftInterfaceType);
1:fe77ca5: 			if (rightOperand != null)
1:fe77ca5: 			{
1:fe77ca5: 				rightOperand.generateExpression(acb, mb);
1:fe77ca5: 				mb.upCast(rightInterfaceType);
1:fe77ca5: 			}
1:fe77ca5: 			else
1:fe77ca5: 			{
1:fe77ca5: 				mb.pushNull(rightInterfaceType);
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			mb.getField(field); // third arg
1:fe77ca5: 			mb.push(receiver.getTypeServices().getMaximumWidth());
1:fe77ca5: 			nargs = 4;
1:fe77ca5: 			receiverType = receiverInterfaceType;
1:fe77ca5: 		}
1:2706d1f:         else if (kind == K_TIMESTAMPADD || kind == K_TIMESTAMPDIFF)
1:fe77ca5:         {
1:d365a22:             Object intervalType = leftOperand.getConstantValueAsObject();
1:d365a22:             if( SanityManager.DEBUG)
1:d365a22:                 SanityManager.ASSERT( intervalType != null && intervalType instanceof Integer,
1:d365a22:                                       "Invalid interval type used for " + operator);
1:d365a22:             mb.push( ((Integer) intervalType).intValue());
1:d365a22:             rightOperand.generateExpression( acb, mb);
1:2706d1f:             mb.upCast(TernaryArgType[kind][2]);
1:d365a22:             acb.getCurrentDateExpression( mb);
1:d365a22: 			mb.getField(field);
1:d365a22: 			nargs = 4;
1:d365a22: 			receiverType = receiverInterfaceType;
1:fe77ca5:         }
1:fe77ca5:             
1:fe77ca5: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultInterfaceType, nargs);
1:fe77ca5: 
1:fe77ca5: 		/*
1:fe77ca5: 		** Store the result of the method call in the field, so we can re-use
1:fe77ca5: 		** the object.
1:fe77ca5: 		*/
1:fe77ca5: 		mb.putField(field);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Set the leftOperand to the specified ValueNode
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param newLeftOperand	The new leftOperand
1:fe77ca5: 	 */
1:3bb140c:     void setLeftOperand(ValueNode newLeftOperand)
1:fe77ca5: 	{
1:fe77ca5: 		leftOperand = newLeftOperand;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the leftOperand
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return The current leftOperand.
1:fe77ca5: 	 */
1:3bb140c:     ValueNode getLeftOperand()
1:fe77ca5: 	{
1:fe77ca5: 		return leftOperand;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Set the rightOperand to the specified ValueNode
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param newRightOperand	The new rightOperand
1:fe77ca5: 	 */
1:3bb140c:     void setRightOperand(ValueNode newRightOperand)
1:fe77ca5: 	{
1:fe77ca5: 		rightOperand = newRightOperand;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the rightOperand
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return The current rightOperand.
1:fe77ca5: 	 */
1:3bb140c:     ValueNode getRightOperand()
1:fe77ca5: 	{
1:fe77ca5: 		return rightOperand;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Categorize this predicate.  Initially, this means
1:fe77ca5: 	 * building a bit map of the referenced tables for each predicate.
1:fe77ca5: 	 * If the source of this ColumnReference (at the next underlying level) 
1:fe77ca5: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1:fe77ca5: 	 * will not be pushed down.
1:fe77ca5: 	 *
1:fe77ca5: 	 * For example, in:
1:fe77ca5: 	 *		select * from (select 1 from s) a (x) where x = 1
1:fe77ca5: 	 * we will not push down x = 1.
1:fe77ca5: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1:fe77ca5: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1:fe77ca5: 	 * that tree into the pushed predicate, and that tree could contain
1:fe77ca5: 	 * subqueries and method calls.
1:fe77ca5: 	 * RESOLVE - revisit this issue once we have views.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1:fe77ca5: 	 * @param simplePredsOnly	Whether or not to consider method
1:fe77ca5: 	 *							calls, field references and conditional nodes
1:fe77ca5: 	 *							when building bit map
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1:fe77ca5: 	 *						or a VirtualColumnNode.
1:fe77ca5: 	 * @exception StandardException			Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		boolean pushable;
1:fe77ca5: 		pushable = receiver.categorize(referencedTabs, simplePredsOnly);
1:fe77ca5: 		pushable = (leftOperand.categorize(referencedTabs, simplePredsOnly) && pushable);
1:fe77ca5: 		if (rightOperand != null)
1:fe77ca5: 		{
1:fe77ca5: 			pushable = (rightOperand.categorize(referencedTabs, simplePredsOnly) && pushable);
1:fe77ca5: 		}
1:fe77ca5: 		return pushable;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Remap all ColumnReferences in this tree to be clones of the
1:fe77ca5: 	 * underlying expression.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return ValueNode			The remapped expression tree.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException			Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode remapColumnReferencesToExpressions()
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		receiver = receiver.remapColumnReferencesToExpressions();
1:fe77ca5: 		leftOperand = leftOperand.remapColumnReferencesToExpressions();
1:fe77ca5: 		if (rightOperand != null)
1:fe77ca5: 		{
1:fe77ca5: 			rightOperand = rightOperand.remapColumnReferencesToExpressions();
1:fe77ca5: 		}
1:fe77ca5: 		return this;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Return whether or not this expression tree represents a constant expression.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	Whether or not this expression tree represents a constant expression.
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isConstantExpression()
1:fe77ca5: 	{
1:fe77ca5: 		return (receiver.isConstantExpression() &&
1:fe77ca5: 				leftOperand.isConstantExpression() &&
1:fe77ca5: 				(rightOperand == null || rightOperand.isConstantExpression()));
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/** @see ValueNode#constantExpression */
1:3bb140c:     @Override
1:3bb140c:     boolean constantExpression(PredicateList whereClause)
1:fe77ca5: 	{
1:fe77ca5: 		return (receiver.constantExpression(whereClause) &&
1:fe77ca5: 				leftOperand.constantExpression(whereClause) &&
1:fe77ca5: 				(rightOperand == null ||
1:fe77ca5: 					rightOperand.constantExpression(whereClause)));
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:fe77ca5: 	 * 
1:fe77ca5: 	 * @param v the visitor
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:fe77ca5: 
1:aebfb28: 		if (receiver != null)
1:fe77ca5: 		{
1:fe77ca5: 			receiver = (ValueNode)receiver.accept(v);
1:fe77ca5: 		}
1:fe77ca5: 
1:aebfb28: 		if (leftOperand != null)
1:fe77ca5: 		{
1:fe77ca5: 			leftOperand = (ValueNode)leftOperand.accept(v);
1:fe77ca5: 		}
1:fe77ca5: 
1:aebfb28: 		if (rightOperand != null)
1:fe77ca5: 		{
1:fe77ca5: 			rightOperand = (ValueNode)rightOperand.accept(v);
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 	/**
1:fe77ca5: 	 * Bind trim expression. 
1:db9ad01: 	 * The variable receiver is the string that needs to be trimmed.
1:db9ad01: 	 * The variable leftOperand is the character that needs to be trimmed from
1:db9ad01: 	 *     receiver.
1:fe77ca5: 	 *     
1:fe77ca5: 	 * @return	The new top of the expression tree.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:fe77ca5: 
1:fe77ca5: 	private ValueNode trimBind() 
1:fe77ca5: 			throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		TypeId	receiverType;
1:3d56c74: 		TypeId	resultType = TypeId.getBuiltInTypeId(Types.VARCHAR);
1:fe77ca5: 
1:fe77ca5: 		// handle parameters here
1:fe77ca5: 
1:fe77ca5: 		/* Is there a ? parameter for the receiver? */
1:d5bc20f: 		if (receiver.requiresTypeFromContext())
1:fe77ca5: 		{
1:fe77ca5: 			/*
1:fe77ca5: 			** According to the SQL standard, if trim has a ? receiver,
1:fe77ca5: 			** its type is varchar with the implementation-defined maximum length
1:fe77ca5: 			** for a varchar.
1:fe77ca5: 			*/
1:fe77ca5: 	
1:d5bc20f: 			receiver.setType(getVarcharDescriptor());
1:db9ad01:             //check if this parameter can pick up it's collation from the 
1:db9ad01: 			//character that will be used for trimming. If not(meaning the
1:db9ad01: 			//character to be trimmed is also a parameter), then it will take 
1:db9ad01: 			//it's collation from the compilation schema.
1:db9ad01:             if (!leftOperand.requiresTypeFromContext()) {
1:b25481f:                 receiver.setCollationInfo(leftOperand.getTypeServices());
1:db9ad01:             } else {
1:9ed7c4d:     			receiver.setCollationUsingCompilationSchema();            	
1:fe77ca5:             }
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		/* Is there a ? parameter on the left? */
1:d5bc20f: 		if (leftOperand.requiresTypeFromContext())
1:fe77ca5: 		{
1:fe77ca5: 			/* Set the left operand type to varchar. */
1:d5bc20f: 			leftOperand.setType(getVarcharDescriptor());
1:db9ad01: 			//collation of ? operand should be picked up from the context.
1:db9ad01:             //By the time we come here, receiver will have correct collation
1:db9ad01:             //set on it and hence we can rely on it to get correct collation
1:db9ad01:             //for the ? for the character that needs to be used for trimming.
1:b25481f:             leftOperand.setCollationInfo(receiver.getTypeServices());           	
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		bindToBuiltIn();
1:fe77ca5: 
1:fe77ca5: 		/*
1:fe77ca5: 		** Check the type of the receiver - this function is allowed only on
1:fe77ca5: 		** string value types.  
1:fe77ca5: 		*/
1:3d56c74: 		receiverType = receiver.getTypeId();
1:fe77ca5: 		if (receiverType.userType())
1:fe77ca5: 			throwBadType("trim", receiverType.getSQLTypeName());
1:fe77ca5: 
1:fe77ca5: 		receiver = castArgToString(receiver);
1:fe77ca5: 
1:111785f: 		if (receiverType.getTypeFormatId() == StoredFormatIds.CLOB_TYPE_ID) {
1:fe77ca5: 		// special case for CLOBs: if we start with a CLOB, we have to get
1:fe77ca5: 		// a CLOB as a result (as opposed to a VARCHAR), because we can have a 
1:fe77ca5: 		// CLOB that is beyond the max length of VARCHAR (ex. "clob(100k)").
1:fe77ca5: 		// This is okay because CLOBs, like VARCHARs, allow variable-length
1:fe77ca5: 		// values (which is a must for the trim to actually work).
1:fe77ca5: 			resultType = receiverType;
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		/*
1:fe77ca5: 		** Check the type of the leftOperand (trimSet).
1:fe77ca5: 		** The leftOperand should be a string value type.  
1:fe77ca5: 		*/
1:fe77ca5: 		TypeId	leftCTI;
1:fe77ca5: 		leftCTI = leftOperand.getTypeId();
1:fe77ca5: 		if (leftCTI.userType())
1:fe77ca5: 			throwBadType("trim", leftCTI.getSQLTypeName());
1:fe77ca5: 
1:fe77ca5: 		leftOperand = castArgToString(leftOperand);
1:fe77ca5: 
1:fe77ca5: 		/*
1:fe77ca5: 		** The result type of trim is varchar.
1:fe77ca5: 		*/
1:fe77ca5: 		setResultType(resultType);
1:133d0fb: 		//Result of TRIM should pick up the collation of the character string
1:133d0fb: 		//that is getting trimmed (which is variable receiver) because it has
1:133d0fb: 		//correct collation set on it.
1:b25481f:         setCollationInfo(receiver.getTypeServices());
1:fe77ca5: 
1:fe77ca5: 		return this;
1:fe77ca5: 	}
1:fe77ca5: 	/*
1:fe77ca5: 	** set result type for operator
1:fe77ca5: 	*/
1:fe77ca5: 	private void setResultType(TypeId resultType) throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		setType(new DataTypeDescriptor(
1:fe77ca5: 						resultType,
1:fe77ca5: 						true,
1:fe77ca5: 						receiver.getTypeServices().getMaximumWidth()
1:fe77ca5: 					)
1:fe77ca5: 				);
1:fe77ca5: 	}
1:fe77ca5: 	/**
1:fe77ca5: 	 * Bind locate operator
1:de4d4c5: 	 * The variable receiver is the string which will searched
1:de4d4c5: 	 * The variable leftOperand is the search character that will looked in the
1:de4d4c5: 	 *     receiver variable.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	The new top of the expression tree.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:fe77ca5: 
1:3bb140c:     ValueNode locateBind() throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		TypeId	firstOperandType, secondOperandType, offsetType;
1:fe77ca5: 
1:fe77ca5: 		/*
1:fe77ca5: 		 * Is there a ? parameter for the first arg.  Copy the 
1:fe77ca5: 		 * left/firstOperand's.  If the left/firstOperand are both parameters,
1:fe77ca5: 		 * both will be max length.
1:fe77ca5: 		 */
1:d5bc20f: 		if( receiver.requiresTypeFromContext())
1:fe77ca5: 		{
1:d5bc20f: 			if( leftOperand.requiresTypeFromContext())
1:fe77ca5: 			{
1:d5bc20f: 				receiver.setType(getVarcharDescriptor());
1:de4d4c5: 	            //Since both receiver and leftOperands are parameters, use the
1:de4d4c5: 				//collation of compilation schema for receiver.
1:9ed7c4d: 				receiver.setCollationUsingCompilationSchema();            	
1:fe77ca5: 			}
1:fe77ca5: 			else
1:fe77ca5: 			{
1:fe77ca5: 				if( leftOperand.getTypeId().isStringTypeId() )
1:fe77ca5: 				{
1:de4d4c5: 					//Since the leftOperand is not a parameter, receiver will
1:de4d4c5: 					//get it's collation from leftOperand through following
1:de4d4c5: 					//setType method
1:d5bc20f: 					receiver.setType(
1:fe77ca5: 							         leftOperand.getTypeServices());
1:fe77ca5: 				}
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 							                            
1:fe77ca5: 		/*
1:fe77ca5: 		 * Is there a ? parameter for the second arg.  Copy the receiver's.
1:fe77ca5: 		 * If the receiver are both parameters, both will be max length.
1:fe77ca5: 		 */
1:d5bc20f: 		if(leftOperand.requiresTypeFromContext())
1:fe77ca5: 		{
1:d5bc20f: 			if(receiver.requiresTypeFromContext())
1:fe77ca5: 			{
1:d5bc20f: 				leftOperand.setType(getVarcharDescriptor());
1:fe77ca5: 			}
1:fe77ca5: 			else
1:fe77ca5: 			{
1:fe77ca5: 				if( receiver.getTypeId().isStringTypeId() )
1:fe77ca5: 				{
1:d5bc20f: 					leftOperand.setType(
1:fe77ca5: 							         receiver.getTypeServices());
1:fe77ca5: 				}
1:fe77ca5: 			}
1:de4d4c5: 			//collation of ? operand should be picked up from the context.
1:de4d4c5:             //By the time we come here, receiver will have correct collation
1:de4d4c5:             //set on it and hence we can rely on it to get correct collation
1:de4d4c5:             //for this ? 
1:b25481f:             leftOperand.setCollationInfo(receiver.getTypeServices());          	
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		/*
1:c6892a1: 		 * Is there a ? parameter for the third arg.  It will be an int.
1:fe77ca5: 		 */
1:d5bc20f: 		if( rightOperand.requiresTypeFromContext())
1:fe77ca5: 		{
1:d5bc20f: 			rightOperand.setType(
1:fe77ca5: 				new DataTypeDescriptor(TypeId.INTEGER_ID, true)); 
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		bindToBuiltIn();
1:fe77ca5: 
1:fe77ca5: 		/*
1:fe77ca5: 		** Check the type of the operand - this function is allowed only
1:fe77ca5: 		** for: receiver = CHAR
1:fe77ca5: 		**      firstOperand = CHAR
1:fe77ca5: 		**      secondOperand = INT
1:fe77ca5: 		*/
1:fe77ca5: 		secondOperandType = leftOperand.getTypeId();
1:fe77ca5: 		offsetType = rightOperand.getTypeId();
1:fe77ca5: 		firstOperandType = receiver.getTypeId();
1:fe77ca5: 
1:fe77ca5: 		if (!firstOperandType.isStringTypeId() ||
1:fe77ca5: 			!secondOperandType.isStringTypeId() || 
1:fe77ca5: 			offsetType.getJDBCTypeId() != Types.INTEGER)
1:fe77ca5: 			throw StandardException.newException(SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE,
1:fe77ca5: 					"LOCATE", "FUNCTION");
1:fe77ca5: 
1:fe77ca5: 		/*
1:fe77ca5: 		** The result type of a LocateFunctionNode is an integer.
1:fe77ca5: 		*/
1:fe77ca5: 		setType(new DataTypeDescriptor(TypeId.INTEGER_ID, 
1:fe77ca5: 				receiver.getTypeServices().isNullable())); 
1:fe77ca5: 
1:fe77ca5: 		return this;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* cast arg to a varchar */
1:fe77ca5: 	protected ValueNode castArgToString(ValueNode vn) throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		TypeCompiler vnTC = vn.getTypeCompiler();
1:fe77ca5: 		if (! vn.getTypeId().isStringTypeId())
1:fe77ca5: 		{
1:d9b6192: 			DataTypeDescriptor dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true,
1:fe77ca5: 	                vnTC.getCastToCharWidth(
1:d9b6192: 		                    vn.getTypeServices()));
1:9ed7c4d: 
1:3bb140c:             ValueNode newNode = new CastNode(vn, dtd, getContextManager());
1:9ed7c4d:             
1:9ed7c4d:             // DERBY-2910 - Match current schema collation for implicit cast as we do for
1:9ed7c4d:             // explicit casts per SQL Spec 6.12 (10)                                                
1:9ed7c4d:             newNode.setCollationUsingCompilationSchema();
1:9ed7c4d:             
1:fe77ca5: 			((CastNode) newNode).bindCastNodeOnly();
1:fe77ca5: 			return newNode;
1:fe77ca5: 		}
1:fe77ca5: 		return vn;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Bind substr expression.  
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	The new top of the expression tree.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:fe77ca5: 
1:3bb140c:     ValueNode substrBind()
1:fe77ca5: 			throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		TypeId	receiverType;
1:fe77ca5: 		TypeId	resultType = TypeId.getBuiltInTypeId(Types.VARCHAR);
1:fe77ca5: 
1:fe77ca5: 		// handle parameters here
1:fe77ca5: 
1:fe77ca5: 		/* Is there a ? parameter for the receiver? */
1:d5bc20f: 		if (receiver.requiresTypeFromContext())
1:fe77ca5: 		{
1:fe77ca5: 			/*
1:fe77ca5: 			** According to the SQL standard, if substr has a ? receiver,
1:fe77ca5: 			** its type is varchar with the implementation-defined maximum length
1:fe77ca5: 			** for a varchar.
1:fe77ca5: 			*/
1:fe77ca5: 	
1:d5bc20f: 			receiver.setType(getVarcharDescriptor());
1:dcca4df: 			//collation of ? operand should be same as the compilation schema 
1:dcca4df: 			//because that is the only context available for us to pick up the
1:dcca4df: 			//collation. There are no other character operands to SUBSTR method
1:dcca4df: 			//to pick up the collation from.
1:9ed7c4d: 			receiver.setCollationUsingCompilationSchema();
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		/* Is there a ? parameter on the left? */
1:d5bc20f: 		if (leftOperand.requiresTypeFromContext())
1:fe77ca5: 		{
1:fe77ca5: 			/* Set the left operand type to int. */
1:d5bc20f: 			leftOperand.setType(							
1:fe77ca5: 				new DataTypeDescriptor(TypeId.INTEGER_ID, true)); 
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		/* Is there a ? parameter on the right? */
1:d5bc20f: 		if ((rightOperand != null) && rightOperand.requiresTypeFromContext())
1:fe77ca5: 		{
1:fe77ca5: 			/* Set the right operand type to int. */
1:d5bc20f: 			rightOperand.setType(							
1:fe77ca5: 				new DataTypeDescriptor(TypeId.INTEGER_ID, true)); 
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		bindToBuiltIn();
1:fe77ca5: 
1:fe77ca5: 		if (!leftOperand.getTypeId().isNumericTypeId() ||
1:fe77ca5: 			(rightOperand != null && !rightOperand.getTypeId().isNumericTypeId()))
1:fe77ca5: 			throw StandardException.newException(SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, "SUBSTR", "FUNCTION");
1:fe77ca5: 
1:fe77ca5: 		/*
1:fe77ca5: 		** Check the type of the receiver - this function is allowed only on
1:fe77ca5: 		** string value types.  
1:fe77ca5: 		*/
1:fe77ca5: 		receiverType = receiver.getTypeId();
1:fe77ca5: 		switch (receiverType.getJDBCTypeId())
1:fe77ca5: 		{
1:fe77ca5: 			case Types.CHAR:
1:fe77ca5: 			case Types.VARCHAR:
1:fe77ca5: 			case Types.LONGVARCHAR:
1:fe77ca5: 			case Types.CLOB:
1:fe77ca5: 				break;
1:fe77ca5: 			default:
1:fe77ca5: 			{
1:fe77ca5: 				throwBadType("SUBSTR", receiverType.getSQLTypeName());
1:fe77ca5: 			}
1:fe77ca5: 		}
1:111785f: 		if (receiverType.getTypeFormatId() == StoredFormatIds.CLOB_TYPE_ID) {
1:3d56c74: 		// special case for CLOBs: if we start with a CLOB, we have to get
1:3d56c74: 		// a CLOB as a result (as opposed to a VARCHAR), because we can have a 
1:3d56c74: 		// CLOB that is beyond the max length of VARCHAR (ex. "clob(100k)").
1:3d56c74: 		// This is okay because CLOBs, like VARCHARs, allow variable-length
1:3d56c74: 		// values (which is a must for the substr to actually work).
1:3d56c74: 			resultType = receiverType;
1:3d56c74: 		}
1:fe77ca5: 
1:fe77ca5: 		// Determine the maximum length of the result
1:fe77ca5: 		int resultLen = receiver.getTypeServices().getMaximumWidth();
1:fe77ca5: 
1:fe77ca5: 		if (rightOperand != null && rightOperand instanceof ConstantNode)
1:fe77ca5: 		{
1:fe77ca5: 			if (((ConstantNode)rightOperand).getValue().getInt() < resultLen)
1:fe77ca5: 				resultLen = ((ConstantNode)rightOperand).getValue().getInt();
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		/*
1:fe77ca5: 		** The result type of substr is a string type
1:fe77ca5: 		*/
1:fe77ca5: 		setType(new DataTypeDescriptor(
1:fe77ca5: 						resultType,
1:fe77ca5: 						true,
1:fe77ca5: 						resultLen
1:fe77ca5: 					));
1:7c5fbc4: 		//Result of SUSBSTR should pick up the collation of the 1st argument
1:7c5fbc4: 		//to SUBSTR. The 1st argument to SUBSTR is represented by the variable
1:7c5fbc4: 		//receiver in this class.
1:b25481f:         setCollationInfo(receiver.getTypeServices());
1:fe77ca5: 		return this;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/**
1:d365a22: 	 * Bind TIMESTAMPADD expression.  
1:fe77ca5: 	 *
1:d365a22: 	 * @return	The new top of the expression tree.
1:fe77ca5: 	 *
1:d365a22: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:fe77ca5: 
1:d365a22:  	private ValueNode timestampAddBind() 
1:d365a22: 			throws StandardException
1:fe77ca5: 	{
1:d365a22:         if( ! bindParameter( rightOperand, Types.INTEGER))
1:fe77ca5:         {
1:d365a22:             int jdbcType = rightOperand.getTypeId().getJDBCTypeId();
1:d365a22:             if( jdbcType != Types.TINYINT && jdbcType != Types.SMALLINT &&
1:d365a22:                 jdbcType != Types.INTEGER && jdbcType != Types.BIGINT)
1:d365a22:                 throw StandardException.newException(SQLState.LANG_INVALID_FUNCTION_ARG_TYPE,
1:bb5be6f:                                                      rightOperand.getTypeId().getSQLTypeName(), 2,
1:d365a22:                                                      operator);
1:fe77ca5:         }
1:d365a22:         bindDateTimeArg( receiver, 3);
1:d365a22:         setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.TIMESTAMP));
1:d365a22:         return this;
1:d365a22:     } // end of timestampAddBind
1:fe77ca5: 
1:fe77ca5: 	/**
1:d365a22: 	 * Bind TIMESTAMPDIFF expression.  
1:fe77ca5: 	 *
1:d365a22: 	 * @return	The new top of the expression tree.
1:fe77ca5: 	 *
1:d365a22: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:fe77ca5: 
1:d365a22:  	private ValueNode timestampDiffBind() 
1:d365a22: 			throws StandardException
1:fe77ca5: 	{
1:d365a22:         bindDateTimeArg( rightOperand, 2);
1:d365a22:         bindDateTimeArg( receiver, 3);
1:962db2d:         setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.BIGINT));
1:d365a22:         return this;
1:d365a22:     } // End of timestampDiffBind
1:fe77ca5: 
1:d365a22:     private void bindDateTimeArg( ValueNode arg, int argNumber) throws StandardException
1:fe77ca5:     {
1:d365a22:         if( ! bindParameter( arg, Types.TIMESTAMP))
1:fe77ca5:         {
1:d365a22:             if( ! arg.getTypeId().isDateTimeTimeStampTypeId())
1:d365a22:                 throw StandardException.newException(SQLState.LANG_INVALID_FUNCTION_ARG_TYPE,
1:bb5be6f:                                                      arg.getTypeId().getSQLTypeName(), argNumber,
1:d365a22:                                                      operator);
1:fe77ca5:         }
1:d365a22:     } // end of bindDateTimeArg
1:fe77ca5: 
1:9841c0d:     /**
1:9841c0d:      * This method gets called for non-character string types and hence no need 
1:9841c0d:      * to set any collation info. Collation applies only to character string
1:9841c0d:      * types.
1:9841c0d:      *  
1:9841c0d:      * @param arg Check if arg is a ? param and if yes, then set it's type to
1:9841c0d:      *    jdbcType if arg doesn't have a type associated with it.
1:9841c0d:      *    
1:9841c0d:      * @param jdbcType Associate this type with arg if arg is a ? param with no
1:9841c0d:      *    type associated with it
1:9841c0d:      *    
1:9841c0d:      * @return true if arg is a ? param with no type associated with it
1:9841c0d:      * @throws StandardException
1:fe77ca5:      */
1:d365a22:     private boolean bindParameter( ValueNode arg, int jdbcType) throws StandardException
1:d365a22:     {
1:d5bc20f:         if( arg.requiresTypeFromContext() && arg.getTypeId() == null)
6:d365a22:         {
1:d5bc20f:             arg.setType( new DataTypeDescriptor(TypeId.getBuiltInTypeId( jdbcType), true));
1:d365a22:             return true;
1:db9ad01:         }
1:d365a22:         return false;
1:d365a22:     } // end of bindParameter
1:fe77ca5: 
1:3bb140c:     ValueNode getReceiver()
1:d365a22: 	{
1:fe77ca5: 		return receiver;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* throw bad type message */
1:fe77ca5: 	private void throwBadType(String funcName, String type) 
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1:fe77ca5: 										funcName,
1:fe77ca5: 										type);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/* bind arguments to built in types */
1:fe77ca5: 	protected void bindToBuiltIn() 
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		/* If the receiver is not a built-in type, then generate a bound conversion
1:fe77ca5: 		 * tree to a built-in type.
1:fe77ca5: 		 */
1:08d6ce2: 		if (receiver.getTypeId().userType())
1:fe77ca5: 		{
1:fe77ca5: 			receiver = receiver.genSQLJavaSQLTree();
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		/* If the left operand is not a built-in type, then generate a bound conversion
1:fe77ca5: 		 * tree to a built-in type.
1:fe77ca5: 		 */
1:08d6ce2: 		if (leftOperand.getTypeId().userType())
1:fe77ca5: 		{
1:fe77ca5: 			leftOperand = leftOperand.genSQLJavaSQLTree();
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		/* If the right operand is not a built-in type, then generate a bound conversion
1:fe77ca5: 		 * tree to a built-in type.
1:fe77ca5: 		 */
1:fe77ca5: 		if (rightOperand != null)
1:fe77ca5: 		{
1:08d6ce2: 			if (rightOperand.getTypeId().userType())
1:fe77ca5: 			{
1:fe77ca5: 				rightOperand = rightOperand.genSQLJavaSQLTree();
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	private DataTypeDescriptor getVarcharDescriptor() {
1:fe77ca5: 		return new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), true);
1:fe77ca5: 	}
1:01217c2:         
1:2706d1f:     boolean isSameNodeKind(ValueNode o) {
1:2706d1f:         return super.isSameNodeKind(o) &&
1:2706d1f:                 ((TernaryOperatorNode)o).kind == this.kind;
1:2706d1f:     }
1:2706d1f: 
1:2706d1f: 
1:2706d1f:     boolean isEquivalent(ValueNode o) throws StandardException
1:01217c2:     {
1:2706d1f:         if (isSameNodeKind(o)) {
1:2706d1f:             TernaryOperatorNode other = (TernaryOperatorNode)o;
1:9ea9234: 		
1:9ea9234: 			/*
1:9ea9234: 			 * SUBSTR function can either have 2 or 3 arguments.  In the 
1:9ea9234: 			 * 2-args case, rightOperand will be null and thus needs 
1:9ea9234: 			 * additional handling in the equivalence check.
1:9ea9234: 			 */
1:01217c2:     		return (other.methodName.equals(methodName)
1:01217c2: 				&& other.receiver.isEquivalent(receiver)
1:01217c2:     				&& other.leftOperand.isEquivalent(leftOperand)
1:9ea9234:     				&& ( (rightOperand == null && other.rightOperand == null) || 
1:9ea9234:     				     (other.rightOperand != null && 
1:9ea9234:     				    	other.rightOperand.isEquivalent(rightOperand)) ) );
1:01217c2:         }
1:01217c2:     	return false;
1:01217c2:     }
1:fe77ca5: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:bb5be6f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                                                      rightOperand.getTypeId().getSQLTypeName(), 2,
/////////////////////////////////////////////////////////////////////////
1:                                                      arg.getTypeId().getSQLTypeName(), argNumber,
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates        The aggregate list being built as we find AggregateNodes
0:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List aggregates)
1:             aggregates);
1:                 aggregates);
1:                 aggregates);
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 		List aggregateVector)
commit:c6892a1
/////////////////////////////////////////////////////////////////////////
1: 		 * Is there a ? parameter for the third arg.  It will be an int.
commit:044afae
/////////////////////////////////////////////////////////////////////////
0: public class TernaryOperatorNode extends OperatorNode
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
1: 		if (receiver != null)
1: 		if (leftOperand != null)
1: 		if (rightOperand != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:3d56c74
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		TypeId	resultType = TypeId.getBuiltInTypeId(Types.VARCHAR);
/////////////////////////////////////////////////////////////////////////
1: 		receiverType = receiver.getTypeId();
/////////////////////////////////////////////////////////////////////////
0: 		if ((receiverType.getTypeFormatId() == StoredFormatIds.CLOB_TYPE_ID) ||
0: 		   (receiverType.getTypeFormatId() == StoredFormatIds.NCLOB_TYPE_ID)) {
1: 		// special case for CLOBs: if we start with a CLOB, we have to get
1: 		// a CLOB as a result (as opposed to a VARCHAR), because we can have a 
1: 		// CLOB that is beyond the max length of VARCHAR (ex. "clob(100k)").
1: 		// This is okay because CLOBs, like VARCHARs, allow variable-length
1: 		// values (which is a must for the substr to actually work).
1: 			resultType = receiverType;
1: 		}
commit:9ea9234
/////////////////////////////////////////////////////////////////////////
1: 		
1: 			/*
1: 			 * SUBSTR function can either have 2 or 3 arguments.  In the 
1: 			 * 2-args case, rightOperand will be null and thus needs 
1: 			 * additional handling in the equivalence check.
1: 			 */
1:     				&& ( (rightOperand == null && other.rightOperand == null) || 
1:     				     (other.rightOperand != null && 
1:     				    	other.rightOperand.isEquivalent(rightOperand)) ) );
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
1: 
1:     // Allowed kinds
1:     final static int K_TRIM = 0;
1:     final static int K_LOCATE = 1;
1:     final static int K_SUBSTRING = 2;
1:     final static int K_LIKE = 3;
1:     final static int K_TIMESTAMPADD = 4;
1:     final static int K_TIMESTAMPDIFF = 5;
1: 
1:     /**
1:      * This class is used to hold logically different objects for
1:      * space efficiency. {@code kind} represents the logical object
1:      * type. See also {@link ValueNode#isSameNodeKind}.
1:      */
1:     final int kind;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param kind          The kind of the operand
1:                     int kind,
1:         this.kind = kind;
1:                 receiver, leftOperand, rightOperand, -1);
1:      * @param kind          The kind of the operand
1:      * @param trimType      The trim type
1:     TernaryOperatorNode(ValueNode receiver,
1:                         int kind,
1:         this.kind = kind;
1:                 receiver, leftOperand, rightOperand, trimType);
1:         this.operator = TernaryOperators[this.kind];
1:         this.methodName = TernaryMethodNames[this.kind];
1:         this.resultInterfaceType = TernaryResultType[this.kind];
1:         this.receiverInterfaceType = TernaryArgType[this.kind][0];
1:         this.leftInterfaceType = TernaryArgType[this.kind][1];
1:         this.rightInterfaceType = TernaryArgType[this.kind][2];
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (kind == K_TRIM) {
1:         } else if (kind == K_LOCATE) {
1:         } else if (kind == K_SUBSTRING) {
1:         } else if (kind == K_TIMESTAMPADD) {
1:         } else if (kind == K_TIMESTAMPDIFF) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (kind == K_TRIM)
/////////////////////////////////////////////////////////////////////////
1:         else if (kind == K_LOCATE)
/////////////////////////////////////////////////////////////////////////
1:         else if (kind == K_SUBSTRING)
/////////////////////////////////////////////////////////////////////////
1:         else if (kind == K_TIMESTAMPADD || kind == K_TIMESTAMPDIFF)
/////////////////////////////////////////////////////////////////////////
1:             mb.upCast(TernaryArgType[kind][2]);
/////////////////////////////////////////////////////////////////////////
1:     boolean isSameNodeKind(ValueNode o) {
1:         return super.isSameNodeKind(o) &&
1:                 ((TernaryOperatorNode)o).kind == this.kind;
1:     }
1: 
1: 
1:     boolean isEquivalent(ValueNode o) throws StandardException
1:         if (isSameNodeKind(o)) {
1:             TernaryOperatorNode other = (TernaryOperatorNode)o;
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Modifier;
1: import java.sql.Types;
0: import java.util.List;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.types.TypeId;
1:  * This covers  built-in functions like {@code substr()}.
1: class TernaryOperatorNode extends OperatorNode
/////////////////////////////////////////////////////////////////////////
0:     static final int TRIM = 0;
0:     static final int LOCATE = 1;
0:     static final int SUBSTRING = 2;
0:     static final int LIKE = 3;
0:     static final int TIMESTAMPADD = 4;
0:     static final int TIMESTAMPDIFF = 5;
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a TernaryOperatorNode
1:      * @param receiver      The receiver (e.g., string being operated on in
1:      *                      {@code substr()})
1:      * @param cm            The context manager
1:      */
1:     TernaryOperatorNode(
1:                     ValueNode receiver,
1:                     ValueNode leftOperand,
1:                     ValueNode rightOperand,
0:                     int operatorType,
1:                     int trimType,
1:                     ContextManager cm)
1:     {
1:         super(cm);
1:         constructorMinion(
0:                 receiver, leftOperand, rightOperand, operatorType, trimType);
1:     }
1:     /**
1:      * Constructor for a TernaryOperatorNode
1:      *
0:      * @param nodeType      The node type
1:      * @param receiver      The receiver (e.g., string being operated on in
1:      *                      {@code substr()})
1:      * @param leftOperand   The left operand of the node
1:      * @param rightOperand  The right operand of the node
0:      * @param operatorType  The type of the operand
1:      * @param cm            The context manager
1:      */
0:     TernaryOperatorNode(int nodeType,
1:                         ValueNode receiver,
1:                         ValueNode leftOperand,
1:                         ValueNode rightOperand,
0:                         int operatorType,
1:                         int trimType,
1:                         ContextManager cm)
1:     {
1:         super(cm);
0:         setNodeType(nodeType);
1:         constructorMinion(
0:                 receiver, leftOperand, rightOperand, operatorType, trimType);
1:     }
1: 
1:     private void constructorMinion(ValueNode receiver,
1:                                    ValueNode leftOperand,
1:                                    ValueNode rightOperand,
0:                                    int operatorType,
1:                                    int trimType) {
1:         this.receiver = receiver;
1:         this.leftOperand = leftOperand;
1:         this.rightOperand = rightOperand;
0:         this.operatorType = operatorType;
0:         this.operator = TernaryOperators[this.operatorType];
0:         this.methodName = TernaryMethodNames[this.operatorType];
0:         this.resultInterfaceType = TernaryResultType[this.operatorType];
0:         this.receiverInterfaceType = TernaryArgType[this.operatorType][0];
0:         this.leftInterfaceType = TernaryArgType[this.operatorType][1];
0:         this.rightInterfaceType = TernaryArgType[this.operatorType][2];
1: 
1:         if (trimType != -1) {
1:             this.trimType = trimType;
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     void setLeftOperand(ValueNode newLeftOperand)
/////////////////////////////////////////////////////////////////////////
1:     ValueNode getLeftOperand()
/////////////////////////////////////////////////////////////////////////
1:     void setRightOperand(ValueNode newRightOperand)
/////////////////////////////////////////////////////////////////////////
1:     ValueNode getRightOperand()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode remapColumnReferencesToExpressions()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isConstantExpression()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean constantExpression(PredicateList whereClause)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     ValueNode locateBind() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:             ValueNode newNode = new CastNode(vn, dtd, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     ValueNode substrBind()
/////////////////////////////////////////////////////////////////////////
1:     ValueNode getReceiver()
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9ed7c4d
/////////////////////////////////////////////////////////////////////////
1:     			receiver.setCollationUsingCompilationSchema();            	
/////////////////////////////////////////////////////////////////////////
1: 				receiver.setCollationUsingCompilationSchema();            	
/////////////////////////////////////////////////////////////////////////
1: 
1:             
1:             // DERBY-2910 - Match current schema collation for implicit cast as we do for
1:             // explicit casts per SQL Spec 6.12 (10)                                                
1:             newNode.setCollationUsingCompilationSchema();
1:             
/////////////////////////////////////////////////////////////////////////
1: 			receiver.setCollationUsingCompilationSchema();
commit:b25481f
/////////////////////////////////////////////////////////////////////////
1:                 receiver.setCollationInfo(leftOperand.getTypeServices());
/////////////////////////////////////////////////////////////////////////
1:             leftOperand.setCollationInfo(receiver.getTypeServices());           	
/////////////////////////////////////////////////////////////////////////
1:         setCollationInfo(receiver.getTypeServices());
/////////////////////////////////////////////////////////////////////////
1:             leftOperand.setCollationInfo(receiver.getTypeServices());          	
/////////////////////////////////////////////////////////////////////////
1:         setCollationInfo(receiver.getTypeServices());
commit:962db2d
/////////////////////////////////////////////////////////////////////////
1:         setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.BIGINT));
commit:01217c2
/////////////////////////////////////////////////////////////////////////
1:         
0:     protected boolean isEquivalent(ValueNode o) throws StandardException
1:     {
0:     	if (isSameNodeType(o)) 
1: 	{
0: 		TernaryOperatorNode other = (TernaryOperatorNode)o;
1:     		return (other.methodName.equals(methodName)
1: 				&& other.receiver.isEquivalent(receiver)
1:     				&& other.leftOperand.isEquivalent(leftOperand)
0:     				&& other.rightOperand.isEquivalent(rightOperand));
1:         }
1:     	return false;
1:     }
commit:08d6ce2
/////////////////////////////////////////////////////////////////////////
1: 		if (receiver.getTypeId().userType())
/////////////////////////////////////////////////////////////////////////
1: 		if (leftOperand.getTypeId().userType())
/////////////////////////////////////////////////////////////////////////
1: 			if (rightOperand.getTypeId().userType())
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.TernaryOperatorNode
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:fe77ca5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: import org.apache.derby.iapi.util.JBitSet;
1: 
0: import java.lang.reflect.Modifier;
1: 
0: import java.sql.Types;
0: import java.util.Vector;
1: /**
1:  * A TernaryOperatorNode represents a built-in ternary operators.
0:  * This covers  built-in functions like substr().
1:  * Java operators are not represented here: the JSQL language allows Java
1:  * methods to be called from expressions, but not Java operators.
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
0: public class TernaryOperatorNode extends ValueNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	String		operator;
1: 	String		methodName;
0: 	int			operatorType;
1: 	ValueNode	receiver; 
1: 
1: 	ValueNode	leftOperand;
1: 	ValueNode	rightOperand;
1: 
1: 	String		resultInterfaceType;
1: 	String		receiverInterfaceType;
1: 	String		leftInterfaceType;
1: 	String		rightInterfaceType;
1: 	int			trimType;
1: 
0: 	public static final int TRIM = 0;
0: 	public static final int LOCATE = 1;
0: 	public static final int SUBSTRING = 2;
0: 	public static final int LIKE = 3;
0: 	static final String[] TernaryOperators = {"trim", "LOCATE", "substring", "like"};
0: 	static final String[] TernaryMethodNames = {"trim", "locate", "substring", "like"};
1: 	static final String[] TernaryResultType = {ClassName.StringDataValue, 
1: 			ClassName.NumberDataValue,
1: 			ClassName.ConcatableDataValue,
0: 			ClassName.BooleanDataValue};
1: 	static final String[][] TernaryArgType = {
1: 	{ClassName.StringDataValue, ClassName.StringDataValue, "java.lang.Integer"},
1: 	{ClassName.StringDataValue, ClassName.StringDataValue, ClassName.NumberDataValue},
1: 	{ClassName.ConcatableDataValue, ClassName.NumberDataValue, ClassName.NumberDataValue},
0: 	{ClassName.DataValueDescriptor, ClassName.DataValueDescriptor, ClassName.DataValueDescriptor}
1: 	};
1: 
1: 	/**
0: 	 * Initializer for a TernaryOperatorNode
1: 	 *
0: 	 * @param receiver		The receiver (eg, string being operated on in substr())
1: 	 * @param leftOperand	The left operand of the node
1: 	 * @param rightOperand	The right operand of the node
0: 	 * @param operatorType	The type of the operand
1: 	 */
1: 
0: 	public void init(
0: 					Object receiver,
0: 					Object leftOperand,
0: 					Object rightOperand,
0: 					Object operatorType,
0: 					Object trimType)
1: 	{
0: 		this.receiver = (ValueNode) receiver;
0: 		this.leftOperand = (ValueNode) leftOperand;
0: 		this.rightOperand = (ValueNode) rightOperand;
0: 		this.operatorType = ((Integer) operatorType).intValue();
0: 		this.operator = (String) TernaryOperators[this.operatorType];
0: 		this.methodName = (String) TernaryMethodNames[this.operatorType];
0: 		this.resultInterfaceType = (String) TernaryResultType[this.operatorType];
0: 		this.receiverInterfaceType = (String) TernaryArgType[this.operatorType][0];
0: 		this.leftInterfaceType = (String) TernaryArgType[this.operatorType][1];
0: 		this.rightInterfaceType = (String) TernaryArgType[this.operatorType][2];
0: 		if (trimType != null)
0: 				this.trimType = ((Integer) trimType).intValue();
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return "operator: " + operator + "\n" +
1: 				"methodName: " + methodName + "\n" + 
1: 				"resultInterfaceType: " + resultInterfaceType + "\n" + 
1: 				"receiverInterfaceType: " + receiverInterfaceType + "\n" + 
1: 				"leftInterfaceType: " + leftInterfaceType + "\n" + 
1: 				"rightInterfaceType: " + rightInterfaceType + "\n" + 
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Set the clause that this node appears in.
1: 	 *
0: 	 * @param clause	The clause that this node appears in.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setClause(int clause)
1: 	{
0: 		super.setClause(clause);
0: 		receiver.setClause(clause);
0: 		leftOperand.setClause(clause);
1: 		if (rightOperand != null)
1: 		{
0: 			rightOperand.setClause(clause);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (receiver != null)
1: 			{
1: 				printLabel(depth, "receiver: ");
1: 				receiver.treePrint(depth + 1);
1: 			}
1: 
1: 			if (leftOperand != null)
1: 			{
1: 				printLabel(depth, "leftOperand: ");
1: 				leftOperand.treePrint(depth + 1);
1: 			}
1: 
1: 			if (rightOperand != null)
1: 			{
1: 				printLabel(depth, "rightOperand: ");
1: 				rightOperand.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind this expression.  This means binding the sub-expressions,
1: 	 * as well as figuring out what the return type is for this expression.
1: 	 *
1: 	 * @param fromList		The FROM list for the query this
1: 	 *				expression is in, for binding columns.
1: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector) 
1: 			throws StandardException
1: 	{
1: 		receiver = receiver.bindExpression(fromList, subqueryList, 
0: 			aggregateVector);
1: 		leftOperand = leftOperand.bindExpression(fromList, subqueryList, 
0: 			aggregateVector);
1: 
1: 		if (rightOperand != null)
1: 		{
1: 			rightOperand = rightOperand.bindExpression(fromList, subqueryList, 
0: 				aggregateVector);
1: 		}
0: 		if (operatorType == TRIM)
1: 			trimBind();
0: 		else if (operatorType == LOCATE)
1: 			locateBind();
0: 		else if (operatorType == SUBSTRING)
1: 			substrBind();
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Preprocess an expression tree.  We do a number of transformations
1: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1: 	 * subquery flattening.
1: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1: 	 *
1: 	 * @param	numTables			Number of tables in the DML Statement
1: 	 * @param	outerFromList		FromList from outer query block
1: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1: 	 * @param	outerPredicateList	PredicateList from outer query block
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode preprocess(int numTables,
1: 								FromList outerFromList,
1: 								SubqueryList outerSubqueryList,
1: 								PredicateList outerPredicateList) 
1: 					throws StandardException
1: 	{
1: 		receiver = receiver.preprocess(numTables,
1: 											 outerFromList, outerSubqueryList,
1: 											 outerPredicateList);
1: 
1: 		leftOperand = leftOperand.preprocess(numTables,
1: 											 outerFromList, outerSubqueryList,
1: 											 outerPredicateList);
1: 		if (rightOperand != null)
1: 		{
1: 			rightOperand = rightOperand.preprocess(numTables,
1: 												   outerFromList, outerSubqueryList,
1: 												   outerPredicateList);
1: 		}
1: 		return this;
1: 	}
1: 	/**
1: 	 * Do code generation for this ternary operator.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb	The method the expression will go into
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
1: 		throws StandardException
1: 	{
1: 		int nargs = 0;
1: 		String receiverType = null;
1: 
1: 		/* Allocate an object for re-use to hold the result of the operator */
1: 		LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, resultInterfaceType);
1: 
1: 		receiver.generateExpression(acb, mb);
0: 		if (operatorType == TRIM)
1: 		{
1: 			mb.push(trimType);
1: 			mb.getField(field);
0: 			nargs = 2;
1: 			receiverType = receiverInterfaceType;
1: 		}
0: 		else if (operatorType == LOCATE)
1: 		{
1: 			leftOperand.generateExpression(acb, mb); 
1: 			mb.upCast(leftInterfaceType);
1: 			rightOperand.generateExpression(acb, mb);
1: 			mb.upCast(rightInterfaceType);
1: 			mb.getField(field);
1: 			nargs = 3;
1: 		
1: 		}
0: 		else if (operatorType == SUBSTRING)
1: 		{
1: 			leftOperand.generateExpression(acb, mb); 
1: 			mb.upCast(leftInterfaceType);
1: 			if (rightOperand != null)
1: 			{
1: 				rightOperand.generateExpression(acb, mb);
1: 				mb.upCast(rightInterfaceType);
1: 			}
1: 			else
1: 			{
1: 				mb.pushNull(rightInterfaceType);
1: 			}
1: 
1: 			mb.getField(field); // third arg
1: 			mb.push(receiver.getTypeServices().getMaximumWidth());
1: 			nargs = 4;
1: 			receiverType = receiverInterfaceType;
1: 		}
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultInterfaceType, nargs);
1: 
1: 		/*
1: 		** Store the result of the method call in the field, so we can re-use
1: 		** the object.
1: 		*/
1: 		mb.putField(field);
1: 	}
1: 
1: 	/**
1: 	 * Set the leftOperand to the specified ValueNode
1: 	 *
1: 	 * @param newLeftOperand	The new leftOperand
1: 	 *
0: 	 * @return None.
1: 	 */
0: 	public void setLeftOperand(ValueNode newLeftOperand)
1: 	{
1: 		leftOperand = newLeftOperand;
1: 	}
1: 
1: 	/**
1: 	 * Get the leftOperand
1: 	 *
1: 	 * @return The current leftOperand.
1: 	 */
0: 	public ValueNode getLeftOperand()
1: 	{
1: 		return leftOperand;
1: 	}
1: 
1: 	/**
1: 	 * Set the rightOperand to the specified ValueNode
1: 	 *
1: 	 * @param newRightOperand	The new rightOperand
1: 	 *
0: 	 * @return None.
1: 	 */
0: 	public void setRightOperand(ValueNode newRightOperand)
1: 	{
1: 		rightOperand = newRightOperand;
1: 	}
1: 
1: 	/**
1: 	 * Get the rightOperand
1: 	 *
1: 	 * @return The current rightOperand.
1: 	 */
0: 	public ValueNode getRightOperand()
1: 	{
1: 		return rightOperand;
1: 	}
1: 
1: 	/**
1: 	 * Categorize this predicate.  Initially, this means
1: 	 * building a bit map of the referenced tables for each predicate.
1: 	 * If the source of this ColumnReference (at the next underlying level) 
1: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1: 	 * will not be pushed down.
1: 	 *
1: 	 * For example, in:
1: 	 *		select * from (select 1 from s) a (x) where x = 1
1: 	 * we will not push down x = 1.
1: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1: 	 * that tree into the pushed predicate, and that tree could contain
1: 	 * subqueries and method calls.
1: 	 * RESOLVE - revisit this issue once we have views.
1: 	 *
1: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1: 	 * @param simplePredsOnly	Whether or not to consider method
1: 	 *							calls, field references and conditional nodes
1: 	 *							when building bit map
1: 	 *
1: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1: 	 *						or a VirtualColumnNode.
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1: 		throws StandardException
1: 	{
1: 		boolean pushable;
1: 		pushable = receiver.categorize(referencedTabs, simplePredsOnly);
1: 		pushable = (leftOperand.categorize(referencedTabs, simplePredsOnly) && pushable);
1: 		if (rightOperand != null)
1: 		{
1: 			pushable = (rightOperand.categorize(referencedTabs, simplePredsOnly) && pushable);
1: 		}
1: 		return pushable;
1: 	}
1: 
1: 	/**
1: 	 * Remap all ColumnReferences in this tree to be clones of the
1: 	 * underlying expression.
1: 	 *
1: 	 * @return ValueNode			The remapped expression tree.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public ValueNode remapColumnReferencesToExpressions()
1: 		throws StandardException
1: 	{
1: 		receiver = receiver.remapColumnReferencesToExpressions();
1: 		leftOperand = leftOperand.remapColumnReferencesToExpressions();
1: 		if (rightOperand != null)
1: 		{
1: 			rightOperand = rightOperand.remapColumnReferencesToExpressions();
1: 		}
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this expression tree represents a constant expression.
1: 	 *
1: 	 * @return	Whether or not this expression tree represents a constant expression.
1: 	 */
0: 	public boolean isConstantExpression()
1: 	{
1: 		return (receiver.isConstantExpression() &&
1: 				leftOperand.isConstantExpression() &&
1: 				(rightOperand == null || rightOperand.isConstantExpression()));
1: 	}
1: 
1: 	/** @see ValueNode#constantExpression */
0: 	public boolean constantExpression(PredicateList whereClause)
1: 	{
1: 		return (receiver.constantExpression(whereClause) &&
1: 				leftOperand.constantExpression(whereClause) &&
1: 				(rightOperand == null ||
1: 					rightOperand.constantExpression(whereClause)));
1: 	}
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		Visitable returnNode = v.visit(this);
1: 	
0: 		if (v.skipChildren(this))
1: 		{
0: 			return returnNode;
1: 		}
1: 
0: 		if (receiver != null && !v.stopTraversal())
1: 		{
1: 			receiver = (ValueNode)receiver.accept(v);
1: 		}
1: 
0: 		if (leftOperand != null && !v.stopTraversal())
1: 		{
1: 			leftOperand = (ValueNode)leftOperand.accept(v);
1: 		}
1: 
0: 		if (rightOperand != null && !v.stopTraversal())
1: 		{
1: 			rightOperand = (ValueNode)rightOperand.accept(v);
1: 		}
1: 		
0: 		return returnNode;
1: 	}
1: 	/**
1: 	 * Bind trim expression. 
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	private ValueNode trimBind() 
1: 			throws StandardException
1: 	{
1: 		TypeId	receiverType;
1: 		TypeId	resultType = TypeId.getBuiltInTypeId(Types.VARCHAR);
1: 
1: 		// handle parameters here
1: 
1: 		/* Is there a ? parameter for the receiver? */
0: 		if (receiver.isParameterNode())
1: 		{
1: 			/*
1: 			** According to the SQL standard, if trim has a ? receiver,
1: 			** its type is varchar with the implementation-defined maximum length
1: 			** for a varchar.
1: 			*/
1: 	
0: 			((ParameterNode) receiver).setDescriptor(getVarcharDescriptor());
1: 		}
1: 
1: 		/* Is there a ? parameter on the left? */
0: 		if (leftOperand.isParameterNode())
1: 		{
1: 			/* Set the left operand type to varchar. */
0: 			((ParameterNode) leftOperand).setDescriptor(getVarcharDescriptor());
1: 		}
1: 
1: 		bindToBuiltIn();
1: 
1: 		/*
1: 		** Check the type of the receiver - this function is allowed only on
1: 		** string value types.  
1: 		*/
1: 		receiverType = receiver.getTypeId();
1: 		if (receiverType.userType())
1: 			throwBadType("trim", receiverType.getSQLTypeName());
1: 
1: 		receiver = castArgToString(receiver);
1: 
0: 		if ((receiverType.getTypeFormatId() == StoredFormatIds.CLOB_TYPE_ID) ||
0: 		   (receiverType.getTypeFormatId() == StoredFormatIds.NCLOB_TYPE_ID)) {
1: 		// special case for CLOBs: if we start with a CLOB, we have to get
1: 		// a CLOB as a result (as opposed to a VARCHAR), because we can have a 
1: 		// CLOB that is beyond the max length of VARCHAR (ex. "clob(100k)").
1: 		// This is okay because CLOBs, like VARCHARs, allow variable-length
1: 		// values (which is a must for the trim to actually work).
1: 			resultType = receiverType;
1: 		}
1: 
1: 		/*
1: 		** Check the type of the leftOperand (trimSet).
1: 		** The leftOperand should be a string value type.  
1: 		*/
1: 		TypeId	leftCTI;
1: 		leftCTI = leftOperand.getTypeId();
1: 		if (leftCTI.userType())
1: 			throwBadType("trim", leftCTI.getSQLTypeName());
1: 
1: 		leftOperand = castArgToString(leftOperand);
1: 
1: 		/*
1: 		** The result type of trim is varchar.
1: 		*/
1: 		setResultType(resultType);
1: 
1: 		return this;
1: 	}
1: 	/*
1: 	** set result type for operator
1: 	*/
1: 	private void setResultType(TypeId resultType) throws StandardException
1: 	{
1: 		setType(new DataTypeDescriptor(
1: 						resultType,
1: 						true,
1: 						receiver.getTypeServices().getMaximumWidth()
1: 					)
1: 				);
1: 	}
1: 	/**
1: 	 * Bind locate operator
1: 	 *
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ValueNode locateBind() throws StandardException
1: 	{
1: 		TypeId	firstOperandType, secondOperandType, offsetType;
1: 
1: 		/*
1: 		 * Is there a ? parameter for the first arg.  Copy the 
1: 		 * left/firstOperand's.  If the left/firstOperand are both parameters,
1: 		 * both will be max length.
1: 		 */
0: 		if( receiver.isParameterNode())
1: 		{
0: 			if( leftOperand.isParameterNode())
1: 			{
0: 				((ParameterNode) receiver).setDescriptor(getVarcharDescriptor());
1: 			}
1: 			else
1: 			{
1: 				if( leftOperand.getTypeId().isStringTypeId() )
1: 				{
0: 					((ParameterNode) receiver).setDescriptor(
1: 							         leftOperand.getTypeServices());
1: 				}
1: 			}
1: 		}
1: 							                            
1: 		/*
1: 		 * Is there a ? parameter for the second arg.  Copy the receiver's.
1: 		 * If the receiver are both parameters, both will be max length.
1: 		 */
0: 		if(leftOperand.isParameterNode())
1: 		{
0: 			if(receiver.isParameterNode())
1: 			{
0: 				((ParameterNode) leftOperand).setDescriptor(getVarcharDescriptor());
1: 			}
1: 			else
1: 			{
1: 				if( receiver.getTypeId().isStringTypeId() )
1: 				{
0: 					((ParameterNode) leftOperand).setDescriptor(
1: 							         receiver.getTypeServices());
1: 				}
1: 			}
1: 		}
1: 
1: 		/*
0: 		 * Is there a ? paramter for the third arg.  It will be an int.
1: 		 */
0: 		if( rightOperand.isParameterNode())
1: 		{
0: 			((ParameterNode) rightOperand).setDescriptor(
1: 				new DataTypeDescriptor(TypeId.INTEGER_ID, true)); 
1: 		}
1: 
1: 		bindToBuiltIn();
1: 
1: 		/*
1: 		** Check the type of the operand - this function is allowed only
1: 		** for: receiver = CHAR
1: 		**      firstOperand = CHAR
1: 		**      secondOperand = INT
1: 		*/
1: 		secondOperandType = leftOperand.getTypeId();
1: 		offsetType = rightOperand.getTypeId();
1: 		firstOperandType = receiver.getTypeId();
1: 
1: 		if (!firstOperandType.isStringTypeId() ||
1: 			!secondOperandType.isStringTypeId() || 
1: 			offsetType.getJDBCTypeId() != Types.INTEGER)
1: 			throw StandardException.newException(SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE,
1: 					"LOCATE", "FUNCTION");
1: 
1: 		/*
1: 		** The result type of a LocateFunctionNode is an integer.
1: 		*/
1: 		setType(new DataTypeDescriptor(TypeId.INTEGER_ID, 
1: 				receiver.getTypeServices().isNullable())); 
1: 
1: 		return this;
1: 	}
1: 
1: 	/* cast arg to a varchar */
1: 	protected ValueNode castArgToString(ValueNode vn) throws StandardException
1: 	{
1: 		TypeCompiler vnTC = vn.getTypeCompiler();
1: 		if (! vn.getTypeId().isStringTypeId())
1: 		{
0: 			ValueNode newNode = (ValueNode)
0: 						getNodeFactory().getNode(
0: 							C_NodeTypes.CAST_NODE,
0: 							vn,
0: 							DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true,
1: 							                vnTC.getCastToCharWidth(
0: 							                    vn.getTypeServices())),
0: 							getContextManager());
1: 			((CastNode) newNode).bindCastNodeOnly();
1: 			return newNode;
1: 		}
1: 		return vn;
1: 	}
1: 
1: 	/**
1: 	 * Bind substr expression.  
1: 	 *
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0:  	public ValueNode substrBind() 
1: 			throws StandardException
1: 	{
1: 		TypeId	receiverType;
0: 		TypeId	resultType;
1: 
1: 		// handle parameters here
1: 
1: 		/* Is there a ? parameter for the receiver? */
0: 		if (receiver.isParameterNode())
1: 		{
1: 			/*
1: 			** According to the SQL standard, if substr has a ? receiver,
1: 			** its type is varchar with the implementation-defined maximum length
1: 			** for a varchar.
1: 			*/
1: 	
0: 			((ParameterNode) receiver).setDescriptor(getVarcharDescriptor());
1: 		}
1: 
1: 		/* Is there a ? parameter on the left? */
0: 		if (leftOperand.isParameterNode())
1: 		{
1: 			/* Set the left operand type to int. */
0: 			((ParameterNode) leftOperand).setDescriptor(							
1: 				new DataTypeDescriptor(TypeId.INTEGER_ID, true)); 
1: 		}
1: 
1: 		/* Is there a ? parameter on the right? */
0: 		if ((rightOperand != null) && rightOperand.isParameterNode())
1: 		{
1: 			/* Set the right operand type to int. */
0: 			((ParameterNode) rightOperand).setDescriptor(							
1: 				new DataTypeDescriptor(TypeId.INTEGER_ID, true)); 
1: 		}
1: 
1: 		bindToBuiltIn();
1: 
1: 		if (!leftOperand.getTypeId().isNumericTypeId() ||
1: 			(rightOperand != null && !rightOperand.getTypeId().isNumericTypeId()))
1: 			throw StandardException.newException(SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, "SUBSTR", "FUNCTION");
1: 
1: 		/*
1: 		** Check the type of the receiver - this function is allowed only on
1: 		** string value types.  
1: 		*/
0: 		resultType = receiverType = receiver.getTypeId();
1: 		switch (receiverType.getJDBCTypeId())
1: 		{
1: 			case Types.CHAR:
1: 			case Types.VARCHAR:
1: 			case Types.LONGVARCHAR:
1: 			case Types.CLOB:
1: 				break;
1: 			default:
1: 			{
1: 				throwBadType("SUBSTR", receiverType.getSQLTypeName());
1: 			}
1: 		}
1: 
1: 		// Determine the maximum length of the result
1: 		int resultLen = receiver.getTypeServices().getMaximumWidth();
1: 
1: 		if (rightOperand != null && rightOperand instanceof ConstantNode)
1: 		{
1: 			if (((ConstantNode)rightOperand).getValue().getInt() < resultLen)
1: 				resultLen = ((ConstantNode)rightOperand).getValue().getInt();
1: 		}
1: 
1: 		/*
1: 		** The result type of substr is a string type
1: 		*/
1: 		setType(new DataTypeDescriptor(
1: 						resultType,
1: 						true,
1: 						resultLen
1: 					));
1: 
1: 		return this;
1: 	}
1: 
0: 	public ValueNode getReceiver()
1: 	{
1: 		return receiver;
1: 	}
1: 
1: 	/* throw bad type message */
1: 	private void throwBadType(String funcName, String type) 
1: 		throws StandardException
1: 	{
1: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1: 										funcName,
1: 										type);
1: 	}
1: 
1: 	/* bind arguments to built in types */
1: 	protected void bindToBuiltIn() 
1: 		throws StandardException
1: 	{
1: 		/* If the receiver is not a built-in type, then generate a bound conversion
1: 		 * tree to a built-in type.
1: 		 */
0: 		if (! receiver.getTypeId().systemBuiltIn())
1: 		{
1: 			receiver = receiver.genSQLJavaSQLTree();
1: 		}
1: 
1: 		/* If the left operand is not a built-in type, then generate a bound conversion
1: 		 * tree to a built-in type.
1: 		 */
0: 		if (! leftOperand.getTypeId().systemBuiltIn())
1: 		{
1: 			leftOperand = leftOperand.genSQLJavaSQLTree();
1: 		}
1: 
1: 		/* If the right operand is not a built-in type, then generate a bound conversion
1: 		 * tree to a built-in type.
1: 		 */
1: 		if (rightOperand != null)
1: 		{
0: 			if (! rightOperand.getTypeId().systemBuiltIn())
1: 			{
1: 				rightOperand = rightOperand.genSQLJavaSQLTree();
1: 			}
1: 		}
1: 	}
1: 
1: 	private DataTypeDescriptor getVarcharDescriptor() {
1: 		return new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), true);
1: 	}
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:111785f
/////////////////////////////////////////////////////////////////////////
1: 		if (receiverType.getTypeFormatId() == StoredFormatIds.CLOB_TYPE_ID) {
/////////////////////////////////////////////////////////////////////////
1: 		if (receiverType.getTypeFormatId() == StoredFormatIds.CLOB_TYPE_ID) {
commit:9841c0d
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * This method gets called for non-character string types and hence no need 
1:      * to set any collation info. Collation applies only to character string
1:      * types.
1:      *  
1:      * @param arg Check if arg is a ? param and if yes, then set it's type to
1:      *    jdbcType if arg doesn't have a type associated with it.
1:      *    
1:      * @param jdbcType Associate this type with arg if arg is a ? param with no
1:      *    type associated with it
1:      *    
1:      * @return true if arg is a ? param with no type associated with it
1:      * @throws StandardException
0:      */
commit:dcca4df
/////////////////////////////////////////////////////////////////////////
1: 			//collation of ? operand should be same as the compilation schema 
1: 			//because that is the only context available for us to pick up the
1: 			//collation. There are no other character operands to SUBSTR method
1: 			//to pick up the collation from.
commit:de4d4c5
/////////////////////////////////////////////////////////////////////////
1: 	 * The variable receiver is the string which will searched
1: 	 * The variable leftOperand is the search character that will looked in the
1: 	 *     receiver variable.
/////////////////////////////////////////////////////////////////////////
1: 	            //Since both receiver and leftOperands are parameters, use the
1: 				//collation of compilation schema for receiver.
0: 				receiver.setCollationUsingCompilationSchema(
0: 						StringDataValue.COLLATION_DERIVATION_IMPLICIT);            	
1: 					//Since the leftOperand is not a parameter, receiver will
1: 					//get it's collation from leftOperand through following
1: 					//setType method
/////////////////////////////////////////////////////////////////////////
1: 			//collation of ? operand should be picked up from the context.
1:             //By the time we come here, receiver will have correct collation
1:             //set on it and hence we can rely on it to get correct collation
1:             //for this ? 
0: 			leftOperand.getTypeServices().setCollationDerivation(
0: 					receiver.getTypeServices().getCollationDerivation());
0: 			leftOperand.getTypeServices().setCollationType(
0:         			receiver.getTypeServices().getCollationType());            	
commit:133d0fb
/////////////////////////////////////////////////////////////////////////
1: 		//Result of TRIM should pick up the collation of the character string
1: 		//that is getting trimmed (which is variable receiver) because it has
1: 		//correct collation set on it.
/////////////////////////////////////////////////////////////////////////
commit:db9ad01
/////////////////////////////////////////////////////////////////////////
1: 	 * The variable receiver is the string that needs to be trimmed.
1: 	 * The variable leftOperand is the character that needs to be trimmed from
1: 	 *     receiver.
0: 	 *     
/////////////////////////////////////////////////////////////////////////
1:             //check if this parameter can pick up it's collation from the 
1: 			//character that will be used for trimming. If not(meaning the
1: 			//character to be trimmed is also a parameter), then it will take 
1: 			//it's collation from the compilation schema.
1:             if (!leftOperand.requiresTypeFromContext()) {
0:             	receiver.getTypeServices().setCollationDerivation(
0:             			leftOperand.getTypeServices().getCollationDerivation());
0:             	receiver.getTypeServices().setCollationType(
0:             			leftOperand.getTypeServices().getCollationType());
1:             } else {
0:     			receiver.setCollationUsingCompilationSchema(
0:     					StringDataValue.COLLATION_DERIVATION_IMPLICIT);            	
1:             }
/////////////////////////////////////////////////////////////////////////
1: 			//collation of ? operand should be picked up from the context.
1:             //By the time we come here, receiver will have correct collation
1:             //set on it and hence we can rely on it to get correct collation
1:             //for the ? for the character that needs to be used for trimming.
0: 			leftOperand.getTypeServices().setCollationDerivation(
0: 					receiver.getTypeServices().getCollationDerivation());
0: 			leftOperand.getTypeServices().setCollationType(
0:         			receiver.getTypeServices().getCollationType());            	
commit:f63b7da
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the compilation schema
0: 			receiver.setCollationUsingCompilationSchema(
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the compilation schema
0: 			leftOperand.setCollationUsingCompilationSchema(
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the compilation schema
0: 			receiver.setCollationUsingCompilationSchema(
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the compilation schema
0: 			leftOperand.setCollationUsingCompilationSchema(
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the compilation schema
0: 			rightOperand.setCollationUsingCompilationSchema(
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the compilation schema
0: 			receiver.setCollationUsingCompilationSchema(
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the compilation schema
0: 			arg.setCollationUsingCompilationSchema(
commit:7c5fbc4
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the current schema
0: 			receiver.getTypeServices().setCollationDerivation(
0: 					StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			receiver.getTypeServices().setCollationType(
0: 					getLanguageConnectionContext().getDefaultSchema()
0: 							.getCollationType());
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the current schema
0: 			leftOperand.getTypeServices().setCollationDerivation(
0: 					StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			leftOperand.getTypeServices().setCollationType(
0: 					getLanguageConnectionContext().getDefaultSchema()
0: 							.getCollationType());
/////////////////////////////////////////////////////////////////////////
0: 		//Result of TRIM should pick up the collation of the 1st argument
0: 		//to TRIM. The 1st argument to TRIM is represented by the variable
1: 		//receiver in this class.
0: 		getTypeServices().setCollationDerivation(
0: 				receiver.getTypeServices().getCollationDerivation());
0: 		getTypeServices().setCollationType(
0: 				receiver.getTypeServices().getCollationType());
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the current schema
0: 			receiver.getTypeServices().setCollationDerivation(
0: 					StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			receiver.getTypeServices().setCollationType(
0: 					getLanguageConnectionContext().getDefaultSchema()
0: 							.getCollationType());
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the current schema
0: 			leftOperand.getTypeServices().setCollationDerivation(
0: 					StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			leftOperand.getTypeServices().setCollationType(
0: 					getLanguageConnectionContext().getDefaultSchema()
0: 							.getCollationType());
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the current schema
0: 			rightOperand.getTypeServices().setCollationDerivation(
0: 					StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			rightOperand.getTypeServices().setCollationType(
0: 					getLanguageConnectionContext().getDefaultSchema()
0: 							.getCollationType());
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the current schema
0: 			receiver.getTypeServices().setCollationDerivation(
0: 					StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			receiver.getTypeServices().setCollationType(
0: 					getLanguageConnectionContext().getDefaultSchema()
0: 							.getCollationType());
/////////////////////////////////////////////////////////////////////////
1: 		//Result of SUSBSTR should pick up the collation of the 1st argument
1: 		//to SUBSTR. The 1st argument to SUBSTR is represented by the variable
0: 		//receiver in this class.
0: 		getTypeServices().setCollationDerivation(
0: 				receiver.getTypeServices().getCollationDerivation());
0: 		getTypeServices().setCollationType(
0: 				receiver.getTypeServices().getCollationType());
/////////////////////////////////////////////////////////////////////////
0: 			//collation of ? operand should be same as the current schema
0: 			arg.getTypeServices().setCollationDerivation(
0: 					StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			arg.getTypeServices().setCollationType(
0: 					getLanguageConnectionContext().getDefaultSchema()
0: 							.getCollationType());
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:2278311
/////////////////////////////////////////////////////////////////////////
1: 			mb.cast(leftInterfaceType);
commit:d9b6192
/////////////////////////////////////////////////////////////////////////
1: 			DataTypeDescriptor dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true,
0: 	                vnTC.getCastToCharWidth(
1: 		                    vn.getTypeServices()));
0: 			// DERBY-2910 - Match current schema collation for implicit cast as we do for
0: 			// explicit casts per SQL Spec 6.12 (10)							                    
0: 			dtd.setCollationType(getSchemaDescriptor(null).getCollationType());
0: 			dtd.setCollationDerivation(StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 							dtd,
author:Army
-------------------------------------------------------------------------------
commit:fb3b060
/////////////////////////////////////////////////////////////////////////
1: 	static final String[] TernaryMethodNames = {"ansiTrim", "locate", "substring", "like", "timestampAdd", "timestampDiff"};
/////////////////////////////////////////////////////////////////////////
0: 
0: 		leftOperand = leftOperand.bindExpression(fromList, subqueryList,
0: 			    aggregateVector);
/////////////////////////////////////////////////////////////////////////
1: 			leftOperand.generateExpression(acb, mb);
0: 			mb.upCast(leftInterfaceType);
0: 
1: 			nargs = 3;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b3bf9ca
/////////////////////////////////////////////////////////////////////////
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
1: 		if (receiver.requiresTypeFromContext())
/////////////////////////////////////////////////////////////////////////
1: 			receiver.setType(getVarcharDescriptor());
1: 		if (leftOperand.requiresTypeFromContext())
1: 			leftOperand.setType(getVarcharDescriptor());
/////////////////////////////////////////////////////////////////////////
1: 		if( receiver.requiresTypeFromContext())
1: 			if( leftOperand.requiresTypeFromContext())
1: 				receiver.setType(getVarcharDescriptor());
1: 					receiver.setType(
/////////////////////////////////////////////////////////////////////////
1: 		if(leftOperand.requiresTypeFromContext())
1: 			if(receiver.requiresTypeFromContext())
1: 				leftOperand.setType(getVarcharDescriptor());
1: 					leftOperand.setType(
/////////////////////////////////////////////////////////////////////////
1: 		if( rightOperand.requiresTypeFromContext())
1: 			rightOperand.setType(
/////////////////////////////////////////////////////////////////////////
1: 		if (receiver.requiresTypeFromContext())
/////////////////////////////////////////////////////////////////////////
1: 			receiver.setType(getVarcharDescriptor());
1: 		if (leftOperand.requiresTypeFromContext())
1: 			leftOperand.setType(							
1: 		if ((rightOperand != null) && rightOperand.requiresTypeFromContext())
1: 			rightOperand.setType(							
/////////////////////////////////////////////////////////////////////////
1:         if( arg.requiresTypeFromContext() && arg.getTypeId() == null)
1:             arg.setType( new DataTypeDescriptor(TypeId.getBuiltInTypeId( jdbcType), true));
commit:d365a22
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.util.ReuseFactory;
/////////////////////////////////////////////////////////////////////////
0: 	public static final int TIMESTAMPADD = 4;
0: 	public static final int TIMESTAMPDIFF = 5;
1: 	static final String[] TernaryOperators = {"trim", "LOCATE", "substring", "like", "TIMESTAMPADD", "TIMESTAMPDIFF"};
0: 	static final String[] TernaryMethodNames = {"trim", "locate", "substring", "like", "timestampAdd", "timestampDiff"};
1: 			ClassName.BooleanDataValue,
1:             ClassName.DateTimeDataValue, 
1: 			ClassName.NumberDataValue};
1: 	{ClassName.DataValueDescriptor, ClassName.DataValueDescriptor, ClassName.DataValueDescriptor},
1:     {ClassName.DateTimeDataValue, "java.lang.Integer", ClassName.NumberDataValue}, // time.timestampadd( interval, count)
1:     {ClassName.DateTimeDataValue, "java.lang.Integer", ClassName.DateTimeDataValue}// time2.timestampDiff( interval, time1)
/////////////////////////////////////////////////////////////////////////
0: 		else if (operatorType == TIMESTAMPADD)
1:             timestampAddBind();
0: 		else if (operatorType == TIMESTAMPDIFF)
1:             timestampDiffBind();
/////////////////////////////////////////////////////////////////////////
0: 		else if (operatorType == TIMESTAMPADD || operatorType == TIMESTAMPDIFF)
1:         {
1:             Object intervalType = leftOperand.getConstantValueAsObject();
1:             if( SanityManager.DEBUG)
1:                 SanityManager.ASSERT( intervalType != null && intervalType instanceof Integer,
1:                                       "Invalid interval type used for " + operator);
1:             mb.push( ((Integer) intervalType).intValue());
1:             rightOperand.generateExpression( acb, mb);
0:             mb.upCast( TernaryArgType[ operatorType][2]);
1:             acb.getCurrentDateExpression( mb);
1: 			mb.getField(field);
1: 			nargs = 4;
1: 			receiverType = receiverInterfaceType;
0:         }
0:             
/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
1: 	 * Bind TIMESTAMPADD expression.  
0: 	 *
1: 	 * @return	The new top of the expression tree.
0: 	 *
1: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
1:  	private ValueNode timestampAddBind() 
1: 			throws StandardException
1: 	{
1:         if( ! bindParameter( rightOperand, Types.INTEGER))
1:         {
1:             int jdbcType = rightOperand.getTypeId().getJDBCTypeId();
1:             if( jdbcType != Types.TINYINT && jdbcType != Types.SMALLINT &&
1:                 jdbcType != Types.INTEGER && jdbcType != Types.BIGINT)
1:                 throw StandardException.newException(SQLState.LANG_INVALID_FUNCTION_ARG_TYPE,
0:                                                      rightOperand.getTypeId().getSQLTypeName(),
0:                                                      ReuseFactory.getInteger( 2),
1:                                                      operator);
0:         }
1:         bindDateTimeArg( receiver, 3);
1:         setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.TIMESTAMP));
1:         return this;
1:     } // end of timestampAddBind
0: 
0: 	/**
1: 	 * Bind TIMESTAMPDIFF expression.  
0: 	 *
1: 	 * @return	The new top of the expression tree.
0: 	 *
1: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
1:  	private ValueNode timestampDiffBind() 
1: 			throws StandardException
1: 	{
1:         bindDateTimeArg( rightOperand, 2);
1:         bindDateTimeArg( receiver, 3);
0:         setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.INTEGER));
1:         return this;
1:     } // End of timestampDiffBind
0: 
1:     private void bindDateTimeArg( ValueNode arg, int argNumber) throws StandardException
1:     {
1:         if( ! bindParameter( arg, Types.TIMESTAMP))
1:         {
1:             if( ! arg.getTypeId().isDateTimeTimeStampTypeId())
1:                 throw StandardException.newException(SQLState.LANG_INVALID_FUNCTION_ARG_TYPE,
0:                                                      arg.getTypeId().getSQLTypeName(),
0:                                                      ReuseFactory.getInteger( argNumber),
1:                                                      operator);
0:         }
1:     } // end of bindDateTimeArg
0: 
1:     private boolean bindParameter( ValueNode arg, int jdbcType) throws StandardException
1:     {
0:         if( arg.isParameterNode() && arg.getTypeId() == null)
1:         {
0:             ((ParameterNode) arg).setDescriptor( new DataTypeDescriptor(TypeId.getBuiltInTypeId( jdbcType), true));
1:             return true;
0:         }
1:         return false;
1:     } // end of bindParameter
0: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.iapi.util.JBitSet;
0: 
0: import java.lang.reflect.Modifier;
0: 
0: import java.sql.Types;
0: import java.util.Vector;
0: /**
0:  * A TernaryOperatorNode represents a built-in ternary operators.
0:  * This covers  built-in functions like substr().
0:  * Java operators are not represented here: the JSQL language allows Java
0:  * methods to be called from expressions, but not Java operators.
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public class TernaryOperatorNode extends ValueNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	String		operator;
0: 	String		methodName;
0: 	int			operatorType;
0: 	ValueNode	receiver; 
0: 
0: 	ValueNode	leftOperand;
0: 	ValueNode	rightOperand;
0: 
0: 	String		resultInterfaceType;
0: 	String		receiverInterfaceType;
0: 	String		leftInterfaceType;
0: 	String		rightInterfaceType;
0: 	int			trimType;
0: 
0: 	public static final int TRIM = 0;
0: 	public static final int LOCATE = 1;
0: 	public static final int SUBSTRING = 2;
0: 	public static final int LIKE = 3;
0: 	static final String[] TernaryOperators = {"trim", "LOCATE", "substring", "like"};
0: 	static final String[] TernaryMethodNames = {"trim", "locate", "substring", "like"};
0: 	static final String[] TernaryResultType = {ClassName.StringDataValue, 
0: 			ClassName.NumberDataValue,
0: 			ClassName.ConcatableDataValue,
0: 			ClassName.BooleanDataValue};
0: 	static final String[][] TernaryArgType = {
0: 	{ClassName.StringDataValue, ClassName.StringDataValue, "java.lang.Integer"},
0: 	{ClassName.StringDataValue, ClassName.StringDataValue, ClassName.NumberDataValue},
0: 	{ClassName.ConcatableDataValue, ClassName.NumberDataValue, ClassName.NumberDataValue},
0: 	{ClassName.DataValueDescriptor, ClassName.DataValueDescriptor, ClassName.DataValueDescriptor}
0: 	};
0: 
0: 	/**
0: 	 * Initializer for a TernaryOperatorNode
0: 	 *
0: 	 * @param receiver		The receiver (eg, string being operated on in substr())
0: 	 * @param leftOperand	The left operand of the node
0: 	 * @param rightOperand	The right operand of the node
0: 	 * @param operatorType	The type of the operand
0: 	 */
0: 
0: 	public void init(
0: 					Object receiver,
0: 					Object leftOperand,
0: 					Object rightOperand,
0: 					Object operatorType,
0: 					Object trimType)
0: 	{
0: 		this.receiver = (ValueNode) receiver;
0: 		this.leftOperand = (ValueNode) leftOperand;
0: 		this.rightOperand = (ValueNode) rightOperand;
0: 		this.operatorType = ((Integer) operatorType).intValue();
0: 		this.operator = (String) TernaryOperators[this.operatorType];
0: 		this.methodName = (String) TernaryMethodNames[this.operatorType];
0: 		this.resultInterfaceType = (String) TernaryResultType[this.operatorType];
0: 		this.receiverInterfaceType = (String) TernaryArgType[this.operatorType][0];
0: 		this.leftInterfaceType = (String) TernaryArgType[this.operatorType][1];
0: 		this.rightInterfaceType = (String) TernaryArgType[this.operatorType][2];
0: 		if (trimType != null)
0: 				this.trimType = ((Integer) trimType).intValue();
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "operator: " + operator + "\n" +
0: 				"methodName: " + methodName + "\n" + 
0: 				"resultInterfaceType: " + resultInterfaceType + "\n" + 
0: 				"receiverInterfaceType: " + receiverInterfaceType + "\n" + 
0: 				"leftInterfaceType: " + leftInterfaceType + "\n" + 
0: 				"rightInterfaceType: " + rightInterfaceType + "\n" + 
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Set the clause that this node appears in.
0: 	 *
0: 	 * @param clause	The clause that this node appears in.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setClause(int clause)
0: 	{
0: 		super.setClause(clause);
0: 		receiver.setClause(clause);
0: 		leftOperand.setClause(clause);
0: 		if (rightOperand != null)
0: 		{
0: 			rightOperand.setClause(clause);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			if (receiver != null)
0: 			{
0: 				printLabel(depth, "receiver: ");
0: 				receiver.treePrint(depth + 1);
0: 			}
0: 
0: 			if (leftOperand != null)
0: 			{
0: 				printLabel(depth, "leftOperand: ");
0: 				leftOperand.treePrint(depth + 1);
0: 			}
0: 
0: 			if (rightOperand != null)
0: 			{
0: 				printLabel(depth, "rightOperand: ");
0: 				rightOperand.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind this expression.  This means binding the sub-expressions,
0: 	 * as well as figuring out what the return type is for this expression.
0: 	 *
0: 	 * @param fromList		The FROM list for the query this
0: 	 *				expression is in, for binding columns.
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector) 
0: 			throws StandardException
0: 	{
0: 		receiver = receiver.bindExpression(fromList, subqueryList, 
0: 			aggregateVector);
0: 		leftOperand = leftOperand.bindExpression(fromList, subqueryList, 
0: 			aggregateVector);
0: 
0: 		if (rightOperand != null)
0: 		{
0: 			rightOperand = rightOperand.bindExpression(fromList, subqueryList, 
0: 				aggregateVector);
0: 		}
0: 		if (operatorType == TRIM)
0: 			trimBind();
0: 		else if (operatorType == LOCATE)
0: 			locateBind();
0: 		else if (operatorType == SUBSTRING)
0: 			substrBind();
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Preprocess an expression tree.  We do a number of transformations
0: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
0: 	 * subquery flattening.
0: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
0: 	 *
0: 	 * @param	numTables			Number of tables in the DML Statement
0: 	 * @param	outerFromList		FromList from outer query block
0: 	 * @param	outerSubqueryList	SubqueryList from outer query block
0: 	 * @param	outerPredicateList	PredicateList from outer query block
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode preprocess(int numTables,
0: 								FromList outerFromList,
0: 								SubqueryList outerSubqueryList,
0: 								PredicateList outerPredicateList) 
0: 					throws StandardException
0: 	{
0: 		receiver = receiver.preprocess(numTables,
0: 											 outerFromList, outerSubqueryList,
0: 											 outerPredicateList);
0: 
0: 		leftOperand = leftOperand.preprocess(numTables,
0: 											 outerFromList, outerSubqueryList,
0: 											 outerPredicateList);
0: 		if (rightOperand != null)
0: 		{
0: 			rightOperand = rightOperand.preprocess(numTables,
0: 												   outerFromList, outerSubqueryList,
0: 												   outerPredicateList);
0: 		}
0: 		return this;
0: 	}
0: 	/**
0: 	 * Do code generation for this ternary operator.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 		throws StandardException
0: 	{
0: 		int nargs = 0;
0: 		String receiverType = null;
0: 
0: 		/* Allocate an object for re-use to hold the result of the operator */
0: 		LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, resultInterfaceType);
0: 
0: 		receiver.generateExpression(acb, mb);
0: 		if (operatorType == TRIM)
0: 		{
0: 			mb.push(trimType);
0: 			mb.getField(field);
0: 			nargs = 2;
0: 			receiverType = receiverInterfaceType;
0: 		}
0: 		else if (operatorType == LOCATE)
0: 		{
0: 			leftOperand.generateExpression(acb, mb); 
0: 			mb.upCast(leftInterfaceType);
0: 			rightOperand.generateExpression(acb, mb);
0: 			mb.upCast(rightInterfaceType);
0: 			mb.getField(field);
0: 			nargs = 3;
0: 		
0: 		}
0: 		else if (operatorType == SUBSTRING)
0: 		{
0: 			leftOperand.generateExpression(acb, mb); 
0: 			mb.upCast(leftInterfaceType);
0: 			if (rightOperand != null)
0: 			{
0: 				rightOperand.generateExpression(acb, mb);
0: 				mb.upCast(rightInterfaceType);
0: 			}
0: 			else
0: 			{
0: 				mb.pushNull(rightInterfaceType);
0: 			}
0: 
0: 			mb.getField(field); // third arg
0: 			mb.push(receiver.getTypeServices().getMaximumWidth());
0: 			nargs = 4;
0: 			receiverType = receiverInterfaceType;
0: 		}
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultInterfaceType, nargs);
0: 
0: 		/*
0: 		** Store the result of the method call in the field, so we can re-use
0: 		** the object.
0: 		*/
0: 		mb.putField(field);
0: 	}
0: 
0: 	/**
0: 	 * Set the leftOperand to the specified ValueNode
0: 	 *
0: 	 * @param newLeftOperand	The new leftOperand
0: 	 *
0: 	 * @return None.
0: 	 */
0: 	public void setLeftOperand(ValueNode newLeftOperand)
0: 	{
0: 		leftOperand = newLeftOperand;
0: 	}
0: 
0: 	/**
0: 	 * Get the leftOperand
0: 	 *
0: 	 * @return The current leftOperand.
0: 	 */
0: 	public ValueNode getLeftOperand()
0: 	{
0: 		return leftOperand;
0: 	}
0: 
0: 	/**
0: 	 * Set the rightOperand to the specified ValueNode
0: 	 *
0: 	 * @param newRightOperand	The new rightOperand
0: 	 *
0: 	 * @return None.
0: 	 */
0: 	public void setRightOperand(ValueNode newRightOperand)
0: 	{
0: 		rightOperand = newRightOperand;
0: 	}
0: 
0: 	/**
0: 	 * Get the rightOperand
0: 	 *
0: 	 * @return The current rightOperand.
0: 	 */
0: 	public ValueNode getRightOperand()
0: 	{
0: 		return rightOperand;
0: 	}
0: 
0: 	/**
0: 	 * Categorize this predicate.  Initially, this means
0: 	 * building a bit map of the referenced tables for each predicate.
0: 	 * If the source of this ColumnReference (at the next underlying level) 
0: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
0: 	 * will not be pushed down.
0: 	 *
0: 	 * For example, in:
0: 	 *		select * from (select 1 from s) a (x) where x = 1
0: 	 * we will not push down x = 1.
0: 	 * NOTE: It would be easy to handle the case of a constant, but if the
0: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
0: 	 * that tree into the pushed predicate, and that tree could contain
0: 	 * subqueries and method calls.
0: 	 * RESOLVE - revisit this issue once we have views.
0: 	 *
0: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
0: 	 * @param simplePredsOnly	Whether or not to consider method
0: 	 *							calls, field references and conditional nodes
0: 	 *							when building bit map
0: 	 *
0: 	 * @return boolean		Whether or not source.expression is a ColumnReference
0: 	 *						or a VirtualColumnNode.
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
0: 		throws StandardException
0: 	{
0: 		boolean pushable;
0: 		pushable = receiver.categorize(referencedTabs, simplePredsOnly);
0: 		pushable = (leftOperand.categorize(referencedTabs, simplePredsOnly) && pushable);
0: 		if (rightOperand != null)
0: 		{
0: 			pushable = (rightOperand.categorize(referencedTabs, simplePredsOnly) && pushable);
0: 		}
0: 		return pushable;
0: 	}
0: 
0: 	/**
0: 	 * Remap all ColumnReferences in this tree to be clones of the
0: 	 * underlying expression.
0: 	 *
0: 	 * @return ValueNode			The remapped expression tree.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public ValueNode remapColumnReferencesToExpressions()
0: 		throws StandardException
0: 	{
0: 		receiver = receiver.remapColumnReferencesToExpressions();
0: 		leftOperand = leftOperand.remapColumnReferencesToExpressions();
0: 		if (rightOperand != null)
0: 		{
0: 			rightOperand = rightOperand.remapColumnReferencesToExpressions();
0: 		}
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not this expression tree represents a constant expression.
0: 	 *
0: 	 * @return	Whether or not this expression tree represents a constant expression.
0: 	 */
0: 	public boolean isConstantExpression()
0: 	{
0: 		return (receiver.isConstantExpression() &&
0: 				leftOperand.isConstantExpression() &&
0: 				(rightOperand == null || rightOperand.isConstantExpression()));
0: 	}
0: 
0: 	/** @see ValueNode#constantExpression */
0: 	public boolean constantExpression(PredicateList whereClause)
0: 	{
0: 		return (receiver.constantExpression(whereClause) &&
0: 				leftOperand.constantExpression(whereClause) &&
0: 				(rightOperand == null ||
0: 					rightOperand.constantExpression(whereClause)));
0: 	}
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		Visitable returnNode = v.visit(this);
0: 	
0: 		if (v.skipChildren(this))
0: 		{
0: 			return returnNode;
0: 		}
0: 
0: 		if (receiver != null && !v.stopTraversal())
0: 		{
0: 			receiver = (ValueNode)receiver.accept(v);
0: 		}
0: 
0: 		if (leftOperand != null && !v.stopTraversal())
0: 		{
0: 			leftOperand = (ValueNode)leftOperand.accept(v);
0: 		}
0: 
0: 		if (rightOperand != null && !v.stopTraversal())
0: 		{
0: 			rightOperand = (ValueNode)rightOperand.accept(v);
0: 		}
0: 		
0: 		return returnNode;
0: 	}
0: 	/**
0: 	 * Bind trim expression. 
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	private ValueNode trimBind() 
0: 			throws StandardException
0: 	{
0: 		TypeId	receiverType;
0: 		TypeId	resultType = TypeId.getBuiltInTypeId(Types.VARCHAR);
0: 
0: 		// handle parameters here
0: 
0: 		/* Is there a ? parameter for the receiver? */
0: 		if (receiver.isParameterNode())
0: 		{
0: 			/*
0: 			** According to the SQL standard, if trim has a ? receiver,
0: 			** its type is varchar with the implementation-defined maximum length
0: 			** for a varchar.
0: 			*/
0: 	
0: 			((ParameterNode) receiver).setDescriptor(getVarcharDescriptor());
0: 		}
0: 
0: 		/* Is there a ? parameter on the left? */
0: 		if (leftOperand.isParameterNode())
0: 		{
0: 			/* Set the left operand type to varchar. */
0: 			((ParameterNode) leftOperand).setDescriptor(getVarcharDescriptor());
0: 		}
0: 
0: 		bindToBuiltIn();
0: 
0: 		/*
0: 		** Check the type of the receiver - this function is allowed only on
0: 		** string value types.  
0: 		*/
0: 		receiverType = receiver.getTypeId();
0: 		if (receiverType.userType())
0: 			throwBadType("trim", receiverType.getSQLTypeName());
0: 
0: 		receiver = castArgToString(receiver);
0: 
0: 		if ((receiverType.getTypeFormatId() == StoredFormatIds.CLOB_TYPE_ID) ||
0: 		   (receiverType.getTypeFormatId() == StoredFormatIds.NCLOB_TYPE_ID)) {
0: 		// special case for CLOBs: if we start with a CLOB, we have to get
0: 		// a CLOB as a result (as opposed to a VARCHAR), because we can have a 
0: 		// CLOB that is beyond the max length of VARCHAR (ex. "clob(100k)").
0: 		// This is okay because CLOBs, like VARCHARs, allow variable-length
0: 		// values (which is a must for the trim to actually work).
0: 			resultType = receiverType;
0: 		}
0: 
0: 		/*
0: 		** Check the type of the leftOperand (trimSet).
0: 		** The leftOperand should be a string value type.  
0: 		*/
0: 		TypeId	leftCTI;
0: 		leftCTI = leftOperand.getTypeId();
0: 		if (leftCTI.userType())
0: 			throwBadType("trim", leftCTI.getSQLTypeName());
0: 
0: 		leftOperand = castArgToString(leftOperand);
0: 
0: 		/*
0: 		** The result type of trim is varchar.
0: 		*/
0: 		setResultType(resultType);
0: 
0: 		return this;
0: 	}
0: 	/*
0: 	** set result type for operator
0: 	*/
0: 	private void setResultType(TypeId resultType) throws StandardException
0: 	{
0: 		setType(new DataTypeDescriptor(
0: 						resultType,
0: 						true,
0: 						receiver.getTypeServices().getMaximumWidth()
0: 					)
0: 				);
0: 	}
0: 	/**
0: 	 * Bind locate operator
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ValueNode locateBind() throws StandardException
0: 	{
0: 		TypeId	firstOperandType, secondOperandType, offsetType;
0: 
0: 		/*
0: 		 * Is there a ? parameter for the first arg.  Copy the 
0: 		 * left/firstOperand's.  If the left/firstOperand are both parameters,
0: 		 * both will be max length.
0: 		 */
0: 		if( receiver.isParameterNode())
0: 		{
0: 			if( leftOperand.isParameterNode())
0: 			{
0: 				((ParameterNode) receiver).setDescriptor(getVarcharDescriptor());
0: 			}
0: 			else
0: 			{
0: 				if( leftOperand.getTypeId().isStringTypeId() )
0: 				{
0: 					((ParameterNode) receiver).setDescriptor(
0: 							         leftOperand.getTypeServices());
0: 				}
0: 			}
0: 		}
0: 							                            
0: 		/*
0: 		 * Is there a ? parameter for the second arg.  Copy the receiver's.
0: 		 * If the receiver are both parameters, both will be max length.
0: 		 */
0: 		if(leftOperand.isParameterNode())
0: 		{
0: 			if(receiver.isParameterNode())
0: 			{
0: 				((ParameterNode) leftOperand).setDescriptor(getVarcharDescriptor());
0: 			}
0: 			else
0: 			{
0: 				if( receiver.getTypeId().isStringTypeId() )
0: 				{
0: 					((ParameterNode) leftOperand).setDescriptor(
0: 							         receiver.getTypeServices());
0: 				}
0: 			}
0: 		}
0: 
0: 		/*
0: 		 * Is there a ? paramter for the third arg.  It will be an int.
0: 		 */
0: 		if( rightOperand.isParameterNode())
0: 		{
0: 			((ParameterNode) rightOperand).setDescriptor(
0: 				new DataTypeDescriptor(TypeId.INTEGER_ID, true)); 
0: 		}
0: 
0: 		bindToBuiltIn();
0: 
0: 		/*
0: 		** Check the type of the operand - this function is allowed only
0: 		** for: receiver = CHAR
0: 		**      firstOperand = CHAR
0: 		**      secondOperand = INT
0: 		*/
0: 		secondOperandType = leftOperand.getTypeId();
0: 		offsetType = rightOperand.getTypeId();
0: 		firstOperandType = receiver.getTypeId();
0: 
0: 		if (!firstOperandType.isStringTypeId() ||
0: 			!secondOperandType.isStringTypeId() || 
0: 			offsetType.getJDBCTypeId() != Types.INTEGER)
0: 			throw StandardException.newException(SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE,
0: 					"LOCATE", "FUNCTION");
0: 
0: 		/*
0: 		** The result type of a LocateFunctionNode is an integer.
0: 		*/
0: 		setType(new DataTypeDescriptor(TypeId.INTEGER_ID, 
0: 				receiver.getTypeServices().isNullable())); 
0: 
0: 		return this;
0: 	}
0: 
0: 	/* cast arg to a varchar */
0: 	protected ValueNode castArgToString(ValueNode vn) throws StandardException
0: 	{
0: 		TypeCompiler vnTC = vn.getTypeCompiler();
0: 		if (! vn.getTypeId().isStringTypeId())
0: 		{
0: 			ValueNode newNode = (ValueNode)
0: 						getNodeFactory().getNode(
0: 							C_NodeTypes.CAST_NODE,
0: 							vn,
0: 							DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true,
0: 							                vnTC.getCastToCharWidth(
0: 							                    vn.getTypeServices())),
0: 							getContextManager());
0: 			((CastNode) newNode).bindCastNodeOnly();
0: 			return newNode;
0: 		}
0: 		return vn;
0: 	}
0: 
0: 	/**
0: 	 * Bind substr expression.  
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0:  	public ValueNode substrBind() 
0: 			throws StandardException
0: 	{
0: 		TypeId	receiverType;
0: 		TypeId	resultType;
0: 
0: 		// handle parameters here
0: 
0: 		/* Is there a ? parameter for the receiver? */
0: 		if (receiver.isParameterNode())
0: 		{
0: 			/*
0: 			** According to the SQL standard, if substr has a ? receiver,
0: 			** its type is varchar with the implementation-defined maximum length
0: 			** for a varchar.
0: 			*/
0: 	
0: 			((ParameterNode) receiver).setDescriptor(getVarcharDescriptor());
0: 		}
0: 
0: 		/* Is there a ? parameter on the left? */
0: 		if (leftOperand.isParameterNode())
0: 		{
0: 			/* Set the left operand type to int. */
0: 			((ParameterNode) leftOperand).setDescriptor(							
0: 				new DataTypeDescriptor(TypeId.INTEGER_ID, true)); 
0: 		}
0: 
0: 		/* Is there a ? parameter on the right? */
0: 		if ((rightOperand != null) && rightOperand.isParameterNode())
0: 		{
0: 			/* Set the right operand type to int. */
0: 			((ParameterNode) rightOperand).setDescriptor(							
0: 				new DataTypeDescriptor(TypeId.INTEGER_ID, true)); 
0: 		}
0: 
0: 		bindToBuiltIn();
0: 
0: 		if (!leftOperand.getTypeId().isNumericTypeId() ||
0: 			(rightOperand != null && !rightOperand.getTypeId().isNumericTypeId()))
0: 			throw StandardException.newException(SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, "SUBSTR", "FUNCTION");
0: 
0: 		/*
0: 		** Check the type of the receiver - this function is allowed only on
0: 		** string value types.  
0: 		*/
0: 		resultType = receiverType = receiver.getTypeId();
0: 		switch (receiverType.getJDBCTypeId())
0: 		{
0: 			case Types.CHAR:
0: 			case Types.VARCHAR:
0: 			case Types.LONGVARCHAR:
0: 			case Types.CLOB:
0: 				break;
0: 			default:
0: 			{
0: 				throwBadType("SUBSTR", receiverType.getSQLTypeName());
0: 			}
0: 		}
0: 
0: 		// Determine the maximum length of the result
0: 		int resultLen = receiver.getTypeServices().getMaximumWidth();
0: 
0: 		if (rightOperand != null && rightOperand instanceof ConstantNode)
0: 		{
0: 			if (((ConstantNode)rightOperand).getValue().getInt() < resultLen)
0: 				resultLen = ((ConstantNode)rightOperand).getValue().getInt();
0: 		}
0: 
0: 		/*
0: 		** The result type of substr is a string type
0: 		*/
0: 		setType(new DataTypeDescriptor(
0: 						resultType,
0: 						true,
0: 						resultLen
0: 					));
0: 
0: 		return this;
0: 	}
0: 
0: 	public ValueNode getReceiver()
0: 	{
0: 		return receiver;
0: 	}
0: 
0: 	/* throw bad type message */
0: 	private void throwBadType(String funcName, String type) 
0: 		throws StandardException
0: 	{
0: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
0: 										funcName,
0: 										type);
0: 	}
0: 
0: 	/* bind arguments to built in types */
0: 	protected void bindToBuiltIn() 
0: 		throws StandardException
0: 	{
0: 		/* If the receiver is not a built-in type, then generate a bound conversion
0: 		 * tree to a built-in type.
0: 		 */
0: 		if (! receiver.getTypeId().systemBuiltIn())
0: 		{
0: 			receiver = receiver.genSQLJavaSQLTree();
0: 		}
0: 
0: 		/* If the left operand is not a built-in type, then generate a bound conversion
0: 		 * tree to a built-in type.
0: 		 */
0: 		if (! leftOperand.getTypeId().systemBuiltIn())
0: 		{
0: 			leftOperand = leftOperand.genSQLJavaSQLTree();
0: 		}
0: 
0: 		/* If the right operand is not a built-in type, then generate a bound conversion
0: 		 * tree to a built-in type.
0: 		 */
0: 		if (rightOperand != null)
0: 		{
0: 			if (! rightOperand.getTypeId().systemBuiltIn())
0: 			{
0: 				rightOperand = rightOperand.genSQLJavaSQLTree();
0: 			}
0: 		}
0: 	}
0: 
0: 	private DataTypeDescriptor getVarcharDescriptor() {
0: 		return new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), true);
0: 	}
0: }
============================================================================