1:036a61f: /*
1:036a61f: 
1:036a61f:    Derby - Class org.apache.derbyTesting.perf.basic.jdbc.ClobAccessTest
1:036a61f: 
1:036a61f:    Licensed to the Apache Software Foundation (ASF) under one or more
1:036a61f:    contributor license agreements.  See the NOTICE file distributed with
1:036a61f:    this work for additional information regarding copyright ownership.
1:036a61f:    The ASF licenses this file to you under the Apache License, Version 2.0
1:036a61f:    (the "License"); you may not use this file except in compliance with
1:036a61f:    the License.  You may obtain a copy of the License at
1:036a61f: 
1:036a61f:       http://www.apache.org/licenses/LICENSE-2.0
1:036a61f: 
1:036a61f:    Unless required by applicable law or agreed to in writing, software
1:036a61f:    distributed under the License is distributed on an "AS IS" BASIS,
1:036a61f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:036a61f:    See the License for the specific language governing permissions and
1:036a61f:    limitations under the License.
1:036a61f: 
1:036a61f:  */
1:036a61f: package org.apache.derbyTesting.perf.basic.jdbc;
1:036a61f: 
1:036a61f: import java.io.BufferedReader;
1:036a61f: import java.io.IOException;
1:036a61f: import java.io.Reader;
1:036a61f: import java.sql.Clob;
1:036a61f: import java.sql.Connection;
1:036a61f: import java.sql.PreparedStatement;
1:036a61f: import java.sql.ResultSet;
1:036a61f: import java.sql.SQLException;
1:036a61f: import java.sql.Statement;
1:036a61f: import junit.framework.Test;
1:036a61f: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:036a61f: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:036a61f: import org.apache.derbyTesting.junit.JDBCPerfTestCase;
1:036a61f: import org.apache.derbyTesting.perf.clients.BackToBackLoadGenerator;
1:036a61f: import org.apache.derbyTesting.perf.clients.Client;
1:036a61f: import org.apache.derbyTesting.perf.clients.DBFiller;
1:036a61f: import org.apache.derbyTesting.perf.clients.LoadGenerator;
1:036a61f: import org.apache.derbyTesting.perf.clients.SingleRecordFiller;
1:036a61f: import org.apache.derbyTesting.perf.clients.SingleRecordSelectClient;
1:036a61f: 
1:036a61f: /**
1:036a61f:  * A series of tests accessing Clobs in various ways.
1:036a61f:  * <p>
1:036a61f:  * These tests are intended to detect Clob performance regressions. Before
1:036a61f:  * committing a patch that might change the Clob performance characteristics,
1:036a61f:  * first run these tests on a clean build and then with the patch applied. The
1:036a61f:  * results can only be compared when both runs are done on the same machine.
1:036a61f:  * <p>
1:036a61f:  * The results are time taken to execute the test. Lower duration is better
1:036a61f:  * (improvement). Currently the results are printed to standard out. There is
1:036a61f:  * one exception, which is {@code testConcurrency}. For this test, the
1:036a61f:  * throughput is printed and it will always run for a fixed amount of time.
1:036a61f:  * <p>
1:036a61f:  * The tests are written with two axis in mind: read-only vs update and small vs
1:036a61f:  * large. These axis were chosen based on the Clob implementation at the time.
1:036a61f:  * In the context of this test, small means the Clob is represented as a string
1:036a61f:  * by the Derby store and large means the Clob is represtend as a stream into
1:036a61f:  * the Derby store. When a Clob is modified, an in-memory or on disk temporary
1:036a61f:  * copy is created. The performance of these temporary representations are
1:036a61f:  * tested with the tests that modify the Clob content.
1:036a61f:  * <p>
1:036a61f:  * System properties controlling test behavior:
1:678938c:  * <dl>
1:678938c:  *      <dt>derby.tests.disableSmallClobs</dt>
1:678938c:  *      <dd>Whether or not to disable the testing of small Clobs.</dd>
1:678938c:  *      <dt>derby.tests.disableLargeClobs</dt>
1:678938c:  *      <dd>Whether or not to disable the testing of large Clobs.</dd>
1:678938c:  *      <dt>derby.tests.disableConcurrencyTest</dt>
1:678938c:  *      <dd>Whether or not to disable the concurrency test.</dd>
1:678938c:  *      <dt>derby.tests.largeClobSize</dt>
1:678938c:  *      <dd>Size of the large Clobs in MB, 15 MB is the default.</dd>
1:678938c:  *      <dt>derby.tests.runLargeClobTests</dt>
1:678938c:  *      <dd>A list of one or more tests to run. Only tests using large Clobs
1:678938c:  *          should be specified, but this is not enforced. Example:
1:678938c:  *          <tt>testFetchLargeClobPieceByPiece,testLargeClobGetLength</tt></dd>
1:678938c:  * </dl>
1:036a61f:  *
1:036a61f:  * <p>
1:036a61f:  * <b>NOTE</b>: Currently there are no tests for the client driver (network)
1:036a61f:  * or for encrypted Clobs.
1:036a61f:  */
1:036a61f: public class ClobAccessTest
1:036a61f:         extends JDBCPerfTestCase {
1:036a61f: 
1:036a61f:     private static final boolean disableSmallClobs =
1:036a61f:             Boolean.getBoolean("derby.tests.disableSmallClobs");
1:036a61f:     private static final boolean disableLargeClobs =
1:036a61f:             Boolean.getBoolean("derby.tests.disableLargeClobs");
1:036a61f:     private static final boolean disableConcurrencyTest =
1:036a61f:             Boolean.getBoolean("derby.tests.disableConcurrencyTest");
1:678938c:     /**
1:678938c:      * A list of one or more tests to be run. Only tests using a large Clob
1:678938c:      * should be specified.
1:678938c:      */
1:678938c:     private static final String runLargeClobTests =
1:678938c:             System.getProperty("derby.tests.runLargeClobTests", null);
1:036a61f:     private static final int largeClobSizeMB =
1:036a61f:             Integer.getInteger("derby.tests.largeClobSize", 15).intValue();
1:036a61f: 
1:036a61f: 
1:036a61f:     /** Maximum buffer size to use. */
1:036a61f:     private static final int MAX_BSIZE = 32676;
1:036a61f: 
1:036a61f:     /**
1:036a61f:      * Instantiates a new test that will be run the specified number of
1:036a61f:      * iterations and repeated as specified.
1:036a61f:      *
1:036a61f:      * @param name name of the test to instantiate
1:036a61f:      * @param iterations number of iterations per repetition
1:036a61f:      * @param repeats number of repetitions
1:036a61f:      */
1:036a61f:     public ClobAccessTest(String name, int iterations, int repeats) {
1:036a61f:         super(name, iterations, repeats);
1:036a61f:     }
1:036a61f: 
1:036a61f:     /**
1:036a61f:      * Set autocommit to false by default.
1:036a61f:      */
1:036a61f:     public void initializeConnection(Connection conn)
1:036a61f:             throws SQLException {
1:036a61f:         conn.setAutoCommit(false);
1:036a61f:     }
1:036a61f: 
1:036a61f:     public static Test suite() {
1:1ae02c9:         BaseTestSuite mainSuite = new BaseTestSuite("ClobAccessTest suite");
1:036a61f:         if (!disableSmallClobs) {
1:036a61f:             int iters = 50;
1:036a61f:             int reps = 1;
1:036a61f:             println("Adding small Clob tests.");
1:1ae02c9:             BaseTestSuite smallSuite = new BaseTestSuite("Small Clob suite");
1:036a61f:             smallSuite.addTest(new ClobAccessTest(
1:036a61f:                     "testFetchSmallClobs", iters, reps));
1:036a61f:             smallSuite.addTest(new ClobAccessTest(
1:036a61f:                     "testFetchSmallClobsInaccurateLength", iters, reps));
1:036a61f:             smallSuite.addTest(new ClobAccessTest(
1:036a61f:                     "testModifySmallClobs", iters, reps));
1:036a61f:             mainSuite.addTest(smallSuite);
1:036a61f:         }
1:036a61f:         if (!disableLargeClobs) {
1:036a61f:             int iters = 5;
1:036a61f:             int reps = 1;
1:678938c:             String[] tests = new String[] {
1:678938c:                     "testFetchLargeClobs",
1:678938c:                     "testFetchLargeClobsModified",
1:678938c:                     "testFetchLargeClobWithStream",
1:678938c:                     "testFetchLargeClobOneByOneCharBaseline",
1:678938c:                     "testFetchLargeClobOneByOneCharModified",
1:678938c:                     "testFetchLargeClobOneByOneChar",
1:678938c:                     "testFetchLargeClobPieceByPiece",
1:678938c:                     "testFetchLargeClobPieceByPieceModified",
1:678938c:                     "testLargeClobGetLength",
1:678938c:                     "testLargeClobGetLengthModified",
1:bde5241:                     "testLargeClobTruncateLengthMinusOne",
1:678938c:                     "testFetchLargeClobPieceByPieceBackwards",
1:678938c:                 };
1:678938c:             // See if the user has overridden which tests to run.
1:678938c:             if (runLargeClobTests != null) {
1:678938c:                 String[] specifiedTests = runLargeClobTests.split(",");
1:678938c:                 if (specifiedTests.length > 0) {
1:678938c:                     tests = specifiedTests;
1:678938c:                 }
1:678938c:             }
1:678938c:             println("Adding " + tests.length + " large Clob tests.");
1:1ae02c9:             BaseTestSuite largeSuite = new BaseTestSuite("Large Clob suite");
1:678938c:             for (int i=0; i < tests.length; i++) {
1:678938c:                 largeSuite.addTest(new ClobAccessTest(tests[i] , iters, reps));
1:678938c:             }
1:036a61f:             mainSuite.addTest(largeSuite);
1:036a61f:         }
1:036a61f:         if (!disableConcurrencyTest) {
1:036a61f:             mainSuite.addTest(new ClobAccessTest("testConcurrency", 1, 1));
1:036a61f:         }
1:036a61f:         return new CleanDatabaseTestSetup(mainSuite) {
1:036a61f:             protected void decorateSQL(Statement stmt)
1:036a61f:                     throws SQLException {
1:036a61f:                 initializeClobData(stmt);
1:036a61f:             }
1:036a61f:         };
1:036a61f:     }
1:036a61f: 
1:036a61f:     /**
1:036a61f:      * Fetches a number of small Clobs, getting the content using getSubString.
1:036a61f:      * <p>
1:036a61f:      * The exact length of the clob is used when getting the string.
1:036a61f:      */
1:036a61f:     public void testFetchSmallClobs()
1:036a61f:             throws SQLException {
1:036a61f:         PreparedStatement ps = prepareStatement(
1:036a61f:                 "select dClob, length from smallClobs");
1:036a61f:         ResultSet rs = ps.executeQuery();
1:036a61f:         while (rs.next()) {
1:036a61f:             Clob clob = rs.getClob(1);
1:036a61f:             int clobLength = rs.getInt(2);
1:036a61f:             String content = clob.getSubString(1, clobLength);
1:036a61f:         }
1:036a61f:         rs.close();
1:036a61f:     }
1:036a61f: 
1:036a61f:     /**
1:036a61f:      * Fetches a number of small Clobs, getting the content using getSubString.
1:036a61f:      * <p>
1:036a61f:      * A too long length of the clob is used when getting the string.
1:036a61f:      */
1:036a61f:     public void testFetchSmallClobsInaccurateLength()
1:036a61f:             throws SQLException {
1:036a61f:         PreparedStatement ps = prepareStatement(
1:036a61f:                 "select dClob, length from smallClobs");
1:036a61f:         ResultSet rs = ps.executeQuery();
1:036a61f:         while (rs.next()) {
1:036a61f:             Clob clob = rs.getClob(1);
1:036a61f:             int unusedLength = rs.getInt(2);
1:036a61f:             String content = clob.getSubString(1, 100);
1:036a61f:         }
1:036a61f:         rs.close();
1:036a61f:     }
1:036a61f: 
1:036a61f:     /**
1:036a61f:      * Test fetching the content after adding a single character at the end.
1:036a61f:      */
1:036a61f:     public void testModifySmallClobs()
1:036a61f:             throws SQLException {
1:036a61f:         PreparedStatement ps = prepareStatement(
1:036a61f:                 "select dClob, length from smallClobs");
1:036a61f:         ResultSet rs = ps.executeQuery();
1:036a61f:         while (rs.next()) {
1:036a61f:             Clob clob = rs.getClob(1);
1:036a61f:             int length = rs.getInt(2);
1:036a61f:             clob.setString(length, "X");
1:036a61f:             String content = clob.getSubString(1, 100);
1:036a61f:         }
1:036a61f:         rs.close();
1:036a61f:     }
1:036a61f: 
1:036a61f:     public void testFetchLargeClobs()
1:036a61f:             throws IOException, SQLException {
1:036a61f:         PreparedStatement ps = prepareStatement(
1:036a61f:                 "select dClob, length from largeClobs");
1:036a61f:         ResultSet rs = ps.executeQuery();
1:036a61f:         char[] charBuf = new char[16*1024]; // 16 KB
1:036a61f:         while (rs.next()) {
1:036a61f:             Clob clob = rs.getClob(1);
1:036a61f:             Reader content = clob.getCharacterStream();
1:036a61f:             long remaining = rs.getInt(2);
1:036a61f:             while (remaining > 0) {
1:036a61f:                 remaining -= content.read(charBuf);
1:036a61f:             }
1:036a61f:             content.close();
1:036a61f:         }
1:036a61f:         rs.close();
1:036a61f:     }
1:036a61f: 
1:036a61f:     public void testFetchLargeClobsModified()
1:036a61f:             throws IOException, SQLException {
1:036a61f:         PreparedStatement ps = prepareStatement(
1:036a61f:                 "select dClob, length from largeClobs");
1:036a61f:         ResultSet rs = ps.executeQuery();
1:036a61f:         char[] charBuf = new char[16*1024]; // 16 KB
1:036a61f:         while (rs.next()) {
1:036a61f:             Clob clob = rs.getClob(1);
1:036a61f:             clob.setString(1, "X");
1:036a61f:             Reader content = clob.getCharacterStream();
1:036a61f:             long remaining = rs.getInt(2);
1:036a61f:             while (remaining > 0) {
1:036a61f:                 remaining -= content.read(charBuf);
1:036a61f:             }
1:036a61f:             content.close();
1:036a61f:         }
1:036a61f:         rs.close();
1:036a61f:     }
1:036a61f: 
1:036a61f:     /**
1:036a61f:      * Fetches a single Clob and reads it char by char, but utilizing a
1:036a61f:      * buffered stream to get a lower time bound on the read operation.
1:036a61f:      */
1:036a61f:     public void testFetchLargeClobOneByOneCharBaseline()
1:036a61f:             throws IOException, SQLException {
1:036a61f:         // Select just one Clob.
1:036a61f:         PreparedStatement ps = prepareStatement(
1:036a61f:                 "select dClob, length from largeClobs where id = 4");
1:036a61f:         ResultSet rs = ps.executeQuery();
1:036a61f:         while (rs.next()) {
1:036a61f:             Clob clob = rs.getClob(1);
1:036a61f:             Reader content = clob.getCharacterStream();
1:036a61f:             BufferedReader bufferedContent = new BufferedReader(content);
1:036a61f:             long remaining = rs.getInt(2);
1:036a61f:             while (bufferedContent.read() != -1) {
1:036a61f:                 remaining--;
1:036a61f:             }
1:036a61f:             content.close();
1:036a61f:             assertEquals(0, remaining);
1:036a61f:         }
1:036a61f:         rs.close();
1:036a61f:     }
1:036a61f: 
1:036a61f:     public void testFetchLargeClobOneByOneChar()
1:036a61f:             throws IOException, SQLException {
1:036a61f:         // Select just one Clob.
1:036a61f:         PreparedStatement ps = prepareStatement(
1:036a61f:                 "select dClob, length from largeClobs where id = 4");
1:036a61f:         ResultSet rs = ps.executeQuery();
1:036a61f:         while (rs.next()) {
1:036a61f:             Clob clob = rs.getClob(1);
1:036a61f:             Reader content = clob.getCharacterStream();
1:036a61f:             long remaining = rs.getInt(2);
1:036a61f:             while (content.read() != -1) {
1:036a61f:                 remaining--;
1:036a61f:             }
1:036a61f:             content.close();
1:036a61f:             assertEquals(0, remaining);
1:036a61f:         }
1:036a61f:         rs.close();
1:036a61f:     }
1:036a61f: 
1:036a61f:     public void testFetchLargeClobOneByOneCharModified()
1:036a61f:             throws IOException, SQLException {
1:036a61f:         // Select just one Clob.
1:036a61f:         PreparedStatement ps = prepareStatement(
1:036a61f:                 "select dClob, length from largeClobs where id = 4");
1:036a61f:         ResultSet rs = ps.executeQuery();
1:036a61f:         while (rs.next()) {
1:036a61f:             Clob clob = rs.getClob(1);
1:036a61f:             long remaining = rs.getInt(2);
1:036a61f:             clob.setString(++remaining, "X");
1:036a61f:             Reader content = clob.getCharacterStream();
1:036a61f:             while (content.read() != -1) {
1:036a61f:                 remaining --;
1:036a61f:             }
1:036a61f:             content.close();
1:036a61f:             assertEquals(0, remaining);
1:036a61f:         }
1:036a61f:         rs.close();
1:036a61f:     }
1:036a61f: 
1:036a61f:     /**
1:036a61f:      * Tests that repositioning within the current internal character buffer is
1:036a61f:      * cheap.
1:036a61f:      * <p>
1:036a61f:      * Note that the positions used in this test have been chosen based on the
1:036a61f:      * internal buffer size (8KB), which is an implementation detail.
1:036a61f:      *
1:036a61f:      * @throws SQLException if the test fails
1:036a61f:      */
1:036a61f:     public void testFetchLargeClobPieceByPieceBackwards()
1:036a61f:             throws IOException, SQLException {
1:036a61f:         boolean modifyClob = false;
1:036a61f:         final int intBufSize = 8192; // Implementation detail.
1:036a61f:         // Select just one Clob.
1:036a61f:         PreparedStatement ps = prepareStatement(
1:036a61f:                 "select dClob, length from largeClobs where id = 4");
1:036a61f:         ResultSet rs = ps.executeQuery();
1:036a61f:         while (rs.next()) {
1:036a61f:             Clob clob = rs.getClob(1);
1:036a61f:             int remaining = rs.getInt(2);
1:036a61f:             if (modifyClob) {
1:036a61f:                 // Modify the Clob to create a temporary copy in memory or on
1:036a61f:                 // disk (depends on the Clob size).
1:036a61f:                 long modifyStart = System.currentTimeMillis();
1:036a61f:                 clob.setString(++remaining, "X");
1:036a61f:                 println("Clob modification duration: " +
1:036a61f:                         (System.currentTimeMillis() - modifyStart) + " ms");
1:036a61f:             }
1:036a61f:             // Go close to the middle of the Clob on a buffer border, then
1:036a61f:             // subtract the piece size to avoid repositioning.
1:036a61f:             final int pieceSize = 10;
1:036a61f:             final long pos = (remaining / 2 / intBufSize) *
1:036a61f:                     intBufSize - pieceSize;
1:036a61f:             for (int i=0; i < intBufSize; i += pieceSize) {
1:036a61f:                 String str = clob.getSubString(
1:036a61f:                         pos -i, pieceSize);
1:036a61f:             }
1:036a61f:         }
1:036a61f:         rs.close();
1:036a61f:     }
1:036a61f: 
1:036a61f:     /**
1:036a61f:      * Fetches a "large" Clob piece by piece using getSubString.
1:036a61f:      */
1:036a61f:     public void testFetchLargeClobPieceByPiece()
1:036a61f:             throws IOException, SQLException {
1:036a61f:         fetchPieceByPiece(false);
1:036a61f:     }
1:036a61f: 
1:036a61f:     /**
1:036a61f:      * Fetches a "large" Clob piece by piece using getSubString.
1:036a61f:      * <p>
1:036a61f:      * The Clob is modified before fetched to create a temporary Clob
1:036a61f:      * representation in memory / on disk.
1:036a61f:      */
1:036a61f:     public void testFetchLargeClobPieceByPieceModified()
1:036a61f:             throws IOException, SQLException {
1:036a61f:         fetchPieceByPiece(true);
1:036a61f:     }
1:036a61f:     
1:036a61f:     /**
1:036a61f:      * Fetches a "large" Clob piece by piece using getSubString.
1:036a61f:      *
1:036a61f:      * @param modifyClob whether to modify the Clob before fetching it
1:036a61f:      *      (determines the internal Derby Clob representation)
1:036a61f:      */
1:036a61f:     private void fetchPieceByPiece(final boolean modifyClob)
1:036a61f:             throws IOException, SQLException {
1:036a61f:         // Select just one Clob.
1:036a61f:         PreparedStatement ps = prepareStatement(
1:036a61f:                 "select dClob, length from largeClobs where id = 4");
1:036a61f:         ResultSet rs = ps.executeQuery();
1:036a61f:         while (rs.next()) {
1:036a61f:             Clob clob = rs.getClob(1);
1:036a61f:             int remaining = rs.getInt(2);
1:036a61f:             Reader myReader = new LoopingAlphabetReader(remaining);
1:036a61f:             if (modifyClob) {
1:036a61f:                 // Modify the Clob to create a temporary copy in memory or on
1:036a61f:                 // disk (depends on the Clob size).
1:036a61f:                 long modifyStart = System.currentTimeMillis();
1:036a61f:                 clob.setString(++remaining, "X");
1:036a61f:                 println("Clob modification duration: " +
1:036a61f:                         (System.currentTimeMillis() - modifyStart) + " ms");
1:036a61f:             }
1:036a61f:             long pos = 1;
1:036a61f:             while (remaining > 0) {
1:036a61f:                 String str = clob.getSubString(
1:036a61f:                         pos, Math.min(MAX_BSIZE, remaining));
1:036a61f:                 myReader.skip(Math.min(MAX_BSIZE, remaining) -1);
1:036a61f:                 pos += str.length();
1:036a61f:                 remaining -= str.length();
1:036a61f:                 // Avoid failure on the last char when Clob is modified.
1:036a61f:                 if (!modifyClob || remaining != 0) {
1:036a61f:                     assertEquals(myReader.read(), str.charAt(str.length() -1));
1:036a61f:                 }
1:036a61f:             }
1:036a61f:         }
1:036a61f:         rs.close();
1:036a61f:     }
1:036a61f: 
1:036a61f:     public void testFetchLargeClobWithStream()
1:036a61f:             throws IOException, SQLException {
1:036a61f:         boolean modifyClob = false;
1:036a61f:         // Select just one Clob.
1:036a61f:         PreparedStatement ps = prepareStatement(
1:036a61f:                 "select dClob, length from largeClobs where id = 5");
1:036a61f:         ResultSet rs = ps.executeQuery();
1:036a61f:         while (rs.next()) {
1:036a61f:             Clob clob = rs.getClob(1);
1:036a61f:             int remaining = rs.getInt(2);
1:036a61f:             Reader myReader = new LoopingAlphabetReader(remaining);
1:036a61f:             if (modifyClob) {
1:036a61f:                 // Modify the Clob to create a temporary copy in memory or on
1:036a61f:                 // disk (depends on the Clob size).
1:036a61f:                 long modifyStart = System.currentTimeMillis();
1:036a61f:                 clob.setString(++remaining, "X");
1:036a61f:                 println("Clob modification duration: " +
1:036a61f:                         (System.currentTimeMillis() - modifyStart) + " ms");
1:036a61f:             }
1:036a61f:             Reader clobReader = clob.getCharacterStream();
1:036a61f:             char[] buf = new char[MAX_BSIZE];
1:036a61f:             while (remaining > 0) {
1:036a61f:                 int read = clobReader.read(buf, 0, Math.min(MAX_BSIZE, remaining));
1:036a61f:                 myReader.skip(read -1);
1:036a61f:                 remaining -= read;
1:036a61f:                 assertEquals(myReader.read(), buf[read -1]);
1:036a61f:             }
1:036a61f:         }
1:036a61f:         rs.close();
1:036a61f:         
1:036a61f:     }
1:036a61f: 
1:036a61f:     /**
1:036a61f:      * Tests if the Clob length is cached.
1:036a61f:      */
1:036a61f:     public void testLargeClobGetLength() throws SQLException {
1:036a61f:         // Select just one Clob.
1:036a61f:         PreparedStatement ps = prepareStatement(
1:036a61f:                 "select dClob, length from largeClobs where id = 7");
1:036a61f:         ResultSet rs = ps.executeQuery();
1:036a61f:         while (rs.next()) {
1:036a61f:             Clob clob = rs.getClob(1);
1:036a61f:             long remaining = rs.getInt(2);
1:036a61f:             // This should be cached. Lots of data have to be skipped otherwise.
1:036a61f:             for (int i=0; i < 50; i++) {
1:036a61f:                 assertEquals(remaining, clob.length());
1:036a61f:             }
1:036a61f:         }
1:036a61f:         rs.close();
1:036a61f:     }
1:036a61f: 
1:036a61f:     /**
1:036a61f:      * Tests if the Clob length is cached.
1:036a61f:      */
1:036a61f:     public void testLargeClobGetLengthModified() throws SQLException {
1:036a61f:         // Select just one Clob.
1:036a61f:         PreparedStatement ps = prepareStatement(
1:036a61f:                 "select dClob, length from largeClobs where id = 7");
1:036a61f:         ResultSet rs = ps.executeQuery();
1:036a61f:         while (rs.next()) {
1:036a61f:             Clob clob = rs.getClob(1);
1:036a61f:             clob.setString(1, "X");
1:036a61f:             long remaining = rs.getInt(2);
1:036a61f:             // This should be cached. Lots of data have to be skipped otherwise.
1:036a61f:             for (int i=0; i < 50; i++) {
1:036a61f:                 assertEquals(remaining, clob.length());
1:036a61f:             }
1:036a61f:         }
1:036a61f:         rs.close();
1:036a61f:     }
1:036a61f: 
1:036a61f:     /**
1:bde5241:      * Tests the speed of transferring data from the store to local temporary
1:bde5241:      * storage as part of the truncate operation.
1:bde5241:      */
1:bde5241:     public void testLargeClobTruncateLengthMinusOne()
1:bde5241:             throws SQLException {
1:bde5241:         // Select just one Clob.
1:bde5241:         PreparedStatement ps = prepareStatement(
1:bde5241:                 "select dClob, length from largeClobs where id = 8");
1:bde5241:         ResultSet rs = ps.executeQuery();
1:bde5241:         while (rs.next()) {
1:bde5241:             Clob clob = rs.getClob(1);
1:bde5241:             int length = rs.getInt(2);
1:bde5241:             clob.truncate(length -1);
1:bde5241:         }
1:bde5241:     }
1:bde5241: 
1:bde5241:     /**
1:036a61f:      * Runs a test using multiple threads.
1:036a61f:      * <p>
1:036a61f:      * This test intends to detect problems with small Clobs and general
1:036a61f:      * problems with concurrency.
1:036a61f:      * <p>
1:036a61f:      * <b>NOTE</b>: To produce more reliable numbers, please run the performance
1:036a61f:      * client independently outside this JUnit test framework. Performance also
1:036a61f:      * suffers greatly with SANE builds.
1:036a61f:      */
1:036a61f:     public void testConcurrency()
1:036a61f:             throws InterruptedException, SQLException {
1:036a61f: 
1:036a61f:         final int records = 100000;
1:036a61f:         final int tables = 1;
1:036a61f:         final int threads = 16;
1:036a61f:         DBFiller filler = new SingleRecordFiller(
1:036a61f:                 records, tables, java.sql.Types.CLOB, false, false);
1:036a61f:         Connection conn = getConnection();
1:036a61f:         println("initializing database...");
1:036a61f:         filler.fill(conn);
1:036a61f:         conn.close();
1:036a61f: 
1:036a61f:         Client[] clients = new Client[threads];
1:036a61f:         for (int i = 0; i < clients.length; i++) {
1:036a61f:             Connection c = openDefaultConnection();
1:036a61f:             c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:036a61f:             clients[i] = new SingleRecordSelectClient(
1:036a61f:                     records, tables, java.sql.Types.CLOB, false, false);
1:036a61f:             clients[i].init(c);
1:036a61f:         }
1:036a61f: 
1:036a61f:         final int warmupSec = 30;
1:036a61f:         final int steadySec = 60;
1:036a61f:         LoadGenerator gen = new BackToBackLoadGenerator();
1:036a61f:         gen.init(clients);
1:036a61f:         println("starting warmup...");
1:036a61f:         gen.startWarmup();
1:036a61f:         Thread.sleep(1000L * warmupSec);
1:036a61f:         println("entering steady state...");
1:036a61f:         gen.startSteadyState();
1:036a61f:         Thread.sleep(1000L * steadySec);
1:036a61f:         println("stopping threads...");
1:036a61f:         gen.stop();
1:036a61f:         // Should get the printstream used by the test harness here.
1:036a61f:         gen.printReport(System.out);
1:036a61f:     }
1:036a61f: 
1:036a61f:     /**
1:036a61f:      * Generates test data.
1:036a61f:      */
1:036a61f:     private static void initializeClobData(Statement stmt)
1:036a61f:             throws SQLException {
1:036a61f:         Connection con = stmt.getConnection();
1:036a61f:         con.setAutoCommit(false);
1:036a61f:         if (!disableSmallClobs) {
1:036a61f:             println("Generating small Clobs test data.");
1:036a61f:             // Insert small Clob data.
1:036a61f:             try {
1:036a61f:                 stmt.executeUpdate("drop table smallClobs");
1:036a61f:             } catch (SQLException sqle) {
1:036a61f:                 assertSQLState("42Y55", sqle);
1:036a61f:             }
1:036a61f:             stmt.executeUpdate(
1:036a61f:                     "create table smallClobs (dClob clob, length int)");
1:036a61f:             PreparedStatement smallClobInsert = con.prepareStatement(
1:036a61f:                     "insert into smallClobs values (?,?)");
1:036a61f:             // Insert 15 000 small clobs.
1:036a61f:             for (int clobCounter = 1; clobCounter < 15001; clobCounter++) {
1:036a61f:                 String content = Integer.toString(clobCounter);
1:036a61f:                 smallClobInsert.setString(1, content);
1:036a61f:                 smallClobInsert.setInt(2, content.length());
1:036a61f:                 smallClobInsert.executeUpdate();
1:036a61f:                 if (clobCounter % 1000 == 0) {
1:036a61f:                     con.commit();
1:036a61f:                 }
1:036a61f:             }
1:036a61f:             con.commit();
1:036a61f:         }
1:036a61f: 
1:036a61f:         if (!disableLargeClobs) {
1:036a61f:             println("Generating large Clobs test data.");
1:036a61f:             // Insert large Clob data.
1:036a61f:             try {
1:036a61f:                 stmt.executeUpdate("drop table largeClobs");
1:036a61f:             } catch (SQLException sqle) {
1:036a61f:                 assertSQLState("42Y55", sqle);
1:036a61f:             }
1:036a61f:             stmt.executeUpdate("create table largeClobs (" +
1:036a61f:                     "id int unique not null, dClob clob, length int)");
1:036a61f:             PreparedStatement largeClobInsert = con.prepareStatement(
1:036a61f:                     "insert into largeClobs values (?,?,?)");
1:036a61f:             // Insert some large Clobs.
1:036a61f:             final int size = largeClobSizeMB*1024*1024; // 15 MB default
1:036a61f:             for (int clobCounter = 1; clobCounter < 11; clobCounter++) {
1:036a61f:                 largeClobInsert.setInt(1, clobCounter);
1:036a61f:                 largeClobInsert.setCharacterStream(
1:036a61f:                         2, new LoopingAlphabetReader(size), size);
1:036a61f:                 largeClobInsert.setInt(3, size);
1:036a61f:                 largeClobInsert.executeUpdate();
1:036a61f:                 println("Inserted large Clob #" + (clobCounter -1));
1:036a61f:             }
1:036a61f:             con.commit();
1:036a61f:         }
1:036a61f:     }
1:036a61f: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite mainSuite = new BaseTestSuite("ClobAccessTest suite");
1:             BaseTestSuite smallSuite = new BaseTestSuite("Small Clob suite");
/////////////////////////////////////////////////////////////////////////
1:             BaseTestSuite largeSuite = new BaseTestSuite("Large Clob suite");
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:bde5241
/////////////////////////////////////////////////////////////////////////
1:                     "testLargeClobTruncateLengthMinusOne",
/////////////////////////////////////////////////////////////////////////
1:      * Tests the speed of transferring data from the store to local temporary
1:      * storage as part of the truncate operation.
1:      */
1:     public void testLargeClobTruncateLengthMinusOne()
1:             throws SQLException {
1:         // Select just one Clob.
1:         PreparedStatement ps = prepareStatement(
1:                 "select dClob, length from largeClobs where id = 8");
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next()) {
1:             Clob clob = rs.getClob(1);
1:             int length = rs.getInt(2);
1:             clob.truncate(length -1);
1:         }
1:     }
1: 
1:     /**
commit:678938c
/////////////////////////////////////////////////////////////////////////
1:  * <dl>
1:  *      <dt>derby.tests.disableSmallClobs</dt>
1:  *      <dd>Whether or not to disable the testing of small Clobs.</dd>
1:  *      <dt>derby.tests.disableLargeClobs</dt>
1:  *      <dd>Whether or not to disable the testing of large Clobs.</dd>
1:  *      <dt>derby.tests.disableConcurrencyTest</dt>
1:  *      <dd>Whether or not to disable the concurrency test.</dd>
1:  *      <dt>derby.tests.largeClobSize</dt>
1:  *      <dd>Size of the large Clobs in MB, 15 MB is the default.</dd>
1:  *      <dt>derby.tests.runLargeClobTests</dt>
1:  *      <dd>A list of one or more tests to run. Only tests using large Clobs
1:  *          should be specified, but this is not enforced. Example:
1:  *          <tt>testFetchLargeClobPieceByPiece,testLargeClobGetLength</tt></dd>
1:  * </dl>
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * A list of one or more tests to be run. Only tests using a large Clob
1:      * should be specified.
1:      */
1:     private static final String runLargeClobTests =
1:             System.getProperty("derby.tests.runLargeClobTests", null);
/////////////////////////////////////////////////////////////////////////
1:             String[] tests = new String[] {
1:                     "testFetchLargeClobs",
1:                     "testFetchLargeClobsModified",
1:                     "testFetchLargeClobWithStream",
1:                     "testFetchLargeClobOneByOneCharBaseline",
1:                     "testFetchLargeClobOneByOneCharModified",
1:                     "testFetchLargeClobOneByOneChar",
1:                     "testFetchLargeClobPieceByPiece",
1:                     "testFetchLargeClobPieceByPieceModified",
1:                     "testLargeClobGetLength",
1:                     "testLargeClobGetLengthModified",
1:                     "testFetchLargeClobPieceByPieceBackwards",
1:                 };
1:             // See if the user has overridden which tests to run.
1:             if (runLargeClobTests != null) {
1:                 String[] specifiedTests = runLargeClobTests.split(",");
1:                 if (specifiedTests.length > 0) {
1:                     tests = specifiedTests;
1:                 }
1:             }
1:             println("Adding " + tests.length + " large Clob tests.");
1:             for (int i=0; i < tests.length; i++) {
1:                 largeSuite.addTest(new ClobAccessTest(tests[i] , iters, reps));
1:             }
commit:036a61f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.perf.basic.jdbc.ClobAccessTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.perf.basic.jdbc;
1: 
1: import java.io.BufferedReader;
1: import java.io.IOException;
1: import java.io.Reader;
1: import java.sql.Clob;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBCPerfTestCase;
1: import org.apache.derbyTesting.perf.clients.BackToBackLoadGenerator;
1: import org.apache.derbyTesting.perf.clients.Client;
1: import org.apache.derbyTesting.perf.clients.DBFiller;
1: import org.apache.derbyTesting.perf.clients.LoadGenerator;
1: import org.apache.derbyTesting.perf.clients.SingleRecordFiller;
1: import org.apache.derbyTesting.perf.clients.SingleRecordSelectClient;
1: 
1: /**
1:  * A series of tests accessing Clobs in various ways.
1:  * <p>
1:  * These tests are intended to detect Clob performance regressions. Before
1:  * committing a patch that might change the Clob performance characteristics,
1:  * first run these tests on a clean build and then with the patch applied. The
1:  * results can only be compared when both runs are done on the same machine.
1:  * <p>
1:  * The results are time taken to execute the test. Lower duration is better
1:  * (improvement). Currently the results are printed to standard out. There is
1:  * one exception, which is {@code testConcurrency}. For this test, the
1:  * throughput is printed and it will always run for a fixed amount of time.
1:  * <p>
1:  * The tests are written with two axis in mind: read-only vs update and small vs
1:  * large. These axis were chosen based on the Clob implementation at the time.
1:  * In the context of this test, small means the Clob is represented as a string
1:  * by the Derby store and large means the Clob is represtend as a stream into
1:  * the Derby store. When a Clob is modified, an in-memory or on disk temporary
1:  * copy is created. The performance of these temporary representations are
1:  * tested with the tests that modify the Clob content.
1:  * <p>
1:  * System properties controlling test behavior:
0:  * <lu><li>derby.tests.disableSmallClobs</li>
0:  *     <li>derby.tests.disableLargeClobs</li>
0:  *     <li>derby.tests.disableConcurrencyTest</li>
0:  *     <li>derby.tests.largeClobSize (in MB, 15 is the default)</li>
0:  * </ul>
1:  *
1:  * <p>
1:  * <b>NOTE</b>: Currently there are no tests for the client driver (network)
1:  * or for encrypted Clobs.
1:  */
1: public class ClobAccessTest
1:         extends JDBCPerfTestCase {
1: 
1:     private static final boolean disableSmallClobs =
1:             Boolean.getBoolean("derby.tests.disableSmallClobs");
1:     private static final boolean disableLargeClobs =
1:             Boolean.getBoolean("derby.tests.disableLargeClobs");
1:     private static final boolean disableConcurrencyTest =
1:             Boolean.getBoolean("derby.tests.disableConcurrencyTest");
1:     private static final int largeClobSizeMB =
1:             Integer.getInteger("derby.tests.largeClobSize", 15).intValue();
1: 
1: 
1:     /** Maximum buffer size to use. */
1:     private static final int MAX_BSIZE = 32676;
1: 
1:     /**
1:      * Instantiates a new test that will be run the specified number of
1:      * iterations and repeated as specified.
1:      *
1:      * @param name name of the test to instantiate
1:      * @param iterations number of iterations per repetition
1:      * @param repeats number of repetitions
1:      */
1:     public ClobAccessTest(String name, int iterations, int repeats) {
1:         super(name, iterations, repeats);
1:     }
1: 
1:     /**
1:      * Set autocommit to false by default.
1:      */
1:     public void initializeConnection(Connection conn)
1:             throws SQLException {
1:         conn.setAutoCommit(false);
1:     }
1: 
1:     public static Test suite() {
0:         TestSuite mainSuite = new TestSuite("ClobAccessTest suite");
1:         if (!disableSmallClobs) {
1:             int iters = 50;
1:             int reps = 1;
1:             println("Adding small Clob tests.");
0:             TestSuite smallSuite = new TestSuite("Small Clob suite");
1:             smallSuite.addTest(new ClobAccessTest(
1:                     "testFetchSmallClobs", iters, reps));
1:             smallSuite.addTest(new ClobAccessTest(
1:                     "testFetchSmallClobsInaccurateLength", iters, reps));
1:             smallSuite.addTest(new ClobAccessTest(
1:                     "testModifySmallClobs", iters, reps));
1:             mainSuite.addTest(smallSuite);
1:         }
1:         if (!disableLargeClobs) {
1:             int iters = 5;
1:             int reps = 1;
0:             println("Adding large Clob tests.");
0:             TestSuite largeSuite = new TestSuite("Large Clob suite");
0:             largeSuite.addTest(new ClobAccessTest(
0:                     "testFetchLargeClobs", iters, reps));
0:             largeSuite.addTest(new ClobAccessTest(
0:                     "testFetchLargeClobsModified", iters, reps));
0:             largeSuite.addTest(new ClobAccessTest(
0:                     "testFetchLargeClobWithStream", iters, reps));
0:             largeSuite.addTest(new ClobAccessTest(
0:                     "testFetchLargeClobOneByOneCharBaseline", iters, reps));
0:             largeSuite.addTest(new ClobAccessTest(
0:                     "testFetchLargeClobOneByOneCharModified", iters, reps));
0:             largeSuite.addTest(new ClobAccessTest(
0:                     "testFetchLargeClobOneByOneChar", iters, reps));
0:             largeSuite.addTest(new ClobAccessTest(
0:                     "testFetchLargeClobPieceByPiece", iters, reps));
0:             largeSuite.addTest(new ClobAccessTest(
0:                     "testFetchLargeClobPieceByPieceModified", iters, reps));
0:             largeSuite.addTest(new ClobAccessTest(
0:                     "testLargeClobGetLength", iters, reps));
0:             largeSuite.addTest(new ClobAccessTest(
0:                     "testFetchLargeClobPieceByPieceBackwards", iters, reps));
1:             mainSuite.addTest(largeSuite);
1:         }
1:         if (!disableConcurrencyTest) {
1:             mainSuite.addTest(new ClobAccessTest("testConcurrency", 1, 1));
1:         }
1:         return new CleanDatabaseTestSetup(mainSuite) {
1:             protected void decorateSQL(Statement stmt)
1:                     throws SQLException {
1:                 initializeClobData(stmt);
1:             }
1:         };
1:     }
1: 
1:     /**
1:      * Fetches a number of small Clobs, getting the content using getSubString.
1:      * <p>
1:      * The exact length of the clob is used when getting the string.
1:      */
1:     public void testFetchSmallClobs()
1:             throws SQLException {
1:         PreparedStatement ps = prepareStatement(
1:                 "select dClob, length from smallClobs");
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next()) {
1:             Clob clob = rs.getClob(1);
1:             int clobLength = rs.getInt(2);
1:             String content = clob.getSubString(1, clobLength);
1:         }
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Fetches a number of small Clobs, getting the content using getSubString.
1:      * <p>
1:      * A too long length of the clob is used when getting the string.
1:      */
1:     public void testFetchSmallClobsInaccurateLength()
1:             throws SQLException {
1:         PreparedStatement ps = prepareStatement(
1:                 "select dClob, length from smallClobs");
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next()) {
1:             Clob clob = rs.getClob(1);
1:             int unusedLength = rs.getInt(2);
1:             String content = clob.getSubString(1, 100);
1:         }
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Test fetching the content after adding a single character at the end.
1:      */
1:     public void testModifySmallClobs()
1:             throws SQLException {
1:         PreparedStatement ps = prepareStatement(
1:                 "select dClob, length from smallClobs");
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next()) {
1:             Clob clob = rs.getClob(1);
1:             int length = rs.getInt(2);
1:             clob.setString(length, "X");
1:             String content = clob.getSubString(1, 100);
1:         }
1:         rs.close();
1:     }
1: 
1:     public void testFetchLargeClobs()
1:             throws IOException, SQLException {
1:         PreparedStatement ps = prepareStatement(
1:                 "select dClob, length from largeClobs");
1:         ResultSet rs = ps.executeQuery();
1:         char[] charBuf = new char[16*1024]; // 16 KB
1:         while (rs.next()) {
1:             Clob clob = rs.getClob(1);
1:             Reader content = clob.getCharacterStream();
1:             long remaining = rs.getInt(2);
1:             while (remaining > 0) {
1:                 remaining -= content.read(charBuf);
1:             }
1:             content.close();
1:         }
1:         rs.close();
1:     }
1: 
1:     public void testFetchLargeClobsModified()
1:             throws IOException, SQLException {
1:         PreparedStatement ps = prepareStatement(
1:                 "select dClob, length from largeClobs");
1:         ResultSet rs = ps.executeQuery();
1:         char[] charBuf = new char[16*1024]; // 16 KB
1:         while (rs.next()) {
1:             Clob clob = rs.getClob(1);
1:             clob.setString(1, "X");
1:             Reader content = clob.getCharacterStream();
1:             long remaining = rs.getInt(2);
1:             while (remaining > 0) {
1:                 remaining -= content.read(charBuf);
1:             }
1:             content.close();
1:         }
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Fetches a single Clob and reads it char by char, but utilizing a
1:      * buffered stream to get a lower time bound on the read operation.
1:      */
1:     public void testFetchLargeClobOneByOneCharBaseline()
1:             throws IOException, SQLException {
1:         // Select just one Clob.
1:         PreparedStatement ps = prepareStatement(
1:                 "select dClob, length from largeClobs where id = 4");
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next()) {
1:             Clob clob = rs.getClob(1);
1:             Reader content = clob.getCharacterStream();
1:             BufferedReader bufferedContent = new BufferedReader(content);
1:             long remaining = rs.getInt(2);
1:             while (bufferedContent.read() != -1) {
1:                 remaining--;
1:             }
1:             content.close();
1:             assertEquals(0, remaining);
1:         }
1:         rs.close();
1:     }
1: 
1:     public void testFetchLargeClobOneByOneChar()
1:             throws IOException, SQLException {
1:         // Select just one Clob.
1:         PreparedStatement ps = prepareStatement(
1:                 "select dClob, length from largeClobs where id = 4");
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next()) {
1:             Clob clob = rs.getClob(1);
1:             Reader content = clob.getCharacterStream();
1:             long remaining = rs.getInt(2);
1:             while (content.read() != -1) {
1:                 remaining--;
1:             }
1:             content.close();
1:             assertEquals(0, remaining);
1:         }
1:         rs.close();
1:     }
1: 
1:     public void testFetchLargeClobOneByOneCharModified()
1:             throws IOException, SQLException {
1:         // Select just one Clob.
1:         PreparedStatement ps = prepareStatement(
1:                 "select dClob, length from largeClobs where id = 4");
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next()) {
1:             Clob clob = rs.getClob(1);
1:             long remaining = rs.getInt(2);
1:             clob.setString(++remaining, "X");
1:             Reader content = clob.getCharacterStream();
1:             while (content.read() != -1) {
1:                 remaining --;
1:             }
1:             content.close();
1:             assertEquals(0, remaining);
1:         }
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Tests that repositioning within the current internal character buffer is
1:      * cheap.
1:      * <p>
1:      * Note that the positions used in this test have been chosen based on the
1:      * internal buffer size (8KB), which is an implementation detail.
1:      *
1:      * @throws SQLException if the test fails
1:      */
1:     public void testFetchLargeClobPieceByPieceBackwards()
1:             throws IOException, SQLException {
1:         boolean modifyClob = false;
1:         final int intBufSize = 8192; // Implementation detail.
1:         // Select just one Clob.
1:         PreparedStatement ps = prepareStatement(
1:                 "select dClob, length from largeClobs where id = 4");
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next()) {
1:             Clob clob = rs.getClob(1);
1:             int remaining = rs.getInt(2);
1:             if (modifyClob) {
1:                 // Modify the Clob to create a temporary copy in memory or on
1:                 // disk (depends on the Clob size).
1:                 long modifyStart = System.currentTimeMillis();
1:                 clob.setString(++remaining, "X");
1:                 println("Clob modification duration: " +
1:                         (System.currentTimeMillis() - modifyStart) + " ms");
1:             }
1:             // Go close to the middle of the Clob on a buffer border, then
1:             // subtract the piece size to avoid repositioning.
1:             final int pieceSize = 10;
1:             final long pos = (remaining / 2 / intBufSize) *
1:                     intBufSize - pieceSize;
1:             for (int i=0; i < intBufSize; i += pieceSize) {
1:                 String str = clob.getSubString(
1:                         pos -i, pieceSize);
1:             }
1:         }
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Fetches a "large" Clob piece by piece using getSubString.
1:      */
1:     public void testFetchLargeClobPieceByPiece()
1:             throws IOException, SQLException {
1:         fetchPieceByPiece(false);
1:     }
1: 
1:     /**
1:      * Fetches a "large" Clob piece by piece using getSubString.
1:      * <p>
1:      * The Clob is modified before fetched to create a temporary Clob
1:      * representation in memory / on disk.
1:      */
1:     public void testFetchLargeClobPieceByPieceModified()
1:             throws IOException, SQLException {
1:         fetchPieceByPiece(true);
1:     }
1:     
1:     /**
1:      * Fetches a "large" Clob piece by piece using getSubString.
1:      *
1:      * @param modifyClob whether to modify the Clob before fetching it
1:      *      (determines the internal Derby Clob representation)
1:      */
1:     private void fetchPieceByPiece(final boolean modifyClob)
1:             throws IOException, SQLException {
1:         // Select just one Clob.
1:         PreparedStatement ps = prepareStatement(
1:                 "select dClob, length from largeClobs where id = 4");
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next()) {
1:             Clob clob = rs.getClob(1);
1:             int remaining = rs.getInt(2);
1:             Reader myReader = new LoopingAlphabetReader(remaining);
1:             if (modifyClob) {
1:                 // Modify the Clob to create a temporary copy in memory or on
1:                 // disk (depends on the Clob size).
1:                 long modifyStart = System.currentTimeMillis();
1:                 clob.setString(++remaining, "X");
1:                 println("Clob modification duration: " +
1:                         (System.currentTimeMillis() - modifyStart) + " ms");
1:             }
1:             long pos = 1;
1:             while (remaining > 0) {
1:                 String str = clob.getSubString(
1:                         pos, Math.min(MAX_BSIZE, remaining));
1:                 myReader.skip(Math.min(MAX_BSIZE, remaining) -1);
1:                 pos += str.length();
1:                 remaining -= str.length();
1:                 // Avoid failure on the last char when Clob is modified.
1:                 if (!modifyClob || remaining != 0) {
1:                     assertEquals(myReader.read(), str.charAt(str.length() -1));
1:                 }
1:             }
1:         }
1:         rs.close();
1:     }
1: 
1:     public void testFetchLargeClobWithStream()
1:             throws IOException, SQLException {
1:         boolean modifyClob = false;
1:         // Select just one Clob.
1:         PreparedStatement ps = prepareStatement(
1:                 "select dClob, length from largeClobs where id = 5");
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next()) {
1:             Clob clob = rs.getClob(1);
1:             int remaining = rs.getInt(2);
1:             Reader myReader = new LoopingAlphabetReader(remaining);
1:             if (modifyClob) {
1:                 // Modify the Clob to create a temporary copy in memory or on
1:                 // disk (depends on the Clob size).
1:                 long modifyStart = System.currentTimeMillis();
1:                 clob.setString(++remaining, "X");
1:                 println("Clob modification duration: " +
1:                         (System.currentTimeMillis() - modifyStart) + " ms");
1:             }
1:             Reader clobReader = clob.getCharacterStream();
1:             char[] buf = new char[MAX_BSIZE];
1:             while (remaining > 0) {
1:                 int read = clobReader.read(buf, 0, Math.min(MAX_BSIZE, remaining));
1:                 myReader.skip(read -1);
1:                 remaining -= read;
1:                 assertEquals(myReader.read(), buf[read -1]);
1:             }
1:         }
1:         rs.close();
1:         
1:     }
1: 
1:     /**
1:      * Tests if the Clob length is cached.
1:      */
1:     public void testLargeClobGetLength() throws SQLException {
1:         // Select just one Clob.
1:         PreparedStatement ps = prepareStatement(
1:                 "select dClob, length from largeClobs where id = 7");
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next()) {
1:             Clob clob = rs.getClob(1);
1:             long remaining = rs.getInt(2);
1:             // This should be cached. Lots of data have to be skipped otherwise.
1:             for (int i=0; i < 50; i++) {
1:                 assertEquals(remaining, clob.length());
1:             }
1:         }
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Tests if the Clob length is cached.
1:      */
1:     public void testLargeClobGetLengthModified() throws SQLException {
1:         // Select just one Clob.
1:         PreparedStatement ps = prepareStatement(
1:                 "select dClob, length from largeClobs where id = 7");
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next()) {
1:             Clob clob = rs.getClob(1);
1:             clob.setString(1, "X");
1:             long remaining = rs.getInt(2);
1:             // This should be cached. Lots of data have to be skipped otherwise.
1:             for (int i=0; i < 50; i++) {
1:                 assertEquals(remaining, clob.length());
1:             }
1:         }
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Runs a test using multiple threads.
1:      * <p>
1:      * This test intends to detect problems with small Clobs and general
1:      * problems with concurrency.
1:      * <p>
1:      * <b>NOTE</b>: To produce more reliable numbers, please run the performance
1:      * client independently outside this JUnit test framework. Performance also
1:      * suffers greatly with SANE builds.
1:      */
1:     public void testConcurrency()
1:             throws InterruptedException, SQLException {
1: 
1:         final int records = 100000;
1:         final int tables = 1;
1:         final int threads = 16;
1:         DBFiller filler = new SingleRecordFiller(
1:                 records, tables, java.sql.Types.CLOB, false, false);
1:         Connection conn = getConnection();
1:         println("initializing database...");
1:         filler.fill(conn);
1:         conn.close();
1: 
1:         Client[] clients = new Client[threads];
1:         for (int i = 0; i < clients.length; i++) {
1:             Connection c = openDefaultConnection();
1:             c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:             clients[i] = new SingleRecordSelectClient(
1:                     records, tables, java.sql.Types.CLOB, false, false);
1:             clients[i].init(c);
1:         }
1: 
1:         final int warmupSec = 30;
1:         final int steadySec = 60;
1:         LoadGenerator gen = new BackToBackLoadGenerator();
1:         gen.init(clients);
1:         println("starting warmup...");
1:         gen.startWarmup();
1:         Thread.sleep(1000L * warmupSec);
1:         println("entering steady state...");
1:         gen.startSteadyState();
1:         Thread.sleep(1000L * steadySec);
1:         println("stopping threads...");
1:         gen.stop();
1:         // Should get the printstream used by the test harness here.
1:         gen.printReport(System.out);
1:     }
1: 
1:     /**
1:      * Generates test data.
1:      */
1:     private static void initializeClobData(Statement stmt)
1:             throws SQLException {
1:         Connection con = stmt.getConnection();
1:         con.setAutoCommit(false);
1:         if (!disableSmallClobs) {
1:             println("Generating small Clobs test data.");
1:             // Insert small Clob data.
1:             try {
1:                 stmt.executeUpdate("drop table smallClobs");
1:             } catch (SQLException sqle) {
1:                 assertSQLState("42Y55", sqle);
1:             }
1:             stmt.executeUpdate(
1:                     "create table smallClobs (dClob clob, length int)");
1:             PreparedStatement smallClobInsert = con.prepareStatement(
1:                     "insert into smallClobs values (?,?)");
1:             // Insert 15 000 small clobs.
1:             for (int clobCounter = 1; clobCounter < 15001; clobCounter++) {
1:                 String content = Integer.toString(clobCounter);
1:                 smallClobInsert.setString(1, content);
1:                 smallClobInsert.setInt(2, content.length());
1:                 smallClobInsert.executeUpdate();
1:                 if (clobCounter % 1000 == 0) {
1:                     con.commit();
1:                 }
1:             }
1:             con.commit();
1:         }
1: 
1:         if (!disableLargeClobs) {
1:             println("Generating large Clobs test data.");
1:             // Insert large Clob data.
1:             try {
1:                 stmt.executeUpdate("drop table largeClobs");
1:             } catch (SQLException sqle) {
1:                 assertSQLState("42Y55", sqle);
1:             }
1:             stmt.executeUpdate("create table largeClobs (" +
1:                     "id int unique not null, dClob clob, length int)");
1:             PreparedStatement largeClobInsert = con.prepareStatement(
1:                     "insert into largeClobs values (?,?,?)");
1:             // Insert some large Clobs.
1:             final int size = largeClobSizeMB*1024*1024; // 15 MB default
1:             for (int clobCounter = 1; clobCounter < 11; clobCounter++) {
1:                 largeClobInsert.setInt(1, clobCounter);
1:                 largeClobInsert.setCharacterStream(
1:                         2, new LoopingAlphabetReader(size), size);
1:                 largeClobInsert.setInt(3, size);
1:                 largeClobInsert.executeUpdate();
1:                 println("Inserted large Clob #" + (clobCounter -1));
1:             }
1:             con.commit();
1:         }
1:     }
1: }
============================================================================