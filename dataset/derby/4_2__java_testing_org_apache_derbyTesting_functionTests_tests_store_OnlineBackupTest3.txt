2:7ddacaa: /*
4:7ddacaa: 
1:7ddacaa:    Derby - Class org.apache.derbyTesting.functionTests.store.OnlineBackupTest3
1:7ddacaa: 
1:dff95a1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:dff95a1:    contributor license agreements.  See the NOTICE file distributed with
1:dff95a1:    this work for additional information regarding copyright ownership.
1:dff95a1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:dff95a1:    (the "License"); you may not use this file except in compliance with
1:dff95a1:    the License.  You may obtain a copy of the License at
1:7ddacaa: 
1:7ddacaa:       http://www.apache.org/licenses/LICENSE-2.0
1:7ddacaa: 
1:7ddacaa:    Unless required by applicable law or agreed to in writing, software
1:7ddacaa:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ddacaa:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ddacaa:    See the License for the specific language governing permissions and
1:7ddacaa:    limitations under the License.
1:7ddacaa: 
2:7ddacaa:  */
1:7ddacaa: 
1:7ddacaa: package org.apache.derbyTesting.functionTests.tests.store;
1:7ddacaa: import java.sql.Connection;
1:7ddacaa: import java.sql.Statement;
1:7ddacaa: import java.sql.PreparedStatement;
1:7ddacaa: import java.sql.ResultSet;
1:7ddacaa: import java.sql.SQLException;
1:7ddacaa: import org.apache.derby.tools.ij;
1:7ddacaa: import org.apache.derbyTesting.functionTests.util.TestUtil;
1:7ddacaa: 
1:7ddacaa: /*
1:7ddacaa:  * This class tests online backup when jar actions
1:7ddacaa:  * are running in parallel to the backup thread. 
1:7ddacaa:  *
1:7ddacaa:  * @version 1.0
1:7ddacaa:  */
1:7ddacaa: 
1:7ddacaa: public class OnlineBackupTest3 {
1:7ddacaa: 
1:7ddacaa:     private static final String TEST_DATABASE_NAME = "wombat" ;
1:7ddacaa:     private static final String BACKUP_PATH = "extinout/onlinebackuptest3";
1:7ddacaa: 
1:7ddacaa:     public static void main(String[] argv) throws Throwable {
1:7ddacaa: 
1:7ddacaa:         OnlineBackupTest3 test = new OnlineBackupTest3();
1:7ddacaa:         ij.getPropertyArg(argv); 
1:7ddacaa: 
1:7ddacaa:         try {
1:7ddacaa:             test.runTest();
3:7ddacaa:         }
1:7ddacaa:         catch (SQLException sqle) {
1:7ddacaa:             dumpSQLException(sqle);
1:7ddacaa:         } 
1:7ddacaa:     }
1:7ddacaa: 
1:7ddacaa: 
1:7ddacaa:     /*
1:7ddacaa:      * Test online backup with unlogged jar operations running in parallel. 
1:7ddacaa:      */
1:7ddacaa:     private void runTest() throws Exception{
1:7ddacaa:         logMessage("Begin Online Backup Test3");
1:7ddacaa:         Connection conn = ij.startJBMS();
1:7ddacaa:         conn.setAutoCommit(false);
1:7ddacaa:         Statement stmt = conn.createStatement();
1:7ddacaa:         stmt.execute("create table t1(a int ) ");
1:7ddacaa:         stmt.execute("insert into t1 values(1)");
1:7ddacaa:         stmt.execute("insert into t1 values(2)");
1:7ddacaa:         stmt.execute("create table customer(id int , name varchar(100))");
1:7ddacaa:         stmt.execute("insert into customer values(1, 'ABC')");
1:7ddacaa:         stmt.execute("insert into customer values(2, 'XYZ')");
1:7ddacaa:         String crproc = "create procedure addCustomer(id INT, name VARCHAR(100)) " +
1:7ddacaa:             "MODIFIES SQL DATA " + 
1:7ddacaa:             "external name " + 
1:7ddacaa:             "'org.apache.derbyTesting.backupRestore.Customer.addCustomer' " + 
1:7ddacaa:             " language java parameter style java ";
1:7ddacaa:             
1:7ddacaa:         stmt.execute(crproc);
1:7ddacaa: 
1:7ddacaa:         String dvfunc = "create function dv(P1 INT) RETURNS INT NO SQL " +
1:7ddacaa:             " external name 'dbytesting.CodeInAJar.doubleMe' " + 
1:7ddacaa:             " language java parameter style java " ;
1:7ddacaa: 
1:7ddacaa:         stmt.execute(dvfunc) ;
1:7ddacaa:         conn.commit();
1:7ddacaa:         
1:7ddacaa:         logMessage("Initial Setup Complete");
1:7ddacaa: 
1:7ddacaa:         // perform install jar operation with 
1:7ddacaa:         // online backup running in parallel.
1:7ddacaa:         installJarTest();
1:7ddacaa: 
1:7ddacaa:         // perform remove jar operation with 
1:7ddacaa:         // online backup running in parallel.
1:7ddacaa:         removeJarTest();
1:7ddacaa: 
1:7ddacaa:         logMessage("End Online Backup Test3");
1:7ddacaa:     }
1:7ddacaa: 
1:7ddacaa: 
1:7ddacaa:     /**
1:7ddacaa:      * Shutdown the datbase
1:7ddacaa:      * @param  dbName  Name of the database to shutdown.
1:7ddacaa:      */
1:7ddacaa:     void shutdown(String dbName) {
1:7ddacaa: 
1:7ddacaa:         try{
1:7ddacaa:             //shutdown
1:e72bcdd:             TestUtil.getConnection(dbName, "shutdown=true");
1:7ddacaa:         }catch(SQLException se){
1:7ddacaa:             if (se.getSQLState() != null && se.getSQLState().equals("08006"))
1:7ddacaa:                 System.out.println("database shutdown properly");
2:7ddacaa:             else
1:7ddacaa:                 dumpSQLException(se);
1:7ddacaa:         }
1:7ddacaa:     }
1:7ddacaa: 
1:7ddacaa:     /**
1:7ddacaa:      * Write message to the standard output.
1:7ddacaa:      */
1:7ddacaa:     void logMessage(String   str){
1:7ddacaa:         System.out.println(str);
1:7ddacaa:     }
1:7ddacaa: 
1:7ddacaa:     /**
1:7ddacaa:      * dump the SQLException to the standard output.
1:7ddacaa:      */
1:7ddacaa:     static private void dumpSQLException(SQLException sqle) {
1:7ddacaa: 
1:7ddacaa:         org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:7ddacaa:         sqle.printStackTrace(System.out);
1:7ddacaa:     }
1:7ddacaa: 
1:7ddacaa:     
1:7ddacaa:     private int countRows(Connection conn, 
1:7ddacaa:                           String tableName) 
1:7ddacaa:         throws SQLException
2:7ddacaa:     {
1:7ddacaa:         Statement s = conn.createStatement();
1:7ddacaa:         ResultSet rs = s.executeQuery("SELECT count(*) from " +  tableName );
1:7ddacaa:         rs.next();
1:7ddacaa:         int noRows = rs.getInt(1);
1:7ddacaa:         rs.close();
1:7ddacaa:         s.close();
1:7ddacaa:         return noRows;
1:7ddacaa:     }
1:7ddacaa: 
1:7ddacaa:     /*
1:7ddacaa:      * Test install jar running in parallel to backup and vice versa. 
1:7ddacaa:      */
1:7ddacaa:     void installJarTest() throws Exception{
1:7ddacaa:         logMessage("Begin Install Jar Test");
1:e72bcdd:         Connection conn1 = TestUtil.getConnection(TEST_DATABASE_NAME, null);
1:7ddacaa:         conn1.setAutoCommit(false);
1:7ddacaa:         Statement conn1_stmt = conn1.createStatement();
1:e72bcdd:         Connection conn2 = TestUtil.getConnection(TEST_DATABASE_NAME, null);
1:7ddacaa:         conn2.setAutoCommit(false);
1:7ddacaa:         Statement conn2_stmt = conn2.createStatement();
1:7ddacaa: 
1:7ddacaa:         
1:7ddacaa:         conn1_stmt.execute(
1:7ddacaa:            "call sqlj.install_jar('extin/brtestjar.jar', 'math_routines', 0)");
1:7ddacaa:         
1:7ddacaa:         try {
1:7ddacaa:             // followng backup call should fail because jar operation is pending 
1:7ddacaa:            conn2_stmt.execute(
1:7ddacaa:             "call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_NOWAIT('extinout/mybackup')");
1:7ddacaa:         } catch (SQLException sqle) {
1:7ddacaa:             //above statement should have failed. 
1:7ddacaa:             org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:7ddacaa:         }
1:7ddacaa: 
1:7ddacaa:         // invoke backup in another thread, it should block for the above install jar 
1:7ddacaa:         // operation to install  'brtestjar.jar to commit.
1:7ddacaa:         
1:7ddacaa:         // start a  thread to perform online backup
1:7ddacaa:         OnlineBackup backup = new OnlineBackup(TEST_DATABASE_NAME, BACKUP_PATH);
1:7ddacaa:         Thread backupThread = new Thread(backup, "BACKUP1");
1:7ddacaa:         backupThread.start();
1:7ddacaa:         // wait for the backup to start
1:7ddacaa:         backup.waitForBackupToBegin();
1:7ddacaa:         logMessage("Backup-1 Started");
1:7ddacaa: 
1:7ddacaa:         // sleep for few seconds just to make sure backup thread has actually
1:7ddacaa:         // gone into a wait state for unlogged actions to commit.
1:7ddacaa:         java.lang.Thread.sleep(1000);
1:7ddacaa:         
1:7ddacaa:         // backup should not even start doing real work before the
1:7ddacaa:         // unlogged transaction is commited
1:7ddacaa:         if(!backup.isRunning())
1:7ddacaa:             logMessage("Backup is not waiting for unlogged " +  
1:7ddacaa:                        "install jar action to commit");
1:7ddacaa: 
1:7ddacaa:         //insert some rows that should appear in the backup.
1:7ddacaa:         conn1_stmt.execute("insert into t1 values(3)");
1:7ddacaa:         conn1_stmt.execute("insert into t1 values(4)");
1:7ddacaa:         conn1_stmt.execute("insert into t1 values(5)");
1:7ddacaa:         
1:7ddacaa:         // set the database class with both the jars  installed above.
1:7ddacaa:         conn1_stmt.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY( " + 
1:7ddacaa:                            "'derby.database.classpath', " + 
1:7ddacaa:                            "'APP.math_routines') " ) ;
1:7ddacaa: 
1:7ddacaa:         //commit the transaction with jar opearation that is blocking the backup.
1:7ddacaa:         conn1.commit();
1:7ddacaa:         logMessage("The transaction that was blocking the backup has ended");
1:7ddacaa: 
1:7ddacaa:         // wait for backup to finish. 
1:7ddacaa:         backup.waitForBackupToEnd();
1:7ddacaa:         backupThread.join();
1:7ddacaa:         logMessage("Backup-1 Completed");
1:7ddacaa:         
1:7ddacaa:         // Case : jar op should block if backup is in progress
1:7ddacaa:         // add a index that will block the backup until it is committted.
1:7ddacaa:         conn1_stmt.execute("create index idx1 on customer(id)");
1:7ddacaa:         conn1_stmt.execute("insert into t1 values(6)");
1:7ddacaa:         
1:7ddacaa:         // start a  thread to perform online backup
1:7ddacaa:         backup = new OnlineBackup(TEST_DATABASE_NAME, BACKUP_PATH);
1:7ddacaa:         backupThread = new Thread(backup, "BACKUP2");
1:7ddacaa:         backupThread.start();
1:7ddacaa:         // wait for the backup to start
1:7ddacaa:         backup.waitForBackupToBegin();
1:7ddacaa:         logMessage("Backup-2 Started");
1:7ddacaa: 
1:7ddacaa:         // sleep for few seconds just to make sure backup thread is actually
1:7ddacaa:         // gone to a wait state for unlogged actions to commit.
1:7ddacaa:         java.lang.Thread.sleep(1000);
1:7ddacaa: 
1:7ddacaa:         // backup should not even start doing real work before the
1:7ddacaa:         // unlogged transaction is commited
1:7ddacaa:         if(!backup.isRunning())
1:7ddacaa:             logMessage("Backup is not waiting for unlogged " +  
1:7ddacaa:                        "index action to commit");
1:7ddacaa: 
1:7ddacaa: 
1:7ddacaa:         // add another jar file  , this one should block and 
1:7ddacaa:         // should not get into the backup. Backup does not allow new 
1:7ddacaa:         // jar operation if it is already waiting for backup blocking
1:7ddacaa:         // to complete(commit/rollback). 
1:7ddacaa: 
1:7ddacaa:         AsyncStatementThread asyncJarActionThread = 
1:7ddacaa:             new AsyncStatementThread(conn2, 
1:7ddacaa:           "call sqlj.install_jar('extin/obtest_customer.jar', 'customer_app', 0)");
1:7ddacaa:         asyncJarActionThread.start();
1:7ddacaa:         logMessage("Started obtest_customer.jar addition in seperate thread");
1:7ddacaa: 
1:7ddacaa:         //sleep for few seconds to give a chance for the 
1:7ddacaa:         //jar addition thread to get into action.
1:7ddacaa:         java.lang.Thread.sleep(1000);
1:7ddacaa: 
1:7ddacaa:         //roll back the index op. Backup should proceed now.
1:7ddacaa:         conn1.rollback();
1:7ddacaa:         logMessage("The transaction that was blocking the backup has ended");
1:7ddacaa: 
1:7ddacaa:         // wait for backup to finish. 
1:7ddacaa:         backup.waitForBackupToEnd();
1:7ddacaa:         backupThread.join();
1:7ddacaa:         logMessage("Backup-2 Completed");
1:7ddacaa:         
1:7ddacaa:         // wait for customer app jar installation to finish now. 
1:7ddacaa:         asyncJarActionThread.join();
1:7ddacaa:         logMessage("obtest_customer.jar addition is complete");
1:7ddacaa: 
1:7ddacaa:         // set the database class with both the jars  installed above.
1:7ddacaa:         conn1_stmt.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY( " + 
1:7ddacaa:                            "'derby.database.classpath', " + 
1:7ddacaa:                            "'APP.customer_app:APP.math_routines') " ) ;
1:7ddacaa:         
1:7ddacaa:         conn1.commit();
1:7ddacaa: 
1:7ddacaa:         // second jar must have got installed after the backup. 
1:7ddacaa:         // call a function in the custome_app jar
1:7ddacaa:         conn1_stmt.execute("call addCustomer(3 , 'John')");
1:7ddacaa:         conn1.commit();
1:7ddacaa:         
1:7ddacaa:         logMessage("No of rows in table t1: " + countRows(conn1, "T1"));
1:7ddacaa:         logMessage("No of rows in table customer: " + 
1:7ddacaa:                    countRows(conn1, "customer"));
1:7ddacaa:         conn1.commit();
1:7ddacaa:         conn2.commit();
1:7ddacaa:         conn1_stmt.close();
1:7ddacaa:         conn2_stmt.close();
1:7ddacaa:         conn1.close();
1:7ddacaa:         conn2.close();
1:7ddacaa:         
1:7ddacaa:         //shutdown the test db 
1:7ddacaa:         shutdown(TEST_DATABASE_NAME);
1:7ddacaa:         // restore the database from the backup and run some checks 
1:7ddacaa:         backup.restoreFromBackup();
1:7ddacaa:         logMessage("Restored From the Backup");
1:e72bcdd:         Connection conn = TestUtil.getConnection(TEST_DATABASE_NAME, null);
1:7ddacaa:         Statement stmt = conn.createStatement();
1:7ddacaa:         logMessage("No of rows in table t1: " + countRows(conn, "T1"));
1:7ddacaa:         logMessage("No of rows in table customer: " + 
1:7ddacaa:                    countRows(conn, "customer"));
1:7ddacaa:         // execute select statement using the "dv" funciont.  
1:7ddacaa:         stmt.execute("select dv(a) from t1");
1:7ddacaa: 
1:7ddacaa:         
1:7ddacaa:         try {
1:7ddacaa:             // set the database class with both the jars  installed above.
1:7ddacaa:             stmt.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY( " + 
1:7ddacaa:                            "'derby.database.classpath', " + 
1:7ddacaa:                            "'APP.customer_app:APP.math_routines') " ) ;
1:7ddacaa:             stmt.execute("call addCustomer(3 , 'John')"); 
1:7ddacaa:         }catch(SQLException se) {
1:7ddacaa:             //ignore for now. No sure way to 
1:7ddacaa:             //check that jar did not get into backup 
1:7ddacaa:             //without debug flags. 
1:7ddacaa:         }
1:7ddacaa: 
1:7ddacaa:         stmt.close();
1:7ddacaa:         conn.close();
1:7ddacaa: 
1:7ddacaa:         //shutdown the test db 
1:7ddacaa:         shutdown(TEST_DATABASE_NAME);
1:7ddacaa:         logMessage("End Of Install Jar Test.");
1:7ddacaa: 
1:7ddacaa:     }
1:7ddacaa: 
1:7ddacaa: 
1:7ddacaa:     /*
1:7ddacaa:      * Test remove jar running in parallel to backup and vice versa. 
1:7ddacaa:      */
1:7ddacaa:     void removeJarTest() throws Exception{
1:7ddacaa:         logMessage("Begin Remove Jar Test");
1:e72bcdd:         Connection conn1 = TestUtil.getConnection(TEST_DATABASE_NAME, null);
1:7ddacaa:         conn1.setAutoCommit(false);
1:7ddacaa:         Statement conn1_stmt = conn1.createStatement();
1:e72bcdd:         Connection conn2 = TestUtil.getConnection(TEST_DATABASE_NAME, null);
1:7ddacaa:         conn2.setAutoCommit(false);
1:7ddacaa:         Statement conn2_stmt = conn2.createStatement();
1:7ddacaa:         try {
1:7ddacaa:             conn1_stmt.execute(
1:7ddacaa:            "call sqlj.install_jar('extin/obtest_customer.jar', 'customer_app', 0)");
1:7ddacaa:         }catch(SQLException se) {
1:7ddacaa:             //it is ok if was jar already there.
1:7ddacaa:         }
1:7ddacaa: 
1:7ddacaa:         // remove both the jars from the class path , 
1:7ddacaa:         // so that we can remove them from the database. 
1:7ddacaa:         conn1_stmt.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY( " + 
1:7ddacaa:                         "'derby.database.classpath', '')") ;
1:7ddacaa:         conn1.commit();
1:7ddacaa: 
1:7ddacaa:         conn1_stmt.execute(
1:7ddacaa:            "call sqlj.remove_jar('APP.math_routines', 0)");
1:7ddacaa:         
1:7ddacaa:         // Case 0: backup call that is not waiting for unlogged 
1:7ddacaa:         // opereation to complete should fail when a remove jar 
1:7ddacaa:         // is not ended when backup started. 
1:7ddacaa: 
1:7ddacaa:         try {
1:7ddacaa:             // followng backup call should fail because remove 
1:7ddacaa:             // jar operation is pending 
1:7ddacaa:            conn2_stmt.execute(
1:7ddacaa:             "call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_NOWAIT('extinout/mybackup')");
1:7ddacaa:         } catch (SQLException sqle) {
1:7ddacaa:             //above statement should have failed. 
1:7ddacaa:             org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:7ddacaa:         }
1:7ddacaa: 
1:7ddacaa: 
1:7ddacaa:                 
1:7ddacaa:         // Case 1: backup should block because when a remove jar
1:7ddacaa:         // is not ended when backup started. 
1:7ddacaa: 
1:7ddacaa:         // invoke backup in another thread, should block for 
1:7ddacaa:         // the above remove jar  to commit.
1:7ddacaa:         
1:7ddacaa:         // start a  thread to perform online backup
1:7ddacaa:         OnlineBackup backup = new OnlineBackup(TEST_DATABASE_NAME, BACKUP_PATH);
1:7ddacaa:         Thread backupThread = new Thread(backup, "BACKUP3");
1:7ddacaa:         backupThread.start();
1:7ddacaa:         // wait for the backup to start
1:7ddacaa:         backup.waitForBackupToBegin();
1:7ddacaa:         logMessage("Backup-3 Started");
1:7ddacaa: 
1:7ddacaa:         // sleep for few seconds just to make sure backup thread is actually
1:7ddacaa:         // gone to a wait state for unlogged actions to commit.
1:7ddacaa:         java.lang.Thread.sleep(1000);
1:7ddacaa: 
1:7ddacaa:         // backup should not even start doing real work before the
1:7ddacaa:         // unlogged transaction is commited
1:7ddacaa:         if(!backup.isRunning())
1:7ddacaa:             logMessage("Backup is not waiting for unlogged " +  
1:7ddacaa:                        "remove jar action to commit");
1:7ddacaa: 
1:7ddacaa:         //insert some rows that should appear in the backup.
1:7ddacaa:         conn1_stmt.execute("insert into t1 values(10)");
1:7ddacaa:         conn1_stmt.execute("insert into t1 values(11)");
1:7ddacaa: 
1:7ddacaa:         //commit the transaction with jar opearation that is blocking the backup.
1:7ddacaa:         conn1.commit();
1:7ddacaa:         logMessage("The transaction that was blocking the backup has ended");
1:7ddacaa:         
1:7ddacaa:         // wait for backup to finish. 
1:7ddacaa:         backup.waitForBackupToEnd();
1:7ddacaa:         backupThread.join();
1:7ddacaa: 
1:7ddacaa:         logMessage("Backup-3 Completed");
1:7ddacaa:         
1:7ddacaa:         // Case 2: remove jar op should block if backup is in progress
1:7ddacaa:         // add a index that will block the backup until it is committted.
1:7ddacaa:         conn1_stmt.execute("create index idx1 on customer(id)");
1:7ddacaa:         conn1_stmt.execute("insert into t1 values(12)");
1:7ddacaa:         
1:7ddacaa:         // start a  thread to perform online backup
1:7ddacaa:         backup = new OnlineBackup(TEST_DATABASE_NAME, BACKUP_PATH);
1:7ddacaa:         backupThread = new Thread(backup, "BACKUP4");
1:7ddacaa:         backupThread.start();
1:7ddacaa:         // wait for the backup to start
1:7ddacaa:         backup.waitForBackupToBegin();
1:7ddacaa:         logMessage("Backup-4 Started");
1:7ddacaa: 
1:7ddacaa:         // sleep for few seconds just to make sure backup thread is actually
1:7ddacaa:         // gone to a wait state for unlogged actions to commit.
1:7ddacaa:         java.lang.Thread.sleep(1000);
1:7ddacaa: 
1:7ddacaa:         // backup should not even start doing real work before the
1:7ddacaa:         // unlogged transaction is commited
1:7ddacaa:         if(!backup.isRunning())
1:7ddacaa:             logMessage("Backup is not waiting for unlogged " +  
1:7ddacaa:                        "index action to commit");
1:7ddacaa: 
1:7ddacaa: 
1:7ddacaa:         // remove another jar file  , this one should block and 
1:7ddacaa:         // should not get into the backup. Backup does not allow new 
1:7ddacaa:         // jar operation if it is already waiting for backup blocking
1:7ddacaa:         // to complete(commit/rollback). 
1:7ddacaa: 
1:7ddacaa:         AsyncStatementThread asyncJarActionThread = 
1:7ddacaa:             new AsyncStatementThread(conn2, 
1:7ddacaa:           "call sqlj.remove_jar('APP.customer_app', 0)");
1:7ddacaa:         asyncJarActionThread.start();
1:7ddacaa:         logMessage("Started obtest_customer.jar remove in seperate thread");
1:7ddacaa: 
1:7ddacaa:         //sleep for few seconds to give a chance for the 
1:7ddacaa:         //jar addition thread to get into action.
1:7ddacaa:         java.lang.Thread.sleep(1000);
1:7ddacaa: 
1:7ddacaa:         //roll back the index op. Backup should proceed now.
1:7ddacaa:         conn1.rollback();
1:7ddacaa:         logMessage("The transaction that was blocking the backup has ended");
1:7ddacaa:         // wait for backup to finish. 
1:7ddacaa:         backup.waitForBackupToEnd();
1:7ddacaa:         backupThread.join();
1:7ddacaa:         logMessage("Backup-4 Completed");
1:7ddacaa: 
1:7ddacaa:         // wait for customer app jar removal to finish now. 
1:7ddacaa:         asyncJarActionThread.join();
1:7ddacaa:         logMessage("obtest_customer.jar remove is complete");
1:7ddacaa:         
1:7ddacaa:         //this insert should not apprear on restore.
1:7ddacaa:         conn1_stmt.execute("insert into t1 values(13)");
1:7ddacaa: 
1:7ddacaa:         logMessage("No of rows in table t1: " + countRows(conn1, "T1"));
1:7ddacaa:         logMessage("No of rows in table customer: " + 
1:7ddacaa:                    countRows(conn1, "customer"));
1:7ddacaa:         conn1.commit();
1:7ddacaa:         conn2.commit();
1:7ddacaa:         conn1_stmt.close();
1:7ddacaa:         conn2_stmt.close();
1:7ddacaa:         conn1.close();
1:7ddacaa:         conn2.close();
1:7ddacaa:         
1:7ddacaa:         //shutdown the test db 
1:7ddacaa:         shutdown(TEST_DATABASE_NAME);
1:7ddacaa:         // restore the database from the backup and run some checks 
1:7ddacaa:         backup.restoreFromBackup();
1:7ddacaa:         logMessage("Restored From the Backup");
1:e72bcdd:         Connection conn = TestUtil.getConnection(TEST_DATABASE_NAME, null);
1:7ddacaa:         Statement stmt = conn.createStatement();
1:7ddacaa:         logMessage("No of rows in table t1: " + countRows(conn, "T1"));
1:7ddacaa:         logMessage("No of rows in table customer: " + 
1:7ddacaa:                    countRows(conn, "customer"));
1:7ddacaa: 
1:7ddacaa:         // check if the jar removal was successful.
1:7ddacaa:         // APP.math_routines should not be in backup.
1:7ddacaa:         try {
1:7ddacaa:             // set the database class path with the jar removed above, 
1:7ddacaa:             // it should fail.
1:7ddacaa:             stmt.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY( " + 
1:7ddacaa:                            "'derby.database.classpath', " + 
1:7ddacaa:                            "'APP.math_routines') " ) ;
1:7ddacaa:         }catch (SQLException sqle) {
1:7ddacaa:             //above statement should have failed. 
1:7ddacaa:             org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:7ddacaa:         }
1:7ddacaa:         
1:7ddacaa: 
1:7ddacaa:         stmt.close();
1:7ddacaa:         conn.close();
1:7ddacaa: 
1:7ddacaa:         //shutdown the test db 
1:7ddacaa:         shutdown(TEST_DATABASE_NAME);
1:7ddacaa:         logMessage("End Of Remove Jar Test.");
1:7ddacaa: 
1:7ddacaa:     }
1:7ddacaa: 
1:7ddacaa: 
1:7ddacaa:     /*
1:7ddacaa:      * Run a sql statement in a seperate thread. 
1:7ddacaa:      */
1:7ddacaa:     class AsyncStatementThread extends Thread {
2:7ddacaa:         Connection conn;
1:7ddacaa:         String stmt;
1:7ddacaa:     
1:7ddacaa:         AsyncStatementThread(Connection conn, String stmt) {
1:7ddacaa:             this.conn = conn;
1:7ddacaa:             this.stmt = stmt;
1:7ddacaa:         }
1:7ddacaa: 
1:7ddacaa:         public void run() {
1:7ddacaa:             Statement aStatement = null;
1:7ddacaa:             try {
1:7ddacaa:                 aStatement = conn.createStatement();
1:7ddacaa:                 aStatement.execute(stmt);
1:7ddacaa:                 aStatement.close();
1:7ddacaa:                 // commit here, it is possible that 
1:7ddacaa:                 // this thread may have got into action 
1:7ddacaa:                 // before the backup went into wait state.
1:7ddacaa:                 conn.commit();
1:7ddacaa:             } catch (SQLException sqle) {
1:7ddacaa:                 org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:7ddacaa:                 sqle.printStackTrace(System.out);
1:7ddacaa:             }
1:7ddacaa:             aStatement = null;
1:7ddacaa:         }
1:7ddacaa:     }
1:7ddacaa: 
1:7ddacaa: }
============================================================================
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:dff95a1
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:e72bcdd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             TestUtil.getConnection(dbName, "shutdown=true");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Connection conn1 = TestUtil.getConnection(TEST_DATABASE_NAME, null);
1:         Connection conn2 = TestUtil.getConnection(TEST_DATABASE_NAME, null);
/////////////////////////////////////////////////////////////////////////
1:         Connection conn = TestUtil.getConnection(TEST_DATABASE_NAME, null);
/////////////////////////////////////////////////////////////////////////
1:         Connection conn1 = TestUtil.getConnection(TEST_DATABASE_NAME, null);
1:         Connection conn2 = TestUtil.getConnection(TEST_DATABASE_NAME, null);
/////////////////////////////////////////////////////////////////////////
1:         Connection conn = TestUtil.getConnection(TEST_DATABASE_NAME, null);
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:7ddacaa
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.store.OnlineBackupTest3
1: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.store;
1: import java.sql.Connection;
0: import java.sql.DriverManager;
1: import java.sql.Statement;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import org.apache.derby.tools.ij;
1: import org.apache.derbyTesting.functionTests.util.TestUtil;
0: import java.util.Properties;
1: 
1: /*
1:  * This class tests online backup when jar actions
1:  * are running in parallel to the backup thread. 
1:  *
0:  * @author <a href="mailto:suresh.thalamati@gmail.com">Suresh Thalamati</a>
1:  * @version 1.0
1:  */
1: 
1: public class OnlineBackupTest3 {
1: 
1:     private static final String TEST_DATABASE_NAME = "wombat" ;
1:     private static final String BACKUP_PATH = "extinout/onlinebackuptest3";
1: 
1:     public static void main(String[] argv) throws Throwable {
1: 
1:         OnlineBackupTest3 test = new OnlineBackupTest3();
1:         ij.getPropertyArg(argv); 
1: 
1:         try {
1:             test.runTest();
1:         }
1:         catch (SQLException sqle) {
1:             dumpSQLException(sqle);
1:         } 
1:     }
1: 
1: 
1:     /*
1:      * Test online backup with unlogged jar operations running in parallel. 
1:      */
1:     private void runTest() throws Exception{
1:         logMessage("Begin Online Backup Test3");
1:         Connection conn = ij.startJBMS();
1:         conn.setAutoCommit(false);
1:         Statement stmt = conn.createStatement();
1:         stmt.execute("create table t1(a int ) ");
1:         stmt.execute("insert into t1 values(1)");
1:         stmt.execute("insert into t1 values(2)");
1:         stmt.execute("create table customer(id int , name varchar(100))");
1:         stmt.execute("insert into customer values(1, 'ABC')");
1:         stmt.execute("insert into customer values(2, 'XYZ')");
1:         String crproc = "create procedure addCustomer(id INT, name VARCHAR(100)) " +
1:             "MODIFIES SQL DATA " + 
1:             "external name " + 
1:             "'org.apache.derbyTesting.backupRestore.Customer.addCustomer' " + 
1:             " language java parameter style java ";
1:             
1:         stmt.execute(crproc);
1: 
1:         String dvfunc = "create function dv(P1 INT) RETURNS INT NO SQL " +
1:             " external name 'dbytesting.CodeInAJar.doubleMe' " + 
1:             " language java parameter style java " ;
1: 
1:         stmt.execute(dvfunc) ;
1:         conn.commit();
1:         
1:         logMessage("Initial Setup Complete");
1: 
1:         // perform install jar operation with 
1:         // online backup running in parallel.
1:         installJarTest();
1: 
1:         // perform remove jar operation with 
1:         // online backup running in parallel.
1:         removeJarTest();
1: 
1:         logMessage("End Online Backup Test3");
1:     }
1: 
1: 
1:     /**
1:      * Shutdown the datbase
1:      * @param  dbName  Name of the database to shutdown.
1:      */
1:     void shutdown(String dbName) {
1: 
1:         try{
1:             //shutdown
0:             if(TestUtil.HAVE_DRIVER_CLASS)
0:                 DriverManager.getConnection("jdbc:derby:" + dbName + ";shutdown=true");
1:             else 
0:                 TestUtil.shutdownUsingDataSource(dbName);
1:         }catch(SQLException se){
1:             if (se.getSQLState() != null && se.getSQLState().equals("08006"))
1:                 System.out.println("database shutdown properly");
1:             else
1:                 dumpSQLException(se);
1:         }
1:     }
1: 
1:     /*
0:      * get connection to the test database
1:      */
0:     Connection getConnection() throws SQLException 
1:     {
1:         Connection conn;
0:         if(TestUtil.HAVE_DRIVER_CLASS)
0:             conn = DriverManager.getConnection("jdbc:derby:" + TEST_DATABASE_NAME );
0:         else {
0:             Properties prop = new Properties();
0:             prop.setProperty("databaseName", TEST_DATABASE_NAME);
0:             conn = TestUtil.getDataSourceConnection(prop);
1:         }
0:         return conn;
1:     }
1: 
1: 
1:     /**
1:      * Write message to the standard output.
1:      */
1:     void logMessage(String   str){
1:         System.out.println(str);
1:     }
1: 
1:     /**
1:      * dump the SQLException to the standard output.
1:      */
1:     static private void dumpSQLException(SQLException sqle) {
1: 
1:         org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:         sqle.printStackTrace(System.out);
1:     }
1: 
1:     
1:     private int countRows(Connection conn, 
1:                           String tableName) 
1:         throws SQLException
1:     {
1:         Statement s = conn.createStatement();
1:         ResultSet rs = s.executeQuery("SELECT count(*) from " +  tableName );
1:         rs.next();
1:         int noRows = rs.getInt(1);
1:         rs.close();
1:         s.close();
1:         return noRows;
1:     }
1: 
1:     /*
1:      * Test install jar running in parallel to backup and vice versa. 
1:      */
1:     void installJarTest() throws Exception{
1:         logMessage("Begin Install Jar Test");
0:         Connection conn1 = getConnection();
1:         conn1.setAutoCommit(false);
1:         Statement conn1_stmt = conn1.createStatement();
0:         Connection conn2 = getConnection();
1:         conn2.setAutoCommit(false);
1:         Statement conn2_stmt = conn2.createStatement();
1: 
1:         
1:         conn1_stmt.execute(
1:            "call sqlj.install_jar('extin/brtestjar.jar', 'math_routines', 0)");
1:         
1:         try {
1:             // followng backup call should fail because jar operation is pending 
1:            conn2_stmt.execute(
1:             "call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_NOWAIT('extinout/mybackup')");
1:         } catch (SQLException sqle) {
1:             //above statement should have failed. 
1:             org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:         }
1: 
1:         // invoke backup in another thread, it should block for the above install jar 
1:         // operation to install  'brtestjar.jar to commit.
1:         
1:         // start a  thread to perform online backup
1:         OnlineBackup backup = new OnlineBackup(TEST_DATABASE_NAME, BACKUP_PATH);
1:         Thread backupThread = new Thread(backup, "BACKUP1");
1:         backupThread.start();
1:         // wait for the backup to start
1:         backup.waitForBackupToBegin();
1:         logMessage("Backup-1 Started");
1: 
1:         // sleep for few seconds just to make sure backup thread has actually
1:         // gone into a wait state for unlogged actions to commit.
1:         java.lang.Thread.sleep(1000);
1:         
1:         // backup should not even start doing real work before the
1:         // unlogged transaction is commited
1:         if(!backup.isRunning())
1:             logMessage("Backup is not waiting for unlogged " +  
1:                        "install jar action to commit");
1: 
1:         //insert some rows that should appear in the backup.
1:         conn1_stmt.execute("insert into t1 values(3)");
1:         conn1_stmt.execute("insert into t1 values(4)");
1:         conn1_stmt.execute("insert into t1 values(5)");
1:         
1:         // set the database class with both the jars  installed above.
1:         conn1_stmt.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY( " + 
1:                            "'derby.database.classpath', " + 
1:                            "'APP.math_routines') " ) ;
1: 
1:         //commit the transaction with jar opearation that is blocking the backup.
1:         conn1.commit();
1:         logMessage("The transaction that was blocking the backup has ended");
1: 
1:         // wait for backup to finish. 
1:         backup.waitForBackupToEnd();
1:         backupThread.join();
1:         logMessage("Backup-1 Completed");
1:         
1:         // Case : jar op should block if backup is in progress
1:         // add a index that will block the backup until it is committted.
1:         conn1_stmt.execute("create index idx1 on customer(id)");
1:         conn1_stmt.execute("insert into t1 values(6)");
1:         
1:         // start a  thread to perform online backup
1:         backup = new OnlineBackup(TEST_DATABASE_NAME, BACKUP_PATH);
1:         backupThread = new Thread(backup, "BACKUP2");
1:         backupThread.start();
1:         // wait for the backup to start
1:         backup.waitForBackupToBegin();
1:         logMessage("Backup-2 Started");
1: 
1:         // sleep for few seconds just to make sure backup thread is actually
1:         // gone to a wait state for unlogged actions to commit.
1:         java.lang.Thread.sleep(1000);
1: 
1:         // backup should not even start doing real work before the
1:         // unlogged transaction is commited
1:         if(!backup.isRunning())
1:             logMessage("Backup is not waiting for unlogged " +  
1:                        "index action to commit");
1: 
1: 
1:         // add another jar file  , this one should block and 
1:         // should not get into the backup. Backup does not allow new 
1:         // jar operation if it is already waiting for backup blocking
1:         // to complete(commit/rollback). 
1: 
1:         AsyncStatementThread asyncJarActionThread = 
1:             new AsyncStatementThread(conn2, 
1:           "call sqlj.install_jar('extin/obtest_customer.jar', 'customer_app', 0)");
1:         asyncJarActionThread.start();
1:         logMessage("Started obtest_customer.jar addition in seperate thread");
1: 
1:         //sleep for few seconds to give a chance for the 
1:         //jar addition thread to get into action.
1:         java.lang.Thread.sleep(1000);
1: 
1:         //roll back the index op. Backup should proceed now.
1:         conn1.rollback();
1:         logMessage("The transaction that was blocking the backup has ended");
1: 
1:         // wait for backup to finish. 
1:         backup.waitForBackupToEnd();
1:         backupThread.join();
1:         logMessage("Backup-2 Completed");
1:         
1:         // wait for customer app jar installation to finish now. 
1:         asyncJarActionThread.join();
1:         logMessage("obtest_customer.jar addition is complete");
1: 
1:         // set the database class with both the jars  installed above.
1:         conn1_stmt.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY( " + 
1:                            "'derby.database.classpath', " + 
1:                            "'APP.customer_app:APP.math_routines') " ) ;
1:         
1:         conn1.commit();
1: 
1:         // second jar must have got installed after the backup. 
1:         // call a function in the custome_app jar
1:         conn1_stmt.execute("call addCustomer(3 , 'John')");
1:         conn1.commit();
1:         
1:         logMessage("No of rows in table t1: " + countRows(conn1, "T1"));
1:         logMessage("No of rows in table customer: " + 
1:                    countRows(conn1, "customer"));
1:         conn1.commit();
1:         conn2.commit();
1:         conn1_stmt.close();
1:         conn2_stmt.close();
1:         conn1.close();
1:         conn2.close();
1:         
1:         //shutdown the test db 
1:         shutdown(TEST_DATABASE_NAME);
1:         // restore the database from the backup and run some checks 
1:         backup.restoreFromBackup();
1:         logMessage("Restored From the Backup");
0:         Connection conn = getConnection();
1:         Statement stmt = conn.createStatement();
1:         logMessage("No of rows in table t1: " + countRows(conn, "T1"));
1:         logMessage("No of rows in table customer: " + 
1:                    countRows(conn, "customer"));
1:         // execute select statement using the "dv" funciont.  
1:         stmt.execute("select dv(a) from t1");
1: 
1:         
1:         try {
1:             // set the database class with both the jars  installed above.
1:             stmt.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY( " + 
1:                            "'derby.database.classpath', " + 
1:                            "'APP.customer_app:APP.math_routines') " ) ;
1:             stmt.execute("call addCustomer(3 , 'John')"); 
1:         }catch(SQLException se) {
1:             //ignore for now. No sure way to 
1:             //check that jar did not get into backup 
1:             //without debug flags. 
1:         }
1: 
1:         stmt.close();
1:         conn.close();
1: 
1:         //shutdown the test db 
1:         shutdown(TEST_DATABASE_NAME);
1:         logMessage("End Of Install Jar Test.");
1: 
1:     }
1: 
1: 
1:     /*
1:      * Test remove jar running in parallel to backup and vice versa. 
1:      */
1:     void removeJarTest() throws Exception{
1:         logMessage("Begin Remove Jar Test");
0:         Connection conn1 = getConnection();
1:         conn1.setAutoCommit(false);
1:         Statement conn1_stmt = conn1.createStatement();
0:         Connection conn2 = getConnection();
1:         conn2.setAutoCommit(false);
1:         Statement conn2_stmt = conn2.createStatement();
1:         try {
1:             conn1_stmt.execute(
1:            "call sqlj.install_jar('extin/obtest_customer.jar', 'customer_app', 0)");
1:         }catch(SQLException se) {
1:             //it is ok if was jar already there.
1:         }
1: 
1:         // remove both the jars from the class path , 
1:         // so that we can remove them from the database. 
1:         conn1_stmt.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY( " + 
1:                         "'derby.database.classpath', '')") ;
1:         conn1.commit();
1: 
1:         conn1_stmt.execute(
1:            "call sqlj.remove_jar('APP.math_routines', 0)");
1:         
1:         // Case 0: backup call that is not waiting for unlogged 
1:         // opereation to complete should fail when a remove jar 
1:         // is not ended when backup started. 
1: 
1:         try {
1:             // followng backup call should fail because remove 
1:             // jar operation is pending 
1:            conn2_stmt.execute(
1:             "call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_NOWAIT('extinout/mybackup')");
1:         } catch (SQLException sqle) {
1:             //above statement should have failed. 
1:             org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:         }
1: 
1: 
1:                 
1:         // Case 1: backup should block because when a remove jar
1:         // is not ended when backup started. 
1: 
1:         // invoke backup in another thread, should block for 
1:         // the above remove jar  to commit.
1:         
1:         // start a  thread to perform online backup
1:         OnlineBackup backup = new OnlineBackup(TEST_DATABASE_NAME, BACKUP_PATH);
1:         Thread backupThread = new Thread(backup, "BACKUP3");
1:         backupThread.start();
1:         // wait for the backup to start
1:         backup.waitForBackupToBegin();
1:         logMessage("Backup-3 Started");
1: 
1:         // sleep for few seconds just to make sure backup thread is actually
1:         // gone to a wait state for unlogged actions to commit.
1:         java.lang.Thread.sleep(1000);
1: 
1:         // backup should not even start doing real work before the
1:         // unlogged transaction is commited
1:         if(!backup.isRunning())
1:             logMessage("Backup is not waiting for unlogged " +  
1:                        "remove jar action to commit");
1: 
1:         //insert some rows that should appear in the backup.
1:         conn1_stmt.execute("insert into t1 values(10)");
1:         conn1_stmt.execute("insert into t1 values(11)");
1: 
1:         //commit the transaction with jar opearation that is blocking the backup.
1:         conn1.commit();
1:         logMessage("The transaction that was blocking the backup has ended");
1:         
1:         // wait for backup to finish. 
1:         backup.waitForBackupToEnd();
1:         backupThread.join();
1: 
1:         logMessage("Backup-3 Completed");
1:         
1:         // Case 2: remove jar op should block if backup is in progress
1:         // add a index that will block the backup until it is committted.
1:         conn1_stmt.execute("create index idx1 on customer(id)");
1:         conn1_stmt.execute("insert into t1 values(12)");
1:         
1:         // start a  thread to perform online backup
1:         backup = new OnlineBackup(TEST_DATABASE_NAME, BACKUP_PATH);
1:         backupThread = new Thread(backup, "BACKUP4");
1:         backupThread.start();
1:         // wait for the backup to start
1:         backup.waitForBackupToBegin();
1:         logMessage("Backup-4 Started");
1: 
1:         // sleep for few seconds just to make sure backup thread is actually
1:         // gone to a wait state for unlogged actions to commit.
1:         java.lang.Thread.sleep(1000);
1: 
1:         // backup should not even start doing real work before the
1:         // unlogged transaction is commited
1:         if(!backup.isRunning())
1:             logMessage("Backup is not waiting for unlogged " +  
1:                        "index action to commit");
1: 
1: 
1:         // remove another jar file  , this one should block and 
1:         // should not get into the backup. Backup does not allow new 
1:         // jar operation if it is already waiting for backup blocking
1:         // to complete(commit/rollback). 
1: 
1:         AsyncStatementThread asyncJarActionThread = 
1:             new AsyncStatementThread(conn2, 
1:           "call sqlj.remove_jar('APP.customer_app', 0)");
1:         asyncJarActionThread.start();
1:         logMessage("Started obtest_customer.jar remove in seperate thread");
1: 
1:         //sleep for few seconds to give a chance for the 
1:         //jar addition thread to get into action.
1:         java.lang.Thread.sleep(1000);
1: 
1:         //roll back the index op. Backup should proceed now.
1:         conn1.rollback();
1:         logMessage("The transaction that was blocking the backup has ended");
1:         // wait for backup to finish. 
1:         backup.waitForBackupToEnd();
1:         backupThread.join();
1:         logMessage("Backup-4 Completed");
1: 
1:         // wait for customer app jar removal to finish now. 
1:         asyncJarActionThread.join();
1:         logMessage("obtest_customer.jar remove is complete");
1:         
1:         //this insert should not apprear on restore.
1:         conn1_stmt.execute("insert into t1 values(13)");
1: 
1:         logMessage("No of rows in table t1: " + countRows(conn1, "T1"));
1:         logMessage("No of rows in table customer: " + 
1:                    countRows(conn1, "customer"));
1:         conn1.commit();
1:         conn2.commit();
1:         conn1_stmt.close();
1:         conn2_stmt.close();
1:         conn1.close();
1:         conn2.close();
1:         
1:         //shutdown the test db 
1:         shutdown(TEST_DATABASE_NAME);
1:         // restore the database from the backup and run some checks 
1:         backup.restoreFromBackup();
1:         logMessage("Restored From the Backup");
0:         Connection conn = getConnection();
1:         Statement stmt = conn.createStatement();
1:         logMessage("No of rows in table t1: " + countRows(conn, "T1"));
1:         logMessage("No of rows in table customer: " + 
1:                    countRows(conn, "customer"));
1: 
1:         // check if the jar removal was successful.
1:         // APP.math_routines should not be in backup.
1:         try {
1:             // set the database class path with the jar removed above, 
1:             // it should fail.
1:             stmt.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY( " + 
1:                            "'derby.database.classpath', " + 
1:                            "'APP.math_routines') " ) ;
1:         }catch (SQLException sqle) {
1:             //above statement should have failed. 
1:             org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:         }
1:         
1: 
1:         stmt.close();
1:         conn.close();
1: 
1:         //shutdown the test db 
1:         shutdown(TEST_DATABASE_NAME);
1:         logMessage("End Of Remove Jar Test.");
1: 
1:     }
1: 
1: 
1:     /*
1:      * Run a sql statement in a seperate thread. 
1:      */
1:     class AsyncStatementThread extends Thread {
1:         Connection conn;
1:         String stmt;
1:     
1:         AsyncStatementThread(Connection conn, String stmt) {
1:             this.conn = conn;
1:             this.stmt = stmt;
1:         }
1: 
1:         public void run() {
1:             Statement aStatement = null;
1:             try {
1:                 aStatement = conn.createStatement();
1:                 aStatement.execute(stmt);
1:                 aStatement.close();
1:                 // commit here, it is possible that 
1:                 // this thread may have got into action 
1:                 // before the backup went into wait state.
1:                 conn.commit();
1:             } catch (SQLException sqle) {
1:                 org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:                 sqle.printStackTrace(System.out);
1:             }
1:             aStatement = null;
1:         }
1:     }
1: 
1: }
commit:3108341
/////////////////////////////////////////////////////////////////////////
0:     private static final String BACKUP_PATH = "extinout/onlinebackuptest3";
/////////////////////////////////////////////////////////////////////////
0:     private void runTest() throws Exception{
/////////////////////////////////////////////////////////////////////////
0:     void installJarTest() throws Exception{
/////////////////////////////////////////////////////////////////////////
0:         OnlineBackup backup = new OnlineBackup(TEST_DATABASE_NAME, BACKUP_PATH);
/////////////////////////////////////////////////////////////////////////
0:         backup = new OnlineBackup(TEST_DATABASE_NAME, BACKUP_PATH);
/////////////////////////////////////////////////////////////////////////
0:     void removeJarTest() throws Exception{
/////////////////////////////////////////////////////////////////////////
0:         OnlineBackup backup = new OnlineBackup(TEST_DATABASE_NAME, BACKUP_PATH);
/////////////////////////////////////////////////////////////////////////
0:         backup = new OnlineBackup(TEST_DATABASE_NAME, BACKUP_PATH);
commit:402725c
/////////////////////////////////////////////////////////////////////////
0:     private static final String TEST_DATABASE_NAME = "wombat" ;
0:     public static void main(String[] argv) throws Throwable {
0: 
0:         ij.getPropertyArg(argv); 
0:             dumpSQLException(sqle);
0:         } 
0:     /*
0:      * Test online backup with unlogged jar operations running in parallel. 
0:      */
0:     private void runTest() throws SQLException, Exception {
0:         logMessage("Begin Online Backup Test3");
0:         Connection conn = ij.startJBMS();
/////////////////////////////////////////////////////////////////////////
0:         logMessage("End Online Backup Test3");
0:     }
0:     /**
0:      * Shutdown the datbase
0:      * @param  dbName  Name of the database to shutdown.
0:      */
0:     void shutdown(String dbName) {
0: 
0:         try{
0:             //shutdown
0:             if(TestUtil.HAVE_DRIVER_CLASS)
0:                 DriverManager.getConnection("jdbc:derby:" + dbName + ";shutdown=true");
0:             else 
0:                 TestUtil.shutdownUsingDataSource(dbName);
0:         }catch(SQLException se){
0:             if (se.getSQLState() != null && se.getSQLState().equals("08006"))
0:                 System.out.println("database shutdown properly");
0:             else
0:                 dumpSQLException(se);
0:         }
0:     }
0:         Connection conn;
0:         if(TestUtil.HAVE_DRIVER_CLASS)
0:             conn = DriverManager.getConnection("jdbc:derby:" + TEST_DATABASE_NAME );
0:         else {
0:             Properties prop = new Properties();
0:             prop.setProperty("databaseName", TEST_DATABASE_NAME);
0:             conn = TestUtil.getDataSourceConnection(prop);
0:         }
0:     /**
0:      * Write message to the standard output.
0:      */
0:     void logMessage(String   str){
0:         System.out.println(str);
0:     }
0:     /**
0:      * dump the SQLException to the standard output.
0:      */
0:     static private void dumpSQLException(SQLException sqle) {
0: 
0:         org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
0:         sqle.printStackTrace(System.out);
0:     }
/////////////////////////////////////////////////////////////////////////
0:             // followng backup call should fail because jar operation is pending 
0:             "call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_NOWAIT('extinout/mybackup')");
0:             org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
0:         // invoke backup in another thread, it should block for the above install jar 
0:         // operation to install  'brtestjar.jar to commit.
0:         OnlineBackup backup = new OnlineBackup(TEST_DATABASE_NAME);
0:         Thread backupThread = new Thread(backup, "BACKUP1");
0:         backupThread.start();
0:         // wait for the backup to start
0:         backup.waitForBackupToBegin();
0:         logMessage("Backup-1 Started");
0:         // sleep for few seconds just to make sure backup thread has actually
0:         // gone into a wait state for unlogged actions to commit.
0:         java.lang.Thread.sleep(1000);
0:         
0:         // backup should not even start doing real work before the
0:         // unlogged transaction is commited
0:         if(!backup.isRunning())
0:             logMessage("Backup is not waiting for unlogged " +  
0:         conn1_stmt.execute("insert into t1 values(5)");
0:         backupThread.join();
/////////////////////////////////////////////////////////////////////////
0:         backupThread.start();
0:         // wait for the backup to start
0:         backup.waitForBackupToBegin();
0:         logMessage("Backup-2 Started");
0:         // gone to a wait state for unlogged actions to commit.
0:         java.lang.Thread.sleep(1000);
0: 
0:         // backup should not even start doing real work before the
0:         // unlogged transaction is commited
0:         if(!backup.isRunning())
0:             logMessage("Backup is not waiting for unlogged " +  
/////////////////////////////////////////////////////////////////////////
0:         backupThread.join();
/////////////////////////////////////////////////////////////////////////
0:         shutdown(TEST_DATABASE_NAME);
0:         // restore the database from the backup and run some checks 
0:         backup.restoreFromBackup();
0:         logMessage("Restored From the Backup");
/////////////////////////////////////////////////////////////////////////
0:         //shutdown the test db 
0:         shutdown(TEST_DATABASE_NAME);
0:         logMessage("End Of Install Jar Test.");
/////////////////////////////////////////////////////////////////////////
0:         // so that we can remove them from the database. 
/////////////////////////////////////////////////////////////////////////
0:         // Case 0: backup call that is not waiting for unlogged 
0:         // opereation to complete should fail when a remove jar 
0:         // is not ended when backup started. 
0: 
0:             // followng backup call should fail because remove 
0:             "call SYSCS_UTIL.SYSCS_BACKUP_DATABASE_NOWAIT('extinout/mybackup')");
0:             org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
0: 
0: 
0:                 
0:         // Case 1: backup should block because when a remove jar
0:         // is not ended when backup started. 
0: 
0:         OnlineBackup backup = new OnlineBackup(TEST_DATABASE_NAME);
0:         Thread backupThread = new Thread(backup, "BACKUP3");
0:         backupThread.start();
0:         // wait for the backup to start
0:         backup.waitForBackupToBegin();
0:         logMessage("Backup-3 Started");
0:         // gone to a wait state for unlogged actions to commit.
0:         java.lang.Thread.sleep(1000);
0: 
0:         // backup should not even start doing real work before the
0:         // unlogged transaction is commited
0:         if(!backup.isRunning())
0:             logMessage("Backup is not waiting for unlogged " +  
/////////////////////////////////////////////////////////////////////////
0:         backupThread.join();
/////////////////////////////////////////////////////////////////////////
0:         backupThread.start();
0:         // wait for the backup to start
0:         backup.waitForBackupToBegin();
0:         logMessage("Backup-4 Started");
0:         // gone to a wait state for unlogged actions to commit.
0:         java.lang.Thread.sleep(1000);
0: 
0:         // backup should not even start doing real work before the
0:         // unlogged transaction is commited
0:         if(!backup.isRunning())
0:             logMessage("Backup is not waiting for unlogged " +  
/////////////////////////////////////////////////////////////////////////
0:         backupThread.join();
0:         // wait for customer app jar removal to finish now. 
/////////////////////////////////////////////////////////////////////////
0:         shutdown(TEST_DATABASE_NAME);
0:         // restore the database from the backup and run some checks 
0:         backup.restoreFromBackup();
0:         logMessage("Restored From the Backup");
/////////////////////////////////////////////////////////////////////////
0:             // set the database class path with the jar removed above, 
0:             // it should fail.
0:             org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
0:         //shutdown the test db 
0:         shutdown(TEST_DATABASE_NAME);
0:         logMessage("End Of Remove Jar Test.");
/////////////////////////////////////////////////////////////////////////
0:                 sqle.printStackTrace(System.out);
commit:24bbe75
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Derby - Class org.apache.derbyTesting.functionTests.store.OnlineBackupTest3
0: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0: 
0:  */
0: 
0: package org.apache.derbyTesting.functionTests.tests.store;
0: import java.sql.Connection;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import org.apache.derby.tools.ij;
0: import org.apache.derbyTesting.functionTests.util.TestUtil;
0: import java.util.Properties;
0: 
0: /*
0:  * This class tests online backup when jar actions
0:  * are running in parallel to the backup thread. 
0:  *
0:  * @author <a href="mailto:suresh.thalamati@gmail.com">Suresh Thalamati</a>
0:  * @version 1.0
0:  */
0: 
0: public class OnlineBackupTest3 {
0: 
0: 	private static final String TEST_DATABASE_NAME = "wombat" ;
0: 
0: 	public static void main(String[] argv) throws Throwable {
0: 		
0:         OnlineBackupTest3 test = new OnlineBackupTest3();
0:    		ij.getPropertyArg(argv); 
0: 
0:         try {
0:             test.runTest();
0:         }
0:         catch (SQLException sqle) {
0: 			dumpSQLException(sqle);
0: 		} 
0:     }
0: 
0: 
0: 	/*
0: 	 * Test online backup with unlogged jar operations running in parallel. 
0: 	 */
0: 	private void runTest() throws SQLException, Exception {
0: 		logMessage("Begin Online Backup Test3");
0: 		Connection conn = ij.startJBMS();
0:         conn.setAutoCommit(false);
0:         Statement stmt = conn.createStatement();
0:         stmt.execute("create table t1(a int ) ");
0:         stmt.execute("insert into t1 values(1)");
0:         stmt.execute("insert into t1 values(2)");
0:         stmt.execute("create table customer(id int , name varchar(100))");
0:         stmt.execute("insert into customer values(1, 'ABC')");
0:         stmt.execute("insert into customer values(2, 'XYZ')");
0:         String crproc = "create procedure addCustomer(id INT, name VARCHAR(100)) " +
0:             "MODIFIES SQL DATA " + 
0:             "external name " + 
0:             "'org.apache.derbyTesting.backupRestore.Customer.addCustomer' " + 
0:             " language java parameter style java ";
0:             
0:         stmt.execute(crproc);
0: 
0:         String dvfunc = "create function dv(P1 INT) RETURNS INT NO SQL " +
0:             " external name 'dbytesting.CodeInAJar.doubleMe' " + 
0:             " language java parameter style java " ;
0: 
0:         stmt.execute(dvfunc) ;
0:         conn.commit();
0:         
0:         logMessage("Initial Setup Complete");
0: 
0:         // perform install jar operation with 
0:         // online backup running in parallel.
0:         installJarTest();
0: 
0:         // perform remove jar operation with 
0:         // online backup running in parallel.
0:         removeJarTest();
0: 
0: 		logMessage("End Online Backup Test3");
0: 	}
0: 
0: 		
0: 	/**
0: 	 * Shutdown the datbase
0: 	 * @param  dbName  Name of the database to shutdown.
0: 	 */
0: 	void shutdown(String dbName) {
0: 
0: 		try{
0: 			// shutdown 
0:             TestUtil.shutdownUsingDataSource(TEST_DATABASE_NAME);
0: 		}catch(SQLException se){
0: 			if (se.getSQLState() != null && se.getSQLState().equals("08006"))
0: 				System.out.println("database shutdown properly");
0: 			else
0: 				dumpSQLException(se);
0: 		}
0: 	}
0: 
0:     /*
0:      * get connection to the test database
0:      */
0:     Connection getConnection() throws SQLException 
0:     {
0:         Properties prop = new Properties();
0:         prop.setProperty("databaseName", TEST_DATABASE_NAME);
0:         Connection conn = TestUtil.getDataSourceConnection(prop);
0:         return conn;
0:     }
0: 
0: 
0: 	/**
0: 	 * Write message to the standard output.
0: 	 */
0: 	void logMessage(String   str)	{
0: 			System.out.println(str);
0: 	}
0: 
0: 	
0: 	/**
0: 	 * dump the SQLException to the standard output.
0: 	 */
0: 	static private void dumpSQLException(SQLException sqle) {
0: 		
0: 		org.apache.derby.tools.JDBCDisplayUtil.	ShowSQLException(System.out, sqle);
0: 		sqle.printStackTrace(System.out);
0: 	}
0: 
0:     
0:     private int countRows(Connection conn, 
0:                           String tableName) 
0:         throws SQLException
0:     {
0:         Statement s = conn.createStatement();
0:         ResultSet rs = s.executeQuery("SELECT count(*) from " +  tableName );
0:         rs.next();
0:         int noRows = rs.getInt(1);
0:         rs.close();
0:         s.close();
0:         return noRows;
0:     }
0: 
0:     /*
0:      * Test install jar running in parallel to backup and vice versa. 
0:      */
0:     void installJarTest() throws SQLException, Exception{
0:         logMessage("Begin Install Jar Test");
0:         Connection conn1 = getConnection();
0:         conn1.setAutoCommit(false);
0:         Statement conn1_stmt = conn1.createStatement();
0:         Connection conn2 = getConnection();
0:         conn2.setAutoCommit(false);
0:         Statement conn2_stmt = conn2.createStatement();
0: 
0:         
0:         conn1_stmt.execute(
0:            "call sqlj.install_jar('extin/brtestjar.jar', 'math_routines', 0)");
0:         
0:         try {
0:             // followng backup call should because jar operation is pending 
0:            conn2_stmt.execute(
0:             "call SYSCS_UTIL.SYSCS_ONLINE_BACKUP_DATABASE('extinout/mybackup', 0)");
0:         } catch (SQLException sqle) {
0:             //above statement should have failed. 
0:             org.apache.derby.tools.JDBCDisplayUtil.	ShowSQLException(System.out, sqle);
0:         }
0: 
0:         // invoke backup in another thread, should block for the above install jar 
0:         // operation for 'brtestjar.jar to commit.
0:         
0:         // start a  thread to perform online backup
0: 		OnlineBackup backup = new OnlineBackup(TEST_DATABASE_NAME);
0: 		Thread backupThread = new Thread(backup, "BACKUP1");
0: 		backupThread.start();	
0: 		// wait for the backup to start
0: 		backup.waitForBackupToBegin();
0: 		logMessage("Backup-1 Started");
0: 
0:         // sleep for few seconds just to make sure backup thread is actually
0: 		// gone to a wait state for unlogged actions to commit.
0: 		java.lang.Thread.sleep(1000);
0: 			
0: 		// backup should not even start doing real work before the
0: 		// unlogged transaction is commited
0: 		if(!backup.isRunning())
0: 			logMessage("Backup is not waiting for unlogged " +  
0:                        "install jar action to commit");
0: 
0:         //insert some rows that should appear in the backup.
0:         conn1_stmt.execute("insert into t1 values(3)");
0:         conn1_stmt.execute("insert into t1 values(4)");
0: 
0:         
0:         // set the database class with both the jars  installed above.
0:         conn1_stmt.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY( " + 
0:                            "'derby.database.classpath', " + 
0:                            "'APP.math_routines') " ) ;
0: 
0:         //Now commit the jar operation in connection1 for backup to proceed. 
0:         conn1_stmt.execute("insert into t1 values(5)");
0:         //commit the transaction with jar opearation that is blocking the backup.
0:         conn1.commit();
0:         logMessage("The transaction that was blocking the backup has ended");
0: 
0:         // wait for backup to finish. 
0:         backup.waitForBackupToEnd();
0: 		backupThread.join();
0:         logMessage("Backup-1 Completed");
0:         
0:         // Case : jar op should block if backup is in progress
0:         // add a index that will block the backup until it is committted.
0:         conn1_stmt.execute("create index idx1 on customer(id)");
0:         conn1_stmt.execute("insert into t1 values(6)");
0:         
0:         // start a  thread to perform online backup
0:         backup = new OnlineBackup(TEST_DATABASE_NAME);
0:         backupThread = new Thread(backup, "BACKUP2");
0: 		backupThread.start();	
0: 		// wait for the backup to start
0: 		backup.waitForBackupToBegin();
0: 		logMessage("Backup-2 Started");
0: 
0:         // sleep for few seconds just to make sure backup thread is actually
0: 		// gone to a wait state for unlogged actions to commit.
0: 		java.lang.Thread.sleep(1000);
0: 			
0: 		// backup should not even start doing real work before the
0: 		// unlogged transaction is commited
0: 		if(!backup.isRunning())
0: 			logMessage("Backup is not waiting for unlogged " +  
0:                        "index action to commit");
0: 
0: 
0:         // add another jar file  , this one should block and 
0:         // should not get into the backup. Backup does not allow new 
0:         // jar operation if it is already waiting for backup blocking
0:         // to complete(commit/rollback). 
0: 
0:         AsyncStatementThread asyncJarActionThread = 
0:             new AsyncStatementThread(conn2, 
0:           "call sqlj.install_jar('extin/obtest_customer.jar', 'customer_app', 0)");
0:         asyncJarActionThread.start();
0:         logMessage("Started obtest_customer.jar addition in seperate thread");
0: 
0:         //sleep for few seconds to give a chance for the 
0:         //jar addition thread to get into action.
0:         java.lang.Thread.sleep(1000);
0: 
0:         //roll back the index op. Backup should proceed now.
0:         conn1.rollback();
0:         logMessage("The transaction that was blocking the backup has ended");
0: 
0:         // wait for backup to finish. 
0:         backup.waitForBackupToEnd();
0: 		backupThread.join();
0:         logMessage("Backup-2 Completed");
0:         
0:         // wait for customer app jar installation to finish now. 
0:         asyncJarActionThread.join();
0:         logMessage("obtest_customer.jar addition is complete");
0: 
0:         // set the database class with both the jars  installed above.
0:         conn1_stmt.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY( " + 
0:                            "'derby.database.classpath', " + 
0:                            "'APP.customer_app:APP.math_routines') " ) ;
0:         
0:         conn1.commit();
0: 
0:         // second jar must have got installed after the backup. 
0:         // call a function in the custome_app jar
0:         conn1_stmt.execute("call addCustomer(3 , 'John')");
0:         conn1.commit();
0:         
0:         logMessage("No of rows in table t1: " + countRows(conn1, "T1"));
0:         logMessage("No of rows in table customer: " + 
0:                    countRows(conn1, "customer"));
0:         conn1.commit();
0:         conn2.commit();
0:         conn1_stmt.close();
0:         conn2_stmt.close();
0:         conn1.close();
0:         conn2.close();
0:         
0:         //shutdown the test db 
0: 		shutdown(TEST_DATABASE_NAME);
0: 		// restore the database from the backup and run some checks 
0: 		backup.restoreFromBackup();
0: 		logMessage("Restored From the Backup");
0:         Connection conn = getConnection();
0:         Statement stmt = conn.createStatement();
0:         logMessage("No of rows in table t1: " + countRows(conn, "T1"));
0:         logMessage("No of rows in table customer: " + 
0:                    countRows(conn, "customer"));
0:         // execute select statement using the "dv" funciont.  
0:         stmt.execute("select dv(a) from t1");
0: 
0:         
0:         try {
0:             // set the database class with both the jars  installed above.
0:             stmt.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY( " + 
0:                            "'derby.database.classpath', " + 
0:                            "'APP.customer_app:APP.math_routines') " ) ;
0:             stmt.execute("call addCustomer(3 , 'John')"); 
0:         }catch(SQLException se) {
0:             //ignore for now. No sure way to 
0:             //check that jar did not get into backup 
0:             //without debug flags. 
0:         }
0: 
0:         stmt.close();
0:         conn.close();
0: 
0: 		//shutdown the test db 
0: 		shutdown(TEST_DATABASE_NAME);
0: 		logMessage("End Of Install Jar Test.");
0: 
0:     }
0: 
0: 
0:     /*
0:      * Test remove jar running in parallel to backup and vice versa. 
0:      */
0:     void removeJarTest() throws SQLException, Exception{
0:         logMessage("Begin Remove Jar Test");
0:         Connection conn1 = getConnection();
0:         conn1.setAutoCommit(false);
0:         Statement conn1_stmt = conn1.createStatement();
0:         Connection conn2 = getConnection();
0:         conn2.setAutoCommit(false);
0:         Statement conn2_stmt = conn2.createStatement();
0:         try {
0:             conn1_stmt.execute(
0:            "call sqlj.install_jar('extin/obtest_customer.jar', 'customer_app', 0)");
0:         }catch(SQLException se) {
0:             //it is ok if was jar already there.
0:         }
0: 
0:         // remove both the jars from the class path , 
0:         // so that we can remove them. 
0:         conn1_stmt.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY( " + 
0:                         "'derby.database.classpath', '')") ;
0:         conn1.commit();
0: 
0:         conn1_stmt.execute(
0:            "call sqlj.remove_jar('APP.math_routines', 0)");
0:         
0:         try {
0:             // followng backup call should because remove 
0:             // jar operation is pending 
0:            conn2_stmt.execute(
0:             "call SYSCS_UTIL.SYSCS_ONLINE_BACKUP_DATABASE('extinout/mybackup', 0)");
0:         } catch (SQLException sqle) {
0:             //above statement should have failed. 
0:             org.apache.derby.tools.JDBCDisplayUtil.	ShowSQLException(System.out, sqle);
0:         }
0:             
0:         // invoke backup in another thread, should block for 
0:         // the above remove jar  to commit.
0:         
0:         // start a  thread to perform online backup
0: 		OnlineBackup backup = new OnlineBackup(TEST_DATABASE_NAME);
0: 		Thread backupThread = new Thread(backup, "BACKUP3");
0: 		backupThread.start();	
0: 		// wait for the backup to start
0: 		backup.waitForBackupToBegin();
0: 		logMessage("Backup-3 Started");
0: 
0:         // sleep for few seconds just to make sure backup thread is actually
0: 		// gone to a wait state for unlogged actions to commit.
0: 		java.lang.Thread.sleep(1000);
0: 			
0: 		// backup should not even start doing real work before the
0: 		// unlogged transaction is commited
0: 		if(!backup.isRunning())
0: 			logMessage("Backup is not waiting for unlogged " +  
0:                        "remove jar action to commit");
0: 
0:         //insert some rows that should appear in the backup.
0:         conn1_stmt.execute("insert into t1 values(10)");
0:         conn1_stmt.execute("insert into t1 values(11)");
0: 
0:         //commit the transaction with jar opearation that is blocking the backup.
0:         conn1.commit();
0:         logMessage("The transaction that was blocking the backup has ended");
0:         
0:         // wait for backup to finish. 
0:         backup.waitForBackupToEnd();
0: 		backupThread.join();
0: 
0:         logMessage("Backup-3 Completed");
0:         
0:         // Case 2: remove jar op should block if backup is in progress
0:         // add a index that will block the backup until it is committted.
0:         conn1_stmt.execute("create index idx1 on customer(id)");
0:         conn1_stmt.execute("insert into t1 values(12)");
0:         
0:         // start a  thread to perform online backup
0:         backup = new OnlineBackup(TEST_DATABASE_NAME);
0:         backupThread = new Thread(backup, "BACKUP4");
0: 		backupThread.start();	
0: 		// wait for the backup to start
0: 		backup.waitForBackupToBegin();
0: 		logMessage("Backup-4 Started");
0: 
0:         // sleep for few seconds just to make sure backup thread is actually
0: 		// gone to a wait state for unlogged actions to commit.
0: 		java.lang.Thread.sleep(1000);
0: 			
0: 		// backup should not even start doing real work before the
0: 		// unlogged transaction is commited
0: 		if(!backup.isRunning())
0: 			logMessage("Backup is not waiting for unlogged " +  
0:                        "index action to commit");
0: 
0: 
0:         // remove another jar file  , this one should block and 
0:         // should not get into the backup. Backup does not allow new 
0:         // jar operation if it is already waiting for backup blocking
0:         // to complete(commit/rollback). 
0: 
0:         AsyncStatementThread asyncJarActionThread = 
0:             new AsyncStatementThread(conn2, 
0:           "call sqlj.remove_jar('APP.customer_app', 0)");
0:         asyncJarActionThread.start();
0:         logMessage("Started obtest_customer.jar remove in seperate thread");
0: 
0:         //sleep for few seconds to give a chance for the 
0:         //jar addition thread to get into action.
0:         java.lang.Thread.sleep(1000);
0: 
0:         //roll back the index op. Backup should proceed now.
0:         conn1.rollback();
0:         logMessage("The transaction that was blocking the backup has ended");
0:         // wait for backup to finish. 
0:         backup.waitForBackupToEnd();
0: 		backupThread.join();
0:         logMessage("Backup-4 Completed");
0: 
0:         // wait for customer app jar installation to finish now. 
0:         asyncJarActionThread.join();
0:         logMessage("obtest_customer.jar remove is complete");
0:         
0:         //this insert should not apprear on restore.
0:         conn1_stmt.execute("insert into t1 values(13)");
0: 
0:         logMessage("No of rows in table t1: " + countRows(conn1, "T1"));
0:         logMessage("No of rows in table customer: " + 
0:                    countRows(conn1, "customer"));
0:         conn1.commit();
0:         conn2.commit();
0:         conn1_stmt.close();
0:         conn2_stmt.close();
0:         conn1.close();
0:         conn2.close();
0:         
0:         //shutdown the test db 
0: 		shutdown(TEST_DATABASE_NAME);
0: 		// restore the database from the backup and run some checks 
0: 		backup.restoreFromBackup();
0: 		logMessage("Restored From the Backup");
0:         Connection conn = getConnection();
0:         Statement stmt = conn.createStatement();
0:         logMessage("No of rows in table t1: " + countRows(conn, "T1"));
0:         logMessage("No of rows in table customer: " + 
0:                    countRows(conn, "customer"));
0: 
0:         // check if the jar removal was successful.
0:         // APP.math_routines should not be in backup.
0:         try {
0:             // set the database class with both the jars  installed above.
0:             stmt.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY( " + 
0:                            "'derby.database.classpath', " + 
0:                            "'APP.math_routines') " ) ;
0:         }catch (SQLException sqle) {
0:             //above statement should have failed. 
0:             org.apache.derby.tools.JDBCDisplayUtil.	ShowSQLException(System.out, sqle);
0:         }
0:         
0: 
0:         stmt.close();
0:         conn.close();
0: 
0: 		//shutdown the test db 
0: 		shutdown(TEST_DATABASE_NAME);
0: 		logMessage("End Of Remove Jar Test.");
0: 
0:     }
0: 
0: 
0:     /*
0:      * Run a sql statement in a seperate thread. 
0:      */
0:     class AsyncStatementThread extends Thread {
0:         Connection conn;
0:         String stmt;
0:     
0:         AsyncStatementThread(Connection conn, String stmt) {
0:             this.conn = conn;
0:             this.stmt = stmt;
0:         }
0: 
0:         public void run() {
0:             Statement aStatement = null;
0:             try {
0:                 aStatement = conn.createStatement();
0:                 aStatement.execute(stmt);
0:                 aStatement.close();
0:                 // commit here, it is possible that 
0:                 // this thread may have got into action 
0:                 // before the backup went into wait state.
0:                 conn.commit();
0:             } catch (SQLException sqle) {
0:                 org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
0: 				sqle.printStackTrace(System.out);
0:             }
0:             aStatement = null;
0:         }
0:     }
0: 
0: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:e967126
/////////////////////////////////////////////////////////////////////////
0: import java.sql.DriverManager;
/////////////////////////////////////////////////////////////////////////
0: 			//shutdown
0: 			if(TestUtil.HAVE_DRIVER_CLASS)
0: 				DriverManager.getConnection("jdbc:derby:" + dbName + ";shutdown=true");
0: 			else 
0: 				TestUtil.shutdownUsingDataSource(dbName);
/////////////////////////////////////////////////////////////////////////
0:     	Connection conn;
0:     	if(TestUtil.HAVE_DRIVER_CLASS)
0: 			conn = DriverManager.getConnection("jdbc:derby:" + TEST_DATABASE_NAME );
0:     	else {
0: 	    	Properties prop = new Properties();
0: 	        prop.setProperty("databaseName", TEST_DATABASE_NAME);
0: 	        conn = TestUtil.getDataSourceConnection(prop);
0:     	}
============================================================================