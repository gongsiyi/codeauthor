1:fe77ca5: /* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */
1:fe77ca5: /*
1:985fc85: 
1:985fc85:    Derby - Class org.apache.derby.impl.tools.ij.ParseException
1:985fc85: 
1:11bc2d0:    Licensed to the Apache Software Foundation (ASF) under one or more
1:11bc2d0:    contributor license agreements.  See the NOTICE file distributed with
1:11bc2d0:    this work for additional information regarding copyright ownership.
1:11bc2d0:    The ASF licenses this file to You under the Apache License, Version 2.0
1:11bc2d0:    (the "License"); you may not use this file except in compliance with
1:11bc2d0:    the License.  You may obtain a copy of the License at
1:985fc85: 
1:985fc85:       http://www.apache.org/licenses/LICENSE-2.0
1:985fc85: 
1:985fc85:    Unless required by applicable law or agreed to in writing, software
1:985fc85:    distributed under the License is distributed on an "AS IS" BASIS,
1:985fc85:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:985fc85:    See the License for the specific language governing permissions and
1:985fc85:    limitations under the License.
2:fe77ca5: 
2:fe77ca5:  */
1:fe77ca5: package org.apache.derby.impl.tools.ij;
1:fe77ca5: 
1:7e79830: import org.apache.derby.iapi.tools.ToolUtils;
1:7e79830: 
2:fe77ca5: /**
1:fe77ca5:  * This exception is thrown when parse errors are encountered.
1:fe77ca5:  * You can explicitly create objects of this exception type by
1:fe77ca5:  * calling the method generateParseException in the generated
1:fe77ca5:  * parser.
1:fe77ca5:  *
1:fe77ca5:  * You can modify this class to customize your error reporting
1:fe77ca5:  * mechanisms so long as you retain the public fields.
1:fe77ca5:  */
1:fe77ca5: public class ParseException extends Exception {
1:fe77ca5:   /**
1:fe77ca5:    * This constructor is used by the method "generateParseException"
1:fe77ca5:    * in the generated parser.  Calling this constructor generates
1:fe77ca5:    * a new object of this type with the fields "currentToken",
1:fe77ca5:    * "expectedTokenSequences", and "tokenImage" set.  The boolean
1:fe77ca5:    * flag "specialConstructor" is also set to true to indicate that
1:fe77ca5:    * this constructor was used to create this object.
1:fe77ca5:    * This constructor calls its super class with the empty string
1:fe77ca5:    * to force the "toString" method of parent class "Throwable" to
1:fe77ca5:    * print the error message in the form:
1:fe77ca5:    *     ParseException: <result of getMessage>
1:fe77ca5:    */
1:fe77ca5:   public ParseException(Token currentTokenVal,
1:fe77ca5:                         int[][] expectedTokenSequencesVal,
1:fe77ca5:                         String[] tokenImageVal
1:fe77ca5:                        )
1:fe77ca5:   {
1:fe77ca5:     super("");
1:fe77ca5:     specialConstructor = true;
1:fe77ca5:     currentToken = currentTokenVal;
1:7e79830:     expectedTokenSequences = ToolUtils.copy2( expectedTokenSequencesVal );
1:7e79830:     tokenImage = ToolUtils.copy( tokenImageVal );
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   /**
1:fe77ca5:    * The following constructors are for use by you for whatever
1:fe77ca5:    * purpose you can think of.  Constructing the exception in this
1:fe77ca5:    * manner makes the exception behave in the normal way - i.e., as
1:fe77ca5:    * documented in the class "Throwable".  The fields "errorToken",
1:fe77ca5:    * "expectedTokenSequences", and "tokenImage" do not contain
1:fe77ca5:    * relevant information.  The JavaCC generated code does not use
1:fe77ca5:    * these constructors.
1:fe77ca5:    */
1:fe77ca5: 
1:fe77ca5:   public ParseException() {
1:fe77ca5:     super();
1:fe77ca5:     specialConstructor = false;
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   public ParseException(String message) {
1:fe77ca5:     super(message);
1:fe77ca5:     specialConstructor = false;
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   /**
1:fe77ca5:    * This variable determines which constructor was used to create
1:fe77ca5:    * this object and thereby affects the semantics of the
1:fe77ca5:    * "getMessage" method (see below).
1:fe77ca5:    */
1:7e79830:   private boolean specialConstructor;
1:fe77ca5: 
1:fe77ca5:   /**
1:fe77ca5:    * This is the last token that has been consumed successfully.  If
1:fe77ca5:    * this object has been created due to a parse error, the token
1:fe77ca5:    * followng this token will (therefore) be the first error token.
1:fe77ca5:    */
1:7e79830:   private Token currentToken;
1:fe77ca5: 
1:fe77ca5:   /**
1:fe77ca5:    * Each entry in this array is an array of integers.  Each array
1:fe77ca5:    * of integers represents a sequence of tokens (by their ordinal
1:fe77ca5:    * values) that is expected at this point of the parse.
1:fe77ca5:    */
1:7e79830:   private int[][] expectedTokenSequences;
1:fe77ca5: 
1:fe77ca5:   /**
1:fe77ca5:    * This is a reference to the "tokenImage" array of the generated
1:fe77ca5:    * parser within which the parse error occurred.  This array is
1:fe77ca5:    * defined in the generated ...Constants interface.
1:fe77ca5:    */
1:7e79830:   private String[] tokenImage;
1:fe77ca5: 
1:fe77ca5:   /**
1:fe77ca5:    * This method has the standard behavior when this object has been
1:fe77ca5:    * created using the standard constructors.  Otherwise, it uses
1:fe77ca5:    * "currentToken" and "expectedTokenSequences" to generate a parse
1:fe77ca5:    * error message and returns it.  If this object has been created
1:fe77ca5:    * due to a parse error, and you do not catch it (it gets thrown
1:fe77ca5:    * from the parser), then this method is called during the printing
1:fe77ca5:    * of the final stack trace, and hence the correct error message
1:fe77ca5:    * gets displayed.
1:fe77ca5:    */
1:fe77ca5:   public String getMessage() {
1:fe77ca5:     if (!specialConstructor) {
1:fe77ca5:       return super.getMessage();
1:fe77ca5:     }
1:fe77ca5:     String expected = "";
1:fe77ca5:     int maxSize = 0;
1:fe77ca5:     for (int i = 0; i < expectedTokenSequences.length; i++) {
1:fe77ca5:       if (maxSize < expectedTokenSequences[i].length) {
1:fe77ca5:         maxSize = expectedTokenSequences[i].length;
1:fe77ca5:       }
1:fe77ca5:       for (int j = 0; j < expectedTokenSequences[i].length; j++) {
1:fe77ca5:         expected += tokenImage[expectedTokenSequences[i][j]] + " ";
1:fe77ca5:       }
1:fe77ca5:       if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
1:fe77ca5:         expected += "...";
1:fe77ca5:       }
1:fe77ca5:       expected += eol + "    ";
1:fe77ca5:     }
1:fe77ca5:     String retval = "Encountered \"";
1:fe77ca5:     Token tok = currentToken.next;
1:fe77ca5:     for (int i = 0; i < maxSize; i++) {
1:fe77ca5:       if (i != 0) retval += " ";
1:fe77ca5:       if (tok.kind == 0) {
1:fe77ca5:         retval += tokenImage[0];
1:fe77ca5:         break;
1:fe77ca5:       }
1:fe77ca5:       retval += add_escapes(tok.image);
1:fe77ca5:       tok = tok.next;
1:fe77ca5:     }
1:fe77ca5:     retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
1:fe77ca5:  /*
1:fe77ca5:   * for output compatibility with previous releases, do not report expected tokens.
1:fe77ca5:   *
1:fe77ca5:     retval += "." + eol;
1:fe77ca5:     if (expectedTokenSequences.length == 1) {
1:fe77ca5:       retval += "Was expecting:" + eol + "    ";
1:fe77ca5:     } else {
1:fe77ca5:       retval += "Was expecting one of:" + eol + "    ";
1:fe77ca5:     }
1:fe77ca5:     retval += expected;
1:fe77ca5:   */
1:fe77ca5:     return retval;
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   /**
1:fe77ca5:    * The end of line string for this machine.
1:fe77ca5:    */
1:7e79830:   private String eol = System.getProperty("line.separator", "\n");
1:fe77ca5: 
1:fe77ca5:   /**
1:fe77ca5:    * Used to convert raw characters to their escaped version
1:fe77ca5:    * when these raw version cannot be used as part of an ASCII
1:fe77ca5:    * string literal.
1:fe77ca5:    */
1:7e79830:   private String add_escapes(String str) {
1:fe77ca5:       StringBuffer retval = new StringBuffer();
1:fe77ca5:       char ch;
1:fe77ca5:       for (int i = 0; i < str.length(); i++) {
1:fe77ca5:         switch (str.charAt(i))
1:fe77ca5:         {
1:fe77ca5:            case 0 :
1:fe77ca5:               continue;
1:fe77ca5:            case '\b':
1:fe77ca5:               retval.append("\\b");
1:fe77ca5:               continue;
1:fe77ca5:            case '\t':
1:fe77ca5:               retval.append("\\t");
1:fe77ca5:               continue;
1:fe77ca5:            case '\n':
1:fe77ca5:               retval.append("\\n");
1:fe77ca5:               continue;
1:fe77ca5:            case '\f':
1:fe77ca5:               retval.append("\\f");
1:fe77ca5:               continue;
1:fe77ca5:            case '\r':
1:fe77ca5:               retval.append("\\r");
1:fe77ca5:               continue;
1:fe77ca5:            case '\"':
1:fe77ca5:               retval.append("\\\"");
1:fe77ca5:               continue;
1:fe77ca5:            case '\'':
1:fe77ca5:               retval.append("\\\'");
1:fe77ca5:               continue;
1:fe77ca5:            case '\\':
1:fe77ca5:               retval.append("\\\\");
1:fe77ca5:               continue;
1:fe77ca5:            default:
1:fe77ca5:               if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
1:fe77ca5:                  String s = "0000" + Integer.toString(ch, 16);
1:fe77ca5:                  retval.append("\\u" + s.substring(s.length() - 4, s.length()));
1:fe77ca5:               } else {
1:fe77ca5:                  retval.append(ch);
1:fe77ca5:               }
1:fe77ca5:               continue;
1:fe77ca5:         }
1:fe77ca5:       }
1:fe77ca5:       return retval.toString();
1:fe77ca5:    }
1:fe77ca5: 
1:fe77ca5: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:7e79830
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.tools.ToolUtils;
1: 
/////////////////////////////////////////////////////////////////////////
1:     expectedTokenSequences = ToolUtils.copy2( expectedTokenSequencesVal );
1:     tokenImage = ToolUtils.copy( tokenImageVal );
/////////////////////////////////////////////////////////////////////////
1:   private boolean specialConstructor;
1:   private Token currentToken;
1:   private int[][] expectedTokenSequences;
1:   private String[] tokenImage;
/////////////////////////////////////////////////////////////////////////
1:   private String eol = System.getProperty("line.separator", "\n");
1:   private String add_escapes(String str) {
author:David Van Couvering
-------------------------------------------------------------------------------
commit:11bc2d0
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:985fc85
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.tools.ij.ParseException
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:a8ff4fd
/////////////////////////////////////////////////////////////////////////
commit:fe77ca5
/////////////////////////////////////////////////////////////////////////
1: /* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.tools.ij
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: package org.apache.derby.impl.tools.ij;
1: 
1: /**
1:  * This exception is thrown when parse errors are encountered.
1:  * You can explicitly create objects of this exception type by
1:  * calling the method generateParseException in the generated
1:  * parser.
1:  *
1:  * You can modify this class to customize your error reporting
1:  * mechanisms so long as you retain the public fields.
1:  */
1: public class ParseException extends Exception {
1:   /**
0: 			IBM Copyright &copy notice.
1:    */
0:   public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1:   /**
1:    * This constructor is used by the method "generateParseException"
1:    * in the generated parser.  Calling this constructor generates
1:    * a new object of this type with the fields "currentToken",
1:    * "expectedTokenSequences", and "tokenImage" set.  The boolean
1:    * flag "specialConstructor" is also set to true to indicate that
1:    * this constructor was used to create this object.
1:    * This constructor calls its super class with the empty string
1:    * to force the "toString" method of parent class "Throwable" to
1:    * print the error message in the form:
1:    *     ParseException: <result of getMessage>
1:    */
1:   public ParseException(Token currentTokenVal,
1:                         int[][] expectedTokenSequencesVal,
1:                         String[] tokenImageVal
1:                        )
1:   {
1:     super("");
1:     specialConstructor = true;
1:     currentToken = currentTokenVal;
0:     expectedTokenSequences = expectedTokenSequencesVal;
0:     tokenImage = tokenImageVal;
1:   }
1: 
1:   /**
1:    * The following constructors are for use by you for whatever
1:    * purpose you can think of.  Constructing the exception in this
1:    * manner makes the exception behave in the normal way - i.e., as
1:    * documented in the class "Throwable".  The fields "errorToken",
1:    * "expectedTokenSequences", and "tokenImage" do not contain
1:    * relevant information.  The JavaCC generated code does not use
1:    * these constructors.
1:    */
1: 
1:   public ParseException() {
1:     super();
1:     specialConstructor = false;
1:   }
1: 
1:   public ParseException(String message) {
1:     super(message);
1:     specialConstructor = false;
1:   }
1: 
1:   /**
1:    * This variable determines which constructor was used to create
1:    * this object and thereby affects the semantics of the
1:    * "getMessage" method (see below).
1:    */
0:   protected boolean specialConstructor;
1: 
1:   /**
1:    * This is the last token that has been consumed successfully.  If
1:    * this object has been created due to a parse error, the token
1:    * followng this token will (therefore) be the first error token.
1:    */
0:   public Token currentToken;
1: 
1:   /**
1:    * Each entry in this array is an array of integers.  Each array
1:    * of integers represents a sequence of tokens (by their ordinal
1:    * values) that is expected at this point of the parse.
1:    */
0:   public int[][] expectedTokenSequences;
1: 
1:   /**
1:    * This is a reference to the "tokenImage" array of the generated
1:    * parser within which the parse error occurred.  This array is
1:    * defined in the generated ...Constants interface.
1:    */
0:   public String[] tokenImage;
1: 
1:   /**
1:    * This method has the standard behavior when this object has been
1:    * created using the standard constructors.  Otherwise, it uses
1:    * "currentToken" and "expectedTokenSequences" to generate a parse
1:    * error message and returns it.  If this object has been created
1:    * due to a parse error, and you do not catch it (it gets thrown
1:    * from the parser), then this method is called during the printing
1:    * of the final stack trace, and hence the correct error message
1:    * gets displayed.
1:    */
1:   public String getMessage() {
1:     if (!specialConstructor) {
1:       return super.getMessage();
1:     }
1:     String expected = "";
1:     int maxSize = 0;
1:     for (int i = 0; i < expectedTokenSequences.length; i++) {
1:       if (maxSize < expectedTokenSequences[i].length) {
1:         maxSize = expectedTokenSequences[i].length;
1:       }
1:       for (int j = 0; j < expectedTokenSequences[i].length; j++) {
1:         expected += tokenImage[expectedTokenSequences[i][j]] + " ";
1:       }
1:       if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
1:         expected += "...";
1:       }
1:       expected += eol + "    ";
1:     }
1:     String retval = "Encountered \"";
1:     Token tok = currentToken.next;
1:     for (int i = 0; i < maxSize; i++) {
1:       if (i != 0) retval += " ";
1:       if (tok.kind == 0) {
1:         retval += tokenImage[0];
1:         break;
1:       }
1:       retval += add_escapes(tok.image);
1:       tok = tok.next;
1:     }
1:     retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
1:  /*
1:   * for output compatibility with previous releases, do not report expected tokens.
1:   *
1:     retval += "." + eol;
1:     if (expectedTokenSequences.length == 1) {
1:       retval += "Was expecting:" + eol + "    ";
1:     } else {
1:       retval += "Was expecting one of:" + eol + "    ";
1:     }
1:     retval += expected;
1:   */
1:     return retval;
1:   }
1: 
1:   /**
1:    * The end of line string for this machine.
1:    */
0:   protected String eol = System.getProperty("line.separator", "\n");
1: 
1:   /**
1:    * Used to convert raw characters to their escaped version
1:    * when these raw version cannot be used as part of an ASCII
1:    * string literal.
1:    */
0:   protected String add_escapes(String str) {
1:       StringBuffer retval = new StringBuffer();
1:       char ch;
1:       for (int i = 0; i < str.length(); i++) {
1:         switch (str.charAt(i))
1:         {
1:            case 0 :
1:               continue;
1:            case '\b':
1:               retval.append("\\b");
1:               continue;
1:            case '\t':
1:               retval.append("\\t");
1:               continue;
1:            case '\n':
1:               retval.append("\\n");
1:               continue;
1:            case '\f':
1:               retval.append("\\f");
1:               continue;
1:            case '\r':
1:               retval.append("\\r");
1:               continue;
1:            case '\"':
1:               retval.append("\\\"");
1:               continue;
1:            case '\'':
1:               retval.append("\\\'");
1:               continue;
1:            case '\\':
1:               retval.append("\\\\");
1:               continue;
1:            default:
1:               if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
1:                  String s = "0000" + Integer.toString(ch, 16);
1:                  retval.append("\\u" + s.substring(s.length() - 4, s.length()));
1:               } else {
1:                  retval.append(ch);
1:               }
1:               continue;
1:         }
1:       }
1:       return retval.toString();
1:    }
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.tools.ij
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: package org.apache.derby.impl.tools.ij;
0: 
0: /**
0:  * This exception is thrown when parse errors are encountered.
0:  * You can explicitly create objects of this exception type by
0:  * calling the method generateParseException in the generated
0:  * parser.
0:  *
0:  * You can modify this class to customize your error reporting
0:  * mechanisms so long as you retain the public fields.
0:  */
0: public class ParseException extends Exception {
0:   /**
0: 			IBM Copyright &copy notice.
0:    */
0:   public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0:   /**
0:    * This constructor is used by the method "generateParseException"
0:    * in the generated parser.  Calling this constructor generates
0:    * a new object of this type with the fields "currentToken",
0:    * "expectedTokenSequences", and "tokenImage" set.  The boolean
0:    * flag "specialConstructor" is also set to true to indicate that
0:    * this constructor was used to create this object.
0:    * This constructor calls its super class with the empty string
0:    * to force the "toString" method of parent class "Throwable" to
0:    * print the error message in the form:
0:    *     ParseException: <result of getMessage>
0:    */
0:   public ParseException(Token currentTokenVal,
0:                         int[][] expectedTokenSequencesVal,
0:                         String[] tokenImageVal
0:                        )
0:   {
0:     super("");
0:     specialConstructor = true;
0:     currentToken = currentTokenVal;
0:     expectedTokenSequences = expectedTokenSequencesVal;
0:     tokenImage = tokenImageVal;
0:   }
0: 
0:   /**
0:    * The following constructors are for use by you for whatever
0:    * purpose you can think of.  Constructing the exception in this
0:    * manner makes the exception behave in the normal way - i.e., as
0:    * documented in the class "Throwable".  The fields "errorToken",
0:    * "expectedTokenSequences", and "tokenImage" do not contain
0:    * relevant information.  The JavaCC generated code does not use
0:    * these constructors.
0:    */
0: 
0:   public ParseException() {
0:     super();
0:     specialConstructor = false;
0:   }
0: 
0:   public ParseException(String message) {
0:     super(message);
0:     specialConstructor = false;
0:   }
0: 
0:   /**
0:    * This variable determines which constructor was used to create
0:    * this object and thereby affects the semantics of the
0:    * "getMessage" method (see below).
0:    */
0:   protected boolean specialConstructor;
0: 
0:   /**
0:    * This is the last token that has been consumed successfully.  If
0:    * this object has been created due to a parse error, the token
0:    * followng this token will (therefore) be the first error token.
0:    */
0:   public Token currentToken;
0: 
0:   /**
0:    * Each entry in this array is an array of integers.  Each array
0:    * of integers represents a sequence of tokens (by their ordinal
0:    * values) that is expected at this point of the parse.
0:    */
0:   public int[][] expectedTokenSequences;
0: 
0:   /**
0:    * This is a reference to the "tokenImage" array of the generated
0:    * parser within which the parse error occurred.  This array is
0:    * defined in the generated ...Constants interface.
0:    */
0:   public String[] tokenImage;
0: 
0:   /**
0:    * This method has the standard behavior when this object has been
0:    * created using the standard constructors.  Otherwise, it uses
0:    * "currentToken" and "expectedTokenSequences" to generate a parse
0:    * error message and returns it.  If this object has been created
0:    * due to a parse error, and you do not catch it (it gets thrown
0:    * from the parser), then this method is called during the printing
0:    * of the final stack trace, and hence the correct error message
0:    * gets displayed.
0:    */
0:   public String getMessage() {
0:     if (!specialConstructor) {
0:       return super.getMessage();
0:     }
0:     String expected = "";
0:     int maxSize = 0;
0:     for (int i = 0; i < expectedTokenSequences.length; i++) {
0:       if (maxSize < expectedTokenSequences[i].length) {
0:         maxSize = expectedTokenSequences[i].length;
0:       }
0:       for (int j = 0; j < expectedTokenSequences[i].length; j++) {
0:         expected += tokenImage[expectedTokenSequences[i][j]] + " ";
0:       }
0:       if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
0:         expected += "...";
0:       }
0:       expected += eol + "    ";
0:     }
0:     String retval = "Encountered \"";
0:     Token tok = currentToken.next;
0:     for (int i = 0; i < maxSize; i++) {
0:       if (i != 0) retval += " ";
0:       if (tok.kind == 0) {
0:         retval += tokenImage[0];
0:         break;
0:       }
0:       retval += add_escapes(tok.image);
0:       tok = tok.next;
0:     }
0:     retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
0:  /*
0:   * for output compatibility with previous releases, do not report expected tokens.
0:   *
0:     retval += "." + eol;
0:     if (expectedTokenSequences.length == 1) {
0:       retval += "Was expecting:" + eol + "    ";
0:     } else {
0:       retval += "Was expecting one of:" + eol + "    ";
0:     }
0:     retval += expected;
0:   */
0:     return retval;
0:   }
0: 
0:   /**
0:    * The end of line string for this machine.
0:    */
0:   protected String eol = System.getProperty("line.separator", "\n");
0: 
0:   /**
0:    * Used to convert raw characters to their escaped version
0:    * when these raw version cannot be used as part of an ASCII
0:    * string literal.
0:    */
0:   protected String add_escapes(String str) {
0:       StringBuffer retval = new StringBuffer();
0:       char ch;
0:       for (int i = 0; i < str.length(); i++) {
0:         switch (str.charAt(i))
0:         {
0:            case 0 :
0:               continue;
0:            case '\b':
0:               retval.append("\\b");
0:               continue;
0:            case '\t':
0:               retval.append("\\t");
0:               continue;
0:            case '\n':
0:               retval.append("\\n");
0:               continue;
0:            case '\f':
0:               retval.append("\\f");
0:               continue;
0:            case '\r':
0:               retval.append("\\r");
0:               continue;
0:            case '\"':
0:               retval.append("\\\"");
0:               continue;
0:            case '\'':
0:               retval.append("\\\'");
0:               continue;
0:            case '\\':
0:               retval.append("\\\\");
0:               continue;
0:            default:
0:               if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
0:                  String s = "0000" + Integer.toString(ch, 16);
0:                  retval.append("\\u" + s.substring(s.length() - 4, s.length()));
0:               } else {
0:                  retval.append(ch);
0:               }
0:               continue;
0:         }
0:       }
0:       return retval.toString();
0:    }
0: 
0: }
============================================================================