1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.FromList
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
6:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:1c6c2e8: import java.util.ArrayList;
1:3bb140c: import java.util.Enumeration;
1:3bb140c: import java.util.Properties;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:e3720ab: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizable;
1:eac0369: import org.apache.derby.iapi.sql.compile.OptimizableList;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizer;
1:e3720ab: import org.apache.derby.iapi.sql.conn.Authorizer;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: import org.apache.derby.iapi.util.StringUtil;
1:1c6c2e8: 
1:eac0369: 
5:eac0369: /**
1:eac0369:  * A FromList represents the list of tables in a FROM clause in a DML
1:eac0369:  * statement.  It extends QueryTreeNodeVector.
14:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:e1f49ca: class FromList extends    QueryTreeNodeVector<ResultSetNode>
1:e1f49ca:                implements OptimizableList
1:eac0369: {
1:eac0369: 	Properties	properties;
1:eac0369: 	// RESOLVE: The default should be false
1:eac0369: 	boolean		fixedJoinOrder = true;
1:eac0369: 	// true by default.
1:eac0369: 	boolean 	useStatistics = true;
1:eac0369: 
1:6d9c32a: 	// FromList could have a view in it's list. If the view is defined in SESSION
1:6d9c32a: 	// schema, then we do not want to cache the statement's plan. This boolean
1:6d9c32a: 	// will help keep track of such a condition.
1:6d9c32a: 	private boolean  referencesSessionSchema;
1:eac0369: 
1:0787955: 	/* Whether or not this FromList is transparent.  A "transparent" FromList
1:0787955: 	 * is one in which all FromTables are bound based on an outer query's
1:0787955: 	 * FromList.  This means that the FromTables in the transparent list are
1:0787955: 	 * allowed to see and reference FromTables in the outer query's list.
1:0787955: 	 * Or put differently, a FromTable which sits in a transparent FromList
1:0787955: 	 * does not "see" the transparent FromList when binding; rather, it sees
1:0787955: 	 * (and can therefore reference) the FromList of an outer query.
1:eac0369: 	 */
1:0787955: 	private boolean isTransparent;
1:eac0369: 
1:7a9ce7e: 	/**
1:7a9ce7e: 	 * Window definitions used for resolving window functions not containing
1:7a9ce7e: 	 * in-line window specifications, but referring window definitions
1:7a9ce7e: 	 */
1:7a9ce7e: 	private WindowList windows;
1:7a9ce7e: 
1:3bb140c:     /**
1:3bb140c:      *  Does not change the default for join order optimization, i.e.
1:3bb140c:      * {@code false}.
1:3bb140c:      * @param cm context manager
1:3bb140c:      */
1:3bb140c:     FromList(ContextManager cm) {
1:e1f49ca:         super(ResultSetNode.class, cm);
1:3bb140c:         this.isTransparent = false;
1:3bb140c:     }
1:7a9ce7e: 
1:3bb140c:     /**
1:3bb140c:      * Constructor for a FromList
1:3bb140c:      *
1:3bb140c:      * @param optimizeJoinOrder {@code true} if join order optimization is to
1:3bb140c:      *                          be performed
1:3bb140c:      * @param cm                context manager
1:3bb140c:      */
1:7a9ce7e: 
1:3bb140c:     FromList(boolean optimizeJoinOrder, ContextManager cm)
1:eac0369: 	{
1:e1f49ca:         super(ResultSetNode.class, cm);
1:3bb140c:         constructorMinion(optimizeJoinOrder);
1:eac0369: 	}
1:7a9ce7e: 
1:7a9ce7e: 	/**
1:3bb140c:      * Constructor for a FromList
1:eac0369: 	 *
1:3bb140c:      * @param optimizeJoinOrder {@code true} if join order optimization is to
1:3bb140c:      *                          be performed
1:3bb140c:      * @param fromTable         initialize list with this table
1:3bb140c:      * @param cm                context manager
2:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     FromList(boolean optimizeJoinOrder,
1:3bb140c:              FromTable fromTable,
1:3bb140c:              ContextManager cm) throws StandardException
1:eac0369: 	{
1:e1f49ca:         super(ResultSetNode.class, cm);
1:3bb140c:         constructorMinion(optimizeJoinOrder);
1:3bb140c:         addFromTable(fromTable);
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     private void constructorMinion(boolean optimizeJoinOrder) {
1:3bb140c:         this.fixedJoinOrder = !optimizeJoinOrder;
1:3bb140c:         this.isTransparent = false;
1:3bb140c:     }
1:eac0369: 	/*
1:eac0369: 	 * OptimizableList interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see org.apache.derby.iapi.sql.compile.OptimizableList#getOptimizable
1:eac0369: 	 */
1:eac0369: 	public Optimizable getOptimizable(int index)
1:eac0369: 	{
1:eac0369: 		return (Optimizable) elementAt(index);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see org.apache.derby.iapi.sql.compile.OptimizableList#setOptimizable
1:eac0369: 	 */
1:eac0369: 	public void setOptimizable(int index, Optimizable optimizable)
1:eac0369: 	{
1:eac0369: 		setElementAt((FromTable) optimizable, index);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * @see OptimizableList#verifyProperties
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void verifyProperties(DataDictionary dDictionary) throws StandardException
1:eac0369: 	{
4:eac0369: 		int size = size();
4:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			((Optimizable) elementAt(index)).verifyProperties(dDictionary);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add a table to the FROM list.
1:eac0369: 	 *
1:eac0369: 	 * @param fromTable	A FromTable to add to the list
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     final void addFromTable(FromTable fromTable) throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Don't worry about checking TableOperatorNodes since
1:eac0369: 		 * they don't have exposed names.  This will potentially
1:eac0369: 		 * allow duplicate exposed names in some degenerate cases,
1:eac0369: 		 * but the binding of the ColumnReferences will catch those
1:eac0369: 		 * cases with a different error.  If the query does not have
1:eac0369: 		 * any ColumnReferences from the duplicate exposed name, the
1:eac0369: 		 * user is executing a really dumb query and we won't throw
1:eac0369: 		 * and exception - consider it an ANSI extension.
1:eac0369: 		 */
1:3bb140c:         TableName leftTable;
1:3bb140c:         TableName rightTable;
1:3bb140c: 
1:eac0369: 		if (! (fromTable instanceof TableOperatorNode))
1:eac0369: 		{
1:eac0369: 			/* Check for duplicate table name in FROM list */
1:eac0369: 			int size = size();
1:eac0369: 			for (int index = 0; index < size; index++)
1:eac0369: 			{
1:c83a399:                 leftTable = fromTable.getTableName();
1:c83a399: 
1:c83a399:                 if(((FromTable) elementAt(index)) instanceof TableOperatorNode) {
1:c83a399:                     continue;
1:c83a399:                 }
1:c83a399: 
1:c83a399:                 else {                    
1:c83a399:                     rightTable = ((FromTable) elementAt(index)).getTableName();
1:c83a399:                 }
1:c83a399:                 if(leftTable.equals(rightTable))
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_FROM_LIST_DUPLICATE_TABLE_NAME, fromTable.getExposedName());
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:e1f49ca:         addElement(fromTable);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Search to see if a query references the specifed table name.
1:eac0369: 	 *
1:eac0369: 	 * @param name		Table name (String) to search for.
1:eac0369: 	 * @param baseTable	Whether or not name is for a base table
1:eac0369: 	 *
1:eac0369: 	 * @return	true if found, else false
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     boolean referencesTarget(String name, boolean baseTable)
4:eac0369: 		throws StandardException
1:eac0369: 	{
2:eac0369: 		FromTable		fromTable;
2:eac0369: 		boolean			found = false;
1:eac0369: 
1:eac0369: 		/* Check for table or VTI name in FROM list */
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
3:eac0369: 			fromTable = (FromTable) elementAt(index);
1:eac0369: 
1:eac0369: 			if (fromTable.referencesTarget(name, baseTable)) 
1:eac0369: 			{
1:eac0369: 				found = true;
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return found;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1:eac0369: 	 *
1:eac0369: 	 * @return	true if references SESSION schema tables, else false
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public boolean referencesSessionSchema()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		FromTable		fromTable;
1:eac0369: 		boolean			found = false;
1:eac0369: 
1:6d9c32a: 		// Following if will return true if this FromList object had any VIEWs
1:6d9c32a: 		// from SESSION schema as elements.  This information is gathered during
1:6d9c32a: 		// the bindTables method. At the end of the bindTables, we loose
1:6d9c32a: 		// the information on VIEWs since they get replaced with their view
1:6d9c32a: 		// definition. Hence, we need to intercept in the middle on the bindTables
1:6d9c32a: 		// method and save that information in referencesSeesionSchema field.
1:6d9c32a: 		if (referencesSessionSchema) return true;
1:eac0369: 
1:eac0369: 		/* Check for table or VTI name in FROM list */
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			fromTable = (FromTable) elementAt(index);
1:eac0369: 
1:eac0369: 			if (fromTable.referencesSessionSchema())
1:eac0369: 			{
1:eac0369: 				found = true;
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return found;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Determine whether or not the specified name is an exposed name in
1:eac0369: 	 * the current query block.
1:eac0369: 	 *
1:eac0369: 	 * @param name	The specified name to search for as an exposed name.
1:eac0369: 	 * @param schemaName	Schema name, if non-null.
1:eac0369: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
1:eac0369: 	 *						names or match on table id.
1:eac0369: 	 *
1:eac0369: 	 * @return The FromTable, if any, with the exposed name.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:9f2ed7d:     FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		FromTable		fromTable;
1:eac0369: 		FromTable		result = null;
1:eac0369: 
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			fromTable = (FromTable) elementAt(index);
1:eac0369: 
1:eac0369: 			result = fromTable.getFromTableByName(name, schemaName, exactMatch);
1:eac0369: 
1:eac0369: 			if (result != null)
1:eac0369: 			{
1:eac0369: 				return result;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:0eb98f1: 	 * Go through the list of the tables and see if the passed ResultColumn
1:0eb98f1: 	 *  is a join column for a right outer join with USING/NATURAL clause.
1:0eb98f1: 	 * @see HalfOuterJoinNode#isJoinColumnForRightOuterJoin
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void isJoinColumnForRightOuterJoin(ResultColumn rc)
1:0eb98f1: 	{
1:0eb98f1: 		FromTable	fromTable;
1:0eb98f1: 		int size = size();
1:0eb98f1: 		for (int index = 0; index < size; index++)
1:0eb98f1: 		{
1:0eb98f1: 			fromTable = (FromTable) elementAt(index);
1:0eb98f1: 			fromTable.isJoinColumnForRightOuterJoin(rc);
1:0eb98f1: 		}
1:0eb98f1: 	}
1:3bb140c:     void bindTables(DataDictionary dataDictionary,
1:eac0369: 							FromList fromListParam) 
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:b93f9db:         //
1:b93f9db:         // Don't add USAGE privilege on user-defined types just because we're
1:b93f9db:         // binding tables.
1:b93f9db:         //
1:b93f9db:         boolean wasSkippingTypePrivileges = getCompilerContext().skipTypePrivileges( true );
1:b93f9db:         
3:eac0369: 		FromTable	fromTable;
1:eac0369: 
1:eac0369: 		/* Now we bind the tables - this is a 2 step process.
1:eac0369: 		 * We first bind all of the non-VTIs, then we bind the VTIs.
1:eac0369: 		 * This enables us to handle the passing of correlation
1:eac0369: 		 * columns in VTI parameters.
1:eac0369: 		 * NOTE: We set the table numbers for all of the VTIs in the
1:eac0369: 		 * first step, when we find them, in order to avoid an ordering
1:eac0369: 		 * problem with join columns in parameters.
1:eac0369: 		 */
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			fromTable = (FromTable) elementAt(index);
1:3e77b5a: 			FromTable   newNode = (FromTable) fromTable.bindNonVTITables(dataDictionary, fromListParam);
1:6d9c32a: 			// If the fromTable is a view in the SESSION schema, then we need to save that information
1:6d9c32a: 			// in referencesSessionSchema element. The reason for this is that the view will get
1:6d9c32a: 			// replaced by it's view definition and we will loose the information that the statement
1:6d9c32a: 			// was referencing a SESSION schema object. 
1:6d9c32a: 			if (fromTable.referencesSessionSchema())
1:3e77b5a:             {
1:6d9c32a: 				referencesSessionSchema = true;
1:3e77b5a:             }
1:3e77b5a:             newNode.setMergeTableID( fromTable.getMergeTableID() );
1:6d9c32a: 			setElementAt(newNode, index);
1:eac0369: 		}
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			fromTable = (FromTable) elementAt(index);
1:3e77b5a: 			FromTable   newNode = (FromTable) fromTable.bindVTITables(fromListParam);
1:6d9c32a: 			if (fromTable.referencesSessionSchema())
1:3e77b5a:             {
1:6d9c32a: 				referencesSessionSchema = true;
1:3e77b5a:             }
1:3e77b5a:             newNode.setMergeTableID( fromTable.getMergeTableID() );
1:6d9c32a: 			setElementAt(newNode, index);
1:eac0369: 		}
1:e3720ab: 
1:e3720ab:         // DERBY-4191: We must have some SELECT privilege on every table
1:e3720ab:         // that we read from, even if we don't actually read any column
1:e3720ab:         // values from it (for example if we do SELECT COUNT(*) FROM T).
1:e3720ab:         // We ask for MIN_SELECT_PRIV requirement of the first column in
1:e3720ab:         // the table. The first column is just a place holder. What we
1:e3720ab:         // really do at execution time when we see we are looking for
1:e3720ab:         // MIN_SELECT_PRIV privilege is as follows:
1:3e77b5a:         //
1:e3720ab:         // 1) We will look for SELECT privilege at table level.
1:e3720ab:         // 2) If not found, we will look for SELECT privilege on
1:e3720ab:         //    ANY column, not necessarily the first column. But since
1:e3720ab:         //    the constructor for column privilege requires us to pass
1:e3720ab:         //    a column descriptor, we just choose the first column for
1:e3720ab:         //    MIN_SELECT_PRIV requirement.
1:e3720ab:         final CompilerContext cc = getCompilerContext();
1:e3720ab:         cc.pushCurrentPrivType(Authorizer.MIN_SELECT_PRIV);
1:e3720ab:         for (int index = 0; index < size; index++) {
1:e3720ab:             fromTable = (FromTable) elementAt(index);
1:e3720ab:             if (fromTable.isPrivilegeCollectionRequired() &&
1:e3720ab:                     fromTable.isBaseTable() && !fromTable.forUpdate()) {
1:e3720ab:                 // This is a base table in the FROM list of a SELECT statement.
1:e3720ab:                 // Make sure we check for minimum SELECT privilege on it.
1:e3720ab:                 cc.addRequiredColumnPriv(
1:e3720ab:                     fromTable.getTableDescriptor().getColumnDescriptor(1));
1:e3720ab:             }
1:e3720ab:         }
1:e3720ab:         cc.popCurrentPrivType();
1:b93f9db:         getCompilerContext().skipTypePrivileges( wasSkippingTypePrivileges );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind the expressions in this FromList.  This means 
1:eac0369: 	 * binding the sub-expressions, as well as figuring out what the return 
1:eac0369: 	 * type is for each expression.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void bindExpressions( FromList fromListParam )
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		FromTable	fromTable;
1:eac0369: 
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			fromTable = (FromTable) elementAt(index);
1:eac0369: 
1:0787955: 			/* If this FromList is transparent then its FromTables should
1:0787955: 			 * be bound based on the outer query's FROM list.
1:eac0369: 			 */
1:0787955: 			fromTable.bindExpressions(
1:0787955: 				isTransparent ? fromListParam : this);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind the result columns of the ResultSetNodes in this FromList when there is no
1:eac0369: 	 * base table to bind them to.  This is useful for SELECT statements,
1:eac0369: 	 * where the result columns get their types from the expressions that
1:eac0369: 	 * live under them.
1:eac0369: 	 *
2:eac0369: 	 * @param fromListParam		FromList to use/append to.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void bindResultColumns(FromList fromListParam)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		FromTable	fromTable;
1:eac0369: 
1:eac0369: 		int origList = fromListParam.size();
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			fromTable = (FromTable) elementAt(index);
1:eac0369: 			if (fromTable.needsSpecialRCLBinding())
1:eac0369: 				fromTable.bindResultColumns(fromListParam);
1:eac0369: 
1:eac0369: 			fromListParam.insertElementAt(fromTable, 0);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Remove all references added here */
1:eac0369: 		while (fromListParam.size() > origList)
1:eac0369: 			fromListParam.removeElementAt(0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Expand a "*" into the appropriate ResultColumnList. If the "*"
1:eac0369: 	 * is unqualified it will expand into a list of all columns in all
1:0787955: 	 * of the base tables in the from list at the current nesting level;
1:0787955: 	 * otherwise it will expand into a list of all of the columns in the
1:0787955: 	 * base table that matches the qualification.
1:eac0369: 	 *
1:0787955: 	 * NOTE: Callers are responsible for ordering the FromList by nesting
1:0787955: 	 * level, with tables at the deepest (current) nesting level first.  
1:0787955: 	 * We will expand the "*" into a list of all columns from all tables
1:0787955: 	 * having the same nesting level as the first FromTable in this list.
1:0787955: 	 * The check for nesting level exists because it's possible that this
1:0787955: 	 * FromList includes FromTables from an outer query, which can happen
1:0787955: 	 * if there is a "transparent" FromList above this one in the query
1:0787955: 	 * tree.  Ex:
1:eac0369: 	 *
1:0787955: 	 *  select j from onerow where exists
1:0787955: 	 *    (select 1 from somerow
1:dbed020: 	 *      union select * from diffrow where onerow.j &lt; diffrow.k)
1:eac0369: 	 *
1:0787955: 	 * If "this" is the FromList for the right child of the UNION then it will
1:0787955: 	 * contain both "diffrow" and "onerow", the latter of which was passed
1:0787955: 	 * down via a transparent FromList (to allow binding of the WHERE clause).
1:0787955: 	 * In that case the "*" should only expand the result columns of "diffrow";
1:0787955: 	 * it should not expand the result columns of "onerow" because that table
1:0787955: 	 * is from an outer query.  We can achieve this selective expansion by
1:0787955: 	 * looking at nesting levels.
1:eac0369: 	 * 
1:eac0369: 	 * @param allTableName		The qualification on the "*" as a String.
1:eac0369: 	 *
1:eac0369: 	 * @return ResultColumnList representing expansion
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     ResultColumnList expandAll(TableName allTableName)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		ResultColumnList resultColumnList = null;
1:3bb140c:         ResultColumnList tempRCList;
1:eac0369: 		boolean			 matchfound = false;
1:eac0369: 		FromTable	 fromTable;
1:eac0369:  
1:eac0369: 		/* Expand the "*" for the table that matches, if it is qualified 
1:0787955: 		 * (allTableName is not null) or for all tables in the list at the
1:0787955: 		 * current nesting level if the "*" is not qualified (allTableName
1:0787955: 		 * is null).  Current nesting level is determined by the nesting
1:0787955: 		 * level of the first FromTable in the list.
1:eac0369: 		 */
1:0787955: 		int targetNestingLevel = ((FromTable)elementAt(0)).getLevel();
1:eac0369: 		int size = size();
1:eac0369: 
1:0787955: 		/* Make sure our assumption about nesting-based ordering
1:0787955: 		 * has been satisified.  I.e. that the list is ordered
1:0787955: 		 * with the most deeply nested FromTables first.
1:eac0369: 		 */
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:0787955: 			int prevNL = targetNestingLevel;
1:0787955: 			for (int i = 1; i < size; i++)
1:eac0369: 			{
1:0787955: 				int currNL = ((FromTable)elementAt(i)).getLevel();
1:0787955: 				SanityManager.ASSERT((prevNL >= currNL),
1:0787955: 					"FROM list should have been ordered by nesting " +
1:0787955: 					"level (deepest level first), but it was not.");
1:eac0369: 
1:0787955: 				prevNL = currNL;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			fromTable = (FromTable) elementAt(index);
1:0787955: 			if (targetNestingLevel != fromTable.getLevel())
1:eac0369: 			{
1:0787955: 				/* We only expand result columns for tables at the
1:0787955: 				 * target nesting level.  Since the FromTables are
1:0787955: 				 * sorted based on nesting level, we're done if we
1:0787955: 				 * get here.
1:eac0369: 				 */
1:0787955: 				break;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* We let the FromTable decide if there is a match on
1:eac0369: 			 * the exposed name.  (A JoinNode will not have an
1:eac0369: 			 * exposed name, so it will need to pass the info to its
1:eac0369: 			 * left and right children.)
1:eac0369: 			 */
1:eac0369: 			tempRCList = fromTable.getAllResultColumns(allTableName);
1:eac0369: 
1:eac0369: 			if (tempRCList == null)
1:eac0369: 			{
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* Expand the column list and append to the list that
1:eac0369: 			 * we will return.
1:eac0369: 			 */
1:eac0369: 			if (resultColumnList == null)
1:eac0369: 			{
1:eac0369: 				resultColumnList = tempRCList;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				resultColumnList.nondestructiveAppend(tempRCList);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* If the "*" is qualified, then we can stop the
1:eac0369: 			 * expansion as soon as we find the matching table.
1:eac0369: 			 */
1:eac0369: 			if (allTableName != null)
1:eac0369: 			{
1:eac0369: 				matchfound = true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Give an error if the qualification name did not match 
1:eac0369: 		 * an exposed name 
1:eac0369: 		 */
1:eac0369: 		if (resultColumnList == null)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_EXPOSED_NAME_NOT_FOUND, allTableName);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return resultColumnList;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:6ab1083:      * <p>
1:eac0369: 	 * Bind a column reference to one of the tables in this FromList.  The column name
1:eac0369: 	 * must be unique within the tables in the FromList.  An exception is thrown
1:6ab1083: 	 * if a column name is not unique. This method fills in various fields
1:6ab1083:      * in the column reference.
1:6ab1083:      * </p>
1:eac0369: 	 *
1:6ab1083:      * <p>
1:eac0369: 	 * NOTE: Callers are responsible for ordering the FromList by nesting level,
1:eac0369: 	 * with tables at the deepest (current) nesting level first.  We will try to 
1:eac0369: 	 * match against all FromTables at a given nesting level.  If no match is
1:eac0369: 	 * found at a nesting level, then we proceed to the next level.  We stop
1:eac0369: 	 * walking the list when the nesting level changes and we have found a match.
1:6ab1083:      * </p>
1:eac0369: 	 *
1:6ab1083:      * <p>
1:eac0369: 	 * NOTE: If the ColumnReference is qualified, then we will stop the search
1:eac0369: 	 * at the first nesting level where there is a match on the exposed table name.
1:6ab1083: 	 * For example,
1:6ab1083:      * <p>
1:6ab1083:      *
1:6ab1083:      * <pre>
1:6ab1083:      *s (a, b, c), t (d, e, f)
1:eac0369: 	 *		select * from s where exists (select * from t s where s.c = a)
1:6ab1083:      * </pre>
1:6ab1083:      *
1:6ab1083:      * <p>
1:eac0369: 	 * will not find a match for s.c, which is the expected ANSI behavior.
1:6ab1083:      * </p>
1:eac0369: 	 *
1:6ab1083:      * <p>
1:eac0369: 	 * bindTables() must have already been called on this FromList before
1:eac0369: 	 * calling this method.
1:6ab1083:      * </p>
1:eac0369: 	 *
1:eac0369: 	 * @param columnReference	The ColumnReference describing the column to bind
1:eac0369: 	 *
1:4fc5f9c:      * @return ResultColumn     The matching ResultColumn, or {@code null} if
1:4fc5f9c:      *                          there is no matching column
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     ResultColumn bindColumnReference(ColumnReference columnReference)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean			columnNameMatch = false;
1:eac0369: 		boolean			tableNameMatch = false;
1:6ab1083: 		FromTable		fromTable = null;
1:6ab1083: 		FromTable		matchingTable = null;
1:3bb140c:         int             currentLevel;
1:eac0369: 		int				previousLevel = -1;
1:eac0369: 		ResultColumn	matchingRC = null;
1:eac0369: 		ResultColumn	resultColumn;
1:eac0369: 		String			crTableName = columnReference.getTableName();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Find the first table with matching column name.  If there
1:eac0369: 		** is more than one table with a matching column name at the same
1:eac0369: 		** nesting level, give an error.
1:eac0369: 		*/
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			fromTable = (FromTable) elementAt(index);
1:eac0369: 
1:e3720ab:             //
1:3e77b5a:             // If the MERGE statement has marked its variables, we expect to follow
1:3e77b5a:             // its judgment. Make sure that we only match SOURCE columns to
1:3e77b5a:             // SOURCE tables and TARGET columns to TARGET tables.
1:3e77b5a:             //
1:3e77b5a:             if (
1:3e77b5a:                 (fromTable.getMergeTableID() != ColumnReference.MERGE_UNKNOWN) &&
1:3e77b5a:                 (columnReference.getMergeTableID() != ColumnReference.MERGE_UNKNOWN) &&
1:3e77b5a:                 (fromTable.getMergeTableID() != columnReference.getMergeTableID())
1:3e77b5a:                 )
1:3e77b5a:             {
1:3e77b5a:                 continue;
1:3e77b5a:             }
1:3e77b5a: 
1:eac0369: 			/* We can stop if we've found a matching column or table name 
1:eac0369: 			 * at the previous nesting level.
1:eac0369: 			 */
1:eac0369: 			currentLevel = fromTable.getLevel();
1:eac0369: 			if (previousLevel != currentLevel)
1:eac0369: 			{
1:eac0369: 				if (columnNameMatch)
1:eac0369: 				{
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				if (tableNameMatch)
1:eac0369: 				{
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			/* Simpler to always set previousLevel then to test and set */
1:eac0369: 			previousLevel = currentLevel;
1:eac0369: 
1:eac0369: 			resultColumn = fromTable.getMatchingColumn(columnReference);
1:eac0369: 			if (resultColumn != null)
1:eac0369: 			{
1:eac0369: 				if (! columnNameMatch)
1:eac0369: 				{
1:ee21e7c:                     /* TableNumbers and column numbers are set in the CR in the
1:ee21e7c:                      * underlying FromTable.  This ensures that they get the
1:ee21e7c:                      * table number/column number from the underlying table,
1:ee21e7c:                      * not the join node.  This is important for beging able to
1:ee21e7c:                      * push predicates down through join nodes.
1:ee21e7c:                      */
1:eac0369: 					matchingRC = resultColumn;
1:eac0369: 					columnReference.setSource(resultColumn);
1:eac0369: 					/* Set the nesting level at which the CR appears and the nesting level
1:eac0369: 					 * of its source RC.
1:eac0369: 					 */
1:eac0369: 					columnReference.setNestingLevel(((FromTable) elementAt(0)).getLevel());
1:eac0369: 					columnReference.setSourceLevel(currentLevel);
1:eac0369: 					columnNameMatch = true;
1:eac0369: 
1:2d2e717: 					if (fromTable.isPrivilegeCollectionRequired())
1:6ab1083:                     {
1:6ab1083: 						getCompilerContext().addRequiredColumnPriv( resultColumn.getTableColumnDescriptor());
1:6ab1083:                     }
1:6ab1083: 
1:6ab1083:                     matchingTable = fromTable;
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_AMBIGUOUS_COLUMN_NAME, 
1:f1d4e9d: 							 columnReference.getSQLColumnName());
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* Remember if we get a match on the exposed table name, so that
1:eac0369: 			 * we can stop at the beginning of the next level.
1:eac0369: 			 */
1:eac0369: 			tableNameMatch = tableNameMatch || 
1:eac0369: 						(crTableName != null &&
1:eac0369: 						 crTableName.equals(fromTable.getExposedName()) );
1:eac0369: 		}
1:eac0369: 
1:6ab1083:         // fill in the table name
1:6ab1083:         if ( (matchingTable != null) && (matchingRC != null) && (columnReference.getTableName() == null) )
1:6ab1083:         {
1:6ab1083:             TableName   crtn = matchingTable.getTableName();
1:6ab1083:             if ( matchingTable instanceof FromBaseTable )
1:6ab1083:             {
1:6ab1083:                 FromBaseTable   fbt = (FromBaseTable) matchingTable;
1:6ab1083:                 if ( fbt.getExposedTableName() !=  null )
1:6ab1083:                 {
1:6ab1083:                     crtn = fbt.getExposedTableName();
1:6ab1083:                 }
1:6ab1083:             }
1:b0456a0:             columnReference.setQualifiedTableName( crtn );
1:6ab1083:         }
1:6ab1083:         
1:eac0369: 		return matchingRC;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check for (and reject) all ? parameters directly under the ResultColumns.
1:eac0369: 	 * This is done for SELECT statements.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown if a ? parameter found
1:eac0369: 	 *									directly under a ResultColumn
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void rejectParameters() throws StandardException
1:eac0369: 	{
1:eac0369: 		FromTable	fromTable;
1:eac0369: 
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			fromTable = (FromTable) elementAt(index);
1:eac0369: 			fromTable.rejectParameters();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// This method reorders LOJs in the FROM clause.
1:eac0369: 	// For now, we process only a LOJ.  For example, "... from LOJ_1, LOJ2 ..."
1:eac0369: 	// will not be processed. 
1:3bb140c:     boolean LOJ_reorderable(int numTables) throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean anyChange = false;
1:eac0369: 
1:eac0369: 		if (size() > 1) return anyChange;
1:eac0369: 
1:eac0369: 		FromTable ft = (FromTable) elementAt(0);
1:eac0369: 
1:eac0369: 		anyChange = ft.LOJ_reorderable(numTables);
1:eac0369: 
1:eac0369: 		return anyChange;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Preprocess the query tree - this currently means:
1:eac0369: 	 *	o  Generating a referenced table map for each ResultSetNode.
1:eac0369: 	 *  o  Putting the WHERE and HAVING clauses in conjunctive normal form (CNF).
1:eac0369: 	 *  o  Converting the WHERE and HAVING clauses into PredicateLists and
1:eac0369: 	 *	   classifying them.
1:eac0369: 	 *  o  Flatten those FromSubqueries which can be flattened.
1:eac0369: 	 *  o  Ensuring that a ProjectRestrictNode is generated on top of every 
1:eac0369: 	 *     FromBaseTable and generated in place of every FromSubquery which
1:eac0369: 	 *	   could not be flattened.  
1:eac0369: 	 *  o  Pushing single table predicates down to the new ProjectRestrictNodes.
1:eac0369: 	 *
1:eac0369: 	 * @param numTables			The number of tables in the DML Statement
1:eac0369: 	 * @param gbl				The group by list, if any
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void preprocess(int numTables,
1:eac0369: 						   GroupByList gbl,
1:eac0369: 						   ValueNode predicateTree)
1:eac0369: 								throws StandardException
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 
1:eac0369: 		/* Preprocess each FromTable in the list */
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			FromTable ft = (FromTable) elementAt(index);
1:eac0369: 
1:eac0369: 			/* Transform any outer joins to inner joins where appropriate */
1:eac0369: 			ft = ft.transformOuterJoins(predicateTree, numTables);
1:eac0369: 			/* Preprocess this FromTable */
1:eac0369: 			setElementAt(ft.preprocess(numTables, gbl, this), index);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Flatten all the FromTables that are flattenable.
1:eac0369: 	 * RESOLVE - right now we just flatten FromSubqueries.  We
1:eac0369: 	 * should also flatten flattenable JoinNodes here.
1:eac0369: 	 *
1:eac0369: 	 * @param rcl				The RCL from the outer query
1:eac0369: 	 * @param predicateList		The PredicateList from the outer query
1:eac0369: 	 * @param sql				The SubqueryList from the outer query
1:eac0369: 	 * @param gbl				The group by list, if any
1:2e7e8f6:      * @param havingClause      The HAVING clause, if any
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void flattenFromTables(ResultColumnList rcl,
1:eac0369: 								  PredicateList predicateList,
1:eac0369: 								  SubqueryList sql,
1:2e7e8f6:                                   GroupByList gbl,
1:2e7e8f6:                                   ValueNode havingClause)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean			flattened = true;
1:71c8e86: 		ArrayList<Integer>		flattenedTableNumbers = new ArrayList<Integer>();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(rcl != null,
1:eac0369: 							 "rcl is expected to be non-null");
1:eac0369: 			SanityManager.ASSERT(predicateList != null,
1:eac0369: 							 "predicateList is expected to be non-null");
1:eac0369: 			SanityManager.ASSERT(sql != null,
1:eac0369: 							 "sql is expected to be non-null");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Loop until all flattenable entries are flattened.
1:eac0369: 		 * We restart the inner loop after flattening an in place
1:eac0369: 		 * to simplify the logic and so that we don't have to worry
1:eac0369: 		 * about walking a list while we are modifying it.
1:eac0369: 		 */
1:eac0369: 		while (flattened)
1:eac0369: 		{
1:eac0369: 			flattened = false;
1:eac0369: 
1:eac0369: 			for (int index = 0; index < size() && ! flattened; index++)
1:eac0369: 			{
1:eac0369: 				FromTable ft = (FromTable) elementAt(index);
1:eac0369: 
1:eac0369: 				/* Flatten FromSubquerys and flattenable JoinNodes */
1:eac0369: 				if ((ft instanceof FromSubquery) ||
1:eac0369: 					ft.isFlattenableJoinNode())
1:eac0369: 				{
1:eac0369: 					//save the table number of the node to be flattened
1:bb5be6f:                     flattenedTableNumbers.add(ft.getTableNumber());
1:eac0369: 
1:eac0369: 					/* Remove the node from the list and insert its
1:eac0369: 					 * FromList here.
1:eac0369: 					 */
1:eac0369: 					FromList	 flatteningFL = ft.flatten(
1:eac0369: 														rcl,
1:eac0369: 														predicateList,
1:eac0369: 														sql,
1:2e7e8f6:                                                         gbl,
1:2e7e8f6:                                                         havingClause);
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 					{
1:eac0369: 						SanityManager.ASSERT(flatteningFL == null ||
1:eac0369: 											 flatteningFL.size() > 0,
1:eac0369: 							"flatteningFL expected to be null or size > 0");
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					if (flatteningFL != null)
1:eac0369: 					{
1:eac0369: 						setElementAt(flatteningFL.elementAt(0), index);
1:eac0369: 
1:eac0369: 						int innerSize = flatteningFL.size();
1:eac0369: 						for (int inner = 1; inner < innerSize; inner++)
1:eac0369: 						{
1:eac0369: 							insertElementAt(flatteningFL.elementAt(inner), index + inner);
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 					else
1:eac0369: 					{
1:eac0369: 						/*
1:eac0369: 						** If flatten returns null, that means it wants to
1:eac0369: 						** be removed from the FromList.
1:eac0369: 						*/
1:eac0369: 						removeElementAt(index);
1:eac0369: 					}
1:eac0369: 					flattened = true;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		/* fix up dependency maps for exists base tables since they might have a
1:eac0369: 		 * dependency on this join node
1:eac0369: 		 */
1:1c6c2e8: 		if (!flattenedTableNumbers.isEmpty())
1:eac0369: 		{
1:eac0369: 			for (int i = 0; i < size(); i++)
1:eac0369: 			{
1:eac0369: 				FromTable ft = (FromTable) elementAt(i);
1:eac0369: 				if (ft instanceof ProjectRestrictNode)
1:eac0369: 				{
1:eac0369: 					ResultSetNode rst = ((ProjectRestrictNode)ft).getChildResult();
1:eac0369: 					if (rst instanceof FromBaseTable)
1:eac0369: 					{
1:eac0369: 						((FromBaseTable)rst).clearDependency(flattenedTableNumbers);
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Categorize and push the predicates that are pushable.
1:eac0369: 	 *
1:eac0369: 	 * @param predicateList		The query's PredicateList
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void pushPredicates(PredicateList predicateList)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(predicateList != null,
1:eac0369: 							 "predicateList is expected to be non-null");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* We can finally categorize each Predicate and try to push them down.
1:eac0369: 		 * NOTE: The PredicateList may be empty, but that's okay, we still
1:eac0369: 		 * call pushExpressions() for each entry in the FromList because that's
1:eac0369: 		 * where any outer join conditions will get pushed down.
1:eac0369: 		 */
1:eac0369: 		predicateList.categorize();
1:eac0369: 
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
2:eac0369: 			FromTable fromTable = (FromTable) elementAt(index);
1:eac0369: 			fromTable.pushExpressions(predicateList);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the (query block) level (0-based) for the FromTables in this
1:eac0369: 	 * FromList.
1:eac0369: 	 *
1:eac0369: 	 * @param level		The query block level for this table.
1:eac0369: 	 */
1:3bb140c:     void setLevel(int level)
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			FromTable fromTable = (FromTable) elementAt(index);
1:eac0369: 			fromTable.setLevel(level);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the FromTable from this list which has the specified ResultColumn in
1:eac0369: 	 * its RCL.
1:eac0369: 	 *
1:eac0369: 	 * @param rc	The ResultColumn match on.
1:eac0369: 	 *
1:eac0369: 	 * @return FromTable	The matching FromTable.
1:eac0369: 	 */
1:9f2ed7d:     FromTable getFromTableByResultColumn(ResultColumn rc)
1:eac0369: 	{
1:eac0369: 		FromTable	fromTable = null;
1:eac0369: 
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			fromTable = (FromTable) elementAt(index);
1:eac0369: 
1:eac0369: 			if (fromTable.getResultColumns().indexOf(rc) != -1)
1:eac0369: 			{
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(fromTable != null,
1:eac0369: 				"No matching FromTable found");
1:eac0369: 		}
1:eac0369: 		return fromTable;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the Properties list for this FromList.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void setProperties(Properties props) throws StandardException
1:eac0369: 	{
1:eac0369: 		properties = props;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Validate the properties list now.  This is possible because
1:eac0369: 		** there is nothing in this properties list that relies on binding
1:eac0369: 		** or optimization to validate.
1:eac0369: 		*/
1:e1f49ca:         Enumeration<?> e = properties.keys();
1:df9af89: 		while (e.hasMoreElements())
1:eac0369: 		{
1:df9af89: 			String key = (String) e.nextElement();
1:eac0369: 			String value = (String) properties.get(key);
1:eac0369: 
1:eac0369: 			if (key.equals("joinOrder"))
1:eac0369: 			{
1:eac0369: 				if (StringUtil.SQLEqualsIgnoreCase(value,"fixed"))
1:eac0369: 				{
1:eac0369: 					fixedJoinOrder = true;
1:eac0369: 				}
1:eac0369: 				else if (StringUtil.SQLEqualsIgnoreCase(value,"unfixed"))
1:eac0369: 				{
1:eac0369: 					fixedJoinOrder = false;
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_INVALID_JOIN_ORDER_SPEC, value);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			else if (key.equals("useStatistics"))
1:eac0369: 			{
1:eac0369: 				if (StringUtil.SQLEqualsIgnoreCase(value,"true"))
1:eac0369: 				{
1:eac0369: 					useStatistics = true;
1:eac0369: 				}
1:eac0369: 				else if (StringUtil.SQLEqualsIgnoreCase(value,"false"))
1:eac0369: 				{
1:eac0369: 					useStatistics = false;
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_INVALID_STATISTICS_SPEC, value);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_INVALID_FROM_LIST_PROPERTY, key, value);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see OptimizableList#reOrder */
1:eac0369: 	public void reOrder(int[] joinOrder)
1:eac0369: 	{
1:eac0369: 		int	posn;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (joinOrder.length != size())
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT("In reOrder(), size of FromList is " + size() + " while size of joinOrder array is " + joinOrder.length);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Determine that the values in the list are unique and in range.
1:eac0369: 			** The easiest way to determine that they are unique is to add
1:eac0369: 			** them all up and see whether the result is what's expected
1:eac0369: 			** for that array size.
1:eac0369: 			*/
1:eac0369: 			int sum = 0;
2:eac0369: 			for (int i = 0; i < joinOrder.length; i++)
1:eac0369: 			{
1:eac0369: 				if (joinOrder[i] < 0 || joinOrder[i] > (joinOrder.length - 1))
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT("joinOrder[" + i + "] == " +
1:eac0369: 											joinOrder[i] +
1:eac0369: 											" is out of range - must be between 0 and " + 
1:eac0369: 											(joinOrder.length - 1) +
1:eac0369: 											" inclusive.");
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				sum += joinOrder[i];
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** The sum of all integers from 0 through n is (n * (n - 1)) / 2.
1:eac0369: 			*/
1:eac0369: 			if (sum != ( ( joinOrder.length * (joinOrder.length - 1) ) / 2) )
1:eac0369: 			{
1:e1f49ca:                 StringBuilder arrayVals = new StringBuilder();
1:e1f49ca:                 for (int i : joinOrder) {
1:e1f49ca:                     arrayVals.append(i);
1:e1f49ca:                     arrayVals.append(' ');
1:e1f49ca:                 }
1:eac0369: 				SanityManager.THROWASSERT("joinOrder array has some duplicate value: " + arrayVals);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Form a list that's in the order we want */
1:e1f49ca:         ResultSetNode[] orderedFL = new FromTable[joinOrder.length];
1:eac0369: 		for (posn = 0; posn < joinOrder.length; posn++)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Get the element at the i'th join order position from the
1:eac0369: 			** current list and make it the next element of orderedList.
1:eac0369: 			*/
1:eac0369: 			orderedFL[posn] = elementAt(joinOrder[posn]);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Now orderedList has been built, so set this list to the same order */
1:eac0369: 		for (posn = 0; posn < joinOrder.length; posn++)
1:eac0369: 		{
1:eac0369: 			setElementAt(orderedFL[posn], posn);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see OptimizableList#useStatistics */
1:eac0369: 	public boolean useStatistics()
1:eac0369: 	{
1:eac0369: 		return useStatistics;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see OptimizableList#optimizeJoinOrder */
1:eac0369: 	public boolean optimizeJoinOrder()
1:eac0369: 	{
1:eac0369: 		return ! fixedJoinOrder;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see OptimizableList#legalJoinOrder */
1:eac0369: 	public boolean legalJoinOrder(int numTablesInQuery)
1:eac0369: 	{
1:eac0369: 		JBitSet			assignedTableMap = new JBitSet(numTablesInQuery);
1:eac0369: 
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			FromTable ft = (FromTable) elementAt(index);
1:eac0369: 			assignedTableMap.or(ft.getReferencedTableMap());
1:eac0369: 			if ( ! ft.legalJoinOrder(assignedTableMap))
1:eac0369: 			{
2:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 		}
2:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see OptimizableList#initAccessPaths */
1:eac0369: 	public void initAccessPaths(Optimizer optimizer)
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			FromTable ft = (FromTable) elementAt(index);
1:eac0369: 			ft.initAccessPaths(optimizer);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind any untyped null nodes to the types in the given ResultColumnList.
1:eac0369: 	 *
1:eac0369: 	 * @param bindingRCL	The ResultColumnList with the types to bind to.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void bindUntypedNullsToResultColumns(ResultColumnList bindingRCL)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			FromTable fromTable = (FromTable) elementAt(index);
1:eac0369: 			fromTable.bindUntypedNullsToResultColumns(bindingRCL);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Decrement (query block) level (0-based) for
1:eac0369: 	 * all of the tables in this from list.
1:eac0369: 	 * This is useful when flattening a subquery.
1:eac0369: 	 *
1:eac0369: 	 * @param decrement	The amount to decrement by.
1:eac0369: 	 */
1:eac0369: 	void decrementLevel(int decrement)
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			FromTable fromTable = (FromTable) elementAt(index);
1:eac0369: 			fromTable.decrementLevel(decrement);
1:eac0369: 
1:eac0369: 			/* Decrement the level of any CRs in single table
1:eac0369: 			 * predicates that are interesting to transitive
1:eac0369: 			 * closure.
1:eac0369: 			 */
1:eac0369: 			ProjectRestrictNode prn = (ProjectRestrictNode) fromTable;
1:eac0369: 			PredicateList pl = prn.getRestrictionList();
1:eac0369: 			if (pl != null)
1:eac0369: 			{
1:eac0369: 				pl.decrementLevel(this, decrement);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This method is used for both subquery flattening and distinct
1:eac0369: 	 * elimination based on a uniqueness condition.  For subquery
1:eac0369: 	 * flattening we want to make sure that the query block
1:eac0369: 	 * will return at most 1 row.  For distinct elimination we
1:eac0369: 	 * want to make sure that the query block will not return
1:eac0369: 	 * any duplicates.
1:eac0369: 	 * This is true if every table in the from list is
1:eac0369: 	 * (a base table and the set of columns from the table that
1:eac0369: 	 * are in equality comparisons with expressions that do not include columns
1:eac0369: 	 * from the same table is a superset of any unique index
1:eac0369: 	 * on the table) or an EXISTS FBT.  In addition, at least 1 of the tables
1:eac0369: 	 * in the list has a set of columns in equality comparisons with expressions
1:eac0369: 	 * that do not include column references from the same query block
1:eac0369: 	 * is a superset of a unique index
1:eac0369: 	 * on that table.  (This ensures that the query block will onlyr
1:eac0369: 	 * return a single row.)
1:eac0369: 	 * This method is expected to be called after normalization and
1:eac0369: 	 * after the from list has been preprocessed.
1:eac0369: 	 * It can be called both before and after the predicates have
1:eac0369: 	 * been pulled from the where clause.
1:eac0369: 	 * The algorithm for this is as follows
1:eac0369: 	 *
1:eac0369: 	 *	If any table in the query block is not a base table, give up.
1:eac0369: 	 * 	For each table in the query
1:eac0369: 	 *		Ignore exists table since they can only produce one row
1:eac0369: 	 *
1:eac0369: 	 *		create a matrix of tables and columns from the table (tableColMap)
1:eac0369: 	 *		(this is used to keep track of the join columns and constants
1:eac0369: 	 *		that can be used to figure out whether the rows from a join
1:eac0369: 	 *		or in a select list are distinct based on unique indexes)
1:eac0369: 	 *
1:eac0369: 	 *		create an array of columns from the table(eqOuterCol)
1:eac0369: 	 *		(this is used to determine that only one row will be returned
1:eac0369: 	 *		from a join)
1:eac0369: 	 *
1:eac0369: 	 *		if the current table is the table for the result columns
1:eac0369: 	 *			set the result columns in the eqOuterCol and tableColMap
1:eac0369: 	 *			(if these columns are a superset of a unique index and
1:eac0369: 	 *			all joining tables result in only one row, the
1:eac0369: 	 *			results will be distinct)
1:eac0369: 	 *		go through all the predicates and update tableColMap  and
1:eac0369: 	 *		eqOuterCol with join columns and correlation variables,
1:eac0369: 	 *		parameters and constants
1:eac0369: 	 *		since setting constants, correlation variables and parameters,
1:eac0369: 	 * 		reduces the number of columns required for uniqueness in a
1:eac0369: 	 *		multi-column index, they are set for all the tables (if the
1:eac0369: 	 *		table is not the result table, in this case only the column of the
1:eac0369:      *		result table is set)
1:eac0369: 	 *		join columns are just updated for the column in the row of the
1:eac0369: 	 *		joining table.
1:eac0369: 	 *
1:eac0369: 	 *		check if the marked columns in tableColMap are a superset of a unique
1:eac0369: 	 *			index
1:eac0369: 	 *			(This means that the join will only produce 1 row when joined
1:eac0369: 	 *			with 1 row of another table)
1:eac0369: 	 *		check that there is a least one table for which the columns in
1:eac0369: 	 *			eqOuterCol(i.e. constant values) are a superset of a unique index
1:eac0369: 	 *			(This quarantees that there will be only one row selected
1:eac0369: 	 *			from this table).
1:eac0369: 	 *
1:eac0369: 	 *	Once all tables have been evaluated, check that all the tables can be
1:eac0369: 	 * 	joined by unique index or will have only one row
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @param rcl				If non-null, the RCL from the query block.
1:eac0369: 	 *							If non-null for subqueries, then entry can
1:eac0369: 	 *							be considered as part of an = comparison.
1:eac0369: 	 * @param whereClause		The WHERE clause to consider.
1:eac0369: 	 * @param wherePredicates	The predicates that have already been
1:eac0369: 	 *							pulled from the WHERE clause.
1:eac0369: 	 * @param dd				The DataDictionary to use.
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether or not query block will return
1:eac0369: 	 *			at most 1 row for a subquery, no duplicates
1:eac0369: 	 *			for a distinct.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	boolean returnsAtMostSingleRow(ResultColumnList rcl,
1:eac0369: 								   ValueNode whereClause,
1:eac0369: 								   PredicateList wherePredicates,
1:eac0369: 								   DataDictionary dd)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean			satisfiesOuter = false;
1:eac0369: 		int[]			tableNumbers;
1:eac0369: 		ColumnReference	additionalCR = null;
1:eac0369: 
1:ef20e7a: 		PredicateList predicatesTemp;
1:3bb140c:         predicatesTemp = new PredicateList(getContextManager());
1:e1f49ca: 
1:e1f49ca:         for (Predicate p : wherePredicates) {
1:e1f49ca:             predicatesTemp.addPredicate(p);
1:e1f49ca:         }
1:eac0369: 
1:eac0369: 		/* When considering subquery flattening, we are interested
1:eac0369: 		 * in the 1st (and only) entry in the RCL.  (The RCL will be
1:eac0369: 		 * null if result column is not of interest for subquery flattening.)
1:eac0369: 		 * We are interested in all entries in the RCL for distinct
1:eac0369: 		 * elimination.
1:eac0369: 		 */
1:eac0369: 		if (rcl != null)
1:eac0369: 		{
1:e1f49ca:             ResultColumn rc = rcl.elementAt(0);
1:eac0369: 			if (rc.getExpression() instanceof ColumnReference)
1:eac0369: 			{
1:eac0369: 				additionalCR = (ColumnReference) rc.getExpression();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* First see if all entries are FromBaseTables.  No point
1:eac0369: 		 * in continuing if not.
1:eac0369: 		 */
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			FromTable fromTable = (FromTable) elementAt(index);
1:eac0369: 			if (! (fromTable instanceof ProjectRestrictNode))
1:eac0369: 			{
1:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			ProjectRestrictNode prn = (ProjectRestrictNode) fromTable;
1:eac0369: 
1:eac0369: 			if (! (prn.getChildResult() instanceof FromBaseTable))
1:eac0369: 			{
1:eac0369: 				return false;
1:eac0369: 			}
1:ef20e7a: 			FromBaseTable fbt = (FromBaseTable) prn.getChildResult();
1:ef20e7a: 			//Following for loop code is to take care of Derby-251 (DISTINCT returns
1:ef20e7a: 			//duplicate rows).
1:ef20e7a: 			//Derby-251 returned duplicate rows because we were looking at predicates
1:ef20e7a: 			//that belong to existsTable to determine DISTINCT elimination
1:ef20e7a: 			//
1:ef20e7a: 			//(Check method level comments to understand DISTINCT elimination rules.)
1:ef20e7a: 			//
1:ef20e7a: 			//For one specific example, consider the query below
1:ef20e7a: 			//select  distinct  q1."NO1" from IDEPT q1, IDEPT q2
1:ef20e7a: 			//where  ( q2."DISCRIM_DEPT" = 'HardwareDept')
1:ef20e7a: 			//and  ( q1."DISCRIM_DEPT" = 'SoftwareDept')  and  ( q1."NO1" <> ALL
1:ef20e7a: 			//(select  q3."NO1" from IDEPT q3 where  (q3."REPORTTO_NO" =  q2."NO1")))
1:ef20e7a: 			//(select  q3."NO1" from IDEPT q3 where  ( ABS(q3."REPORTTO_NO") =  q2."NO1")))
1:ef20e7a: 			//
1:ef20e7a: 			//Table IDEPT in the query above has a primary key defined on column "NO1"
1:ef20e7a: 			//This query gets converted to following during optimization
1:ef20e7a: 			//
1:ef20e7a: 			//select  distinct  q1."NO1" from IDEPT q1, IDEPT q2
1:ef20e7a: 			//where  ( q2."DISCRIM_DEPT" = 'HardwareDept')
1:ef20e7a: 			//and  ( q1."DISCRIM_DEPT" = 'SoftwareDept')  and  not exists (
1:ef20e7a: 			//(select  q3."NO1" from IDEPT q3 where
1:ef20e7a: 			//(  ( ABS(q3."REPORTTO_NO") =  q2."NO1")  and q3."NO1" = q1."NO1") ) )  ;
1:ef20e7a: 			//
1:ef20e7a: 			//For the optimized query above, Derby generates following predicates.
1:ef20e7a: 			//ABS(q3.reportto_no) = q2.no1
1:ef20e7a: 			//q2.discrim_dept = 'HardwareDept'
1:ef20e7a: 			//q1.descrim_dept = 'SoftwareDept'
1:ef20e7a: 			//q1.no1 = q3.no1
1:ef20e7a: 			//The predicate ABS(q3."NO1") = q1."NO1" should not be considered when trying
1:ef20e7a: 			//to determine if q1 in the outer query has equality comparisons. 
1:ef20e7a: 			//Similarly, the predicate q3.reportto_no = q2.no1 should not be
1:ef20e7a: 			//considered when trying to determine if q2 in the outer query has
1:ef20e7a: 			//equality comparisons. To achieve this, predicates based on exists base
1:ef20e7a: 			//table q3 (the first and the last predicate) should be removed while
1:ef20e7a: 			//evaluating outer query for uniqueness.
1:ef20e7a: 			//
1:ef20e7a: 			if (fbt.getExistsBaseTable())
1:eac0369: 			{
1:ef20e7a: 				int existsTableNumber = fbt.getTableNumber();
1:e1f49ca: 
1:e1f49ca:                 for (int i = predicatesTemp.size() - 1; i >= 0; i--)
1:eac0369: 				{
1:3bb140c:                     AndNode topAndNode =
1:e1f49ca:                             predicatesTemp.elementAt(i).getAndNode();
1:eac0369: 
1:ef20e7a: 					for (ValueNode whereWalker = topAndNode; whereWalker instanceof AndNode;
1:ef20e7a: 						whereWalker = ((AndNode) whereWalker).getRightOperand())
1:eac0369: 					{
1:ef20e7a: 						// See if this is a candidate =
1:ef20e7a: 						AndNode and = (AndNode) whereWalker;
1:eac0369: 
1:ef20e7a: 						//we only need to worry about equality predicates because only those
1:ef20e7a: 						//predicates are considered during DISTINCT elimination.
1:ef20e7a: 						if (!and.getLeftOperand().isRelationalOperator() ||
1:ef20e7a: 							!(((RelationalOperator)(and.getLeftOperand())).getOperator() ==
1:ef20e7a: 							RelationalOperator.EQUALS_RELOP))
1:eac0369: 						{
1:ef20e7a: 							continue;
1:eac0369: 						}
1:eac0369: 
1:ef20e7a: 						JBitSet referencedTables = and.getLeftOperand().getTablesReferenced();
1:ef20e7a: 						if (referencedTables.get(existsTableNumber))
3:0787955: 						{
1:e1f49ca:                             predicatesTemp.removeElementAt(i);
1:ef20e7a: 							break;
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
3:0787955: 		}
1:eac0369: 
1:eac0369: 		/* Build an array of tableNumbers from this query block.
1:eac0369: 		 * We will use that array to find out if we have at least
1:eac0369: 		 * one table with a uniqueness condition based only on
1:eac0369: 		 * constants, parameters and correlation columns.
1:eac0369: 		 */
1:eac0369: 		tableNumbers = getTableNumbers();
1:eac0369: 		JBitSet[][] tableColMap = new JBitSet[size][size];
1:eac0369: 		boolean[] oneRow = new boolean[size];
1:3bb140c:         boolean oneRowResult;
1:eac0369: 
1:eac0369: 		/* See if each table has a uniqueness condition */
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			ProjectRestrictNode prn = (ProjectRestrictNode) elementAt(index);
1:eac0369: 			FromBaseTable fbt = (FromBaseTable) prn.getChildResult();
1:eac0369: 
1:eac0369: 			// Skip over EXISTS FBT since they cannot introduce duplicates
1:eac0369: 			if (fbt.getExistsBaseTable())
1:eac0369: 			{
1:eac0369: 				oneRow[index] = true;
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			int numColumns = fbt.getTableDescriptor().getNumberOfColumns();
1:eac0369: 			boolean[] eqOuterCols = new boolean[numColumns + 1];
1:eac0369: 			int tableNumber = fbt.getTableNumber();
1:eac0369: 			boolean resultColTable = false;
1:eac0369: 			for (int i = 0; i < size; i++)
1:eac0369: 				tableColMap[index][i] = new JBitSet(numColumns + 1);
1:eac0369: 
1:eac0369: 			if (additionalCR != null &&
1:eac0369: 				additionalCR.getTableNumber() == tableNumber)
1:eac0369: 			{
1:eac0369: 				rcl.recordColumnReferences(eqOuterCols, tableColMap[index], index);
1:eac0369: 				resultColTable = true;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* Now see if there are any equality conditions
1:eac0369: 			 * of interest in the where clause.
1:eac0369: 			 */
1:eac0369: 			if (whereClause != null)
1:eac0369: 			{
1:eac0369: 				whereClause.checkTopPredicatesForEqualsConditions(
1:eac0369: 								tableNumber, eqOuterCols, tableNumbers,
1:eac0369: 								tableColMap[index], resultColTable);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* Now see if there are any equality conditions
1:eac0369: 			 * of interest in the where predicates.
1:eac0369: 			 */
1:ef20e7a: 			predicatesTemp.checkTopPredicatesForEqualsConditions(
1:eac0369: 								tableNumber, eqOuterCols, tableNumbers,
1:eac0369: 								tableColMap[index], resultColTable);
1:eac0369: 
1:eac0369: 			/* Now see if there are any equality conditions
1:eac0369: 			 * of interest that were already pushed down to the
1:eac0369: 			 * PRN above the FBT. (Single table predicates.)
1:eac0369: 			 */
1:eac0369: 			if (prn.getRestrictionList() != null)
1:eac0369: 			{
1:eac0369: 				prn.getRestrictionList().checkTopPredicatesForEqualsConditions(
1:eac0369: 								tableNumber, eqOuterCols, tableNumbers,
1:eac0369: 								tableColMap[index], resultColTable);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* We can finally check to see if the marked columns
1:eac0369: 			 * are a superset of any unique index.
1:eac0369: 			 */
1:eac0369: 			if (! fbt.supersetOfUniqueIndex(tableColMap[index]))
1:eac0369: 			{
1:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 			
1:eac0369: 			/* Do we have at least 1 table whose equality condition
1:eac0369: 			 * is based solely on constants, parameters and correlation columns.
1:eac0369: 			 */
1:eac0369: 			oneRowResult = fbt.supersetOfUniqueIndex(eqOuterCols);
1:eac0369: 			if (oneRowResult)
1:eac0369: 			{
1:eac0369: 				oneRow[index] = true;
1:eac0369: 				satisfiesOuter = true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Have we met all of the criteria */
1:eac0369: 		if (satisfiesOuter)
1:eac0369: 		{
1:eac0369: 			/* check that all the tables are joined by unique indexes 
1:eac0369: 			 * or only produce 1 row
1:eac0369: 			 */
1:eac0369: 			boolean foundOneRow = true;
1:eac0369: 			while (foundOneRow)
1:eac0369: 			{
1:eac0369: 				foundOneRow = false;
1:eac0369: 				for (int index = 0; index < size; index++)
1:eac0369: 				{
1:eac0369: 					if (oneRow[index])
1:eac0369: 					{
1:eac0369: 						for (int i = 0; i < size; i++)
1:eac0369: 						{
1:eac0369: 							/* unique key join - exists tables already marked as 
1:eac0369: 							 * 1 row - so don't need to look at them
1:eac0369: 							 */
1:eac0369: 							if (!oneRow[i] && tableColMap[i][index].get(0))
1:eac0369: 							{
1:eac0369: 								oneRow[i] = true;
1:eac0369: 								foundOneRow = true;
1:eac0369: 							}
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			/* does any table produce more than one row */
1:eac0369: 			for (int index = 0; index < size; index++)
1:eac0369: 			{
1:eac0369: 				if (!oneRow[index])
1:eac0369: 				{
1:eac0369: 					satisfiesOuter = false;
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return satisfiesOuter;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	int[] getTableNumbers()
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 		int[] tableNumbers = new int[size];
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			ProjectRestrictNode prn = (ProjectRestrictNode) elementAt(index);
1:eac0369: 			if (! (prn.getChildResult() instanceof FromTable))
1:eac0369: 			{
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 			FromTable ft = (FromTable) prn.getChildResult();
1:eac0369: 			tableNumbers[index] = ft.getTableNumber();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return tableNumbers;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark all of the FromBaseTables in the list as EXISTS FBTs.
1:eac0369: 	 * Each EBT has the same dependency list - those tables that are referenced
1:eac0369: 	 * minus the tables in the from list.
1:eac0369: 	 *
1:eac0369: 	 * @param referencedTableMap	The referenced table map.
1:eac0369: 	 * @param outerFromList			FromList from outer query block
1:eac0369: 	 * @param isNotExists			Whether or not for NOT EXISTS
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void genExistsBaseTables(JBitSet referencedTableMap, FromList outerFromList,
1:eac0369: 							 boolean isNotExists)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		JBitSet			dependencyMap = (JBitSet) referencedTableMap.clone();
1:eac0369: 
1:eac0369: 		// We currently only flatten single table from lists
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (size() != 1)
1:eac0369: 			{
2:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"size() expected to be 1, not " + size());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Create the dependency map */
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			ResultSetNode ft = ((ProjectRestrictNode) elementAt(index)).getChildResult();
1:eac0369: 			if (ft instanceof FromTable)
1:eac0369: 			{
1:eac0369: 				dependencyMap.clear(((FromTable) ft).getTableNumber());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Degenerate case - If flattening a non-correlated EXISTS subquery
1:eac0369: 		 * then we need to make the table that is getting flattened dependendent on
1:eac0369: 		 * all of the tables in the outer query block.  Gross but true.  Otherwise
1:eac0369: 		 * that table can get chosen as an outer table and introduce duplicates.
1:eac0369: 		 * The reason that duplicates can be introduced is that we do special processing
1:eac0369: 		 * in the join to make sure only one qualified row from the right side is
1:eac0369: 		 * returned.  If the exists table is on the left, we can return all the
1:eac0369: 		 * qualified rows. 
1:eac0369: 		 */
1:eac0369: 		if (dependencyMap.getFirstSetBit() == -1)
1:eac0369: 		{
1:eac0369: 			int outerSize = outerFromList.size();
1:eac0369: 			for (int outer = 0; outer < outerSize; outer++)
1:eac0369: 				dependencyMap.or(((FromTable) outerFromList.elementAt(outer)).getReferencedTableMap());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Do the marking */
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			FromTable fromTable = (FromTable) elementAt(index);
1:eac0369: 			if (fromTable instanceof ProjectRestrictNode)
1:eac0369: 			{
1:eac0369: 				ProjectRestrictNode prn = (ProjectRestrictNode) fromTable;
1:eac0369: 				if (prn.getChildResult() instanceof FromBaseTable)
1:eac0369: 				{
1:eac0369: 					FromBaseTable fbt = (FromBaseTable) prn.getChildResult();
1:eac0369: 					fbt.setExistsBaseTable(true, (JBitSet) dependencyMap.clone(), isNotExists);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:9247f31: 	 * determine whether this table is NOT EXISTS.
1:9247f31: 	 *
1:9247f31: 	 * This routine searches for the indicated table number in the fromlist
1:9247f31: 	 * and returns TRUE if the table is present in the from list and is 
1:9247f31: 	 * marked NOT EXISTS, false otherwise.
1:9247f31: 	 *
1:9247f31: 	 * A table may be present in the from list for NOT EXISTS if it is used
1:9247f31: 	 * as a correlated NOT EXISTS subquery. In such a situation, when the
1:9247f31: 	 * subquery is flattened, it is important that we remember that this is
1:9247f31: 	 * a NOT EXISTS subquery, because the join semantics are different 
1:9247f31: 	 * (we're looking for rows that do NOT match, rather than rows
1:9247f31: 	 * that do). And since the join semantics are different, we cannot
1:9247f31: 	 * include this table into a transitive closure of equijoins
1:9247f31: 	 * (See DERBY-3033 for a situation where this occurs).
1:9247f31: 	 *
1:9247f31: 	 * @param tableNumber	which table to check
1:9247f31: 	 * @return true if this table is in the from list as NOT EXISTS
1:9247f31: 	 */
1:9247f31: 	boolean tableNumberIsNotExists(int tableNumber)
1:9247f31: 		throws StandardException
1:9247f31: 	{
1:9247f31: 		int size = size();
1:9247f31: 		for (int index = 0; index < size; index++)
1:9247f31: 		{
1:9247f31: 			ProjectRestrictNode prn = (ProjectRestrictNode) elementAt(index);
1:9247f31: 			if (! (prn.getChildResult() instanceof FromTable))
1:9247f31: 			{
1:9247f31: 				continue;
1:9247f31: 			}
1:9247f31: 			FromTable ft = (FromTable) prn.getChildResult();
1:9247f31: 			if (ft.getTableNumber() == tableNumber)
1:9247f31: 				return ft.isNotExists();
1:9247f31: 		}
1:9247f31: 		return false;
1:9247f31: 	}
1:9247f31: 	/**
1:eac0369: 	 * Get the lock mode for the target of an update statement
1:eac0369: 	 * (a delete or update).  The update mode will always be row for
1:eac0369: 	 * CurrentOfNodes.  It will be table if there is no where clause.
1:eac0369: 	 *
1:eac0369: 	 * @return	The lock mode
1:eac0369: 	 */
1:3bb140c:     int updateTargetLockMode()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (size() != 1)
1:eac0369: 			{
1:6ab1083: 				SanityManager.THROWASSERT
1:6ab1083:                     ( "size() is " + size() + " but should be 1");
1:eac0369: 			}
1:eac0369: 		}
1:e1f49ca:         return elementAt(0).updateTargetLockMode();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not the user specified a hash join for any of the 
1:eac0369: 	 * tables in this list.
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether or not the user specified a hash join for any of the 
1:eac0369: 	 *			tables in this list.
1:eac0369: 	 */
1:eac0369: 	boolean hashJoinSpecified()
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			FromTable ft = (FromTable) elementAt(index);
1:eac0369: 			String joinStrategy = ft.getUserSpecifiedJoinStrategy();
1:eac0369: 
1:eac0369: 			if (joinStrategy != null && StringUtil.SQLToUpperCase(joinStrategy).equals("HASH"))
1:eac0369: 			{
1:eac0369: 				return true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:0787955: 	 * Indicate that this FromList is "transparent", which means that
1:0787955: 	 * its FromTables should be bound to tables from an outer query.
1:0787955: 	 * Generally this is not allowed, but there are exceptions.  See
1:0787955: 	 * SetOperatorNode.setResultToBooleanTrueNode() for more.
1:eac0369: 	 */
1:0787955: 	void markAsTransparent()
1:eac0369: 	{
1:0787955: 		isTransparent = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:7a9ce7e: 	 * Set windows field to the supplied value.
1:7a9ce7e: 	 * @param windows list of window definitions associated with a SELECT.
1:7a9ce7e: 	 */
1:3bb140c:     void setWindows(WindowList windows) {
1:7a9ce7e: 		this.windows = windows;
1:7a9ce7e: 	}
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e: 	/**
1:7a9ce7e: 	 * @return list of window definitions associated with a SELECT.
1:7a9ce7e: 	 */
1:3bb140c:     WindowList getWindows() {
1:7a9ce7e: 		return windows;
1:7a9ce7e: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 *      union select * from diffrow where onerow.j &lt; diffrow.k)
commit:b93f9db
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // Don't add USAGE privilege on user-defined types just because we're
1:         // binding tables.
1:         //
1:         boolean wasSkippingTypePrivileges = getCompilerContext().skipTypePrivileges( true );
1:         
/////////////////////////////////////////////////////////////////////////
1:         getCompilerContext().skipTypePrivileges( wasSkippingTypePrivileges );
commit:3e77b5a
/////////////////////////////////////////////////////////////////////////
1: 			FromTable   newNode = (FromTable) fromTable.bindNonVTITables(dataDictionary, fromListParam);
1:             {
1:             }
1:             newNode.setMergeTableID( fromTable.getMergeTableID() );
1: 			FromTable   newNode = (FromTable) fromTable.bindVTITables(fromListParam);
1:             {
1:             }
1:             newNode.setMergeTableID( fromTable.getMergeTableID() );
/////////////////////////////////////////////////////////////////////////
1:             //
1:             // If the MERGE statement has marked its variables, we expect to follow
1:             // its judgment. Make sure that we only match SOURCE columns to
1:             // SOURCE tables and TARGET columns to TARGET tables.
1:             //
1:             if (
1:                 (fromTable.getMergeTableID() != ColumnReference.MERGE_UNKNOWN) &&
1:                 (columnReference.getMergeTableID() != ColumnReference.MERGE_UNKNOWN) &&
1:                 (fromTable.getMergeTableID() != columnReference.getMergeTableID())
1:                 )
1:             {
1:                 continue;
1:             }
1: 
commit:b0456a0
/////////////////////////////////////////////////////////////////////////
1:             columnReference.setQualifiedTableName( crtn );
commit:6ab1083
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1: 	 * if a column name is not unique. This method fills in various fields
1:      * in the column reference.
1:      * </p>
1:      * <p>
1:      * </p>
1:      * <p>
1: 	 * For example,
1:      * <p>
1:      *
1:      * <pre>
1:      *s (a, b, c), t (d, e, f)
1:      * </pre>
1:      *
1:      * <p>
1:      * </p>
1:      * <p>
1:      * </p>
/////////////////////////////////////////////////////////////////////////
1: 		FromTable		fromTable = null;
1: 		FromTable		matchingTable = null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     {
1: 						getCompilerContext().addRequiredColumnPriv( resultColumn.getTableColumnDescriptor());
1:                     }
1: 
1:                     matchingTable = fromTable;
/////////////////////////////////////////////////////////////////////////
1:         // fill in the table name
1:         if ( (matchingTable != null) && (matchingRC != null) && (columnReference.getTableName() == null) )
1:         {
1:             TableName   crtn = matchingTable.getTableName();
1:             if ( matchingTable instanceof FromBaseTable )
1:             {
1:                 FromBaseTable   fbt = (FromBaseTable) matchingTable;
1:                 if ( fbt.getExposedTableName() !=  null )
1:                 {
1:                     crtn = fbt.getExposedTableName();
1:                 }
1:             }
0:             columnReference.setTableNameNode( crtn );
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1: 				SanityManager.THROWASSERT
1:                     ( "size() is " + size() + " but should be 1");
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1: 		ArrayList<Integer>		flattenedTableNumbers = new ArrayList<Integer>();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:bb5be6f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     flattenedTableNumbers.add(ft.getTableNumber());
commit:4fc5f9c
/////////////////////////////////////////////////////////////////////////
1:      * @return ResultColumn     The matching ResultColumn, or {@code null} if
1:      *                          there is no matching column
commit:e3720ab
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.conn.Authorizer;
/////////////////////////////////////////////////////////////////////////
1: 
1:         // DERBY-4191: We must have some SELECT privilege on every table
1:         // that we read from, even if we don't actually read any column
1:         // values from it (for example if we do SELECT COUNT(*) FROM T).
1:         // We ask for MIN_SELECT_PRIV requirement of the first column in
1:         // the table. The first column is just a place holder. What we
1:         // really do at execution time when we see we are looking for
1:         // MIN_SELECT_PRIV privilege is as follows:
1:         //
1:         // 1) We will look for SELECT privilege at table level.
1:         // 2) If not found, we will look for SELECT privilege on
1:         //    ANY column, not necessarily the first column. But since
1:         //    the constructor for column privilege requires us to pass
1:         //    a column descriptor, we just choose the first column for
1:         //    MIN_SELECT_PRIV requirement.
1:         final CompilerContext cc = getCompilerContext();
1:         cc.pushCurrentPrivType(Authorizer.MIN_SELECT_PRIV);
1:         for (int index = 0; index < size; index++) {
1:             fromTable = (FromTable) elementAt(index);
1:             if (fromTable.isPrivilegeCollectionRequired() &&
1:                     fromTable.isBaseTable() && !fromTable.forUpdate()) {
1:                 // This is a base table in the FROM list of a SELECT statement.
1:                 // Make sure we check for minimum SELECT privilege on it.
1:                 cc.addRequiredColumnPriv(
1:                     fromTable.getTableDescriptor().getColumnDescriptor(1));
1:             }
1:         }
1:         cc.popCurrentPrivType();
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
0:     void addFromTable(FromTable fromTable) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
/////////////////////////////////////////////////////////////////////////
1:     FromTable getFromTableByResultColumn(ResultColumn rc)
commit:1c6c2e8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.util.ReuseFactory;
1: import java.util.ArrayList;
1: 
/////////////////////////////////////////////////////////////////////////
0: 		ArrayList		flattenedTableNumbers = new ArrayList();
/////////////////////////////////////////////////////////////////////////
0:                     flattenedTableNumbers.add(
0:                             ReuseFactory.getInteger(ft.getTableNumber()));
/////////////////////////////////////////////////////////////////////////
1: 		if (!flattenedTableNumbers.isEmpty())
commit:a32eb9f
/////////////////////////////////////////////////////////////////////////
0: 					flattenedTableNumbers.add(new Integer(ft.getTableNumber()));
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
commit:2d9b17d
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:9247f31
/////////////////////////////////////////////////////////////////////////
1: 	 * determine whether this table is NOT EXISTS.
1: 	 *
1: 	 * This routine searches for the indicated table number in the fromlist
1: 	 * and returns TRUE if the table is present in the from list and is 
1: 	 * marked NOT EXISTS, false otherwise.
1: 	 *
1: 	 * A table may be present in the from list for NOT EXISTS if it is used
1: 	 * as a correlated NOT EXISTS subquery. In such a situation, when the
1: 	 * subquery is flattened, it is important that we remember that this is
1: 	 * a NOT EXISTS subquery, because the join semantics are different 
1: 	 * (we're looking for rows that do NOT match, rather than rows
1: 	 * that do). And since the join semantics are different, we cannot
1: 	 * include this table into a transitive closure of equijoins
1: 	 * (See DERBY-3033 for a situation where this occurs).
1: 	 *
1: 	 * @param tableNumber	which table to check
1: 	 * @return true if this table is in the from list as NOT EXISTS
1: 	 */
1: 	boolean tableNumberIsNotExists(int tableNumber)
1: 		throws StandardException
1: 	{
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			ProjectRestrictNode prn = (ProjectRestrictNode) elementAt(index);
1: 			if (! (prn.getChildResult() instanceof FromTable))
1: 			{
1: 				continue;
1: 			}
1: 			FromTable ft = (FromTable) prn.getChildResult();
1: 			if (ft.getTableNumber() == tableNumber)
1: 				return ft.isNotExists();
1: 		}
1: 		return false;
1: 	}
1: 	/**
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1: class FromList extends    QueryTreeNodeVector<ResultSetNode>
1:                implements OptimizableList
/////////////////////////////////////////////////////////////////////////
1:         super(ResultSetNode.class, cm);
/////////////////////////////////////////////////////////////////////////
1:         super(ResultSetNode.class, cm);
/////////////////////////////////////////////////////////////////////////
1:         super(ResultSetNode.class, cm);
/////////////////////////////////////////////////////////////////////////
1:         addElement(fromTable);
/////////////////////////////////////////////////////////////////////////
1:         Enumeration<?> e = properties.keys();
/////////////////////////////////////////////////////////////////////////
1:                 StringBuilder arrayVals = new StringBuilder();
1:                 for (int i : joinOrder) {
1:                     arrayVals.append(i);
1:                     arrayVals.append(' ');
1:                 }
1:         ResultSetNode[] orderedFL = new FromTable[joinOrder.length];
/////////////////////////////////////////////////////////////////////////
1: 
1:         for (Predicate p : wherePredicates) {
1:             predicatesTemp.addPredicate(p);
1:         }
/////////////////////////////////////////////////////////////////////////
1:             ResultColumn rc = rcl.elementAt(0);
/////////////////////////////////////////////////////////////////////////
1: 
1:                 for (int i = predicatesTemp.size() - 1; i >= 0; i--)
1:                             predicatesTemp.elementAt(i).getAndNode();
/////////////////////////////////////////////////////////////////////////
1:                             predicatesTemp.removeElementAt(i);
/////////////////////////////////////////////////////////////////////////
1:         return elementAt(0).updateTargetLockMode();
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
1: import java.util.Enumeration;
1: import java.util.Properties;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
/////////////////////////////////////////////////////////////////////////
0: class FromList extends QueryTreeNodeVector implements OptimizableList
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      *  Does not change the default for join order optimization, i.e.
1:      * {@code false}.
1:      * @param cm context manager
1:      */
1:     FromList(ContextManager cm) {
0:         super(cm);
1:         this.isTransparent = false;
0:         setNodeType(C_NodeTypes.FROM_LIST);
1:     }
1:     /**
1:      * Constructor for a FromList
1:      *
1:      * @param optimizeJoinOrder {@code true} if join order optimization is to
1:      *                          be performed
1:      * @param cm                context manager
1:      */
1:     FromList(boolean optimizeJoinOrder, ContextManager cm)
0:         super(cm);
1:         constructorMinion(optimizeJoinOrder);
1:      * Constructor for a FromList
1:      * @param optimizeJoinOrder {@code true} if join order optimization is to
1:      *                          be performed
1:      * @param fromTable         initialize list with this table
1:      * @param cm                context manager
1:     FromList(boolean optimizeJoinOrder,
1:              FromTable fromTable,
1:              ContextManager cm) throws StandardException
0:         super(cm);
1:         constructorMinion(optimizeJoinOrder);
1:         addFromTable(fromTable);
1:     private void constructorMinion(boolean optimizeJoinOrder) {
1:         this.fixedJoinOrder = !optimizeJoinOrder;
1:         this.isTransparent = false;
0:         setNodeType(C_NodeTypes.FROM_LIST);
1:     }
/////////////////////////////////////////////////////////////////////////
1:     final void addFromTable(FromTable fromTable) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:         TableName leftTable;
1:         TableName rightTable;
1: 
/////////////////////////////////////////////////////////////////////////
1:     boolean referencesTarget(String name, boolean baseTable)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     void isJoinColumnForRightOuterJoin(ResultColumn rc)
/////////////////////////////////////////////////////////////////////////
1:     void bindTables(DataDictionary dataDictionary,
/////////////////////////////////////////////////////////////////////////
1:     void bindExpressions( FromList fromListParam )
/////////////////////////////////////////////////////////////////////////
1:     void bindResultColumns(FromList fromListParam)
/////////////////////////////////////////////////////////////////////////
1:     ResultColumnList expandAll(TableName allTableName)
1:         ResultColumnList tempRCList;
/////////////////////////////////////////////////////////////////////////
1:     ResultColumn bindColumnReference(ColumnReference columnReference)
1:         int             currentLevel;
/////////////////////////////////////////////////////////////////////////
1:     void rejectParameters() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     boolean LOJ_reorderable(int numTables) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     void preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     void flattenFromTables(ResultColumnList rcl,
/////////////////////////////////////////////////////////////////////////
1:     void setLevel(int level)
/////////////////////////////////////////////////////////////////////////
1:     void setProperties(Properties props) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     void bindUntypedNullsToResultColumns(ResultColumnList bindingRCL)
/////////////////////////////////////////////////////////////////////////
1:         predicatesTemp = new PredicateList(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                     AndNode topAndNode =
/////////////////////////////////////////////////////////////////////////
1:         boolean oneRowResult;
/////////////////////////////////////////////////////////////////////////
1:     int updateTargetLockMode()
/////////////////////////////////////////////////////////////////////////
1:     void setWindows(WindowList windows) {
/////////////////////////////////////////////////////////////////////////
1:     WindowList getWindows() {
commit:ee21e7c
/////////////////////////////////////////////////////////////////////////
1:                     /* TableNumbers and column numbers are set in the CR in the
1:                      * underlying FromTable.  This ensures that they get the
1:                      * table number/column number from the underlying table,
1:                      * not the join node.  This is important for beging able to
1:                      * push predicates down through join nodes.
1:                      */
commit:2e7e8f6
/////////////////////////////////////////////////////////////////////////
1:      * @param havingClause      The HAVING clause, if any
1:                                   GroupByList gbl,
1:                                   ValueNode havingClause)
/////////////////////////////////////////////////////////////////////////
1:                                                         gbl,
1:                                                         havingClause);
commit:7a9ce7e
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Window definitions used for resolving window functions not containing
1: 	 * in-line window specifications, but referring window definitions
1: 	 */
1: 	private WindowList windows;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	/**
1: 	 * Set windows field to the supplied value.
1: 	 * @param windows list of window definitions associated with a SELECT.
1: 	 */
0: 	public void setWindows(WindowList windows) {
1: 		this.windows = windows;
1: 	}
1: 
1: 
1: 	/**
1: 	 * @return list of window definitions associated with a SELECT.
1: 	 */
0: 	public WindowList getWindows() {
1: 		return windows;
1: 	}
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:0eb98f1
/////////////////////////////////////////////////////////////////////////
1: 	 * Go through the list of the tables and see if the passed ResultColumn
1: 	 *  is a join column for a right outer join with USING/NATURAL clause.
1: 	 * @see HalfOuterJoinNode#isJoinColumnForRightOuterJoin
0: 	public void isJoinColumnForRightOuterJoin(ResultColumn rc) 
1: 	{
1: 		FromTable	fromTable;
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			fromTable = (FromTable) elementAt(index);
1: 			fromTable.isJoinColumnForRightOuterJoin(rc);
1: 		}
1: 	}
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ed82406
/////////////////////////////////////////////////////////////////////////
commit:03eae1d
/////////////////////////////////////////////////////////////////////////
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 					if (fromTable.isPrivilegeCollectionRequired())
0: 						getCompilerContext().addRequiredColumnPriv( resultColumn.getTableColumnDescriptor());						
commit:6b26ee1
/////////////////////////////////////////////////////////////////////////
commit:f1d4e9d
/////////////////////////////////////////////////////////////////////////
1: 							 columnReference.getSQLColumnName());
commit:c83a399
/////////////////////////////////////////////////////////////////////////
0:         TableName leftTable = null;
0:         TableName rightTable = null;
1:                 leftTable = fromTable.getTableName();
1: 
1:                 if(((FromTable) elementAt(index)) instanceof TableOperatorNode) {
1:                     continue;
1:                 }
1: 
1:                 else {                    
1:                     rightTable = ((FromTable) elementAt(index)).getTableName();
1:                 }
1:                 if(leftTable.equals(rightTable))
/////////////////////////////////////////////////////////////////////////
0: 	public ResultColumnList expandAll(TableName allTableName)
commit:df9af89
/////////////////////////////////////////////////////////////////////////
0: 		Enumeration e = properties.keys();
1: 		while (e.hasMoreElements())
1: 			String key = (String) e.nextElement();
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.FromList
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: import org.apache.derby.iapi.sql.compile.OptimizableList;
1: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
1: import org.apache.derby.iapi.util.StringUtil;
1: 
0: import java.util.Properties;
0: import java.util.Enumeration;
0: import java.util.Vector;
1: 
1: /**
1:  * A FromList represents the list of tables in a FROM clause in a DML
1:  * statement.  It extends QueryTreeNodeVector.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public class FromList extends QueryTreeNodeVector implements OptimizableList
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	Properties	properties;
1: 	// RESOLVE: The default should be false
1: 	boolean		fixedJoinOrder = true;
1: 	// true by default.
1: 	boolean 	useStatistics = true;
1: 
0: 	/** Initializer for a FromList */
1: 
0: 	public void init(Object optimizeJoinOrder)
1: 	{
0: 		fixedJoinOrder = ! (((Boolean) optimizeJoinOrder).booleanValue());
1: 	}
1: 
1: 	/**
0: 	 * Initializer for a FromList
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object optimizeJoinOrder, Object fromTable)
1: 				throws StandardException
1: 	{
0: 		init(optimizeJoinOrder);
1: 
0: 		addFromTable((FromTable) fromTable);
1: 	}
1: 
1: 	/*
1: 	 * OptimizableList interface
1: 	 */
1: 
1: 	/**
1: 	 * @see org.apache.derby.iapi.sql.compile.OptimizableList#getOptimizable
1: 	 */
1: 	public Optimizable getOptimizable(int index)
1: 	{
1: 		return (Optimizable) elementAt(index);
1: 	}
1: 
1: 	/**
1: 	 * @see org.apache.derby.iapi.sql.compile.OptimizableList#setOptimizable
1: 	 */
1: 	public void setOptimizable(int index, Optimizable optimizable)
1: 	{
1: 		setElementAt((FromTable) optimizable, index);
1: 	}
1: 
1: 	/** 
1: 	 * @see OptimizableList#verifyProperties
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void verifyProperties(DataDictionary dDictionary) throws StandardException
1: 	{
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			((Optimizable) elementAt(index)).verifyProperties(dDictionary);
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 	 * Add a table to the FROM list.
1: 	 *
1: 	 * @param fromTable	A FromTable to add to the list
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void addFromTable(FromTable fromTable) throws StandardException
1: 	{
1: 		/* Don't worry about checking TableOperatorNodes since
1: 		 * they don't have exposed names.  This will potentially
1: 		 * allow duplicate exposed names in some degenerate cases,
1: 		 * but the binding of the ColumnReferences will catch those
1: 		 * cases with a different error.  If the query does not have
1: 		 * any ColumnReferences from the duplicate exposed name, the
1: 		 * user is executing a really dumb query and we won't throw
1: 		 * and exception - consider it an ANSI extension.
1: 		 */
1: 		if (! (fromTable instanceof TableOperatorNode))
1: 		{
1: 			/* Check for duplicate table name in FROM list */
1: 			int size = size();
1: 			for (int index = 0; index < size; index++)
1: 			{
0: 				if (fromTable.getExposedName().equals
0: 					(((FromTable) elementAt(index)).getExposedName()) )
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_FROM_LIST_DUPLICATE_TABLE_NAME, fromTable.getExposedName());
1: 				}
1: 			}
1: 		}
1: 
0: 		addElement(fromTable);
1: 	}
1: 
1: 	/**
1: 	 * Search to see if a query references the specifed table name.
1: 	 *
1: 	 * @param name		Table name (String) to search for.
1: 	 * @param baseTable	Whether or not name is for a base table
1: 	 *
1: 	 * @return	true if found, else false
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public boolean referencesTarget(String name, boolean baseTable)
1: 		throws StandardException
1: 	{
1: 		FromTable		fromTable;
1: 		boolean			found = false;
1: 
1: 		/* Check for table or VTI name in FROM list */
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			fromTable = (FromTable) elementAt(index);
1: 
1: 			if (fromTable.referencesTarget(name, baseTable)) 
1: 			{
1: 				found = true;
1: 				break;
1: 			}
1: 		}
1: 
1: 		return found;
1: 	}
1: 
1: 	/**
1: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1: 	 *
1: 	 * @return	true if references SESSION schema tables, else false
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean referencesSessionSchema()
1: 		throws StandardException
1: 	{
1: 		FromTable		fromTable;
1: 		boolean			found = false;
1: 
1: 		/* Check for table or VTI name in FROM list */
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			fromTable = (FromTable) elementAt(index);
1: 
1: 			if (fromTable.referencesSessionSchema())
1: 			{
1: 				found = true;
1: 				break;
1: 			}
1: 		}
1: 
1: 		return found;
1: 	}
1: 
1: 	/** 
1: 	 * Determine whether or not the specified name is an exposed name in
1: 	 * the current query block.
1: 	 *
1: 	 * @param name	The specified name to search for as an exposed name.
1: 	 * @param schemaName	Schema name, if non-null.
1: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
1: 	 *						names or match on table id.
1: 	 *
1: 	 * @return The FromTable, if any, with the exposed name.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	protected FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
1: 		throws StandardException
1: 	{
1: 		boolean			found = false;
1: 		FromTable		fromTable;
1: 		FromTable		result = null;
1: 
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			fromTable = (FromTable) elementAt(index);
1: 
1: 			result = fromTable.getFromTableByName(name, schemaName, exactMatch);
1: 
1: 			if (result != null)
1: 			{
1: 				return result;
1: 			}
1: 		}
1: 		return result;
1: 	}
1: 
1: 	/**
0: 	 * Bind the tables in this FromList.  This includes looking them up in
0: 	 * the DataDictionary, getting their TableDescriptors and assigning the
0: 	 * table numbers.
1: 	 *
0: 	 * @param dataDictionary	The DataDictionary to use for binding
1: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
0: 	 * @return	Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void bindTables(DataDictionary dataDictionary, 
1: 							FromList fromListParam) 
1: 			throws StandardException
1: 	{
1: 		FromTable	fromTable;
1: 
1: 		/* Now we bind the tables - this is a 2 step process.
1: 		 * We first bind all of the non-VTIs, then we bind the VTIs.
1: 		 * This enables us to handle the passing of correlation
1: 		 * columns in VTI parameters.
1: 		 * NOTE: We set the table numbers for all of the VTIs in the
1: 		 * first step, when we find them, in order to avoid an ordering
1: 		 * problem with join columns in parameters.
1: 		 */
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			fromTable = (FromTable) elementAt(index);
0: 			setElementAt(fromTable.bindNonVTITables(dataDictionary, fromListParam), index);
1: 		}
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			fromTable = (FromTable) elementAt(index);
0: 			setElementAt(fromTable.bindVTITables(fromListParam), index);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind the expressions in this FromList.  This means 
1: 	 * binding the sub-expressions, as well as figuring out what the return 
1: 	 * type is for each expression.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void bindExpressions()
1: 					throws StandardException
1: 	{
1: 		FromTable	fromTable;
1: 
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			fromTable = (FromTable) elementAt(index);
0: 			fromTable.bindExpressions(this);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind the result columns of the ResultSetNodes in this FromList when there is no
1: 	 * base table to bind them to.  This is useful for SELECT statements,
1: 	 * where the result columns get their types from the expressions that
1: 	 * live under them.
1: 	 *
1: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void bindResultColumns(FromList fromListParam)
1: 				throws StandardException
1: 	{
1: 		FromTable	fromTable;
1: 
1: 		int origList = fromListParam.size();
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			fromTable = (FromTable) elementAt(index);
1: 			if (fromTable.needsSpecialRCLBinding())
1: 				fromTable.bindResultColumns(fromListParam);
1: 
1: 			fromListParam.insertElementAt(fromTable, 0);
1: 		}
1: 
1: 		/* Remove all references added here */
1: 		while (fromListParam.size() > origList)
1: 			fromListParam.removeElementAt(0);
1: 	}
1: 
1: 	/**
0: 	 * Returns true if any Outer joins present. Used to set Nullability
1: 	 *
0: 	 * @return	True if has any outer joins. False otherwise.
1: 	 */
0: 	public boolean hasOuterJoins()
1: 				throws StandardException
1: 	{
1: 		FromTable	fromTable;
1: 
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			fromTable = (FromTable) elementAt(index);
0: 			if (fromTable instanceof HalfOuterJoinNode)
1: 				return true;
1: 		}
1: 
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Expand a "*" into the appropriate ResultColumnList. If the "*"
1: 	 * is unqualified it will expand into a list of all columns in all
0: 	 * of the base tables in the from list, otherwise it will expand
0: 	 * into a list of all of the columns in the base table that matches
0: 	 * the qualification.
1: 	 *
1: 	 * @param allTableName		The qualification on the "*" as a String.
1: 	 *
1: 	 * @return ResultColumnList representing expansion
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultColumnList expandAll(String allTableName)
1: 			throws StandardException
1: 	{
1: 		ResultColumnList resultColumnList = null;
0: 		ResultColumnList tempRCList = null;
1: 		boolean			 matchfound = false;
1: 		FromTable	 fromTable;
1:  
1: 		/* Expand the "*" for the table that matches, if it is qualified 
0: 		 * (allTableName is not null) or for all tables in the list if the 
0: 		 * "*" is not qualified (allTableName is null).
1: 		 */
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			fromTable = (FromTable) elementAt(index);
0: 			fromTable.setAllColumnsProjected(true);
1: 
1: 			/* We let the FromTable decide if there is a match on
1: 			 * the exposed name.  (A JoinNode will not have an
1: 			 * exposed name, so it will need to pass the info to its
1: 			 * left and right children.)
1: 			 */
1: 			tempRCList = fromTable.getAllResultColumns(allTableName);
1: 
1: 			if (tempRCList == null)
1: 			{
1: 				continue;
1: 			}
1: 
1: 			/* Expand the column list and append to the list that
1: 			 * we will return.
1: 			 */
1: 			if (resultColumnList == null)
1: 			{
1: 				resultColumnList = tempRCList;
1: 			}
1: 			else
1: 			{
1: 				resultColumnList.nondestructiveAppend(tempRCList);
1: 			}
1: 
1: 			/* If the "*" is qualified, then we can stop the
1: 			 * expansion as soon as we find the matching table.
1: 			 */
1: 			if (allTableName != null)
1: 			{
1: 				matchfound = true;
1: 			}
1: 		}
1: 
1: 		/* Give an error if the qualification name did not match 
1: 		 * an exposed name 
1: 		 */
1: 		if (resultColumnList == null)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_EXPOSED_NAME_NOT_FOUND, allTableName);
1: 		}
1: 
1: 		return resultColumnList;
1: 	}
1: 
1: 	/**
1: 	 * Bind a column reference to one of the tables in this FromList.  The column name
1: 	 * must be unique within the tables in the FromList.  An exception is thrown
0: 	 * if a column name is not unique.
1: 	 *
1: 	 * NOTE: Callers are responsible for ordering the FromList by nesting level,
1: 	 * with tables at the deepest (current) nesting level first.  We will try to 
1: 	 * match against all FromTables at a given nesting level.  If no match is
1: 	 * found at a nesting level, then we proceed to the next level.  We stop
1: 	 * walking the list when the nesting level changes and we have found a match.
1: 	 *
1: 	 * NOTE: If the ColumnReference is qualified, then we will stop the search
1: 	 * at the first nesting level where there is a match on the exposed table name.
0: 	 * For example, s (a, b, c), t (d, e, f)
1: 	 *		select * from s where exists (select * from t s where s.c = a)
1: 	 * will not find a match for s.c, which is the expected ANSI behavior.
1: 	 *
1: 	 * bindTables() must have already been called on this FromList before
1: 	 * calling this method.
1: 	 *
1: 	 * @param columnReference	The ColumnReference describing the column to bind
1: 	 *
0: 	 * @return	ResultColumn	The matching ResultColumn
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultColumn bindColumnReference(ColumnReference columnReference)
1: 				throws StandardException
1: 	{
1: 		boolean			columnNameMatch = false;
1: 		boolean			tableNameMatch = false;
1: 		FromTable		fromTable;
0: 		int				currentLevel = -1;
1: 		int				previousLevel = -1;
1: 		ResultColumn	matchingRC = null;
1: 		ResultColumn	resultColumn;
1: 		String			crTableName = columnReference.getTableName();
1: 
1: 		/*
1: 		** Find the first table with matching column name.  If there
1: 		** is more than one table with a matching column name at the same
1: 		** nesting level, give an error.
1: 		*/
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			fromTable = (FromTable) elementAt(index);
1: 
1: 			/* We can stop if we've found a matching column or table name 
1: 			 * at the previous nesting level.
1: 			 */
1: 			currentLevel = fromTable.getLevel();
1: 			if (previousLevel != currentLevel)
1: 			{
1: 				if (columnNameMatch)
1: 				{
1: 					break;
1: 				}
1: 
1: 				if (tableNameMatch)
1: 				{
1: 					break;
1: 				}
1: 			}
1: 			/* Simpler to always set previousLevel then to test and set */
1: 			previousLevel = currentLevel;
1: 
1: 			resultColumn = fromTable.getMatchingColumn(columnReference);
1: 			if (resultColumn != null)
1: 			{
1: 				if (! columnNameMatch)
1: 				{
0: 					/* TableNumbers are set in the CR in the underlying
0: 					 * FromTable.  This ensures that they get the table
0: 					 * number from the underlying table, not the join node.
0: 					 * This is important for beging able to push predicates 
0: 					 * down through join nodes.
1: 					 */
1: 					matchingRC = resultColumn;
1: 					columnReference.setSource(resultColumn);
0: 					columnReference.setType(resultColumn.getTypeServices());
1: 					/* Set the nesting level at which the CR appears and the nesting level
1: 					 * of its source RC.
1: 					 */
1: 					columnReference.setNestingLevel(((FromTable) elementAt(0)).getLevel());
1: 					columnReference.setSourceLevel(currentLevel);
1: 					columnNameMatch = true;
1: 				}
1: 				else
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_AMBIGUOUS_COLUMN_NAME, 
0: 							 columnReference.getFullColumnName());
1: 				}
1: 			}
1: 
1: 			/* Remember if we get a match on the exposed table name, so that
1: 			 * we can stop at the beginning of the next level.
1: 			 */
1: 			tableNameMatch = tableNameMatch || 
1: 						(crTableName != null &&
1: 						 crTableName.equals(fromTable.getExposedName()) );
1: 		}
1: 
1: 		return matchingRC;
1: 	}
1: 
1: 	/**
1: 	 * Check for (and reject) all ? parameters directly under the ResultColumns.
1: 	 * This is done for SELECT statements.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown if a ? parameter found
1: 	 *									directly under a ResultColumn
1: 	 */
1: 
0: 	public void rejectParameters() throws StandardException
1: 	{
1: 		FromTable	fromTable;
1: 
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			fromTable = (FromTable) elementAt(index);
1: 			fromTable.rejectParameters();
1: 		}
1: 	}
1: 
1: 	// This method reorders LOJs in the FROM clause.
1: 	// For now, we process only a LOJ.  For example, "... from LOJ_1, LOJ2 ..."
1: 	// will not be processed. 
0: 	public boolean LOJ_reorderable(int numTables) throws StandardException
1: 	{
1: 		boolean anyChange = false;
1: 
1: 		if (size() > 1) return anyChange;
1: 
1: 		FromTable ft = (FromTable) elementAt(0);
1: 
1: 		anyChange = ft.LOJ_reorderable(numTables);
1: 
1: 		return anyChange;
1: 	}
1: 
1: 	/**
1: 	 * Preprocess the query tree - this currently means:
1: 	 *	o  Generating a referenced table map for each ResultSetNode.
1: 	 *  o  Putting the WHERE and HAVING clauses in conjunctive normal form (CNF).
1: 	 *  o  Converting the WHERE and HAVING clauses into PredicateLists and
1: 	 *	   classifying them.
1: 	 *  o  Flatten those FromSubqueries which can be flattened.
1: 	 *  o  Ensuring that a ProjectRestrictNode is generated on top of every 
1: 	 *     FromBaseTable and generated in place of every FromSubquery which
1: 	 *	   could not be flattened.  
1: 	 *  o  Pushing single table predicates down to the new ProjectRestrictNodes.
1: 	 *
1: 	 * @param numTables			The number of tables in the DML Statement
1: 	 * @param gbl				The group by list, if any
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void preprocess(int numTables,
1: 						   GroupByList gbl,
1: 						   ValueNode predicateTree)
1: 								throws StandardException
1: 	{
1: 		int size = size();
1: 
1: 		/* Preprocess each FromTable in the list */
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			FromTable ft = (FromTable) elementAt(index);
1: 
1: 			/* Transform any outer joins to inner joins where appropriate */
1: 			ft = ft.transformOuterJoins(predicateTree, numTables);
1: 			/* Preprocess this FromTable */
1: 			setElementAt(ft.preprocess(numTables, gbl, this), index);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Flatten all the FromTables that are flattenable.
1: 	 * RESOLVE - right now we just flatten FromSubqueries.  We
1: 	 * should also flatten flattenable JoinNodes here.
1: 	 *
1: 	 * @param rcl				The RCL from the outer query
1: 	 * @param predicateList		The PredicateList from the outer query
1: 	 * @param sql				The SubqueryList from the outer query
1: 	 * @param gbl				The group by list, if any
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void flattenFromTables(ResultColumnList rcl,
1: 								  PredicateList predicateList,
1: 								  SubqueryList sql,
0: 								  GroupByList gbl)
1: 									throws StandardException
1: 	{
1: 		boolean			flattened = true;
0: 		Vector 			flattenedTableNumbers = new Vector();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(rcl != null,
1: 							 "rcl is expected to be non-null");
1: 			SanityManager.ASSERT(predicateList != null,
1: 							 "predicateList is expected to be non-null");
1: 			SanityManager.ASSERT(sql != null,
1: 							 "sql is expected to be non-null");
1: 		}
1: 
1: 		/* Loop until all flattenable entries are flattened.
1: 		 * We restart the inner loop after flattening an in place
1: 		 * to simplify the logic and so that we don't have to worry
1: 		 * about walking a list while we are modifying it.
1: 		 */
1: 		while (flattened)
1: 		{
1: 			flattened = false;
1: 
1: 			for (int index = 0; index < size() && ! flattened; index++)
1: 			{
1: 				FromTable ft = (FromTable) elementAt(index);
1: 
1: 				/* Flatten FromSubquerys and flattenable JoinNodes */
1: 				if ((ft instanceof FromSubquery) ||
1: 					ft.isFlattenableJoinNode())
1: 				{
1: 					//save the table number of the node to be flattened
0: 					flattenedTableNumbers.addElement(new Integer(ft.getTableNumber()));
1: 
1: 					/* Remove the node from the list and insert its
1: 					 * FromList here.
1: 					 */
1: 					FromList	 flatteningFL = ft.flatten(
1: 														rcl,
1: 														predicateList,
1: 														sql,
0: 														gbl);
1: 					if (SanityManager.DEBUG)
1: 					{
1: 						SanityManager.ASSERT(flatteningFL == null ||
1: 											 flatteningFL.size() > 0,
1: 							"flatteningFL expected to be null or size > 0");
1: 					}
1: 
1: 					if (flatteningFL != null)
1: 					{
1: 						setElementAt(flatteningFL.elementAt(0), index);
1: 
1: 						int innerSize = flatteningFL.size();
1: 						for (int inner = 1; inner < innerSize; inner++)
1: 						{
1: 							insertElementAt(flatteningFL.elementAt(inner), index + inner);
1: 						}
1: 					}
1: 					else
1: 					{
1: 						/*
1: 						** If flatten returns null, that means it wants to
1: 						** be removed from the FromList.
1: 						*/
1: 						removeElementAt(index);
1: 					}
1: 					flattened = true;
1: 				}
1: 			}
1: 		}
1: 		
1: 		/* fix up dependency maps for exists base tables since they might have a
1: 		 * dependency on this join node
1: 		 */
0: 		if (flattenedTableNumbers.size() > 0)
1: 		{
1: 			for (int i = 0; i < size(); i++)
1: 			{
1: 				FromTable ft = (FromTable) elementAt(i);
1: 				if (ft instanceof ProjectRestrictNode)
1: 				{
1: 					ResultSetNode rst = ((ProjectRestrictNode)ft).getChildResult();
1: 					if (rst instanceof FromBaseTable)
1: 					{
1: 						((FromBaseTable)rst).clearDependency(flattenedTableNumbers);
1: 					}
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Categorize and push the predicates that are pushable.
1: 	 *
1: 	 * @param predicateList		The query's PredicateList
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void pushPredicates(PredicateList predicateList)
1: 			throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(predicateList != null,
1: 							 "predicateList is expected to be non-null");
1: 		}
1: 
1: 		/* We can finally categorize each Predicate and try to push them down.
1: 		 * NOTE: The PredicateList may be empty, but that's okay, we still
1: 		 * call pushExpressions() for each entry in the FromList because that's
1: 		 * where any outer join conditions will get pushed down.
1: 		 */
1: 		predicateList.categorize();
1: 
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			FromTable fromTable = (FromTable) elementAt(index);
1: 			fromTable.pushExpressions(predicateList);
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
1: 	 *
0: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			FromTable	fromTable;
1: 
0: 			super.printSubNodes(depth);
1: 
1: 			int size = size();
1: 			for (int index = 0; index < size; index++)
1: 			{
1: 				fromTable = (FromTable) elementAt(index);
0: 				fromTable.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Set the (query block) level (0-based) for the FromTables in this
1: 	 * FromList.
1: 	 *
1: 	 * @param level		The query block level for this table.
1: 	 *
0: 	 * @return Nothing
1: 	 */
0: 	public void setLevel(int level)
1: 	{
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			FromTable fromTable = (FromTable) elementAt(index);
1: 			fromTable.setLevel(level);
1: 		}
1: 	}
1: 
1: 	/**
0: 		Move the mark for result set being the statement's outermost
0: 		result set down into the first table of the from list.
0: 		Generally expect there is only one table at this point.
1: 	 */
0: 	void markStatementResultSet()
1: 	{
0: 		((FromTable) elementAt(0)).markStatementResultSet();
1: 	}
1: 
1: 	/**
1: 	 * Get the FromTable from this list which has the specified ResultColumn in
1: 	 * its RCL.
1: 	 *
1: 	 * @param rc	The ResultColumn match on.
1: 	 *
1: 	 * @return FromTable	The matching FromTable.
1: 	 */
0: 	public FromTable getFromTableByResultColumn(ResultColumn rc)
1: 	{
1: 		FromTable	fromTable = null;
1: 
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			fromTable = (FromTable) elementAt(index);
1: 
1: 			if (fromTable.getResultColumns().indexOf(rc) != -1)
1: 			{
1: 				break;
1: 			}
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(fromTable != null,
1: 				"No matching FromTable found");
1: 		}
1: 		return fromTable;
1: 	}
1: 
1: 	/**
1: 	 * Set the Properties list for this FromList.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void setProperties(Properties props) throws StandardException
1: 	{
1: 		properties = props;
1: 
1: 		/*
1: 		** Validate the properties list now.  This is possible because
1: 		** there is nothing in this properties list that relies on binding
1: 		** or optimization to validate.
1: 		*/
0: 		Enumeration enum = properties.keys();
0: 		while (enum.hasMoreElements())
1: 		{
0: 			String key = (String) enum.nextElement();
1: 			String value = (String) properties.get(key);
1: 
1: 			if (key.equals("joinOrder"))
1: 			{
1: 				if (StringUtil.SQLEqualsIgnoreCase(value,"fixed"))
1: 				{
1: 					fixedJoinOrder = true;
1: 				}
1: 				else if (StringUtil.SQLEqualsIgnoreCase(value,"unfixed"))
1: 				{
1: 					fixedJoinOrder = false;
1: 				}
1: 				else
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_INVALID_JOIN_ORDER_SPEC, value);
1: 				}
1: 			}
1: 			else if (key.equals("useStatistics"))
1: 			{
1: 				if (StringUtil.SQLEqualsIgnoreCase(value,"true"))
1: 				{
1: 					useStatistics = true;
1: 				}
1: 				else if (StringUtil.SQLEqualsIgnoreCase(value,"false"))
1: 				{
1: 					useStatistics = false;
1: 				}
1: 				else
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_INVALID_STATISTICS_SPEC, value);
1: 				}
1: 			}
1: 			else
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_INVALID_FROM_LIST_PROPERTY, key, value);
1: 			}
1: 		}
1: 	}
1: 
1: 	/** @see OptimizableList#reOrder */
1: 	public void reOrder(int[] joinOrder)
1: 	{
1: 		int	posn;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (joinOrder.length != size())
1: 			{
1: 				SanityManager.THROWASSERT("In reOrder(), size of FromList is " + size() + " while size of joinOrder array is " + joinOrder.length);
1: 			}
1: 
1: 			/*
1: 			** Determine that the values in the list are unique and in range.
1: 			** The easiest way to determine that they are unique is to add
1: 			** them all up and see whether the result is what's expected
1: 			** for that array size.
1: 			*/
1: 			int sum = 0;
1: 			for (int i = 0; i < joinOrder.length; i++)
1: 			{
1: 				if (joinOrder[i] < 0 || joinOrder[i] > (joinOrder.length - 1))
1: 				{
1: 					SanityManager.THROWASSERT("joinOrder[" + i + "] == " +
1: 											joinOrder[i] +
1: 											" is out of range - must be between 0 and " + 
1: 											(joinOrder.length - 1) +
1: 											" inclusive.");
1: 				}
1: 
1: 				sum += joinOrder[i];
1: 			}
1: 
1: 			/*
1: 			** The sum of all integers from 0 through n is (n * (n - 1)) / 2.
1: 			*/
1: 			if (sum != ( ( joinOrder.length * (joinOrder.length - 1) ) / 2) )
1: 			{
0: 				String arrayVals = "";
1: 				for (int i = 0; i < joinOrder.length; i++)
0: 					arrayVals = arrayVals + joinOrder[i] + " ";
1: 				SanityManager.THROWASSERT("joinOrder array has some duplicate value: " + arrayVals);
1: 			}
1: 		}
1: 
1: 		/* Form a list that's in the order we want */
0: 		QueryTreeNode[] orderedFL = new FromTable[joinOrder.length];
1: 		for (posn = 0; posn < joinOrder.length; posn++)
1: 		{
1: 			/*
1: 			** Get the element at the i'th join order position from the
1: 			** current list and make it the next element of orderedList.
1: 			*/
1: 			orderedFL[posn] = elementAt(joinOrder[posn]);
1: 		}
1: 
1: 		/* Now orderedList has been built, so set this list to the same order */
1: 		for (posn = 0; posn < joinOrder.length; posn++)
1: 		{
1: 			setElementAt(orderedFL[posn], posn);
1: 		}
1: 	}
1: 
1: 	/** @see OptimizableList#useStatistics */
1: 	public boolean useStatistics()
1: 	{
1: 		return useStatistics;
1: 	}
1: 
1: 	/** @see OptimizableList#optimizeJoinOrder */
1: 	public boolean optimizeJoinOrder()
1: 	{
1: 		return ! fixedJoinOrder;
1: 	}
1: 
1: 	/** @see OptimizableList#legalJoinOrder */
1: 	public boolean legalJoinOrder(int numTablesInQuery)
1: 	{
1: 		JBitSet			assignedTableMap = new JBitSet(numTablesInQuery);
1: 
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			FromTable ft = (FromTable) elementAt(index);
1: 			assignedTableMap.or(ft.getReferencedTableMap());
1: 			if ( ! ft.legalJoinOrder(assignedTableMap))
1: 			{
1: 				return false;
1: 			}
1: 		}
1: 		return true;
1: 	}
1: 
1: 	/** @see OptimizableList#initAccessPaths */
1: 	public void initAccessPaths(Optimizer optimizer)
1: 	{
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			FromTable ft = (FromTable) elementAt(index);
1: 			ft.initAccessPaths(optimizer);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind any untyped null nodes to the types in the given ResultColumnList.
1: 	 *
1: 	 * @param bindingRCL	The ResultColumnList with the types to bind to.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void bindUntypedNullsToResultColumns(ResultColumnList bindingRCL)
1: 				throws StandardException
1: 	{
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			FromTable fromTable = (FromTable) elementAt(index);
1: 			fromTable.bindUntypedNullsToResultColumns(bindingRCL);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Decrement (query block) level (0-based) for 
1: 	 * all of the tables in this from list.
1: 	 * This is useful when flattening a subquery.
1: 	 *
1: 	 * @param decrement	The amount to decrement by.
1: 	 *
0: 	 * @return Nothing;
1: 	 */
1: 	void decrementLevel(int decrement)
1: 	{
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			FromTable fromTable = (FromTable) elementAt(index);
1: 			fromTable.decrementLevel(decrement);
1: 
1: 			/* Decrement the level of any CRs in single table
1: 			 * predicates that are interesting to transitive
1: 			 * closure.
1: 			 */
1: 			ProjectRestrictNode prn = (ProjectRestrictNode) fromTable;
1: 			PredicateList pl = prn.getRestrictionList();
1: 			if (pl != null)
1: 			{
1: 				pl.decrementLevel(this, decrement);
1: 			}
1: 		}
1: 	}
1: 
1: 	
1: 	/**
1: 	 * This method is used for both subquery flattening and distinct
1: 	 * elimination based on a uniqueness condition.  For subquery
1: 	 * flattening we want to make sure that the query block
1: 	 * will return at most 1 row.  For distinct elimination we
1: 	 * want to make sure that the query block will not return
1: 	 * any duplicates.
1: 	 * This is true if every table in the from list is
1: 	 * (a base table and the set of columns from the table that
1: 	 * are in equality comparisons with expressions that do not include columns 
1: 	 * from the same table is a superset of any unique index
1: 	 * on the table) or an EXISTS FBT.  In addition, at least 1 of the tables
1: 	 * in the list has a set of columns in equality comparisons with expressions
1: 	 * that do not include column references from the same query block
1: 	 * is a superset of a unique index
1: 	 * on that table.  (This ensures that the query block will onlyr
1: 	 * return a single row.)
1: 	 * This method is expected to be called after normalization and
1: 	 * after the from list has been preprocessed.
1: 	 * It can be called both before and after the predicates have
1: 	 * been pulled from the where clause.
1: 	 * The algorithm for this is as follows
1: 	 *
1: 	 *	If any table in the query block is not a base table, give up.
1: 	 * 	For each table in the query
1: 	 *		Ignore exists table since they can only produce one row
1: 	 *
1: 	 *		create a matrix of tables and columns from the table (tableColMap)
1: 	 *		(this is used to keep track of the join columns and constants
1: 	 *		that can be used to figure out whether the rows from a join
1: 	 *		or in a select list are distinct based on unique indexes)
1: 	 *
1: 	 *		create an array of columns from the table(eqOuterCol)
1: 	 *		(this is used to determine that only one row will be returned
1: 	 *		from a join)
1: 	 *			
1: 	 *		if the current table is the table for the result columns
1: 	 *			set the result columns in the eqOuterCol and tableColMap
1: 	 *			(if these columns are a superset of a unique index and
1: 	 *			all joining tables result in only one row, the
1: 	 *			results will be distinct)
1: 	 *		go through all the predicates and update tableColMap  and
1: 	 *		eqOuterCol with join columns and correlation variables, 
1: 	 *		parameters and constants
1: 	 *		since setting constants, correlation variables and parameters,
1: 	 * 		reduces the number of columns required for uniqueness in a 
1: 	 *		multi-column index, they are set for all the tables (if the
1: 	 *		table is not the result table, in this case only the column of the
1:      *		result table is set)
1: 	 *		join columns are just updated for the column in the row of the
1: 	 *		joining table.
1: 	 *		
1: 	 *		check if the marked columns in tableColMap are a superset of a unique 
1: 	 *			index		
1: 	 *			(This means that the join will only produce 1 row when joined
1: 	 *			with 1 row of another table)
1: 	 *		check that there is a least one table for which the columns in 
1: 	 *			eqOuterCol(i.e. constant values) are a superset of a unique index
1: 	 *			(This quarantees that there will be only one row selected
1: 	 *			from this table).
1: 	 *
1: 	 *	Once all tables have been evaluated, check that all the tables can be
1: 	 * 	joined by unique index or will have only one row
1: 	 *
1: 	 *	
1: 	 *
1: 	 * @param rcl				If non-null, the RCL from the query block.
1: 	 *							If non-null for subqueries, then entry can
1: 	 *							be considered as part of an = comparison.
1: 	 * @param whereClause		The WHERE clause to consider.
1: 	 * @param wherePredicates	The predicates that have already been
1: 	 *							pulled from the WHERE clause.
1: 	 * @param dd				The DataDictionary to use.
1: 	 *
1: 	 * @return	Whether or not query block will return
1: 	 *			at most 1 row for a subquery, no duplicates
1: 	 *			for a distinct.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	boolean returnsAtMostSingleRow(ResultColumnList rcl, 
1: 								   ValueNode whereClause, 
1: 								   PredicateList wherePredicates,
1: 								   DataDictionary dd)
1: 		throws StandardException
1: 	{
1: 		boolean			satisfiesOuter = false;
1: 		int[]			tableNumbers;
1: 		ColumnReference	additionalCR = null;
1: 
1: 		/* When considering subquery flattening, we are interested
1: 		 * in the 1st (and only) entry in the RCL.  (The RCL will be
1: 		 * null if result column is not of interest for subquery flattening.)
1: 		 * We are interested in all entries in the RCL for distinct
1: 		 * elimination.
1: 		 */
1: 		if (rcl != null)
1: 		{
0: 			ResultColumn rc = (ResultColumn) rcl.elementAt(0);
1: 			if (rc.getExpression() instanceof ColumnReference)
1: 			{
1: 				additionalCR = (ColumnReference) rc.getExpression();
1: 			}
1: 		}
1: 
1: 		/* First see if all entries are FromBaseTables.  No point
1: 		 * in continuing if not.
1: 		 */
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			FromTable fromTable = (FromTable) elementAt(index);
1: 			if (! (fromTable instanceof ProjectRestrictNode))
1: 			{
1: 				return false;
1: 			}
1: 
1: 			ProjectRestrictNode prn = (ProjectRestrictNode) fromTable;
1: 
1: 			if (! (prn.getChildResult() instanceof FromBaseTable))
1: 			{
1: 				return false;
1: 			}
1: 		}
1: 
1: 		/* Build an array of tableNumbers from this query block.
1: 		 * We will use that array to find out if we have at least
1: 		 * one table with a uniqueness condition based only on
1: 		 * constants, parameters and correlation columns.
1: 		 */
1: 		tableNumbers = getTableNumbers();
1: 		JBitSet[][] tableColMap = new JBitSet[size][size];
1: 		boolean[] oneRow = new boolean[size];
0: 		boolean oneRowResult = false;
1: 
1: 		/* See if each table has a uniqueness condition */
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			ProjectRestrictNode prn = (ProjectRestrictNode) elementAt(index);
1: 			FromBaseTable fbt = (FromBaseTable) prn.getChildResult();
1: 
1: 			// Skip over EXISTS FBT since they cannot introduce duplicates
1: 			if (fbt.getExistsBaseTable())
1: 			{
1: 				oneRow[index] = true;
1: 				continue;
1: 			}
1: 
1: 			int numColumns = fbt.getTableDescriptor().getNumberOfColumns();
1: 			boolean[] eqOuterCols = new boolean[numColumns + 1];
1: 			int tableNumber = fbt.getTableNumber();
1: 			boolean resultColTable = false;
1: 			for (int i = 0; i < size; i++)
1: 				tableColMap[index][i] = new JBitSet(numColumns + 1);
1: 
1: 			if (additionalCR != null &&
1: 				additionalCR.getTableNumber() == tableNumber)
1: 			{
1: 				rcl.recordColumnReferences(eqOuterCols, tableColMap[index], index);
1: 				resultColTable = true;
1: 			}
1: 
1: 			/* Now see if there are any equality conditions
1: 			 * of interest in the where clause.
1: 			 */
1: 			if (whereClause != null)
1: 			{
1: 				whereClause.checkTopPredicatesForEqualsConditions(
1: 								tableNumber, eqOuterCols, tableNumbers,
1: 								tableColMap[index], resultColTable);
1: 			}
1: 
1: 			/* Now see if there are any equality conditions
1: 			 * of interest in the where predicates.
1: 			 */
0: 			wherePredicates.checkTopPredicatesForEqualsConditions(
1: 								tableNumber, eqOuterCols, tableNumbers,
1: 								tableColMap[index], resultColTable);
1: 
1: 			/* Now see if there are any equality conditions
1: 			 * of interest that were already pushed down to the
1: 			 * PRN above the FBT. (Single table predicates.)
1: 			 */
1: 			if (prn.getRestrictionList() != null)
1: 			{
1: 				prn.getRestrictionList().checkTopPredicatesForEqualsConditions(
1: 								tableNumber, eqOuterCols, tableNumbers,
1: 								tableColMap[index], resultColTable);
1: 			}
1: 
1: 			/* We can finally check to see if the marked columns
1: 			 * are a superset of any unique index.
1: 			 */
1: 			if (! fbt.supersetOfUniqueIndex(tableColMap[index]))
1: 			{
1: 				return false;
1: 			}
1: 			
1: 			/* Do we have at least 1 table whose equality condition
1: 			 * is based solely on constants, parameters and correlation columns.
1: 			 */
1: 			oneRowResult = fbt.supersetOfUniqueIndex(eqOuterCols);
1: 			if (oneRowResult)
1: 			{
1: 				oneRow[index] = true;
1: 				satisfiesOuter = true;
1: 			}
1: 		}
1: 
1: 		/* Have we met all of the criteria */
1: 		if (satisfiesOuter)
1: 		{
1: 			/* check that all the tables are joined by unique indexes 
1: 			 * or only produce 1 row
1: 			 */
1: 			boolean foundOneRow = true;
1: 			while (foundOneRow)
1: 			{
1: 				foundOneRow = false;
1: 				for (int index = 0; index < size; index++)
1: 				{
1: 					if (oneRow[index])
1: 					{
1: 						for (int i = 0; i < size; i++)
1: 						{
1: 							/* unique key join - exists tables already marked as 
1: 							 * 1 row - so don't need to look at them
1: 							 */
1: 							if (!oneRow[i] && tableColMap[i][index].get(0))	
1: 							{
1: 								oneRow[i] = true;
1: 								foundOneRow = true;
1: 							}
1: 						}
1: 					}
1: 				}
1: 			}
1: 			/* does any table produce more than one row */
1: 			for (int index = 0; index < size; index++)
1: 			{
1: 				if (!oneRow[index])
1: 				{
1: 					satisfiesOuter = false;
1: 					break;
1: 				}
1: 			}
1: 		}
1: 		return satisfiesOuter;
1: 	}
1: 
1: 	int[] getTableNumbers()
1: 	{
1: 		int size = size();
1: 		int[] tableNumbers = new int[size];
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			ProjectRestrictNode prn = (ProjectRestrictNode) elementAt(index);
1: 			if (! (prn.getChildResult() instanceof FromTable))
1: 			{
1: 				continue;
1: 			}
1: 			FromTable ft = (FromTable) prn.getChildResult();
1: 			tableNumbers[index] = ft.getTableNumber();
1: 		}
1: 
1: 		return tableNumbers;
1: 	}
1: 
1: 	/**
1: 	 * Mark all of the FromBaseTables in the list as EXISTS FBTs.
1: 	 * Each EBT has the same dependency list - those tables that are referenced
1: 	 * minus the tables in the from list.
1: 	 *
1: 	 * @param referencedTableMap	The referenced table map.
1: 	 * @param outerFromList			FromList from outer query block
1: 	 * @param isNotExists			Whether or not for NOT EXISTS
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void genExistsBaseTables(JBitSet referencedTableMap, FromList outerFromList,
1: 							 boolean isNotExists)
1: 		throws StandardException
1: 	{
1: 		JBitSet			dependencyMap = (JBitSet) referencedTableMap.clone();
1: 
1: 		// We currently only flatten single table from lists
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (size() != 1)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"size() expected to be 1, not " + size());
1: 			}
1: 		}
1: 
1: 		/* Create the dependency map */
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			ResultSetNode ft = ((ProjectRestrictNode) elementAt(index)).getChildResult();
1: 			if (ft instanceof FromTable)
1: 			{
1: 				dependencyMap.clear(((FromTable) ft).getTableNumber());
1: 			}
1: 		}
1: 
1: 		/* Degenerate case - If flattening a non-correlated EXISTS subquery
1: 		 * then we need to make the table that is getting flattened dependendent on
1: 		 * all of the tables in the outer query block.  Gross but true.  Otherwise
1: 		 * that table can get chosen as an outer table and introduce duplicates.
1: 		 * The reason that duplicates can be introduced is that we do special processing
1: 		 * in the join to make sure only one qualified row from the right side is
1: 		 * returned.  If the exists table is on the left, we can return all the
1: 		 * qualified rows. 
1: 		 */
1: 		if (dependencyMap.getFirstSetBit() == -1)
1: 		{
1: 			int outerSize = outerFromList.size();
1: 			for (int outer = 0; outer < outerSize; outer++)
1: 				dependencyMap.or(((FromTable) outerFromList.elementAt(outer)).getReferencedTableMap());
1: 		}
1: 
1: 		/* Do the marking */
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			FromTable fromTable = (FromTable) elementAt(index);
1: 			if (fromTable instanceof ProjectRestrictNode)
1: 			{
1: 				ProjectRestrictNode prn = (ProjectRestrictNode) fromTable;
1: 				if (prn.getChildResult() instanceof FromBaseTable)
1: 				{
1: 					FromBaseTable fbt = (FromBaseTable) prn.getChildResult();
1: 					fbt.setExistsBaseTable(true, (JBitSet) dependencyMap.clone(), isNotExists);
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the lock mode for the target of an update statement
1: 	 * (a delete or update).  The update mode will always be row for
1: 	 * CurrentOfNodes.  It will be table if there is no where clause.
1: 	 *
1: 	 * @return	The lock mode
1: 	 */
0: 	public int updateTargetLockMode()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (size() != 1)
1: 			{
1: 				SanityManager.THROWASSERT(
0: 					"size() expected to be 1");
1: 			}
1: 		}
0: 		return ((ResultSetNode) elementAt(0)).updateTargetLockMode();
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not the user specified a hash join for any of the 
1: 	 * tables in this list.
1: 	 *
1: 	 * @return	Whether or not the user specified a hash join for any of the 
1: 	 *			tables in this list.
1: 	 */
1: 	boolean hashJoinSpecified()
1: 	{
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			FromTable ft = (FromTable) elementAt(index);
1: 			String joinStrategy = ft.getUserSpecifiedJoinStrategy();
1: 
1: 			if (joinStrategy != null && StringUtil.SQLToUpperCase(joinStrategy).equals("HASH"))
1: 			{
1: 				return true;
1: 			}
1: 		}
1: 
1: 		return false;
1: 	}
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
0: 	 * @param v the visitor
1: 	 *
0: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			FromTable fromTable = (FromTable) elementAt(index);
0: 			setElementAt((QueryTreeNode) fromTable.accept(v), index);
1: 		}
1: 
0: 		return this;
1: 	}
1: }
author:Army
-------------------------------------------------------------------------------
commit:0787955
/////////////////////////////////////////////////////////////////////////
1: 	/* Whether or not this FromList is transparent.  A "transparent" FromList
1: 	 * is one in which all FromTables are bound based on an outer query's
1: 	 * FromList.  This means that the FromTables in the transparent list are
1: 	 * allowed to see and reference FromTables in the outer query's list.
1: 	 * Or put differently, a FromTable which sits in a transparent FromList
1: 	 * does not "see" the transparent FromList when binding; rather, it sees
1: 	 * (and can therefore reference) the FromList of an outer query.
0: 	 */
1: 	private boolean isTransparent;
0: 		isTransparent = false;
/////////////////////////////////////////////////////////////////////////
0: 
1: 			/* If this FromList is transparent then its FromTables should
1: 			 * be bound based on the outer query's FROM list.
0: 			 */
1: 			fromTable.bindExpressions(
1: 				isTransparent ? fromListParam : this);
/////////////////////////////////////////////////////////////////////////
1: 	 * of the base tables in the from list at the current nesting level;
1: 	 * otherwise it will expand into a list of all of the columns in the
1: 	 * base table that matches the qualification.
1: 	 * NOTE: Callers are responsible for ordering the FromList by nesting
1: 	 * level, with tables at the deepest (current) nesting level first.  
1: 	 * We will expand the "*" into a list of all columns from all tables
1: 	 * having the same nesting level as the first FromTable in this list.
1: 	 * The check for nesting level exists because it's possible that this
1: 	 * FromList includes FromTables from an outer query, which can happen
1: 	 * if there is a "transparent" FromList above this one in the query
1: 	 * tree.  Ex:
0: 	 *
1: 	 *  select j from onerow where exists
1: 	 *    (select 1 from somerow
0: 	 *      union select * from diffrow where onerow.j < diffrow.k)
0: 	 *
1: 	 * If "this" is the FromList for the right child of the UNION then it will
1: 	 * contain both "diffrow" and "onerow", the latter of which was passed
1: 	 * down via a transparent FromList (to allow binding of the WHERE clause).
1: 	 * In that case the "*" should only expand the result columns of "diffrow";
1: 	 * it should not expand the result columns of "onerow" because that table
1: 	 * is from an outer query.  We can achieve this selective expansion by
1: 	 * looking at nesting levels.
0: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 		 * (allTableName is not null) or for all tables in the list at the
1: 		 * current nesting level if the "*" is not qualified (allTableName
1: 		 * is null).  Current nesting level is determined by the nesting
1: 		 * level of the first FromTable in the list.
1: 		int targetNestingLevel = ((FromTable)elementAt(0)).getLevel();
0: 
1: 		/* Make sure our assumption about nesting-based ordering
1: 		 * has been satisified.  I.e. that the list is ordered
1: 		 * with the most deeply nested FromTables first.
0: 		 */
0: 		if (SanityManager.DEBUG)
1: 		{
1: 			int prevNL = targetNestingLevel;
1: 			for (int i = 1; i < size; i++)
1: 			{
1: 				int currNL = ((FromTable)elementAt(i)).getLevel();
1: 				SanityManager.ASSERT((prevNL >= currNL),
1: 					"FROM list should have been ordered by nesting " +
1: 					"level (deepest level first), but it was not.");
0: 
1: 				prevNL = currNL;
1: 			}
1: 		}
0: 
1: 			if (targetNestingLevel != fromTable.getLevel())
1: 			{
1: 				/* We only expand result columns for tables at the
1: 				 * target nesting level.  Since the FromTables are
1: 				 * sorted based on nesting level, we're done if we
1: 				 * get here.
0: 				 */
1: 				break;
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 	 * Indicate that this FromList is "transparent", which means that
1: 	 * its FromTables should be bound to tables from an outer query.
1: 	 * Generally this is not allowed, but there are exceptions.  See
1: 	 * SetOperatorNode.setResultToBooleanTrueNode() for more.
0: 	 */
1: 	void markAsTransparent()
0: 	{
1: 		isTransparent = true;
0: 	}
0: 
0: 	/**
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:41943bb
/////////////////////////////////////////////////////////////////////////
0: 			fromTable.bindExpressions(this);
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:444aa52
/////////////////////////////////////////////////////////////////////////
0: 	public void bindExpressions( FromList fromListParam )
/////////////////////////////////////////////////////////////////////////
0: 			fromTable.bindExpressions( makeFromList( fromListParam, fromTable ) );
0: 	 * Construct an appropriate from list for binding an individual
0: 	 * table element. Normally, this is just this list. However,
0: 	 * for the special wrapper queries which the parser creates for
0: 	 * GROUP BY and HAVING clauses, the appropriate list is the
0: 	 * outer list passed into us--it will contain the appropriate
0: 	 * tables needed to resolve correlated columns.
0: 	 */
0: 	private	FromList	makeFromList( FromList fromListParam, FromTable fromTable )
0: 	{
0: 		if ( fromTable instanceof FromSubquery )
0: 		{
0: 			FromSubquery	fromSubquery = (FromSubquery) fromTable;
0: 
0: 			if ( fromSubquery.generatedForGroupByClause || fromSubquery.generatedForHavingClause )
0: 			{ return fromListParam; }
0: 		}
0: 
0: 		return this;
0: 	}
0: 	
0: 	/**
/////////////////////////////////////////////////////////////////////////
0: 
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:318307e
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
0: 
0: 					CompilerContext cc = getCompilerContext();
0: 					cc.addRequiredColumnPriv( resultColumn.getTableColumnDescriptor());
commit:6d9c32a
/////////////////////////////////////////////////////////////////////////
1: 	// FromList could have a view in it's list. If the view is defined in SESSION
1: 	// schema, then we do not want to cache the statement's plan. This boolean
1: 	// will help keep track of such a condition.
1: 	private boolean  referencesSessionSchema;
0: 
0: 
/////////////////////////////////////////////////////////////////////////
1: 		// Following if will return true if this FromList object had any VIEWs
1: 		// from SESSION schema as elements.  This information is gathered during
1: 		// the bindTables method. At the end of the bindTables, we loose
1: 		// the information on VIEWs since they get replaced with their view
1: 		// definition. Hence, we need to intercept in the middle on the bindTables
1: 		// method and save that information in referencesSeesionSchema field.
1: 		if (referencesSessionSchema) return true;
0: 
/////////////////////////////////////////////////////////////////////////
0: 			ResultSetNode newNode = fromTable.bindNonVTITables(dataDictionary, fromListParam);
1: 			// If the fromTable is a view in the SESSION schema, then we need to save that information
1: 			// in referencesSessionSchema element. The reason for this is that the view will get
1: 			// replaced by it's view definition and we will loose the information that the statement
1: 			// was referencing a SESSION schema object. 
1: 			if (fromTable.referencesSessionSchema())
1: 				referencesSessionSchema = true;
1: 			setElementAt(newNode, index);
0: 			ResultSetNode newNode = fromTable.bindVTITables(fromListParam);
1: 			if (fromTable.referencesSessionSchema())
1: 				referencesSessionSchema = true;
1: 			setElementAt(newNode, index);
commit:ef20e7a
/////////////////////////////////////////////////////////////////////////
0: 	 * Decrement (query block) level (0-based) for
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 	 * are in equality comparisons with expressions that do not include columns
/////////////////////////////////////////////////////////////////////////
0: 	 *
0: 	 *		eqOuterCol with join columns and correlation variables,
0: 	 * 		reduces the number of columns required for uniqueness in a
0: 	 *
0: 	 *		check if the marked columns in tableColMap are a superset of a unique
0: 	 *			index
0: 	 *		check that there is a least one table for which the columns in
/////////////////////////////////////////////////////////////////////////
0: 	 *
/////////////////////////////////////////////////////////////////////////
0: 	boolean returnsAtMostSingleRow(ResultColumnList rcl,
0: 								   ValueNode whereClause,
/////////////////////////////////////////////////////////////////////////
1: 		PredicateList predicatesTemp;
0: 		predicatesTemp = (PredicateList) getNodeFactory().getNode(
0: 			C_NodeTypes.PREDICATE_LIST,	getContextManager());
0: 		int wherePredicatesSize = wherePredicates.size();
0: 		for (int index = 0; index < wherePredicatesSize; index++)
0: 			predicatesTemp.addPredicate((Predicate)wherePredicates.elementAt(index));
0: 
/////////////////////////////////////////////////////////////////////////
1: 			FromBaseTable fbt = (FromBaseTable) prn.getChildResult();
1: 			//Following for loop code is to take care of Derby-251 (DISTINCT returns
1: 			//duplicate rows).
1: 			//Derby-251 returned duplicate rows because we were looking at predicates
1: 			//that belong to existsTable to determine DISTINCT elimination
1: 			//
1: 			//(Check method level comments to understand DISTINCT elimination rules.)
1: 			//
1: 			//For one specific example, consider the query below
1: 			//select  distinct  q1."NO1" from IDEPT q1, IDEPT q2
1: 			//where  ( q2."DISCRIM_DEPT" = 'HardwareDept')
1: 			//and  ( q1."DISCRIM_DEPT" = 'SoftwareDept')  and  ( q1."NO1" <> ALL
1: 			//(select  q3."NO1" from IDEPT q3 where  (q3."REPORTTO_NO" =  q2."NO1")))
1: 			//(select  q3."NO1" from IDEPT q3 where  ( ABS(q3."REPORTTO_NO") =  q2."NO1")))
1: 			//
1: 			//Table IDEPT in the query above has a primary key defined on column "NO1"
1: 			//This query gets converted to following during optimization
1: 			//
1: 			//select  distinct  q1."NO1" from IDEPT q1, IDEPT q2
1: 			//where  ( q2."DISCRIM_DEPT" = 'HardwareDept')
1: 			//and  ( q1."DISCRIM_DEPT" = 'SoftwareDept')  and  not exists (
1: 			//(select  q3."NO1" from IDEPT q3 where
1: 			//(  ( ABS(q3."REPORTTO_NO") =  q2."NO1")  and q3."NO1" = q1."NO1") ) )  ;
1: 			//
1: 			//For the optimized query above, Derby generates following predicates.
1: 			//ABS(q3.reportto_no) = q2.no1
1: 			//q2.discrim_dept = 'HardwareDept'
1: 			//q1.descrim_dept = 'SoftwareDept'
1: 			//q1.no1 = q3.no1
1: 			//The predicate ABS(q3."NO1") = q1."NO1" should not be considered when trying
1: 			//to determine if q1 in the outer query has equality comparisons. 
1: 			//Similarly, the predicate q3.reportto_no = q2.no1 should not be
1: 			//considered when trying to determine if q2 in the outer query has
1: 			//equality comparisons. To achieve this, predicates based on exists base
1: 			//table q3 (the first and the last predicate) should be removed while
1: 			//evaluating outer query for uniqueness.
1: 			//
1: 			if (fbt.getExistsBaseTable())
0: 			{
1: 				int existsTableNumber = fbt.getTableNumber();
0: 				int predicatesTempSize = predicatesTemp.size();
0: 				for (int predicatesTempIndex = predicatesTempSize-1;
0: 					predicatesTempIndex >= 0; predicatesTempIndex--)
0: 				{
0: 					AndNode topAndNode = (AndNode)
0: 						((Predicate) predicatesTemp.elementAt(predicatesTempIndex)).getAndNode();
0: 
1: 					for (ValueNode whereWalker = topAndNode; whereWalker instanceof AndNode;
1: 						whereWalker = ((AndNode) whereWalker).getRightOperand())
0: 					{
1: 						// See if this is a candidate =
1: 						AndNode and = (AndNode) whereWalker;
0: 
1: 						//we only need to worry about equality predicates because only those
1: 						//predicates are considered during DISTINCT elimination.
1: 						if (!and.getLeftOperand().isRelationalOperator() ||
1: 							!(((RelationalOperator)(and.getLeftOperand())).getOperator() ==
1: 							RelationalOperator.EQUALS_RELOP))
0: 						{
1: 							continue;
0: 						}
0: 
1: 						JBitSet referencedTables = and.getLeftOperand().getTablesReferenced();
1: 						if (referencedTables.get(existsTableNumber))
0: 						{
0: 							predicatesTemp.removeElementAt(predicatesTempIndex);
1: 							break;
0: 						}
0: 					}
0: 				}
0: 			}
/////////////////////////////////////////////////////////////////////////
1: 			predicatesTemp.checkTopPredicatesForEqualsConditions(
/////////////////////////////////////////////////////////////////////////
0: 							if (!oneRow[i] && tableColMap[i][index].get(0))
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import java.util.Properties;
0: import java.util.Enumeration;
0: import java.util.Vector;
0: 
0: /**
0:  * A FromList represents the list of tables in a FROM clause in a DML
0:  * statement.  It extends QueryTreeNodeVector.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public class FromList extends QueryTreeNodeVector implements OptimizableList
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	Properties	properties;
0: 	// RESOLVE: The default should be false
0: 	boolean		fixedJoinOrder = true;
0: 	// true by default.
0: 	boolean 	useStatistics = true;
0: 
0: 	/** Initializer for a FromList */
0: 
0: 	public void init(Object optimizeJoinOrder)
0: 	{
0: 		fixedJoinOrder = ! (((Boolean) optimizeJoinOrder).booleanValue());
0: 	}
0: 
0: 	/**
0: 	 * Initializer for a FromList
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(Object optimizeJoinOrder, Object fromTable)
0: 				throws StandardException
0: 	{
0: 		init(optimizeJoinOrder);
0: 
0: 		addFromTable((FromTable) fromTable);
0: 	}
0: 
0: 	/*
0: 	 * OptimizableList interface
0: 	 */
0: 
0: 	/**
0: 	 * @see org.apache.derby.iapi.sql.compile.OptimizableList#getOptimizable
0: 	 */
0: 	public Optimizable getOptimizable(int index)
0: 	{
0: 		return (Optimizable) elementAt(index);
0: 	}
0: 
0: 	/**
0: 	 * @see org.apache.derby.iapi.sql.compile.OptimizableList#setOptimizable
0: 	 */
0: 	public void setOptimizable(int index, Optimizable optimizable)
0: 	{
0: 		setElementAt((FromTable) optimizable, index);
0: 	}
0: 
0: 	/** 
0: 	 * @see OptimizableList#verifyProperties
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void verifyProperties(DataDictionary dDictionary) throws StandardException
0: 	{
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			((Optimizable) elementAt(index)).verifyProperties(dDictionary);
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 	 * Add a table to the FROM list.
0: 	 *
0: 	 * @param fromTable	A FromTable to add to the list
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void addFromTable(FromTable fromTable) throws StandardException
0: 	{
0: 		/* Don't worry about checking TableOperatorNodes since
0: 		 * they don't have exposed names.  This will potentially
0: 		 * allow duplicate exposed names in some degenerate cases,
0: 		 * but the binding of the ColumnReferences will catch those
0: 		 * cases with a different error.  If the query does not have
0: 		 * any ColumnReferences from the duplicate exposed name, the
0: 		 * user is executing a really dumb query and we won't throw
0: 		 * and exception - consider it an ANSI extension.
0: 		 */
0: 		if (! (fromTable instanceof TableOperatorNode))
0: 		{
0: 			/* Check for duplicate table name in FROM list */
0: 			int size = size();
0: 			for (int index = 0; index < size; index++)
0: 			{
0: 				if (fromTable.getExposedName().equals
0: 					(((FromTable) elementAt(index)).getExposedName()) )
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_FROM_LIST_DUPLICATE_TABLE_NAME, fromTable.getExposedName());
0: 				}
0: 			}
0: 		}
0: 
0: 		addElement(fromTable);
0: 	}
0: 
0: 	/**
0: 	 * Search to see if a query references the specifed table name.
0: 	 *
0: 	 * @param name		Table name (String) to search for.
0: 	 * @param baseTable	Whether or not name is for a base table
0: 	 *
0: 	 * @return	true if found, else false
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean referencesTarget(String name, boolean baseTable)
0: 		throws StandardException
0: 	{
0: 		FromTable		fromTable;
0: 		boolean			found = false;
0: 
0: 		/* Check for table or VTI name in FROM list */
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			fromTable = (FromTable) elementAt(index);
0: 
0: 			if (fromTable.referencesTarget(name, baseTable)) 
0: 			{
0: 				found = true;
0: 				break;
0: 			}
0: 		}
0: 
0: 		return found;
0: 	}
0: 
0: 	/**
0: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
0: 	 *
0: 	 * @return	true if references SESSION schema tables, else false
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean referencesSessionSchema()
0: 		throws StandardException
0: 	{
0: 		FromTable		fromTable;
0: 		boolean			found = false;
0: 
0: 		/* Check for table or VTI name in FROM list */
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			fromTable = (FromTable) elementAt(index);
0: 
0: 			if (fromTable.referencesSessionSchema())
0: 			{
0: 				found = true;
0: 				break;
0: 			}
0: 		}
0: 
0: 		return found;
0: 	}
0: 
0: 	/** 
0: 	 * Determine whether or not the specified name is an exposed name in
0: 	 * the current query block.
0: 	 *
0: 	 * @param name	The specified name to search for as an exposed name.
0: 	 * @param schemaName	Schema name, if non-null.
0: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
0: 	 *						names or match on table id.
0: 	 *
0: 	 * @return The FromTable, if any, with the exposed name.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
0: 		throws StandardException
0: 	{
0: 		boolean			found = false;
0: 		FromTable		fromTable;
0: 		FromTable		result = null;
0: 
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			fromTable = (FromTable) elementAt(index);
0: 
0: 			result = fromTable.getFromTableByName(name, schemaName, exactMatch);
0: 
0: 			if (result != null)
0: 			{
0: 				return result;
0: 			}
0: 		}
0: 		return result;
0: 	}
0: 
0: 	/**
0: 	 * Bind the tables in this FromList.  This includes looking them up in
0: 	 * the DataDictionary, getting their TableDescriptors and assigning the
0: 	 * table numbers.
0: 	 *
0: 	 * @param dataDictionary	The DataDictionary to use for binding
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void bindTables(DataDictionary dataDictionary, 
0: 							FromList fromListParam) 
0: 			throws StandardException
0: 	{
0: 		FromTable	fromTable;
0: 
0: 		/* Now we bind the tables - this is a 2 step process.
0: 		 * We first bind all of the non-VTIs, then we bind the VTIs.
0: 		 * This enables us to handle the passing of correlation
0: 		 * columns in VTI parameters.
0: 		 * NOTE: We set the table numbers for all of the VTIs in the
0: 		 * first step, when we find them, in order to avoid an ordering
0: 		 * problem with join columns in parameters.
0: 		 */
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			fromTable = (FromTable) elementAt(index);
0: 			setElementAt(fromTable.bindNonVTITables(dataDictionary, fromListParam), index);
0: 		}
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			fromTable = (FromTable) elementAt(index);
0: 			setElementAt(fromTable.bindVTITables(fromListParam), index);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind the expressions in this FromList.  This means 
0: 	 * binding the sub-expressions, as well as figuring out what the return 
0: 	 * type is for each expression.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void bindExpressions()
0: 					throws StandardException
0: 	{
0: 		FromTable	fromTable;
0: 
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			fromTable = (FromTable) elementAt(index);
0: 			fromTable.bindExpressions(this);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind the result columns of the ResultSetNodes in this FromList when there is no
0: 	 * base table to bind them to.  This is useful for SELECT statements,
0: 	 * where the result columns get their types from the expressions that
0: 	 * live under them.
0: 	 *
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void bindResultColumns(FromList fromListParam)
0: 				throws StandardException
0: 	{
0: 		FromTable	fromTable;
0: 
0: 		int origList = fromListParam.size();
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			fromTable = (FromTable) elementAt(index);
0: 			if (fromTable.needsSpecialRCLBinding())
0: 				fromTable.bindResultColumns(fromListParam);
0: 
0: 			fromListParam.insertElementAt(fromTable, 0);
0: 		}
0: 
0: 		/* Remove all references added here */
0: 		while (fromListParam.size() > origList)
0: 			fromListParam.removeElementAt(0);
0: 	}
0: 
0: 	/**
0: 	 * Returns true if any Outer joins present. Used to set Nullability
0: 	 *
0: 	 * @return	True if has any outer joins. False otherwise.
0: 	 */
0: 	public boolean hasOuterJoins()
0: 				throws StandardException
0: 	{
0: 		FromTable	fromTable;
0: 
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			fromTable = (FromTable) elementAt(index);
0: 			if (fromTable instanceof HalfOuterJoinNode)
0: 				return true;
0: 		}
0: 
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Expand a "*" into the appropriate ResultColumnList. If the "*"
0: 	 * is unqualified it will expand into a list of all columns in all
0: 	 * of the base tables in the from list, otherwise it will expand
0: 	 * into a list of all of the columns in the base table that matches
0: 	 * the qualification.
0: 	 *
0: 	 * @param allTableName		The qualification on the "*" as a String.
0: 	 *
0: 	 * @return ResultColumnList representing expansion
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultColumnList expandAll(String allTableName)
0: 			throws StandardException
0: 	{
0: 		ResultColumnList resultColumnList = null;
0: 		ResultColumnList tempRCList = null;
0: 		boolean			 matchfound = false;
0: 		FromTable	 fromTable;
0:  
0: 		/* Expand the "*" for the table that matches, if it is qualified 
0: 		 * (allTableName is not null) or for all tables in the list if the 
0: 		 * "*" is not qualified (allTableName is null).
0: 		 */
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			fromTable = (FromTable) elementAt(index);
0: 			fromTable.setAllColumnsProjected(true);
0: 
0: 			/* We let the FromTable decide if there is a match on
0: 			 * the exposed name.  (A JoinNode will not have an
0: 			 * exposed name, so it will need to pass the info to its
0: 			 * left and right children.)
0: 			 */
0: 			tempRCList = fromTable.getAllResultColumns(allTableName);
0: 
0: 			if (tempRCList == null)
0: 			{
0: 				continue;
0: 			}
0: 
0: 			/* Expand the column list and append to the list that
0: 			 * we will return.
0: 			 */
0: 			if (resultColumnList == null)
0: 			{
0: 				resultColumnList = tempRCList;
0: 			}
0: 			else
0: 			{
0: 				resultColumnList.nondestructiveAppend(tempRCList);
0: 			}
0: 
0: 			/* If the "*" is qualified, then we can stop the
0: 			 * expansion as soon as we find the matching table.
0: 			 */
0: 			if (allTableName != null)
0: 			{
0: 				matchfound = true;
0: 			}
0: 		}
0: 
0: 		/* Give an error if the qualification name did not match 
0: 		 * an exposed name 
0: 		 */
0: 		if (resultColumnList == null)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_EXPOSED_NAME_NOT_FOUND, allTableName);
0: 		}
0: 
0: 		return resultColumnList;
0: 	}
0: 
0: 	/**
0: 	 * Bind a column reference to one of the tables in this FromList.  The column name
0: 	 * must be unique within the tables in the FromList.  An exception is thrown
0: 	 * if a column name is not unique.
0: 	 *
0: 	 * NOTE: Callers are responsible for ordering the FromList by nesting level,
0: 	 * with tables at the deepest (current) nesting level first.  We will try to 
0: 	 * match against all FromTables at a given nesting level.  If no match is
0: 	 * found at a nesting level, then we proceed to the next level.  We stop
0: 	 * walking the list when the nesting level changes and we have found a match.
0: 	 *
0: 	 * NOTE: If the ColumnReference is qualified, then we will stop the search
0: 	 * at the first nesting level where there is a match on the exposed table name.
0: 	 * For example, s (a, b, c), t (d, e, f)
0: 	 *		select * from s where exists (select * from t s where s.c = a)
0: 	 * will not find a match for s.c, which is the expected ANSI behavior.
0: 	 *
0: 	 * bindTables() must have already been called on this FromList before
0: 	 * calling this method.
0: 	 *
0: 	 * @param columnReference	The ColumnReference describing the column to bind
0: 	 *
0: 	 * @return	ResultColumn	The matching ResultColumn
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultColumn bindColumnReference(ColumnReference columnReference)
0: 				throws StandardException
0: 	{
0: 		boolean			columnNameMatch = false;
0: 		boolean			tableNameMatch = false;
0: 		FromTable		fromTable;
0: 		int				currentLevel = -1;
0: 		int				previousLevel = -1;
0: 		ResultColumn	matchingRC = null;
0: 		ResultColumn	resultColumn;
0: 		String			crTableName = columnReference.getTableName();
0: 
0: 		/*
0: 		** Find the first table with matching column name.  If there
0: 		** is more than one table with a matching column name at the same
0: 		** nesting level, give an error.
0: 		*/
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			fromTable = (FromTable) elementAt(index);
0: 
0: 			/* We can stop if we've found a matching column or table name 
0: 			 * at the previous nesting level.
0: 			 */
0: 			currentLevel = fromTable.getLevel();
0: 			if (previousLevel != currentLevel)
0: 			{
0: 				if (columnNameMatch)
0: 				{
0: 					break;
0: 				}
0: 
0: 				if (tableNameMatch)
0: 				{
0: 					break;
0: 				}
0: 			}
0: 			/* Simpler to always set previousLevel then to test and set */
0: 			previousLevel = currentLevel;
0: 
0: 			resultColumn = fromTable.getMatchingColumn(columnReference);
0: 			if (resultColumn != null)
0: 			{
0: 				if (! columnNameMatch)
0: 				{
0: 					/* TableNumbers are set in the CR in the underlying
0: 					 * FromTable.  This ensures that they get the table
0: 					 * number from the underlying table, not the join node.
0: 					 * This is important for beging able to push predicates 
0: 					 * down through join nodes.
0: 					 */
0: 					matchingRC = resultColumn;
0: 					columnReference.setSource(resultColumn);
0: 					columnReference.setType(resultColumn.getTypeServices());
0: 					/* Set the nesting level at which the CR appears and the nesting level
0: 					 * of its source RC.
0: 					 */
0: 					columnReference.setNestingLevel(((FromTable) elementAt(0)).getLevel());
0: 					columnReference.setSourceLevel(currentLevel);
0: 					columnNameMatch = true;
0: 				}
0: 				else
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_AMBIGUOUS_COLUMN_NAME, 
0: 							 columnReference.getFullColumnName());
0: 				}
0: 			}
0: 
0: 			/* Remember if we get a match on the exposed table name, so that
0: 			 * we can stop at the beginning of the next level.
0: 			 */
0: 			tableNameMatch = tableNameMatch || 
0: 						(crTableName != null &&
0: 						 crTableName.equals(fromTable.getExposedName()) );
0: 		}
0: 
0: 		return matchingRC;
0: 	}
0: 
0: 	/**
0: 	 * Check for (and reject) all ? parameters directly under the ResultColumns.
0: 	 * This is done for SELECT statements.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown if a ? parameter found
0: 	 *									directly under a ResultColumn
0: 	 */
0: 
0: 	public void rejectParameters() throws StandardException
0: 	{
0: 		FromTable	fromTable;
0: 
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			fromTable = (FromTable) elementAt(index);
0: 			fromTable.rejectParameters();
0: 		}
0: 	}
0: 
0: 	// This method reorders LOJs in the FROM clause.
0: 	// For now, we process only a LOJ.  For example, "... from LOJ_1, LOJ2 ..."
0: 	// will not be processed. 
0: 	public boolean LOJ_reorderable(int numTables) throws StandardException
0: 	{
0: 		boolean anyChange = false;
0: 
0: 		if (size() > 1) return anyChange;
0: 
0: 		FromTable ft = (FromTable) elementAt(0);
0: 
0: 		anyChange = ft.LOJ_reorderable(numTables);
0: 
0: 		return anyChange;
0: 	}
0: 
0: 	/**
0: 	 * Preprocess the query tree - this currently means:
0: 	 *	o  Generating a referenced table map for each ResultSetNode.
0: 	 *  o  Putting the WHERE and HAVING clauses in conjunctive normal form (CNF).
0: 	 *  o  Converting the WHERE and HAVING clauses into PredicateLists and
0: 	 *	   classifying them.
0: 	 *  o  Flatten those FromSubqueries which can be flattened.
0: 	 *  o  Ensuring that a ProjectRestrictNode is generated on top of every 
0: 	 *     FromBaseTable and generated in place of every FromSubquery which
0: 	 *	   could not be flattened.  
0: 	 *  o  Pushing single table predicates down to the new ProjectRestrictNodes.
0: 	 *
0: 	 * @param numTables			The number of tables in the DML Statement
0: 	 * @param gbl				The group by list, if any
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void preprocess(int numTables,
0: 						   GroupByList gbl,
0: 						   ValueNode predicateTree)
0: 								throws StandardException
0: 	{
0: 		int size = size();
0: 
0: 		/* Preprocess each FromTable in the list */
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			FromTable ft = (FromTable) elementAt(index);
0: 
0: 			/* Transform any outer joins to inner joins where appropriate */
0: 			ft = ft.transformOuterJoins(predicateTree, numTables);
0: 			/* Preprocess this FromTable */
0: 			setElementAt(ft.preprocess(numTables, gbl, this), index);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Flatten all the FromTables that are flattenable.
0: 	 * RESOLVE - right now we just flatten FromSubqueries.  We
0: 	 * should also flatten flattenable JoinNodes here.
0: 	 *
0: 	 * @param rcl				The RCL from the outer query
0: 	 * @param predicateList		The PredicateList from the outer query
0: 	 * @param sql				The SubqueryList from the outer query
0: 	 * @param gbl				The group by list, if any
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void flattenFromTables(ResultColumnList rcl,
0: 								  PredicateList predicateList,
0: 								  SubqueryList sql,
0: 								  GroupByList gbl)
0: 									throws StandardException
0: 	{
0: 		boolean			flattened = true;
0: 		Vector 			flattenedTableNumbers = new Vector();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(rcl != null,
0: 							 "rcl is expected to be non-null");
0: 			SanityManager.ASSERT(predicateList != null,
0: 							 "predicateList is expected to be non-null");
0: 			SanityManager.ASSERT(sql != null,
0: 							 "sql is expected to be non-null");
0: 		}
0: 
0: 		/* Loop until all flattenable entries are flattened.
0: 		 * We restart the inner loop after flattening an in place
0: 		 * to simplify the logic and so that we don't have to worry
0: 		 * about walking a list while we are modifying it.
0: 		 */
0: 		while (flattened)
0: 		{
0: 			flattened = false;
0: 
0: 			for (int index = 0; index < size() && ! flattened; index++)
0: 			{
0: 				FromTable ft = (FromTable) elementAt(index);
0: 
0: 				/* Flatten FromSubquerys and flattenable JoinNodes */
0: 				if ((ft instanceof FromSubquery) ||
0: 					ft.isFlattenableJoinNode())
0: 				{
0: 					//save the table number of the node to be flattened
0: 					flattenedTableNumbers.addElement(new Integer(ft.getTableNumber()));
0: 
0: 					/* Remove the node from the list and insert its
0: 					 * FromList here.
0: 					 */
0: 					FromList	 flatteningFL = ft.flatten(
0: 														rcl,
0: 														predicateList,
0: 														sql,
0: 														gbl);
0: 					if (SanityManager.DEBUG)
0: 					{
0: 						SanityManager.ASSERT(flatteningFL == null ||
0: 											 flatteningFL.size() > 0,
0: 							"flatteningFL expected to be null or size > 0");
0: 					}
0: 
0: 					if (flatteningFL != null)
0: 					{
0: 						setElementAt(flatteningFL.elementAt(0), index);
0: 
0: 						int innerSize = flatteningFL.size();
0: 						for (int inner = 1; inner < innerSize; inner++)
0: 						{
0: 							insertElementAt(flatteningFL.elementAt(inner), index + inner);
0: 						}
0: 					}
0: 					else
0: 					{
0: 						/*
0: 						** If flatten returns null, that means it wants to
0: 						** be removed from the FromList.
0: 						*/
0: 						removeElementAt(index);
0: 					}
0: 					flattened = true;
0: 				}
0: 			}
0: 		}
0: 		
0: 		/* fix up dependency maps for exists base tables since they might have a
0: 		 * dependency on this join node
0: 		 */
0: 		if (flattenedTableNumbers.size() > 0)
0: 		{
0: 			for (int i = 0; i < size(); i++)
0: 			{
0: 				FromTable ft = (FromTable) elementAt(i);
0: 				if (ft instanceof ProjectRestrictNode)
0: 				{
0: 					ResultSetNode rst = ((ProjectRestrictNode)ft).getChildResult();
0: 					if (rst instanceof FromBaseTable)
0: 					{
0: 						((FromBaseTable)rst).clearDependency(flattenedTableNumbers);
0: 					}
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Categorize and push the predicates that are pushable.
0: 	 *
0: 	 * @param predicateList		The query's PredicateList
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void pushPredicates(PredicateList predicateList)
0: 			throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(predicateList != null,
0: 							 "predicateList is expected to be non-null");
0: 		}
0: 
0: 		/* We can finally categorize each Predicate and try to push them down.
0: 		 * NOTE: The PredicateList may be empty, but that's okay, we still
0: 		 * call pushExpressions() for each entry in the FromList because that's
0: 		 * where any outer join conditions will get pushed down.
0: 		 */
0: 		predicateList.categorize();
0: 
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			FromTable fromTable = (FromTable) elementAt(index);
0: 			fromTable.pushExpressions(predicateList);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			FromTable	fromTable;
0: 
0: 			super.printSubNodes(depth);
0: 
0: 			int size = size();
0: 			for (int index = 0; index < size; index++)
0: 			{
0: 				fromTable = (FromTable) elementAt(index);
0: 				fromTable.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Set the (query block) level (0-based) for the FromTables in this
0: 	 * FromList.
0: 	 *
0: 	 * @param level		The query block level for this table.
0: 	 *
0: 	 * @return Nothing
0: 	 */
0: 	public void setLevel(int level)
0: 	{
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			FromTable fromTable = (FromTable) elementAt(index);
0: 			fromTable.setLevel(level);
0: 		}
0: 	}
0: 
0: 	/**
0: 		Move the mark for result set being the statement's outermost
0: 		result set down into the first table of the from list.
0: 		Generally expect there is only one table at this point.
0: 	 */
0: 	void markStatementResultSet()
0: 	{
0: 		((FromTable) elementAt(0)).markStatementResultSet();
0: 	}
0: 
0: 	/**
0: 	 * Get the FromTable from this list which has the specified ResultColumn in
0: 	 * its RCL.
0: 	 *
0: 	 * @param rc	The ResultColumn match on.
0: 	 *
0: 	 * @return FromTable	The matching FromTable.
0: 	 */
0: 	public FromTable getFromTableByResultColumn(ResultColumn rc)
0: 	{
0: 		FromTable	fromTable = null;
0: 
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			fromTable = (FromTable) elementAt(index);
0: 
0: 			if (fromTable.getResultColumns().indexOf(rc) != -1)
0: 			{
0: 				break;
0: 			}
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(fromTable != null,
0: 				"No matching FromTable found");
0: 		}
0: 		return fromTable;
0: 	}
0: 
0: 	/**
0: 	 * Set the Properties list for this FromList.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setProperties(Properties props) throws StandardException
0: 	{
0: 		properties = props;
0: 
0: 		/*
0: 		** Validate the properties list now.  This is possible because
0: 		** there is nothing in this properties list that relies on binding
0: 		** or optimization to validate.
0: 		*/
0: 		Enumeration enum = properties.keys();
0: 		while (enum.hasMoreElements())
0: 		{
0: 			String key = (String) enum.nextElement();
0: 			String value = (String) properties.get(key);
0: 
0: 			if (key.equals("joinOrder"))
0: 			{
0: 				if (StringUtil.SQLEqualsIgnoreCase(value,"fixed"))
0: 				{
0: 					fixedJoinOrder = true;
0: 				}
0: 				else if (StringUtil.SQLEqualsIgnoreCase(value,"unfixed"))
0: 				{
0: 					fixedJoinOrder = false;
0: 				}
0: 				else
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_INVALID_JOIN_ORDER_SPEC, value);
0: 				}
0: 			}
0: 			else if (key.equals("useStatistics"))
0: 			{
0: 				if (StringUtil.SQLEqualsIgnoreCase(value,"true"))
0: 				{
0: 					useStatistics = true;
0: 				}
0: 				else if (StringUtil.SQLEqualsIgnoreCase(value,"false"))
0: 				{
0: 					useStatistics = false;
0: 				}
0: 				else
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_INVALID_STATISTICS_SPEC, value);
0: 				}
0: 			}
0: 			else
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_INVALID_FROM_LIST_PROPERTY, key, value);
0: 			}
0: 		}
0: 	}
0: 
0: 	/** @see OptimizableList#reOrder */
0: 	public void reOrder(int[] joinOrder)
0: 	{
0: 		int	posn;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (joinOrder.length != size())
0: 			{
0: 				SanityManager.THROWASSERT("In reOrder(), size of FromList is " + size() + " while size of joinOrder array is " + joinOrder.length);
0: 			}
0: 
0: 			/*
0: 			** Determine that the values in the list are unique and in range.
0: 			** The easiest way to determine that they are unique is to add
0: 			** them all up and see whether the result is what's expected
0: 			** for that array size.
0: 			*/
0: 			int sum = 0;
0: 			for (int i = 0; i < joinOrder.length; i++)
0: 			{
0: 				if (joinOrder[i] < 0 || joinOrder[i] > (joinOrder.length - 1))
0: 				{
0: 					SanityManager.THROWASSERT("joinOrder[" + i + "] == " +
0: 											joinOrder[i] +
0: 											" is out of range - must be between 0 and " + 
0: 											(joinOrder.length - 1) +
0: 											" inclusive.");
0: 				}
0: 
0: 				sum += joinOrder[i];
0: 			}
0: 
0: 			/*
0: 			** The sum of all integers from 0 through n is (n * (n - 1)) / 2.
0: 			*/
0: 			if (sum != ( ( joinOrder.length * (joinOrder.length - 1) ) / 2) )
0: 			{
0: 				String arrayVals = "";
0: 				for (int i = 0; i < joinOrder.length; i++)
0: 					arrayVals = arrayVals + joinOrder[i] + " ";
0: 				SanityManager.THROWASSERT("joinOrder array has some duplicate value: " + arrayVals);
0: 			}
0: 		}
0: 
0: 		/* Form a list that's in the order we want */
0: 		QueryTreeNode[] orderedFL = new FromTable[joinOrder.length];
0: 		for (posn = 0; posn < joinOrder.length; posn++)
0: 		{
0: 			/*
0: 			** Get the element at the i'th join order position from the
0: 			** current list and make it the next element of orderedList.
0: 			*/
0: 			orderedFL[posn] = elementAt(joinOrder[posn]);
0: 		}
0: 
0: 		/* Now orderedList has been built, so set this list to the same order */
0: 		for (posn = 0; posn < joinOrder.length; posn++)
0: 		{
0: 			setElementAt(orderedFL[posn], posn);
0: 		}
0: 	}
0: 
0: 	/** @see OptimizableList#useStatistics */
0: 	public boolean useStatistics()
0: 	{
0: 		return useStatistics;
0: 	}
0: 
0: 	/** @see OptimizableList#optimizeJoinOrder */
0: 	public boolean optimizeJoinOrder()
0: 	{
0: 		return ! fixedJoinOrder;
0: 	}
0: 
0: 	/** @see OptimizableList#legalJoinOrder */
0: 	public boolean legalJoinOrder(int numTablesInQuery)
0: 	{
0: 		JBitSet			assignedTableMap = new JBitSet(numTablesInQuery);
0: 
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			FromTable ft = (FromTable) elementAt(index);
0: 			assignedTableMap.or(ft.getReferencedTableMap());
0: 			if ( ! ft.legalJoinOrder(assignedTableMap))
0: 			{
0: 				return false;
0: 			}
0: 		}
0: 		return true;
0: 	}
0: 
0: 	/** @see OptimizableList#initAccessPaths */
0: 	public void initAccessPaths(Optimizer optimizer)
0: 	{
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			FromTable ft = (FromTable) elementAt(index);
0: 			ft.initAccessPaths(optimizer);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind any untyped null nodes to the types in the given ResultColumnList.
0: 	 *
0: 	 * @param bindingRCL	The ResultColumnList with the types to bind to.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void bindUntypedNullsToResultColumns(ResultColumnList bindingRCL)
0: 				throws StandardException
0: 	{
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			FromTable fromTable = (FromTable) elementAt(index);
0: 			fromTable.bindUntypedNullsToResultColumns(bindingRCL);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Decrement (query block) level (0-based) for 
0: 	 * all of the tables in this from list.
0: 	 * This is useful when flattening a subquery.
0: 	 *
0: 	 * @param decrement	The amount to decrement by.
0: 	 *
0: 	 * @return Nothing;
0: 	 */
0: 	void decrementLevel(int decrement)
0: 	{
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			FromTable fromTable = (FromTable) elementAt(index);
0: 			fromTable.decrementLevel(decrement);
0: 
0: 			/* Decrement the level of any CRs in single table
0: 			 * predicates that are interesting to transitive
0: 			 * closure.
0: 			 */
0: 			ProjectRestrictNode prn = (ProjectRestrictNode) fromTable;
0: 			PredicateList pl = prn.getRestrictionList();
0: 			if (pl != null)
0: 			{
0: 				pl.decrementLevel(this, decrement);
0: 			}
0: 		}
0: 	}
0: 
0: 	
0: 	/**
0: 	 * This method is used for both subquery flattening and distinct
0: 	 * elimination based on a uniqueness condition.  For subquery
0: 	 * flattening we want to make sure that the query block
0: 	 * will return at most 1 row.  For distinct elimination we
0: 	 * want to make sure that the query block will not return
0: 	 * any duplicates.
0: 	 * This is true if every table in the from list is
0: 	 * (a base table and the set of columns from the table that
0: 	 * are in equality comparisons with expressions that do not include columns 
0: 	 * from the same table is a superset of any unique index
0: 	 * on the table) or an EXISTS FBT.  In addition, at least 1 of the tables
0: 	 * in the list has a set of columns in equality comparisons with expressions
0: 	 * that do not include column references from the same query block
0: 	 * is a superset of a unique index
0: 	 * on that table.  (This ensures that the query block will onlyr
0: 	 * return a single row.)
0: 	 * This method is expected to be called after normalization and
0: 	 * after the from list has been preprocessed.
0: 	 * It can be called both before and after the predicates have
0: 	 * been pulled from the where clause.
0: 	 * The algorithm for this is as follows
0: 	 *
0: 	 *	If any table in the query block is not a base table, give up.
0: 	 * 	For each table in the query
0: 	 *		Ignore exists table since they can only produce one row
0: 	 *
0: 	 *		create a matrix of tables and columns from the table (tableColMap)
0: 	 *		(this is used to keep track of the join columns and constants
0: 	 *		that can be used to figure out whether the rows from a join
0: 	 *		or in a select list are distinct based on unique indexes)
0: 	 *
0: 	 *		create an array of columns from the table(eqOuterCol)
0: 	 *		(this is used to determine that only one row will be returned
0: 	 *		from a join)
0: 	 *			
0: 	 *		if the current table is the table for the result columns
0: 	 *			set the result columns in the eqOuterCol and tableColMap
0: 	 *			(if these columns are a superset of a unique index and
0: 	 *			all joining tables result in only one row, the
0: 	 *			results will be distinct)
0: 	 *		go through all the predicates and update tableColMap  and
0: 	 *		eqOuterCol with join columns and correlation variables, 
0: 	 *		parameters and constants
0: 	 *		since setting constants, correlation variables and parameters,
0: 	 * 		reduces the number of columns required for uniqueness in a 
0: 	 *		multi-column index, they are set for all the tables (if the
0: 	 *		table is not the result table, in this case only the column of the
0:      *		result table is set)
0: 	 *		join columns are just updated for the column in the row of the
0: 	 *		joining table.
0: 	 *		
0: 	 *		check if the marked columns in tableColMap are a superset of a unique 
0: 	 *			index		
0: 	 *			(This means that the join will only produce 1 row when joined
0: 	 *			with 1 row of another table)
0: 	 *		check that there is a least one table for which the columns in 
0: 	 *			eqOuterCol(i.e. constant values) are a superset of a unique index
0: 	 *			(This quarantees that there will be only one row selected
0: 	 *			from this table).
0: 	 *
0: 	 *	Once all tables have been evaluated, check that all the tables can be
0: 	 * 	joined by unique index or will have only one row
0: 	 *
0: 	 *	
0: 	 *
0: 	 * @param rcl				If non-null, the RCL from the query block.
0: 	 *							If non-null for subqueries, then entry can
0: 	 *							be considered as part of an = comparison.
0: 	 * @param whereClause		The WHERE clause to consider.
0: 	 * @param wherePredicates	The predicates that have already been
0: 	 *							pulled from the WHERE clause.
0: 	 * @param dd				The DataDictionary to use.
0: 	 *
0: 	 * @return	Whether or not query block will return
0: 	 *			at most 1 row for a subquery, no duplicates
0: 	 *			for a distinct.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	boolean returnsAtMostSingleRow(ResultColumnList rcl, 
0: 								   ValueNode whereClause, 
0: 								   PredicateList wherePredicates,
0: 								   DataDictionary dd)
0: 		throws StandardException
0: 	{
0: 		boolean			satisfiesOuter = false;
0: 		int[]			tableNumbers;
0: 		ColumnReference	additionalCR = null;
0: 
0: 		/* When considering subquery flattening, we are interested
0: 		 * in the 1st (and only) entry in the RCL.  (The RCL will be
0: 		 * null if result column is not of interest for subquery flattening.)
0: 		 * We are interested in all entries in the RCL for distinct
0: 		 * elimination.
0: 		 */
0: 		if (rcl != null)
0: 		{
0: 			ResultColumn rc = (ResultColumn) rcl.elementAt(0);
0: 			if (rc.getExpression() instanceof ColumnReference)
0: 			{
0: 				additionalCR = (ColumnReference) rc.getExpression();
0: 			}
0: 		}
0: 
0: 		/* First see if all entries are FromBaseTables.  No point
0: 		 * in continuing if not.
0: 		 */
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			FromTable fromTable = (FromTable) elementAt(index);
0: 			if (! (fromTable instanceof ProjectRestrictNode))
0: 			{
0: 				return false;
0: 			}
0: 
0: 			ProjectRestrictNode prn = (ProjectRestrictNode) fromTable;
0: 
0: 			if (! (prn.getChildResult() instanceof FromBaseTable))
0: 			{
0: 				return false;
0: 			}
0: 		}
0: 
0: 		/* Build an array of tableNumbers from this query block.
0: 		 * We will use that array to find out if we have at least
0: 		 * one table with a uniqueness condition based only on
0: 		 * constants, parameters and correlation columns.
0: 		 */
0: 		tableNumbers = getTableNumbers();
0: 		JBitSet[][] tableColMap = new JBitSet[size][size];
0: 		boolean[] oneRow = new boolean[size];
0: 		boolean oneRowResult = false;
0: 
0: 		/* See if each table has a uniqueness condition */
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			ProjectRestrictNode prn = (ProjectRestrictNode) elementAt(index);
0: 			FromBaseTable fbt = (FromBaseTable) prn.getChildResult();
0: 
0: 			// Skip over EXISTS FBT since they cannot introduce duplicates
0: 			if (fbt.getExistsBaseTable())
0: 			{
0: 				oneRow[index] = true;
0: 				continue;
0: 			}
0: 
0: 			int numColumns = fbt.getTableDescriptor().getNumberOfColumns();
0: 			boolean[] eqOuterCols = new boolean[numColumns + 1];
0: 			int tableNumber = fbt.getTableNumber();
0: 			boolean resultColTable = false;
0: 			for (int i = 0; i < size; i++)
0: 				tableColMap[index][i] = new JBitSet(numColumns + 1);
0: 
0: 			if (additionalCR != null &&
0: 				additionalCR.getTableNumber() == tableNumber)
0: 			{
0: 				rcl.recordColumnReferences(eqOuterCols, tableColMap[index], index);
0: 				resultColTable = true;
0: 			}
0: 
0: 			/* Now see if there are any equality conditions
0: 			 * of interest in the where clause.
0: 			 */
0: 			if (whereClause != null)
0: 			{
0: 				whereClause.checkTopPredicatesForEqualsConditions(
0: 								tableNumber, eqOuterCols, tableNumbers,
0: 								tableColMap[index], resultColTable);
0: 			}
0: 
0: 			/* Now see if there are any equality conditions
0: 			 * of interest in the where predicates.
0: 			 */
0: 			wherePredicates.checkTopPredicatesForEqualsConditions(
0: 								tableNumber, eqOuterCols, tableNumbers,
0: 								tableColMap[index], resultColTable);
0: 
0: 			/* Now see if there are any equality conditions
0: 			 * of interest that were already pushed down to the
0: 			 * PRN above the FBT. (Single table predicates.)
0: 			 */
0: 			if (prn.getRestrictionList() != null)
0: 			{
0: 				prn.getRestrictionList().checkTopPredicatesForEqualsConditions(
0: 								tableNumber, eqOuterCols, tableNumbers,
0: 								tableColMap[index], resultColTable);
0: 			}
0: 
0: 			/* We can finally check to see if the marked columns
0: 			 * are a superset of any unique index.
0: 			 */
0: 			if (! fbt.supersetOfUniqueIndex(tableColMap[index]))
0: 			{
0: 				return false;
0: 			}
0: 			
0: 			/* Do we have at least 1 table whose equality condition
0: 			 * is based solely on constants, parameters and correlation columns.
0: 			 */
0: 			oneRowResult = fbt.supersetOfUniqueIndex(eqOuterCols);
0: 			if (oneRowResult)
0: 			{
0: 				oneRow[index] = true;
0: 				satisfiesOuter = true;
0: 			}
0: 		}
0: 
0: 		/* Have we met all of the criteria */
0: 		if (satisfiesOuter)
0: 		{
0: 			/* check that all the tables are joined by unique indexes 
0: 			 * or only produce 1 row
0: 			 */
0: 			boolean foundOneRow = true;
0: 			while (foundOneRow)
0: 			{
0: 				foundOneRow = false;
0: 				for (int index = 0; index < size; index++)
0: 				{
0: 					if (oneRow[index])
0: 					{
0: 						for (int i = 0; i < size; i++)
0: 						{
0: 							/* unique key join - exists tables already marked as 
0: 							 * 1 row - so don't need to look at them
0: 							 */
0: 							if (!oneRow[i] && tableColMap[i][index].get(0))	
0: 							{
0: 								oneRow[i] = true;
0: 								foundOneRow = true;
0: 							}
0: 						}
0: 					}
0: 				}
0: 			}
0: 			/* does any table produce more than one row */
0: 			for (int index = 0; index < size; index++)
0: 			{
0: 				if (!oneRow[index])
0: 				{
0: 					satisfiesOuter = false;
0: 					break;
0: 				}
0: 			}
0: 		}
0: 		return satisfiesOuter;
0: 	}
0: 
0: 	int[] getTableNumbers()
0: 	{
0: 		int size = size();
0: 		int[] tableNumbers = new int[size];
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			ProjectRestrictNode prn = (ProjectRestrictNode) elementAt(index);
0: 			if (! (prn.getChildResult() instanceof FromTable))
0: 			{
0: 				continue;
0: 			}
0: 			FromTable ft = (FromTable) prn.getChildResult();
0: 			tableNumbers[index] = ft.getTableNumber();
0: 		}
0: 
0: 		return tableNumbers;
0: 	}
0: 
0: 	/**
0: 	 * Mark all of the FromBaseTables in the list as EXISTS FBTs.
0: 	 * Each EBT has the same dependency list - those tables that are referenced
0: 	 * minus the tables in the from list.
0: 	 *
0: 	 * @param referencedTableMap	The referenced table map.
0: 	 * @param outerFromList			FromList from outer query block
0: 	 * @param isNotExists			Whether or not for NOT EXISTS
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void genExistsBaseTables(JBitSet referencedTableMap, FromList outerFromList,
0: 							 boolean isNotExists)
0: 		throws StandardException
0: 	{
0: 		JBitSet			dependencyMap = (JBitSet) referencedTableMap.clone();
0: 
0: 		// We currently only flatten single table from lists
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (size() != 1)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"size() expected to be 1, not " + size());
0: 			}
0: 		}
0: 
0: 		/* Create the dependency map */
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			ResultSetNode ft = ((ProjectRestrictNode) elementAt(index)).getChildResult();
0: 			if (ft instanceof FromTable)
0: 			{
0: 				dependencyMap.clear(((FromTable) ft).getTableNumber());
0: 			}
0: 		}
0: 
0: 		/* Degenerate case - If flattening a non-correlated EXISTS subquery
0: 		 * then we need to make the table that is getting flattened dependendent on
0: 		 * all of the tables in the outer query block.  Gross but true.  Otherwise
0: 		 * that table can get chosen as an outer table and introduce duplicates.
0: 		 * The reason that duplicates can be introduced is that we do special processing
0: 		 * in the join to make sure only one qualified row from the right side is
0: 		 * returned.  If the exists table is on the left, we can return all the
0: 		 * qualified rows. 
0: 		 */
0: 		if (dependencyMap.getFirstSetBit() == -1)
0: 		{
0: 			int outerSize = outerFromList.size();
0: 			for (int outer = 0; outer < outerSize; outer++)
0: 				dependencyMap.or(((FromTable) outerFromList.elementAt(outer)).getReferencedTableMap());
0: 		}
0: 
0: 		/* Do the marking */
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			FromTable fromTable = (FromTable) elementAt(index);
0: 			if (fromTable instanceof ProjectRestrictNode)
0: 			{
0: 				ProjectRestrictNode prn = (ProjectRestrictNode) fromTable;
0: 				if (prn.getChildResult() instanceof FromBaseTable)
0: 				{
0: 					FromBaseTable fbt = (FromBaseTable) prn.getChildResult();
0: 					fbt.setExistsBaseTable(true, (JBitSet) dependencyMap.clone(), isNotExists);
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the lock mode for the target of an update statement
0: 	 * (a delete or update).  The update mode will always be row for
0: 	 * CurrentOfNodes.  It will be table if there is no where clause.
0: 	 *
0: 	 * @return	The lock mode
0: 	 */
0: 	public int updateTargetLockMode()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (size() != 1)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"size() expected to be 1");
0: 			}
0: 		}
0: 		return ((ResultSetNode) elementAt(0)).updateTargetLockMode();
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not the user specified a hash join for any of the 
0: 	 * tables in this list.
0: 	 *
0: 	 * @return	Whether or not the user specified a hash join for any of the 
0: 	 *			tables in this list.
0: 	 */
0: 	boolean hashJoinSpecified()
0: 	{
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			FromTable ft = (FromTable) elementAt(index);
0: 			String joinStrategy = ft.getUserSpecifiedJoinStrategy();
0: 
0: 			if (joinStrategy != null && StringUtil.SQLToUpperCase(joinStrategy).equals("HASH"))
0: 			{
0: 				return true;
0: 			}
0: 		}
0: 
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			FromTable fromTable = (FromTable) elementAt(index);
0: 			setElementAt((QueryTreeNode) fromTable.accept(v), index);
0: 		}
0: 
0: 		return this;
0: 	}
0: }
============================================================================