1:eac0369: /*
1:ccc1b8d: 
1:345de35:    Derby - Class org.apache.derby.impl.load.Import
1:345de35: 
1:6d913c6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6d913c6:    contributor license agreements.  See the NOTICE file distributed with
1:6d913c6:    this work for additional information regarding copyright ownership.
1:6d913c6:    The ASF licenses this file to You under the Apache License, Version 2.0
1:6d913c6:    (the "License"); you may not use this file except in compliance with
1:6d913c6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
4:eac0369:  */
47:eac0369: 
1:eac0369: package org.apache.derby.impl.load;
1:eac0369: 
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.Statement;
1:eac0369: import java.sql.PreparedStatement;
1:eac0369: import java.sql.Connection;
1:eac0369: import java.util.*;
1:eac0369: 
1:97fdc36: import org.apache.derby.iapi.reference.SQLState;
1:97fdc36: import org.apache.derby.iapi.error.StandardException;
1:97fdc36: import org.apache.derby.iapi.error.PublicAPI;
1:bf32514: import org.apache.derby.iapi.security.Securable;
1:bf32514: import org.apache.derby.iapi.security.SecurityUtil;
1:ccc1b8d: import org.apache.derby.iapi.util.IdUtil;
1:ccc1b8d: import org.apache.derby.iapi.util.StringUtil;
1:97fdc36: 
2:eac0369: /**
1:eac0369:  * This class implements import of data from a URL into a table.
1:eac0369:  * Import functions provided here in this class shouble be called through
1:eac0369:  * Systement Procedures. Import uses VTI , which is supprted only through 
1:eac0369:  * Systemem procedures mechanism. 
1:eac0369:  */
1:eac0369: 
1:eac0369: public class Import extends ImportAbstract{
1:eac0369: 
1:97fdc36:     private static  int                _importCounter;
1:459e1d0: 
1:459e1d0:     //
1:459e1d0:     // This hashtable stores Import instances, which keep the context needed
1:459e1d0:     // to correlate Derby errors with line numbers in the file that is being
1:459e1d0:     // imported. An importing thread will access this hashtable at the very
1:459e1d0:     // beginning and the very end of its run. We cannot use Hashmap
1:459e1d0:     // because different threads may simultaneously put and delete entries.
1:459e1d0:     //
1:400f6eb:     private static  Hashtable<Integer,Import>   _importers = new Hashtable<Integer,Import>();
1:97fdc36: 
1:97fdc36:     private String inputFileName;
1:ea2e939:     private static short skip; //The number of header lines to be skipped
1:eac0369: 	/**
1:0c5bc3a:      * Constructor to Invoke Import from a select statement
1:eac0369: 	 * @param inputFileName	 The URL of the ASCII file from which import will happen
1:f668d94:      * @exception SQLException on error
1:eac0369: 	 */
1:eac0369: 	public Import(String inputFileName, String columnDelimiter,
1:84e347a:                   String characterDelimiter,  String codeset, 
1:84e347a:                   int noOfColumnsExpected,  String columnTypes, 
1:97fdc36:                   boolean lobsInExtFile,
1:2732872:                   int importCounter,
1:2732872:                   String columnTypeNames, String udtClassNamesString ) throws SQLException 
2:eac0369: 	{
1:eac0369: 		try{
1:eac0369: 			this.inputFileName = inputFileName;
1:84e347a:             this.noOfColumnsExpected = noOfColumnsExpected;
1:84e347a:             this.tableColumnTypesStr = columnTypes;
1:2732872:             this.columnTypeNamesString = columnTypeNames;
1:2732872:             this.udtClassNamesString = udtClassNamesString;
1:eac0369: 			controlFileReader = new ControlInfo();
1:eac0369: 			controlFileReader.setControlProperties(characterDelimiter,
1:eac0369: 												   columnDelimiter, codeset);
1:84e347a:             this.lobsInExtFile = lobsInExtFile;
1:97fdc36: 
1:ce40a31:             _importers.put( importCounter, this );
1:84e347a:             
1:eac0369: 			doImport();
1:eac0369: 
1:eac0369: 		}catch(Exception e)
1:eac0369: 		{
1:c0a8467: 			throw importError(e);
2:eac0369: 		}
1:eac0369: 	}
1:ccc1b8d: 
1:eac0369: 
1:eac0369: 	private void doImport() throws Exception
1:eac0369: 	{
1:eac0369: 		if (inputFileName == null)
1:eac0369: 			throw LoadError.dataFileNull();
1:eac0369: 		doAllTheWork();
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * SYSCS_IMPORT_TABLE  system Procedure from ij or from a Java application
1:eac0369: 	 * invokes  this method to perform import to a table from a file.
1:ea2e939: 	 *
1:ea2e939: 	 * The extraArgs parameter is variadic, and is used when this method is
1:ea2e939: 	 * called from SYSCS_IMPORT_TABLE_BULK, in which case extraArgs[0]
1:ea2e939: 	 * specifies the number of header lines to skip.
1:ea2e939: 	 *
1:94f158a: 	 * @param connection	 The Derby database connection URL for the database containing the table
1:eac0369: 	 * @param schemaName	The name of the schema where table to import exists 
1:eac0369: 	 * @param tableName     Name of the Table the data has to be imported to.
1:eac0369: 	 * @param inputFileName Name of the file from which data has to be imported.
1:6b50965: 	 * @param columnDelimiter  Delimiter that seperates columns in the file
1:eac0369: 	 * @param characterDelimiter  Delimiter that is used to quiote non-numeric types
1:eac0369: 	 * @param codeset           Codeset of the data in the file
1:eac0369: 	 * @param replace          Indicates whether the data in table has to be replaced or
1:dbed020: 	 *                         appended.(0 - append , &gt; 0 Replace the data)
1:84e347a:      * @param lobsInExtFile true, if the lobs data is stored in an external file,
1:84e347a:      *                      and the reference to it is stored in the main import file.
1:f668d94:      * @exception SQLException on errors
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public static void importTable(Connection connection, String schemaName, 
1:84e347a:                                    String tableName, String inputFileName,  
1:84e347a:                                    String columnDelimiter, 
1:84e347a:                                    String characterDelimiter,String codeset, 
1:ea2e939:                                    short replace, boolean lobsInExtFile, short... extraArgs)
1:eac0369: 		throws SQLException {
1:eac0369: 
1:eac0369: 
1:bf32514:         /** Make sure that the current user has permission to perform this operation */
1:bf32514:         try {
1:bf32514:             if ( lobsInExtFile )
1:bf32514:             {
1:bf32514:                 SecurityUtil.authorize( Securable.IMPORT_TABLE_LOBS_FROM_EXTFILE );
1:bf32514:             }
1:bf32514:             else
1:bf32514:             {
1:bf32514:                 SecurityUtil.authorize( Securable.IMPORT_TABLE );
1:bf32514:             }
1:bf32514:         }
1:bf32514:         catch (StandardException se) { throw PublicAPI.wrapStandardException( se ); }
1:bb55cc3:         if(extraArgs.length>0){
1:bb55cc3:              skip=extraArgs[0];
1:bb55cc3: 	     if(skip<0) throw PublicAPI.wrapStandardException(StandardException.newException
1:bb55cc3: 				(SQLState.LANG_INVALID_NUMBEROF_HEADER_LINES)); 
1:bf32514: 	     
1:bb55cc3: 	}
1:08cc0f8:         else 
1:08cc0f8:             skip=0;
1:bb55cc3: 
1:eac0369: 		performImport(connection,  schemaName,  null, //No columnList 
1:eac0369: 					  null , //No column indexes
1:eac0369: 					  tableName, inputFileName, columnDelimiter, 
1:84e347a: 					  characterDelimiter, codeset, replace, lobsInExtFile);
1:bb55cc3: 	}
1:bb55cc3: 
1:ea2e939: 
1:eac0369: 
1:eac0369: 		
1:eac0369: 	/**
1:eac0369: 	 * SYSCS_IMPORT_DATA  system Procedure from ij or from a Java application
1:eac0369: 	 * invokes  this method to perform import to a table from a file.
1:94f158a: 	 * @param connection	 The Derby database connection URL for the database containing the table
1:eac0369: 	 * @param schemaName	The name of the schema where table to import exists 
1:eac0369: 	 * @param tableName     Name of the Table the data has to be imported to.
1:eac0369: 	 * @param insertColumnList  Comma Seperated column name list to which data
1:eac0369: 	 *                          has to be imported from file.eg: 'c2,c2,'c3'.
1:eac0369: 	 * @param columnIndexes     Comma sepearted Lit Index of the columns in the file(first column
1:eac0369: 	                             starts at 1). eg: '3 ,4 , 5'
1:eac0369: 	 * @param inputFileName Name of the file from which data has to be imported.
1:6b50965: 	 * @param columnDelimiter  Delimiter that seperates columns in the file
1:eac0369: 	 * @param characterDelimiter  Delimiter that is used to quiote non-numeric types
1:eac0369: 	 * @param codeset           Codeset of the data in the file
1:eac0369: 	 * @param replace          Indicates whether the data in table has to be replaced or
1:dbed020: 	 *                         appended.(0 - append , &gt; 0 Replace the data)
1:84e347a:      * @param lobsInExtFile true, if the lobs data is stored in an external file,
1:84e347a:      *                      and the reference is stored in the main import file.
1:f668d94:      * @exception SQLException on errors
1:eac0369: 	 */
1:eac0369: 	public static void importData(Connection connection, String schemaName,
1:84e347a:                                   String tableName, String insertColumnList, 
1:84e347a:                                   String columnIndexes, String inputFileName, 
1:84e347a:                                   String columnDelimiter, 
1:84e347a:                                   String characterDelimiter,
1:84e347a:                                   String codeset, short replace, 
1:08cc0f8:                                   boolean lobsInExtFile, short... extraArgs)
2:eac0369: 		throws SQLException 
1:bf32514: 	{
1:bf32514:         /** Make sure that the current user has permission to perform this operation */
1:bf32514:         try {
1:bf32514:             if ( lobsInExtFile )
1:eac0369:             {
1:bf32514:                 SecurityUtil.authorize( Securable.IMPORT_DATA_LOBS_FROM_EXTFILE );
1:bf32514:             }
1:bf32514:             else
1:bf32514:             {
1:bf32514:                 SecurityUtil.authorize( Securable.IMPORT_DATA );
1:bf32514:             }
1:bf32514:         }
1:bf32514:         catch (StandardException se) { throw PublicAPI.wrapStandardException( se ); }
1:bb55cc3: 	if(extraArgs.length>0){
1:bb55cc3: 	    skip=extraArgs[0];
1:bb55cc3: 	    if(skip<0) throw PublicAPI.wrapStandardException(StandardException.newException
1:bb55cc3: 				(SQLState.LANG_INVALID_NUMBEROF_HEADER_LINES)); 
1:97fdc36:             
1:eac0369: 	}
1:ea2e939:         else 
1:ea2e939:             skip=0;
1:eac0369: 			performImport(connection,  schemaName,  insertColumnList,columnIndexes, 
1:eac0369: 						  tableName, inputFileName, columnDelimiter, 
1:84e347a: 						  characterDelimiter, codeset, replace, lobsInExtFile);
1:eac0369: 	}
1:97fdc36: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * This function creates and executes  SQL Insert statement that performs the 
1:eac0369: 	 * the import using VTI. 
1:eac0369: 	 * eg:
1:eac0369: 	 * insert into T1 select  (cast column1 as DECIMAL), (cast column2 as
1:eac0369: 	 * INTEGER)  from new org.apache.derby.impl.load.Import('extin/Tutor1.asc') as importvti;
1:eac0369: 	 *
1:97fdc36: 	 */
1:97fdc36:     private static void performImport
1:97fdc36:         (Connection connection, 
1:97fdc36:          String schemaName, 
1:97fdc36:          String insertColumnList, 
1:97fdc36:          String columnIndexes,
1:97fdc36:          String tableName, 
1:97fdc36:          String inputFileName,  
1:97fdc36:          String  columnDelimiter, 
1:97fdc36:          String characterDelimiter, 
1:97fdc36:          String codeset, 
1:97fdc36:          short replace, 
1:97fdc36:          boolean lobsInExtFile)
1:84e347a:         throws SQLException 
1:97fdc36:     {
1:ce40a31:         Integer     importCounter = bumpImportCounter();
1:97fdc36:         
1:97fdc36:         try {
1:97fdc36:             if (connection == null)
1:97fdc36:                 throw LoadError.connectionNull();
1:97fdc36:             
1:97fdc36:             
1:97fdc36:             
1:97fdc36:             if (tableName == null)
1:97fdc36:                 throw LoadError.entityNameMissing();
1:97fdc36:             
1:97fdc36:             
1:97fdc36:             ColumnInfo columnInfo = new ColumnInfo(connection , schemaName ,
1:97fdc36:                                                    tableName, insertColumnList, 
1:bb55cc3:                                                    columnIndexes, COLUMNNAMEPREFIX,readHeaders(inputFileName ,
1:bb55cc3: 												characterDelimiter,
1:bb55cc3: 												columnDelimiter,
1:bb55cc3: 												codeset));
1:97fdc36: 
1:2732872:             String columnTypeNames = null;
1:2732872:             String udtClassNames = null;
1:2732872:             try {
1:2732872:                 columnTypeNames = columnInfo.getColumnTypeNames();
1:2732872:                 udtClassNames = columnInfo.getUDTClassNames();
1:2732872:             }
1:2732872:             catch (Throwable t)
1:2732872:             {
1:2732872:                 throw formatImportError( (Import) _importers.get( importCounter ), inputFileName, t );
1:2732872:             }
1:2732872: 
1:97fdc36:             StringBuffer sb = new StringBuffer("new ");
1:97fdc36:             sb.append("org.apache.derby.impl.load.Import");
1:97fdc36:             sb.append("(") ;
1:ccc1b8d:             sb.append(quoteStringArgument(inputFileName));
1:97fdc36:             sb.append(",") ;
1:ccc1b8d:             sb.append(quoteStringArgument(columnDelimiter));
1:97fdc36:             sb.append(",") ;
1:ccc1b8d:             sb.append(quoteStringArgument(characterDelimiter));
1:97fdc36:             sb.append(",") ;
1:ccc1b8d:             sb.append(quoteStringArgument(codeset));
1:97fdc36:             sb.append(", ");
1:97fdc36:             sb.append( columnInfo.getExpectedNumberOfColumnsInFile());
1:97fdc36:             sb.append(", ");
1:ccc1b8d:             sb.append(quoteStringArgument(
1:ccc1b8d:                     columnInfo.getExpectedVtiColumnTypesAsString()));
1:97fdc36:             sb.append(", ");
1:97fdc36:             sb.append(lobsInExtFile);
1:97fdc36:             sb.append(", ");
1:97fdc36:             sb.append( importCounter.intValue() );
1:2732872:             sb.append(", ");
1:2732872:             sb.append(quoteStringArgument( columnTypeNames ) );
1:2732872:             sb.append(", ");
1:2732872:             sb.append(quoteStringArgument( udtClassNames ) );
1:97fdc36:             sb.append(" )") ;
1:97fdc36:             
1:97fdc36:             String importvti = sb.toString();
1:97fdc36:             
1:97fdc36:             // delimit the table and schema names with quotes.
1:97fdc36:             // because they might have been  created as quoted
1:97fdc36:             // identifiers(for example when reserved words are used, names are quoted)
1:97fdc36:             
1:97fdc36:             // Import procedures are to be called with case-senisitive names. 
1:97fdc36:             // Incase of delimited table names, they need to be passed as defined
1:97fdc36:             // and when they are not delimited, they need to be passed in upper
1:97fdc36:             // case, because all undelimited names are stored in the upper case 
1:97fdc36:             // in the database. 
1:97fdc36:             
1:ccc1b8d:             String entityName = IdUtil.mkQualifiedName(schemaName, tableName);
1:97fdc36:             
1:97fdc36:             String insertModeValue;
1:97fdc36:             if(replace > 0)
1:97fdc36:                 insertModeValue = "replace";
1:97fdc36:             else
1:97fdc36:                 insertModeValue = "bulkInsert";
1:97fdc36:             
1:97fdc36:             String cNamesWithCasts = columnInfo.getColumnNamesWithCasts();
1:97fdc36:             String insertColumnNames = columnInfo.getInsertColumnNames();
1:97fdc36:             if(insertColumnNames !=null)
1:97fdc36:                 insertColumnNames = "(" + insertColumnNames + ") " ;
1:97fdc36:             else
1:97fdc36:                 insertColumnNames = "";
1:97fdc36:             String insertSql = "INSERT INTO " + entityName +  insertColumnNames + 
1:97fdc36:                 " --DERBY-PROPERTIES insertMode=" + insertModeValue + "\n" +
1:97fdc36:                 " SELECT " + cNamesWithCasts + " from " + 
1:97fdc36:                 importvti + " AS importvti" ;
1:97fdc36:             
1:97fdc36:             //prepare the import statement to hit any errors before locking the table
1:97fdc36:             PreparedStatement ips = connection.prepareStatement(insertSql);
1:97fdc36:             
1:97fdc36:             //lock the table before perfoming import, because there may 
1:97fdc36:             //huge number of lockes aquired that might have affect on performance 
1:97fdc36:             //and some possible dead lock scenarios.
1:97fdc36:             Statement statement = connection.createStatement();
1:97fdc36:             String lockSql = "LOCK TABLE " + entityName + " IN EXCLUSIVE MODE";
1:97fdc36:             statement.executeUpdate(lockSql);
1:97fdc36:             
1:97fdc36:             //execute the import operaton.
1:97fdc36:             try {
1:97fdc36:                 ips.executeUpdate();
1:97fdc36:             }
1:97fdc36:             catch (Throwable t)
1:97fdc36:             {
1:97fdc36:                 throw formatImportError( (Import) _importers.get( importCounter ), inputFileName, t );
1:97fdc36:             }
1:97fdc36:             statement.close();
1:97fdc36:             ips.close();
1:97fdc36:         }
1:97fdc36:         finally
1:97fdc36:         {
1:97fdc36:             //
1:97fdc36:             // The importer was put into a hashtable so that we could look up
1:97fdc36:             // line numbers for error messages. The Import constructor put
1:97fdc36:             // the importer in the hashtable. Now garbage collect that entry.
1:97fdc36:             //
1:97fdc36:             _importers.remove( importCounter );
1:97fdc36:         }
1:97fdc36:     }
1:bb55cc3:     
1:bb55cc3:     //Read the header lines to get column names to identify columns by name
1:bb55cc3:     private static String[] readHeaders(String inputFileName ,String characterDelimiter,String columnDelimiter,String codeset) 
1:bb55cc3: 	throws SQLException
1:bb55cc3: 	{
1:bb55cc3: 	try {
1:bb55cc3: 	    if(skip>0){
1:bb55cc3:                 ControlInfo controlFR = new ControlInfo();
1:bb55cc3: 		controlFR.setControlProperties(characterDelimiter,columnDelimiter, codeset);
1:bb55cc3: 
1:bb55cc3: 		ImportReadData importReadData = new ImportReadData(inputFileName, controlFR, (short)0);
1:bb55cc3: 			
1:bb55cc3: 		String[] fullColumnName = new String[importReadData.numberOfColumns];
1:bb55cc3: 		String[] temp = new String[importReadData.numberOfColumns];
1:bb55cc3: 		for(int i=0; i< skip;i++){
1:bb55cc3:                     importReadData.readNextRow(temp);
1:bb55cc3: 		        for(int j=0;j < importReadData.numberOfColumns;j++){
1:bb55cc3: 			    if(i==0)
1:bb55cc3: 			        fullColumnName[j]=temp[j];	
1:bb55cc3: 			    else
1:bb55cc3: 			    {
1:bb55cc3: 				if(temp[j]!=null)
1:bb55cc3: 				    fullColumnName[j]=fullColumnName[j] + " " + temp[j];
1:bb55cc3: 				
1:bb55cc3: 			    }
1:bb55cc3: 			}
1:bb55cc3: 		}
1:bb55cc3: 		return fullColumnName;
1:bb55cc3: 	    }
1:bb55cc3: 	    return null;
1:bb55cc3: 			
1:bb55cc3: 	}
1:bb55cc3: 	catch(Exception e){
1:bb55cc3: 	
1:bb55cc3: 	throw LoadError.unexpectedError(e);
1:bb55cc3: 	}
1:bb55cc3:     }
1:eac0369: 
1:eac0369: 	/** virtual method from the abstract class
1:eac0369: 	 * @exception	Exception on error
1:eac0369: 	 */
1:7a92d1f: 	ImportReadData getImportReadData() throws Exception {
1:ea2e939: 		return new ImportReadData(inputFileName, controlFileReader, skip);
1:eac0369: 	}
1:97fdc36: 
1:97fdc36:     /*
1:97fdc36:      * Bump the import counter.
1:97fdc36:      *
1:97fdc36:      */
1:97fdc36:     private static  synchronized    int bumpImportCounter()
1:97fdc36:     {
1:97fdc36:         return ++_importCounter;
1:97fdc36:     }
1:97fdc36:     
1:97fdc36:     /*
1:97fdc36:      * Format a import error with line number
1:97fdc36:      *
1:97fdc36:      */
1:97fdc36:     private static  SQLException    formatImportError( Import importer, String inputFile, Throwable t )
1:97fdc36:     {
1:97fdc36:         int     lineNumber = -1;
1:97fdc36: 
1:97fdc36:         if ( importer != null ) { lineNumber = importer.getCurrentLineNumber(); }
1:97fdc36:         
1:97fdc36:         StandardException se = StandardException.newException
1:ce40a31:             ( SQLState.UNEXPECTED_IMPORT_ERROR, lineNumber, inputFile, t.getMessage() );
1:e70c716:         se.initCause(t);
1:97fdc36: 
1:97fdc36:         return PublicAPI.wrapStandardException(se);
1:97fdc36:     }
1:97fdc36: 
1:ccc1b8d:     /**
1:ccc1b8d:      * Quote a string argument so that it can be used as a literal in an
1:ccc1b8d:      * SQL statement. If the string argument is {@code null} an SQL NULL token
1:ccc1b8d:      * is returned.
1:ccc1b8d:      *
1:ccc1b8d:      * @param string a string or {@code null}
1:ccc1b8d:      * @return the string in quotes and with proper escape sequences for
1:ccc1b8d:      * special characters, or "NULL" if the string is {@code null}
1:ccc1b8d:      */
1:ccc1b8d:     private static String quoteStringArgument(String string) {
1:ccc1b8d:         if (string == null) {
1:ccc1b8d:             return "NULL";
1:ccc1b8d:         }
1:ccc1b8d:         return StringUtil.quoteStringLiteral(string);
1:ccc1b8d:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 *                         appended.(0 - append , &gt; 0 Replace the data)
/////////////////////////////////////////////////////////////////////////
1: 	 *                         appended.(0 - append , &gt; 0 Replace the data)
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:             _importers.put( importCounter, this );
/////////////////////////////////////////////////////////////////////////
1:         Integer     importCounter = bumpImportCounter();
/////////////////////////////////////////////////////////////////////////
1:             ( SQLState.UNEXPECTED_IMPORT_ERROR, lineNumber, inputFile, t.getMessage() );
commit:bf32514
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.security.Securable;
1: import org.apache.derby.iapi.security.SecurityUtil;
/////////////////////////////////////////////////////////////////////////
1:         /** Make sure that the current user has permission to perform this operation */
1:         try {
1:             if ( lobsInExtFile )
1:             {
1:                 SecurityUtil.authorize( Securable.IMPORT_TABLE_LOBS_FROM_EXTFILE );
1:             }
1:             else
1:             {
1:                 SecurityUtil.authorize( Securable.IMPORT_TABLE );
1:             }
1:         }
1:         catch (StandardException se) { throw PublicAPI.wrapStandardException( se ); }
1: 		
/////////////////////////////////////////////////////////////////////////
1:         /** Make sure that the current user has permission to perform this operation */
1:         try {
1:             if ( lobsInExtFile )
1:             {
1:                 SecurityUtil.authorize( Securable.IMPORT_DATA_LOBS_FROM_EXTFILE );
1:             }
1:             else
1:             {
1:                 SecurityUtil.authorize( Securable.IMPORT_DATA );
1:             }
1:         }
1:         catch (StandardException se) { throw PublicAPI.wrapStandardException( se ); }
commit:400f6eb
/////////////////////////////////////////////////////////////////////////
1:     private static  Hashtable<Integer,Import>   _importers = new Hashtable<Integer,Import>();
commit:2732872
/////////////////////////////////////////////////////////////////////////
1:                   int importCounter,
1:                   String columnTypeNames, String udtClassNamesString ) throws SQLException 
1:             this.columnTypeNamesString = columnTypeNames;
1:             this.udtClassNamesString = udtClassNamesString;
/////////////////////////////////////////////////////////////////////////
1:             String columnTypeNames = null;
1:             String udtClassNames = null;
1:             try {
1:                 columnTypeNames = columnInfo.getColumnTypeNames();
1:                 udtClassNames = columnInfo.getUDTClassNames();
1:             }
1:             catch (Throwable t)
1:             {
1:                 throw formatImportError( (Import) _importers.get( importCounter ), inputFileName, t );
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:             sb.append(", ");
1:             sb.append(quoteStringArgument( columnTypeNames ) );
1:             sb.append(", ");
1:             sb.append(quoteStringArgument( udtClassNames ) );
commit:459e1d0
/////////////////////////////////////////////////////////////////////////
1: 
1:     //
1:     // This hashtable stores Import instances, which keep the context needed
1:     // to correlate Derby errors with line numbers in the file that is being
1:     // imported. An importing thread will access this hashtable at the very
1:     // beginning and the very end of its run. We cannot use Hashmap
1:     // because different threads may simultaneously put and delete entries.
1:     //
commit:97fdc36
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.error.PublicAPI;
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static  int                _importCounter;
0:     private static  Hashtable   _importers = new Hashtable();
1: 
1:     private String inputFileName;
/////////////////////////////////////////////////////////////////////////
1:                   boolean lobsInExtFile,
0:                   int importCounter ) throws SQLException 
/////////////////////////////////////////////////////////////////////////
0:             _importers.put( new Integer( importCounter ), this );
1:             
/////////////////////////////////////////////////////////////////////////
1:     private static void performImport
1:         (Connection connection, 
1:          String schemaName, 
1:          String insertColumnList, 
1:          String columnIndexes,
1:          String tableName, 
1:          String inputFileName,  
1:          String  columnDelimiter, 
1:          String characterDelimiter, 
1:          String codeset, 
1:          short replace, 
1:          boolean lobsInExtFile)
1:     {
0:         Integer     importCounter = new Integer( bumpImportCounter() );
1:         
1:         try {
1:             if (connection == null)
1:                 throw LoadError.connectionNull();
1:             
1:             
1:             
1:             if (tableName == null)
1:                 throw LoadError.entityNameMissing();
1:             
1:             
1:             ColumnInfo columnInfo = new ColumnInfo(connection , schemaName ,
1:                                                    tableName, insertColumnList, 
0:                                                    columnIndexes, COLUMNNAMEPREFIX);
1:             
0:             /* special handling of single quote delimiters
0:              * Single quote should be writeen with an extra quote otherwise sql will
0:              * throw syntac error.
0:              * i.e  to recognize a quote  it has to be appended with extra  quote ('')
1:              */
0:             if(characterDelimiter!=null && characterDelimiter.equals("'"))
0:                 characterDelimiter = "''";
0:             if(columnDelimiter !=null && columnDelimiter.equals("'"))
0:                 columnDelimiter = "''";
1:             
1:             
1:             StringBuffer sb = new StringBuffer("new ");
1:             sb.append("org.apache.derby.impl.load.Import");
1:             sb.append("(") ; 
0:             sb.append(	(inputFileName !=null ? "'" + inputFileName + "'" : null));
1:             sb.append(",") ;
0:             sb.append(	(columnDelimiter !=null ? "'" + columnDelimiter + "'" : null));
1:             sb.append(",") ;
0:             sb.append(	(characterDelimiter !=null ? "'" + characterDelimiter + "'" : null));
1:             sb.append(",") ;
0:             sb.append(	(codeset !=null ? "'" + codeset + "'" : null));
1:             sb.append(", ");
1:             sb.append( columnInfo.getExpectedNumberOfColumnsInFile());
1:             sb.append(", ");
0:             sb.append( "'" + columnInfo.getExpectedVtiColumnTypesAsString() + "'");
1:             sb.append(", ");
1:             sb.append(lobsInExtFile);
1:             sb.append(", ");
1:             sb.append( importCounter.intValue() );
1:             sb.append(" )") ;
1:             
1:             String importvti = sb.toString();
1:             
1:             // delimit the table and schema names with quotes.
1:             // because they might have been  created as quoted
1:             // identifiers(for example when reserved words are used, names are quoted)
1:             
1:             // Import procedures are to be called with case-senisitive names. 
1:             // Incase of delimited table names, they need to be passed as defined
1:             // and when they are not delimited, they need to be passed in upper
1:             // case, because all undelimited names are stored in the upper case 
1:             // in the database. 
1:             
0:             String entityName = (schemaName == null ? "\""+ tableName + "\"" : 
0:                                  "\"" + schemaName + "\"" + "." + "\"" + tableName + "\""); 
1:             
1:             String insertModeValue;
1:             if(replace > 0)
1:                 insertModeValue = "replace";
1:             else
1:                 insertModeValue = "bulkInsert";
1:             
1:             String cNamesWithCasts = columnInfo.getColumnNamesWithCasts();
1:             String insertColumnNames = columnInfo.getInsertColumnNames();
1:             if(insertColumnNames !=null)
1:                 insertColumnNames = "(" + insertColumnNames + ") " ;
1:             else
1:                 insertColumnNames = "";
1:             String insertSql = "INSERT INTO " + entityName +  insertColumnNames + 
1:                 " --DERBY-PROPERTIES insertMode=" + insertModeValue + "\n" +
1:                 " SELECT " + cNamesWithCasts + " from " + 
1:                 importvti + " AS importvti" ;
1:             
1:             //prepare the import statement to hit any errors before locking the table
1:             PreparedStatement ips = connection.prepareStatement(insertSql);
1:             
1:             //lock the table before perfoming import, because there may 
1:             //huge number of lockes aquired that might have affect on performance 
1:             //and some possible dead lock scenarios.
1:             Statement statement = connection.createStatement();
1:             String lockSql = "LOCK TABLE " + entityName + " IN EXCLUSIVE MODE";
1:             statement.executeUpdate(lockSql);
1:             
1:             //execute the import operaton.
1:             try {
1:                 ips.executeUpdate();
1:             }
1:             catch (Throwable t)
1:             {
1:                 throw formatImportError( (Import) _importers.get( importCounter ), inputFileName, t );
1:             }
1:             statement.close();
1:             ips.close();
1:         }
1:         finally
1:         {
1:             //
1:             // The importer was put into a hashtable so that we could look up
1:             // line numbers for error messages. The Import constructor put
1:             // the importer in the hashtable. Now garbage collect that entry.
1:             //
1:             _importers.remove( importCounter );
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1:     /*
1:      * Bump the import counter.
1:      *
1:      */
1:     private static  synchronized    int bumpImportCounter()
1:     {
1:         return ++_importCounter;
1:     }
1:     
1:     /*
1:      * Format a import error with line number
1:      *
1:      */
1:     private static  SQLException    formatImportError( Import importer, String inputFile, Throwable t )
1:     {
1:         int     lineNumber = -1;
1: 
1:         if ( importer != null ) { lineNumber = importer.getCurrentLineNumber(); }
1:         
1:         StandardException se = StandardException.newException
0:             ( SQLState.UNEXPECTED_IMPORT_ERROR, new Integer( lineNumber ), inputFile, t.getMessage() );
0:         se.setNestedException( t );
1: 
1:         return PublicAPI.wrapStandardException(se);
1:     }
1:     
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:bb55cc3
/////////////////////////////////////////////////////////////////////////
1:         if(extraArgs.length>0){
1:              skip=extraArgs[0];
1: 	     if(skip<0) throw PublicAPI.wrapStandardException(StandardException.newException
1: 				(SQLState.LANG_INVALID_NUMBEROF_HEADER_LINES)); 
1: 	     
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 	if(extraArgs.length>0){
1: 	    skip=extraArgs[0];
1: 	    if(skip<0) throw PublicAPI.wrapStandardException(StandardException.newException
1: 				(SQLState.LANG_INVALID_NUMBEROF_HEADER_LINES)); 
1:             
1: 	}
/////////////////////////////////////////////////////////////////////////
1:                                                    columnIndexes, COLUMNNAMEPREFIX,readHeaders(inputFileName ,
1: 												characterDelimiter,
1: 												columnDelimiter,
1: 												codeset));
/////////////////////////////////////////////////////////////////////////
1:     
1:     //Read the header lines to get column names to identify columns by name
1:     private static String[] readHeaders(String inputFileName ,String characterDelimiter,String columnDelimiter,String codeset) 
1: 	throws SQLException
1: 	{
1: 	try {
1: 	    if(skip>0){
1:                 ControlInfo controlFR = new ControlInfo();
1: 		controlFR.setControlProperties(characterDelimiter,columnDelimiter, codeset);
1: 
1: 		ImportReadData importReadData = new ImportReadData(inputFileName, controlFR, (short)0);
1: 			
1: 		String[] fullColumnName = new String[importReadData.numberOfColumns];
1: 		String[] temp = new String[importReadData.numberOfColumns];
1: 		for(int i=0; i< skip;i++){
1:                     importReadData.readNextRow(temp);
1: 		        for(int j=0;j < importReadData.numberOfColumns;j++){
1: 			    if(i==0)
1: 			        fullColumnName[j]=temp[j];	
1: 			    else
1: 			    {
1: 				if(temp[j]!=null)
1: 				    fullColumnName[j]=fullColumnName[j] + " " + temp[j];
1: 				
1: 			    }
1: 			}
1: 		}
1: 		return fullColumnName;
1: 	    }
1: 	    return null;
1: 			
1: 	}
1: 	catch(Exception e){
1: 	
1: 	throw LoadError.unexpectedError(e);
1: 	}
1:     }
commit:08cc0f8
/////////////////////////////////////////////////////////////////////////
1:                                   boolean lobsInExtFile, short... extraArgs)
/////////////////////////////////////////////////////////////////////////
0: 	if(extraArgs.length>0)
0:             skip=extraArgs[0];
1:         else 
1:             skip=0;
commit:ea2e939
/////////////////////////////////////////////////////////////////////////
1:     private static short skip; //The number of header lines to be skipped
/////////////////////////////////////////////////////////////////////////
1: 	 *
1: 	 * The extraArgs parameter is variadic, and is used when this method is
1: 	 * called from SYSCS_IMPORT_TABLE_BULK, in which case extraArgs[0]
1: 	 * specifies the number of header lines to skip.
1: 	 *
/////////////////////////////////////////////////////////////////////////
1:                                    short replace, boolean lobsInExtFile, short... extraArgs)
/////////////////////////////////////////////////////////////////////////
0:         if(extraArgs.length>0)
0:             skip=extraArgs[0];
1:         else 
1:             skip=0;
1: 
/////////////////////////////////////////////////////////////////////////
1: 		return new ImportReadData(inputFileName, controlFileReader, skip);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1:      * Constructor to Invoke Import from a select statement
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f668d94
/////////////////////////////////////////////////////////////////////////
1:      * @exception SQLException on error
/////////////////////////////////////////////////////////////////////////
1:      * @exception SQLException on errors
/////////////////////////////////////////////////////////////////////////
1:      * @exception SQLException on errors
commit:ccc1b8d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.IdUtil;
1: import org.apache.derby.iapi.util.StringUtil;
/////////////////////////////////////////////////////////////////////////
1: 
0:             sb.append("(") ;
1:             sb.append(quoteStringArgument(inputFileName));
1:             sb.append(quoteStringArgument(columnDelimiter));
1:             sb.append(quoteStringArgument(characterDelimiter));
1:             sb.append(quoteStringArgument(codeset));
1:             sb.append(quoteStringArgument(
1:                     columnInfo.getExpectedVtiColumnTypesAsString()));
/////////////////////////////////////////////////////////////////////////
1:             String entityName = IdUtil.mkQualifiedName(schemaName, tableName);
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Quote a string argument so that it can be used as a literal in an
1:      * SQL statement. If the string argument is {@code null} an SQL NULL token
1:      * is returned.
1:      *
1:      * @param string a string or {@code null}
1:      * @return the string in quotes and with proper escape sequences for
1:      * special characters, or "NULL" if the string is {@code null}
1:      */
1:     private static String quoteStringArgument(String string) {
1:         if (string == null) {
1:             return "NULL";
1:         }
1:         return StringUtil.quoteStringLiteral(string);
1:     }
commit:e70c716
/////////////////////////////////////////////////////////////////////////
1:         se.initCause(t);
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:c0a8467
/////////////////////////////////////////////////////////////////////////
1: 			throw importError(e);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 	 * @param connection	 The Derby database connection URL for the database containing the table
/////////////////////////////////////////////////////////////////////////
1: 	 * @param connection	 The Derby database connection URL for the database containing the table
commit:6d913c6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:84e347a
/////////////////////////////////////////////////////////////////////////
1:                   String characterDelimiter,  String codeset, 
1:                   int noOfColumnsExpected,  String columnTypes, 
0:                   boolean lobsInExtFile) throws SQLException 
1:             this.noOfColumnsExpected = noOfColumnsExpected;
1:             this.tableColumnTypesStr = columnTypes;
1:             this.lobsInExtFile = lobsInExtFile;
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @param lobsInExtFile true, if the lobs data is stored in an external file,
1:      *                      and the reference to it is stored in the main import file.
1:                                    String tableName, String inputFileName,  
1:                                    String columnDelimiter, 
1:                                    String characterDelimiter,String codeset, 
0:                                    short replace, boolean lobsInExtFile)
1: 					  characterDelimiter, codeset, replace, lobsInExtFile);
/////////////////////////////////////////////////////////////////////////
1:      * @param lobsInExtFile true, if the lobs data is stored in an external file,
1:      *                      and the reference is stored in the main import file.
1:                                   String tableName, String insertColumnList, 
1:                                   String columnIndexes, String inputFileName, 
1:                                   String columnDelimiter, 
1:                                   String characterDelimiter,
1:                                   String codeset, short replace, 
0:                                   boolean lobsInExtFile)
1: 						  characterDelimiter, codeset, replace, lobsInExtFile);
/////////////////////////////////////////////////////////////////////////
0: 	private static void performImport(Connection connection, 
0:                                       String schemaName, 
0:                                       String insertColumnList, 
0:                                       String columnIndexes,
0:                                       String tableName, 
0:                                       String inputFileName,  
0:                                       String  columnDelimiter, 
0:                                       String characterDelimiter, 
0:                                       String codeset, 
0:                                       short replace, 
0:                                       boolean lobsInExtFile)
1:         throws SQLException 
/////////////////////////////////////////////////////////////////////////
0:         sb.append( columnInfo.getExpectedNumberOfColumnsInFile());
0:         sb.append(", ");
0:         sb.append( "'" + columnInfo.getExpectedVtiColumnTypesAsString() + "'");
0:         sb.append(", ");
0:         sb.append(lobsInExtFile);
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
0: 	 * @param connection	 The Cloudscape database connection URL for the database containing the table
1: 	 * @param columnDelimiter  Delimiter that seperates columns in the file
/////////////////////////////////////////////////////////////////////////
0: 	 * @param connection	 The Cloudscape database connection URL for the database containing the table
/////////////////////////////////////////////////////////////////////////
1: 	 * @param columnDelimiter  Delimiter that seperates columns in the file
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:2dc0b91
/////////////////////////////////////////////////////////////////////////
0: 			" --DERBY-PROPERTIES insertMode=" + insertModeValue + "\n" +
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7a92d1f
/////////////////////////////////////////////////////////////////////////
1: 	ImportReadData getImportReadData() throws Exception {
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.load.Import
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:bff3c2e
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.load
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.load;
1: 
0: import java.sql.ResultSet;
1: import java.sql.SQLException;
0: import java.sql.SQLWarning;
1: import java.sql.Statement;
1: import java.sql.PreparedStatement;
1: import java.sql.Connection;
0: import java.sql.DriverManager;
0: import java.sql.ResultSetMetaData;
0: import java.sql.DatabaseMetaData;
1: import java.util.*;
1: 
1: /**
1:  * This class implements import of data from a URL into a table.
1:  * Import functions provided here in this class shouble be called through
1:  * Systement Procedures. Import uses VTI , which is supprted only through 
1:  * Systemem procedures mechanism. 
1:  */
1: 
1: public class Import extends ImportAbstract{
1: 	/**
0: 	   IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
0: 	private String inputFileName;
1: 
1: 	/**
0: 	 * Constructior to Invoke Import from a select statement 
1: 	 * @param inputFileName	 The URL of the ASCII file from which import will happen
0: 	 * @exception Exception on error 
1: 	 */
1: 	public Import(String inputFileName, String columnDelimiter,
0: 					  String characterDelimiter,  String codeset, 
0: 					  int noOfColumnsExpected) throws SQLException 
1: 	{
1: 
1: 		try{
1: 			this.inputFileName = inputFileName;
0: 			this.noOfColumnsExpected = noOfColumnsExpected;
1: 			controlFileReader = new ControlInfo();
1: 			controlFileReader.setControlProperties(characterDelimiter,
1: 												   columnDelimiter, codeset);
1: 			doImport();
1: 
1: 		}catch(Exception e)
1: 		{
0: 			throw LoadError.unexpectedError(e);
1: 		}
1: 	}
1: 
1: 
1: 	private void doImport() throws Exception
1: 	{
1: 		if (inputFileName == null)
1: 			throw LoadError.dataFileNull();
1: 		doAllTheWork();
1: 
1: 	}
1: 
1: 	
1: 	/**
1: 	 * SYSCS_IMPORT_TABLE  system Procedure from ij or from a Java application
1: 	 * invokes  this method to perform import to a table from a file.
0: 	 * @param con	 The Cloudscape database connection URL for the database containing the table
1: 	 * @param schemaName	The name of the schema where table to import exists 
1: 	 * @param tableName     Name of the Table the data has to be imported to.
1: 	 * @param inputFileName Name of the file from which data has to be imported.
0: 	 * @param colDelimiter  Delimiter that seperates columns in the file
1: 	 * @param characterDelimiter  Delimiter that is used to quiote non-numeric types
1: 	 * @param codeset           Codeset of the data in the file
1: 	 * @param replace          Indicates whether the data in table has to be replaced or
0: 	 *                         appended.(0 - append , > 0 Replace the data)
0:  	 * @exception SQL Exception on errors
1: 	 */
1: 
1: 	public static void importTable(Connection connection, String schemaName, 
0:                               String tableName, String inputFileName,  
0: 							  String columnDelimiter, String characterDelimiter,
0: 							  String codeset, short replace)
1: 		throws SQLException {
1: 
1: 
1: 		performImport(connection,  schemaName,  null, //No columnList 
1: 					  null , //No column indexes
1: 					  tableName, inputFileName, columnDelimiter, 
0: 					  characterDelimiter, codeset, replace);
1: 	}
1: 
1: 
1: 
1: 		
1: 	/**
1: 	 * SYSCS_IMPORT_DATA  system Procedure from ij or from a Java application
1: 	 * invokes  this method to perform import to a table from a file.
0: 	 * @param con	 The Cloudscape database connection URL for the database containing the table
1: 	 * @param schemaName	The name of the schema where table to import exists 
1: 	 * @param tableName     Name of the Table the data has to be imported to.
1: 	 * @param insertColumnList  Comma Seperated column name list to which data
1: 	 *                          has to be imported from file.eg: 'c2,c2,'c3'.
1: 	 * @param columnIndexes     Comma sepearted Lit Index of the columns in the file(first column
1: 	                             starts at 1). eg: '3 ,4 , 5'
1: 	 * @param inputFileName Name of the file from which data has to be imported.
0: 	 * @param colDelimiter  Delimiter that seperates columns in the file
1: 	 * @param characterDelimiter  Delimiter that is used to quiote non-numeric types
1: 	 * @param codeset           Codeset of the data in the file
1: 	 * @param replace          Indicates whether the data in table has to be replaced or
0: 	 *                         appended.(0 - append , > 0 Replace the data)
0:  	 * @exception SQL Exception on errors
1: 	 */
1: 	public static void importData(Connection connection, String schemaName,
0: 								  String tableName, String insertColumnList, 
0: 								  String columnIndexes,
0: 								  String inputFileName, String columnDelimiter, 
0: 								  String characterDelimiter,
0: 								  String codeset, short replace)
1: 		throws SQLException 
1: 	{
1: 		
1: 
1: 			performImport(connection,  schemaName,  insertColumnList,columnIndexes, 
1: 						  tableName, inputFileName, columnDelimiter, 
0: 						  characterDelimiter, codeset, replace);
1: 	}
1: 
1: 
1: 	/*
1: 	 * This function creates and executes  SQL Insert statement that performs the 
1: 	 * the import using VTI. 
1: 	 * eg:
1: 	 * insert into T1 select  (cast column1 as DECIMAL), (cast column2 as
1: 	 * INTEGER)  from new org.apache.derby.impl.load.Import('extin/Tutor1.asc') as importvti;
1: 	 *
1: 	 */
0: 	private static void performImport(Connection connection, String schemaName, 
0: 									  String insertColumnList, String columnIndexes,
0: 									  String tableName, 
0: 									  String inputFileName,  String  columnDelimiter, 
0: 									  String characterDelimiter, String codeset, 
0: 									  short replace)
1: 		throws SQLException 
1: 	{
1: 
0: 		if (connection == null)
0: 			throw LoadError.connectionNull();
1: 		
0: 		String entityName = (schemaName == null ? tableName : schemaName + "." + tableName); 
1: 		
0: 		if (entityName == null)
0: 			throw LoadError.entityNameMissing();
1: 		
1: 
0: 		ColumnInfo columnInfo = new ColumnInfo(connection , schemaName ,
0: 											   tableName, insertColumnList, 
0: 											   columnIndexes, COLUMNNAMEPREFIX);
1: 
0: 		/* special handling of single quote delimiters
0: 		 * Single quote should be writeen with an extra quote otherwise sql will
0: 		 * throw syntac error.
0: 		 * i.e  to recognize a quote  it has to be appended with extra  quote ('')
1: 		 */
0: 		if(characterDelimiter!=null && characterDelimiter.equals("'"))
0: 			characterDelimiter = "''";
0: 		if(columnDelimiter !=null && columnDelimiter.equals("'"))
0: 			columnDelimiter = "''";
1: 		
1: 
0: 		StringBuffer sb = new StringBuffer("new ");
0: 		sb.append("org.apache.derby.impl.load.Import");
0: 		sb.append("(") ; 
0: 		sb.append(	(inputFileName !=null ? "'" + inputFileName + "'" : null));
0: 		sb.append(",") ;
0: 		sb.append(	(columnDelimiter !=null ? "'" + columnDelimiter + "'" : null));
0: 		sb.append(",") ;
0: 		sb.append(	(characterDelimiter !=null ? "'" + characterDelimiter + "'" : null));
0: 		sb.append(",") ;
0: 		sb.append(	(codeset !=null ? "'" + codeset + "'" : null));
0: 		sb.append(", ");
0: 		sb.append( columnInfo.getExpectedNumberOfColumnsInFile());
0: 		sb.append(" )") ;
1: 
0: 		String importvti = sb.toString();
1: 
1: 
0: 		String insertModeValue;
0: 		if(replace > 0)
0: 			insertModeValue = "replace";
0: 		else
0: 			insertModeValue = "bulkInsert";
1: 
0: 		String cNamesWithCasts = columnInfo.getColumnNamesWithCasts();
0: 		String insertColumnNames = columnInfo.getInsertColumnNames();
0: 		if(insertColumnNames !=null)
0: 			insertColumnNames = "(" + insertColumnNames + ") " ;
0: 		else
0: 			insertColumnNames = "";
0: 		String insertSql = "INSERT INTO " + entityName +  insertColumnNames + 
0: 			" PROPERTIES insertMode=" + insertModeValue + 
0: 			" SELECT " + cNamesWithCasts + " from " + 
0: 			importvti + " AS importvti" ;
1: 
0: 		//prepare the import statement to hit any errors before locking the table
0: 		PreparedStatement ips = connection.prepareStatement(insertSql);
1: 		
0: 		//lock the table before perfoming import, because there may 
0: 		//huge number of lockes aquired that might have affect on performance 
0: 		//and some possible dead lock scenarios.
0: 		Statement statement = connection.createStatement();
0: 		String lockSql = "LOCK TABLE " + entityName + " IN EXCLUSIVE MODE";
0: 		statement.executeUpdate(lockSql);
1: 
0: 		//execute the import operaton.
0: 		ips.executeUpdate();
0: 		statement.close();
0: 		ips.close();
1: 
1: 	}
1: 
1: 
1: 	/** virtual method from the abstract class
1: 	 * @exception	Exception on error
1: 	 */
0: 	protected ImportReadData getImportReadData() throws Exception {
0: 		return new ImportReadData(inputFileName, controlFileReader);
1: 	}
1: }
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:c47d471
/////////////////////////////////////////////////////////////////////////
0: 	
0: 		if (tableName == null)
/////////////////////////////////////////////////////////////////////////
0: 		// delimit the table and schema names with quotes.
0: 		// because they might have been  created as quoted
0: 		// identifiers(for example when reserved words are used, names are quoted)
0: 		
0: 		// Import procedures are to be called with case-senisitive names. 
0: 		// Incase of delimited table names, they need to be passed as defined
0: 		// and when they are not delimited, they need to be passed in upper
0: 		// case, because all undelimited names are stored in the upper case 
0: 		// in the database. 
0: 
0: 		String entityName = (schemaName == null ? "\""+ tableName + "\"" : 
0: 							 "\"" + schemaName + "\"" + "." + "\"" + tableName + "\""); 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.load
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.load;
0: 
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import java.sql.SQLWarning;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
0: import java.sql.Connection;
0: import java.sql.DriverManager;
0: import java.sql.ResultSetMetaData;
0: import java.sql.DatabaseMetaData;
0: import java.util.*;
0: 
0: /**
0:  * This class implements import of data from a URL into a table.
0:  * Import functions provided here in this class shouble be called through
0:  * Systement Procedures. Import uses VTI , which is supprted only through 
0:  * Systemem procedures mechanism. 
0:  */
0: 
0: public class Import extends ImportAbstract{
0: 	/**
0: 	   IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0: 	private String inputFileName;
0: 
0: 	/**
0: 	 * Constructior to Invoke Import from a select statement 
0: 	 * @param inputFileName	 The URL of the ASCII file from which import will happen
0: 	 * @exception Exception on error 
0: 	 */
0: 	public Import(String inputFileName, String columnDelimiter,
0: 					  String characterDelimiter,  String codeset, 
0: 					  int noOfColumnsExpected) throws SQLException 
0: 	{
0: 
0: 		try{
0: 			this.inputFileName = inputFileName;
0: 			this.noOfColumnsExpected = noOfColumnsExpected;
0: 			controlFileReader = new ControlInfo();
0: 			controlFileReader.setControlProperties(characterDelimiter,
0: 												   columnDelimiter, codeset);
0: 			doImport();
0: 
0: 		}catch(Exception e)
0: 		{
0: 			throw LoadError.unexpectedError(e);
0: 		}
0: 	}
0: 
0: 
0: 	private void doImport() throws Exception
0: 	{
0: 		if (inputFileName == null)
0: 			throw LoadError.dataFileNull();
0: 		doAllTheWork();
0: 
0: 	}
0: 
0: 	
0: 	/**
0: 	 * SYSCS_IMPORT_TABLE  system Procedure from ij or from a Java application
0: 	 * invokes  this method to perform import to a table from a file.
0: 	 * @param con	 The Cloudscape database connection URL for the database containing the table
0: 	 * @param schemaName	The name of the schema where table to import exists 
0: 	 * @param tableName     Name of the Table the data has to be imported to.
0: 	 * @param inputFileName Name of the file from which data has to be imported.
0: 	 * @param colDelimiter  Delimiter that seperates columns in the file
0: 	 * @param characterDelimiter  Delimiter that is used to quiote non-numeric types
0: 	 * @param codeset           Codeset of the data in the file
0: 	 * @param replace          Indicates whether the data in table has to be replaced or
0: 	 *                         appended.(0 - append , > 0 Replace the data)
0:  	 * @exception SQL Exception on errors
0: 	 */
0: 
0: 	public static void importTable(Connection connection, String schemaName, 
0:                               String tableName, String inputFileName,  
0: 							  String columnDelimiter, String characterDelimiter,
0: 							  String codeset, short replace)
0: 		throws SQLException {
0: 
0: 
0: 		performImport(connection,  schemaName,  null, //No columnList 
0: 					  null , //No column indexes
0: 					  tableName, inputFileName, columnDelimiter, 
0: 					  characterDelimiter, codeset, replace);
0: 	}
0: 
0: 
0: 
0: 		
0: 	/**
0: 	 * SYSCS_IMPORT_DATA  system Procedure from ij or from a Java application
0: 	 * invokes  this method to perform import to a table from a file.
0: 	 * @param con	 The Cloudscape database connection URL for the database containing the table
0: 	 * @param schemaName	The name of the schema where table to import exists 
0: 	 * @param tableName     Name of the Table the data has to be imported to.
0: 	 * @param insertColumnList  Comma Seperated column name list to which data
0: 	 *                          has to be imported from file.eg: 'c2,c2,'c3'.
0: 	 * @param columnIndexes     Comma sepearted Lit Index of the columns in the file(first column
0: 	                             starts at 1). eg: '3 ,4 , 5'
0: 	 * @param inputFileName Name of the file from which data has to be imported.
0: 	 * @param colDelimiter  Delimiter that seperates columns in the file
0: 	 * @param characterDelimiter  Delimiter that is used to quiote non-numeric types
0: 	 * @param codeset           Codeset of the data in the file
0: 	 * @param replace          Indicates whether the data in table has to be replaced or
0: 	 *                         appended.(0 - append , > 0 Replace the data)
0:  	 * @exception SQL Exception on errors
0: 	 */
0: 	public static void importData(Connection connection, String schemaName,
0: 								  String tableName, String insertColumnList, 
0: 								  String columnIndexes,
0: 								  String inputFileName, String columnDelimiter, 
0: 								  String characterDelimiter,
0: 								  String codeset, short replace)
0: 		throws SQLException 
0: 	{
0: 		
0: 
0: 			performImport(connection,  schemaName,  insertColumnList,columnIndexes, 
0: 						  tableName, inputFileName, columnDelimiter, 
0: 						  characterDelimiter, codeset, replace);
0: 	}
0: 
0: 
0: 	/*
0: 	 * This function creates and executes  SQL Insert statement that performs the 
0: 	 * the import using VTI. 
0: 	 * eg:
0: 	 * insert into T1 select  (cast column1 as DECIMAL), (cast column2 as
0: 	 * INTEGER)  from new org.apache.derby.impl.load.Import('extin/Tutor1.asc') as importvti;
0: 	 *
0: 	 */
0: 	private static void performImport(Connection connection, String schemaName, 
0: 									  String insertColumnList, String columnIndexes,
0: 									  String tableName, 
0: 									  String inputFileName,  String  columnDelimiter, 
0: 									  String characterDelimiter, String codeset, 
0: 									  short replace)
0: 		throws SQLException 
0: 	{
0: 
0: 		if (connection == null)
0: 			throw LoadError.connectionNull();
0: 		
0: 		String entityName = (schemaName == null ? tableName : schemaName + "." + tableName); 
0: 		
0: 		if (entityName == null)
0: 			throw LoadError.entityNameMissing();
0: 		
0: 
0: 		ColumnInfo columnInfo = new ColumnInfo(connection , schemaName ,
0: 											   tableName, insertColumnList, 
0: 											   columnIndexes, COLUMNNAMEPREFIX);
0: 
0: 		/* special handling of single quote delimiters
0: 		 * Single quote should be writeen with an extra quote otherwise sql will
0: 		 * throw syntac error.
0: 		 * i.e  to recognize a quote  it has to be appended with extra  quote ('')
0: 		 */
0: 		if(characterDelimiter!=null && characterDelimiter.equals("'"))
0: 			characterDelimiter = "''";
0: 		if(columnDelimiter !=null && columnDelimiter.equals("'"))
0: 			columnDelimiter = "''";
0: 		
0: 
0: 		StringBuffer sb = new StringBuffer("new ");
0: 		sb.append("org.apache.derby.impl.load.Import");
0: 		sb.append("(") ; 
0: 		sb.append(	(inputFileName !=null ? "'" + inputFileName + "'" : null));
0: 		sb.append(",") ;
0: 		sb.append(	(columnDelimiter !=null ? "'" + columnDelimiter + "'" : null));
0: 		sb.append(",") ;
0: 		sb.append(	(characterDelimiter !=null ? "'" + characterDelimiter + "'" : null));
0: 		sb.append(",") ;
0: 		sb.append(	(codeset !=null ? "'" + codeset + "'" : null));
0: 		sb.append(", ");
0: 		sb.append( columnInfo.getExpectedNumberOfColumnsInFile());
0: 		sb.append(" )") ;
0: 
0: 		String importvti = sb.toString();
0: 
0: 
0: 		String insertModeValue;
0: 		if(replace > 0)
0: 			insertModeValue = "replace";
0: 		else
0: 			insertModeValue = "bulkInsert";
0: 
0: 		String cNamesWithCasts = columnInfo.getColumnNamesWithCasts();
0: 		String insertColumnNames = columnInfo.getInsertColumnNames();
0: 		if(insertColumnNames !=null)
0: 			insertColumnNames = "(" + insertColumnNames + ") " ;
0: 		else
0: 			insertColumnNames = "";
0: 		String insertSql = "INSERT INTO " + entityName +  insertColumnNames + 
0: 			" PROPERTIES insertMode=" + insertModeValue + 
0: 			" SELECT " + cNamesWithCasts + " from " + 
0: 			importvti + " AS importvti" ;
0: 
0: 		//prepare the import statement to hit any errors before locking the table
0: 		PreparedStatement ips = connection.prepareStatement(insertSql);
0: 		
0: 		//lock the table before perfoming import, because there may 
0: 		//huge number of lockes aquired that might have affect on performance 
0: 		//and some possible dead lock scenarios.
0: 		Statement statement = connection.createStatement();
0: 		String lockSql = "LOCK TABLE " + entityName + " IN EXCLUSIVE MODE";
0: 		statement.executeUpdate(lockSql);
0: 
0: 		//execute the import operaton.
0: 		ips.executeUpdate();
0: 		statement.close();
0: 		ips.close();
0: 
0: 	}
0: 
0: 
0: 	/** virtual method from the abstract class
0: 	 * @exception	Exception on error
0: 	 */
0: 	protected ImportReadData getImportReadData() throws Exception {
0: 		return new ImportReadData(inputFileName, controlFileReader);
0: 	}
0: }
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
============================================================================