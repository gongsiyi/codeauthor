6:eac0369: /*
1:f697326: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.data.OverflowInputStream
1:f697326: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
8:eac0369:  */
1:345de35: 
1:eac0369: package org.apache.derby.impl.store.raw.data;
17:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:b44abbf: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:1b454a1: import org.apache.derby.iapi.services.io.CloneableStream;
1:8f01b3c: import org.apache.derby.iapi.services.i18n.MessageService;
1:1b454a1: 
1:eac0369: import org.apache.derby.iapi.store.raw.RecordHandle;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.Resetable;
1:1b454a1: 
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:8f01b3c: import org.apache.derby.shared.common.reference.MessageId;
1:8f01b3c: 
1:8f01b3c: import java.io.EOFException;
1:1b454a1: import java.io.InputStream;
1:eac0369: import java.io.IOException;
1:eac0369: 
1:f697326: /**
1:dc5597b: A OverflowInputStream is used by store to turn a long column into an 
1:dc5597b: InputStream.
1:dc5597b: <p>
1:dc5597b: Any time store fetches a long column, the value is returned as a stream.
1:dc5597b: A long column is any column that at some point was longer than a page, so
1:dc5597b: a long column in one table may not be long in another depending on page size.
1:dbed020: <p>
1:dc5597b: When the column is fetched a new OverflowInputStream is created and then
1:dc5597b: the datatype's stream is set using:
1:dc5597b:  ((StreamStorable)sColumn).setStream(OverflowInputStream);
1:dc5597b: 
1:dc5597b: **/
1:dc5597b: 
1:eac0369: public class OverflowInputStream
1:eac0369: extends BufferedByteHolderInputStream
1:1b454a1: implements Resetable, CloneableStream
5:eac0369: {
1:dc5597b:     /**************************************************************************
1:dc5597b:      * Fields of the class
1:dc5597b:      **************************************************************************
1:dc5597b:      */
1:dc5597b:     protected BaseContainerHandle   owner;
1:dc5597b: 
1:dc5597b:     // tracks the next overflow page and id on that page to read
1:dc5597b:     protected long                  overflowPage;
1:dc5597b:     protected int                   overflowId;
1:dc5597b: 
1:eac0369:     // remember first page and id for reset
1:dc5597b:     protected long                  firstOverflowPage;
1:dc5597b:     protected int                   firstOverflowId;
1:dc5597b: 
1:eac0369:     // the row to lock for Blobs/Clobs
1:dc5597b:     protected RecordHandle          recordToLock;
1:dc5597b: 
1:f697326:     // Make sure record is only locked once.
1:f697326:     private boolean initialized = false;
1:dc5597b: 
1:eac0369: 
1:dc5597b:     /**************************************************************************
1:dc5597b:      * Constructors for This class:
1:dc5597b:      **************************************************************************
1:dc5597b:      */
1:dc5597b: 
1:dc5597b:     /**
1:dc5597b:      * Constructor for OverflowInputStream
1:dc5597b:      * <p>
1:dc5597b:      * It is up to the caller to allocate the ByteHolder for this stream,
1:dc5597b:      * and pass it in.
2:dc5597b:      *
1:dc5597b:      * @param bh            ByteHolder to hold buffers of bytes as the stream is
1:dc5597b:      *                      walked.  Expected usage is that a page worth of 
1:dc5597b:      *                      data is held in memory at a time, filled by a 
1:dc5597b:      *                      calls to restorePortionLongColumn(). 
1:dc5597b:      *
1:dc5597b:      * @param owner         BaseContainerHandle used to read pages from the 
1:dc5597b:      *                      container.  Note this handle is closed automatically
1:dc5597b:      *                      on commit.
1:dc5597b:      *
1:dc5597b:      * @param overflowPage  The first overflow page of this long column.  
1:dc5597b:      *
1:dc5597b:      * @param overflowId    The record id of 1st segment of the long column on
1:dc5597b:      *                      overflowPage.
1:dc5597b:      *
1:dc5597b:      * @param recordToLock  RecordHandle of the owning record of the long long
1:dc5597b:      *                      column, this is the row level lock to get.
1:dc5597b:      **/
1:dc5597b:     public OverflowInputStream(
1:dc5597b:     ByteHolder          bh, 
1:dc5597b:     BaseContainerHandle owner,
1:dc5597b:     long                overflowPage, 
1:dc5597b:     int                 overflowId, 
1:1b454a1:     RecordHandle        recordToLock) {
1:dc5597b:         super(bh);
1:dc5597b:         this.owner              = owner;
1:dc5597b:         this.overflowPage       = overflowPage;
1:dc5597b:         this.overflowId         = overflowId;
1:dc5597b:         this.firstOverflowPage  = overflowPage;
1:dc5597b:         this.firstOverflowId    = overflowId;
1:dc5597b:         this.recordToLock       = recordToLock;
1:dc5597b:     }
1:f697326: 
1:dc5597b:     /**************************************************************************
1:dc5597b:      * Public Methods of This class:
1:dc5597b:      **************************************************************************
1:dc5597b:      */
1:dc5597b: 
1:dc5597b:     /**
1:dc5597b:      * If bytes remain in stream, insure the current buffer is not empty.
1:dc5597b:      * <p>
1:dc5597b:      * If there are bytes in current buffer than no more work necessary,
1:dc5597b:      * else if there are no bytes available in current buffer and there are 
1:dc5597b:      * still more overflow segments then get the next buffer's worth of
1:dc5597b:      * data.
1:dc5597b:      *
1:dc5597b:      * @exception  IOException
1:dc5597b:      **/
1:dc5597b:     public void fillByteHolder() 
1:dc5597b:         throws IOException
1:dc5597b:     {
1:dc5597b:         if ((this.bh.available() == 0) && (this.overflowPage != -1))
1:dc5597b:         {
1:dc5597b:             this.bh.clear();
1:f697326: 
1:dc5597b:             try
1:eac0369:             {
1:dc5597b:                 // fill the byte holder with data from the page.
1:dc5597b:                 BasePage columnOverflowPage = 
1:dd2accd:                     ((BasePage) this.owner.getPage(overflowPage));
1:eac0369: 
1:dc5597b:                 if (columnOverflowPage != null)
1:eac0369:                 {
1:dc5597b:                     columnOverflowPage.restorePortionLongColumn(this);
1:dc5597b:                     columnOverflowPage.unlatch();
1:dc5597b:                     columnOverflowPage = null;
1:8f01b3c:                 } else {
1:8f01b3c:                     // An overflow page was specified, but we failed to get it.
1:8f01b3c:                     // Probably the value got deleted under our feet.
1:8f01b3c:                     throw new EOFException(MessageService.getTextMessage(
1:8f01b3c:                             MessageId.STORE_STREAM_OVERFLOW_PAGE_NOT_FOUND));
1:dc5597b:                 }
1:dc5597b: 
1:dc5597b:             }
1:eac0369:             catch (StandardException se)
1:eac0369:             {
1:be94230:                 throw new IOException(se);
1:dc5597b:             }
1:eac0369: 
1:dc5597b:             this.bh.startReading();
1:dc5597b:         }
1:dc5597b:     }
1:eac0369: 
1:dc5597b:     /**
1:dc5597b:      * Set the next overflow page of the long column.
1:dc5597b:      * <p>
1:dc5597b:      * Used by StorePage.restorePortionLongColumn() as part of the call back
1:dc5597b:      * process to save the state of the scan of the pieces of the long column.
1:dc5597b:      * StorePage.restorePortionLongColumn() is called by fillByteHolder() to
1:dc5597b:      * get the next page worth into a buffer, and in turn after those bytes
1:dc5597b:      * are read the state of this stream is updated with then next overflow
1:dc5597b:      * page.
1:dc5597b:      *
2:dc5597b:      * @param overflowPage  Page number containing the next segment of the
1:dc5597b:      *                      long column.  -1 if there are no more segments.
1:dc5597b:      *
1:dc5597b:      **/
1:dc5597b:     public void setOverflowPage(long overflowPage) 
1:dc5597b:     {
1:dc5597b:         this.overflowPage = overflowPage;
1:dc5597b:     }
1:eac0369: 
1:dc5597b:     /**
1:dc5597b:      * Set the next overflow page of the long column.
1:dc5597b:      * <p>
1:dc5597b:      * Used by StorePage.restorePortionLongColumn() as part of the call back
1:dc5597b:      * process to save the state of the scan of the pieces of the long column.
1:dc5597b:      * StorePage.restorePortionLongColumn() is called by fillByteHolder() to
1:dc5597b:      * get the next page worth into a buffer, and in turn after those bytes
1:dc5597b:      * are read the state of this stream is updated with then next overflow
1:dc5597b:      * page.
1:dc5597b:      *
1:5a2e494:      * @param overflowId    Page number containing the next segment of the
1:dc5597b:      *                      long column.  -1 if there are no more segments.
1:dc5597b:      *
1:dc5597b:      **/
1:dc5597b:     public void setOverflowId(int overflowId) 
1:dc5597b:     {
1:dc5597b:         this.overflowId = overflowId;
1:dc5597b:     }
1:eac0369: 
1:dc5597b:     public long getOverflowPage() 
1:dc5597b:     {
1:dc5597b:         return this.overflowPage;
1:dc5597b:     }
1:eac0369: 
1:dc5597b:     public int getOverflowId() 
1:dc5597b:     {
1:dc5597b:         return this.overflowId;
1:dc5597b:     }
1:eac0369: 
1:dc5597b:     /**************************************************************************
1:dc5597b:      * Public Methods of Resetable Interface
1:dc5597b:      **************************************************************************
1:f697326:      */
1:dc5597b: 
1:dc5597b:     /**
1:dc5597b:      * Initialize a Resetable stream.
1:dc5597b:      * <p>
1:dc5597b:      * InitStream() must be called first before using any other of the 
1:dc5597b:      * Resetable interfaces.
1:dc5597b:      * <p>
1:dc5597b:      * Reopens the container.  This gets a separate intent shared locked on
1:dc5597b:      * the table and a read lock on the appropriate row.  These locks remain
1:dc5597b:      * until the enclosing blob/clob object is closed, or until the end of
1:dc5597b:      * the transaction in which initStream() was first called.  This locking
1:dc5597b:      * behavior protects the row while the stream is being accessed.  Otherwise
1:dc5597b:      * for instance in the case of read committed the original row lock on 
1:dc5597b:      * the row would be released when the scan went to the next row, and there
1:dc5597b:      * would be nothing to stop another transaction from deleting the row while
1:dc5597b:      * the client read through the stream.
1:dc5597b:      *
1:dc5597b:      * @exception  StandardException  Standard exception policy.
1:dc5597b:      **/
1:dc5597b: 
1:dc5597b:     public void initStream() throws StandardException
1:dc5597b:     {
1:dc5597b:         // only one initStream() required.
1:dc5597b:         if (initialized) 
1:dc5597b:             return;
1:dc5597b: 
1:dc5597b:         // it is possible that the transaction in which the stream was
1:dc5597b:         // created is committed and no longer valid dont want to get NPE but 
1:dc5597b:         // instead throw error that container was not opened
1:dc5597b:         if (owner.getTransaction() == null)
1:dc5597b:         {
1:dc5597b:             throw StandardException.newException(
1:dc5597b:                     SQLState.DATA_CONTAINER_CLOSED);
1:dc5597b:         }
1:dc5597b: 
1:dc5597b:         // Use isolation level READ_COMMITTED and reopen the container to 
1:dc5597b:         // get a new container handle to use for locking.  This way, the lock 
1:9e951e2:         // will be freed when the container handle is closed. This will 
1:dc5597b:         // happen in closeStream() or when the transaction commits. 
1:dc5597b:         // Hence, locks will be released before the end of transaction if 
1:dc5597b:         // blobs/clobs are explicitly released.
1:dc5597b:         LockingPolicy lp = 
1:dc5597b:             owner.getTransaction().newLockingPolicy(
1:dc5597b:                 LockingPolicy.MODE_RECORD, 
1:dc5597b:                 TransactionController.ISOLATION_READ_COMMITTED, 
1:dc5597b:                 true);
1:dc5597b: 
1:dc5597b:         // reopen the container
1:dc5597b:         owner = (BaseContainerHandle) owner.getTransaction().openContainer(
1:dc5597b:                     owner.getId(), lp, owner.getMode());
1:dc5597b: 
1:dc5597b:         // get a read lock on the appropriate row this will wait until either 
1:dc5597b:         // the lock is granted or an exception is thrown
1:dc5597b:         owner.getLockingPolicy().lockRecordForRead(
1:dc5597b:             owner.getTransaction(), owner, recordToLock, true, false);
1:dc5597b: 
1:dc5597b:         initialized = true;
1:dc5597b:     }
1:dc5597b: 
1:dc5597b:     /**
1:dc5597b:      * Reset the stream back to beginning of the long column.
1:dc5597b:      * <p>
1:dc5597b:      * Also fills in the first buffer from the stream.
1:dc5597b:      * <p>
1:dc5597b:      * Throws exception if the underlying open container has been closed,
1:dc5597b:      * for example automatically by a commit().
1:dc5597b:      *
1:dc5597b:      * @exception  StandardException  Standard exception policy.
1:dc5597b:      **/
1:eac0369:     public void resetStream() throws IOException, StandardException
1:eac0369:     {
1:eac0369:         // check the container is open, this is needed to make sure the
1:eac0369:         // container closed exception is thrown as a StandardException and not
1:eac0369:         // as an IOException
1:eac0369:         owner.checkOpen();
1:dc5597b: 
1:eac0369:         // return to the original overflow page and id
1:dc5597b:         this.overflowPage   = firstOverflowPage;
1:dc5597b:         this.overflowId     = firstOverflowId;
1:dc5597b: 
1:eac0369:         // completely clear the byte holder
2:eac0369:         this.bh.clear();
2:eac0369:         this.bh.startReading();
12:eac0369:     }
1:dc5597b: 
2:eac0369:     /**
1:dc5597b:      * Close the Resetable stream.
1:dc5597b:      * <p>
1:dc5597b:      * Close the container associated with this stream.  (This will also free 
1:dc5597b:      * the associated IS table lock and the associated S row lock.)
1:dc5597b:      **/
1:eac0369:     public void closeStream()
1:eac0369:     {
1:eac0369:         owner.close();
1:f697326:         initialized = false;
1:eac0369:     }
1:1b454a1: 
1:1b454a1:     /**************************************************************************
1:1b454a1:      * Public Methods of CloneableStream Interface
1:1b454a1:      **************************************************************************/
1:1b454a1: 
1:1b454a1:     /**
1:1b454a1:      * Clone this object.
1:1b454a1:      * <p>
1:1b454a1:      * Creates a deep copy of this object. The returned stream has its own
1:1b454a1:      * working buffers and can be initialized, reset and read independently
1:1b454a1:      * from this stream.
1:1b454a1:      * <p>
1:1b454a1:      * The cloned stream is set back to the beginning of stream, no matter
1:1b454a1:      * where the current stream happens to be positioned.
1:dc5597b:      *
1:1b454a1:      * @return Copy of this stream which can be used independently.
1:1b454a1:      */
1:1b454a1:     public InputStream cloneStream() {
1:1b454a1:         OverflowInputStream ret_stream = 
1:1b454a1:             new OverflowInputStream(
1:1b454a1:                 bh.cloneEmpty(),
1:1b454a1:                 owner, 
1:1b454a1:                 firstOverflowPage, 
1:1b454a1:                 firstOverflowId, 
1:1b454a1:                 recordToLock);
1:1b454a1: 
1:1b454a1:         return(ret_stream);
1:1b454a1:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: <p>
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:be94230
/////////////////////////////////////////////////////////////////////////
1:                 throw new IOException(se);
commit:5a2e494
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param overflowId    Page number containing the next segment of the
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:9e951e2
/////////////////////////////////////////////////////////////////////////
1:         // will be freed when the container handle is closed. This will 
commit:dc5597b
/////////////////////////////////////////////////////////////////////////
1: A OverflowInputStream is used by store to turn a long column into an 
1: InputStream.
1: <p>
1: Any time store fetches a long column, the value is returned as a stream.
1: A long column is any column that at some point was longer than a page, so
1: a long column in one table may not be long in another depending on page size.
0: <p)
1: When the column is fetched a new OverflowInputStream is created and then
1: the datatype's stream is set using:
1:  ((StreamStorable)sColumn).setStream(OverflowInputStream);
1: 
1: **/
1: 
1:     /**************************************************************************
1:      * Fields of the class
1:      **************************************************************************
1:      */
1:     protected BaseContainerHandle   owner;
1: 
1:     // tracks the next overflow page and id on that page to read
1:     protected long                  overflowPage;
1:     protected int                   overflowId;
1: 
1:     protected long                  firstOverflowPage;
1:     protected int                   firstOverflowId;
1: 
1:     protected RecordHandle          recordToLock;
1: 
1: 
1:     /**************************************************************************
1:      * Constructors for This class:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Constructor for OverflowInputStream
1:      * <p>
1:      * It is up to the caller to allocate the ByteHolder for this stream,
1:      * and pass it in.
1:      *
1:      * @param bh            ByteHolder to hold buffers of bytes as the stream is
1:      *                      walked.  Expected usage is that a page worth of 
1:      *                      data is held in memory at a time, filled by a 
1:      *                      calls to restorePortionLongColumn(). 
1:      *
1:      * @param owner         BaseContainerHandle used to read pages from the 
1:      *                      container.  Note this handle is closed automatically
1:      *                      on commit.
1:      *
1:      * @param overflowPage  The first overflow page of this long column.  
1:      *
1:      * @param overflowId    The record id of 1st segment of the long column on
1:      *                      overflowPage.
1:      *
1:      * @param recordToLock  RecordHandle of the owning record of the long long
1:      *                      column, this is the row level lock to get.
1:      **/
1:     public OverflowInputStream(
1:     ByteHolder          bh, 
1:     BaseContainerHandle owner,
1:     long                overflowPage, 
1:     int                 overflowId, 
0:     RecordHandle        recordToLock)
1:     {
1:         super(bh);
1:         this.owner              = owner;
1:         this.overflowPage       = overflowPage;
1:         this.overflowId         = overflowId;
1:         this.firstOverflowPage  = overflowPage;
1:         this.firstOverflowId    = overflowId;
1:         this.recordToLock       = recordToLock;
0:         fillByteHolder();
1:     }
1:     /**************************************************************************
1:      * Public Methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * If bytes remain in stream, insure the current buffer is not empty.
1:      * <p>
1:      * If there are bytes in current buffer than no more work necessary,
1:      * else if there are no bytes available in current buffer and there are 
1:      * still more overflow segments then get the next buffer's worth of
1:      * data.
1:      *
1:      * @exception  IOException
1:      **/
1:     public void fillByteHolder() 
1:         throws IOException
1:     {
1:         if ((this.bh.available() == 0) && (this.overflowPage != -1))
1:             this.bh.clear();
1:             try
1:                 // fill the byte holder with data from the page.
1:                 BasePage columnOverflowPage = 
1:                 if (columnOverflowPage != null)
1:                     columnOverflowPage.restorePortionLongColumn(this);
1:                     columnOverflowPage.unlatch();
1:                     columnOverflowPage = null;
1:                 }
1: 
1:             }
0:                 throw new IOException(se.toString());
1:             }
1:             this.bh.startReading();
1:         }
1:     }
1:     /**
1:      * Set the next overflow page of the long column.
1:      * <p>
1:      * Used by StorePage.restorePortionLongColumn() as part of the call back
1:      * process to save the state of the scan of the pieces of the long column.
1:      * StorePage.restorePortionLongColumn() is called by fillByteHolder() to
1:      * get the next page worth into a buffer, and in turn after those bytes
1:      * are read the state of this stream is updated with then next overflow
1:      * page.
1:      *
0:      * @return The identifier to be used to open the conglomerate later.
1:      *
1:      * @param overflowPage  Page number containing the next segment of the
1:      *                      long column.  -1 if there are no more segments.
1:      *
1:      **/
1:     public void setOverflowPage(long overflowPage) 
1:     {
1:         this.overflowPage = overflowPage;
1:     }
1:     /**
1:      * Set the next overflow page of the long column.
1:      * <p>
1:      * Used by StorePage.restorePortionLongColumn() as part of the call back
1:      * process to save the state of the scan of the pieces of the long column.
1:      * StorePage.restorePortionLongColumn() is called by fillByteHolder() to
1:      * get the next page worth into a buffer, and in turn after those bytes
1:      * are read the state of this stream is updated with then next overflow
1:      * page.
1:      *
0:      * @return The identifier to be used to open the conglomerate later.
1:      *
1:      * @param overflowPage  Page number containing the next segment of the
1:      *                      long column.  -1 if there are no more segments.
1:      *
1:      **/
1:     public void setOverflowId(int overflowId) 
1:     {
1:         this.overflowId = overflowId;
1:     }
1:     public long getOverflowPage() 
1:     {
1:         return this.overflowPage;
1:     }
1:     public int getOverflowId() 
1:     {
1:         return this.overflowId;
1:     }
1:     /**************************************************************************
1:      * Public Methods of Resetable Interface
1:      **************************************************************************
1: 
1:     /**
1:      * Initialize a Resetable stream.
1:      * <p>
1:      * InitStream() must be called first before using any other of the 
1:      * Resetable interfaces.
1:      * <p>
1:      * Reopens the container.  This gets a separate intent shared locked on
1:      * the table and a read lock on the appropriate row.  These locks remain
1:      * until the enclosing blob/clob object is closed, or until the end of
1:      * the transaction in which initStream() was first called.  This locking
1:      * behavior protects the row while the stream is being accessed.  Otherwise
1:      * for instance in the case of read committed the original row lock on 
1:      * the row would be released when the scan went to the next row, and there
1:      * would be nothing to stop another transaction from deleting the row while
1:      * the client read through the stream.
1:      *
1:      * @exception  StandardException  Standard exception policy.
1:      **/
1: 
1:     public void initStream() throws StandardException
1:     {
1:         // only one initStream() required.
1:         if (initialized) 
1:             return;
1: 
1:         // it is possible that the transaction in which the stream was
1:         // created is committed and no longer valid dont want to get NPE but 
1:         // instead throw error that container was not opened
1:         if (owner.getTransaction() == null)
1:         {
1:             throw StandardException.newException(
1:                     SQLState.DATA_CONTAINER_CLOSED);
1:         }
1: 
1:         // Use isolation level READ_COMMITTED and reopen the container to 
1:         // get a new container handle to use for locking.  This way, the lock 
0:         // will be freed when we the container handle is closed. This will 
1:         // happen in closeStream() or when the transaction commits. 
1:         // Hence, locks will be released before the end of transaction if 
1:         // blobs/clobs are explicitly released.
1:         LockingPolicy lp = 
1:             owner.getTransaction().newLockingPolicy(
1:                 LockingPolicy.MODE_RECORD, 
1:                 TransactionController.ISOLATION_READ_COMMITTED, 
1:                 true);
1: 
1:         // reopen the container
1:         owner = (BaseContainerHandle) owner.getTransaction().openContainer(
1:                     owner.getId(), lp, owner.getMode());
1: 
1:         // get a read lock on the appropriate row this will wait until either 
1:         // the lock is granted or an exception is thrown
1:         owner.getLockingPolicy().lockRecordForRead(
1:             owner.getTransaction(), owner, recordToLock, true, false);
1: 
1:         initialized = true;
1:     }
1: 
1:     /**
1:      * Reset the stream back to beginning of the long column.
1:      * <p>
1:      * Also fills in the first buffer from the stream.
1:      * <p>
1:      * Throws exception if the underlying open container has been closed,
1:      * for example automatically by a commit().
1:      *
1:      * @exception  StandardException  Standard exception policy.
1:      **/
1: 
1:         this.overflowPage   = firstOverflowPage;
1:         this.overflowId     = firstOverflowId;
1: 
1: 
0:         fillByteHolder();
1:      * Close the Resetable stream.
1:      * <p>
1:      * Close the container associated with this stream.  (This will also free 
1:      * the associated IS table lock and the associated S row lock.)
1:      **/
commit:dd2accd
/////////////////////////////////////////////////////////////////////////
0: 				BasePage columnOverflowPage = 
1:                     ((BasePage) this.owner.getPage(overflowPage));
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:8f01b3c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.i18n.MessageService;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.MessageId;
1: 
1: import java.io.EOFException;
/////////////////////////////////////////////////////////////////////////
1:                 } else {
1:                     // An overflow page was specified, but we failed to get it.
1:                     // Probably the value got deleted under our feet.
1:                     throw new EOFException(MessageService.getTextMessage(
1:                             MessageId.STORE_STREAM_OVERFLOW_PAGE_NOT_FOUND));
commit:1b454a1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.CloneableStream;
1: 
1: 
1: import java.io.InputStream;
/////////////////////////////////////////////////////////////////////////
1: implements Resetable, CloneableStream
/////////////////////////////////////////////////////////////////////////
1:     RecordHandle        recordToLock) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 // Simplify this code when we can use the Java 1.5 constructor
0:                 // taking the cause as an argument.
0:                 IOException ioe = new IOException(se.toString());
0:                 ioe.initCause(se);
0:                 throw ioe;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**************************************************************************
1:      * Public Methods of CloneableStream Interface
1:      **************************************************************************/
1: 
1:     /**
1:      * Clone this object.
1:      * <p>
1:      * Creates a deep copy of this object. The returned stream has its own
1:      * working buffers and can be initialized, reset and read independently
1:      * from this stream.
1:      * <p>
1:      * The cloned stream is set back to the beginning of stream, no matter
1:      * where the current stream happens to be positioned.
0:      *
1:      * @return Copy of this stream which can be used independently.
1:      */
1:     public InputStream cloneStream() {
1:         OverflowInputStream ret_stream = 
1:             new OverflowInputStream(
1:                 bh.cloneEmpty(),
1:                 owner, 
1:                 firstOverflowPage, 
1:                 firstOverflowId, 
1:                 recordToLock);
1: 
1:         return(ret_stream);
1:     }
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:f697326
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
1:     // Make sure record is only locked once.
1:     private boolean initialized = false;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Initialize.  Reopen the container. This will have the effect of
0:      * getting an intent shared lock on the table, which will stay around until
0:      * the enclosing blob/clob object is closed, or until the end of the 
0:      * transaction. Also get a read lock on the appropriate row.
0:      * 
0:      * @throws org.apache.derby.iapi.error.StandardException
1:      */
0:         if (initialized) return;
1:         
0:         // it is possible that the transaction in which the stream was
1:                 
0:         We use isolation level READ_COMMITTED and reopen the container to 
0:         get a new container handle to use for locking.  This way, the lock will
0:         be freed when we the container handle is closed. This will happen in
0:         closeStream() or when the transaction commits. 
0:         Hence, locks will be released before the end of transaction if 
0:         blobs/clobs are explicitly released.
0:                 TransactionController.ISOLATION_READ_COMMITTED, true);
/////////////////////////////////////////////////////////////////////////
1:         
0:         initialized = true;
0:       Close the container associated with this stream. (This will also free the 
0:       associated IS table lock and the associated S row lock.)
1:         initialized = false;
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b44abbf
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
0:         // it is possible that the transaction in which the stream was 
0:         // created is committed and no longer valid
0:         // dont want to get NPE but instead throw error that
0:         // container was not opened
0:         if (owner.getTransaction() == null)
0:             throw StandardException.newException(SQLState.DATA_CONTAINER_CLOSED);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.data.OverflowInputStream
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:c6ad534
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.data;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.raw.RecordHandle;
1: 
1: import org.apache.derby.iapi.types.Resetable;
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import java.io.InputStream;
1: import java.io.IOException;
1: 
1: /**
0: 	A OverflowInputStream is used by store to turn a long column
0: 	into an InputStream.
1: */
1: public class OverflowInputStream
1: extends BufferedByteHolderInputStream
0: implements Resetable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	protected BaseContainerHandle owner;
0: 	protected long overflowPage;
0: 	protected int overflowId;
1:     // remember first page and id for reset
0: 	protected long firstOverflowPage;
0: 	protected int firstOverflowId;
1:     // the row to lock for Blobs/Clobs
0:     protected RecordHandle recordToLock;
1: 
0: 	public OverflowInputStream(ByteHolder bh, BaseContainerHandle owner,
0: 		    long overflowPage, int overflowId, RecordHandle recordToLock)
0:         throws IOException, StandardException
1: 	{
0: 		super(bh);
0: 		this.owner = owner;
0: 		this.overflowPage = overflowPage;
0: 		this.overflowId = overflowId;
0: 		this.firstOverflowPage = overflowPage;
0: 		this.firstOverflowId = overflowId;
0:         this.recordToLock = recordToLock;
0: 		fillByteHolder();
1: 	}
1: 
1: 
0: 	public void fillByteHolder() throws IOException
1: 	{
0: 		if ((this.bh.available() == 0) && (this.overflowPage != -1))
1:         {
1: 			this.bh.clear();
1: 
0: 			try
1:             {
0: 				// fill the byte holder with data from the page.
0: 				BasePage columnOverflowPage = ((BasePage) this.owner.getPage(overflowPage));
1: 
0: 				if (columnOverflowPage != null)
1:                 {
0: 					columnOverflowPage.restorePortionLongColumn(this);
0: 					columnOverflowPage.unlatch();
0: 					columnOverflowPage = null;
1: 				}
1: 			}
1:             catch (StandardException se)
1:             {
0: 				throw new IOException( se.toString() );
1: 			}
1: 			this.bh.startReading();
1: 		}
1: 	}
1: 
1: 
0: 	public long getOverflowPage() {
0: 		return this.overflowPage;
1: 	}
1: 
0: 	public int getOverflowId() {
0: 		return this.overflowId;
1: 	}
1: 
0: 	public void setOverflowPage(long overflowPage) {
0: 		this.overflowPage = overflowPage;
1: 	}
1: 
0: 	public void setOverflowId(int overflowId) {
0: 		this.overflowId = overflowId;
1: 	}
1: 
1: 
1:     /*
0:      Methods of Resetable interface.
1:     */
1: 
1:     /*
0:      Resets the stream to the beginning.
1:      */
1:     public void resetStream() throws IOException, StandardException
1:     {
1:         // check the container is open, this is needed to make sure the
1:         // container closed exception is thrown as a StandardException and not
1:         // as an IOException
1:         owner.checkOpen();
1:         // return to the original overflow page and id
0: 		this.overflowPage = firstOverflowPage;
0: 		this.overflowId = firstOverflowId;
1:         // completely clear the byte holder
1:         this.bh.clear();
1:         this.bh.startReading();
0:         // fill the byte holder
0: 		fillByteHolder();
1:     }
1: 
1:     /*
0:       Initialize.  Reopen the container. This will have the effect of
0:       getting an intent shared lock on the table, which will stay around until
0:       the end of the transaction (or until the enclosing blob/clob object is
0:       closed). Also get a read lock on the appropriate row.
1:     */
0:     public void initStream() throws StandardException
1:     {
1:         /*
0:         We might want to use the mode and isolation level of the container.
0:         This would have the advantage that, if the isolation level
0:         is READ_COMMITTED, resources would be freed if blobs/clob finalizers are
0:         called (e.g. they are garbage collected) before the end of transaction.
0:         If the mode was MODE_CONTAINER, openContainer would get an S lock on the
0:         table instead of an IS lock, and lockRecordForRead would have no effect.
1: 
0:         To do this, need to consider:
0:         Sometimes the container's locking policy may NOT reflect the correct
0:         locking policy. For example, if the container is a table (not an index)
0:         and Access handles the locking of the table via an index, the container's
0:         locking policy would be set to do no locking.
0:         Moreover, if the container is an index, the locking policy would
0:         always be set to do no locking.
1:         */
1: 
0:         LockingPolicy lp = 
0:             owner.getTransaction().newLockingPolicy(
0:                 LockingPolicy.MODE_RECORD, 
0:                 TransactionController.ISOLATION_REPEATABLE_READ, true);
1: 
0:         // reopen the container
0:         owner = (BaseContainerHandle) owner.getTransaction().openContainer(
0:             owner.getId(), lp, owner.getMode());
1: 
0:         // get a read lock on the appropriate row
0:         // this will wait until either the lock is granted or an exception is
0:         // thrown
0:         owner.getLockingPolicy().lockRecordForRead(
0:             owner.getTransaction(), owner, recordToLock, true, false);
1:     }
1: 
1: 
1:     /*
0:       Close the container associated with this stream. (In the future if we use
0:       a read committed isolation mode, this will also free the associated IS
0:       table lock and the associated S row lock.)
1:     */
1:     public void closeStream()
1:     {
1:         owner.close();
1:     }
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.data;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: 
0: import org.apache.derby.iapi.types.Resetable;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import java.io.InputStream;
0: import java.io.IOException;
0: 
0: /**
0: 	A OverflowInputStream is used by store to turn a long column
0: 	into an InputStream.
0: */
0: public class OverflowInputStream
0: extends BufferedByteHolderInputStream
0: implements Resetable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	protected BaseContainerHandle owner;
0: 	protected long overflowPage;
0: 	protected int overflowId;
0:     // remember first page and id for reset
0: 	protected long firstOverflowPage;
0: 	protected int firstOverflowId;
0:     // the row to lock for Blobs/Clobs
0:     protected RecordHandle recordToLock;
0: 
0: 	public OverflowInputStream(ByteHolder bh, BaseContainerHandle owner,
0: 		    long overflowPage, int overflowId, RecordHandle recordToLock)
0:         throws IOException, StandardException
0: 	{
0: 		super(bh);
0: 		this.owner = owner;
0: 		this.overflowPage = overflowPage;
0: 		this.overflowId = overflowId;
0: 		this.firstOverflowPage = overflowPage;
0: 		this.firstOverflowId = overflowId;
0:         this.recordToLock = recordToLock;
0: 		fillByteHolder();
0: 	}
0: 
0: 
0: 	public void fillByteHolder() throws IOException
0: 	{
0: 		if ((this.bh.available() == 0) && (this.overflowPage != -1))
0:         {
0: 			this.bh.clear();
0: 
0: 			try
0:             {
0: 				// fill the byte holder with data from the page.
0: 				BasePage columnOverflowPage = ((BasePage) this.owner.getPage(overflowPage));
0: 
0: 				if (columnOverflowPage != null)
0:                 {
0: 					columnOverflowPage.restorePortionLongColumn(this);
0: 					columnOverflowPage.unlatch();
0: 					columnOverflowPage = null;
0: 				}
0: 			}
0:             catch (StandardException se)
0:             {
0: 				throw new IOException( se.toString() );
0: 			}
0: 			this.bh.startReading();
0: 		}
0: 	}
0: 
0: 
0: 	public long getOverflowPage() {
0: 		return this.overflowPage;
0: 	}
0: 
0: 	public int getOverflowId() {
0: 		return this.overflowId;
0: 	}
0: 
0: 	public void setOverflowPage(long overflowPage) {
0: 		this.overflowPage = overflowPage;
0: 	}
0: 
0: 	public void setOverflowId(int overflowId) {
0: 		this.overflowId = overflowId;
0: 	}
0: 
0: 
0:     /*
0:      Methods of Resetable interface.
0:     */
0: 
0:     /*
0:      Resets the stream to the beginning.
0:      */
0:     public void resetStream() throws IOException, StandardException
0:     {
0:         // check the container is open, this is needed to make sure the
0:         // container closed exception is thrown as a StandardException and not
0:         // as an IOException
0:         owner.checkOpen();
0:         // return to the original overflow page and id
0: 		this.overflowPage = firstOverflowPage;
0: 		this.overflowId = firstOverflowId;
0:         // completely clear the byte holder
0:         this.bh.clear();
0:         this.bh.startReading();
0:         // fill the byte holder
0: 		fillByteHolder();
0:     }
0: 
0:     /*
0:       Initialize.  Reopen the container. This will have the effect of
0:       getting an intent shared lock on the table, which will stay around until
0:       the end of the transaction (or until the enclosing blob/clob object is
0:       closed). Also get a read lock on the appropriate row.
0:     */
0:     public void initStream() throws StandardException
0:     {
0:         /*
0:         We might want to use the mode and isolation level of the container.
0:         This would have the advantage that, if the isolation level
0:         is READ_COMMITTED, resources would be freed if blobs/clob finalizers are
0:         called (e.g. they are garbage collected) before the end of transaction.
0:         If the mode was MODE_CONTAINER, openContainer would get an S lock on the
0:         table instead of an IS lock, and lockRecordForRead would have no effect.
0: 
0:         To do this, need to consider:
0:         Sometimes the container's locking policy may NOT reflect the correct
0:         locking policy. For example, if the container is a table (not an index)
0:         and Access handles the locking of the table via an index, the container's
0:         locking policy would be set to do no locking.
0:         Moreover, if the container is an index, the locking policy would
0:         always be set to do no locking.
0:         */
0: 
0:         LockingPolicy lp = 
0:             owner.getTransaction().newLockingPolicy(
0:                 LockingPolicy.MODE_RECORD, 
0:                 TransactionController.ISOLATION_REPEATABLE_READ, true);
0: 
0:         // reopen the container
0:         owner = (BaseContainerHandle) owner.getTransaction().openContainer(
0:             owner.getId(), lp, owner.getMode());
0: 
0:         // get a read lock on the appropriate row
0:         // this will wait until either the lock is granted or an exception is
0:         // thrown
0:         owner.getLockingPolicy().lockRecordForRead(
0:             owner.getTransaction(), owner, recordToLock, true, false);
0:     }
0: 
0: 
0:     /*
0:       Close the container associated with this stream. (In the future if we use
0:       a read committed isolation mode, this will also free the associated IS
0:       table lock and the associated S row lock.)
0:     */
0:     public void closeStream()
0:     {
0:         owner.close();
0:     }
0: 
0: }
============================================================================