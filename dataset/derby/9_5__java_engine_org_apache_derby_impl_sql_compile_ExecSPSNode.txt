8:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.ExecSPSNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
38:eac0369: 
9:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:afe6225: import org.apache.derby.iapi.services.loader.GeneratedClass;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:afe6225: import org.apache.derby.iapi.sql.ResultDescription;
1:69f8afa: import org.apache.derby.iapi.sql.compile.Visitor;
1:afe6225: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:afe6225: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
1:afe6225: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1:eac0369: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: import org.apache.derby.iapi.util.ByteArray;
1:eac0369: 
1:eac0369: 
2:eac0369: /**
1:eac0369:  * A ExecSPSNode is the root of a QueryTree 
1:eac0369:  * that represents an EXECUTE STATEMENT
1:3bb140c:  * statement.  It is a tad abnormal.  During a
1:eac0369:  * bind, it locates and retrieves the SPSDescriptor
1:eac0369:  * for the particular statement.  At generate time,
1:eac0369:  * it generates the prepared statement for the 
1:eac0369:  * stored prepared statement and returns it (i.e.
1:eac0369:  * it effectively replaces itself with the appropriate
1:eac0369:  * prepared statement).
2:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:3bb140c: class ExecSPSNode extends StatementNode
10:eac0369: {
1:eac0369: 	private TableName			name;
1:eac0369: 	private SPSDescriptor		spsd;
1:eac0369: 	private ExecPreparedStatement ps;
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for a ExecSPSNode
1:eac0369: 	 *
1:eac0369: 	 * @param newObjectName		The name of the table to be created
1:3bb140c:      * @param cm                The context manager
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     ExecSPSNode(TableName newObjectName,
1:3bb140c:                 ContextManager cm) {
1:3bb140c:         super(cm);
1:3bb140c:         this.name = newObjectName;
12:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this ExecSPSNode.  This means doing any static error
1:eac0369: 	 * checking that can be done before actually creating the table.
1:eac0369: 	 * For example, verifying that the ResultColumnList does not
1:eac0369: 	 * contain any duplicate column names.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:cc770d8: 	public void bindStatement() throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Grab the compiler context each time we bind just
1:eac0369: 		** to make sure we have the write one (even though
1:eac0369: 		** we are caching it).
1:eac0369: 		*/
1:1260b94: 		DataDictionary dd = getDataDictionary();
1:eac0369: 
1:eac0369: 		String schemaName = name.getSchemaName();
1:eac0369: 		SchemaDescriptor sd = getSchemaDescriptor(name.getSchemaName());
1:eac0369: 		if (schemaName == null)
1:eac0369: 			name.setSchemaName(sd.getSchemaName());
1:eac0369: 
1:eac0369: 		if (sd.getUUID() != null)
1:eac0369: 			spsd = dd.getSPSDescriptor(name.getTableName(), sd);
1:eac0369: 
1:eac0369: 		if (spsd == null)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_OBJECT_NOT_FOUND, "STATEMENT", name);
1:eac0369: 		}
1:eac0369: 
1:3bb140c:         if (spsd.getType() == SPSDescriptor.SPS_TYPE_TRIGGER)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_TRIGGER_SPS_CANNOT_BE_EXECED, name);
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** This execute statement is dependent on the
1:eac0369: 		** stored prepared statement.  If for any reason
1:eac0369: 		** the underlying statement is invalidated by
1:eac0369: 		** the time we get to execution, the 'execute statement'
1:eac0369: 		** will get invalidated when the underlying statement
1:eac0369: 		** is invalidated.
1:eac0369: 		*/
1:eac0369: 		getCompilerContext().createDependency(spsd);
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * SPSes are atomic if its underlying statement is
1:eac0369: 	 * atomic.
1:eac0369: 	 *
1:eac0369: 	 * @return true if the statement is atomic
1:eac0369: 	 */	
1:3bb140c:     @Override
1:eac0369: 	public boolean isAtomic()
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(ps != null, 
1:eac0369: 				"statement expected to be bound before calling isAtomic()");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return ps.isAtomic();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do code generation for this statement.  Overrides
1:eac0369: 	 * the normal generation path in StatementNode.
1:eac0369: 	 *
1:eac0369: 	 * @param	ignored - ignored (he he)
1:eac0369: 	 *
1:eac0369: 	 * @return		A GeneratedClass for this statement
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public GeneratedClass generate(ByteArray ignored) throws StandardException
1:eac0369: 	{
1:eac0369: 		//Bug 4821 - commiting the nested transaction will release any bind time locks
1:eac0369: 		//This way we won't get lock time out errors while trying to update sysstatement
1:eac0369: 		//table during stale sps recompilation later in the getPreparedstatement() call.
1:eac0369: 		if (spsd.isValid() == false) {
1:eac0369: 			getLanguageConnectionContext().commitNestedTransaction();
1:eac0369: 			getLanguageConnectionContext().beginNestedTransaction(true);
1:eac0369: 		}  
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** The following does a prepare on the underlying
1:eac0369: 		** statement if necessary.  The returned statement
1:eac0369: 		** is valid and its class is loaded up.
1:eac0369: 		*/
1:eac0369: 		ps = spsd.getPreparedStatement();
1:eac0369: 
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Set the saved constants from the prepared statement.
1:eac0369: 		** Put them in the compilation context -- this is where
1:eac0369: 		** they are expected.
1:eac0369: 		*/
1:eac0369: 		getCompilerContext().setSavedObjects(ps.getSavedObjects());
1:eac0369: 		getCompilerContext().setCursorInfo(ps.getCursorInfo());
1:eac0369: 		GeneratedClass gc = ps.getActivationClass();
1:eac0369: 		
1:eac0369: 		return gc;
1:eac0369: 	}
1:eac0369: 		
1:eac0369: 	/**
1:eac0369: 	 * Make the result description.  Really, we are just
1:eac0369: 	 * copying it from the stored prepared statement.
1:eac0369: 	 *
1:eac0369: 	 * @return	the description
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public ResultDescription makeResultDescription()
1:eac0369: 	{
1:eac0369: 		return ps.getResultDescription();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get information about this cursor.  For sps,
1:eac0369: 	 * this is info saved off of the original query
1:eac0369: 	 * tree (the one for the underlying query).
1:eac0369: 	 *
1:eac0369: 	 * @return	the cursor info
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public Object getCursorInfo()
1:eac0369: 	{
1:eac0369: 		return ps.getCursorInfo();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return a description of the ? parameters for the statement
1:eac0369: 	 * represented by this query tree.  Just return the params
1:eac0369: 	 * stored with the prepared statement.
1:eac0369: 	 *
1:eac0369: 	 * @return	An array of DataTypeDescriptors describing the
1:eac0369: 	 *		? parameters for this statement.  It returns null
1:eac0369: 	 *		if there are no parameters.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public DataTypeDescriptor[]	getParameterTypes() throws StandardException
1:eac0369: 	{
1:eac0369: 		return spsd.getParams();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Create the Constant information that will drive the guts of Execution.
1:eac0369: 	 * This is assumed to be the first action on this node.
1:eac0369: 	 *
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     public ConstantAction makeConstantAction()
1:eac0369: 	{
1:eac0369: 		return ps.getConstantAction();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * We need a savepoint if we will do transactional work.
1:eac0369: 	 * We'll ask the underlying statement if it needs
1:eac0369: 	 * a savepoint and pass that back.  We have to do this
1:eac0369: 	 * after generation because getting the PS now might
1:eac0369: 	 * cause us to basically do DDL (for a stmt recompilation)
1:eac0369: 	 * which is explicitly banned during binding.  So the
1:eac0369: 	 * caller can only call this after generate() has retrieved
1:eac0369: 	 * the target PS.  
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	always true.
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public boolean needsSavepoint()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(ps != null, 
1:eac0369: 				"statement expected to be bound before calling needsSavepoint()");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return ps.needsSavepoint();
1:eac0369: 	}
1:eac0369: 
1:40b6aed: 	/** @see StatementNode#executeStatementName */
1:3bb140c:     @Override
1:eac0369: 	public String executeStatementName()
1:eac0369: 	{
1:eac0369: 		return name.getTableName();
1:eac0369: 	}
1:eac0369: 
1:40b6aed: 	/** @see StatementNode#executeSchemaName */
1:3bb140c:     @Override
1:eac0369: 	public String executeSchemaName()
1:eac0369: 	{
1:eac0369: 		return name.getSchemaName();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the name of the SPS that is used
1:eac0369: 	 * to execute this statement.  Only relevant
1:eac0369: 	 * for an ExecSPSNode -- otherwise, returns null.
1:eac0369: 	 *
1:eac0369: 	 * @return the name of the underlying sps
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String getSPSName()
1:eac0369: 	{
1:eac0369: 		return spsd.getQualifiedName();
1:eac0369: 	}
1:eac0369: 		
1:eac0369: 	/*
1:eac0369: 	 * Shouldn't be called
1:eac0369: 	 */
1:eac0369: 	int activationKind()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT("activationKind not expected "+
1:eac0369: 				"to be called for a stored prepared statement");
1:eac0369: 		}
1:eac0369: 	   return StatementNode.NEED_PARAM_ACTIVATION;
1:eac0369: 	}
1:eac0369: 	/////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// PRIVATE
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 		
1:eac0369: 	/////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// MISC
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////
1:3bb140c:     String statementToString()
1:eac0369: 	{
1:eac0369: 		return "EXECUTE STATEMENT";
1:eac0369: 	}
1:69f8afa: 
1:69f8afa:     @Override
1:69f8afa:     void acceptChildren(Visitor v) throws StandardException {
1:69f8afa:         super.acceptChildren(v);
1:69f8afa: 
1:69f8afa:         if (name != null) {
1:69f8afa:             name = (TableName) name.accept(v);
1:69f8afa:         }
1:69f8afa:     }
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:69f8afa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     void acceptChildren(Visitor v) throws StandardException {
1:         super.acceptChildren(v);
1: 
1:         if (name != null) {
1:             name = (TableName) name.accept(v);
1:         }
1:     }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
/////////////////////////////////////////////////////////////////////////
1:  * statement.  It is a tad abnormal.  During a
/////////////////////////////////////////////////////////////////////////
1: class ExecSPSNode extends StatementNode
1:      * Constructor for a ExecSPSNode
1:      * @param cm                The context manager
1:     ExecSPSNode(TableName newObjectName,
1:                 ContextManager cm) {
1:         super(cm);
0:         setNodeType(C_NodeTypes.EXEC_SPS_NODE);
1:         this.name = newObjectName;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         if (spsd.getType() == SPSDescriptor.SPS_TYPE_TRIGGER)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public ConstantAction makeConstantAction()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     String statementToString()
commit:afe6225
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:40b6aed
/////////////////////////////////////////////////////////////////////////
1: 	/** @see StatementNode#executeStatementName */
1: 	/** @see StatementNode#executeSchemaName */
commit:cc770d8
/////////////////////////////////////////////////////////////////////////
1: 	public void bindStatement() throws StandardException
/////////////////////////////////////////////////////////////////////////
commit:1260b94
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 				Object 		newObjectName)
/////////////////////////////////////////////////////////////////////////
1: 		DataDictionary dd = getDataDictionary();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	private final SPSDescriptor getSPSDescriptor()
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.ExecSPSNode
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
1: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.depend.Dependent;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
1: 
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.sql.PreparedStatement;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.impl.sql.execute.BaseActivation;
0: import org.apache.derby.impl.sql.execute.ColumnInfo;
0: import org.apache.derby.impl.sql.CursorInfo;
1: 
1: import org.apache.derby.iapi.util.ByteArray;
1: 
0: import java.util.Enumeration;
1: 
1: /**
1:  * A ExecSPSNode is the root of a QueryTree 
1:  * that represents an EXECUTE STATEMENT
0:  * statement.  It is a tad abnormal.  Duringa
1:  * bind, it locates and retrieves the SPSDescriptor
1:  * for the particular statement.  At generate time,
1:  * it generates the prepared statement for the 
1:  * stored prepared statement and returns it (i.e.
1:  * it effectively replaces itself with the appropriate
1:  * prepared statement).
1:  *
0:  * @author jamie
1:  */
1: 
0: public class ExecSPSNode extends StatementNode 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	private TableName			name;
1: 	private SPSDescriptor		spsd;
1: 	private ExecPreparedStatement ps;
0: 	private ResultSetNode		usingClause;
0: 	private String				usingText;
1: 
1: 	/**
0: 	 * Initializer for a ExecSPSNode
1: 	 *
1: 	 * @param newObjectName		The name of the table to be created
0: 	 * @param usingClause		The using clause
0: 	 * @param usingText			The text of the using clause
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void init(
0: 				Object 		newObjectName,
0: 				Object	usingClause,
0: 				Object			usingText)
0: 		throws StandardException
1: 	{
0: 		this.name = (TableName) newObjectName;
0: 		this.usingClause = (ResultSetNode) usingClause;
0: 		this.usingText = (String) usingText;
1: 	}
1: 
1: 	/**
1: 	 * Bind this ExecSPSNode.  This means doing any static error
1: 	 * checking that can be done before actually creating the table.
1: 	 * For example, verifying that the ResultColumnList does not
1: 	 * contain any duplicate column names.
1: 	 *
0: 	 * @return	The bound query tree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public QueryTreeNode bind() throws StandardException
1: 	{
0: 		DataDictionary		dd;
1: 
1: 		/*
1: 		** Grab the compiler context each time we bind just
1: 		** to make sure we have the write one (even though
1: 		** we are caching it).
1: 		*/
0: 		dd = getDataDictionary();
1: 
0: 		// bind the using Clause
0: 		if (usingClause != null)
1: 		{
0: 			usingClause.bind();
1: 		}
1: 
1: 		String schemaName = name.getSchemaName();
1: 		SchemaDescriptor sd = getSchemaDescriptor(name.getSchemaName());
1: 		if (schemaName == null)
1: 			name.setSchemaName(sd.getSchemaName());
1: 
1: 		if (sd.getUUID() != null)
1: 			spsd = dd.getSPSDescriptor(name.getTableName(), sd);
1: 
1: 		if (spsd == null)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_OBJECT_NOT_FOUND, "STATEMENT", name);
1: 		}
1: 
0: 		if (spsd.getType() == spsd.SPS_TYPE_TRIGGER)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_TRIGGER_SPS_CANNOT_BE_EXECED, name);
1: 		}
1: 		
1: 
1: 		/*
1: 		** This execute statement is dependent on the
1: 		** stored prepared statement.  If for any reason
1: 		** the underlying statement is invalidated by
1: 		** the time we get to execution, the 'execute statement'
1: 		** will get invalidated when the underlying statement
1: 		** is invalidated.
1: 		*/
1: 		getCompilerContext().createDependency(spsd);
1: 
0: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * SPSes are atomic if its underlying statement is
1: 	 * atomic.
1: 	 *
1: 	 * @return true if the statement is atomic
1: 	 */	
1: 	public boolean isAtomic()
1: 	{
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(ps != null, 
1: 				"statement expected to be bound before calling isAtomic()");
1: 		}
1: 
1: 		return ps.isAtomic();
1: 	}
1: 
1: 	/**
1: 	 * Do code generation for this statement.  Overrides
1: 	 * the normal generation path in StatementNode.
1: 	 *
1: 	 * @param	ignored - ignored (he he)
1: 	 *
1: 	 * @return		A GeneratedClass for this statement
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public GeneratedClass generate(ByteArray ignored) throws StandardException
1: 	{
1: 		//Bug 4821 - commiting the nested transaction will release any bind time locks
1: 		//This way we won't get lock time out errors while trying to update sysstatement
1: 		//table during stale sps recompilation later in the getPreparedstatement() call.
1: 		if (spsd.isValid() == false) {
1: 			getLanguageConnectionContext().commitNestedTransaction();
1: 			getLanguageConnectionContext().beginNestedTransaction(true);
1: 		}  
1: 
1: 		/*
1: 		** The following does a prepare on the underlying
1: 		** statement if necessary.  The returned statement
1: 		** is valid and its class is loaded up.
1: 		*/
1: 		ps = spsd.getPreparedStatement();
1: 
1: 
1: 		/*
1: 		** Set the saved constants from the prepared statement.
1: 		** Put them in the compilation context -- this is where
1: 		** they are expected.
1: 		*/
1: 		getCompilerContext().setSavedObjects(ps.getSavedObjects());
1: 		getCompilerContext().setCursorInfo(ps.getCursorInfo());
1: 		GeneratedClass gc = ps.getActivationClass();
1: 
1: 		/*
0: 		** Set up the params for our using clause.
1: 		*/
0: 		setupParams();
1: 		
1: 		return gc;
1: 	}
1: 		
1: 	/**
1: 	 * Make the result description.  Really, we are just
1: 	 * copying it from the stored prepared statement.
1: 	 *
1: 	 * @return	the description
1: 	 */
1: 	public ResultDescription makeResultDescription()
1: 	{
1: 		return ps.getResultDescription();
1: 	}
1: 
1: 	/**
1: 	 * Get information about this cursor.  For sps,
1: 	 * this is info saved off of the original query
1: 	 * tree (the one for the underlying query).
1: 	 *
1: 	 * @return	the cursor info
1: 	 */
1: 	public Object getCursorInfo()
1: 	{
1: 		return ps.getCursorInfo();
1: 	}
1: 
1: 	/**
1: 	 * Return a description of the ? parameters for the statement
1: 	 * represented by this query tree.  Just return the params
1: 	 * stored with the prepared statement.
1: 	 *
1: 	 * @return	An array of DataTypeDescriptors describing the
1: 	 *		? parameters for this statement.  It returns null
1: 	 *		if there are no parameters.
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public DataTypeDescriptor[]	getParameterTypes() throws StandardException
1: 	{
1: 		return spsd.getParams();
1: 	}
1: 
1: 
1: 	/**
1: 	 * Create the Constant information that will drive the guts of Execution.
1: 	 * This is assumed to be the first action on this node.
1: 	 *
1: 	 */
0: 	public ConstantAction	makeConstantAction()
1: 	{
1: 		return ps.getConstantAction();
1: 	}
1: 
1: 	/**
1: 	 * We need a savepoint if we will do transactional work.
1: 	 * We'll ask the underlying statement if it needs
1: 	 * a savepoint and pass that back.  We have to do this
1: 	 * after generation because getting the PS now might
1: 	 * cause us to basically do DDL (for a stmt recompilation)
1: 	 * which is explicitly banned during binding.  So the
1: 	 * caller can only call this after generate() has retrieved
1: 	 * the target PS.  
1: 	 *
1: 	 * @return boolean	always true.
1: 	 */
1: 	public boolean needsSavepoint()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(ps != null, 
1: 				"statement expected to be bound before calling needsSavepoint()");
1: 		}
1: 
1: 		return ps.needsSavepoint();
1: 	}
1: 
0: 	/** @see QueryTreeNode#executeStatementName */
1: 	public String executeStatementName()
1: 	{
1: 		return name.getTableName();
1: 	}
1: 
0: 	/** @see QueryTreeNode#executeSchemaName */
1: 	public String executeSchemaName()
1: 	{
1: 		return name.getSchemaName();
1: 	}
1: 
1: 	/**
1: 	 * Get the name of the SPS that is used
1: 	 * to execute this statement.  Only relevant
1: 	 * for an ExecSPSNode -- otherwise, returns null.
1: 	 *
1: 	 * @return the name of the underlying sps
1: 	 */
1: 	public String getSPSName()
1: 	{
1: 		return spsd.getQualifiedName();
1: 	}
1: 		
1: 	/*
1: 	 * Shouldn't be called
1: 	 */
1: 	int activationKind()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT("activationKind not expected "+
1: 				"to be called for a stored prepared statement");
1: 		}
1: 	   return StatementNode.NEED_PARAM_ACTIVATION;
1: 	}
1: 	/////////////////////////////////////////////////////////////////////
1: 	//
1: 	// PRIVATE
1: 	//
1: 	/////////////////////////////////////////////////////////////////////
1: 	/*
0: 	** Set up the parameters for this node.  Takes
0: 	** the usingClause and executes it.  The results
0: 	** are used to set the parameters for the
0: 	** statement.
1: 	*/
0: 	private void setupParams() throws StandardException
1: 	{
0: 		if (usingClause == null)
0: 			return;
1: 
0: 		DataTypeDescriptor[] types = spsd.getParams();
1: 		/*
0: 		** If the sps doesn't support any 
0: 		** parameters, then don't bother.
1: 		*/
0: 		if (types == null) 
1: 		{
0: 			return;
1: 		}
1: 
1: 		/*
0: 		** Get the results the easy way: create
0: 		** a statement from the text and execute
0: 		** it.
1: 		*/
0: 		LanguageConnectionContext lcc = getLanguageConnectionContext();
1: 
0: 		PreparedStatement ps = lcc.prepareInternalStatement(usingText);
1: 	
0: 		ResultSet rs = ps.execute(lcc, false);
1: 		
0: 		try {
0: 			ExecRow row = rs.getNextRow();
0: 			if (row == null)
1: 			{
0: 				throw StandardException.newException(SQLState.LANG_NO_ROWS_FROM_USING);
1: 			}
1: 
1: 			/*
0: 			** Get the row and set the parameters based on that
1: 			*/
0: 			ParameterValueSet params = lcc.getLanguageFactory().newParameterValueSet(
0: 				lcc.getLanguageConnectionFactory().getClassFactory().getClassInspector(), types.length, false);
1: 
0: 			DataValueDescriptor[] rowArray = row.getRowArray();
0: 			// Check at compile time that the using clause has the correct number of parameters.
0: 			if (rowArray.length != types.length) {
0: 				throw StandardException.newException(SQLState.LANG_NUM_PARAMS_INCORRECT,
0: 					Integer.toString(rowArray.length), Integer.toString(types.length));
1: 			}
1: 
0: 			for (int i = 0; i < types.length; i++)
1: 			{
0: 				TypeId typeId = types[i].getTypeId();
1: 
0: 				params.setStorableDataValue( 
0: 					typeId.getNull(),
0: 					i, typeId.getJDBCTypeId(), typeId.getCorrespondingJavaTypeName());
1: 
0: 				params.getParameterForSet(i).setValue(rowArray[i]);
1: 			}
1: 
1: 			/*
0: 			** If there are any other rows, then throw an
0: 			** exception
1: 			*/
0: 			if (rs.getNextRow() != null)
1: 			{
0: 				throw StandardException.newException(SQLState.LANG_USING_CARDINALITY_VIOLATION);
1: 			}
0: 			//bug 4552 - "exec statement using" will return no parameters through parametermetadata
0: 			params.setUsingParameterValueSet();
1: 
1: 			/*
0: 			** Stash the parameters in the compiler context
1: 			*/	
0: 			getCompilerContext().setParams(params); 
1: 		}
0: 		finally {
1: 
0: 			rs.close();
1: 		}
1: 
1: 
1: 
1: 
1: 	}
1: 		
1: 	/////////////////////////////////////////////////////////////////////
1: 	//
1: 	// MISC
1: 	//
1: 	/////////////////////////////////////////////////////////////////////
0: 	public String statementToString()
1: 	{
1: 		return "EXECUTE STATEMENT";
1: 	}
1: 
0: 	// called after bind only
0: 	SPSDescriptor getSPSDescriptor()
1: 	{
0: 		return spsd;
1: 	}
1: 
0: 	String getUsingText()
1: 	{
0: 		return usingText;
1: 	}
1: }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:871a533
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
0: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.sql.PreparedStatement;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.impl.sql.execute.BaseActivation;
0: import org.apache.derby.impl.sql.execute.ColumnInfo;
0: import org.apache.derby.impl.sql.CursorInfo;
0: 
0: import org.apache.derby.iapi.util.ByteArray;
0: 
0: import java.util.Enumeration;
0: 
0: /**
0:  * A ExecSPSNode is the root of a QueryTree 
0:  * that represents an EXECUTE STATEMENT
0:  * statement.  It is a tad abnormal.  Duringa
0:  * bind, it locates and retrieves the SPSDescriptor
0:  * for the particular statement.  At generate time,
0:  * it generates the prepared statement for the 
0:  * stored prepared statement and returns it (i.e.
0:  * it effectively replaces itself with the appropriate
0:  * prepared statement).
0:  *
0:  * @author jamie
0:  */
0: 
0: public class ExecSPSNode extends StatementNode 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	private TableName			name;
0: 	private SPSDescriptor		spsd;
0: 	private ExecPreparedStatement ps;
0: 	private ResultSetNode		usingClause;
0: 	private String				usingText;
0: 
0: 	/**
0: 	 * Initializer for a ExecSPSNode
0: 	 *
0: 	 * @param newObjectName		The name of the table to be created
0: 	 * @param usingClause		The using clause
0: 	 * @param usingText			The text of the using clause
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void init(
0: 				Object 		newObjectName,
0: 				Object	usingClause,
0: 				Object			usingText)
0: 		throws StandardException
0: 	{
0: 		this.name = (TableName) newObjectName;
0: 		this.usingClause = (ResultSetNode) usingClause;
0: 		this.usingText = (String) usingText;
0: 	}
0: 
0: 	/**
0: 	 * Bind this ExecSPSNode.  This means doing any static error
0: 	 * checking that can be done before actually creating the table.
0: 	 * For example, verifying that the ResultColumnList does not
0: 	 * contain any duplicate column names.
0: 	 *
0: 	 * @return	The bound query tree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public QueryTreeNode bind() throws StandardException
0: 	{
0: 		DataDictionary		dd;
0: 
0: 		/*
0: 		** Grab the compiler context each time we bind just
0: 		** to make sure we have the write one (even though
0: 		** we are caching it).
0: 		*/
0: 		dd = getDataDictionary();
0: 
0: 		// bind the using Clause
0: 		if (usingClause != null)
0: 		{
0: 			usingClause.bind();
0: 		}
0: 
0: 		String schemaName = name.getSchemaName();
0: 		SchemaDescriptor sd = getSchemaDescriptor(name.getSchemaName());
0: 		if (schemaName == null)
0: 			name.setSchemaName(sd.getSchemaName());
0: 
0: 		if (sd.getUUID() != null)
0: 			spsd = dd.getSPSDescriptor(name.getTableName(), sd);
0: 
0: 		if (spsd == null)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_OBJECT_NOT_FOUND, "STATEMENT", name);
0: 		}
0: 
0: 		if (spsd.getType() == spsd.SPS_TYPE_TRIGGER)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_TRIGGER_SPS_CANNOT_BE_EXECED, name);
0: 		}
0: 		
0: 
0: 		/*
0: 		** This execute statement is dependent on the
0: 		** stored prepared statement.  If for any reason
0: 		** the underlying statement is invalidated by
0: 		** the time we get to execution, the 'execute statement'
0: 		** will get invalidated when the underlying statement
0: 		** is invalidated.
0: 		*/
0: 		getCompilerContext().createDependency(spsd);
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * SPSes are atomic if its underlying statement is
0: 	 * atomic.
0: 	 *
0: 	 * @return true if the statement is atomic
0: 	 */	
0: 	public boolean isAtomic()
0: 	{
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(ps != null, 
0: 				"statement expected to be bound before calling isAtomic()");
0: 		}
0: 
0: 		return ps.isAtomic();
0: 	}
0: 
0: 	/**
0: 	 * Do code generation for this statement.  Overrides
0: 	 * the normal generation path in StatementNode.
0: 	 *
0: 	 * @param	ignored - ignored (he he)
0: 	 *
0: 	 * @return		A GeneratedClass for this statement
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public GeneratedClass generate(ByteArray ignored) throws StandardException
0: 	{
0: 		//Bug 4821 - commiting the nested transaction will release any bind time locks
0: 		//This way we won't get lock time out errors while trying to update sysstatement
0: 		//table during stale sps recompilation later in the getPreparedstatement() call.
0: 		if (spsd.isValid() == false) {
0: 			getLanguageConnectionContext().commitNestedTransaction();
0: 			getLanguageConnectionContext().beginNestedTransaction(true);
0: 		}  
0: 
0: 		/*
0: 		** The following does a prepare on the underlying
0: 		** statement if necessary.  The returned statement
0: 		** is valid and its class is loaded up.
0: 		*/
0: 		ps = spsd.getPreparedStatement();
0: 
0: 
0: 		/*
0: 		** Set the saved constants from the prepared statement.
0: 		** Put them in the compilation context -- this is where
0: 		** they are expected.
0: 		*/
0: 		getCompilerContext().setSavedObjects(ps.getSavedObjects());
0: 		getCompilerContext().setCursorInfo(ps.getCursorInfo());
0: 		GeneratedClass gc = ps.getActivationClass();
0: 
0: 		/*
0: 		** Set up the params for our using clause.
0: 		*/
0: 		setupParams();
0: 		
0: 		return gc;
0: 	}
0: 		
0: 	/**
0: 	 * Make the result description.  Really, we are just
0: 	 * copying it from the stored prepared statement.
0: 	 *
0: 	 * @return	the description
0: 	 */
0: 	public ResultDescription makeResultDescription()
0: 	{
0: 		return ps.getResultDescription();
0: 	}
0: 
0: 	/**
0: 	 * Get information about this cursor.  For sps,
0: 	 * this is info saved off of the original query
0: 	 * tree (the one for the underlying query).
0: 	 *
0: 	 * @return	the cursor info
0: 	 */
0: 	public Object getCursorInfo()
0: 	{
0: 		return ps.getCursorInfo();
0: 	}
0: 
0: 	/**
0: 	 * Return a description of the ? parameters for the statement
0: 	 * represented by this query tree.  Just return the params
0: 	 * stored with the prepared statement.
0: 	 *
0: 	 * @return	An array of DataTypeDescriptors describing the
0: 	 *		? parameters for this statement.  It returns null
0: 	 *		if there are no parameters.
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public DataTypeDescriptor[]	getParameterTypes() throws StandardException
0: 	{
0: 		return spsd.getParams();
0: 	}
0: 
0: 
0: 	/**
0: 	 * Create the Constant information that will drive the guts of Execution.
0: 	 * This is assumed to be the first action on this node.
0: 	 *
0: 	 */
0: 	public ConstantAction	makeConstantAction()
0: 	{
0: 		return ps.getConstantAction();
0: 	}
0: 
0: 	/**
0: 	 * We need a savepoint if we will do transactional work.
0: 	 * We'll ask the underlying statement if it needs
0: 	 * a savepoint and pass that back.  We have to do this
0: 	 * after generation because getting the PS now might
0: 	 * cause us to basically do DDL (for a stmt recompilation)
0: 	 * which is explicitly banned during binding.  So the
0: 	 * caller can only call this after generate() has retrieved
0: 	 * the target PS.  
0: 	 *
0: 	 * @return boolean	always true.
0: 	 */
0: 	public boolean needsSavepoint()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(ps != null, 
0: 				"statement expected to be bound before calling needsSavepoint()");
0: 		}
0: 
0: 		return ps.needsSavepoint();
0: 	}
0: 
0: 	/** @see QueryTreeNode#executeStatementName */
0: 	public String executeStatementName()
0: 	{
0: 		return name.getTableName();
0: 	}
0: 
0: 	/** @see QueryTreeNode#executeSchemaName */
0: 	public String executeSchemaName()
0: 	{
0: 		return name.getSchemaName();
0: 	}
0: 
0: 	/**
0: 	 * Get the name of the SPS that is used
0: 	 * to execute this statement.  Only relevant
0: 	 * for an ExecSPSNode -- otherwise, returns null.
0: 	 *
0: 	 * @return the name of the underlying sps
0: 	 */
0: 	public String getSPSName()
0: 	{
0: 		return spsd.getQualifiedName();
0: 	}
0: 		
0: 	/*
0: 	 * Shouldn't be called
0: 	 */
0: 	int activationKind()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("activationKind not expected "+
0: 				"to be called for a stored prepared statement");
0: 		}
0: 	   return StatementNode.NEED_PARAM_ACTIVATION;
0: 	}
0: 	/////////////////////////////////////////////////////////////////////
0: 	//
0: 	// PRIVATE
0: 	//
0: 	/////////////////////////////////////////////////////////////////////
0: 	/*
0: 	** Set up the parameters for this node.  Takes
0: 	** the usingClause and executes it.  The results
0: 	** are used to set the parameters for the
0: 	** statement.
0: 	*/
0: 	private void setupParams() throws StandardException
0: 	{
0: 		if (usingClause == null)
0: 			return;
0: 
0: 		DataTypeDescriptor[] types = spsd.getParams();
0: 		/*
0: 		** If the sps doesn't support any 
0: 		** parameters, then don't bother.
0: 		*/
0: 		if (types == null) 
0: 		{
0: 			return;
0: 		}
0: 
0: 		/*
0: 		** Get the results the easy way: create
0: 		** a statement from the text and execute
0: 		** it.
0: 		*/
0: 		LanguageConnectionContext lcc = getLanguageConnectionContext();
0: 
0: 		PreparedStatement ps = lcc.prepareInternalStatement(usingText);
0: 	
0: 		ResultSet rs = ps.execute(lcc, false);
0: 		
0: 		try {
0: 			ExecRow row = rs.getNextRow();
0: 			if (row == null)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_NO_ROWS_FROM_USING);
0: 			}
0: 
0: 			/*
0: 			** Get the row and set the parameters based on that
0: 			*/
0: 			ParameterValueSet params = lcc.getLanguageFactory().newParameterValueSet(
0: 				lcc.getLanguageConnectionFactory().getClassFactory().getClassInspector(), types.length, false);
0: 
0: 			DataValueDescriptor[] rowArray = row.getRowArray();
0: 			// Check at compile time that the using clause has the correct number of parameters.
0: 			if (rowArray.length != types.length) {
0: 				throw StandardException.newException(SQLState.LANG_NUM_PARAMS_INCORRECT,
0: 					Integer.toString(rowArray.length), Integer.toString(types.length));
0: 			}
0: 
0: 			for (int i = 0; i < types.length; i++)
0: 			{
0: 				TypeId typeId = types[i].getTypeId();
0: 
0: 				params.setStorableDataValue( 
0: 					typeId.getNull(),
0: 					i, typeId.getJDBCTypeId(), typeId.getCorrespondingJavaTypeName());
0: 
0: 				params.getParameterForSet(i).setValue(rowArray[i]);
0: 			}
0: 
0: 			/*
0: 			** If there are any other rows, then throw an
0: 			** exception
0: 			*/
0: 			if (rs.getNextRow() != null)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_USING_CARDINALITY_VIOLATION);
0: 			}
0: 			//bug 4552 - "exec statement using" will return no parameters through parametermetadata
0: 			params.setUsingParameterValueSet();
0: 
0: 			/*
0: 			** Stash the parameters in the compiler context
0: 			*/	
0: 			getCompilerContext().setParams(params); 
0: 		}
0: 		finally {
0: 
0: 			rs.close();
0: 		}
0: 
0: 
0: 
0: 
0: 	}
0: 		
0: 	/////////////////////////////////////////////////////////////////////
0: 	//
0: 	// MISC
0: 	//
0: 	/////////////////////////////////////////////////////////////////////
0: 	public String statementToString()
0: 	{
0: 		return "EXECUTE STATEMENT";
0: 	}
0: 
0: 	// called after bind only
0: 	SPSDescriptor getSPSDescriptor()
0: 	{
0: 		return spsd;
0: 	}
0: 
0: 	String getUsingText()
0: 	{
0: 		return usingText;
0: 	}
0: }
============================================================================