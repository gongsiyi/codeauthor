2:67614ad: /*
6:67614ad: 
1:f68f62f:    Derby - Class org.apache.derbyTesting.functionTests.tests.tools.dblook_test
1:67614ad: 
1:dff95a1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:dff95a1:    contributor license agreements.  See the NOTICE file distributed with
1:dff95a1:    this work for additional information regarding copyright ownership.
1:dff95a1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:dff95a1:    (the "License"); you may not use this file except in compliance with
1:dff95a1:    the License.  You may obtain a copy of the License at
1:67614ad: 
1:f68f62f:       http://www.apache.org/licenses/LICENSE-2.0
1:67614ad: 
1:f68f62f:    Unless required by applicable law or agreed to in writing, software
1:f68f62f:    distributed under the License is distributed on an "AS IS" BASIS,
1:f68f62f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f68f62f:    See the License for the specific language governing permissions and
1:f68f62f:    limitations under the License.
1:67614ad: 
2:67614ad:  */
1:67614ad: 
1:67614ad: package org.apache.derbyTesting.functionTests.tests.tools;
1:67614ad: 
1:67614ad: import java.sql.DriverManager;
1:67614ad: import java.sql.ResultSet;
1:67614ad: import java.sql.Connection;
1:67614ad: import java.sql.Statement;
1:67614ad: import java.sql.ResultSetMetaData;
1:67614ad: import java.sql.SQLException;
1:67614ad: import java.io.BufferedReader;
1:67614ad: import java.io.FileReader;
1:67614ad: import java.io.File;
1:67614ad: 
1:67614ad: import org.apache.derby.tools.dblook;
1:67614ad: import org.apache.derby.catalog.DependableFinder;
1:0bbfdac: import org.apache.derbyTesting.functionTests.util.TestUtil;
1:67614ad: 
1:67614ad: 
1:67614ad: 
1:67614ad: import java.util.HashMap;
1:67614ad: import java.util.TreeMap;
1:67614ad: import java.util.Set;
1:67614ad: import java.util.ArrayList;
1:67614ad: 
1:67614ad: public class dblook_test {
1:67614ad: 
1:67614ad: 	private static final int SERVER_PORT = 1527;
1:67614ad: 	private static final int FRONT = -1;
1:67614ad: 	private static final int REAR = 1;
1:67614ad: 
1:97cb351: 	protected static final String dbCreationScript_1 = "dblook_makeDB.sql";
1:97cb351: 	protected static final String dbCreationScript_2 = "dblook_makeDB_2.sql";
1:67614ad: 	private static final char TEST_DELIMITER='#';
1:67614ad: 
1:6a85bc6: 	protected static String testDirectory = "dblook_test";
1:cd8191c: 	protected static String testDBName = "wombat";
1:67614ad: 	protected static String separator;
1:67614ad: 
1:67614ad: 	private static String dbPath;
1:67614ad: 	private static int duplicateCounter = 0;
1:67614ad: 	private static int sysNameCount = 0;
1:67614ad: 	private static String jdbcProtocol;
1:cd8191c: 	protected static String territoryBased = "";
1:cd8191c: 	protected static String expectedCollation = "UCS_BASIC";
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * main:
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	public static void main (String[] args) {
1:67614ad: 
1:67614ad: 		separator = System.getProperty("file.separator");
1:67614ad: 		new dblook_test().doTest();
1:67614ad: 		System.out.println("\n[ Done. ]\n");
1:cd8191c: 		renameDbLookLog("dblook_test");
1:67614ad: 
3:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * doTest
1:67614ad: 	 * Run a full test of the dblook utility.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	protected void doTest() {
1:67614ad: 
2:67614ad: 		try {
1:67614ad: 
1:97cb351: 			// Test full dblook functionality.
1:97cb351: 			System.out.println("\n-= Start dblook Functional Tests. =-");
1:97cb351: 			createTestDatabase(dbCreationScript_1);
1:97cb351: 			runDBLook(testDBName);
1:97cb351: 
1:97cb351: 			// Test dblook messages.
1:97cb351: 			System.out.println("\n-= Start dblook Message Tests =-");
1:97cb351: 			createTestDatabase(dbCreationScript_2);
1:97cb351: 			runMessageCheckTest(testDBName);
1:67614ad: 
1:0d4cef5:             // Test DERBY-6387 - wrong order of triggers
1:0d4cef5:             System.out.println("\n-= Start DERBY-6387 test. =-");
1:0d4cef5:             testDerby6387();
1:0d4cef5: 
1:67614ad: 		} catch (SQLException se) {
1:67614ad: 
1:67614ad: 			System.out.println("FAILED: to complete the test:");
1:97cb351: 			se.printStackTrace(System.out);
1:67614ad: 			for (se = se.getNextException(); se != null;
1:67614ad: 				se = se.getNextException())
1:67614ad: 			{
1:97cb351: 				se.printStackTrace(System.out);
1:67614ad: 			}
1:67614ad: 		
2:67614ad: 		} catch (Exception e) {
1:67614ad: 
1:67614ad: 			System.out.println("FAILED: to complete the test:");
1:97cb351: 			e.printStackTrace(System.out);
1:67614ad: 
1:67614ad: 		}
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * createTestDatabase:
1:67614ad: 	 * Using the creation script created as part of
1:67614ad: 	 * the test package, create the database that
1:67614ad: 	 * will be used as the basis for all dblook
1:67614ad: 	 * tests.
1:97cb351: 	 * @param scriptName The name of the sql script
1:97cb351: 	 *  to use for creating the test database.
1:67614ad: 	 * @return The test database has been created
1:67614ad: 	 *  in the current test directory, which is
1:67614ad: 	 *  "./dblook/" (as created by the harness).
1:67614ad: 	 ****/
1:67614ad: 
1:97cb351: 	protected void createTestDatabase(String scriptName)
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:97cb351: 		// Delete existing database, if it exists.
1:97cb351: 		try {
1:97cb351: 			deleteDB(testDBName);
1:97cb351: 		} catch (Exception e) {
1:97cb351: 			System.out.println("** Warning: failed to delete " +
1:97cb351: 				"old test db before creating a new one...");
1:97cb351: 		}
1:97cb351: 
1:4469400:         Class<?> clazz = Class.forName("org.apache.derby.jdbc.EmbeddedDriver");
1:4469400:         clazz.getConstructor().newInstance();
1:67614ad: 		jdbcProtocol = "jdbc:derby:";
1:97cb351: 		createDBFromDDL(testDBName, scriptName);
1:67614ad: 
1:67614ad: 		// Figure out where our database directory is (abs path).
1:6a85bc6: 		String systemhome = System.getProperty("derby.system.home");
1:6a85bc6: 		dbPath = systemhome + File.separatorChar;
2:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:97cb351: 	 * runDBLook:
1:67614ad: 	 * Runs a series of tests using dblook on
1:67614ad: 	 * the received database.
1:67614ad: 	 * @param dbName The name of the database on which to
1:67614ad: 	 *   run the tests.
1:67614ad: 	 * @return A series of tests intended to verify
1:67614ad: 	 *  the full functionality of the dblook utility
1:67614ad: 	 *  has been run.
1:67614ad: 	 ****/
1:67614ad: 
1:97cb351: 	private void runDBLook(String dbName)
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		// Close the error stream, so that messages
1:67614ad: 		// printed to System.err aren't intermixed
1:67614ad: 		// with our output (otherwise, the order
1:67614ad: 		// of the System.out vs System.err is
1:67614ad: 		// arbitrary (because of the way the harness
1:67614ad: 		// works), and so we will get diffs with
1:67614ad: 		// the master.
1:67614ad: 		System.err.close();
1:67614ad: 
1:67614ad: 		// First, we dump all system catalogs for
1:67614ad: 		// the original source database to file.
1:67614ad: 		dumpSysCatalogs(dbName);
1:67614ad: 
1:67614ad: 		// Then, we run dblook on the source database
1:67614ad: 		// with no limitations (i.e. we generate the
1:67614ad: 		// DDL for the FULL database).
1:67614ad: 		lookOne(dbName);
1:67614ad: 		dumpFileToSysOut("dblook.log");
1:67614ad: 
1:67614ad: 		// Now, create new db from the DDL that
1:67614ad: 		// was generated by dblook.
1:67614ad: 		String newDBName = dbName + "_new";
1:67614ad: 		createDBFromDDL(newDBName, dbName + ".sql");
1:67614ad: 		deleteFile(new File(dbName + ".sql"));
1:67614ad: 
1:67614ad: 		// Dump all system catalogs for the database
1:67614ad: 		// that was created from the DDL generated
1:67614ad: 		// by dblook.
1:67614ad: 		dumpSysCatalogs(newDBName);
1:67614ad: 
1:67614ad: 		// Delete the new database.
1:67614ad: 		deleteDB(newDBName);
1:67614ad: 		deleteFile(new File(newDBName + ".sql"));
1:67614ad: 
1:67614ad: 		// Run dblook on the source database
1:67614ad: 		// with various parameter configurations,
1:67614ad: 		// to make sure they are all working as
1:67614ad: 		// planned.
1:67614ad: 		runAllTests(dbName, newDBName);
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * runAllTests:
1:67614ad: 	 * Makes the call to execute each of the desired
1:67614ad: 	 * tests.
1:67614ad: 	 * @param dbName The name of the database on which to
1:67614ad: 	 *   run the tests.
1:67614ad: 	 * @param newDBName The name of the database to be
1:67614ad: 	 *  created from the DDL that is generated (by
1:67614ad: 	 *  dblook) for the source database.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	protected void runAllTests(String dbName,
1:67614ad: 		String newDBName) throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		runTest(2, dbName, newDBName);
1:67614ad: 
1:67614ad: 		// Test 3 is run as part of derbynet suite;
1:67614ad: 		// see derbynet/dblook_test_net.java.
1:67614ad: 
1:67614ad: 		runTest(4, dbName, newDBName);
1:67614ad: 		runTest(5, dbName, newDBName);
1:67614ad: 		runTest(7, dbName, newDBName);
1:67614ad: 		runTest(6, dbName, newDBName);
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * runTest:
1:67614ad: 	 * Runs dblook on the source database with a
1:67614ad: 	 * specific set of parameters, then uses the
1:67614ad: 	 * resultant DDL to create a new database, and
1:67614ad: 	 * dumps the system catalogs for that database
1:67614ad: 	 * to file.  Finally, the new database is deleted
1:67614ad: 	 * in preparation for subsequent calls to this
1:67614ad: 	 * method.
1:67614ad: 	 * @param whichTest An indication of which test to run;
1:67614ad: 	 *  each test number has a different set of
1:67614ad: 	 *  parameters.
1:67614ad: 	 * @param dbName The name of the source database.
1:67614ad: 	 * @param newDBName The name of the database to be
1:67614ad: 	 *  created from the DDL that is generated (by
1:67614ad: 	 *  dblook) for the source database.
1:67614ad: 	 * @return dblook has been executed using the
1:67614ad: 	 *  parameters associated with the given test,
1:67614ad: 	 *  and that DDL has been written to a ".sql"
1:67614ad: 	 *  file named after the source database;
1:67614ad: 	 *  a new database has been created from the
1:67614ad: 	 *  ".sql" generated by dblook; the system
1:67614ad: 	 *  catalogs for that new database have been
1:67614ad: 	 *  dumped to output; and the new database has
1:67614ad: 	 *  been deleted.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	protected void runTest(int whichTest, String dbName,
1:67614ad: 		String newDBName)
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		try {
1:67614ad: 
1:67614ad: 			switch(whichTest) {
1:67614ad: 				case 2:		lookTwo(dbName); break;
1:67614ad: 				case 3:		lookThree(dbName); break;
1:67614ad: 				case 4:		lookFour(dbName); break;
1:67614ad: 				case 5:		lookFive(dbName); break;
1:67614ad: 				case 6:		lookSix(dbName); break;
1:67614ad: 				case 7:		lookSeven(dbName); break;
1:67614ad: 				default:	break;
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			dumpFileToSysOut("dblook.log");
1:67614ad: 			createDBFromDDL(newDBName, dbName + ".sql");
1:67614ad: 			dumpSysCatalogs(newDBName);
1:67614ad: 			deleteDB(newDBName);
1:67614ad: 			deleteFile(new File(dbName + ".sql"));
1:67614ad: 
1:67614ad: 		} catch (SQLException e) {
1:67614ad: 
1:67614ad: 			System.out.println("FAILED: Test # : " + whichTest);
1:97cb351: 			e.printStackTrace(System.out);
1:67614ad: 			for (e = e.getNextException(); e != null;
1:67614ad: 				e = e.getNextException())
1:67614ad: 			{
1:97cb351: 				e.printStackTrace(System.out);
1:67614ad: 			}
1:67614ad: 
1:67614ad: 		} catch (Exception e) {
1:67614ad: 
1:67614ad: 			System.out.println("FAILED: Test # : " + whichTest);
1:97cb351: 			e.printStackTrace(System.out);
1:67614ad: 
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * lookOne:
1:67614ad: 	 * Use dblook to generate FULL DDL for a given
1:67614ad: 	 * database.
1:67614ad: 	 * @param dbName The name of the source database (i.e.
1:67614ad: 	 *  the database for which the DDL is generated).
1:67614ad: 	 * @return The full DDL for the source database
1:67614ad: 	 *  has been generated and written to a file
1:67614ad: 	 *  called <dbName + ".sql">.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private void lookOne(String dbName)
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		printAsHeader("\nDumping full schema for '" +
1:67614ad: 			dbName + "'\nto file '" + dbName + ".sql':\n");
1:67614ad: 
1:67614ad: 		String [] args = new String[] {
2:67614ad: 			"-o", dbName + ".sql",
1:67614ad: 			"-td", ""
1:67614ad: 		};
1:67614ad: 
1:67614ad: 		go(dbName, args);
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * lookTwo:
1:67614ad: 	 * Use dblook to generate DDL for all objects 
1:67614ad: 	 * in the source database with schema 'BAR',
1:67614ad: 	 * excluding views:
1:67614ad: 	 *  -z bar -noview
1:67614ad: 	 * @param dbName The name of the source database (i.e.
1:67614ad: 	 *  the database for which the DDL is generated).
1:67614ad: 	 * @return The appropriate DDL has been generated
1:67614ad: 	 *  and written to a file called <dbName + ".sql">.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private void lookTwo(String dbName)
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		printAsHeader("\nDumping DDL for all objects " +
1:67614ad: 			"with schema\n'BAR', excluding views:\n");
1:67614ad:  
1:67614ad: 		String [] args = new String[] {
1:67614ad: 			"-o", dbName + ".sql",
1:67614ad: 			"-td", "",
1:67614ad: 			"-z", "bar",
1:67614ad: 			"-noview"
1:67614ad: 		};
1:67614ad: 
1:67614ad: 		go(dbName, args);
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * lookThree:
1:67614ad: 	 * Use dblook to generate DDL for all objects
1:67614ad: 	 * in the source database, using Network
1:67614ad: 	 * Server.
1:67614ad: 	 * @param dbName The name of the source database (i.e.
1:67614ad: 	 *  the database for which the DDL is generated).
1:67614ad: 	 * @return The appropriate DDL has been generated
1:67614ad: 	 *  and written to a file called <dbName + ".sql">.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private void lookThree(String dbName)
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		printAsHeader("\nDumping DDL for all objects, " +
1:67614ad: 			"using\nNetwork Server:\n");
1:5ff5941: 		String hostName = TestUtil.getHostName();
1:5ff5941: 		jdbcProtocol = TestUtil.getJdbcUrlPrefix(hostName,SERVER_PORT);
1:67614ad: 
1:41e2806: 		String sourceDBUrl;
1:41e2806: 		if (TestUtil.isJCCFramework())
1:41e2806: 			sourceDBUrl = jdbcProtocol + "\"" + dbPath +
1:ebad814: 				separator + dbName + "\":user=app;password=apppw;";
1:41e2806: 		else
1:41e2806: 			sourceDBUrl = jdbcProtocol + dbPath +
1:ebad814: 			separator + dbName + ";user=app;password=apppw";
1:67614ad: 
1:67614ad: 		// Make sure we're not connected to the database
1:67614ad: 		// (we connected to it in embedded mode when we
1:67614ad: 		// created it, so we have to shut it down).
1:67614ad: 		try {
1:67614ad: 			DriverManager.getConnection(
1:ebad814: 				"jdbc:derby:" + dbName +
1:ebad814: 				";shutdown=true;user=app;password=apppw");
1:67614ad: 		} catch (SQLException e) {}
1:67614ad: 
1:67614ad: 		// Run the test.
1:67614ad: 		try {
1:97cb351: 
1:97cb351: 			new dblook(new String[] {
1:97cb351: 				"-d", sourceDBUrl,
1:97cb351: 				"-o", dbName + ".sql",
1:97cb351: 				"-td", "" }
1:97cb351: 			);
1:97cb351: 
1:67614ad: 		} catch (Exception e) {
2:67614ad: 			System.out.println("FAILED: ");
1:97cb351: 			e.printStackTrace(System.out);
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * lookFour:
1:67614ad: 	 * Use dblook to generate DDL for all objects 
1:67614ad: 	 * in the source database with schema 'BAR'
1:67614ad: 	 * that are related to tables 'T3', 'tWithKeys',
1:67614ad: 	 * and 'MULTI WORD NAME'.
1:67614ad: 	 *  -z bar -t t3 "\"tWithKeys\"" "Multi word name"
1:67614ad: 	 * @param dbName The name of the source database (i.e.
1:67614ad: 	 *  the database for which the DDL is generated).
1:67614ad: 	 * @return The appropriate DDL has been generated
1:67614ad: 	 *  and written to a file called <dbName + ".sql">.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private void lookFour(String dbName)
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		printAsHeader("\nDumping DDL for all objects " +
1:67614ad: 			"with schema 'BAR'\nthat are related to tables " +
1:67614ad: 			"'T3', 'tWithKeys',\nand 'MULTI WORD NAME':\n");
1:67614ad:  
1:67614ad: 		String [] args = new String [] {
1:67614ad: 			"-o", dbName + ".sql",
1:67614ad: 			"-td", "",
1:67614ad: 			"-z", "BAR",
1:67614ad: 			"-t", "t3", "\"tWithKeys\"", "Multi word name"
1:67614ad: 		};
1:67614ad: 
1:67614ad: 		go(dbName, args);
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * lookFive:
1:67614ad: 	 * Use dblook to generate DDL for all objects 
1:67614ad: 	 * in the source database (with any schema)
1:67614ad: 	 * that are related to table 'T1' and 'TWITHKEYS'
1:67614ad: 	 * (with no matches existing for the latter).
1:67614ad: 	 * 	-t t1 "tWithKeys"
1:67614ad: 	 * @param dbName The name of the source database (i.e.
1:67614ad: 	 *  the database for which the DDL is generated).
1:67614ad: 	 * @return The appropriate DDL has been generated
1:67614ad: 	 *  and written to a file called <dbName + ".sql">.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private void lookFive(String dbName)
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		printAsHeader("\nDumping DDL for all objects " +
1:67614ad: 			"related to 'T1'\nand 'TWITHKEYS':\n");
1:67614ad:  
1:67614ad: 		String [] args = new String [] {
1:67614ad: 			"-o", dbName + ".sql",
1:67614ad: 			"-td", "",
1:67614ad: 			"-t", "t1", "tWithKeys"
1:67614ad: 		};
1:67614ad: 
1:67614ad: 		go(dbName, args);
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * lookSix:
1:67614ad: 	 * Call dblook with an invalid url, to make
1:67614ad: 	 * sure that errors are printed to log.
1:67614ad: 	 *   -d <dbName> // missing protocol.
1:67614ad: 	 * @param dbName The name of the source database (i.e.
1:67614ad: 	 *  the database for which the DDL is generated).
1:67614ad: 	 * @return The appropriate DDL has been generated
1:67614ad: 	 *  and written to a file called <dbName + ".sql">.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private void lookSix(String dbName)
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		printAsHeader("\nDumping DDL w/ invalid url, and " +
1:67614ad: 			"writing\nerror to the log:\n");
1:67614ad:  
1:67614ad: 		// Url is intentionally incorrect; it will cause an error.
1:97cb351: 		new dblook(new String[] {
1:67614ad: 			"-o", dbName + ".sql",
1:67614ad: 			"-d", dbName }
2:67614ad: 		);
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * lookSeven:
1:67614ad: 	 * Use dblook to generate DDL for all objects 
1:67614ad: 	 * in the source database with schema '"Quoted"Schema"'.
1:67614ad: 	 *  -z \"\"Quoted\"Schema\"\"
1:67614ad: 	 * @param dbName The name of the source database (i.e.
1:67614ad: 	 *  the database for which the DDL is generated).
1:67614ad: 	 * @return The appropriate DDL has been generated
1:67614ad: 	 *  and written to a file called <dbName + ".sql">.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private void lookSeven(String dbName)
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		printAsHeader("\nDumping DDL for all objects " +
1:67614ad: 			"with schema\n'\"Quoted\"Schema\"':\n");
1:67614ad:  
1:67614ad: 		String [] args = new String[] {
1:67614ad: 			"-o", dbName + ".sql",
1:67614ad: 			"-td", "",
1:67614ad: 			"-z", "\"\"Quoted\"Schema\"\""
1:67614ad: 		};
1:67614ad: 
1:67614ad: 		go(dbName, args);
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * go:
1:67614ad: 	 * Makes the call to execute the dblook command
1:67614ad: 	 * using the received arguments.
1:67614ad: 	 * @param dbName The name of the source database (i.e.
1:67614ad: 	 *  the database for which the DDL is generated).
1:67614ad: 	 * @args The list of arguments with which to execute
1:67614ad: 	 *  the dblook command.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private void go(String dbName, String [] args) {
1:67614ad: 
1:67614ad: 		jdbcProtocol = "jdbc:derby:";
1:67614ad: 		String sourceDBUrl = jdbcProtocol + dbPath +
1:ebad814: 			separator + dbName + ";user=app;password=apppw";
1:67614ad: 
1:97cb351: 		String [] fullArgs = new String[args.length+2];
1:67614ad: 		fullArgs[0] = "-d";
1:67614ad: 		fullArgs[1] = sourceDBUrl;
1:97cb351: 		for (int i = 2; i < fullArgs.length; i++)
1:97cb351: 			fullArgs[i] = args[i-2];
1:67614ad: 
1:67614ad: 		try {
1:97cb351: 			new dblook(fullArgs);
1:67614ad: 		} catch (Exception e) {
1:97cb351: 			System.out.println("FAILED: to run dblook: ");
1:97cb351: 			e.printStackTrace(System.out);
1:97cb351: 		}
1:97cb351: 
1:97cb351: 	}
1:97cb351: 
1:97cb351: 	/* **********************************************
1:97cb351: 	 * runMessageCheckTest
1:97cb351: 	 * Run dblook and verify that all of the dblook
1:97cb351: 	 * messages are correctly displayed.
1:97cb351: 	 * @param dbName The name of the source database (i.e.
1:97cb351: 	 *  the database for which the DDL is generated).
1:97cb351: 	 * @return The DDL for a simple database, plus all
1:97cb351: 	 *  dblook messages, have been generated and written
1:97cb351: 	 *  to System.out.
1:97cb351: 	 ****/
1:97cb351: 	private void runMessageCheckTest(String dbName)
1:97cb351: 		throws Exception
1:97cb351: 	{
1:97cb351: 
1:97cb351: 		// #1: First, run DB look standard to check for
1:97cb351: 		// all of the "header" messages that are printed
1:97cb351: 		// out along with DDL.
1:97cb351: 		System.out.println("\n************\n" +
1:97cb351: 			"Msg Test 1\n" +
1:97cb351: 			"************\n");
1:97cb351: 		lookOne(dbName);
1:97cb351: 		dumpFileToSysOut(dbName + ".sql");
1:97cb351: 		dumpFileToSysOut("dblook.log");
1:97cb351: 
1:97cb351: 		// Now, we have to run some additional dblook commands
1:97cb351: 		// to get the "non-standard" messages.
1:97cb351: 
1:97cb351: 		// #2: Specify a target table and target schema, to
1:97cb351: 		// make sure they are echoed correctly.  Also, specify
1:97cb351: 		// an output file to make sure the file creation header
1:97cb351: 		// is printed in the file.
1:97cb351: 		System.out.println(
1:97cb351: 			"\n************\n" +
1:97cb351: 			"Msg Test 2\n" +
1:97cb351: 			"************\n");
1:97cb351: 		go(dbName, new String [] {
1:97cb351: 				"-t", "t1",
1:97cb351: 				"-z", "bar",
1:97cb351: 				"-o", dbName + ".sql"
1:97cb351: 			});
1:97cb351: 		dumpFileToSysOut(dbName + ".sql");
1:97cb351: 		dumpFileToSysOut("dblook.log");
1:97cb351: 
1:97cb351: 		// #3: Run without specifying a database, to make
1:97cb351: 		// sure the usage message is printed to System.out
1:97cb351: 		System.out.println(
1:97cb351: 			"\n************\n" +
1:97cb351: 			"Msg Test 3\n" +
1:97cb351: 			"************\n");
1:97cb351: 		try {
1:97cb351: 			new dblook(new String[] { "-verbose" });
1:97cb351: 		} catch (Exception e) {
1:97cb351: 			System.out.println("FAILED: to run dblook: ");
1:97cb351: 			e.printStackTrace(System.out);
1:97cb351: 		}
1:97cb351: 
1:97cb351: 		// #4: Just to confirm, try once with a statement
1:97cb351: 		// delimiter, to make sure it's actually working
1:97cb351: 		// correctly (this isn't a "message" per se, but
1:97cb351: 		// still, it's worth verifying).
1:97cb351: 		System.out.println(
1:97cb351: 			"\n************\n" +
1:97cb351: 			"Msg Test 4\n" +
1:97cb351: 			"************\n");
1:97cb351: 		go(dbName, new String [] {
1:97cb351: 				"-td", " " + TEST_DELIMITER
1:97cb351: 			});
1:97cb351: 
1:97cb351: 		// #5: Intentionally create an error while loading
1:97cb351: 		// a jar file, to make sure the resultant message is
1:97cb351: 		// printed correctly.
1:97cb351: 		System.out.println(
1:97cb351: 			"\n************\n" +
1:97cb351: 			"Msg Test 5\n" +
1:97cb351: 			"************\n");
1:97cb351: 
1:97cb351: 		// We'll cause the error by going in and deleting
1:97cb351: 		// the jar file from the test database.  First,
1:97cb351: 		// get the jar path.
1:97cb351: 		String jarPath = (new
1:97cb351: 			File(dbPath + separator + dbName)).getAbsolutePath();
1:97cb351: 
1:97cb351: 		// Have to shut db down before we can mess with it.
1:97cb351: 		try {
1:97cb351: 			Connection conn =
1:97cb351: 				DriverManager.getConnection("jdbc:derby:" + 
1:ebad814: 					jarPath + ";shutdown=true,user=app;password=apppw");
1:97cb351: 			conn.close();
1:97cb351: 		} catch (SQLException se) {
1:97cb351: 		// shutdown exception.
1:97cb351: 		}
1:97cb351: 
1:97cb351: 		jarPath = jarPath + separator + "jar";
1:97cb351: 		deleteFile(new File(jarPath));
1:97cb351: 
1:97cb351: 		// Now that we've deleted the jar file, run dblook
1:97cb351: 		// and check the error.
1:97cb351: 		go(dbName, new String [] { 
1:97cb351: 				"-verbose",
1:97cb351: 				"-o", dbName + ".sql"
1:97cb351: 			});
1:97cb351: 		dumpFileToSysOut("dblook.log");
1:97cb351: 
1:97cb351: 		// Clean up.
1:97cb351: 		try {
1:97cb351: 			deleteFile(new File(dbName + ".sql"));
1:97cb351: 		} catch (Exception e) {
1:97cb351: 		// not too big of a deal if we fail; just ignore...
1:67614ad: 		}
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * dumpSysCatalogs:
1:67614ad: 	 * Takes a database name and dumps ALL of the
1:67614ad: 	 * system catalogs for that database, with the
1:67614ad: 	 * exception of SYSSTATISTICS.  This allows us
1:67614ad: 	 * to look at the full contents of a database's
1:67614ad: 	 * schema (without using dblook, of course)
1:67614ad: 	 * so that we can see if the databases created
1:67614ad: 	 * from the DDL generated by dblook have been
1:67614ad: 	 * built correctly--if they have all of the
1:67614ad: 	 * correct system catalog information, then
1:67614ad: 	 * the databases themselves must be correct.
1:67614ad: 	 * @param dbName The name of the database for which
1:67614ad: 	 *  we are dumping the system catalogs.
1:67614ad: 	 * @return All of the system catalogs for
1:67614ad: 	 *  the received database have been dumped
1:67614ad: 	 *  to output.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private void dumpSysCatalogs(String dbName)
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		System.out.println("\nDumping system tables for '" + dbName + "'\n");
1:67614ad: 
1:67614ad: 		writeOut("\n----------------=================---------------");
1:67614ad: 		writeOut("System Tables for: " + dbName);
1:67614ad: 		writeOut("----------------=================---------------\n");
1:67614ad: 
1:67614ad: 		// Connect to the database.
1:67614ad: 		Connection conn = DriverManager.getConnection(
1:ebad814: 				"jdbc:derby:" + dbName + ";user=app;password=apppw");
1:67614ad: 		conn.setAutoCommit(false);
1:cd8191c: 
1:cd8191c: 		// Set the system schema to ensure that UCS_BASIC collation is used.
1:67614ad: 		Statement stmt = conn.createStatement();
1:cd8191c: 		stmt.executeUpdate("SET SCHEMA SYS");
1:cd8191c: 
1:cd8191c: 		// Ensure that the database has the expected collation type. 
1:cd8191c: 		ResultSet rs = null;
1:cd8191c: 		try {
1:cd8191c: 			rs = stmt.executeQuery("VALUES SYSCS_UTIL.SYSCS_GET_DATABASE_PROPERTY('derby.database.collation')");
1:cd8191c: 			rs.next();
1:cd8191c: 			String collation = rs.getString(1); 
1:cd8191c: 			if (collation == null || !collation.equals(expectedCollation)) {
1:cd8191c: 				throw new SQLException("Collation doesn't match with the expected type " + 
1:cd8191c: 						expectedCollation);
1:cd8191c: 			}
1:cd8191c: 		} catch (Exception e) {
1:cd8191c: 			System.out.println("FAILED: incorrect database collation\n");
1:cd8191c: 			System.out.println(e.getMessage());
1:cd8191c: 		} finally {
1:cd8191c: 			if (rs != null) {
1:cd8191c: 				rs.close();
1:cd8191c: 			}
1:cd8191c: 		}
1:67614ad: 
1:67614ad: 		// Load any id-to-name mappings that will be useful
1:67614ad: 		// when dumping the catalogs.
1:c393694: 		HashMap<String, String> idToNameMap = loadIdMappings(stmt);
1:67614ad: 
1:67614ad: 		// Go through and dump all system catalog information,
1:67614ad: 		// filtering out database-dependent id's so that they
1:67614ad: 		// won't cause diffs.
1:67614ad: 
1:67614ad: 		writeOut("\n========== SYSALIASES ==========\n");
1:cd8191c: 		rs =
1:67614ad: 			stmt.executeQuery("select schemaid, sys.sysaliases.* from sys.sysaliases");
1:67614ad: 		dumpResultSet(rs, idToNameMap, null);
1:67614ad: 
1:67614ad: 		writeOut("\n========== SYSCHECKS ==========\n");
1:67614ad: 		rs = stmt.executeQuery("select c.schemaid, ck.* from " +
1:67614ad: 			"sys.syschecks ck, sys.sysconstraints c where " +
1:67614ad: 			"ck.constraintid = c.constraintid");
1:67614ad: 		dumpResultSet(rs, idToNameMap, null);
1:67614ad: 
1:67614ad: 		writeOut("\n========== SYSCOLUMNS ==========\n");
1:67614ad: 		writeOut("--- Columns for Tables ---");
1:67614ad: 		rs = stmt.executeQuery("select t.schemaid, c.* from " +
1:67614ad: 			"sys.syscolumns c, sys.systables t where c.referenceid " +
1:67614ad: 			"= t.tableid" );
1:67614ad: 		dumpResultSet(rs, idToNameMap, null);
1:67614ad: 		writeOut("\n--- Columns for Statements ---");
1:67614ad: 		rs = stmt.executeQuery("select s.schemaid, c.* from " +
1:67614ad: 			"sys.syscolumns c, sys.sysstatements s where c.referenceid " +
1:67614ad: 			"= s.stmtid" );
1:67614ad: 		dumpResultSet(rs, idToNameMap, null);
1:67614ad: 
1:67614ad: 		writeOut("\n========== SYSCONGLOMERATES ==========\n");
1:67614ad: 		rs = stmt.executeQuery("select schemaid, sys.sysconglomerates.* " +
1:67614ad: 			"from sys.sysconglomerates");
1:67614ad: 		dumpResultSet(rs, idToNameMap, null);
1:67614ad: 
1:67614ad: 		writeOut("\n========== SYSCONSTRAINTS ==========\n");
1:67614ad: 		rs = stmt.executeQuery("select schemaid, sys.sysconstraints.* " +
1:67614ad: 			"from sys.sysconstraints");
1:67614ad: 		dumpResultSet(rs, idToNameMap, null);
1:67614ad: 
1:67614ad: 		writeOut("\n========== SYSDEPENDS ==========\n");
1:67614ad: 		rs = stmt.executeQuery("select dependentid, sys.sysdepends.* from sys.sysdepends");
1:67614ad: 		dumpResultSet(rs, idToNameMap, conn);
1:67614ad: 
1:67614ad: 		writeOut("\n========== SYSFILES ==========\n");
1:67614ad: 		rs = stmt.executeQuery("select schemaid, sys.sysfiles.* from sys.sysfiles");
1:67614ad: 		dumpResultSet(rs, idToNameMap, null);
1:67614ad: 
1:67614ad: 		writeOut("\n========== SYSFOREIGNKEYS ==========\n");
1:67614ad: 		rs = stmt.executeQuery("select c.schemaid, fk.* from " +
1:67614ad: 			"sys.sysforeignkeys fk, sys.sysconstraints c where " +
1:67614ad: 			"fk.constraintid = c.constraintid");
1:67614ad: 		dumpResultSet(rs, idToNameMap, null);
1:67614ad: 
1:67614ad: 		writeOut("\n========== SYSKEYS ==========\n");
1:67614ad: 		rs = stmt.executeQuery("select c.schemaid, k.* from " +
1:67614ad: 			"sys.syskeys k, sys.sysconstraints c where " +
1:67614ad: 			"k.constraintid = c.constraintid");
1:67614ad: 		dumpResultSet(rs, idToNameMap, null);
1:67614ad: 
1:67614ad: 		writeOut("\n========== SYSSCHEMAS ==========\n");
1:67614ad: 		rs = stmt.executeQuery("select schemaid, sys.sysschemas.* from sys.sysschemas");
1:67614ad: 		dumpResultSet(rs, idToNameMap, null);
1:67614ad: 
1:67614ad: 		writeOut("\n========== SYSSTATEMENTS ==========\n");
1:67614ad: 		rs = stmt.executeQuery("select schemaid, sys.sysstatements.* from sys.sysstatements");
1:67614ad: 		dumpResultSet(rs, idToNameMap, null);
1:67614ad: 
1:67614ad: 		writeOut("\n========== SYSTABLES ==========\n");
1:67614ad: 		rs = stmt.executeQuery("select schemaid, sys.systables.* from sys.systables");
1:67614ad: 		dumpResultSet(rs, idToNameMap, null);
1:67614ad: 
1:67614ad: 		writeOut("\n========== SYSTRIGGERS ==========\n");
1:67614ad: 		rs = stmt.executeQuery("select schemaid, sys.systriggers.* from sys.systriggers");
1:67614ad: 		dumpResultSet(rs, idToNameMap, null);
1:67614ad: 
1:67614ad: 		writeOut("\n========== SYSVIEWS ==========\n");
1:67614ad: 		rs = stmt.executeQuery("select compilationschemaid, sys.sysviews.* from sys.sysviews");
1:67614ad: 		dumpResultSet(rs, idToNameMap, null);
1:67614ad: 
1:ebad814: 		writeOut("\n========== SYSROLES ==========\n");
1:ebad814: 		rs = stmt.executeQuery
1:ebad814: 			("select 'dummyFirstCol', " +
1:ebad814: 			 "roleid || '_' || grantee || '_' || grantor as rgd, " +
1:ebad814: 			 "roleid, grantee, grantor, withadminoption, isdef " +
1:ebad814: 			 "from sys.sysroles");
1:ebad814: 		dumpResultSet(rs, idToNameMap, null);
1:ebad814: 
1:67614ad: 		stmt.close();
1:67614ad: 		rs.close();
1:67614ad: 		conn.commit();
2:67614ad: 		conn.close();
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * isIgnorableSchema:
1:67614ad:      * Returns true if the the schema is a "system" schema, vs. a user 
1:67614ad:      * schema.  
1:67614ad: 	 * @param schemaName name of schema to check.
1:67614ad: 	 ****/
1:67614ad: 	private boolean isIgnorableSchema(String schemaName) {
1:67614ad: 
1:67614ad:         boolean ret = false;
1:67614ad: 
1:67614ad:         for (int i = ignorableSchemaNames.length - 1; i >= 0;)
1:67614ad:         {
1:67614ad:             if ((ret = ignorableSchemaNames[i--].equalsIgnoreCase(schemaName)))
1:67614ad:                 break;
1:67614ad:         }
1:67614ad: 
1:67614ad:         return(ret);
1:67614ad: 	}
1:67614ad: 
1:67614ad:     private static final String[] ignorableSchemaNames = {
1:67614ad:         "SYSIBM",
1:67614ad:         "SYS",
1:67614ad:         "SYSVISUAL",
1:67614ad:         "SYSCAT",
1:67614ad:         "SYSFUN",
1:67614ad:         "SYSPROC",
1:67614ad:         "SYSSTAT",
1:67614ad:         "NULLID",
1:67614ad:         "SYSCS_ADMIN",
1:67614ad:         "SYSCS_DIAG",
1:67614ad:         "SYSCS_UTIL",
1:67614ad:         "SQLJ"};
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * dumpResultSet:
1:67614ad: 	 * Iterates through the received result set and
1:67614ad: 	 * dumps ALL columns in ALL rows of that result
1:67614ad: 	 * set to output.  Since no order is guaranteed
1:67614ad: 	 * in the received result set, we have to generate
1:67614ad: 	 * unique "ids" for each row in the result, and
1:67614ad: 	 * then use those ids to determine what order the
1:67614ad: 	 * rows will be output.  Failure to do so will
1:67614ad: 	 * lead to diffs in the test for rows that occur
1:67614ad: 	 * out of order.  The unique id's must NOT
1:67614ad: 	 * depend on system-generated id's, as the
1:67614ad: 	 * latter will vary for every run of the test,
1:67614ad: 	 * and thus will lead to different orderings
1:67614ad: 	 * every time (which we don't want).
1:67614ad: 	 *
1:67614ad: 	 * @param rs The result set that is being dumped.
1:67614ad: 	 * @param idToNameMap Mapping of various ids to
1:67614ad: 	 *  object names; used in forming unique ids.
1:67614ad: 	 * @param conn Connection from which the result set
1:67614ad: 	 *  originated.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private void dumpResultSet (ResultSet rs,
1:c393694: 		HashMap<String, String> idToNameMap, Connection conn)
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		// We need to form unique names for the rows of the
1:67614ad: 		// result set so that we can preserve the order of
1:67614ad: 		// the output and avoid diffs with a master.  This is
1:67614ad: 		// because a "select *" doesn't order rows--and even
1:67614ad: 		// though the schema for two databases might be the
1:67614ad: 		// same (i.e. the system tables contain all of the same
1:67614ad: 		// information) there's nothing to say the various rows in
1:67614ad: 		// the respective system tables will be the same (they
1:67614ad: 		// usually are NOT).  While system id's automatically
1:67614ad: 		// give us uniqueness, we can NOT order on them because
1:67614ad: 		// they vary from database to database; so, we need
1:67614ad: 		// to use something constant across the databases,
1:67614ad: 		// which is why we use object names.
1:67614ad: 		StringBuffer uniqueName = new StringBuffer();
1:67614ad: 
1:c393694: 		TreeMap<String, ArrayList<String>> orderedRows =
1:c393694:                 new TreeMap<String, ArrayList<String>>();
1:c393694: 		ArrayList<String> rowValues = new ArrayList<String>();
1:c393694: 		ArrayList<String> duplicateRowIds = new ArrayList<String>();
1:67614ad: 		ResultSetMetaData rsmd = rs.getMetaData();
1:67614ad: 		int cols = rsmd.getColumnCount();
1:67614ad: 		while (rs.next()) {
1:67614ad: 
1:67614ad: 			for (int i = 1; i <= cols; i++) {
1:67614ad: 
1:67614ad: 				String colName = rsmd.getColumnName(i);
1:67614ad: 				String value = rs.getString(i);
1:c393694: 				String mappedName = idToNameMap.get(value);
1:67614ad: 
1:67614ad: 				if ((colName.indexOf("SCHEMAID") != -1) &&
1:67614ad: 					(mappedName != null) &&
1:67614ad: 					((mappedName.indexOf("SYS") != -1) ||
1:67614ad:                      (isIgnorableSchema(mappedName))))
1:67614ad:                 {
1:67614ad: 				// then this row of the result set is for a system
1:67614ad: 				// object, which will always be the same for the
1:67614ad: 				// source and new database, so don't bother dumping
1:67614ad: 				// them to the output file (makes the test less
1:67614ad: 				// like to require updates when changes to database
1:67614ad: 				// metadata for system objects are checked in).
1:67614ad: 					rowValues = null;
1:67614ad: 					break;
1:67614ad: 				}
1:582425f: 				else if (colName.equals("JAVACLASSNAME") && (value != null) &&
1:67614ad: 					(value.indexOf("org.apache.derby") != -1) &&
1:67614ad: 					(value.indexOf(".util.") == -1)) {
1:67614ad: 				// this is a -- hack -- to see if the alias is a
1:67614ad: 				// a system alias, needed because aliases
1:67614ad: 				// (other than stored procedures) do not have
1:67614ad: 				// an associated schema).
1:67614ad: 					rowValues = null;
1:67614ad: 					break;
1:67614ad: 				}
1:67614ad: 
1:67614ad: 				if (i == 1)
1:67614ad: 				// 1st column is just for figuring out whether
1:67614ad: 				// to dump this row; no need to actually include
1:67614ad: 				// it in the results.
1:67614ad: 					continue;
1:ebad814: 
1:67614ad: 
1:ebad814: 				String uniquePiece;
1:ebad814: 
1:ebad814: 				if (colName.equals("RGD")) {
1:ebad814: 					// Role Grant Descriptor: synthetic unique column, see query
1:ebad814: 					// from SYS.SYSROLES.
1:ebad814: 					uniquePiece = value;
1:ebad814: 				} else {
1:ebad814: 					uniquePiece = dumpColumnData(colName,
1:ebad814: 												 value, mappedName, rowValues);
1:ebad814: 				}
1:ebad814: 
1:67614ad: 
1:67614ad: 				if (colName.equals("DEPENDENTID")) {
1:67614ad: 				// Special case: rows in the "DEPENDS" table
1:67614ad: 				// don't have unique ids or names; we have to
1:67614ad: 				// build one by extracting information indirectly.
1:67614ad: 					String hiddenInfo = getDependsData(rs, conn,
1:67614ad: 						idToNameMap);
1:67614ad: 					if (hiddenInfo.indexOf("SYS_OBJECT") != -1) {
1:67614ad: 					// this info is for a system object, so
1:67614ad: 					// ignore it.
1:67614ad: 						rowValues = null;
1:67614ad: 						break;
1:67614ad: 					}
1:67614ad: 					uniqueName.append(hiddenInfo);
1:67614ad: 					// Include the hidden data as part of the
1:67614ad: 					// output.
1:67614ad: 					rowValues.add(hiddenInfo);
1:67614ad: 				}
1:67614ad: 
1:67614ad: 		 		if (uniquePiece != null)
1:67614ad: 					uniqueName.append(uniquePiece);
1:67614ad: 
1:67614ad: 				if (colName.equals("STMTNAME") &&
1:67614ad: 				  (value.indexOf("TRIGGERACTN") != -1))
1:67614ad: 				// Special case: can't use statement name, because
1:67614ad: 				// the entire statement may be automatically generated
1:67614ad: 				// in each database (to back a trigger), so the name
1:67614ad: 				// in which case the generated name will be different
1:67614ad: 				// every time; but filtering out the name means
1:67614ad: 				// we have no other guaranteed unique 'id' for
1:67614ad: 				// ordering.  So, just take "text" field, and
1:67614ad: 				// design test db so that no two triggers have the
1:67614ad: 				// same text value.
1:67614ad: 				uniqueName.append(rs.getString(6));
1:67614ad: 
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			if (rowValues != null) {
1:67614ad: 
1:67614ad: 				if (duplicateRowIds.contains(uniqueName.toString()))
1:67614ad: 				// then we've already encountered this row id before;
1:67614ad: 				// to preserve ordering, use the entire row as an
1:67614ad: 				// id.
1:67614ad: 					handleDuplicateRow(rowValues, null, orderedRows);
1:67614ad: 				else {
1:c393694: 					ArrayList<String> oldRow = orderedRows.put(
1:c393694: 						uniqueName.toString(), rowValues);
1:67614ad: 					if (oldRow != null) {
1:67614ad: 					// Duplicate row id.
1:67614ad: 						duplicateRowIds.add(uniqueName.toString());
1:67614ad: 						// Delete the row that has the duplicate row id.
1:67614ad: 							orderedRows.remove(uniqueName.toString());
1:67614ad: 						handleDuplicateRow(rowValues, oldRow, orderedRows);
1:67614ad: 					}
1:67614ad: 				}
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			uniqueName = new StringBuffer();
1:c393694: 			rowValues = new ArrayList<String>();
1:67614ad: 
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		// Now, print out all of the data in this result set
1:67614ad: 		// using the order of the unique names that we created.
1:c393694:         Set<String> objectNames = orderedRows.keySet();
1:c393694:         for (String row : objectNames) {
1:c393694:             ArrayList<String> colData = orderedRows.get(row);
1:c393694:             for (int i = 0; i < colData.size(); i++)
1:c393694:                 writeOut((String)colData.get(i));
1:c393694:             writeOut("----");
1:c393694:         }
1:67614ad: 
1:67614ad: 		orderedRows = null;
1:67614ad: 		rs.close();
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * dumpColumnData:
1:67614ad: 	 * Stores the value for a specific column of
1:67614ad: 	 * some result set.  If the value needs to
1:67614ad: 	 * be filtered (to remove system-generated ids
1:67614ad: 	 * that would otherwise cause diffs with the
1:67614ad: 	 * master), that filtering is done here.
1:67614ad: 	 * @param colName Name of the column whose value we're
1:67614ad: 	 *  writing.
1:67614ad: 	 * @param value Value that we're writing.
1:67614ad: 	 * @param mappedName: Name corresponding to the value,
1:67614ad: 	 *  for cases where the value is actually an
1:67614ad: 	 *  object id (then we want to write the name
1:67614ad: 	 *  instead).
1:67614ad: 	 * rowValues a list of column values for the
1:67614ad: 	 *  current row of the result set.
1:67614ad: 	 * @return The (possibly filtered) value of the
1:67614ad: 	 *  received column has been added to the
1:67614ad: 	 *  "rowVals" array list, and the corresponding
1:67614ad: 	 *  piece of the row's unique name has been
1:67614ad: 	 *  returned, if one exists.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private String dumpColumnData(String colName,
1:c393694: 		String value, String mappedName, ArrayList<String> rowVals)
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		if (mappedName == null) {
1:67614ad: 		// probably not an id.
1:67614ad: 			if (colName.equals("CONGLOMERATENUMBER") ||
1:67614ad: 				colName.equals("GENERATIONID"))
1:67614ad: 			// special case: these numbers aren't ids per
1:67614ad: 			// se, but they are still generated by the system,
1:67614ad: 			// and will cause diffs with the master; so, ignore
1:67614ad: 			// them.
1:67614ad: 				rowVals.add("<systemnumber>");
1:67614ad: 			else if (colName.equals("AUTOINCREMENTVALUE"))
1:67614ad: 			// special case: new database won't have any data,
1:67614ad: 			// old will, so unless we filter this out, we'll
1:67614ad: 			// get a diff.
1:67614ad: 				rowVals.add("<autoincval>");
1:67614ad: 			else if (colName.equals("VALID"))
1:67614ad: 			// special case: ignore whether or not stored
1:67614ad: 			// statements are valid (have been compiled)
1:67614ad: 			// since it depends on history of database,
1:67614ad: 			// which we can't duplicate.
1:67614ad: 				rowVals.add("<validityflag>");
1:67614ad: 			else if (value != null) {
1:67614ad: 				if (looksLikeSysGenName(value)) {
1:67614ad: 					if (columnHoldsObjectName(colName))
1:67614ad: 						rowVals.add("<systemname>");
1:67614ad: 					else {
1:67614ad: 					// looks like a sys gen name, but's actually a VALUE.
1:67614ad: 						rowVals.add(value);
1:67614ad: 						return value;
1:67614ad: 					}
1:67614ad: 				}
1:67614ad: 				else if (looksLikeSysGenId(value))
1:67614ad: 					rowVals.add("<systemid>");
1:67614ad: 				else {
1:67614ad: 					rowVals.add(value);
1:67614ad: 					if (columnHoldsObjectName(colName))
1:67614ad: 					// if it's a name, we need it as part of
1:67614ad: 					// our unique id.
1:67614ad: 						return value;
1:67614ad: 				}
1:67614ad: 			}
1:67614ad: 			else
1:67614ad: 			// null value.
1:67614ad: 				rowVals.add(value);
1:67614ad: 		}
1:67614ad: 		else {
1:67614ad: 		// it's an id, so write the corresponding name.
1:67614ad: 			if (!isSystemGenerated(mappedName)) {
1:67614ad: 			// Not an id-as-name, so use it as part of our unique id.
1:67614ad: 				rowVals.add(mappedName);
1:67614ad: 				return mappedName;
1:67614ad: 			}
1:67614ad: 			else
1:67614ad: 				rowVals.add("<systemname>");
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		// If we get here, we do NOT want the received value
1:67614ad: 		// to be treated as part of this row's unique name.
1:67614ad: 		return null;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * handleDuplicateRow:
1:67614ad: 	 * If we get here, then despite our efforts (while
1:67614ad: 	 * dumping the system catalogs for a database), we
1:67614ad: 	 * still have a duplicate row id.  So, as a last
1:67614ad: 	 * resort we just use the ENTIRE row as a 'row id'.
1:67614ad: 	 * In the rare-but-possible case that the entire
1:67614ad: 	 * row is a duplicate (as can happen with the
1:67614ad: 	 * SYSDEPENDS table), then we tag a simple number
1:67614ad: 	 * onto the latest row's id, so that the row will
1:67614ad: 	 * still show up multiple times--and since the rows
1:67614ad: 	 * are identical, it doesn't matter which comes
1:67614ad: 	 * 'first'.
1:67614ad: 	 * @param newRow The most recently-fetched row from
1:67614ad: 	 *  the database system catalogs.
1:67614ad: 	 * @param oldRow The row that was replaced when the
1:67614ad: 	 *  newRow was inserted (because they had the
1:67614ad: 	 *  same row id), or "null" if we were already
1:67614ad: 	 *  here once for this row id, and so just want
1:67614ad: 	 *  insert a new row.
1:67614ad: 	 * @param orderedRows The ordered set of rows, into
1:67614ad: 	 *  which oldRow and newRow need to be inserted.
1:67614ad: 	 * @return oldRow and newRow have been inserted
1:67614ad: 	 *  into orderedRows, and each has a (truly)
1:67614ad: 	 *  unique id with it.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private void handleDuplicateRow(
1:c393694: 		ArrayList<String> newRow, ArrayList<String> oldRow,
1:c393694: 		TreeMap<String, ArrayList<String>> orderedRows)
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		// Add the received rows (old and new) with
1:67614ad: 		// unique row ids.
1:67614ad: 
1:67614ad: 		StringBuffer newRowId = new StringBuffer();
1:67614ad: 		for (int i = 0; i < newRow.size(); i++)
1:67614ad: 			newRowId.append((String)newRow.get(i));
1:67614ad: 
1:c393694: 		ArrayList<String> obj = orderedRows.put(newRowId.toString(), newRow);
1:67614ad: 		if (obj != null)
1:67614ad: 		// entire row is a duplicate.
1:67614ad: 			orderedRows.put(newRowId.toString() + 
1:67614ad: 				duplicateCounter++, newRow);
1:67614ad: 
1:67614ad: 		if (oldRow != null) {
1:67614ad: 
1:67614ad: 			StringBuffer oldRowId = new StringBuffer();
1:67614ad: 			for (int i = 0; i < oldRow.size(); i++)
1:67614ad: 				oldRowId.append((String)oldRow.get(i));
1:67614ad: 
1:c393694: 			obj = orderedRows.put(oldRowId.toString(), oldRow);
1:67614ad: 			if (obj != null)
1:67614ad: 			// entire row is a duplicate.
1:67614ad: 				orderedRows.put(oldRowId.toString() +
1:67614ad: 					duplicateCounter++, oldRow);
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * createDBFromDDL:
1:67614ad: 	 * Read from the given script and use it to create
1:67614ad: 	 * a new database of the given name.
1:67614ad: 	 * @param newDBName Name of the database to be created.
1:67614ad: 	 * @param scriptName Name of the script containing the
1:67614ad: 	 *  DDL from which the new database will be created.
1:67614ad: 	 * @return New database has been created from
1:67614ad: 	 *   the script; any commands in the script that
1:67614ad: 	 *   failed to execute have been echoed to output.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private void createDBFromDDL(String newDBName,
1:67614ad: 		String scriptName) throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		System.out.println("\n\nCreating database '" + newDBName +
1:67614ad: 			"' from ddl script '" + scriptName + "'");
1:67614ad: 
1:67614ad: 		Connection conn = DriverManager.getConnection(
1:ebad814: 				"jdbc:derby:" + newDBName +
1:ebad814: 				";create=true;user=app;password=apppw" + territoryBased);
1:67614ad: 
1:3130800:         runDDL( conn, scriptName );
1:3130800: 
1:3130800: 		conn.close();
1:3130800: 
1:3130800: 		return;
1:3130800: 	}
1:3130800: 
1:3130800: 	/* **********************************************
1:3130800: 	 * runDDL:
1:3130800: 	 * Run an sql script.
1:3130800: 	 * @param conn database connection
1:3130800: 	 * @param scriptName Name of the script
1:3130800: 	 ****/
1:3130800: 
1:3130800: 	static  void runDDL( Connection conn, String scriptName)
1:3130800:         throws Exception
1:3130800: 	{
1:67614ad: 		Statement stmt = conn.createStatement();
1:67614ad: 		BufferedReader ddlScript =
1:3130800: 			new BufferedReader( new FileReader( scriptName ) );
1:67614ad: 
1:67614ad: 		for (String sqlCmd = ddlScript.readLine(); sqlCmd != null;
1:67614ad: 			sqlCmd = ddlScript.readLine()) {
1:67614ad: 
1:67614ad: 			if (sqlCmd.indexOf("--") == 0)
1:67614ad: 			// then this is a script comment; ignore it;
1:67614ad: 				continue;
1:67614ad: 			else if (sqlCmd.trim().length() == 0)
1:67614ad: 			// blank line; ignore it.
1:67614ad: 				continue;
1:67614ad: 
1:67614ad: 			// Execute the command.
1:67614ad: 			if ((sqlCmd.charAt(sqlCmd.length()-1) == TEST_DELIMITER)
1:67614ad: 			  || (sqlCmd.charAt(sqlCmd.length()-1) == ';'))
1:67614ad: 			// strip off the delimiter.
1:67614ad: 				sqlCmd = sqlCmd.substring(0, sqlCmd.length()-1);
1:67614ad: 
1:67614ad: 			try {
1:67614ad: 				stmt.execute(sqlCmd);
1:67614ad: 			} catch (Exception e) {
1:67614ad: 				System.out.println("FAILED: to execute cmd " +
1:67614ad: 					"from DDL script:\n" + sqlCmd + "\n");
4:67614ad: 				System.out.println(e.getMessage());
1:67614ad: 			}
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		// Cleanup.
1:67614ad: 		ddlScript.close();
1:67614ad: 		stmt.close();
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * writeOut:
1:67614ad: 	 * Write the received string to some output.
1:67614ad: 	 * @param str String to write.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private static void writeOut(String str) {
1:67614ad: 
1:67614ad: 		System.out.println(str);
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * loadIdMappings:
1:67614ad: 	 * Load mappings of object ids to object names
1:67614ad: 	 * for purposes of having meaningful output
1:67614ad: 	 * and for creating unique ids on the rows of
1:67614ad: 	 * the system catalogs.
1:67614ad: 	 * @param stmt Statement on a connection to the
1:67614ad: 	 *  database being examined.
1:67614ad: 	 * @param conn Connection to the database being
1:67614ad: 	 *   examined.
1:67614ad: 	 * @return A HashMap with all relevant id-to-
1:67614ad: 	 *  name mappings has been returned.
1:67614ad: 	 ****/
1:67614ad: 
1:c393694:     private HashMap<String, String> loadIdMappings(Statement stmt)
1:c393694:             throws Exception {
1:67614ad: 
1:c393694: 		HashMap<String, String> idToNameMap = new HashMap<String, String>();
1:67614ad: 
1:67614ad: 		// Table ids.
1:67614ad: 		ResultSet rs = stmt.executeQuery(
1:67614ad: 			"select tableid, tablename from sys.systables");
1:67614ad: 		while (rs.next())
1:67614ad: 			idToNameMap.put(rs.getString(1), rs.getString(2));
1:67614ad: 
1:67614ad: 		// Schema ids.
1:67614ad: 		rs = stmt.executeQuery(
1:67614ad: 			"select schemaid, schemaname from sys.sysschemas");
1:67614ad: 		while (rs.next())
1:67614ad: 			idToNameMap.put(rs.getString(1), rs.getString(2));
1:67614ad: 
1:67614ad: 		// Constraint ids.
1:67614ad: 		rs = stmt.executeQuery(
1:67614ad: 			"select constraintid, constraintname from " +
1:67614ad: 			"sys.sysconstraints");
1:67614ad: 		while (rs.next())
1:67614ad: 			idToNameMap.put(rs.getString(1), rs.getString(2));
1:67614ad: 
1:67614ad: 		return idToNameMap;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * getDependsData:
1:67614ad: 	 * Forms a string containing detailed information
1:67614ad: 	 * about a row in the SYSDEPENDS table, and returns
1:67614ad: 	 * that string.
1:67614ad: 	 * @param rs Result set with SYSDEPENDS rows; current
1:67614ad: 	 *  row is the one for which we're getting the
1:67614ad: 	 *  data.
1:67614ad: 	 * @param conn Connection to the database being
1:67614ad: 	 *   examined.
1:67614ad: 	 * @param idToNameMap mapping of object ids to names
1:67614ad: 	 *  for the database in question.
1:67614ad: 	 * @return Schema, type and name of both the Provider
1:67614ad: 	 *   and the Dependent for the current row of
1:67614ad: 	 *   SYSDEPENDS have been returned as a string.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private String getDependsData(ResultSet rs,
1:67614ad: 		Connection conn, HashMap idToNameMap)
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		DependableFinder dep =
1:67614ad: 			(DependableFinder)rs.getObject(3);
1:67614ad: 
1:67614ad: 		DependableFinder prov =
1:67614ad: 			(DependableFinder)rs.getObject(5);
1:67614ad: 
1:67614ad: 		String depType = dep.getSQLObjectType();
1:67614ad: 		String provType = prov.getSQLObjectType();
1:67614ad: 
1:67614ad: 		Statement dependsStmt = conn.createStatement();
1:67614ad: 		StringBuffer dependsData = new StringBuffer();
1:67614ad: 		dependsData.append(getHiddenDependsData(depType,
1:67614ad: 			rs.getString(2), dependsStmt, idToNameMap));
1:67614ad: 		dependsData.append(" -> ");
1:67614ad: 		dependsData.append(getHiddenDependsData(provType,
1:67614ad: 			rs.getString(4), dependsStmt, idToNameMap));
1:67614ad: 
1:67614ad: 		return dependsData.toString();
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * getHiddenDependsData:
1:67614ad: 	 * Returns a string containing the schema and
1:67614ad: 	 * name of the object having the received id.
1:67614ad: 	 * All object ids received by this message come
1:67614ad: 	 * from rows of the SYSDEPENDS table.
1:67614ad: 	 * @param type Type of the object that has the received
1:67614ad: 	 *   object id.
1:67614ad: 	 * @param id Id of the object in question.
1:67614ad: 	 * @param stmt Statement from the database in question.
1:67614ad: 	 * @param idToNameMap mapping of ids to names for
1:67614ad: 	 *  the database in question.
1:67614ad: 	 * @isProvider True if we're getting data for a
1:67614ad: 	 *  Provider object; false if we're getting data for
1:67614ad: 	 *  a Dependent object.
1:67614ad: 	 * @return Schema, type, and name for the object with
1:67614ad: 	 *   the received id have been returned as a string.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private String getHiddenDependsData(String type,
1:67614ad: 		String id, Statement pStmt, HashMap idToNameMap)
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		ResultSet rs = null;
1:67614ad: 		if (type.equals("Constraint")) {
1:67614ad: 			rs = pStmt.executeQuery(
1:67614ad: 				"select schemaid, constraintname from " +
1:67614ad: 				"sys.sysconstraints where " +
1:67614ad: 				"constraintid = '" + id + "'");
1:67614ad: 		}
1:67614ad: 		else if (type.equals("StoredPreparedStatement")) {
1:67614ad: 			rs = pStmt.executeQuery(
1:67614ad: 				"select schemaid, stmtname from " +
1:67614ad: 				"sys.sysstatements where stmtid = '" +
1:67614ad: 				id + "'");
1:67614ad: 		}
1:67614ad: 		else if (type.equals("Trigger")) {
1:67614ad: 			rs = pStmt.executeQuery(
1:67614ad: 				"select schemaid, triggername from " +
1:67614ad: 				"sys.systriggers where triggerid = '" +
1:67614ad: 				id + "'");
1:67614ad: 		}
1:67614ad: 		else if (type.equals("View") || type.equals("Table")
1:67614ad: 		  || type.equals("ColumnsInTable")) {
1:67614ad: 			rs = pStmt.executeQuery(
1:67614ad: 				"select schemaid, tablename from " +
1:67614ad: 				"sys.systables where tableid = '" +
1:67614ad: 				id + "'");
1:67614ad: 		}
1:67614ad: 		else if (type.equals("Conglomerate")) {
1:67614ad: 			rs = pStmt.executeQuery(
1:67614ad: 				"select schemaid, conglomeratename from " +
1:67614ad: 				"sys.sysconglomerates where conglomerateid = '" +
1:67614ad: 				id + "'");
1:67614ad: 		}
1:67614ad: 		else {
1:67614ad: 			System.out.println("WARNING: Unexpected " +
1:67614ad: 				"dependent type: " + type);
1:67614ad: 			return "";
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		if (rs.next()) {
1:67614ad: 			String schema = (String)idToNameMap.get(rs.getString(1));
1:67614ad: 			if (isIgnorableSchema(schema))
1:67614ad: 			// system object (so we want to ignore it); indicate
1:67614ad: 			// this by returning the string "SYS_OBJECT".
1:67614ad: 				return "SYS_OBJECT";
1:67614ad: 			StringBuffer result = new StringBuffer();
1:67614ad: 			result.append("<");
1:67614ad: 			result.append(type);
1:67614ad: 			result.append(">");
1:67614ad: 			result.append(schema);
1:67614ad: 			result.append(".");
1:67614ad: 			if (isSystemGenerated(rs.getString(2)))
1:67614ad: 				result.append("<sysname>");
1:67614ad: 			else
1:67614ad: 				result.append(rs.getString(2));
1:67614ad: 			return result.toString();
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		return "";
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * deleteDB:
1:67614ad: 	 * Deletes the database with the received name
1:67614ad: 	 * from the test directory.
1:67614ad: 	 * @param dbName Name of the database to be deleted.
1:67614ad: 	 * @return Database has been completely deleted;
1:67614ad: 	 *   if deletion failed for any reason, a message
1:67614ad: 	 *   saying so has been printed to output.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private void deleteDB(String dbName)
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		// Get the full path.
1:67614ad: 		String deletePath = (new
1:67614ad: 			File(dbPath + separator + dbName)).getAbsolutePath();
1:67614ad: 
1:67614ad: 		// Have to shut it down before we can delete it.
1:67614ad: 		try {
1:67614ad: 			Connection conn =
1:67614ad: 				DriverManager.getConnection("jdbc:derby:" + 
1:ebad814: 					deletePath + ";shutdown=true;user=app;password=apppw");
1:67614ad: 			conn.close();
1:67614ad: 		} catch (SQLException se) {
1:67614ad: 		// shutdown exception.
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		File f = new File(deletePath);
1:67614ad: 		if (!f.exists()) 
1:67614ad: 		// nothing to do.
1:67614ad: 			return;
1:67614ad: 
1:67614ad: 		File [] files = f.listFiles();
1:67614ad: 		for (int i = 0; i < files.length; i++)
1:67614ad: 			deleteFile(files[i]);
1:67614ad: 
1:67614ad: 		if (!f.delete()) {
1:67614ad: 		// still failed.
1:67614ad: 			System.out.println("ERROR: deleting: " +
1:67614ad: 				f.getName());
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		// And finally, delete the CSJARS directory,
1:67614ad: 		// if there is one.
1:67614ad: 		deleteFile(new File(System.getProperty("user.dir") +
1:67614ad: 			separator + "CSJARS"));
1:67614ad: 
1:67614ad: 		System.out.println("Database '" + dbName + "' deleted.");
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * deleteFile:
1:67614ad: 	 * Delete everything in a given directory, then
1:67614ad: 	 * delete the directory itself (recursive).
1:67614ad: 	 * @param aFile File object representing the directory
1:67614ad: 	 *  to be deleted.
1:67614ad: 	 * @return the directory corresponding to aFile
1:67614ad: 	 *  has been deleted, as have all of its contents.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private void deleteFile(File aFile)
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad: 		if (!aFile.exists())
1:67614ad: 		// don't bother.
1:67614ad: 			return;
1:67614ad: 
1:67614ad: 		if (aFile.delete())
1:67614ad: 		// just a file; we're done.
1:67614ad: 			return;
1:67614ad: 
1:67614ad: 		// Otherwise, have to descend and delete all
1:67614ad: 		// files in this directory.
1:67614ad: 		File [] files = aFile.listFiles();
1:67614ad: 		if (files != null) {
1:67614ad: 			for (int i = 0; i < files.length; i++)
1:67614ad: 				deleteFile(files[i]);
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		// Now try to delete.
1:67614ad: 		if (!aFile.delete()) {
1:67614ad: 		// still failed.
1:67614ad: 			System.out.println("ERROR: deleting: " +
1:67614ad: 				aFile.getName());
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:cd8191c: 	 * renameDbLookLog:
1:cd8191c: 	 * Checks if the logfile of dblook exists and
1:cd8191c: 	 * tries to rename it to prevent possible 
1:cd8191c: 	 * next tests from failing. The log should not be 
1:cd8191c: 	 * deleted because the output may be examined in 
1:cd8191c: 	 * case a test fails.
1:cd8191c: 	 * The new name of dblook.log should be dblook_testname#.log,
1:cd8191c: 	 * where # is a 'version' number. The 'version' number is
1:cd8191c: 	 * needed because the same test may be run multiple
1:cd8191c: 	 * times with different parameters.
1:cd8191c: 	 * @param nameOfTest Name of the finished test.
1:cd8191c: 	 ****/
1:cd8191c: 
1:cd8191c: 	protected static void renameDbLookLog(String nameOfTest)
1:cd8191c: 	{
1:cd8191c: 		File dbLookTestLog = new File("dblook.log");
1:cd8191c: 		if (dbLookTestLog.exists()) {
1:cd8191c: 			int i = 0;
1:cd8191c: 			String renamedLogName = nameOfTest + i + ".log";
1:cd8191c: 			File renamedLog = new File(renamedLogName);
1:cd8191c: 			while (renamedLog.exists()) {
1:cd8191c: 				i++;
1:cd8191c: 				renamedLogName = nameOfTest + i + ".log";
1:cd8191c: 				renamedLog = new File(renamedLogName);
1:cd8191c: 			}
1:cd8191c: 			if (!dbLookTestLog.renameTo(renamedLog)) {
1:cd8191c: 				System.out.println("Failed to rename dblook.org to " + 
1:cd8191c: 						renamedLogName);
1:cd8191c: 			}
1:cd8191c: 		}
1:cd8191c: 	}
1:cd8191c: 
1:cd8191c: 	/* **********************************************
1:67614ad: 	 * dumpFileToSysOut:
1:67614ad: 	 * Checks to see if the received file is empty,
1:67614ad: 	 * and prints a message saying so.
1:67614ad: 	 * @param fName Name of the file to be written to output.
1:67614ad: 	 * @return The contents of the specified file have
1:67614ad: 	 *   been written to System.out.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private void dumpFileToSysOut(String fName) {
1:67614ad: 
1:67614ad: 		try {
1:67614ad: 
1:97cb351: 			BufferedReader dumpFile =
1:67614ad: 				new BufferedReader(new FileReader(fName));
1:67614ad: 
1:97cb351: 			String line = dumpFile.readLine();
1:97cb351: 			if (line != null) {
1:67614ad: 				System.out.println("File " + fName + " was NOT " +
1:97cb351: 					"empty.  Contents are:\n" +
1:97cb351: 					"############## Begin File Contents ################\n");
1:97cb351: 				do {
1:97cb351: 					System.out.println(line);
1:97cb351: 					line = dumpFile.readLine();
1:97cb351: 				} while (line != null);
1:97cb351: 				System.out.println(
1:97cb351: 					"############## End File Contents ################");
1:97cb351: 			}
1:67614ad: 			else
1:67614ad: 				System.out.println("File " + fName + " was empty.");
1:67614ad: 
1:97cb351: 			// Close the file.
1:97cb351: 			dumpFile.close();
1:97cb351: 
1:67614ad: 		} catch (Exception e) {
1:97cb351: 			System.out.println("FAILED: to dump file '" + fName + "'");
1:97cb351: 			e.printStackTrace(System.out);
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * isSystemGenerated:
1:67614ad: 	 * Returns true if the received string looks like
1:67614ad: 	 * it is a system-generated string.  We assume
1:67614ad: 	 * it's system-generated if either 1) it starts
1:67614ad: 	 * with the letters "SQL", in which case it's a
1:67614ad: 	 * system-name, or 2) it has a dash in it, in which
1:67614ad: 	 * case it's a system id.
1:67614ad: 	 * @param str The string to check.
1:67614ad: 	 * @return True if we assume the string is system-
1:67614ad: 	 *  generated, false otherwise.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private boolean isSystemGenerated(String str) {
1:67614ad: 
1:67614ad: 		return (looksLikeSysGenName(str) ||
1:67614ad: 			looksLikeSysGenId(str));
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * looksLikeSysGenName:
1:67614ad: 	 * See if the received string looks like it is
1:67614ad: 	 * a system-generated name.  There are two types
1:67614ad: 	 * of system-generated names: 1) visible names,
1:67614ad: 	 * which start with "SQL", and 2) hidden names,
1:67614ad: 	 * which exist for Stored Statements that are
1:67614ad: 	 * used to back triggers; these names start with
1:67614ad: 	 * "TRIGGERACTN_" and then have a UUID.
1:67614ad: 	 * NOTE: This test assumes that none of object names
1:67614ad: 	 * provided in "dblook_makeDB.sql" satisfy
1:67614ad: 	 * either of these conditions.  If they do, they
1:67614ad: 	 * will be filtered out of the test output.
1:67614ad: 	 * @param val The string value in question.
1:67614ad: 	 * @return True if the value looks like it is a system-
1:67614ad: 	 *  generated name; false otherwise.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private boolean looksLikeSysGenName(String val) {
1:67614ad: 
1:67614ad: 		return ((val != null) &&
1:67614ad: 			((val.trim().indexOf("SQL") == 0) || 			// case 1.
1:67614ad: 			((val.trim().indexOf("TRIGGERACTN_") == 0) &&	// case 2.
1:67614ad: 			(val.indexOf("-") != -1))));
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * looksLikeSysGenId:
1:67614ad: 	 * See if the received string looks like it is
1:67614ad: 	 * a system-generated id (i.e. contains a dash (-)).
1:67614ad: 	 * NOTE: This test assumes that none of object names
1:67614ad: 	 * provided in "dblook_makeDB.sql" will contain
1:67614ad: 	 * dashes.  If they do, then they will be filtered out
1:67614ad: 	 * in the test output.
1:67614ad: 	 * @param val The string value in question.
1:67614ad: 	 * @return True if the value looks like it is a system-
1:67614ad: 	 *  generated id; false otherwise.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private boolean looksLikeSysGenId(String val) {
1:67614ad: 
1:67614ad: 		return ((val != null) && (val.indexOf("-") != -1));
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * columnHoldsObjectName:
1:67614ad: 	 * Return true if the received column, which is from
1:67614ad: 	 * some system table, holds the _name_ of a database
1:67614ad: 	 * object (table, constraint, etc.).  Typically, we
1:67614ad: 	 * can just look for the keyword "NAME"; the exception
1:67614ad: 	 * is aliases, where the name is held in a column called
1:67614ad: 	 * ALIAS.
1:67614ad: 	 * @param colName Name of the column in question.
1:67614ad: 	 * @return True if the column name indicates that it
1:67614ad: 	 *  holds the _name_ of a database object; false if the
1:67614ad: 	 *  column name indicates that it holds something else.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private boolean columnHoldsObjectName(String colName) {
1:67614ad: 
1:67614ad: 		return (colName.equals("ALIAS") ||
1:67614ad: 				(colName.indexOf("NAME") != -1));
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/* **********************************************
1:67614ad: 	 * printAsHeader:
1:67614ad: 	 * Print the received string to output as a
1:67614ad: 	 * header.
1:67614ad: 	 * @param str String to print.
1:67614ad: 	 ****/
1:67614ad: 
1:67614ad: 	private void printAsHeader(String str) {
1:67614ad: 
1:67614ad: 		writeOut("--\n*******************************************");
1:67614ad: 		writeOut(str);
1:67614ad: 		writeOut("*******************************************\n");
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:0d4cef5:     /**
1:0d4cef5:      * Regression test case for DERBY-6387. Verify that triggers are returned
1:0d4cef5:      * in the order in which they were created.
1:0d4cef5:      */
1:0d4cef5:     private void testDerby6387() throws Exception {
1:0d4cef5:         // Create the test database.
1:0d4cef5:         createTestDatabase("dblook_makeDB_derby6387.sql");
1:0d4cef5: 
1:0d4cef5:         // Run dblook on it.
1:0d4cef5:         lookOne(testDBName);
1:0d4cef5: 
1:0d4cef5:         // Check that the error log was empty.
1:0d4cef5:         dumpFileToSysOut("dblook.log");
1:0d4cef5: 
1:0d4cef5:         // Check the dblook output. Before DERBY-6387 was fixed, TR24 was
1:0d4cef5:         // first in the output. It should be last.
1:0d4cef5:         dumpFileToSysOut(testDBName + ".sql");
1:0d4cef5:     }
1:67614ad: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:         Class<?> clazz = Class.forName("org.apache.derby.jdbc.EmbeddedDriver");
1:         clazz.getConstructor().newInstance();
commit:3130800
/////////////////////////////////////////////////////////////////////////
1:         runDDL( conn, scriptName );
1: 
1: 		conn.close();
1: 
1: 		return;
1: 	}
1: 
1: 	/* **********************************************
1: 	 * runDDL:
1: 	 * Run an sql script.
1: 	 * @param conn database connection
1: 	 * @param scriptName Name of the script
1: 	 ****/
1: 
1: 	static  void runDDL( Connection conn, String scriptName)
1:         throws Exception
1: 	{
1: 			new BufferedReader( new FileReader( scriptName ) );
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:0d4cef5
/////////////////////////////////////////////////////////////////////////
1:             // Test DERBY-6387 - wrong order of triggers
1:             System.out.println("\n-= Start DERBY-6387 test. =-");
1:             testDerby6387();
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Regression test case for DERBY-6387. Verify that triggers are returned
1:      * in the order in which they were created.
1:      */
1:     private void testDerby6387() throws Exception {
1:         // Create the test database.
1:         createTestDatabase("dblook_makeDB_derby6387.sql");
1: 
1:         // Run dblook on it.
1:         lookOne(testDBName);
1: 
1:         // Check that the error log was empty.
1:         dumpFileToSysOut("dblook.log");
1: 
1:         // Check the dblook output. Before DERBY-6387 was fixed, TR24 was
1:         // first in the output. It should be last.
1:         dumpFileToSysOut(testDBName + ".sql");
1:     }
commit:c393694
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		HashMap<String, String> idToNameMap = loadIdMappings(stmt);
/////////////////////////////////////////////////////////////////////////
1: 		HashMap<String, String> idToNameMap, Connection conn)
/////////////////////////////////////////////////////////////////////////
1: 		TreeMap<String, ArrayList<String>> orderedRows =
1:                 new TreeMap<String, ArrayList<String>>();
1: 		ArrayList<String> rowValues = new ArrayList<String>();
1: 		ArrayList<String> duplicateRowIds = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1: 				String mappedName = idToNameMap.get(value);
/////////////////////////////////////////////////////////////////////////
1: 					ArrayList<String> oldRow = orderedRows.put(
1: 						uniqueName.toString(), rowValues);
/////////////////////////////////////////////////////////////////////////
1: 			rowValues = new ArrayList<String>();
1:         Set<String> objectNames = orderedRows.keySet();
1:         for (String row : objectNames) {
1:             ArrayList<String> colData = orderedRows.get(row);
1:             for (int i = 0; i < colData.size(); i++)
1:                 writeOut((String)colData.get(i));
1:             writeOut("----");
1:         }
/////////////////////////////////////////////////////////////////////////
1: 		String value, String mappedName, ArrayList<String> rowVals)
/////////////////////////////////////////////////////////////////////////
1: 		ArrayList<String> newRow, ArrayList<String> oldRow,
1: 		TreeMap<String, ArrayList<String>> orderedRows)
/////////////////////////////////////////////////////////////////////////
1: 		ArrayList<String> obj = orderedRows.put(newRowId.toString(), newRow);
/////////////////////////////////////////////////////////////////////////
1: 			obj = orderedRows.put(oldRowId.toString(), oldRow);
/////////////////////////////////////////////////////////////////////////
1:     private HashMap<String, String> loadIdMappings(Statement stmt)
1:             throws Exception {
1: 		HashMap<String, String> idToNameMap = new HashMap<String, String>();
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:ebad814
/////////////////////////////////////////////////////////////////////////
1: 				separator + dbName + "\":user=app;password=apppw;";
1: 			separator + dbName + ";user=app;password=apppw";
1: 				"jdbc:derby:" + dbName +
1: 				";shutdown=true;user=app;password=apppw");
/////////////////////////////////////////////////////////////////////////
1: 			separator + dbName + ";user=app;password=apppw";
/////////////////////////////////////////////////////////////////////////
1: 					jarPath + ";shutdown=true,user=app;password=apppw");
/////////////////////////////////////////////////////////////////////////
1: 				"jdbc:derby:" + dbName + ";user=app;password=apppw");
/////////////////////////////////////////////////////////////////////////
1: 		writeOut("\n========== SYSROLES ==========\n");
1: 		rs = stmt.executeQuery
1: 			("select 'dummyFirstCol', " +
1: 			 "roleid || '_' || grantee || '_' || grantor as rgd, " +
1: 			 "roleid, grantee, grantor, withadminoption, isdef " +
1: 			 "from sys.sysroles");
1: 		dumpResultSet(rs, idToNameMap, null);
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: 				String uniquePiece;
1: 
1: 				if (colName.equals("RGD")) {
1: 					// Role Grant Descriptor: synthetic unique column, see query
1: 					// from SYS.SYSROLES.
1: 					uniquePiece = value;
1: 				} else {
1: 					uniquePiece = dumpColumnData(colName,
1: 												 value, mappedName, rowValues);
1: 				}
1: 
/////////////////////////////////////////////////////////////////////////
1: 				"jdbc:derby:" + newDBName +
1: 				";create=true;user=app;password=apppw" + territoryBased);
/////////////////////////////////////////////////////////////////////////
1: 					deletePath + ";shutdown=true;user=app;password=apppw");
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:cd8191c
/////////////////////////////////////////////////////////////////////////
1: 	protected static String testDBName = "wombat";
1: 	protected static String territoryBased = "";
1: 	protected static String expectedCollation = "UCS_BASIC";
/////////////////////////////////////////////////////////////////////////
1: 		renameDbLookLog("dblook_test");
/////////////////////////////////////////////////////////////////////////
1: 
1: 		// Set the system schema to ensure that UCS_BASIC collation is used.
1: 		stmt.executeUpdate("SET SCHEMA SYS");
1: 
1: 		// Ensure that the database has the expected collation type. 
1: 		ResultSet rs = null;
1: 		try {
1: 			rs = stmt.executeQuery("VALUES SYSCS_UTIL.SYSCS_GET_DATABASE_PROPERTY('derby.database.collation')");
1: 			rs.next();
1: 			String collation = rs.getString(1); 
1: 			if (collation == null || !collation.equals(expectedCollation)) {
1: 				throw new SQLException("Collation doesn't match with the expected type " + 
1: 						expectedCollation);
1: 			}
1: 		} catch (Exception e) {
1: 			System.out.println("FAILED: incorrect database collation\n");
1: 			System.out.println(e.getMessage());
1: 		} finally {
1: 			if (rs != null) {
1: 				rs.close();
1: 			}
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 		rs =
/////////////////////////////////////////////////////////////////////////
0: 				"jdbc:derby:" + newDBName + ";create=true" + territoryBased);
/////////////////////////////////////////////////////////////////////////
1: 	 * renameDbLookLog:
1: 	 * Checks if the logfile of dblook exists and
1: 	 * tries to rename it to prevent possible 
1: 	 * next tests from failing. The log should not be 
1: 	 * deleted because the output may be examined in 
1: 	 * case a test fails.
1: 	 * The new name of dblook.log should be dblook_testname#.log,
1: 	 * where # is a 'version' number. The 'version' number is
1: 	 * needed because the same test may be run multiple
1: 	 * times with different parameters.
1: 	 * @param nameOfTest Name of the finished test.
1: 	 ****/
1: 
1: 	protected static void renameDbLookLog(String nameOfTest)
1: 	{
1: 		File dbLookTestLog = new File("dblook.log");
1: 		if (dbLookTestLog.exists()) {
1: 			int i = 0;
1: 			String renamedLogName = nameOfTest + i + ".log";
1: 			File renamedLog = new File(renamedLogName);
1: 			while (renamedLog.exists()) {
1: 				i++;
1: 				renamedLogName = nameOfTest + i + ".log";
1: 				renamedLog = new File(renamedLogName);
1: 			}
1: 			if (!dbLookTestLog.renameTo(renamedLog)) {
1: 				System.out.println("Failed to rename dblook.org to " + 
1: 						renamedLogName);
1: 			}
1: 		}
1: 	}
1: 
1: 	/* **********************************************
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:dff95a1
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6a85bc6
/////////////////////////////////////////////////////////////////////////
1: 	protected static String testDirectory = "dblook_test";
/////////////////////////////////////////////////////////////////////////
1: 		String systemhome = System.getProperty("derby.system.home");
1: 		dbPath = systemhome + File.separatorChar;
commit:5ff5941
/////////////////////////////////////////////////////////////////////////
1: 		String hostName = TestUtil.getHostName();
1: 		jdbcProtocol = TestUtil.getJdbcUrlPrefix(hostName,SERVER_PORT);
commit:97cb351
/////////////////////////////////////////////////////////////////////////
1: 	protected static final String dbCreationScript_1 = "dblook_makeDB.sql";
1: 	protected static final String dbCreationScript_2 = "dblook_makeDB_2.sql";
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			// Test full dblook functionality.
1: 			System.out.println("\n-= Start dblook Functional Tests. =-");
1: 			createTestDatabase(dbCreationScript_1);
1: 			runDBLook(testDBName);
1: 
1: 			// Test dblook messages.
1: 			System.out.println("\n-= Start dblook Message Tests =-");
1: 			createTestDatabase(dbCreationScript_2);
1: 			runMessageCheckTest(testDBName);
1: 			se.printStackTrace(System.out);
1: 				se.printStackTrace(System.out);
1: 			e.printStackTrace(System.out);
/////////////////////////////////////////////////////////////////////////
1: 	 * @param scriptName The name of the sql script
1: 	 *  to use for creating the test database.
1: 	protected void createTestDatabase(String scriptName)
1: 		// Delete existing database, if it exists.
1: 		try {
1: 			deleteDB(testDBName);
1: 		} catch (Exception e) {
1: 			System.out.println("** Warning: failed to delete " +
1: 				"old test db before creating a new one...");
1: 		}
1: 
1: 		createDBFromDDL(testDBName, scriptName);
/////////////////////////////////////////////////////////////////////////
1: 	 * runDBLook:
/////////////////////////////////////////////////////////////////////////
1: 	private void runDBLook(String dbName)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			e.printStackTrace(System.out);
1: 				e.printStackTrace(System.out);
1: 			e.printStackTrace(System.out);
/////////////////////////////////////////////////////////////////////////
1: 
1: 			new dblook(new String[] {
1: 				"-d", sourceDBUrl,
1: 				"-o", dbName + ".sql",
1: 				"-td", "" }
1: 			);
1: 
1: 			e.printStackTrace(System.out);
/////////////////////////////////////////////////////////////////////////
1: 		new dblook(new String[] {
/////////////////////////////////////////////////////////////////////////
1: 		String [] fullArgs = new String[args.length+2];
1: 		for (int i = 2; i < fullArgs.length; i++)
1: 			fullArgs[i] = args[i-2];
1: 			new dblook(fullArgs);
1: 			System.out.println("FAILED: to run dblook: ");
1: 			e.printStackTrace(System.out);
1: 		}
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * runMessageCheckTest
1: 	 * Run dblook and verify that all of the dblook
1: 	 * messages are correctly displayed.
1: 	 * @param dbName The name of the source database (i.e.
1: 	 *  the database for which the DDL is generated).
1: 	 * @return The DDL for a simple database, plus all
1: 	 *  dblook messages, have been generated and written
1: 	 *  to System.out.
1: 	 ****/
1: 	private void runMessageCheckTest(String dbName)
1: 		throws Exception
1: 	{
1: 
1: 		// #1: First, run DB look standard to check for
1: 		// all of the "header" messages that are printed
1: 		// out along with DDL.
1: 		System.out.println("\n************\n" +
1: 			"Msg Test 1\n" +
1: 			"************\n");
1: 		lookOne(dbName);
1: 		dumpFileToSysOut(dbName + ".sql");
1: 		dumpFileToSysOut("dblook.log");
1: 
1: 		// Now, we have to run some additional dblook commands
1: 		// to get the "non-standard" messages.
1: 
1: 		// #2: Specify a target table and target schema, to
1: 		// make sure they are echoed correctly.  Also, specify
1: 		// an output file to make sure the file creation header
1: 		// is printed in the file.
1: 		System.out.println(
1: 			"\n************\n" +
1: 			"Msg Test 2\n" +
1: 			"************\n");
1: 		go(dbName, new String [] {
1: 				"-t", "t1",
1: 				"-z", "bar",
1: 				"-o", dbName + ".sql"
1: 			});
1: 		dumpFileToSysOut(dbName + ".sql");
1: 		dumpFileToSysOut("dblook.log");
1: 
1: 		// #3: Run without specifying a database, to make
1: 		// sure the usage message is printed to System.out
1: 		System.out.println(
1: 			"\n************\n" +
1: 			"Msg Test 3\n" +
1: 			"************\n");
1: 		try {
1: 			new dblook(new String[] { "-verbose" });
1: 		} catch (Exception e) {
1: 			System.out.println("FAILED: to run dblook: ");
1: 			e.printStackTrace(System.out);
1: 		}
1: 
1: 		// #4: Just to confirm, try once with a statement
1: 		// delimiter, to make sure it's actually working
1: 		// correctly (this isn't a "message" per se, but
1: 		// still, it's worth verifying).
1: 		System.out.println(
1: 			"\n************\n" +
1: 			"Msg Test 4\n" +
1: 			"************\n");
1: 		go(dbName, new String [] {
1: 				"-td", " " + TEST_DELIMITER
1: 			});
1: 
1: 		// #5: Intentionally create an error while loading
1: 		// a jar file, to make sure the resultant message is
1: 		// printed correctly.
1: 		System.out.println(
1: 			"\n************\n" +
1: 			"Msg Test 5\n" +
1: 			"************\n");
1: 
1: 		// We'll cause the error by going in and deleting
1: 		// the jar file from the test database.  First,
1: 		// get the jar path.
1: 		String jarPath = (new
1: 			File(dbPath + separator + dbName)).getAbsolutePath();
1: 
1: 		// Have to shut db down before we can mess with it.
1: 		try {
1: 			Connection conn =
1: 				DriverManager.getConnection("jdbc:derby:" + 
0: 					jarPath + ";shutdown=true");
1: 			conn.close();
1: 		} catch (SQLException se) {
1: 		// shutdown exception.
1: 		}
1: 
1: 		jarPath = jarPath + separator + "jar";
1: 		deleteFile(new File(jarPath));
1: 
1: 		// Now that we've deleted the jar file, run dblook
1: 		// and check the error.
1: 		go(dbName, new String [] { 
1: 				"-verbose",
1: 				"-o", dbName + ".sql"
1: 			});
1: 		dumpFileToSysOut("dblook.log");
1: 
1: 		// Clean up.
1: 		try {
1: 			deleteFile(new File(dbName + ".sql"));
1: 		} catch (Exception e) {
1: 		// not too big of a deal if we fail; just ignore...
/////////////////////////////////////////////////////////////////////////
1: 			BufferedReader dumpFile =
1: 			String line = dumpFile.readLine();
1: 			if (line != null) {
1: 					"empty.  Contents are:\n" +
1: 					"############## Begin File Contents ################\n");
1: 				do {
1: 					System.out.println(line);
1: 					line = dumpFile.readLine();
1: 				} while (line != null);
1: 				System.out.println(
1: 					"############## End File Contents ################");
1: 			}
1: 			// Close the file.
1: 			dumpFile.close();
1: 
1: 			System.out.println("FAILED: to dump file '" + fName + "'");
1: 			e.printStackTrace(System.out);
commit:67614ad
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyTesting.functionTests.tests.tools
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.tools;
1: 
1: import java.sql.DriverManager;
1: import java.sql.ResultSet;
1: import java.sql.Connection;
1: import java.sql.Statement;
0: import java.sql.PreparedStatement;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
0: import java.sql.SQLWarning;
0: import java.sql.Timestamp;
1: 
0: import java.io.PrintWriter;
0: import java.io.FileOutputStream;
0: import java.io.FileNotFoundException;
1: import java.io.BufferedReader;
1: import java.io.FileReader;
1: import java.io.File;
1: 
1: import org.apache.derby.tools.dblook;
1: import org.apache.derby.catalog.DependableFinder;
1: 
1: import java.util.HashMap;
1: import java.util.TreeMap;
1: import java.util.Set;
0: import java.util.Iterator;
1: import java.util.ArrayList;
0: import java.util.StringTokenizer;
1: 
1: public class dblook_test {
1: 	/* 
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
1: 
1: 	private static final int SERVER_PORT = 1527;
1: 	private static final int FRONT = -1;
1: 	private static final int REAR = 1;
1: 
0: 	private static final String testDBCreationScript = "dblook_makeDB.sql";
1: 	private static final char TEST_DELIMITER='#';
1: 
0: 	protected static String testDirectory = "dblook_test/";
0: 	protected static final String testDBName = "wombat";
1: 	protected static String separator;
1: 
1: 	private static String dbPath;
1: 	private static int duplicateCounter = 0;
1: 	private static int sysNameCount = 0;
1: 	private static String jdbcProtocol;
1: 
1: 	/* **********************************************
1: 	 * main:
0: 	 * @param args Ignored.
1: 	 ****/
1: 
1: 	public static void main (String[] args) {
1: 
0: 		System.out.println("\n-= Start Test. =-");
1: 		separator = System.getProperty("file.separator");
1: 		new dblook_test().doTest();
1: 		System.out.println("\n[ Done. ]\n");
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * doTest
1: 	 * Run a full test of the dblook utility.
1: 	 ****/
1: 
1: 	protected void doTest() {
1: 
1: 		try {
1: 
0: 			createTestDatabase();
0: 			runCSLook(testDBName);
1: 
1: 		} catch (SQLException se) {
1: 
1: 			System.out.println("FAILED: to complete the test:");
0: 			se.printStackTrace();
1: 			for (se = se.getNextException(); se != null;
1: 				se = se.getNextException())
1: 			{
0: 				se.printStackTrace();
1: 			}
1: 		
1: 		} catch (Exception e) {
1: 
1: 			System.out.println("FAILED: to complete the test:");
0: 			e.printStackTrace();
1: 
1: 		}
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * createTestDatabase:
1: 	 * Using the creation script created as part of
1: 	 * the test package, create the database that
1: 	 * will be used as the basis for all dblook
1: 	 * tests.
1: 	 * @return The test database has been created
1: 	 *  in the current test directory, which is
1: 	 *  "./dblook/" (as created by the harness).
1: 	 ****/
1: 
0: 	protected void createTestDatabase()
1: 		throws Exception
1: 	{
1: 
0: 		Class.forName("org.apache.derby.jdbc.EmbeddedDriver").newInstance();
1: 		jdbcProtocol = "jdbc:derby:";
0: 		createDBFromDDL(testDBName, testDBCreationScript);
1: 
1: 		// Figure out where our database directory is (abs path).
0: 		dbPath = (new File(testDirectory)).getAbsolutePath();
1: 		return;
1: 
1: 	}
1: 
1: 	/* **********************************************
0: 	 * runCSLook:
1: 	 * Runs a series of tests using dblook on
1: 	 * the received database.
1: 	 * @param dbName The name of the database on which to
1: 	 *   run the tests.
1: 	 * @return A series of tests intended to verify
1: 	 *  the full functionality of the dblook utility
1: 	 *  has been run.
1: 	 ****/
1: 
0: 	private void runCSLook(String dbName)
1: 		throws Exception
1: 	{
1: 
1: 		// Close the error stream, so that messages
1: 		// printed to System.err aren't intermixed
1: 		// with our output (otherwise, the order
1: 		// of the System.out vs System.err is
1: 		// arbitrary (because of the way the harness
1: 		// works), and so we will get diffs with
1: 		// the master.
1: 		System.err.close();
1: 
1: 		// First, we dump all system catalogs for
1: 		// the original source database to file.
1: 		dumpSysCatalogs(dbName);
1: 
1: 		// Then, we run dblook on the source database
1: 		// with no limitations (i.e. we generate the
1: 		// DDL for the FULL database).
1: 		lookOne(dbName);
1: 		dumpFileToSysOut("dblook.log");
1: 
1: 
1: 		// Now, create new db from the DDL that
1: 		// was generated by dblook.
1: 		String newDBName = dbName + "_new";
1: 		createDBFromDDL(newDBName, dbName + ".sql");
1: 		deleteFile(new File(dbName + ".sql"));
1: 
1: 		// Dump all system catalogs for the database
1: 		// that was created from the DDL generated
1: 		// by dblook.
1: 		dumpSysCatalogs(newDBName);
1: 
1: 		// Delete the new database.
1: 		deleteDB(newDBName);
1: 		deleteFile(new File(newDBName + ".sql"));
1: 
1: 		// Run dblook on the source database
1: 		// with various parameter configurations,
1: 		// to make sure they are all working as
1: 		// planned.
1: 		runAllTests(dbName, newDBName);
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * runAllTests:
1: 	 * Makes the call to execute each of the desired
1: 	 * tests.
1: 	 * @param dbName The name of the database on which to
1: 	 *   run the tests.
1: 	 * @param newDBName The name of the database to be
1: 	 *  created from the DDL that is generated (by
1: 	 *  dblook) for the source database.
1: 	 ****/
1: 
1: 	protected void runAllTests(String dbName,
1: 		String newDBName) throws Exception
1: 	{
1: 
1: 		runTest(2, dbName, newDBName);
1: 
1: 		// Test 3 is run as part of derbynet suite;
1: 		// see derbynet/dblook_test_net.java.
1: 
1: 		runTest(4, dbName, newDBName);
1: 		runTest(5, dbName, newDBName);
1: 		runTest(7, dbName, newDBName);
1: 		runTest(6, dbName, newDBName);
1: 		return;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * runTest:
1: 	 * Runs dblook on the source database with a
1: 	 * specific set of parameters, then uses the
1: 	 * resultant DDL to create a new database, and
1: 	 * dumps the system catalogs for that database
1: 	 * to file.  Finally, the new database is deleted
1: 	 * in preparation for subsequent calls to this
1: 	 * method.
1: 	 * @param whichTest An indication of which test to run;
1: 	 *  each test number has a different set of
1: 	 *  parameters.
1: 	 * @param dbName The name of the source database.
1: 	 * @param newDBName The name of the database to be
1: 	 *  created from the DDL that is generated (by
1: 	 *  dblook) for the source database.
1: 	 * @return dblook has been executed using the
1: 	 *  parameters associated with the given test,
1: 	 *  and that DDL has been written to a ".sql"
1: 	 *  file named after the source database;
1: 	 *  a new database has been created from the
1: 	 *  ".sql" generated by dblook; the system
1: 	 *  catalogs for that new database have been
1: 	 *  dumped to output; and the new database has
1: 	 *  been deleted.
1: 	 ****/
1: 
1: 	protected void runTest(int whichTest, String dbName,
1: 		String newDBName)
1: 	{
1: 
1: 		try {
1: 
1: 			switch(whichTest) {
1: 				case 2:		lookTwo(dbName); break;
1: 				case 3:		lookThree(dbName); break;
1: 				case 4:		lookFour(dbName); break;
1: 				case 5:		lookFive(dbName); break;
1: 				case 6:		lookSix(dbName); break;
1: 				case 7:		lookSeven(dbName); break;
1: 				default:	break;
1: 			}
1: 
1: 			dumpFileToSysOut("dblook.log");
1: 			createDBFromDDL(newDBName, dbName + ".sql");
1: 			dumpSysCatalogs(newDBName);
1: 			deleteDB(newDBName);
1: 			deleteFile(new File(dbName + ".sql"));
1: 
1: 		} catch (SQLException e) {
1: 
1: 			System.out.println("FAILED: Test # : " + whichTest);
1: 			System.out.println(e.getMessage());
1: 			for (e = e.getNextException(); e != null;
1: 				e = e.getNextException())
1: 			{
1: 				System.out.println(e.getMessage());
1: 			}
1: 
1: 		} catch (Exception e) {
1: 
1: 			System.out.println("FAILED: Test # : " + whichTest);
1: 			System.out.println(e.getMessage());
1: 
1: 		}
1: 
1: 		return;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * lookOne:
1: 	 * Use dblook to generate FULL DDL for a given
1: 	 * database.
1: 	 * @param dbName The name of the source database (i.e.
1: 	 *  the database for which the DDL is generated).
1: 	 * @return The full DDL for the source database
1: 	 *  has been generated and written to a file
1: 	 *  called <dbName + ".sql">.
1: 	 ****/
1: 
1: 	private void lookOne(String dbName)
1: 		throws Exception
1: 	{
1: 
1: 		printAsHeader("\nDumping full schema for '" +
1: 			dbName + "'\nto file '" + dbName + ".sql':\n");
1: 
1: 		String [] args = new String[] {
1: 			"-o", dbName + ".sql",
1: 			"-td", ""
1: 		};
1: 
1: 		go(dbName, args);
1: 		return;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * lookTwo:
1: 	 * Use dblook to generate DDL for all objects 
1: 	 * in the source database with schema 'BAR',
1: 	 * excluding views:
1: 	 *  -z bar -noview
1: 	 * @param dbName The name of the source database (i.e.
1: 	 *  the database for which the DDL is generated).
1: 	 * @return The appropriate DDL has been generated
1: 	 *  and written to a file called <dbName + ".sql">.
1: 	 ****/
1: 
1: 	private void lookTwo(String dbName)
1: 		throws Exception
1: 	{
1: 
1: 		printAsHeader("\nDumping DDL for all objects " +
1: 			"with schema\n'BAR', excluding views:\n");
1:  
1: 		String [] args = new String[] {
1: 			"-o", dbName + ".sql",
1: 			"-td", "",
1: 			"-z", "bar",
1: 			"-noview"
1: 		};
1: 
1: 		go(dbName, args);
1: 		return;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * lookThree:
1: 	 * Use dblook to generate DDL for all objects
1: 	 * in the source database, using Network
1: 	 * Server.
1: 	 * @param dbName The name of the source database (i.e.
1: 	 *  the database for which the DDL is generated).
1: 	 * @return The appropriate DDL has been generated
1: 	 *  and written to a file called <dbName + ".sql">.
1: 	 ****/
1: 
1: 	private void lookThree(String dbName)
1: 		throws Exception
1: 	{
1: 
1: 		printAsHeader("\nDumping DDL for all objects, " +
1: 			"using\nNetwork Server:\n");
1:  
0: 		jdbcProtocol = "jdbc:derby:net://localhost:" +
0: 			SERVER_PORT + "/";
0: 		String sourceDBUrl = jdbcProtocol + "\"" + dbPath +
0: 			separator + dbName + "\":user=someusr;password=somepwd;";
1: 
1: 		// Make sure we're not connected to the database
1: 		// (we connected to it in embedded mode when we
1: 		// created it, so we have to shut it down).
1: 		try {
1: 			DriverManager.getConnection(
0: 				"jdbc:derby:" + dbName + ";shutdown=true");
1: 		} catch (SQLException e) {}
1: 
1: 		// Run the test.
1: 
0: 		dblook looker = new dblook(new String[] {
0: 			"-d", sourceDBUrl,
1: 			"-o", dbName + ".sql",
0: 			"-td", "" }
1: 		);
1: 
1: 		try {
0: 			looker.go(sourceDBUrl, dbPath + separator + dbName);
1: 		} catch (Exception e) {
1: 			System.out.println("FAILED: ");
0: 			e.printStackTrace();
1: 		}
1: 
1: 		return;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * lookFour:
1: 	 * Use dblook to generate DDL for all objects 
1: 	 * in the source database with schema 'BAR'
1: 	 * that are related to tables 'T3', 'tWithKeys',
1: 	 * and 'MULTI WORD NAME'.
1: 	 *  -z bar -t t3 "\"tWithKeys\"" "Multi word name"
1: 	 * @param dbName The name of the source database (i.e.
1: 	 *  the database for which the DDL is generated).
1: 	 * @return The appropriate DDL has been generated
1: 	 *  and written to a file called <dbName + ".sql">.
1: 	 ****/
1: 
1: 	private void lookFour(String dbName)
1: 		throws Exception
1: 	{
1: 
1: 		printAsHeader("\nDumping DDL for all objects " +
1: 			"with schema 'BAR'\nthat are related to tables " +
1: 			"'T3', 'tWithKeys',\nand 'MULTI WORD NAME':\n");
1:  
1: 		String [] args = new String [] {
1: 			"-o", dbName + ".sql",
1: 			"-td", "",
1: 			"-z", "BAR",
1: 			"-t", "t3", "\"tWithKeys\"", "Multi word name"
1: 		};
1: 
1: 		go(dbName, args);
1: 		return;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * lookFive:
1: 	 * Use dblook to generate DDL for all objects 
1: 	 * in the source database (with any schema)
1: 	 * that are related to table 'T1' and 'TWITHKEYS'
1: 	 * (with no matches existing for the latter).
1: 	 * 	-t t1 "tWithKeys"
1: 	 * @param dbName The name of the source database (i.e.
1: 	 *  the database for which the DDL is generated).
1: 	 * @return The appropriate DDL has been generated
1: 	 *  and written to a file called <dbName + ".sql">.
1: 	 ****/
1: 
1: 	private void lookFive(String dbName)
1: 		throws Exception
1: 	{
1: 
1: 		printAsHeader("\nDumping DDL for all objects " +
1: 			"related to 'T1'\nand 'TWITHKEYS':\n");
1:  
1: 		String [] args = new String [] {
1: 			"-o", dbName + ".sql",
1: 			"-td", "",
1: 			"-t", "t1", "tWithKeys"
1: 		};
1: 
1: 		go(dbName, args);
1: 		return;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * lookSix:
1: 	 * Call dblook with an invalid url, to make
1: 	 * sure that errors are printed to log.
1: 	 *   -d <dbName> // missing protocol.
1: 	 * @param dbName The name of the source database (i.e.
1: 	 *  the database for which the DDL is generated).
1: 	 * @return The appropriate DDL has been generated
1: 	 *  and written to a file called <dbName + ".sql">.
1: 	 ****/
1: 
1: 	private void lookSix(String dbName)
1: 		throws Exception
1: 	{
1: 
1: 		printAsHeader("\nDumping DDL w/ invalid url, and " +
1: 			"writing\nerror to the log:\n");
1:  
1: 		// Url is intentionally incorrect; it will cause an error.
0: 		dblook looker = new dblook(new String[] {
1: 			"-o", dbName + ".sql",
1: 			"-d", dbName }
1: 		);
1: 		try {
0: 			looker.go(dbName, dbName);
1: 		} catch (Exception e) {
0: 		// we expect it to go wrong.
1: 		}
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * lookSeven:
1: 	 * Use dblook to generate DDL for all objects 
1: 	 * in the source database with schema '"Quoted"Schema"'.
1: 	 *  -z \"\"Quoted\"Schema\"\"
1: 	 * @param dbName The name of the source database (i.e.
1: 	 *  the database for which the DDL is generated).
1: 	 * @return The appropriate DDL has been generated
1: 	 *  and written to a file called <dbName + ".sql">.
1: 	 ****/
1: 
1: 	private void lookSeven(String dbName)
1: 		throws Exception
1: 	{
1: 
1: 		printAsHeader("\nDumping DDL for all objects " +
1: 			"with schema\n'\"Quoted\"Schema\"':\n");
1:  
1: 		String [] args = new String[] {
1: 			"-o", dbName + ".sql",
1: 			"-td", "",
1: 			"-z", "\"\"Quoted\"Schema\"\""
1: 		};
1: 
1: 		go(dbName, args);
1: 		return;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * go:
1: 	 * Makes the call to execute the dblook command
1: 	 * using the received arguments.
1: 	 * @param dbName The name of the source database (i.e.
1: 	 *  the database for which the DDL is generated).
1: 	 * @args The list of arguments with which to execute
1: 	 *  the dblook command.
1: 	 ****/
1: 
1: 	private void go(String dbName, String [] args) {
1: 
1: 		jdbcProtocol = "jdbc:derby:";
1: 		String sourceDBUrl = jdbcProtocol + dbPath +
0: 			separator + dbName;
1: 
0: 		String [] fullArgs = new String[args.length+3];
1: 		fullArgs[0] = "-d";
1: 		fullArgs[1] = sourceDBUrl;
0: 		fullArgs[2] = "-append";
0: 		for (int i = 3; i < fullArgs.length; i++)
0: 			fullArgs[i] = args[i-3];
1: 
0: 		dblook looker = new dblook(fullArgs);
1: 		try {
0: 			looker.go(sourceDBUrl, dbPath + separator + dbName);
1: 		} catch (Exception e) {
1: 			System.out.println("FAILED: ");
0: 			e.printStackTrace();
1: 		}
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * dumpSysCatalogs:
1: 	 * Takes a database name and dumps ALL of the
1: 	 * system catalogs for that database, with the
1: 	 * exception of SYSSTATISTICS.  This allows us
1: 	 * to look at the full contents of a database's
1: 	 * schema (without using dblook, of course)
1: 	 * so that we can see if the databases created
1: 	 * from the DDL generated by dblook have been
1: 	 * built correctly--if they have all of the
1: 	 * correct system catalog information, then
1: 	 * the databases themselves must be correct.
1: 	 * @param dbName The name of the database for which
1: 	 *  we are dumping the system catalogs.
1: 	 * @return All of the system catalogs for
1: 	 *  the received database have been dumped
1: 	 *  to output.
1: 	 ****/
1: 
1: 	private void dumpSysCatalogs(String dbName)
1: 		throws Exception
1: 	{
1: 
1: 		System.out.println("\nDumping system tables for '" + dbName + "'\n");
1: 
1: 		writeOut("\n----------------=================---------------");
1: 		writeOut("System Tables for: " + dbName);
1: 		writeOut("----------------=================---------------\n");
1: 
1: 		// Connect to the database.
1: 		Connection conn = DriverManager.getConnection(
0: 				"jdbc:derby:" + dbName);
1: 		conn.setAutoCommit(false);
1: 		Statement stmt = conn.createStatement();
1: 
1: 		// Load any id-to-name mappings that will be useful
1: 		// when dumping the catalogs.
0: 		HashMap idToNameMap = loadIdMappings(stmt, conn);
1: 
1: 		// Go through and dump all system catalog information,
1: 		// filtering out database-dependent id's so that they
1: 		// won't cause diffs.
1: 
1: 		writeOut("\n========== SYSALIASES ==========\n");
0: 		ResultSet rs =
1: 			stmt.executeQuery("select schemaid, sys.sysaliases.* from sys.sysaliases");
1: 		dumpResultSet(rs, idToNameMap, null);
1: 
1: 		writeOut("\n========== SYSCHECKS ==========\n");
1: 		rs = stmt.executeQuery("select c.schemaid, ck.* from " +
1: 			"sys.syschecks ck, sys.sysconstraints c where " +
1: 			"ck.constraintid = c.constraintid");
1: 		dumpResultSet(rs, idToNameMap, null);
1: 
1: 		writeOut("\n========== SYSCOLUMNS ==========\n");
1: 		writeOut("--- Columns for Tables ---");
1: 		rs = stmt.executeQuery("select t.schemaid, c.* from " +
1: 			"sys.syscolumns c, sys.systables t where c.referenceid " +
1: 			"= t.tableid" );
1: 		dumpResultSet(rs, idToNameMap, null);
1: 		writeOut("\n--- Columns for Statements ---");
1: 		rs = stmt.executeQuery("select s.schemaid, c.* from " +
1: 			"sys.syscolumns c, sys.sysstatements s where c.referenceid " +
1: 			"= s.stmtid" );
1: 		dumpResultSet(rs, idToNameMap, null);
1: 
1: 		writeOut("\n========== SYSCONGLOMERATES ==========\n");
1: 		rs = stmt.executeQuery("select schemaid, sys.sysconglomerates.* " +
1: 			"from sys.sysconglomerates");
1: 		dumpResultSet(rs, idToNameMap, null);
1: 
1: 		writeOut("\n========== SYSCONSTRAINTS ==========\n");
1: 		rs = stmt.executeQuery("select schemaid, sys.sysconstraints.* " +
1: 			"from sys.sysconstraints");
1: 		dumpResultSet(rs, idToNameMap, null);
1: 
1: 		writeOut("\n========== SYSDEPENDS ==========\n");
1: 		rs = stmt.executeQuery("select dependentid, sys.sysdepends.* from sys.sysdepends");
1: 		dumpResultSet(rs, idToNameMap, conn);
1: 
1: 		writeOut("\n========== SYSFILES ==========\n");
1: 		rs = stmt.executeQuery("select schemaid, sys.sysfiles.* from sys.sysfiles");
1: 		dumpResultSet(rs, idToNameMap, null);
1: 
1: 		writeOut("\n========== SYSFOREIGNKEYS ==========\n");
1: 		rs = stmt.executeQuery("select c.schemaid, fk.* from " +
1: 			"sys.sysforeignkeys fk, sys.sysconstraints c where " +
1: 			"fk.constraintid = c.constraintid");
1: 		dumpResultSet(rs, idToNameMap, null);
1: 
1: 		writeOut("\n========== SYSKEYS ==========\n");
1: 		rs = stmt.executeQuery("select c.schemaid, k.* from " +
1: 			"sys.syskeys k, sys.sysconstraints c where " +
1: 			"k.constraintid = c.constraintid");
1: 		dumpResultSet(rs, idToNameMap, null);
1: 
1: 		writeOut("\n========== SYSSCHEMAS ==========\n");
1: 		rs = stmt.executeQuery("select schemaid, sys.sysschemas.* from sys.sysschemas");
1: 		dumpResultSet(rs, idToNameMap, null);
1: 
1: 		writeOut("\n========== SYSSTATEMENTS ==========\n");
1: 		rs = stmt.executeQuery("select schemaid, sys.sysstatements.* from sys.sysstatements");
1: 		dumpResultSet(rs, idToNameMap, null);
1: 
1: 		writeOut("\n========== SYSTABLES ==========\n");
1: 		rs = stmt.executeQuery("select schemaid, sys.systables.* from sys.systables");
1: 		dumpResultSet(rs, idToNameMap, null);
1: 
1: 		writeOut("\n========== SYSTRIGGERS ==========\n");
1: 		rs = stmt.executeQuery("select schemaid, sys.systriggers.* from sys.systriggers");
1: 		dumpResultSet(rs, idToNameMap, null);
1: 
1: 		writeOut("\n========== SYSVIEWS ==========\n");
1: 		rs = stmt.executeQuery("select compilationschemaid, sys.sysviews.* from sys.sysviews");
1: 		dumpResultSet(rs, idToNameMap, null);
1: 
1: 		stmt.close();
1: 		rs.close();
1: 		conn.commit();
1: 		conn.close();
1: 		return;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * isIgnorableSchema:
1:      * Returns true if the the schema is a "system" schema, vs. a user 
1:      * schema.  
1: 	 * @param schemaName name of schema to check.
1: 	 ****/
1: 	private boolean isIgnorableSchema(String schemaName) {
1: 
1:         boolean ret = false;
1: 
1:         for (int i = ignorableSchemaNames.length - 1; i >= 0;)
1:         {
1:             if ((ret = ignorableSchemaNames[i--].equalsIgnoreCase(schemaName)))
1:                 break;
1:         }
1: 
1:         return(ret);
1: 	}
1: 
1:     private static final String[] ignorableSchemaNames = {
1:         "SYSIBM",
1:         "SYS",
1:         "SYSVISUAL",
1:         "SYSCAT",
1:         "SYSFUN",
1:         "SYSPROC",
1:         "SYSSTAT",
1:         "NULLID",
1:         "SYSCS_ADMIN",
1:         "SYSCS_DIAG",
1:         "SYSCS_UTIL",
1:         "SQLJ"};
1: 
1: 	/* **********************************************
1: 	 * dumpResultSet:
1: 	 * Iterates through the received result set and
1: 	 * dumps ALL columns in ALL rows of that result
1: 	 * set to output.  Since no order is guaranteed
1: 	 * in the received result set, we have to generate
1: 	 * unique "ids" for each row in the result, and
1: 	 * then use those ids to determine what order the
1: 	 * rows will be output.  Failure to do so will
1: 	 * lead to diffs in the test for rows that occur
1: 	 * out of order.  The unique id's must NOT
1: 	 * depend on system-generated id's, as the
1: 	 * latter will vary for every run of the test,
1: 	 * and thus will lead to different orderings
1: 	 * every time (which we don't want).
1: 	 *
1: 	 * @param rs The result set that is being dumped.
1: 	 * @param idToNameMap Mapping of various ids to
1: 	 *  object names; used in forming unique ids.
1: 	 * @param conn Connection from which the result set
1: 	 *  originated.
1: 	 ****/
1: 
1: 	private void dumpResultSet (ResultSet rs,
0: 		HashMap idToNameMap, Connection conn)
1: 		throws Exception
1: 	{
1: 
1: 		// We need to form unique names for the rows of the
1: 		// result set so that we can preserve the order of
1: 		// the output and avoid diffs with a master.  This is
1: 		// because a "select *" doesn't order rows--and even
1: 		// though the schema for two databases might be the
1: 		// same (i.e. the system tables contain all of the same
1: 		// information) there's nothing to say the various rows in
1: 		// the respective system tables will be the same (they
1: 		// usually are NOT).  While system id's automatically
1: 		// give us uniqueness, we can NOT order on them because
1: 		// they vary from database to database; so, we need
1: 		// to use something constant across the databases,
1: 		// which is why we use object names.
1: 		StringBuffer uniqueName = new StringBuffer();
1: 
0: 		TreeMap orderedRows = new TreeMap();
0: 		ArrayList rowValues = new ArrayList();
0: 		ArrayList duplicateRowIds = new ArrayList();
1: 
1: 		ResultSetMetaData rsmd = rs.getMetaData();
1: 		int cols = rsmd.getColumnCount();
1: 		while (rs.next()) {
1: 
1: 			for (int i = 1; i <= cols; i++) {
1: 
1: 				String colName = rsmd.getColumnName(i);
1: 				String value = rs.getString(i);
0: 				String mappedName = (String)idToNameMap.get(value);
1: 
1: 				if ((colName.indexOf("SCHEMAID") != -1) &&
1: 					(mappedName != null) &&
1: 					((mappedName.indexOf("SYS") != -1) ||
1:                      (isIgnorableSchema(mappedName))))
1:                 {
1: 				// then this row of the result set is for a system
1: 				// object, which will always be the same for the
1: 				// source and new database, so don't bother dumping
1: 				// them to the output file (makes the test less
1: 				// like to require updates when changes to database
1: 				// metadata for system objects are checked in).
1: 					rowValues = null;
1: 					break;
1: 				}
0: 				else if (colName.equals("JAVACLASSNAME") &&
1: 					(value.indexOf("org.apache.derby") != -1) &&
1: 					(value.indexOf(".util.") == -1)) {
1: 				// this is a -- hack -- to see if the alias is a
1: 				// a system alias, needed because aliases
1: 				// (other than stored procedures) do not have
1: 				// an associated schema).
1: 					rowValues = null;
1: 					break;
1: 				}
1: 
1: 				if (i == 1)
1: 				// 1st column is just for figuring out whether
1: 				// to dump this row; no need to actually include
1: 				// it in the results.
1: 					continue;
1: 
0: 				String uniquePiece = dumpColumnData(colName,
0: 					value, mappedName, rowValues);
1: 
1: 				if (colName.equals("DEPENDENTID")) {
1: 				// Special case: rows in the "DEPENDS" table
1: 				// don't have unique ids or names; we have to
1: 				// build one by extracting information indirectly.
1: 					String hiddenInfo = getDependsData(rs, conn,
1: 						idToNameMap);
1: 					if (hiddenInfo.indexOf("SYS_OBJECT") != -1) {
1: 					// this info is for a system object, so
1: 					// ignore it.
1: 						rowValues = null;
1: 						break;
1: 					}
1: 					uniqueName.append(hiddenInfo);
1: 					// Include the hidden data as part of the
1: 					// output.
1: 					rowValues.add(hiddenInfo);
1: 				}
1: 
1: 		 		if (uniquePiece != null)
1: 					uniqueName.append(uniquePiece);
1: 
1: 				if (colName.equals("STMTNAME") &&
1: 				  (value.indexOf("TRIGGERACTN") != -1))
1: 				// Special case: can't use statement name, because
1: 				// the entire statement may be automatically generated
1: 				// in each database (to back a trigger), so the name
1: 				// in which case the generated name will be different
1: 				// every time; but filtering out the name means
1: 				// we have no other guaranteed unique 'id' for
1: 				// ordering.  So, just take "text" field, and
1: 				// design test db so that no two triggers have the
1: 				// same text value.
1: 				uniqueName.append(rs.getString(6));
1: 
1: 			}
1: 
1: 			if (rowValues != null) {
1: 
1: 				if (duplicateRowIds.contains(uniqueName.toString()))
1: 				// then we've already encountered this row id before;
1: 				// to preserve ordering, use the entire row as an
1: 				// id.
1: 					handleDuplicateRow(rowValues, null, orderedRows);
1: 				else {
0: 					ArrayList oldRow = (ArrayList)(orderedRows.put(
0: 						uniqueName.toString(), rowValues));
1: 					if (oldRow != null) {
1: 					// Duplicate row id.
1: 						duplicateRowIds.add(uniqueName.toString());
1: 						// Delete the row that has the duplicate row id.
1: 							orderedRows.remove(uniqueName.toString());
1: 						handleDuplicateRow(rowValues, oldRow, orderedRows);
1: 					}
1: 				}
1: 			}
1: 
1: 			uniqueName = new StringBuffer();
0: 			rowValues = new ArrayList();
1: 
1: 		}
1: 
1: 		// Now, print out all of the data in this result set
1: 		// using the order of the unique names that we created.
0: 		Set objectNames = orderedRows.keySet();
0: 		for (Iterator itr = objectNames.iterator();
0: 			itr.hasNext(); ) {
1: 
0: 			String row = (String)itr.next();
0: 			ArrayList colData = (ArrayList)orderedRows.get(row);
0: 			for (int i = 0; i < colData.size(); i++)
0: 				writeOut((String)colData.get(i));
0: 			writeOut("----");
1: 
1: 		}
1: 
1: 		orderedRows = null;
1: 		rs.close();
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * dumpColumnData:
1: 	 * Stores the value for a specific column of
1: 	 * some result set.  If the value needs to
1: 	 * be filtered (to remove system-generated ids
1: 	 * that would otherwise cause diffs with the
1: 	 * master), that filtering is done here.
1: 	 * @param colName Name of the column whose value we're
1: 	 *  writing.
1: 	 * @param value Value that we're writing.
1: 	 * @param mappedName: Name corresponding to the value,
1: 	 *  for cases where the value is actually an
1: 	 *  object id (then we want to write the name
1: 	 *  instead).
1: 	 * rowValues a list of column values for the
1: 	 *  current row of the result set.
1: 	 * @return The (possibly filtered) value of the
1: 	 *  received column has been added to the
1: 	 *  "rowVals" array list, and the corresponding
1: 	 *  piece of the row's unique name has been
1: 	 *  returned, if one exists.
1: 	 ****/
1: 
1: 	private String dumpColumnData(String colName,
0: 		String value, String mappedName, ArrayList rowVals)
1: 	{
1: 
1: 		if (mappedName == null) {
1: 		// probably not an id.
1: 			if (colName.equals("CONGLOMERATENUMBER") ||
1: 				colName.equals("GENERATIONID"))
1: 			// special case: these numbers aren't ids per
1: 			// se, but they are still generated by the system,
1: 			// and will cause diffs with the master; so, ignore
1: 			// them.
1: 				rowVals.add("<systemnumber>");
1: 			else if (colName.equals("AUTOINCREMENTVALUE"))
1: 			// special case: new database won't have any data,
1: 			// old will, so unless we filter this out, we'll
1: 			// get a diff.
1: 				rowVals.add("<autoincval>");
1: 			else if (colName.equals("VALID"))
1: 			// special case: ignore whether or not stored
1: 			// statements are valid (have been compiled)
1: 			// since it depends on history of database,
1: 			// which we can't duplicate.
1: 				rowVals.add("<validityflag>");
1: 			else if (value != null) {
1: 				if (looksLikeSysGenName(value)) {
1: 					if (columnHoldsObjectName(colName))
1: 						rowVals.add("<systemname>");
1: 					else {
1: 					// looks like a sys gen name, but's actually a VALUE.
1: 						rowVals.add(value);
1: 						return value;
1: 					}
1: 				}
1: 				else if (looksLikeSysGenId(value))
1: 					rowVals.add("<systemid>");
1: 				else {
1: 					rowVals.add(value);
1: 					if (columnHoldsObjectName(colName))
1: 					// if it's a name, we need it as part of
1: 					// our unique id.
1: 						return value;
1: 				}
1: 			}
1: 			else
1: 			// null value.
1: 				rowVals.add(value);
1: 		}
1: 		else {
1: 		// it's an id, so write the corresponding name.
1: 			if (!isSystemGenerated(mappedName)) {
1: 			// Not an id-as-name, so use it as part of our unique id.
1: 				rowVals.add(mappedName);
1: 				return mappedName;
1: 			}
1: 			else
1: 				rowVals.add("<systemname>");
1: 		}
1: 
1: 		// If we get here, we do NOT want the received value
1: 		// to be treated as part of this row's unique name.
1: 		return null;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * handleDuplicateRow:
1: 	 * If we get here, then despite our efforts (while
1: 	 * dumping the system catalogs for a database), we
1: 	 * still have a duplicate row id.  So, as a last
1: 	 * resort we just use the ENTIRE row as a 'row id'.
1: 	 * In the rare-but-possible case that the entire
1: 	 * row is a duplicate (as can happen with the
1: 	 * SYSDEPENDS table), then we tag a simple number
1: 	 * onto the latest row's id, so that the row will
1: 	 * still show up multiple times--and since the rows
1: 	 * are identical, it doesn't matter which comes
1: 	 * 'first'.
1: 	 * @param newRow The most recently-fetched row from
1: 	 *  the database system catalogs.
1: 	 * @param oldRow The row that was replaced when the
1: 	 *  newRow was inserted (because they had the
1: 	 *  same row id), or "null" if we were already
1: 	 *  here once for this row id, and so just want
1: 	 *  insert a new row.
1: 	 * @param orderedRows The ordered set of rows, into
1: 	 *  which oldRow and newRow need to be inserted.
1: 	 * @return oldRow and newRow have been inserted
1: 	 *  into orderedRows, and each has a (truly)
1: 	 *  unique id with it.
1: 	 ****/
1: 
1: 	private void handleDuplicateRow(
0: 		ArrayList newRow, ArrayList oldRow,
0: 		TreeMap orderedRows)
1: 	{
1: 
1: 		// Add the received rows (old and new) with
1: 		// unique row ids.
1: 
1: 		StringBuffer newRowId = new StringBuffer();
1: 		for (int i = 0; i < newRow.size(); i++)
1: 			newRowId.append((String)newRow.get(i));
1: 
0: 		Object obj = (ArrayList)(orderedRows.put(
0: 						newRowId.toString(), newRow));
1: 		if (obj != null)
1: 		// entire row is a duplicate.
1: 			orderedRows.put(newRowId.toString() + 
1: 				duplicateCounter++, newRow);
1: 
1: 		if (oldRow != null) {
1: 
1: 			StringBuffer oldRowId = new StringBuffer();
1: 			for (int i = 0; i < oldRow.size(); i++)
1: 				oldRowId.append((String)oldRow.get(i));
1: 
0: 			obj = (ArrayList)(orderedRows.put(
0: 				oldRowId.toString(), oldRow));
1: 			if (obj != null)
1: 			// entire row is a duplicate.
1: 				orderedRows.put(oldRowId.toString() +
1: 					duplicateCounter++, oldRow);
1: 		}
1: 
1: 		return;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * createDBFromDDL:
1: 	 * Read from the given script and use it to create
1: 	 * a new database of the given name.
1: 	 * @param newDBName Name of the database to be created.
1: 	 * @param scriptName Name of the script containing the
1: 	 *  DDL from which the new database will be created.
1: 	 * @return New database has been created from
1: 	 *   the script; any commands in the script that
1: 	 *   failed to execute have been echoed to output.
1: 	 ****/
1: 
1: 	private void createDBFromDDL(String newDBName,
1: 		String scriptName) throws Exception
1: 	{
1: 
1: 		System.out.println("\n\nCreating database '" + newDBName +
1: 			"' from ddl script '" + scriptName + "'");
1: 
1: 		Connection conn = DriverManager.getConnection(
0: 			"jdbc:derby:" + newDBName + ";create=true");
1: 
1: 		Statement stmt = conn.createStatement();
1: 		BufferedReader ddlScript =
0: 			new BufferedReader(new FileReader(scriptName));
1: 
1: 		for (String sqlCmd = ddlScript.readLine(); sqlCmd != null;
1: 			sqlCmd = ddlScript.readLine()) {
1: 
1: 			if (sqlCmd.indexOf("--") == 0)
1: 			// then this is a script comment; ignore it;
1: 				continue;
1: 			else if (sqlCmd.trim().length() == 0)
1: 			// blank line; ignore it.
1: 				continue;
1: 
1: 			// Execute the command.
1: 			if ((sqlCmd.charAt(sqlCmd.length()-1) == TEST_DELIMITER)
1: 			  || (sqlCmd.charAt(sqlCmd.length()-1) == ';'))
1: 			// strip off the delimiter.
1: 				sqlCmd = sqlCmd.substring(0, sqlCmd.length()-1);
1: 
1: 			try {
1: 				stmt.execute(sqlCmd);
1: 			} catch (Exception e) {
1: 				System.out.println("FAILED: to execute cmd " +
1: 					"from DDL script:\n" + sqlCmd + "\n");
1: 				System.out.println(e.getMessage());
1: 			}
1: 
1: 		}
1: 
1: 		// Cleanup.
1: 		ddlScript.close();
1: 		stmt.close();
1: 		conn.close();
1: 
1: 		return;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * writeOut:
1: 	 * Write the received string to some output.
1: 	 * @param str String to write.
1: 	 ****/
1: 
1: 	private static void writeOut(String str) {
1: 
1: 		System.out.println(str);
1: 		return;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * loadIdMappings:
1: 	 * Load mappings of object ids to object names
1: 	 * for purposes of having meaningful output
1: 	 * and for creating unique ids on the rows of
1: 	 * the system catalogs.
1: 	 * @param stmt Statement on a connection to the
1: 	 *  database being examined.
1: 	 * @param conn Connection to the database being
1: 	 *   examined.
1: 	 * @return A HashMap with all relevant id-to-
1: 	 *  name mappings has been returned.
1: 	 ****/
1: 
0: 	private HashMap loadIdMappings(Statement stmt,
0: 		Connection conn) throws Exception {
1: 
0: 		HashMap idToNameMap = new HashMap();
1: 
1: 		// Table ids.
1: 		ResultSet rs = stmt.executeQuery(
1: 			"select tableid, tablename from sys.systables");
1: 		while (rs.next())
1: 			idToNameMap.put(rs.getString(1), rs.getString(2));
1: 
1: 		// Schema ids.
1: 		rs = stmt.executeQuery(
1: 			"select schemaid, schemaname from sys.sysschemas");
1: 		while (rs.next())
1: 			idToNameMap.put(rs.getString(1), rs.getString(2));
1: 
1: 		// Constraint ids.
1: 		rs = stmt.executeQuery(
1: 			"select constraintid, constraintname from " +
1: 			"sys.sysconstraints");
1: 		while (rs.next())
1: 			idToNameMap.put(rs.getString(1), rs.getString(2));
1: 
1: 		return idToNameMap;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * getDependsData:
1: 	 * Forms a string containing detailed information
1: 	 * about a row in the SYSDEPENDS table, and returns
1: 	 * that string.
1: 	 * @param rs Result set with SYSDEPENDS rows; current
1: 	 *  row is the one for which we're getting the
1: 	 *  data.
1: 	 * @param conn Connection to the database being
1: 	 *   examined.
1: 	 * @param idToNameMap mapping of object ids to names
1: 	 *  for the database in question.
1: 	 * @return Schema, type and name of both the Provider
1: 	 *   and the Dependent for the current row of
1: 	 *   SYSDEPENDS have been returned as a string.
1: 	 ****/
1: 
1: 	private String getDependsData(ResultSet rs,
1: 		Connection conn, HashMap idToNameMap)
1: 		throws Exception
1: 	{
1: 
1: 		DependableFinder dep =
1: 			(DependableFinder)rs.getObject(3);
1: 
1: 		DependableFinder prov =
1: 			(DependableFinder)rs.getObject(5);
1: 
1: 		String depType = dep.getSQLObjectType();
1: 		String provType = prov.getSQLObjectType();
1: 
1: 		Statement dependsStmt = conn.createStatement();
1: 		StringBuffer dependsData = new StringBuffer();
1: 		dependsData.append(getHiddenDependsData(depType,
1: 			rs.getString(2), dependsStmt, idToNameMap));
1: 		dependsData.append(" -> ");
1: 		dependsData.append(getHiddenDependsData(provType,
1: 			rs.getString(4), dependsStmt, idToNameMap));
1: 
1: 		return dependsData.toString();
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * getHiddenDependsData:
1: 	 * Returns a string containing the schema and
1: 	 * name of the object having the received id.
1: 	 * All object ids received by this message come
1: 	 * from rows of the SYSDEPENDS table.
1: 	 * @param type Type of the object that has the received
1: 	 *   object id.
1: 	 * @param id Id of the object in question.
1: 	 * @param stmt Statement from the database in question.
1: 	 * @param idToNameMap mapping of ids to names for
1: 	 *  the database in question.
1: 	 * @isProvider True if we're getting data for a
1: 	 *  Provider object; false if we're getting data for
1: 	 *  a Dependent object.
1: 	 * @return Schema, type, and name for the object with
1: 	 *   the received id have been returned as a string.
1: 	 ****/
1: 
1: 	private String getHiddenDependsData(String type,
1: 		String id, Statement pStmt, HashMap idToNameMap)
1: 		throws Exception
1: 	{
1: 
1: 		ResultSet rs = null;
1: 		if (type.equals("Constraint")) {
1: 			rs = pStmt.executeQuery(
1: 				"select schemaid, constraintname from " +
1: 				"sys.sysconstraints where " +
1: 				"constraintid = '" + id + "'");
1: 		}
1: 		else if (type.equals("StoredPreparedStatement")) {
1: 			rs = pStmt.executeQuery(
1: 				"select schemaid, stmtname from " +
1: 				"sys.sysstatements where stmtid = '" +
1: 				id + "'");
1: 		}
1: 		else if (type.equals("Trigger")) {
1: 			rs = pStmt.executeQuery(
1: 				"select schemaid, triggername from " +
1: 				"sys.systriggers where triggerid = '" +
1: 				id + "'");
1: 		}
1: 		else if (type.equals("View") || type.equals("Table")
1: 		  || type.equals("ColumnsInTable")) {
1: 			rs = pStmt.executeQuery(
1: 				"select schemaid, tablename from " +
1: 				"sys.systables where tableid = '" +
1: 				id + "'");
1: 		}
1: 		else if (type.equals("Conglomerate")) {
1: 			rs = pStmt.executeQuery(
1: 				"select schemaid, conglomeratename from " +
1: 				"sys.sysconglomerates where conglomerateid = '" +
1: 				id + "'");
1: 		}
1: 		else {
1: 			System.out.println("WARNING: Unexpected " +
1: 				"dependent type: " + type);
1: 			return "";
1: 		}
1: 
1: 		if (rs.next()) {
1: 			String schema = (String)idToNameMap.get(rs.getString(1));
1: 			if (isIgnorableSchema(schema))
1: 			// system object (so we want to ignore it); indicate
1: 			// this by returning the string "SYS_OBJECT".
1: 				return "SYS_OBJECT";
1: 			StringBuffer result = new StringBuffer();
1: 			result.append("<");
1: 			result.append(type);
1: 			result.append(">");
1: 			result.append(schema);
1: 			result.append(".");
1: 			if (isSystemGenerated(rs.getString(2)))
1: 				result.append("<sysname>");
1: 			else
1: 				result.append(rs.getString(2));
1: 			return result.toString();
1: 		}
1: 
1: 		return "";
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * deleteDB:
1: 	 * Deletes the database with the received name
1: 	 * from the test directory.
1: 	 * @param dbName Name of the database to be deleted.
1: 	 * @return Database has been completely deleted;
1: 	 *   if deletion failed for any reason, a message
1: 	 *   saying so has been printed to output.
1: 	 ****/
1: 
1: 	private void deleteDB(String dbName)
1: 		throws Exception
1: 	{
1: 
1: 		// Get the full path.
1: 		String deletePath = (new
1: 			File(dbPath + separator + dbName)).getAbsolutePath();
1: 
1: 		// Have to shut it down before we can delete it.
1: 		try {
1: 			Connection conn =
1: 				DriverManager.getConnection("jdbc:derby:" + 
0: 					deletePath + ";shutdown=true");
1: 			conn.close();
1: 		} catch (SQLException se) {
1: 		// shutdown exception.
1: 		}
1: 
1: 		File f = new File(deletePath);
1: 		if (!f.exists()) 
1: 		// nothing to do.
1: 			return;
1: 
1: 		File [] files = f.listFiles();
1: 		for (int i = 0; i < files.length; i++)
1: 			deleteFile(files[i]);
1: 
1: 		if (!f.delete()) {
1: 		// still failed.
1: 			System.out.println("ERROR: deleting: " +
1: 				f.getName());
1: 		}
1: 
1: 		// And finally, delete the CSJARS directory,
1: 		// if there is one.
1: 		deleteFile(new File(System.getProperty("user.dir") +
1: 			separator + "CSJARS"));
1: 
1: 		System.out.println("Database '" + dbName + "' deleted.");
1: 		return;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * deleteFile:
1: 	 * Delete everything in a given directory, then
1: 	 * delete the directory itself (recursive).
1: 	 * @param aFile File object representing the directory
1: 	 *  to be deleted.
1: 	 * @return the directory corresponding to aFile
1: 	 *  has been deleted, as have all of its contents.
1: 	 ****/
1: 
1: 	private void deleteFile(File aFile)
1: 		throws Exception
1: 	{
1: 
1: 		if (!aFile.exists())
1: 		// don't bother.
1: 			return;
1: 
1: 		if (aFile.delete())
1: 		// just a file; we're done.
1: 			return;
1: 
1: 		// Otherwise, have to descend and delete all
1: 		// files in this directory.
1: 		File [] files = aFile.listFiles();
1: 		if (files != null) {
1: 			for (int i = 0; i < files.length; i++)
1: 				deleteFile(files[i]);
1: 		}
1: 
1: 		// Now try to delete.
1: 		if (!aFile.delete()) {
1: 		// still failed.
1: 			System.out.println("ERROR: deleting: " +
1: 				aFile.getName());
1: 		}
1: 
1: 		return;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * dumpFileToSysOut:
1: 	 * Checks to see if the received file is empty,
1: 	 * and prints a message saying so.
1: 	 * @param fName Name of the file to be written to output.
1: 	 * @return The contents of the specified file have
1: 	 *   been written to System.out.
1: 	 ****/
1: 
1: 	private void dumpFileToSysOut(String fName) {
1: 
1: 		try {
1: 
0: 			BufferedReader logFile =
1: 				new BufferedReader(new FileReader(fName));
1: 
0: 			if (logFile.readLine() != null)
1: 				System.out.println("File " + fName + " was NOT " +
0: 					"empty; refer to that file (in the test " +
0: 					"directory) to see its contents.");
1: 			else
1: 				System.out.println("File " + fName + " was empty.");
1: 
1: 		} catch (Exception e) {
0: 			System.out.println("FAILED: to dump log file.");
0: 			e.printStackTrace();
1: 		}
1: 
1: 		return;
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * isSystemGenerated:
1: 	 * Returns true if the received string looks like
1: 	 * it is a system-generated string.  We assume
1: 	 * it's system-generated if either 1) it starts
1: 	 * with the letters "SQL", in which case it's a
1: 	 * system-name, or 2) it has a dash in it, in which
1: 	 * case it's a system id.
1: 	 * @param str The string to check.
1: 	 * @return True if we assume the string is system-
1: 	 *  generated, false otherwise.
1: 	 ****/
1: 
1: 	private boolean isSystemGenerated(String str) {
1: 
1: 		return (looksLikeSysGenName(str) ||
1: 			looksLikeSysGenId(str));
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * looksLikeSysGenName:
1: 	 * See if the received string looks like it is
1: 	 * a system-generated name.  There are two types
1: 	 * of system-generated names: 1) visible names,
1: 	 * which start with "SQL", and 2) hidden names,
1: 	 * which exist for Stored Statements that are
1: 	 * used to back triggers; these names start with
1: 	 * "TRIGGERACTN_" and then have a UUID.
1: 	 * NOTE: This test assumes that none of object names
1: 	 * provided in "dblook_makeDB.sql" satisfy
1: 	 * either of these conditions.  If they do, they
1: 	 * will be filtered out of the test output.
1: 	 * @param val The string value in question.
1: 	 * @return True if the value looks like it is a system-
1: 	 *  generated name; false otherwise.
1: 	 ****/
1: 
1: 	private boolean looksLikeSysGenName(String val) {
1: 
1: 		return ((val != null) &&
1: 			((val.trim().indexOf("SQL") == 0) || 			// case 1.
1: 			((val.trim().indexOf("TRIGGERACTN_") == 0) &&	// case 2.
1: 			(val.indexOf("-") != -1))));
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * looksLikeSysGenId:
1: 	 * See if the received string looks like it is
1: 	 * a system-generated id (i.e. contains a dash (-)).
1: 	 * NOTE: This test assumes that none of object names
1: 	 * provided in "dblook_makeDB.sql" will contain
1: 	 * dashes.  If they do, then they will be filtered out
1: 	 * in the test output.
1: 	 * @param val The string value in question.
1: 	 * @return True if the value looks like it is a system-
1: 	 *  generated id; false otherwise.
1: 	 ****/
1: 
1: 	private boolean looksLikeSysGenId(String val) {
1: 
1: 		return ((val != null) && (val.indexOf("-") != -1));
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * columnHoldsObjectName:
1: 	 * Return true if the received column, which is from
1: 	 * some system table, holds the _name_ of a database
1: 	 * object (table, constraint, etc.).  Typically, we
1: 	 * can just look for the keyword "NAME"; the exception
1: 	 * is aliases, where the name is held in a column called
1: 	 * ALIAS.
1: 	 * @param colName Name of the column in question.
1: 	 * @return True if the column name indicates that it
1: 	 *  holds the _name_ of a database object; false if the
1: 	 *  column name indicates that it holds something else.
1: 	 ****/
1: 
1: 	private boolean columnHoldsObjectName(String colName) {
1: 
1: 		return (colName.equals("ALIAS") ||
1: 				(colName.indexOf("NAME") != -1));
1: 
1: 	}
1: 
1: 	/* **********************************************
1: 	 * printAsHeader:
1: 	 * Print the received string to output as a
1: 	 * header.
1: 	 * @param str String to print.
1: 	 ****/
1: 
1: 	private void printAsHeader(String str) {
1: 
1: 		writeOut("--\n*******************************************");
1: 		writeOut(str);
1: 		writeOut("*******************************************\n");
1: 		return;
1: 
1: 	}
1: 
1: }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:582425f
/////////////////////////////////////////////////////////////////////////
1: 				else if (colName.equals("JAVACLASSNAME") && (value != null) &&
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:41e2806
/////////////////////////////////////////////////////////////////////////
0: 
1: 		String sourceDBUrl;
1: 		if (TestUtil.isJCCFramework())
1: 			sourceDBUrl = jdbcProtocol + "\"" + dbPath +
0: 				separator + dbName + "\":user=someusr;password=somepwd;";
1: 		else
1: 			sourceDBUrl = jdbcProtocol + dbPath +
0: 			separator + dbName + ";user=someusr;password=somepwd";
commit:0bbfdac
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.tools.ij;
1: import org.apache.derbyTesting.functionTests.util.TestUtil;
0: 
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		jdbcProtocol = TestUtil.getJdbcUrlPrefix("localhost",SERVER_PORT);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:f68f62f
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.tools.dblook_test
0: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
1:       http://www.apache.org/licenses/LICENSE-2.0
0: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
0: 
0:  */
0: 
0: package org.apache.derbyTesting.functionTests.tests.tools;
0: 
0: import java.sql.DriverManager;
0: import java.sql.ResultSet;
0: import java.sql.Connection;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSetMetaData;
0: import java.sql.SQLException;
0: import java.sql.SQLWarning;
0: import java.sql.Timestamp;
0: 
0: import java.io.PrintWriter;
0: import java.io.FileOutputStream;
0: import java.io.FileNotFoundException;
0: import java.io.BufferedReader;
0: import java.io.FileReader;
0: import java.io.File;
0: 
0: import org.apache.derby.tools.dblook;
0: import org.apache.derby.catalog.DependableFinder;
0: 
0: import java.util.HashMap;
0: import java.util.TreeMap;
0: import java.util.Set;
0: import java.util.Iterator;
0: import java.util.ArrayList;
0: import java.util.StringTokenizer;
0: 
0: public class dblook_test {
0: 
0: 	private static final int SERVER_PORT = 1527;
0: 	private static final int FRONT = -1;
0: 	private static final int REAR = 1;
0: 
0: 	protected static final String dbCreationScript_1 = "dblook_makeDB.sql";
0: 	protected static final String dbCreationScript_2 = "dblook_makeDB_2.sql";
0: 	private static final char TEST_DELIMITER='#';
0: 
0: 	protected static String testDirectory = "dblook_test/";
0: 	protected static final String testDBName = "wombat";
0: 	protected static String separator;
0: 
0: 	private static String dbPath;
0: 	private static int duplicateCounter = 0;
0: 	private static int sysNameCount = 0;
0: 	private static String jdbcProtocol;
0: 
0: 	/* **********************************************
0: 	 * main:
0: 	 * @param args Ignored.
0: 	 ****/
0: 
0: 	public static void main (String[] args) {
0: 
0: 		separator = System.getProperty("file.separator");
0: 		new dblook_test().doTest();
0: 		System.out.println("\n[ Done. ]\n");
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * doTest
0: 	 * Run a full test of the dblook utility.
0: 	 ****/
0: 
0: 	protected void doTest() {
0: 
0: 		try {
0: 
0: 			// Test full dblook functionality.
0: 			System.out.println("\n-= Start dblook Functional Tests. =-");
0: 			createTestDatabase(dbCreationScript_1);
0: 			runDBLook(testDBName);
0: 
0: 			// Test dblook messages.
0: 			System.out.println("\n-= Start dblook Message Tests =-");
0: 			createTestDatabase(dbCreationScript_2);
0: 			runMessageCheckTest(testDBName);
0: 
0: 		} catch (SQLException se) {
0: 
0: 			System.out.println("FAILED: to complete the test:");
0: 			se.printStackTrace(System.out);
0: 			for (se = se.getNextException(); se != null;
0: 				se = se.getNextException())
0: 			{
0: 				se.printStackTrace(System.out);
0: 			}
0: 		
0: 		} catch (Exception e) {
0: 
0: 			System.out.println("FAILED: to complete the test:");
0: 			e.printStackTrace(System.out);
0: 
0: 		}
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * createTestDatabase:
0: 	 * Using the creation script created as part of
0: 	 * the test package, create the database that
0: 	 * will be used as the basis for all dblook
0: 	 * tests.
0: 	 * @param scriptName The name of the sql script
0: 	 *  to use for creating the test database.
0: 	 * @return The test database has been created
0: 	 *  in the current test directory, which is
0: 	 *  "./dblook/" (as created by the harness).
0: 	 ****/
0: 
0: 	protected void createTestDatabase(String scriptName)
0: 		throws Exception
0: 	{
0: 
0: 		// Delete existing database, if it exists.
0: 		try {
0: 			deleteDB(testDBName);
0: 		} catch (Exception e) {
0: 			System.out.println("** Warning: failed to delete " +
0: 				"old test db before creating a new one...");
0: 		}
0: 
0: 		Class.forName("org.apache.derby.jdbc.EmbeddedDriver").newInstance();
0: 		jdbcProtocol = "jdbc:derby:";
0: 		createDBFromDDL(testDBName, scriptName);
0: 
0: 		// Figure out where our database directory is (abs path).
0: 		dbPath = (new File(testDirectory)).getAbsolutePath();
0: 		return;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * runDBLook:
0: 	 * Runs a series of tests using dblook on
0: 	 * the received database.
0: 	 * @param dbName The name of the database on which to
0: 	 *   run the tests.
0: 	 * @return A series of tests intended to verify
0: 	 *  the full functionality of the dblook utility
0: 	 *  has been run.
0: 	 ****/
0: 
0: 	private void runDBLook(String dbName)
0: 		throws Exception
0: 	{
0: 
0: 		// Close the error stream, so that messages
0: 		// printed to System.err aren't intermixed
0: 		// with our output (otherwise, the order
0: 		// of the System.out vs System.err is
0: 		// arbitrary (because of the way the harness
0: 		// works), and so we will get diffs with
0: 		// the master.
0: 		System.err.close();
0: 
0: 		// First, we dump all system catalogs for
0: 		// the original source database to file.
0: 		dumpSysCatalogs(dbName);
0: 
0: 		// Then, we run dblook on the source database
0: 		// with no limitations (i.e. we generate the
0: 		// DDL for the FULL database).
0: 		lookOne(dbName);
0: 		dumpFileToSysOut("dblook.log");
0: 
0: 		// Now, create new db from the DDL that
0: 		// was generated by dblook.
0: 		String newDBName = dbName + "_new";
0: 		createDBFromDDL(newDBName, dbName + ".sql");
0: 		deleteFile(new File(dbName + ".sql"));
0: 
0: 		// Dump all system catalogs for the database
0: 		// that was created from the DDL generated
0: 		// by dblook.
0: 		dumpSysCatalogs(newDBName);
0: 
0: 		// Delete the new database.
0: 		deleteDB(newDBName);
0: 		deleteFile(new File(newDBName + ".sql"));
0: 
0: 		// Run dblook on the source database
0: 		// with various parameter configurations,
0: 		// to make sure they are all working as
0: 		// planned.
0: 		runAllTests(dbName, newDBName);
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * runAllTests:
0: 	 * Makes the call to execute each of the desired
0: 	 * tests.
0: 	 * @param dbName The name of the database on which to
0: 	 *   run the tests.
0: 	 * @param newDBName The name of the database to be
0: 	 *  created from the DDL that is generated (by
0: 	 *  dblook) for the source database.
0: 	 ****/
0: 
0: 	protected void runAllTests(String dbName,
0: 		String newDBName) throws Exception
0: 	{
0: 
0: 		runTest(2, dbName, newDBName);
0: 
0: 		// Test 3 is run as part of derbynet suite;
0: 		// see derbynet/dblook_test_net.java.
0: 
0: 		runTest(4, dbName, newDBName);
0: 		runTest(5, dbName, newDBName);
0: 		runTest(7, dbName, newDBName);
0: 		runTest(6, dbName, newDBName);
0: 		return;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * runTest:
0: 	 * Runs dblook on the source database with a
0: 	 * specific set of parameters, then uses the
0: 	 * resultant DDL to create a new database, and
0: 	 * dumps the system catalogs for that database
0: 	 * to file.  Finally, the new database is deleted
0: 	 * in preparation for subsequent calls to this
0: 	 * method.
0: 	 * @param whichTest An indication of which test to run;
0: 	 *  each test number has a different set of
0: 	 *  parameters.
0: 	 * @param dbName The name of the source database.
0: 	 * @param newDBName The name of the database to be
0: 	 *  created from the DDL that is generated (by
0: 	 *  dblook) for the source database.
0: 	 * @return dblook has been executed using the
0: 	 *  parameters associated with the given test,
0: 	 *  and that DDL has been written to a ".sql"
0: 	 *  file named after the source database;
0: 	 *  a new database has been created from the
0: 	 *  ".sql" generated by dblook; the system
0: 	 *  catalogs for that new database have been
0: 	 *  dumped to output; and the new database has
0: 	 *  been deleted.
0: 	 ****/
0: 
0: 	protected void runTest(int whichTest, String dbName,
0: 		String newDBName)
0: 	{
0: 
0: 		try {
0: 
0: 			switch(whichTest) {
0: 				case 2:		lookTwo(dbName); break;
0: 				case 3:		lookThree(dbName); break;
0: 				case 4:		lookFour(dbName); break;
0: 				case 5:		lookFive(dbName); break;
0: 				case 6:		lookSix(dbName); break;
0: 				case 7:		lookSeven(dbName); break;
0: 				default:	break;
0: 			}
0: 
0: 			dumpFileToSysOut("dblook.log");
0: 			createDBFromDDL(newDBName, dbName + ".sql");
0: 			dumpSysCatalogs(newDBName);
0: 			deleteDB(newDBName);
0: 			deleteFile(new File(dbName + ".sql"));
0: 
0: 		} catch (SQLException e) {
0: 
0: 			System.out.println("FAILED: Test # : " + whichTest);
0: 			e.printStackTrace(System.out);
0: 			for (e = e.getNextException(); e != null;
0: 				e = e.getNextException())
0: 			{
0: 				e.printStackTrace(System.out);
0: 			}
0: 
0: 		} catch (Exception e) {
0: 
0: 			System.out.println("FAILED: Test # : " + whichTest);
0: 			e.printStackTrace(System.out);
0: 
0: 		}
0: 
0: 		return;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * lookOne:
0: 	 * Use dblook to generate FULL DDL for a given
0: 	 * database.
0: 	 * @param dbName The name of the source database (i.e.
0: 	 *  the database for which the DDL is generated).
0: 	 * @return The full DDL for the source database
0: 	 *  has been generated and written to a file
0: 	 *  called <dbName + ".sql">.
0: 	 ****/
0: 
0: 	private void lookOne(String dbName)
0: 		throws Exception
0: 	{
0: 
0: 		printAsHeader("\nDumping full schema for '" +
0: 			dbName + "'\nto file '" + dbName + ".sql':\n");
0: 
0: 		String [] args = new String[] {
0: 			"-o", dbName + ".sql",
0: 			"-td", ""
0: 		};
0: 
0: 		go(dbName, args);
0: 		return;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * lookTwo:
0: 	 * Use dblook to generate DDL for all objects 
0: 	 * in the source database with schema 'BAR',
0: 	 * excluding views:
0: 	 *  -z bar -noview
0: 	 * @param dbName The name of the source database (i.e.
0: 	 *  the database for which the DDL is generated).
0: 	 * @return The appropriate DDL has been generated
0: 	 *  and written to a file called <dbName + ".sql">.
0: 	 ****/
0: 
0: 	private void lookTwo(String dbName)
0: 		throws Exception
0: 	{
0: 
0: 		printAsHeader("\nDumping DDL for all objects " +
0: 			"with schema\n'BAR', excluding views:\n");
0:  
0: 		String [] args = new String[] {
0: 			"-o", dbName + ".sql",
0: 			"-td", "",
0: 			"-z", "bar",
0: 			"-noview"
0: 		};
0: 
0: 		go(dbName, args);
0: 		return;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * lookThree:
0: 	 * Use dblook to generate DDL for all objects
0: 	 * in the source database, using Network
0: 	 * Server.
0: 	 * @param dbName The name of the source database (i.e.
0: 	 *  the database for which the DDL is generated).
0: 	 * @return The appropriate DDL has been generated
0: 	 *  and written to a file called <dbName + ".sql">.
0: 	 ****/
0: 
0: 	private void lookThree(String dbName)
0: 		throws Exception
0: 	{
0: 
0: 		printAsHeader("\nDumping DDL for all objects, " +
0: 			"using\nNetwork Server:\n");
0:  
0: 		jdbcProtocol = "jdbc:derby:net://localhost:" +
0: 			SERVER_PORT + "/";
0: 		String sourceDBUrl = jdbcProtocol + "\"" + dbPath +
0: 			separator + dbName + "\":user=someusr;password=somepwd;";
0: 
0: 		// Make sure we're not connected to the database
0: 		// (we connected to it in embedded mode when we
0: 		// created it, so we have to shut it down).
0: 		try {
0: 			DriverManager.getConnection(
0: 				"jdbc:derby:" + dbName + ";shutdown=true");
0: 		} catch (SQLException e) {}
0: 
0: 		// Run the test.
0: 		try {
0: 
0: 			new dblook(new String[] {
0: 				"-d", sourceDBUrl,
0: 				"-o", dbName + ".sql",
0: 				"-td", "" }
0: 			);
0: 
0: 		} catch (Exception e) {
0: 			System.out.println("FAILED: ");
0: 			e.printStackTrace(System.out);
0: 		}
0: 
0: 		return;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * lookFour:
0: 	 * Use dblook to generate DDL for all objects 
0: 	 * in the source database with schema 'BAR'
0: 	 * that are related to tables 'T3', 'tWithKeys',
0: 	 * and 'MULTI WORD NAME'.
0: 	 *  -z bar -t t3 "\"tWithKeys\"" "Multi word name"
0: 	 * @param dbName The name of the source database (i.e.
0: 	 *  the database for which the DDL is generated).
0: 	 * @return The appropriate DDL has been generated
0: 	 *  and written to a file called <dbName + ".sql">.
0: 	 ****/
0: 
0: 	private void lookFour(String dbName)
0: 		throws Exception
0: 	{
0: 
0: 		printAsHeader("\nDumping DDL for all objects " +
0: 			"with schema 'BAR'\nthat are related to tables " +
0: 			"'T3', 'tWithKeys',\nand 'MULTI WORD NAME':\n");
0:  
0: 		String [] args = new String [] {
0: 			"-o", dbName + ".sql",
0: 			"-td", "",
0: 			"-z", "BAR",
0: 			"-t", "t3", "\"tWithKeys\"", "Multi word name"
0: 		};
0: 
0: 		go(dbName, args);
0: 		return;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * lookFive:
0: 	 * Use dblook to generate DDL for all objects 
0: 	 * in the source database (with any schema)
0: 	 * that are related to table 'T1' and 'TWITHKEYS'
0: 	 * (with no matches existing for the latter).
0: 	 * 	-t t1 "tWithKeys"
0: 	 * @param dbName The name of the source database (i.e.
0: 	 *  the database for which the DDL is generated).
0: 	 * @return The appropriate DDL has been generated
0: 	 *  and written to a file called <dbName + ".sql">.
0: 	 ****/
0: 
0: 	private void lookFive(String dbName)
0: 		throws Exception
0: 	{
0: 
0: 		printAsHeader("\nDumping DDL for all objects " +
0: 			"related to 'T1'\nand 'TWITHKEYS':\n");
0:  
0: 		String [] args = new String [] {
0: 			"-o", dbName + ".sql",
0: 			"-td", "",
0: 			"-t", "t1", "tWithKeys"
0: 		};
0: 
0: 		go(dbName, args);
0: 		return;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * lookSix:
0: 	 * Call dblook with an invalid url, to make
0: 	 * sure that errors are printed to log.
0: 	 *   -d <dbName> // missing protocol.
0: 	 * @param dbName The name of the source database (i.e.
0: 	 *  the database for which the DDL is generated).
0: 	 * @return The appropriate DDL has been generated
0: 	 *  and written to a file called <dbName + ".sql">.
0: 	 ****/
0: 
0: 	private void lookSix(String dbName)
0: 		throws Exception
0: 	{
0: 
0: 		printAsHeader("\nDumping DDL w/ invalid url, and " +
0: 			"writing\nerror to the log:\n");
0:  
0: 		// Url is intentionally incorrect; it will cause an error.
0: 		new dblook(new String[] {
0: 			"-o", dbName + ".sql",
0: 			"-d", dbName }
0: 		);
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * lookSeven:
0: 	 * Use dblook to generate DDL for all objects 
0: 	 * in the source database with schema '"Quoted"Schema"'.
0: 	 *  -z \"\"Quoted\"Schema\"\"
0: 	 * @param dbName The name of the source database (i.e.
0: 	 *  the database for which the DDL is generated).
0: 	 * @return The appropriate DDL has been generated
0: 	 *  and written to a file called <dbName + ".sql">.
0: 	 ****/
0: 
0: 	private void lookSeven(String dbName)
0: 		throws Exception
0: 	{
0: 
0: 		printAsHeader("\nDumping DDL for all objects " +
0: 			"with schema\n'\"Quoted\"Schema\"':\n");
0:  
0: 		String [] args = new String[] {
0: 			"-o", dbName + ".sql",
0: 			"-td", "",
0: 			"-z", "\"\"Quoted\"Schema\"\""
0: 		};
0: 
0: 		go(dbName, args);
0: 		return;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * go:
0: 	 * Makes the call to execute the dblook command
0: 	 * using the received arguments.
0: 	 * @param dbName The name of the source database (i.e.
0: 	 *  the database for which the DDL is generated).
0: 	 * @args The list of arguments with which to execute
0: 	 *  the dblook command.
0: 	 ****/
0: 
0: 	private void go(String dbName, String [] args) {
0: 
0: 		jdbcProtocol = "jdbc:derby:";
0: 		String sourceDBUrl = jdbcProtocol + dbPath +
0: 			separator + dbName;
0: 
0: 		String [] fullArgs = new String[args.length+2];
0: 		fullArgs[0] = "-d";
0: 		fullArgs[1] = sourceDBUrl;
0: 		for (int i = 2; i < fullArgs.length; i++)
0: 			fullArgs[i] = args[i-2];
0: 
0: 		try {
0: 			new dblook(fullArgs);
0: 		} catch (Exception e) {
0: 			System.out.println("FAILED: to run dblook: ");
0: 			e.printStackTrace(System.out);
0: 		}
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * runMessageCheckTest
0: 	 * Run dblook and verify that all of the dblook
0: 	 * messages are correctly displayed.
0: 	 * @param dbName The name of the source database (i.e.
0: 	 *  the database for which the DDL is generated).
0: 	 * @return The DDL for a simple database, plus all
0: 	 *  dblook messages, have been generated and written
0: 	 *  to System.out.
0: 	 ****/
0: 	private void runMessageCheckTest(String dbName)
0: 		throws Exception
0: 	{
0: 
0: 		// #1: First, run DB look standard to check for
0: 		// all of the "header" messages that are printed
0: 		// out along with DDL.
0: 		System.out.println("\n************\n" +
0: 			"Msg Test 1\n" +
0: 			"************\n");
0: 		lookOne(dbName);
0: 		dumpFileToSysOut(dbName + ".sql");
0: 		dumpFileToSysOut("dblook.log");
0: 
0: 		// Now, we have to run some additional dblook commands
0: 		// to get the "non-standard" messages.
0: 
0: 		// #2: Specify a target table and target schema, to
0: 		// make sure they are echoed correctly.  Also, specify
0: 		// an output file to make sure the file creation header
0: 		// is printed in the file.
0: 		System.out.println(
0: 			"\n************\n" +
0: 			"Msg Test 2\n" +
0: 			"************\n");
0: 		go(dbName, new String [] {
0: 				"-t", "t1",
0: 				"-z", "bar",
0: 				"-o", dbName + ".sql"
0: 			});
0: 		dumpFileToSysOut(dbName + ".sql");
0: 		dumpFileToSysOut("dblook.log");
0: 
0: 		// #3: Run without specifying a database, to make
0: 		// sure the usage message is printed to System.out
0: 		System.out.println(
0: 			"\n************\n" +
0: 			"Msg Test 3\n" +
0: 			"************\n");
0: 		try {
0: 			new dblook(new String[] { "-verbose" });
0: 		} catch (Exception e) {
0: 			System.out.println("FAILED: to run dblook: ");
0: 			e.printStackTrace(System.out);
0: 		}
0: 
0: 		// #4: Just to confirm, try once with a statement
0: 		// delimiter, to make sure it's actually working
0: 		// correctly (this isn't a "message" per se, but
0: 		// still, it's worth verifying).
0: 		System.out.println(
0: 			"\n************\n" +
0: 			"Msg Test 4\n" +
0: 			"************\n");
0: 		go(dbName, new String [] {
0: 				"-td", " " + TEST_DELIMITER
0: 			});
0: 
0: 		// #5: Intentionally create an error while loading
0: 		// a jar file, to make sure the resultant message is
0: 		// printed correctly.
0: 		System.out.println(
0: 			"\n************\n" +
0: 			"Msg Test 5\n" +
0: 			"************\n");
0: 
0: 		// We'll cause the error by going in and deleting
0: 		// the jar file from the test database.  First,
0: 		// get the jar path.
0: 		String jarPath = (new
0: 			File(dbPath + separator + dbName)).getAbsolutePath();
0: 
0: 		// Have to shut db down before we can mess with it.
0: 		try {
0: 			Connection conn =
0: 				DriverManager.getConnection("jdbc:derby:" + 
0: 					jarPath + ";shutdown=true");
0: 			conn.close();
0: 		} catch (SQLException se) {
0: 		// shutdown exception.
0: 		}
0: 
0: 		jarPath = jarPath + separator + "jar";
0: 		deleteFile(new File(jarPath));
0: 
0: 		// Now that we've deleted the jar file, run dblook
0: 		// and check the error.
0: 		go(dbName, new String [] { 
0: 				"-verbose",
0: 				"-o", dbName + ".sql"
0: 			});
0: 		dumpFileToSysOut("dblook.log");
0: 
0: 		// Clean up.
0: 		try {
0: 			deleteFile(new File(dbName + ".sql"));
0: 		} catch (Exception e) {
0: 		// not too big of a deal if we fail; just ignore...
0: 		}
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * dumpSysCatalogs:
0: 	 * Takes a database name and dumps ALL of the
0: 	 * system catalogs for that database, with the
0: 	 * exception of SYSSTATISTICS.  This allows us
0: 	 * to look at the full contents of a database's
0: 	 * schema (without using dblook, of course)
0: 	 * so that we can see if the databases created
0: 	 * from the DDL generated by dblook have been
0: 	 * built correctly--if they have all of the
0: 	 * correct system catalog information, then
0: 	 * the databases themselves must be correct.
0: 	 * @param dbName The name of the database for which
0: 	 *  we are dumping the system catalogs.
0: 	 * @return All of the system catalogs for
0: 	 *  the received database have been dumped
0: 	 *  to output.
0: 	 ****/
0: 
0: 	private void dumpSysCatalogs(String dbName)
0: 		throws Exception
0: 	{
0: 
0: 		System.out.println("\nDumping system tables for '" + dbName + "'\n");
0: 
0: 		writeOut("\n----------------=================---------------");
0: 		writeOut("System Tables for: " + dbName);
0: 		writeOut("----------------=================---------------\n");
0: 
0: 		// Connect to the database.
0: 		Connection conn = DriverManager.getConnection(
0: 				"jdbc:derby:" + dbName);
0: 		conn.setAutoCommit(false);
0: 		Statement stmt = conn.createStatement();
0: 
0: 		// Load any id-to-name mappings that will be useful
0: 		// when dumping the catalogs.
0: 		HashMap idToNameMap = loadIdMappings(stmt, conn);
0: 
0: 		// Go through and dump all system catalog information,
0: 		// filtering out database-dependent id's so that they
0: 		// won't cause diffs.
0: 
0: 		writeOut("\n========== SYSALIASES ==========\n");
0: 		ResultSet rs =
0: 			stmt.executeQuery("select schemaid, sys.sysaliases.* from sys.sysaliases");
0: 		dumpResultSet(rs, idToNameMap, null);
0: 
0: 		writeOut("\n========== SYSCHECKS ==========\n");
0: 		rs = stmt.executeQuery("select c.schemaid, ck.* from " +
0: 			"sys.syschecks ck, sys.sysconstraints c where " +
0: 			"ck.constraintid = c.constraintid");
0: 		dumpResultSet(rs, idToNameMap, null);
0: 
0: 		writeOut("\n========== SYSCOLUMNS ==========\n");
0: 		writeOut("--- Columns for Tables ---");
0: 		rs = stmt.executeQuery("select t.schemaid, c.* from " +
0: 			"sys.syscolumns c, sys.systables t where c.referenceid " +
0: 			"= t.tableid" );
0: 		dumpResultSet(rs, idToNameMap, null);
0: 		writeOut("\n--- Columns for Statements ---");
0: 		rs = stmt.executeQuery("select s.schemaid, c.* from " +
0: 			"sys.syscolumns c, sys.sysstatements s where c.referenceid " +
0: 			"= s.stmtid" );
0: 		dumpResultSet(rs, idToNameMap, null);
0: 
0: 		writeOut("\n========== SYSCONGLOMERATES ==========\n");
0: 		rs = stmt.executeQuery("select schemaid, sys.sysconglomerates.* " +
0: 			"from sys.sysconglomerates");
0: 		dumpResultSet(rs, idToNameMap, null);
0: 
0: 		writeOut("\n========== SYSCONSTRAINTS ==========\n");
0: 		rs = stmt.executeQuery("select schemaid, sys.sysconstraints.* " +
0: 			"from sys.sysconstraints");
0: 		dumpResultSet(rs, idToNameMap, null);
0: 
0: 		writeOut("\n========== SYSDEPENDS ==========\n");
0: 		rs = stmt.executeQuery("select dependentid, sys.sysdepends.* from sys.sysdepends");
0: 		dumpResultSet(rs, idToNameMap, conn);
0: 
0: 		writeOut("\n========== SYSFILES ==========\n");
0: 		rs = stmt.executeQuery("select schemaid, sys.sysfiles.* from sys.sysfiles");
0: 		dumpResultSet(rs, idToNameMap, null);
0: 
0: 		writeOut("\n========== SYSFOREIGNKEYS ==========\n");
0: 		rs = stmt.executeQuery("select c.schemaid, fk.* from " +
0: 			"sys.sysforeignkeys fk, sys.sysconstraints c where " +
0: 			"fk.constraintid = c.constraintid");
0: 		dumpResultSet(rs, idToNameMap, null);
0: 
0: 		writeOut("\n========== SYSKEYS ==========\n");
0: 		rs = stmt.executeQuery("select c.schemaid, k.* from " +
0: 			"sys.syskeys k, sys.sysconstraints c where " +
0: 			"k.constraintid = c.constraintid");
0: 		dumpResultSet(rs, idToNameMap, null);
0: 
0: 		writeOut("\n========== SYSSCHEMAS ==========\n");
0: 		rs = stmt.executeQuery("select schemaid, sys.sysschemas.* from sys.sysschemas");
0: 		dumpResultSet(rs, idToNameMap, null);
0: 
0: 		writeOut("\n========== SYSSTATEMENTS ==========\n");
0: 		rs = stmt.executeQuery("select schemaid, sys.sysstatements.* from sys.sysstatements");
0: 		dumpResultSet(rs, idToNameMap, null);
0: 
0: 		writeOut("\n========== SYSTABLES ==========\n");
0: 		rs = stmt.executeQuery("select schemaid, sys.systables.* from sys.systables");
0: 		dumpResultSet(rs, idToNameMap, null);
0: 
0: 		writeOut("\n========== SYSTRIGGERS ==========\n");
0: 		rs = stmt.executeQuery("select schemaid, sys.systriggers.* from sys.systriggers");
0: 		dumpResultSet(rs, idToNameMap, null);
0: 
0: 		writeOut("\n========== SYSVIEWS ==========\n");
0: 		rs = stmt.executeQuery("select compilationschemaid, sys.sysviews.* from sys.sysviews");
0: 		dumpResultSet(rs, idToNameMap, null);
0: 
0: 		stmt.close();
0: 		rs.close();
0: 		conn.commit();
0: 		conn.close();
0: 		return;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * isIgnorableSchema:
0:      * Returns true if the the schema is a "system" schema, vs. a user 
0:      * schema.  
0: 	 * @param schemaName name of schema to check.
0: 	 ****/
0: 	private boolean isIgnorableSchema(String schemaName) {
0: 
0:         boolean ret = false;
0: 
0:         for (int i = ignorableSchemaNames.length - 1; i >= 0;)
0:         {
0:             if ((ret = ignorableSchemaNames[i--].equalsIgnoreCase(schemaName)))
0:                 break;
0:         }
0: 
0:         return(ret);
0: 	}
0: 
0:     private static final String[] ignorableSchemaNames = {
0:         "SYSIBM",
0:         "SYS",
0:         "SYSVISUAL",
0:         "SYSCAT",
0:         "SYSFUN",
0:         "SYSPROC",
0:         "SYSSTAT",
0:         "NULLID",
0:         "SYSCS_ADMIN",
0:         "SYSCS_DIAG",
0:         "SYSCS_UTIL",
0:         "SQLJ"};
0: 
0: 	/* **********************************************
0: 	 * dumpResultSet:
0: 	 * Iterates through the received result set and
0: 	 * dumps ALL columns in ALL rows of that result
0: 	 * set to output.  Since no order is guaranteed
0: 	 * in the received result set, we have to generate
0: 	 * unique "ids" for each row in the result, and
0: 	 * then use those ids to determine what order the
0: 	 * rows will be output.  Failure to do so will
0: 	 * lead to diffs in the test for rows that occur
0: 	 * out of order.  The unique id's must NOT
0: 	 * depend on system-generated id's, as the
0: 	 * latter will vary for every run of the test,
0: 	 * and thus will lead to different orderings
0: 	 * every time (which we don't want).
0: 	 *
0: 	 * @param rs The result set that is being dumped.
0: 	 * @param idToNameMap Mapping of various ids to
0: 	 *  object names; used in forming unique ids.
0: 	 * @param conn Connection from which the result set
0: 	 *  originated.
0: 	 ****/
0: 
0: 	private void dumpResultSet (ResultSet rs,
0: 		HashMap idToNameMap, Connection conn)
0: 		throws Exception
0: 	{
0: 
0: 		// We need to form unique names for the rows of the
0: 		// result set so that we can preserve the order of
0: 		// the output and avoid diffs with a master.  This is
0: 		// because a "select *" doesn't order rows--and even
0: 		// though the schema for two databases might be the
0: 		// same (i.e. the system tables contain all of the same
0: 		// information) there's nothing to say the various rows in
0: 		// the respective system tables will be the same (they
0: 		// usually are NOT).  While system id's automatically
0: 		// give us uniqueness, we can NOT order on them because
0: 		// they vary from database to database; so, we need
0: 		// to use something constant across the databases,
0: 		// which is why we use object names.
0: 		StringBuffer uniqueName = new StringBuffer();
0: 
0: 		TreeMap orderedRows = new TreeMap();
0: 		ArrayList rowValues = new ArrayList();
0: 		ArrayList duplicateRowIds = new ArrayList();
0: 
0: 		ResultSetMetaData rsmd = rs.getMetaData();
0: 		int cols = rsmd.getColumnCount();
0: 		while (rs.next()) {
0: 
0: 			for (int i = 1; i <= cols; i++) {
0: 
0: 				String colName = rsmd.getColumnName(i);
0: 				String value = rs.getString(i);
0: 				String mappedName = (String)idToNameMap.get(value);
0: 
0: 				if ((colName.indexOf("SCHEMAID") != -1) &&
0: 					(mappedName != null) &&
0: 					((mappedName.indexOf("SYS") != -1) ||
0:                      (isIgnorableSchema(mappedName))))
0:                 {
0: 				// then this row of the result set is for a system
0: 				// object, which will always be the same for the
0: 				// source and new database, so don't bother dumping
0: 				// them to the output file (makes the test less
0: 				// like to require updates when changes to database
0: 				// metadata for system objects are checked in).
0: 					rowValues = null;
0: 					break;
0: 				}
0: 				else if (colName.equals("JAVACLASSNAME") &&
0: 					(value.indexOf("org.apache.derby") != -1) &&
0: 					(value.indexOf(".util.") == -1)) {
0: 				// this is a -- hack -- to see if the alias is a
0: 				// a system alias, needed because aliases
0: 				// (other than stored procedures) do not have
0: 				// an associated schema).
0: 					rowValues = null;
0: 					break;
0: 				}
0: 
0: 				if (i == 1)
0: 				// 1st column is just for figuring out whether
0: 				// to dump this row; no need to actually include
0: 				// it in the results.
0: 					continue;
0: 
0: 				String uniquePiece = dumpColumnData(colName,
0: 					value, mappedName, rowValues);
0: 
0: 				if (colName.equals("DEPENDENTID")) {
0: 				// Special case: rows in the "DEPENDS" table
0: 				// don't have unique ids or names; we have to
0: 				// build one by extracting information indirectly.
0: 					String hiddenInfo = getDependsData(rs, conn,
0: 						idToNameMap);
0: 					if (hiddenInfo.indexOf("SYS_OBJECT") != -1) {
0: 					// this info is for a system object, so
0: 					// ignore it.
0: 						rowValues = null;
0: 						break;
0: 					}
0: 					uniqueName.append(hiddenInfo);
0: 					// Include the hidden data as part of the
0: 					// output.
0: 					rowValues.add(hiddenInfo);
0: 				}
0: 
0: 		 		if (uniquePiece != null)
0: 					uniqueName.append(uniquePiece);
0: 
0: 				if (colName.equals("STMTNAME") &&
0: 				  (value.indexOf("TRIGGERACTN") != -1))
0: 				// Special case: can't use statement name, because
0: 				// the entire statement may be automatically generated
0: 				// in each database (to back a trigger), so the name
0: 				// in which case the generated name will be different
0: 				// every time; but filtering out the name means
0: 				// we have no other guaranteed unique 'id' for
0: 				// ordering.  So, just take "text" field, and
0: 				// design test db so that no two triggers have the
0: 				// same text value.
0: 				uniqueName.append(rs.getString(6));
0: 
0: 			}
0: 
0: 			if (rowValues != null) {
0: 
0: 				if (duplicateRowIds.contains(uniqueName.toString()))
0: 				// then we've already encountered this row id before;
0: 				// to preserve ordering, use the entire row as an
0: 				// id.
0: 					handleDuplicateRow(rowValues, null, orderedRows);
0: 				else {
0: 					ArrayList oldRow = (ArrayList)(orderedRows.put(
0: 						uniqueName.toString(), rowValues));
0: 					if (oldRow != null) {
0: 					// Duplicate row id.
0: 						duplicateRowIds.add(uniqueName.toString());
0: 						// Delete the row that has the duplicate row id.
0: 							orderedRows.remove(uniqueName.toString());
0: 						handleDuplicateRow(rowValues, oldRow, orderedRows);
0: 					}
0: 				}
0: 			}
0: 
0: 			uniqueName = new StringBuffer();
0: 			rowValues = new ArrayList();
0: 
0: 		}
0: 
0: 		// Now, print out all of the data in this result set
0: 		// using the order of the unique names that we created.
0: 		Set objectNames = orderedRows.keySet();
0: 		for (Iterator itr = objectNames.iterator();
0: 			itr.hasNext(); ) {
0: 
0: 			String row = (String)itr.next();
0: 			ArrayList colData = (ArrayList)orderedRows.get(row);
0: 			for (int i = 0; i < colData.size(); i++)
0: 				writeOut((String)colData.get(i));
0: 			writeOut("----");
0: 
0: 		}
0: 
0: 		orderedRows = null;
0: 		rs.close();
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * dumpColumnData:
0: 	 * Stores the value for a specific column of
0: 	 * some result set.  If the value needs to
0: 	 * be filtered (to remove system-generated ids
0: 	 * that would otherwise cause diffs with the
0: 	 * master), that filtering is done here.
0: 	 * @param colName Name of the column whose value we're
0: 	 *  writing.
0: 	 * @param value Value that we're writing.
0: 	 * @param mappedName: Name corresponding to the value,
0: 	 *  for cases where the value is actually an
0: 	 *  object id (then we want to write the name
0: 	 *  instead).
0: 	 * rowValues a list of column values for the
0: 	 *  current row of the result set.
0: 	 * @return The (possibly filtered) value of the
0: 	 *  received column has been added to the
0: 	 *  "rowVals" array list, and the corresponding
0: 	 *  piece of the row's unique name has been
0: 	 *  returned, if one exists.
0: 	 ****/
0: 
0: 	private String dumpColumnData(String colName,
0: 		String value, String mappedName, ArrayList rowVals)
0: 	{
0: 
0: 		if (mappedName == null) {
0: 		// probably not an id.
0: 			if (colName.equals("CONGLOMERATENUMBER") ||
0: 				colName.equals("GENERATIONID"))
0: 			// special case: these numbers aren't ids per
0: 			// se, but they are still generated by the system,
0: 			// and will cause diffs with the master; so, ignore
0: 			// them.
0: 				rowVals.add("<systemnumber>");
0: 			else if (colName.equals("AUTOINCREMENTVALUE"))
0: 			// special case: new database won't have any data,
0: 			// old will, so unless we filter this out, we'll
0: 			// get a diff.
0: 				rowVals.add("<autoincval>");
0: 			else if (colName.equals("VALID"))
0: 			// special case: ignore whether or not stored
0: 			// statements are valid (have been compiled)
0: 			// since it depends on history of database,
0: 			// which we can't duplicate.
0: 				rowVals.add("<validityflag>");
0: 			else if (value != null) {
0: 				if (looksLikeSysGenName(value)) {
0: 					if (columnHoldsObjectName(colName))
0: 						rowVals.add("<systemname>");
0: 					else {
0: 					// looks like a sys gen name, but's actually a VALUE.
0: 						rowVals.add(value);
0: 						return value;
0: 					}
0: 				}
0: 				else if (looksLikeSysGenId(value))
0: 					rowVals.add("<systemid>");
0: 				else {
0: 					rowVals.add(value);
0: 					if (columnHoldsObjectName(colName))
0: 					// if it's a name, we need it as part of
0: 					// our unique id.
0: 						return value;
0: 				}
0: 			}
0: 			else
0: 			// null value.
0: 				rowVals.add(value);
0: 		}
0: 		else {
0: 		// it's an id, so write the corresponding name.
0: 			if (!isSystemGenerated(mappedName)) {
0: 			// Not an id-as-name, so use it as part of our unique id.
0: 				rowVals.add(mappedName);
0: 				return mappedName;
0: 			}
0: 			else
0: 				rowVals.add("<systemname>");
0: 		}
0: 
0: 		// If we get here, we do NOT want the received value
0: 		// to be treated as part of this row's unique name.
0: 		return null;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * handleDuplicateRow:
0: 	 * If we get here, then despite our efforts (while
0: 	 * dumping the system catalogs for a database), we
0: 	 * still have a duplicate row id.  So, as a last
0: 	 * resort we just use the ENTIRE row as a 'row id'.
0: 	 * In the rare-but-possible case that the entire
0: 	 * row is a duplicate (as can happen with the
0: 	 * SYSDEPENDS table), then we tag a simple number
0: 	 * onto the latest row's id, so that the row will
0: 	 * still show up multiple times--and since the rows
0: 	 * are identical, it doesn't matter which comes
0: 	 * 'first'.
0: 	 * @param newRow The most recently-fetched row from
0: 	 *  the database system catalogs.
0: 	 * @param oldRow The row that was replaced when the
0: 	 *  newRow was inserted (because they had the
0: 	 *  same row id), or "null" if we were already
0: 	 *  here once for this row id, and so just want
0: 	 *  insert a new row.
0: 	 * @param orderedRows The ordered set of rows, into
0: 	 *  which oldRow and newRow need to be inserted.
0: 	 * @return oldRow and newRow have been inserted
0: 	 *  into orderedRows, and each has a (truly)
0: 	 *  unique id with it.
0: 	 ****/
0: 
0: 	private void handleDuplicateRow(
0: 		ArrayList newRow, ArrayList oldRow,
0: 		TreeMap orderedRows)
0: 	{
0: 
0: 		// Add the received rows (old and new) with
0: 		// unique row ids.
0: 
0: 		StringBuffer newRowId = new StringBuffer();
0: 		for (int i = 0; i < newRow.size(); i++)
0: 			newRowId.append((String)newRow.get(i));
0: 
0: 		Object obj = (ArrayList)(orderedRows.put(
0: 						newRowId.toString(), newRow));
0: 		if (obj != null)
0: 		// entire row is a duplicate.
0: 			orderedRows.put(newRowId.toString() + 
0: 				duplicateCounter++, newRow);
0: 
0: 		if (oldRow != null) {
0: 
0: 			StringBuffer oldRowId = new StringBuffer();
0: 			for (int i = 0; i < oldRow.size(); i++)
0: 				oldRowId.append((String)oldRow.get(i));
0: 
0: 			obj = (ArrayList)(orderedRows.put(
0: 				oldRowId.toString(), oldRow));
0: 			if (obj != null)
0: 			// entire row is a duplicate.
0: 				orderedRows.put(oldRowId.toString() +
0: 					duplicateCounter++, oldRow);
0: 		}
0: 
0: 		return;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * createDBFromDDL:
0: 	 * Read from the given script and use it to create
0: 	 * a new database of the given name.
0: 	 * @param newDBName Name of the database to be created.
0: 	 * @param scriptName Name of the script containing the
0: 	 *  DDL from which the new database will be created.
0: 	 * @return New database has been created from
0: 	 *   the script; any commands in the script that
0: 	 *   failed to execute have been echoed to output.
0: 	 ****/
0: 
0: 	private void createDBFromDDL(String newDBName,
0: 		String scriptName) throws Exception
0: 	{
0: 
0: 		System.out.println("\n\nCreating database '" + newDBName +
0: 			"' from ddl script '" + scriptName + "'");
0: 
0: 		Connection conn = DriverManager.getConnection(
0: 			"jdbc:derby:" + newDBName + ";create=true");
0: 
0: 		Statement stmt = conn.createStatement();
0: 		BufferedReader ddlScript =
0: 			new BufferedReader(new FileReader(scriptName));
0: 
0: 		for (String sqlCmd = ddlScript.readLine(); sqlCmd != null;
0: 			sqlCmd = ddlScript.readLine()) {
0: 
0: 			if (sqlCmd.indexOf("--") == 0)
0: 			// then this is a script comment; ignore it;
0: 				continue;
0: 			else if (sqlCmd.trim().length() == 0)
0: 			// blank line; ignore it.
0: 				continue;
0: 
0: 			// Execute the command.
0: 			if ((sqlCmd.charAt(sqlCmd.length()-1) == TEST_DELIMITER)
0: 			  || (sqlCmd.charAt(sqlCmd.length()-1) == ';'))
0: 			// strip off the delimiter.
0: 				sqlCmd = sqlCmd.substring(0, sqlCmd.length()-1);
0: 
0: 			try {
0: 				stmt.execute(sqlCmd);
0: 			} catch (Exception e) {
0: 				System.out.println("FAILED: to execute cmd " +
0: 					"from DDL script:\n" + sqlCmd + "\n");
0: 				System.out.println(e.getMessage());
0: 			}
0: 
0: 		}
0: 
0: 		// Cleanup.
0: 		ddlScript.close();
0: 		stmt.close();
0: 		conn.close();
0: 
0: 		return;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * writeOut:
0: 	 * Write the received string to some output.
0: 	 * @param str String to write.
0: 	 ****/
0: 
0: 	private static void writeOut(String str) {
0: 
0: 		System.out.println(str);
0: 		return;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * loadIdMappings:
0: 	 * Load mappings of object ids to object names
0: 	 * for purposes of having meaningful output
0: 	 * and for creating unique ids on the rows of
0: 	 * the system catalogs.
0: 	 * @param stmt Statement on a connection to the
0: 	 *  database being examined.
0: 	 * @param conn Connection to the database being
0: 	 *   examined.
0: 	 * @return A HashMap with all relevant id-to-
0: 	 *  name mappings has been returned.
0: 	 ****/
0: 
0: 	private HashMap loadIdMappings(Statement stmt,
0: 		Connection conn) throws Exception {
0: 
0: 		HashMap idToNameMap = new HashMap();
0: 
0: 		// Table ids.
0: 		ResultSet rs = stmt.executeQuery(
0: 			"select tableid, tablename from sys.systables");
0: 		while (rs.next())
0: 			idToNameMap.put(rs.getString(1), rs.getString(2));
0: 
0: 		// Schema ids.
0: 		rs = stmt.executeQuery(
0: 			"select schemaid, schemaname from sys.sysschemas");
0: 		while (rs.next())
0: 			idToNameMap.put(rs.getString(1), rs.getString(2));
0: 
0: 		// Constraint ids.
0: 		rs = stmt.executeQuery(
0: 			"select constraintid, constraintname from " +
0: 			"sys.sysconstraints");
0: 		while (rs.next())
0: 			idToNameMap.put(rs.getString(1), rs.getString(2));
0: 
0: 		return idToNameMap;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * getDependsData:
0: 	 * Forms a string containing detailed information
0: 	 * about a row in the SYSDEPENDS table, and returns
0: 	 * that string.
0: 	 * @param rs Result set with SYSDEPENDS rows; current
0: 	 *  row is the one for which we're getting the
0: 	 *  data.
0: 	 * @param conn Connection to the database being
0: 	 *   examined.
0: 	 * @param idToNameMap mapping of object ids to names
0: 	 *  for the database in question.
0: 	 * @return Schema, type and name of both the Provider
0: 	 *   and the Dependent for the current row of
0: 	 *   SYSDEPENDS have been returned as a string.
0: 	 ****/
0: 
0: 	private String getDependsData(ResultSet rs,
0: 		Connection conn, HashMap idToNameMap)
0: 		throws Exception
0: 	{
0: 
0: 		DependableFinder dep =
0: 			(DependableFinder)rs.getObject(3);
0: 
0: 		DependableFinder prov =
0: 			(DependableFinder)rs.getObject(5);
0: 
0: 		String depType = dep.getSQLObjectType();
0: 		String provType = prov.getSQLObjectType();
0: 
0: 		Statement dependsStmt = conn.createStatement();
0: 		StringBuffer dependsData = new StringBuffer();
0: 		dependsData.append(getHiddenDependsData(depType,
0: 			rs.getString(2), dependsStmt, idToNameMap));
0: 		dependsData.append(" -> ");
0: 		dependsData.append(getHiddenDependsData(provType,
0: 			rs.getString(4), dependsStmt, idToNameMap));
0: 
0: 		return dependsData.toString();
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * getHiddenDependsData:
0: 	 * Returns a string containing the schema and
0: 	 * name of the object having the received id.
0: 	 * All object ids received by this message come
0: 	 * from rows of the SYSDEPENDS table.
0: 	 * @param type Type of the object that has the received
0: 	 *   object id.
0: 	 * @param id Id of the object in question.
0: 	 * @param stmt Statement from the database in question.
0: 	 * @param idToNameMap mapping of ids to names for
0: 	 *  the database in question.
0: 	 * @isProvider True if we're getting data for a
0: 	 *  Provider object; false if we're getting data for
0: 	 *  a Dependent object.
0: 	 * @return Schema, type, and name for the object with
0: 	 *   the received id have been returned as a string.
0: 	 ****/
0: 
0: 	private String getHiddenDependsData(String type,
0: 		String id, Statement pStmt, HashMap idToNameMap)
0: 		throws Exception
0: 	{
0: 
0: 		ResultSet rs = null;
0: 		if (type.equals("Constraint")) {
0: 			rs = pStmt.executeQuery(
0: 				"select schemaid, constraintname from " +
0: 				"sys.sysconstraints where " +
0: 				"constraintid = '" + id + "'");
0: 		}
0: 		else if (type.equals("StoredPreparedStatement")) {
0: 			rs = pStmt.executeQuery(
0: 				"select schemaid, stmtname from " +
0: 				"sys.sysstatements where stmtid = '" +
0: 				id + "'");
0: 		}
0: 		else if (type.equals("Trigger")) {
0: 			rs = pStmt.executeQuery(
0: 				"select schemaid, triggername from " +
0: 				"sys.systriggers where triggerid = '" +
0: 				id + "'");
0: 		}
0: 		else if (type.equals("View") || type.equals("Table")
0: 		  || type.equals("ColumnsInTable")) {
0: 			rs = pStmt.executeQuery(
0: 				"select schemaid, tablename from " +
0: 				"sys.systables where tableid = '" +
0: 				id + "'");
0: 		}
0: 		else if (type.equals("Conglomerate")) {
0: 			rs = pStmt.executeQuery(
0: 				"select schemaid, conglomeratename from " +
0: 				"sys.sysconglomerates where conglomerateid = '" +
0: 				id + "'");
0: 		}
0: 		else {
0: 			System.out.println("WARNING: Unexpected " +
0: 				"dependent type: " + type);
0: 			return "";
0: 		}
0: 
0: 		if (rs.next()) {
0: 			String schema = (String)idToNameMap.get(rs.getString(1));
0: 			if (isIgnorableSchema(schema))
0: 			// system object (so we want to ignore it); indicate
0: 			// this by returning the string "SYS_OBJECT".
0: 				return "SYS_OBJECT";
0: 			StringBuffer result = new StringBuffer();
0: 			result.append("<");
0: 			result.append(type);
0: 			result.append(">");
0: 			result.append(schema);
0: 			result.append(".");
0: 			if (isSystemGenerated(rs.getString(2)))
0: 				result.append("<sysname>");
0: 			else
0: 				result.append(rs.getString(2));
0: 			return result.toString();
0: 		}
0: 
0: 		return "";
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * deleteDB:
0: 	 * Deletes the database with the received name
0: 	 * from the test directory.
0: 	 * @param dbName Name of the database to be deleted.
0: 	 * @return Database has been completely deleted;
0: 	 *   if deletion failed for any reason, a message
0: 	 *   saying so has been printed to output.
0: 	 ****/
0: 
0: 	private void deleteDB(String dbName)
0: 		throws Exception
0: 	{
0: 
0: 		// Get the full path.
0: 		String deletePath = (new
0: 			File(dbPath + separator + dbName)).getAbsolutePath();
0: 
0: 		// Have to shut it down before we can delete it.
0: 		try {
0: 			Connection conn =
0: 				DriverManager.getConnection("jdbc:derby:" + 
0: 					deletePath + ";shutdown=true");
0: 			conn.close();
0: 		} catch (SQLException se) {
0: 		// shutdown exception.
0: 		}
0: 
0: 		File f = new File(deletePath);
0: 		if (!f.exists()) 
0: 		// nothing to do.
0: 			return;
0: 
0: 		File [] files = f.listFiles();
0: 		for (int i = 0; i < files.length; i++)
0: 			deleteFile(files[i]);
0: 
0: 		if (!f.delete()) {
0: 		// still failed.
0: 			System.out.println("ERROR: deleting: " +
0: 				f.getName());
0: 		}
0: 
0: 		// And finally, delete the CSJARS directory,
0: 		// if there is one.
0: 		deleteFile(new File(System.getProperty("user.dir") +
0: 			separator + "CSJARS"));
0: 
0: 		System.out.println("Database '" + dbName + "' deleted.");
0: 		return;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * deleteFile:
0: 	 * Delete everything in a given directory, then
0: 	 * delete the directory itself (recursive).
0: 	 * @param aFile File object representing the directory
0: 	 *  to be deleted.
0: 	 * @return the directory corresponding to aFile
0: 	 *  has been deleted, as have all of its contents.
0: 	 ****/
0: 
0: 	private void deleteFile(File aFile)
0: 		throws Exception
0: 	{
0: 
0: 		if (!aFile.exists())
0: 		// don't bother.
0: 			return;
0: 
0: 		if (aFile.delete())
0: 		// just a file; we're done.
0: 			return;
0: 
0: 		// Otherwise, have to descend and delete all
0: 		// files in this directory.
0: 		File [] files = aFile.listFiles();
0: 		if (files != null) {
0: 			for (int i = 0; i < files.length; i++)
0: 				deleteFile(files[i]);
0: 		}
0: 
0: 		// Now try to delete.
0: 		if (!aFile.delete()) {
0: 		// still failed.
0: 			System.out.println("ERROR: deleting: " +
0: 				aFile.getName());
0: 		}
0: 
0: 		return;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * dumpFileToSysOut:
0: 	 * Checks to see if the received file is empty,
0: 	 * and prints a message saying so.
0: 	 * @param fName Name of the file to be written to output.
0: 	 * @return The contents of the specified file have
0: 	 *   been written to System.out.
0: 	 ****/
0: 
0: 	private void dumpFileToSysOut(String fName) {
0: 
0: 		try {
0: 
0: 			BufferedReader dumpFile =
0: 				new BufferedReader(new FileReader(fName));
0: 
0: 			String line = dumpFile.readLine();
0: 			if (line != null) {
0: 				System.out.println("File " + fName + " was NOT " +
0: 					"empty.  Contents are:\n" +
0: 					"############## Begin File Contents ################\n");
0: 				do {
0: 					System.out.println(line);
0: 					line = dumpFile.readLine();
0: 				} while (line != null);
0: 				System.out.println(
0: 					"############## End File Contents ################");
0: 			}
0: 			else
0: 				System.out.println("File " + fName + " was empty.");
0: 
0: 			// Close the file.
0: 			dumpFile.close();
0: 
0: 		} catch (Exception e) {
0: 			System.out.println("FAILED: to dump file '" + fName + "'");
0: 			e.printStackTrace(System.out);
0: 		}
0: 
0: 		return;
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * isSystemGenerated:
0: 	 * Returns true if the received string looks like
0: 	 * it is a system-generated string.  We assume
0: 	 * it's system-generated if either 1) it starts
0: 	 * with the letters "SQL", in which case it's a
0: 	 * system-name, or 2) it has a dash in it, in which
0: 	 * case it's a system id.
0: 	 * @param str The string to check.
0: 	 * @return True if we assume the string is system-
0: 	 *  generated, false otherwise.
0: 	 ****/
0: 
0: 	private boolean isSystemGenerated(String str) {
0: 
0: 		return (looksLikeSysGenName(str) ||
0: 			looksLikeSysGenId(str));
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * looksLikeSysGenName:
0: 	 * See if the received string looks like it is
0: 	 * a system-generated name.  There are two types
0: 	 * of system-generated names: 1) visible names,
0: 	 * which start with "SQL", and 2) hidden names,
0: 	 * which exist for Stored Statements that are
0: 	 * used to back triggers; these names start with
0: 	 * "TRIGGERACTN_" and then have a UUID.
0: 	 * NOTE: This test assumes that none of object names
0: 	 * provided in "dblook_makeDB.sql" satisfy
0: 	 * either of these conditions.  If they do, they
0: 	 * will be filtered out of the test output.
0: 	 * @param val The string value in question.
0: 	 * @return True if the value looks like it is a system-
0: 	 *  generated name; false otherwise.
0: 	 ****/
0: 
0: 	private boolean looksLikeSysGenName(String val) {
0: 
0: 		return ((val != null) &&
0: 			((val.trim().indexOf("SQL") == 0) || 			// case 1.
0: 			((val.trim().indexOf("TRIGGERACTN_") == 0) &&	// case 2.
0: 			(val.indexOf("-") != -1))));
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * looksLikeSysGenId:
0: 	 * See if the received string looks like it is
0: 	 * a system-generated id (i.e. contains a dash (-)).
0: 	 * NOTE: This test assumes that none of object names
0: 	 * provided in "dblook_makeDB.sql" will contain
0: 	 * dashes.  If they do, then they will be filtered out
0: 	 * in the test output.
0: 	 * @param val The string value in question.
0: 	 * @return True if the value looks like it is a system-
0: 	 *  generated id; false otherwise.
0: 	 ****/
0: 
0: 	private boolean looksLikeSysGenId(String val) {
0: 
0: 		return ((val != null) && (val.indexOf("-") != -1));
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * columnHoldsObjectName:
0: 	 * Return true if the received column, which is from
0: 	 * some system table, holds the _name_ of a database
0: 	 * object (table, constraint, etc.).  Typically, we
0: 	 * can just look for the keyword "NAME"; the exception
0: 	 * is aliases, where the name is held in a column called
0: 	 * ALIAS.
0: 	 * @param colName Name of the column in question.
0: 	 * @return True if the column name indicates that it
0: 	 *  holds the _name_ of a database object; false if the
0: 	 *  column name indicates that it holds something else.
0: 	 ****/
0: 
0: 	private boolean columnHoldsObjectName(String colName) {
0: 
0: 		return (colName.equals("ALIAS") ||
0: 				(colName.indexOf("NAME") != -1));
0: 
0: 	}
0: 
0: 	/* **********************************************
0: 	 * printAsHeader:
0: 	 * Print the received string to output as a
0: 	 * header.
0: 	 * @param str String to print.
0: 	 ****/
0: 
0: 	private void printAsHeader(String str) {
0: 
0: 		writeOut("--\n*******************************************");
0: 		writeOut(str);
0: 		writeOut("*******************************************\n");
0: 		return;
0: 
0: 	}
0: 
0: }
commit:c1c71ef
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class org.apache.derbyTesting.functionTests.tests.tools.dblook_test
0: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
commit:cb1ca12
/////////////////////////////////////////////////////////////////////////
============================================================================