1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.data.RFResource
1:24bbe75: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
6:eac0369:  */
15:eac0369: 
1:eac0369: package org.apache.derby.impl.store.raw.data;
1:eac0369: 
1:dc43cf8: import java.io.FileNotFoundException;
1:fb93460: import java.io.IOException;
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.OutputStream;
1:66f66a1: import java.security.AccessController;
1:66f66a1: import java.security.PrivilegedActionException;
1:66f66a1: import java.security.PrivilegedExceptionAction;
1:eac0369: 
1:fb93460: import org.apache.derby.iapi.error.StandardException;
1:fb93460: import org.apache.derby.iapi.reference.SQLState;
1:fb93460: import org.apache.derby.iapi.services.context.ContextManager;
1:fb93460: import org.apache.derby.iapi.services.context.ContextService;
1:fb93460: import org.apache.derby.iapi.services.daemon.Serviceable;
1:fb93460: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1:fb93460: import org.apache.derby.iapi.store.access.FileResource;
1:24bbe75: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
1:fb93460: import org.apache.derby.io.StorageFile;
1:fb93460: 
1:949ce92: class RFResource implements FileResource {
1:eac0369: 
1:609999f: 	private final BaseDataFileFactory factory;
1:eac0369: 
1:609999f: 	RFResource(BaseDataFileFactory dataFactory) {
1:eac0369: 		this.factory = dataFactory;
11:eac0369: 	}
1:eac0369: 
7:eac0369: 	/**
1:eac0369: 	  @see FileResource#add
1:eac0369: 	  @exception StandardException Oops
1:eac0369: 	*/
1:eac0369: 	public long add(String name, InputStream source)
1:eac0369: 		 throws StandardException
9:eac0369: 	{
1:eac0369: 		OutputStream os = null;
1:eac0369: 
1:eac0369: 		if (factory.isReadOnly())
1:eac0369:         {
1:eac0369: 			throw StandardException.newException(SQLState.FILE_READ_ONLY);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		long generationId = factory.getNextId();
1:eac0369: 
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			StorageFile file = getAsFile(name, generationId);
1:eac0369:             if (file.exists())
1:eac0369:             {
1:66f66a1: 				throw StandardException.newException(
1:eac0369:                         SQLState.FILE_EXISTS, file);
1:eac0369:             }
1:24bbe75: 
1:24bbe75:             ContextManager cm = 
1:a0dbbd7:                 FileContainer.getContextService().getCurrentContextManager();
1:24bbe75: 
1:402725c:             RawTransaction tran = 
1:402725c:                 factory.getRawStoreFactory().getXactFactory().findUserTransaction(
1:402725c:                         factory.getRawStoreFactory(), 
1:402725c:                         cm, 
1:402725c:                         AccessFactoryGlobals.USER_TRANS_NAME);
1:402725c:             
1:402725c:             // Block the backup, If backup is already in progress wait 
1:402725c:             // for the backup to finish. Jar files are unlogged but the 
1:402725c:             // changes to the  references to the jar file in the catalogs 
1:402725c:             // is logged. A consistent backup can not be made when jar file 
1:402725c:             // is being added.
1:402725c: 
1:402725c:             tran.blockBackup(true);
1:24bbe75: 
1:eac0369: 			StorageFile directory = file.getParentDir();
1:dc43cf8:             StorageFile parentDir = directory.getParentDir();
1:dc43cf8:             boolean pdExisted = parentDir.exists();
1:dc43cf8: 
1:eac0369:             if (!directory.exists())
1:eac0369: 			{
1:eac0369:                 if (!directory.mkdirs())
1:eac0369:                 {
3:eac0369: 					throw StandardException.newException(
1:eac0369:                             SQLState.FILE_CANNOT_CREATE_SEGMENT, directory);
1:eac0369:                 }
1:dc43cf8: 
1:dc43cf8:                 directory.limitAccessToOwner();
1:dc43cf8: 
1:dc43cf8:                 if (!pdExisted) {
1:dc43cf8:                     parentDir.limitAccessToOwner();
1:dc43cf8:                 }
1:eac0369: 			}
1:eac0369: 
1:eac0369:             os = file.getOutputStream();
1:eac0369: 			byte[] data = new byte[4096];
1:eac0369: 			int len;
1:eac0369: 
1:eac0369: 			factory.writeInProgress();
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				while ((len = source.read(data)) != -1) {
1:eac0369: 					os.write(data, 0, len);
1:eac0369: 				}
1:eac0369:                 factory.writableStorageFactory.sync( os, false);
1:eac0369: 			}
1:eac0369: 			finally
1:eac0369: 			{
1:eac0369: 				factory.writeFinished();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		catch (IOException ioe)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(
1:eac0369:                     SQLState.FILE_UNEXPECTED_EXCEPTION, ioe);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			try {
1:eac0369: 				if (os != null) {
1:eac0369: 					os.close();
1:eac0369: 				}
1:eac0369: 			} catch (IOException ioe2) {/*RESOLVE: Why ignore this?*/}
1:eac0369: 
1:eac0369: 			try {
1:eac0369: 				if (source != null)source.close();
1:eac0369: 			} catch (IOException ioe2) {/* RESOLVE: Why ignore this?*/}
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		return generationId;
1:eac0369: 	}
1:eac0369: 
1:78c2db1:     /**
1:78c2db1:      * @see FileResource#removeJarDir
1:78c2db1:      */
1:78c2db1:     public void removeJarDir(String f) throws StandardException {
1:78c2db1:         if (factory.isReadOnly())
1:78c2db1:             throw StandardException.newException(SQLState.FILE_READ_ONLY);
1:78c2db1: 
1:78c2db1:         ContextManager cm =
1:a0dbbd7:             FileContainer.getContextService().getCurrentContextManager();
1:78c2db1: 
1:402725c:         RawTransaction tran =
1:402725c:             factory.getRawStoreFactory().getXactFactory().findUserTransaction(
1:402725c:                         factory.getRawStoreFactory(),
1:402725c:                         cm,
1:402725c:                         AccessFactoryGlobals.USER_TRANS_NAME);
1:78c2db1: 
1:78c2db1:         StorageFile ff = factory.storageFactory.newStorageFile(f);
1:78c2db1:         Serviceable s = new RemoveFile(ff);
1:78c2db1: 
1:78c2db1:         // Since this code is only used during upgrade to post-10.8 databases
1:78c2db1:         // we do no bother to build code for a special RemoveDirOperation and
1:78c2db1:         // do tran.logAndDo (cf. logic in #remove). If the post-commit removal
1:78c2db1:         // doesn't get completed, that is no big issue, the dirs can be removed
1:78c2db1:         // by hand if need be. A prudent DBA will rerun the upgrade from a
1:78c2db1:         // backup if something crashes anyway..
1:78c2db1: 
1:78c2db1:         tran.addPostCommitWork(s);
1:78c2db1:     }
1:78c2db1: 
1:78c2db1:     /**
1:eac0369: 	  @see FileResource#remove
1:eac0369: 	  @exception StandardException Oops
1:eac0369: 	  */
1:609999f: 	public void remove(String name, long currentGenerationId)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (factory.isReadOnly())
1:eac0369: 			throw StandardException.newException(SQLState.FILE_READ_ONLY);
1:eac0369: 
1:eac0369: 			
1:a0dbbd7: 		ContextManager cm = FileContainer.getContextService().getCurrentContextManager();
1:eac0369: 
1:78c2db1:         RawTransaction tran = 
1:78c2db1:             factory.getRawStoreFactory().getXactFactory().findUserTransaction(
1:78c2db1:                         factory.getRawStoreFactory(), 
1:78c2db1:                         cm, 
1:78c2db1:                         AccessFactoryGlobals.USER_TRANS_NAME);
1:eac0369:                     
1:402725c:         // Block the backup, If backup is already in progress wait 
1:402725c:         // for the backup to finish. Jar files are unlogged but the 
1:402725c:         // changes to the  references to the jar file in the catalogs 
1:402725c:         // is logged. A consistent backup can not be made when jar file 
1:402725c:         // is being removed.
1:eac0369: 
1:402725c:         tran.blockBackup(true);
1:eac0369: 
1:609999f: 		tran.logAndDo(new RemoveFileOperation(name, currentGenerationId, true));
1:eac0369: 
1:609999f: 		Serviceable s = new RemoveFile(getAsFile(name, currentGenerationId));
1:eac0369: 
1:609999f: 	    tran.addPostCommitWork(s);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see FileResource#replace
1:eac0369: 	  @exception StandardException Oops
1:eac0369: 	  */
1:609999f: 	public long replace(String name, long currentGenerationId, InputStream source)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (factory.isReadOnly())
1:eac0369: 			throw StandardException.newException(SQLState.FILE_READ_ONLY);
1:eac0369: 
1:609999f: 		remove(name, currentGenerationId);
1:eac0369: 
1:eac0369: 		long generationId = add(name, source);
1:eac0369: 
1:eac0369: 		return generationId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
2:eac0369: 	  @see FileResource#getAsFile
1:eac0369: 	  */
1:eac0369: 	public StorageFile getAsFile(String name, long generationId)
1:eac0369: 	{
1:eac0369: 		String versionedFileName = factory.getVersionedName(name, generationId);
1:eac0369: 
1:eac0369: 		return factory.storageFactory.newStorageFile( versionedFileName);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     public char getSeparatorChar()
1:eac0369:     {
1:eac0369:         return factory.storageFactory.getSeparator();
1:eac0369:     }
1:eac0369: } // end of class RFResource
1:eac0369: 
1:eac0369: 
1:7e7a589: final class RemoveFile implements Serviceable, PrivilegedExceptionAction<Object>
1:eac0369: {
1:eac0369: 	private final StorageFile fileToGo;
1:eac0369: 
1:eac0369: 	RemoveFile(StorageFile fileToGo)
1:eac0369:     {
1:eac0369: 		this.fileToGo = fileToGo;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int performWork(ContextManager context)
1:eac0369:         throws StandardException
1:eac0369:     {
1:66f66a1:         try {
1:66f66a1:             AccessController.doPrivileged(this);
1:66f66a1:         } catch (PrivilegedActionException e) {
1:66f66a1:             throw (StandardException) (e.getException());
1:66f66a1:          }
1:eac0369:         return Serviceable.DONE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public boolean serviceASAP()
1:eac0369:     {
2:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:24bbe75:     /**
1:24bbe75:      * File deletion is a quick operation and typically releases substantial
1:24bbe75:      * amount of space very quickly, this work should be done on the
1:24bbe75:      * user thread. 
1:24bbe75:      * @return true, this work needs to done on user thread. 
1:24bbe75:      */
1:eac0369: 	public boolean serviceImmediately()
1:eac0369: 	{
1:24bbe75: 		return true;
1:66f66a1: 	}
1:66f66a1: 
1:66f66a1:     public Object run() throws StandardException {
1:66f66a1:         // SECURITY PERMISSION - MP1, OP5
1:66f66a1:         if (fileToGo.exists()) {
1:78c2db1:             if (fileToGo.isDirectory()) {
1:78c2db1:                 if (!fileToGo.deleteAll()) {
1:78c2db1:                     throw StandardException.newException(
1:d976a70:                             SQLState.FILE_CANNOT_REMOVE_JAR_FILE, fileToGo);
1:78c2db1:                 }
1:78c2db1:             } else {
1:78c2db1:                 if (!fileToGo.delete()) {
1:78c2db1:                     throw StandardException.newException(
1:d976a70:                             SQLState.FILE_CANNOT_REMOVE_JAR_FILE, fileToGo);
1:78c2db1:                 }
1:66f66a1:             }
1:66f66a1:         }
1:66f66a1:         return null;
1:66f66a1:     }	
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1:                 FileContainer.getContextService().getCurrentContextManager();
/////////////////////////////////////////////////////////////////////////
1:             FileContainer.getContextService().getCurrentContextManager();
/////////////////////////////////////////////////////////////////////////
1: 		ContextManager cm = FileContainer.getContextService().getCurrentContextManager();
commit:7e7a589
/////////////////////////////////////////////////////////////////////////
1: final class RemoveFile implements Serviceable, PrivilegedExceptionAction<Object>
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:d976a70
/////////////////////////////////////////////////////////////////////////
1:                             SQLState.FILE_CANNOT_REMOVE_JAR_FILE, fileToGo);
1:                             SQLState.FILE_CANNOT_REMOVE_JAR_FILE, fileToGo);
commit:402725c
/////////////////////////////////////////////////////////////////////////
1:             RawTransaction tran = 
1:                 factory.getRawStoreFactory().getXactFactory().findUserTransaction(
1:                         factory.getRawStoreFactory(), 
1:                         cm, 
1:                         AccessFactoryGlobals.USER_TRANS_NAME);
1:             // Block the backup, If backup is already in progress wait 
1:             // for the backup to finish. Jar files are unlogged but the 
1:             // changes to the  references to the jar file in the catalogs 
1:             // is logged. A consistent backup can not be made when jar file 
1:             // is being added.
1: 
1:             tran.blockBackup(true);
/////////////////////////////////////////////////////////////////////////
1:         RawTransaction tran = 
1:             factory.getRawStoreFactory().getXactFactory().findUserTransaction(
1:                         factory.getRawStoreFactory(), 
1:                         cm, 
1:                         AccessFactoryGlobals.USER_TRANS_NAME);
1:                     
1:         // Block the backup, If backup is already in progress wait 
1:         // for the backup to finish. Jar files are unlogged but the 
1:         // changes to the  references to the jar file in the catalogs 
1:         // is logged. A consistent backup can not be made when jar file 
1:         // is being removed.
1:         tran.blockBackup(true);
commit:24bbe75
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
/////////////////////////////////////////////////////////////////////////
1:             ContextManager cm = 
0:                 ContextService.getFactory().getCurrentContextManager();
1: 
0:             Transaction tran = 
0:                 factory.getRawStoreFactory().findUserTransaction(
0:                         cm, AccessFactoryGlobals.USER_TRANS_NAME);
1:             
0:             // Prevent backup operation when a jar file is being added
0:             // by setting the transaction into a backup blocking state.
0:             // If backup is already in progress this call will wait 
0:             // for the backup to finish .
0:             ((RawTransaction)tran).setBackupBlockingState(true);
1: 
/////////////////////////////////////////////////////////////////////////
0:         // Prevent backup operation when a jar file is being removed
0:         // by setting the transaction into a backup blocking state.
0:         // If backup is already in progress this call will wait 
0:         // for the backup to finish.
0:         ((RawTransaction)tran).setBackupBlockingState(true);
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * File deletion is a quick operation and typically releases substantial
1:      * amount of space very quickly, this work should be done on the
1:      * user thread. 
1:      * @return true, this work needs to done on user thread. 
1:      */
1: 		return true;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:78c2db1
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @see FileResource#removeJarDir
1:      */
1:     public void removeJarDir(String f) throws StandardException {
1:         if (factory.isReadOnly())
1:             throw StandardException.newException(SQLState.FILE_READ_ONLY);
1: 
1:         ContextManager cm =
0:             ContextService.getFactory().getCurrentContextManager();
1: 
1:         RawTransaction tran =
1:             factory.getRawStoreFactory().getXactFactory().findUserTransaction(
1:                         factory.getRawStoreFactory(),
1:                         cm,
1:                         AccessFactoryGlobals.USER_TRANS_NAME);
1: 
1:         StorageFile ff = factory.storageFactory.newStorageFile(f);
1:         Serviceable s = new RemoveFile(ff);
1: 
1:         // Since this code is only used during upgrade to post-10.8 databases
1:         // we do no bother to build code for a special RemoveDirOperation and
1:         // do tran.logAndDo (cf. logic in #remove). If the post-commit removal
1:         // doesn't get completed, that is no big issue, the dirs can be removed
1:         // by hand if need be. A prudent DBA will rerun the upgrade from a
1:         // backup if something crashes anyway..
1: 
1:         tran.addPostCommitWork(s);
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:             if (fileToGo.isDirectory()) {
1:                 if (!fileToGo.deleteAll()) {
1:                     throw StandardException.newException(
0:                             SQLState.FILE_CANNOT_REMOVE_FILE, fileToGo);
1:                 }
1:             } else {
1:                 if (!fileToGo.delete()) {
1:                     throw StandardException.newException(
0:                             SQLState.FILE_CANNOT_REMOVE_FILE, fileToGo);
1:                 }
commit:dc43cf8
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileNotFoundException;
/////////////////////////////////////////////////////////////////////////
1:             StorageFile parentDir = directory.getParentDir();
1:             boolean pdExisted = parentDir.exists();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:                 directory.limitAccessToOwner();
1: 
1:                 if (!pdExisted) {
1:                     parentDir.limitAccessToOwner();
1:                 }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:fb93460
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.daemon.Serviceable;
1: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1: import org.apache.derby.iapi.store.access.FileResource;
0: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
1: import org.apache.derby.io.StorageFile;
1: 
/////////////////////////////////////////////////////////////////////////
commit:66f66a1
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
0: import java.security.PrivilegedAction;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
0: final class RemoveFile implements Serviceable, PrivilegedExceptionAction
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             AccessController.doPrivileged(this);
1:         } catch (PrivilegedActionException e) {
1:             throw (StandardException) (e.getException());
1:          }
/////////////////////////////////////////////////////////////////////////
1: 	}
1: 
1:     public Object run() throws StandardException {
1:         // SECURITY PERMISSION - MP1, OP5
1:         if (fileToGo.exists()) {
0:             if (!fileToGo.delete()) {
1:                 throw StandardException.newException(
0:                         SQLState.FILE_CANNOT_REMOVE_FILE, fileToGo);
1:             }
1:         }
1:         return null;
1:     }	
commit:609999f
/////////////////////////////////////////////////////////////////////////
1: 	private final BaseDataFileFactory factory;
1: 	RFResource(BaseDataFileFactory dataFactory) {
/////////////////////////////////////////////////////////////////////////
1: 	public void remove(String name, long currentGenerationId)
/////////////////////////////////////////////////////////////////////////
1: 		tran.logAndDo(new RemoveFileOperation(name, currentGenerationId, true));
1: 		Serviceable s = new RemoveFile(getAsFile(name, currentGenerationId));
1: 	    tran.addPostCommitWork(s);
1: 	public long replace(String name, long currentGenerationId, InputStream source)
1: 		remove(name, currentGenerationId);
/////////////////////////////////////////////////////////////////////////
commit:949ce92
/////////////////////////////////////////////////////////////////////////
1: class RFResource implements FileResource {
/////////////////////////////////////////////////////////////////////////
0: 		tran.logAndDo(new RemoveFileOperation(name, currentGenerationId, purgeOnCommit));
0: 			Serviceable s = new RemoveFile(getAsFile(name, currentGenerationId));
/////////////////////////////////////////////////////////////////////////
0: 	private StorageFile getAsFile(String name)
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.data.RFResource
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:c6ad534
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.data;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.daemon.Serviceable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.FileResource;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
0: import org.apache.derby.iapi.store.access.DatabaseInstant;
1: 
0: import org.apache.derby.io.StorageFactory;
0: import org.apache.derby.io.WritableStorageFactory;
0: import org.apache.derby.io.StorageFile;
0: import org.apache.derby.io.StorageRandomAccessFile;
1: 
1: import java.io.InputStream;
1: import java.io.OutputStream;
0: import java.io.FileNotFoundException;
0: import java.io.IOException;
1: 
0: public class RFResource implements FileResource {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
0: 	protected final BaseDataFileFactory factory;
1: 
0: 	public RFResource(BaseDataFileFactory dataFactory) {
1: 		this.factory = dataFactory;
1: 	}
1: 
1: 	/**
1: 	  @see FileResource#add
1: 	  @exception StandardException Oops
1: 	*/
1: 	public long add(String name, InputStream source)
1: 		 throws StandardException
1: 	{
1: 		OutputStream os = null;
1: 
1: 		if (factory.isReadOnly())
1:         {
1: 			throw StandardException.newException(SQLState.FILE_READ_ONLY);
1:         }
1: 
1: 		long generationId = factory.getNextId();
1: 
1: 		try
1: 		{
1: 			StorageFile file = getAsFile(name, generationId);
1:             if (file.exists())
1:             {
1: 				throw StandardException.newException(
1:                         SQLState.FILE_EXISTS, file);
1:             }
1: 
1: 			StorageFile directory = file.getParentDir();
1:             if (!directory.exists())
1: 			{
1:                 if (!directory.mkdirs())
1:                 {
1: 					throw StandardException.newException(
1:                             SQLState.FILE_CANNOT_CREATE_SEGMENT, directory);
1:                 }
1: 			}
1: 
1:             os = file.getOutputStream();
1: 			byte[] data = new byte[4096];
1: 			int len;
1: 
1: 			factory.writeInProgress();
1: 			try
1: 			{
1: 				while ((len = source.read(data)) != -1) {
1: 					os.write(data, 0, len);
1: 				}
1:                 factory.writableStorageFactory.sync( os, false);
1: 			}
1: 			finally
1: 			{
1: 				factory.writeFinished();
1: 			}
1: 		}
1: 
1: 		catch (IOException ioe)
1: 		{
1: 			throw StandardException.newException(
1:                     SQLState.FILE_UNEXPECTED_EXCEPTION, ioe);
1: 		}
1: 
1: 		finally
1: 		{
1: 			try {
1: 				if (os != null) {
1: 					os.close();
1: 				}
1: 			} catch (IOException ioe2) {/*RESOLVE: Why ignore this?*/}
1: 
1: 			try {
1: 				if (source != null)source.close();
1: 			} catch (IOException ioe2) {/* RESOLVE: Why ignore this?*/}
1: 		}
1: 		
1: 		return generationId;
1: 	}
1: 
1: 	/**
1: 	  @see FileResource#remove
1: 	  @exception StandardException Oops
1: 	  */
0: 	public void remove(String name, long currentGenerationId, boolean purgeOnCommit)
1: 		throws StandardException
1: 	{
1: 		if (factory.isReadOnly())
1: 			throw StandardException.newException(SQLState.FILE_READ_ONLY);
1: 
1: 			
0: 		ContextManager cm = ContextService.getFactory().getCurrentContextManager();
1: 
0: 		Transaction tran = 
0:             factory.getRawStoreFactory().findUserTransaction(
0:                 cm, AccessFactoryGlobals.USER_TRANS_NAME);
1: 
0: 		tran.logAndDo(privRemoveFileOperation(name, currentGenerationId, purgeOnCommit));
1: 
0: 		if (purgeOnCommit) {
1: 
0: 			Serviceable s = privRemoveFile(getAsFile(name, currentGenerationId));
1: 
0: 			tran.addPostCommitWork(s);
1: 		}
1: 	}
1: 
1: 	/**
1: 	  @see FileResource#replace
1: 	  @exception StandardException Oops
1: 	  */
0: 	public long replace(String name, long currentGenerationId, InputStream source, boolean purgeOnCommit)
1: 		throws StandardException
1: 	{
1: 		if (factory.isReadOnly())
1: 			throw StandardException.newException(SQLState.FILE_READ_ONLY);
1: 
0: 		remove(name, currentGenerationId, purgeOnCommit);
1: 
1: 		long generationId = add(name, source);
1: 
1: 		return generationId;
1: 	}
1: 
1: 
1: 	/**
1: 	  @see FileResource#getAsFile
1: 	  */
1: 	public StorageFile getAsFile(String name, long generationId)
1: 	{
1: 		String versionedFileName = factory.getVersionedName(name, generationId);
1: 
1: 		return factory.storageFactory.newStorageFile( versionedFileName);
1: 	}
1: 
1: 	/**
1: 	  @see FileResource#getAsFile
1: 	  */
0: 	public StorageFile getAsFile(String name)
1: 	{
0: 		return factory.storageFactory.newStorageFile( name);
1: 	}
1: 
1: 	/**
0: 	  @see FileResource#getAsStream
0: 	  @exception IOException trouble accessing file.
1: 	  */
0: 	public InputStream getAsStream(String name, long generationId) 
0: 		 throws IOException
1: 	{
0:         return getAsFile(name, generationId).getInputStream();
1: 	}
1: 
1: 	/**
0: 	  @see FileResource#getAsStream
0: 	  @exception IOException trouble accessing file.
1: 	  */
0: 	public InputStream getAsStream(String name)
0: 		 throws IOException
1: 	{
0: 		return getAsFile(name).getInputStream();
1: 	}
1: 
1: 	/**
0: 	  @see FileResource#purgeOldGenerations
1: 	  */
0:     public void purgeOldGenerations(DatabaseInstant purgeTo)
1: 	{
1: 
0: 		// search from the start of the log until now
0: 		// remove any generation files that have been
0: 		// logged for removal and their transaction committed.
1: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.THROWASSERT("purgeOldGenerations is not implemented");
1: 	}
1: 
1:     public char getSeparatorChar()
1:     {
1:         return factory.storageFactory.getSeparator();
1:     }
1:     
0:     protected Serviceable privRemoveFile(StorageFile file)
1:     {
0:         return new RemoveFile(file);
1:     }
1: 
0:     protected RemoveFileOperation privRemoveFileOperation(
0:         String name, long generationId, boolean removeAtOnce)
1:     {
0:         return new RemoveFileOperation(name,generationId,removeAtOnce);
1:     }
1: } // end of class RFResource
1: 
1: 
0: class RemoveFile implements Serviceable
1: {
1: 	private final StorageFile fileToGo;
1: 
1: 	RemoveFile(StorageFile fileToGo)
1:     {
1: 		this.fileToGo = fileToGo;
1: 	}
1: 
1: 	public int performWork(ContextManager context)
1:         throws StandardException
1:     {
0:         // SECURITY PERMISSION - MP1, OP5
0:         if (fileToGo.exists())
1:         {
0:             if (!fileToGo.delete())
1:             {
1:                 throw StandardException.newException(
0:                     SQLState.FILE_CANNOT_REMOVE_FILE, fileToGo);
1:             }
1:         }
1:         return Serviceable.DONE;
1: 	}
1: 
1: 	public boolean serviceASAP()
1:     {
1: 		return false;
1: 	}
1: 
1: 
0: 	// @return true, if this work needs to be done on a user thread immediately
1: 	public boolean serviceImmediately()
1: 	{
1: 		return false;
1: 	}	
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.data;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.daemon.Serviceable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.FileResource;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
0: import org.apache.derby.iapi.store.access.DatabaseInstant;
0: 
0: import org.apache.derby.io.StorageFactory;
0: import org.apache.derby.io.WritableStorageFactory;
0: import org.apache.derby.io.StorageFile;
0: import org.apache.derby.io.StorageRandomAccessFile;
0: 
0: import java.io.InputStream;
0: import java.io.OutputStream;
0: import java.io.FileNotFoundException;
0: import java.io.IOException;
0: 
0: public class RFResource implements FileResource {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0: 	protected final BaseDataFileFactory factory;
0: 
0: 	public RFResource(BaseDataFileFactory dataFactory) {
0: 		this.factory = dataFactory;
0: 	}
0: 
0: 	/**
0: 	  @see FileResource#add
0: 	  @exception StandardException Oops
0: 	*/
0: 	public long add(String name, InputStream source)
0: 		 throws StandardException
0: 	{
0: 		OutputStream os = null;
0: 
0: 		if (factory.isReadOnly())
0:         {
0: 			throw StandardException.newException(SQLState.FILE_READ_ONLY);
0:         }
0: 
0: 		long generationId = factory.getNextId();
0: 
0: 		try
0: 		{
0: 			StorageFile file = getAsFile(name, generationId);
0:             if (file.exists())
0:             {
0: 				throw StandardException.newException(
0:                         SQLState.FILE_EXISTS, file);
0:             }
0: 
0: 			StorageFile directory = file.getParentDir();
0:             if (!directory.exists())
0: 			{
0:                 if (!directory.mkdirs())
0:                 {
0: 					throw StandardException.newException(
0:                             SQLState.FILE_CANNOT_CREATE_SEGMENT, directory);
0:                 }
0: 			}
0: 
0:             os = file.getOutputStream();
0: 			byte[] data = new byte[4096];
0: 			int len;
0: 
0: 			factory.writeInProgress();
0: 			try
0: 			{
0: 				while ((len = source.read(data)) != -1) {
0: 					os.write(data, 0, len);
0: 				}
0:                 factory.writableStorageFactory.sync( os, false);
0: 			}
0: 			finally
0: 			{
0: 				factory.writeFinished();
0: 			}
0: 		}
0: 
0: 		catch (IOException ioe)
0: 		{
0: 			throw StandardException.newException(
0:                     SQLState.FILE_UNEXPECTED_EXCEPTION, ioe);
0: 		}
0: 
0: 		finally
0: 		{
0: 			try {
0: 				if (os != null) {
0: 					os.close();
0: 				}
0: 			} catch (IOException ioe2) {/*RESOLVE: Why ignore this?*/}
0: 
0: 			try {
0: 				if (source != null)source.close();
0: 			} catch (IOException ioe2) {/* RESOLVE: Why ignore this?*/}
0: 		}
0: 		
0: 		return generationId;
0: 	}
0: 
0: 	/**
0: 	  @see FileResource#remove
0: 	  @exception StandardException Oops
0: 	  */
0: 	public void remove(String name, long currentGenerationId, boolean purgeOnCommit)
0: 		throws StandardException
0: 	{
0: 		if (factory.isReadOnly())
0: 			throw StandardException.newException(SQLState.FILE_READ_ONLY);
0: 
0: 			
0: 		ContextManager cm = ContextService.getFactory().getCurrentContextManager();
0: 
0: 		Transaction tran = 
0:             factory.getRawStoreFactory().findUserTransaction(
0:                 cm, AccessFactoryGlobals.USER_TRANS_NAME);
0: 
0: 		tran.logAndDo(privRemoveFileOperation(name, currentGenerationId, purgeOnCommit));
0: 
0: 		if (purgeOnCommit) {
0: 
0: 			Serviceable s = privRemoveFile(getAsFile(name, currentGenerationId));
0: 
0: 			tran.addPostCommitWork(s);
0: 		}
0: 	}
0: 
0: 	/**
0: 	  @see FileResource#replace
0: 	  @exception StandardException Oops
0: 	  */
0: 	public long replace(String name, long currentGenerationId, InputStream source, boolean purgeOnCommit)
0: 		throws StandardException
0: 	{
0: 		if (factory.isReadOnly())
0: 			throw StandardException.newException(SQLState.FILE_READ_ONLY);
0: 
0: 		remove(name, currentGenerationId, purgeOnCommit);
0: 
0: 		long generationId = add(name, source);
0: 
0: 		return generationId;
0: 	}
0: 
0: 
0: 	/**
0: 	  @see FileResource#getAsFile
0: 	  */
0: 	public StorageFile getAsFile(String name, long generationId)
0: 	{
0: 		String versionedFileName = factory.getVersionedName(name, generationId);
0: 
0: 		return factory.storageFactory.newStorageFile( versionedFileName);
0: 	}
0: 
0: 	/**
0: 	  @see FileResource#getAsFile
0: 	  */
0: 	public StorageFile getAsFile(String name)
0: 	{
0: 		return factory.storageFactory.newStorageFile( name);
0: 	}
0: 
0: 	/**
0: 	  @see FileResource#getAsStream
0: 	  @exception IOException trouble accessing file.
0: 	  */
0: 	public InputStream getAsStream(String name, long generationId) 
0: 		 throws IOException
0: 	{
0:         return getAsFile(name, generationId).getInputStream();
0: 	}
0: 
0: 	/**
0: 	  @see FileResource#getAsStream
0: 	  @exception IOException trouble accessing file.
0: 	  */
0: 	public InputStream getAsStream(String name)
0: 		 throws IOException
0: 	{
0: 		return getAsFile(name).getInputStream();
0: 	}
0: 
0: 	/**
0: 	  @see FileResource#purgeOldGenerations
0: 	  */
0:     public void purgeOldGenerations(DatabaseInstant purgeTo)
0: 	{
0: 
0: 		// search from the start of the log until now
0: 		// remove any generation files that have been
0: 		// logged for removal and their transaction committed.
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.THROWASSERT("purgeOldGenerations is not implemented");
0: 	}
0: 
0:     public char getSeparatorChar()
0:     {
0:         return factory.storageFactory.getSeparator();
0:     }
0:     
0:     protected Serviceable privRemoveFile(StorageFile file)
0:     {
0:         return new RemoveFile(file);
0:     }
0: 
0:     protected RemoveFileOperation privRemoveFileOperation(
0:         String name, long generationId, boolean removeAtOnce)
0:     {
0:         return new RemoveFileOperation(name,generationId,removeAtOnce);
0:     }
0: } // end of class RFResource
0: 
0: 
0: class RemoveFile implements Serviceable
0: {
0: 	private final StorageFile fileToGo;
0: 
0: 	RemoveFile(StorageFile fileToGo)
0:     {
0: 		this.fileToGo = fileToGo;
0: 	}
0: 
0: 	public int performWork(ContextManager context)
0:         throws StandardException
0:     {
0:         // SECURITY PERMISSION - MP1, OP5
0:         if (fileToGo.exists())
0:         {
0:             if (!fileToGo.delete())
0:             {
0:                 throw StandardException.newException(
0:                     SQLState.FILE_CANNOT_REMOVE_FILE, fileToGo);
0:             }
0:         }
0:         return Serviceable.DONE;
0: 	}
0: 
0: 	public boolean serviceASAP()
0:     {
0: 		return false;
0: 	}
0: 
0: 
0: 	// @return true, if this work needs to be done on a user thread immediately
0: 	public boolean serviceImmediately()
0: 	{
0: 		return false;
0: 	}	
0: }
============================================================================