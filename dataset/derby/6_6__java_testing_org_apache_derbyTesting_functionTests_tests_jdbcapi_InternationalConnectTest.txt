1:6c42ee6: /*
1:b005ffa:  
1:6384512:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.InternationalConnectTest
1:b005ffa:  
1:6384512:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6384512:    contributor license agreements.  See the NOTICE file distributed with
1:6384512:    this work for additional information regarding copyright ownership.
1:6384512:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6384512:    (the "License"); you may not use this file except in compliance with
1:6384512:    the License.  You may obtain a copy of the License at
1:b005ffa:  
1:6384512:       http://www.apache.org/licenses/LICENSE-2.0
1:b005ffa:  
1:6384512:    Unless required by applicable law or agreed to in writing, software
1:6384512:    distributed under the License is distributed on an "AS IS" BASIS,
1:6384512:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6384512:    See the License for the specific language governing permissions and
1:6384512:    limitations under the License.
1:b005ffa:  
6:6384512:  */
1:6384512: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:b005ffa: 
1:6384512: import java.io.File;
1:b005ffa: import java.io.UnsupportedEncodingException;
1:6384512: import java.sql.Connection;
1:6384512: import java.sql.DriverManager;
1:6384512: import java.sql.SQLException;
1:e5a97fe: import java.util.ArrayList;
1:6384512: import javax.sql.ConnectionPoolDataSource;
1:6384512: import javax.sql.PooledConnection;
1:6384512: import javax.sql.XAConnection;
1:6384512: import javax.sql.XADataSource;
1:b005ffa: 
1:6384512: import junit.framework.Test;
1:b005ffa: 
1:6384512: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:6384512: import org.apache.derbyTesting.junit.J2EEDataSource;
1:6384512: import org.apache.derbyTesting.junit.TestConfiguration;
1:b005ffa: 
1:6384512: public class InternationalConnectTest extends BaseJDBCTestCase {
1:b005ffa: 
1:b005ffa:     /**
1:6384512:      * Test connecting with multibyte characters in:
1:6384512:      * - Database name 
1:6384512:      * - User
1:6384512:      * - Password
2:6384512:      * 
1:6384512:      * Currently just throws an exception for client.
1:6384512:      * Works ok for embedded.
1:6384512:      * 
1:6384512:      * This test tests DriverManager, XADataSource and ConnectionPoolDataSource
1:6384512:      * and is not run with J2ME.  Simple DataSource is tested with 
1:6384512:      * InternationalConnectSimpleDSTest
1:6384512:      * 
1:b005ffa:      */
1:b005ffa:    
1:e5a97fe:     /* Keep track of the databases created in the fixtures to cleanup in tearDown() */
1:e18f54b:     private ArrayList<String> databasesForCleanup;
1:e5a97fe:     
2:6384512:     /**
1:6384512:      * @param name
1:c7bf46c:      */
1:6384512:     public InternationalConnectTest(String name) {
1:6384512:         super(name);
1:e5a97fe:         
1:e18f54b:         databasesForCleanup = new ArrayList<String>();
1:45e3ef0:     }
1:6c42ee6: 
1:813aa38:     //DERBY-4805(Increase the length of the RDBNAM field in the DRDA 
1:813aa38:     // implementation)
1:813aa38:     //Fixing the jira above now prevents us from getting limited to 255 bytes
1:813aa38:     // in network server case for RDBNAM. The new limit now is 1024 bytes.
1:813aa38:     //Try 2 test cases for database name. 
1:813aa38:     // One right at the upper boundary of 1024 byte length
1:813aa38:     // and second with going little over 1024 byte length.
1:813aa38:     //Note that the test below is written for in-memory db rather than
1:813aa38:     // traditional on disk dbs. This is because depending on the file
1:813aa38:     // system and operating systems, there are different limits on
1:813aa38:     // how long a file name can be. In order to avoid having to 
1:813aa38:     // worry about various OSes, it is more portable to do the testing
1:813aa38:     // with in-memory db. 
1:b005ffa:     public void testBoundaries() throws SQLException, UnsupportedEncodingException {
1:b005ffa:         if (usingEmbedded()) return; /* This test is only for Client/Server */
1:4b013e1: 
1:813aa38:         //To get around the file name length limit on various operating 
1:813aa38:         // systems, using in memory db to try the long RDBNAM of 1024
1:813aa38:         // bytes
1:813aa38:         //Following url works fine because the length of string
1:813aa38:         // memory...;true is 1024 bytes long
1:3c26ad0:         String dbUrl1024bytes = "memory:/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;create=true";
1:813aa38:         //Following url fails because the length of string
1:813aa38:         // memory...;true is 1025 bytes long, 1 byte longer than max length
1:3c26ad0:         String dbUrl1025bytes = "memory:/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;create=true";
1:813aa38: 
1:6c42ee6:         /*
1:813aa38:          *Prior to DERBY-4805 fix, maximum length in bytes was 255. With
1:813aa38:          * the fix, the new maximum length is 1024 bytes
1:813aa38:          *Try 2 test cases. One right at the upper boundary of 1024 byte length
1:813aa38:          * and second with 1025 byte length.
1:6c42ee6:          */
1:6c42ee6: 
1:813aa38:         /* This time it should work as we're right at the limit */
1:813aa38:         String url = TestConfiguration
1:813aa38:                 .getCurrent().getJDBCUrl(dbUrl1024bytes);
1:813aa38:         loadDriver(url);
1:813aa38:         Connection conn = DriverManager.getConnection(url);
1:813aa38:         conn.close();
1:65b2c92: 
1:813aa38:         //Add test case 2
1:813aa38:         //We will try going over 1024 byte length for database name and it 
1:813aa38:         // will fail as expected
1:813aa38:         url = TestConfiguration
1:813aa38:                 .getCurrent().getJDBCUrl(dbUrl1025bytes);
1:813aa38: 
1:813aa38:         try {
1:b005ffa:                 conn = DriverManager.getConnection(url);
1:b005ffa:                 assertTrue("Used more characters than possible in database name",
1:b005ffa:                         false);
1:813aa38:         } catch (SQLException e) {
1:813aa38:             	assertSQLState("08001", e); /* Check if it failed */
1:813aa38:         }
1:813aa38:     }
1:813aa38:     
1:813aa38:     /**
1:813aa38:      * Will check if the JDBC driver has been loaded and load it if that is not
1:813aa38:      * the case.
1:813aa38:      * Any other exception messages than "No suitable driver" on the first
1:813aa38:      * attempt to get the JDBC driver will result in an assertion failure.
1:813aa38:      * 
1:813aa38:      * @param url a valid connection URL for the desired JDBC driver
1:813aa38:      * @throws SQLException if an unexpected exception is thrown
1:813aa38:      */
1:813aa38:     private void loadDriver(String url) throws SQLException {
1:813aa38:         try {
1:813aa38:             DriverManager.getDriver(url);
1:813aa38:         } catch (SQLException e) {
1:813aa38:             // getDriver() failed, JDBC driver probably not loaded.
1:813aa38:             // Expecting SQLState 08001 and message "No suitable driver"...
1:813aa38:             assertSQLState("Unexpected SQLState from getDriver().", "08001", e);
1:813aa38:             assertEquals("Unexpected exception message from getDriver(), ",
1:813aa38:                     "No suitable driver", e.getMessage());
1:813aa38:             String driverClass = 
1:813aa38:                     getTestConfiguration().getJDBCClient().getJDBCDriverName();
1:813aa38:             println("Loading JDBC driver " + driverClass);
1:813aa38:             // load the driver
1:813aa38:             try {
1:4469400:                 Class<?> clazz = Class.forName(driverClass);
1:4469400:                 clazz.getConstructor().newInstance();
1:813aa38:             } catch (ClassNotFoundException cnfe) {
1:813aa38:                 throw new SQLException("Failed to load JDBC driver '" 
1:813aa38:                         + driverClass + "', ClassNotFoundException: " 
1:813aa38:                         + cnfe.getMessage());
1:813aa38:             } catch (IllegalAccessException iae) {
1:813aa38:                 throw new SQLException("Failed to load JDBC driver '" 
1:813aa38:                         + driverClass + "', IllegalAccessException: " 
1:813aa38:                         + iae.getMessage());
1:813aa38:             } catch (InstantiationException ie) {
1:813aa38:                 throw new SQLException("Failed to load JDBC driver '" 
1:813aa38:                         + driverClass + "', InstantiationException: " 
1:813aa38:                         + ie.getMessage());
1:4469400:             } catch (NoSuchMethodException ie) {
1:4469400:                 throw new SQLException("Failed to load JDBC driver '" 
1:4469400:                         + driverClass + "', InstantiationException: " 
1:4469400:                         + ie.getMessage());
1:4469400:             } catch (java.lang.reflect.InvocationTargetException ie) {
1:4469400:                 throw new SQLException("Failed to load JDBC driver '" 
1:4469400:                         + driverClass + "', InstantiationException: " 
1:4469400:                         + ie.getMessage());
1:6c42ee6:             }
1:6c42ee6:         }
1:65b2c92:     }
1:65b2c92:     
1:c7bf46c:     /**
1:6384512:      * Test Chinese character in database name, user and password, using 
1:6384512:      * DriverManager methods.
1:e5a97fe:      * 
1:6384512:      * @throws SQLException
1:6c42ee6:      */
1:cd5b86c:     public void testDriverManagerConnect() throws SQLException {        
1:6384512:         //get a connection to load the driver
1:4b013e1:         getConnection();
1:6384512:         Connection conn = null;
1:6384512:         String url = null;
1:6c42ee6: 
1:b005ffa:         //Test Chinese database name
1:b005ffa:         url = TestConfiguration.getCurrent().getJDBCUrl("\u4e10;create=true");
1:6c42ee6:         
1:b005ffa:         conn = DriverManager.getConnection(url);
1:b005ffa:         conn.close();           
1:e5a97fe: 
1:b005ffa:         // Test Chinese user name
1:b005ffa:         url = TestConfiguration.getCurrent().getJDBCUrl("\u4e10;user=\u4e10");
1:b005ffa:         conn = DriverManager.getConnection(url);
1:b005ffa:         conn.close();
1:e5a97fe: 
1:b005ffa:         // Test Chinese user name in parameter to getConnection
1:b005ffa:         url = TestConfiguration.getCurrent().getJDBCUrl("\u4e10");
1:b005ffa:         conn = DriverManager.getConnection(url,"\u4e10","pass");
1:b005ffa:         conn.close();
1:e5a97fe: 
1:b005ffa:         // Test Chinese password in url
1:b005ffa:         url = TestConfiguration.getCurrent().getJDBCUrl("\u4e10;user=user;password=\u4e10");
1:b005ffa:         conn = DriverManager.getConnection(url);
1:b005ffa:         conn.close();
1:e5a97fe: 
1:b005ffa:         // Test Chinese password in parameter to getConnection()
1:b005ffa:         url = TestConfiguration.getCurrent().getJDBCUrl("\u4e10");
1:b005ffa:         conn = DriverManager.getConnection(url,"\u4e10","\u4e10");
1:b005ffa:         conn.close();
1:e5a97fe:         
1:e5a97fe:         /* Add the created database for cleanup by tearDown() */
1:e5a97fe:         databasesForCleanup.add("\u4e10");
1:6c42ee6:     }
1:b005ffa:     
1:b005ffa:     
1:6384512:     /**
1:6384512:      * Test XA Connection for chinese database name, user and password.
1:6384512:      * @throws SQLException
1:6c42ee6:      */
1:cd5b86c:     public void testXADSConnect() throws SQLException {        
1:6384512:         // Test chinese database name.
1:6384512:         XADataSource ds = J2EEDataSource.getXADataSource();
1:6384512:         J2EEDataSource.setBeanProperty(ds, "databaseName", "\u4e10");
1:6384512:         J2EEDataSource.setBeanProperty(ds, "createDatabase", "create");        
1:b005ffa: 
1:b005ffa:         XAConnection xaconn = ds.getXAConnection();
1:b005ffa:         Connection conn = xaconn.getConnection();
1:b005ffa:         conn.close();
1:9b4a465:         xaconn.close();
1:b005ffa:   
1:6384512:         // Chinese user
1:b005ffa:         J2EEDataSource.setBeanProperty(ds, "user", "\u4e10");
1:b005ffa:         xaconn = ds.getXAConnection();
1:b005ffa:         conn = xaconn.getConnection();
1:b005ffa:         conn.close();
1:9b4a465:         xaconn.close();
1:e5a97fe: 
1:6384512:         // Chinese password
1:b005ffa:         J2EEDataSource.setBeanProperty(ds, "password", "\u4e10");
1:b005ffa:         xaconn = ds.getXAConnection();
1:b005ffa:         conn = xaconn.getConnection();
1:b005ffa:         conn.close();
1:9b4a465:         xaconn.close();
1:b005ffa:         
1:e5a97fe:         /* Add the created database for cleanup by tearDown() */
1:e5a97fe:         databasesForCleanup.add("\u4e10");
1:6c42ee6:     }
1:b005ffa:     
1:b005ffa:     
1:6384512:     /**
1:6384512:      * Test pooled connetion for chinese database name, user and password.
1:6384512:      * @throws SQLException
1:6c42ee6:      */
1:6384512:     public void testCPDSConnect() throws SQLException {
1:6384512:         // Test chinese database name.
1:6384512:         ConnectionPoolDataSource ds = J2EEDataSource.getConnectionPoolDataSource();
1:6384512:         J2EEDataSource.setBeanProperty(ds, "databaseName", "\u4e10");
1:6384512:         J2EEDataSource.setBeanProperty(ds, "createDatabase", "create");        
1:b005ffa: 
1:b005ffa:         PooledConnection poolConn = ds.getPooledConnection();
1:b005ffa:         Connection conn = poolConn.getConnection();
1:b005ffa:         conn.close();
1:9b4a465:         poolConn.close();
1:b005ffa:  
1:6384512:         // Chinese user
1:b005ffa:         J2EEDataSource.setBeanProperty(ds, "user", "\u4e10");
1:b005ffa:         poolConn = ds.getPooledConnection();
1:b005ffa:         conn = poolConn.getConnection();
2:b005ffa:         conn.close();
1:9b4a465:         poolConn.close();
1:b005ffa: 
1:6384512:         // Chinese password
1:b005ffa:         J2EEDataSource.setBeanProperty(ds, "password", "\u4e10");
1:b005ffa:         poolConn= ds.getPooledConnection();
1:b005ffa:         conn = poolConn.getConnection();
1:b005ffa:         conn.close();
1:9b4a465:         poolConn.close();
1:e5a97fe:         
1:e5a97fe:         /* Add the created database for cleanup by tearDown() */
1:e5a97fe:         databasesForCleanup.add("\u4e10");
1:e5a97fe:     }
1:b005ffa: 
1:6384512:     /**
1:c7bf46c:      * Regression test case for DERBY-4799. Attempting to connect to a
1:c7bf46c:      * database that doesn't exist used to cause a protocol error between
1:c7bf46c:      * the network server and the client. This only happened if the
1:c7bf46c:      * database name was at least 18 characters and the name contained at
1:c7bf46c:      * least one non-ascii character.
1:e5a97fe:      */
1:c7bf46c:     public void testFailureOnNonExistentDatabase() throws SQLException {
1:6c42ee6:         
1:c7bf46c:         String url = TestConfiguration.getCurrent().getJDBCUrl(
1:c7bf46c:                 "abcdefghijklmnopq\u00E5");
1:b005ffa:         try {
1:c7bf46c:             // This call used to fail with a protocol error with the
1:c7bf46c:             // client driver. Check that it fails gracefully now.
1:c7bf46c:             DriverManager.getConnection(url);
1:c7bf46c:             fail(url + " should not exist");
1:c7bf46c:         } catch (SQLException sqle) {
1:c7bf46c:             // Embedded responds with XJ004 - database not found.
1:c7bf46c:             // Client responds with 08004 - connection refused because
1:c7bf46c:             // the database was not found.
1:c7bf46c:             String expected = usingEmbedded() ? "XJ004" : "08004";
1:c7bf46c:             assertSQLState(expected, sqle);
1:b005ffa:         }
1:b005ffa:     }
1:c7bf46c: 
1:9b4a465:     public void tearDown() throws Exception {
1:e5a97fe:         /* Iterate through the databases for cleanup and delete them */
1:e5a97fe:         for (int i=0; i<databasesForCleanup.size(); i++) {
1:e5a97fe:             String shutdownUrl = TestConfiguration.getCurrent()
1:e5a97fe:                                 .getJDBCUrl(databasesForCleanup.get(i) + ";shutdown=true");
1:e5a97fe:             try {
1:e5a97fe:                 DriverManager.getConnection(shutdownUrl);
1:45e3ef0:                 fail("Database didn't shut down");
1:e5a97fe:             } catch (SQLException se) {
1:e5a97fe:                 // ignore shutdown exception
1:45e3ef0:                 assertSQLState("08006", se);
1:e5a97fe:             }
1:e5a97fe:             removeDirectory(getSystemProperty("derby.system.home") +  File.separator + 
1:e5a97fe:                     databasesForCleanup.get(i));
1:b005ffa:         }
1:e5a97fe:         
1:e5a97fe:         /* Clear the array list as new fixtures will add other databases */
1:9b4a465:         databasesForCleanup = null;
1:9b4a465: 
1:9b4a465:         super.tearDown();
1:b005ffa:     }
1:c7bf46c:     
1:e5a97fe:     public static Test suite() {        
1:6384512:         return TestConfiguration.defaultSuite(InternationalConnectTest.class);
1:c7bf46c:     }
23:6384512:    
1:c7bf46c: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:                 Class<?> clazz = Class.forName(driverClass);
1:                 clazz.getConstructor().newInstance();
/////////////////////////////////////////////////////////////////////////
1:             } catch (NoSuchMethodException ie) {
1:                 throw new SQLException("Failed to load JDBC driver '" 
1:                         + driverClass + "', InstantiationException: " 
1:                         + ie.getMessage());
1:             } catch (java.lang.reflect.InvocationTargetException ie) {
1:                 throw new SQLException("Failed to load JDBC driver '" 
1:                         + driverClass + "', InstantiationException: " 
1:                         + ie.getMessage());
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:3c26ad0
/////////////////////////////////////////////////////////////////////////
1:         String dbUrl1024bytes = "memory:/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;create=true";
1:         String dbUrl1025bytes = "memory:/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;create=true";
commit:813aa38
/////////////////////////////////////////////////////////////////////////
1:     //DERBY-4805(Increase the length of the RDBNAM field in the DRDA 
1:     // implementation)
1:     //Fixing the jira above now prevents us from getting limited to 255 bytes
1:     // in network server case for RDBNAM. The new limit now is 1024 bytes.
1:     //Try 2 test cases for database name. 
1:     // One right at the upper boundary of 1024 byte length
1:     // and second with going little over 1024 byte length.
1:     //Note that the test below is written for in-memory db rather than
1:     // traditional on disk dbs. This is because depending on the file
1:     // system and operating systems, there are different limits on
1:     // how long a file name can be. In order to avoid having to 
1:     // worry about various OSes, it is more portable to do the testing
1:     // with in-memory db. 
1:         //To get around the file name length limit on various operating 
1:         // systems, using in memory db to try the long RDBNAM of 1024
1:         // bytes
1:         //Following url works fine because the length of string
1:         // memory...;true is 1024 bytes long
0:         String dbUrl1024bytes = "memory:dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;create=true";
1:         //Following url fails because the length of string
1:         // memory...;true is 1025 bytes long, 1 byte longer than max length
0:         String dbUrl1025bytes = "memory:dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/dir1234567890/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;create=true";
1: 
1:          *Prior to DERBY-4805 fix, maximum length in bytes was 255. With
1:          * the fix, the new maximum length is 1024 bytes
1:          *Try 2 test cases. One right at the upper boundary of 1024 byte length
1:          * and second with 1025 byte length.
1:         /* This time it should work as we're right at the limit */
1:         String url = TestConfiguration
1:                 .getCurrent().getJDBCUrl(dbUrl1024bytes);
1:         loadDriver(url);
1:         Connection conn = DriverManager.getConnection(url);
1:         conn.close();
1:         //Add test case 2
1:         //We will try going over 1024 byte length for database name and it 
1:         // will fail as expected
1:         url = TestConfiguration
1:                 .getCurrent().getJDBCUrl(dbUrl1025bytes);
1: 
1:         try {
1:         } catch (SQLException e) {
1:             	assertSQLState("08001", e); /* Check if it failed */
1:         }
1:     }
1:     
1:     /**
1:      * Will check if the JDBC driver has been loaded and load it if that is not
1:      * the case.
1:      * Any other exception messages than "No suitable driver" on the first
1:      * attempt to get the JDBC driver will result in an assertion failure.
1:      * 
1:      * @param url a valid connection URL for the desired JDBC driver
1:      * @throws SQLException if an unexpected exception is thrown
1:      */
1:     private void loadDriver(String url) throws SQLException {
1:         try {
1:             DriverManager.getDriver(url);
1:         } catch (SQLException e) {
1:             // getDriver() failed, JDBC driver probably not loaded.
1:             // Expecting SQLState 08001 and message "No suitable driver"...
1:             assertSQLState("Unexpected SQLState from getDriver().", "08001", e);
1:             assertEquals("Unexpected exception message from getDriver(), ",
1:                     "No suitable driver", e.getMessage());
1:             String driverClass = 
1:                     getTestConfiguration().getJDBCClient().getJDBCDriverName();
1:             println("Loading JDBC driver " + driverClass);
1:             // load the driver
1:             try {
0:                 Class.forName(driverClass).newInstance();
1:             } catch (ClassNotFoundException cnfe) {
1:                 throw new SQLException("Failed to load JDBC driver '" 
1:                         + driverClass + "', ClassNotFoundException: " 
1:                         + cnfe.getMessage());
1:             } catch (IllegalAccessException iae) {
1:                 throw new SQLException("Failed to load JDBC driver '" 
1:                         + driverClass + "', IllegalAccessException: " 
1:                         + iae.getMessage());
1:             } catch (InstantiationException ie) {
1:                 throw new SQLException("Failed to load JDBC driver '" 
1:                         + driverClass + "', InstantiationException: " 
1:                         + ie.getMessage());
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e18f54b
/////////////////////////////////////////////////////////////////////////
1:     private ArrayList<String> databasesForCleanup;
/////////////////////////////////////////////////////////////////////////
1:         databasesForCleanup = new ArrayList<String>();
commit:9b4a465
/////////////////////////////////////////////////////////////////////////
1:         xaconn.close();
1:         xaconn.close();
1:         xaconn.close();
/////////////////////////////////////////////////////////////////////////
1:         poolConn.close();
1:         poolConn.close();
1:         poolConn.close();
/////////////////////////////////////////////////////////////////////////
1:     public void tearDown() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         databasesForCleanup = null;
1: 
1:         super.tearDown();
commit:45e3ef0
/////////////////////////////////////////////////////////////////////////
0:         // Maximum length in bytes is 255. We subtract 14 to account for
0:         // ;create=true and ;shutdown=true
0:         int maxNameLength = 255 - 14;
/////////////////////////////////////////////////////////////////////////
0:             /* Append three more characters to make it fail */
0:             for (int i = 0; i < 3; i++) {
0:                 dbName.append(testCharacters[ch]);
1:             }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 fail("Database didn't shut down");
1:                 assertSQLState("08006", se);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:cd5b86c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testDriverManagerConnect() throws SQLException {        
/////////////////////////////////////////////////////////////////////////
1:     public void testXADSConnect() throws SQLException {        
/////////////////////////////////////////////////////////////////////////
commit:4b013e1
/////////////////////////////////////////////////////////////////////////
0:         // ensuring that we get a connection.
1:         getConnection();
1:         
0:         if (getSystemProperty("os.name").startsWith("Windows")) {            
0:             /* Skip with 1.4.2 jvms */
0:             if (getSystemProperty("java.version").startsWith("1.4.2")) return;
commit:6c42ee6
/////////////////////////////////////////////////////////////////////////
1:         /*
0:          * IBM's jvms on iseries have a bug that causes this fixture to fail
0:          * and leave behind a hard-to-remove file, see DERBY-4149.
0:          * Skip on that O.S.
1:          */
0:         if (getSystemProperty("os.name").startsWith("OS/400")) {
0:             return;
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:         /*
0:          * IBM's jvms on iseries have a bug that causes this fixture to fail
0:          * and leave behind a hard-to-remove file, see DERBY-4149.
0:          * Skip on that O.S.
1:          */
0:         if (getSystemProperty("os.name").startsWith("OS/400")) {
0:             return;
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
0:         /*
0:          * IBM's jvms on iseries have a bug that causes this fixture to fail
0:          * and leave behind a hard-to-remove file, see DERBY-4149.
0:          * Skip on that O.S.
1:          */
0:         if (getSystemProperty("os.name").startsWith("OS/400")) {
0:             return;
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
0:         /*
0:          * IBM's jvms on iseries have a bug that causes this fixture to fail
0:          * and leave behind a hard-to-remove file, see DERBY-4149.
0:          * Skip on that O.S.
1:          */
0:         if (getSystemProperty("os.name").startsWith("OS/400")) {
0:             return;
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:         
commit:65b2c92
/////////////////////////////////////////////////////////////////////////
0: import junit.framework.TestSuite;
/////////////////////////////////////////////////////////////////////////
1:         
0:         if (! isSunJVM()) {
0:             TestSuite suite = new TestSuite("InternationalConnectTest with non-sun/oracle jvm");
0:             // DERBY-4836 test fails on IBM VMs (on windows). 
0:             // Skip while research is happening..
0:             println("Test skipped for this VM, cf. DERBY-4836");
0:             return suite;            
1:         }
1:         
author:Tiago Aur¨¦lio Rodrigues Espinha
-------------------------------------------------------------------------------
commit:e5a97fe
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1:     /* Keep track of the databases created in the fixtures to cleanup in tearDown() */
0:     private ArrayList databasesForCleanup;
1:     
1:         
0:         databasesForCleanup = new ArrayList();
1: 
0:         /*
0:          * Sun's 1.4.2 JVM and IBM's JVM (any version) fail on Windows for this test
0:          * Thus, we skip it.
1:          * 
0:          * Read JIRA's DERBY-4836 for more information.
1:          */
0:         if (getSystemProperty("os.name").startsWith("Windows")) {
0:             /* Skip with IBM */
0:             if (isIBMJVM()) return;
1:             
0:             /* Skip with Sun 1.4.2 */
0:             if (isSunJVM() && getSystemProperty("java.version").startsWith("1.4.2")) return;
1:         }
/////////////////////////////////////////////////////////////////////////
0:             /* Add the database name for cleanup on tearDown() */
0:             databasesForCleanup.add(dbName.toString());
1:             
/////////////////////////////////////////////////////////////////////////
1:         
1:         /* Add the created database for cleanup by tearDown() */
1:         databasesForCleanup.add("\u4e10");
/////////////////////////////////////////////////////////////////////////
1:         
1:         /* Add the created database for cleanup by tearDown() */
1:         databasesForCleanup.add("\u4e10");
/////////////////////////////////////////////////////////////////////////
1:         
1:         /* Add the created database for cleanup by tearDown() */
1:         databasesForCleanup.add("\u4e10");
/////////////////////////////////////////////////////////////////////////
1:         
0:         /* Add the created database for cleanup by tearDown() */
0:         databasesForCleanup.add("\u4e10");
1:         /* Iterate through the databases for cleanup and delete them */
1:         for (int i=0; i<databasesForCleanup.size(); i++) {
1:             String shutdownUrl = TestConfiguration.getCurrent()
1:                                 .getJDBCUrl(databasesForCleanup.get(i) + ";shutdown=true");
1:             try {
1:                 DriverManager.getConnection(shutdownUrl);
1:             } catch (SQLException se) {
1:                 // ignore shutdown exception
1:             }
1:             removeDirectory(getSystemProperty("derby.system.home") +  File.separator + 
1:                     databasesForCleanup.get(i));
1:         
1:         /* Clear the array list as new fixtures will add other databases */
0:         databasesForCleanup.clear();
1:     public static Test suite() {        
commit:b005ffa
/////////////////////////////////////////////////////////////////////////
1: import java.io.UnsupportedEncodingException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testBoundaries() throws SQLException, UnsupportedEncodingException {
1:         if (usingEmbedded()) return; /* This test is only for Client/Server */
1:         
0:         /* Maximum length in bytes is 255. We subtract 12 for ;create=true  */
0:         int maxNameLength = 255 - 12;
1:         
1:         /**
0:          * \u0041 is the letter 'A' (1 byte)
0:          * \u00e7 is the letter 'c' with a cedilla (2 bytes)
0:          * \u4310 is a Chinese character (3 bytes)
0:          * \u1f030 is a domino tile (4 bytes)
1:          */
0:         String[] testCharacters = {"\u0041", "\u00e7", "\u4e10", "\u1f030"}; 
1:         
0:         for (int ch=0; ch<testCharacters.length; ch++) {
0:             StringBuffer dbName = new StringBuffer();
1:             
0:             /* max length in bytes divided by length of 1 chinese char */ 
0:             int maxChars = maxNameLength / testCharacters[ch].getBytes("UTF-8").length;
0:             for(int i=0; i<maxChars; i++) {
0:                 dbName.append(testCharacters[ch]);
1:             }
1:             
0:             /* This time it should work as we're right at the limit */
0:             String url = TestConfiguration
0:                     .getCurrent().getJDBCUrl(dbName.toString()+ ";create=true");
1:             
0:             Connection conn = DriverManager.getConnection(url);
1:             conn.close();
1:             
0:             /* Append one more character to make it fail */
0:             dbName.append(testCharacters[ch]);
1: 
0:             url = TestConfiguration
0:                     .getCurrent().getJDBCUrl(dbName.toString()+ ";create=true");
1: 
1:             try {
1:                 conn = DriverManager.getConnection(url);
1:                 assertTrue("Used more characters than possible in database name",
1:                         false);
0:             } catch (SQLException e) {
0:                 assertSQLState("08001", e); /* Check if it failed */
1:             }
1:         }
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1: 
1:         //Test Chinese database name
1:         url = TestConfiguration.getCurrent().getJDBCUrl("\u4e10;create=true");
1:         
1:         conn = DriverManager.getConnection(url);
1:         conn.close();           
1: 
1:         // Test Chinese user name
1:         url = TestConfiguration.getCurrent().getJDBCUrl("\u4e10;user=\u4e10");
1:         conn = DriverManager.getConnection(url);
1:         conn.close();
1: 
1:         // Test Chinese user name in parameter to getConnection
1:         url = TestConfiguration.getCurrent().getJDBCUrl("\u4e10");
1:         conn = DriverManager.getConnection(url,"\u4e10","pass");
1:         conn.close();
1: 
1:         // Test Chinese password in url
1:         url = TestConfiguration.getCurrent().getJDBCUrl("\u4e10;user=user;password=\u4e10");
1:         conn = DriverManager.getConnection(url);
1:         conn.close();
1: 
1:         // Test Chinese password in parameter to getConnection()
1:         url = TestConfiguration.getCurrent().getJDBCUrl("\u4e10");
1:         conn = DriverManager.getConnection(url,"\u4e10","\u4e10");
1:         conn.close();
/////////////////////////////////////////////////////////////////////////
1: 
1:         XAConnection xaconn = ds.getXAConnection();
1:         Connection conn = xaconn.getConnection();
1:         conn.close();
1:   
1:         J2EEDataSource.setBeanProperty(ds, "user", "\u4e10");
1:         xaconn = ds.getXAConnection();
1:         conn = xaconn.getConnection();
1:         conn.close();
1: 
1:         J2EEDataSource.setBeanProperty(ds, "password", "\u4e10");
1:         xaconn = ds.getXAConnection();
1:         conn = xaconn.getConnection();
1:         conn.close();
/////////////////////////////////////////////////////////////////////////
1: 
1:         PooledConnection poolConn = ds.getPooledConnection();
1:         Connection conn = poolConn.getConnection();
1:         conn.close();
1:  
1:         J2EEDataSource.setBeanProperty(ds, "user", "\u4e10");
1:         poolConn = ds.getPooledConnection();
1:         conn = poolConn.getConnection();
1:         conn.close();
1: 
1:         J2EEDataSource.setBeanProperty(ds, "password", "\u4e10");
1:         poolConn= ds.getPooledConnection();
1:         conn = poolConn.getConnection();
1:         conn.close();
commit:c7bf46c
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Regression test case for DERBY-4799. Attempting to connect to a
1:      * database that doesn't exist used to cause a protocol error between
1:      * the network server and the client. This only happened if the
1:      * database name was at least 18 characters and the name contained at
1:      * least one non-ascii character.
1:      */
1:     public void testFailureOnNonExistentDatabase() throws SQLException {
1:         String url = TestConfiguration.getCurrent().getJDBCUrl(
1:                 "abcdefghijklmnopq\u00E5");
0:         try {
1:             // This call used to fail with a protocol error with the
1:             // client driver. Check that it fails gracefully now.
1:             DriverManager.getConnection(url);
1:             fail(url + " should not exist");
1:         } catch (SQLException sqle) {
1:             // Embedded responds with XJ004 - database not found.
1:             // Client responds with 08004 - connection refused because
1:             // the database was not found.
1:             String expected = usingEmbedded() ? "XJ004" : "08004";
1:             assertSQLState(expected, sqle);
1:         }
1:     }
1: 
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6384512
/////////////////////////////////////////////////////////////////////////
0: /*
1:  
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.InternationalConnectTest
1:  
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1:  
1:       http://www.apache.org/licenses/LICENSE-2.0
1:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1:  
1:  */
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.io.File;
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.SQLException;
1: 
1: import javax.sql.ConnectionPoolDataSource;
1: import javax.sql.PooledConnection;
1: import javax.sql.XAConnection;
1: import javax.sql.XADataSource;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.J2EEDataSource;
0: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: public class InternationalConnectTest extends BaseJDBCTestCase {
1: 
1:     /**
1:      * Test connecting with multibyte characters in:
1:      * - Database name 
1:      * - User
1:      * - Password
1:      * 
1:      * Currently just throws an exception for client.
1:      * Works ok for embedded.
1:      * 
1:      * This test tests DriverManager, XADataSource and ConnectionPoolDataSource
1:      * and is not run with J2ME.  Simple DataSource is tested with 
1:      * InternationalConnectSimpleDSTest
1:      * 
1:      */
1:    
1:     /**
1:      * @param name
1:      */
1:     public InternationalConnectTest(String name) {
1:         super(name);
1:     
0:     }
1: 
1:     /**
1:      * Test Chinese character in database name, user and password, using 
1:      * DriverManager methods.
1:      * 
1:      * @throws SQLException
1:      */
0:     public void testDriverManagerConnect() throws SQLException {
1:         //get a connection to load the driver
0:         getConnection();
1:         Connection conn = null;
1:         String url = null;
0:         try {
0:             //Test Chinese database name
0:             url = TestConfiguration.getCurrent().getJDBCUrl("\u4e10;create=true");
1:             
0:             conn = DriverManager.getConnection(url);
0:             conn.close();
0:         } catch (SQLException se) {
0:             if (usingEmbedded())
0:                 throw se;
0:             else
0:                 assertSQLState("22005",se);
0:         }            
0:         try {
0:             // Test Chinese user name
0:             url = TestConfiguration.getCurrent().getJDBCUrl("\u4e10;user=\u4e10");
0:             conn = DriverManager.getConnection(url);
0:             conn.close();
0:         } catch (SQLException se ){
0:             if (usingEmbedded())
0:                 throw se;
0:             else
0:                 assertSQLState("22005",se);
0:         }
0:         try {
0:             // Test Chinese user name in parameter to getConnection
0:             url = TestConfiguration.getCurrent().getJDBCUrl("\u4e10");
0:             conn = DriverManager.getConnection(url,"\u4e10","pass");
0:             conn.close();
0:         } catch (SQLException se ) {
0:             if (usingEmbedded())
0:                 throw se;
0:             else
0:                 assertSQLState("22005",se);
0:         }
0:         try {
0:             // Test Chinese password in url
0:             url = TestConfiguration.getCurrent().getJDBCUrl("\u4e10;user=user;password=\u4e10");
0:             conn = DriverManager.getConnection(url);
0:             conn.close();
0:         } catch (SQLException se ){
0:             if (usingEmbedded())
0:                 throw se;
0:             else
0:                 assertSQLState("22005",se);
0:         }
0:         try {
0:             // Test Chinese password in parameter to getConnection()
0:             url = TestConfiguration.getCurrent().getJDBCUrl("\u4e10");
0:             conn = DriverManager.getConnection(url,"\u4e10","\u4e10");
0:             conn.close();
0:         } catch (SQLException se ) {
0:             if (usingEmbedded())
0:                 throw se;
0:             else
0:                 assertSQLState("22005",se);
0:         }
1:        
0:     }
1:     
1:     
1:     /**
1:      * Test XA Connection for chinese database name, user and password.
1:      * @throws SQLException
1:      */
0:     public void testXADSConnect() throws SQLException {
1:         // Test chinese database name.
1:         XADataSource ds = J2EEDataSource.getXADataSource();
1:         J2EEDataSource.setBeanProperty(ds, "databaseName", "\u4e10");
1:         J2EEDataSource.setBeanProperty(ds, "createDatabase", "create");        
0:         try {
0:             XAConnection xaconn = ds.getXAConnection();
0:             Connection conn = xaconn.getConnection();
0:             conn.close();
0:         } catch (SQLException se ) {
0:             if (usingEmbedded())
0:                 throw se;
0:             else
0:                 assertSQLState("22005",se);
0:         }   
1:         // Chinese user
0:         try {
0:             J2EEDataSource.setBeanProperty(ds, "user", "\u4e10");
0:             XAConnection xaconn = ds.getXAConnection();
0:             Connection conn = xaconn.getConnection();
0:             conn.close();
0:         } catch (SQLException se ) {
0:             if (usingEmbedded())
0:                 throw se;
0:             else
0:                 assertSQLState("22005",se);
0:         } 
1:         // Chinese password
0:         try {
0:             J2EEDataSource.setBeanProperty(ds, "password", "\u4e10");
0:             XAConnection xaconn = ds.getXAConnection();
0:             Connection conn = xaconn.getConnection();
0:             conn.close();
0:         } catch (SQLException se ) {
0:             if (usingEmbedded())
0:                 throw se;
0:             else
0:                 assertSQLState("22005",se);
0:         } 
0:     }
1:     
1:     
1:     /**
1:      * Test pooled connetion for chinese database name, user and password.
1:      * @throws SQLException
1:      */
1:     public void testCPDSConnect() throws SQLException {
1:         // Test chinese database name.
1:         ConnectionPoolDataSource ds = J2EEDataSource.getConnectionPoolDataSource();
1:         J2EEDataSource.setBeanProperty(ds, "databaseName", "\u4e10");
1:         J2EEDataSource.setBeanProperty(ds, "createDatabase", "create");        
0:         try {
0:             PooledConnection poolConn = ds.getPooledConnection();
0:             Connection conn = poolConn.getConnection();
0:             conn.close();
0:         } catch (SQLException se ) {
0:             if (usingEmbedded())
0:                 throw se;
0:             else
0:                 assertSQLState("22005",se);
0:         }   
1:         // Chinese user
0:         try {
0:             J2EEDataSource.setBeanProperty(ds, "user", "\u4e10");
0:             PooledConnection poolConn = ds.getPooledConnection();
0:             Connection conn = poolConn.getConnection();
0:             conn.close();
0:         } catch (SQLException se ) {
0:             if (usingEmbedded())
0:                 throw se;
0:             else
0:                 assertSQLState("22005",se);
0:         } 
1:         // Chinese password
0:         try {
0:             J2EEDataSource.setBeanProperty(ds, "password", "\u4e10");
0:             PooledConnection poolConn= ds.getPooledConnection();
0:             Connection conn = poolConn.getConnection();
0:             conn.close();
0:         } catch (SQLException se ) {
0:             if (usingEmbedded())
0:                 throw se;
0:             else
0:                 assertSQLState("22005",se);
0:         } 
0:     }
1:     
0:     public void tearDown() throws SQLException {
0:         String shutdownUrl = TestConfiguration.getCurrent().getJDBCUrl("\u4e10;shutdown=true");
0:         try {
0:             DriverManager.getConnection(shutdownUrl);
0:         } catch (SQLException se) {
0:             // ignore shutdown exception
0:         }
0:         removeDirectory(getSystemProperty("derby.system.home") +  File.separator + 
0:                 "\u4e10");
0:     }
1:     
0:     public static Test suite() {
1:         return TestConfiguration.defaultSuite(InternationalConnectTest.class);
0:     }
1:    
0: }
============================================================================