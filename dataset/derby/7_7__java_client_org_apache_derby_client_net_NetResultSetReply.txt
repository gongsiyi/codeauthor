1:33776ff: /*
31:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.net.NetResultSetReply
1:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:33776ff: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.net;
1:33776ff: 
1:33776ff: import org.apache.derby.client.am.DisconnectException;
1:69e3d06: import org.apache.derby.client.am.ClientResultSet;
1:33776ff: import org.apache.derby.client.am.ResultSetCallbackInterface;
1:70f7692: import org.apache.derby.client.am.SqlException;
1:f271471: import org.apache.derby.client.am.ClientMessageId;
1:f271471: 
1:f271471: import org.apache.derby.shared.common.reference.SQLState;
1:f271471: import org.apache.derby.shared.common.reference.MessageId;
1:33776ff: 
1:0326967: class NetResultSetReply extends NetStatementReply
1:0326967:     implements ResultSetReplyInterface {
1:0326967: 
1:0326967:     NetResultSetReply(NetAgent netAgent, int bufferSize) {
1:70f7692:         super(netAgent, bufferSize);
27:33776ff:     }
1:33776ff: 
1:70f7692:     //----------------------------- entry points ---------------------------------
1:33776ff: 
1:70f7692:     public void readFetch(ResultSetCallbackInterface resultSet) throws DisconnectException {
1:70f7692:         startSameIdChainParse();
1:70f7692:         parseCNTQRYreply(resultSet, true); // true means we expect row data
1:70f7692:         endOfSameIdChainData();
1:70f7692:     }
1:33776ff: 
1:70f7692:     public void readPositioningFetch(ResultSetCallbackInterface resultSet) throws DisconnectException {
1:70f7692:         startSameIdChainParse();
1:70f7692:         parseCNTQRYreply(resultSet, false);  // false means return data is not expected
1:70f7692:         endOfSameIdChainData();
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void readScrollableFetch(ResultSetCallbackInterface resultSet) throws DisconnectException {
1:70f7692:         startSameIdChainParse();
1:70f7692:         parseCNTQRYreply(resultSet, true);   // true means return data is expected
1:70f7692:         endOfSameIdChainData();
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void readCursorClose(ResultSetCallbackInterface resultSet) throws DisconnectException {
1:70f7692:         startSameIdChainParse();
1:70f7692:         parseCLSQRYreply(resultSet);
1:70f7692:         endOfSameIdChainData();
1:70f7692:     }
1:70f7692: 
1:70f7692:     //----------------------helper methods----------------------------------------
1:70f7692: 
1:70f7692:     //------------------parse reply for specific command--------------------------
1:70f7692: 
1:70f7692:     // These methods are "private protected", which is not a recognized java privilege,
1:70f7692:     // but means that these methods are private to this class and to subclasses,
1:70f7692:     // and should not be used as package-wide friendly methods.
1:70f7692: 
1:70f7692:     // Parse the reply for the Close Query Command.
1:70f7692:     // This method handles the parsing of all command replies and reply data
1:70f7692:     // for the clsqry command.
1:70f7692:     private void parseCLSQRYreply(ResultSetCallbackInterface resultSet) throws DisconnectException {
1:70f7692:         int peekCP = parseTypdefsOrMgrlvlovrs();
1:70f7692: 
1:70f7692:         if (peekCP == CodePoint.SQLCARD) {
1:70f7692:             NetSqlca netSqlca = parseSQLCARD(null);  //@f48553sxg - null means rowsetSqlca_ is null
1:70f7692:             // Set the cursor state if null SQLCA or sqlcode is equal to 0.
1:70f7692:             resultSet.completeSqlca(netSqlca);
1:70f7692:         } else {
1:70f7692:             parseCloseError(resultSet);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Parse the reply for the Continue Query Command.
1:70f7692:     // This method handles the parsing of all command replies and reply data for the cntqry command.
1:70f7692:     // If doCopyQrydta==false, then there is no data, and we're only parsing out the sqlca to get the row count.
1:70f7692:     private void parseCNTQRYreply(ResultSetCallbackInterface resultSetI,
1:70f7692:                                   boolean doCopyQrydta) throws DisconnectException {
1:70f7692:         boolean found = false;
1:70f7692:         int peekCP = peekCodePoint();
3:33776ff:         if (peekCP == CodePoint.RDBUPDRM) {
1:70f7692:             found = true;
1:70f7692:             parseRDBUPDRM();
1:c6c4d4d:             peekCP = peekCodePoint();
1:33776ff:         }
1:33776ff: 
1:70f7692:         if (peekCP == CodePoint.QRYDTA) {
1:70f7692:             found = true;
1:70f7692:             if (!doCopyQrydta) {
1:70f7692:                 parseLengthAndMatchCodePoint(CodePoint.QRYDTA);
1:70f7692:                 //we don't need to copy QRYDTA since there is no data
1:70f7692:                 if (longValueForDecryption_ != null) {
1:70f7692:                     longValueForDecryption_ = null;
1:70f7692:                 }
1:70f7692:                 if (longBufferForDecryption_ != null) {
1:70f7692:                     longBufferForDecryption_ = null;
1:70f7692:                 }
1:70f7692: 
1:70f7692:                 int ddmLength = getDdmLength();
1:70f7692:                 ensureBLayerDataInBuffer(ddmLength);
1:69e3d06:                 ((ClientResultSet) resultSetI).expandRowsetSqlca();
1:69e3d06:                 NetSqlca sqlca = parseSQLCARDrow(
1:69e3d06:                     ((ClientResultSet) resultSetI).rowsetSqlca_);
1:70f7692:                 int daNullIndicator = readFastByte();
1:70f7692:                 adjustLengths(getDdmLength());
1:70f7692:                 // define event interface and use the event method
1:70f7692:                 // only get the rowCount_ if sqlca is not null and rowCount_ is unknown
1:70f7692:                 if (sqlca != null && sqlca.containsSqlcax()) {
1:69e3d06:                     ((ClientResultSet)resultSetI).setRowCountEvent(
1:69e3d06:                         sqlca.getRowCount());
1:70f7692:                 }
1:70f7692: 
1:70f7692:                 peekCP = peekCodePoint();
1:4c9b831:                 if (peekCP == CodePoint.SQLCARD) {
1:4c9b831:                     NetSqlca netSqlca = parseSQLCARD(((ClientResultSet) resultSetI).rowsetSqlca_);
1:4c9b831:                     resultSetI.completeSqlca(netSqlca);
1:4c9b831:                 }
1:70f7692:                 if (peekCP == CodePoint.RDBUPDRM) {
1:70f7692:                     parseRDBUPDRM();
1:70f7692:                     peekCP = peekCodePoint();
1:70f7692:                 }
1:c6c4d4d:                 if (peekCP == CodePoint.PBSD) {
1:c6c4d4d:                     parsePBSD();
1:c6c4d4d:                 }
1:70f7692:                 return;
1:70f7692:             }
1:70f7692:             do {
1:70f7692:                 parseQRYDTA((NetResultSet) resultSetI);
1:70f7692:                 peekCP = peekCodePoint();
1:70f7692:             } while (peekCP == CodePoint.QRYDTA);
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (peekCP == CodePoint.EXTDTA) {
1:70f7692:             found = true;
1:70f7692:             do {
1:69e3d06:                 copyEXTDTA((NetCursor) ((ClientResultSet) resultSetI).cursor_);
1:70f7692:                 if (longBufferForDecryption_ != null) {//encrypted EXTDTA
1:70f7692:                     buffer_ = longBufferForDecryption_;
1:70f7692:                     pos_ = longPosForDecryption_;
1:70f7692:                     if (longBufferForDecryption_ != null && count_ > longBufferForDecryption_.length) {
1:70f7692:                         count_ = longBufferForDecryption_.length;
1:70f7692:                     }
1:70f7692:                 }
1:70f7692: 
1:70f7692:                 peekCP = peekCodePoint();
1:70f7692:             } while (peekCP == CodePoint.EXTDTA);
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (peekCP == CodePoint.SQLCARD) {
1:70f7692:             found = true;
1:69e3d06:             ((ClientResultSet) resultSetI).expandRowsetSqlca();
1:69e3d06:             NetSqlca netSqlca =
1:69e3d06:                 parseSQLCARD(((ClientResultSet)resultSetI).rowsetSqlca_);
1:70f7692:             // for an atomic operation, the SQLCA contains the sqlcode for the first (statement
1:70f7692:             // terminating)error, the last warning, or zero.  all multi-row fetch operatons are
1:70f7692:             // atomic.  (the only operation that is not atomic is multi-row insert).
1:69e3d06:             if (((ClientResultSet)resultSetI).sensitivity_ !=
1:69e3d06:                 ClientResultSet.sensitivity_sensitive_dynamic__) {
1:69e3d06: 
1:70f7692:                 if (netSqlca != null && netSqlca.containsSqlcax() && netSqlca.getRowsetRowCount() == 0) {
1:69e3d06:                     ((ClientResultSet)resultSetI).setRowCountEvent(
1:69e3d06:                         netSqlca.getRowCount());
1:70f7692:                 }
1:70f7692:             }
1:70f7692:             resultSetI.completeSqlca(netSqlca);
1:70f7692:             peekCP = peekCodePoint();
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (peekCP == CodePoint.ENDQRYRM) {
1:70f7692:             found = true;
1:70f7692:             parseEndQuery(resultSetI);
1:70f7692:             peekCP = peekCodePoint();
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (peekCP == CodePoint.RDBUPDRM) {
1:70f7692:             found = true;
1:70f7692:             parseRDBUPDRM();
1:70f7692:             peekCP = peekCodePoint();
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (!found) {
1:70f7692:             parseFetchError(resultSetI);
1:c6c4d4d:         }
1:c6c4d4d: 
1:c6c4d4d:         if (peekCP == CodePoint.PBSD) {
1:c6c4d4d:             parsePBSD();
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (longBufferForDecryption_ != null) {
1:70f7692:             // Not a good idea to create a new buffer_
1:70f7692:             buffer_ = new byte[DEFAULT_BUFFER_SIZE];
1:70f7692:             longBufferForDecryption_ = null;
1:70f7692:         }
1:33776ff:     }
1:33776ff: 
1:0326967:     private void parseCloseError(ResultSetCallbackInterface resultSetI)
1:0326967:             throws DisconnectException {
1:0326967: 
1:70f7692:         int peekCP = peekCodePoint();
1:70f7692:         switch (peekCP) {
1:70f7692:         case CodePoint.ABNUOWRM:
1:70f7692:             {
1:ad94e28:                 //passing the ResultSetCallbackInterface implementation will
1:ad94e28:                 //help in retrieving the the UnitOfWorkListener that needs to
1:ad94e28:                 //be rolled back 
1:ad94e28:                 NetSqlca sqlca = parseAbnormalEndUow(resultSetI);
1:70f7692:                 resultSetI.completeSqlca(sqlca);
1:70f7692:                 break;
1:70f7692:             }
1:70f7692:         case CodePoint.CMDCHKRM:
1:70f7692:             parseCMDCHKRM();
1:70f7692:             break;
1:70f7692:         case CodePoint.QRYNOPRM:
1:70f7692:             parseQRYNOPRM(resultSetI);
1:70f7692:             break;
1:70f7692:         case CodePoint.RDBNACRM:
1:70f7692:             parseRDBNACRM();
1:70f7692:             break;
1:70f7692:         default:
1:70f7692:             parseCommonError(peekCP);
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:0326967:     private void parseFetchError(ResultSetCallbackInterface resultSetI)
1:0326967:             throws DisconnectException {
1:0326967: 
1:70f7692:         int peekCP = peekCodePoint();
1:70f7692:         switch (peekCP) {
1:70f7692:         case CodePoint.ABNUOWRM:
1:70f7692:             {
1:ad94e28:                 //passing the ResultSetCallbackInterface implementation will
1:ad94e28:                 //help in retrieving the the UnitOfWorkListener that needs to
1:ad94e28:                 //be rolled back 
1:ad94e28:                 NetSqlca sqlca = parseAbnormalEndUow(resultSetI);
1:70f7692:                 resultSetI.completeSqlca(sqlca);
1:70f7692:                 break;
1:33776ff:             }
1:70f7692:         case CodePoint.CMDCHKRM:
1:70f7692:             parseCMDCHKRM();
1:70f7692:             break;
1:70f7692:         case CodePoint.CMDNSPRM:
1:70f7692:             parseCMDNSPRM();
1:70f7692:             break;
1:70f7692:         case CodePoint.QRYNOPRM:
1:70f7692:             parseQRYNOPRM(resultSetI);
1:70f7692:             break;
1:70f7692:         case CodePoint.RDBNACRM:
1:70f7692:             parseRDBNACRM();
1:70f7692:             break;
1:70f7692:         default:
1:70f7692:             parseCommonError(peekCP);
1:70f7692:         }
1:33776ff:     }
1:33776ff: 
1:70f7692:     //-----------------------------parse DDM Reply Messages-----------------------
1:70f7692: 
1:70f7692:     // Query Not Opened Reply Message is issued if a CNTQRY or CLSQRY
1:70f7692:     // command is issued for a query that is not open.  A previous
1:70f7692:     // ENDQRYRM, ENDUOWRM, or ABNUOWRM reply message might have
1:70f7692:     // terminated the command.
1:70f7692:     // PROTOCOL architects the SQLSTATE value depending on SVRCOD
1:70f7692:     // SVRCOD 4 -> SQLSTATE is 24501
1:70f7692:     // SVRCOD 8 -> SQLSTATE of 58008 or 58009
1:70f7692:     //
1:70f7692:     // if SVRCOD is 4 then SQLSTATE 24501, SQLCODE -501
1:70f7692:     // else SQLSTATE 58009, SQLCODE -30020
1:70f7692:     //
1:70f7692:     // Messages
1:70f7692:     // SQLSTATE : 24501
1:70f7692:     //     The identified cursor is not open.
1:70f7692:     //     SQLCODE : -501
1:70f7692:     //     The cursor specified in a FETCH or CLOSE statement is not open.
1:70f7692:     //     The statement cannot be processed.
1:70f7692:     // SQLSTATE : 58009
1:70f7692:     //     Execution failed due to a distribution protocol error that caused deallocation of the conversation.
1:70f7692:     //     SQLCODE : -30020
1:70f7692:     //     Execution failed because of a Distributed Protocol
1:70f7692:     //         Error that will affect the successful execution of subsequent
1:70f7692:     //         commands and SQL statements: Reason Code <reason-code>.
1:70f7692:     //     Some possible reason codes include:
1:70f7692:     //     121C Indicates that the user is not authorized to perform the requested command.
1:70f7692:     //     1232 The command could not be completed because of a permanent error.
1:70f7692:     //         In most cases, the server will be in the process of an abend.
1:70f7692:     //     220A The target server has received an invalid data description.
1:70f7692:     //         If a user SQLDA is specified, ensure that the fields are
1:70f7692:     //         initialized correctly. Also, ensure that the length does not exceed
1:70f7692:     //         the maximum allowed length for the data type being used.
1:70f7692:     //
1:70f7692:     //     The command or statement cannot be processed.  The current
1:70f7692:     //         transaction is rolled back and the application is disconnected
1:70f7692:     //         from the remote database.
1:70f7692:     //
1:70f7692:     // Returned from Server:
1:70f7692:     // SVRCOD - required  (4 - WARNING, 8 - ERROR)
1:70f7692:     // RDBNAM - required
1:70f7692:     // PKGNAMCSN - required
1:70f7692:     //
1:70f7692:     private void parseQRYNOPRM(ResultSetCallbackInterface resultSet) throws DisconnectException {
1:70f7692:         boolean svrcodReceived = false;
1:70f7692:         int svrcod = CodePoint.SVRCOD_INFO;
1:70f7692:         boolean rdbnamReceived = false;
1:70f7692:         String rdbnam = null;
1:70f7692:         boolean pkgnamcsnReceived = false;
1:70f7692:         Object pkgnamcsn = null;
1:70f7692: 
1:70f7692:         parseLengthAndMatchCodePoint(CodePoint.QRYNOPRM);
1:70f7692:         pushLengthOnCollectionStack();
1:70f7692:         int peekCP = peekCodePoint();
1:70f7692: 
1:70f7692:         while (peekCP != Reply.END_OF_COLLECTION) {
1:70f7692: 
1:70f7692:             boolean foundInPass = false;
1:70f7692: 
1:70f7692:             if (peekCP == CodePoint.SVRCOD) {
1:70f7692:                 foundInPass = true;
1:70f7692:                 svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);
1:70f7692:                 svrcod = parseSVRCOD(CodePoint.SVRCOD_WARNING, CodePoint.SVRCOD_ERROR);
1:70f7692:                 peekCP = peekCodePoint();
1:70f7692:             }
1:70f7692: 
1:70f7692:             if (peekCP == CodePoint.RDBNAM) {
1:70f7692:                 foundInPass = true;
1:70f7692:                 rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);
1:70f7692:                 rdbnam = parseRDBNAM(true);
1:70f7692:                 peekCP = peekCodePoint();
1:70f7692:             }
1:70f7692: 
1:70f7692:             if (peekCP == CodePoint.PKGNAMCSN) {
1:70f7692:                 foundInPass = true;
1:70f7692:                 pkgnamcsnReceived = checkAndGetReceivedFlag(pkgnamcsnReceived);
1:70f7692:                 pkgnamcsn = parsePKGNAMCSN(true);
1:70f7692:                 peekCP = peekCodePoint();
1:70f7692:             }
1:70f7692: 
1:70f7692:             if (!foundInPass) {
1:70f7692:                 doPrmnsprmSemantics(peekCP);
1:70f7692:             }
1:70f7692: 
1:70f7692:         }
1:70f7692:         popCollectionStack();
1:70f7692:         checkRequiredObjects(svrcodReceived, rdbnamReceived, pkgnamcsnReceived);
1:70f7692: 
1:70f7692:         // move into a method
1:70f7692:         netAgent_.setSvrcod(svrcod);
1:70f7692:         if (svrcod == CodePoint.SVRCOD_WARNING) {
1:70f7692:             netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
1:f271471:                 new ClientMessageId(SQLState.DRDA_CURSOR_NOT_OPEN)));
1:70f7692:         } else {
1:70f7692:             agent_.accumulateChainBreakingReadExceptionAndThrow(new DisconnectException(agent_,
1:f271471:                 new ClientMessageId(SQLState.DRDA_CONNECTION_TERMINATED),
1:f271471:                     SqlException.getMessageUtil().
1:f271471:                     getTextMessage(MessageId.CONN_CURSOR_NOT_OPEN)));
1:70f7692:         }
1:33776ff:     }
1:33776ff: }
1:33776ff: 
============================================================================
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:4c9b831
/////////////////////////////////////////////////////////////////////////
1:                 if (peekCP == CodePoint.SQLCARD) {
1:                     NetSqlca netSqlca = parseSQLCARD(((ClientResultSet) resultSetI).rowsetSqlca_);
1:                     resultSetI.completeSqlca(netSqlca);
1:                 }
commit:c6c4d4d
/////////////////////////////////////////////////////////////////////////
1:                 if (peekCP == CodePoint.PBSD) {
1:                     parsePBSD();
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             peekCP = peekCodePoint();
1:         if (peekCP == CodePoint.PBSD) {
1:             parsePBSD();
1:         }
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0326967
/////////////////////////////////////////////////////////////////////////
1: class NetResultSetReply extends NetStatementReply
1:     implements ResultSetReplyInterface {
1: 
1:     NetResultSetReply(NetAgent netAgent, int bufferSize) {
/////////////////////////////////////////////////////////////////////////
1:     private void parseCloseError(ResultSetCallbackInterface resultSetI)
1:             throws DisconnectException {
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void parseFetchError(ResultSetCallbackInterface resultSetI)
1:             throws DisconnectException {
1: 
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.ClientResultSet;
/////////////////////////////////////////////////////////////////////////
1:                 ((ClientResultSet) resultSetI).expandRowsetSqlca();
1:                 NetSqlca sqlca = parseSQLCARDrow(
1:                     ((ClientResultSet) resultSetI).rowsetSqlca_);
1:                     ((ClientResultSet)resultSetI).setRowCountEvent(
1:                         sqlca.getRowCount());
/////////////////////////////////////////////////////////////////////////
1:                 copyEXTDTA((NetCursor) ((ClientResultSet) resultSetI).cursor_);
/////////////////////////////////////////////////////////////////////////
1:             ((ClientResultSet) resultSetI).expandRowsetSqlca();
1:             NetSqlca netSqlca =
1:                 parseSQLCARD(((ClientResultSet)resultSetI).rowsetSqlca_);
1:             if (((ClientResultSet)resultSetI).sensitivity_ !=
1:                 ClientResultSet.sensitivity_sensitive_dynamic__) {
1: 
1:                     ((ClientResultSet)resultSetI).setRowCountEvent(
1:                         netSqlca.getRowCount());
commit:95049cf
/////////////////////////////////////////////////////////////////////////
0:                     ((ResultSet) resultSetI).setRowCountEvent(sqlca.getRowCount());
/////////////////////////////////////////////////////////////////////////
0:                     ((ResultSet) resultSetI).setRowCountEvent(netSqlca.getRowCount());
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ad94e28
/////////////////////////////////////////////////////////////////////////
1:                 //passing the ResultSetCallbackInterface implementation will
1:                 //help in retrieving the the UnitOfWorkListener that needs to
1:                 //be rolled back 
1:                 NetSqlca sqlca = parseAbnormalEndUow(resultSetI);
/////////////////////////////////////////////////////////////////////////
1:                 //passing the ResultSetCallbackInterface implementation will
1:                 //help in retrieving the the UnitOfWorkListener that needs to
1:                 //be rolled back 
1:                 NetSqlca sqlca = parseAbnormalEndUow(resultSetI);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f271471
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.ClientMessageId;
1: 
1: import org.apache.derby.shared.common.reference.SQLState;
1: import org.apache.derby.shared.common.reference.MessageId;
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.DRDA_CURSOR_NOT_OPEN)));
1:                 new ClientMessageId(SQLState.DRDA_CONNECTION_TERMINATED),
1:                     SqlException.getMessageUtil().
1:                     getTextMessage(MessageId.CONN_CURSOR_NOT_OPEN)));
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.SqlException;
0: import org.apache.derby.client.am.SqlState;
0: public class NetResultSetReply extends NetStatementReply implements ResultSetReplyInterface {
0:     public NetResultSetReply(NetAgent netAgent, int bufferSize) {
1:         super(netAgent, bufferSize);
1:     //----------------------------- entry points ---------------------------------
1:     public void readFetch(ResultSetCallbackInterface resultSet) throws DisconnectException {
1:         startSameIdChainParse();
1:         parseCNTQRYreply(resultSet, true); // true means we expect row data
1:         endOfSameIdChainData();
1:     }
1:     public void readPositioningFetch(ResultSetCallbackInterface resultSet) throws DisconnectException {
1:         startSameIdChainParse();
1:         parseCNTQRYreply(resultSet, false);  // false means return data is not expected
1:         endOfSameIdChainData();
1:     }
1: 
1:     public void readScrollableFetch(ResultSetCallbackInterface resultSet) throws DisconnectException {
1:         startSameIdChainParse();
1:         parseCNTQRYreply(resultSet, true);   // true means return data is expected
1:         endOfSameIdChainData();
1:     }
1: 
1:     public void readCursorClose(ResultSetCallbackInterface resultSet) throws DisconnectException {
1:         startSameIdChainParse();
1:         parseCLSQRYreply(resultSet);
1:         endOfSameIdChainData();
1:     }
1: 
1:     //----------------------helper methods----------------------------------------
1: 
1:     //------------------parse reply for specific command--------------------------
1: 
1:     // These methods are "private protected", which is not a recognized java privilege,
1:     // but means that these methods are private to this class and to subclasses,
1:     // and should not be used as package-wide friendly methods.
1: 
1:     // Parse the reply for the Close Query Command.
1:     // This method handles the parsing of all command replies and reply data
1:     // for the clsqry command.
1:     private void parseCLSQRYreply(ResultSetCallbackInterface resultSet) throws DisconnectException {
1:         int peekCP = parseTypdefsOrMgrlvlovrs();
1: 
1:         if (peekCP == CodePoint.SQLCARD) {
1:             NetSqlca netSqlca = parseSQLCARD(null);  //@f48553sxg - null means rowsetSqlca_ is null
1:             // Set the cursor state if null SQLCA or sqlcode is equal to 0.
1:             resultSet.completeSqlca(netSqlca);
1:         } else {
1:             parseCloseError(resultSet);
1:         }
1:     }
1: 
1:     // Parse the reply for the Continue Query Command.
1:     // This method handles the parsing of all command replies and reply data for the cntqry command.
1:     // If doCopyQrydta==false, then there is no data, and we're only parsing out the sqlca to get the row count.
1:     private void parseCNTQRYreply(ResultSetCallbackInterface resultSetI,
1:                                   boolean doCopyQrydta) throws DisconnectException {
1:         boolean found = false;
1:         int peekCP = peekCodePoint();
1:             found = true;
1:             parseRDBUPDRM();
1:             peekCP = peekCodePoint();
1:         if (peekCP == CodePoint.QRYDTA) {
1:             found = true;
1:             if (!doCopyQrydta) {
1:                 parseLengthAndMatchCodePoint(CodePoint.QRYDTA);
1:                 //we don't need to copy QRYDTA since there is no data
1:                 if (longValueForDecryption_ != null) {
1:                     longValueForDecryption_ = null;
1:                 }
1:                 if (longBufferForDecryption_ != null) {
1:                     longBufferForDecryption_ = null;
1:                 }
1: 
1:                 int ddmLength = getDdmLength();
1:                 ensureBLayerDataInBuffer(ddmLength);
0:                 ((ResultSet) resultSetI).expandRowsetSqlca();
0:                 NetSqlca sqlca = parseSQLCARDrow(((ResultSet) resultSetI).rowsetSqlca_);
1:                 int daNullIndicator = readFastByte();
1:                 adjustLengths(getDdmLength());
1:                 // define event interface and use the event method
1:                 // only get the rowCount_ if sqlca is not null and rowCount_ is unknown
1:                 if (sqlca != null && sqlca.containsSqlcax()) {
0:                     ((ResultSet) resultSetI).setRowCountEvent(sqlca.getRowCount(netAgent_.targetTypdef_));
1:                 }
1: 
1:                 peekCP = peekCodePoint();
1:                 if (peekCP == CodePoint.RDBUPDRM) {
1:                     parseRDBUPDRM();
1:                     peekCP = peekCodePoint();
1:                 }
1:                 return;
1:             }
1:             do {
1:                 parseQRYDTA((NetResultSet) resultSetI);
1:                 peekCP = peekCodePoint();
1:             } while (peekCP == CodePoint.QRYDTA);
1:         }
1: 
1:         if (peekCP == CodePoint.EXTDTA) {
1:             found = true;
1:             do {
0:                 copyEXTDTA((NetCursor) ((ResultSet) resultSetI).cursor_);
1:                 if (longBufferForDecryption_ != null) {//encrypted EXTDTA
1:                     buffer_ = longBufferForDecryption_;
1:                     pos_ = longPosForDecryption_;
1:                     if (longBufferForDecryption_ != null && count_ > longBufferForDecryption_.length) {
1:                         count_ = longBufferForDecryption_.length;
1:                     }
1:                 }
1: 
1:                 peekCP = peekCodePoint();
1:             } while (peekCP == CodePoint.EXTDTA);
1:         }
1: 
1:         if (peekCP == CodePoint.SQLCARD) {
1:             found = true;
0:             ((ResultSet) resultSetI).expandRowsetSqlca();
0:             NetSqlca netSqlca = parseSQLCARD(((ResultSet) resultSetI).rowsetSqlca_);
1:             // for an atomic operation, the SQLCA contains the sqlcode for the first (statement
1:             // terminating)error, the last warning, or zero.  all multi-row fetch operatons are
1:             // atomic.  (the only operation that is not atomic is multi-row insert).
0:             if (((ResultSet) resultSetI).sensitivity_ != ResultSet.sensitivity_sensitive_dynamic__) {
1:                 if (netSqlca != null && netSqlca.containsSqlcax() && netSqlca.getRowsetRowCount() == 0) {
0:                     ((ResultSet) resultSetI).setRowCountEvent(netSqlca.getRowCount(netAgent_.targetTypdef_));
1:                 }
1:             }
1:             resultSetI.completeSqlca(netSqlca);
1:             peekCP = peekCodePoint();
1:         }
1: 
1:         if (peekCP == CodePoint.ENDQRYRM) {
1:             found = true;
1:             parseEndQuery(resultSetI);
1:             peekCP = peekCodePoint();
1:         }
1: 
1:         if (peekCP == CodePoint.RDBUPDRM) {
1:             found = true;
1:             parseRDBUPDRM();
1:         }
1: 
1:         if (!found) {
1:             parseFetchError(resultSetI);
1:         }
1: 
1:         if (longBufferForDecryption_ != null) {
1:             // Not a good idea to create a new buffer_
1:             buffer_ = new byte[DEFAULT_BUFFER_SIZE];
1:             longBufferForDecryption_ = null;
1:         }
0:     void parseCloseError(ResultSetCallbackInterface resultSetI) throws DisconnectException {
1:         int peekCP = peekCodePoint();
1:         switch (peekCP) {
1:         case CodePoint.ABNUOWRM:
1:             {
0:                 NetSqlca sqlca = parseAbnormalEndUow(resultSetI.getConnectionCallbackInterface());
1:                 resultSetI.completeSqlca(sqlca);
1:                 break;
1:             }
1:         case CodePoint.CMDCHKRM:
1:             parseCMDCHKRM();
1:             break;
1:         case CodePoint.QRYNOPRM:
1:             parseQRYNOPRM(resultSetI);
1:             break;
1:         case CodePoint.RDBNACRM:
1:             parseRDBNACRM();
1:             break;
1:         default:
1:             parseCommonError(peekCP);
1:         }
0:     void parseFetchError(ResultSetCallbackInterface resultSetI) throws DisconnectException {
1:         int peekCP = peekCodePoint();
1:         switch (peekCP) {
1:         case CodePoint.ABNUOWRM:
1:             {
0:                 NetSqlca sqlca = parseAbnormalEndUow(resultSetI.getConnectionCallbackInterface());
1:                 resultSetI.completeSqlca(sqlca);
1:                 break;
1:             }
1:         case CodePoint.CMDCHKRM:
1:             parseCMDCHKRM();
1:             break;
1:         case CodePoint.CMDNSPRM:
1:             parseCMDNSPRM();
1:             break;
1:         case CodePoint.QRYNOPRM:
1:             parseQRYNOPRM(resultSetI);
1:             break;
1:         case CodePoint.RDBNACRM:
1:             parseRDBNACRM();
1:             break;
1:         default:
1:             parseCommonError(peekCP);
1:         }
1:     //-----------------------------parse DDM Reply Messages-----------------------
1: 
1:     // Query Not Opened Reply Message is issued if a CNTQRY or CLSQRY
1:     // command is issued for a query that is not open.  A previous
1:     // ENDQRYRM, ENDUOWRM, or ABNUOWRM reply message might have
1:     // terminated the command.
1:     // PROTOCOL architects the SQLSTATE value depending on SVRCOD
1:     // SVRCOD 4 -> SQLSTATE is 24501
1:     // SVRCOD 8 -> SQLSTATE of 58008 or 58009
1:     //
1:     // if SVRCOD is 4 then SQLSTATE 24501, SQLCODE -501
1:     // else SQLSTATE 58009, SQLCODE -30020
1:     //
1:     // Messages
1:     // SQLSTATE : 24501
1:     //     The identified cursor is not open.
1:     //     SQLCODE : -501
1:     //     The cursor specified in a FETCH or CLOSE statement is not open.
1:     //     The statement cannot be processed.
1:     // SQLSTATE : 58009
1:     //     Execution failed due to a distribution protocol error that caused deallocation of the conversation.
1:     //     SQLCODE : -30020
1:     //     Execution failed because of a Distributed Protocol
1:     //         Error that will affect the successful execution of subsequent
1:     //         commands and SQL statements: Reason Code <reason-code>.
1:     //     Some possible reason codes include:
1:     //     121C Indicates that the user is not authorized to perform the requested command.
1:     //     1232 The command could not be completed because of a permanent error.
1:     //         In most cases, the server will be in the process of an abend.
1:     //     220A The target server has received an invalid data description.
1:     //         If a user SQLDA is specified, ensure that the fields are
1:     //         initialized correctly. Also, ensure that the length does not exceed
1:     //         the maximum allowed length for the data type being used.
1:     //
1:     //     The command or statement cannot be processed.  The current
1:     //         transaction is rolled back and the application is disconnected
1:     //         from the remote database.
1:     //
1:     // Returned from Server:
1:     // SVRCOD - required  (4 - WARNING, 8 - ERROR)
1:     // RDBNAM - required
1:     // PKGNAMCSN - required
1:     //
1:     private void parseQRYNOPRM(ResultSetCallbackInterface resultSet) throws DisconnectException {
1:         boolean svrcodReceived = false;
1:         int svrcod = CodePoint.SVRCOD_INFO;
1:         boolean rdbnamReceived = false;
1:         String rdbnam = null;
1:         boolean pkgnamcsnReceived = false;
1:         Object pkgnamcsn = null;
1: 
1:         parseLengthAndMatchCodePoint(CodePoint.QRYNOPRM);
1:         pushLengthOnCollectionStack();
1:         int peekCP = peekCodePoint();
1: 
1:         while (peekCP != Reply.END_OF_COLLECTION) {
1: 
1:             boolean foundInPass = false;
1: 
1:             if (peekCP == CodePoint.SVRCOD) {
1:                 foundInPass = true;
1:                 svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);
1:                 svrcod = parseSVRCOD(CodePoint.SVRCOD_WARNING, CodePoint.SVRCOD_ERROR);
1:                 peekCP = peekCodePoint();
1:             }
1: 
1:             if (peekCP == CodePoint.RDBNAM) {
1:                 foundInPass = true;
1:                 rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);
1:                 rdbnam = parseRDBNAM(true);
1:                 peekCP = peekCodePoint();
1:             }
1: 
1:             if (peekCP == CodePoint.PKGNAMCSN) {
1:                 foundInPass = true;
1:                 pkgnamcsnReceived = checkAndGetReceivedFlag(pkgnamcsnReceived);
1:                 pkgnamcsn = parsePKGNAMCSN(true);
1:                 peekCP = peekCodePoint();
1:             }
1: 
1:             if (!foundInPass) {
1:                 doPrmnsprmSemantics(peekCP);
1:             }
1: 
1:         }
1:         popCollectionStack();
1:         checkRequiredObjects(svrcodReceived, rdbnamReceived, pkgnamcsnReceived);
1: 
1:         // move into a method
1:         netAgent_.setSvrcod(svrcod);
1:         if (svrcod == CodePoint.SVRCOD_WARNING) {
1:             netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0:                     "The identified cursor is not open.",
0:                     SqlState._24501));
1:         } else {
1:             agent_.accumulateChainBreakingReadExceptionAndThrow(new DisconnectException(agent_,
0:                     "Execution failed due to a distribution protocol error that " +
0:                     "caused deallocation of the conversation.  " +
0:                     "The identified cursor is not open.",
0:                     SqlState._58009));
1:         }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.net.NetResultSetReply
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.client.net;
1: 
0: import org.apache.derby.client.am.SqlState;
1: 
0: import org.apache.derby.client.am.SqlException;
1: import org.apache.derby.client.am.DisconnectException;
1: 
0: import org.apache.derby.client.am.ResultSet;
1: import org.apache.derby.client.am.ResultSetCallbackInterface;
1: 
0: public class NetResultSetReply extends NetStatementReply implements ResultSetReplyInterface
0: {
0:   public NetResultSetReply (NetAgent netAgent, int bufferSize)
0:   {
0:     super (netAgent, bufferSize);
1:   }
1: 
0:   //----------------------------- entry points ---------------------------------
1: 
0:   public void readFetch (ResultSetCallbackInterface resultSet) throws DisconnectException
0:   {
0:     startSameIdChainParse();
0:     parseCNTQRYreply (resultSet, true); // true means we expect row data
0:     endOfSameIdChainData();
1:   }
1: 
0:   public void readPositioningFetch (ResultSetCallbackInterface resultSet) throws DisconnectException
0:   {
0:     startSameIdChainParse();
0:     parseCNTQRYreply (resultSet, false);  // false means return data is not expected
0:     endOfSameIdChainData();
1:   }
1: 
0:   public void readScrollableFetch (ResultSetCallbackInterface resultSet) throws DisconnectException
0:   {
0:     startSameIdChainParse();
0:     parseCNTQRYreply (resultSet, true);   // true means return data is expected
0:     endOfSameIdChainData();
1:   }
1: 
0:   public void readCursorClose (ResultSetCallbackInterface resultSet) throws DisconnectException
0:   {
0:     startSameIdChainParse();
0:     parseCLSQRYreply (resultSet);
0:     endOfSameIdChainData();
1:   }
1: 
0:   //----------------------helper methods----------------------------------------
1: 
0:   //------------------parse reply for specific command--------------------------
1: 
0:   // These methods are "private protected", which is not a recognized java privilege,
0:   // but means that these methods are private to this class and to subclasses,
0:   // and should not be used as package-wide friendly methods.
1: 
0:   // Parse the reply for the Close Query Command.
0:   // This method handles the parsing of all command replies and reply data
0:   // for the clsqry command.
0:   private void parseCLSQRYreply (ResultSetCallbackInterface resultSet) throws DisconnectException
0:   {
0:     int peekCP = parseTypdefsOrMgrlvlovrs ();
1: 
0:     if (peekCP == CodePoint.SQLCARD) {
0:       NetSqlca netSqlca = parseSQLCARD (null);  //@f48553sxg - null means rowsetSqlca_ is null
0:       // Set the cursor state if null SQLCA or sqlcode is equal to 0.
0:       resultSet.completeSqlca (netSqlca);
1:     }
0:     else
0:       parseCloseError (resultSet);
1:   }
1: 
0:   // Parse the reply for the Continue Query Command.
0:   // This method handles the parsing of all command replies and reply data for the cntqry command.
0:   // If doCopyQrydta==false, then there is no data, and we're only parsing out the sqlca to get the row count.
0:   private void parseCNTQRYreply (ResultSetCallbackInterface resultSetI,
0:                                  boolean doCopyQrydta) throws DisconnectException
0:   {
0:     boolean found = false;
0:     int peekCP = peekCodePoint();
1:     if (peekCP == CodePoint.RDBUPDRM) {
0:       found = true;
0:       parseRDBUPDRM();
0:       peekCP = peekCodePoint();
1:     }
1: 
0:     if (peekCP == CodePoint.QRYDTA) {
0:       found = true;
0:       if (!doCopyQrydta) {
0:         parseLengthAndMatchCodePoint (CodePoint.QRYDTA);
0:         //we don't need to copy QRYDTA since there is no data
0:         if (longValueForDecryption_ != null)
0:           longValueForDecryption_ = null;
0:         if (longBufferForDecryption_ != null)
0:           longBufferForDecryption_ = null;
1: 
0:         int ddmLength = getDdmLength();
0:         ensureBLayerDataInBuffer (ddmLength);
0:         ((ResultSet)resultSetI).expandRowsetSqlca ();
0:         NetSqlca sqlca = parseSQLCARDrow (((ResultSet)resultSetI).rowsetSqlca_);  
0:         int daNullIndicator = readFastByte();
0:         adjustLengths (getDdmLength());
0:         // define event interface and use the event method
0:         // only get the rowCount_ if sqlca is not null and rowCount_ is unknown
0:         if (sqlca != null && sqlca.containsSqlcax())
0:           ((ResultSet) resultSetI).setRowCountEvent (sqlca.getRowCount(netAgent_.targetTypdef_));
1: 
0:         peekCP = peekCodePoint();
1:         if (peekCP == CodePoint.RDBUPDRM) {
0:           parseRDBUPDRM();
0:           peekCP = peekCodePoint();
1:         }
0:         return;
1:       }
0:       do {
0:         parseQRYDTA ((NetResultSet) resultSetI);
0:         peekCP = peekCodePoint();
0:       } while (peekCP == CodePoint.QRYDTA);
1:     }
1: 
0:     if (peekCP == CodePoint.EXTDTA) {
0:       found = true;
0:       do {
0:         copyEXTDTA ((NetCursor)((ResultSet) resultSetI).cursor_);
0:         if (longBufferForDecryption_ != null ) {//encrypted EXTDTA
0:           buffer_ = longBufferForDecryption_;
0:           pos_ = longPosForDecryption_;
0:           if (longBufferForDecryption_ != null && count_ > longBufferForDecryption_.length)
0:             count_ = longBufferForDecryption_.length;
1:         }
1: 
0:         peekCP = peekCodePoint();
0:       } while (peekCP == CodePoint.EXTDTA);
1:     }
1: 
0:     if (peekCP == CodePoint.SQLCARD) {
0:       found = true;
0:       ((ResultSet)resultSetI).expandRowsetSqlca ();
0:       NetSqlca netSqlca = parseSQLCARD (((ResultSet)resultSetI).rowsetSqlca_);
0:       // for an atomic operation, the SQLCA contains the sqlcode for the first (statement
0:       // terminating)error, the last warning, or zero.  all multi-row fetch operatons are
0:       // atomic.  (the only operation that is not atomic is multi-row insert).
0:       if (((ResultSet)resultSetI).sensitivity_ != ResultSet.sensitivity_sensitive_dynamic__) {
0:         if (netSqlca != null && netSqlca.containsSqlcax() && netSqlca.getRowsetRowCount() == 0)
0:           ((ResultSet) resultSetI).setRowCountEvent (netSqlca.getRowCount(netAgent_.targetTypdef_));
1:       }
0:       resultSetI.completeSqlca (netSqlca);
0:       peekCP = peekCodePoint();
1:     }
1: 
0:     if (peekCP == CodePoint.ENDQRYRM) {
0:       found = true;
0:       parseEndQuery (resultSetI);
0:       peekCP = peekCodePoint();
1:     }
1: 
1:     if (peekCP == CodePoint.RDBUPDRM) {
0:       found = true;
0:       parseRDBUPDRM();
1:     }
1: 
0:     if (!found)
0:       parseFetchError (resultSetI);
1: 
0:     if (longBufferForDecryption_ != null) {
0:       // Not a good idea to create a new buffer_
0:       buffer_ = new byte[DEFAULT_BUFFER_SIZE];
0:       longBufferForDecryption_ = null;
1:   }
1:   }
1: 
0:   void parseCloseError (ResultSetCallbackInterface resultSetI) throws DisconnectException
0:   {
0:     int peekCP = peekCodePoint();
0:     switch (peekCP) {
0:     case CodePoint.ABNUOWRM: {
0:       NetSqlca sqlca = parseAbnormalEndUow (resultSetI.getConnectionCallbackInterface());
0:       resultSetI.completeSqlca (sqlca);
0:       break;
1:     }
0:     case CodePoint.CMDCHKRM:
0:       parseCMDCHKRM();
0:       break;
0:     case CodePoint.QRYNOPRM:
0:       parseQRYNOPRM (resultSetI);
0:       break;
0:     case CodePoint.RDBNACRM:
0:       parseRDBNACRM();
0:       break;
0:     default:
0:       parseCommonError (peekCP);
1:     }
1:   }
1: 
0:   void parseFetchError (ResultSetCallbackInterface resultSetI) throws DisconnectException
0:   {
0:     int peekCP = peekCodePoint();
0:     switch (peekCP) {
0:     case CodePoint.ABNUOWRM: {
0:       NetSqlca sqlca = parseAbnormalEndUow (resultSetI.getConnectionCallbackInterface());
0:       resultSetI.completeSqlca (sqlca);
0:       break;
1:     }
0:     case CodePoint.CMDCHKRM:
0:       parseCMDCHKRM();
0:       break;
0:     case CodePoint.CMDNSPRM:
0:       parseCMDNSPRM();
0:       break;
0:     case CodePoint.QRYNOPRM:
0:       parseQRYNOPRM (resultSetI);
0:       break;
0:     case CodePoint.RDBNACRM:
0:       parseRDBNACRM();
0:       break;
0:     default:
0:       parseCommonError (peekCP);
1:     }
1:   }
1: 
0:   //-----------------------------parse DDM Reply Messages-----------------------
1: 
0:   // Query Not Opened Reply Message is issued if a CNTQRY or CLSQRY
0:   // command is issued for a query that is not open.  A previous
0:   // ENDQRYRM, ENDUOWRM, or ABNUOWRM reply message might have
0:   // terminated the command.
0:   // PROTOCOL architects the SQLSTATE value depending on SVRCOD
0:   // SVRCOD 4 -> SQLSTATE is 24501
0:   // SVRCOD 8 -> SQLSTATE of 58008 or 58009
0:   //
0:   // if SVRCOD is 4 then SQLSTATE 24501, SQLCODE -501
0:   // else SQLSTATE 58009, SQLCODE -30020
0:   //
0:   // Messages
0:   // SQLSTATE : 24501
0:   //     The identified cursor is not open.
0:   //     SQLCODE : -501
0:   //     The cursor specified in a FETCH or CLOSE statement is not open.
0:   //     The statement cannot be processed.
0:   // SQLSTATE : 58009
0:   //     Execution failed due to a distribution protocol error that caused deallocation of the conversation.
0:   //     SQLCODE : -30020
0:   //     Execution failed because of a Distributed Protocol
0:   //         Error that will affect the successful execution of subsequent
0:   //         commands and SQL statements: Reason Code <reason-code>.
0:   //     Some possible reason codes include:
0:   //     121C Indicates that the user is not authorized to perform the requested command.
0:   //     1232 The command could not be completed because of a permanent error.
0:   //         In most cases, the server will be in the process of an abend.
0:   //     220A The target server has received an invalid data description.
0:   //         If a user SQLDA is specified, ensure that the fields are
0:   //         initialized correctly. Also, ensure that the length does not exceed
0:   //         the maximum allowed length for the data type being used.
0:   //
0:   //     The command or statement cannot be processed.  The current
0:   //         transaction is rolled back and the application is disconnected
0:   //         from the remote database.
0:   //
0:   // Returned from Server:
0:   // SVRCOD - required  (4 - WARNING, 8 - ERROR)
0:   // RDBNAM - required
0:   // PKGNAMCSN - required
0:   //
0:   private void parseQRYNOPRM (ResultSetCallbackInterface resultSet) throws DisconnectException
0:   {
0:     boolean svrcodReceived = false;
0:     int svrcod = CodePoint.SVRCOD_INFO;
0:     boolean rdbnamReceived = false;
0:     String rdbnam = null;
0:     boolean pkgnamcsnReceived = false;
0:     Object pkgnamcsn = null;
1: 
0:     parseLengthAndMatchCodePoint (CodePoint.QRYNOPRM);
0:     pushLengthOnCollectionStack();
0:     int peekCP = peekCodePoint();
1: 
0:     while (peekCP != Reply.END_OF_COLLECTION) {
1: 
0:       boolean foundInPass = false;
1: 
0:       if (peekCP == CodePoint.SVRCOD) {
0:         foundInPass = true;
0:         svrcodReceived = checkAndGetReceivedFlag (svrcodReceived);
0:         svrcod = parseSVRCOD (CodePoint.SVRCOD_WARNING, CodePoint.SVRCOD_ERROR);
0:         peekCP = peekCodePoint();
1:       }
1: 
0:       if (peekCP == CodePoint.RDBNAM) {
0:         foundInPass = true;
0:         rdbnamReceived = checkAndGetReceivedFlag (rdbnamReceived);
0:         rdbnam = parseRDBNAM (true);
0:         peekCP = peekCodePoint();
1:       }
1: 
0:       if (peekCP == CodePoint.PKGNAMCSN) {
0:         foundInPass = true;
0:         pkgnamcsnReceived = checkAndGetReceivedFlag (pkgnamcsnReceived);
0:         pkgnamcsn = parsePKGNAMCSN (true);
0:         peekCP = peekCodePoint();
1:       }
1: 
0:       if (!foundInPass)
0:         doPrmnsprmSemantics (peekCP);
1: 
1:     }
0:     popCollectionStack();
0:     checkRequiredObjects (svrcodReceived, rdbnamReceived, pkgnamcsnReceived);
1: 
0:     // move into a method
0:     netAgent_.setSvrcod (svrcod);
0:     if (svrcod == CodePoint.SVRCOD_WARNING) {
0:       netAgent_.accumulateReadException (new SqlException (netAgent_.logWriter_,
0:         "The identified cursor is not open.",
0:         SqlState._24501));
1:     }
0:     else {
0:       agent_.accumulateChainBreakingReadExceptionAndThrow (new DisconnectException (
0:         agent_,
0:         "Execution failed due to a distribution protocol error that " +
0:         "caused deallocation of the conversation.  " +
0:         "The identified cursor is not open.",
0:         SqlState._58009));
1:     }
1:   }
1: }
1: 
============================================================================