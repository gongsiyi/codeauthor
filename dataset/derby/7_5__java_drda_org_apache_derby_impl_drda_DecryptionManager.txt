1:eac0369: /*
1:d7258ed: 
1:d7258ed:    Derby - Class org.apache.derby.impl.drda.DecryptionManager
1:d7258ed: 
1:59e5225:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59e5225:    contributor license agreements.  See the NOTICE file distributed with
1:59e5225:    this work for additional information regarding copyright ownership.
1:59e5225:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59e5225:    (the "License"); you may not use this file except in compliance with
1:59e5225:    the License.  You may obtain a copy of the License at
1:d7258ed: 
1:d7258ed:       http://www.apache.org/licenses/LICENSE-2.0
1:d7258ed: 
1:d7258ed:    Unless required by applicable law or agreed to in writing, software
1:d7258ed:    distributed under the License is distributed on an "AS IS" BASIS,
1:d7258ed:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d7258ed:    See the License for the specific language governing permissions and
1:d7258ed:    limitations under the License.
3:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.drda;
1:eac0369: 
1:eac0369: import java.math.BigInteger;
1:db4c995: import java.security.KeyFactory;
1:db4c995: import java.security.KeyPair;
1:db4c995: import java.security.KeyPairGenerator;
1:db4c995: import java.security.PublicKey;
1:db4c995: import java.security.spec.AlgorithmParameterSpec;
1:db4c995: import java.sql.SQLException;
1:db4c995: import javax.crypto.Cipher;
1:db4c995: import javax.crypto.KeyAgreement;
1:db4c995: import javax.crypto.interfaces.DHPublicKey;
1:db4c995: import javax.crypto.spec.DHParameterSpec;
1:db4c995: import javax.crypto.spec.DHPublicKeySpec;
1:db4c995: import javax.crypto.spec.IvParameterSpec;
1:db4c995: import javax.crypto.spec.SecretKeySpec;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * This class is used to decrypt password and/or userid.
1:eac0369:  * It uses Diffie_Hellman algorithm to get the publick key and secret key, and then
1:eac0369:  * DES encryption is done using certain token (based on security mechanism) and 
1:eac0369:  * this side's own public key. Basically, this class is called when using a security
1:eac0369:  * mechanism that encrypts user ID and password (eusridpwd). This class uses IBM JCE
1:eac0369:  * to do Diffie_Hellman algorithm and DES encryption.
1:eac0369:  */
1:eac0369: 
1:7df5ffe: class DecryptionManager
6:eac0369: {
1:eac0369:   // DRDA's Diffie-Hellman agreed public value: prime.
1:eac0369:   private static final byte modulusBytes__[] = {
1:eac0369:     (byte)0xC6, (byte)0x21, (byte)0x12, (byte)0xD7,
1:eac0369:     (byte)0x3E, (byte)0xE6, (byte)0x13, (byte)0xF0,
1:eac0369:     (byte)0x94, (byte)0x7A, (byte)0xB3, (byte)0x1F,
1:eac0369:     (byte)0x0F, (byte)0x68, (byte)0x46, (byte)0xA1,
1:eac0369:     (byte)0xBF, (byte)0xF5, (byte)0xB3, (byte)0xA4,
1:eac0369:     (byte)0xCA, (byte)0x0D, (byte)0x60, (byte)0xBC,
1:eac0369:     (byte)0x1E, (byte)0x4C, (byte)0x7A, (byte)0x0D,
1:eac0369:     (byte)0x8C, (byte)0x16, (byte)0xB3, (byte)0xE3
1:eac0369:   };
1:eac0369: 
1:eac0369:   //the prime value in BigInteger form. It has to be in BigInteger form because this
1:eac0369:   //is the form used in JCE library.
1:eac0369:   private static final BigInteger modulus__
1:eac0369:   = new BigInteger (1, modulusBytes__);
1:eac0369: 
1:eac0369:   //  DRDA's Diffie-Hellman agreed public value: base.
1:eac0369:   private static final byte baseBytes__[] = {
1:eac0369:     (byte)0x46, (byte)0x90, (byte)0xFA, (byte)0x1F,
1:eac0369:     (byte)0x7B, (byte)0x9E, (byte)0x1D, (byte)0x44,
1:eac0369:     (byte)0x42, (byte)0xC8, (byte)0x6C, (byte)0x91,
1:eac0369:     (byte)0x14, (byte)0x60, (byte)0x3F, (byte)0xDE,
1:eac0369:     (byte)0xCF, (byte)0x07, (byte)0x1E, (byte)0xDC,
1:eac0369:     (byte)0xEC, (byte)0x5F, (byte)0x62, (byte)0x6E,
1:eac0369:     (byte)0x21, (byte)0xE2, (byte)0x56, (byte)0xAE,
1:eac0369:     (byte)0xD9, (byte)0xEA, (byte)0x34, (byte)0xE4
1:eac0369:   };
1:eac0369: 
1:eac0369:   // The base value in BigInteger form. It has to be in BigInteger form because
1:eac0369:   //this is the form used in IBM JCE library.
1:eac0369:   private static final BigInteger base__ =
1:eac0369:     new BigInteger (1, baseBytes__);
1:eac0369: 
1:eac0369:   //DRDA's Diffie-Hellman agreed exponential length
1:eac0369:   private static final int exponential_length__ = 255;
1:eac0369: 
1:eac0369:   private KeyPairGenerator keyPairGenerator_;
1:eac0369:   private KeyPair keyPair_;
1:eac0369:   private KeyAgreement keyAgreement_;
1:eac0369:   private DHParameterSpec paramSpec_;
1:eac0369: 
1:7233e33:   // Random Number Generator (PRNG) Algorithm
1:7233e33:   private final static String SHA_1_PRNG_ALGORITHM = "SHA1PRNG";
1:7233e33:   private final static int SECMEC_USRSSBPWD_SEED_LEN = 8;  // Seed length
1:7233e33: 
1:eac0369:   /**
1:eac0369:    * EncryptionManager constructor. In this constructor,DHParameterSpec,
1:eac0369:    * KeyPairGenerator, KeyPair, and KeyAgreement  are initialized.
1:eac0369:    *
1:eac0369:    * @throws SQLException that wraps any error
1:eac0369:    */
1:7df5ffe:   DecryptionManager () throws SQLException
1:db9a013:   {
1:eac0369:     try {
1:eac0369:       if (java.security.Security.getProvider ("IBMJCE") == null) // IBMJCE is not installed, install it.
1:4469400:       {
1:4469400:           Class<?> clazz = Class.forName("IBMJCE");
1:4469400:           java.security.Security.addProvider ((java.security.Provider) clazz.getConstructor().newInstance());
1:4469400:       }
1:eac0369:       paramSpec_ = new DHParameterSpec (modulus__, base__, exponential_length__);
1:eac0369:       keyPairGenerator_ = KeyPairGenerator.getInstance ("DH", "IBMJCE");
1:eac0369:       keyPairGenerator_.initialize ((AlgorithmParameterSpec)paramSpec_);
1:eac0369:       keyPair_ = keyPairGenerator_.generateKeyPair();
1:eac0369:       keyAgreement_ = KeyAgreement.getInstance ("DH", "IBMJCE");
1:eac0369:       keyAgreement_.init (keyPair_.getPrivate());
4:eac0369:     }
1:eac0369:     catch (java.lang.ClassNotFoundException e) {
1:eac0369:       throw new SQLException ("java.lang.ClassNotFoundException is caught" +
4:eac0369:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
1:eac0369:     }
1:eac0369:     catch (java.lang.IllegalAccessException e) {
1:eac0369:       throw new SQLException ("java.lang.IllegalAccessException is caught" +
1:eac0369:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
1:eac0369:     }
1:eac0369:     catch (java.lang.InstantiationException e) {
1:eac0369:       throw new SQLException ("java.lang.InstantiationException is caught" +
1:eac0369:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
1:eac0369:     }
1:4469400:     catch (java.lang.NoSuchMethodException e) {
1:4469400:       throw new SQLException ("java.lang.NoSuchMethodException is caught" +
1:4469400:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
1:4469400:     }
1:4469400:     catch (java.lang.reflect.InvocationTargetException e) {
1:4469400:       throw new SQLException ("java.lang.reflect.InvocationTargetException is caught" +
1:4469400:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
1:4469400:     }
1:eac0369:     catch (java.security.NoSuchProviderException e) {
1:eac0369:       throw new SQLException ("java.security.NoSuchProviderException is caught" +
1:eac0369:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
1:eac0369:     }
1:eac0369:     catch (java.security.NoSuchAlgorithmException e) {
1:eac0369:       throw new SQLException ("java.security.NoSuchAlgorithmException is caught" +
1:4f996a4:                   " when initializing EncryptionManager '" + e.getMessage() + "'");
1:eac0369:     }
1:eac0369:     catch (java.security.InvalidAlgorithmParameterException e) {
1:eac0369:       throw new SQLException ("java.security.InvalidAlgorithmParameterException is caught" +
1:4f996a4:                   " when initializing EncryptionManager '" + e.getMessage() + "'");
1:eac0369:     }
1:eac0369: 
1:eac0369:     catch (java.security.InvalidKeyException e) {
1:eac0369:       throw new SQLException ("java.security.InvalidKeyException is caught" +
1:4f996a4:                   " when initializing EncryptionManager '" + e.getMessage() + "'");
1:eac0369:     }
1:eac0369:   }
1:eac0369: 
1:eac0369:   /**
1:eac0369:    * This method generates the public key and returns it. This
1:eac0369:    * shared public key is the application server's connection key and will
1:eac0369:    * be exchanged with the application requester's connection key. This connection
1:eac0369:    * key will be put in the sectkn in ACCSECRD command and send to the application
1:eac0369:    * requester.
1:eac0369:    *
1:eac0369:    * @return  a byte array that is the application server's public key
1:eac0369:    */
1:eac0369:   public byte[] obtainPublicKey ()
1:4f996a4:   {
1:eac0369:     //The encoded public key
1:eac0369:     byte[] publicEnc =   keyPair_.getPublic().getEncoded();
1:eac0369: 
1:eac0369:     //we need to get the plain form public key because DRDA accepts plain form
1:eac0369:     //public key only.
1:eac0369:     BigInteger aPub = ((DHPublicKey) keyPair_.getPublic()).getY();
1:eac0369:     byte[] aPubKey = aPub.toByteArray();
1:eac0369: 
1:eac0369:     //the following lines of code is to adjust the length of the key. PublicKey
1:eac0369:     //in JCE is in the form of BigInteger and it's a signed value. When tranformed
1:eac0369:     //to a Byte array form, normally this array is 32 bytes. However, if the
1:eac0369:     //value happens to take up all 32 X 8 bits and it is positive, an extra
1:eac0369:     //bit is needed and then a 33 byte array will be returned. Since DRDA can't
1:eac0369:     //recogize the 33 byte key, we check the length here, if the length is 33,
1:eac0369:     //we will just trim off the first byte (0) and get the rest of 32 bytes.
1:eac0369:     if (aPubKey.length == 33 && aPubKey[0]==0) {
1:eac0369:       byte[] newKey = new byte[32];
1:eac0369:       for (int i=0; i < newKey.length; i++)
1:4f996a4:         newKey[i] = aPubKey[i+1];
1:eac0369:       return newKey;
1:eac0369:     }
1:eac0369: 
1:eac0369:     //the following lines of code is to adjust the length of the key. Occasionally,
1:eac0369:     //the length of the public key is less than 32, the reason of this is that the 0 byte
1:eac0369:     //in the beginning is somehow not returned. So we check the length here, if the length
1:eac0369:     //is less than 32, we will pad 0 in the beginning to make the public key 32 bytes
1:eac0369:     if (aPubKey.length < 32) {
1:eac0369:       byte[] newKey = new byte[32];
2:eac0369:       int i;
1:eac0369:       for (i=0; i < 32-aPubKey.length; i++) {
1:4f996a4:         newKey[i] = 0;
1:eac0369:       }
1:eac0369:       for (int j=i; j<newKey.length; j++)
1:4f996a4:         newKey[j] = aPubKey[j-i];
1:eac0369:       return newKey;
1:eac0369:     }
1:eac0369:     return aPubKey;
1:eac0369:   }
1:eac0369: 
1:eac0369:   /**
1:eac0369:    * This method is used to calculate the decryption token. DES encrypts the
1:eac0369:    * data using a token and the generated shared private key. The token used
1:eac0369:    * depends on the type of security mechanism being used:
1:eac0369:    * USRENCPWD - The userid is used as the token. The USRID is zero-padded to
1:eac0369:    * 8 bytes if less than 8 bytes or truncated to 8 bytes if greater than 8 bytes.
1:eac0369:    * EUSRIDPWD - The middle 8 bytes of the server's connection key is used as
1:eac0369:    * the token.  Decryption needs to use exactly the same token as encryption.
1:eac0369:    *
1:f0b0870:    * @param  securityMechanism security mechanism
1:f0b0870:    * @param  initVector  userid or server(this side)'s connection key
1:eac0369:    * @return byte[]  the decryption token
1:eac0369:    */
1:eac0369:   private byte[] calculateDecryptionToken (int securityMechanism, byte[] initVector)
1:eac0369:   {
1:eac0369:     byte[] token = new byte[8];
1:eac0369: 
1:eac0369:     //USRENCPWD, the userid is used as token
1:eac0369:     if (securityMechanism == 7) {
1:eac0369:       if (initVector.length < 8) { //shorter than 8 bytes, zero padded to 8 bytes
1:b3e9947:         System.arraycopy(initVector, 0, token, 0, initVector.length);
1:4f996a4:         for (int i=initVector.length; i<8; i++)
1:db9a013:          token[i] = 0;
1:eac0369:       }
1:eac0369:       else {  //longer than 8 bytes, truncated to 8 bytes
1:b3e9947:         System.arraycopy(initVector, 0, token, 0, 8);
1:eac0369:       }
1:eac0369:     }
1:eac0369:     //EUSRIDPWD - The middle 8 bytes of the server's connection key is used as
1:eac0369:     //the token.
1:eac0369:     else if (securityMechanism == 9) {
1:eac0369:       for (int i = 0; i < 8; i++) {
1:4f996a4:         token[i] = initVector[i + 12];
1:eac0369:       }
1:eac0369:     }
1:eac0369:     return token;
1:eac0369:   }
1:eac0369: 
1:eac0369:   /**
1:eac0369:    * This method generates a secret key using the application requester's
1:eac0369:    * public key, and decrypts the usreid/password with the middle 8 bytes of
1:eac0369:    * the generated secret key and a decryption token. Then it returns the
1:eac0369:    * decrypted data in a byte array.
1:eac0369:    *
1:eac0369:    * @param cipherText        The byte array form userid/password to decrypt.
1:f0b0870:    * @param securityMechanism security mechanism
1:eac0369:    * @param initVector        The byte array which is used to calculate the
1:eac0369:    *                          decryption token for initializing the cipher
1:eac0369:    * @param sourcePublicKey   application requester (encrypter)'s public key.
1:eac0369:    * @return the decrypted data (plain text) in a byte array.
1:eac0369:    */
1:eac0369:   public byte[] decryptData (byte[] cipherText,
1:4f996a4:                  int    securityMechanism,
1:4f996a4:                  byte[] initVector,
1:4f996a4:                  byte[] sourcePublicKey) throws SQLException
1:eac0369:   {
1:eac0369:     byte[] plainText = null;
1:eac0369:     byte[] token = calculateDecryptionToken (securityMechanism, initVector);
1:eac0369:     try {
1:eac0369: 
1:eac0369:       //initiate a Diffie_Hellman KeyFactory object.
1:eac0369:       KeyFactory keyFac = KeyFactory.getInstance ("DH", "IBMJCE");
1:eac0369: 
1:eac0369:       //Use server's public key to initiate a DHPublicKeySpec and then use
1:eac0369:       //this DHPublicKeySpec to initiate a publicKey object
1:eac0369:       BigInteger publicKey = new BigInteger (1, sourcePublicKey);
1:eac0369:       DHPublicKeySpec dhKeySpec = new DHPublicKeySpec (publicKey, modulus__, base__);
1:eac0369:       PublicKey pubKey = keyFac.generatePublic (dhKeySpec);
1:eac0369: 
1:eac0369:       //Execute the first phase of DH keyagreement protocal.
1:eac0369:       keyAgreement_.doPhase (pubKey, true);
1:eac0369: 
1:eac0369:       //generate the shared secret key. The application requestor's shared secret
1:eac0369:       //key should be exactly the same as the application server's shared secret
1:eac0369:       //key
1:eac0369:       byte[] sharedSecret = keyAgreement_.generateSecret();
1:eac0369:       byte[] newKey = new byte[32];
1:eac0369: 
1:eac0369:       //We adjust the length here. If the length of secret key is 33 and the first byte is 0,
1:eac0369:       //we trim off the frist byte. If the length of secret key is less than 32, we will
1:eac0369:       //pad 0 to the beginning of the byte array tho make the secret key 32 bytes.
1:eac0369:       if (sharedSecret.length == 33 && sharedSecret[0] == 0) {
1:4f996a4:         for (int i=0; i<newKey.length; i++)
1:4f996a4:           newKey[i] = sharedSecret[i+1];
1:eac0369:       }
1:eac0369:       if (sharedSecret.length < 32) {
1:4f996a4:         int i;
1:4f996a4:         for (i=0; i<(32 - sharedSecret.length); i++)
1:db9a013:             newKey[i] = 0;
1:4f996a4:         for (int j=i; j<sharedSecret.length; j++)
1:db9a013:              newKey[j] = sharedSecret[j-i];
1:eac0369:       }
1:eac0369: 
1:eac0369:       //The Data Encryption Standard (DES) is going to be used to encrypt userid
1:eac0369:       //and password. DES is a block cipher; it encrypts data in 64-bit blocks.
1:eac0369:       //DRDA encryption uses DES CBC mode as defined by the FIPS standard
1:eac0369:       //DES CBC requires an encryption key and an 8 byte token to encrypt the data.
1:eac0369:       //The middle 8 bytes of Diffie-Hellman shared private key is used as the
1:eac0369:       //encryption key. The following code retrieves middle 8 bytes of the shared
1:eac0369:       //private key.
1:eac0369:       byte[] key = new byte[8];
1:eac0369: 
1:eac0369:       //if secret key is not 32, we will use the adjust length secret key
1:eac0369:       if (sharedSecret.length==32) {
1:4f996a4:         for (int i=0; i< 8;i++)
1:4f996a4:           key[i] = sharedSecret[i+12];
1:eac0369:       }
1:eac0369:       else if (sharedSecret.length==33 || sharedSecret.length < 32) {
1:4f996a4:         for (int i=0; i< 8;i++)
1:4f996a4:           key[i] = newKey[i+12];
1:eac0369:       }
2:eac0369:       else
1:4f996a4:         throw new SQLException ("sharedSecret key length error " + sharedSecret.length);
1:eac0369: 
1:4f996a4:       // make parity bit right, even number of 1's
1:4f996a4:       byte temp;
1:4f996a4:       int changeParity;
1:4f996a4:       for (int i=0; i<8; i++)
1:4f996a4:       {
1:4f996a4:         temp = key[i];
1:4f996a4:         changeParity = 1;
1:4f996a4:         for (int j=0; j<8; j++)
1:4f996a4:         {
1:4f996a4:             if (temp < 0)
1:4f996a4:                 changeParity = 1 - changeParity;
1:4f996a4:             temp = (byte) (temp << 1);
1:4f996a4:         }
1:4f996a4:         if (changeParity == 1)
1:4f996a4:         {
1:4f996a4:             if ((key[i] & 1) != 0)
1:4f996a4:                 key[i] &= 0xfe;
1:4f996a4:             else
1:4f996a4:                 key[i] |= 1;
1:4f996a4:         }
1:4f996a4:       }
1:eac0369: 
1:eac0369:       //use this encryption key to initiate a SecretKeySpec object
1:eac0369:       SecretKeySpec desKey = new SecretKeySpec (key, "DES");
1:eac0369: 
1:eac0369:       //We use DES in CBC mode because this is the mode used in DRDA. The
1:eac0369:       //encryption mode has to be consistent for encryption and decryption.
1:eac0369:       //CBC mode requires an initialization vector(IV) parameter. In CBC mode
1:eac0369:       //we need to initialize the Cipher object with an IV, which can be supplied
1:eac0369:       // using the javax.crypto.spec.IvParameterSpec class.
1:eac0369:       Cipher cipher= Cipher.getInstance ("DES/CBC/PKCS5Padding", "IBMJCE");
1:eac0369: 
1:eac0369:       //generate a IVParameterSpec object and use it to initiate the
1:eac0369:       //Cipher object.
1:eac0369:       IvParameterSpec ivParam = new IvParameterSpec (token);
1:eac0369: 
1:eac0369:       //initiate the Cipher using encryption mode, encryption key and the
1:eac0369:       //IV parameter.
1:eac0369:       cipher.init (javax.crypto.Cipher.DECRYPT_MODE, desKey,ivParam);
1:eac0369: 
1:eac0369:       //Execute the final phase of encryption
1:eac0369:       plainText = cipher.doFinal (cipherText);
1:eac0369:     }
1:eac0369:     catch (java.security.NoSuchProviderException e) {
1:eac0369:       throw new SQLException ("java.security.NoSuchProviderException is caught "
1:4f996a4:                   + "when encrypting data '" + e.getMessage() + "'");
1:eac0369:     }
1:eac0369:     catch (java.security.NoSuchAlgorithmException e) {
1:eac0369:       throw new SQLException ("java.security.NoSuchAlgorithmException is caught "
1:4f996a4:                   + "when encrypting data '" + e.getMessage() + "'");
1:eac0369:     }
1:eac0369:     catch (java.security.spec.InvalidKeySpecException e) {
1:eac0369:       throw new SQLException ("java.security.InvalidKeySpecException is caught "
1:4f996a4:                   + "when encrypting data");
1:eac0369:     }
1:eac0369:     catch (java.security.InvalidKeyException e) {
1:eac0369:       throw new SQLException ("java.security.InvalidKeyException is caught "
1:4f996a4:                   + "when encrypting data '" + e.getMessage() + "'");
1:eac0369:     }
1:eac0369:     catch (javax.crypto.NoSuchPaddingException e) {
1:eac0369:       throw new SQLException ("javax.crypto.NoSuchPaddingException is caught "
1:4f996a4:                   + "when encrypting data '" + e.getMessage() + "'");
1:eac0369:     }
1:eac0369:     catch (javax.crypto.BadPaddingException e) {
1:eac0369:       throw new SQLException ("javax.crypto.BadPaddingException is caught "
1:4f996a4:                   + "when encrypting data '" + e.getMessage() + "'");
1:eac0369:     }
1:eac0369:     catch (java.security.InvalidAlgorithmParameterException e) {
1:eac0369:       throw new SQLException ("java.security.InvalidAlgorithmParameterException is caught "
1:4f996a4:                   + "when encrypting data '" + e.getMessage() + "'");
1:eac0369:     }
1:eac0369:     catch (javax.crypto.IllegalBlockSizeException e) {
1:eac0369:       throw new SQLException ("javax.crypto.IllegalBlockSizeException is caught "
1:4f996a4:                   + "when encrypting data '" + e.getMessage() + "'");
1:eac0369:     }
1:eac0369:     return plainText;
1:eac0369:   }
1:7233e33: 
1:7233e33:     /**
1:7233e33:      * This method generates an 8-Byte random seed.
1:7233e33:      *
1:7233e33:      * Required for the SECMEC_USRSSBPWD security mechanism
1:7233e33:      *
1:7233e33:      * @return a random 8-Byte seed.
1:7233e33:      */
1:7233e33:     protected static byte[] generateSeed() throws SQLException {
1:7233e33:         java.security.SecureRandom secureRandom = null;
1:7233e33:         try {
1:7233e33:           // We're verifying that we can instantiate a randon number
1:7233e33:           // generator (PRNG).
1:7233e33:           secureRandom =
1:7233e33:               java.security.SecureRandom.getInstance(SHA_1_PRNG_ALGORITHM);
1:7233e33:         } catch (java.security.NoSuchAlgorithmException nsae) {
1:7233e33:             throw new SQLException(
1:7233e33:                     "java.security.NoSuchAlgorithmException is caught" +
1:7233e33:                     " when initializing DecryptionManager '" +
1:7233e33:                     nsae.getMessage() + "'");
1:7233e33:         }
1:7233e33:         byte randomSeedBytes[] = new byte[SECMEC_USRSSBPWD_SEED_LEN];
1:7233e33:         secureRandom.setSeed(secureRandom.generateSeed(
1:7233e33:                                         SECMEC_USRSSBPWD_SEED_LEN));
1:7233e33:         secureRandom.nextBytes(randomSeedBytes);
1:7233e33:         // Return the 8-byte generated random seed
1:7233e33:         return randomSeedBytes;
1:7233e33:     }
1:7233e33: 
1:7233e33:     /*********************************************************************
1:7233e33:      * RESOLVE:                                                          *
1:7233e33:      * The methods and static vars below should go into some 'shared'    *
1:7233e33:      * package when the capability is put back in (StringUtil.java).     *
1:7233e33:      *********************************************************************/
1:7233e33: 
1:7233e33:     private static char[] hex_table = {
1:7233e33:                 '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
1:7233e33:                 'a', 'b', 'c', 'd', 'e', 'f'
1:7233e33:             };
1:7233e33:     
1:7233e33:     /**
1:7233e33:         Convert a byte array to a String with a hexidecimal format.
1:7233e33:         The String may be converted back to a byte array using fromHexString.
1:7233e33:         <BR>
1:7233e33:         For each byte (b) two characaters are generated, the first character
1:dbed020:         represents the high nibble (4 bits) in hexidecimal (<code>b &amp; 0xf0</code>),
1:dbed020:         the second character represents the low nibble (<code>b &amp; 0x0f</code>).
1:7233e33:         <BR>
1:7233e33:         The byte at <code>data[offset]</code> is represented by the first two characters in the returned String.
1:7233e33: 
1:db9a013:         @param  data    byte array
1:db9a013:         @param  offset  starting byte (zero based) to convert.
1:db9a013:         @param  length  number of bytes to convert.
1:7233e33: 
1:7233e33:         @return the String (with hexidecimal format) form of the byte array
1:7233e33:     */
1:7233e33:     protected static String toHexString(byte[] data, int offset, int length)
1:7233e33:     {
1:7233e33:         StringBuffer s = new StringBuffer(length*2);
1:7233e33:         int end = offset+length;
1:7233e33: 
1:7233e33:         for (int i = offset; i < end; i++)
1:7233e33:         {
1:7233e33:             int high_nibble = (data[i] & 0xf0) >>> 4;
1:7233e33:             int low_nibble = (data[i] & 0x0f);
1:7233e33:             s.append(hex_table[high_nibble]);
1:7233e33:             s.append(hex_table[low_nibble]);
1:7233e33:         }
1:7233e33: 
1:7233e33:         return s.toString();
1:7233e33:     }
1:7233e33: 
1:7233e33:     /**
1:7233e33:   
1:7233e33:         Convert a string into a byte array in hex format.
1:7233e33:         <BR>
1:7233e33:         For each character (b) two bytes are generated, the first byte 
1:dbed020:         represents the high nibble (4 bits) in hexidecimal (<code>b &amp; 0xf0</code>),
1:7233e33:         the second byte 
1:dbed020:         represents the low nibble (<code>b &amp; 0x0f</code>).
1:7233e33:         <BR>
1:7233e33:         The character at <code>str.charAt(0)</code> is represented by the first two bytes 
1:7233e33:         in the returned String.
1:7233e33: 
1:db9a013:         @param  str string
1:db9a013:         @param  offset  starting character (zero based) to convert.
1:db9a013:         @param  length  number of characters to convert.
1:7233e33: 
1:7233e33:         @return the byte[]  (with hexidecimal format) form of the string (str) 
1:7233e33:     */
1:7233e33:     protected static byte[] toHexByte(String str, int offset, int length)
1:7233e33:     {
1:7233e33:         byte[] data = new byte[(length - offset) * 2];
1:7233e33:         int end = offset+length;
1:7233e33: 
1:7233e33:         for (int i = offset; i < end; i++)
1:7233e33:         {
1:7233e33:             char ch = str.charAt(i);
1:7233e33:             int high_nibble = (ch & 0xf0) >>> 4;
1:7233e33:             int low_nibble = (ch & 0x0f);
1:7233e33:             data[i] = (byte)high_nibble;
1:7233e33:             data[i+1] = (byte)low_nibble;
1:7233e33:         }
1:7233e33:         return data;
1:7233e33:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:         represents the high nibble (4 bits) in hexidecimal (<code>b &amp; 0xf0</code>),
1:         the second character represents the low nibble (<code>b &amp; 0x0f</code>).
/////////////////////////////////////////////////////////////////////////
1:         represents the high nibble (4 bits) in hexidecimal (<code>b &amp; 0xf0</code>),
1:         represents the low nibble (<code>b &amp; 0x0f</code>).
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:       {
1:           Class<?> clazz = Class.forName("IBMJCE");
1:           java.security.Security.addProvider ((java.security.Provider) clazz.getConstructor().newInstance());
1:       }
/////////////////////////////////////////////////////////////////////////
1:     catch (java.lang.NoSuchMethodException e) {
1:       throw new SQLException ("java.lang.NoSuchMethodException is caught" +
1:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
1:     }
1:     catch (java.lang.reflect.InvocationTargetException e) {
1:       throw new SQLException ("java.lang.reflect.InvocationTargetException is caught" +
1:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
1:     }
commit:7233e33
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:   // Random Number Generator (PRNG) Algorithm
1:   private final static String SHA_1_PRNG_ALGORITHM = "SHA1PRNG";
1:   private final static int SECMEC_USRSSBPWD_SEED_LEN = 8;  // Seed length
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * This method generates an 8-Byte random seed.
1:      *
1:      * Required for the SECMEC_USRSSBPWD security mechanism
1:      *
1:      * @return a random 8-Byte seed.
1:      */
1:     protected static byte[] generateSeed() throws SQLException {
1:         java.security.SecureRandom secureRandom = null;
1:         try {
1:           // We're verifying that we can instantiate a randon number
1:           // generator (PRNG).
1:           secureRandom =
1:               java.security.SecureRandom.getInstance(SHA_1_PRNG_ALGORITHM);
1:         } catch (java.security.NoSuchAlgorithmException nsae) {
1:             throw new SQLException(
1:                     "java.security.NoSuchAlgorithmException is caught" +
1:                     " when initializing DecryptionManager '" +
1:                     nsae.getMessage() + "'");
1:         }
1:         byte randomSeedBytes[] = new byte[SECMEC_USRSSBPWD_SEED_LEN];
1:         secureRandom.setSeed(secureRandom.generateSeed(
1:                                         SECMEC_USRSSBPWD_SEED_LEN));
1:         secureRandom.nextBytes(randomSeedBytes);
1:         // Return the 8-byte generated random seed
1:         return randomSeedBytes;
1:     }
1: 
1:     /*********************************************************************
1:      * RESOLVE:                                                          *
1:      * The methods and static vars below should go into some 'shared'    *
1:      * package when the capability is put back in (StringUtil.java).     *
1:      *********************************************************************/
1: 
1:     private static char[] hex_table = {
1:                 '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
1:                 'a', 'b', 'c', 'd', 'e', 'f'
1:             };
1:     
1:     /**
1:         Convert a byte array to a String with a hexidecimal format.
1:         The String may be converted back to a byte array using fromHexString.
1:         <BR>
1:         For each byte (b) two characaters are generated, the first character
0:         represents the high nibble (4 bits) in hexidecimal (<code>b & 0xf0</code>),
0:         the second character represents the low nibble (<code>b & 0x0f</code>).
1: 		<BR>
1:         The byte at <code>data[offset]</code> is represented by the first two characters in the returned String.
1: 
0:         @param	data	byte array
0:         @param	offset	starting byte (zero based) to convert.
0:         @param	length	number of bytes to convert.
1: 
1:         @return the String (with hexidecimal format) form of the byte array
1:     */
1:     protected static String toHexString(byte[] data, int offset, int length)
1:     {
1:         StringBuffer s = new StringBuffer(length*2);
1:         int end = offset+length;
1: 
1:         for (int i = offset; i < end; i++)
1:         {
1:             int high_nibble = (data[i] & 0xf0) >>> 4;
1:             int low_nibble = (data[i] & 0x0f);
1:             s.append(hex_table[high_nibble]);
1:             s.append(hex_table[low_nibble]);
1:         }
1: 
1:         return s.toString();
1:     }
1: 
1:     /**
1:   
1:         Convert a string into a byte array in hex format.
1:         <BR>
1:         For each character (b) two bytes are generated, the first byte 
0:         represents the high nibble (4 bits) in hexidecimal (<code>b & 0xf0</code>),
1:         the second byte 
0:         represents the low nibble (<code>b & 0x0f</code>).
1:         <BR>
1:         The character at <code>str.charAt(0)</code> is represented by the first two bytes 
1:         in the returned String.
1: 
0:         @param	str string 
0:         @param	offset	starting character (zero based) to convert.
0:         @param	length	number of characters to convert.
1: 
1:         @return the byte[]  (with hexidecimal format) form of the string (str) 
1:     */
1:     protected static byte[] toHexByte(String str, int offset, int length)
1:     {
1:   	    byte[] data = new byte[(length - offset) * 2];
1:         int end = offset+length;
1: 
1:         for (int i = offset; i < end; i++)
1:  	    {
1:             char ch = str.charAt(i);
1:             int high_nibble = (ch & 0xf0) >>> 4;
1:             int low_nibble = (ch & 0x0f);
1:             data[i] = (byte)high_nibble;
1:             data[i+1] = (byte)low_nibble;
1:         }
1:         return data;
1:     }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:db9a013
/////////////////////////////////////////////////////////////////////////
1:          token[i] = 0;
/////////////////////////////////////////////////////////////////////////
1:             newKey[i] = 0;
1:              newKey[j] = sharedSecret[j-i];
/////////////////////////////////////////////////////////////////////////
1:         @param  data    byte array
1:         @param  offset  starting byte (zero based) to convert.
1:         @param  length  number of bytes to convert.
/////////////////////////////////////////////////////////////////////////
1:         @param  str string
1:         @param  offset  starting character (zero based) to convert.
1:         @param  length  number of characters to convert.
0:         byte[] data = new byte[(length - offset) * 2];
1:         {
commit:db4c995
/////////////////////////////////////////////////////////////////////////
1: import java.security.KeyFactory;
1: import java.security.KeyPair;
1: import java.security.KeyPairGenerator;
1: import java.security.PublicKey;
1: import java.security.spec.AlgorithmParameterSpec;
1: import java.sql.SQLException;
1: import javax.crypto.Cipher;
1: import javax.crypto.KeyAgreement;
1: import javax.crypto.interfaces.DHPublicKey;
1: import javax.crypto.spec.DHParameterSpec;
1: import javax.crypto.spec.DHPublicKeySpec;
1: import javax.crypto.spec.IvParameterSpec;
1: import javax.crypto.spec.SecretKeySpec;
commit:b3e9947
/////////////////////////////////////////////////////////////////////////
1:         System.arraycopy(initVector, 0, token, 0, initVector.length);
1:         System.arraycopy(initVector, 0, token, 0, 8);
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:4f996a4
/////////////////////////////////////////////////////////////////////////
1:                   " when initializing EncryptionManager '" + e.getMessage() + "'");
1:                   " when initializing EncryptionManager '" + e.getMessage() + "'");
1:                   " when initializing EncryptionManager '" + e.getMessage() + "'");
/////////////////////////////////////////////////////////////////////////
1:         newKey[i] = aPubKey[i+1];
/////////////////////////////////////////////////////////////////////////
1:         newKey[i] = 0;
1:         newKey[j] = aPubKey[j-i];
/////////////////////////////////////////////////////////////////////////
1:         for (int i=initVector.length; i<8; i++)
0:           token[i] = 0;
/////////////////////////////////////////////////////////////////////////
1:         token[i] = initVector[i + 12];
/////////////////////////////////////////////////////////////////////////
1:                  int    securityMechanism,
1:                  byte[] initVector,
1:                  byte[] sourcePublicKey) throws SQLException
/////////////////////////////////////////////////////////////////////////
1:         for (int i=0; i<newKey.length; i++)
1:           newKey[i] = sharedSecret[i+1];
1:         int i;
1:         for (i=0; i<(32 - sharedSecret.length); i++)
0:              newKey[i] = 0;
1:         for (int j=i; j<sharedSecret.length; j++)
0:               newKey[j] = sharedSecret[j-i];
/////////////////////////////////////////////////////////////////////////
1:         for (int i=0; i< 8;i++)
1:           key[i] = sharedSecret[i+12];
1:         for (int i=0; i< 8;i++)
1:           key[i] = newKey[i+12];
1:         throw new SQLException ("sharedSecret key length error " + sharedSecret.length);
1:       // make parity bit right, even number of 1's
1:       byte temp;
1:       int changeParity;
1:       for (int i=0; i<8; i++)
1:       {
1:         temp = key[i];
1:         changeParity = 1;
1:         for (int j=0; j<8; j++)
1:         {
1:             if (temp < 0)
1:                 changeParity = 1 - changeParity;
1:             temp = (byte) (temp << 1);
1:         }
1:         if (changeParity == 1)
1:         {
1:             if ((key[i] & 1) != 0)
1:                 key[i] &= 0xfe;
1:             else
1:                 key[i] |= 1;
1:         }
1:       }
/////////////////////////////////////////////////////////////////////////
1:                   + "when encrypting data '" + e.getMessage() + "'");
1:                   + "when encrypting data '" + e.getMessage() + "'");
1:                   + "when encrypting data");
1:                   + "when encrypting data '" + e.getMessage() + "'");
1:                   + "when encrypting data '" + e.getMessage() + "'");
1:                   + "when encrypting data '" + e.getMessage() + "'");
1:                   + "when encrypting data '" + e.getMessage() + "'");
1:                   + "when encrypting data '" + e.getMessage() + "'");
/////////////////////////////////////////////////////////////////////////
0:         <BR>
0:         @param    data    byte array
0:         @param    offset    starting byte (zero based) to convert.
0:         @param    length    number of bytes to convert.
/////////////////////////////////////////////////////////////////////////
0:         @param    str string 
0:         @param    offset    starting character (zero based) to convert.
0:         @param    length    number of characters to convert.
0:           byte[] data = new byte[(length - offset) * 2];
1:          {
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59e5225
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:f0b0870
/////////////////////////////////////////////////////////////////////////
1:    * @param  securityMechanism security mechanism
1:    * @param  initVector  userid or server(this side)'s connection key
/////////////////////////////////////////////////////////////////////////
1:    * @param securityMechanism security mechanism
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7df5ffe
/////////////////////////////////////////////////////////////////////////
1: class DecryptionManager
/////////////////////////////////////////////////////////////////////////
1:   DecryptionManager () throws SQLException
commit:d7258ed
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.drda.DecryptionManager
1: 
0:    Copyright 2002, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:141cd31
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.drda;
1: 
0: import java.security.KeyPairGenerator;
0: import java.security.KeyPair;
0: import javax.crypto.KeyAgreement;
0: import javax.crypto.spec.DHParameterSpec;
0: import javax.crypto.interfaces.DHPublicKey;
0: import javax.crypto.spec.DHPublicKeySpec;
0: import javax.crypto.spec.SecretKeySpec;
0: import javax.crypto.Cipher;
0: import javax.crypto.spec.IvParameterSpec;
0: import java.security.spec.AlgorithmParameterSpec;
0: import java.security.KeyFactory;
0: import java.security.PublicKey;
0: import java.sql.SQLException;
1: import java.math.BigInteger;
1: 
1: /**
1:  * This class is used to decrypt password and/or userid.
1:  * It uses Diffie_Hellman algorithm to get the publick key and secret key, and then
1:  * DES encryption is done using certain token (based on security mechanism) and 
1:  * this side's own public key. Basically, this class is called when using a security
1:  * mechanism that encrypts user ID and password (eusridpwd). This class uses IBM JCE
1:  * to do Diffie_Hellman algorithm and DES encryption.
1:  */
1: 
0: public class DecryptionManager
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1: 
0:   private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
1:   // DRDA's Diffie-Hellman agreed public value: prime.
1:   private static final byte modulusBytes__[] = {
1:     (byte)0xC6, (byte)0x21, (byte)0x12, (byte)0xD7,
1:     (byte)0x3E, (byte)0xE6, (byte)0x13, (byte)0xF0,
1:     (byte)0x94, (byte)0x7A, (byte)0xB3, (byte)0x1F,
1:     (byte)0x0F, (byte)0x68, (byte)0x46, (byte)0xA1,
1:     (byte)0xBF, (byte)0xF5, (byte)0xB3, (byte)0xA4,
1:     (byte)0xCA, (byte)0x0D, (byte)0x60, (byte)0xBC,
1:     (byte)0x1E, (byte)0x4C, (byte)0x7A, (byte)0x0D,
1:     (byte)0x8C, (byte)0x16, (byte)0xB3, (byte)0xE3
1:   };
1: 
1:   //the prime value in BigInteger form. It has to be in BigInteger form because this
1:   //is the form used in JCE library.
1:   private static final BigInteger modulus__
1:   = new BigInteger (1, modulusBytes__);
1: 
1:   //  DRDA's Diffie-Hellman agreed public value: base.
1:   private static final byte baseBytes__[] = {
1:     (byte)0x46, (byte)0x90, (byte)0xFA, (byte)0x1F,
1:     (byte)0x7B, (byte)0x9E, (byte)0x1D, (byte)0x44,
1:     (byte)0x42, (byte)0xC8, (byte)0x6C, (byte)0x91,
1:     (byte)0x14, (byte)0x60, (byte)0x3F, (byte)0xDE,
1:     (byte)0xCF, (byte)0x07, (byte)0x1E, (byte)0xDC,
1:     (byte)0xEC, (byte)0x5F, (byte)0x62, (byte)0x6E,
1:     (byte)0x21, (byte)0xE2, (byte)0x56, (byte)0xAE,
1:     (byte)0xD9, (byte)0xEA, (byte)0x34, (byte)0xE4
1:   };
1: 
1:   // The base value in BigInteger form. It has to be in BigInteger form because
1:   //this is the form used in IBM JCE library.
1:   private static final BigInteger base__ =
1:     new BigInteger (1, baseBytes__);
1: 
1:   //DRDA's Diffie-Hellman agreed exponential length
1:   private static final int exponential_length__ = 255;
1: 
1:   private KeyPairGenerator keyPairGenerator_;
1:   private KeyPair keyPair_;
1:   private KeyAgreement keyAgreement_;
1:   private DHParameterSpec paramSpec_;
1: 
1:   /**
1:    * EncryptionManager constructor. In this constructor,DHParameterSpec,
1:    * KeyPairGenerator, KeyPair, and KeyAgreement  are initialized.
1:    *
1:    * @throws SQLException that wraps any error
1:    */
0:   public DecryptionManager () throws SQLException
1:   {
1:     try {
1:       if (java.security.Security.getProvider ("IBMJCE") == null) // IBMJCE is not installed, install it.
0:         java.security.Security.addProvider ((java.security.Provider) Class.forName("IBMJCE").newInstance());
1:       paramSpec_ = new DHParameterSpec (modulus__, base__, exponential_length__);
1:       keyPairGenerator_ = KeyPairGenerator.getInstance ("DH", "IBMJCE");
1:       keyPairGenerator_.initialize ((AlgorithmParameterSpec)paramSpec_);
1:       keyPair_ = keyPairGenerator_.generateKeyPair();
1:       keyAgreement_ = KeyAgreement.getInstance ("DH", "IBMJCE");
1:       keyAgreement_.init (keyPair_.getPrivate());
1:     }
1:     catch (java.lang.ClassNotFoundException e) {
1:       throw new SQLException ("java.lang.ClassNotFoundException is caught" +
1:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
1:     }
1:     catch (java.lang.IllegalAccessException e) {
1:       throw new SQLException ("java.lang.IllegalAccessException is caught" +
1:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
1:     }
1:     catch (java.lang.InstantiationException e) {
1:       throw new SQLException ("java.lang.InstantiationException is caught" +
1:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
1:     }
1:     catch (java.security.NoSuchProviderException e) {
1:       throw new SQLException ("java.security.NoSuchProviderException is caught" +
1:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
1:     }
1:     catch (java.security.NoSuchAlgorithmException e) {
1:       throw new SQLException ("java.security.NoSuchAlgorithmException is caught" +
1: 			      " when initializing EncryptionManager '" + e.getMessage() + "'");
1:     }
1:     catch (java.security.InvalidAlgorithmParameterException e) {
1:       throw new SQLException ("java.security.InvalidAlgorithmParameterException is caught" +
1: 			      " when initializing EncryptionManager '" + e.getMessage() + "'");
1:     }
1: 
1:     catch (java.security.InvalidKeyException e) {
1:       throw new SQLException ("java.security.InvalidKeyException is caught" +
1: 			      " when initializing EncryptionManager '" + e.getMessage() + "'");
1:     }
1:   }
1: 
1:   /**
1:    * This method generates the public key and returns it. This
1:    * shared public key is the application server's connection key and will
1:    * be exchanged with the application requester's connection key. This connection
1:    * key will be put in the sectkn in ACCSECRD command and send to the application
1:    * requester.
1:    *
1:    * @return  a byte array that is the application server's public key
1:    */
1:   public byte[] obtainPublicKey ()
1:   {
1:     //The encoded public key
1:     byte[] publicEnc =   keyPair_.getPublic().getEncoded();
1: 
1:     //we need to get the plain form public key because DRDA accepts plain form
1:     //public key only.
1:     BigInteger aPub = ((DHPublicKey) keyPair_.getPublic()).getY();
1:     byte[] aPubKey = aPub.toByteArray();
1: 
1:     //the following lines of code is to adjust the length of the key. PublicKey
1:     //in JCE is in the form of BigInteger and it's a signed value. When tranformed
1:     //to a Byte array form, normally this array is 32 bytes. However, if the
1:     //value happens to take up all 32 X 8 bits and it is positive, an extra
1:     //bit is needed and then a 33 byte array will be returned. Since DRDA can't
1:     //recogize the 33 byte key, we check the length here, if the length is 33,
1:     //we will just trim off the first byte (0) and get the rest of 32 bytes.
1:     if (aPubKey.length == 33 && aPubKey[0]==0) {
1:       byte[] newKey = new byte[32];
1:       for (int i=0; i < newKey.length; i++)
0: 		newKey[i] = aPubKey[i+1];
1:       return newKey;
1:     }
1: 
1:     //the following lines of code is to adjust the length of the key. Occasionally,
1:     //the length of the public key is less than 32, the reason of this is that the 0 byte
1:     //in the beginning is somehow not returned. So we check the length here, if the length
1:     //is less than 32, we will pad 0 in the beginning to make the public key 32 bytes
1:     if (aPubKey.length < 32) {
1:       byte[] newKey = new byte[32];
1:       int i;
1:       for (i=0; i < 32-aPubKey.length; i++) {
0: 		newKey[i] = 0;
1:       }
1:       for (int j=i; j<newKey.length; j++)
0: 		newKey[j] = aPubKey[j-i];
1:       return newKey;
1:     }
1:     return aPubKey;
1:   }
1: 
1:   /**
1:    * This method is used to calculate the decryption token. DES encrypts the
1:    * data using a token and the generated shared private key. The token used
1:    * depends on the type of security mechanism being used:
1:    * USRENCPWD - The userid is used as the token. The USRID is zero-padded to
1:    * 8 bytes if less than 8 bytes or truncated to 8 bytes if greater than 8 bytes.
1:    * EUSRIDPWD - The middle 8 bytes of the server's connection key is used as
1:    * the token.  Decryption needs to use exactly the same token as encryption.
1:    *
0:    * @param  int     securityMechanism
0:    * @param  byte[]  userid or server(this side)'s connection key
1:    * @return byte[]  the decryption token
1:    */
1:   private byte[] calculateDecryptionToken (int securityMechanism, byte[] initVector)
1:   {
1:     byte[] token = new byte[8];
1: 
1:     //USRENCPWD, the userid is used as token
1:     if (securityMechanism == 7) {
1:       if (initVector.length < 8) { //shorter than 8 bytes, zero padded to 8 bytes
0: 		for (int i=0; i<initVector.length; i++)
0: 		  token[i] = initVector[i];
0: 		for (int i=initVector.length; i<8; i++)
0: 	 	 token[i] = 0;
1:       }
1:       else {  //longer than 8 bytes, truncated to 8 bytes
0: 		for (int i=0; i<8; i++)
0: 		  token[i] = initVector[i];
1:       }
1:     }
1:     //EUSRIDPWD - The middle 8 bytes of the server's connection key is used as
1:     //the token.
1:     else if (securityMechanism == 9) {
1:       for (int i = 0; i < 8; i++) {
0: 		token[i] = initVector[i + 12];
1:       }
1:     }
1:     return token;
1:   }
1: 
1:   /**
1:    * This method generates a secret key using the application requester's
1:    * public key, and decrypts the usreid/password with the middle 8 bytes of
1:    * the generated secret key and a decryption token. Then it returns the
1:    * decrypted data in a byte array.
1:    *
1:    * @param cipherText        The byte array form userid/password to decrypt.
0:    * @param security mechanism
1:    * @param initVector        The byte array which is used to calculate the
1:    *                          decryption token for initializing the cipher
1:    * @param sourcePublicKey   application requester (encrypter)'s public key.
1:    * @return the decrypted data (plain text) in a byte array.
1:    */
1:   public byte[] decryptData (byte[] cipherText,
0: 			     int    securityMechanism,
0: 			     byte[] initVector,
0: 			     byte[] sourcePublicKey) throws SQLException
1:   {
1:     byte[] plainText = null;
1:     byte[] token = calculateDecryptionToken (securityMechanism, initVector);
1:     try {
1: 
1:       //initiate a Diffie_Hellman KeyFactory object.
1:       KeyFactory keyFac = KeyFactory.getInstance ("DH", "IBMJCE");
1: 
1:       //Use server's public key to initiate a DHPublicKeySpec and then use
1:       //this DHPublicKeySpec to initiate a publicKey object
1:       BigInteger publicKey = new BigInteger (1, sourcePublicKey);
1:       DHPublicKeySpec dhKeySpec = new DHPublicKeySpec (publicKey, modulus__, base__);
1:       PublicKey pubKey = keyFac.generatePublic (dhKeySpec);
1: 
1:       //Execute the first phase of DH keyagreement protocal.
1:       keyAgreement_.doPhase (pubKey, true);
1: 
1:       //generate the shared secret key. The application requestor's shared secret
1:       //key should be exactly the same as the application server's shared secret
1:       //key
1:       byte[] sharedSecret = keyAgreement_.generateSecret();
1:       byte[] newKey = new byte[32];
1: 
1:       //We adjust the length here. If the length of secret key is 33 and the first byte is 0,
1:       //we trim off the frist byte. If the length of secret key is less than 32, we will
1:       //pad 0 to the beginning of the byte array tho make the secret key 32 bytes.
1:       if (sharedSecret.length == 33 && sharedSecret[0] == 0) {
0: 		for (int i=0; i<newKey.length; i++)
0: 		  newKey[i] = sharedSecret[i+1];
1:       }
1:       if (sharedSecret.length < 32) {
1: 		int i;
0: 		for (i=0; i<(32 - sharedSecret.length); i++)
0: 	 		newKey[i] = 0;
0: 		for (int j=i; j<sharedSecret.length; j++)
0: 	 		 newKey[j] = sharedSecret[j-i];
1:       }
1: 
1:       //The Data Encryption Standard (DES) is going to be used to encrypt userid
1:       //and password. DES is a block cipher; it encrypts data in 64-bit blocks.
1:       //DRDA encryption uses DES CBC mode as defined by the FIPS standard
1:       //DES CBC requires an encryption key and an 8 byte token to encrypt the data.
1:       //The middle 8 bytes of Diffie-Hellman shared private key is used as the
1:       //encryption key. The following code retrieves middle 8 bytes of the shared
1:       //private key.
1:       byte[] key = new byte[8];
1: 
1:       //if secret key is not 32, we will use the adjust length secret key
1:       if (sharedSecret.length==32) {
0: 		for (int i=0; i< 8;i++)
0: 		  key[i] = sharedSecret[i+12];
1:       }
1:       else if (sharedSecret.length==33 || sharedSecret.length < 32) {
0: 		for (int i=0; i< 8;i++)
0: 		  key[i] = newKey[i+12];
1:       }
1:       else
0: 		throw new SQLException ("sharedSecret key length error " + sharedSecret.length);
1: 
0: 	  // make parity bit right, even number of 1's
0: 	  byte temp;
0: 	  int changeParity;
0: 	  for (int i=0; i<8; i++)
1: 	  {
0: 		temp = key[i];
0: 		changeParity = 1;
0: 		for (int j=0; j<8; j++)
1: 		{
0: 			if (temp < 0)
0: 				changeParity = 1 - changeParity;
0: 			temp = (byte) (temp << 1);
1: 		}
0: 		if (changeParity == 1)
1: 		{
0: 			if ((key[i] & 1) != 0)
0: 				key[i] &= 0xfe;
1: 			else
0: 				key[i] |= 1;
1: 		}
1: 	  }
1: 
1:       //use this encryption key to initiate a SecretKeySpec object
1:       SecretKeySpec desKey = new SecretKeySpec (key, "DES");
1: 
1:       //We use DES in CBC mode because this is the mode used in DRDA. The
1:       //encryption mode has to be consistent for encryption and decryption.
1:       //CBC mode requires an initialization vector(IV) parameter. In CBC mode
1:       //we need to initialize the Cipher object with an IV, which can be supplied
1:       // using the javax.crypto.spec.IvParameterSpec class.
1:       Cipher cipher= Cipher.getInstance ("DES/CBC/PKCS5Padding", "IBMJCE");
1: 
1:       //generate a IVParameterSpec object and use it to initiate the
1:       //Cipher object.
1:       IvParameterSpec ivParam = new IvParameterSpec (token);
1: 
1:       //initiate the Cipher using encryption mode, encryption key and the
1:       //IV parameter.
1:       cipher.init (javax.crypto.Cipher.DECRYPT_MODE, desKey,ivParam);
1: 
1:       //Execute the final phase of encryption
1:       plainText = cipher.doFinal (cipherText);
1:     }
1:     catch (java.security.NoSuchProviderException e) {
1:       throw new SQLException ("java.security.NoSuchProviderException is caught "
0: 			      + "when encrypting data '" + e.getMessage() + "'");
1:     }
1:     catch (java.security.NoSuchAlgorithmException e) {
1:       throw new SQLException ("java.security.NoSuchAlgorithmException is caught "
0: 			      + "when encrypting data '" + e.getMessage() + "'");
1:     }
1:     catch (java.security.spec.InvalidKeySpecException e) {
1:       throw new SQLException ("java.security.InvalidKeySpecException is caught "
0: 			      + "when encrypting data");
1:     }
1:     catch (java.security.InvalidKeyException e) {
1:       throw new SQLException ("java.security.InvalidKeyException is caught "
0: 			      + "when encrypting data '" + e.getMessage() + "'");
1:     }
1:     catch (javax.crypto.NoSuchPaddingException e) {
1:       throw new SQLException ("javax.crypto.NoSuchPaddingException is caught "
0: 			      + "when encrypting data '" + e.getMessage() + "'");
1:     }
1:     catch (javax.crypto.BadPaddingException e) {
1:       throw new SQLException ("javax.crypto.BadPaddingException is caught "
0: 			      + "when encrypting data '" + e.getMessage() + "'");
1:     }
1:     catch (java.security.InvalidAlgorithmParameterException e) {
1:       throw new SQLException ("java.security.InvalidAlgorithmParameterException is caught "
0: 			      + "when encrypting data '" + e.getMessage() + "'");
1:     }
1:     catch (javax.crypto.IllegalBlockSizeException e) {
1:       throw new SQLException ("javax.crypto.IllegalBlockSizeException is caught "
0: 			      + "when encrypting data '" + e.getMessage() + "'");
1:     }
1:     return plainText;
1:   }
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.drda;
0: 
0: import java.security.KeyPairGenerator;
0: import java.security.KeyPair;
0: import javax.crypto.KeyAgreement;
0: import javax.crypto.spec.DHParameterSpec;
0: import javax.crypto.interfaces.DHPublicKey;
0: import javax.crypto.spec.DHPublicKeySpec;
0: import javax.crypto.spec.SecretKeySpec;
0: import javax.crypto.Cipher;
0: import javax.crypto.spec.IvParameterSpec;
0: import java.security.spec.AlgorithmParameterSpec;
0: import java.security.KeyFactory;
0: import java.security.PublicKey;
0: import java.sql.SQLException;
0: import java.math.BigInteger;
0: 
0: /**
0:  * This class is used to decrypt password and/or userid.
0:  * It uses Diffie_Hellman algorithm to get the publick key and secret key, and then
0:  * DES encryption is done using certain token (based on security mechanism) and 
0:  * this side's own public key. Basically, this class is called when using a security
0:  * mechanism that encrypts user ID and password (eusridpwd). This class uses IBM JCE
0:  * to do Diffie_Hellman algorithm and DES encryption.
0:  */
0: 
0: public class DecryptionManager
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0:   private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
0:   // DRDA's Diffie-Hellman agreed public value: prime.
0:   private static final byte modulusBytes__[] = {
0:     (byte)0xC6, (byte)0x21, (byte)0x12, (byte)0xD7,
0:     (byte)0x3E, (byte)0xE6, (byte)0x13, (byte)0xF0,
0:     (byte)0x94, (byte)0x7A, (byte)0xB3, (byte)0x1F,
0:     (byte)0x0F, (byte)0x68, (byte)0x46, (byte)0xA1,
0:     (byte)0xBF, (byte)0xF5, (byte)0xB3, (byte)0xA4,
0:     (byte)0xCA, (byte)0x0D, (byte)0x60, (byte)0xBC,
0:     (byte)0x1E, (byte)0x4C, (byte)0x7A, (byte)0x0D,
0:     (byte)0x8C, (byte)0x16, (byte)0xB3, (byte)0xE3
0:   };
0: 
0:   //the prime value in BigInteger form. It has to be in BigInteger form because this
0:   //is the form used in JCE library.
0:   private static final BigInteger modulus__
0:   = new BigInteger (1, modulusBytes__);
0: 
0:   //  DRDA's Diffie-Hellman agreed public value: base.
0:   private static final byte baseBytes__[] = {
0:     (byte)0x46, (byte)0x90, (byte)0xFA, (byte)0x1F,
0:     (byte)0x7B, (byte)0x9E, (byte)0x1D, (byte)0x44,
0:     (byte)0x42, (byte)0xC8, (byte)0x6C, (byte)0x91,
0:     (byte)0x14, (byte)0x60, (byte)0x3F, (byte)0xDE,
0:     (byte)0xCF, (byte)0x07, (byte)0x1E, (byte)0xDC,
0:     (byte)0xEC, (byte)0x5F, (byte)0x62, (byte)0x6E,
0:     (byte)0x21, (byte)0xE2, (byte)0x56, (byte)0xAE,
0:     (byte)0xD9, (byte)0xEA, (byte)0x34, (byte)0xE4
0:   };
0: 
0:   // The base value in BigInteger form. It has to be in BigInteger form because
0:   //this is the form used in IBM JCE library.
0:   private static final BigInteger base__ =
0:     new BigInteger (1, baseBytes__);
0: 
0:   //DRDA's Diffie-Hellman agreed exponential length
0:   private static final int exponential_length__ = 255;
0: 
0:   private KeyPairGenerator keyPairGenerator_;
0:   private KeyPair keyPair_;
0:   private KeyAgreement keyAgreement_;
0:   private DHParameterSpec paramSpec_;
0: 
0:   /**
0:    * EncryptionManager constructor. In this constructor,DHParameterSpec,
0:    * KeyPairGenerator, KeyPair, and KeyAgreement  are initialized.
0:    *
0:    * @throws SQLException that wraps any error
0:    */
0:   public DecryptionManager () throws SQLException
0:   {
0:     try {
0:       if (java.security.Security.getProvider ("IBMJCE") == null) // IBMJCE is not installed, install it.
0:         java.security.Security.addProvider ((java.security.Provider) Class.forName("IBMJCE").newInstance());
0:       paramSpec_ = new DHParameterSpec (modulus__, base__, exponential_length__);
0:       keyPairGenerator_ = KeyPairGenerator.getInstance ("DH", "IBMJCE");
0:       keyPairGenerator_.initialize ((AlgorithmParameterSpec)paramSpec_);
0:       keyPair_ = keyPairGenerator_.generateKeyPair();
0:       keyAgreement_ = KeyAgreement.getInstance ("DH", "IBMJCE");
0:       keyAgreement_.init (keyPair_.getPrivate());
0:     }
0:     catch (java.lang.ClassNotFoundException e) {
0:       throw new SQLException ("java.lang.ClassNotFoundException is caught" +
0:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
0:     }
0:     catch (java.lang.IllegalAccessException e) {
0:       throw new SQLException ("java.lang.IllegalAccessException is caught" +
0:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
0:     }
0:     catch (java.lang.InstantiationException e) {
0:       throw new SQLException ("java.lang.InstantiationException is caught" +
0:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
0:     }
0:     catch (java.security.NoSuchProviderException e) {
0:       throw new SQLException ("java.security.NoSuchProviderException is caught" +
0:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
0:     }
0:     catch (java.security.NoSuchAlgorithmException e) {
0:       throw new SQLException ("java.security.NoSuchAlgorithmException is caught" +
0: 			      " when initializing EncryptionManager '" + e.getMessage() + "'");
0:     }
0:     catch (java.security.InvalidAlgorithmParameterException e) {
0:       throw new SQLException ("java.security.InvalidAlgorithmParameterException is caught" +
0: 			      " when initializing EncryptionManager '" + e.getMessage() + "'");
0:     }
0: 
0:     catch (java.security.InvalidKeyException e) {
0:       throw new SQLException ("java.security.InvalidKeyException is caught" +
0: 			      " when initializing EncryptionManager '" + e.getMessage() + "'");
0:     }
0:   }
0: 
0:   /**
0:    * This method generates the public key and returns it. This
0:    * shared public key is the application server's connection key and will
0:    * be exchanged with the application requester's connection key. This connection
0:    * key will be put in the sectkn in ACCSECRD command and send to the application
0:    * requester.
0:    *
0:    * @return  a byte array that is the application server's public key
0:    */
0:   public byte[] obtainPublicKey ()
0:   {
0:     //The encoded public key
0:     byte[] publicEnc =   keyPair_.getPublic().getEncoded();
0: 
0:     //we need to get the plain form public key because DRDA accepts plain form
0:     //public key only.
0:     BigInteger aPub = ((DHPublicKey) keyPair_.getPublic()).getY();
0:     byte[] aPubKey = aPub.toByteArray();
0: 
0:     //the following lines of code is to adjust the length of the key. PublicKey
0:     //in JCE is in the form of BigInteger and it's a signed value. When tranformed
0:     //to a Byte array form, normally this array is 32 bytes. However, if the
0:     //value happens to take up all 32 X 8 bits and it is positive, an extra
0:     //bit is needed and then a 33 byte array will be returned. Since DRDA can't
0:     //recogize the 33 byte key, we check the length here, if the length is 33,
0:     //we will just trim off the first byte (0) and get the rest of 32 bytes.
0:     if (aPubKey.length == 33 && aPubKey[0]==0) {
0:       byte[] newKey = new byte[32];
0:       for (int i=0; i < newKey.length; i++)
0: 		newKey[i] = aPubKey[i+1];
0:       return newKey;
0:     }
0: 
0:     //the following lines of code is to adjust the length of the key. Occasionally,
0:     //the length of the public key is less than 32, the reason of this is that the 0 byte
0:     //in the beginning is somehow not returned. So we check the length here, if the length
0:     //is less than 32, we will pad 0 in the beginning to make the public key 32 bytes
0:     if (aPubKey.length < 32) {
0:       byte[] newKey = new byte[32];
0:       int i;
0:       for (i=0; i < 32-aPubKey.length; i++) {
0: 		newKey[i] = 0;
0:       }
0:       for (int j=i; j<newKey.length; j++)
0: 		newKey[j] = aPubKey[j-i];
0:       return newKey;
0:     }
0:     return aPubKey;
0:   }
0: 
0:   /**
0:    * This method is used to calculate the decryption token. DES encrypts the
0:    * data using a token and the generated shared private key. The token used
0:    * depends on the type of security mechanism being used:
0:    * USRENCPWD - The userid is used as the token. The USRID is zero-padded to
0:    * 8 bytes if less than 8 bytes or truncated to 8 bytes if greater than 8 bytes.
0:    * EUSRIDPWD - The middle 8 bytes of the server's connection key is used as
0:    * the token.  Decryption needs to use exactly the same token as encryption.
0:    *
0:    * @param  int     securityMechanism
0:    * @param  byte[]  userid or server(this side)'s connection key
0:    * @return byte[]  the decryption token
0:    */
0:   private byte[] calculateDecryptionToken (int securityMechanism, byte[] initVector)
0:   {
0:     byte[] token = new byte[8];
0: 
0:     //USRENCPWD, the userid is used as token
0:     if (securityMechanism == 7) {
0:       if (initVector.length < 8) { //shorter than 8 bytes, zero padded to 8 bytes
0: 		for (int i=0; i<initVector.length; i++)
0: 		  token[i] = initVector[i];
0: 		for (int i=initVector.length; i<8; i++)
0: 	 	 token[i] = 0;
0:       }
0:       else {  //longer than 8 bytes, truncated to 8 bytes
0: 		for (int i=0; i<8; i++)
0: 		  token[i] = initVector[i];
0:       }
0:     }
0:     //EUSRIDPWD - The middle 8 bytes of the server's connection key is used as
0:     //the token.
0:     else if (securityMechanism == 9) {
0:       for (int i = 0; i < 8; i++) {
0: 		token[i] = initVector[i + 12];
0:       }
0:     }
0:     return token;
0:   }
0: 
0:   /**
0:    * This method generates a secret key using the application requester's
0:    * public key, and decrypts the usreid/password with the middle 8 bytes of
0:    * the generated secret key and a decryption token. Then it returns the
0:    * decrypted data in a byte array.
0:    *
0:    * @param cipherText        The byte array form userid/password to decrypt.
0:    * @param security mechanism
0:    * @param initVector        The byte array which is used to calculate the
0:    *                          decryption token for initializing the cipher
0:    * @param sourcePublicKey   application requester (encrypter)'s public key.
0:    * @return the decrypted data (plain text) in a byte array.
0:    */
0:   public byte[] decryptData (byte[] cipherText,
0: 			     int    securityMechanism,
0: 			     byte[] initVector,
0: 			     byte[] sourcePublicKey) throws SQLException
0:   {
0:     byte[] plainText = null;
0:     byte[] token = calculateDecryptionToken (securityMechanism, initVector);
0:     try {
0: 
0:       //initiate a Diffie_Hellman KeyFactory object.
0:       KeyFactory keyFac = KeyFactory.getInstance ("DH", "IBMJCE");
0: 
0:       //Use server's public key to initiate a DHPublicKeySpec and then use
0:       //this DHPublicKeySpec to initiate a publicKey object
0:       BigInteger publicKey = new BigInteger (1, sourcePublicKey);
0:       DHPublicKeySpec dhKeySpec = new DHPublicKeySpec (publicKey, modulus__, base__);
0:       PublicKey pubKey = keyFac.generatePublic (dhKeySpec);
0: 
0:       //Execute the first phase of DH keyagreement protocal.
0:       keyAgreement_.doPhase (pubKey, true);
0: 
0:       //generate the shared secret key. The application requestor's shared secret
0:       //key should be exactly the same as the application server's shared secret
0:       //key
0:       byte[] sharedSecret = keyAgreement_.generateSecret();
0:       byte[] newKey = new byte[32];
0: 
0:       //We adjust the length here. If the length of secret key is 33 and the first byte is 0,
0:       //we trim off the frist byte. If the length of secret key is less than 32, we will
0:       //pad 0 to the beginning of the byte array tho make the secret key 32 bytes.
0:       if (sharedSecret.length == 33 && sharedSecret[0] == 0) {
0: 		for (int i=0; i<newKey.length; i++)
0: 		  newKey[i] = sharedSecret[i+1];
0:       }
0:       if (sharedSecret.length < 32) {
0: 		int i;
0: 		for (i=0; i<(32 - sharedSecret.length); i++)
0: 	 		newKey[i] = 0;
0: 		for (int j=i; j<sharedSecret.length; j++)
0: 	 		 newKey[j] = sharedSecret[j-i];
0:       }
0: 
0:       //The Data Encryption Standard (DES) is going to be used to encrypt userid
0:       //and password. DES is a block cipher; it encrypts data in 64-bit blocks.
0:       //DRDA encryption uses DES CBC mode as defined by the FIPS standard
0:       //DES CBC requires an encryption key and an 8 byte token to encrypt the data.
0:       //The middle 8 bytes of Diffie-Hellman shared private key is used as the
0:       //encryption key. The following code retrieves middle 8 bytes of the shared
0:       //private key.
0:       byte[] key = new byte[8];
0: 
0:       //if secret key is not 32, we will use the adjust length secret key
0:       if (sharedSecret.length==32) {
0: 		for (int i=0; i< 8;i++)
0: 		  key[i] = sharedSecret[i+12];
0:       }
0:       else if (sharedSecret.length==33 || sharedSecret.length < 32) {
0: 		for (int i=0; i< 8;i++)
0: 		  key[i] = newKey[i+12];
0:       }
0:       else
0: 		throw new SQLException ("sharedSecret key length error " + sharedSecret.length);
0: 
0: 	  // make parity bit right, even number of 1's
0: 	  byte temp;
0: 	  int changeParity;
0: 	  for (int i=0; i<8; i++)
0: 	  {
0: 		temp = key[i];
0: 		changeParity = 1;
0: 		for (int j=0; j<8; j++)
0: 		{
0: 			if (temp < 0)
0: 				changeParity = 1 - changeParity;
0: 			temp = (byte) (temp << 1);
0: 		}
0: 		if (changeParity == 1)
0: 		{
0: 			if ((key[i] & 1) != 0)
0: 				key[i] &= 0xfe;
0: 			else
0: 				key[i] |= 1;
0: 		}
0: 	  }
0: 
0:       //use this encryption key to initiate a SecretKeySpec object
0:       SecretKeySpec desKey = new SecretKeySpec (key, "DES");
0: 
0:       //We use DES in CBC mode because this is the mode used in DRDA. The
0:       //encryption mode has to be consistent for encryption and decryption.
0:       //CBC mode requires an initialization vector(IV) parameter. In CBC mode
0:       //we need to initialize the Cipher object with an IV, which can be supplied
0:       // using the javax.crypto.spec.IvParameterSpec class.
0:       Cipher cipher= Cipher.getInstance ("DES/CBC/PKCS5Padding", "IBMJCE");
0: 
0:       //generate a IVParameterSpec object and use it to initiate the
0:       //Cipher object.
0:       IvParameterSpec ivParam = new IvParameterSpec (token);
0: 
0:       //initiate the Cipher using encryption mode, encryption key and the
0:       //IV parameter.
0:       cipher.init (javax.crypto.Cipher.DECRYPT_MODE, desKey,ivParam);
0: 
0:       //Execute the final phase of encryption
0:       plainText = cipher.doFinal (cipherText);
0:     }
0:     catch (java.security.NoSuchProviderException e) {
0:       throw new SQLException ("java.security.NoSuchProviderException is caught "
0: 			      + "when encrypting data '" + e.getMessage() + "'");
0:     }
0:     catch (java.security.NoSuchAlgorithmException e) {
0:       throw new SQLException ("java.security.NoSuchAlgorithmException is caught "
0: 			      + "when encrypting data '" + e.getMessage() + "'");
0:     }
0:     catch (java.security.spec.InvalidKeySpecException e) {
0:       throw new SQLException ("java.security.InvalidKeySpecException is caught "
0: 			      + "when encrypting data");
0:     }
0:     catch (java.security.InvalidKeyException e) {
0:       throw new SQLException ("java.security.InvalidKeyException is caught "
0: 			      + "when encrypting data '" + e.getMessage() + "'");
0:     }
0:     catch (javax.crypto.NoSuchPaddingException e) {
0:       throw new SQLException ("javax.crypto.NoSuchPaddingException is caught "
0: 			      + "when encrypting data '" + e.getMessage() + "'");
0:     }
0:     catch (javax.crypto.BadPaddingException e) {
0:       throw new SQLException ("javax.crypto.BadPaddingException is caught "
0: 			      + "when encrypting data '" + e.getMessage() + "'");
0:     }
0:     catch (java.security.InvalidAlgorithmParameterException e) {
0:       throw new SQLException ("java.security.InvalidAlgorithmParameterException is caught "
0: 			      + "when encrypting data '" + e.getMessage() + "'");
0:     }
0:     catch (javax.crypto.IllegalBlockSizeException e) {
0:       throw new SQLException ("javax.crypto.IllegalBlockSizeException is caught "
0: 			      + "when encrypting data '" + e.getMessage() + "'");
0:     }
0:     return plainText;
0:   }
0: }
============================================================================