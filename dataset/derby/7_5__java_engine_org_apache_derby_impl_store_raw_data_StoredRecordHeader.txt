1:eac0369: /*
15:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.data.StoredRecordHeader
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:eac0369: package org.apache.derby.impl.store.raw.data;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.PageKey;
1:eac0369: import org.apache.derby.iapi.store.raw.RecordHandle;
1:eac0369: 
1:eac0369: import java.io.IOException;
1:eac0369: import java.io.EOFException;
1:eac0369: 
1:eac0369: import java.io.OutputStream;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.CompressedNumber;
1:eac0369: 
4:eac0369: /**
1:883a153:     A class StoredPage uses to cache record headers by passing instances
1:883a153:     to BasePage, and to write stored versions of record headers.
1:eac0369: 
1:883a153:     Format
1:eac0369: 
1:883a153:     <PRE>
1:eac0369: 
1:883a153:     1 byte          - status
1:883a153:     compressed int  - record identifier
1:eac0369: 
1:883a153:     compressed long - overflow page } only if hasOverflow() is true
1:883a153:     compressed int  - overflow id   }     "        "           "
1:eac0369: 
1:883a153:     compressed int  - first field   } only if hasFirstField set - otherwise 0
1:eac0369: 
1:883a153:     compressed int  - number of fields in this portion - only if hasOverflow()
1:883a153:                                 is false OR hasFirstField is true - otherwise 0
1:883a153:     </PRE>
1:eac0369: 
1:eac0369: */
1:eac0369: 
1:eac0369: public final class StoredRecordHeader
15:eac0369: {
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Constants of the class
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Status bits for the record header:
3:eac0369:      *
1:883a153:      * RECORD_DELETED           - used to indicate the record has been deleted
1:883a153:      * RECORD_OVERFLOW          - used to indicate the record has been 
1:eac0369:      *                            overflowed, it will point to the overflow 
1:eac0369:      *                            page and ID
1:883a153:      * RECORD_HAS_FIRST_FIELD   - used to indicate that firstField is stored. 
1:0ce6b77:      *                            When RECORD_OVERFLOW and 
1:eac0369:      *                            RECORD_HAS_FIRST_FIELD both are set, part of 
1:eac0369:      *                            record is on the page, the record header 
1:3f42a3e:      *                            also stores the overflow pointer to the next 
1:eac0369:      *                            part of the record.
1:eac0369:      * RECORD_VALID_MASK        - A mask of valid bits that can be set 
1:eac0369:      *                            currently, such that the following assert can
1:eac0369:      *                            be made: 
1:dbed020:      *                              ASSERT((status &amp; ~RECORD_VALID_MASK) == 0))
4:eac0369:      **/
1:bf5fd3c:     private static final byte RECORD_DELETED = 0x01;
1:bf5fd3c:     private static final byte RECORD_OVERFLOW = 0x02;
1:bf5fd3c:     private static final byte RECORD_HAS_FIRST_FIELD = 0x04;
1:bf5fd3c:     private static final byte RECORD_VALID_MASK = 0x0f;
1:eac0369: 
1:2f41733:     /**
1:2f41733:      * maximum length for row containing just an overflow pointer.
1:2f41733:      * <p>
1:2f41733:      * The maximum stored length of a row that just contains an overflow pointer
1:2f41733:      * is 17 bytes:
1:2f41733:      *   stored sizeof(status byte)       :  1 +
1:2f41733:      *   stored sizeof(record id)         :  4 +
1:2f41733:      *   max stored size overflow page ptr:  8 +
1:2f41733:      *   max stored size overflow record id: 4  
1:2f41733:      **/
1:2f41733:     public static final int MAX_OVERFLOW_ONLY_REC_SIZE = 
1:2f41733:             1 +                                     // stored status byte
1:2f41733:             CompressedNumber.MAX_INT_STORED_SIZE  + // max stored record id size
1:2f41733:             CompressedNumber.MAX_LONG_STORED_SIZE + // max stored overflow page 
1:2f41733:             CompressedNumber.MAX_INT_STORED_SIZE;   // max stored overflow id
1:2f41733: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Fields of the class
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Actual identifier of the record
1:eac0369:      *
1:eac0369:      * <BR> MT - Mutable
1:eac0369:      **/
1:883a153:     protected int   id;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Status of the record.
1:eac0369:      *
1:eac0369:      * See above for description of fields:
1:eac0369:      *     RECORD_DELETED
1:eac0369:      *     RECORD_OVERFLOW
1:eac0369:      *     RECORD_HAS_FIRST_FIELD
1:eac0369:      *     RECORD_VALID_MASK
1:eac0369:      *
1:eac0369:      * <BR> MT - Mutable - single thread required.
1:eac0369:      **/
1:bf5fd3c:     private byte status;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * number of fields in the row.
1:eac0369:      **/
1:883a153:     protected int numberFields;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * A record handle that can represent the record, may be null.
1:eac0369:      **/
1:883a153:     protected RecordHandle  handle;
1:eac0369: 
1:eac0369:     /**
1:bf5fd3c:      * Class which holds the fields {@code overflowId}, {@code overflowPage}
1:bf5fd3c:      * and {@code firstField}, which are not needed when there is no
1:bf5fd3c:      * overflow. These fields are factored out to save Java heap space (see
1:bf5fd3c:      * DERBY-3130).
1:bf5fd3c:      */
1:bf5fd3c:     private static class OverflowInfo {
1:eac0369: 
1:bf5fd3c:         /** Create an empty {@code OverflowInfo} object. */
1:bf5fd3c:         private OverflowInfo() { }
1:eac0369: 
1:bf5fd3c:         /** Create a copy of a {@code OverflowInfo} object. */
1:bf5fd3c:         private OverflowInfo(OverflowInfo from) {
1:bf5fd3c:             overflowId = from.overflowId;
1:bf5fd3c:             overflowPage = from.overflowPage;
1:bf5fd3c:             firstField = from.firstField;
1:bf5fd3c:         }
1:eac0369: 
1:bf5fd3c:         /**
1:bf5fd3c:          * If (hasOverflow()) then this is the id of the row on page
1:bf5fd3c:          * overflowPage where the next portion of the row can be found. In this
1:bf5fd3c:          * case there are no "real" fields on this page.  This situation comes
1:bf5fd3c:          * about if a row has been updated such that the real first field no
1:bf5fd3c:          * longer fits on the head page.
1:bf5fd3c:          */
1:bf5fd3c:         private int overflowId;
1:eac0369: 
1:bf5fd3c:         /**
1:bf5fd3c:          * If (hasOverflow()) then this is the page where where the next
1:bf5fd3c:          * portion of the row can be found. In this case there are no "real"
1:bf5fd3c:          * fields on this page.
1:bf5fd3c:          */
1:bf5fd3c:         private long overflowPage;
1:bf5fd3c: 
1:bf5fd3c:         /**
1:bf5fd3c:          * If (hasFirstField()) then this field is the number of the column in
1:bf5fd3c:          * the orginal row which is now stored as the first field in this row.
1:bf5fd3c:          * This row is 2nd through N'th portion of a long row.
1:bf5fd3c:          *
1:bf5fd3c:          * For example if a row has its first 3 fields on page 0 and its next 3
1:bf5fd3c:          * fields on page 1, then the record header of the row portion on page
1:bf5fd3c:          * 1 will have hasFirstField() set to true, and the value would be 4,
1:bf5fd3c:          * indicating that the 4th field of the row is stored as the 1st field
1:bf5fd3c:          * of the partial row portion stored on page 1.
1:bf5fd3c:          */
1:bf5fd3c:         private int firstField;
1:bf5fd3c:     }
1:bf5fd3c: 
1:bf5fd3c:     private OverflowInfo overflow;
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Constructors for This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:883a153:     public StoredRecordHeader() 
1:eac0369:     {
1:883a153:     }
1:eac0369: 
1:883a153:     public StoredRecordHeader(int id, int numberFields) 
1:eac0369:     {
1:883a153:         setId(id);
1:883a153:         setNumberFields(numberFields);
1:883a153:     }
1:eac0369: 
1:883a153:     public StoredRecordHeader(
1:eac0369:     byte    data[],
2:eac0369:     int     offset)
1:eac0369:     {
1:eac0369:         read(data, offset);
1:883a153:     }
1:eac0369: 
1:883a153:     public StoredRecordHeader(StoredRecordHeader loadTargetFrom) 
1:eac0369:     {
1:883a153:         this.status         = loadTargetFrom.status;
1:883a153:         this.id             = loadTargetFrom.id;
1:883a153:         this.numberFields   = loadTargetFrom.numberFields;
1:883a153:         handle              = null;
1:eac0369: 
1:bf5fd3c:         if (loadTargetFrom.overflow != null) {
1:bf5fd3c:             overflow = new OverflowInfo(loadTargetFrom.overflow);
1:bf5fd3c:         }
1:883a153:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Accessor "Get" Methods of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get a record handle for the record.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * <BR> MT - single thread required
1:eac0369:      **/
1:883a153:     protected RecordHandle getHandle(
1:eac0369:     PageKey pageId, 
1:eac0369:     int current_slot) 
1:eac0369:     {
1:883a153:         if (handle == null)
1:883a153:             handle = new RecordId(pageId, id, current_slot);
1:eac0369: 
1:883a153:         return handle;
1:883a153:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the record identifier
1:eac0369:      *
1:eac0369:      * <BR> MT - thread safe
1:eac0369:      **/
1:883a153:     public final int getId() 
1:eac0369:     {
1:883a153:         return id;
1:883a153:     }
1:eac0369: 
1:883a153:     public int getNumberFields() 
1:eac0369:     {
1:883a153:         return numberFields;
1:883a153:     }
1:eac0369: 
1:883a153:     public long getOverflowPage() 
1:eac0369:     {
1:bf5fd3c:         return overflow == null ? 0 : overflow.overflowPage;
1:883a153:     }
1:eac0369: 
1:883a153:     public int getOverflowId() 
1:eac0369:     {
1:bf5fd3c:         return overflow == null ? 0 : overflow.overflowId;
1:883a153:     }
1:eac0369: 
1:883a153:     public int getFirstField() 
1:eac0369:     {
1:bf5fd3c:         return overflow == null ? 0 : overflow.firstField;
1:883a153:     }
1:eac0369: 
1:883a153:     public final boolean hasOverflow() 
1:eac0369:     {
1:883a153:         return ((status & RECORD_OVERFLOW) == RECORD_OVERFLOW);
1:883a153:     }
1:eac0369: 
1:883a153:     protected final boolean hasFirstField() 
1:eac0369:     {
1:883a153:         return ((status & RECORD_HAS_FIRST_FIELD) == RECORD_HAS_FIRST_FIELD);
1:883a153:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the deleted state of the record.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * <BR> MT - single thread required
1:eac0369:      **/
1:883a153:     public final boolean isDeleted() 
1:eac0369:     {
1:883a153:         return ((status & RECORD_DELETED) == RECORD_DELETED);
1:883a153:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * return the size of the record header.
1:eac0369:      * <p>
1:eac0369:      * Calculates the size of the record header, mostly used to allow a
1:eac0369:      * reader to skip over the record header and position on the 1st field
1:eac0369:      * of the record.
1:eac0369:      * <p>
1:eac0369:      * This low level routine is performance critical to processing lots of
1:eac0369:      * rows, so calls to CompressNumber have been hand inlined.
1:eac0369:      *
1:883a153:      * @return The length of the record header.
1:eac0369:      **/
1:883a153:     public int size() 
1:eac0369:     {
1:eac0369:         // account for length of fieldDataLength field stored as a compressed
1:eac0369:         // int plus one byte for status.  
3:eac0369:         //
1:eac0369:         //    int len = CompressedNumber.sizeInt(id) + 1;
1:eac0369:         int len = 
1:eac0369:           (id <= CompressedNumber.MAX_COMPRESSED_INT_ONE_BYTE) ?
1:eac0369:               2 : 
1:eac0369:           (id <= CompressedNumber.MAX_COMPRESSED_INT_TWO_BYTES) ?
1:eac0369:               3 : 5;
1:eac0369: 
1:eac0369:         if ((status & (RECORD_OVERFLOW | RECORD_HAS_FIRST_FIELD)) == 0)
1:eac0369:         {
1:eac0369:             // usual case, not a record overflow and does not have first field
2:eac0369:             len += 
1:eac0369:               (numberFields <= CompressedNumber.MAX_COMPRESSED_INT_ONE_BYTE) ?
3:eac0369:                   1 : 
2:eac0369:               (numberFields <= CompressedNumber.MAX_COMPRESSED_INT_TWO_BYTES) ?
1:eac0369:                   2 : 4;
48:eac0369:         }
1:eac0369:         else if ((status & RECORD_OVERFLOW) == 0)
1:eac0369:         {
1:eac0369:             // not overflow, and has first field set.
1:bf5fd3c:             len += CompressedNumber.sizeInt(numberFields);
1:bf5fd3c:             len += CompressedNumber.sizeInt(overflow.firstField);
1:eac0369:         }
6:eac0369:         else
1:eac0369:         {
1:eac0369:             // is an overflow field
1:eac0369: 
1:bf5fd3c:             len += CompressedNumber.sizeLong(overflow.overflowPage);
1:bf5fd3c:             len += CompressedNumber.sizeInt(overflow.overflowId);
1:eac0369: 
3:eac0369:             if (hasFirstField())
1:eac0369:             {
1:bf5fd3c:                 len += CompressedNumber.sizeInt(overflow.firstField);
1:eac0369:                 len += CompressedNumber.sizeInt(numberFields);
1:883a153:             }
1:eac0369:         }
1:eac0369: 
1:883a153:         return len;
1:883a153:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Accessor "Set" Methods of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:20bc69f:      * Set the deleted state of the record.
1:eac0369:      * <p>
1:883a153:      * return   1, if delete status from not deleted to deleted
1:eac0369:      * return  -1, if delete status from deleted to not deleted
1:eac0369:      * return   0, if status unchanged.
1:eac0369:      *
1:eac0369:      * <BR> MT - single thread required
1:eac0369:      **/
1:883a153:     public int setDeleted(boolean deleteTrue) 
1:eac0369:     {
1:eac0369: 
1:883a153:         int retCode = 0;
1:eac0369: 
1:883a153:         if (deleteTrue) 
1:eac0369:         {
1:883a153:             if (!isDeleted()) 
1:eac0369:             {
1:883a153:                 // setting the bit from not deleted to deleted
1:883a153:                 retCode = 1;
1:883a153:                 status |= RECORD_DELETED;
1:883a153:             }
1:883a153:         } 
1:eac0369:         else 
1:eac0369:         {
1:883a153:             if (isDeleted()) 
1:eac0369:             {
1:883a153:                 // setting the bit from deleted to not deleted
1:883a153:                 retCode = -1;
1:883a153:                 status &= ~RECORD_DELETED;
1:883a153:             }
1:883a153:         }
1:eac0369: 
1:883a153:         return(retCode);
1:883a153:     }
1:eac0369: 
1:883a153:     public void setFirstField(int firstField) 
1:eac0369:     {
1:bf5fd3c:         if (overflow == null) {
1:bf5fd3c:             overflow = new OverflowInfo();
1:bf5fd3c:         }
1:bf5fd3c:         overflow.firstField = firstField;
1:eac0369:         status |= RECORD_HAS_FIRST_FIELD;
1:883a153:     }
1:eac0369: 
1:883a153:     public final void setId(int id) 
1:eac0369:     {
1:883a153:         this.id = id;
1:883a153:     }
1:eac0369: 
1:883a153:     public void setOverflowDetails(RecordHandle overflowHandle) 
1:eac0369:     {
1:bf5fd3c:         if (overflow == null) {
1:bf5fd3c:             overflow = new OverflowInfo();
1:bf5fd3c:         }
1:bf5fd3c:         overflow.overflowPage = overflowHandle.getPageNumber();
1:bf5fd3c:         overflow.overflowId = overflowHandle.getId();
1:883a153:     }
1:eac0369: 
1:eac0369:     public void setOverflowFields(StoredRecordHeader loadFromTarget)
1:eac0369:     {
1:bf5fd3c:         if (overflow == null) {
1:bf5fd3c:             overflow = new OverflowInfo();
1:bf5fd3c:         }
1:bf5fd3c:         this.status = (byte) (loadFromTarget.status | RECORD_OVERFLOW);
1:883a153:         this.id             = loadFromTarget.id;
1:883a153:         this.numberFields   = loadFromTarget.numberFields;
1:bf5fd3c:         overflow.firstField = loadFromTarget.overflow.firstField;
1:883a153:         handle              = null;
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:883a153:     public final void setNumberFields(int numberFields) 
1:eac0369:     {
1:883a153:         this.numberFields = numberFields;
1:883a153:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods implmenting read/write of Storable Interface:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:883a153:     public int write(OutputStream out) 
1:eac0369:         throws IOException 
1:eac0369:     {
1:eac0369:         // check consistency of the status field - this has caught
1:eac0369:         // byte writing corruptions in StoredPage in the past.
2:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
2:eac0369:             if ((status & ~RECORD_VALID_MASK) != 0)
1:883a153:                 SanityManager.THROWASSERT(
1:883a153:                     "Invalid status in StoredRecordHeaader = " + status);
1:eac0369:         }
1:eac0369: 
1:eac0369:         // write status
1:883a153:         int len = 1;
1:883a153:         out.write(status);
1:eac0369: 
1:eac0369:         // write id
1:883a153:         len += CompressedNumber.writeInt(out, id);
1:883a153:         
1:eac0369: 
1:eac0369:         // write overflow information for overflow record headers
1:883a153:         if (hasOverflow()) 
1:eac0369:         {
1:883a153:             // if overflow bit is set, then write the overflow pointer info.
1:bf5fd3c:             len += CompressedNumber.writeLong(out, overflow.overflowPage);
1:bf5fd3c:             len += CompressedNumber.writeInt(out, overflow.overflowId);
1:883a153:         }
1:eac0369: 
1:eac0369:         // write first field info for long row parts
1:883a153:         if (hasFirstField()) 
1:eac0369:         {
1:bf5fd3c:             len += CompressedNumber.writeInt(out, overflow.firstField);
1:883a153:         }
1:eac0369: 
1:eac0369:         // write number of fields, except in the case of a record header
1:eac0369:         // which is solely a pointer to another row portion.
1:eac0369:         //
1:883a153:         // see read
1:883a153:         if (!hasOverflow() || hasFirstField())
1:883a153:             len += CompressedNumber.writeInt(out, numberFields);
1:eac0369: 
1:883a153:         return len;
1:883a153:     }
1:eac0369: 
1:883a153:     public void read(java.io.ObjectInput in) 
1:eac0369:         throws IOException 
1:eac0369:     {
1:eac0369: 
1:eac0369:         // read status
1:bf5fd3c:         int s = in.read();
1:bf5fd3c:         if (s < 0) {
1:883a153:             throw new EOFException();
1:bf5fd3c:         }
1:bf5fd3c: 
1:bf5fd3c:         status = (byte) s;
1:eac0369: 
1:eac0369:         // check consistency of the status field - this has caught
1:eac0369:         // byte writing corruptions in StoredPage in the past.
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:bf5fd3c:             if ((s & ~RECORD_VALID_MASK) != 0)
1:883a153:                 SanityManager.THROWASSERT(
1:bf5fd3c:                     "Invalid status in StoredRecordHeader = " + s);
1:eac0369:         }
1:eac0369: 
1:eac0369:         // read the record id
1:883a153:         id = CompressedNumber.readInt(in);
1:eac0369: 
1:bf5fd3c:         if (hasOverflow() || hasFirstField()) {
1:bf5fd3c:             overflow = new OverflowInfo();
1:bf5fd3c:         } else {
1:bf5fd3c:             overflow = null;
1:bf5fd3c:         }
1:bf5fd3c: 
1:eac0369:         // initialize the overflow pointer based on status.
1:883a153:         if (hasOverflow()) 
1:eac0369:         {
1:bf5fd3c:             overflow.overflowPage = CompressedNumber.readLong(in);
1:bf5fd3c:             overflow.overflowId   = CompressedNumber.readInt(in);
1:eac0369: 
1:883a153:         } 
1:eac0369: 
1:eac0369:         // initialize the 1st field overflow pointer based on status.
1:883a153:         if (hasFirstField()) 
1:eac0369:         {
1:bf5fd3c:             overflow.firstField = CompressedNumber.readInt(in);
1:883a153:         } 
1:883a153:     
1:883a153:         // In releases prior to 1.3 an overflow record was handled
1:883a153:         // by an overflow header pointing to a complete record on
1:883a153:         // another page. This header had the overflow bit set but not
1:883a153:         // the has first field bit. This header also did not have the
1:883a153:         // number of fields written out, but it can be seen as
1:883a153:         // a header with 0 fields and a first field of 0.
1:883a153:         if (!hasOverflow() || hasFirstField())
1:883a153:             numberFields = CompressedNumber.readInt(in);
1:883a153:         else
1:883a153:             numberFields = 0;
1:eac0369: 
1:883a153:         handle = null;
1:883a153:     }
1:eac0369: 
1:eac0369:     private int readOverFlowPage(
2:eac0369:     byte[]  data,
1:eac0369:     int     offset)
1:eac0369:     {
1:883a153:         int int_value = data[offset++];
1:eac0369: 
1:eac0369:         if ((int_value & ~0x3f) == 0)
1:eac0369:         {
1:eac0369:             // test for small case first - assuming this is usual case.
1:eac0369:             // this is stored in 2 bytes.
1:eac0369: 
1:bf5fd3c:             overflow.overflowPage = ((int_value << 8) | (data[offset] & 0xff));
1:eac0369: 
2:eac0369:             return(2);
1:883a153:         }
1:883a153:         else if ((int_value & 0x80) == 0)
1:883a153:         {
1:eac0369:             // value is stored in 4 bytes.  only use low 6 bits from 1st byte.
1:eac0369: 
1:bf5fd3c:             overflow.overflowPage =
1:eac0369:                 ((int_value      & 0x3f) << 24) |
2:eac0369:                 ((data[offset++] & 0xff) << 16) |
2:eac0369:                 ((data[offset++] & 0xff) <<  8) |
2:eac0369:                 ((data[offset]   & 0xff)      );
1:eac0369: 
2:eac0369:             return(4);
1:eac0369: 
1:883a153:         } 
1:eac0369:         else
1:883a153:         {
1:eac0369:             // value is stored in 8 bytes.  only use low 6 bits from 1st byte.
1:bf5fd3c:             overflow.overflowPage =
1:eac0369:                 (((long) (int_value      & 0x7f)) << 56) |
1:eac0369:                 (((long) (data[offset++] & 0xff)) << 48) |
1:eac0369:                 (((long) (data[offset++] & 0xff)) << 40) |
1:eac0369:                 (((long) (data[offset++] & 0xff)) << 32) |
1:eac0369:                 (((long) (data[offset++] & 0xff)) << 24) |
1:eac0369:                 (((long) (data[offset++] & 0xff)) << 16) |
1:eac0369:                 (((long) (data[offset++] & 0xff)) <<  8) |
1:eac0369:                 (((long) (data[offset]   & 0xff))      );
1:eac0369: 
1:eac0369:             return(8);
1:883a153:         }
1:883a153:     }
1:eac0369:     private int readOverFlowId(
1:eac0369:     byte[]  data,
1:eac0369:     int     offset)
1:eac0369:     {
1:883a153:         int value = data[offset++];
1:eac0369: 
2:eac0369:         if ((value & ~0x3f) == 0)
1:eac0369:         {
1:eac0369:             // length stored in this byte.
1:bf5fd3c:             overflow.overflowId = value;
1:eac0369: 
2:eac0369:             return(1);
1:eac0369:         }
1:883a153:         else if ((value & 0x80) == 0)
1:883a153:         {
1:eac0369:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
1:eac0369: 
1:bf5fd3c:             overflow.overflowId =
1:bf5fd3c:                 (((value & 0x3f) << 8) | (data[offset] & 0xff));
1:eac0369: 
1:eac0369:             return(2);
1:883a153:         }
1:eac0369:         else
1:883a153:         {
1:eac0369:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
1:bf5fd3c:             overflow.overflowId =
2:eac0369:                 ((value          & 0x7f) << 24) |
1:eac0369:                 ((data[offset++] & 0xff) << 16) |
1:eac0369:                 ((data[offset++] & 0xff) <<  8) |
1:eac0369:                 ((data[offset]   & 0xff)      );
1:eac0369: 
1:eac0369:             return(4);
1:eac0369:         }
1:eac0369:     }
1:eac0369:     private int readFirstField(
1:eac0369:     byte[]  data,
1:eac0369:     int     offset)
1:eac0369:     {
1:883a153:         int value = data[offset++];
1:eac0369: 
1:eac0369:         if ((value & ~0x3f) == 0)
1:eac0369:         {
1:eac0369:             // length stored in this byte.
1:bf5fd3c:             overflow.firstField = value;
1:eac0369: 
1:eac0369:             return(1);
1:eac0369:         }
1:883a153:         else if ((value & 0x80) == 0)
1:eac0369:         {
1:eac0369:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
1:eac0369: 
1:bf5fd3c:             overflow.firstField =
1:bf5fd3c:                 (((value & 0x3f) << 8) | (data[offset] & 0xff));
1:eac0369: 
1:eac0369:             return(2);
1:883a153:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
1:bf5fd3c:             overflow.firstField =
1:eac0369:                 ((value          & 0x7f) << 24) |
1:eac0369:                 ((data[offset++] & 0xff) << 16) |
1:eac0369:                 ((data[offset++] & 0xff) <<  8) |
1:eac0369:                 ((data[offset]   & 0xff)      );
1:eac0369: 
1:eac0369:             return(4);
1:eac0369:         }
1:eac0369:     }
1:eac0369:     private void readNumberFields(
1:eac0369:     byte[]  data,
1:eac0369:     int     offset)
1:eac0369:     {
1:883a153:         int value = data[offset++];
1:eac0369: 
1:eac0369:         if ((value & ~0x3f) == 0)
1:eac0369:         {
1:eac0369:             // length stored in this byte.
1:eac0369:             numberFields = value;
1:eac0369:         }
1:883a153:         else if ((value & 0x80) == 0)
1:883a153:         {
1:eac0369:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
1:eac0369: 
1:eac0369:             numberFields = (((value & 0x3f) << 8) | (data[offset] & 0xff));
1:883a153:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
1:eac0369:             numberFields = 
1:eac0369:                 ((value          & 0x7f) << 24) |
1:eac0369:                 ((data[offset++] & 0xff) << 16) |
1:eac0369:                 ((data[offset++] & 0xff) <<  8) |
1:eac0369:                 ((data[offset]   & 0xff)      );
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:883a153:     private void read(
1:eac0369:     byte[]  data,
1:eac0369:     int     offset)
1:eac0369:     {
1:eac0369:         status = data[offset++];
1:eac0369: 
1:883a153:         int value = data[offset++];
1:eac0369: 
1:eac0369:         if ((value & ~0x3f) == 0)
1:eac0369:         {
2:eac0369:             // value stored in this byte.
2:eac0369:             id = value;
1:eac0369:         }
1:883a153:         else if ((value & 0x80) == 0)
1:883a153:         {
2:eac0369:             // value is stored in 2 bytes.  only use low 6 bits from 1st byte.
1:eac0369: 
1:eac0369:             id = (((value & 0x3f) << 8) | (data[offset++] & 0xff));
1:883a153:         }
1:eac0369:         else
1:eac0369:         {
2:eac0369:             // value is stored in 4 bytes.  only use low 7 bits from 1st byte.
2:eac0369:             id = 
1:eac0369:                 ((value          & 0x7f) << 24) |
1:eac0369:                 ((data[offset++] & 0xff) << 16) |
1:eac0369:                 ((data[offset++] & 0xff) <<  8) |
1:eac0369:                 ((data[offset++] & 0xff)      );
1:eac0369:         }
1:eac0369: 
1:eac0369:         if ((status & (RECORD_OVERFLOW | RECORD_HAS_FIRST_FIELD)) == 0)
1:eac0369:         {
1:eac0369:             // usual case, not a record overflow and does not have first field
1:bf5fd3c:             overflow = null;
1:eac0369: 
1:eac0369:             readNumberFields(data, offset);
1:eac0369:         }
1:eac0369:         else if ((status & RECORD_OVERFLOW) == 0)
1:eac0369:         {
1:eac0369:             // not overflow, and has first field set.
1:bf5fd3c:             overflow = new OverflowInfo();
1:eac0369: 
1:eac0369:             offset += readFirstField(data, offset);
1:eac0369: 
1:eac0369:             readNumberFields(data, offset);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             // is an overflow field
1:bf5fd3c:             overflow = new OverflowInfo();
1:eac0369: 
1:eac0369:             offset += readOverFlowPage(data, offset);
1:eac0369:             offset += readOverFlowId(data, offset);
1:eac0369: 
1:eac0369:             if (hasFirstField())
1:eac0369:             {
1:eac0369:                 offset += readFirstField(data, offset);
1:eac0369:                 readNumberFields(data, offset);
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
2:eac0369:                 numberFields = 0;
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
2:eac0369:         handle = null;
1:eac0369: 
1:eac0369:         return;
1:883a153:     }
1:eac0369: 
1:5314923:     /**
1:5314923:      * Return length on disk of the record id portion of the record header
1:5314923:      *
1:5314923:      * Record id is part of the record header and is stored in an internal
1:5314923:      * compressed format.  The length of this format depends on the value
1:5314923:      * of the record id.
1:5314923:      *
1:5314923:      * @return length of encoded record id on disk.
1:5314923:      **/
1:5314923:     public static final int getStoredSizeRecordId(int record_id)
1:5314923:     {
1:5314923:         return(CompressedNumber.sizeInt(record_id));
1:5314923:     }
1:eac0369: 
1:883a153:     public String toString()
1:883a153:     {
1:883a153:         if (SanityManager.DEBUG)
1:eac0369:         {
1:883a153:             String str = "recordHeader: Id=" + getId();
1:883a153:             
1:883a153:             str += "\n  isDeleted     = " + isDeleted();
1:883a153:             str += "\n  hasOverflow   = " + hasOverflow();
1:883a153:             str += "\n  hasFirstField = " + hasFirstField();
1:883a153:             str += "\n  numberFields  = " + getNumberFields();
1:883a153:             str += "\n  firstField    = " + getFirstField();
1:883a153:             str += "\n  overflowPage  = " + getOverflowPage();
1:883a153:             str += "\n  overflowId    = " + getOverflowId();
1:883a153:             str += "\n  header length = " + size();
1:883a153: 
1:883a153:             return str;
1:eac0369:         }
1:883a153:         else
1:883a153:         {
1:883a153:             return null;
1:883a153:         }
1:883a153:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      *                              ASSERT((status &amp; ~RECORD_VALID_MASK) == 0))
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f668d94
/////////////////////////////////////////////////////////////////////////
commit:bf5fd3c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static final byte RECORD_DELETED = 0x01;
1:     private static final byte RECORD_OVERFLOW = 0x02;
1:     private static final byte RECORD_HAS_FIRST_FIELD = 0x04;
1:     private static final byte RECORD_VALID_MASK = 0x0f;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private byte status;
/////////////////////////////////////////////////////////////////////////
1:      * Class which holds the fields {@code overflowId}, {@code overflowPage}
1:      * and {@code firstField}, which are not needed when there is no
1:      * overflow. These fields are factored out to save Java heap space (see
1:      * DERBY-3130).
1:      */
1:     private static class OverflowInfo {
1:         /** Create an empty {@code OverflowInfo} object. */
1:         private OverflowInfo() { }
1:         /** Create a copy of a {@code OverflowInfo} object. */
1:         private OverflowInfo(OverflowInfo from) {
1:             overflowId = from.overflowId;
1:             overflowPage = from.overflowPage;
1:             firstField = from.firstField;
1:         }
1:         /**
1:          * If (hasOverflow()) then this is the id of the row on page
1:          * overflowPage where the next portion of the row can be found. In this
1:          * case there are no "real" fields on this page.  This situation comes
1:          * about if a row has been updated such that the real first field no
1:          * longer fits on the head page.
1:          */
1:         private int overflowId;
1:         /**
1:          * If (hasOverflow()) then this is the page where where the next
1:          * portion of the row can be found. In this case there are no "real"
1:          * fields on this page.
1:          */
1:         private long overflowPage;
1: 
1:         /**
1:          * If (hasFirstField()) then this field is the number of the column in
1:          * the orginal row which is now stored as the first field in this row.
1:          * This row is 2nd through N'th portion of a long row.
1:          *
1:          * For example if a row has its first 3 fields on page 0 and its next 3
1:          * fields on page 1, then the record header of the row portion on page
1:          * 1 will have hasFirstField() set to true, and the value would be 4,
1:          * indicating that the 4th field of the row is stored as the 1st field
1:          * of the partial row portion stored on page 1.
1:          */
1:         private int firstField;
1:     }
1: 
1:     private OverflowInfo overflow;
/////////////////////////////////////////////////////////////////////////
1:         if (loadTargetFrom.overflow != null) {
1:             overflow = new OverflowInfo(loadTargetFrom.overflow);
1:         }
/////////////////////////////////////////////////////////////////////////
1: 		return overflow == null ? 0 : overflow.overflowPage;
1: 		return overflow == null ? 0 : overflow.overflowId;
1: 		return overflow == null ? 0 : overflow.firstField;
/////////////////////////////////////////////////////////////////////////
1:             len += CompressedNumber.sizeInt(numberFields);
1:             len += CompressedNumber.sizeInt(overflow.firstField);
1: 			len += CompressedNumber.sizeLong(overflow.overflowPage);
1: 			len += CompressedNumber.sizeInt(overflow.overflowId);
1:                 len += CompressedNumber.sizeInt(overflow.firstField);
/////////////////////////////////////////////////////////////////////////
1:         if (overflow == null) {
1:             overflow = new OverflowInfo();
1:         }
1:         overflow.firstField = firstField;
/////////////////////////////////////////////////////////////////////////
1:         if (overflow == null) {
1:             overflow = new OverflowInfo();
1:         }
1:         overflow.overflowPage = overflowHandle.getPageNumber();
1:         overflow.overflowId = overflowHandle.getId();
1:         if (overflow == null) {
1:             overflow = new OverflowInfo();
1:         }
1:         this.status = (byte) (loadFromTarget.status | RECORD_OVERFLOW);
1:         overflow.firstField = loadFromTarget.overflow.firstField;
/////////////////////////////////////////////////////////////////////////
1: 			len += CompressedNumber.writeLong(out, overflow.overflowPage);
1: 			len += CompressedNumber.writeInt(out, overflow.overflowId);
1: 			len += CompressedNumber.writeInt(out, overflow.firstField);
/////////////////////////////////////////////////////////////////////////
1:         int s = in.read();
1:         if (s < 0) {
1:         }
1: 
1:         status = (byte) s;
1:             if ((s & ~RECORD_VALID_MASK) != 0)
1:                 	"Invalid status in StoredRecordHeader = " + s);
1:         if (hasOverflow() || hasFirstField()) {
1:             overflow = new OverflowInfo();
1:         } else {
1:             overflow = null;
1:         }
1: 
1: 			overflow.overflowPage = CompressedNumber.readLong(in);
1: 			overflow.overflowId   = CompressedNumber.readInt(in);
1: 			overflow.firstField = CompressedNumber.readInt(in);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             overflow.overflowPage = ((int_value << 8) | (data[offset] & 0xff));
/////////////////////////////////////////////////////////////////////////
1:             overflow.overflowPage =
/////////////////////////////////////////////////////////////////////////
1:             overflow.overflowPage =
/////////////////////////////////////////////////////////////////////////
1:             overflow.overflowId = value;
/////////////////////////////////////////////////////////////////////////
1:             overflow.overflowId =
1:                 (((value & 0x3f) << 8) | (data[offset] & 0xff));
1:             overflow.overflowId =
/////////////////////////////////////////////////////////////////////////
1:             overflow.firstField = value;
/////////////////////////////////////////////////////////////////////////
1:             overflow.firstField =
1:                 (((value & 0x3f) << 8) | (data[offset] & 0xff));
1:             overflow.firstField =
/////////////////////////////////////////////////////////////////////////
1:             overflow = null;
1:             overflow = new OverflowInfo();
/////////////////////////////////////////////////////////////////////////
1:             overflow = new OverflowInfo();
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:883a153
/////////////////////////////////////////////////////////////////////////
1:     A class StoredPage uses to cache record headers by passing instances
1:     to BasePage, and to write stored versions of record headers.
1:     Format
1:     <PRE>
1:     1 byte          - status
1:     compressed int  - record identifier
1:     compressed long - overflow page } only if hasOverflow() is true
1:     compressed int  - overflow id   }     "        "           "
1:     compressed int  - first field   } only if hasFirstField set - otherwise 0
1:     compressed int  - number of fields in this portion - only if hasOverflow()
1:                                 is false OR hasFirstField is true - otherwise 0
1:     </PRE>
/////////////////////////////////////////////////////////////////////////
1:      * RECORD_DELETED           - used to indicate the record has been deleted
1:      * RECORD_OVERFLOW          - used to indicate the record has been 
1:      * RECORD_HAS_FIRST_FIELD   - used to indicate that firstField is stored. 
/////////////////////////////////////////////////////////////////////////
1:     protected int   id;
/////////////////////////////////////////////////////////////////////////
1:     protected int numberFields;
1:     protected RecordHandle  handle;
/////////////////////////////////////////////////////////////////////////
1:     public StoredRecordHeader() 
1:     }
1:     public StoredRecordHeader(int id, int numberFields) 
1:         setId(id);
1:         setNumberFields(numberFields);
1:     }
1:     public StoredRecordHeader(
1:     }
1:     public StoredRecordHeader(StoredRecordHeader loadTargetFrom) 
1:         this.status         = loadTargetFrom.status;
1:         this.id             = loadTargetFrom.id;
1:         this.numberFields   = loadTargetFrom.numberFields;
1:         handle              = null;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     protected RecordHandle getHandle(
1:         if (handle == null)
1:             handle = new RecordId(pageId, id, current_slot);
1:         return handle;
1:     }
1:     public final int getId() 
1:         return id;
1:     }
1:     public int getNumberFields() 
1:         return numberFields;
1:     }
1:     public long getOverflowPage() 
0:         return overflow == null ? 0 : overflow.overflowPage;
1:     }
1:     public int getOverflowId() 
0:         return overflow == null ? 0 : overflow.overflowId;
1:     }
1:     public int getFirstField() 
0:         return overflow == null ? 0 : overflow.firstField;
1:     }
1:     public final boolean hasOverflow() 
1:         return ((status & RECORD_OVERFLOW) == RECORD_OVERFLOW);
1:     }
1:     protected final boolean hasFirstField() 
1:         return ((status & RECORD_HAS_FIRST_FIELD) == RECORD_HAS_FIRST_FIELD);
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public final boolean isDeleted() 
1:         return ((status & RECORD_DELETED) == RECORD_DELETED);
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * @return The length of the record header.
0:      * @exception  StandardException  Standard exception policy.
1:     public int size() 
/////////////////////////////////////////////////////////////////////////
0:             len += CompressedNumber.sizeLong(overflow.overflowPage);
0:             len += CompressedNumber.sizeInt(overflow.overflowId);
1:         }
1:         return len;
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * return   1, if delete status from not deleted to deleted
1:     public int setDeleted(boolean deleteTrue) 
1:         int retCode = 0;
1:         if (deleteTrue) 
1:             if (!isDeleted()) 
1:                 // setting the bit from not deleted to deleted
1:                 retCode = 1;
1:                 status |= RECORD_DELETED;
1:             }
1:         } 
1:             if (isDeleted()) 
1:                 // setting the bit from deleted to not deleted
1:                 retCode = -1;
1:                 status &= ~RECORD_DELETED;
1:             }
1:         }
1:         return(retCode);
1:     }
1:     public void setFirstField(int firstField) 
1:     }
1:     public final void setId(int id) 
1:         this.id = id;
1:     }
1:     public void setOverflowDetails(RecordHandle overflowHandle) 
1:     }
/////////////////////////////////////////////////////////////////////////
1:         this.id             = loadFromTarget.id;
1:         this.numberFields   = loadFromTarget.numberFields;
1:         handle              = null;
1:     public final void setNumberFields(int numberFields) 
1:         this.numberFields = numberFields;
1:     }
1:     public int write(OutputStream out) 
/////////////////////////////////////////////////////////////////////////
1:                 SanityManager.THROWASSERT(
1:                     "Invalid status in StoredRecordHeaader = " + status);
1:         int len = 1;
1:         out.write(status);
1:         len += CompressedNumber.writeInt(out, id);
1:         
1:         if (hasOverflow()) 
1:             // if overflow bit is set, then write the overflow pointer info.
0:             len += CompressedNumber.writeLong(out, overflow.overflowPage);
0:             len += CompressedNumber.writeInt(out, overflow.overflowId);
1:         }
1:         if (hasFirstField()) 
0:             len += CompressedNumber.writeInt(out, overflow.firstField);
1:         }
1:         // see read
1:         if (!hasOverflow() || hasFirstField())
1:             len += CompressedNumber.writeInt(out, numberFields);
1:         return len;
1:     }
1:     public void read(java.io.ObjectInput in) 
1:             throw new EOFException();
/////////////////////////////////////////////////////////////////////////
1:                 SanityManager.THROWASSERT(
0:                     "Invalid status in StoredRecordHeader = " + s);
1:         id = CompressedNumber.readInt(in);
/////////////////////////////////////////////////////////////////////////
1:         if (hasOverflow()) 
0:             overflow.overflowPage = CompressedNumber.readLong(in);
0:             overflow.overflowId   = CompressedNumber.readInt(in);
1:         } 
1:         if (hasFirstField()) 
0:             overflow.firstField = CompressedNumber.readInt(in);
1:         } 
1:     
1:         // In releases prior to 1.3 an overflow record was handled
1:         // by an overflow header pointing to a complete record on
1:         // another page. This header had the overflow bit set but not
1:         // the has first field bit. This header also did not have the
1:         // number of fields written out, but it can be seen as
1:         // a header with 0 fields and a first field of 0.
1:         if (!hasOverflow() || hasFirstField())
1:             numberFields = CompressedNumber.readInt(in);
1:         else
1:             numberFields = 0;
1:         handle = null;
1:     }
1:         int int_value = data[offset++];
/////////////////////////////////////////////////////////////////////////
1:         }
1:         else if ((int_value & 0x80) == 0)
1:         {
/////////////////////////////////////////////////////////////////////////
1:         } 
1:         {
/////////////////////////////////////////////////////////////////////////
1:         }
1:         int value = data[offset++];
/////////////////////////////////////////////////////////////////////////
1:         else if ((value & 0x80) == 0)
1:         {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         int value = data[offset++];
/////////////////////////////////////////////////////////////////////////
1:         else if ((value & 0x80) == 0)
1:         {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         int value = data[offset++];
1:         else if ((value & 0x80) == 0)
1:         {
1:         }
/////////////////////////////////////////////////////////////////////////
1:     private void read(
1:         int value = data[offset++];
1:         else if ((value & 0x80) == 0)
1:         {
1:         }
/////////////////////////////////////////////////////////////////////////
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public String toString()
1:     {
1:         if (SanityManager.DEBUG)
1:             String str = "recordHeader: Id=" + getId();
1:             
1:             str += "\n  isDeleted     = " + isDeleted();
1:             str += "\n  hasOverflow   = " + hasOverflow();
1:             str += "\n  hasFirstField = " + hasFirstField();
1:             str += "\n  numberFields  = " + getNumberFields();
1:             str += "\n  firstField    = " + getFirstField();
1:             str += "\n  overflowPage  = " + getOverflowPage();
1:             str += "\n  overflowId    = " + getOverflowId();
1:             str += "\n  header length = " + size();
1: 
1:             return str;
1:         else
1:         {
1:             return null;
1:         }
1:     }
commit:2f41733
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * maximum length for row containing just an overflow pointer.
1:      * <p>
1:      * The maximum stored length of a row that just contains an overflow pointer
1:      * is 17 bytes:
1:      *   stored sizeof(status byte)       :  1 +
1:      *   stored sizeof(record id)         :  4 +
1:      *   max stored size overflow page ptr:  8 +
1:      *   max stored size overflow record id: 4  
1:      **/
1:     public static final int MAX_OVERFLOW_ONLY_REC_SIZE = 
1:             1 +                                     // stored status byte
1:             CompressedNumber.MAX_INT_STORED_SIZE  + // max stored record id size
1:             CompressedNumber.MAX_LONG_STORED_SIZE + // max stored overflow page 
1:             CompressedNumber.MAX_INT_STORED_SIZE;   // max stored overflow id
1: 
/////////////////////////////////////////////////////////////////////////
0: 			str += "\n  header length = " + size();
commit:3f42a3e
/////////////////////////////////////////////////////////////////////////
1:      *                            also stores the overflow pointer to the next 
/////////////////////////////////////////////////////////////////////////
0: 		// another page. This header had the overflow bit set but not
commit:5314923
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return length on disk of the record id portion of the record header
1:      *
1:      * Record id is part of the record header and is stored in an internal
1:      * compressed format.  The length of this format depends on the value
1:      * of the record id.
1:      *
1:      * @return length of encoded record id on disk.
1:      **/
1:     public static final int getStoredSizeRecordId(int record_id)
1:     {
1:         return(CompressedNumber.sizeInt(record_id));
1:     }
commit:0ce6b77
/////////////////////////////////////////////////////////////////////////
0:      * RECORD_HAS_FIRST_FIELD	- used to indicate that firstField is stored. 
1:      *                            When RECORD_OVERFLOW and 
commit:20bc69f
/////////////////////////////////////////////////////////////////////////
1:      * Set the deleted state of the record.
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.data.StoredRecordHeader
1: 
0:    Copyright 2002, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:c6ad534
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: package org.apache.derby.impl.store.raw.data;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.store.raw.PageKey;
1: import org.apache.derby.iapi.store.raw.RecordHandle;
1: 
1: import java.io.IOException;
1: import java.io.EOFException;
1: 
0: import java.io.InputStream;
1: import java.io.OutputStream;
1: 
1: import org.apache.derby.iapi.services.io.CompressedNumber;
1: 
1: /**
0: 	A class StoredPage uses to cache record headers by passing instances
0: 	to BasePage, and to write stored versions of record headers.
1: 
0: 	Format
1: 
0: 	<PRE>
1: 
0: 	1 byte          - status
0: 	compressed int  - record identifier
1: 
0: 	compressed long - overflow page } only if hasOverflow() is true
0: 	compressed int  - overflow id   }     "        "           "
1: 
0: 	compressed int  - first field   } only if hasFirstField set - otherwise 0
1: 
0: 	compressed int  - number of fields in this portion - only if hasOverflow()
0: 								is false OR hasFirstField is true - otherwise 0
0: 	</PRE>
1: 
1: */
1: 
1: public final class StoredRecordHeader
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
1: 
1:     /**************************************************************************
1:      * Constants of the class
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Status bits for the record header:
1:      *
0:      * RECORD_INITIAL			- used when record header is first initialized
0:      * RECORD_DELETED			- used to indicate the record has been deleted
0:      * RECORD_OVERFLOW			- used to indicate the record has been 
1:      *                            overflowed, it will point to the overflow 
1:      *                            page and ID
0:      * RECORD_HAS_FIRST_FIELD	- used to indicate that firstField is stored 
0:      *                            will be stored.  When RECORD_OVERFLOW and 
1:      *                            RECORD_HAS_FIRST_FIELD both are set, part of 
1:      *                            record is on the page, the record header 
0:      *                            also stores the overflow point to the next 
1:      *                            part of the record.
1:      * RECORD_VALID_MASK        - A mask of valid bits that can be set 
1:      *                            currently, such that the following assert can
1:      *                            be made: 
0:      *                              ASSERT((status & ~RECORD_VALID_MASK) == 0))
1:      **/
0: 	public static final int RECORD_INITIAL =			0x00;
0: 	public static final int RECORD_DELETED =			0x01;
0: 	public static final int RECORD_OVERFLOW =			0x02;
0: 	public static final int RECORD_HAS_FIRST_FIELD =	0x04; 
0:     public static final int RECORD_VALID_MASK  =        0x0f;
1: 
1: 
1:     /**************************************************************************
1:      * Fields of the class
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Actual identifier of the record
1:      *
1:      * <BR> MT - Mutable
1:      **/
0: 	protected int   id;
1: 
1:     /**
1:      * Status of the record.
1:      *
1:      * See above for description of fields:
0:      *     RECORD_INITIAL
1:      *     RECORD_DELETED
1:      *     RECORD_OVERFLOW
1:      *     RECORD_HAS_FIRST_FIELD
1:      *     RECORD_VALID_MASK
1:      *
1:      * <BR> MT - Mutable - single thread required.
1:      **/
0: 	protected int status;
1: 
1:     /**
1:      * number of fields in the row.
1:      **/
0: 	protected int numberFields;
1: 
1:     /**
1:      * A record handle that can represent the record, may be null.
1:      **/
0: 	protected RecordHandle	handle;
1: 
1: 
1:     /**
0:      * If (hasOverflow()) then this is the id of the row on page overflowPage
0:      * where the next portion of the row can be found.  In this case there
0:      * are no "real" fields on this page.  This situation comes about if a
0:      * row has been updated such that the real first field no longer fits on
0:      * the head page.
1:      **/
0: 	protected int	overflowId;
1: 
1: 
1:     /**
0:      * If (hasOverflow()) then this is the page where where the next portion of
0:      * the row can be found.  In this case there are no "real" fields on this 
0:      * page.
1:      **/
0: 	protected long  overflowPage;
1: 
1:     /**
0:      * if (hasFirstField()) then this field is the number of the column in
0:      * the orginal row which is now stored as the first field in this row.  This
0:      * row is 2nd through N'th portion of a long row. 
1:      *
0:      * For example if a row has its first 3 fields on page 0 and its next 3
0:      * fields on page 1, then the record header of the row portion on page 1
0:      * will have hasFirstField() set to true, and the value would be 4, 
0:      * indicating that the 4th field of the row is stored as the 1st field of
0:      * the partial row portion stored on page 1.
1:      **/
0: 	protected int	firstField;
1: 
1: 
1:     /**************************************************************************
1:      * Constructors for This class:
1:      **************************************************************************
1:      */
0: 	public StoredRecordHeader() 
1:     {
1: 	}
1: 
0: 	public StoredRecordHeader(int id, int numberFields) 
1:     {
0: 		setId(id);
0: 		setNumberFields(numberFields);
1: 	}
1: 
0: 	public StoredRecordHeader(
1:     byte    data[],
1:     int     offset)
1:     {
1:         read(data, offset);
1: 	}
1: 
0: 	public StoredRecordHeader(StoredRecordHeader loadTargetFrom) 
1:     {
0: 		this.status         = loadTargetFrom.status;
0: 		this.id             = loadTargetFrom.id;
0: 		this.numberFields   = loadTargetFrom.numberFields;
0: 		handle              = null;
1: 
0: 		overflowId          = loadTargetFrom.overflowId;
0: 		overflowPage        = loadTargetFrom.overflowPage;
0: 		firstField          = loadTargetFrom.firstField;
1: 	}
1: 
1:     /**************************************************************************
1:      * Public Accessor "Get" Methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Get a record handle for the record.
1:      * <p>
1:      *
1:      * <BR> MT - single thread required
1:      **/
0: 	protected RecordHandle getHandle(
1:     PageKey pageId, 
1:     int current_slot) 
1:     {
0: 		if (handle == null)
0: 			handle = new RecordId(pageId, id, current_slot);
1: 
0: 		return handle;
1: 	}
1: 
1:     /**
1:      * Get the record identifier
1:      *
1:      * <BR> MT - thread safe
1:      **/
0: 	public final int getId() 
1:     {
0: 		return id;
1: 	}
1: 
0: 	public int getNumberFields() 
1:     {
0: 		return numberFields;
1: 	}
1: 
0: 	public long getOverflowPage() 
1:     {
0: 		return overflowPage;
1: 	}
1: 
0: 	public int getOverflowId() 
1:     {
0: 		return overflowId;
1: 	}
1: 
0: 	public int getFirstField() 
1:     {
0: 		return firstField;
1: 	}
1: 
0: 	public final boolean hasOverflow() 
1:     {
0: 		return ((status & RECORD_OVERFLOW) == RECORD_OVERFLOW);
1: 	}
1: 
0: 	protected final boolean hasFirstField() 
1:     {
0: 		return ((status & RECORD_HAS_FIRST_FIELD) == RECORD_HAS_FIRST_FIELD);
1: 	}
1: 
1:     /**
1:      * Get the deleted state of the record.
1:      * <p>
1:      *
1:      * <BR> MT - single thread required
1:      **/
0: 	public final boolean isDeleted() 
1:     {
0: 		return ((status & RECORD_DELETED) == RECORD_DELETED);
1: 	}
1: 
1: 
1:     /**
1:      * return the size of the record header.
1:      * <p>
1:      * Calculates the size of the record header, mostly used to allow a
1:      * reader to skip over the record header and position on the 1st field
1:      * of the record.
1:      * <p>
1:      * This low level routine is performance critical to processing lots of
1:      * rows, so calls to CompressNumber have been hand inlined.
1:      *
0: 	 * @return The length of the record header.
1:      *
0: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0: 	public int size() 
1:     {
1:         // account for length of fieldDataLength field stored as a compressed
1:         // int plus one byte for status.  
1:         //
1:         //    int len = CompressedNumber.sizeInt(id) + 1;
1:         int len = 
1:           (id <= CompressedNumber.MAX_COMPRESSED_INT_ONE_BYTE) ?
1:               2 : 
1:           (id <= CompressedNumber.MAX_COMPRESSED_INT_TWO_BYTES) ?
1:               3 : 5;
1: 
1:         if ((status & (RECORD_OVERFLOW | RECORD_HAS_FIRST_FIELD)) == 0)
1:         {
1:             // usual case, not a record overflow and does not have first field
1:             len += 
1:               (numberFields <= CompressedNumber.MAX_COMPRESSED_INT_ONE_BYTE) ?
1:                   1 : 
1:               (numberFields <= CompressedNumber.MAX_COMPRESSED_INT_TWO_BYTES) ?
1:                   2 : 4;
1:         }
1:         else if ((status & RECORD_OVERFLOW) == 0)
1:         {
1:             // not overflow, and has first field set.
1: 
0:             // account for size of the numberFields field + size fo the 
0:             // firstField field.
1:             //
0:             //     len += (CompressedNumber.sizeInt(numberFields) +
0:             //             CompressedNumber.sizeInt(firstField);
1:             //
1:             len += 
0:               ((numberFields <= CompressedNumber.MAX_COMPRESSED_INT_ONE_BYTE) ?
1:                   1 : 
1:                (numberFields <= CompressedNumber.MAX_COMPRESSED_INT_TWO_BYTES) ?
0:                   2 : 4) +
1: 
0:               ((firstField <= CompressedNumber.MAX_COMPRESSED_INT_ONE_BYTE) ?
1:                   1 : 
0:                (firstField <= CompressedNumber.MAX_COMPRESSED_INT_TWO_BYTES) ?
0:                   2 : 4);
1:         }
1:         else
1:         {
1:             // is an overflow field
1: 
0: 			len += CompressedNumber.sizeLong(overflowPage);
0: 			len += CompressedNumber.sizeInt(overflowId);
1: 
1:             if (hasFirstField())
1:             {
0:                 len += CompressedNumber.sizeInt(firstField);
1:                 len += CompressedNumber.sizeInt(numberFields);
1:             }
1: 		}
1: 
0: 		return len;
1: 	}
1: 
1:     /**************************************************************************
1:      * Public Accessor "Set" Methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     /**
0:      * Set the deleted state of the record
1:      * <p>
0:      * return	1, if delete status from not deleted to deleted
1:      * return  -1, if delete status from deleted to not deleted
1:      * return   0, if status unchanged.
1:      *
1:      * <BR> MT - single thread required
1:      **/
0: 	public int setDeleted(boolean deleteTrue) 
1:     {
1: 
0: 		int retCode = 0;
1: 
0: 		if (deleteTrue) 
1:         {
0: 			if (!isDeleted()) 
1:             {
0: 				// setting the bit from not deleted to deleted
0: 				retCode = 1;
0: 				status |= RECORD_DELETED;
1: 			}
1: 		} 
1:         else 
1:         {
0: 			if (isDeleted()) 
1:             {
0: 				// setting the bit from deleted to not deleted
0: 				retCode = -1;
0: 				status &= ~RECORD_DELETED;
1: 			}
1: 		}
1: 
0: 		return(retCode);
1: 	}
1: 
0: 	public void setFirstField(int firstField) 
1:     {
0: 		this.firstField = firstField;
1:         status |= RECORD_HAS_FIRST_FIELD;
1: 	}
1: 
0: 	public final void setId(int id) 
1:     {
0: 		this.id = id;
1: 	}
1: 
0: 	public void setOverflowDetails(RecordHandle overflowHandle) 
1:     {
0: 		this.overflowPage   = overflowHandle.getPageNumber();
0: 		this.overflowId     = overflowHandle.getId();
1: 	}
1: 
1:     public void setOverflowFields(StoredRecordHeader loadFromTarget)
1:     {
0: 		this.status         = (loadFromTarget.status | RECORD_OVERFLOW);
0: 		this.id             = loadFromTarget.id;
0: 		this.numberFields   = loadFromTarget.numberFields;
0:         this.firstField     = loadFromTarget.firstField;
0: 		handle              = null;
1:     }
1: 
1: 
0: 	public final void setNumberFields(int numberFields) 
1:     {
0: 		this.numberFields = numberFields;
1: 	}
1: 
1:     /**************************************************************************
1:      * Public Methods implmenting read/write of Storable Interface:
1:      **************************************************************************
1:      */
0: 	public int write(OutputStream out) 
1:         throws IOException 
1:     {
1:         // check consistency of the status field - this has caught
1:         // byte writing corruptions in StoredPage in the past.
1:         if (SanityManager.DEBUG)
1:         {
1:             if ((status & ~RECORD_VALID_MASK) != 0)
0:             	SanityManager.THROWASSERT(
0:                 	"Invalid status in StoredRecordHeaader = " + status);
1:         }
1: 
1:         // write status
0: 		int len = 1;
0: 		out.write(status);
1: 
1:         // write id
0: 		len += CompressedNumber.writeInt(out, id);
1: 		
1: 
1:         // write overflow information for overflow record headers
0: 		if (hasOverflow()) 
1:         {
0: 			// if overflow bit is set, then write the overflow pointer info.
0: 			len += CompressedNumber.writeLong(out, overflowPage);
0: 			len += CompressedNumber.writeInt(out, overflowId);
1: 		}
1: 
1:         // write first field info for long row parts
1: 		if (hasFirstField()) 
1:         {
0: 			len += CompressedNumber.writeInt(out, firstField);
1: 		}
1: 
1:         // write number of fields, except in the case of a record header
1:         // which is solely a pointer to another row portion.
1:         //
0: 		// see read
0: 		if (!hasOverflow() || hasFirstField())
0: 			len += CompressedNumber.writeInt(out, numberFields);
1: 
0: 		return len;
1: 	}
1: 
0: 	public void read(java.io.ObjectInput in) 
1:         throws IOException 
1:     {
1: 
1:         // read status
0: 		status = in.read();
0: 		if (status < 0)
0: 			throw new EOFException();
1: 
1:         // check consistency of the status field - this has caught
1:         // byte writing corruptions in StoredPage in the past.
1:         if (SanityManager.DEBUG)
1:         {
1:             if ((status & ~RECORD_VALID_MASK) != 0)
0:             	SanityManager.THROWASSERT(
0:                 	"Invalid status in StoredRecordHeader = " + status);
1:         }
1: 
1:         // read the record id
0: 		id = CompressedNumber.readInt(in);
1: 
1:         // initialize the overflow pointer based on status.
0: 		if (hasOverflow()) 
1:         {
0: 			overflowPage = CompressedNumber.readLong(in);
0: 			overflowId   = CompressedNumber.readInt(in);
1: 
1: 		} 
1:         else 
1:         {
0: 			overflowPage = 0;
0: 			overflowId   = 0;
1: 		}
1: 
1:         // initialize the 1st field overflow pointer based on status.
1: 		if (hasFirstField()) 
1:         {
0: 			firstField = CompressedNumber.readInt(in);
1: 		} 
1:         else 
1:         {
0: 			firstField = 0;
1: 		}
1: 	
0: 		// In releases prior to 1.3 an overflow record was handled
0: 		// by an overflow header pointing to a complete record on
0: 		// another page. This header had the has overflow bit set but not
0: 		// the has first field bit. This header also did not have the
0: 		// number of fields written out, but it can be seen as
0: 		// a header with 0 fields and a first field of 0.
0: 		if (!hasOverflow() || hasFirstField())
0: 			numberFields = CompressedNumber.readInt(in);
1: 		else
1: 			numberFields = 0;
1: 
1: 		handle = null;
1: 	}
1: 
0:     private int readId(
1:     byte[]  data,
1:     int     offset)
1:     {
0: 		int value = data[offset++];
1: 
1:         if ((value & ~0x3f) == 0)
1:         {
1:             // value stored in this byte.
1:             id = value;
1: 
1:             return(1);
1:         }
0: 		else if ((value & 0x80) == 0)
1: 		{
1:             // value is stored in 2 bytes.  only use low 6 bits from 1st byte.
1: 
0:             id = (((value & 0x3f) << 8) | (data[offset] & 0xff));
1: 
1:             return(2);
1: 		}
1:         else
1:         {
1:             // value is stored in 4 bytes.  only use low 7 bits from 1st byte.
1:             id = 
1:                 ((value          & 0x7f) << 24) |
1:                 ((data[offset++] & 0xff) << 16) |
1:                 ((data[offset++] & 0xff) <<  8) |
1:                 ((data[offset]   & 0xff)      );
1: 
1:             return(4);
1:         }
1:     }
1:     private int readOverFlowPage(
1:     byte[]  data,
1:     int     offset)
1:     {
0: 		int int_value = data[offset++];
1: 
1:         if ((int_value & ~0x3f) == 0)
1:         {
1:             // test for small case first - assuming this is usual case.
1:             // this is stored in 2 bytes.
1: 
0:             overflowPage = ((int_value << 8) | (data[offset] & 0xff));
1: 
1:             return(2);
1: 		}
0: 		else if ((int_value & 0x80) == 0)
1: 		{
1:             // value is stored in 4 bytes.  only use low 6 bits from 1st byte.
1: 
0:             overflowPage = 
1:                 ((int_value      & 0x3f) << 24) |
1:                 ((data[offset++] & 0xff) << 16) |
1:                 ((data[offset++] & 0xff) <<  8) |
1:                 ((data[offset]   & 0xff)      );
1: 
1:             return(4);
1: 
1: 		} 
1:         else
1: 		{
1:             // value is stored in 8 bytes.  only use low 6 bits from 1st byte.
0:             overflowPage = 
1:                 (((long) (int_value      & 0x7f)) << 56) |
1:                 (((long) (data[offset++] & 0xff)) << 48) |
1:                 (((long) (data[offset++] & 0xff)) << 40) |
1:                 (((long) (data[offset++] & 0xff)) << 32) |
1:                 (((long) (data[offset++] & 0xff)) << 24) |
1:                 (((long) (data[offset++] & 0xff)) << 16) |
1:                 (((long) (data[offset++] & 0xff)) <<  8) |
1:                 (((long) (data[offset]   & 0xff))      );
1: 
1:             return(8);
1: 		}
1:     }
1:     private int readOverFlowId(
1:     byte[]  data,
1:     int     offset)
1:     {
0: 		int value = data[offset++];
1: 
1:         if ((value & ~0x3f) == 0)
1:         {
1:             // length stored in this byte.
0:             overflowId = value;
1: 
1:             return(1);
1:         }
0: 		else if ((value & 0x80) == 0)
1: 		{
1:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
1: 
0:             overflowId = (((value & 0x3f) << 8) | (data[offset] & 0xff));
1: 
1:             return(2);
1: 		}
1:         else
1:         {
1:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
0:             overflowId = 
1:                 ((value          & 0x7f) << 24) |
1:                 ((data[offset++] & 0xff) << 16) |
1:                 ((data[offset++] & 0xff) <<  8) |
1:                 ((data[offset]   & 0xff)      );
1: 
1:             return(4);
1:         }
1:     }
1:     private int readFirstField(
1:     byte[]  data,
1:     int     offset)
1:     {
0: 		int value = data[offset++];
1: 
1:         if ((value & ~0x3f) == 0)
1:         {
1:             // length stored in this byte.
0:             firstField = value;
1: 
1:             return(1);
1:         }
0: 		else if ((value & 0x80) == 0)
1: 		{
1:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
1: 
0:             firstField = (((value & 0x3f) << 8) | (data[offset] & 0xff));
1: 
1:             return(2);
1: 		}
1:         else
1:         {
1:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
0:             firstField = 
1:                 ((value          & 0x7f) << 24) |
1:                 ((data[offset++] & 0xff) << 16) |
1:                 ((data[offset++] & 0xff) <<  8) |
1:                 ((data[offset]   & 0xff)      );
1: 
1:             return(4);
1:         }
1:     }
1:     private void readNumberFields(
1:     byte[]  data,
1:     int     offset)
1:     {
0: 		int value = data[offset++];
1: 
1:         if ((value & ~0x3f) == 0)
1:         {
1:             // length stored in this byte.
1:             numberFields = value;
1:         }
0: 		else if ((value & 0x80) == 0)
1: 		{
1:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
1: 
1:             numberFields = (((value & 0x3f) << 8) | (data[offset] & 0xff));
1: 		}
1:         else
1:         {
1:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
1:             numberFields = 
1:                 ((value          & 0x7f) << 24) |
1:                 ((data[offset++] & 0xff) << 16) |
1:                 ((data[offset++] & 0xff) <<  8) |
1:                 ((data[offset]   & 0xff)      );
1:         }
1:     }
1: 
1: 
0: 	private void read(
1:     byte[]  data,
1:     int     offset)
1:     {
1:         status = data[offset++];
1: 
0: 		int value = data[offset++];
1: 
1:         if ((value & ~0x3f) == 0)
1:         {
1:             // value stored in this byte.
1:             id = value;
1:         }
0: 		else if ((value & 0x80) == 0)
1: 		{
1:             // value is stored in 2 bytes.  only use low 6 bits from 1st byte.
1: 
1:             id = (((value & 0x3f) << 8) | (data[offset++] & 0xff));
1: 		}
1:         else
1:         {
1:             // value is stored in 4 bytes.  only use low 7 bits from 1st byte.
1:             id = 
1:                 ((value          & 0x7f) << 24) |
1:                 ((data[offset++] & 0xff) << 16) |
1:                 ((data[offset++] & 0xff) <<  8) |
1:                 ((data[offset++] & 0xff)      );
1:         }
1: 
1:         if ((status & (RECORD_OVERFLOW | RECORD_HAS_FIRST_FIELD)) == 0)
1:         {
1:             // usual case, not a record overflow and does not have first field
0: 			overflowPage = 0;
0: 			overflowId   = 0;
0:             firstField   = 0;
1: 
1:             readNumberFields(data, offset);
1:         }
1:         else if ((status & RECORD_OVERFLOW) == 0)
1:         {
1:             // not overflow, and has first field set.
0: 			overflowPage = 0;
0: 			overflowId   = 0;
1: 
1:             offset += readFirstField(data, offset);
1: 
1:             readNumberFields(data, offset);
1:         }
1:         else
1:         {
1:             // is an overflow field
1: 
1:             offset += readOverFlowPage(data, offset);
1:             offset += readOverFlowId(data, offset);
1: 
1:             if (hasFirstField())
1:             {
1:                 offset += readFirstField(data, offset);
1:                 readNumberFields(data, offset);
1:             }
1:             else
1:             {
0:                 firstField   = 0;
1:                 numberFields = 0;
1:             }
1: 		}
1: 
1:         handle = null;
1: 
1:         return;
1: 	}
1: 
1: 
0: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			String str = "recordHeader: Id=" + getId();
1: 			
0: 			str += "\n  isDeleted     = " + isDeleted();
0: 			str += "\n  hasOverflow   = " + hasOverflow();
0: 			str += "\n  hasFirstField = " + hasFirstField();
0: 			str += "\n  numberFields  = " + getNumberFields();
0: 			str += "\n  firstField    = " + getFirstField();
0: 			str += "\n  overflowPage  = " + getOverflowPage();
0: 			str += "\n  overflowId    = " + getOverflowId();
1: 
0: 			return str;
1: 		}
1: 		else
1:         {
0: 			return null;
1:         }
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: package org.apache.derby.impl.store.raw.data;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.store.raw.PageKey;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: 
0: import java.io.IOException;
0: import java.io.EOFException;
0: 
0: import java.io.InputStream;
0: import java.io.OutputStream;
0: 
0: import org.apache.derby.iapi.services.io.CompressedNumber;
0: 
0: /**
0: 	A class StoredPage uses to cache record headers by passing instances
0: 	to BasePage, and to write stored versions of record headers.
0: 
0: 	Format
0: 
0: 	<PRE>
0: 
0: 	1 byte          - status
0: 	compressed int  - record identifier
0: 
0: 	compressed long - overflow page } only if hasOverflow() is true
0: 	compressed int  - overflow id   }     "        "           "
0: 
0: 	compressed int  - first field   } only if hasFirstField set - otherwise 0
0: 
0: 	compressed int  - number of fields in this portion - only if hasOverflow()
0: 								is false OR hasFirstField is true - otherwise 0
0: 	</PRE>
0: 
0: */
0: 
0: public final class StoredRecordHeader
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
0: 
0:     /**************************************************************************
0:      * Constants of the class
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Status bits for the record header:
0:      *
0:      * RECORD_INITIAL			- used when record header is first initialized
0:      * RECORD_DELETED			- used to indicate the record has been deleted
0:      * RECORD_OVERFLOW			- used to indicate the record has been 
0:      *                            overflowed, it will point to the overflow 
0:      *                            page and ID
0:      * RECORD_HAS_FIRST_FIELD	- used to indicate that firstField is stored 
0:      *                            will be stored.  When RECORD_OVERFLOW and 
0:      *                            RECORD_HAS_FIRST_FIELD both are set, part of 
0:      *                            record is on the page, the record header 
0:      *                            also stores the overflow point to the next 
0:      *                            part of the record.
0:      * RECORD_VALID_MASK        - A mask of valid bits that can be set 
0:      *                            currently, such that the following assert can
0:      *                            be made: 
0:      *                              ASSERT((status & ~RECORD_VALID_MASK) == 0))
0:      **/
0: 	public static final int RECORD_INITIAL =			0x00;
0: 	public static final int RECORD_DELETED =			0x01;
0: 	public static final int RECORD_OVERFLOW =			0x02;
0: 	public static final int RECORD_HAS_FIRST_FIELD =	0x04; 
0:     public static final int RECORD_VALID_MASK  =        0x0f;
0: 
0: 
0:     /**************************************************************************
0:      * Fields of the class
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Actual identifier of the record
0:      *
0:      * <BR> MT - Mutable
0:      **/
0: 	protected int   id;
0: 
0:     /**
0:      * Status of the record.
0:      *
0:      * See above for description of fields:
0:      *     RECORD_INITIAL
0:      *     RECORD_DELETED
0:      *     RECORD_OVERFLOW
0:      *     RECORD_HAS_FIRST_FIELD
0:      *     RECORD_VALID_MASK
0:      *
0:      * <BR> MT - Mutable - single thread required.
0:      **/
0: 	protected int status;
0: 
0:     /**
0:      * number of fields in the row.
0:      **/
0: 	protected int numberFields;
0: 
0:     /**
0:      * A record handle that can represent the record, may be null.
0:      **/
0: 	protected RecordHandle	handle;
0: 
0: 
0:     /**
0:      * If (hasOverflow()) then this is the id of the row on page overflowPage
0:      * where the next portion of the row can be found.  In this case there
0:      * are no "real" fields on this page.  This situation comes about if a
0:      * row has been updated such that the real first field no longer fits on
0:      * the head page.
0:      **/
0: 	protected int	overflowId;
0: 
0: 
0:     /**
0:      * If (hasOverflow()) then this is the page where where the next portion of
0:      * the row can be found.  In this case there are no "real" fields on this 
0:      * page.
0:      **/
0: 	protected long  overflowPage;
0: 
0:     /**
0:      * if (hasFirstField()) then this field is the number of the column in
0:      * the orginal row which is now stored as the first field in this row.  This
0:      * row is 2nd through N'th portion of a long row. 
0:      *
0:      * For example if a row has its first 3 fields on page 0 and its next 3
0:      * fields on page 1, then the record header of the row portion on page 1
0:      * will have hasFirstField() set to true, and the value would be 4, 
0:      * indicating that the 4th field of the row is stored as the 1st field of
0:      * the partial row portion stored on page 1.
0:      **/
0: 	protected int	firstField;
0: 
0: 
0:     /**************************************************************************
0:      * Constructors for This class:
0:      **************************************************************************
0:      */
0: 	public StoredRecordHeader() 
0:     {
0: 	}
0: 
0: 	public StoredRecordHeader(int id, int numberFields) 
0:     {
0: 		setId(id);
0: 		setNumberFields(numberFields);
0: 	}
0: 
0: 	public StoredRecordHeader(
0:     byte    data[],
0:     int     offset)
0:     {
0:         read(data, offset);
0: 	}
0: 
0: 	public StoredRecordHeader(StoredRecordHeader loadTargetFrom) 
0:     {
0: 		this.status         = loadTargetFrom.status;
0: 		this.id             = loadTargetFrom.id;
0: 		this.numberFields   = loadTargetFrom.numberFields;
0: 		handle              = null;
0: 
0: 		overflowId          = loadTargetFrom.overflowId;
0: 		overflowPage        = loadTargetFrom.overflowPage;
0: 		firstField          = loadTargetFrom.firstField;
0: 	}
0: 
0:     /**************************************************************************
0:      * Public Accessor "Get" Methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Get a record handle for the record.
0:      * <p>
0:      *
0:      * <BR> MT - single thread required
0:      **/
0: 	protected RecordHandle getHandle(
0:     PageKey pageId, 
0:     int current_slot) 
0:     {
0: 		if (handle == null)
0: 			handle = new RecordId(pageId, id, current_slot);
0: 
0: 		return handle;
0: 	}
0: 
0:     /**
0:      * Get the record identifier
0:      *
0:      * <BR> MT - thread safe
0:      **/
0: 	public final int getId() 
0:     {
0: 		return id;
0: 	}
0: 
0: 	public int getNumberFields() 
0:     {
0: 		return numberFields;
0: 	}
0: 
0: 	public long getOverflowPage() 
0:     {
0: 		return overflowPage;
0: 	}
0: 
0: 	public int getOverflowId() 
0:     {
0: 		return overflowId;
0: 	}
0: 
0: 	public int getFirstField() 
0:     {
0: 		return firstField;
0: 	}
0: 
0: 	public final boolean hasOverflow() 
0:     {
0: 		return ((status & RECORD_OVERFLOW) == RECORD_OVERFLOW);
0: 	}
0: 
0: 	protected final boolean hasFirstField() 
0:     {
0: 		return ((status & RECORD_HAS_FIRST_FIELD) == RECORD_HAS_FIRST_FIELD);
0: 	}
0: 
0:     /**
0:      * Get the deleted state of the record.
0:      * <p>
0:      *
0:      * <BR> MT - single thread required
0:      **/
0: 	public final boolean isDeleted() 
0:     {
0: 		return ((status & RECORD_DELETED) == RECORD_DELETED);
0: 	}
0: 
0: 
0:     /**
0:      * return the size of the record header.
0:      * <p>
0:      * Calculates the size of the record header, mostly used to allow a
0:      * reader to skip over the record header and position on the 1st field
0:      * of the record.
0:      * <p>
0:      * This low level routine is performance critical to processing lots of
0:      * rows, so calls to CompressNumber have been hand inlined.
0:      *
0: 	 * @return The length of the record header.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public int size() 
0:     {
0:         // account for length of fieldDataLength field stored as a compressed
0:         // int plus one byte for status.  
0:         //
0:         //    int len = CompressedNumber.sizeInt(id) + 1;
0:         int len = 
0:           (id <= CompressedNumber.MAX_COMPRESSED_INT_ONE_BYTE) ?
0:               2 : 
0:           (id <= CompressedNumber.MAX_COMPRESSED_INT_TWO_BYTES) ?
0:               3 : 5;
0: 
0:         if ((status & (RECORD_OVERFLOW | RECORD_HAS_FIRST_FIELD)) == 0)
0:         {
0:             // usual case, not a record overflow and does not have first field
0:             len += 
0:               (numberFields <= CompressedNumber.MAX_COMPRESSED_INT_ONE_BYTE) ?
0:                   1 : 
0:               (numberFields <= CompressedNumber.MAX_COMPRESSED_INT_TWO_BYTES) ?
0:                   2 : 4;
0:         }
0:         else if ((status & RECORD_OVERFLOW) == 0)
0:         {
0:             // not overflow, and has first field set.
0: 
0:             // account for size of the numberFields field + size fo the 
0:             // firstField field.
0:             //
0:             //     len += (CompressedNumber.sizeInt(numberFields) +
0:             //             CompressedNumber.sizeInt(firstField);
0:             //
0:             len += 
0:               ((numberFields <= CompressedNumber.MAX_COMPRESSED_INT_ONE_BYTE) ?
0:                   1 : 
0:                (numberFields <= CompressedNumber.MAX_COMPRESSED_INT_TWO_BYTES) ?
0:                   2 : 4) +
0: 
0:               ((firstField <= CompressedNumber.MAX_COMPRESSED_INT_ONE_BYTE) ?
0:                   1 : 
0:                (firstField <= CompressedNumber.MAX_COMPRESSED_INT_TWO_BYTES) ?
0:                   2 : 4);
0:         }
0:         else
0:         {
0:             // is an overflow field
0: 
0: 			len += CompressedNumber.sizeLong(overflowPage);
0: 			len += CompressedNumber.sizeInt(overflowId);
0: 
0:             if (hasFirstField())
0:             {
0:                 len += CompressedNumber.sizeInt(firstField);
0:                 len += CompressedNumber.sizeInt(numberFields);
0:             }
0: 		}
0: 
0: 		return len;
0: 	}
0: 
0:     /**************************************************************************
0:      * Public Accessor "Set" Methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Set the deleted state of the record
0:      * <p>
0:      * return	1, if delete status from not deleted to deleted
0:      * return  -1, if delete status from deleted to not deleted
0:      * return   0, if status unchanged.
0:      *
0:      * <BR> MT - single thread required
0:      **/
0: 	public int setDeleted(boolean deleteTrue) 
0:     {
0: 
0: 		int retCode = 0;
0: 
0: 		if (deleteTrue) 
0:         {
0: 			if (!isDeleted()) 
0:             {
0: 				// setting the bit from not deleted to deleted
0: 				retCode = 1;
0: 				status |= RECORD_DELETED;
0: 			}
0: 		} 
0:         else 
0:         {
0: 			if (isDeleted()) 
0:             {
0: 				// setting the bit from deleted to not deleted
0: 				retCode = -1;
0: 				status &= ~RECORD_DELETED;
0: 			}
0: 		}
0: 
0: 		return(retCode);
0: 	}
0: 
0: 	public void setFirstField(int firstField) 
0:     {
0: 		this.firstField = firstField;
0:         status |= RECORD_HAS_FIRST_FIELD;
0: 	}
0: 
0: 	public final void setId(int id) 
0:     {
0: 		this.id = id;
0: 	}
0: 
0: 	public void setOverflowDetails(RecordHandle overflowHandle) 
0:     {
0: 		this.overflowPage   = overflowHandle.getPageNumber();
0: 		this.overflowId     = overflowHandle.getId();
0: 	}
0: 
0:     public void setOverflowFields(StoredRecordHeader loadFromTarget)
0:     {
0: 		this.status         = (loadFromTarget.status | RECORD_OVERFLOW);
0: 		this.id             = loadFromTarget.id;
0: 		this.numberFields   = loadFromTarget.numberFields;
0:         this.firstField     = loadFromTarget.firstField;
0: 		handle              = null;
0:     }
0: 
0: 
0: 	public final void setNumberFields(int numberFields) 
0:     {
0: 		this.numberFields = numberFields;
0: 	}
0: 
0:     /**************************************************************************
0:      * Public Methods implmenting read/write of Storable Interface:
0:      **************************************************************************
0:      */
0: 	public int write(OutputStream out) 
0:         throws IOException 
0:     {
0:         // check consistency of the status field - this has caught
0:         // byte writing corruptions in StoredPage in the past.
0:         if (SanityManager.DEBUG)
0:         {
0:             if ((status & ~RECORD_VALID_MASK) != 0)
0:             	SanityManager.THROWASSERT(
0:                 	"Invalid status in StoredRecordHeaader = " + status);
0:         }
0: 
0:         // write status
0: 		int len = 1;
0: 		out.write(status);
0: 
0:         // write id
0: 		len += CompressedNumber.writeInt(out, id);
0: 		
0: 
0:         // write overflow information for overflow record headers
0: 		if (hasOverflow()) 
0:         {
0: 			// if overflow bit is set, then write the overflow pointer info.
0: 			len += CompressedNumber.writeLong(out, overflowPage);
0: 			len += CompressedNumber.writeInt(out, overflowId);
0: 		}
0: 
0:         // write first field info for long row parts
0: 		if (hasFirstField()) 
0:         {
0: 			len += CompressedNumber.writeInt(out, firstField);
0: 		}
0: 
0:         // write number of fields, except in the case of a record header
0:         // which is solely a pointer to another row portion.
0:         //
0: 		// see read
0: 		if (!hasOverflow() || hasFirstField())
0: 			len += CompressedNumber.writeInt(out, numberFields);
0: 
0: 		return len;
0: 	}
0: 
0: 	public void read(java.io.ObjectInput in) 
0:         throws IOException 
0:     {
0: 
0:         // read status
0: 		status = in.read();
0: 		if (status < 0)
0: 			throw new EOFException();
0: 
0:         // check consistency of the status field - this has caught
0:         // byte writing corruptions in StoredPage in the past.
0:         if (SanityManager.DEBUG)
0:         {
0:             if ((status & ~RECORD_VALID_MASK) != 0)
0:             	SanityManager.THROWASSERT(
0:                 	"Invalid status in StoredRecordHeader = " + status);
0:         }
0: 
0:         // read the record id
0: 		id = CompressedNumber.readInt(in);
0: 
0:         // initialize the overflow pointer based on status.
0: 		if (hasOverflow()) 
0:         {
0: 			overflowPage = CompressedNumber.readLong(in);
0: 			overflowId   = CompressedNumber.readInt(in);
0: 
0: 		} 
0:         else 
0:         {
0: 			overflowPage = 0;
0: 			overflowId   = 0;
0: 		}
0: 
0:         // initialize the 1st field overflow pointer based on status.
0: 		if (hasFirstField()) 
0:         {
0: 			firstField = CompressedNumber.readInt(in);
0: 		} 
0:         else 
0:         {
0: 			firstField = 0;
0: 		}
0: 	
0: 		// In releases prior to 1.3 an overflow record was handled
0: 		// by an overflow header pointing to a complete record on
0: 		// another page. This header had the has overflow bit set but not
0: 		// the has first field bit. This header also did not have the
0: 		// number of fields written out, but it can be seen as
0: 		// a header with 0 fields and a first field of 0.
0: 		if (!hasOverflow() || hasFirstField())
0: 			numberFields = CompressedNumber.readInt(in);
0: 		else
0: 			numberFields = 0;
0: 
0: 		handle = null;
0: 	}
0: 
0:     private int readId(
0:     byte[]  data,
0:     int     offset)
0:     {
0: 		int value = data[offset++];
0: 
0:         if ((value & ~0x3f) == 0)
0:         {
0:             // value stored in this byte.
0:             id = value;
0: 
0:             return(1);
0:         }
0: 		else if ((value & 0x80) == 0)
0: 		{
0:             // value is stored in 2 bytes.  only use low 6 bits from 1st byte.
0: 
0:             id = (((value & 0x3f) << 8) | (data[offset] & 0xff));
0: 
0:             return(2);
0: 		}
0:         else
0:         {
0:             // value is stored in 4 bytes.  only use low 7 bits from 1st byte.
0:             id = 
0:                 ((value          & 0x7f) << 24) |
0:                 ((data[offset++] & 0xff) << 16) |
0:                 ((data[offset++] & 0xff) <<  8) |
0:                 ((data[offset]   & 0xff)      );
0: 
0:             return(4);
0:         }
0:     }
0:     private int readOverFlowPage(
0:     byte[]  data,
0:     int     offset)
0:     {
0: 		int int_value = data[offset++];
0: 
0:         if ((int_value & ~0x3f) == 0)
0:         {
0:             // test for small case first - assuming this is usual case.
0:             // this is stored in 2 bytes.
0: 
0:             overflowPage = ((int_value << 8) | (data[offset] & 0xff));
0: 
0:             return(2);
0: 		}
0: 		else if ((int_value & 0x80) == 0)
0: 		{
0:             // value is stored in 4 bytes.  only use low 6 bits from 1st byte.
0: 
0:             overflowPage = 
0:                 ((int_value      & 0x3f) << 24) |
0:                 ((data[offset++] & 0xff) << 16) |
0:                 ((data[offset++] & 0xff) <<  8) |
0:                 ((data[offset]   & 0xff)      );
0: 
0:             return(4);
0: 
0: 		} 
0:         else
0: 		{
0:             // value is stored in 8 bytes.  only use low 6 bits from 1st byte.
0:             overflowPage = 
0:                 (((long) (int_value      & 0x7f)) << 56) |
0:                 (((long) (data[offset++] & 0xff)) << 48) |
0:                 (((long) (data[offset++] & 0xff)) << 40) |
0:                 (((long) (data[offset++] & 0xff)) << 32) |
0:                 (((long) (data[offset++] & 0xff)) << 24) |
0:                 (((long) (data[offset++] & 0xff)) << 16) |
0:                 (((long) (data[offset++] & 0xff)) <<  8) |
0:                 (((long) (data[offset]   & 0xff))      );
0: 
0:             return(8);
0: 		}
0:     }
0:     private int readOverFlowId(
0:     byte[]  data,
0:     int     offset)
0:     {
0: 		int value = data[offset++];
0: 
0:         if ((value & ~0x3f) == 0)
0:         {
0:             // length stored in this byte.
0:             overflowId = value;
0: 
0:             return(1);
0:         }
0: 		else if ((value & 0x80) == 0)
0: 		{
0:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
0: 
0:             overflowId = (((value & 0x3f) << 8) | (data[offset] & 0xff));
0: 
0:             return(2);
0: 		}
0:         else
0:         {
0:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
0:             overflowId = 
0:                 ((value          & 0x7f) << 24) |
0:                 ((data[offset++] & 0xff) << 16) |
0:                 ((data[offset++] & 0xff) <<  8) |
0:                 ((data[offset]   & 0xff)      );
0: 
0:             return(4);
0:         }
0:     }
0:     private int readFirstField(
0:     byte[]  data,
0:     int     offset)
0:     {
0: 		int value = data[offset++];
0: 
0:         if ((value & ~0x3f) == 0)
0:         {
0:             // length stored in this byte.
0:             firstField = value;
0: 
0:             return(1);
0:         }
0: 		else if ((value & 0x80) == 0)
0: 		{
0:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
0: 
0:             firstField = (((value & 0x3f) << 8) | (data[offset] & 0xff));
0: 
0:             return(2);
0: 		}
0:         else
0:         {
0:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
0:             firstField = 
0:                 ((value          & 0x7f) << 24) |
0:                 ((data[offset++] & 0xff) << 16) |
0:                 ((data[offset++] & 0xff) <<  8) |
0:                 ((data[offset]   & 0xff)      );
0: 
0:             return(4);
0:         }
0:     }
0:     private void readNumberFields(
0:     byte[]  data,
0:     int     offset)
0:     {
0: 		int value = data[offset++];
0: 
0:         if ((value & ~0x3f) == 0)
0:         {
0:             // length stored in this byte.
0:             numberFields = value;
0:         }
0: 		else if ((value & 0x80) == 0)
0: 		{
0:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
0: 
0:             numberFields = (((value & 0x3f) << 8) | (data[offset] & 0xff));
0: 		}
0:         else
0:         {
0:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
0:             numberFields = 
0:                 ((value          & 0x7f) << 24) |
0:                 ((data[offset++] & 0xff) << 16) |
0:                 ((data[offset++] & 0xff) <<  8) |
0:                 ((data[offset]   & 0xff)      );
0:         }
0:     }
0: 
0: 
0: 	private void read(
0:     byte[]  data,
0:     int     offset)
0:     {
0:         status = data[offset++];
0: 
0: 		int value = data[offset++];
0: 
0:         if ((value & ~0x3f) == 0)
0:         {
0:             // value stored in this byte.
0:             id = value;
0:         }
0: 		else if ((value & 0x80) == 0)
0: 		{
0:             // value is stored in 2 bytes.  only use low 6 bits from 1st byte.
0: 
0:             id = (((value & 0x3f) << 8) | (data[offset++] & 0xff));
0: 		}
0:         else
0:         {
0:             // value is stored in 4 bytes.  only use low 7 bits from 1st byte.
0:             id = 
0:                 ((value          & 0x7f) << 24) |
0:                 ((data[offset++] & 0xff) << 16) |
0:                 ((data[offset++] & 0xff) <<  8) |
0:                 ((data[offset++] & 0xff)      );
0:         }
0: 
0:         if ((status & (RECORD_OVERFLOW | RECORD_HAS_FIRST_FIELD)) == 0)
0:         {
0:             // usual case, not a record overflow and does not have first field
0: 			overflowPage = 0;
0: 			overflowId   = 0;
0:             firstField   = 0;
0: 
0:             readNumberFields(data, offset);
0:         }
0:         else if ((status & RECORD_OVERFLOW) == 0)
0:         {
0:             // not overflow, and has first field set.
0: 			overflowPage = 0;
0: 			overflowId   = 0;
0: 
0:             offset += readFirstField(data, offset);
0: 
0:             readNumberFields(data, offset);
0:         }
0:         else
0:         {
0:             // is an overflow field
0: 
0:             offset += readOverFlowPage(data, offset);
0:             offset += readOverFlowId(data, offset);
0: 
0:             if (hasFirstField())
0:             {
0:                 offset += readFirstField(data, offset);
0:                 readNumberFields(data, offset);
0:             }
0:             else
0:             {
0:                 firstField   = 0;
0:                 numberFields = 0;
0:             }
0: 		}
0: 
0:         handle = null;
0: 
0:         return;
0: 	}
0: 
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			String str = "recordHeader: Id=" + getId();
0: 			
0: 			str += "\n  isDeleted     = " + isDeleted();
0: 			str += "\n  hasOverflow   = " + hasOverflow();
0: 			str += "\n  hasFirstField = " + hasFirstField();
0: 			str += "\n  numberFields  = " + getNumberFields();
0: 			str += "\n  firstField    = " + getFirstField();
0: 			str += "\n  overflowPage  = " + getOverflowPage();
0: 			str += "\n  overflowId    = " + getOverflowId();
0: 
0: 			return str;
0: 		}
0: 		else
0:         {
0: 			return null;
0:         }
0: 	}
0: }
============================================================================