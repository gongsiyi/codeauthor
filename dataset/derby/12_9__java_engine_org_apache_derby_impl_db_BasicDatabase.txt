3:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.db.BasicDatabase
1:345de35: 
1:2724c48:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2724c48:    contributor license agreements.  See the NOTICE file distributed with
1:2724c48:    this work for additional information regarding copyright ownership.
1:2724c48:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2724c48:    (the "License"); you may not use this file except in compliance with
1:2724c48:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
25:eac0369: 
5:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.db;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.PublicAPI;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.Property;
1:eac0369: import org.apache.derby.iapi.reference.EngineType;
1:eac0369: import org.apache.derby.iapi.util.DoubleProperties;
1:eac0369: import org.apache.derby.iapi.util.IdUtil;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.property.PropertyUtil;
1:eac0369: import org.apache.derby.iapi.services.loader.ClassFactory;
1:eac0369: import org.apache.derby.iapi.services.loader.JarReader;
1:eac0369: import org.apache.derby.iapi.services.context.ContextManager;
1:eac0369: import org.apache.derby.iapi.services.context.ContextService;
1:eac0369: import org.apache.derby.iapi.services.daemon.Serviceable;
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleControl;
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.db.Database;
1:eac0369: import org.apache.derby.iapi.db.DatabaseContext;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1:502ed2e: import org.apache.derby.iapi.store.raw.data.DataFactory;
1:eac0369: import org.apache.derby.iapi.types.DataValueFactory;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:502ed2e: import org.apache.derby.iapi.util.StringUtil;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.FileInfoDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:eac0369: 
2:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.sql.LanguageFactory;
1:eac0369: import org.apache.derby.iapi.store.access.AccessFactory;
1:eac0369: import org.apache.derby.iapi.store.access.FileResource;
1:eac0369: import org.apache.derby.iapi.services.property.PropertyFactory;
1:eac0369: import org.apache.derby.iapi.services.property.PropertySetCallback;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.jdbc.AuthenticationService;
1:eac0369: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1:c2a8161: import org.apache.derby.impl.sql.execute.JarUtil;
1:502ed2e: import org.apache.derby.iapi.services.io.FileUtil;
1:fb93460: import org.apache.derby.io.StorageFile;
1:502ed2e: import org.apache.derby.io.StorageFactory;
1:eac0369: import org.apache.derby.catalog.UUID;
1:49653be: 
1:1bac3f3: import org.apache.derby.iapi.store.replication.slave.SlaveFactory;
1:eac0369: 
1:502ed2e: import java.io.File;
1:502ed2e: import java.io.IOException;
1:eac0369: import java.io.Serializable;
1:502ed2e: import java.security.AccessController;
1:a0dbbd7: import java.security.PrivilegedAction;
1:502ed2e: import java.security.PrivilegedActionException;
1:502ed2e: import java.security.PrivilegedExceptionAction;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.util.Properties;
1:eac0369: import java.util.Dictionary;
1:eac0369: import java.util.Locale;
1:eac0369: import java.text.DateFormat;
1:eac0369: 
1:4841b0e: /**
1:eac0369:  * The Database interface provides control over the physical database
1:eac0369:  * (that is, the stored data and the files the data are stored in),
1:eac0369:  * connections to the database, operations on the database such as
1:eac0369:  * backup and recovery, and all other things that are associated
1:eac0369:  * with the database itself.
1:eac0369:  * <p>
1:eac0369:  * The Database interface does not provide control over things that are part of
1:eac0369:  * the Domain, such as users.
1:eac0369:  * <p>
1:eac0369:  * I'm not sure what this will hold in a real system, for now
1:eac0369:  * it simply provides connection-creation for us.  Perhaps when it boots,
1:eac0369:  * it creates the datadictionary object for the database, which all users
1:eac0369:  * will then interact with?
3:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: public class BasicDatabase implements ModuleControl, ModuleSupportable, PropertySetCallback, Database, JarReader
13:eac0369: {
1:836ab97: 	protected boolean	active;
1:eac0369: 	private AuthenticationService authenticationService;
1:eac0369: 	protected AccessFactory af;
1:eac0369: 	protected PropertyFactory pf;
1:eac0369: 	protected ClassFactory cfDB; // classFactory but only set when per-database
1:4841b0e:     /**
1:4841b0e:      * DataDictionary for this database.
1:4841b0e:      */
1:4841b0e:     private DataDictionary dd;
1:4841b0e:     
1:eac0369: 	protected LanguageConnectionFactory lcf;
1:eac0369: 	protected LanguageFactory lf;
1:eac0369: 	// hold resourceAdapter in an Object instead of a ResourceAdapter
1:eac0369: 	// so that XA class use can be isolated to XA modules.
1:eac0369: 	protected Object resourceAdapter;
1:eac0369: 	private Locale databaseLocale;
1:eac0369: 	private DateFormat dateFormat;
1:eac0369: 	private DateFormat timeFormat;
1:eac0369: 	private DateFormat timestampFormat;
1:eac0369: 	private UUID		myUUID;
1:eac0369: 
1:eac0369: 	protected boolean lastToBoot; // is this class last to boot
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * ModuleControl interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public boolean canSupport(Properties startParams) {
1:836ab97:         boolean supported =
1:836ab97:             Monitor.isDesiredCreateType(startParams, getEngineType());
1:836ab97: 
1:836ab97:         if (supported) {
1:836ab97:             String repliMode =
1:836ab97:                 startParams.getProperty(SlaveFactory.REPLICATION_MODE);
1:836ab97:             if (repliMode != null &&
1:836ab97:                 !repliMode.equals(SlaveFactory.SLAVE_PRE_MODE)) {
1:836ab97:                 supported = false;
1:836ab97:             }
1:836ab97:         }
1:54be3b4: 
1:836ab97:         return supported;
1:49653be: 	}
1:836ab97: 
1:eac0369: 	public void boot(boolean create, Properties startParams)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:49653be: 
1:56c1dc2: 		ModuleFactory monitor = getMonitor();
1:eac0369: 		if (create)
1:eac0369: 		{
1:eac0369: 			if (startParams.getProperty(Property.CREATE_WITH_NO_LOG) == null)
1:eac0369: 				startParams.put(Property.CREATE_WITH_NO_LOG, "true");
1:49653be: 
1:722a889: 			String localeID = 
1:722a889:                 startParams.getProperty(
1:722a889:                     org.apache.derby.iapi.reference.Attribute.TERRITORY);
1:eac0369: 
1:eac0369: 			if (localeID == null) {
1:eac0369: 				localeID = Locale.getDefault().toString();
1:49653be: 			}
1:eac0369: 			databaseLocale = monitor.setLocale(startParams, localeID);
1:eac0369: 
2:eac0369: 		} else {
1:eac0369: 			databaseLocale = monitor.getLocale(this);
21:eac0369: 		}
1:9067662: 		setLocale(databaseLocale);      
1:eac0369: 
1:eac0369: 		// boot the validation needed to do property validation, now property
1:eac0369: 		// validation is separated from AccessFactory, therefore from store
1:eac0369: 		bootValidation(create, startParams);
1:33dab75: 		
1:2ca9dc6: 		// boot the type factory before store to ensure any dynamically
1:722a889: 		// registered types (DECIMAL) are there before logical undo recovery 
1:722a889:         // might need them.
1:722a889: 		DataValueFactory dvf = (DataValueFactory) 
1:56c1dc2:             bootServiceModule(
1:722a889:                 create, 
1:722a889:                 this,
1:722a889: 				org.apache.derby.iapi.reference.ClassName.DataValueFactory, 
1:722a889:                 startParams);
1:eac0369: 
1:eac0369: 		bootStore(create, startParams);
1:eac0369: 
1:eac0369: 		// create a database ID if one doesn't already exist
1:eac0369: 		myUUID = makeDatabaseID(create, startParams);
1:eac0369: 
1:eac0369: 
1:2fa8526:         // Add the database properties read from disk (not stored
1:2fa8526:         // in service.properties) into the set seen by booting modules.
1:2fa8526: 		Properties allParams =
1:2fa8526:             new DoubleProperties(getAllDatabaseProperties(), startParams);
1:eac0369: 
1:eac0369: 		if (pf != null)
1:eac0369: 			pf.addPropertySetNotification(this);
1:eac0369: 
1:eac0369: 			// Boot the ClassFactory, will be per-database or per-system.
1:eac0369: 			// reget the tc in case someone inadverdently destroyed it 
1:eac0369: 		bootClassFactory(create, allParams);
1:4841b0e:         
1:4841b0e:         dd = (DataDictionary)
1:56c1dc2:             bootServiceModule(create, this,
1:2fa8526:                     DataDictionary.MODULE, allParams);
1:eac0369: 
1:722a889: 		lcf = (LanguageConnectionFactory) 
1:56c1dc2:             bootServiceModule(
1:722a889:                 create, this, LanguageConnectionFactory.MODULE, allParams);
1:eac0369: 
1:722a889: 		lf = (LanguageFactory) 
1:56c1dc2:             bootServiceModule(
1:722a889:                 create, this, LanguageFactory.MODULE, allParams);
1:eac0369: 
1:2fa8526: 		bootResourceAdapter(create, allParams);
1:eac0369: 
1:eac0369: 
1:eac0369: 		// may also want to set up a check that we are a singleton,
1:eac0369: 		// or that there isn't already a database object in the system
1:eac0369: 		// for the same database?
1:eac0369: 
1:eac0369: 
1:eac0369: 		//
1:eac0369: 		// We boot the authentication service. There should at least be one
1:eac0369: 		// per database (even if authentication is turned off) .
1:eac0369: 		//
1:eac0369: 		authenticationService = bootAuthenticationService(create, allParams);
1:eac0369: 		if (SanityManager.DEBUG) {
1:722a889: 			SanityManager.ASSERT(
1:722a889:                 authenticationService != null,
1:eac0369:                 "Failed to set the Authentication service for the database");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Lastly, let store knows that database creation is done and turn
1:eac0369: 		// on logging
1:eac0369: 		if (create && lastToBoot &&
1:eac0369: 			(startParams.getProperty(Property.CREATE_WITH_NO_LOG) != null))
1:eac0369: 		{
1:eac0369: 			createFinished();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		active = true;
1:eac0369: 
1:7916398:         // Create an index statistics update daemon.
1:7916398:         if (dd.doCreateIndexStatsRefresher()) {
1:7916398:             dd.createIndexStatsRefresher(this, allParams.getProperty(
1:7916398:                         Property.PROPERTY_RUNTIME_PREFIX + "serviceDirectory"));
1:7916398:         }
1:7916398:     }
1:eac0369: 
1:eac0369: 	public void stop() {
1:8f87469:         // The data dictionary is not available if this database has the
1:8f87469:         // role as an active replication slave database.
1:8f87469:         if (dd != null) {
1:b023843:             try {
1:8f87469:                 // on orderly shutdown, try not to leak unused numbers from
1:8f87469:                 // the sequence generators.
1:b023843:                 dd.clearSequenceCaches();
1:8f87469:             } catch (StandardException se) {
1:8f87469:                 se.printStackTrace(Monitor.getStream().getPrintWriter());
1:b023843:             }
1:b023843:         }
1:eac0369: 		active = false;
1:8f87469: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods related to  ModuleControl
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Database interface
1:eac0369:  	 */
1:eac0369: 
1:502ed2e: 	/**
1:dcd3fec:      * Return the engine type that this Database implementation
1:dcd3fec:      * supports.
1:dcd3fec:      * This implementation supports the standard database.
1:eac0369: 	  */
1:dcd3fec: 	public int getEngineType() {
1:dcd3fec:         return EngineType.STANDALONE_DB;
1:dcd3fec:     }
1:eac0369: 
1:eac0369: 	public boolean isReadOnly()
1:502ed2e: 	{
1:eac0369: 		//
1:eac0369: 		//Notice if no full users?
1:eac0369: 		//RESOLVE: (Make access factory check?)
1:eac0369: 		return af.isReadOnly();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public LanguageConnectionContext setupConnection(ContextManager cm, String user, String drdaID, String dbname)
1:eac0369: 		throws StandardException {
1:49653be: 
1:eac0369: 		TransactionController tc = getConnectionTransaction(cm);
1:eac0369: 
1:eac0369: 		cm.setLocaleFinder(this);
1:eac0369: 		pushDbContext(cm);
1:eac0369: 
1:eac0369: 		// push a database shutdown context
1:eac0369: 		// we also need to push a language connection context.
1:eac0369: 		LanguageConnectionContext lctx = lcf.newLanguageConnectionContext(cm, tc, lf, this, user, drdaID, dbname);
1:eac0369: 
1:eac0369: 		// push the context that defines our class factory
1:eac0369: 		pushClassFactoryContext(cm, lcf.getClassFactory());
1:eac0369: 
1:eac0369: 		// we also need to push an execution context.
1:eac0369: 		ExecutionFactory ef = lcf.getExecutionFactory();
1:eac0369: 
1:eac0369: 		ef.newExecutionContext(cm);
1:eac0369: 		//
1:eac0369: 		//Initialize our language connection context. Note: This is
1:eac0369: 		//a bit of a hack. Unfortunately, we can't initialize this
1:eac0369: 		//when we push it. We first must push a few more contexts. 
1:9ac3a76: 		lctx.initialize();		
1:eac0369: 
1:eac0369: 		// Need to commit this to release locks gotten in initialize.  
1:eac0369: 		// Commit it but make sure transaction not have any updates. 
1:eac0369: 		lctx.internalCommitNoSync(
1:eac0369: 			TransactionController.RELEASE_LOCKS |
1:eac0369: 			TransactionController.READONLY_TRANSACTION_INITIALIZATION);
1:eac0369: 
1:eac0369: 		return lctx;
1:4841b0e: 
1:eac0369: 	}
1:eac0369:     
1:54be3b4:     /**
1:4841b0e:      * Return the DataDictionary for this database, set up at boot time.
1:4841b0e:      */
1:4841b0e:     public final DataDictionary getDataDictionary()
1:502ed2e:     {
1:4841b0e:         return dd;
1:4841b0e:     }
1:eac0369: 
1:eac0369: 	public void pushDbContext(ContextManager cm)
1:b023843: 	{
1:eac0369: 		/* We cache the locale in the DatabaseContext
1:eac0369: 		 * so that the Datatypes can get to it easily.
1:eac0369: 		 */
1:eac0369: 		DatabaseContext dc = new DatabaseContextImpl(cm, this);
1:eac0369: 	}
1:eac0369: 
1:696377a: 	public AuthenticationService getAuthenticationService()
1:696377a: 		throws StandardException{
1:eac0369: 
1:eac0369: 		// Expected to find one - Sanity check being done at
1:eac0369: 		// DB boot-up.
1:eac0369: 
1:eac0369: 		// We should have a Authentication Service
1:eac0369: 		//
3:eac0369: 		if (SanityManager.DEBUG)
1:4841b0e: 		{
1:eac0369: 			SanityManager.ASSERT(this.authenticationService != null, 
1:eac0369: 				"Unexpected - There is no valid authentication service for the database!");
1:eac0369: 		}
1:eac0369: 		return this.authenticationService;
1:eac0369: 	}
1:eac0369: 
1:4aeada8:     /**
1:4aeada8:      * Start the replication master role for this database
1:964abfa:      * @param dbmaster The master database that is being replicated.
1:4aeada8:      * @param host The hostname for the slave
1:4aeada8:      * @param port The port the slave is listening on
1:4aeada8:      * @param replicationMode The type of replication contract.
1:4aeada8:      * Currently only asynchronous replication is supported, but
1:4aeada8:      * 1-safe/2-safe/very-safe modes may be added later.
1:4aeada8:      * @exception SQLException Thrown on error
1:4aeada8:      */
1:964abfa:     public void startReplicationMaster(String dbmaster, String host, int port,
1:4aeada8:                                        String replicationMode)
1:4aeada8:         throws SQLException {
1:8f87469:         try {
1:964abfa:             af.startReplicationMaster(dbmaster, host, port, replicationMode);
1:4aeada8:         } catch (StandardException se) {
1:4aeada8:             throw PublicAPI.wrapStandardException(se);
1:4aeada8:         }
1:4aeada8:     }
1:b9c57d5:     
1:b9c57d5:     /**
1:54be3b4:      * Stop the replication master role for this database.
1:54be3b4:      * 
1:54be3b4:      * @exception SQLException Thrown on error
1:54be3b4:      */
1:54be3b4:     public void stopReplicationMaster()  throws SQLException {
1:fd20d6b:         try {
1:54be3b4:             af.stopReplicationMaster();
1:54be3b4:         } catch (StandardException se) {
1:54be3b4:             throw PublicAPI.wrapStandardException(se);
1:54be3b4:         }
1:54be3b4:     }
1:4aeada8:     
1:2fa8526:     /**
1:b9c57d5:      * Only a SlaveDatabase can be in replication slave mode. Always 
1:b9c57d5:      * throws an exception
1:b9c57d5:      * 
1:b9c57d5:      * @exception SQLException Always thrown because BasicDatabase cannot 
1:b9c57d5:      * be in replication slave mode
1:b9c57d5:      */
1:b9c57d5:     public void stopReplicationSlave() throws SQLException {
1:b9c57d5:         StandardException se = StandardException.
1:b9c57d5:             newException(SQLState.REPLICATION_NOT_IN_SLAVE_MODE);
1:fd20d6b:         throw PublicAPI.wrapStandardException(se);
1:fd20d6b:     }
1:fd20d6b:     
1:9e88b9d:     public boolean isInSlaveMode() {
1:9e88b9d:         return false;
1:9e88b9d:     }
1:9e88b9d:     
1:fd20d6b:     /**
1:869c85a:      * @see org.apache.derby.iapi.db.Database#failover(String)
1:fd20d6b:      */
1:5a6acbf:     public void failover(String dbname) throws StandardException {
1:5a6acbf:         af.failover(dbname);
1:fd20d6b:     }
1:eac0369: 
1:eac0369: 	public void freeze() throws SQLException
1:eac0369: 	{
1:54be3b4: 		try {
1:eac0369: 			af.freeze();
1:fd20d6b: 		} catch (StandardException se) {
1:b9c57d5: 			throw PublicAPI.wrapStandardException(se);
1:b9c57d5: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void unfreeze() throws SQLException
1:eac0369: 	{
1:4aeada8: 		try {
1:eac0369: 			af.unfreeze();
4:eac0369: 		} catch (StandardException se) {
5:eac0369: 			throw PublicAPI.wrapStandardException(se);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:fbb8866:     public void backup(String backupDir, boolean wait) 
1:eac0369:         throws SQLException
1:eac0369:     {
6:eac0369: 		try {
1:fbb8866: 			af.backup(backupDir, wait);
1:502ed2e:             if ( luceneLoaded() )
1:502ed2e:             {
1:502ed2e:                 backupLucene( backupDir );
1:502ed2e:             }
1:eac0369: 		} catch (StandardException se) {
1:eac0369: 			throw PublicAPI.wrapStandardException(se);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:402725c:     public void backupAndEnableLogArchiveMode(String  backupDir, 
1:402725c:                                               boolean deleteOnlineArchivedLogFiles,
1:402725c:                                               boolean wait)
1:eac0369:         throws SQLException
1:eac0369: 	{
1:eac0369: 		try {
1:fbb8866: 			af.backupAndEnableLogArchiveMode(backupDir, 
1:fbb8866:                                              deleteOnlineArchivedLogFiles,
1:fbb8866:                                              wait); 
1:502ed2e:             if ( luceneLoaded() )
1:502ed2e:             {
1:502ed2e:                 backupLucene( backupDir );
1:502ed2e:             }
1:eac0369: 		} catch (StandardException se) {
1:eac0369: 			throw PublicAPI.wrapStandardException(se);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	
1:eac0369: 	public void disableLogArchiveMode(boolean deleteOnlineArchivedLogFiles)
1:eac0369: 		throws SQLException
1:eac0369: 	{
1:eac0369: 		try{
1:eac0369: 			af.disableLogArchiveMode(deleteOnlineArchivedLogFiles);
1:eac0369: 		}catch (StandardException se) {
1:eac0369: 			throw PublicAPI.wrapStandardException(se);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public void	checkpoint() throws SQLException
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			af.checkpoint();
1:eac0369: 		} catch (StandardException se) {
1:eac0369: 			throw PublicAPI.wrapStandardException(se);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* Methods from org.apache.derby.database.Database */
1:eac0369: 	public Locale getLocale() {
1:eac0369: 		return databaseLocale;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
3:eac0369: 	/**
1:eac0369: 		Return the UUID of this database.
1:e24d8ef:         @deprecated
1:eac0369: 	*/
1:eac0369: 	public final UUID getId() {
1:eac0369: 		return myUUID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* LocaleFinder methods */
1:eac0369: 
2:eac0369: 	/** @exception StandardException	Thrown on error */
1:eac0369: 	public Locale getCurrentLocale() throws StandardException {
1:eac0369: 		if (databaseLocale != null)
1:eac0369: 			return databaseLocale;
2:eac0369: 		throw noLocale();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @exception StandardException	Thrown on error */
1:eac0369: 	public DateFormat getDateFormat() throws StandardException {
2:eac0369: 		if (databaseLocale != null) {
1:eac0369: 			if (dateFormat == null) {
1:eac0369: 				dateFormat = DateFormat.getDateInstance(DateFormat.LONG,
1:eac0369: 																databaseLocale);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return dateFormat;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		throw noLocale();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @exception StandardException	Thrown on error */
1:eac0369: 	public DateFormat getTimeFormat() throws StandardException {
1:eac0369: 		if (databaseLocale != null) {
1:eac0369: 			if (timeFormat == null) {
1:eac0369: 				timeFormat = DateFormat.getTimeInstance(DateFormat.LONG,
1:eac0369: 																databaseLocale);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return timeFormat;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		throw noLocale();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @exception StandardException	Thrown on error */
1:eac0369: 	public DateFormat getTimestampFormat() throws StandardException {
1:eac0369: 		if (databaseLocale != null) {
1:eac0369: 			if (timestampFormat == null) {
1:eac0369: 				timestampFormat = DateFormat.getDateTimeInstance(
1:eac0369: 															DateFormat.LONG,
1:eac0369: 															DateFormat.LONG,
1:eac0369: 															databaseLocale);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return timestampFormat;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		throw noLocale();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private static StandardException noLocale() {
1:eac0369: 		return StandardException.newException(SQLState.NO_LOCALE);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setLocale(Locale locale) {
1:eac0369: 		databaseLocale = locale;
1:eac0369: 
1:eac0369: 		dateFormat = null;
1:eac0369: 		timeFormat = null;
1:eac0369: 		timestampFormat = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Is the database active (open).
1:eac0369: 	*/
1:eac0369: 	public boolean isActive() {
1:eac0369: 		return active;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * class interface
1:eac0369: 	 */
1:eac0369: 	public BasicDatabase() {
1:eac0369: 		lastToBoot = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	protected	UUID	makeDatabaseID(boolean create, Properties startParams)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		
1:eac0369: 		TransactionController tc = af.getTransaction(
1:a0dbbd7: 				getContextService().getCurrentContextManager());
1:eac0369: 
1:eac0369: 		String  upgradeID = null;
1:eac0369: 		UUID	databaseID;
1:eac0369: 
1:eac0369: 		if ((databaseID = (UUID) tc.getProperty(DataDictionary.DATABASE_ID)) == null) {
1:eac0369: 
1:eac0369: 			// no property defined in the Transaction set
1:eac0369: 			// this could be an upgrade, see if it's stored in the service set
1:eac0369: 
1:56c1dc2: 			UUIDFactory	uuidFactory  = getMonitor().getUUIDFactory();
1:eac0369: 
1:eac0369: 			
1:eac0369: 			upgradeID = startParams.getProperty(DataDictionary.DATABASE_ID);
1:eac0369: 			if (upgradeID == null )
1:eac0369: 			{
1:eac0369: 				// just create one
1:eac0369: 				databaseID = uuidFactory.createUUID();
1:eac0369: 			} else {
1:eac0369: 				databaseID = uuidFactory.recreateUUID(upgradeID);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			tc.setProperty(DataDictionary.DATABASE_ID, databaseID, true);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Remove the database identifier from the service.properties
1:eac0369: 		// file only if we upgraded it to be stored in the transactional
1:eac0369: 		// property set.
1:eac0369: 		if (upgradeID != null)
1:eac0369: 			startParams.remove(DataDictionary.DATABASE_ID);
1:eac0369: 
1:eac0369: 		tc.commit();
1:eac0369: 		tc.destroy();
1:eac0369: 
1:eac0369: 		return databaseID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Return an Object instead of a ResourceAdapter
1:eac0369: 	** so that XA classes are only used where needed;
1:eac0369: 	** caller must cast to ResourceAdapter.
1:eac0369: 	*/
1:eac0369: 	public Object getResourceAdapter()
1:eac0369: 	{
1:eac0369: 		return resourceAdapter;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of PropertySetCallback
1:eac0369: 	*/
1:eac0369: 	public void init(boolean dbOnly, Dictionary p) {
1:eac0369: 		// not called yet ...
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see PropertySetCallback#validate
1:eac0369: 	  @exception StandardException Thrown on error.
1:eac0369: 	*/
1:eac0369: 	public boolean validate(String key,
1:eac0369: 						 Serializable value,
1:eac0369: 						 Dictionary p)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		//
1:eac0369: 		//Disallow setting static creation time only configuration properties
1:eac0369: 	    if (key.equals(EngineType.PROPERTY))
1:eac0369: 			throw StandardException.newException(SQLState.PROPERTY_UNSUPPORTED_CHANGE, key, value);
1:eac0369: 	
1:eac0369: 		// only interested in the classpath
1:eac0369: 		if (!key.equals(Property.DATABASE_CLASSPATH)) return false;
1:eac0369: 
1:eac0369: 		String newClasspath = (String) value;
1:eac0369: 		String[][] dbcp = null; //The parsed dbclasspath
1:eac0369: 
1:eac0369: 		if (newClasspath != null) {
1:eac0369: 			// parse it when it is set to ensure only valid values
1:eac0369: 			// are written to the actual conglomerate.
1:9067662: 			dbcp = IdUtil.parseDbClassPath(newClasspath);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		//
1:eac0369: 		//Verify that all jar files on the database classpath are in the data dictionary.
1:eac0369: 		if (dbcp != null)
1:eac0369: 		{
1:eac0369: 			for (int ix=0;ix<dbcp.length;ix++)
1:eac0369: 			{
1:eac0369: 				SchemaDescriptor sd = dd.getSchemaDescriptor(dbcp[ix][IdUtil.DBCP_SCHEMA_NAME], null, false);
1:eac0369: 
1:eac0369:                 FileInfoDescriptor fid = null;	
1:eac0369: 				if (sd != null) 
1:eac0369: 					fid = dd.getFileInfoDescriptor(sd,dbcp[ix][IdUtil.DBCP_SQL_JAR_NAME]);			
1:eac0369: 
1:eac0369: 				if (fid == null){
1:eac0369: 					throw StandardException.newException(SQLState.LANG_DB_CLASS_PATH_HAS_MISSING_JAR						, IdUtil.mkQualifiedName(dbcp[ix]));
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	  @see PropertySetCallback#apply
1:eac0369: 	  @exception StandardException Thrown on error.
1:eac0369: 	*/
1:eac0369: 	public Serviceable apply(String key, Serializable value, Dictionary p)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		// only interested in the classpath
1:eac0369: 		if (!key.equals(Property.DATABASE_CLASSPATH)) return null;
1:eac0369: 
1:eac0369: 		// only do the change dynamically if we are already
1:eac0369: 		// a per-database classapath.
1:eac0369: 		if (cfDB != null) {
1:eac0369: 
1:eac0369: 			//
1:eac0369: 			// Invalidate stored plans.
1:4841b0e:             getDataDictionary().invalidateAllSPSPlans();
1:eac0369: 		
1:eac0369: 			String newClasspath = (String) value;
1:eac0369: 			if (newClasspath == null) newClasspath = "";
1:eac0369: 			cfDB.notifyModifyClasspath(newClasspath);
1:eac0369: 		}
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	  @see PropertySetCallback#map
1:eac0369: 	*/
1:eac0369: 	public Serializable map(String key,Serializable value,Dictionary p)
1:eac0369: 	{
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * methods specific to this class 
1:eac0369: 	 */
1:eac0369: 	protected void createFinished() throws StandardException
1:eac0369: 	{
1:eac0369: 		// find the access factory and tell it that database creation has
1:eac0369: 		// finished
1:eac0369: 		af.createFinished();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected String getClasspath(Properties startParams) {
1:eac0369: 		String cp = PropertyUtil.getPropertyFromSet(startParams, Property.DATABASE_CLASSPATH);
1:eac0369: 		if (cp == null)
1:eac0369: 			cp = PropertyUtil.getSystemProperty(Property.DATABASE_CLASSPATH, "");
1:eac0369: 		return cp;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	protected void bootClassFactory(boolean create,
1:eac0369: 								  Properties startParams) 
1:eac0369: 		 throws StandardException
1:eac0369: 	{ 
1:eac0369: 			String classpath = getClasspath(startParams);
1:eac0369: 
1:eac0369: 			// parse the class path and allow 2 part names.
1:9067662: 			IdUtil.parseDbClassPath(classpath);
1:eac0369: 
1:eac0369: 			startParams.put(Property.BOOT_DB_CLASSPATH, classpath);
1:56c1dc2: 			cfDB = (ClassFactory) bootServiceModule(create, this,
1:eac0369: 					org.apache.derby.iapi.reference.Module.ClassFactory, startParams);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods to allow sub-classes to offer alternate implementations.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	protected TransactionController getConnectionTransaction(ContextManager cm)
1:eac0369: 		throws StandardException {
1:eac0369: 
1:eac0369: 		// start a local transaction
1:eac0369: 		return af.getTransaction(cm);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected AuthenticationService bootAuthenticationService(boolean create, Properties props) throws StandardException {
1:eac0369: 		return (AuthenticationService)
1:56c1dc2: 				bootServiceModule(create, this, AuthenticationService.MODULE, props);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected void bootValidation(boolean create, Properties startParams)
1:eac0369: 		throws StandardException {
1:56c1dc2: 		pf = (PropertyFactory) bootServiceModule(create, this,
1:eac0369: 			org.apache.derby.iapi.reference.Module.PropertyFactory, startParams);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected void bootStore(boolean create, Properties startParams)
1:eac0369: 		throws StandardException {
1:56c1dc2: 		af = (AccessFactory) bootServiceModule(create, this, AccessFactory.MODULE, startParams);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:2fa8526:      * Get the set of database properties from the set stored
1:2fa8526:      * on disk outside of service.properties.
1:2fa8526:      */
1:eac0369: 	protected Properties getAllDatabaseProperties()
1:eac0369: 		throws StandardException {
1:eac0369: 
1:eac0369: 		TransactionController tc = af.getTransaction(
1:a0dbbd7:                     getContextService().getCurrentContextManager());
1:eac0369: 		Properties dbProps = tc.getProperties();
1:eac0369: 		tc.commit();
1:eac0369: 		tc.destroy();
1:eac0369: 
1:eac0369: 		return dbProps;
1:eac0369: 	}
1:eac0369: 
1:2fa8526: 	protected void bootResourceAdapter(boolean create, Properties allParams) {
1:eac0369: 
1:eac0369: 		// Boot resource adapter - only if we are running Java 2 or
1:eac0369: 		// beyondwith JDBC20 extension, JTA and JNDI classes in the classpath
1:eac0369: 		//
1:eac0369: 		// assume if it doesn't boot it was because the required
1:eac0369: 		// classes were missing, and continue without it.
1:eac0369: 		// Done this way to work around Chai's need to preload
1:eac0369: 		// classes.
1:6ae3022: 		// Assume both of these classes are in the class path.
1:6ae3022: 		// Assume we may need a ResourceAdapter since we don't know how
1:6ae3022: 		// this database is going to be used.
1:6ae3022: 		try
1:eac0369: 		{
1:6ae3022: 			resourceAdapter = 
1:56c1dc2: 				bootServiceModule(create, this,
1:6ae3022: 										 org.apache.derby.iapi.reference.Module.ResourceAdapter,
1:6ae3022: 										 allParams);
1:6ae3022: 		}
1:6ae3022: 		catch (StandardException mse)
1:6ae3022: 		{
1:6ae3022: 			// OK, resourceAdapter is an optional module
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected void pushClassFactoryContext(ContextManager cm, ClassFactory cf) {
1:eac0369: 		new StoreClassFactoryContext(cm, cf, af, this);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of JarReader
1:eac0369: 	*/
1:2b7530f: 	public StorageFile getJarFile(String schemaName, String sqlName)
1:eac0369: 		throws StandardException {
1:eac0369: 
1:eac0369: 		SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, null, true);
1:eac0369: 		FileInfoDescriptor fid = dd.getFileInfoDescriptor(sd,sqlName);
1:eac0369: 		if (fid == null)
1:eac0369: 			throw StandardException.newException(SQLState.LANG_FILE_DOES_NOT_EXIST, sqlName,schemaName);
1:eac0369: 
1:eac0369: 		long generationId = fid.getGenerationId();
1:eac0369: 
1:a0dbbd7:         ContextManager cm = getContextService().getCurrentContextManager();
1:2bb479f: 		FileResource fr = af.getTransaction(cm).getFileHandler();
1:eac0369: 
1:78c2db1:         String externalName = JarUtil.mkExternalName(
1:78c2db1:             fid.getUUID(), schemaName, sqlName, fr.getSeparatorChar());
1:eac0369: 
1:2b7530f: 		return fr.getAsFile(externalName, generationId);
1:eac0369: 	}
1:eac0369: 
1:502ed2e:     ////////////////////////////////////////////////////////////////////////
1:502ed2e:     //
1:502ed2e:     // SUPPORT FOR BACKING UP LUCENE DIRECTORY
1:502ed2e:     //
1:502ed2e:     ////////////////////////////////////////////////////////////////////////
1:502ed2e: 
1:502ed2e:     /**
1:502ed2e:      * <p>
1:502ed2e:      * Return true if the Lucene plugin is loaded.
1:502ed2e:      * </p>
1:502ed2e:      */
1:502ed2e:     private boolean luceneLoaded()
1:502ed2e:         throws StandardException
1:502ed2e:     {
1:502ed2e:         try {
1:502ed2e:             return AccessController.doPrivileged
1:502ed2e:                 (
1:502ed2e:                  new PrivilegedExceptionAction<Boolean>()
1:502ed2e:                  {
1:502ed2e:                      public Boolean run()
1:502ed2e:                          throws StandardException
1:502ed2e:                      {
1:502ed2e:                          return getLuceneDir().exists();
1:502ed2e:                      }
1:502ed2e:                  }
1:502ed2e:                  ).booleanValue();
1:502ed2e:         }
1:502ed2e:         catch (PrivilegedActionException pae) { throw StandardException.plainWrapException( pae ); }
1:502ed2e:     }
1:502ed2e: 
1:502ed2e:     /** Get the location of the Lucene indexes */
1:502ed2e:     private StorageFile getLuceneDir()
1:502ed2e:         throws StandardException
1:a0dbbd7:     {
1:502ed2e:         StorageFactory  dir = getStorageFactory();
1:502ed2e: 		
1:502ed2e: 		return dir.newStorageFile( Database.LUCENE_DIR );
1:502ed2e:     }
1:502ed2e: 
1:a0dbbd7:     /**
1:502ed2e:      * <p>
1:502ed2e:      * Get the database StorageFactory.
1:502ed2e:      * </p>
1:502ed2e:      */
1:502ed2e:     private StorageFactory  getStorageFactory()
1:502ed2e:         throws StandardException
1:a0dbbd7:     {
1:56c1dc2:         DataFactory dataFactory = (DataFactory) findServiceModule( this, DataFactory.MODULE );
1:502ed2e: 
1:502ed2e:         return dataFactory.getStorageFactory();
1:502ed2e:     }
1:502ed2e: 
1:502ed2e:     /**
1:502ed2e:      * <p>
1:502ed2e:      * Backup Lucene indexes to the backup directory. This assumes
1:502ed2e:      * that the rest of the database has been backup up and sanity
1:502ed2e:      * checks have been run.
1:502ed2e:      * </p>
1:502ed2e:      */
1:502ed2e:     private void    backupLucene( String backupDir )
1:502ed2e:         throws StandardException
1:502ed2e:     {
1:502ed2e:         try {
1:502ed2e:             File            backupRoot = new File( backupDir );
1:502ed2e:             StorageFactory  storageFactory = getStorageFactory();
1:502ed2e:             String      canonicalDbName = storageFactory.getCanonicalName();
1:502ed2e:             String      dbname = StringUtil.shortDBName( canonicalDbName, storageFactory.getSeparator() );
1:502ed2e:             File        backupDB = new File( backupRoot, dbname );
1:502ed2e:         
1:502ed2e:             final   File            targetDir = new File( backupDB, Database.LUCENE_DIR );
1:502ed2e:             final   StorageFile sourceDir = getLuceneDir();
1:502ed2e: 
1:502ed2e:             AccessController.doPrivileged
1:502ed2e:                 (
1:502ed2e:                  new PrivilegedExceptionAction<Object>()
1:502ed2e:                  {
1:502ed2e:                      public Boolean run()
1:502ed2e:                          throws StandardException
1:502ed2e:                      {
1:502ed2e:                          if ( !FileUtil.copyDirectory( getStorageFactory(), sourceDir, targetDir, null, null, true ) )
1:502ed2e:                          {
1:502ed2e:                              throw StandardException.newException
1:502ed2e:                                  (
1:502ed2e:                                   SQLState.UNABLE_TO_COPY_FILE_FROM_BACKUP,
1:502ed2e:                                   sourceDir.getPath(),
1:502ed2e:                                   targetDir.getAbsolutePath()
1:502ed2e:                                   );
1:502ed2e:                          }
1:502ed2e:                          
1:502ed2e:                          return null;
1:502ed2e:                      }
1:502ed2e:                  }
1:502ed2e:                  );
1:502ed2e:         }
1:502ed2e:         catch (IOException ioe) { throw StandardException.plainWrapException( ioe ); }
1:502ed2e:         catch (PrivilegedActionException pae) { throw StandardException.plainWrapException( pae ); }
1:502ed2e:     }
1:502ed2e: 
1:eac0369:     /**
1:a0dbbd7:      * Privileged lookup of the ContextService. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  ContextService    getContextService()
1:a0dbbd7:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ContextService>()
1:56c1dc2:              {
1:56c1dc2:                  public ContextService run()
1:56c1dc2:                  {
1:56c1dc2:                      return ContextService.getFactory();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object bootServiceModule
1:56c1dc2:         (
1:56c1dc2:          final boolean create, final Object serviceModule,
1:56c1dc2:          final String factoryInterface, final Properties properties
1:56c1dc2:          )
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:a0dbbd7:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.bootServiceModule( create, serviceModule, factoryInterface, properties );
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object findServiceModule( final Object serviceModule, final String factoryInterface)
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:a0dbbd7:                      {
1:56c1dc2:                          return Monitor.findServiceModule( serviceModule, factoryInterface );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:a0dbbd7: 
1:a0dbbd7: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: 		ModuleFactory monitor = getMonitor();
/////////////////////////////////////////////////////////////////////////
1:             bootServiceModule(
/////////////////////////////////////////////////////////////////////////
1:             bootServiceModule(create, this,
1:             bootServiceModule(
1:             bootServiceModule(
/////////////////////////////////////////////////////////////////////////
1: 			UUIDFactory	uuidFactory  = getMonitor().getUUIDFactory();
/////////////////////////////////////////////////////////////////////////
1: 			cfDB = (ClassFactory) bootServiceModule(create, this,
/////////////////////////////////////////////////////////////////////////
1: 				bootServiceModule(create, this, AuthenticationService.MODULE, props);
1: 		pf = (PropertyFactory) bootServiceModule(create, this,
1: 		af = (AccessFactory) bootServiceModule(create, this, AccessFactory.MODULE, startParams);
/////////////////////////////////////////////////////////////////////////
1: 				bootServiceModule(create, this,
/////////////////////////////////////////////////////////////////////////
1:         DataFactory dataFactory = (DataFactory) findServiceModule( this, DataFactory.MODULE );
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ContextService>()
1:              {
1:                  public ContextService run()
1:                  {
1:                      return ContextService.getFactory();
1:                  }
1:              }
1:              );
1:     }
1: 
1:     /**
1:      * Privileged Monitor lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
1:     }
1: 
1:     
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object bootServiceModule
1:         (
1:          final boolean create, final Object serviceModule,
1:          final String factoryInterface, final Properties properties
1:          )
1:         throws StandardException
1:     {
1:         try {
1:                  new PrivilegedExceptionAction<Object>()
1:                      public Object run()
1:                          throws StandardException
1:                          return Monitor.bootServiceModule( create, serviceModule, factoryInterface, properties );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object findServiceModule( final Object serviceModule, final String factoryInterface)
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.findServiceModule( serviceModule, factoryInterface );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: 				getContextService().getCurrentContextManager());
/////////////////////////////////////////////////////////////////////////
1:                     getContextService().getCurrentContextManager());
/////////////////////////////////////////////////////////////////////////
1:         ContextManager cm = getContextService().getCurrentContextManager();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Privileged lookup of the ContextService. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ContextService    getContextService()
1:     {
0:         if ( System.getSecurityManager() == null )
1:         {
0:             return ContextService.getFactory();
1:         }
0:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
0:                  new PrivilegedAction<ContextService>()
1:                  {
0:                      public ContextService run()
1:                      {
0:                          return ContextService.getFactory();
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
commit:502ed2e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.raw.data.DataFactory;
1: import org.apache.derby.iapi.util.StringUtil;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.FileUtil;
1: import org.apache.derby.io.StorageFactory;
1: import java.io.File;
1: import java.io.IOException;
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1:             if ( luceneLoaded() )
1:             {
1:                 backupLucene( backupDir );
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if ( luceneLoaded() )
1:             {
1:                 backupLucene( backupDir );
1:             }
/////////////////////////////////////////////////////////////////////////
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     // SUPPORT FOR BACKING UP LUCENE DIRECTORY
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Return true if the Lucene plugin is loaded.
1:      * </p>
1:      */
1:     private boolean luceneLoaded()
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Boolean>()
1:                  {
1:                      public Boolean run()
1:                          throws StandardException
1:                      {
1:                          return getLuceneDir().exists();
1:                      }
1:                  }
1:                  ).booleanValue();
1:         }
1:         catch (PrivilegedActionException pae) { throw StandardException.plainWrapException( pae ); }
1:     }
1: 
1:     /** Get the location of the Lucene indexes */
1:     private StorageFile getLuceneDir()
1:         throws StandardException
1:     {
1:         StorageFactory  dir = getStorageFactory();
1: 		
1: 		return dir.newStorageFile( Database.LUCENE_DIR );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Get the database StorageFactory.
1:      * </p>
1:      */
1:     private StorageFactory  getStorageFactory()
1:         throws StandardException
1:     {
0:         DataFactory dataFactory = (DataFactory) Monitor.findServiceModule( this, DataFactory.MODULE );
1: 
1:         return dataFactory.getStorageFactory();
1:     }
1: 
1:     /**
1:      * <p>
1:      * Backup Lucene indexes to the backup directory. This assumes
1:      * that the rest of the database has been backup up and sanity
1:      * checks have been run.
1:      * </p>
1:      */
1:     private void    backupLucene( String backupDir )
1:         throws StandardException
1:     {
1:         try {
1:             File            backupRoot = new File( backupDir );
1:             StorageFactory  storageFactory = getStorageFactory();
1:             String      canonicalDbName = storageFactory.getCanonicalName();
1:             String      dbname = StringUtil.shortDBName( canonicalDbName, storageFactory.getSeparator() );
1:             File        backupDB = new File( backupRoot, dbname );
1:         
1:             final   File            targetDir = new File( backupDB, Database.LUCENE_DIR );
1:             final   StorageFile sourceDir = getLuceneDir();
1: 
1:             AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Boolean run()
1:                          throws StandardException
1:                      {
1:                          if ( !FileUtil.copyDirectory( getStorageFactory(), sourceDir, targetDir, null, null, true ) )
1:                          {
1:                              throw StandardException.newException
1:                                  (
1:                                   SQLState.UNABLE_TO_COPY_FILE_FROM_BACKUP,
1:                                   sourceDir.getPath(),
1:                                   targetDir.getAbsolutePath()
1:                                   );
1:                          }
1:                          
1:                          return null;
1:                      }
1:                  }
1:                  );
1:         }
1:         catch (IOException ioe) { throw StandardException.plainWrapException( ioe ); }
1:         catch (PrivilegedActionException pae) { throw StandardException.plainWrapException( pae ); }
1:     }
1: 
commit:b023843
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             // on orderly shutdown, try not to leak unused numbers from the sequence generators.
1:             dd.clearSequenceCaches();
1:         }
0:         catch (Throwable t)
1:         {
0:             t.printStackTrace(Monitor.getStream().getPrintWriter());
1:         }
commit:2724c48
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:78c2db1
/////////////////////////////////////////////////////////////////////////
1:         String externalName = JarUtil.mkExternalName(
1:             fid.getUUID(), schemaName, sqlName, fr.getSeparatorChar());
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:8f87469
/////////////////////////////////////////////////////////////////////////
1:         // The data dictionary is not available if this database has the
1:         // role as an active replication slave database.
1:         if (dd != null) {
1:             try {
1:                 // on orderly shutdown, try not to leak unused numbers from
1:                 // the sequence generators.
0:                 dd.clearSequenceCaches();
1:             } catch (StandardException se) {
1:                 se.printStackTrace(Monitor.getStream().getPrintWriter());
1:             }
commit:7916398
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // Create an index statistics update daemon.
1:         if (dd.doCreateIndexStatsRefresher()) {
1:             dd.createIndexStatsRefresher(this, allParams.getProperty(
1:                         Property.PROPERTY_RUNTIME_PREFIX + "serviceDirectory"));
1:         }
1:     }
commit:869c85a
/////////////////////////////////////////////////////////////////////////
1:      * @see org.apache.derby.iapi.db.Database#failover(String)
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:abe46d0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e24d8ef
/////////////////////////////////////////////////////////////////////////
1:         @deprecated
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:6b95f61
/////////////////////////////////////////////////////////////////////////
commit:50bd23b
/////////////////////////////////////////////////////////////////////////
0: 		DataValueFactory dvf = (DataValueFactory) Monitor.bootServiceModule(create, this,
/////////////////////////////////////////////////////////////////////////
0: 		dvf.setLocale(databaseLocale);
commit:2ca9dc6
/////////////////////////////////////////////////////////////////////////
1: 		// boot the type factory before store to ensure any dynamically
0: 				org.apache.derby.iapi.reference.ClassName.DataValueFactory, startParams);
0: /*		DataValueFactory dvf = (DataValueFactory) Monitor.bootServiceModule(create, this,
0: 				org.apache.derby.iapi.reference.ClassName.DataValueFactory, startParams);
0: 		//After booting the DVF, set the Locale information into it. This 
0: 		//Locale will be either the Locale obtained from the territory 
0: 		//attribute supplied by the user on the JDBC url at database create 
0: 		//time or if user didn't provide the territory attribute at database
0: 		//create time, then it will be set to the default JVM locale. If user 
0: 		//has requested territory based collation then a Collator object will
0: 		//be constructed from this Locale object. 
0: 		dvf.setLocale(databaseLocale);*/
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:1bac3f3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.replication.slave.SlaveFactory;
commit:5a6acbf
/////////////////////////////////////////////////////////////////////////
1:     public void failover(String dbname) throws StandardException {
1:         af.failover(dbname);
commit:9e88b9d
/////////////////////////////////////////////////////////////////////////
1:     public boolean isInSlaveMode() {
1:         return false;
1:     }
1:     
commit:fd20d6b
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * @see org.apache.derby.database.Database#failover(String dbname).
1:      */
0:     public void failover(String dbname) throws SQLException {
1:         try {
0:             af.failover(dbname);
1:         } catch (StandardException se) {
1:             throw PublicAPI.wrapStandardException(se);
1:         }
1:     }
commit:964abfa
/////////////////////////////////////////////////////////////////////////
1:      * @param dbmaster The master database that is being replicated.
/////////////////////////////////////////////////////////////////////////
1:     public void startReplicationMaster(String dbmaster, String host, int port,
1:             af.startReplicationMaster(dbmaster, host, port, replicationMode);
commit:b9c57d5
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Only a SlaveDatabase can be in replication slave mode. Always 
1:      * throws an exception
1:      * 
1:      * @exception SQLException Always thrown because BasicDatabase cannot 
1:      * be in replication slave mode
1:      */
1:     public void stopReplicationSlave() throws SQLException {
1:         StandardException se = StandardException.
1:             newException(SQLState.REPLICATION_NOT_IN_SLAVE_MODE);
1:         throw PublicAPI.wrapStandardException(se);
1:     }
commit:696377a
/////////////////////////////////////////////////////////////////////////
1: 	public AuthenticationService getAuthenticationService()
1: 		throws StandardException{
commit:54be3b4
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Stop the replication master role for this database.
1:      * 
1:      * @exception SQLException Thrown on error
1:      */
1:     public void stopReplicationMaster()  throws SQLException {
1:         try {
1:             af.stopReplicationMaster();
1:         } catch (StandardException se) {
1:             throw PublicAPI.wrapStandardException(se);
1:         }
1:     }
commit:836ab97
/////////////////////////////////////////////////////////////////////////
1: 	protected boolean	active;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         boolean supported =
1:             Monitor.isDesiredCreateType(startParams, getEngineType());
1: 
1:         if (supported) {
1:             String repliMode =
1:                 startParams.getProperty(SlaveFactory.REPLICATION_MODE);
1:             if (repliMode != null &&
1:                 !repliMode.equals(SlaveFactory.SLAVE_PRE_MODE)) {
1:                 supported = false;
1:             }
1:         }
1: 
1:         return supported;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	public AuthenticationService getAuthenticationService() {
commit:49653be
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.replication.slave.SlaveFactory;
1: 
/////////////////////////////////////////////////////////////////////////
0:     private boolean inReplicationSlaveMode = false;
/////////////////////////////////////////////////////////////////////////
1: 
0:         // Database is booted in replication slave mode. Make sure
0:         // other clients are not able to connect
0:         String slave = startParams.getProperty(SlaveFactory.REPLICATION_MODE);
0:         if (slave != null && slave.equals(SlaveFactory.SLAVE_MODE)) {
0:             inReplicationSlaveMode = true;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (inReplicationSlaveMode) {
0:             // do not allow connections to a database that is
0:             // currently in replication slave move
0:             throw StandardException.newException(
0:                         SQLState.CANNOT_CONNECT_TO_DB_IN_SLAVE_MODE, dbname);
1:         }
1: 
commit:4aeada8
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Start the replication master role for this database
1:      * @param host The hostname for the slave
1:      * @param port The port the slave is listening on
1:      * @param replicationMode The type of replication contract.
1:      * Currently only asynchronous replication is supported, but
1:      * 1-safe/2-safe/very-safe modes may be added later.
1:      * @exception SQLException Thrown on error
1:      */
0:     public void startReplicationMaster(String host, int port,
1:                                        String replicationMode)
1:         throws SQLException {
1:         try {
0:             af.startReplicationMaster(host, port, replicationMode);
1:         } catch (StandardException se) {
1:             throw PublicAPI.wrapStandardException(se);
1:         }
1:     }
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9ac3a76
/////////////////////////////////////////////////////////////////////////
1: 		lctx.initialize();		
commit:9067662
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		setLocale(databaseLocale);      
/////////////////////////////////////////////////////////////////////////
1: 			dbcp = IdUtil.parseDbClassPath(newClasspath);
/////////////////////////////////////////////////////////////////////////
1: 			IdUtil.parseDbClassPath(classpath);
commit:2d461fa
/////////////////////////////////////////////////////////////////////////
commit:c2a8161
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.sql.execute.JarUtil;
/////////////////////////////////////////////////////////////////////////
0: 		String externalName = JarUtil.mkExternalName(schemaName, sqlName, fr.getSeparatorChar());
commit:2fa8526
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // Add the database properties read from disk (not stored
1:         // in service.properties) into the set seen by booting modules.
1: 		Properties allParams =
1:             new DoubleProperties(getAllDatabaseProperties(), startParams);
/////////////////////////////////////////////////////////////////////////
1:                     DataDictionary.MODULE, allParams);
1: 		bootResourceAdapter(create, allParams);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the set of database properties from the set stored
1:      * on disk outside of service.properties.
1:      */
/////////////////////////////////////////////////////////////////////////
1: 	protected void bootResourceAdapter(boolean create, Properties allParams) {
commit:dcd3fec
/////////////////////////////////////////////////////////////////////////
0:         return Monitor.isDesiredCreateType(startParams, getEngineType());
/////////////////////////////////////////////////////////////////////////
1:      * Return the engine type that this Database implementation
1:      * supports.
1:      * This implementation supports the standard database.
1: 	public int getEngineType() {
1:         return EngineType.STANDALONE_DB;
1:     }
commit:2bb479f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ContextManager cm = ContextService.getFactory().getCurrentContextManager();
1: 		FileResource fr = af.getTransaction(cm).getFileHandler();
commit:2b7530f
/////////////////////////////////////////////////////////////////////////
1: 	public StorageFile getJarFile(String schemaName, String sqlName)
/////////////////////////////////////////////////////////////////////////
1: 		return fr.getAsFile(externalName, generationId);
commit:4841b0e
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * DataDictionary for this database.
1:      */
1:     private DataDictionary dd;
1:     
/////////////////////////////////////////////////////////////////////////
1:         
1:         dd = (DataDictionary)
0:             Monitor.bootServiceModule(create, this,
0:                     DataDictionary.MODULE, startParams);
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Return the DataDictionary for this database, set up at boot time.
1:      */
1:     public final DataDictionary getDataDictionary()
1:     {
1:         return dd;
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             getDataDictionary().invalidateAllSPSPlans();
/////////////////////////////////////////////////////////////////////////
0: 		DataDictionary dd = getDataDictionary();
commit:fb93460
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.io.StorageFile;
/////////////////////////////////////////////////////////////////////////
0: 		StorageFile f = fr.getAsFile(externalName, generationId);
0: 			return f.getInputStream();
commit:33dab75
/////////////////////////////////////////////////////////////////////////
1: 		
0: 		// boot the type factpry before store to ensure any dynamically
0: 		// registered types (DECIMAL) are there before logical undo recovery might need them.
0: 		Monitor.bootServiceModule(create, this,
0: 					org.apache.derby.iapi.reference.ClassName.DataValueFactory, startParams);
commit:6ae3022
/////////////////////////////////////////////////////////////////////////
1: 		// Assume both of these classes are in the class path.
1: 		// Assume we may need a ResourceAdapter since we don't know how
1: 		// this database is going to be used.
1: 		try
1: 			resourceAdapter = 
0: 				Monitor.bootServiceModule(create, this,
1: 										 org.apache.derby.iapi.reference.Module.ResourceAdapter,
1: 										 allParams);
1: 		}
1: 		catch (StandardException mse)
1: 		{
1: 			// OK, resourceAdapter is an optional module
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.db.BasicDatabase
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:217667e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 											 org.apache.derby.iapi.reference.Module.ResourceAdapter,
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.db
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.db;
1: 
1: import org.apache.derby.iapi.error.PublicAPI;
1: 
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.reference.EngineType;
1: import org.apache.derby.iapi.util.DoubleProperties;
1: import org.apache.derby.iapi.util.IdUtil;
0: import org.apache.derby.iapi.services.info.JVMInfo;
1: 
1: import org.apache.derby.iapi.services.property.PropertyUtil;
1: import org.apache.derby.iapi.services.loader.ClassFactory;
1: import org.apache.derby.iapi.services.loader.JarReader;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.daemon.Serviceable;
1: import org.apache.derby.iapi.services.monitor.ModuleControl;
1: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.property.PersistentSet;
1: import org.apache.derby.iapi.db.Database;
1: import org.apache.derby.iapi.db.DatabaseContext;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
1: 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
1: 
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
1: import org.apache.derby.iapi.sql.dictionary.FileInfoDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
1: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.sql.LanguageFactory;
0: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.store.access.AccessFactory;
1: import org.apache.derby.iapi.store.access.FileResource;
1: import org.apache.derby.iapi.services.property.PropertyFactory;
1: import org.apache.derby.iapi.services.property.PropertySetCallback;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.jdbc.AuthenticationService;
1: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.jdbc.ResourceAdapter;
1: 
0: import java.io.InputStream;
0: import java.io.OutputStream;
1: import java.io.Serializable;
0: import java.io.File;
0: import java.sql.Date;
0: import java.sql.Timestamp;
1: import java.sql.SQLException;
1: import java.util.Properties;
1: import java.util.Dictionary;
0: import java.util.Enumeration;
0: import java.util.Hashtable;
1: import java.util.Locale;
0: import java.lang.reflect.Method;
0: import java.text.Collator;
0: import java.text.RuleBasedCollator;
1: import java.text.DateFormat;
1: 
1: /**
1:  * The Database interface provides control over the physical database
1:  * (that is, the stored data and the files the data are stored in),
1:  * connections to the database, operations on the database such as
1:  * backup and recovery, and all other things that are associated
1:  * with the database itself.
1:  * <p>
1:  * The Database interface does not provide control over things that are part of
1:  * the Domain, such as users.
1:  * <p>
1:  * I'm not sure what this will hold in a real system, for now
1:  * it simply provides connection-creation for us.  Perhaps when it boots,
1:  * it creates the datadictionary object for the database, which all users
1:  * will then interact with?
1:  *
0:  * @author ames
1:  */
1: 
1: public class BasicDatabase implements ModuleControl, ModuleSupportable, PropertySetCallback, Database, JarReader
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private boolean		active;
1: 	private AuthenticationService authenticationService;
1: 	protected AccessFactory af;
1: 	protected PropertyFactory pf;
1: 	protected ClassFactory cfDB; // classFactory but only set when per-database
1: 	protected LanguageConnectionFactory lcf;
1: 	protected LanguageFactory lf;
1: 	// hold resourceAdapter in an Object instead of a ResourceAdapter
1: 	// so that XA class use can be isolated to XA modules.
1: 	protected Object resourceAdapter;
1: 	private Locale databaseLocale;
0: 	private RuleBasedCollator ruleBasedCollator;
0: 	private int			spaceInt;
0: 	private boolean		spaceIntSet;
1: 	private DateFormat dateFormat;
1: 	private DateFormat timeFormat;
1: 	private DateFormat timestampFormat;
1: 	private UUID		myUUID;
0:     private boolean normalizeToUpper = true;
1: 
1: 	protected boolean lastToBoot; // is this class last to boot
1: 
1: 	/*
1: 	 * ModuleControl interface
1: 	 */
1: 
1: 	public boolean canSupport(Properties startParams) {
1: 
0: 		return Monitor.isDesiredCreateType(startParams, org.apache.derby.iapi.reference.EngineType.NONE);
1: 
1: 	}
1: 
0: 	protected Properties allParams;	// properties to be used *only* while booting.
1: 
1: 	public void boot(boolean create, Properties startParams)
1: 		throws StandardException
1: 	{
0: 		ModuleFactory monitor = Monitor.getMonitor();
1: 		if (create)
1: 		{
1: 			if (startParams.getProperty(Property.CREATE_WITH_NO_LOG) == null)
1: 				startParams.put(Property.CREATE_WITH_NO_LOG, "true");
1: 
0: 			String localeID = startParams.getProperty(org.apache.derby.iapi.reference.Attribute.TERRITORY);
1: 
1: 			if (localeID == null) {
1: 				localeID = Locale.getDefault().toString();
1: 			}
1: 			databaseLocale = monitor.setLocale(startParams, localeID);
1: 
1: 		} else {
1: 			databaseLocale = monitor.getLocale(this);
1: 		}
0: 		setLocale(databaseLocale);
1: 
0:         normalizeToUpper = true;
1:         
1: 
1: 		// boot the validation needed to do property validation, now property
1: 		// validation is separated from AccessFactory, therefore from store
1: 		bootValidation(create, startParams);
1: 
1: 		bootStore(create, startParams);
1: 
1: 		// create a database ID if one doesn't already exist
1: 		myUUID = makeDatabaseID(create, startParams);
1: 
1: 
0: 		allParams = new DoubleProperties(getAllDatabaseProperties(), startParams);
1: 
1: 		if (pf != null)
1: 			pf.addPropertySetNotification(this);
1: 
1: 			// Boot the ClassFactory, will be per-database or per-system.
1: 			// reget the tc in case someone inadverdently destroyed it 
1: 		bootClassFactory(create, allParams);
1: 
0: 		lcf = (LanguageConnectionFactory) Monitor.bootServiceModule(create, this, LanguageConnectionFactory.MODULE, allParams);
0: 		lf = (LanguageFactory) Monitor.bootServiceModule(create, this, LanguageFactory.MODULE, allParams);
1: 
0: 		bootResourceAdapter(create, startParams);
1: 
1: 
1: 		// may also want to set up a check that we are a singleton,
1: 		// or that there isn't already a database object in the system
1: 		// for the same database?
1: 
1: 
1: 		//
1: 		// We boot the authentication service. There should at least be one
1: 		// per database (even if authentication is turned off) .
1: 		//
1: 		authenticationService = bootAuthenticationService(create, allParams);
1: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(authenticationService != null,
1: 								 "Failed to set the Authentication service for the database");
1: 		}
1: 
1: 		// Lastly, let store knows that database creation is done and turn
1: 		// on logging
1: 		if (create && lastToBoot &&
1: 			(startParams.getProperty(Property.CREATE_WITH_NO_LOG) != null))
1: 		{
1: 			createFinished();
1: 		}
1: 
1: 		active = true;
1: 
0: 		if (lastToBoot)
0: 			allParams = null; // should not be used anymore
1: 	}
1: 
1: 	public void stop() {
1: 		active = false;
1: 	}
1: 
1: 	/*
1: 	** Methods related to  ModuleControl
1: 	*/
1: 
1: 	/*
1: 	 * Database interface
1:  	 */
1: 
1: 	/**
0: 	  *	@return	one of the values from EngineType.java:
1: 	  *
1: 	  */
0: 	public	int	getEngineType() { return org.apache.derby.iapi.reference.EngineType.NONE; }
1: 
1: 	public boolean isReadOnly()
1: 	{
1: 		//
1: 		//Notice if no full users?
1: 		//RESOLVE: (Make access factory check?)
1: 		return af.isReadOnly();
1: 	}
1: 
1: 	public LanguageConnectionContext setupConnection(ContextManager cm, String user, String drdaID, String dbname)
1: 		throws StandardException {
1: 
1: 		TransactionController tc = getConnectionTransaction(cm);
1: 
1: 		cm.setLocaleFinder(this);
1: 		pushDbContext(cm);
1: 
1: 		// push a database shutdown context
1: 		// we also need to push a language connection context.
1: 		LanguageConnectionContext lctx = lcf.newLanguageConnectionContext(cm, tc, lf, this, user, drdaID, dbname);
1: 
1: 		// push the context that defines our class factory
1: 		pushClassFactoryContext(cm, lcf.getClassFactory());
1: 
1: 		// we also need to push an execution context.
1: 		ExecutionFactory ef = lcf.getExecutionFactory();
1: 
1: 		ef.newExecutionContext(cm);
1: 		//
1: 		//Initialize our language connection context. Note: This is
1: 		//a bit of a hack. Unfortunately, we can't initialize this
1: 		//when we push it. We first must push a few more contexts. 
0: 		lctx.initialize(true);		
1: 
1: 		// Need to commit this to release locks gotten in initialize.  
1: 		// Commit it but make sure transaction not have any updates. 
1: 		lctx.internalCommitNoSync(
1: 			TransactionController.RELEASE_LOCKS |
1: 			TransactionController.READONLY_TRANSACTION_INITIALIZATION);
1: 
1: 		return lctx;
1: 
1: 	}
1: 
1: 	public void pushDbContext(ContextManager cm)
1: 	{
1: 		/* We cache the locale in the DatabaseContext
1: 		 * so that the Datatypes can get to it easily.
1: 		 */
1: 		DatabaseContext dc = new DatabaseContextImpl(cm, this);
1: 	}
1: 
0: 	public final AuthenticationService getAuthenticationService() {
1: 
1: 		// Expected to find one - Sanity check being done at
1: 		// DB boot-up.
1: 
1: 		// We should have a Authentication Service
1: 		//
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(this.authenticationService != null, 
1: 				"Unexpected - There is no valid authentication service for the database!");
1: 		}
1: 		return this.authenticationService;
1: 	}
1: 
1: 	public void freeze() throws SQLException
1: 	{
1: 		try {
1: 			af.freeze();
1: 		} catch (StandardException se) {
1: 			throw PublicAPI.wrapStandardException(se);
1: 		}
1: 	}
1: 
1: 	public void unfreeze() throws SQLException
1: 	{
1: 		try {
1: 			af.unfreeze();
1: 		} catch (StandardException se) {
1: 			throw PublicAPI.wrapStandardException(se);
1: 		}
1: 	}
1: 
1: 
0: 	public void backup(String backupDir) throws SQLException
1: 	{
1: 		try {
0: 			af.backup(backupDir);
1: 		} catch (StandardException se) {
1: 			throw PublicAPI.wrapStandardException(se);
1: 		}
1: 	}
1: 
1: 
0: 	public void backup(File backupDir) throws SQLException
1: 	{
1: 		try {
0: 			af.backup(backupDir);
1: 		} catch (StandardException se) {
1: 			throw PublicAPI.wrapStandardException(se);
1: 		}
1: 	}
1: 
1: 
1: 
0: 	public void backupAndEnableLogArchiveMode(String backupDir, 
0: 											  boolean
0: 											  deleteOnlineArchivedLogFiles)
1: 		throws SQLException
1: 	{
1: 		try {
0: 			af.backupAndEnableLogArchiveMode(backupDir, deleteOnlineArchivedLogFiles);
1: 		} catch (StandardException se) {
1: 			throw PublicAPI.wrapStandardException(se);
1: 		}
1: 	}
1: 
0: 	public void backupAndEnableLogArchiveMode(File backupDir, 
0: 											  boolean
0: 											  deleteOnlineArchivedLogFiles)
1: 		throws SQLException
1: 	{
1: 		try {
0: 			af.backupAndEnableLogArchiveMode(backupDir, deleteOnlineArchivedLogFiles);
1: 		} catch (StandardException se) {
1: 			throw PublicAPI.wrapStandardException(se);
1: 		}
1: 	}
1: 	
1: 	public void disableLogArchiveMode(boolean deleteOnlineArchivedLogFiles)
1: 		throws SQLException
1: 	{
1: 		try{
1: 			af.disableLogArchiveMode(deleteOnlineArchivedLogFiles);
1: 		}catch (StandardException se) {
1: 			throw PublicAPI.wrapStandardException(se);
1: 		}
1: 	}
1: 
1: 
1: 	public void	checkpoint() throws SQLException
1: 	{
1: 		try {
1: 			af.checkpoint();
1: 		} catch (StandardException se) {
1: 			throw PublicAPI.wrapStandardException(se);
1: 		}
1: 	}
1: 
1: 	/* Methods from org.apache.derby.database.Database */
1: 	public Locale getLocale() {
1: 		return databaseLocale;
1: 	}
1: 
1: 
1: 	/**
1: 		Return the UUID of this database.
1: 	*/
1: 	public final UUID getId() {
1: 		return myUUID;
1: 	}
1: 
1: 	/* LocaleFinder methods */
1: 
1: 	/** @exception StandardException	Thrown on error */
1: 	public Locale getCurrentLocale() throws StandardException {
1: 		if (databaseLocale != null)
1: 			return databaseLocale;
1: 		throw noLocale();
1: 	}
1: 
1: 	/** @exception StandardException	Thrown on error */
0: 	public RuleBasedCollator getCollator() throws StandardException {
0: 		RuleBasedCollator retval = ruleBasedCollator;
1: 
0: 		if (retval == null) {
1: 			if (databaseLocale != null) {
0: 				retval = ruleBasedCollator =
0: 					(RuleBasedCollator) Collator.getInstance(databaseLocale);
1: 			} else {
1: 				throw noLocale();
1: 			}
1: 		}
1: 
0: 		return retval;
1: 	}
1: 
1: 
1: 	/** @exception StandardException	Thrown on error */
1: 	public DateFormat getDateFormat() throws StandardException {
1: 		if (databaseLocale != null) {
1: 			if (dateFormat == null) {
1: 				dateFormat = DateFormat.getDateInstance(DateFormat.LONG,
1: 																databaseLocale);
1: 			}
1: 
1: 			return dateFormat;
1: 		}
1: 
1: 		throw noLocale();
1: 	}
1: 
1: 	/** @exception StandardException	Thrown on error */
1: 	public DateFormat getTimeFormat() throws StandardException {
1: 		if (databaseLocale != null) {
1: 			if (timeFormat == null) {
1: 				timeFormat = DateFormat.getTimeInstance(DateFormat.LONG,
1: 																databaseLocale);
1: 			}
1: 
1: 			return timeFormat;
1: 		}
1: 
1: 		throw noLocale();
1: 	}
1: 
1: 	/** @exception StandardException	Thrown on error */
1: 	public DateFormat getTimestampFormat() throws StandardException {
1: 		if (databaseLocale != null) {
1: 			if (timestampFormat == null) {
1: 				timestampFormat = DateFormat.getDateTimeInstance(
1: 															DateFormat.LONG,
1: 															DateFormat.LONG,
1: 															databaseLocale);
1: 			}
1: 
1: 			return timestampFormat;
1: 		}
1: 
1: 		throw noLocale();
1: 	}
1: 
1: 	private static StandardException noLocale() {
1: 		return StandardException.newException(SQLState.NO_LOCALE);
1: 	}
1: 
1: 	public void setLocale(Locale locale) {
1: 		databaseLocale = locale;
1: 
1: 		dateFormat = null;
1: 		timeFormat = null;
1: 		timestampFormat = null;
1: 	}
1: 
1: 	/**
1: 		Is the database active (open).
1: 	*/
1: 	public boolean isActive() {
1: 		return active;
1: 	}
1: 
1: 	/*
1: 	 * class interface
1: 	 */
1: 	public BasicDatabase() {
1: 		lastToBoot = true;
1: 	}
1: 
1: 
1: 	protected	UUID	makeDatabaseID(boolean create, Properties startParams)
1: 		throws StandardException
1: 	{
1: 		
1: 		TransactionController tc = af.getTransaction(
0: 				ContextService.getFactory().getCurrentContextManager());
1: 
1: 		String  upgradeID = null;
1: 		UUID	databaseID;
1: 
1: 		if ((databaseID = (UUID) tc.getProperty(DataDictionary.DATABASE_ID)) == null) {
1: 
1: 			// no property defined in the Transaction set
1: 			// this could be an upgrade, see if it's stored in the service set
1: 
0: 			UUIDFactory	uuidFactory  = Monitor.getMonitor().getUUIDFactory();
1: 
1: 			
1: 			upgradeID = startParams.getProperty(DataDictionary.DATABASE_ID);
1: 			if (upgradeID == null )
1: 			{
1: 				// just create one
1: 				databaseID = uuidFactory.createUUID();
1: 			} else {
1: 				databaseID = uuidFactory.recreateUUID(upgradeID);
1: 			}
1: 
1: 			tc.setProperty(DataDictionary.DATABASE_ID, databaseID, true);
1: 		}
1: 
1: 		// Remove the database identifier from the service.properties
1: 		// file only if we upgraded it to be stored in the transactional
1: 		// property set.
1: 		if (upgradeID != null)
1: 			startParams.remove(DataDictionary.DATABASE_ID);
1: 
1: 		tc.commit();
1: 		tc.destroy();
1: 
1: 		return databaseID;
1: 	}
1: 
1: 	/**
0: 	 * Drop all Stored Prepared Statements that
0: 	 * have been created for JDBC MetaData queries.
0: 	 * Does NOT commit the current transaction
0: 	 * upon completation.  
1: 	 *
0: 	 * @exception SQLException on error, most likely
0: 	 *			a deadlock or timeout.
1: 	 */
0: 	public void dropAllJDBCMetaDataSPSes() throws SQLException
1: 	{
0: 		try
1: 		{
0: 			LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
1: 
0: 			DataDictionary dd = lcc.getDataDictionary();
1: 
0: 			TransactionController tc = lcc.getTransactionExecute();
1: 
1: 			/*
0: 			** Inform the data dictionary we are going
0: 			** to perform some DDL
1: 			*/
0: 			dd.startWriting(lcc);
1: 
0: 			for (java.util.ListIterator li = dd.getAllSPSDescriptors().listIterator(); li.hasNext(); )
1: 			{
0: 				SPSDescriptor spsd = (SPSDescriptor) li.next();
1: 
1: 				/*
0: 				** Is it in SYS? if so, zap it. Can't drop metadata SPS in SYSIBM, JCC depends on it.
1: 				*/
0: 				if (spsd.getSchemaDescriptor().isSystemSchema() && !spsd.getSchemaDescriptor().isSYSIBM())
1: 				{
0: 					dd.dropSPSDescriptor(spsd, tc);
0: 					dd.dropDependentsStoredDependencies(spsd.getUUID(), tc);
1: 				}
1: 			}
0: 		} catch (StandardException se)
1: 		{
1: 			throw PublicAPI.wrapStandardException(se);
1: 		}
1: 	}
1: 
1: 	/*
1: 	** Return an Object instead of a ResourceAdapter
1: 	** so that XA classes are only used where needed;
1: 	** caller must cast to ResourceAdapter.
1: 	*/
1: 	public Object getResourceAdapter()
1: 	{
1: 		return resourceAdapter;
1: 	}
1: 
1: 	/*
1: 	** Methods of PropertySetCallback
1: 	*/
1: 	public void init(boolean dbOnly, Dictionary p) {
1: 		// not called yet ...
1: 	}
1: 
1: 	/**
1: 	  @see PropertySetCallback#validate
1: 	  @exception StandardException Thrown on error.
1: 	*/
1: 	public boolean validate(String key,
1: 						 Serializable value,
1: 						 Dictionary p)
1: 		throws StandardException
1: 	{
1: 		//
1: 		//Disallow setting static creation time only configuration properties
1: 	    if (key.equals(EngineType.PROPERTY))
1: 			throw StandardException.newException(SQLState.PROPERTY_UNSUPPORTED_CHANGE, key, value);
1: 	
1: 		// only interested in the classpath
1: 		if (!key.equals(Property.DATABASE_CLASSPATH)) return false;
1: 
1: 		String newClasspath = (String) value;
1: 		String[][] dbcp = null; //The parsed dbclasspath
1: 
1: 		if (newClasspath != null) {
1: 			// parse it when it is set to ensure only valid values
1: 			// are written to the actual conglomerate.
0: 			dbcp = IdUtil.parseDbClassPath(newClasspath, normalizeToUpper);
1: 		}
1: 
0: 		DataDictionaryContext ddc =
0: 			(DataDictionaryContext)ContextService.getContext(DataDictionaryContext.CONTEXT_ID);
1: 		if (SanityManager.DEBUG)
0: 			if (ddc == null) SanityManager.THROWASSERT("Class path change with no connection");
0: 		DataDictionary dd = ddc.getDataDictionary();
1: 
1: 		//
1: 		//Verify that all jar files on the database classpath are in the data dictionary.
1: 		if (dbcp != null)
1: 		{
1: 			for (int ix=0;ix<dbcp.length;ix++)
1: 			{
1: 				SchemaDescriptor sd = dd.getSchemaDescriptor(dbcp[ix][IdUtil.DBCP_SCHEMA_NAME], null, false);
1: 
1:                 FileInfoDescriptor fid = null;	
1: 				if (sd != null) 
1: 					fid = dd.getFileInfoDescriptor(sd,dbcp[ix][IdUtil.DBCP_SQL_JAR_NAME]);			
1: 
1: 				if (fid == null){
1: 					throw StandardException.newException(SQLState.LANG_DB_CLASS_PATH_HAS_MISSING_JAR						, IdUtil.mkQualifiedName(dbcp[ix]));
1: 				}
1: 			}
1: 		}
1: 
1: 		return true;
1: 	}
1: 	/**
1: 	  @see PropertySetCallback#apply
1: 	  @exception StandardException Thrown on error.
1: 	*/
1: 	public Serviceable apply(String key, Serializable value, Dictionary p)
1: 		throws StandardException
1: 	{
1: 		// only interested in the classpath
1: 		if (!key.equals(Property.DATABASE_CLASSPATH)) return null;
1: 
1: 		// only do the change dynamically if we are already
1: 		// a per-database classapath.
1: 		if (cfDB != null) {
0: 			DataDictionaryContext ddc =
0: 				(DataDictionaryContext)ContextService.getContext(DataDictionaryContext.CONTEXT_ID);
1: 			if (SanityManager.DEBUG)
0: 				if (ddc == null) SanityManager.THROWASSERT("Class path change with no connection");
0: 			DataDictionary dd = ddc.getDataDictionary();
1: 
1: 			//
1: 			// Invalidate stored plans.
0: 			dd.invalidateAllSPSPlans();
1: 		
1: 			String newClasspath = (String) value;
1: 			if (newClasspath == null) newClasspath = "";
1: 			cfDB.notifyModifyClasspath(newClasspath);
1: 		}
1: 		return null;
1: 	}
1: 	/**
1: 	  @see PropertySetCallback#map
1: 	*/
1: 	public Serializable map(String key,Serializable value,Dictionary p)
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/*
1: 	 * methods specific to this class 
1: 	 */
1: 	protected void createFinished() throws StandardException
1: 	{
1: 		// find the access factory and tell it that database creation has
1: 		// finished
1: 		af.createFinished();
1: 	}
1: 
1: 	protected String getClasspath(Properties startParams) {
1: 		String cp = PropertyUtil.getPropertyFromSet(startParams, Property.DATABASE_CLASSPATH);
1: 		if (cp == null)
1: 			cp = PropertyUtil.getSystemProperty(Property.DATABASE_CLASSPATH, "");
1: 		return cp;
1: 	}
1: 
1: 
1: 	protected void bootClassFactory(boolean create,
1: 								  Properties startParams) 
1: 		 throws StandardException
1: 	{ 
1: 			String classpath = getClasspath(startParams);
1: 
1: 			// parse the class path and allow 2 part names.
0:             boolean normalizeToUpper = true;
0: 			String[][] elements =
0: 				IdUtil.parseDbClassPath(classpath, normalizeToUpper);
1: 
1: 			startParams.put(Property.BOOT_DB_CLASSPATH, classpath);
0: 			cfDB = (ClassFactory) Monitor.bootServiceModule(create, this,
1: 					org.apache.derby.iapi.reference.Module.ClassFactory, startParams);
1: 	}
1: 
1: 
1: 	/*
1: 	** Methods to allow sub-classes to offer alternate implementations.
1: 	*/
1: 
1: 	protected TransactionController getConnectionTransaction(ContextManager cm)
1: 		throws StandardException {
1: 
1: 		// start a local transaction
1: 		return af.getTransaction(cm);
1: 	}
1: 
1: 	protected AuthenticationService bootAuthenticationService(boolean create, Properties props) throws StandardException {
1: 		return (AuthenticationService)
0: 				Monitor.bootServiceModule(create, this, AuthenticationService.MODULE, props);
1: 	}
1: 
1: 	protected void bootValidation(boolean create, Properties startParams)
1: 		throws StandardException {
0: 		pf = (PropertyFactory) Monitor.bootServiceModule(create, this,
1: 			org.apache.derby.iapi.reference.Module.PropertyFactory, startParams);
1: 	}
1: 
1: 	protected void bootStore(boolean create, Properties startParams)
1: 		throws StandardException {
0: 		af = (AccessFactory) Monitor.bootServiceModule(create, this, AccessFactory.MODULE, startParams);
1: 	}
1: 
1: 	protected Properties getAllDatabaseProperties()
1: 		throws StandardException {
1: 
1: 		TransactionController tc = af.getTransaction(
0:                     ContextService.getFactory().getCurrentContextManager());
1: 		Properties dbProps = tc.getProperties();
1: 		tc.commit();
1: 		tc.destroy();
1: 
1: 		return dbProps;
1: 	}
1: 
0: 	protected void bootResourceAdapter(boolean create, Properties startParams) {
1: 
1: 		// Boot resource adapter - only if we are running Java 2 or
1: 		// beyondwith JDBC20 extension, JTA and JNDI classes in the classpath
1: 		//
1: 		// assume if it doesn't boot it was because the required
1: 		// classes were missing, and continue without it.
1: 		// Done this way to work around Chai's need to preload
1: 		// classes.
0: 		if (JVMInfo.JDK_ID >= 2)
1: 		{
0: 			// If we got here, both of these classes are in the class path.
0: 			// Assume we may need a ResourceAdapter since we don't know how
0: 			// this database is going to be used.
0: 			try
1: 			{
0: 				resourceAdapter = 
0: 					Monitor.bootServiceModule(create, this,
0: 											 ResourceAdapter.MODULE,
0: 											 allParams);
1: 			}
0: 			catch (StandardException mse)
1: 			{
0: 				// OK, resourceAdapter is an optional module
1: 			}
1: 		}
1: 	}
1: 
1: 	protected void pushClassFactoryContext(ContextManager cm, ClassFactory cf) {
1: 		new StoreClassFactoryContext(cm, cf, af, this);
1: 	}
1: 
1: 	/*
1: 	** Methods of JarReader
1: 	*/
0: 	public Object readJarFile(String schemaName, String sqlName)
1: 		throws StandardException {
1: 
0: 		DataDictionaryContext ddc =
0: 			(DataDictionaryContext) ContextService.getContext(DataDictionaryContext.CONTEXT_ID);
0: 		DataDictionary dd = ddc.getDataDictionary();
1: 
1: 		SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, null, true);
1: 		FileInfoDescriptor fid = dd.getFileInfoDescriptor(sd,sqlName);
1: 		if (fid == null)
1: 			throw StandardException.newException(SQLState.LANG_FILE_DOES_NOT_EXIST, sqlName,schemaName);
1: 
1: 		long generationId = fid.getGenerationId();
1: 
0: 		FileResource fr = af.getTransaction(ddc.getContextManager()).getFileHandler();
1: 
0: 		String externalName = org.apache.derby.impl.sql.execute.JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar());
1: 
0: 		Object f = fr.getAsFile(externalName, generationId);
0: 		if (f instanceof java.io.File)
0: 			return f;
1: 
1: 		try {
0: 			return fr.getAsStream(externalName, generationId);
0: 		} catch (java.io.IOException ioe) {
0: 			throw StandardException.newException(SQLState.LANG_FILE_ERROR, ioe.toString(),ioe);	
1: 		}
1: 	}
1: 
1: }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:722a889
/////////////////////////////////////////////////////////////////////////
1: 			String localeID = 
1:                 startParams.getProperty(
1:                     org.apache.derby.iapi.reference.Attribute.TERRITORY);
/////////////////////////////////////////////////////////////////////////
1: 		// registered types (DECIMAL) are there before logical undo recovery 
1:         // might need them.
1: 		DataValueFactory dvf = (DataValueFactory) 
0:             Monitor.bootServiceModule(
1:                 create, 
1:                 this,
1: 				org.apache.derby.iapi.reference.ClassName.DataValueFactory, 
1:                 startParams);
0: 
/////////////////////////////////////////////////////////////////////////
1: 		lcf = (LanguageConnectionFactory) 
0:             Monitor.bootServiceModule(
1:                 create, this, LanguageConnectionFactory.MODULE, allParams);
0: 
1: 		lf = (LanguageFactory) 
0:             Monitor.bootServiceModule(
1:                 create, this, LanguageFactory.MODULE, allParams);
/////////////////////////////////////////////////////////////////////////
1: 			SanityManager.ASSERT(
1:                 authenticationService != null,
0:                 "Failed to set the Authentication service for the database");
commit:ffd4e9b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:402725c
/////////////////////////////////////////////////////////////////////////
1:     public void backupAndEnableLogArchiveMode(String  backupDir, 
1:                                               boolean deleteOnlineArchivedLogFiles,
1:                                               boolean wait)
commit:fbb8866
/////////////////////////////////////////////////////////////////////////
1:     public void backup(String backupDir, boolean wait) 
0:         throws SQLException
0:     {
1: 			af.backup(backupDir, wait);
/////////////////////////////////////////////////////////////////////////
0:     public void backupAndEnableLogArchiveMode(
0:     String  backupDir, 
0:     boolean deleteOnlineArchivedLogFiles,
0:     boolean wait)
0:         throws SQLException
1: 			af.backupAndEnableLogArchiveMode(backupDir, 
1:                                              deleteOnlineArchivedLogFiles,
1:                                              wait); 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:David Van Couvering
-------------------------------------------------------------------------------
commit:75fb1cf
/////////////////////////////////////////////////////////////////////////
0:             throw StandardException.newException(SQLState.LANG_FILE_ERROR, ioe, ioe.toString());    
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.db
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.db;
0: 
0: import org.apache.derby.iapi.error.PublicAPI;
0: 
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.EngineType;
0: import org.apache.derby.iapi.util.DoubleProperties;
0: import org.apache.derby.iapi.util.IdUtil;
0: import org.apache.derby.iapi.services.info.JVMInfo;
0: 
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.loader.JarReader;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.daemon.Serviceable;
0: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.monitor.ModuleFactory;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.property.PersistentSet;
0: import org.apache.derby.iapi.db.Database;
0: import org.apache.derby.iapi.db.DatabaseContext;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.FileInfoDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
0: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.sql.LanguageFactory;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.store.access.AccessFactory;
0: import org.apache.derby.iapi.store.access.FileResource;
0: import org.apache.derby.iapi.services.property.PropertyFactory;
0: import org.apache.derby.iapi.services.property.PropertySetCallback;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.jdbc.AuthenticationService;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.jdbc.ResourceAdapter;
0: 
0: import java.io.InputStream;
0: import java.io.OutputStream;
0: import java.io.Serializable;
0: import java.io.File;
0: import java.sql.Date;
0: import java.sql.Timestamp;
0: import java.sql.SQLException;
0: import java.util.Properties;
0: import java.util.Dictionary;
0: import java.util.Enumeration;
0: import java.util.Hashtable;
0: import java.util.Locale;
0: import java.lang.reflect.Method;
0: import java.text.Collator;
0: import java.text.RuleBasedCollator;
0: import java.text.DateFormat;
0: 
0: /**
0:  * The Database interface provides control over the physical database
0:  * (that is, the stored data and the files the data are stored in),
0:  * connections to the database, operations on the database such as
0:  * backup and recovery, and all other things that are associated
0:  * with the database itself.
0:  * <p>
0:  * The Database interface does not provide control over things that are part of
0:  * the Domain, such as users.
0:  * <p>
0:  * I'm not sure what this will hold in a real system, for now
0:  * it simply provides connection-creation for us.  Perhaps when it boots,
0:  * it creates the datadictionary object for the database, which all users
0:  * will then interact with?
0:  *
0:  * @author ames
0:  */
0: 
0: public class BasicDatabase implements ModuleControl, ModuleSupportable, PropertySetCallback, Database, JarReader
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private boolean		active;
0: 	private AuthenticationService authenticationService;
0: 	protected AccessFactory af;
0: 	protected PropertyFactory pf;
0: 	protected ClassFactory cfDB; // classFactory but only set when per-database
0: 	protected LanguageConnectionFactory lcf;
0: 	protected LanguageFactory lf;
0: 	// hold resourceAdapter in an Object instead of a ResourceAdapter
0: 	// so that XA class use can be isolated to XA modules.
0: 	protected Object resourceAdapter;
0: 	private Locale databaseLocale;
0: 	private RuleBasedCollator ruleBasedCollator;
0: 	private int			spaceInt;
0: 	private boolean		spaceIntSet;
0: 	private DateFormat dateFormat;
0: 	private DateFormat timeFormat;
0: 	private DateFormat timestampFormat;
0: 	private UUID		myUUID;
0:     private boolean normalizeToUpper = true;
0: 
0: 	protected boolean lastToBoot; // is this class last to boot
0: 
0: 	/*
0: 	 * ModuleControl interface
0: 	 */
0: 
0: 	public boolean canSupport(Properties startParams) {
0: 
0: 		return Monitor.isDesiredCreateType(startParams, org.apache.derby.iapi.reference.EngineType.NONE);
0: 
0: 	}
0: 
0: 	protected Properties allParams;	// properties to be used *only* while booting.
0: 
0: 	public void boot(boolean create, Properties startParams)
0: 		throws StandardException
0: 	{
0: 		ModuleFactory monitor = Monitor.getMonitor();
0: 		if (create)
0: 		{
0: 			if (startParams.getProperty(Property.CREATE_WITH_NO_LOG) == null)
0: 				startParams.put(Property.CREATE_WITH_NO_LOG, "true");
0: 
0: 			String localeID = startParams.getProperty(org.apache.derby.iapi.reference.Attribute.TERRITORY);
0: 
0: 			if (localeID == null) {
0: 				localeID = Locale.getDefault().toString();
0: 			}
0: 			databaseLocale = monitor.setLocale(startParams, localeID);
0: 
0: 		} else {
0: 			databaseLocale = monitor.getLocale(this);
0: 		}
0: 		setLocale(databaseLocale);
0: 
0:         normalizeToUpper = true;
0:         
0: 
0: 		// boot the validation needed to do property validation, now property
0: 		// validation is separated from AccessFactory, therefore from store
0: 		bootValidation(create, startParams);
0: 
0: 		bootStore(create, startParams);
0: 
0: 		// create a database ID if one doesn't already exist
0: 		myUUID = makeDatabaseID(create, startParams);
0: 
0: 
0: 		allParams = new DoubleProperties(getAllDatabaseProperties(), startParams);
0: 
0: 		if (pf != null)
0: 			pf.addPropertySetNotification(this);
0: 
0: 			// Boot the ClassFactory, will be per-database or per-system.
0: 			// reget the tc in case someone inadverdently destroyed it 
0: 		bootClassFactory(create, allParams);
0: 
0: 		lcf = (LanguageConnectionFactory) Monitor.bootServiceModule(create, this, LanguageConnectionFactory.MODULE, allParams);
0: 		lf = (LanguageFactory) Monitor.bootServiceModule(create, this, LanguageFactory.MODULE, allParams);
0: 
0: 		bootResourceAdapter(create, startParams);
0: 
0: 
0: 		// may also want to set up a check that we are a singleton,
0: 		// or that there isn't already a database object in the system
0: 		// for the same database?
0: 
0: 
0: 		//
0: 		// We boot the authentication service. There should at least be one
0: 		// per database (even if authentication is turned off) .
0: 		//
0: 		authenticationService = bootAuthenticationService(create, allParams);
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(authenticationService != null,
0: 								 "Failed to set the Authentication service for the database");
0: 		}
0: 
0: 		// Lastly, let store knows that database creation is done and turn
0: 		// on logging
0: 		if (create && lastToBoot &&
0: 			(startParams.getProperty(Property.CREATE_WITH_NO_LOG) != null))
0: 		{
0: 			createFinished();
0: 		}
0: 
0: 		active = true;
0: 
0: 		if (lastToBoot)
0: 			allParams = null; // should not be used anymore
0: 	}
0: 
0: 	public void stop() {
0: 		active = false;
0: 	}
0: 
0: 	/*
0: 	** Methods related to  ModuleControl
0: 	*/
0: 
0: 	/*
0: 	 * Database interface
0:  	 */
0: 
0: 	/**
0: 	  *	@return	one of the values from EngineType.java:
0: 	  *
0: 	  */
0: 	public	int	getEngineType() { return org.apache.derby.iapi.reference.EngineType.NONE; }
0: 
0: 	public boolean isReadOnly()
0: 	{
0: 		//
0: 		//Notice if no full users?
0: 		//RESOLVE: (Make access factory check?)
0: 		return af.isReadOnly();
0: 	}
0: 
0: 	public LanguageConnectionContext setupConnection(ContextManager cm, String user, String drdaID, String dbname)
0: 		throws StandardException {
0: 
0: 		TransactionController tc = getConnectionTransaction(cm);
0: 
0: 		cm.setLocaleFinder(this);
0: 		pushDbContext(cm);
0: 
0: 		// push a database shutdown context
0: 		// we also need to push a language connection context.
0: 		LanguageConnectionContext lctx = lcf.newLanguageConnectionContext(cm, tc, lf, this, user, drdaID, dbname);
0: 
0: 		// push the context that defines our class factory
0: 		pushClassFactoryContext(cm, lcf.getClassFactory());
0: 
0: 		// we also need to push an execution context.
0: 		ExecutionFactory ef = lcf.getExecutionFactory();
0: 
0: 		ef.newExecutionContext(cm);
0: 		//
0: 		//Initialize our language connection context. Note: This is
0: 		//a bit of a hack. Unfortunately, we can't initialize this
0: 		//when we push it. We first must push a few more contexts. 
0: 		lctx.initialize(true);		
0: 
0: 		// Need to commit this to release locks gotten in initialize.  
0: 		// Commit it but make sure transaction not have any updates. 
0: 		lctx.internalCommitNoSync(
0: 			TransactionController.RELEASE_LOCKS |
0: 			TransactionController.READONLY_TRANSACTION_INITIALIZATION);
0: 
0: 		return lctx;
0: 
0: 	}
0: 
0: 	public void pushDbContext(ContextManager cm)
0: 	{
0: 		/* We cache the locale in the DatabaseContext
0: 		 * so that the Datatypes can get to it easily.
0: 		 */
0: 		DatabaseContext dc = new DatabaseContextImpl(cm, this);
0: 	}
0: 
0: 	public final AuthenticationService getAuthenticationService() {
0: 
0: 		// Expected to find one - Sanity check being done at
0: 		// DB boot-up.
0: 
0: 		// We should have a Authentication Service
0: 		//
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(this.authenticationService != null, 
0: 				"Unexpected - There is no valid authentication service for the database!");
0: 		}
0: 		return this.authenticationService;
0: 	}
0: 
0: 	public void freeze() throws SQLException
0: 	{
0: 		try {
0: 			af.freeze();
0: 		} catch (StandardException se) {
0: 			throw PublicAPI.wrapStandardException(se);
0: 		}
0: 	}
0: 
0: 	public void unfreeze() throws SQLException
0: 	{
0: 		try {
0: 			af.unfreeze();
0: 		} catch (StandardException se) {
0: 			throw PublicAPI.wrapStandardException(se);
0: 		}
0: 	}
0: 
0: 
0: 	public void backup(String backupDir) throws SQLException
0: 	{
0: 		try {
0: 			af.backup(backupDir);
0: 		} catch (StandardException se) {
0: 			throw PublicAPI.wrapStandardException(se);
0: 		}
0: 	}
0: 
0: 
0: 	public void backup(File backupDir) throws SQLException
0: 	{
0: 		try {
0: 			af.backup(backupDir);
0: 		} catch (StandardException se) {
0: 			throw PublicAPI.wrapStandardException(se);
0: 		}
0: 	}
0: 
0: 
0: 
0: 	public void backupAndEnableLogArchiveMode(String backupDir, 
0: 											  boolean
0: 											  deleteOnlineArchivedLogFiles)
0: 		throws SQLException
0: 	{
0: 		try {
0: 			af.backupAndEnableLogArchiveMode(backupDir, deleteOnlineArchivedLogFiles);
0: 		} catch (StandardException se) {
0: 			throw PublicAPI.wrapStandardException(se);
0: 		}
0: 	}
0: 
0: 	public void backupAndEnableLogArchiveMode(File backupDir, 
0: 											  boolean
0: 											  deleteOnlineArchivedLogFiles)
0: 		throws SQLException
0: 	{
0: 		try {
0: 			af.backupAndEnableLogArchiveMode(backupDir, deleteOnlineArchivedLogFiles);
0: 		} catch (StandardException se) {
0: 			throw PublicAPI.wrapStandardException(se);
0: 		}
0: 	}
0: 	
0: 	public void disableLogArchiveMode(boolean deleteOnlineArchivedLogFiles)
0: 		throws SQLException
0: 	{
0: 		try{
0: 			af.disableLogArchiveMode(deleteOnlineArchivedLogFiles);
0: 		}catch (StandardException se) {
0: 			throw PublicAPI.wrapStandardException(se);
0: 		}
0: 	}
0: 
0: 
0: 	public void	checkpoint() throws SQLException
0: 	{
0: 		try {
0: 			af.checkpoint();
0: 		} catch (StandardException se) {
0: 			throw PublicAPI.wrapStandardException(se);
0: 		}
0: 	}
0: 
0: 	/* Methods from org.apache.derby.database.Database */
0: 	public Locale getLocale() {
0: 		return databaseLocale;
0: 	}
0: 
0: 
0: 	/**
0: 		Return the UUID of this database.
0: 	*/
0: 	public final UUID getId() {
0: 		return myUUID;
0: 	}
0: 
0: 	/* LocaleFinder methods */
0: 
0: 	/** @exception StandardException	Thrown on error */
0: 	public Locale getCurrentLocale() throws StandardException {
0: 		if (databaseLocale != null)
0: 			return databaseLocale;
0: 		throw noLocale();
0: 	}
0: 
0: 	/** @exception StandardException	Thrown on error */
0: 	public RuleBasedCollator getCollator() throws StandardException {
0: 		RuleBasedCollator retval = ruleBasedCollator;
0: 
0: 		if (retval == null) {
0: 			if (databaseLocale != null) {
0: 				retval = ruleBasedCollator =
0: 					(RuleBasedCollator) Collator.getInstance(databaseLocale);
0: 			} else {
0: 				throw noLocale();
0: 			}
0: 		}
0: 
0: 		return retval;
0: 	}
0: 
0: 
0: 	/** @exception StandardException	Thrown on error */
0: 	public DateFormat getDateFormat() throws StandardException {
0: 		if (databaseLocale != null) {
0: 			if (dateFormat == null) {
0: 				dateFormat = DateFormat.getDateInstance(DateFormat.LONG,
0: 																databaseLocale);
0: 			}
0: 
0: 			return dateFormat;
0: 		}
0: 
0: 		throw noLocale();
0: 	}
0: 
0: 	/** @exception StandardException	Thrown on error */
0: 	public DateFormat getTimeFormat() throws StandardException {
0: 		if (databaseLocale != null) {
0: 			if (timeFormat == null) {
0: 				timeFormat = DateFormat.getTimeInstance(DateFormat.LONG,
0: 																databaseLocale);
0: 			}
0: 
0: 			return timeFormat;
0: 		}
0: 
0: 		throw noLocale();
0: 	}
0: 
0: 	/** @exception StandardException	Thrown on error */
0: 	public DateFormat getTimestampFormat() throws StandardException {
0: 		if (databaseLocale != null) {
0: 			if (timestampFormat == null) {
0: 				timestampFormat = DateFormat.getDateTimeInstance(
0: 															DateFormat.LONG,
0: 															DateFormat.LONG,
0: 															databaseLocale);
0: 			}
0: 
0: 			return timestampFormat;
0: 		}
0: 
0: 		throw noLocale();
0: 	}
0: 
0: 	private static StandardException noLocale() {
0: 		return StandardException.newException(SQLState.NO_LOCALE);
0: 	}
0: 
0: 	public void setLocale(Locale locale) {
0: 		databaseLocale = locale;
0: 
0: 		dateFormat = null;
0: 		timeFormat = null;
0: 		timestampFormat = null;
0: 	}
0: 
0: 	/**
0: 		Is the database active (open).
0: 	*/
0: 	public boolean isActive() {
0: 		return active;
0: 	}
0: 
0: 	/*
0: 	 * class interface
0: 	 */
0: 	public BasicDatabase() {
0: 		lastToBoot = true;
0: 	}
0: 
0: 
0: 	protected	UUID	makeDatabaseID(boolean create, Properties startParams)
0: 		throws StandardException
0: 	{
0: 		
0: 		TransactionController tc = af.getTransaction(
0: 				ContextService.getFactory().getCurrentContextManager());
0: 
0: 		String  upgradeID = null;
0: 		UUID	databaseID;
0: 
0: 		if ((databaseID = (UUID) tc.getProperty(DataDictionary.DATABASE_ID)) == null) {
0: 
0: 			// no property defined in the Transaction set
0: 			// this could be an upgrade, see if it's stored in the service set
0: 
0: 			UUIDFactory	uuidFactory  = Monitor.getMonitor().getUUIDFactory();
0: 
0: 			
0: 			upgradeID = startParams.getProperty(DataDictionary.DATABASE_ID);
0: 			if (upgradeID == null )
0: 			{
0: 				// just create one
0: 				databaseID = uuidFactory.createUUID();
0: 			} else {
0: 				databaseID = uuidFactory.recreateUUID(upgradeID);
0: 			}
0: 
0: 			tc.setProperty(DataDictionary.DATABASE_ID, databaseID, true);
0: 		}
0: 
0: 		// Remove the database identifier from the service.properties
0: 		// file only if we upgraded it to be stored in the transactional
0: 		// property set.
0: 		if (upgradeID != null)
0: 			startParams.remove(DataDictionary.DATABASE_ID);
0: 
0: 		tc.commit();
0: 		tc.destroy();
0: 
0: 		return databaseID;
0: 	}
0: 
0: 	/**
0: 	 * Drop all Stored Prepared Statements that
0: 	 * have been created for JDBC MetaData queries.
0: 	 * Does NOT commit the current transaction
0: 	 * upon completation.  
0: 	 *
0: 	 * @exception SQLException on error, most likely
0: 	 *			a deadlock or timeout.
0: 	 */
0: 	public void dropAllJDBCMetaDataSPSes() throws SQLException
0: 	{
0: 		try
0: 		{
0: 			LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
0: 
0: 			DataDictionary dd = lcc.getDataDictionary();
0: 
0: 			TransactionController tc = lcc.getTransactionExecute();
0: 
0: 			/*
0: 			** Inform the data dictionary we are going
0: 			** to perform some DDL
0: 			*/
0: 			dd.startWriting(lcc);
0: 
0: 			for (java.util.ListIterator li = dd.getAllSPSDescriptors().listIterator(); li.hasNext(); )
0: 			{
0: 				SPSDescriptor spsd = (SPSDescriptor) li.next();
0: 
0: 				/*
0: 				** Is it in SYS? if so, zap it. Can't drop metadata SPS in SYSIBM, JCC depends on it.
0: 				*/
0: 				if (spsd.getSchemaDescriptor().isSystemSchema() && !spsd.getSchemaDescriptor().isSYSIBM())
0: 				{
0: 					dd.dropSPSDescriptor(spsd, tc);
0: 					dd.dropDependentsStoredDependencies(spsd.getUUID(), tc);
0: 				}
0: 			}
0: 		} catch (StandardException se)
0: 		{
0: 			throw PublicAPI.wrapStandardException(se);
0: 		}
0: 	}
0: 
0: 	/*
0: 	** Return an Object instead of a ResourceAdapter
0: 	** so that XA classes are only used where needed;
0: 	** caller must cast to ResourceAdapter.
0: 	*/
0: 	public Object getResourceAdapter()
0: 	{
0: 		return resourceAdapter;
0: 	}
0: 
0: 	/*
0: 	** Methods of PropertySetCallback
0: 	*/
0: 	public void init(boolean dbOnly, Dictionary p) {
0: 		// not called yet ...
0: 	}
0: 
0: 	/**
0: 	  @see PropertySetCallback#validate
0: 	  @exception StandardException Thrown on error.
0: 	*/
0: 	public boolean validate(String key,
0: 						 Serializable value,
0: 						 Dictionary p)
0: 		throws StandardException
0: 	{
0: 		//
0: 		//Disallow setting static creation time only configuration properties
0: 	    if (key.equals(EngineType.PROPERTY))
0: 			throw StandardException.newException(SQLState.PROPERTY_UNSUPPORTED_CHANGE, key, value);
0: 	
0: 		// only interested in the classpath
0: 		if (!key.equals(Property.DATABASE_CLASSPATH)) return false;
0: 
0: 		String newClasspath = (String) value;
0: 		String[][] dbcp = null; //The parsed dbclasspath
0: 
0: 		if (newClasspath != null) {
0: 			// parse it when it is set to ensure only valid values
0: 			// are written to the actual conglomerate.
0: 			dbcp = IdUtil.parseDbClassPath(newClasspath, normalizeToUpper);
0: 		}
0: 
0: 		DataDictionaryContext ddc =
0: 			(DataDictionaryContext)ContextService.getContext(DataDictionaryContext.CONTEXT_ID);
0: 		if (SanityManager.DEBUG)
0: 			if (ddc == null) SanityManager.THROWASSERT("Class path change with no connection");
0: 		DataDictionary dd = ddc.getDataDictionary();
0: 
0: 		//
0: 		//Verify that all jar files on the database classpath are in the data dictionary.
0: 		if (dbcp != null)
0: 		{
0: 			for (int ix=0;ix<dbcp.length;ix++)
0: 			{
0: 				SchemaDescriptor sd = dd.getSchemaDescriptor(dbcp[ix][IdUtil.DBCP_SCHEMA_NAME], null, false);
0: 
0:                 FileInfoDescriptor fid = null;	
0: 				if (sd != null) 
0: 					fid = dd.getFileInfoDescriptor(sd,dbcp[ix][IdUtil.DBCP_SQL_JAR_NAME]);			
0: 
0: 				if (fid == null){
0: 					throw StandardException.newException(SQLState.LANG_DB_CLASS_PATH_HAS_MISSING_JAR						, IdUtil.mkQualifiedName(dbcp[ix]));
0: 				}
0: 			}
0: 		}
0: 
0: 		return true;
0: 	}
0: 	/**
0: 	  @see PropertySetCallback#apply
0: 	  @exception StandardException Thrown on error.
0: 	*/
0: 	public Serviceable apply(String key, Serializable value, Dictionary p)
0: 		throws StandardException
0: 	{
0: 		// only interested in the classpath
0: 		if (!key.equals(Property.DATABASE_CLASSPATH)) return null;
0: 
0: 		// only do the change dynamically if we are already
0: 		// a per-database classapath.
0: 		if (cfDB != null) {
0: 			DataDictionaryContext ddc =
0: 				(DataDictionaryContext)ContextService.getContext(DataDictionaryContext.CONTEXT_ID);
0: 			if (SanityManager.DEBUG)
0: 				if (ddc == null) SanityManager.THROWASSERT("Class path change with no connection");
0: 			DataDictionary dd = ddc.getDataDictionary();
0: 
0: 			//
0: 			// Invalidate stored plans.
0: 			dd.invalidateAllSPSPlans();
0: 		
0: 			String newClasspath = (String) value;
0: 			if (newClasspath == null) newClasspath = "";
0: 			cfDB.notifyModifyClasspath(newClasspath);
0: 		}
0: 		return null;
0: 	}
0: 	/**
0: 	  @see PropertySetCallback#map
0: 	*/
0: 	public Serializable map(String key,Serializable value,Dictionary p)
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/*
0: 	 * methods specific to this class 
0: 	 */
0: 	protected void createFinished() throws StandardException
0: 	{
0: 		// find the access factory and tell it that database creation has
0: 		// finished
0: 		af.createFinished();
0: 	}
0: 
0: 	protected String getClasspath(Properties startParams) {
0: 		String cp = PropertyUtil.getPropertyFromSet(startParams, Property.DATABASE_CLASSPATH);
0: 		if (cp == null)
0: 			cp = PropertyUtil.getSystemProperty(Property.DATABASE_CLASSPATH, "");
0: 		return cp;
0: 	}
0: 
0: 
0: 	protected void bootClassFactory(boolean create,
0: 								  Properties startParams) 
0: 		 throws StandardException
0: 	{ 
0: 			String classpath = getClasspath(startParams);
0: 
0: 			// parse the class path and allow 2 part names.
0:             boolean normalizeToUpper = true;
0: 			String[][] elements =
0: 				IdUtil.parseDbClassPath(classpath, normalizeToUpper);
0: 
0: 			startParams.put(Property.BOOT_DB_CLASSPATH, classpath);
0: 			cfDB = (ClassFactory) Monitor.bootServiceModule(create, this,
0: 					org.apache.derby.iapi.reference.Module.ClassFactory, startParams);
0: 	}
0: 
0: 
0: 	/*
0: 	** Methods to allow sub-classes to offer alternate implementations.
0: 	*/
0: 
0: 	protected TransactionController getConnectionTransaction(ContextManager cm)
0: 		throws StandardException {
0: 
0: 		// start a local transaction
0: 		return af.getTransaction(cm);
0: 	}
0: 
0: 	protected AuthenticationService bootAuthenticationService(boolean create, Properties props) throws StandardException {
0: 		return (AuthenticationService)
0: 				Monitor.bootServiceModule(create, this, AuthenticationService.MODULE, props);
0: 	}
0: 
0: 	protected void bootValidation(boolean create, Properties startParams)
0: 		throws StandardException {
0: 		pf = (PropertyFactory) Monitor.bootServiceModule(create, this,
0: 			org.apache.derby.iapi.reference.Module.PropertyFactory, startParams);
0: 	}
0: 
0: 	protected void bootStore(boolean create, Properties startParams)
0: 		throws StandardException {
0: 		af = (AccessFactory) Monitor.bootServiceModule(create, this, AccessFactory.MODULE, startParams);
0: 	}
0: 
0: 	protected Properties getAllDatabaseProperties()
0: 		throws StandardException {
0: 
0: 		TransactionController tc = af.getTransaction(
0:                     ContextService.getFactory().getCurrentContextManager());
0: 		Properties dbProps = tc.getProperties();
0: 		tc.commit();
0: 		tc.destroy();
0: 
0: 		return dbProps;
0: 	}
0: 
0: 	protected void bootResourceAdapter(boolean create, Properties startParams) {
0: 
0: 		// Boot resource adapter - only if we are running Java 2 or
0: 		// beyondwith JDBC20 extension, JTA and JNDI classes in the classpath
0: 		//
0: 		// assume if it doesn't boot it was because the required
0: 		// classes were missing, and continue without it.
0: 		// Done this way to work around Chai's need to preload
0: 		// classes.
0: 		if (JVMInfo.JDK_ID >= 2)
0: 		{
0: 			// If we got here, both of these classes are in the class path.
0: 			// Assume we may need a ResourceAdapter since we don't know how
0: 			// this database is going to be used.
0: 			try
0: 			{
0: 				resourceAdapter = 
0: 					Monitor.bootServiceModule(create, this,
0: 											 ResourceAdapter.MODULE,
0: 											 allParams);
0: 			}
0: 			catch (StandardException mse)
0: 			{
0: 				// OK, resourceAdapter is an optional module
0: 			}
0: 		}
0: 	}
0: 
0: 	protected void pushClassFactoryContext(ContextManager cm, ClassFactory cf) {
0: 		new StoreClassFactoryContext(cm, cf, af, this);
0: 	}
0: 
0: 	/*
0: 	** Methods of JarReader
0: 	*/
0: 	public Object readJarFile(String schemaName, String sqlName)
0: 		throws StandardException {
0: 
0: 		DataDictionaryContext ddc =
0: 			(DataDictionaryContext) ContextService.getContext(DataDictionaryContext.CONTEXT_ID);
0: 		DataDictionary dd = ddc.getDataDictionary();
0: 
0: 		SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, null, true);
0: 		FileInfoDescriptor fid = dd.getFileInfoDescriptor(sd,sqlName);
0: 		if (fid == null)
0: 			throw StandardException.newException(SQLState.LANG_FILE_DOES_NOT_EXIST, sqlName,schemaName);
0: 
0: 		long generationId = fid.getGenerationId();
0: 
0: 		FileResource fr = af.getTransaction(ddc.getContextManager()).getFileHandler();
0: 
0: 		String externalName = org.apache.derby.impl.sql.execute.JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar());
0: 
0: 		Object f = fr.getAsFile(externalName, generationId);
0: 		if (f instanceof java.io.File)
0: 			return f;
0: 
0: 		try {
0: 			return fr.getAsStream(externalName, generationId);
0: 		} catch (java.io.IOException ioe) {
0: 			throw StandardException.newException(SQLState.LANG_FILE_ERROR, ioe.toString(),ioe);	
0: 		}
0: 	}
0: 
0: }
============================================================================