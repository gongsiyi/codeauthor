2:eac0369: /*
9:eac0369: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.types.SQLTime
1:7ecc1f2: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.types;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.context.ContextService;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.db.DatabaseContext;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.i18n.LocaleFinder;
1:eac0369: import org.apache.derby.iapi.services.cache.ClassSize;
1:eac0369: import org.apache.derby.iapi.util.StringUtil;
1:eac0369: 
1:eac0369: import java.sql.Time;
1:eac0369: import java.sql.Timestamp;
1:e21adc5: import java.sql.PreparedStatement;
1:eac0369: 
1:eac0369: import java.util.Calendar;
1:eac0369: import java.util.GregorianCalendar;
1:eac0369: 
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.IOException;
1:eac0369: 
1:eac0369: import java.sql.ResultSet;
1:eac0369: import java.sql.SQLException;
1:eac0369: 
1:eac0369: import java.text.DateFormat;
1:eac0369: import java.text.ParseException;
1:eac0369: 
1:eac0369: /**
1:eac0369:  * This contains an instance of a SQL Time
1:eac0369:  * Our current implementation doesn't implement time precision so the fractional
1:eac0369:  * seconds portion of the time is always 0.  The default when no time precision
1:eac0369:  * is specified is 0 fractional seconds.  A SQL Time without timezone information
1:eac0369:  * is assumed to be in the local time zone.  The local time is stored as is
1:eac0369:  * and doesn't change if the timezone changes. This is in conformance with the
1:eac0369:  * SQL99 standard.  The SQL92 standard indicates that the time is in GMT and
1:eac0369:  * changes with the timezone.  The SQL99 standard clarifies this to allow time without
1:eac0369:  * timezoned to be stored as the local time.
1:eac0369:  * <p>
1:eac0369:  * Time is stored as two ints.  The first int represents hour, minute, second 
1:eac0369:  * and the second represents fractional seconds (currently 0 since we don't support
1:eac0369:  * time precision)
1:eac0369:  * 	encodedTime = -1 indicates null
1:eac0369:  *
1:eac0369:  * PERFORMANCE OPTIMIZATION:
1:eac0369:  *	The java.sql.Time object is only instantiated on demand for performance
1:eac0369:  * 	reasons.
1:eac0369:  */
1:eac0369: 
1:eac0369: public final class SQLTime extends DataType
1:eac0369: 						implements DateTimeDataValue
15:eac0369: {
1:eac0369: 
1:eac0369: 	private int		encodedTime;
1:eac0369: 	private int		encodedTimeFraction; //currently always 0 since we don't
1:eac0369: 											 //support time precision
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** DataValueDescriptor interface
1:eac0369: 	** (mostly implemented in DataType)
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLTime.class);
1:eac0369: 
1:eac0369:     public int estimateMemoryUsage()
1:eac0369:     {
1:320f6af:         return BASE_MEMORY_USAGE;
1:eac0369:     } // end of estimateMemoryUsage
1:eac0369: 
1:eac0369: 	public String getString()
1:eac0369: 	{
1:eac0369: 		if (!isNull())
1:eac0369: 		{
1:320f6af: 			return encodedTimeToString(encodedTime);
12:eac0369: 		}
2:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     int getEncodedTime()
1:eac0369:     {
1:eac0369:         return encodedTime;
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:0c7cafc:      * Convert a SQL TIME to a JDBC java.sql.Timestamp.
1:0c7cafc:      * 
1:0c7cafc:      * Behaviour is to set the date portion of the Timestamp
1:0c7cafc:      * to the actual current date, which may not match the
1:0c7cafc:      * SQL CURRENT DATE, which remains fixed for the lifetime
1:0c7cafc:      * of a SQL statement. JDBC drivers (especially network client drivers)
1:0c7cafc:      * could not be expected to fetch the CURRENT_DATE SQL value
1:0c7cafc:      * on every query that involved a TIME value, so the current
1:0c7cafc:      * date as seen by the JDBC client was picked as the logical behaviour.
1:0c7cafc:      * See DERBY-1811.
1:eac0369: 	 */
1:0c7cafc: 	public Timestamp getTimestamp( Calendar cal)
1:eac0369: 	{
2:eac0369: 		if (isNull())
1:eac0369: 			return null;
1:eac0369: 		else
1:eac0369: 		{
1:eac0369:             if( cal == null)
1:0c7cafc:             {
1:0c7cafc:                 // Calendar initialized to current date and time.
1:0c7cafc:                 cal = new GregorianCalendar(); 
1:0c7cafc:             }
1:0c7cafc:             else
1:0c7cafc:             {
1:0c7cafc:                 cal.clear();
1:a57602b:                 // Set Calendar to current date and time
1:a57602b:                 // to pick up the current date. Time portion
1:a57602b:                 // will be overridden by this value's time.
1:a57602b:                 cal.setTimeInMillis(System.currentTimeMillis());
1:0c7cafc:             }
1:a57602b:             
1:a57602b:             SQLTime.setTimeInCalendar(cal, encodedTime);
1:a57602b:           
1:0c7cafc:             // Derby's resolution for the TIME type is only seconds.
1:eac0369: 			cal.set(Calendar.MILLISECOND, 0);
1:0c7cafc:             
1:a57602b: 			return new Timestamp(cal.getTimeInMillis());
1:eac0369: 		}
1:eac0369: 	}
1:0c7cafc: 
1:eac0369: 	public Object getObject()
1:eac0369: 	{
1:eac0369: 		return getTime( (Calendar) null);
1:eac0369: 	}
1:eac0369: 		
1:eac0369: 	public int getLength()
1:eac0369: 	{
1:eac0369: 		return 8;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* this is for DataType's error generator */
1:eac0369: 	public String getTypeName()
1:eac0369: 	{
1:eac0369: 		return "TIME";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Storable interface, implies Externalizable, TypedFormat
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my format identifier.
1:eac0369: 
1:eac0369: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1:eac0369: 	*/
1:eac0369: 	public int getTypeFormatId() {
1:eac0369: 		return StoredFormatIds.SQL_TIME_ID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 		@exception IOException error writing data
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public void writeExternal(ObjectOutput out) throws IOException {
1:eac0369: 
8:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!isNull(), "writeExternal() is not supposed to be called for null values.");
1:eac0369: 
1:eac0369: 		out.writeInt(encodedTime);
1:eac0369: 		out.writeInt(encodedTimeFraction);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see java.io.Externalizable#readExternal
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException	Thrown on error reading the object
1:eac0369: 	 */
1:eac0369: 	public void readExternal(ObjectInput in) throws IOException
1:eac0369: 	{
2:eac0369: 		encodedTime = in.readInt();
2:eac0369: 		encodedTimeFraction = in.readInt();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:854dd10: 	/** @see DataValueDescriptor#cloneValue */
1:854dd10: 	public DataValueDescriptor cloneValue(boolean forceMaterialization)
1:eac0369: 	{
1:eac0369: 		// Call constructor with all of our info
1:eac0369: 		return new SQLTime(encodedTime, encodedTimeFraction);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DataValueDescriptor#getNewNull
1:eac0369: 	 */
1:eac0369: 	public DataValueDescriptor getNewNull()
1:eac0369: 	{
1:eac0369: 		return new SQLTime();
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public void restoreToNull()
1:eac0369: 	{
1:eac0369: 		encodedTime = -1;
1:eac0369: 		encodedTimeFraction = 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * @see DataValueDescriptor#setValueFromResultSet 
1:eac0369: 	 *
1:eac0369: 	 * @exception SQLException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
1:eac0369: 									  boolean isNullable)
1:eac0369: 		throws SQLException, StandardException
1:eac0369: 	{
2:eac0369: 			restoreToNull();
1:eac0369: 			encodedTime = computeEncodedTime(resultSet.getTime(colNumber));
1:eac0369: 			//need to set encodedTimeFraction when we implement time precision
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Orderable interface
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @see org.apache.derby.iapi.types.Orderable
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure
1:eac0369: 	 */
1:eac0369: 	public int compare(DataValueDescriptor other)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Use compare method from dominant type, negating result
1:eac0369: 		 * to reflect flipping of sides.
1:eac0369: 		 */
1:eac0369: 		if (typePrecedence() < other.typePrecedence())
1:eac0369: 		{
1:eac0369: 			return - (other.compare(this));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		boolean thisNull, otherNull;
1:eac0369: 
1:eac0369: 		thisNull = this.isNull();
1:eac0369: 		otherNull = other.isNull();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		 * thisNull otherNull	return
1:eac0369: 		 *	T		T		 	0	(this == other)
1:eac0369: 		 *	F		T		 	-1 	(this < other)
1:eac0369: 		 *	T		F		 	1	(this > other)
1:eac0369: 		 */
1:eac0369: 		if (thisNull || otherNull)
1:eac0369: 		{
1:eac0369: 			if (!thisNull)		// otherNull must be true
1:eac0369: 				return -1;
1:eac0369: 			if (!otherNull)		// thisNull must be true
1:eac0369: 				return 1;
1:eac0369: 			return 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 			Neither are null compare them 
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		int comparison;
1:eac0369: 
1:eac0369: 		/* get the comparison time values */
1:eac0369: 		int otherEncodedTime = 0;
1:eac0369: 
1:eac0369: 		/* if the argument is another Time look up the value
1:eac0369: 		 * we have already taken care of Null
1:eac0369: 		 * ignoring encodedTimeFraction for now since it is always 0
1:eac0369: 		 * - need to change this when we support TIME(precision)
1:eac0369: 		 */
1:eac0369: 		if (other instanceof SQLTime)
1:eac0369: 		{
1:eac0369: 			otherEncodedTime=((SQLTime)other).encodedTime;
1:eac0369: 		}
1:eac0369: 		else 
1:eac0369: 		{
1:eac0369: 			/* O.K. have to do it the hard way and calculate the numeric value
1:eac0369: 			 * from the value
1:eac0369: 			 */
1:eac0369: 			otherEncodedTime = computeEncodedTime(other.getTime( (Calendar) null));
1:eac0369: 		}
1:eac0369: 		if (encodedTime < otherEncodedTime)
1:eac0369: 			comparison = -1;
1:eac0369: 		else if (encodedTime > otherEncodedTime)
1:eac0369: 			comparison = 1;
1:eac0369: 		else
1:eac0369: 			comparison = 0;
1:eac0369: 
1:eac0369: 		return comparison;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean compare(int op,
1:eac0369: 						   DataValueDescriptor other,
1:eac0369: 						   boolean orderedNulls,
1:eac0369: 						   boolean unknownRV)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (!orderedNulls)		// nulls are unordered
1:eac0369: 		{
1:eac0369: 			if (this.isNull() || other.isNull())
1:eac0369: 				return unknownRV;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Do the comparison */
1:eac0369: 		return super.compare(op, other, orderedNulls, unknownRV);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Class interface
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Constructors
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/** no-arg constructor required by Formattable */
1:eac0369: 	public SQLTime() 
1:eac0369: 	{ 
1:eac0369: 		encodedTime = -1;	//null value
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public SQLTime(Time value) throws StandardException
1:eac0369: 	{
1:eac0369: 		parseTime(value);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     private void parseTime(java.util.Date value) throws StandardException
1:eac0369: 	{
1:eac0369: 		encodedTime = computeEncodedTime(value);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private SQLTime(int encodedTime, int encodedTimeFraction) {
1:eac0369: 		this.encodedTime = encodedTime;
1:eac0369: 		this.encodedTimeFraction = encodedTimeFraction;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Construct a time from a string. The allowed time formats are:
1:eac0369:      *<ol>
1:eac0369:      *<li>old ISO and IBM European standard: hh.mm[.ss]
1:eac0369:      *<li>IBM USA standard: hh[:mm] {AM | PM}
1:dbed020:      *<li>JIS and current ISO: hh:mm[:ss]
1:eac0369:      *</ol>
1:eac0369:      * 
1:f668d94:      * @exception StandardException if the syntax is invalid or the value is
1:f668d94:      * out of range
1:eac0369:      */
1:eac0369:     public SQLTime( String timeStr, boolean isJdbcEscape, LocaleFinder localeFinder)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         parseTime( timeStr, isJdbcEscape, localeFinder, (Calendar) null);
1:eac0369:     }
1:eac0369:     
1:eac0369:     /**
1:eac0369:      * Construct a time from a string. The allowed time formats are:
1:eac0369:      *<ol>
1:eac0369:      *<li>old ISO and IBM European standard: hh.mm[.ss]
1:eac0369:      *<li>IBM USA standard: hh[:mm] {AM | PM}
1:dbed020:      *<li>JIS and current ISO: hh:mm[:ss]
1:eac0369:      *</ol>
1:eac0369:      * 
1:f668d94:      * @exception StandardException if the syntax is invalid or the value is
1:f668d94:      * out of range
1:eac0369:      */
1:eac0369:     public SQLTime( String timeStr, boolean isJdbcEscape, LocaleFinder localeFinder, Calendar cal)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         parseTime( timeStr, isJdbcEscape, localeFinder, cal);
1:eac0369:     }
1:eac0369: 
1:eac0369:     private static final char IBM_EUR_SEPARATOR = '.';
1:eac0369:     private static final char[] IBM_EUR_SEPARATOR_OR_END = {IBM_EUR_SEPARATOR, (char) 0};
1:eac0369:     static final char JIS_SEPARATOR = ':';
1:2dd0b6f:     private static final char[] US_OR_JIS_MINUTE_END = {JIS_SEPARATOR, ' ', (char) 0};
1:eac0369:     private static final char[] ANY_SEPARATOR = { '.', ':', ' '};
1:eac0369:     private static final String[] AM_PM = {"AM", "PM"};
1:eac0369:     private static final char[] END_OF_STRING = {(char) 0};
1:eac0369:     
1:eac0369:     private void parseTime( String timeStr, boolean isJdbcEscape, LocaleFinder localeFinder, Calendar cal)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         boolean validSyntax = true;
1:eac0369:         DateTimeParser parser = new DateTimeParser( timeStr);
1:eac0369:         StandardException thrownSE = null;
1:eac0369:         int hour = 0;
1:eac0369:         int minute = 0;
1:eac0369:         int second = 0;
1:eac0369:         int amPm = -1;
1:eac0369:         try
1:eac0369:         {
1:eac0369:             if( parser.nextSeparator() == SQLTimestamp.DATE_SEPARATOR)
1:eac0369:             {
1:eac0369:                     encodedTime = SQLTimestamp.parseDateOrTimestamp( parser, true)[1];
1:eac0369:                     return;
1:eac0369:             }
1:eac0369:             hour = parser.parseInt( 2, true, ANY_SEPARATOR, false);
1:eac0369:             switch( parser.getCurrentSeparator())
1:eac0369:             {
1:eac0369:             case IBM_EUR_SEPARATOR:
1:eac0369:                 if( isJdbcEscape)
1:eac0369:                 {
2:eac0369:                     validSyntax = false;
1:eac0369:                     break;
1:eac0369:                 }
1:eac0369:                 minute = parser.parseInt( 2, false, IBM_EUR_SEPARATOR_OR_END, false);
1:eac0369:                 if( parser.getCurrentSeparator() == IBM_EUR_SEPARATOR)
1:eac0369:                     second = parser.parseInt( 2, false, END_OF_STRING, false);
1:eac0369:                 break;
1:eac0369: 
1:eac0369:             case ':':
1:eac0369:                 // IBM USA or JIS (new ISO)
1:eac0369:                 minute = parser.parseInt( 2, false, US_OR_JIS_MINUTE_END, false);
1:eac0369:                 switch( parser.getCurrentSeparator())
1:eac0369:                 {
1:eac0369:                 case ' ':
1:eac0369:                     // IBM USA with minutes
1:eac0369:                     if( isJdbcEscape)
1:eac0369:                     {
1:eac0369:                         validSyntax = false;
1:eac0369:                         break;
1:eac0369:                     }
1:eac0369:                     amPm = parser.parseChoice( AM_PM);
1:eac0369:                     parser.checkEnd();
1:eac0369:                     break;
1:eac0369: 
1:eac0369:                 case JIS_SEPARATOR:
1:eac0369:                     second = parser.parseInt( 2, false, END_OF_STRING, false);
1:eac0369:                     break;
1:eac0369: 
1:2dd0b6f:                     // default is end of string, meaning that the seconds part is zero.
1:eac0369:                 }
1:eac0369:                 break;
1:eac0369: 
1:eac0369:             case ' ':
1:eac0369:                 // IBM USA with minutes omitted
1:eac0369:                 if( isJdbcEscape)
1:eac0369:                 {
1:eac0369:                     validSyntax = false;
1:eac0369:                     break;
1:eac0369:                 }
1:eac0369:                 amPm = parser.parseChoice( AM_PM);
1:eac0369:                 break;
1:eac0369: 
2:eac0369:             default:
1:eac0369:                 validSyntax = false;
1:eac0369:             }
1:eac0369:         }
1:eac0369:         catch( StandardException se)
1:eac0369:         {
1:eac0369:             validSyntax = false;
1:eac0369:             thrownSE = se;
1:eac0369:         }
1:eac0369:         if( validSyntax)
1:eac0369:         {
1:eac0369:             if( amPm == 0) // AM
1:eac0369:             {
1:eac0369:                 if( hour == 12)
1:eac0369:                 {
1:eac0369:                     if( minute == 0 && second == 0)
1:eac0369:                         hour = 24;
1:eac0369:                     else
1:eac0369:                         hour = 0;
1:eac0369:                 }
1:eac0369:                 else if( hour > 12)
1:eac0369:                     throw StandardException.newException( SQLState.LANG_DATE_RANGE_EXCEPTION);
1:eac0369:             }
1:eac0369:             else if( amPm == 1) // PM
1:eac0369:             {
1:eac0369:                 if( hour < 12)
1:eac0369:                     hour += 12;
1:eac0369:                 else if( hour > 12)
1:eac0369:                     throw StandardException.newException( SQLState.LANG_DATE_RANGE_EXCEPTION);
1:eac0369:             }
1:320f6af:             parser.checkEnd();
1:eac0369:             encodedTime = computeEncodedTime( hour, minute, second);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             // See if it is a localized time or timestamp
1:eac0369:             timeStr = StringUtil.trimTrailing( timeStr);
1:eac0369:             DateFormat timeFormat = null;
1:eac0369:             if(localeFinder == null)
1:eac0369:                 timeFormat = DateFormat.getTimeInstance();
1:eac0369:             else if( cal == null)
1:eac0369:                 timeFormat = localeFinder.getTimeFormat();
1:eac0369:             else
1:eac0369:                 timeFormat = (DateFormat) localeFinder.getTimeFormat().clone();
1:eac0369:             if( cal != null)
1:eac0369:                 timeFormat.setCalendar( cal);
1:eac0369:             try
1:eac0369:             {
1:eac0369:                 encodedTime = computeEncodedTime( timeFormat.parse( timeStr), cal);
1:eac0369:             }
1:eac0369:             catch( ParseException pe)
1:eac0369:             {
1:eac0369:                 // Maybe it is a localized timestamp
1:eac0369:                 try
1:eac0369:                 {
1:eac0369:                     encodedTime = SQLTimestamp.parseLocalTimestamp( timeStr, localeFinder, cal)[1];
1:eac0369:                 }
1:eac0369:                 catch( ParseException pe2)
1:eac0369:                 {
1:eac0369:                     if( thrownSE != null)
1:eac0369:                         throw thrownSE;
1:eac0369:                     throw StandardException.newException( SQLState.LANG_DATE_SYNTAX_EXCEPTION);
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369:     } // end of parseTime
1:eac0369: 
1:806114c: 	/**
1:806114c: 	 * Set the value from a correctly typed Time object.
1:806114c: 	 * @throws StandardException 
1:806114c: 	 */
1:806114c: 	void setObject(Object theValue) throws StandardException
1:eac0369: 	{
1:806114c: 		setValue((Time) theValue);
1:eac0369: 	}
1:806114c:     
1:eac0369: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
1:eac0369: 
1:eac0369: 		if (theValue instanceof SQLTime) {
1:eac0369: 			restoreToNull();
1:eac0369: 
1:eac0369: 			SQLTime tvst = (SQLTime) theValue;
1:eac0369: 			encodedTime = tvst.encodedTime;
1:eac0369: 			encodedTimeFraction = tvst.encodedTimeFraction;
1:eac0369: 
1:eac0369: 		}
1:eac0369:         else
1:eac0369:         {
1:eac0369:             Calendar cal = new GregorianCalendar();
1:eac0369: 			setValue(theValue.getTime( cal), cal);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see DateTimeDataValue#setValue
1:eac0369: 
1:eac0369: 		@exception StandardException thrown on failure.
1:eac0369: 	 */
1:eac0369: 	public void setValue(Time value, Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		restoreToNull();
1:eac0369: 		encodedTime = computeEncodedTime(value, cal);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see DateTimeDataValue#setValue
1:eac0369: 
1:eac0369: 		@exception StandardException thrown on failure.
1:eac0369: 	 */
1:eac0369: 	public void setValue(Timestamp value, Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		restoreToNull();
1:eac0369: 		encodedTime = computeEncodedTime(value, cal);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public void setValue(String theValue)
1:eac0369: 	    throws StandardException
1:eac0369: 	{
1:eac0369: 		restoreToNull();
2:eac0369: 		if (theValue != null)
1:eac0369:         {
1:a0dbbd7:             DatabaseContext databaseContext = (DatabaseContext) DataValueFactoryImpl.getContext(DatabaseContext.CONTEXT_ID);
1:eac0369:             parseTime( theValue,
1:eac0369:                        false,
1:eac0369:                        (databaseContext == null) ? null : databaseContext.getDatabase(),
1:eac0369:                        (Calendar) null);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** SQL Operators
1:eac0369: 	*/
1:eac0369: 
1:985f758:     NumberDataValue nullValueInt() {
1:985f758:         return new SQLInteger();
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getYear
1:eac0369: 	 * 
2:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getYear(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1:eac0369: 						"getYear", "Time");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getMonth
1:eac0369: 	 * 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getMonth(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1:eac0369: 						"getMonth", "Time");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getDate
1:eac0369: 	 * 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getDate(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1:eac0369: 						"getDate", "Time");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getHours
1:eac0369: 	 * 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getHours(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:985f758:         if (isNull()) {
1:985f758:             return nullValueInt();
1:985f758:         } else {    
1:eac0369:             return SQLDate.setSource(getHour(encodedTime), result);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getMinutes
1:eac0369: 	 * 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getMinutes(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:985f758:         if (isNull()) {
1:985f758:             return nullValueInt();
1:985f758:         } else {    
1:eac0369:             return SQLDate.setSource(getMinute(encodedTime), result);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getSeconds
1:eac0369: 	 * 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getSeconds(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:985f758:         if (isNull()) {
1:985f758:             return nullValueInt();
1:985f758:         } else {    
1:eac0369:             return SQLDate.setSource(getSecond(encodedTime), result);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** String display of value
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:eac0369: 		{
1:eac0369: 			return "NULL";
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return getTime( (Calendar) null).toString();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Hash code
1:eac0369: 	 */
1:eac0369: 	public int hashCode()
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:eac0369: 		{
1:eac0369: 			return 0;
1:eac0369: 		}
1:eac0369: 		// add 1 since 0 represents a valid time
1:eac0369: 		return encodedTime + encodedTimeFraction + 1;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see DataValueDescriptor#typePrecedence */
1:eac0369: 	public int	typePrecedence()
1:eac0369: 	{
1:eac0369: 		return TypeId.TIME_PRECEDENCE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check if the value is null.  
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not value is logically null.
1:eac0369: 	 */
1:eac0369: 	public final boolean isNull()
1:eac0369: 	{
1:eac0369: 		return (encodedTime ==  -1);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the time value 
1:eac0369: 	 * Since this is a JDBC object we use the JDBC definition
1:eac0369: 	 * we use the JDBC definition, see JDBC API Tutorial and Reference
1:eac0369: 	 * section 47.3.12
1:eac0369: 	 * Date is set to Jan. 1, 1970
1:eac0369: 	 *
1:eac0369: 	 * @return	The localized time value.
1:eac0369: 	 */
1:eac0369: 	public Time getTime(java.util.Calendar cal)
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:eac0369: 			return null;
1:eac0369:         
1:a57602b:         // Derby's SQL TIME type only has second resolution
1:a57602b:         // so pass in 0 for nano-seconds
1:a57602b:         return getTime(cal, encodedTime, 0);
1:a57602b: 	}
1:a57602b:     
1:a57602b:     /**
1:a57602b:      * Set the time portion of a date-time value into
1:a57602b:      * the passed in Calendar object from its encodedTime
1:a57602b:      * value. Note that this is only the time down
1:a57602b:      * to a resolution of one second. Only the HOUR_OF_DAY,
1:a57602b:      * MINUTE and SECOND fields are modified. The remaining
1:a57602b:      * state of the Calendar is not modified.
1:a57602b:      */
1:a57602b:     static void setTimeInCalendar(Calendar cal, int encodedTime)
1:a57602b:     {
1:a57602b:         cal.set(Calendar.HOUR_OF_DAY, getHour(encodedTime));
1:a57602b:         cal.set(Calendar.MINUTE, getMinute(encodedTime));
1:a57602b:         cal.set(Calendar.SECOND, getSecond(encodedTime));        
1:a57602b:     }
1:a57602b:     
1:a57602b:     /**
1:a57602b:      * Get a java.sql.Time object from an encoded time
1:a57602b:      * and nano-second value. As required by JDBC the
1:a57602b:      * date component of the Time object will be set to
1:a57602b:      * Jan. 1, 1970
1:a57602b:      * @param cal Calendar to use for conversion
1:a57602b:      * @param encodedTime Derby encoded time value
1:a57602b:      * @param nanos number of nano-seconds.
1:a57602b:      * @return Valid Time object.
1:a57602b:      */
1:a57602b:     static Time getTime(Calendar cal, int encodedTime, int nanos)
1:a57602b:     {
1:eac0369:         if( cal == null)
2:eac0369:             cal = new GregorianCalendar();
1:a57602b:         
1:0c7cafc:         cal.clear();
1:0c7cafc:         
1:a57602b:         cal.set(1970, Calendar.JANUARY, 1);
1:a57602b: 
1:a57602b:         SQLTime.setTimeInCalendar(cal, encodedTime);
1:a57602b: 
1:a57602b:         cal.set(Calendar.MILLISECOND, nanos/1000000);
1:a57602b:         
1:a57602b:         return new Time(cal.getTimeInMillis());
1:a57602b:     }
1:a57602b:     
1:a57602b:     
1:eac0369: 	/**
1:eac0369: 	 * Get the encoded hour value (may be different than hour value for
1:eac0369: 	 *  	current timezone if value encoded in a different timezone)
1:eac0369: 	 *
1:eac0369: 	 * @return	hour value
1:eac0369: 	 */
1:eac0369: 	protected static int getHour(int encodedTime)
1:eac0369: 	{
1:eac0369: 		return (encodedTime >>> 16) & 0xff;
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 * Get the encoded minute value (may be different than the minute value for
1:eac0369: 	 *  	current timezone if value encoded in a different timezone)
1:eac0369: 	 *
1:eac0369: 	 * @return	minute value
1:eac0369: 	 */
1:eac0369: 	protected static int getMinute(int encodedTime)
1:eac0369: 	{
1:eac0369: 		return ((encodedTime >>> 8) & 0xff);
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 * Get the encoded second value (may be different than the second value for
1:eac0369: 	 *  	current timezone if value encoded in a different timezone)
1:eac0369: 	 *
1:eac0369: 	 * @return	second value
1:eac0369: 	 */
1:eac0369: 	protected static int getSecond(int encodedTime)
1:eac0369: 	{
1:eac0369: 		return (encodedTime & 0xff);
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 *	Calculate the encoded time from a Calendar object
1:dbed020: 	 *	encoded time is hour &lt;&lt; 16 + min &lt;&lt; 8 + sec
1:eac0369: 	 *  this function is also used by SQLTimestamp 
1:eac0369: 	 *
1:6b50965: 	 * @param	cal calendar with time set
1:eac0369: 	 * @return	encoded time
1:eac0369:      *
1:eac0369:      * @exception StandardException if the time is not in the DB2 range
1:eac0369: 	 */
1:eac0369: 	static int computeEncodedTime(Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		return computeEncodedTime(cal.get(Calendar.HOUR_OF_DAY),
1:eac0369:                                   cal.get(Calendar.MINUTE),
1:eac0369:                                   cal.get(Calendar.SECOND));
1:eac0369: 	}
1:0c7cafc: 
1:eac0369:     static int computeEncodedTime( int hour, int minute, int second) throws StandardException
1:eac0369:     {
1:eac0369:         if( hour == 24)
1:eac0369:         {
1:eac0369:             if( minute != 0 || second != 0)
1:eac0369:                 throw StandardException.newException( SQLState.LANG_DATE_RANGE_EXCEPTION);
1:eac0369:         }
1:eac0369:         else if( hour < 0 || hour > 23 || minute < 0 || minute > 59 || second < 0 || second > 59)
1:eac0369:             throw StandardException.newException( SQLState.LANG_DATE_RANGE_EXCEPTION);
1:eac0369: 
1:eac0369:         return (hour << 16) + (minute << 8) + second;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Convert a time to a JDBC escape format string
1:eac0369:      *
1:eac0369:      * @param hour
1:eac0369:      * @param minute
1:eac0369:      * @param second
1:eac0369:      * @param sb The resulting string is appended to this StringBuffer
1:eac0369:      */
1:eac0369:     static void timeToString( int hour, int minute, int second, StringBuffer sb)
1:eac0369:     {
1:eac0369: 		String hourStr = Integer.toString( hour);
1:eac0369: 		String minStr = Integer.toString( minute);
1:eac0369: 		String secondStr = Integer.toString( second);
1:eac0369: 		if (hourStr.length() == 1)
1:eac0369: 			sb.append("0");
1:eac0369: 		sb.append( hourStr);
1:eac0369: 		sb.append( JIS_SEPARATOR);
1:eac0369: 		if (minStr.length() == 1)
1:eac0369: 			sb.append("0");
1:eac0369: 		sb.append(minStr);
1:eac0369: 		sb.append( JIS_SEPARATOR);
1:eac0369: 		if (secondStr.length() == 1)
1:eac0369: 			sb.append("0");
1:eac0369: 		sb.append(secondStr);
1:eac0369:     } // end of timeToString
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the String version from the encodedTime.
1:eac0369: 	 *
1:eac0369: 	 * @return	 string value.
1:eac0369: 	 */
1:eac0369: 	protected static String encodedTimeToString(int encodedTime)
1:eac0369: 	{
1:eac0369: 		StringBuffer vstr = new StringBuffer();
1:eac0369:         timeToString( SQLTime.getHour(encodedTime), SQLTime.getMinute(encodedTime), SQLTime.getSecond(encodedTime), vstr);
1:eac0369: 		return vstr.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Compute encoded time value
1:dbed020: 	 * Time is represented by hour &lt;&lt; 16 + minute &lt;&lt; 8 + seconds
1:eac0369: 	 */
1:eac0369: 	private	int computeEncodedTime(java.util.Date value) throws StandardException
1:eac0369: 	{
1:eac0369:         return computeEncodedTime( value, (Calendar) null);
1:eac0369:     }
1:eac0369: 
1:eac0369:     static int computeEncodedTime(java.util.Date value, Calendar currentCal) throws StandardException
1:eac0369:     {
1:eac0369:         if (value == null)
1:eac0369: 			return -1;
1:eac0369:         if( currentCal == null)
1:eac0369:             currentCal = new GregorianCalendar();
1:eac0369: 		currentCal.setTime(value);
1:eac0369: 		return computeEncodedTime(currentCal);
1:eac0369: 	}
1:e21adc5: 
1:e21adc5:      /** Adding this method to ensure that super class' setInto method doesn't get called
1:e21adc5:       * that leads to the violation of JDBC spec( untyped nulls ) when batching is turned on.
1:e21adc5:       */
1:e21adc5:     public void setInto(PreparedStatement ps, int position) throws SQLException, StandardException {
1:e21adc5: 
1:e21adc5: 		      ps.setTime(position, getTime((Calendar) null));
1:e21adc5:    }
1:e21adc5: 
1:eac0369: 
1:eac0369:     /**
1:d365a22:      * Add a number of intervals to a datetime value. Implements the JDBC escape TIMESTAMPADD function.
1:eac0369:      *
1:d365a22:      * @param intervalType One of FRAC_SECOND_INTERVAL, SECOND_INTERVAL, MINUTE_INTERVAL, HOUR_INTERVAL,
1:d365a22:      *                     DAY_INTERVAL, WEEK_INTERVAL, MONTH_INTERVAL, QUARTER_INTERVAL, or YEAR_INTERVAL
1:d365a22:      * @param intervalCount The number of intervals to add
1:d365a22:      * @param currentDate Used to convert time to timestamp
1:d365a22:      * @param resultHolder If non-null a DateTimeDataValue that can be used to hold the result. If null then
1:d365a22:      *                     generate a new holder
1:eac0369:      *
1:d365a22:      * @return startTime + intervalCount intervals, as a timestamp
1:eac0369:      *
1:d365a22:      * @exception StandardException
1:eac0369:      */
1:d365a22:     public DateTimeDataValue timestampAdd( int intervalType,
1:d365a22:                                            NumberDataValue intervalCount,
1:d365a22:                                            java.sql.Date currentDate,
1:d365a22:                                            DateTimeDataValue resultHolder)
1:d365a22:         throws StandardException
1:eac0369:     {
1:d365a22:         return toTimestamp( currentDate).timestampAdd( intervalType, intervalCount, currentDate, resultHolder);
1:eac0369:     }
1:eac0369: 
1:d365a22:     private SQLTimestamp toTimestamp(java.sql.Date currentDate) throws StandardException
1:eac0369:     {
1:d365a22:         return new SQLTimestamp( SQLDate.computeEncodedDate( currentDate, (Calendar) null),
1:d365a22:                                  getEncodedTime(),
1:d365a22:                                  0 /* nanoseconds */);
1:eac0369:     }
1:eac0369:     
1:eac0369:     /**
1:d365a22:      * Finds the difference between two datetime values as a number of intervals. Implements the JDBC
1:d365a22:      * TIMESTAMPDIFF escape function.
1:eac0369:      *
1:d365a22:      * @param intervalType One of FRAC_SECOND_INTERVAL, SECOND_INTERVAL, MINUTE_INTERVAL, HOUR_INTERVAL,
1:d365a22:      *                     DAY_INTERVAL, WEEK_INTERVAL, MONTH_INTERVAL, QUARTER_INTERVAL, or YEAR_INTERVAL
1:d365a22:      * @param time1
1:d365a22:      * @param currentDate Used to convert time to timestamp
1:d365a22:      * @param resultHolder If non-null a NumberDataValue that can be used to hold the result. If null then
1:d365a22:      *                     generate a new holder
1:eac0369:      *
1:d365a22:      * @return the number of intervals by which this datetime is greater than time1
6:d365a22:      *
1:d365a22:      * @exception StandardException
1:eac0369:      */
1:d365a22:     public NumberDataValue timestampDiff( int intervalType,
1:d365a22:                                           DateTimeDataValue time1,
1:d365a22:                                           java.sql.Date currentDate,
1:d365a22:                                           NumberDataValue resultHolder)
1:d365a22:         throws StandardException
1:eac0369:     {
1:d365a22:         return toTimestamp( currentDate ).timestampDiff( intervalType, time1, currentDate, resultHolder);
1:eac0369:     }
1:eac0369: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      *<li>JIS and current ISO: hh:mm[:ss]
/////////////////////////////////////////////////////////////////////////
1:      *<li>JIS and current ISO: hh:mm[:ss]
/////////////////////////////////////////////////////////////////////////
1: 	 *	encoded time is hour &lt;&lt; 16 + min &lt;&lt; 8 + sec
/////////////////////////////////////////////////////////////////////////
1: 	 * Time is represented by hour &lt;&lt; 16 + minute &lt;&lt; 8 + seconds
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1:             DatabaseContext databaseContext = (DatabaseContext) DataValueFactoryImpl.getContext(DatabaseContext.CONTEXT_ID);
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f668d94
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException if the syntax is invalid or the value is
1:      * out of range
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException if the syntax is invalid or the value is
1:      * out of range
commit:4ecfb0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:320f6af
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return BASE_MEMORY_USAGE;
1: 			return encodedTimeToString(encodedTime);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             parser.checkEnd();
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:aff8c99
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:854dd10
/////////////////////////////////////////////////////////////////////////
1: 	/** @see DataValueDescriptor#cloneValue */
1: 	public DataValueDescriptor cloneValue(boolean forceMaterialization)
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:a57602b
/////////////////////////////////////////////////////////////////////////
1:                 // Set Calendar to current date and time
1:                 // to pick up the current date. Time portion
1:                 // will be overridden by this value's time.
1:                 cal.setTimeInMillis(System.currentTimeMillis());
1:             SQLTime.setTimeInCalendar(cal, encodedTime);
1:           
1: 			return new Timestamp(cal.getTimeInMillis());
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Derby's SQL TIME type only has second resolution
1:         // so pass in 0 for nano-seconds
1:         return getTime(cal, encodedTime, 0);
1: 	}
1:     
1:     /**
1:      * Set the time portion of a date-time value into
1:      * the passed in Calendar object from its encodedTime
1:      * value. Note that this is only the time down
1:      * to a resolution of one second. Only the HOUR_OF_DAY,
1:      * MINUTE and SECOND fields are modified. The remaining
1:      * state of the Calendar is not modified.
1:      */
1:     static void setTimeInCalendar(Calendar cal, int encodedTime)
1:     {
1:         cal.set(Calendar.HOUR_OF_DAY, getHour(encodedTime));
1:         cal.set(Calendar.MINUTE, getMinute(encodedTime));
1:         cal.set(Calendar.SECOND, getSecond(encodedTime));        
1:     }
1:     
1:     /**
1:      * Get a java.sql.Time object from an encoded time
1:      * and nano-second value. As required by JDBC the
1:      * date component of the Time object will be set to
1:      * Jan. 1, 1970
1:      * @param cal Calendar to use for conversion
1:      * @param encodedTime Derby encoded time value
1:      * @param nanos number of nano-seconds.
1:      * @return Valid Time object.
1:      */
1:     static Time getTime(Calendar cal, int encodedTime, int nanos)
1:     {
1:         
1:         cal.set(1970, Calendar.JANUARY, 1);
1: 
1:         SQLTime.setTimeInCalendar(cal, encodedTime);
1: 
1:         cal.set(Calendar.MILLISECOND, nanos/1000000);
1:         
1:         return new Time(cal.getTimeInMillis());
1:     }
1:     
1:     
commit:0c7cafc
/////////////////////////////////////////////////////////////////////////
1:      * Convert a SQL TIME to a JDBC java.sql.Timestamp.
1:      * 
1:      * Behaviour is to set the date portion of the Timestamp
1:      * to the actual current date, which may not match the
1:      * SQL CURRENT DATE, which remains fixed for the lifetime
1:      * of a SQL statement. JDBC drivers (especially network client drivers)
1:      * could not be expected to fetch the CURRENT_DATE SQL value
1:      * on every query that involved a TIME value, so the current
1:      * date as seen by the JDBC client was picked as the logical behaviour.
1:      * See DERBY-1811.
1: 	public Timestamp getTimestamp( Calendar cal)
1:             {
1:                 // Calendar initialized to current date and time.
1:                 cal = new GregorianCalendar(); 
1:             }
1:             else
1:             {
1:                 cal.clear();
0:                 // Set Calendar to current date and time.
0:                 cal.setTime(new Date(System.currentTimeMillis()));
1:             }
1: 
1:             
1:             // Derby's resolution for the TIME type is only seconds.
1:             
/////////////////////////////////////////////////////////////////////////
1:         
1:         cal.clear();
commit:806114c
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Set the value from a correctly typed Time object.
1: 	 * @throws StandardException 
1: 	 */
1: 	void setObject(Object theValue) throws StandardException
1: 		setValue((Time) theValue);
1:     
commit:e21adc5
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1: 
1:      /** Adding this method to ensure that super class' setInto method doesn't get called
1:       * that leads to the violation of JDBC spec( untyped nulls ) when batching is turned on.
1:       */
1:     public void setInto(PreparedStatement ps, int position) throws SQLException, StandardException {
1: 
1: 		      ps.setTime(position, getTime((Calendar) null));
1:    }
1: 
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.SQLTime
1: 
0:    Copyright 2001, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: 
1: import org.apache.derby.iapi.services.context.ContextService;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.db.DatabaseContext;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.types.DateTimeDataValue;
0: import org.apache.derby.iapi.types.NumberDataValue;
1: 
0: import org.apache.derby.iapi.types.DataType;
1: import org.apache.derby.iapi.services.i18n.LocaleFinder;
1: import org.apache.derby.iapi.services.cache.ClassSize;
1: import org.apache.derby.iapi.util.StringUtil;
1: 
0: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
0: import java.sql.Types;
1: 
1: import java.util.Calendar;
1: import java.util.GregorianCalendar;
1: 
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: import java.io.IOException;
1: 
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: 
1: import java.text.DateFormat;
1: import java.text.ParseException;
1: 
1: /**
1:  * This contains an instance of a SQL Time
1:  * Our current implementation doesn't implement time precision so the fractional
1:  * seconds portion of the time is always 0.  The default when no time precision
1:  * is specified is 0 fractional seconds.  A SQL Time without timezone information
1:  * is assumed to be in the local time zone.  The local time is stored as is
1:  * and doesn't change if the timezone changes. This is in conformance with the
1:  * SQL99 standard.  The SQL92 standard indicates that the time is in GMT and
1:  * changes with the timezone.  The SQL99 standard clarifies this to allow time without
1:  * timezoned to be stored as the local time.
1:  * <p>
1:  * Time is stored as two ints.  The first int represents hour, minute, second 
1:  * and the second represents fractional seconds (currently 0 since we don't support
1:  * time precision)
1:  * 	encodedTime = -1 indicates null
1:  *
1:  * PERFORMANCE OPTIMIZATION:
1:  *	The java.sql.Time object is only instantiated on demand for performance
1:  * 	reasons.
1:  */
1: 
1: public final class SQLTime extends DataType
1: 						implements DateTimeDataValue
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
1: 
1: 	private int		encodedTime;
1: 	private int		encodedTimeFraction; //currently always 0 since we don't
1: 											 //support time precision
1: 
0: 	// The cached value.toString()
0: 	private String	valueString;
1: 
1: 	/*
1: 	** DataValueDescriptor interface
1: 	** (mostly implemented in DataType)
1: 	*/
1: 
1:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLTime.class);
1: 
1:     public int estimateMemoryUsage()
1:     {
0:         return BASE_MEMORY_USAGE + ClassSize.estimateMemoryUsage( valueString);
1:     } // end of estimateMemoryUsage
1: 
1: 	public String getString()
1: 	{
1: 		if (!isNull())
1: 		{
0: 			if (valueString == null)
1: 			{
0: 				valueString = encodedTimeToString(encodedTime);
1: 			}
0: 			return valueString;
1: 		}
1: 		else
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
0: 				if (valueString != null)
1: 				{
0: 					SanityManager.THROWASSERT(
0: 						"valueString expected to be null, not " +
0: 						valueString);
1: 				}
1: 			}
1: 			return null;
1: 		}
1: 	}
1: 
1:     int getEncodedTime()
1:     {
1:         return encodedTime;
1:     }
1: 
1: 	/**
0: 		@exception StandardException thrown on failure
1: 	 */
0: 	public Timestamp getTimestamp( Calendar cal) throws StandardException
1: 	{
1: 		if (isNull())
1: 			return null;
1: 		else
1: 		{
1:             if( cal == null)
1:                 cal = new GregorianCalendar();
1: 			/*
0: 			** HACK FOR SYMANTEC: in symantec 1.8, the call
0: 			** to today.getTime().getTime() will blow up 
0: 			** in GregorianCalendar because year <= 0.
0: 			** This is a bug in some sort of optimization that
0: 			** symantic is doing (not related to the JIT).  If 
0: 			** we do a reference to that field everythings works 
0: 			** fine, hence this extraneous get(Calendar.YEAR).
1: 			*/
0: 			cal.get(Calendar.YEAR);
0: 			cal.set(Calendar.HOUR_OF_DAY, getHour(encodedTime));
0: 			cal.set(Calendar.MINUTE, getMinute(encodedTime));
0: 			cal.set(Calendar.SECOND, getSecond(encodedTime));
1: 			cal.set(Calendar.MILLISECOND, 0);
0: 			return new Timestamp(cal.getTime().getTime());
1: 		}
1: 	}
1: 
1: 	public Object getObject()
1: 	{
1: 		return getTime( (Calendar) null);
1: 	}
1: 		
1: 	public int getLength()
1: 	{
1: 		return 8;
1: 	}
1: 
1: 	/* this is for DataType's error generator */
1: 	public String getTypeName()
1: 	{
1: 		return "TIME";
1: 	}
1: 
1: 
1: 	/*
1: 	 * Storable interface, implies Externalizable, TypedFormat
1: 	 */
1: 
1: 	/**
1: 		Return my format identifier.
1: 
1: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1: 	*/
1: 	public int getTypeFormatId() {
1: 		return StoredFormatIds.SQL_TIME_ID;
1: 	}
1: 
1: 	/** 
1: 		@exception IOException error writing data
1: 
1: 	*/
1: 	public void writeExternal(ObjectOutput out) throws IOException {
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!isNull(), "writeExternal() is not supposed to be called for null values.");
1: 
1: 		out.writeInt(encodedTime);
1: 		out.writeInt(encodedTimeFraction);
1: 	}
1: 
1: 	/**
1: 	 * @see java.io.Externalizable#readExternal
1: 	 *
1: 	 * @exception IOException	Thrown on error reading the object
1: 	 */
1: 	public void readExternal(ObjectInput in) throws IOException
1: 	{
1: 		encodedTime = in.readInt();
1: 		encodedTimeFraction = in.readInt();
0: 		// reset cached values
0: 		valueString = null;
1: 	}
0: 	public void readExternalFromArray(ArrayInputStream in) throws IOException
1: 	{
1: 		encodedTime = in.readInt();
1: 		encodedTimeFraction = in.readInt();
0: 		// reset cached values
0: 		valueString = null;
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
0: 	/** @see DataValueDescriptor#getClone */
0: 	public DataValueDescriptor getClone()
1: 	{
1: 		// Call constructor with all of our info
1: 		return new SQLTime(encodedTime, encodedTimeFraction);
1: 	}
1: 
1: 	/**
1: 	 * @see DataValueDescriptor#getNewNull
1: 	 */
1: 	public DataValueDescriptor getNewNull()
1: 	{
1: 		return new SQLTime();
1: 	}
1: 	/**
1: 	 * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
1: 	 *
1: 	 */
1: 
1: 	public void restoreToNull()
1: 	{
1: 		encodedTime = -1;
1: 		encodedTimeFraction = 0;
1: 
0: 		// clear cached valueString
0: 		valueString = null;
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
1: 	/** 
1: 	 * @see DataValueDescriptor#setValueFromResultSet 
1: 	 *
1: 	 * @exception SQLException		Thrown on error
1: 	 */
1: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
1: 									  boolean isNullable)
1: 		throws SQLException, StandardException
1: 	{
1: 			restoreToNull();
1: 			encodedTime = computeEncodedTime(resultSet.getTime(colNumber));
1: 			//need to set encodedTimeFraction when we implement time precision
1: 	}
1: 
1: 	/**
1: 	 * Orderable interface
1: 	 *
1: 	 *
1: 	 * @see org.apache.derby.iapi.types.Orderable
1: 	 *
1: 	 * @exception StandardException thrown on failure
1: 	 */
1: 	public int compare(DataValueDescriptor other)
1: 		throws StandardException
1: 	{
1: 		/* Use compare method from dominant type, negating result
1: 		 * to reflect flipping of sides.
1: 		 */
1: 		if (typePrecedence() < other.typePrecedence())
1: 		{
1: 			return - (other.compare(this));
1: 		}
1: 
1: 		boolean thisNull, otherNull;
1: 
1: 		thisNull = this.isNull();
1: 		otherNull = other.isNull();
1: 
1: 		/*
1: 		 * thisNull otherNull	return
1: 		 *	T		T		 	0	(this == other)
1: 		 *	F		T		 	-1 	(this < other)
1: 		 *	T		F		 	1	(this > other)
1: 		 */
1: 		if (thisNull || otherNull)
1: 		{
1: 			if (!thisNull)		// otherNull must be true
1: 				return -1;
1: 			if (!otherNull)		// thisNull must be true
1: 				return 1;
1: 			return 0;
1: 		}
1: 
1: 		/*
1: 			Neither are null compare them 
1: 		 */
1: 
1: 		int comparison;
1: 
1: 		/* get the comparison time values */
1: 		int otherEncodedTime = 0;
1: 
1: 		/* if the argument is another Time look up the value
1: 		 * we have already taken care of Null
1: 		 * ignoring encodedTimeFraction for now since it is always 0
1: 		 * - need to change this when we support TIME(precision)
1: 		 */
1: 		if (other instanceof SQLTime)
1: 		{
1: 			otherEncodedTime=((SQLTime)other).encodedTime;
1: 		}
1: 		else 
1: 		{
1: 			/* O.K. have to do it the hard way and calculate the numeric value
1: 			 * from the value
1: 			 */
1: 			otherEncodedTime = computeEncodedTime(other.getTime( (Calendar) null));
1: 		}
1: 		if (encodedTime < otherEncodedTime)
1: 			comparison = -1;
1: 		else if (encodedTime > otherEncodedTime)
1: 			comparison = 1;
1: 		else
1: 			comparison = 0;
1: 
1: 		return comparison;
1: 	}
1: 
1: 	/**
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public boolean compare(int op,
1: 						   DataValueDescriptor other,
1: 						   boolean orderedNulls,
1: 						   boolean unknownRV)
1: 		throws StandardException
1: 	{
1: 		if (!orderedNulls)		// nulls are unordered
1: 		{
1: 			if (this.isNull() || other.isNull())
1: 				return unknownRV;
1: 		}
1: 
1: 		/* Do the comparison */
1: 		return super.compare(op, other, orderedNulls, unknownRV);
1: 	}
1: 
1: 	/*
1: 	** Class interface
1: 	*/
1: 
1: 	/*
1: 	** Constructors
1: 	*/
1: 
1: 	/** no-arg constructor required by Formattable */
1: 	public SQLTime() 
1: 	{ 
1: 		encodedTime = -1;	//null value
1: 	}
1: 
1: 	public SQLTime(Time value) throws StandardException
1: 	{
1: 		parseTime(value);
1: 	}
1: 
1:     private void parseTime(java.util.Date value) throws StandardException
1: 	{
1: 		encodedTime = computeEncodedTime(value);
1: 	}
1: 
1: 	private SQLTime(int encodedTime, int encodedTimeFraction) {
1: 		this.encodedTime = encodedTime;
1: 		this.encodedTimeFraction = encodedTimeFraction;
1: 	}
1: 
1: 
1:     /**
1:      * Construct a time from a string. The allowed time formats are:
1:      *<ol>
1:      *<li>old ISO and IBM European standard: hh.mm[.ss]
1:      *<li>IBM USA standard: hh[:mm] {AM | PM}
0:      *<li>JIS & current ISO: hh:mm[:ss]
1:      *</ol>
1:      * 
0:      * @param dateStr
0:      * @param localFinder
1:      *
0:      * @return the internal DataValueDescriptor for the value
1:      *
0:      * @exception Standard exception if the syntax is invalid or the value is out of range.
1:      */
1:     public SQLTime( String timeStr, boolean isJdbcEscape, LocaleFinder localeFinder)
1:         throws StandardException
1:     {
1:         parseTime( timeStr, isJdbcEscape, localeFinder, (Calendar) null);
1:     }
1:     
1:     /**
1:      * Construct a time from a string. The allowed time formats are:
1:      *<ol>
1:      *<li>old ISO and IBM European standard: hh.mm[.ss]
1:      *<li>IBM USA standard: hh[:mm] {AM | PM}
0:      *<li>JIS & current ISO: hh:mm[:ss]
1:      *</ol>
1:      * 
0:      * @param dateStr
0:      * @param localFinder
1:      *
0:      * @return the internal DataValueDescriptor for the value
1:      *
0:      * @exception Standard exception if the syntax is invalid or the value is out of range.
1:      */
1:     public SQLTime( String timeStr, boolean isJdbcEscape, LocaleFinder localeFinder, Calendar cal)
1:         throws StandardException
1:     {
1:         parseTime( timeStr, isJdbcEscape, localeFinder, cal);
1:     }
1: 
1:     private static final char IBM_EUR_SEPARATOR = '.';
1:     private static final char[] IBM_EUR_SEPARATOR_OR_END = {IBM_EUR_SEPARATOR, (char) 0};
1:     static final char JIS_SEPARATOR = ':';
0:     private static final char[] US_OR_JIS_MINUTE_END = {JIS_SEPARATOR, ' '};
1:     private static final char[] ANY_SEPARATOR = { '.', ':', ' '};
1:     private static final String[] AM_PM = {"AM", "PM"};
1:     private static final char[] END_OF_STRING = {(char) 0};
1:     
1:     private void parseTime( String timeStr, boolean isJdbcEscape, LocaleFinder localeFinder, Calendar cal)
1:         throws StandardException
1:     {
1:         boolean validSyntax = true;
1:         DateTimeParser parser = new DateTimeParser( timeStr);
1:         StandardException thrownSE = null;
1:         int hour = 0;
1:         int minute = 0;
1:         int second = 0;
1:         int amPm = -1;
1:         try
1:         {
1:             if( parser.nextSeparator() == SQLTimestamp.DATE_SEPARATOR)
1:             {
1:                     encodedTime = SQLTimestamp.parseDateOrTimestamp( parser, true)[1];
0:                     valueString = parser.getTrimmedString();
1:                     return;
1:             }
1:             hour = parser.parseInt( 2, true, ANY_SEPARATOR, false);
1:             switch( parser.getCurrentSeparator())
1:             {
1:             case IBM_EUR_SEPARATOR:
1:                 if( isJdbcEscape)
1:                 {
1:                     validSyntax = false;
1:                     break;
1:                 }
1:                 minute = parser.parseInt( 2, false, IBM_EUR_SEPARATOR_OR_END, false);
1:                 if( parser.getCurrentSeparator() == IBM_EUR_SEPARATOR)
1:                     second = parser.parseInt( 2, false, END_OF_STRING, false);
1:                 break;
1: 
1:             case ':':
1:                 // IBM USA or JIS (new ISO)
1:                 minute = parser.parseInt( 2, false, US_OR_JIS_MINUTE_END, false);
1:                 switch( parser.getCurrentSeparator())
1:                 {
1:                 case ' ':
1:                     // IBM USA with minutes
1:                     if( isJdbcEscape)
1:                     {
1:                         validSyntax = false;
1:                         break;
1:                     }
1:                     amPm = parser.parseChoice( AM_PM);
1:                     parser.checkEnd();
1:                     break;
1: 
1:                 case JIS_SEPARATOR:
1:                     second = parser.parseInt( 2, false, END_OF_STRING, false);
1:                     break;
1: 
1:                 default:
1:                     validSyntax = false;
1:                 }
1:                 break;
1: 
1:             case ' ':
1:                 // IBM USA with minutes omitted
1:                 if( isJdbcEscape)
1:                 {
1:                     validSyntax = false;
1:                     break;
1:                 }
1:                 amPm = parser.parseChoice( AM_PM);
1:                 break;
1: 
1:             default:
1:                 validSyntax = false;
1:             }
1:         }
1:         catch( StandardException se)
1:         {
1:             validSyntax = false;
1:             thrownSE = se;
1:         }
1:         if( validSyntax)
1:         {
1:             if( amPm == 0) // AM
1:             {
1:                 if( hour == 12)
1:                 {
1:                     if( minute == 0 && second == 0)
1:                         hour = 24;
1:                     else
1:                         hour = 0;
1:                 }
1:                 else if( hour > 12)
1:                     throw StandardException.newException( SQLState.LANG_DATE_RANGE_EXCEPTION);
1:             }
1:             else if( amPm == 1) // PM
1:             {
1:                 if( hour < 12)
1:                     hour += 12;
1:                 else if( hour > 12)
1:                     throw StandardException.newException( SQLState.LANG_DATE_RANGE_EXCEPTION);
1:             }
0:             valueString = parser.checkEnd();
1:             encodedTime = computeEncodedTime( hour, minute, second);
1:         }
1:         else
1:         {
1:             // See if it is a localized time or timestamp
1:             timeStr = StringUtil.trimTrailing( timeStr);
1:             DateFormat timeFormat = null;
1:             if(localeFinder == null)
1:                 timeFormat = DateFormat.getTimeInstance();
1:             else if( cal == null)
1:                 timeFormat = localeFinder.getTimeFormat();
1:             else
1:                 timeFormat = (DateFormat) localeFinder.getTimeFormat().clone();
1:             if( cal != null)
1:                 timeFormat.setCalendar( cal);
1:             try
1:             {
1:                 encodedTime = computeEncodedTime( timeFormat.parse( timeStr), cal);
1:             }
1:             catch( ParseException pe)
1:             {
1:                 // Maybe it is a localized timestamp
1:                 try
1:                 {
1:                     encodedTime = SQLTimestamp.parseLocalTimestamp( timeStr, localeFinder, cal)[1];
1:                 }
1:                 catch( ParseException pe2)
1:                 {
1:                     if( thrownSE != null)
1:                         throw thrownSE;
1:                     throw StandardException.newException( SQLState.LANG_DATE_SYNTAX_EXCEPTION);
1:                 }
1:             }
0:             valueString = timeStr;
1:         }
1:     } // end of parseTime
1: 
0: 	public void setValue(Object theValue) throws StandardException
1: 	{
1: 		restoreToNull();
1: 		if (theValue != null)
1: 		{
0: 			if (theValue instanceof Time)
1: 			{
0: 				this.setValue((Time)theValue, (Calendar) null);
1: 			}
0: 			else if (theValue instanceof Timestamp)
1: 			{
0: 				this.setValue((Timestamp)theValue, (Calendar) null);
1: 			}
1: 			else
1: 			{
0: 				genericSetObject(theValue);
1: 			}
1: 		}
1: 	}
1: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
1: 
1: 		if (theValue instanceof SQLTime) {
1: 			restoreToNull();
1: 
1: 			SQLTime tvst = (SQLTime) theValue;
1: 			encodedTime = tvst.encodedTime;
1: 			encodedTimeFraction = tvst.encodedTimeFraction;
1: 
1: 		}
1:         else
1:         {
1:             Calendar cal = new GregorianCalendar();
1: 			setValue(theValue.getTime( cal), cal);
1:         }
1: 	}
1: 
1: 	/**
1: 		@see DateTimeDataValue#setValue
1: 
1: 		@exception StandardException thrown on failure.
1: 	 */
1: 	public void setValue(Time value, Calendar cal) throws StandardException
1: 	{
1: 		restoreToNull();
1: 		encodedTime = computeEncodedTime(value, cal);
1: 	}
1: 
1: 	/**
1: 		@see DateTimeDataValue#setValue
1: 
1: 		@exception StandardException thrown on failure.
1: 	 */
1: 	public void setValue(Timestamp value, Calendar cal) throws StandardException
1: 	{
1: 		restoreToNull();
1: 		encodedTime = computeEncodedTime(value, cal);
1: 	}
1: 
1: 
1: 	public void setValue(String theValue)
1: 	    throws StandardException
1: 	{
1: 		restoreToNull();
1: 		if (theValue != null)
1:         {
0:             DatabaseContext databaseContext = (DatabaseContext) ContextService.getContext(DatabaseContext.CONTEXT_ID);
1:             parseTime( theValue,
1:                        false,
1:                        (databaseContext == null) ? null : databaseContext.getDatabase(),
1:                        (Calendar) null);
1:         }
1: 	}
1: 
1: 	/*
1: 	** SQL Operators
1: 	*/
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getYear
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getYear(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getYear called on null.");
1: 		}
1: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1: 						"getYear", "Time");
1: 	}
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getMonth
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getMonth(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getMonth called on null.");
1: 		}
1: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1: 						"getMonth", "Time");
1: 	}
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getDate
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getDate(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getDate called on null.");
1: 		}
1: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1: 						"getDate", "Time");
1: 	}
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getHours
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getHours(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(),  "getHours called on null");
1: 		}
1: 		return SQLDate.setSource(getHour(encodedTime), result);
1: 	}
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getMinutes
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getMinutes(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getMinutes called on null");
1: 		}
1: 		return SQLDate.setSource(getMinute(encodedTime), result);
1: 	}
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getSeconds
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getSeconds(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getMinutes called on null");
1: 		}
1: 		return SQLDate.setSource(getSecond(encodedTime), result);
1: 	}
1: 
1: 	/*
1: 	** String display of value
1: 	*/
1: 
1: 	public String toString()
1: 	{
1: 		if (isNull())
1: 		{
1: 			return "NULL";
1: 		}
1: 		else
1: 		{
1: 			return getTime( (Calendar) null).toString();
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * Hash code
1: 	 */
1: 	public int hashCode()
1: 	{
1: 		if (isNull())
1: 		{
1: 			return 0;
1: 		}
1: 		// add 1 since 0 represents a valid time
1: 		return encodedTime + encodedTimeFraction + 1;
1: 
1: 	}
1: 
1: 	/** @see DataValueDescriptor#typePrecedence */
1: 	public int	typePrecedence()
1: 	{
1: 		return TypeId.TIME_PRECEDENCE;
1: 	}
1: 
1: 	/**
1: 	 * Check if the value is null.  
1: 	 *
1: 	 * @return Whether or not value is logically null.
1: 	 */
1: 	public final boolean isNull()
1: 	{
1: 		return (encodedTime ==  -1);
1: 	}
1: 
1: 	/**
1: 	 * Get the time value 
1: 	 * Since this is a JDBC object we use the JDBC definition
1: 	 * we use the JDBC definition, see JDBC API Tutorial and Reference
1: 	 * section 47.3.12
1: 	 * Date is set to Jan. 1, 1970
1: 	 *
1: 	 * @return	The localized time value.
1: 	 */
1: 	public Time getTime(java.util.Calendar cal)
1: 	{
1: 		if (isNull())
1: 			return null;
1: 
0:         return newTime(cal);
1:     }
1: 
0:     protected Time newTime(java.util.Calendar cal)
1:     {
1:         if( cal == null)
1:             cal = new GregorianCalendar();
0: 		cal.set(Calendar.YEAR, 1970);
0: 		cal.set(Calendar.MONTH, Calendar.JANUARY);
0: 		cal.set(Calendar.DATE, 1);
0: 		cal.set(Calendar.HOUR_OF_DAY, getHour(encodedTime));
0: 		cal.set(Calendar.MINUTE, getMinute(encodedTime));
0: 		cal.set(Calendar.SECOND, getSecond(encodedTime));
0: 		cal.set(Calendar.MILLISECOND, 0);	//only 0 fractional seconds currently
0: 		return new Time(cal.getTime().getTime());
1: 	}
1: 	/**
1: 	 * Get the encoded hour value (may be different than hour value for
1: 	 *  	current timezone if value encoded in a different timezone)
1: 	 *
1: 	 * @return	hour value
1: 	 */
1: 	protected static int getHour(int encodedTime)
1: 	{
1: 		return (encodedTime >>> 16) & 0xff;
1: 	}
1: 	/**
1: 	 * Get the encoded minute value (may be different than the minute value for
1: 	 *  	current timezone if value encoded in a different timezone)
1: 	 *
1: 	 * @return	minute value
1: 	 */
1: 	protected static int getMinute(int encodedTime)
1: 	{
1: 		return ((encodedTime >>> 8) & 0xff);
1: 	}
1: 	/**
1: 	 * Get the encoded second value (may be different than the second value for
1: 	 *  	current timezone if value encoded in a different timezone)
1: 	 *
1: 	 * @return	second value
1: 	 */
1: 	protected static int getSecond(int encodedTime)
1: 	{
1: 		return (encodedTime & 0xff);
1: 	}
1: 	/**
1: 	 *	Calculate the encoded time from a Calendar object
0: 	 *	encoded time is hour << 16 + min << 8 + sec
1: 	 *  this function is also used by SQLTimestamp 
1: 	 *
0: 	 * @param	calendar with time set
1: 	 * @return	encoded time
1:      *
1:      * @exception StandardException if the time is not in the DB2 range
1: 	 */
1: 	static int computeEncodedTime(Calendar cal) throws StandardException
1: 	{
1: 		return computeEncodedTime(cal.get(Calendar.HOUR_OF_DAY),
1:                                   cal.get(Calendar.MINUTE),
1:                                   cal.get(Calendar.SECOND));
1: 	}
1: 
1:     static int computeEncodedTime( int hour, int minute, int second) throws StandardException
1:     {
1:         if( hour == 24)
1:         {
1:             if( minute != 0 || second != 0)
1:                 throw StandardException.newException( SQLState.LANG_DATE_RANGE_EXCEPTION);
1:         }
1:         else if( hour < 0 || hour > 23 || minute < 0 || minute > 59 || second < 0 || second > 59)
1:             throw StandardException.newException( SQLState.LANG_DATE_RANGE_EXCEPTION);
1: 
1:         return (hour << 16) + (minute << 8) + second;
1:     }
1: 
1:     /**
1:      * Convert a time to a JDBC escape format string
1:      *
1:      * @param hour
1:      * @param minute
1:      * @param second
1:      * @param sb The resulting string is appended to this StringBuffer
1:      */
1:     static void timeToString( int hour, int minute, int second, StringBuffer sb)
1:     {
1: 		String hourStr = Integer.toString( hour);
1: 		String minStr = Integer.toString( minute);
1: 		String secondStr = Integer.toString( second);
1: 		if (hourStr.length() == 1)
1: 			sb.append("0");
1: 		sb.append( hourStr);
1: 		sb.append( JIS_SEPARATOR);
1: 		if (minStr.length() == 1)
1: 			sb.append("0");
1: 		sb.append(minStr);
1: 		sb.append( JIS_SEPARATOR);
1: 		if (secondStr.length() == 1)
1: 			sb.append("0");
1: 		sb.append(secondStr);
1:     } // end of timeToString
1: 
1: 	/**
1: 	 * Get the String version from the encodedTime.
1: 	 *
1: 	 * @return	 string value.
1: 	 */
1: 	protected static String encodedTimeToString(int encodedTime)
1: 	{
1: 		StringBuffer vstr = new StringBuffer();
1:         timeToString( SQLTime.getHour(encodedTime), SQLTime.getMinute(encodedTime), SQLTime.getSecond(encodedTime), vstr);
1: 		return vstr.toString();
1: 	}
1: 
0: 	// International Support
1: 
1: 	/**
0: 	 * International version of getString(). Overrides getNationalString
0: 	 * in DataType for date, time, and timestamp.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	protected String getNationalString(LocaleFinder localeFinder) throws StandardException
1: 	{
1: 		if (isNull())
1: 		{
0: 			return getString();
1: 		}
1: 
0: 		return localeFinder.getTimeFormat().format(getTime( (Calendar) null));
1: 	}
1: 
1: 	/**
1: 	 * Compute encoded time value
0: 	 * Time is represented by hour << 16 + minute << 8 + seconds
1: 	 */
1: 	private	int computeEncodedTime(java.util.Date value) throws StandardException
1: 	{
1:         return computeEncodedTime( value, (Calendar) null);
1:     }
1: 
1:     static int computeEncodedTime(java.util.Date value, Calendar currentCal) throws StandardException
1:     {
1:         if (value == null)
1: 			return -1;
1:         if( currentCal == null)
1:             currentCal = new GregorianCalendar();
1: 		currentCal.setTime(value);
1: 		return computeEncodedTime(currentCal);
1: 	}
1: }
1: 
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:985f758
/////////////////////////////////////////////////////////////////////////
1:     NumberDataValue nullValueInt() {
1:         return new SQLInteger();
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (isNull()) {
1:             return nullValueInt();
1:         } else {    
0:             return SQLDate.setSource(getHour(encodedTime), result);
0:         }
/////////////////////////////////////////////////////////////////////////
1:         if (isNull()) {
1:             return nullValueInt();
1:         } else {    
0:             return SQLDate.setSource(getMinute(encodedTime), result);
0:         }
/////////////////////////////////////////////////////////////////////////
1:         if (isNull()) {
1:             return nullValueInt();
1:         } else {    
0:             return SQLDate.setSource(getSecond(encodedTime), result);
0:         }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param	cal calendar with time set
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d365a22
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:      * Add a number of intervals to a datetime value. Implements the JDBC escape TIMESTAMPADD function.
1:      *
1:      * @param intervalType One of FRAC_SECOND_INTERVAL, SECOND_INTERVAL, MINUTE_INTERVAL, HOUR_INTERVAL,
1:      *                     DAY_INTERVAL, WEEK_INTERVAL, MONTH_INTERVAL, QUARTER_INTERVAL, or YEAR_INTERVAL
1:      * @param intervalCount The number of intervals to add
1:      * @param currentDate Used to convert time to timestamp
1:      * @param resultHolder If non-null a DateTimeDataValue that can be used to hold the result. If null then
1:      *                     generate a new holder
1:      *
1:      * @return startTime + intervalCount intervals, as a timestamp
1:      *
1:      * @exception StandardException
0:      */
1:     public DateTimeDataValue timestampAdd( int intervalType,
1:                                            NumberDataValue intervalCount,
1:                                            java.sql.Date currentDate,
1:                                            DateTimeDataValue resultHolder)
1:         throws StandardException
0:     {
1:         return toTimestamp( currentDate).timestampAdd( intervalType, intervalCount, currentDate, resultHolder);
0:     }
0: 
1:     private SQLTimestamp toTimestamp(java.sql.Date currentDate) throws StandardException
0:     {
1:         return new SQLTimestamp( SQLDate.computeEncodedDate( currentDate, (Calendar) null),
1:                                  getEncodedTime(),
1:                                  0 /* nanoseconds */);
0:     }
0:     
0:     /**
1:      * Finds the difference between two datetime values as a number of intervals. Implements the JDBC
1:      * TIMESTAMPDIFF escape function.
1:      *
1:      * @param intervalType One of FRAC_SECOND_INTERVAL, SECOND_INTERVAL, MINUTE_INTERVAL, HOUR_INTERVAL,
1:      *                     DAY_INTERVAL, WEEK_INTERVAL, MONTH_INTERVAL, QUARTER_INTERVAL, or YEAR_INTERVAL
1:      * @param time1
1:      * @param currentDate Used to convert time to timestamp
1:      * @param resultHolder If non-null a NumberDataValue that can be used to hold the result. If null then
1:      *                     generate a new holder
1:      *
1:      * @return the number of intervals by which this datetime is greater than time1
1:      *
1:      * @exception StandardException
0:      */
1:     public NumberDataValue timestampDiff( int intervalType,
1:                                           DateTimeDataValue time1,
1:                                           java.sql.Date currentDate,
1:                                           NumberDataValue resultHolder)
1:         throws StandardException
0:     {
1:         return toTimestamp( currentDate ).timestampDiff( intervalType, time1, currentDate, resultHolder);
0:     }
commit:2dd0b6f
/////////////////////////////////////////////////////////////////////////
1:     private static final char[] US_OR_JIS_MINUTE_END = {JIS_SEPARATOR, ' ', (char) 0};
/////////////////////////////////////////////////////////////////////////
1:                     // default is end of string, meaning that the seconds part is zero.
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.types;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.db.DatabaseContext;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.types.DateTimeDataValue;
0: import org.apache.derby.iapi.types.NumberDataValue;
0: 
0: import org.apache.derby.iapi.types.DataType;
0: import org.apache.derby.iapi.services.i18n.LocaleFinder;
0: import org.apache.derby.iapi.services.cache.ClassSize;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
0: import java.sql.Types;
0: 
0: import java.util.Calendar;
0: import java.util.GregorianCalendar;
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: 
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: 
0: import java.text.DateFormat;
0: import java.text.ParseException;
0: 
0: /**
0:  * This contains an instance of a SQL Time
0:  * Our current implementation doesn't implement time precision so the fractional
0:  * seconds portion of the time is always 0.  The default when no time precision
0:  * is specified is 0 fractional seconds.  A SQL Time without timezone information
0:  * is assumed to be in the local time zone.  The local time is stored as is
0:  * and doesn't change if the timezone changes. This is in conformance with the
0:  * SQL99 standard.  The SQL92 standard indicates that the time is in GMT and
0:  * changes with the timezone.  The SQL99 standard clarifies this to allow time without
0:  * timezoned to be stored as the local time.
0:  * <p>
0:  * Time is stored as two ints.  The first int represents hour, minute, second 
0:  * and the second represents fractional seconds (currently 0 since we don't support
0:  * time precision)
0:  * 	encodedTime = -1 indicates null
0:  *
0:  * PERFORMANCE OPTIMIZATION:
0:  *	The java.sql.Time object is only instantiated on demand for performance
0:  * 	reasons.
0:  */
0: 
0: public final class SQLTime extends DataType
0: 						implements DateTimeDataValue
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
0: 
0: 	private int		encodedTime;
0: 	private int		encodedTimeFraction; //currently always 0 since we don't
0: 											 //support time precision
0: 
0: 	// The cached value.toString()
0: 	private String	valueString;
0: 
0: 	/*
0: 	** DataValueDescriptor interface
0: 	** (mostly implemented in DataType)
0: 	*/
0: 
0:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLTime.class);
0: 
0:     public int estimateMemoryUsage()
0:     {
0:         return BASE_MEMORY_USAGE + ClassSize.estimateMemoryUsage( valueString);
0:     } // end of estimateMemoryUsage
0: 
0: 	public String getString()
0: 	{
0: 		if (!isNull())
0: 		{
0: 			if (valueString == null)
0: 			{
0: 				valueString = encodedTimeToString(encodedTime);
0: 			}
0: 			return valueString;
0: 		}
0: 		else
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (valueString != null)
0: 				{
0: 					SanityManager.THROWASSERT(
0: 						"valueString expected to be null, not " +
0: 						valueString);
0: 				}
0: 			}
0: 			return null;
0: 		}
0: 	}
0: 
0:     int getEncodedTime()
0:     {
0:         return encodedTime;
0:     }
0: 
0: 	/**
0: 		@exception StandardException thrown on failure
0: 	 */
0: 	public Timestamp getTimestamp( Calendar cal) throws StandardException
0: 	{
0: 		if (isNull())
0: 			return null;
0: 		else
0: 		{
0:             if( cal == null)
0:                 cal = new GregorianCalendar();
0: 			/*
0: 			** HACK FOR SYMANTEC: in symantec 1.8, the call
0: 			** to today.getTime().getTime() will blow up 
0: 			** in GregorianCalendar because year <= 0.
0: 			** This is a bug in some sort of optimization that
0: 			** symantic is doing (not related to the JIT).  If 
0: 			** we do a reference to that field everythings works 
0: 			** fine, hence this extraneous get(Calendar.YEAR).
0: 			*/
0: 			cal.get(Calendar.YEAR);
0: 			cal.set(Calendar.HOUR_OF_DAY, getHour(encodedTime));
0: 			cal.set(Calendar.MINUTE, getMinute(encodedTime));
0: 			cal.set(Calendar.SECOND, getSecond(encodedTime));
0: 			cal.set(Calendar.MILLISECOND, 0);
0: 			return new Timestamp(cal.getTime().getTime());
0: 		}
0: 	}
0: 
0: 	public Object getObject()
0: 	{
0: 		return getTime( (Calendar) null);
0: 	}
0: 		
0: 	public int getLength()
0: 	{
0: 		return 8;
0: 	}
0: 
0: 	/* this is for DataType's error generator */
0: 	public String getTypeName()
0: 	{
0: 		return "TIME";
0: 	}
0: 
0: 
0: 	/*
0: 	 * Storable interface, implies Externalizable, TypedFormat
0: 	 */
0: 
0: 	/**
0: 		Return my format identifier.
0: 
0: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
0: 	*/
0: 	public int getTypeFormatId() {
0: 		return StoredFormatIds.SQL_TIME_ID;
0: 	}
0: 
0: 	/** 
0: 		@exception IOException error writing data
0: 
0: 	*/
0: 	public void writeExternal(ObjectOutput out) throws IOException {
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!isNull(), "writeExternal() is not supposed to be called for null values.");
0: 
0: 		out.writeInt(encodedTime);
0: 		out.writeInt(encodedTimeFraction);
0: 	}
0: 
0: 	/**
0: 	 * @see java.io.Externalizable#readExternal
0: 	 *
0: 	 * @exception IOException	Thrown on error reading the object
0: 	 */
0: 	public void readExternal(ObjectInput in) throws IOException
0: 	{
0: 		encodedTime = in.readInt();
0: 		encodedTimeFraction = in.readInt();
0: 		// reset cached values
0: 		valueString = null;
0: 	}
0: 	public void readExternalFromArray(ArrayInputStream in) throws IOException
0: 	{
0: 		encodedTime = in.readInt();
0: 		encodedTimeFraction = in.readInt();
0: 		// reset cached values
0: 		valueString = null;
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/** @see DataValueDescriptor#getClone */
0: 	public DataValueDescriptor getClone()
0: 	{
0: 		// Call constructor with all of our info
0: 		return new SQLTime(encodedTime, encodedTimeFraction);
0: 	}
0: 
0: 	/**
0: 	 * @see DataValueDescriptor#getNewNull
0: 	 */
0: 	public DataValueDescriptor getNewNull()
0: 	{
0: 		return new SQLTime();
0: 	}
0: 	/**
0: 	 * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
0: 	 *
0: 	 */
0: 
0: 	public void restoreToNull()
0: 	{
0: 		encodedTime = -1;
0: 		encodedTimeFraction = 0;
0: 
0: 		// clear cached valueString
0: 		valueString = null;
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/** 
0: 	 * @see DataValueDescriptor#setValueFromResultSet 
0: 	 *
0: 	 * @exception SQLException		Thrown on error
0: 	 */
0: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
0: 									  boolean isNullable)
0: 		throws SQLException, StandardException
0: 	{
0: 			restoreToNull();
0: 			encodedTime = computeEncodedTime(resultSet.getTime(colNumber));
0: 			//need to set encodedTimeFraction when we implement time precision
0: 	}
0: 
0: 	/**
0: 	 * Orderable interface
0: 	 *
0: 	 *
0: 	 * @see org.apache.derby.iapi.types.Orderable
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	public int compare(DataValueDescriptor other)
0: 		throws StandardException
0: 	{
0: 		/* Use compare method from dominant type, negating result
0: 		 * to reflect flipping of sides.
0: 		 */
0: 		if (typePrecedence() < other.typePrecedence())
0: 		{
0: 			return - (other.compare(this));
0: 		}
0: 
0: 		boolean thisNull, otherNull;
0: 
0: 		thisNull = this.isNull();
0: 		otherNull = other.isNull();
0: 
0: 		/*
0: 		 * thisNull otherNull	return
0: 		 *	T		T		 	0	(this == other)
0: 		 *	F		T		 	-1 	(this < other)
0: 		 *	T		F		 	1	(this > other)
0: 		 */
0: 		if (thisNull || otherNull)
0: 		{
0: 			if (!thisNull)		// otherNull must be true
0: 				return -1;
0: 			if (!otherNull)		// thisNull must be true
0: 				return 1;
0: 			return 0;
0: 		}
0: 
0: 		/*
0: 			Neither are null compare them 
0: 		 */
0: 
0: 		int comparison;
0: 
0: 		/* get the comparison time values */
0: 		int otherEncodedTime = 0;
0: 
0: 		/* if the argument is another Time look up the value
0: 		 * we have already taken care of Null
0: 		 * ignoring encodedTimeFraction for now since it is always 0
0: 		 * - need to change this when we support TIME(precision)
0: 		 */
0: 		if (other instanceof SQLTime)
0: 		{
0: 			otherEncodedTime=((SQLTime)other).encodedTime;
0: 		}
0: 		else 
0: 		{
0: 			/* O.K. have to do it the hard way and calculate the numeric value
0: 			 * from the value
0: 			 */
0: 			otherEncodedTime = computeEncodedTime(other.getTime( (Calendar) null));
0: 		}
0: 		if (encodedTime < otherEncodedTime)
0: 			comparison = -1;
0: 		else if (encodedTime > otherEncodedTime)
0: 			comparison = 1;
0: 		else
0: 			comparison = 0;
0: 
0: 		return comparison;
0: 	}
0: 
0: 	/**
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public boolean compare(int op,
0: 						   DataValueDescriptor other,
0: 						   boolean orderedNulls,
0: 						   boolean unknownRV)
0: 		throws StandardException
0: 	{
0: 		if (!orderedNulls)		// nulls are unordered
0: 		{
0: 			if (this.isNull() || other.isNull())
0: 				return unknownRV;
0: 		}
0: 
0: 		/* Do the comparison */
0: 		return super.compare(op, other, orderedNulls, unknownRV);
0: 	}
0: 
0: 	/*
0: 	** Class interface
0: 	*/
0: 
0: 	/*
0: 	** Constructors
0: 	*/
0: 
0: 	/** no-arg constructor required by Formattable */
0: 	public SQLTime() 
0: 	{ 
0: 		encodedTime = -1;	//null value
0: 	}
0: 
0: 	public SQLTime(Time value) throws StandardException
0: 	{
0: 		parseTime(value);
0: 	}
0: 
0:     private void parseTime(java.util.Date value) throws StandardException
0: 	{
0: 		encodedTime = computeEncodedTime(value);
0: 	}
0: 
0: 	private SQLTime(int encodedTime, int encodedTimeFraction) {
0: 		this.encodedTime = encodedTime;
0: 		this.encodedTimeFraction = encodedTimeFraction;
0: 	}
0: 
0: 
0:     /**
0:      * Construct a time from a string. The allowed time formats are:
0:      *<ol>
0:      *<li>old ISO and IBM European standard: hh.mm[.ss]
0:      *<li>IBM USA standard: hh[:mm] {AM | PM}
0:      *<li>JIS & current ISO: hh:mm[:ss]
0:      *</ol>
0:      * 
0:      * @param dateStr
0:      * @param localFinder
0:      *
0:      * @return the internal DataValueDescriptor for the value
0:      *
0:      * @exception Standard exception if the syntax is invalid or the value is out of range.
0:      */
0:     public SQLTime( String timeStr, boolean isJdbcEscape, LocaleFinder localeFinder)
0:         throws StandardException
0:     {
0:         parseTime( timeStr, isJdbcEscape, localeFinder, (Calendar) null);
0:     }
0:     
0:     /**
0:      * Construct a time from a string. The allowed time formats are:
0:      *<ol>
0:      *<li>old ISO and IBM European standard: hh.mm[.ss]
0:      *<li>IBM USA standard: hh[:mm] {AM | PM}
0:      *<li>JIS & current ISO: hh:mm[:ss]
0:      *</ol>
0:      * 
0:      * @param dateStr
0:      * @param localFinder
0:      *
0:      * @return the internal DataValueDescriptor for the value
0:      *
0:      * @exception Standard exception if the syntax is invalid or the value is out of range.
0:      */
0:     public SQLTime( String timeStr, boolean isJdbcEscape, LocaleFinder localeFinder, Calendar cal)
0:         throws StandardException
0:     {
0:         parseTime( timeStr, isJdbcEscape, localeFinder, cal);
0:     }
0: 
0:     private static final char IBM_EUR_SEPARATOR = '.';
0:     private static final char[] IBM_EUR_SEPARATOR_OR_END = {IBM_EUR_SEPARATOR, (char) 0};
0:     static final char JIS_SEPARATOR = ':';
0:     private static final char[] US_OR_JIS_MINUTE_END = {JIS_SEPARATOR, ' '};
0:     private static final char[] ANY_SEPARATOR = { '.', ':', ' '};
0:     private static final String[] AM_PM = {"AM", "PM"};
0:     private static final char[] END_OF_STRING = {(char) 0};
0:     
0:     private void parseTime( String timeStr, boolean isJdbcEscape, LocaleFinder localeFinder, Calendar cal)
0:         throws StandardException
0:     {
0:         boolean validSyntax = true;
0:         DateTimeParser parser = new DateTimeParser( timeStr);
0:         StandardException thrownSE = null;
0:         int hour = 0;
0:         int minute = 0;
0:         int second = 0;
0:         int amPm = -1;
0:         try
0:         {
0:             if( parser.nextSeparator() == SQLTimestamp.DATE_SEPARATOR)
0:             {
0:                     encodedTime = SQLTimestamp.parseDateOrTimestamp( parser, true)[1];
0:                     valueString = parser.getTrimmedString();
0:                     return;
0:             }
0:             hour = parser.parseInt( 2, true, ANY_SEPARATOR, false);
0:             switch( parser.getCurrentSeparator())
0:             {
0:             case IBM_EUR_SEPARATOR:
0:                 if( isJdbcEscape)
0:                 {
0:                     validSyntax = false;
0:                     break;
0:                 }
0:                 minute = parser.parseInt( 2, false, IBM_EUR_SEPARATOR_OR_END, false);
0:                 if( parser.getCurrentSeparator() == IBM_EUR_SEPARATOR)
0:                     second = parser.parseInt( 2, false, END_OF_STRING, false);
0:                 break;
0: 
0:             case ':':
0:                 // IBM USA or JIS (new ISO)
0:                 minute = parser.parseInt( 2, false, US_OR_JIS_MINUTE_END, false);
0:                 switch( parser.getCurrentSeparator())
0:                 {
0:                 case ' ':
0:                     // IBM USA with minutes
0:                     if( isJdbcEscape)
0:                     {
0:                         validSyntax = false;
0:                         break;
0:                     }
0:                     amPm = parser.parseChoice( AM_PM);
0:                     parser.checkEnd();
0:                     break;
0: 
0:                 case JIS_SEPARATOR:
0:                     second = parser.parseInt( 2, false, END_OF_STRING, false);
0:                     break;
0: 
0:                 default:
0:                     validSyntax = false;
0:                 }
0:                 break;
0: 
0:             case ' ':
0:                 // IBM USA with minutes omitted
0:                 if( isJdbcEscape)
0:                 {
0:                     validSyntax = false;
0:                     break;
0:                 }
0:                 amPm = parser.parseChoice( AM_PM);
0:                 break;
0: 
0:             default:
0:                 validSyntax = false;
0:             }
0:         }
0:         catch( StandardException se)
0:         {
0:             validSyntax = false;
0:             thrownSE = se;
0:         }
0:         if( validSyntax)
0:         {
0:             if( amPm == 0) // AM
0:             {
0:                 if( hour == 12)
0:                 {
0:                     if( minute == 0 && second == 0)
0:                         hour = 24;
0:                     else
0:                         hour = 0;
0:                 }
0:                 else if( hour > 12)
0:                     throw StandardException.newException( SQLState.LANG_DATE_RANGE_EXCEPTION);
0:             }
0:             else if( amPm == 1) // PM
0:             {
0:                 if( hour < 12)
0:                     hour += 12;
0:                 else if( hour > 12)
0:                     throw StandardException.newException( SQLState.LANG_DATE_RANGE_EXCEPTION);
0:             }
0:             valueString = parser.checkEnd();
0:             encodedTime = computeEncodedTime( hour, minute, second);
0:         }
0:         else
0:         {
0:             // See if it is a localized time or timestamp
0:             timeStr = StringUtil.trimTrailing( timeStr);
0:             DateFormat timeFormat = null;
0:             if(localeFinder == null)
0:                 timeFormat = DateFormat.getTimeInstance();
0:             else if( cal == null)
0:                 timeFormat = localeFinder.getTimeFormat();
0:             else
0:                 timeFormat = (DateFormat) localeFinder.getTimeFormat().clone();
0:             if( cal != null)
0:                 timeFormat.setCalendar( cal);
0:             try
0:             {
0:                 encodedTime = computeEncodedTime( timeFormat.parse( timeStr), cal);
0:             }
0:             catch( ParseException pe)
0:             {
0:                 // Maybe it is a localized timestamp
0:                 try
0:                 {
0:                     encodedTime = SQLTimestamp.parseLocalTimestamp( timeStr, localeFinder, cal)[1];
0:                 }
0:                 catch( ParseException pe2)
0:                 {
0:                     if( thrownSE != null)
0:                         throw thrownSE;
0:                     throw StandardException.newException( SQLState.LANG_DATE_SYNTAX_EXCEPTION);
0:                 }
0:             }
0:             valueString = timeStr;
0:         }
0:     } // end of parseTime
0: 
0: 	public void setValue(Object theValue) throws StandardException
0: 	{
0: 		restoreToNull();
0: 		if (theValue != null)
0: 		{
0: 			if (theValue instanceof Time)
0: 			{
0: 				this.setValue((Time)theValue, (Calendar) null);
0: 			}
0: 			else if (theValue instanceof Timestamp)
0: 			{
0: 				this.setValue((Timestamp)theValue, (Calendar) null);
0: 			}
0: 			else
0: 			{
0: 				genericSetObject(theValue);
0: 			}
0: 		}
0: 	}
0: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
0: 
0: 		if (theValue instanceof SQLTime) {
0: 			restoreToNull();
0: 
0: 			SQLTime tvst = (SQLTime) theValue;
0: 			encodedTime = tvst.encodedTime;
0: 			encodedTimeFraction = tvst.encodedTimeFraction;
0: 
0: 		}
0:         else
0:         {
0:             Calendar cal = new GregorianCalendar();
0: 			setValue(theValue.getTime( cal), cal);
0:         }
0: 	}
0: 
0: 	/**
0: 		@see DateTimeDataValue#setValue
0: 
0: 		@exception StandardException thrown on failure.
0: 	 */
0: 	public void setValue(Time value, Calendar cal) throws StandardException
0: 	{
0: 		restoreToNull();
0: 		encodedTime = computeEncodedTime(value, cal);
0: 	}
0: 
0: 	/**
0: 		@see DateTimeDataValue#setValue
0: 
0: 		@exception StandardException thrown on failure.
0: 	 */
0: 	public void setValue(Timestamp value, Calendar cal) throws StandardException
0: 	{
0: 		restoreToNull();
0: 		encodedTime = computeEncodedTime(value, cal);
0: 	}
0: 
0: 
0: 	public void setValue(String theValue)
0: 	    throws StandardException
0: 	{
0: 		restoreToNull();
0: 		if (theValue != null)
0:         {
0:             DatabaseContext databaseContext = (DatabaseContext) ContextService.getContext(DatabaseContext.CONTEXT_ID);
0:             parseTime( theValue,
0:                        false,
0:                        (databaseContext == null) ? null : databaseContext.getDatabase(),
0:                        (Calendar) null);
0:         }
0: 	}
0: 
0: 	/*
0: 	** SQL Operators
0: 	*/
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getYear
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getYear(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getYear called on null.");
0: 		}
0: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
0: 						"getYear", "Time");
0: 	}
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getMonth
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getMonth(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getMonth called on null.");
0: 		}
0: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
0: 						"getMonth", "Time");
0: 	}
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getDate
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getDate(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getDate called on null.");
0: 		}
0: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
0: 						"getDate", "Time");
0: 	}
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getHours
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getHours(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(),  "getHours called on null");
0: 		}
0: 		return SQLDate.setSource(getHour(encodedTime), result);
0: 	}
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getMinutes
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getMinutes(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getMinutes called on null");
0: 		}
0: 		return SQLDate.setSource(getMinute(encodedTime), result);
0: 	}
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getSeconds
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getSeconds(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getMinutes called on null");
0: 		}
0: 		return SQLDate.setSource(getSecond(encodedTime), result);
0: 	}
0: 
0: 	/*
0: 	** String display of value
0: 	*/
0: 
0: 	public String toString()
0: 	{
0: 		if (isNull())
0: 		{
0: 			return "NULL";
0: 		}
0: 		else
0: 		{
0: 			return getTime( (Calendar) null).toString();
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * Hash code
0: 	 */
0: 	public int hashCode()
0: 	{
0: 		if (isNull())
0: 		{
0: 			return 0;
0: 		}
0: 		// add 1 since 0 represents a valid time
0: 		return encodedTime + encodedTimeFraction + 1;
0: 
0: 	}
0: 
0: 	/** @see DataValueDescriptor#typePrecedence */
0: 	public int	typePrecedence()
0: 	{
0: 		return TypeId.TIME_PRECEDENCE;
0: 	}
0: 
0: 	/**
0: 	 * Check if the value is null.  
0: 	 *
0: 	 * @return Whether or not value is logically null.
0: 	 */
0: 	public final boolean isNull()
0: 	{
0: 		return (encodedTime ==  -1);
0: 	}
0: 
0: 	/**
0: 	 * Get the time value 
0: 	 * Since this is a JDBC object we use the JDBC definition
0: 	 * we use the JDBC definition, see JDBC API Tutorial and Reference
0: 	 * section 47.3.12
0: 	 * Date is set to Jan. 1, 1970
0: 	 *
0: 	 * @return	The localized time value.
0: 	 */
0: 	public Time getTime(java.util.Calendar cal)
0: 	{
0: 		if (isNull())
0: 			return null;
0: 
0:         return newTime(cal);
0:     }
0: 
0:     protected Time newTime(java.util.Calendar cal)
0:     {
0:         if( cal == null)
0:             cal = new GregorianCalendar();
0: 		cal.set(Calendar.YEAR, 1970);
0: 		cal.set(Calendar.MONTH, Calendar.JANUARY);
0: 		cal.set(Calendar.DATE, 1);
0: 		cal.set(Calendar.HOUR_OF_DAY, getHour(encodedTime));
0: 		cal.set(Calendar.MINUTE, getMinute(encodedTime));
0: 		cal.set(Calendar.SECOND, getSecond(encodedTime));
0: 		cal.set(Calendar.MILLISECOND, 0);	//only 0 fractional seconds currently
0: 		return new Time(cal.getTime().getTime());
0: 	}
0: 	/**
0: 	 * Get the encoded hour value (may be different than hour value for
0: 	 *  	current timezone if value encoded in a different timezone)
0: 	 *
0: 	 * @return	hour value
0: 	 */
0: 	protected static int getHour(int encodedTime)
0: 	{
0: 		return (encodedTime >>> 16) & 0xff;
0: 	}
0: 	/**
0: 	 * Get the encoded minute value (may be different than the minute value for
0: 	 *  	current timezone if value encoded in a different timezone)
0: 	 *
0: 	 * @return	minute value
0: 	 */
0: 	protected static int getMinute(int encodedTime)
0: 	{
0: 		return ((encodedTime >>> 8) & 0xff);
0: 	}
0: 	/**
0: 	 * Get the encoded second value (may be different than the second value for
0: 	 *  	current timezone if value encoded in a different timezone)
0: 	 *
0: 	 * @return	second value
0: 	 */
0: 	protected static int getSecond(int encodedTime)
0: 	{
0: 		return (encodedTime & 0xff);
0: 	}
0: 	/**
0: 	 *	Calculate the encoded time from a Calendar object
0: 	 *	encoded time is hour << 16 + min << 8 + sec
0: 	 *  this function is also used by SQLTimestamp 
0: 	 *
0: 	 * @param	calendar with time set
0: 	 * @return	encoded time
0:      *
0:      * @exception StandardException if the time is not in the DB2 range
0: 	 */
0: 	static int computeEncodedTime(Calendar cal) throws StandardException
0: 	{
0: 		return computeEncodedTime(cal.get(Calendar.HOUR_OF_DAY),
0:                                   cal.get(Calendar.MINUTE),
0:                                   cal.get(Calendar.SECOND));
0: 	}
0: 
0:     static int computeEncodedTime( int hour, int minute, int second) throws StandardException
0:     {
0:         if( hour == 24)
0:         {
0:             if( minute != 0 || second != 0)
0:                 throw StandardException.newException( SQLState.LANG_DATE_RANGE_EXCEPTION);
0:         }
0:         else if( hour < 0 || hour > 23 || minute < 0 || minute > 59 || second < 0 || second > 59)
0:             throw StandardException.newException( SQLState.LANG_DATE_RANGE_EXCEPTION);
0: 
0:         return (hour << 16) + (minute << 8) + second;
0:     }
0: 
0:     /**
0:      * Convert a time to a JDBC escape format string
0:      *
0:      * @param hour
0:      * @param minute
0:      * @param second
0:      * @param sb The resulting string is appended to this StringBuffer
0:      */
0:     static void timeToString( int hour, int minute, int second, StringBuffer sb)
0:     {
0: 		String hourStr = Integer.toString( hour);
0: 		String minStr = Integer.toString( minute);
0: 		String secondStr = Integer.toString( second);
0: 		if (hourStr.length() == 1)
0: 			sb.append("0");
0: 		sb.append( hourStr);
0: 		sb.append( JIS_SEPARATOR);
0: 		if (minStr.length() == 1)
0: 			sb.append("0");
0: 		sb.append(minStr);
0: 		sb.append( JIS_SEPARATOR);
0: 		if (secondStr.length() == 1)
0: 			sb.append("0");
0: 		sb.append(secondStr);
0:     } // end of timeToString
0: 
0: 	/**
0: 	 * Get the String version from the encodedTime.
0: 	 *
0: 	 * @return	 string value.
0: 	 */
0: 	protected static String encodedTimeToString(int encodedTime)
0: 	{
0: 		StringBuffer vstr = new StringBuffer();
0:         timeToString( SQLTime.getHour(encodedTime), SQLTime.getMinute(encodedTime), SQLTime.getSecond(encodedTime), vstr);
0: 		return vstr.toString();
0: 	}
0: 
0: 	// International Support
0: 
0: 	/**
0: 	 * International version of getString(). Overrides getNationalString
0: 	 * in DataType for date, time, and timestamp.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected String getNationalString(LocaleFinder localeFinder) throws StandardException
0: 	{
0: 		if (isNull())
0: 		{
0: 			return getString();
0: 		}
0: 
0: 		return localeFinder.getTimeFormat().format(getTime( (Calendar) null));
0: 	}
0: 
0: 	/**
0: 	 * Compute encoded time value
0: 	 * Time is represented by hour << 16 + minute << 8 + seconds
0: 	 */
0: 	private	int computeEncodedTime(java.util.Date value) throws StandardException
0: 	{
0:         return computeEncodedTime( value, (Calendar) null);
0:     }
0: 
0:     static int computeEncodedTime(java.util.Date value, Calendar currentCal) throws StandardException
0:     {
0:         if (value == null)
0: 			return -1;
0:         if( currentCal == null)
0:             currentCal = new GregorianCalendar();
0: 		currentCal.setTime(value);
0: 		return computeEncodedTime(currentCal);
0: 	}
0: }
0: 
============================================================================