1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.PropertyConglomerate
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
3:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.Attribute;
1:eac0369: import org.apache.derby.iapi.reference.Property;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.UserType;
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: import org.apache.derby.iapi.services.io.FormatableHashtable; 
1:3c1f634: import org.apache.derby.iapi.services.locks.CompatibilitySpace;
1:eac0369: import org.apache.derby.iapi.services.locks.ShExLockable;
1:eac0369: import org.apache.derby.iapi.services.locks.ShExQual;
1:eac0369: import org.apache.derby.iapi.services.locks.C_LockFactory;
1:eac0369: import org.apache.derby.iapi.services.locks.Latch;
1:eac0369: import org.apache.derby.iapi.services.locks.LockFactory;
1:eac0369: import org.apache.derby.iapi.services.property.PropertyUtil;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.services.io.Formatable;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1:eac0369: import org.apache.derby.iapi.store.access.AccessFactory;
1:eac0369: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.services.property.PropertyFactory;
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:eac0369: import org.apache.derby.iapi.store.access.ScanController;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import java.io.Serializable;
1:56c1dc2: import java.security.AccessController;
1:56c1dc2: import java.security.PrivilegedActionException;
1:56c1dc2: import java.security.PrivilegedExceptionAction;
1:eac0369: import java.util.Dictionary;
1:eac0369: import java.util.Enumeration;
1:eac0369: import java.util.Hashtable;
1:eac0369: import java.util.Properties;
1:eac0369: 
2:eac0369: /**
1:eac0369: Stores properties in a congolmerate with complete transactional support.
1:eac0369: <p>
1:eac0369: The PropertyConglomerate contains one row with 2 columns per property.
1:eac0369: Column 0 is the UTF key, and column 1 is the data.
1:eac0369: <p>
1:eac0369: 
1:eac0369: <p>
1:eac0369: The property conglomerate manages the storage of database properties
1:eac0369: and thier defaults. Each property is stored as a row in the
1:eac0369: PropertyConglomerate 
1:eac0369: <OL>
1:eac0369: <LI>Column 0 is the UTF key,
1:eac0369: <LI>Column 1 is the data.
1:eac0369: </OL>
1:eac0369: All the property defaults are stored in a single row of the Property
1:eac0369: Conglomerate:
1:eac0369: <OL>
1:eac0369: <LI>Column 0 is the UTF key "derby.defaultPropertyName".
1:eac0369: <LI>Column 1 is a FormatableProperties object with one
1:eac0369:     row per default property.
1:eac0369: </OL>
1:eac0369: <p>
1:eac0369: In general a propery default defines it value if the property
1:eac0369: itself is not defined.
1:eac0369: 
1:eac0369: <p>
1:eac0369: Because the properties conglomerate is stored in a conglomerate
1:eac0369: the information it contains is not available before the raw store
1:eac0369: runs recovery. To make a small number of properties (listed in
1:eac0369: servicePropertyList) available during early boot, this copies
1:eac0369: them to services.properties.
1:eac0369: **/
1:eac0369: class PropertyConglomerate
1:eac0369: {
1:eac0369: 	protected long propertiesConglomId;
1:eac0369: 	protected Properties serviceProperties;
1:eac0369: 	private LockFactory lf;
1:a045b63:     private Dictionary<String, Object> cachedSet;
1:eac0369: 	private CacheLock cachedLock;
1:eac0369: 
1:eac0369: 	private PropertyFactory  pf;
1:eac0369: 
1:eac0369:     /* Constructors for This class: */
1:eac0369: 
1:eac0369: 	PropertyConglomerate(
1:eac0369:     TransactionController   tc,
1:eac0369:     boolean                 create,
1:eac0369:     Properties              serviceProperties,
1:eac0369: 	PropertyFactory 		pf)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		this.pf = pf;
1:eac0369: 
1:eac0369: 		if (!create) {
1:eac0369: 			String id = serviceProperties.getProperty(Property.PROPERTIES_CONGLOM_ID);
1:eac0369: 			if (id == null) {
1:eac0369: 				create = true;
1:eac0369: 			} else {
1:eac0369: 				try {
1:eac0369: 					propertiesConglomId = Long.valueOf(id).longValue();
1:eac0369: 				} catch (NumberFormatException nfe) {
1:eac0369: 					throw Monitor.exceptionStartingModule(nfe) ;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (create) {
1:eac0369: 			DataValueDescriptor[] template = makeNewTemplate();
1:eac0369: 
1:eac0369: 			Properties conglomProperties = new Properties();
1:eac0369: 
1:eac0369: 			conglomProperties.put(
1:eac0369:                 Property.PAGE_SIZE_PARAMETER, 
1:eac0369:                 RawStoreFactory.PAGE_SIZE_STRING);
1:eac0369: 
1:eac0369: 			conglomProperties.put(
1:eac0369:                 RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER, 
1:eac0369:                 RawStoreFactory.PAGE_RESERVED_ZERO_SPACE_STRING);
1:eac0369: 
1:eac0369: 			propertiesConglomId = 
1:eac0369:                 tc.createConglomerate(
1:eac0369:                     AccessFactoryGlobals.HEAP,
1:eac0369:                     template, 
1:eac0369:                     null, 
1:b61f876:                     (int[]) null, // use default collation for property conglom.
1:eac0369:                     conglomProperties, 
1:eac0369:                     TransactionController.IS_DEFAULT);
1:eac0369: 
1:eac0369: 			serviceProperties.put(
1:eac0369:                 Property.PROPERTIES_CONGLOM_ID, 
1:eac0369:                 Long.toString(propertiesConglomId));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		this.serviceProperties = serviceProperties;
1:eac0369: 
1:eac0369: 		lf = ((RAMTransaction) tc).getAccessManager().getLockFactory();
1:eac0369: 		cachedLock = new CacheLock(this);
1:eac0369: 
1:eac0369: 		PC_XenaVersion softwareVersion = new PC_XenaVersion();
1:eac0369: 		if (create)
1:eac0369: 			setProperty(tc,DataDictionary.PROPERTY_CONGLOMERATE_VERSION,
1:eac0369: 						 softwareVersion, true);
1:eac0369: 		else
1:eac0369: 			softwareVersion.upgradeIfNeeded(tc,this,serviceProperties);
1:eac0369: 
1:eac0369: 		getCachedDbProperties(tc);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /* Private/Protected methods of This class: */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Create a new PropertyConglomerate row, with values in it.
1:eac0369:      **/
1:eac0369:     private DataValueDescriptor[] makeNewTemplate(String key, Serializable value)
1:eac0369:     {
1:eac0369: 		DataValueDescriptor[] template = new DataValueDescriptor[2];
1:eac0369: 
1:eac0369: 		template[0] = new UTF(key);
1:eac0369: 		template[1] = new UserType(value);
1:eac0369: 
1:eac0369:         return(template);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Create a new empty PropertyConglomerate row, to fetch values into.
1:eac0369:      **/
1:eac0369:     private DataValueDescriptor[] makeNewTemplate()
1:eac0369:     {
1:eac0369: 		DataValueDescriptor[] template = new DataValueDescriptor[2];
1:eac0369: 
1:eac0369: 		template[0] = new UTF();
1:eac0369: 		template[1] = new UserType();
1:eac0369: 
1:eac0369:         return(template);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Open a scan on the properties conglomerate looking for "key".
1:eac0369:      * <p>
1:eac0369: 	 * Open a scan on the properties conglomerate qualified to
1:eac0369: 	 * find the row with value key in column 0.  Both column 0
1:eac0369:      * and column 1 are included in the scan list.
1:eac0369:      *
1:eac0369: 	 * @return an open ScanController on the PropertyConglomerate. 
1:eac0369:      *
1:eac0369: 	 * @param tc        The transaction to do the Conglomerate work under.
1:eac0369:      * @param key       The "key" of the property that is being requested.
1:8758a25:      * @param open_mode Whether we are setting or getting the property.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	private ScanController openScan(
1:eac0369:     TransactionController tc, 
1:eac0369:     String                key, 
1:eac0369:     int                   open_mode) 
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369: 		Qualifier[][] qualifiers = null;
1:eac0369: 
1:eac0369: 		if (key != null) {
1:eac0369: 			// Set up qualifier to look for the row with key value in column[0]
1:eac0369: 			qualifiers = new Qualifier[1][];
1:eac0369:             qualifiers[0] = new Qualifier[1];
1:eac0369: 			qualifiers[0][0] = new UTFQualifier(0, key);
1:eac0369: 		}
1:eac0369: 
1:eac0369:         // open the scan, clients will do the fetches and close.
1:eac0369: 		ScanController scan = 
1:eac0369:             tc.openScan(
1:eac0369:                 propertiesConglomId,
1:eac0369:                 false, // don't hold over the commit
1:eac0369:                 open_mode,
1:eac0369:                 TransactionController.MODE_TABLE,
1:eac0369:                 TransactionController.ISOLATION_SERIALIZABLE,
1:eac0369:                 (FormatableBitSet) null,
1:eac0369:                 (DataValueDescriptor[]) null,	// start key
1:eac0369:                 ScanController.NA,
1:eac0369:                 qualifiers,
1:eac0369:                 (DataValueDescriptor[]) null,	// stop key
1:eac0369:                 ScanController.NA);
1:eac0369: 
1:eac0369: 		return(scan);
1:eac0369: 	}
1:eac0369:     /* Package Methods of This class: */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set a property in the conglomerate.
1:eac0369: 
1:eac0369: 	 @param	key		The key used to lookup this property.
1:eac0369: 	 @param	value	The value to be associated with this key. If null, delete the
1:eac0369: 	 					property from the properties list.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the default for a property.
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369: 	 */
1:eac0369:  	void setPropertyDefault(TransactionController tc, String key, Serializable value)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		lockProperties(tc);
1:eac0369: 		Serializable valueToSave = null;
1:eac0369: 		//
1:eac0369: 		//If the default is visible we validate apply and map.
1:eac0369: 		//otherwise we just map.
1:eac0369: 		if (propertyDefaultIsVisible(tc,key))
1:eac0369: 		{
1:eac0369: 			valueToSave = validateApplyAndMap(tc,key,value,false);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			synchronized (this) {
1:a045b63:                 Hashtable<Object, Object> defaults = new Hashtable<Object, Object>();
1:eac0369: 				getProperties(tc,defaults,false/*!stringsOnly*/,true/*defaultsOnly*/);
1:eac0369: 				validate(key,value,defaults);
1:eac0369: 				valueToSave = map(key,value,defaults);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		savePropertyDefault(tc,key,valueToSave);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	boolean propertyDefaultIsVisible(TransactionController tc,String key) throws StandardException
1:eac0369: 	{
1:eac0369: 		lockProperties(tc);
1:eac0369: 		return(readProperty(tc,key) == null);
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	void saveProperty(TransactionController tc, String key, Serializable value)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (saveServiceProperty(key,value)) return;
1:eac0369: 
1:eac0369:         // Do a scan to see if the property already exists in the Conglomerate.
1:eac0369: 		ScanController scan = 
1:eac0369:             this.openScan(tc, key, TransactionController.OPENMODE_FORUPDATE);
1:eac0369: 
1:eac0369:         DataValueDescriptor[] row = makeNewTemplate();
1:eac0369: 
1:eac0369: 		if (scan.fetchNext(row)) 
1:eac0369:         {
1:eac0369: 			if (value == null)
1:eac0369:             {
1:eac0369: 				// A null input value means that we should delete the row
1:eac0369:                 
1:eac0369: 				scan.delete();
1:eac0369: 			} 
1:eac0369:             else
1:eac0369:             {
1:eac0369: 				// a value already exists, just replace the second columm
1:eac0369: 
1:eac0369: 				row[1] = new UserType(value);
1:eac0369: 
1:eac0369: 				scan.replace(row, (FormatableBitSet) null);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			scan.close();
1:eac0369: 		}
1:eac0369:         else
1:eac0369:         {
1:eac0369:             // The value does not exist in the Conglomerate.
1:eac0369: 
1:eac0369:             scan.close();
1:eac0369:             scan = null;
1:eac0369: 
1:eac0369:             if (value != null)
1:eac0369:             {
1:eac0369:                 // not a delete request, so insert the new property.
1:eac0369:                 
1:eac0369:                 row = makeNewTemplate(key, value);
1:eac0369: 
1:eac0369:                 ConglomerateController cc = 
1:eac0369:                     tc.openConglomerate(
1:eac0369:                         propertiesConglomId, 
1:eac0369:                         false,
1:eac0369:                         TransactionController.OPENMODE_FORUPDATE, 
1:eac0369:                         TransactionController.MODE_TABLE,
1:eac0369:                         TransactionController.ISOLATION_SERIALIZABLE);
1:eac0369: 
1:eac0369:                 cc.insert(row);
1:eac0369: 
1:eac0369:                 cc.close();
1:eac0369:             }
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private boolean saveServiceProperty(String key, Serializable value)
1:eac0369: 	{
1:eac0369: 		if (PropertyUtil.isServiceProperty(key))
1:eac0369: 		{
1:eac0369: 			if (value != null)
1:eac0369: 				serviceProperties.put(key, value);
1:eac0369: 			else
1:eac0369: 				serviceProperties.remove(key);
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void savePropertyDefault(TransactionController tc, String key, Serializable value)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (saveServiceProperty(key,value)) return;
1:eac0369: 
1:a045b63:         FormatableHashtable defaults = (FormatableHashtable)
1:7e7a589:             readProperty(tc,AccessFactoryGlobals.DEFAULT_PROPERTY_NAME);
1:eac0369: 		if (defaults == null) defaults = new FormatableHashtable();
1:eac0369: 		if (value==null)
1:eac0369: 			defaults.remove(key);
1:eac0369: 		else
1:eac0369: 			defaults.put(key,value);
1:eac0369: 		if (defaults.size() == 0) defaults = null;
1:eac0369: 		saveProperty(tc,AccessFactoryGlobals.DEFAULT_PROPERTY_NAME,(Serializable)defaults);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private Serializable validateApplyAndMap(TransactionController tc,
1:eac0369: 											 String key, Serializable value, boolean dbOnlyProperty)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:a045b63:         Dictionary<Object, Object> d = new Hashtable<Object, Object>();
1:eac0369: 		getProperties(tc,d,false/*!stringsOnly*/,false/*!defaultsOnly*/);
1:eac0369: 		Serializable mappedValue = pf.doValidateApplyAndMap(tc, key,
1:eac0369: 																   value, d, dbOnlyProperty);
1:eac0369: 		//
1:eac0369: 		// RESOLVE: log device cannot be changed on the fly right now
1:eac0369: 		if (key.equals(Attribute.LOG_DEVICE))
1:eac0369:         {
1:eac0369: 			throw StandardException.newException(
1:eac0369:                     SQLState.RAWSTORE_CANNOT_CHANGE_LOGDEVICE);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		if (mappedValue == null)
1:eac0369: 			return value;
1:eac0369: 		else
1:eac0369: 			return mappedValue;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Call the property set callbacks to map a proposed property value
1:eac0369: 	  to a value to save.
1:eac0369: 	  <P>
1:eac0369: 	  The caller must run this in a block synchronized on this
1:eac0369: 	  to serialize validations with changes to the set of
1:eac0369: 	  property callbacks
1:eac0369: 	  */
1:eac0369: 	private Serializable map(String key,
1:eac0369: 							 Serializable value,
1:eac0369: 							 Dictionary set)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		return pf.doMap(key, value, set);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Call the property set callbacks to validate a property change
1:eac0369: 	  against the property set provided.
1:eac0369: 	  <P>
1:eac0369: 	  The caller must run this in a block synchronized on this
1:eac0369: 	  to serialize validations with changes to the set of
1:eac0369: 	  property callbacks
1:eac0369: 	  */
1:eac0369: 
1:eac0369: 	private void validate(String key,
1:eac0369: 						  Serializable value,
1:eac0369: 						  Dictionary set)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		pf.validateSingleProperty(key, value, set);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	private boolean bootPasswordChange(TransactionController tc,
1:eac0369: 									   String key,
1:eac0369: 									   Serializable value)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		// first check for boot password  change - we don't put boot password
1:eac0369: 		// in the servicePropertyList because if we do, then we expose the
1:eac0369: 		// boot password in clear text
1:eac0369: 		if (key.equals(Attribute.BOOT_PASSWORD))
1:eac0369: 		{
1:eac0369: 			// The user is trying to change the secret key.
1:eac0369: 			// The secret key is never stored in clear text, but we
1:eac0369: 			// store the encrypted form in the services.properties
1:eac0369: 			// file.  Swap the secret key with the encrypted form and
1:eac0369: 			// put that in the services.properties file.
1:eac0369: 			AccessFactory af = ((TransactionManager)tc).getAccessManager();
1:eac0369: 
1:eac0369: 			RawStoreFactory rsf = (RawStoreFactory)
1:56c1dc2: 				findServiceModule(af, RawStoreFactory.MODULE);
1:eac0369: 
1:eac0369: 			// remove secret key from properties list if possible
1:eac0369: 			serviceProperties.remove(Attribute.BOOT_PASSWORD);
1:eac0369: 
1:eac0369: 			value = rsf.changeBootPassword(serviceProperties, value);
1:eac0369: 			serviceProperties.put(RawStoreFactory.ENCRYPTED_KEY,value);
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Sets the Serializable object associated with a property key.
1:eac0369:      * <p>
1:eac0369:      * This implementation turns the setProperty into an insert into the
1:eac0369:      * PropertyConglomerate conglomerate.
1:eac0369:      * <p>
1:eac0369:      * See the discussion of getProperty().
1:eac0369:      * <p>
1:eac0369:      * The value stored may be a Formatable object or a Serializable object
1:eac0369: 	 * whose class name starts with java.*. This stops arbitary objects being
1:eac0369: 	 * stored in the database by class name, which will cause problems in
1:eac0369: 	 * obfuscated/non-obfuscated systems.
1:eac0369:      *
1:eac0369: 	 * @param	tc		The transaction to do the Conglomerate work under.
1:eac0369: 	 * @param	key		The key used to lookup this property.
1:eac0369: 	 * @param	value	The value to be associated with this key. If null,
1:eac0369:      *                  delete the property from the properties list.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	void setProperty(
1:eac0369:     TransactionController tc,
1:eac0369:     String                key,
1:eac0369:     Serializable          value, boolean dbOnlyProperty)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369: 
1:eac0369: 			if (!((value == null) || (value instanceof Formatable)))
1:eac0369:             {
1:eac0369:                 if (!(value.getClass().getName().startsWith("java.")))
1:eac0369:                 {
1:eac0369:                     SanityManager.THROWASSERT(
1:eac0369:                         "Non-formattable, non-java class - " +
1:eac0369:                         value.getClass().getName());
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		lockProperties(tc);
1:eac0369: 		Serializable valueToValidateAndApply = value;
1:eac0369: 		//
1:eac0369: 		//If we remove a property we validate and apply its default.
1:eac0369: 		if (value == null)
1:eac0369: 			valueToValidateAndApply = getPropertyDefault(tc,key);
1:eac0369: 		Serializable valueToSave =
1:eac0369: 			validateApplyAndMap(tc,key,valueToValidateAndApply, dbOnlyProperty);
1:eac0369: 
1:eac0369: 		//
1:eac0369: 		//if this is a bootPasswordChange we save it in
1:eac0369: 		//a special way.
1:eac0369: 		if (bootPasswordChange(tc,key,value))
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		//
1:eac0369: 		//value==null means we are removing a property.
1:eac0369: 		//To remove the property we call saveProperty with
1:eac0369: 		//a null value. Note we avoid saving the mapped
1:eac0369: 		//DEFAULT value returned by validateAndApply.
1:eac0369: 		else if (value==null)
1:eac0369: 			saveProperty(tc,key,null);
1:eac0369: 		//
1:eac0369: 		//value != null means we simply save the possibly
1:eac0369: 		//mapped value of the property returned by
1:eac0369: 		//validateAndApply.
1:eac0369: 		else
1:eac0369: 			saveProperty(tc,key,valueToSave);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private Serializable readProperty(TransactionController tc,
1:eac0369: 									  String key) throws StandardException
1:eac0369: 	{
1:eac0369: 		// scan the table for a row with matching "key"
1:eac0369: 		ScanController scan = openScan(tc, key, 0);
1:eac0369: 
1:eac0369: 		DataValueDescriptor[] row = makeNewTemplate();
1:eac0369: 
1:eac0369: 		// did we find at least one row?
1:eac0369: 		boolean isThere = scan.fetchNext(row);
1:eac0369: 		
1:eac0369: 		scan.close();
1:eac0369: 
1:eac0369: 		if (!isThere) return null;
1:eac0369: 
1:eac0369: 		return (Serializable) (((UserType) row[1]).getObject());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private Serializable getCachedProperty(TransactionController tc,
1:eac0369: 										   String key) throws StandardException
1:eac0369: 	{
1:eac0369: 		//
1:eac0369: 		//Get the cached set of properties.
2:eac0369: 		Dictionary dbProps = getCachedDbProperties(tc);
1:eac0369: 
1:eac0369: 		//
1:eac0369: 		//Return the value if it is defined.
1:eac0369: 		if (dbProps.get(key) != null)
1:eac0369: 			return (Serializable) dbProps.get(key);
1:eac0369: 		else
1:eac0369: 			return getCachedPropertyDefault(tc,key,dbProps);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private Serializable getCachedPropertyDefault(TransactionController tc,
1:eac0369: 												  String key,
1:eac0369: 												  Dictionary dbProps)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		//
1:eac0369: 		//Get the cached set of properties.
1:eac0369: 		if (dbProps == null) dbProps = getCachedDbProperties(tc);
1:eac0369: 		//
1:eac0369: 		//return the default for the value if it is defined.
3:eac0369: 		Dictionary defaults = (Dictionary)dbProps.get(AccessFactoryGlobals.DEFAULT_PROPERTY_NAME);
1:eac0369: 		if (defaults == null)
1:eac0369: 			return null;
1:eac0369: 		else
1:eac0369: 			return (Serializable)defaults.get(key);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Gets the de-serialized object associated with a property key.
1:eac0369:      * <p>
1:eac0369:      * The Store provides a transaction protected list of database properties.
1:eac0369:      * Higher levels of the system can store and retrieve these properties
1:eac0369:      * once Recovery has finished. Each property is a serializable object
1:eac0369:      * and is stored/retrieved using a String key.
1:eac0369:      * <p>
1:eac0369:      * In this implementation a lookup is done on the PropertyConglomerate
1:eac0369:      * conglomerate, using a scan with "key" as the qualifier.
1:eac0369:      * <p>
1:eac0369: 	 * @param tc      The transaction to do the Conglomerate work under.
1:eac0369:      * @param key     The "key" of the property that is being requested.
1:eac0369:      *
1:eac0369: 	 * @return object The object associated with property key. n
1:eac0369:      *                ull means no such key-value pair.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	Serializable getProperty(
1:eac0369:     TransactionController tc, 
1:eac0369:     String                key) 
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369: 		//
1:eac0369: 		//Try service properties first.
1:eac0369: 		if(PropertyUtil.isServiceProperty(key)) return serviceProperties.getProperty(key);
1:eac0369: 
1:eac0369: 		// See if I'm the exclusive owner. If so I cannot populate
1:eac0369: 		// the cache as it would contain my uncommitted changes.
1:eac0369: 		if (iHoldTheUpdateLock(tc))
1:eac0369: 		{
1:eac0369: 			//
1:eac0369: 			//Return the property value if it is defined.
1:eac0369: 			Serializable v = readProperty(tc,key);
1:eac0369: 			if (v != null) return v;
1:eac0369: 
1:eac0369: 			return getPropertyDefault(tc,key);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return getCachedProperty(tc,key);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the default for a property.
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369: 	 */
1:eac0369: 	Serializable getPropertyDefault(TransactionController tc, String key)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		// See if I'm the exclusive owner. If so I cannot populate
1:eac0369: 		// the cache as it would contain my uncommitted changes.
1:eac0369: 		if (iHoldTheUpdateLock(tc))
1:eac0369: 		{
1:eac0369: 			//
1:eac0369: 			//Return the property default value (may be null) if
1:eac0369: 			//defined.
2:eac0369: 			Dictionary defaults = (Dictionary)readProperty(tc,AccessFactoryGlobals.DEFAULT_PROPERTY_NAME);
1:eac0369: 			if (defaults == null)
1:eac0369: 				return null;
1:eac0369: 			else
1:eac0369: 				return (Serializable)defaults.get(key);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return getCachedPropertyDefault(tc,key,null);
1:eac0369: 		}
1:eac0369: 	}
1:a045b63: 
1:a045b63:     private <K, V> Dictionary<? super K, ? super V> copyValues(
1:a045b63:             Dictionary<? super K, ? super V> to,
1:a045b63:             Dictionary<K, V> from, boolean stringsOnly)
1:eac0369: 	{
1:eac0369: 		if (from == null) return to; 
1:a045b63:         for (Enumeration<K> keys = from.keys(); keys.hasMoreElements(); ) {
1:a045b63:             K key = keys.nextElement();
1:a045b63:             V value = from.get(key);
1:eac0369: 			if ((value instanceof String) || !stringsOnly)
1:eac0369: 				to.put(key, value);
1:eac0369: 		}
1:eac0369: 		return to;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Fetch the set of properties as a Properties object. This means
1:eac0369: 		that only keys that have String values will be included.
1:eac0369: 	*/
1:eac0369: 	Properties getProperties(TransactionController tc) throws StandardException {
1:eac0369: 		Properties p = new Properties();
1:eac0369: 		getProperties(tc,p,true/*stringsOnly*/,false/*!defaultsOnly*/);
1:eac0369: 		return p;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void getProperties(TransactionController tc,
1:a045b63:                                Dictionary<Object, Object> d,
1:eac0369: 							   boolean stringsOnly,
1:eac0369: 							   boolean defaultsOnly) throws StandardException
1:eac0369: 	{
1:eac0369: 		// See if I'm the exclusive owner. If so I cannot populate
1:eac0369: 		// the cache as it would contain my uncommitted changes.
1:a045b63:         Dictionary<String, Object> dbProps;
1:eac0369: 		if (iHoldTheUpdateLock(tc))
1:eac0369: 		{
1:a045b63:             dbProps = readDbProperties(tc);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{	
1:a045b63:             dbProps = getCachedDbProperties(tc);
1:eac0369: 		}
1:a045b63: 
1:a045b63:         FormatableHashtable defaults = (FormatableHashtable)
1:a045b63:                 dbProps.get(AccessFactoryGlobals.DEFAULT_PROPERTY_NAME);
1:a045b63:         copyValues(d, defaults, stringsOnly);
1:a045b63:         if (!defaultsOnly) {
1:a045b63:             copyValues(d, dbProps, stringsOnly);
1:a045b63:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void resetCache() {cachedSet = null;}
1:eac0369: 
1:eac0369: 	/** Read the database properties and add in the service set. */
1:7e7a589: 	private Dictionary<String,Object> readDbProperties(TransactionController tc)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:7e7a589: 		Dictionary<String,Object> set = new Hashtable<String,Object>();
1:eac0369: 
1:eac0369:         // scan the table for a row with no matching "key"
1:eac0369: 		ScanController scan = openScan(tc, (String) null, 0);
1:eac0369: 
1:eac0369: 		DataValueDescriptor[] row = makeNewTemplate();
1:eac0369: 
1:eac0369: 		while (scan.fetchNext(row)) {
1:eac0369: 
1:eac0369: 			Object key = ((UserType) row[0]).getObject();
1:eac0369: 			Object value = ((UserType) row[1]).getObject();
1:eac0369: 			if (SanityManager.DEBUG) {
1:eac0369:                 if (!(key instanceof String))
1:eac0369:                     SanityManager.THROWASSERT(
1:eac0369:                         "Key is not a string " + key.getClass().getName());
1:eac0369: 			}
1:7e7a589: 			set.put((String)key, value);
1:eac0369: 		}
1:eac0369: 		scan.close();
1:eac0369: 
1:eac0369: 		// add the known properties from the service properties set
1:da7973c:         String[]    servicePropertyList = PropertyUtil.getServicePropertyList();
1:da7973c: 		for (int i = 0; i < servicePropertyList.length; i++) {
1:eac0369: 			String value =
1:da7973c: 				serviceProperties.getProperty(servicePropertyList[i]);
1:da7973c: 			if (value != null) set.put(servicePropertyList[i], value);
1:eac0369: 		}
1:eac0369: 		return set;
1:eac0369: 	}
1:eac0369: 
1:a045b63:     private Dictionary<String, Object>
1:a045b63:             getCachedDbProperties(TransactionController tc)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:a045b63:         Dictionary<String, Object> dbProps = cachedSet;
1:eac0369: 		//Get the cached set of properties.
1:eac0369: 		if (dbProps == null)
1:eac0369: 		{
1:eac0369: 			dbProps = readDbProperties(tc);
1:eac0369: 			cachedSet = dbProps;
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		return dbProps;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** Lock the database properties for an update. */
1:eac0369: 	void lockProperties(TransactionController tc) throws StandardException
1:eac0369: 	{
1:eac0369: 		// lock the property set until the transaction commits.
1:eac0369: 		// This allows correct operation of the cache. The cache remains
1:eac0369: 		// valid for all transactions except the one that is modifying
1:eac0369: 		// it. Thus readers see the old uncommited values. When this
1:eac0369: 		// thread releases its exclusive lock the cached is cleared
1:eac0369: 		// and the next reader will re-populate the cache.
1:3c1f634: 		CompatibilitySpace cs = tc.getLockSpace();
1:3c1f634: 		Object csGroup = cs.getOwner();
1:3c1f634: 		lf.lockObject(cs, csGroup, cachedLock, ShExQual.EX,
1:3c1f634: 					  C_LockFactory.TIMED_WAIT);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Return true if the caller holds the exclusive update lock on the
1:eac0369: 	  property conglomerate.
1:eac0369: 	  */
1:eac0369: 	private boolean iHoldTheUpdateLock(TransactionController tc) throws StandardException
1:eac0369: 	{
1:3c1f634: 		CompatibilitySpace cs = tc.getLockSpace();
1:3c1f634: 		Object csGroup = cs.getOwner();
1:3c1f634: 		return lf.isLockHeld(cs, csGroup, cachedLock, ShExQual.EX);
1:eac0369: 	}
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object findServiceModule( final Object serviceModule, final String factoryInterface)
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.findServiceModule( serviceModule, factoryInterface );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:eac0369: }
1:eac0369: 
1:eac0369: /**
1:eac0369: 	Only used for exclusive lock purposes.
1:eac0369: */
1:eac0369: class CacheLock extends ShExLockable {
1:eac0369: 
1:eac0369: 	private PropertyConglomerate pc;
1:eac0369: 
1:eac0369: 	CacheLock(PropertyConglomerate pc) {
1:eac0369: 		this.pc = pc;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void unlockEvent(Latch lockInfo)
1:eac0369: 	{
1:eac0369: 		super.unlockEvent(lockInfo);		
1:eac0369: 		pc.resetCache();
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1: 				findServiceModule(af, RawStoreFactory.MODULE);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object findServiceModule( final Object serviceModule, final String factoryInterface)
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.findServiceModule( serviceModule, factoryInterface );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
commit:073b862
/////////////////////////////////////////////////////////////////////////
0: 		Hashtable<Object,Object> defaults = (Hashtable<Object,Object>)
commit:7e7a589
/////////////////////////////////////////////////////////////////////////
0:     @SuppressWarnings("unchecked")
0: 		Dictionary<String,Object> defaults = (Dictionary<String,Object>)
1:             readProperty(tc,AccessFactoryGlobals.DEFAULT_PROPERTY_NAME);
/////////////////////////////////////////////////////////////////////////
0: 	private Dictionary<String,Object> copyValues(Dictionary<String,Object> to, Dictionary<String,Object> from, boolean stringsOnly)
/////////////////////////////////////////////////////////////////////////
0:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
1: 	private Dictionary<String,Object> readDbProperties(TransactionController tc)
1: 		Dictionary<String,Object> set = new Hashtable<String,Object>();
/////////////////////////////////////////////////////////////////////////
1: 			set.put((String)key, value);
commit:da7973c
/////////////////////////////////////////////////////////////////////////
1:         String[]    servicePropertyList = PropertyUtil.getServicePropertyList();
1: 		for (int i = 0; i < servicePropertyList.length; i++) {
1: 				serviceProperties.getProperty(servicePropertyList[i]);
1: 			if (value != null) set.put(servicePropertyList[i], value);
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a045b63
/////////////////////////////////////////////////////////////////////////
1:     private Dictionary<String, Object> cachedSet;
/////////////////////////////////////////////////////////////////////////
1:                 Hashtable<Object, Object> defaults = new Hashtable<Object, Object>();
/////////////////////////////////////////////////////////////////////////
1:         FormatableHashtable defaults = (FormatableHashtable)
/////////////////////////////////////////////////////////////////////////
1:         Dictionary<Object, Object> d = new Hashtable<Object, Object>();
/////////////////////////////////////////////////////////////////////////
1: 
1:     private <K, V> Dictionary<? super K, ? super V> copyValues(
1:             Dictionary<? super K, ? super V> to,
1:             Dictionary<K, V> from, boolean stringsOnly)
1:         for (Enumeration<K> keys = from.keys(); keys.hasMoreElements(); ) {
1:             K key = keys.nextElement();
1:             V value = from.get(key);
/////////////////////////////////////////////////////////////////////////
1:                                Dictionary<Object, Object> d,
1:         Dictionary<String, Object> dbProps;
1:             dbProps = readDbProperties(tc);
1:             dbProps = getCachedDbProperties(tc);
1: 
1:         FormatableHashtable defaults = (FormatableHashtable)
1:                 dbProps.get(AccessFactoryGlobals.DEFAULT_PROPERTY_NAME);
1:         copyValues(d, defaults, stringsOnly);
1:         if (!defaultsOnly) {
1:             copyValues(d, dbProps, stringsOnly);
1:         }
/////////////////////////////////////////////////////////////////////////
1:     private Dictionary<String, Object>
1:             getCachedDbProperties(TransactionController tc)
1:         Dictionary<String, Object> dbProps = cachedSet;
commit:3c1f634
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.locks.CompatibilitySpace;
/////////////////////////////////////////////////////////////////////////
1: 		CompatibilitySpace cs = tc.getLockSpace();
1: 		Object csGroup = cs.getOwner();
1: 		lf.lockObject(cs, csGroup, cachedLock, ShExQual.EX,
1: 					  C_LockFactory.TIMED_WAIT);
/////////////////////////////////////////////////////////////////////////
1: 		CompatibilitySpace cs = tc.getLockSpace();
1: 		Object csGroup = cs.getOwner();
1: 		return lf.isLockHeld(cs, csGroup, cachedLock, ShExQual.EX);
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b61f876
/////////////////////////////////////////////////////////////////////////
1:                     (int[]) null, // use default collation for property conglom.
commit:8758a25
/////////////////////////////////////////////////////////////////////////
1:      * @param open_mode Whether we are setting or getting the property.
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.PropertyConglomerate
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access;
1: 
1: import org.apache.derby.iapi.reference.Attribute;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.types.UserType;
0: import org.apache.derby.impl.store.access.UTF;
0: import org.apache.derby.impl.store.access.UTFQualifier;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.services.io.FormatableHashtable; 
1: import org.apache.derby.iapi.services.locks.ShExLockable;
1: import org.apache.derby.iapi.services.locks.ShExQual;
0: import org.apache.derby.iapi.services.daemon.Serviceable;
1: import org.apache.derby.iapi.services.locks.C_LockFactory;
1: import org.apache.derby.iapi.services.locks.Latch;
1: import org.apache.derby.iapi.services.locks.LockFactory;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
1: 
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.io.Formatable;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: import org.apache.derby.iapi.store.access.AccessFactory;
1: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.services.property.PropertyFactory;
0: import org.apache.derby.iapi.services.property.PropertySetCallback;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import java.io.Serializable;
1: import java.util.Dictionary;
1: import java.util.Enumeration;
1: import java.util.Hashtable;
1: import java.util.Properties;
1: 
1: /**
1: Stores properties in a congolmerate with complete transactional support.
1: <p>
1: The PropertyConglomerate contains one row with 2 columns per property.
1: Column 0 is the UTF key, and column 1 is the data.
1: <p>
1: 
1: <p>
1: The property conglomerate manages the storage of database properties
1: and thier defaults. Each property is stored as a row in the
1: PropertyConglomerate 
1: <OL>
1: <LI>Column 0 is the UTF key,
1: <LI>Column 1 is the data.
1: </OL>
1: All the property defaults are stored in a single row of the Property
1: Conglomerate:
1: <OL>
1: <LI>Column 0 is the UTF key "derby.defaultPropertyName".
1: <LI>Column 1 is a FormatableProperties object with one
1:     row per default property.
1: </OL>
1: <p>
1: In general a propery default defines it value if the property
1: itself is not defined.
1: 
1: <p>
1: Because the properties conglomerate is stored in a conglomerate
1: the information it contains is not available before the raw store
1: runs recovery. To make a small number of properties (listed in
1: servicePropertyList) available during early boot, this copies
1: them to services.properties.
1: **/
1: class PropertyConglomerate
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	protected long propertiesConglomId;
1: 	protected Properties serviceProperties;
1: 	private LockFactory lf;
0: 	private Dictionary	cachedSet;
1: 	private CacheLock cachedLock;
1: 
1: 	private PropertyFactory  pf;
1: 
1:     /* Constructors for This class: */
1: 
1: 	PropertyConglomerate(
1:     TransactionController   tc,
1:     boolean                 create,
1:     Properties              serviceProperties,
1: 	PropertyFactory 		pf)
1: 		throws StandardException
1: 	{
1: 		this.pf = pf;
1: 
1: 		if (!create) {
1: 			String id = serviceProperties.getProperty(Property.PROPERTIES_CONGLOM_ID);
1: 			if (id == null) {
1: 				create = true;
1: 			} else {
1: 				try {
1: 					propertiesConglomId = Long.valueOf(id).longValue();
1: 				} catch (NumberFormatException nfe) {
1: 					throw Monitor.exceptionStartingModule(nfe) ;
1: 				}
1: 			}
1: 		}
1: 
1: 		if (create) {
1: 			DataValueDescriptor[] template = makeNewTemplate();
1: 
1: 			Properties conglomProperties = new Properties();
1: 
1: 			conglomProperties.put(
1:                 Property.PAGE_SIZE_PARAMETER, 
1:                 RawStoreFactory.PAGE_SIZE_STRING);
1: 
1: 			conglomProperties.put(
1:                 RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER, 
1:                 RawStoreFactory.PAGE_RESERVED_ZERO_SPACE_STRING);
1: 
1: 			propertiesConglomId = 
1:                 tc.createConglomerate(
1:                     AccessFactoryGlobals.HEAP,
1:                     template, 
1:                     null, 
1:                     conglomProperties, 
1:                     TransactionController.IS_DEFAULT);
1: 
1: 			serviceProperties.put(
1:                 Property.PROPERTIES_CONGLOM_ID, 
1:                 Long.toString(propertiesConglomId));
1: 		}
1: 
1: 		this.serviceProperties = serviceProperties;
1: 
1: 		lf = ((RAMTransaction) tc).getAccessManager().getLockFactory();
1: 		cachedLock = new CacheLock(this);
1: 
1: 		PC_XenaVersion softwareVersion = new PC_XenaVersion();
1: 		if (create)
1: 			setProperty(tc,DataDictionary.PROPERTY_CONGLOMERATE_VERSION,
1: 						 softwareVersion, true);
1: 		else
1: 			softwareVersion.upgradeIfNeeded(tc,this,serviceProperties);
1: 
1: 		getCachedDbProperties(tc);
1: 	}
1: 
1:     /* Private/Protected methods of This class: */
1: 
1:     /**
1:      * Create a new PropertyConglomerate row, with values in it.
1:      **/
1:     private DataValueDescriptor[] makeNewTemplate(String key, Serializable value)
1:     {
1: 		DataValueDescriptor[] template = new DataValueDescriptor[2];
1: 
1: 		template[0] = new UTF(key);
1: 		template[1] = new UserType(value);
1: 
1:         return(template);
1:     }
1: 
1:     /**
1:      * Create a new empty PropertyConglomerate row, to fetch values into.
1:      **/
1:     private DataValueDescriptor[] makeNewTemplate()
1:     {
1: 		DataValueDescriptor[] template = new DataValueDescriptor[2];
1: 
1: 		template[0] = new UTF();
1: 		template[1] = new UserType();
1: 
1:         return(template);
1:     }
1: 
1:     /**
1:      * Open a scan on the properties conglomerate looking for "key".
1:      * <p>
1: 	 * Open a scan on the properties conglomerate qualified to
1: 	 * find the row with value key in column 0.  Both column 0
1:      * and column 1 are included in the scan list.
1:      *
1: 	 * @return an open ScanController on the PropertyConglomerate. 
1:      *
1: 	 * @param tc        The transaction to do the Conglomerate work under.
1:      * @param key       The "key" of the property that is being requested.
0:      * @param forUpdate Whether we are setting or getting the property.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	private ScanController openScan(
1:     TransactionController tc, 
1:     String                key, 
1:     int                   open_mode) 
1: 		throws StandardException
1:     {
1: 		Qualifier[][] qualifiers = null;
1: 
1: 		if (key != null) {
1: 			// Set up qualifier to look for the row with key value in column[0]
1: 			qualifiers = new Qualifier[1][];
1:             qualifiers[0] = new Qualifier[1];
1: 			qualifiers[0][0] = new UTFQualifier(0, key);
1: 		}
1: 
1:         // open the scan, clients will do the fetches and close.
1: 		ScanController scan = 
1:             tc.openScan(
1:                 propertiesConglomId,
1:                 false, // don't hold over the commit
1:                 open_mode,
1:                 TransactionController.MODE_TABLE,
1:                 TransactionController.ISOLATION_SERIALIZABLE,
1:                 (FormatableBitSet) null,
1:                 (DataValueDescriptor[]) null,	// start key
1:                 ScanController.NA,
1:                 qualifiers,
1:                 (DataValueDescriptor[]) null,	// stop key
1:                 ScanController.NA);
1: 
1: 		return(scan);
1: 	}
1:     /* Package Methods of This class: */
1: 
1: 	/**
1: 		Set a property in the conglomerate.
1: 
1: 	 @param	key		The key used to lookup this property.
1: 	 @param	value	The value to be associated with this key. If null, delete the
1: 	 					property from the properties list.
1: 	*/
1: 
1: 	/**
1: 	 * Set the default for a property.
1: 	 * @exception  StandardException  Standard exception policy.
1: 	 */
1:  	void setPropertyDefault(TransactionController tc, String key, Serializable value)
1: 		 throws StandardException
1: 	{
1: 		lockProperties(tc);
1: 		Serializable valueToSave = null;
1: 		//
1: 		//If the default is visible we validate apply and map.
1: 		//otherwise we just map.
1: 		if (propertyDefaultIsVisible(tc,key))
1: 		{
1: 			valueToSave = validateApplyAndMap(tc,key,value,false);
1: 		}
1: 		else
1: 		{
1: 			synchronized (this) {
0: 				Hashtable defaults = new Hashtable();
1: 				getProperties(tc,defaults,false/*!stringsOnly*/,true/*defaultsOnly*/);
1: 				validate(key,value,defaults);
1: 				valueToSave = map(key,value,defaults);
1: 			}
1: 		}
1: 		savePropertyDefault(tc,key,valueToSave);
1: 	}
1: 
1: 	boolean propertyDefaultIsVisible(TransactionController tc,String key) throws StandardException
1: 	{
1: 		lockProperties(tc);
1: 		return(readProperty(tc,key) == null);
1: 	}
1: 	
1: 	void saveProperty(TransactionController tc, String key, Serializable value)
1: 		 throws StandardException
1: 	{
1: 		if (saveServiceProperty(key,value)) return;
1: 
1:         // Do a scan to see if the property already exists in the Conglomerate.
1: 		ScanController scan = 
1:             this.openScan(tc, key, TransactionController.OPENMODE_FORUPDATE);
1: 
1:         DataValueDescriptor[] row = makeNewTemplate();
1: 
1: 		if (scan.fetchNext(row)) 
1:         {
1: 			if (value == null)
1:             {
1: 				// A null input value means that we should delete the row
1:                 
1: 				scan.delete();
1: 			} 
1:             else
1:             {
1: 				// a value already exists, just replace the second columm
1: 
1: 				row[1] = new UserType(value);
1: 
1: 				scan.replace(row, (FormatableBitSet) null);
1: 			}
1: 
1: 			scan.close();
1: 		}
1:         else
1:         {
1:             // The value does not exist in the Conglomerate.
1: 
1:             scan.close();
1:             scan = null;
1: 
1:             if (value != null)
1:             {
1:                 // not a delete request, so insert the new property.
1:                 
1:                 row = makeNewTemplate(key, value);
1: 
1:                 ConglomerateController cc = 
1:                     tc.openConglomerate(
1:                         propertiesConglomId, 
1:                         false,
1:                         TransactionController.OPENMODE_FORUPDATE, 
1:                         TransactionController.MODE_TABLE,
1:                         TransactionController.ISOLATION_SERIALIZABLE);
1: 
1:                 cc.insert(row);
1: 
1:                 cc.close();
1:             }
1:         }
1: 	}
1: 
1: 	private boolean saveServiceProperty(String key, Serializable value)
1: 	{
1: 		if (PropertyUtil.isServiceProperty(key))
1: 		{
1: 			if (value != null)
1: 				serviceProperties.put(key, value);
1: 			else
1: 				serviceProperties.remove(key);
1: 			return true;
1: 		}
1: 		else
1: 		{
1: 			return false;
1: 		}
1: 	}
1: 
1: 	void savePropertyDefault(TransactionController tc, String key, Serializable value)
1: 		 throws StandardException
1: 	{
1: 		if (saveServiceProperty(key,value)) return;
1: 
1: 		Dictionary defaults = (Dictionary)readProperty(tc,AccessFactoryGlobals.DEFAULT_PROPERTY_NAME);
1: 		if (defaults == null) defaults = new FormatableHashtable();
1: 		if (value==null)
1: 			defaults.remove(key);
1: 		else
1: 			defaults.put(key,value);
1: 		if (defaults.size() == 0) defaults = null;
1: 		saveProperty(tc,AccessFactoryGlobals.DEFAULT_PROPERTY_NAME,(Serializable)defaults);
1: 	}
1: 
1: 	private Serializable validateApplyAndMap(TransactionController tc,
1: 											 String key, Serializable value, boolean dbOnlyProperty)
1: 		 throws StandardException
1: 	{
0: 		Dictionary d = new Hashtable();
1: 		getProperties(tc,d,false/*!stringsOnly*/,false/*!defaultsOnly*/);
1: 		Serializable mappedValue = pf.doValidateApplyAndMap(tc, key,
1: 																   value, d, dbOnlyProperty);
1: 		//
1: 		// RESOLVE: log device cannot be changed on the fly right now
1: 		if (key.equals(Attribute.LOG_DEVICE))
1:         {
1: 			throw StandardException.newException(
1:                     SQLState.RAWSTORE_CANNOT_CHANGE_LOGDEVICE);
1:         }
1: 
1: 		if (mappedValue == null)
1: 			return value;
1: 		else
1: 			return mappedValue;
1: 	}
1: 
1: 	/**
1: 	  Call the property set callbacks to map a proposed property value
1: 	  to a value to save.
1: 	  <P>
1: 	  The caller must run this in a block synchronized on this
1: 	  to serialize validations with changes to the set of
1: 	  property callbacks
1: 	  */
1: 	private Serializable map(String key,
1: 							 Serializable value,
1: 							 Dictionary set)
1: 		 throws StandardException
1: 	{
1: 		return pf.doMap(key, value, set);
1: 	}
1: 
1: 	/**
1: 	  Call the property set callbacks to validate a property change
1: 	  against the property set provided.
1: 	  <P>
1: 	  The caller must run this in a block synchronized on this
1: 	  to serialize validations with changes to the set of
1: 	  property callbacks
1: 	  */
1: 
1: 	private void validate(String key,
1: 						  Serializable value,
1: 						  Dictionary set)
1: 		 throws StandardException
1: 	{
1: 		pf.validateSingleProperty(key, value, set);
1: 	}
1: 
1: 
1: 	private boolean bootPasswordChange(TransactionController tc,
1: 									   String key,
1: 									   Serializable value)
1: 		 throws StandardException
1: 	{
1: 		// first check for boot password  change - we don't put boot password
1: 		// in the servicePropertyList because if we do, then we expose the
1: 		// boot password in clear text
1: 		if (key.equals(Attribute.BOOT_PASSWORD))
1: 		{
1: 			// The user is trying to change the secret key.
1: 			// The secret key is never stored in clear text, but we
1: 			// store the encrypted form in the services.properties
1: 			// file.  Swap the secret key with the encrypted form and
1: 			// put that in the services.properties file.
1: 			AccessFactory af = ((TransactionManager)tc).getAccessManager();
1: 
1: 			RawStoreFactory rsf = (RawStoreFactory)
0: 				Monitor.findServiceModule(af, RawStoreFactory.MODULE);
1: 
1: 			// remove secret key from properties list if possible
1: 			serviceProperties.remove(Attribute.BOOT_PASSWORD);
1: 
1: 			value = rsf.changeBootPassword(serviceProperties, value);
1: 			serviceProperties.put(RawStoreFactory.ENCRYPTED_KEY,value);
1: 			return true;
1: 		}
1: 		else
1: 		{
1: 			return false;
1: 		}
1: 	}
1: 
1:     /**
1:      * Sets the Serializable object associated with a property key.
1:      * <p>
1:      * This implementation turns the setProperty into an insert into the
1:      * PropertyConglomerate conglomerate.
1:      * <p>
1:      * See the discussion of getProperty().
1:      * <p>
1:      * The value stored may be a Formatable object or a Serializable object
1: 	 * whose class name starts with java.*. This stops arbitary objects being
1: 	 * stored in the database by class name, which will cause problems in
1: 	 * obfuscated/non-obfuscated systems.
1:      *
1: 	 * @param	tc		The transaction to do the Conglomerate work under.
1: 	 * @param	key		The key used to lookup this property.
1: 	 * @param	value	The value to be associated with this key. If null,
1:      *                  delete the property from the properties list.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	void setProperty(
1:     TransactionController tc,
1:     String                key,
1:     Serializable          value, boolean dbOnlyProperty)
1: 		throws StandardException
1:     {
1: 		if (SanityManager.DEBUG)
1:         {
1: 
1: 			if (!((value == null) || (value instanceof Formatable)))
1:             {
1:                 if (!(value.getClass().getName().startsWith("java.")))
1:                 {
1:                     SanityManager.THROWASSERT(
1:                         "Non-formattable, non-java class - " +
1:                         value.getClass().getName());
1:                 }
1:             }
1: 		}
1: 
1: 		lockProperties(tc);
1: 		Serializable valueToValidateAndApply = value;
1: 		//
1: 		//If we remove a property we validate and apply its default.
1: 		if (value == null)
1: 			valueToValidateAndApply = getPropertyDefault(tc,key);
1: 		Serializable valueToSave =
1: 			validateApplyAndMap(tc,key,valueToValidateAndApply, dbOnlyProperty);
1: 
1: 		//
1: 		//if this is a bootPasswordChange we save it in
1: 		//a special way.
1: 		if (bootPasswordChange(tc,key,value))
1: 			return;
1: 
1: 		//
1: 		//value==null means we are removing a property.
1: 		//To remove the property we call saveProperty with
1: 		//a null value. Note we avoid saving the mapped
1: 		//DEFAULT value returned by validateAndApply.
1: 		else if (value==null)
1: 			saveProperty(tc,key,null);
1: 		//
1: 		//value != null means we simply save the possibly
1: 		//mapped value of the property returned by
1: 		//validateAndApply.
1: 		else
1: 			saveProperty(tc,key,valueToSave);
1: 	}
1: 
1: 	private Serializable readProperty(TransactionController tc,
1: 									  String key) throws StandardException
1: 	{
1: 		// scan the table for a row with matching "key"
1: 		ScanController scan = openScan(tc, key, 0);
1: 
1: 		DataValueDescriptor[] row = makeNewTemplate();
1: 
1: 		// did we find at least one row?
1: 		boolean isThere = scan.fetchNext(row);
1: 		
1: 		scan.close();
1: 
1: 		if (!isThere) return null;
1: 
1: 		return (Serializable) (((UserType) row[1]).getObject());
1: 	}
1: 
1: 	private Serializable getCachedProperty(TransactionController tc,
1: 										   String key) throws StandardException
1: 	{
1: 		//
1: 		//Get the cached set of properties.
1: 		Dictionary dbProps = getCachedDbProperties(tc);
1: 
1: 		//
1: 		//Return the value if it is defined.
1: 		if (dbProps.get(key) != null)
1: 			return (Serializable) dbProps.get(key);
1: 		else
1: 			return getCachedPropertyDefault(tc,key,dbProps);
1: 	}
1: 
1: 	private Serializable getCachedPropertyDefault(TransactionController tc,
1: 												  String key,
1: 												  Dictionary dbProps)
1: 		 throws StandardException
1: 	{
1: 		//
1: 		//Get the cached set of properties.
1: 		if (dbProps == null) dbProps = getCachedDbProperties(tc);
1: 		//
1: 		//return the default for the value if it is defined.
1: 		Dictionary defaults = (Dictionary)dbProps.get(AccessFactoryGlobals.DEFAULT_PROPERTY_NAME);
1: 		if (defaults == null)
1: 			return null;
1: 		else
1: 			return (Serializable)defaults.get(key);
1: 	}
1: 
1:     /**
1:      * Gets the de-serialized object associated with a property key.
1:      * <p>
1:      * The Store provides a transaction protected list of database properties.
1:      * Higher levels of the system can store and retrieve these properties
1:      * once Recovery has finished. Each property is a serializable object
1:      * and is stored/retrieved using a String key.
1:      * <p>
1:      * In this implementation a lookup is done on the PropertyConglomerate
1:      * conglomerate, using a scan with "key" as the qualifier.
1:      * <p>
1: 	 * @param tc      The transaction to do the Conglomerate work under.
1:      * @param key     The "key" of the property that is being requested.
1:      *
1: 	 * @return object The object associated with property key. n
1:      *                ull means no such key-value pair.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	Serializable getProperty(
1:     TransactionController tc, 
1:     String                key) 
1: 		throws StandardException
1:     {
1: 		//
1: 		//Try service properties first.
1: 		if(PropertyUtil.isServiceProperty(key)) return serviceProperties.getProperty(key);
1: 
1: 		// See if I'm the exclusive owner. If so I cannot populate
1: 		// the cache as it would contain my uncommitted changes.
1: 		if (iHoldTheUpdateLock(tc))
1: 		{
1: 			//
1: 			//Return the property value if it is defined.
1: 			Serializable v = readProperty(tc,key);
1: 			if (v != null) return v;
1: 
1: 			return getPropertyDefault(tc,key);
1: 		}
1: 		else
1: 		{
1: 			return getCachedProperty(tc,key);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the default for a property.
1: 	 * @exception  StandardException  Standard exception policy.
1: 	 */
1: 	Serializable getPropertyDefault(TransactionController tc, String key)
1: 		 throws StandardException
1: 	{
1: 		// See if I'm the exclusive owner. If so I cannot populate
1: 		// the cache as it would contain my uncommitted changes.
1: 		if (iHoldTheUpdateLock(tc))
1: 		{
1: 			//
1: 			//Return the property default value (may be null) if
1: 			//defined.
1: 			Dictionary defaults = (Dictionary)readProperty(tc,AccessFactoryGlobals.DEFAULT_PROPERTY_NAME);
1: 			if (defaults == null)
1: 				return null;
1: 			else
1: 				return (Serializable)defaults.get(key);
1: 		}
1: 		else
1: 		{
1: 			return getCachedPropertyDefault(tc,key,null);
1: 		}
1: 	}
1: 									
0: 	private Dictionary copyValues(Dictionary to, Dictionary from, boolean stringsOnly)
1: 	{
1: 		if (from == null) return to; 
0: 		for (Enumeration keys = from.keys(); keys.hasMoreElements(); ) {
0: 			String key = (String) keys.nextElement();
0: 			Object value = from.get(key);
1: 			if ((value instanceof String) || !stringsOnly)
1: 				to.put(key, value);
1: 		}
1: 		return to;
1: 	}
1: 
1: 	/**
1: 		Fetch the set of properties as a Properties object. This means
1: 		that only keys that have String values will be included.
1: 	*/
1: 	Properties getProperties(TransactionController tc) throws StandardException {
1: 		Properties p = new Properties();
1: 		getProperties(tc,p,true/*stringsOnly*/,false/*!defaultsOnly*/);
1: 		return p;
1: 	}
1: 
1: 	public void getProperties(TransactionController tc,
0: 							   Dictionary d,
1: 							   boolean stringsOnly,
1: 							   boolean defaultsOnly) throws StandardException
1: 	{
1: 		// See if I'm the exclusive owner. If so I cannot populate
1: 		// the cache as it would contain my uncommitted changes.
1: 		if (iHoldTheUpdateLock(tc))
1: 		{
0: 			Dictionary dbProps = readDbProperties(tc);
1: 			Dictionary defaults = (Dictionary)dbProps.get(AccessFactoryGlobals.DEFAULT_PROPERTY_NAME);
0: 			copyValues(d,defaults,stringsOnly);
0: 			if (!defaultsOnly)copyValues(d,dbProps,stringsOnly);
1: 		}
1: 		else
1: 		{	
1: 			Dictionary dbProps = getCachedDbProperties(tc);
1: 			Dictionary defaults = (Dictionary)dbProps.get(AccessFactoryGlobals.DEFAULT_PROPERTY_NAME);
0: 			copyValues(d,defaults,stringsOnly);
0: 			if (!defaultsOnly)copyValues(d,dbProps,stringsOnly);
1: 		}
1: 	}
1: 
1: 	void resetCache() {cachedSet = null;}
1: 
1: 	/** Read the database properties and add in the service set. */
0: 	private Dictionary readDbProperties(TransactionController tc)
1: 		 throws StandardException
1: 	{
0: 		Dictionary set = new Hashtable();
1: 
1:         // scan the table for a row with no matching "key"
1: 		ScanController scan = openScan(tc, (String) null, 0);
1: 
1: 		DataValueDescriptor[] row = makeNewTemplate();
1: 
1: 		while (scan.fetchNext(row)) {
1: 
1: 			Object key = ((UserType) row[0]).getObject();
1: 			Object value = ((UserType) row[1]).getObject();
1: 			if (SanityManager.DEBUG) {
1:                 if (!(key instanceof String))
1:                     SanityManager.THROWASSERT(
1:                         "Key is not a string " + key.getClass().getName());
1: 			}
0: 			set.put(key, value);
1: 		}
1: 		scan.close();
1: 
1: 		// add the known properties from the service properties set
0: 		for (int i = 0; i < PropertyUtil.servicePropertyList.length; i++) {
1: 			String value =
0: 				serviceProperties.getProperty(PropertyUtil.servicePropertyList[i]);
0: 			if (value != null) set.put(PropertyUtil.servicePropertyList[i], value);
1: 		}
1: 		return set;
1: 	}
1: 
0: 	private Dictionary getCachedDbProperties(TransactionController tc)
1: 		 throws StandardException
1: 	{
0: 		Dictionary dbProps = cachedSet;
1: 		//Get the cached set of properties.
1: 		if (dbProps == null)
1: 		{
1: 			dbProps = readDbProperties(tc);
1: 			cachedSet = dbProps;
1: 		}
1: 		
1: 		return dbProps;
1: 	}
1: 
1: 	/** Lock the database properties for an update. */
1: 	void lockProperties(TransactionController tc) throws StandardException
1: 	{
1: 		// lock the property set until the transaction commits.
1: 		// This allows correct operation of the cache. The cache remains
1: 		// valid for all transactions except the one that is modifying
1: 		// it. Thus readers see the old uncommited values. When this
1: 		// thread releases its exclusive lock the cached is cleared
1: 		// and the next reader will re-populate the cache.
0: 		Object csGroup = tc.getLockObject();
0: 		lf.lockObject(csGroup, csGroup, cachedLock, ShExQual.EX, C_LockFactory.TIMED_WAIT);
1: 	}
1: 
1: 	/**
1: 	  Return true if the caller holds the exclusive update lock on the
1: 	  property conglomerate.
1: 	  */
1: 	private boolean iHoldTheUpdateLock(TransactionController tc) throws StandardException
1: 	{
0: 		Object csGroup = tc.getLockObject();
0: 		return lf.isLockHeld(csGroup, csGroup, cachedLock, ShExQual.EX);
1: 	}
1: }
1: 
1: /**
1: 	Only used for exclusive lock purposes.
1: */
1: class CacheLock extends ShExLockable {
1: 
1: 	private PropertyConglomerate pc;
1: 
1: 	CacheLock(PropertyConglomerate pc) {
1: 		this.pc = pc;
1: 	}
1: 
1: 	public void unlockEvent(Latch lockInfo)
1: 	{
1: 		super.unlockEvent(lockInfo);		
1: 		pc.resetCache();
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access;
0: 
0: import org.apache.derby.iapi.reference.Attribute;
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.types.UserType;
0: import org.apache.derby.impl.store.access.UTF;
0: import org.apache.derby.impl.store.access.UTFQualifier;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.io.FormatableHashtable; 
0: import org.apache.derby.iapi.services.locks.ShExLockable;
0: import org.apache.derby.iapi.services.locks.ShExQual;
0: import org.apache.derby.iapi.services.daemon.Serviceable;
0: import org.apache.derby.iapi.services.locks.C_LockFactory;
0: import org.apache.derby.iapi.services.locks.Latch;
0: import org.apache.derby.iapi.services.locks.LockFactory;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: import org.apache.derby.iapi.store.access.AccessFactory;
0: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.services.property.PropertyFactory;
0: import org.apache.derby.iapi.services.property.PropertySetCallback;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import java.io.Serializable;
0: import java.util.Dictionary;
0: import java.util.Enumeration;
0: import java.util.Hashtable;
0: import java.util.Properties;
0: 
0: /**
0: Stores properties in a congolmerate with complete transactional support.
0: <p>
0: The PropertyConglomerate contains one row with 2 columns per property.
0: Column 0 is the UTF key, and column 1 is the data.
0: <p>
0: 
0: <p>
0: The property conglomerate manages the storage of database properties
0: and thier defaults. Each property is stored as a row in the
0: PropertyConglomerate 
0: <OL>
0: <LI>Column 0 is the UTF key,
0: <LI>Column 1 is the data.
0: </OL>
0: All the property defaults are stored in a single row of the Property
0: Conglomerate:
0: <OL>
0: <LI>Column 0 is the UTF key "derby.defaultPropertyName".
0: <LI>Column 1 is a FormatableProperties object with one
0:     row per default property.
0: </OL>
0: <p>
0: In general a propery default defines it value if the property
0: itself is not defined.
0: 
0: <p>
0: Because the properties conglomerate is stored in a conglomerate
0: the information it contains is not available before the raw store
0: runs recovery. To make a small number of properties (listed in
0: servicePropertyList) available during early boot, this copies
0: them to services.properties.
0: **/
0: class PropertyConglomerate
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	protected long propertiesConglomId;
0: 	protected Properties serviceProperties;
0: 	private LockFactory lf;
0: 	private Dictionary	cachedSet;
0: 	private CacheLock cachedLock;
0: 
0: 	private PropertyFactory  pf;
0: 
0:     /* Constructors for This class: */
0: 
0: 	PropertyConglomerate(
0:     TransactionController   tc,
0:     boolean                 create,
0:     Properties              serviceProperties,
0: 	PropertyFactory 		pf)
0: 		throws StandardException
0: 	{
0: 		this.pf = pf;
0: 
0: 		if (!create) {
0: 			String id = serviceProperties.getProperty(Property.PROPERTIES_CONGLOM_ID);
0: 			if (id == null) {
0: 				create = true;
0: 			} else {
0: 				try {
0: 					propertiesConglomId = Long.valueOf(id).longValue();
0: 				} catch (NumberFormatException nfe) {
0: 					throw Monitor.exceptionStartingModule(nfe) ;
0: 				}
0: 			}
0: 		}
0: 
0: 		if (create) {
0: 			DataValueDescriptor[] template = makeNewTemplate();
0: 
0: 			Properties conglomProperties = new Properties();
0: 
0: 			conglomProperties.put(
0:                 Property.PAGE_SIZE_PARAMETER, 
0:                 RawStoreFactory.PAGE_SIZE_STRING);
0: 
0: 			conglomProperties.put(
0:                 RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER, 
0:                 RawStoreFactory.PAGE_RESERVED_ZERO_SPACE_STRING);
0: 
0: 			propertiesConglomId = 
0:                 tc.createConglomerate(
0:                     AccessFactoryGlobals.HEAP,
0:                     template, 
0:                     null, 
0:                     conglomProperties, 
0:                     TransactionController.IS_DEFAULT);
0: 
0: 			serviceProperties.put(
0:                 Property.PROPERTIES_CONGLOM_ID, 
0:                 Long.toString(propertiesConglomId));
0: 		}
0: 
0: 		this.serviceProperties = serviceProperties;
0: 
0: 		lf = ((RAMTransaction) tc).getAccessManager().getLockFactory();
0: 		cachedLock = new CacheLock(this);
0: 
0: 		PC_XenaVersion softwareVersion = new PC_XenaVersion();
0: 		if (create)
0: 			setProperty(tc,DataDictionary.PROPERTY_CONGLOMERATE_VERSION,
0: 						 softwareVersion, true);
0: 		else
0: 			softwareVersion.upgradeIfNeeded(tc,this,serviceProperties);
0: 
0: 		getCachedDbProperties(tc);
0: 	}
0: 
0:     /* Private/Protected methods of This class: */
0: 
0:     /**
0:      * Create a new PropertyConglomerate row, with values in it.
0:      **/
0:     private DataValueDescriptor[] makeNewTemplate(String key, Serializable value)
0:     {
0: 		DataValueDescriptor[] template = new DataValueDescriptor[2];
0: 
0: 		template[0] = new UTF(key);
0: 		template[1] = new UserType(value);
0: 
0:         return(template);
0:     }
0: 
0:     /**
0:      * Create a new empty PropertyConglomerate row, to fetch values into.
0:      **/
0:     private DataValueDescriptor[] makeNewTemplate()
0:     {
0: 		DataValueDescriptor[] template = new DataValueDescriptor[2];
0: 
0: 		template[0] = new UTF();
0: 		template[1] = new UserType();
0: 
0:         return(template);
0:     }
0: 
0:     /**
0:      * Open a scan on the properties conglomerate looking for "key".
0:      * <p>
0: 	 * Open a scan on the properties conglomerate qualified to
0: 	 * find the row with value key in column 0.  Both column 0
0:      * and column 1 are included in the scan list.
0:      *
0: 	 * @return an open ScanController on the PropertyConglomerate. 
0:      *
0: 	 * @param tc        The transaction to do the Conglomerate work under.
0:      * @param key       The "key" of the property that is being requested.
0:      * @param forUpdate Whether we are setting or getting the property.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	private ScanController openScan(
0:     TransactionController tc, 
0:     String                key, 
0:     int                   open_mode) 
0: 		throws StandardException
0:     {
0: 		Qualifier[][] qualifiers = null;
0: 
0: 		if (key != null) {
0: 			// Set up qualifier to look for the row with key value in column[0]
0: 			qualifiers = new Qualifier[1][];
0:             qualifiers[0] = new Qualifier[1];
0: 			qualifiers[0][0] = new UTFQualifier(0, key);
0: 		}
0: 
0:         // open the scan, clients will do the fetches and close.
0: 		ScanController scan = 
0:             tc.openScan(
0:                 propertiesConglomId,
0:                 false, // don't hold over the commit
0:                 open_mode,
0:                 TransactionController.MODE_TABLE,
0:                 TransactionController.ISOLATION_SERIALIZABLE,
0:                 (FormatableBitSet) null,
0:                 (DataValueDescriptor[]) null,	// start key
0:                 ScanController.NA,
0:                 qualifiers,
0:                 (DataValueDescriptor[]) null,	// stop key
0:                 ScanController.NA);
0: 
0: 		return(scan);
0: 	}
0:     /* Package Methods of This class: */
0: 
0: 	/**
0: 		Set a property in the conglomerate.
0: 
0: 	 @param	key		The key used to lookup this property.
0: 	 @param	value	The value to be associated with this key. If null, delete the
0: 	 					property from the properties list.
0: 	*/
0: 
0: 	/**
0: 	 * Set the default for a property.
0: 	 * @exception  StandardException  Standard exception policy.
0: 	 */
0:  	void setPropertyDefault(TransactionController tc, String key, Serializable value)
0: 		 throws StandardException
0: 	{
0: 		lockProperties(tc);
0: 		Serializable valueToSave = null;
0: 		//
0: 		//If the default is visible we validate apply and map.
0: 		//otherwise we just map.
0: 		if (propertyDefaultIsVisible(tc,key))
0: 		{
0: 			valueToSave = validateApplyAndMap(tc,key,value,false);
0: 		}
0: 		else
0: 		{
0: 			synchronized (this) {
0: 				Hashtable defaults = new Hashtable();
0: 				getProperties(tc,defaults,false/*!stringsOnly*/,true/*defaultsOnly*/);
0: 				validate(key,value,defaults);
0: 				valueToSave = map(key,value,defaults);
0: 			}
0: 		}
0: 		savePropertyDefault(tc,key,valueToSave);
0: 	}
0: 
0: 	boolean propertyDefaultIsVisible(TransactionController tc,String key) throws StandardException
0: 	{
0: 		lockProperties(tc);
0: 		return(readProperty(tc,key) == null);
0: 	}
0: 	
0: 	void saveProperty(TransactionController tc, String key, Serializable value)
0: 		 throws StandardException
0: 	{
0: 		if (saveServiceProperty(key,value)) return;
0: 
0:         // Do a scan to see if the property already exists in the Conglomerate.
0: 		ScanController scan = 
0:             this.openScan(tc, key, TransactionController.OPENMODE_FORUPDATE);
0: 
0:         DataValueDescriptor[] row = makeNewTemplate();
0: 
0: 		if (scan.fetchNext(row)) 
0:         {
0: 			if (value == null)
0:             {
0: 				// A null input value means that we should delete the row
0:                 
0: 				scan.delete();
0: 			} 
0:             else
0:             {
0: 				// a value already exists, just replace the second columm
0: 
0: 				row[1] = new UserType(value);
0: 
0: 				scan.replace(row, (FormatableBitSet) null);
0: 			}
0: 
0: 			scan.close();
0: 		}
0:         else
0:         {
0:             // The value does not exist in the Conglomerate.
0: 
0:             scan.close();
0:             scan = null;
0: 
0:             if (value != null)
0:             {
0:                 // not a delete request, so insert the new property.
0:                 
0:                 row = makeNewTemplate(key, value);
0: 
0:                 ConglomerateController cc = 
0:                     tc.openConglomerate(
0:                         propertiesConglomId, 
0:                         false,
0:                         TransactionController.OPENMODE_FORUPDATE, 
0:                         TransactionController.MODE_TABLE,
0:                         TransactionController.ISOLATION_SERIALIZABLE);
0: 
0:                 cc.insert(row);
0: 
0:                 cc.close();
0:             }
0:         }
0: 	}
0: 
0: 	private boolean saveServiceProperty(String key, Serializable value)
0: 	{
0: 		if (PropertyUtil.isServiceProperty(key))
0: 		{
0: 			if (value != null)
0: 				serviceProperties.put(key, value);
0: 			else
0: 				serviceProperties.remove(key);
0: 			return true;
0: 		}
0: 		else
0: 		{
0: 			return false;
0: 		}
0: 	}
0: 
0: 	void savePropertyDefault(TransactionController tc, String key, Serializable value)
0: 		 throws StandardException
0: 	{
0: 		if (saveServiceProperty(key,value)) return;
0: 
0: 		Dictionary defaults = (Dictionary)readProperty(tc,AccessFactoryGlobals.DEFAULT_PROPERTY_NAME);
0: 		if (defaults == null) defaults = new FormatableHashtable();
0: 		if (value==null)
0: 			defaults.remove(key);
0: 		else
0: 			defaults.put(key,value);
0: 		if (defaults.size() == 0) defaults = null;
0: 		saveProperty(tc,AccessFactoryGlobals.DEFAULT_PROPERTY_NAME,(Serializable)defaults);
0: 	}
0: 
0: 	private Serializable validateApplyAndMap(TransactionController tc,
0: 											 String key, Serializable value, boolean dbOnlyProperty)
0: 		 throws StandardException
0: 	{
0: 		Dictionary d = new Hashtable();
0: 		getProperties(tc,d,false/*!stringsOnly*/,false/*!defaultsOnly*/);
0: 		Serializable mappedValue = pf.doValidateApplyAndMap(tc, key,
0: 																   value, d, dbOnlyProperty);
0: 		//
0: 		// RESOLVE: log device cannot be changed on the fly right now
0: 		if (key.equals(Attribute.LOG_DEVICE))
0:         {
0: 			throw StandardException.newException(
0:                     SQLState.RAWSTORE_CANNOT_CHANGE_LOGDEVICE);
0:         }
0: 
0: 		if (mappedValue == null)
0: 			return value;
0: 		else
0: 			return mappedValue;
0: 	}
0: 
0: 	/**
0: 	  Call the property set callbacks to map a proposed property value
0: 	  to a value to save.
0: 	  <P>
0: 	  The caller must run this in a block synchronized on this
0: 	  to serialize validations with changes to the set of
0: 	  property callbacks
0: 	  */
0: 	private Serializable map(String key,
0: 							 Serializable value,
0: 							 Dictionary set)
0: 		 throws StandardException
0: 	{
0: 		return pf.doMap(key, value, set);
0: 	}
0: 
0: 	/**
0: 	  Call the property set callbacks to validate a property change
0: 	  against the property set provided.
0: 	  <P>
0: 	  The caller must run this in a block synchronized on this
0: 	  to serialize validations with changes to the set of
0: 	  property callbacks
0: 	  */
0: 
0: 	private void validate(String key,
0: 						  Serializable value,
0: 						  Dictionary set)
0: 		 throws StandardException
0: 	{
0: 		pf.validateSingleProperty(key, value, set);
0: 	}
0: 
0: 
0: 	private boolean bootPasswordChange(TransactionController tc,
0: 									   String key,
0: 									   Serializable value)
0: 		 throws StandardException
0: 	{
0: 		// first check for boot password  change - we don't put boot password
0: 		// in the servicePropertyList because if we do, then we expose the
0: 		// boot password in clear text
0: 		if (key.equals(Attribute.BOOT_PASSWORD))
0: 		{
0: 			// The user is trying to change the secret key.
0: 			// The secret key is never stored in clear text, but we
0: 			// store the encrypted form in the services.properties
0: 			// file.  Swap the secret key with the encrypted form and
0: 			// put that in the services.properties file.
0: 			AccessFactory af = ((TransactionManager)tc).getAccessManager();
0: 
0: 			RawStoreFactory rsf = (RawStoreFactory)
0: 				Monitor.findServiceModule(af, RawStoreFactory.MODULE);
0: 
0: 			// remove secret key from properties list if possible
0: 			serviceProperties.remove(Attribute.BOOT_PASSWORD);
0: 
0: 			value = rsf.changeBootPassword(serviceProperties, value);
0: 			serviceProperties.put(RawStoreFactory.ENCRYPTED_KEY,value);
0: 			return true;
0: 		}
0: 		else
0: 		{
0: 			return false;
0: 		}
0: 	}
0: 
0:     /**
0:      * Sets the Serializable object associated with a property key.
0:      * <p>
0:      * This implementation turns the setProperty into an insert into the
0:      * PropertyConglomerate conglomerate.
0:      * <p>
0:      * See the discussion of getProperty().
0:      * <p>
0:      * The value stored may be a Formatable object or a Serializable object
0: 	 * whose class name starts with java.*. This stops arbitary objects being
0: 	 * stored in the database by class name, which will cause problems in
0: 	 * obfuscated/non-obfuscated systems.
0:      *
0: 	 * @param	tc		The transaction to do the Conglomerate work under.
0: 	 * @param	key		The key used to lookup this property.
0: 	 * @param	value	The value to be associated with this key. If null,
0:      *                  delete the property from the properties list.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	void setProperty(
0:     TransactionController tc,
0:     String                key,
0:     Serializable          value, boolean dbOnlyProperty)
0: 		throws StandardException
0:     {
0: 		if (SanityManager.DEBUG)
0:         {
0: 
0: 			if (!((value == null) || (value instanceof Formatable)))
0:             {
0:                 if (!(value.getClass().getName().startsWith("java.")))
0:                 {
0:                     SanityManager.THROWASSERT(
0:                         "Non-formattable, non-java class - " +
0:                         value.getClass().getName());
0:                 }
0:             }
0: 		}
0: 
0: 		lockProperties(tc);
0: 		Serializable valueToValidateAndApply = value;
0: 		//
0: 		//If we remove a property we validate and apply its default.
0: 		if (value == null)
0: 			valueToValidateAndApply = getPropertyDefault(tc,key);
0: 		Serializable valueToSave =
0: 			validateApplyAndMap(tc,key,valueToValidateAndApply, dbOnlyProperty);
0: 
0: 		//
0: 		//if this is a bootPasswordChange we save it in
0: 		//a special way.
0: 		if (bootPasswordChange(tc,key,value))
0: 			return;
0: 
0: 		//
0: 		//value==null means we are removing a property.
0: 		//To remove the property we call saveProperty with
0: 		//a null value. Note we avoid saving the mapped
0: 		//DEFAULT value returned by validateAndApply.
0: 		else if (value==null)
0: 			saveProperty(tc,key,null);
0: 		//
0: 		//value != null means we simply save the possibly
0: 		//mapped value of the property returned by
0: 		//validateAndApply.
0: 		else
0: 			saveProperty(tc,key,valueToSave);
0: 	}
0: 
0: 	private Serializable readProperty(TransactionController tc,
0: 									  String key) throws StandardException
0: 	{
0: 		// scan the table for a row with matching "key"
0: 		ScanController scan = openScan(tc, key, 0);
0: 
0: 		DataValueDescriptor[] row = makeNewTemplate();
0: 
0: 		// did we find at least one row?
0: 		boolean isThere = scan.fetchNext(row);
0: 		
0: 		scan.close();
0: 
0: 		if (!isThere) return null;
0: 
0: 		return (Serializable) (((UserType) row[1]).getObject());
0: 	}
0: 
0: 	private Serializable getCachedProperty(TransactionController tc,
0: 										   String key) throws StandardException
0: 	{
0: 		//
0: 		//Get the cached set of properties.
0: 		Dictionary dbProps = getCachedDbProperties(tc);
0: 
0: 		//
0: 		//Return the value if it is defined.
0: 		if (dbProps.get(key) != null)
0: 			return (Serializable) dbProps.get(key);
0: 		else
0: 			return getCachedPropertyDefault(tc,key,dbProps);
0: 	}
0: 
0: 	private Serializable getCachedPropertyDefault(TransactionController tc,
0: 												  String key,
0: 												  Dictionary dbProps)
0: 		 throws StandardException
0: 	{
0: 		//
0: 		//Get the cached set of properties.
0: 		if (dbProps == null) dbProps = getCachedDbProperties(tc);
0: 		//
0: 		//return the default for the value if it is defined.
0: 		Dictionary defaults = (Dictionary)dbProps.get(AccessFactoryGlobals.DEFAULT_PROPERTY_NAME);
0: 		if (defaults == null)
0: 			return null;
0: 		else
0: 			return (Serializable)defaults.get(key);
0: 	}
0: 
0:     /**
0:      * Gets the de-serialized object associated with a property key.
0:      * <p>
0:      * The Store provides a transaction protected list of database properties.
0:      * Higher levels of the system can store and retrieve these properties
0:      * once Recovery has finished. Each property is a serializable object
0:      * and is stored/retrieved using a String key.
0:      * <p>
0:      * In this implementation a lookup is done on the PropertyConglomerate
0:      * conglomerate, using a scan with "key" as the qualifier.
0:      * <p>
0: 	 * @param tc      The transaction to do the Conglomerate work under.
0:      * @param key     The "key" of the property that is being requested.
0:      *
0: 	 * @return object The object associated with property key. n
0:      *                ull means no such key-value pair.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	Serializable getProperty(
0:     TransactionController tc, 
0:     String                key) 
0: 		throws StandardException
0:     {
0: 		//
0: 		//Try service properties first.
0: 		if(PropertyUtil.isServiceProperty(key)) return serviceProperties.getProperty(key);
0: 
0: 		// See if I'm the exclusive owner. If so I cannot populate
0: 		// the cache as it would contain my uncommitted changes.
0: 		if (iHoldTheUpdateLock(tc))
0: 		{
0: 			//
0: 			//Return the property value if it is defined.
0: 			Serializable v = readProperty(tc,key);
0: 			if (v != null) return v;
0: 
0: 			return getPropertyDefault(tc,key);
0: 		}
0: 		else
0: 		{
0: 			return getCachedProperty(tc,key);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the default for a property.
0: 	 * @exception  StandardException  Standard exception policy.
0: 	 */
0: 	Serializable getPropertyDefault(TransactionController tc, String key)
0: 		 throws StandardException
0: 	{
0: 		// See if I'm the exclusive owner. If so I cannot populate
0: 		// the cache as it would contain my uncommitted changes.
0: 		if (iHoldTheUpdateLock(tc))
0: 		{
0: 			//
0: 			//Return the property default value (may be null) if
0: 			//defined.
0: 			Dictionary defaults = (Dictionary)readProperty(tc,AccessFactoryGlobals.DEFAULT_PROPERTY_NAME);
0: 			if (defaults == null)
0: 				return null;
0: 			else
0: 				return (Serializable)defaults.get(key);
0: 		}
0: 		else
0: 		{
0: 			return getCachedPropertyDefault(tc,key,null);
0: 		}
0: 	}
0: 									
0: 	private Dictionary copyValues(Dictionary to, Dictionary from, boolean stringsOnly)
0: 	{
0: 		if (from == null) return to; 
0: 		for (Enumeration keys = from.keys(); keys.hasMoreElements(); ) {
0: 			String key = (String) keys.nextElement();
0: 			Object value = from.get(key);
0: 			if ((value instanceof String) || !stringsOnly)
0: 				to.put(key, value);
0: 		}
0: 		return to;
0: 	}
0: 
0: 	/**
0: 		Fetch the set of properties as a Properties object. This means
0: 		that only keys that have String values will be included.
0: 	*/
0: 	Properties getProperties(TransactionController tc) throws StandardException {
0: 		Properties p = new Properties();
0: 		getProperties(tc,p,true/*stringsOnly*/,false/*!defaultsOnly*/);
0: 		return p;
0: 	}
0: 
0: 	public void getProperties(TransactionController tc,
0: 							   Dictionary d,
0: 							   boolean stringsOnly,
0: 							   boolean defaultsOnly) throws StandardException
0: 	{
0: 		// See if I'm the exclusive owner. If so I cannot populate
0: 		// the cache as it would contain my uncommitted changes.
0: 		if (iHoldTheUpdateLock(tc))
0: 		{
0: 			Dictionary dbProps = readDbProperties(tc);
0: 			Dictionary defaults = (Dictionary)dbProps.get(AccessFactoryGlobals.DEFAULT_PROPERTY_NAME);
0: 			copyValues(d,defaults,stringsOnly);
0: 			if (!defaultsOnly)copyValues(d,dbProps,stringsOnly);
0: 		}
0: 		else
0: 		{	
0: 			Dictionary dbProps = getCachedDbProperties(tc);
0: 			Dictionary defaults = (Dictionary)dbProps.get(AccessFactoryGlobals.DEFAULT_PROPERTY_NAME);
0: 			copyValues(d,defaults,stringsOnly);
0: 			if (!defaultsOnly)copyValues(d,dbProps,stringsOnly);
0: 		}
0: 	}
0: 
0: 	void resetCache() {cachedSet = null;}
0: 
0: 	/** Read the database properties and add in the service set. */
0: 	private Dictionary readDbProperties(TransactionController tc)
0: 		 throws StandardException
0: 	{
0: 		Dictionary set = new Hashtable();
0: 
0:         // scan the table for a row with no matching "key"
0: 		ScanController scan = openScan(tc, (String) null, 0);
0: 
0: 		DataValueDescriptor[] row = makeNewTemplate();
0: 
0: 		while (scan.fetchNext(row)) {
0: 
0: 			Object key = ((UserType) row[0]).getObject();
0: 			Object value = ((UserType) row[1]).getObject();
0: 			if (SanityManager.DEBUG) {
0:                 if (!(key instanceof String))
0:                     SanityManager.THROWASSERT(
0:                         "Key is not a string " + key.getClass().getName());
0: 			}
0: 			set.put(key, value);
0: 		}
0: 		scan.close();
0: 
0: 		// add the known properties from the service properties set
0: 		for (int i = 0; i < PropertyUtil.servicePropertyList.length; i++) {
0: 			String value =
0: 				serviceProperties.getProperty(PropertyUtil.servicePropertyList[i]);
0: 			if (value != null) set.put(PropertyUtil.servicePropertyList[i], value);
0: 		}
0: 		return set;
0: 	}
0: 
0: 	private Dictionary getCachedDbProperties(TransactionController tc)
0: 		 throws StandardException
0: 	{
0: 		Dictionary dbProps = cachedSet;
0: 		//Get the cached set of properties.
0: 		if (dbProps == null)
0: 		{
0: 			dbProps = readDbProperties(tc);
0: 			cachedSet = dbProps;
0: 		}
0: 		
0: 		return dbProps;
0: 	}
0: 
0: 	/** Lock the database properties for an update. */
0: 	void lockProperties(TransactionController tc) throws StandardException
0: 	{
0: 		// lock the property set until the transaction commits.
0: 		// This allows correct operation of the cache. The cache remains
0: 		// valid for all transactions except the one that is modifying
0: 		// it. Thus readers see the old uncommited values. When this
0: 		// thread releases its exclusive lock the cached is cleared
0: 		// and the next reader will re-populate the cache.
0: 		Object csGroup = tc.getLockObject();
0: 		lf.lockObject(csGroup, csGroup, cachedLock, ShExQual.EX, C_LockFactory.TIMED_WAIT);
0: 	}
0: 
0: 	/**
0: 	  Return true if the caller holds the exclusive update lock on the
0: 	  property conglomerate.
0: 	  */
0: 	private boolean iHoldTheUpdateLock(TransactionController tc) throws StandardException
0: 	{
0: 		Object csGroup = tc.getLockObject();
0: 		return lf.isLockHeld(csGroup, csGroup, cachedLock, ShExQual.EX);
0: 	}
0: }
0: 
0: /**
0: 	Only used for exclusive lock purposes.
0: */
0: class CacheLock extends ShExLockable {
0: 
0: 	private PropertyConglomerate pc;
0: 
0: 	CacheLock(PropertyConglomerate pc) {
0: 		this.pc = pc;
0: 	}
0: 
0: 	public void unlockEvent(Latch lockInfo)
0: 	{
0: 		super.unlockEvent(lockInfo);		
0: 		pc.resetCache();
0: 	}
0: }
============================================================================