1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.ModifyColumnNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
10:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.UUID;
1:43da026: import org.apache.derby.catalog.types.DefaultInfoImpl;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.DefaultDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.KeyConstraintDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:3bb140c: import org.apache.derby.impl.sql.execute.ColumnInfo;
1:eac0369: 
1:eac0369: /**
1:eac0369:  * A ModifyColumnNode represents a modify column in an ALTER TABLE statement.
1:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:3bb140c: class ModifyColumnNode extends ColumnDefinitionNode
4:eac0369: {
1:eac0369: 	int		columnPosition = -1;
1:eac0369: 	UUID	oldDefaultUUID;
1:eac0369: 
1:2706d1f:     // Allowed kinds
1:2706d1f:     final static int K_MODIFY_COLUMN_TYPE = 0;
1:2706d1f:     final static int K_MODIFY_COLUMN_DEFAULT = 1;
1:2706d1f:     final static int K_MODIFY_COLUMN_CONSTRAINT = 2;
1:2706d1f:     final static int K_MODIFY_COLUMN_CONSTRAINT_NOT_NULL = 3;
1:2706d1f:     final static int K_DROP_COLUMN = 4;
1:5b838fd:     final static int K_MODIFY_COLUMN_GENERATED_ALWAYS = 5;
1:5b838fd:     final static int K_MODIFY_COLUMN_GENERATED_BY_DEFAULT = 6;
1:2706d1f: 
1:2706d1f:     /**
1:2706d1f:      * This class is used to hold logically different objects for
1:2706d1f:      * space efficiency. {@code kind} represents the logical object
1:2706d1f:      * type. See also {@link ValueNode#isSameNodeKind}.
1:2706d1f:      */
1:2706d1f:     final int kind;
1:2706d1f: 
1:2706d1f:     ModifyColumnNode(int kind,
1:3bb140c:             String name,
1:3bb140c:             ValueNode defaultNode,
1:3bb140c:             DataTypeDescriptor dataTypeServices,
1:3bb140c:             long[] autoIncrementInfo,
1:3bb140c:             ContextManager cm) throws StandardException {
1:3bb140c:         super(name, defaultNode, dataTypeServices, autoIncrementInfo, cm);
1:2706d1f:         this.kind = kind;
1:3bb140c:     }
1:2706d1f: 
1:eac0369: 	/**
1:eac0369: 	 * Get the UUID of the old column default.
1:eac0369: 	 *
1:eac0369: 	 * @return The UUID of the old column default.
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	UUID getOldDefaultUUID()
1:eac0369: 	{
1:eac0369: 		return oldDefaultUUID;
1:eac0369: 	}
1:2706d1f: 
1:eac0369: 	/**
1:eac0369: 	 * Get the column position for the column.
1:eac0369: 	 *
1:eac0369: 	 * @return The column position for the column.
1:eac0369: 	 */
1:3bb140c:     int getColumnPosition()
1:eac0369: 	{
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(columnPosition > 0,
1:eac0369: 				"columnPosition expected to be > 0");
1:eac0369: 		}
1:eac0369: 		return columnPosition;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check the validity of a user type.  Checks that
1:eac0369: 	 * 1. the column type is either varchar, ....
1:eac0369: 	 * 2. is the same type after the alter.
1:eac0369: 	 * 3. length is greater than the old length.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void checkUserType(TableDescriptor td)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:2706d1f:         if (kind != K_MODIFY_COLUMN_TYPE) {
1:2706d1f:             return; // nothing to do if user not changing length
1:2706d1f:         }
1:eac0369: 
1:cb8f109:         ColumnDescriptor cd = td.getColumnDescriptor(name);
1:eac0369: 		if (cd == null)
1:eac0369: 		{
1:2e3ed68: 			throw StandardException.newException(
1:eac0369: 				SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, name, td.getName());
1:eac0369: 		}
1:eac0369: 		
1:cb8f109: 		DataTypeDescriptor oldType = cd.getType();
1:7dda5d5:         setNullability(oldType.isNullable());
1:eac0369: 
1:eac0369: 		// can't change types yet.
1:7dda5d5: 		if (!(oldType.getTypeId().equals(getType().getTypeId())))
1:eac0369: 		{
3:eac0369: 			throw StandardException.newException(
1:eac0369: 					 SQLState.LANG_MODIFY_COLUMN_CHANGE_TYPE, name);
1:eac0369: 		}			
1:eac0369: 		
1:111785f: 		// can only alter the length of varchar, bitvarying columns
1:7dda5d5: 		String typeName = getType().getTypeName();
1:111785f: 		if (!(typeName.equals(TypeId.VARCHAR_NAME)) &&
1:fecd96a: 			!(typeName.equals(TypeId.VARBIT_NAME))&&
1:fecd96a: 			!(typeName.equals(TypeId.BLOB_NAME))&&
1:fecd96a: 			!(typeName.equals(TypeId.CLOB_NAME)))
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(
1:eac0369: 						 SQLState.LANG_MODIFY_COLUMN_INVALID_TYPE);
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		// cannot decrease the length of a column
1:7dda5d5: 		if (getType().getMaximumWidth() < oldType.getMaximumWidth())
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(
1:eac0369: 						 SQLState.LANG_MODIFY_COLUMN_INVALID_LENGTH, name);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:2e3ed68:      * Check if the the column can be modified, and throw error if not.
1:2e3ed68:      *
1:2e3ed68: 	 * If the type of a column is being changed (for instance if the length 
1:2e3ed68:      * of the column is being increased) then make sure that this does not 
1:2e3ed68:      * violate any key constraints; 
1:eac0369: 	 * the column being altered is 
1:eac0369: 	 *   1. part of foreign key constraint 
1:dbed020: 	 *         ==&gt; ERROR. This references a Primary Key constraint and the
1:dbed020: 	 *             type and lengths of the pkey/fkey must match exactly.
1:eac0369: 	 *   2. part of a unique/primary key constraint
1:dbed020: 	 *         ==&gt; OK if no fkey references this constraint.
1:dbed020: 	 *         ==&gt; ERROR if any fkey in the system references this constraint.
1:eac0369: 	 *
1:eac0369: 	 * @param td		The Table Descriptor on which the ALTER is being done.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on Error.
1:eac0369: 	 *
1:eac0369: 	 */
1:3bb140c:     void checkExistingConstraints(TableDescriptor td)
1:eac0369: 	             throws StandardException
1:eac0369: 	{
1:2706d1f:         if ((kind != K_MODIFY_COLUMN_TYPE) &&
1:2706d1f:             (kind != K_MODIFY_COLUMN_CONSTRAINT) &&
1:2706d1f:             (kind != K_MODIFY_COLUMN_CONSTRAINT_NOT_NULL))
1:eac0369: 			return;
1:eac0369: 
1:2e3ed68: 		DataDictionary           dd          = getDataDictionary();
1:2e3ed68: 		ConstraintDescriptorList cdl         = dd.getConstraintDescriptors(td);
1:2e3ed68: 		int                      intArray[]  = new int[1];
1:2e3ed68: 		intArray[0]                          = columnPosition;
1:eac0369: 
1:eac0369: 		for (int index = 0; index < cdl.size(); index++)
1:eac0369: 		{
1:eac0369: 			ConstraintDescriptor existingConstraint =
1:eac0369: 				                                cdl.elementAt(index);
1:2e3ed68: 
1:eac0369: 			if (!(existingConstraint instanceof KeyConstraintDescriptor))
1:eac0369: 				continue;
1:eac0369: 
1:eac0369: 			if (!existingConstraint.columnIntersects(intArray))
1:eac0369: 				continue;
1:eac0369: 															 
1:eac0369: 			int constraintType = existingConstraint.getConstraintType();
1:eac0369: 
1:eac0369: 			// cannot change the length of a column that is part of a 
1:eac0369: 			// foreign key constraint. Must be an exact match between pkey
1:eac0369: 			// and fkey columns.
1:eac0369: 			if ((constraintType == DataDictionary.FOREIGNKEY_CONSTRAINT) 
1:eac0369: 				&&
1:2706d1f:                 (kind == K_MODIFY_COLUMN_TYPE))
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(
1:2e3ed68: 					 SQLState.LANG_MODIFY_COLUMN_FKEY_CONSTRAINT, 
1:2e3ed68:                      name, existingConstraint.getConstraintName());
1:eac0369: 			}	
1:df9bd6e: 			else
1:2e3ed68: 			{
1:419210d: 				if (!dd.checkVersion(
1:419210d: 					DataDictionary.DD_VERSION_DERBY_10_4, null)) 
1:419210d: 				{
1:2706d1f:                     // If a column is part of unique constraint it can't be
1:2706d1f:                     // made nullable in soft upgrade mode from a pre-10.4 db.
1:2706d1f:                     if (kind == K_MODIFY_COLUMN_CONSTRAINT &&
1:c310bdd: 						(existingConstraint.getConstraintType() == 
1:419210d: 							DataDictionary.UNIQUE_CONSTRAINT)) 
1:419210d: 					{
1:a52a206: 						throw StandardException.newException(
1:419210d: 							SQLState.LANG_MODIFY_COLUMN_EXISTING_CONSTRAINT,
1:419210d: 							name);
1:419210d: 					}
1:2e3ed68: 				}
1:2e3ed68: 
1:2706d1f:                 // A column that is part of a primary key
1:c310bdd:                 // is being made nullable; can't be done.
1:2706d1f:                 if ((kind == K_MODIFY_COLUMN_CONSTRAINT) &&
1:c310bdd: 					((existingConstraint.getConstraintType() == 
1:a52a206: 					 DataDictionary.PRIMARYKEY_CONSTRAINT)))
1:2e3ed68: 				{
1:cd38662: 					String errorState = 
1:cd38662: 						(getLanguageConnectionContext().getDataDictionary()
1:cd38662: 								.checkVersion(DataDictionary.DD_VERSION_DERBY_10_4, 
1:cd38662: 								null))
1:cd38662: 						? SQLState.LANG_MODIFY_COLUMN_EXISTING_PRIMARY_KEY
1:cd38662: 						: SQLState.LANG_MODIFY_COLUMN_EXISTING_CONSTRAINT;
1:cd38662: 					throw StandardException.newException(errorState, name);
1:a52a206: 				}
1:eac0369: 				// unique key or primary key.
1:eac0369: 				ConstraintDescriptorList 
1:eac0369: 					refcdl = dd.getForeignKeys(existingConstraint.getUUID());
1:eac0369: 				 
1:eac0369: 				if (refcdl.size() > 0)
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(
1:2e3ed68: 						 SQLState.LANG_MODIFY_COLUMN_REFERENCED, 
1:2e3ed68:                          name, refcdl.elementAt(0).getConstraintName());
1:eac0369: 				}
1:eac0369: 				
1:eac0369: 				// Make the statement dependent on the primary key constraint.
1:eac0369: 				getCompilerContext().createDependency(existingConstraint);
1:eac0369: 			}
1:eac0369: 		}
5:93b320d:     }
1:eac0369: 
1:eac0369: 	/**
1:93b320d: 	 * If the column being modified is of character string type, then it should
1:9ed7c4d: 	 * get its collation from the corresponding column in the TableDescriptor.
1:93b320d: 	 * This will ensure that at alter table time, the existing character string
1:93b320d: 	 * type columns do not loose their collation type. If the alter table is 
1:93b320d: 	 * doing a drop column, then we do not need to worry about collation info.
1:eac0369: 	 * 
1:93b320d: 	 * @param td Table Descriptor that holds the column which is being altered
1:93b320d: 	 * @throws StandardException
1:eac0369: 	 */
1:3bb140c:     void useExistingCollation(TableDescriptor td)
1:eac0369:     throws StandardException
1:eac0369:     {
1:eac0369: 		ColumnDescriptor cd;
1:eac0369: 
1:93b320d: 		// First verify that the column exists
1:eac0369: 		cd = td.getColumnDescriptor(name);
1:93b320d: 		if (cd == null)
1:eac0369: 		{
1:93b320d: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, name, td.getName());
1:eac0369: 		}
1:93b320d: 		//getType() == null means we are dealing with drop column and hence 
1:93b320d: 		//no need to worry about collation info
1:93b320d: 		if (getType() != null) {
1:93b320d: 			if (getType().getTypeId().isStringTypeId()) {
1:9ed7c4d: 				setCollationType(cd.getType().getCollationType());			
1:eac0369: 			}
1:eac0369: 		}
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the action associated with this node.
1:eac0369: 	 *
1:eac0369: 	 * @return The action associated with this node.
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	int getAction()
1:eac0369: 	{
1:2706d1f:         switch (kind) {
1:2706d1f:             case K_MODIFY_COLUMN_DEFAULT:
1:2706d1f:                 if (autoinc_create_or_modify_Start_Increment ==
1:2706d1f:                         ColumnDefinitionNode.MODIFY_AUTOINCREMENT_RESTART_VALUE) {
1:2706d1f:                     return ColumnInfo.MODIFY_COLUMN_DEFAULT_RESTART;
1:2706d1f: 
1:2706d1f:                 } else if (autoinc_create_or_modify_Start_Increment ==
1:2706d1f:                         ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE) {
1:2706d1f:                     return ColumnInfo.MODIFY_COLUMN_DEFAULT_INCREMENT;
1:2706d1f: 
1:2706d1f:                 } else {
1:df9bd6e:                     return ColumnInfo.MODIFY_COLUMN_DEFAULT_VALUE;
1:2706d1f:                 }
1:2706d1f:             case K_MODIFY_COLUMN_TYPE:
1:2706d1f:                 return ColumnInfo.MODIFY_COLUMN_TYPE;
1:2706d1f: 
1:2706d1f:             case K_MODIFY_COLUMN_CONSTRAINT:
1:2706d1f:                 return ColumnInfo.MODIFY_COLUMN_CONSTRAINT;
1:2706d1f: 
1:2706d1f:             case K_MODIFY_COLUMN_CONSTRAINT_NOT_NULL:
1:2706d1f:                 return ColumnInfo.MODIFY_COLUMN_CONSTRAINT_NOT_NULL;
1:2706d1f: 
1:2706d1f:             case K_DROP_COLUMN:
1:ee5857f:                 return ColumnInfo.DROP;
1:2706d1f: 
1:5b838fd:             case K_MODIFY_COLUMN_GENERATED_ALWAYS:
1:5b838fd:                 return ColumnInfo.MODIFY_COLUMN_GENERATED_ALWAYS;
1:5b838fd: 
1:5b838fd:             case K_MODIFY_COLUMN_GENERATED_BY_DEFAULT:
1:5b838fd:                 return ColumnInfo.MODIFY_COLUMN_GENERATED_BY_DEFAULT;
1:5b838fd: 
1:2706d1f:             default:
1:2706d1f:                 if (SanityManager.DEBUG) {
1:2706d1f:                     SanityManager.THROWASSERT("Unexpected type = " + kind);
1:2706d1f:                 }
1:2706d1f:                 return 0;
1:2706d1f:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check the validity of the default, if any, for this node.
1:eac0369: 	 *
1:eac0369: 	 * @param dd		The DataDictionary.
1:eac0369: 	 * @param td		The TableDescriptor.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	void bindAndValidateDefault(DataDictionary dd, TableDescriptor td) 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ColumnDescriptor cd;
1:eac0369: 
1:eac0369: 		// First verify that the column exists
1:eac0369: 		cd = td.getColumnDescriptor(name);
1:eac0369: 		if (cd == null)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, name, td.getName());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		// Get the UUID for the old default
1:eac0369: 		DefaultDescriptor defaultDescriptor = cd.getDefaultDescriptor(dd);
1:eac0369: 		
1:eac0369: 		oldDefaultUUID = (defaultDescriptor == null) ? null : defaultDescriptor.getUUID();
1:eac0369: 
1:eac0369: 		// Remember the column position
1:eac0369: 		columnPosition = cd.getPosition();
1:eac0369: 
1:eac0369: 		// No other work to do if no user specified default
1:2706d1f:         if (kind != K_MODIFY_COLUMN_DEFAULT) {
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:43da026: 		// If the statement is not setting the column's default, then
1:43da026: 		// recover the old default and re-use it. If the statement is
1:43da026: 		// changing the start value for the auto-increment, then recover
1:43da026: 		// the old increment-by value and re-use it. If the statement is
1:43da026: 		// changing the increment-by value, then recover the old start value
1:43da026: 		// and re-use it. This way, the column alteration only changes the
1:43da026: 		// aspects of the autoincrement settings that it intends to change,
1:43da026: 		// and does not lose the other aspecs.
1:fe3c8d8: 		if (keepCurrentDefault)
1:f18c716:         { defaultInfo = (DefaultInfoImpl)cd.getDefaultInfo(); }
1:f18c716:         else
1:f18c716:         {
1:6fdf9c0:             if ( cd.hasGenerationClause() || cd.isAutoincrement() )
1:f18c716:             {
1:f18c716: 				throw StandardException.newException( SQLState.LANG_GEN_COL_DEFAULT, cd.getColumnName() );
1:f18c716:             }
1:f18c716:         }
1:43da026: 		if (autoinc_create_or_modify_Start_Increment ==
1:43da026: 				ColumnDefinitionNode.MODIFY_AUTOINCREMENT_RESTART_VALUE)
1:43da026: 			autoincrementIncrement = cd.getAutoincInc();
1:43da026: 		if (autoinc_create_or_modify_Start_Increment ==
1:df9bd6e: 				ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE)
1:43da026: 			autoincrementStart = cd.getAutoincStart();
1:43da026: 
1:eac0369: 		/* Fill in the DataTypeServices from the DataDictionary */
1:7dda5d5: 		type = cd.getType();
1:eac0369: 
1:eac0369: 		// Now validate the default
1:eac0369: 		validateDefault(dd, td);
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	private ColumnDescriptor getLocalColumnDescriptor(String name, TableDescriptor td)
1:eac0369: 	         throws StandardException
1:eac0369: 	{
1:eac0369: 		ColumnDescriptor cd;
1:eac0369: 
1:eac0369: 		// First verify that the column exists
1:eac0369: 		cd = td.getColumnDescriptor(name);
1:eac0369: 		if (cd == null)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(
1:eac0369: 				SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, name, td.getName());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return cd;
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 * check the validity of autoincrement values in the case that we are 
1:eac0369: 	 * modifying an existing column (includes checking if autoincrement is set
1:eac0369: 	 * when making a column nullable)
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void validateAutoincrement(DataDictionary dd,
1:3bb140c:                                TableDescriptor td,
1:3bb140c:                                int tableType) throws StandardException
1:eac0369: 	{
1:eac0369: 		ColumnDescriptor cd;
1:eac0369: 
1:5b838fd: 		// only autoincrement columns can have their generation property changed
1:5b838fd:         if (
1:5b838fd:             (kind == K_MODIFY_COLUMN_GENERATED_ALWAYS) ||
1:5b838fd:             (kind == K_MODIFY_COLUMN_GENERATED_BY_DEFAULT)
1:5b838fd:             )
1:5b838fd: 		{
1:5b838fd: 			cd = getLocalColumnDescriptor(name, td);
1:5b838fd: 			if (!cd.isAutoincrement())
1:5b838fd: 			{
1:5b838fd: 				throw StandardException.newException(SQLState.LANG_AI_CANNOT_ALTER_IDENTITYNESS,
1:5b838fd: 						getColumnName());
1:5b838fd: 			}
1:5b838fd: 
1:5b838fd:             if (kind == K_MODIFY_COLUMN_GENERATED_BY_DEFAULT)
1:5b838fd:             {
1:5b838fd:                 defaultInfo = createDefaultInfoOfAutoInc();
1:5b838fd:             }
1:5b838fd: 
1:5b838fd:             // nothing more to do here
1:5b838fd:             return;
1:5b838fd: 		}
1:5b838fd: 
1:eac0369: 		// a column that has an autoincrement default can't be made nullable
1:2706d1f:         if (kind == K_MODIFY_COLUMN_CONSTRAINT)
1:eac0369: 		{
1:eac0369: 			cd = getLocalColumnDescriptor(name, td);
1:eac0369: 			if (cd.isAutoincrement())
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_AI_CANNOT_NULL_AI,
1:eac0369: 						getColumnName());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (autoincrementVerify)
1:eac0369: 		{
1:eac0369: 			cd = getLocalColumnDescriptor(name, td);
1:eac0369: 			if (!cd.isAutoincrement())
1:eac0369: 				throw StandardException.newException(SQLState.LANG_INVALID_ALTER_TABLE_ATTRIBUTES,
1:eac0369: 								td.getQualifiedName(), name);
1:eac0369: 		}
1:eac0369: 		if (isAutoincrement == false)
1:eac0369: 			return;
1:eac0369: 		
1:eac0369: 		super.validateAutoincrement(dd, td, tableType);
1:7dda5d5: 		if (getType().isNullable())
1:eac0369: 			throw StandardException.newException(SQLState.LANG_AI_CANNOT_ADD_AI_TO_NULLABLE,
1:eac0369: 												getColumnName());
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 *         ==&gt; ERROR. This references a Primary Key constraint and the
1: 	 *             type and lengths of the pkey/fkey must match exactly.
1: 	 *         ==&gt; OK if no fkey references this constraint.
1: 	 *         ==&gt; ERROR if any fkey in the system references this constraint.
commit:5b838fd
/////////////////////////////////////////////////////////////////////////
1:     final static int K_MODIFY_COLUMN_GENERATED_ALWAYS = 5;
1:     final static int K_MODIFY_COLUMN_GENERATED_BY_DEFAULT = 6;
/////////////////////////////////////////////////////////////////////////
1:             case K_MODIFY_COLUMN_GENERATED_ALWAYS:
1:                 return ColumnInfo.MODIFY_COLUMN_GENERATED_ALWAYS;
1: 
1:             case K_MODIFY_COLUMN_GENERATED_BY_DEFAULT:
1:                 return ColumnInfo.MODIFY_COLUMN_GENERATED_BY_DEFAULT;
1: 
/////////////////////////////////////////////////////////////////////////
1: 		// only autoincrement columns can have their generation property changed
1:         if (
1:             (kind == K_MODIFY_COLUMN_GENERATED_ALWAYS) ||
1:             (kind == K_MODIFY_COLUMN_GENERATED_BY_DEFAULT)
1:             )
1: 		{
1: 			cd = getLocalColumnDescriptor(name, td);
1: 			if (!cd.isAutoincrement())
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_AI_CANNOT_ALTER_IDENTITYNESS,
1: 						getColumnName());
1: 			}
1: 
1:             if (kind == K_MODIFY_COLUMN_GENERATED_BY_DEFAULT)
1:             {
1:                 defaultInfo = createDefaultInfoOfAutoInc();
1:             }
1: 
1:             // nothing more to do here
1:             return;
1: 		}
1: 
commit:6fdf9c0
/////////////////////////////////////////////////////////////////////////
1:             if ( cd.hasGenerationClause() || cd.isAutoincrement() )
commit:f18c716
/////////////////////////////////////////////////////////////////////////
1:         { defaultInfo = (DefaultInfoImpl)cd.getDefaultInfo(); }
1:         else
1:         {
0:             if ( cd.hasGenerationClause() )
1:             {
1: 				throw StandardException.newException( SQLState.LANG_GEN_COL_DEFAULT, cd.getColumnName() );
1:             }
1:         }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:fecd96a
/////////////////////////////////////////////////////////////////////////
1: 			!(typeName.equals(TypeId.VARBIT_NAME))&&
1: 			!(typeName.equals(TypeId.BLOB_NAME))&&
1: 			!(typeName.equals(TypeId.CLOB_NAME)))
commit:fe3c8d8
/////////////////////////////////////////////////////////////////////////
1: 		if (keepCurrentDefault)
commit:df9bd6e
/////////////////////////////////////////////////////////////////////////
0: 			else if (autoinc_create_or_modify_Start_Increment ==
1: 				ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE)
1: 			else
1: 				return ColumnInfo.MODIFY_COLUMN_DEFAULT_VALUE;
commit:43da026
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.types.DefaultInfoImpl;
/////////////////////////////////////////////////////////////////////////
1: 		// If the statement is not setting the column's default, then
1: 		// recover the old default and re-use it. If the statement is
1: 		// changing the start value for the auto-increment, then recover
1: 		// the old increment-by value and re-use it. If the statement is
1: 		// changing the increment-by value, then recover the old start value
1: 		// and re-use it. This way, the column alteration only changes the
1: 		// aspects of the autoincrement settings that it intends to change,
1: 		// and does not lose the other aspecs.
0: 		if (defaultNode == null)
0: 			defaultInfo = (DefaultInfoImpl)cd.getDefaultInfo();
1: 		if (autoinc_create_or_modify_Start_Increment ==
1: 				ColumnDefinitionNode.MODIFY_AUTOINCREMENT_RESTART_VALUE)
1: 			autoincrementIncrement = cd.getAutoincInc();
1: 		if (autoinc_create_or_modify_Start_Increment ==
0: 				ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE)
1: 			autoincrementStart = cd.getAutoincStart();
1: 
commit:ee5857f
/////////////////////////////////////////////////////////////////////////
0: 		case C_NodeTypes.DROP_COLUMN_NODE:
1: 			return ColumnInfo.DROP;
commit:c310bdd
/////////////////////////////////////////////////////////////////////////
0: 				// a column that is part of a primary key or unique constraint
1:                 // is being made nullable; can't be done.
1: 					((existingConstraint.getConstraintType() == 
0: 					 DataDictionary.PRIMARYKEY_CONSTRAINT) ||
1: 					 (existingConstraint.getConstraintType() == 
0: 					 DataDictionary.UNIQUE_CONSTRAINT)))
0: 					 SQLState.LANG_MODIFY_COLUMN_EXISTING_CONSTRAINT, name);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // Allowed kinds
1:     final static int K_MODIFY_COLUMN_TYPE = 0;
1:     final static int K_MODIFY_COLUMN_DEFAULT = 1;
1:     final static int K_MODIFY_COLUMN_CONSTRAINT = 2;
1:     final static int K_MODIFY_COLUMN_CONSTRAINT_NOT_NULL = 3;
1:     final static int K_DROP_COLUMN = 4;
1: 
1:     /**
1:      * This class is used to hold logically different objects for
1:      * space efficiency. {@code kind} represents the logical object
1:      * type. See also {@link ValueNode#isSameNodeKind}.
1:      */
1:     final int kind;
1: 
1:     ModifyColumnNode(int kind,
1:         this.kind = kind;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (kind != K_MODIFY_COLUMN_TYPE) {
1:             return; // nothing to do if user not changing length
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if ((kind != K_MODIFY_COLUMN_TYPE) &&
1:             (kind != K_MODIFY_COLUMN_CONSTRAINT) &&
1:             (kind != K_MODIFY_COLUMN_CONSTRAINT_NOT_NULL))
/////////////////////////////////////////////////////////////////////////
1:                 (kind == K_MODIFY_COLUMN_TYPE))
/////////////////////////////////////////////////////////////////////////
1:                     // If a column is part of unique constraint it can't be
1:                     // made nullable in soft upgrade mode from a pre-10.4 db.
1:                     if (kind == K_MODIFY_COLUMN_CONSTRAINT &&
/////////////////////////////////////////////////////////////////////////
1:                 // A column that is part of a primary key
1:                 if ((kind == K_MODIFY_COLUMN_CONSTRAINT) &&
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         switch (kind) {
1:             case K_MODIFY_COLUMN_DEFAULT:
1:                 if (autoinc_create_or_modify_Start_Increment ==
1:                         ColumnDefinitionNode.MODIFY_AUTOINCREMENT_RESTART_VALUE) {
1:                     return ColumnInfo.MODIFY_COLUMN_DEFAULT_RESTART;
1: 
1:                 } else if (autoinc_create_or_modify_Start_Increment ==
1:                         ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE) {
1:                     return ColumnInfo.MODIFY_COLUMN_DEFAULT_INCREMENT;
1: 
1:                 } else {
0:                     return ColumnInfo.MODIFY_COLUMN_DEFAULT_VALUE;
1:                 }
1:             case K_MODIFY_COLUMN_TYPE:
1:                 return ColumnInfo.MODIFY_COLUMN_TYPE;
1: 
1:             case K_MODIFY_COLUMN_CONSTRAINT:
1:                 return ColumnInfo.MODIFY_COLUMN_CONSTRAINT;
1: 
1:             case K_MODIFY_COLUMN_CONSTRAINT_NOT_NULL:
1:                 return ColumnInfo.MODIFY_COLUMN_CONSTRAINT_NOT_NULL;
1: 
1:             case K_DROP_COLUMN:
0:                 return ColumnInfo.DROP;
1: 
1:             default:
1:                 if (SanityManager.DEBUG) {
1:                     SanityManager.THROWASSERT("Unexpected type = " + kind);
1:                 }
1:                 return 0;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (kind != K_MODIFY_COLUMN_DEFAULT) {
/////////////////////////////////////////////////////////////////////////
1:         if (kind == K_MODIFY_COLUMN_CONSTRAINT)
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.DefaultDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.KeyConstraintDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.impl.sql.execute.ColumnInfo;
1: class ModifyColumnNode extends ColumnDefinitionNode
0:     ModifyColumnNode(int type,
1:             String name,
1:             ValueNode defaultNode,
1:             DataTypeDescriptor dataTypeServices,
1:             long[] autoIncrementInfo,
1:             ContextManager cm) throws StandardException {
1:         super(name, defaultNode, dataTypeServices, autoIncrementInfo, cm);
0:         setNodeType(type);
1:     }
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     int getColumnPosition()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void checkUserType(TableDescriptor td)
/////////////////////////////////////////////////////////////////////////
1:     void checkExistingConstraints(TableDescriptor td)
/////////////////////////////////////////////////////////////////////////
1:     void useExistingCollation(TableDescriptor td)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void validateAutoincrement(DataDictionary dd,
1:                                TableDescriptor td,
1:                                int tableType) throws StandardException
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:419210d
/////////////////////////////////////////////////////////////////////////
1: 				if (!dd.checkVersion(
1: 					DataDictionary.DD_VERSION_DERBY_10_4, null)) 
1: 				{
0: 					//if a column is part of unique constraint it can't be
0: 					//made nullable in soft upgrade mode from a pre-10.4 db.
0: 					if ((getNodeType() == 
0: 						C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NODE) &&
0: 						(existingConstraint.getConstraintType() == 
1: 							DataDictionary.UNIQUE_CONSTRAINT)) 
1: 					{
1: 							SQLState.LANG_MODIFY_COLUMN_EXISTING_CONSTRAINT,
1: 							name);
1: 					}
commit:cd38662
/////////////////////////////////////////////////////////////////////////
1: 					String errorState = 
1: 						(getLanguageConnectionContext().getDataDictionary()
1: 								.checkVersion(DataDictionary.DD_VERSION_DERBY_10_4, 
1: 								null))
1: 						? SQLState.LANG_MODIFY_COLUMN_EXISTING_PRIMARY_KEY
1: 						: SQLState.LANG_MODIFY_COLUMN_EXISTING_CONSTRAINT;
1: 					throw StandardException.newException(errorState, name);
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:2e3ed68
/////////////////////////////////////////////////////////////////////////
1:      * Check if the the column can be modified, and throw error if not.
1:      *
1: 	 * If the type of a column is being changed (for instance if the length 
1:      * of the column is being increased) then make sure that this does not 
1:      * violate any key constraints; 
/////////////////////////////////////////////////////////////////////////
1: 		DataDictionary           dd          = getDataDictionary();
1: 		ConstraintDescriptorList cdl         = dd.getConstraintDescriptors(td);
1: 		int                      intArray[]  = new int[1];
1: 		intArray[0]                          = columnPosition;
1: 
/////////////////////////////////////////////////////////////////////////
1: 					 SQLState.LANG_MODIFY_COLUMN_FKEY_CONSTRAINT, 
1:                      name, existingConstraint.getConstraintName());
0: 				//made nullable in soft upgrade mode from a pre-10.4 db.
0: 								DataDictionary.UNIQUE_CONSTRAINT)) 
1:                 {
1:                     {
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     throw StandardException.newException(
0:                          SQLState.LANG_MODIFY_COLUMN_EXISTING_CONSTRAINT, name);
/////////////////////////////////////////////////////////////////////////
1: 						 SQLState.LANG_MODIFY_COLUMN_REFERENCED, 
1:                          name, refcdl.elementAt(0).getConstraintName());
commit:a52a206
/////////////////////////////////////////////////////////////////////////
0: 				//if a column is part of unique constraint it can't be
0: 				//made nullable in soft upgrade mode
0: 				if ((existingConstraint.getConstraintType() == 
0: 								DataDictionary.UNIQUE_CONSTRAINT)) {
0: 					if (!dd.checkVersion(
0: 							DataDictionary.DD_VERSION_DERBY_10_4, null))
1: 						throw StandardException.newException(
0: 								SQLState.LANG_MODIFY_COLUMN_EXISTING_CONSTRAINT,
0: 								name);
1: 				}
0: 				// a column that is part of a primary key
1: 					 DataDictionary.PRIMARYKEY_CONSTRAINT)))
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9ed7c4d
/////////////////////////////////////////////////////////////////////////
1: 	 * get its collation from the corresponding column in the TableDescriptor.
/////////////////////////////////////////////////////////////////////////
1: 				setCollationType(cd.getType().getCollationType());			
commit:7dda5d5
/////////////////////////////////////////////////////////////////////////
1:         setNullability(oldType.isNullable());
1: 		if (!(oldType.getTypeId().equals(getType().getTypeId())))
1: 		String typeName = getType().getTypeName();
/////////////////////////////////////////////////////////////////////////
1: 		if (getType().getMaximumWidth() < oldType.getMaximumWidth())
/////////////////////////////////////////////////////////////////////////
1: 		type = cd.getType();
/////////////////////////////////////////////////////////////////////////
1: 		if (getType().isNullable())
commit:cb8f109
/////////////////////////////////////////////////////////////////////////
1:         ColumnDescriptor cd = td.getColumnDescriptor(name);
1: 		DataTypeDescriptor oldType = cd.getType();
0:         dataTypeServices = 
0:             getDataTypeServices().getNullabilityType(oldType.isNullable());
0: 		if (!(oldType.getTypeId().equals(getDataTypeServices().getTypeId())))
0: 		String typeName = getDataTypeServices().getTypeName();
/////////////////////////////////////////////////////////////////////////
0: 		if (getDataTypeServices().getMaximumWidth() < oldType.getMaximumWidth())
/////////////////////////////////////////////////////////////////////////
0: 		if (getDataTypeServices().isNullable())
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.ModifyColumnNode
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DefaultDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
0: import org.apache.derby.iapi.sql.dictionary.KeyConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
1: 
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.impl.sql.execute.ColumnInfo;
0: import org.apache.derby.catalog.TypeDescriptor;
1: import org.apache.derby.catalog.UUID;
1: 
1: /**
1:  * A ModifyColumnNode represents a modify column in an ALTER TABLE statement.
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
0: public class ModifyColumnNode extends ColumnDefinitionNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
1: 	int		columnPosition = -1;
1: 	UUID	oldDefaultUUID;
1: 
1: 	/**
1: 	 * Get the UUID of the old column default.
1: 	 *
1: 	 * @return The UUID of the old column default.
1: 	 */
1: 	UUID getOldDefaultUUID()
1: 	{
1: 		return oldDefaultUUID;
1: 	}
1: 
1: 	/**
1: 	 * Get the column position for the column.
1: 	 *
1: 	 * @return The column position for the column.
1: 	 */
0: 	public int getColumnPosition()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(columnPosition > 0,
1: 				"columnPosition expected to be > 0");
1: 		}
1: 		return columnPosition;
1: 	}
1: 
1: 	/**
1: 	 * Check the validity of a user type.  Checks that
1: 	 * 1. the column type is either varchar, ....
1: 	 * 2. is the same type after the alter.
1: 	 * 3. length is greater than the old length.
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void checkUserType(TableDescriptor td)
1: 		throws StandardException
1: 	{
1: 		ColumnDescriptor cd;
0: 		TypeDescriptor oldType;
0: 		TypeDescriptor newType = dataTypeServices;
0: 		TypeId oldTypeId;
0: 		TypeId newTypeId;
1: 
0: 		if (getNodeType() != C_NodeTypes.MODIFY_COLUMN_TYPE_NODE)
0: 			return;				// nothing to do if user not changing length
1: 
1: 		cd = td.getColumnDescriptor(name);
1: 		if (cd == null)
1: 		{
1: 			throw StandardException.newException(
1: 				SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, name, td.getName());
1: 		}
1: 		
0: 		oldType = cd.getType();
0: 		oldTypeId = cd.getType().getTypeId();
0: 		newTypeId = dataTypeServices.getTypeId();
1: 
1: 		// can't change types yet.
0: 		if (!(oldTypeId.equals(newTypeId)))
1: 		{
1: 			throw StandardException.newException(
1: 					 SQLState.LANG_MODIFY_COLUMN_CHANGE_TYPE, name);
1: 		}			
1: 		
0: 		// can only alter the length of varchar, nvarchar, bitvarying columns
0: 		String typeName = dataTypeServices.getTypeName();
0: 		if (!(typeName.equals(TypeId.NATIONAL_VARCHAR_NAME)) &&
0: 			!(typeName.equals(TypeId.VARCHAR_NAME)) &&
0: 			!(typeName.equals(TypeId.VARBIT_NAME)))
1: 		{
1: 			throw StandardException.newException(
1: 						 SQLState.LANG_MODIFY_COLUMN_INVALID_TYPE);
1: 		}
1: 		
1: 		// cannot decrease the length of a column
0: 		if (newType.getMaximumWidth() < oldType.getMaximumWidth())
1: 		{
1: 			throw StandardException.newException(
1: 						 SQLState.LANG_MODIFY_COLUMN_INVALID_LENGTH, name);
1: 		}
1: 	}
1: 	
1: 	/**
0: 	 * If the type of a column is being changed (for mulan, the length of the
0: 	 * column is being increased then make sure that this does not violate
0: 	 * any key constraints; 
1: 	 * the column being altered is 
1: 	 *   1. part of foreign key constraint 
0: 	 *         ==> ERROR. This references a Primary Key constraint and the
0: 	 *             type & lengths of the pkey/fkey must match exactly.
1: 	 *   2. part of a unique/primary key constraint
0: 	 *         ==> OK if no fkey references this constraint.
0: 	 *         ==> ERROR if any fkey in the system references this constraint.
1: 	 *
1: 	 * @param td		The Table Descriptor on which the ALTER is being done.
1: 	 *
1: 	 * @exception StandardException		Thrown on Error.
1: 	 *
1: 	 */
0: 	public void checkExistingConstraints(TableDescriptor td)
1: 	             throws StandardException
1: 	{
0: 		if ((getNodeType() != C_NodeTypes.MODIFY_COLUMN_TYPE_NODE) &&
0: 			(getNodeType() != C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NODE) &&
0: 			(getNodeType() != C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NOT_NULL_NODE))
1: 			return;
1: 
0: 		DataDictionary dd = getDataDictionary();
0: 		ConstraintDescriptorList cdl = dd.getConstraintDescriptors(td);
0: 		int intArray[] = new int[1];
0: 		intArray[0] = columnPosition;
1: 
1: 		for (int index = 0; index < cdl.size(); index++)
1: 		{
1: 			ConstraintDescriptor existingConstraint =
1: 				                                cdl.elementAt(index);
1: 			if (!(existingConstraint instanceof KeyConstraintDescriptor))
1: 				continue;
1: 
1: 			if (!existingConstraint.columnIntersects(intArray))
1: 				continue;
1: 															 
1: 			int constraintType = existingConstraint.getConstraintType();
1: 
1: 			// cannot change the length of a column that is part of a 
1: 			// foreign key constraint. Must be an exact match between pkey
1: 			// and fkey columns.
1: 			if ((constraintType == DataDictionary.FOREIGNKEY_CONSTRAINT) 
1: 				&&
0: 				(getNodeType() == C_NodeTypes.MODIFY_COLUMN_TYPE_NODE))
1: 			{
1: 				throw StandardException.newException(
0: 					 SQLState.LANG_MODIFY_COLUMN_FKEY_CONSTRAINT, name, existingConstraint.getConstraintName());
1: 			}	
1: 			
0: 			else
1: 			{
0: 				// a column that is part of a primary key is being made
0: 				// nullable; can't be done.
0: 				if ((getNodeType() == 
0: 					 C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NODE) &&
0: 					(existingConstraint.getConstraintType() == 
0: 					 DataDictionary.PRIMARYKEY_CONSTRAINT))
1: 				{
1: 				throw StandardException.newException(
0: 					 SQLState.LANG_MODIFY_COLUMN_PKEY_CONSTRAINT, name);
1: 				}
1: 				// unique key or primary key.
1: 				ConstraintDescriptorList 
1: 					refcdl = dd.getForeignKeys(existingConstraint.getUUID());
1: 				 
1: 				if (refcdl.size() > 0)
1: 				{
1: 					throw StandardException.newException(
0: 						 SQLState.LANG_MODIFY_COLUMN_REFERENCED, name, refcdl.elementAt(0).getConstraintName());
1: 				}
1: 				
1: 				// Make the statement dependent on the primary key constraint.
1: 				getCompilerContext().createDependency(existingConstraint);
1: 			}
1: 		}
1: 
1: 	}
1: 	/**
1: 	 * Get the action associated with this node.
1: 	 *
1: 	 * @return The action associated with this node.
1: 	 */
1: 	int getAction()
1: 	{
0: 		switch (getNodeType())
1: 		{
0: 		case C_NodeTypes.MODIFY_COLUMN_DEFAULT_NODE:
0: 			return ColumnInfo.MODIFY_COLUMN_DEFAULT;
0: 		case C_NodeTypes.MODIFY_COLUMN_TYPE_NODE:
0: 			return ColumnInfo.MODIFY_COLUMN_TYPE;
0: 		case C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NODE:
0: 			return ColumnInfo.MODIFY_COLUMN_CONSTRAINT;
0: 		case C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NOT_NULL_NODE:
0: 			return ColumnInfo.MODIFY_COLUMN_CONSTRAINT_NOT_NULL;
0: 		default:
1: 			if (SanityManager.DEBUG)
1: 			{
0: 				SanityManager.THROWASSERT("Unexpected nodeType = " + 
0: 										  getNodeType());
1: 			}
0: 			return 0;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Check the validity of the default, if any, for this node.
1: 	 *
1: 	 * @param dd		The DataDictionary.
1: 	 * @param td		The TableDescriptor.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void bindAndValidateDefault(DataDictionary dd, TableDescriptor td) 
1: 		throws StandardException
1: 	{
1: 		ColumnDescriptor cd;
1: 
1: 		// First verify that the column exists
1: 		cd = td.getColumnDescriptor(name);
1: 		if (cd == null)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, name, td.getName());
1: 		}
1: 
1: 
1: 		// Get the UUID for the old default
1: 		DefaultDescriptor defaultDescriptor = cd.getDefaultDescriptor(dd);
1: 		
1: 		oldDefaultUUID = (defaultDescriptor == null) ? null : defaultDescriptor.getUUID();
1: 
1: 		// Remember the column position
1: 		columnPosition = cd.getPosition();
1: 
1: 		// No other work to do if no user specified default
0: 		if (getNodeType() != C_NodeTypes.MODIFY_COLUMN_DEFAULT_NODE)
1: 		{
1: 			return;
1: 		}
1: 
1: 		/* Fill in the DataTypeServices from the DataDictionary */
0: 		dataTypeServices = cd.getType();
1: 
1: 		// Now validate the default
1: 		validateDefault(dd, td);
1: 	}
1: 	
1: 	private ColumnDescriptor getLocalColumnDescriptor(String name, TableDescriptor td)
1: 	         throws StandardException
1: 	{
1: 		ColumnDescriptor cd;
1: 
1: 		// First verify that the column exists
1: 		cd = td.getColumnDescriptor(name);
1: 		if (cd == null)
1: 		{
1: 			throw StandardException.newException(
1: 				SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, name, td.getName());
1: 		}
1: 
1: 		return cd;
1: 	}
1: 	/**
1: 	 * check the validity of autoincrement values in the case that we are 
1: 	 * modifying an existing column (includes checking if autoincrement is set
1: 	 * when making a column nullable)
1: 	 */
0: 	public void validateAutoincrement(DataDictionary dd, TableDescriptor td, int tableType)
1: 	         throws StandardException
1: 	{
1: 		ColumnDescriptor cd;
1: 
1: 		// a column that has an autoincrement default can't be made nullable
0: 		if (getNodeType() == C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NODE)
1: 		{
1: 			cd = getLocalColumnDescriptor(name, td);
1: 			if (cd.isAutoincrement())
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_AI_CANNOT_NULL_AI,
1: 						getColumnName());
1: 			}
1: 		}
1: 
1: 		if (autoincrementVerify)
1: 		{
1: 			cd = getLocalColumnDescriptor(name, td);
1: 			if (!cd.isAutoincrement())
1: 				throw StandardException.newException(SQLState.LANG_INVALID_ALTER_TABLE_ATTRIBUTES,
1: 								td.getQualifiedName(), name);
1: 		}
1: 		if (isAutoincrement == false)
1: 			return;
1: 		
1: 		super.validateAutoincrement(dd, td, tableType);
0: 		if (dataTypeServices.isNullable())
1: 			throw StandardException.newException(SQLState.LANG_AI_CANNOT_ADD_AI_TO_NULLABLE,
1: 												getColumnName());
1: 	}
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:111785f
/////////////////////////////////////////////////////////////////////////
1: 		// can only alter the length of varchar, bitvarying columns
1: 		if (!(typeName.equals(TypeId.VARCHAR_NAME)) &&
commit:93b320d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
1:     }
0: 	/**
1: 	 * If the column being modified is of character string type, then it should
0: 	 * get it's collation from the corresponding column in the TableDescriptor.
1: 	 * This will ensure that at alter table time, the existing character string
1: 	 * type columns do not loose their collation type. If the alter table is 
1: 	 * doing a drop column, then we do not need to worry about collation info.
0: 	 * 
1: 	 * @param td Table Descriptor that holds the column which is being altered
1: 	 * @throws StandardException
0: 	 */
0: 	public void useExistingCollation(TableDescriptor td)
0:     throws StandardException
0:     {
0: 		ColumnDescriptor cd;
0: 
1: 		// First verify that the column exists
0: 		cd = td.getColumnDescriptor(name);
1: 		if (cd == null)
0: 		{
1: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, name, td.getName());
1: 		}
1: 		//getType() == null means we are dealing with drop column and hence 
1: 		//no need to worry about collation info
1: 		if (getType() != null) {
1: 			if (getType().getTypeId().isStringTypeId()) {
0: 				this.getType().setCollationType(cd.getType().getCollationType());
0: 				this.getType().setCollationDerivation(StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			
1: 			}
1: 		}
1:     }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:a5b55db
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
/////////////////////////////////////////////////////////////////////////
0: 		DataTypeDescriptor newType = dataTypeServices;
/////////////////////////////////////////////////////////////////////////
0: 		newType.setNullability(oldType.isNullable());
commit:6a5edfc
/////////////////////////////////////////////////////////////////////////
0: 			if (autoinc_create_or_modify_Start_Increment == ColumnDefinitionNode.MODIFY_AUTOINCREMENT_RESTART_VALUE)
0: 				return ColumnInfo.MODIFY_COLUMN_DEFAULT_RESTART;
0: 			else
0: 				return ColumnInfo.MODIFY_COLUMN_DEFAULT_INCREMENT;
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DefaultDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
0: import org.apache.derby.iapi.sql.dictionary.KeyConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.impl.sql.execute.ColumnInfo;
0: import org.apache.derby.catalog.TypeDescriptor;
0: import org.apache.derby.catalog.UUID;
0: 
0: /**
0:  * A ModifyColumnNode represents a modify column in an ALTER TABLE statement.
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public class ModifyColumnNode extends ColumnDefinitionNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0: 	int		columnPosition = -1;
0: 	UUID	oldDefaultUUID;
0: 
0: 	/**
0: 	 * Get the UUID of the old column default.
0: 	 *
0: 	 * @return The UUID of the old column default.
0: 	 */
0: 	UUID getOldDefaultUUID()
0: 	{
0: 		return oldDefaultUUID;
0: 	}
0: 
0: 	/**
0: 	 * Get the column position for the column.
0: 	 *
0: 	 * @return The column position for the column.
0: 	 */
0: 	public int getColumnPosition()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(columnPosition > 0,
0: 				"columnPosition expected to be > 0");
0: 		}
0: 		return columnPosition;
0: 	}
0: 
0: 	/**
0: 	 * Check the validity of a user type.  Checks that
0: 	 * 1. the column type is either varchar, ....
0: 	 * 2. is the same type after the alter.
0: 	 * 3. length is greater than the old length.
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void checkUserType(TableDescriptor td)
0: 		throws StandardException
0: 	{
0: 		ColumnDescriptor cd;
0: 		TypeDescriptor oldType;
0: 		TypeDescriptor newType = dataTypeServices;
0: 		TypeId oldTypeId;
0: 		TypeId newTypeId;
0: 
0: 		if (getNodeType() != C_NodeTypes.MODIFY_COLUMN_TYPE_NODE)
0: 			return;				// nothing to do if user not changing length
0: 
0: 		cd = td.getColumnDescriptor(name);
0: 		if (cd == null)
0: 		{
0: 			throw StandardException.newException(
0: 				SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, name, td.getName());
0: 		}
0: 		
0: 		oldType = cd.getType();
0: 		oldTypeId = cd.getType().getTypeId();
0: 		newTypeId = dataTypeServices.getTypeId();
0: 
0: 		// can't change types yet.
0: 		if (!(oldTypeId.equals(newTypeId)))
0: 		{
0: 			throw StandardException.newException(
0: 					 SQLState.LANG_MODIFY_COLUMN_CHANGE_TYPE, name);
0: 		}			
0: 		
0: 		// can only alter the length of varchar, nvarchar, bitvarying columns
0: 		String typeName = dataTypeServices.getTypeName();
0: 		if (!(typeName.equals(TypeId.NATIONAL_VARCHAR_NAME)) &&
0: 			!(typeName.equals(TypeId.VARCHAR_NAME)) &&
0: 			!(typeName.equals(TypeId.VARBIT_NAME)))
0: 		{
0: 			throw StandardException.newException(
0: 						 SQLState.LANG_MODIFY_COLUMN_INVALID_TYPE);
0: 		}
0: 		
0: 		// cannot decrease the length of a column
0: 		if (newType.getMaximumWidth() < oldType.getMaximumWidth())
0: 		{
0: 			throw StandardException.newException(
0: 						 SQLState.LANG_MODIFY_COLUMN_INVALID_LENGTH, name);
0: 		}
0: 	}
0: 	
0: 	/**
0: 	 * If the type of a column is being changed (for mulan, the length of the
0: 	 * column is being increased then make sure that this does not violate
0: 	 * any key constraints; 
0: 	 * the column being altered is 
0: 	 *   1. part of foreign key constraint 
0: 	 *         ==> ERROR. This references a Primary Key constraint and the
0: 	 *             type & lengths of the pkey/fkey must match exactly.
0: 	 *   2. part of a unique/primary key constraint
0: 	 *         ==> OK if no fkey references this constraint.
0: 	 *         ==> ERROR if any fkey in the system references this constraint.
0: 	 *
0: 	 * @param td		The Table Descriptor on which the ALTER is being done.
0: 	 *
0: 	 * @exception StandardException		Thrown on Error.
0: 	 *
0: 	 */
0: 	public void checkExistingConstraints(TableDescriptor td)
0: 	             throws StandardException
0: 	{
0: 		if ((getNodeType() != C_NodeTypes.MODIFY_COLUMN_TYPE_NODE) &&
0: 			(getNodeType() != C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NODE) &&
0: 			(getNodeType() != C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NOT_NULL_NODE))
0: 			return;
0: 
0: 		DataDictionary dd = getDataDictionary();
0: 		ConstraintDescriptorList cdl = dd.getConstraintDescriptors(td);
0: 		int intArray[] = new int[1];
0: 		intArray[0] = columnPosition;
0: 
0: 		for (int index = 0; index < cdl.size(); index++)
0: 		{
0: 			ConstraintDescriptor existingConstraint =
0: 				                                cdl.elementAt(index);
0: 			if (!(existingConstraint instanceof KeyConstraintDescriptor))
0: 				continue;
0: 
0: 			if (!existingConstraint.columnIntersects(intArray))
0: 				continue;
0: 															 
0: 			int constraintType = existingConstraint.getConstraintType();
0: 
0: 			// cannot change the length of a column that is part of a 
0: 			// foreign key constraint. Must be an exact match between pkey
0: 			// and fkey columns.
0: 			if ((constraintType == DataDictionary.FOREIGNKEY_CONSTRAINT) 
0: 				&&
0: 				(getNodeType() == C_NodeTypes.MODIFY_COLUMN_TYPE_NODE))
0: 			{
0: 				throw StandardException.newException(
0: 					 SQLState.LANG_MODIFY_COLUMN_FKEY_CONSTRAINT, name, existingConstraint.getConstraintName());
0: 			}	
0: 			
0: 			else
0: 			{
0: 				// a column that is part of a primary key is being made
0: 				// nullable; can't be done.
0: 				if ((getNodeType() == 
0: 					 C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NODE) &&
0: 					(existingConstraint.getConstraintType() == 
0: 					 DataDictionary.PRIMARYKEY_CONSTRAINT))
0: 				{
0: 				throw StandardException.newException(
0: 					 SQLState.LANG_MODIFY_COLUMN_PKEY_CONSTRAINT, name);
0: 				}
0: 				// unique key or primary key.
0: 				ConstraintDescriptorList 
0: 					refcdl = dd.getForeignKeys(existingConstraint.getUUID());
0: 				 
0: 				if (refcdl.size() > 0)
0: 				{
0: 					throw StandardException.newException(
0: 						 SQLState.LANG_MODIFY_COLUMN_REFERENCED, name, refcdl.elementAt(0).getConstraintName());
0: 				}
0: 				
0: 				// Make the statement dependent on the primary key constraint.
0: 				getCompilerContext().createDependency(existingConstraint);
0: 			}
0: 		}
0: 
0: 	}
0: 	/**
0: 	 * Get the action associated with this node.
0: 	 *
0: 	 * @return The action associated with this node.
0: 	 */
0: 	int getAction()
0: 	{
0: 		switch (getNodeType())
0: 		{
0: 		case C_NodeTypes.MODIFY_COLUMN_DEFAULT_NODE:
0: 			return ColumnInfo.MODIFY_COLUMN_DEFAULT;
0: 		case C_NodeTypes.MODIFY_COLUMN_TYPE_NODE:
0: 			return ColumnInfo.MODIFY_COLUMN_TYPE;
0: 		case C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NODE:
0: 			return ColumnInfo.MODIFY_COLUMN_CONSTRAINT;
0: 		case C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NOT_NULL_NODE:
0: 			return ColumnInfo.MODIFY_COLUMN_CONSTRAINT_NOT_NULL;
0: 		default:
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.THROWASSERT("Unexpected nodeType = " + 
0: 										  getNodeType());
0: 			}
0: 			return 0;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Check the validity of the default, if any, for this node.
0: 	 *
0: 	 * @param dd		The DataDictionary.
0: 	 * @param td		The TableDescriptor.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void bindAndValidateDefault(DataDictionary dd, TableDescriptor td) 
0: 		throws StandardException
0: 	{
0: 		ColumnDescriptor cd;
0: 
0: 		// First verify that the column exists
0: 		cd = td.getColumnDescriptor(name);
0: 		if (cd == null)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, name, td.getName());
0: 		}
0: 
0: 
0: 		// Get the UUID for the old default
0: 		DefaultDescriptor defaultDescriptor = cd.getDefaultDescriptor(dd);
0: 		
0: 		oldDefaultUUID = (defaultDescriptor == null) ? null : defaultDescriptor.getUUID();
0: 
0: 		// Remember the column position
0: 		columnPosition = cd.getPosition();
0: 
0: 		// No other work to do if no user specified default
0: 		if (getNodeType() != C_NodeTypes.MODIFY_COLUMN_DEFAULT_NODE)
0: 		{
0: 			return;
0: 		}
0: 
0: 		/* Fill in the DataTypeServices from the DataDictionary */
0: 		dataTypeServices = cd.getType();
0: 
0: 		// Now validate the default
0: 		validateDefault(dd, td);
0: 	}
0: 	
0: 	private ColumnDescriptor getLocalColumnDescriptor(String name, TableDescriptor td)
0: 	         throws StandardException
0: 	{
0: 		ColumnDescriptor cd;
0: 
0: 		// First verify that the column exists
0: 		cd = td.getColumnDescriptor(name);
0: 		if (cd == null)
0: 		{
0: 			throw StandardException.newException(
0: 				SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, name, td.getName());
0: 		}
0: 
0: 		return cd;
0: 	}
0: 	/**
0: 	 * check the validity of autoincrement values in the case that we are 
0: 	 * modifying an existing column (includes checking if autoincrement is set
0: 	 * when making a column nullable)
0: 	 */
0: 	public void validateAutoincrement(DataDictionary dd, TableDescriptor td, int tableType)
0: 	         throws StandardException
0: 	{
0: 		ColumnDescriptor cd;
0: 
0: 		// a column that has an autoincrement default can't be made nullable
0: 		if (getNodeType() == C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NODE)
0: 		{
0: 			cd = getLocalColumnDescriptor(name, td);
0: 			if (cd.isAutoincrement())
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_AI_CANNOT_NULL_AI,
0: 						getColumnName());
0: 			}
0: 		}
0: 
0: 		if (autoincrementVerify)
0: 		{
0: 			cd = getLocalColumnDescriptor(name, td);
0: 			if (!cd.isAutoincrement())
0: 				throw StandardException.newException(SQLState.LANG_INVALID_ALTER_TABLE_ATTRIBUTES,
0: 								td.getQualifiedName(), name);
0: 		}
0: 		if (isAutoincrement == false)
0: 			return;
0: 		
0: 		super.validateAutoincrement(dd, td, tableType);
0: 		if (dataTypeServices.isNullable())
0: 			throw StandardException.newException(SQLState.LANG_AI_CANNOT_ADD_AI_TO_NULLABLE,
0: 												getColumnName());
0: 	}
0: }
============================================================================