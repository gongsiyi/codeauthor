1:eac0369: /*
1:a280beb: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.DependentResultSet
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
15:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:eac0369: import java.util.Properties;
1:b31849d: import java.util.Vector;
1:b31849d: 
1:b31849d: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.services.i18n.MessageService;
1:b31849d: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:b31849d: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:b31849d: import org.apache.derby.iapi.sql.Activation;
1:b31849d: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:b31849d: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1:b31849d: import org.apache.derby.iapi.sql.execute.ExecRow;
1:b31849d: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
1:b31849d: import org.apache.derby.iapi.store.access.ConglomerateController;
1:b31849d: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:b31849d: import org.apache.derby.iapi.store.access.Qualifier;
1:b31849d: import org.apache.derby.iapi.store.access.ScanController;
1:b31849d: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:b31849d: import org.apache.derby.iapi.store.access.TransactionController;
1:b31849d: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: 
1:eac0369: 
2:eac0369: /**
1:eac0369:  * DependentResultSet should be used by only ON DELETE CASCADE/ON DELETE SET NULL ref
1:eac0369:  * actions implementation to gather the rows from the dependent tables.  
1:eac0369:  * Idea is to scan the foreign key index for the rows in 
1:801cf0d:  * the source table materialized temporary result set.
1:801cf0d:  * Scanning of foreign key index gives us the
1:eac0369:  * rows that needs to be deleted on dependent tables. Using the row location 
1:eac0369:  * we got from the index , base row is fetched.
1:eac0369: */
1:801cf0d: @SuppressWarnings("UseOfObsoleteCollectionType")
1:109cb26: class DependentResultSet extends ScanResultSet implements CursorResultSet
5:eac0369: {
1:eac0369: 
1:eac0369: 
1:eac0369: 	ConglomerateController heapCC;
1:eac0369: 	RowLocation	baseRowLocation;  // base row location we got from the index
1:eac0369: 	ExecRow indexRow; //templeate to fetch the index row
1:eac0369: 	IndexRow indexQualifierRow; // template for the index qualifier row
1:eac0369: 	ScanController indexSC;  // Index Scan Controller
1:eac0369: 	StaticCompiledOpenConglomInfo  indexScoci;
1:eac0369: 	DynamicCompiledOpenConglomInfo indexDcoci;
1:eac0369: 	int numFkColumns;
1:eac0369: 	boolean isOpen; // source result set is opened or not
1:eac0369: 	TemporaryRowHolderResultSet source; // Current parent table result set
1:eac0369: 	TransactionController tc;
1:eac0369: 	String parentResultSetId;
1:eac0369: 	int[] fkColArray;
1:eac0369: 	RowLocation rowLocation;
1:eac0369:     TemporaryRowHolder[] sourceRowHolders;
1:eac0369: 	TemporaryRowHolderResultSet[] sourceResultSets;
1:eac0369: 	int[] sourceOpened;
1:eac0369: 	int    sArrayIndex;
1:801cf0d:     Vector<TemporaryRowHolder> sVector;
1:eac0369: 
1:eac0369: 
1:eac0369:     protected ScanController scanController;
1:eac0369: 	protected boolean		scanControllerOpened;
1:eac0369: 	protected boolean		isKeyed;
1:eac0369: 	protected boolean		firstScan = true;
1:eac0369: 	protected ExecIndexRow	startPosition;
1:eac0369: 	protected ExecIndexRow	stopPosition;
1:eac0369: 
1:eac0369:     // set in constructor and not altered during
1:eac0369:     // life of object.
1:eac0369: 	protected long conglomId;
1:eac0369:     protected DynamicCompiledOpenConglomInfo heapDcoci;
1:eac0369:     protected StaticCompiledOpenConglomInfo heapScoci;
1:eac0369: 	protected int startSearchOperator;
1:eac0369: 	protected int stopSearchOperator;
1:eac0369: 	protected Qualifier[][] qualifiers;
1:c7248d5: 	public String userSuppliedOptimizerOverrides;
1:eac0369: 	protected boolean runTimeStatisticsOn;
1:eac0369: 	public int rowsPerRead;
1:eac0369: 	public boolean forUpdate;
1:eac0369: 
1:eac0369: 	// Run time statistics
1:eac0369: 	private Properties scanProperties;
1:eac0369: 	public String startPositionString;
1:eac0369: 	public String stopPositionString;
1:eac0369: 	public boolean isConstraint;
1:eac0369: 	public boolean coarserLock;
1:eac0369: 	public boolean oneRowScan;
1:eac0369: 	protected long	rowsThisScan;
1:eac0369: 
1:eac0369: 	//
1:eac0369:     // class interface
1:eac0369:     //
1:f77f36d: 	DependentResultSet(
1:eac0369: 		long conglomId,
1:eac0369: 		StaticCompiledOpenConglomInfo scoci, 
1:eac0369: 		Activation activation, 
1:959fef2: 		int resultRowTemplate,
1:eac0369: 		int resultSetNumber,
1:eac0369: 		GeneratedMethod startKeyGetter, int startSearchOperator,
1:eac0369: 		GeneratedMethod stopKeyGetter, int stopSearchOperator,
1:eac0369: 		boolean sameStartStopPosition,
1:eac0369: 		Qualifier[][] qualifiers,
1:eac0369: 		String tableName,
1:c7248d5: 		String userSuppliedOptimizerOverrides,
1:eac0369: 		String indexName,
1:eac0369: 		boolean isConstraint,
1:eac0369: 		boolean forUpdate,
1:eac0369: 		int colRefItem,
1:eac0369: 		int lockMode,
1:eac0369: 		boolean tableLocked,
1:109cb26: 		int isolationLevel,		// ignored
1:eac0369: 		int rowsPerRead,
1:eac0369: 		boolean oneRowScan,
1:eac0369: 		double optimizerEstimatedRowCount,
1:eac0369: 		double optimizerEstimatedCost,
1:eac0369: 		String parentResultSetId, 
1:eac0369: 		long fkIndexConglomId,
1:eac0369: 		int fkColArrayItem,
1:eac0369: 		int rltItem
1:eac0369: 		)	throws StandardException
1:eac0369: 	{
1:959fef2: 		super(activation, resultSetNumber, resultRowTemplate,
1:109cb26: 			  lockMode, tableLocked,
1:109cb26: 			  //Because the scan for the tables in this result set are done
1:109cb26: 			  //internally for delete cascades, isolation should be set to
1:109cb26: 			  //REPEATABLE READ irrespective what the user level isolation
1:109cb26: 			  //level is.
1:109cb26: 			  TransactionController.ISOLATION_REPEATABLE_READ,
1:2ec36d1:               colRefItem,
1:109cb26: 			  optimizerEstimatedRowCount, optimizerEstimatedCost);
1:eac0369: 
1:eac0369: 		this.conglomId = conglomId;
1:eac0369: 
1:eac0369: 		/* Static info created at compile time and can be shared across
1:eac0369: 		 * instances of the plan.
1:eac0369: 		 * Dynamic info created on 1st instantiation of this ResultSet as
1:eac0369: 		 * it cannot be shared.
1:eac0369: 		 */
1:eac0369:         this.heapScoci = scoci;
1:eac0369:         heapDcoci = activation.getTransactionController().getDynamicCompiledConglomInfo(conglomId);
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:a280beb:             // This ResultSet doesn't use start or stop keys, so expect them
1:a280beb:             // to be null.
1:a280beb:             SanityManager.ASSERT(startKeyGetter == null, "start key not null");
1:a280beb:             SanityManager.ASSERT(stopKeyGetter == null, "stop key not null");
4:eac0369: 		}
1:eac0369: 
1:eac0369: 		this.startSearchOperator = startSearchOperator;
1:eac0369: 		this.stopSearchOperator = stopSearchOperator;
1:eac0369: 		this.qualifiers = qualifiers;
1:eac0369: 		this.tableName = tableName;
1:c7248d5: 		this.userSuppliedOptimizerOverrides = userSuppliedOptimizerOverrides;
1:eac0369: 		this.indexName = "On Foreign Key";  // RESOLVE , get actual indexName;
1:eac0369: 		this.isConstraint = isConstraint;
1:eac0369: 		this.forUpdate = forUpdate;
1:eac0369: 		this.rowsPerRead = rowsPerRead;
1:eac0369: 		this.oneRowScan = oneRowScan;
1:eac0369: 		
1:801cf0d:         runTimeStatisticsOn = (activation.getLanguageConnectionContext().getRunTimeStatisticsMode());
1:eac0369: 
1:eac0369: 		tc = activation.getTransactionController();
1:eac0369: 		//values required to scan the forein key index.
1:eac0369: 		indexDcoci = tc.getDynamicCompiledConglomInfo(fkIndexConglomId);
1:eac0369: 		indexScoci = tc.getStaticCompiledConglomInfo(fkIndexConglomId);
1:eac0369: 		
1:eac0369: 		this.parentResultSetId = parentResultSetId;
1:eac0369: 		this.fkColArray = (int[])(activation.getPreparedStatement().
1:eac0369: 						getSavedObject(fkColArrayItem));
1:eac0369: 
1:eac0369: 		this.rowLocation = (RowLocation)(activation.getPreparedStatement().
1:eac0369: 										 getSavedObject(rltItem));
1:eac0369: 		numFkColumns = fkColArray.length;
1:eac0369: 		indexQualifierRow = new IndexRow(numFkColumns);
1:7008b63: 		recordConstructorTime();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get a scan controller positioned using searchRow as
1:eac0369: 	 * the start/stop position.  The assumption is that searchRow
1:eac0369: 	 * is of the same format as the index being opened. 
1:eac0369: 	 * @param searchRow			the row to match
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 
1:eac0369: 	private ScanController openIndexScanController(ExecRow searchRow)	throws StandardException
1:eac0369: 	{
1:eac0369: 		setupQualifierRow(searchRow);
1:eac0369: 		indexSC = tc.openCompiledScan(
1:eac0369: 					  false,                       				// hold 
1:eac0369: 					  TransactionController.OPENMODE_FORUPDATE, // update only
1:eac0369:                       lockMode,									// lock Mode
1:eac0369: 					  isolationLevel,                           //isolation level
1:eac0369:                       (FormatableBitSet)null, 							// retrieve all fields
1:eac0369:                       indexQualifierRow.getRowArray(),    		// startKeyValue
1:eac0369:                       ScanController.GE,            			// startSearchOp
1:eac0369:                       null,                         			// qualifier
1:eac0369:                       indexQualifierRow.getRowArray(),    		// stopKeyValue
1:eac0369:                       ScanController.GT,             			// stopSearchOp 
1:eac0369: 					  indexScoci,
1:eac0369: 					  indexDcoci
1:eac0369:                       );
1:eac0369: 
1:eac0369: 		return indexSC;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	
1:eac0369: 	//reopen the scan with a differnt search row
1:eac0369: 	private void reopenIndexScanController(ExecRow searchRow)	throws   StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		setupQualifierRow(searchRow);
1:eac0369: 		indexSC.reopenScan(
1:eac0369: 						indexQualifierRow.getRowArray(),    	// startKeyValue
1:eac0369: 						ScanController.GE,            		// startSearchOp
1:eac0369: 						null,                         		// qualifier
1:eac0369: 						indexQualifierRow.getRowArray(), 		// stopKeyValue
1:eac0369: 						ScanController.GT             		// stopSearchOp 
1:eac0369: 						);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	
1:eac0369: 	/*
1:eac0369: 	** Do reference copy for the qualifier row.  No cloning.
1:eac0369: 	** So we cannot get another row until we are done with
1:eac0369: 	** this one.
1:eac0369: 	*/
1:eac0369: 	private void setupQualifierRow(ExecRow searchRow)
1:eac0369: 	{
1:801cf0d:         @SuppressWarnings("MismatchedReadAndWriteOfArray")
1:eac0369: 		Object[] indexColArray = indexQualifierRow.getRowArray();
1:eac0369: 		Object[] baseColArray = searchRow.getRowArray();
1:eac0369: 
1:eac0369: 		for (int i = 0; i < numFkColumns; i++)
1:eac0369: 		{
1:eac0369: 			indexColArray[i] = baseColArray[fkColArray[i] - 1];
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	private void  openIndexScan(ExecRow searchRow) throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		if (indexSC == null)
1:eac0369: 		{
1:eac0369: 			indexSC =  openIndexScanController(searchRow);
1:eac0369: 			//create a template for the index row
1:eac0369: 			indexRow = indexQualifierRow.getClone();
1:854dd10: 			indexRow.setColumn(numFkColumns + 1, rowLocation.cloneValue(false));
1:eac0369: 
2:eac0369: 		}else
1:eac0369: 		{
1:eac0369: 			reopenIndexScanController(searchRow);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Fetch a row from the index scan.
1:eac0369: 
1:eac0369: 	  @return The row or null. Note that the next call to fetch will
1:eac0369: 	  replace the columns in the returned row.
1:eac0369: 	  @exception StandardException Ooops
1:eac0369: 	  */
1:eac0369: 	private ExecRow fetchIndexRow()
1:eac0369: 		 throws StandardException
1:eac0369: 	{ 
1:d3a4f64: 		if (!indexSC.fetchNext(indexRow.getRowArray()))
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 		return indexRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Fetch the base row corresponding to the current index row
1:eac0369: 
1:eac0369: 	  @return The base row row or null.
1:eac0369: 	  @exception StandardException Ooops
1:eac0369: 	  */
1:eac0369: 	private ExecRow fetchBaseRow()
1:eac0369: 		 throws StandardException
1:eac0369: 	{ 
1:eac0369: 
1:eac0369: 		if (currentRow == null)
1:eac0369: 		{
1:eac0369: 			currentRow =
1:49f3f24: 				getCompactRow(candidate, accessedCols, isKeyed);
1:eac0369: 		} 
1:eac0369: 
1:eac0369: 		baseRowLocation = (RowLocation) indexRow.getColumn(indexRow.getRowArray().length);
1:eac0369: 		boolean base_row_exists = 
1:eac0369:             heapCC.fetch(
1:eac0369:                 baseRowLocation, candidate.getRowArray(),accessedCols);
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(base_row_exists, "base row disappeared.");
1:eac0369:         }
1:eac0369: 
1:eac0369: 		return currentRow;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 
1:eac0369: 	ExecRow searchRow = null; //the current row we are searching for
1:eac0369: 
1:eac0369: 	//this function will return an index row on dependent table 
1:eac0369: 	public ExecRow	getNextRowCore() throws StandardException 
1:eac0369: 	{
1:eac0369: 		
1:2a4654b: 		if( isXplainOnlyMode() )
1:2a4654b: 			return null;
1:2a4654b: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		if (searchRow == null)
1:eac0369: 		{
1:eac0369: 			//we are searching for a row first time
1:eac0369: 			if((searchRow = getNextParentRow())!=null)
1:eac0369: 			   openIndexScan(searchRow);
1:eac0369: 		}	
1:eac0369: 	
1:eac0369: 		ExecRow currentIndexRow = null;
1:eac0369: 	    while(searchRow != null)
1:eac0369: 		{
1:eac0369: 			//get if the current search row has  more 
1:eac0369: 			//than one row in the dependent tables
1:eac0369: 			currentIndexRow = fetchIndexRow();
1:eac0369: 	
1:eac0369: 			if(currentIndexRow !=null)
1:eac0369: 				break;
1:eac0369: 			if((searchRow = getNextParentRow())!=null)
1:eac0369: 			   openIndexScan(searchRow);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		nextTime += getElapsedMillis(beginTime);
1:eac0369: 		if(currentIndexRow!= null)
1:eac0369: 		{
1:eac0369: 			rowsSeen++;
1:eac0369: 			return fetchBaseRow();
1:eac0369: 		}else
1:eac0369: 		{
1:eac0369: 			return currentIndexRow;
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	//this function will return the rows from the parent result sets 
1:eac0369: 	private ExecRow	getNextParentRow() throws StandardException 
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		ExecRow cRow;
1:eac0369: 		TemporaryRowHolder rowHolder;
1:eac0369: 
1:eac0369: 		if(sourceOpened[sArrayIndex] == 0)
1:eac0369: 		{
1:eac0369: 			rowHolder = sourceRowHolders[sArrayIndex];
1:eac0369: 			source = (TemporaryRowHolderResultSet)rowHolder.getResultSet();
1:eac0369: 			source.open(); //open the cursor result set
1:eac0369: 			sourceOpened[sArrayIndex] = -1;
1:eac0369: 			sourceResultSets[sArrayIndex] = source;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if(sourceOpened[sArrayIndex] == 1)
1:eac0369: 		{
1:eac0369: 			source = sourceResultSets[sArrayIndex];
1:eac0369: 			source.reStartScan(sourceRowHolders[sArrayIndex].getTemporaryConglomId(),
1:eac0369: 							  sourceRowHolders[sArrayIndex].getPositionIndexConglomId());
1:eac0369: 			sourceOpened[sArrayIndex] = -1;
1:eac0369: 			
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if(sVector.size() > sourceRowHolders.length)
1:eac0369: 		{
1:eac0369: 			addNewSources();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		cRow = source.getNextRow();
1:eac0369: 		while(cRow == null &&  (sArrayIndex+1) <  sourceRowHolders.length)
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			//opening the next source;
1:eac0369: 			sArrayIndex++;
1:eac0369: 			if(sourceOpened[sArrayIndex] == 0)
1:eac0369: 			{
1:eac0369: 				rowHolder = sourceRowHolders[sArrayIndex];
1:eac0369: 				source = (TemporaryRowHolderResultSet)rowHolder.getResultSet();
1:eac0369: 				source.open(); //open the cursor result set
1:eac0369: 				sourceOpened[sArrayIndex] = -1;
1:eac0369: 				sourceResultSets[sArrayIndex] = source;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if(sourceOpened[sArrayIndex] == 1)
1:eac0369: 			{
1:eac0369: 				source = sourceResultSets[sArrayIndex];
1:eac0369: 				source.reStartScan(sourceRowHolders[sArrayIndex].getTemporaryConglomId(),
1:eac0369: 								  sourceRowHolders[sArrayIndex].getPositionIndexConglomId());
1:eac0369: 				sourceOpened[sArrayIndex] = -1;
1:eac0369: 			}
1:eac0369: 		
1:eac0369: 			cRow = source.getNextRow();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if(cRow == null)
1:eac0369: 		{
1:eac0369: 			//which means no source has any more  currently rows.
1:eac0369: 			sArrayIndex = 0;
1:eac0369: 			//mark all the sources to  restartScan.
1:eac0369: 			for(int i =0 ; i < sourceOpened.length ; i++)
1:eac0369: 				sourceOpened[i] = 1;
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		return cRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Open the heap Conglomerate controller
1:eac0369: 	**
1:eac0369: 	** @param transaction controller will open one if null
1:eac0369: 	*/
1:eac0369: 	public ConglomerateController openHeapConglomerateController()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return tc.openCompiledConglomerate(
1:eac0369:                     false,
1:eac0369: 				    TransactionController.OPENMODE_FORUPDATE,
1:eac0369: 					lockMode,
1:eac0369: 					isolationLevel,
1:eac0369: 					heapScoci,
1:eac0369: 					heapDcoci);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Close the all the opens we did in this result set.
1:eac0369: 	  */
1:801cf0d:     @Override
1:eac0369: 	public void close()
1:eac0369:         throws StandardException
1:eac0369: 	{
1:801cf0d:         // save the information for the runtime statistics
1:eac0369: 		// This is where we get the scan properties for the reference index scans
1:eac0369: 		if (runTimeStatisticsOn)
1:eac0369: 		{
1:eac0369: 			startPositionString = printStartPosition();
1:eac0369: 			stopPositionString = printStopPosition();
1:eac0369: 			scanProperties = getScanProperties();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (indexSC != null) 
1:eac0369: 		{
1:eac0369: 			indexSC.close();
1:eac0369: 			indexSC = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if ( heapCC != null )
1:eac0369: 		{
1:eac0369: 			heapCC.close();
1:eac0369: 			heapCC = null;
1:eac0369: 		}
1:eac0369: 		if(isOpen)
1:eac0369: 		{
1:eac0369: 			source.close();  
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		closeTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:801cf0d:     @Override
1:eac0369: 	public void	finish() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (source != null)
1:eac0369: 			source.finish();
1:eac0369: 		finishAndRTS();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void openCore() throws StandardException
1:eac0369: 	{
1:109cb26: 		initIsolationLevel();
1:eac0369: 		sVector = activation.getParentResultSet(parentResultSetId);
1:eac0369: 		int size = sVector.size();
1:eac0369: 		sourceRowHolders = new TemporaryRowHolder[size];
1:eac0369: 		sourceOpened = new int[size];
1:eac0369: 		sourceResultSets = new TemporaryRowHolderResultSet[size];
1:eac0369: 		for(int i = 0 ; i < size ; i++)
1:eac0369: 		{
1:801cf0d:             sourceRowHolders[i] = sVector.elementAt(i);
1:eac0369: 			sourceOpened[i] = 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		//open the table scan
1:eac0369: 		heapCC = openHeapConglomerateController();
1:eac0369: 		numOpens++;
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	private void addNewSources()
1:eac0369: 	{
1:eac0369: 		int size = sVector.size();
1:eac0369: 		TemporaryRowHolder[] tsourceRowHolders = new TemporaryRowHolder[size];
1:eac0369: 		int[] tsourceOpened = new int[size];
1:eac0369: 		TemporaryRowHolderResultSet[] tsourceResultSets = new TemporaryRowHolderResultSet[size];
1:eac0369: 		
1:eac0369: 		//copy the source we have now
1:eac0369: 		System.arraycopy(sourceRowHolders, 0, tsourceRowHolders, 0 , sourceRowHolders.length);
1:eac0369: 		System.arraycopy(sourceOpened, 0, tsourceOpened , 0 ,sourceOpened.length);
1:eac0369: 		System.arraycopy(sourceResultSets , 0, tsourceResultSets ,0 ,sourceResultSets.length);
1:eac0369: 
1:eac0369: 		//copy the new sources
1:eac0369: 		for(int i = sourceRowHolders.length; i < size ; i++)
1:eac0369: 		{
1:801cf0d:             tsourceRowHolders[i] = sVector.elementAt(i);
1:eac0369: 			tsourceOpened[i] = 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		sourceRowHolders = tsourceRowHolders;
1:eac0369: 		sourceOpened = tsourceOpened ;
1:eac0369: 		sourceResultSets = tsourceResultSets;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Can we get instantaneous locks when getting share row
1:eac0369: 	 * locks at READ COMMITTED.
1:eac0369: 	 */
1:109cb26: 	boolean canGetInstantaneousLocks()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public long getTimeSpent(int type)
1:eac0369: 	{
1:eac0369: 		return constructorTime + openTime + nextTime + closeTime;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	//Cursor result set information.
1:eac0369: 	public RowLocation getRowLocation() throws StandardException
1:eac0369: 	{
1:eac0369: 		return baseRowLocation;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public ExecRow getCurrentRow() throws StandardException 
1:eac0369: 	{
1:eac0369: 		return currentRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public Properties getScanProperties()
1:eac0369: 	{
1:eac0369: 		if (scanProperties == null)
1:eac0369: 		{
1:eac0369: 			scanProperties = new Properties();
1:eac0369: 		}
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			if (indexSC != null)
1:eac0369: 			{
1:eac0369: 				indexSC.getScanInfo().getAllScanInfo(scanProperties);
1:eac0369: 				/* Did we get a coarser lock due to
1:eac0369: 				 * a covering lock, lock escalation
1:eac0369: 				 * or configuration?
1:eac0369: 				 */
1:eac0369: 				coarserLock = indexSC.isTableLocked() && 
1:eac0369: 					(lockMode == TransactionController.MODE_RECORD);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		catch(StandardException se)
1:eac0369: 		{
1:eac0369: 				// ignore
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return scanProperties;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String printStartPosition()
1:eac0369: 	{
1:eac0369: 		return printPosition(ScanController.GE, indexQualifierRow);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String printStopPosition()
1:eac0369: 	{
1:eac0369: 		return printPosition(ScanController.GT, indexQualifierRow);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return a start or stop positioner as a String.
1:eac0369: 	 *
1:eac0369: 	 * If we already generated the information, then use
1:eac0369: 	 * that.  Otherwise, invoke the activation to get it.
1:eac0369: 	 */
1:eac0369: 	private String printPosition(int searchOperator, ExecIndexRow positioner)
1:eac0369: 	{
1:eac0369: 		String output = "";
1:eac0369: 
1:801cf0d:         String searchOp;
1:eac0369: 		switch (searchOperator)
1:eac0369: 		{
1:eac0369: 			case ScanController.GE:
1:eac0369: 				searchOp = ">=";
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			case ScanController.GT:
1:eac0369: 				searchOp = ">";
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			default:
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT("Unknown search operator " +
1:eac0369: 												searchOperator);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// NOTE: This does not have to be internationalized because
1:eac0369: 				// this code should never be reached.
1:eac0369: 				searchOp = "unknown value (" + searchOperator + ")";
1:eac0369: 				break;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if(positioner !=null)
1:eac0369: 		{
1:eac0369: 			output = output + "\t" +
1:eac0369: 				MessageService.getTextMessage(
1:eac0369: 										  SQLState.LANG_POSITIONER,
1:eac0369: 										  searchOp,
1:eac0369: 										  String.valueOf(positioner.nColumns())) +
1:eac0369: 				"\n";
1:eac0369: 
1:eac0369: 			output = output + "\t" +
1:eac0369: 				MessageService.getTextMessage(
1:eac0369: 											  SQLState.LANG_ORDERED_NULL_SEMANTICS) +
1:eac0369: 				"\n";
1:c9a1206: 			boolean colSeen = false;
1:eac0369: 			for (int position = 0; position < positioner.nColumns(); position++)
1:eac0369: 			{
1:eac0369: 				if (positioner.areNullsOrdered(position))
1:eac0369: 				{
1:eac0369: 					output = output + position + " ";
1:c9a1206: 					colSeen = true;
1:c9a1206: 				}
1:c9a1206: 
1:c9a1206: 				if (colSeen && position == positioner.nColumns() - 1) {
1:c9a1206: 					output = output +  "\n";
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	
1:c9a1206: 		return output;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return an array of Qualifiers as a String
1:eac0369: 	 */
1:eac0369: 	public String printQualifiers()
1:eac0369: 	{
1:eac0369: 		//There are no qualifiers in thie result set for index scans.
2:eac0369: 		String idt = "";
1:eac0369: 		return idt + MessageService.getTextMessage(SQLState.LANG_NONE);
1:eac0369: 	}
1:b197ffa: 
1:eac0369: }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:2a4654b
/////////////////////////////////////////////////////////////////////////
1: 		if( isXplainOnlyMode() )
1: 			return null;
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  * the source table materialized temporary result set.
1:  * Scanning of foreign key index gives us the
1: @SuppressWarnings("UseOfObsoleteCollectionType")
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     Vector<TemporaryRowHolder> sVector;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         runTimeStatisticsOn = (activation.getLanguageConnectionContext().getRunTimeStatisticsMode());
/////////////////////////////////////////////////////////////////////////
1:         @SuppressWarnings("MismatchedReadAndWriteOfArray")
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:         // save the information for the runtime statistics
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             sourceRowHolders[i] = sVector.elementAt(i);
/////////////////////////////////////////////////////////////////////////
1:             tsourceRowHolders[i] = sVector.elementAt(i);
/////////////////////////////////////////////////////////////////////////
1:         String searchOp;
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
1: 			boolean colSeen = false;
1: 					colSeen = true;
1: 				}
1: 
1: 				if (colSeen && position == positioner.nColumns() - 1) {
1: 					output = output +  "\n";
1: 		return output;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:b197ffa
/////////////////////////////////////////////////////////////////////////
0: import org.w3c.dom.Element;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:959fef2
/////////////////////////////////////////////////////////////////////////
1: 		int resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
1: 		super(activation, resultSetNumber, resultRowTemplate,
/////////////////////////////////////////////////////////////////////////
commit:a280beb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:             // This ResultSet doesn't use start or stop keys, so expect them
1:             // to be null.
1:             SanityManager.ASSERT(startKeyGetter == null, "start key not null");
1:             SanityManager.ASSERT(stopKeyGetter == null, "stop key not null");
commit:109cb26
/////////////////////////////////////////////////////////////////////////
1: class DependentResultSet extends ScanResultSet implements CursorResultSet
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		int isolationLevel,		// ignored
/////////////////////////////////////////////////////////////////////////
0: 		super(activation, resultSetNumber, resultRowAllocator,
1: 			  lockMode, tableLocked,
1: 			  //Because the scan for the tables in this result set are done
1: 			  //internally for delete cascades, isolation should be set to
1: 			  //REPEATABLE READ irrespective what the user level isolation
1: 			  //level is.
1: 			  TransactionController.ISOLATION_REPEATABLE_READ,
1: 			  optimizerEstimatedRowCount, optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		initIsolationLevel();
/////////////////////////////////////////////////////////////////////////
1: 	boolean canGetInstantaneousLocks()
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:854dd10
/////////////////////////////////////////////////////////////////////////
1: 			indexRow.setColumn(numFkColumns + 1, rowLocation.cloneValue(false));
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:2ec36d1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:               colRefItem,
/////////////////////////////////////////////////////////////////////////
commit:49f3f24
/////////////////////////////////////////////////////////////////////////
1: 				getCompactRow(candidate, accessedCols, isKeyed);
commit:7008b63
/////////////////////////////////////////////////////////////////////////
1: 		recordConstructorTime();
commit:b31849d
/////////////////////////////////////////////////////////////////////////
1: import java.util.Vector;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.types.RowLocation;
commit:f77f36d
/////////////////////////////////////////////////////////////////////////
0: class DependentResultSet extends NoPutResultSetImpl implements CursorResultSet
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	DependentResultSet(
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d3a4f64
/////////////////////////////////////////////////////////////////////////
1: 		if (!indexSC.fetchNext(indexRow.getRowArray()))
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.DependentResultSet
1: 
0:    Copyright 2002, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ScanQualifier;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.types.RefDataValue;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
0: import java.util.Vector;
1: import java.util.Properties;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: 
1: 
1: 
1: /**
1:  * DependentResultSet should be used by only ON DELETE CASCADE/ON DELETE SET NULL ref
1:  * actions implementation to gather the rows from the dependent tables.  
1:  * Idea is to scan the foreign key index for the rows in 
0:  * the source table matelized temporary result set. Scanning of foreign key index gives us the 
1:  * rows that needs to be deleted on dependent tables. Using the row location 
1:  * we got from the index , base row is fetched.
1: */
0: public class DependentResultSet extends NoPutResultSetImpl implements CursorResultSet
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
1: 
1: 
1: 	ConglomerateController heapCC;
1: 	RowLocation	baseRowLocation;  // base row location we got from the index
1: 	ExecRow indexRow; //templeate to fetch the index row
1: 	IndexRow indexQualifierRow; // template for the index qualifier row
1: 	ScanController indexSC;  // Index Scan Controller
1: 	StaticCompiledOpenConglomInfo  indexScoci;
1: 	DynamicCompiledOpenConglomInfo indexDcoci;
1: 	int numFkColumns;
1: 	boolean isOpen; // source result set is opened or not
0: 	boolean deferred;
1: 	TemporaryRowHolderResultSet source; // Current parent table result set
1: 	TransactionController tc;
1: 	String parentResultSetId;
1: 	int[] fkColArray;
1: 	RowLocation rowLocation;
1:     TemporaryRowHolder[] sourceRowHolders;
1: 	TemporaryRowHolderResultSet[] sourceResultSets;
1: 	int[] sourceOpened;
1: 	int    sArrayIndex;
0: 	Vector sVector;
1: 
1: 
1:     protected ScanController scanController;
1: 	protected boolean		scanControllerOpened;
1: 	protected boolean		isKeyed;
1: 	protected boolean		firstScan = true;
1: 	protected ExecIndexRow	startPosition;
1: 	protected ExecIndexRow	stopPosition;
0: 	protected	ExecRow		candidate;
1: 
1:     // set in constructor and not altered during
1:     // life of object.
1: 	protected long conglomId;
1:     protected DynamicCompiledOpenConglomInfo heapDcoci;
1:     protected StaticCompiledOpenConglomInfo heapScoci;
0: 	protected GeneratedMethod resultRowAllocator;
0: 	protected GeneratedMethod startKeyGetter;
1: 	protected int startSearchOperator;
0: 	protected GeneratedMethod stopKeyGetter;
1: 	protected int stopSearchOperator;
1: 	protected Qualifier[][] qualifiers;
0: 	protected GeneratedMethod closeCleanup;
0: 	public String tableName;
0: 	public String indexName;
1: 	protected boolean runTimeStatisticsOn;
0: 	protected FormatableBitSet accessedCols;
1: 	public int rowsPerRead;
1: 	public boolean forUpdate;
0: 	private boolean sameStartStopPosition;
0: 	private boolean nextDone;
0: 	public int isolationLevel;
0: 	public int lockMode;
1: 
1: 
1: 	// Run time statistics
1: 	private Properties scanProperties;
1: 	public String startPositionString;
1: 	public String stopPositionString;
1: 	public boolean isConstraint;
1: 	public boolean coarserLock;
1: 	public boolean oneRowScan;
1: 	protected long	rowsThisScan;
0: 	private long estimatedRowCount;
1: 
1: 	//
1:     // class interface
1:     //
0: 	public DependentResultSet(
1: 		long conglomId,
1: 		StaticCompiledOpenConglomInfo scoci, 
1: 		Activation activation, 
0: 		GeneratedMethod resultRowAllocator, 
1: 		int resultSetNumber,
1: 		GeneratedMethod startKeyGetter, int startSearchOperator,
1: 		GeneratedMethod stopKeyGetter, int stopSearchOperator,
1: 		boolean sameStartStopPosition,
1: 		Qualifier[][] qualifiers,
1: 		String tableName,
1: 		String indexName,
1: 		boolean isConstraint,
1: 		boolean forUpdate,
1: 		int colRefItem,
1: 		int lockMode,
1: 		boolean tableLocked,
0: 		int isolationLevel,
1: 		int rowsPerRead,
1: 		boolean oneRowScan,
1: 		double optimizerEstimatedRowCount,
1: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup,
1: 		String parentResultSetId, 
1: 		long fkIndexConglomId,
1: 		int fkColArrayItem,
1: 		int rltItem
1: 		)	throws StandardException
1: 	{
0: 		super(activation,
0: 				resultSetNumber,
0: 				optimizerEstimatedRowCount,
0: 				optimizerEstimatedCost);
1: 
1: 		this.conglomId = conglomId;
1: 
1: 		/* Static info created at compile time and can be shared across
1: 		 * instances of the plan.
1: 		 * Dynamic info created on 1st instantiation of this ResultSet as
1: 		 * it cannot be shared.
1: 		 */
1:         this.heapScoci = scoci;
1:         heapDcoci = activation.getTransactionController().getDynamicCompiledConglomInfo(conglomId);
1: 
1: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT( activation!=null, "table scan must get activation context");
0: 			SanityManager.ASSERT( resultRowAllocator!= null, "table scan must get row allocator");
0: 			if (sameStartStopPosition)
1: 			{
0: 				SanityManager.ASSERT(stopKeyGetter == null,
0: 					"stopKeyGetter expected to be null when sameStartStopPosition is true");
1: 			}
1: 		}
1: 
0:         this.resultRowAllocator = resultRowAllocator;
1: 
0: 		this.startKeyGetter = startKeyGetter;
1: 		this.startSearchOperator = startSearchOperator;
0: 		this.stopKeyGetter = stopKeyGetter;
1: 		this.stopSearchOperator = stopSearchOperator;
0: 		this.sameStartStopPosition = sameStartStopPosition;
1: 		this.qualifiers = qualifiers;
1: 		this.tableName = tableName;
1: 		this.indexName = "On Foreign Key";  // RESOLVE , get actual indexName;
1: 		this.isConstraint = isConstraint;
1: 		this.forUpdate = forUpdate;
1: 		this.rowsPerRead = rowsPerRead;
1: 		this.oneRowScan = oneRowScan;
1: 
0: 		// retrieve the valid column list from
0: 		// the saved objects, if it exists
0: 		this.accessedCols = null;
0: 		if (colRefItem != -1)
1: 		{
0: 			this.accessedCols = (FormatableBitSet)(activation.getPreparedStatement().
0: 						getSavedObject(colRefItem));
1: 		}
1: 		
1: 		
0: 		//unless the table locking is specified in sys.systables,
0: 		//irrespective of what optimizer says choose record level 
0: 		//locking  for dependent result sets.
0: 		if (! tableLocked)
1: 		{
0: 			this.lockMode = TransactionController.MODE_RECORD;
1: 		}else
1: 		{
0: 			this.lockMode = lockMode;
1: 		}
1: 
1: 
0: 		//Because the scan for the tables in this result set are done
0: 		//internally for delete cascades, isolation should be set to
0: 		//REPEATABLE READ irrespective what the user level isolation level is.
0: 		this.isolationLevel = TransactionController.ISOLATION_REPEATABLE_READ;
1: 
0: 		this.closeCleanup = closeCleanup;
1: 
0: 		runTimeStatisticsOn = (activation != null &&
0: 							   activation.getLanguageConnectionContext().getRunTimeStatisticsMode());
1: 
0: 		/* Only call row allocators once */
0: 		candidate = (ExecRow) resultRowAllocator.invoke(activation);
1: 		
1: 
1: 		tc = activation.getTransactionController();
1: 		//values required to scan the forein key index.
1: 		indexDcoci = tc.getDynamicCompiledConglomInfo(fkIndexConglomId);
1: 		indexScoci = tc.getStaticCompiledConglomInfo(fkIndexConglomId);
1: 		
1: 		this.parentResultSetId = parentResultSetId;
1: 		this.fkColArray = (int[])(activation.getPreparedStatement().
1: 						getSavedObject(fkColArrayItem));
1: 
1: 		this.rowLocation = (RowLocation)(activation.getPreparedStatement().
1: 										 getSavedObject(rltItem));
1: 		numFkColumns = fkColArray.length;
1: 		indexQualifierRow = new IndexRow(numFkColumns);
0: 		constructorTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 
1: 	/**
1: 	 * Get a scan controller positioned using searchRow as
1: 	 * the start/stop position.  The assumption is that searchRow
1: 	 * is of the same format as the index being opened. 
1: 	 * @param searchRow			the row to match
1: 	 * @exception StandardException on error
1: 	 */
1: 
1: 
1: 	private ScanController openIndexScanController(ExecRow searchRow)	throws StandardException
1: 	{
1: 		setupQualifierRow(searchRow);
1: 		indexSC = tc.openCompiledScan(
1: 					  false,                       				// hold 
1: 					  TransactionController.OPENMODE_FORUPDATE, // update only
1:                       lockMode,									// lock Mode
1: 					  isolationLevel,                           //isolation level
1:                       (FormatableBitSet)null, 							// retrieve all fields
1:                       indexQualifierRow.getRowArray(),    		// startKeyValue
1:                       ScanController.GE,            			// startSearchOp
1:                       null,                         			// qualifier
1:                       indexQualifierRow.getRowArray(),    		// stopKeyValue
1:                       ScanController.GT,             			// stopSearchOp 
1: 					  indexScoci,
1: 					  indexDcoci
1:                       );
1: 
1: 		return indexSC;
1: 
1: 	}
1: 
1: 	
1: 	//reopen the scan with a differnt search row
1: 	private void reopenIndexScanController(ExecRow searchRow)	throws   StandardException
1: 	{
1: 
1: 		setupQualifierRow(searchRow);
1: 		indexSC.reopenScan(
1: 						indexQualifierRow.getRowArray(),    	// startKeyValue
1: 						ScanController.GE,            		// startSearchOp
1: 						null,                         		// qualifier
1: 						indexQualifierRow.getRowArray(), 		// stopKeyValue
1: 						ScanController.GT             		// stopSearchOp 
1: 						);
1: 	}
1: 
1: 	
1: 	/*
1: 	** Do reference copy for the qualifier row.  No cloning.
1: 	** So we cannot get another row until we are done with
1: 	** this one.
1: 	*/
1: 	private void setupQualifierRow(ExecRow searchRow)
1: 	{
1: 		Object[] indexColArray = indexQualifierRow.getRowArray();
1: 		Object[] baseColArray = searchRow.getRowArray();
1: 
1: 		for (int i = 0; i < numFkColumns; i++)
1: 		{
1: 			indexColArray[i] = baseColArray[fkColArray[i] - 1];
1: 		}
1: 	}
1: 
1: 
1: 	private void  openIndexScan(ExecRow searchRow) throws StandardException
1: 	{
1: 
1: 		if (indexSC == null)
1: 		{
1: 			indexSC =  openIndexScanController(searchRow);
1: 			//create a template for the index row
1: 			indexRow = indexQualifierRow.getClone();
0: 			indexRow.setColumn(numFkColumns + 1, rowLocation.getClone());	
1: 
1: 		}else
1: 		{
1: 			reopenIndexScanController(searchRow);
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 	  Fetch a row from the index scan.
1: 
1: 	  @return The row or null. Note that the next call to fetch will
1: 	  replace the columns in the returned row.
1: 	  @exception StandardException Ooops
1: 	  */
1: 	private ExecRow fetchIndexRow()
1: 		 throws StandardException
1: 	{ 
0: 		if (!indexSC.next())
1: 		{
1: 			return null;
1: 		}
0: 		indexSC.fetch(indexRow.getRowArray());
1: 		return indexRow;
1: 	}
1: 
1: 	
1: 
1: 	/**
1: 	  Fetch the base row corresponding to the current index row
1: 
1: 	  @return The base row row or null.
1: 	  @exception StandardException Ooops
1: 	  */
1: 	private ExecRow fetchBaseRow()
1: 		 throws StandardException
1: 	{ 
1: 
1: 		if (currentRow == null)
1: 		{
1: 			currentRow =
0: 				getCompactRow(candidate, accessedCols, (FormatableBitSet) null, isKeyed);
1: 		} 
1: 
1: 		baseRowLocation = (RowLocation) indexRow.getColumn(indexRow.getRowArray().length);
1: 		boolean base_row_exists = 
1:             heapCC.fetch(
1:                 baseRowLocation, candidate.getRowArray(),accessedCols);
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(base_row_exists, "base row disappeared.");
1:         }
1: 
1: 		return currentRow;
1: 	}
1: 	
1: 
1: 	ExecRow searchRow = null; //the current row we are searching for
1: 
1: 	//this function will return an index row on dependent table 
1: 	public ExecRow	getNextRowCore() throws StandardException 
1: 	{
1: 		
1: 		beginTime = getCurrentTimeMillis();
1: 		if (searchRow == null)
1: 		{
1: 			//we are searching for a row first time
1: 			if((searchRow = getNextParentRow())!=null)
1: 			   openIndexScan(searchRow);
1: 		}	
1: 	
1: 		ExecRow currentIndexRow = null;
1: 	    while(searchRow != null)
1: 		{
1: 			//get if the current search row has  more 
1: 			//than one row in the dependent tables
1: 			currentIndexRow = fetchIndexRow();
1: 	
1: 			if(currentIndexRow !=null)
1: 				break;
1: 			if((searchRow = getNextParentRow())!=null)
1: 			   openIndexScan(searchRow);
1: 		}
1: 
1: 		nextTime += getElapsedMillis(beginTime);
1: 		if(currentIndexRow!= null)
1: 		{
1: 			rowsSeen++;
1: 			return fetchBaseRow();
1: 		}else
1: 		{
1: 			return currentIndexRow;
1: 		}
1: 		
1: 		
1: 	}
1: 
1: 
1: 	//this function will return the rows from the parent result sets 
1: 	private ExecRow	getNextParentRow() throws StandardException 
1: 	{
1: 
1: 		ExecRow cRow;
1: 		TemporaryRowHolder rowHolder;
1: 
1: 		if(sourceOpened[sArrayIndex] == 0)
1: 		{
1: 			rowHolder = sourceRowHolders[sArrayIndex];
1: 			source = (TemporaryRowHolderResultSet)rowHolder.getResultSet();
1: 			source.open(); //open the cursor result set
1: 			sourceOpened[sArrayIndex] = -1;
1: 			sourceResultSets[sArrayIndex] = source;
1: 		}
1: 
1: 		if(sourceOpened[sArrayIndex] == 1)
1: 		{
1: 			source = sourceResultSets[sArrayIndex];
1: 			source.reStartScan(sourceRowHolders[sArrayIndex].getTemporaryConglomId(),
1: 							  sourceRowHolders[sArrayIndex].getPositionIndexConglomId());
1: 			sourceOpened[sArrayIndex] = -1;
1: 			
1: 		}
1: 
1: 		if(sVector.size() > sourceRowHolders.length)
1: 		{
1: 			addNewSources();
1: 		}
1: 
1: 		cRow = source.getNextRow();
1: 		while(cRow == null &&  (sArrayIndex+1) <  sourceRowHolders.length)
1: 		{
1: 
1: 			//opening the next source;
1: 			sArrayIndex++;
1: 			if(sourceOpened[sArrayIndex] == 0)
1: 			{
1: 				rowHolder = sourceRowHolders[sArrayIndex];
1: 				source = (TemporaryRowHolderResultSet)rowHolder.getResultSet();
1: 				source.open(); //open the cursor result set
1: 				sourceOpened[sArrayIndex] = -1;
1: 				sourceResultSets[sArrayIndex] = source;
1: 			}
1: 
1: 			if(sourceOpened[sArrayIndex] == 1)
1: 			{
1: 				source = sourceResultSets[sArrayIndex];
1: 				source.reStartScan(sourceRowHolders[sArrayIndex].getTemporaryConglomId(),
1: 								  sourceRowHolders[sArrayIndex].getPositionIndexConglomId());
1: 				sourceOpened[sArrayIndex] = -1;
1: 			}
1: 		
1: 			cRow = source.getNextRow();
1: 		}
1: 
1: 		if(cRow == null)
1: 		{
1: 			//which means no source has any more  currently rows.
1: 			sArrayIndex = 0;
1: 			//mark all the sources to  restartScan.
1: 			for(int i =0 ; i < sourceOpened.length ; i++)
1: 				sourceOpened[i] = 1;
1: 		}
1: 		
1: 		return cRow;
1: 	}
1: 
1: 
1: 
1: 	/*
1: 	** Open the heap Conglomerate controller
1: 	**
1: 	** @param transaction controller will open one if null
1: 	*/
1: 	public ConglomerateController openHeapConglomerateController()
1: 		throws StandardException
1: 	{
1: 		return tc.openCompiledConglomerate(
1:                     false,
1: 				    TransactionController.OPENMODE_FORUPDATE,
1: 					lockMode,
1: 					isolationLevel,
1: 					heapScoci,
1: 					heapDcoci);
1: 	}
1: 
1: 
1: 
1: 
1: 	/**
1: 	  Close the all the opens we did in this result set.
1: 	  */
1: 	public void close()
1:         throws StandardException
1: 	{
0: 		//save the information for the runtime stastics
1: 		// This is where we get the scan properties for the reference index scans
1: 		if (runTimeStatisticsOn)
1: 		{
1: 			startPositionString = printStartPosition();
1: 			stopPositionString = printStopPosition();
1: 			scanProperties = getScanProperties();
1: 		}
1: 
1: 		if (indexSC != null) 
1: 		{
1: 			indexSC.close();
1: 			indexSC = null;
1: 		}
1: 
1: 		if ( heapCC != null )
1: 		{
1: 			heapCC.close();
1: 			heapCC = null;
1: 		}
1: 		if(isOpen)
1: 		{
1: 			source.close();  
1: 		}
1: 		
1: 		closeTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	public void	finish() throws StandardException
1: 	{
1: 		if (source != null)
1: 			source.finish();
1: 		finishAndRTS();
1: 	}
1: 
1: 	public void openCore() throws StandardException
1: 	{
1: 
1: 		sVector = activation.getParentResultSet(parentResultSetId);
1: 		int size = sVector.size();
1: 		sourceRowHolders = new TemporaryRowHolder[size];
1: 		sourceOpened = new int[size];
1: 		sourceResultSets = new TemporaryRowHolderResultSet[size];
1: 		for(int i = 0 ; i < size ; i++)
1: 		{
0: 			sourceRowHolders[i] = (TemporaryRowHolder)sVector.elementAt(i);
1: 			sourceOpened[i] = 0;
1: 		}
1: 
1: 		//open the table scan
1: 		heapCC = openHeapConglomerateController();
1: 		numOpens++;
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 
1: 	private void addNewSources()
1: 	{
1: 		int size = sVector.size();
1: 		TemporaryRowHolder[] tsourceRowHolders = new TemporaryRowHolder[size];
1: 		int[] tsourceOpened = new int[size];
1: 		TemporaryRowHolderResultSet[] tsourceResultSets = new TemporaryRowHolderResultSet[size];
1: 		
1: 		//copy the source we have now
1: 		System.arraycopy(sourceRowHolders, 0, tsourceRowHolders, 0 , sourceRowHolders.length);
1: 		System.arraycopy(sourceOpened, 0, tsourceOpened , 0 ,sourceOpened.length);
1: 		System.arraycopy(sourceResultSets , 0, tsourceResultSets ,0 ,sourceResultSets.length);
1: 
1: 		//copy the new sources
1: 		for(int i = sourceRowHolders.length; i < size ; i++)
1: 		{
0: 			tsourceRowHolders[i] = (TemporaryRowHolder)sVector.elementAt(i);
1: 			tsourceOpened[i] = 0;
1: 		}
1: 
1: 		sourceRowHolders = tsourceRowHolders;
1: 		sourceOpened = tsourceOpened ;
1: 		sourceResultSets = tsourceResultSets;
1: 	}
1: 
1: 
1: 
1: 	/**
1: 	 * Can we get instantaneous locks when getting share row
1: 	 * locks at READ COMMITTED.
1: 	 */
0: 	private boolean canGetInstantaneousLocks()
1: 	{
1: 		return false;
1: 	}
1: 
1: 
1: 	public long getTimeSpent(int type)
1: 	{
1: 		return constructorTime + openTime + nextTime + closeTime;
1: 	}
1: 
1: 
1: 	//Cursor result set information.
1: 	public RowLocation getRowLocation() throws StandardException
1: 	{
1: 		return baseRowLocation;
1: 	}
1: 
1: 	public ExecRow getCurrentRow() throws StandardException 
1: 	{
1: 		return currentRow;
1: 	}
1: 
1: 
1: 	public Properties getScanProperties()
1: 	{
1: 		if (scanProperties == null)
1: 		{
1: 			scanProperties = new Properties();
1: 		}
1: 		try
1: 		{
1: 			if (indexSC != null)
1: 			{
1: 				indexSC.getScanInfo().getAllScanInfo(scanProperties);
1: 				/* Did we get a coarser lock due to
1: 				 * a covering lock, lock escalation
1: 				 * or configuration?
1: 				 */
1: 				coarserLock = indexSC.isTableLocked() && 
1: 					(lockMode == TransactionController.MODE_RECORD);
1: 			}
1: 		}
1: 		catch(StandardException se)
1: 		{
1: 				// ignore
1: 		}
1: 
1: 		return scanProperties;
1: 	}
1: 
1: 	public String printStartPosition()
1: 	{
1: 		return printPosition(ScanController.GE, indexQualifierRow);
1: 	}
1: 
1: 	public String printStopPosition()
1: 	{
1: 		return printPosition(ScanController.GT, indexQualifierRow);
1: 	}
1: 
1: 
1: 	/**
1: 	 * Return a start or stop positioner as a String.
1: 	 *
1: 	 * If we already generated the information, then use
1: 	 * that.  Otherwise, invoke the activation to get it.
1: 	 */
1: 	private String printPosition(int searchOperator, ExecIndexRow positioner)
1: 	{
1: 		String idt = "";
1: 		String output = "";
1: 
0: 		String searchOp = null;
1: 		switch (searchOperator)
1: 		{
1: 			case ScanController.GE:
1: 				searchOp = ">=";
1: 				break;
1: 
1: 			case ScanController.GT:
1: 				searchOp = ">";
1: 				break;
1: 
1: 			default:
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.THROWASSERT("Unknown search operator " +
1: 												searchOperator);
1: 				}
1: 
1: 				// NOTE: This does not have to be internationalized because
1: 				// this code should never be reached.
1: 				searchOp = "unknown value (" + searchOperator + ")";
1: 				break;
1: 		}
1: 
1: 		if(positioner !=null)
1: 		{
1: 			output = output + "\t" +
1: 				MessageService.getTextMessage(
1: 										  SQLState.LANG_POSITIONER,
1: 										  searchOp,
1: 										  String.valueOf(positioner.nColumns())) +
1: 				"\n";
1: 
1: 			output = output + "\t" +
1: 				MessageService.getTextMessage(
1: 											  SQLState.LANG_ORDERED_NULL_SEMANTICS) +
1: 				"\n";
1: 			for (int position = 0; position < positioner.nColumns(); position++)
1: 			{
1: 				if (positioner.areNullsOrdered(position))
1: 				{
1: 					output = output + position + " ";
1: 				}
1: 			}
1: 	
1: 		}
1: 	
0: 		return output + "\n";
1: 	}
1: 
1: 
1: 	/**
1: 	 * Return an array of Qualifiers as a String
1: 	 */
1: 	public String printQualifiers()
1: 	{
1: 		//There are no qualifiers in thie result set for index scans.
1: 		String idt = "";
1: 		return idt + MessageService.getTextMessage(SQLState.LANG_NONE);
1: 	}
1: }
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c7248d5
/////////////////////////////////////////////////////////////////////////
1: 	public String userSuppliedOptimizerOverrides;
/////////////////////////////////////////////////////////////////////////
1: 		String userSuppliedOptimizerOverrides,
/////////////////////////////////////////////////////////////////////////
1: 		this.userSuppliedOptimizerOverrides = userSuppliedOptimizerOverrides;
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ScanQualifier;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.types.RefDataValue;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
0: import java.util.Vector;
0: import java.util.Properties;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: 
0: 
0: 
0: /**
0:  * DependentResultSet should be used by only ON DELETE CASCADE/ON DELETE SET NULL ref
0:  * actions implementation to gather the rows from the dependent tables.  
0:  * Idea is to scan the foreign key index for the rows in 
0:  * the source table matelized temporary result set. Scanning of foreign key index gives us the 
0:  * rows that needs to be deleted on dependent tables. Using the row location 
0:  * we got from the index , base row is fetched.
0: */
0: public class DependentResultSet extends NoPutResultSetImpl implements CursorResultSet
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
0: 
0: 
0: 	ConglomerateController heapCC;
0: 	RowLocation	baseRowLocation;  // base row location we got from the index
0: 	ExecRow indexRow; //templeate to fetch the index row
0: 	IndexRow indexQualifierRow; // template for the index qualifier row
0: 	ScanController indexSC;  // Index Scan Controller
0: 	StaticCompiledOpenConglomInfo  indexScoci;
0: 	DynamicCompiledOpenConglomInfo indexDcoci;
0: 	int numFkColumns;
0: 	boolean isOpen; // source result set is opened or not
0: 	boolean deferred;
0: 	TemporaryRowHolderResultSet source; // Current parent table result set
0: 	TransactionController tc;
0: 	String parentResultSetId;
0: 	int[] fkColArray;
0: 	RowLocation rowLocation;
0:     TemporaryRowHolder[] sourceRowHolders;
0: 	TemporaryRowHolderResultSet[] sourceResultSets;
0: 	int[] sourceOpened;
0: 	int    sArrayIndex;
0: 	Vector sVector;
0: 
0: 
0:     protected ScanController scanController;
0: 	protected boolean		scanControllerOpened;
0: 	protected boolean		isKeyed;
0: 	protected boolean		firstScan = true;
0: 	protected ExecIndexRow	startPosition;
0: 	protected ExecIndexRow	stopPosition;
0: 	protected	ExecRow		candidate;
0: 
0:     // set in constructor and not altered during
0:     // life of object.
0: 	protected long conglomId;
0:     protected DynamicCompiledOpenConglomInfo heapDcoci;
0:     protected StaticCompiledOpenConglomInfo heapScoci;
0: 	protected GeneratedMethod resultRowAllocator;
0: 	protected GeneratedMethod startKeyGetter;
0: 	protected int startSearchOperator;
0: 	protected GeneratedMethod stopKeyGetter;
0: 	protected int stopSearchOperator;
0: 	protected Qualifier[][] qualifiers;
0: 	protected GeneratedMethod closeCleanup;
0: 	public String tableName;
0: 	public String indexName;
0: 	protected boolean runTimeStatisticsOn;
0: 	protected FormatableBitSet accessedCols;
0: 	public int rowsPerRead;
0: 	public boolean forUpdate;
0: 	private boolean sameStartStopPosition;
0: 	private boolean nextDone;
0: 	public int isolationLevel;
0: 	public int lockMode;
0: 
0: 
0: 	// Run time statistics
0: 	private Properties scanProperties;
0: 	public String startPositionString;
0: 	public String stopPositionString;
0: 	public boolean isConstraint;
0: 	public boolean coarserLock;
0: 	public boolean oneRowScan;
0: 	protected long	rowsThisScan;
0: 	private long estimatedRowCount;
0: 
0: 	//
0:     // class interface
0:     //
0: 	public DependentResultSet(
0: 		long conglomId,
0: 		StaticCompiledOpenConglomInfo scoci, 
0: 		Activation activation, 
0: 		GeneratedMethod resultRowAllocator, 
0: 		int resultSetNumber,
0: 		GeneratedMethod startKeyGetter, int startSearchOperator,
0: 		GeneratedMethod stopKeyGetter, int stopSearchOperator,
0: 		boolean sameStartStopPosition,
0: 		Qualifier[][] qualifiers,
0: 		String tableName,
0: 		String indexName,
0: 		boolean isConstraint,
0: 		boolean forUpdate,
0: 		int colRefItem,
0: 		int lockMode,
0: 		boolean tableLocked,
0: 		int isolationLevel,
0: 		int rowsPerRead,
0: 		boolean oneRowScan,
0: 		double optimizerEstimatedRowCount,
0: 		double optimizerEstimatedCost,
0: 		GeneratedMethod closeCleanup,
0: 		String parentResultSetId, 
0: 		long fkIndexConglomId,
0: 		int fkColArrayItem,
0: 		int rltItem
0: 		)	throws StandardException
0: 	{
0: 		super(activation,
0: 				resultSetNumber,
0: 				optimizerEstimatedRowCount,
0: 				optimizerEstimatedCost);
0: 
0: 		this.conglomId = conglomId;
0: 
0: 		/* Static info created at compile time and can be shared across
0: 		 * instances of the plan.
0: 		 * Dynamic info created on 1st instantiation of this ResultSet as
0: 		 * it cannot be shared.
0: 		 */
0:         this.heapScoci = scoci;
0:         heapDcoci = activation.getTransactionController().getDynamicCompiledConglomInfo(conglomId);
0: 
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT( activation!=null, "table scan must get activation context");
0: 			SanityManager.ASSERT( resultRowAllocator!= null, "table scan must get row allocator");
0: 			if (sameStartStopPosition)
0: 			{
0: 				SanityManager.ASSERT(stopKeyGetter == null,
0: 					"stopKeyGetter expected to be null when sameStartStopPosition is true");
0: 			}
0: 		}
0: 
0:         this.resultRowAllocator = resultRowAllocator;
0: 
0: 		this.startKeyGetter = startKeyGetter;
0: 		this.startSearchOperator = startSearchOperator;
0: 		this.stopKeyGetter = stopKeyGetter;
0: 		this.stopSearchOperator = stopSearchOperator;
0: 		this.sameStartStopPosition = sameStartStopPosition;
0: 		this.qualifiers = qualifiers;
0: 		this.tableName = tableName;
0: 		this.indexName = "On Foreign Key";  // RESOLVE , get actual indexName;
0: 		this.isConstraint = isConstraint;
0: 		this.forUpdate = forUpdate;
0: 		this.rowsPerRead = rowsPerRead;
0: 		this.oneRowScan = oneRowScan;
0: 
0: 		// retrieve the valid column list from
0: 		// the saved objects, if it exists
0: 		this.accessedCols = null;
0: 		if (colRefItem != -1)
0: 		{
0: 			this.accessedCols = (FormatableBitSet)(activation.getPreparedStatement().
0: 						getSavedObject(colRefItem));
0: 		}
0: 		
0: 		
0: 		//unless the table locking is specified in sys.systables,
0: 		//irrespective of what optimizer says choose record level 
0: 		//locking  for dependent result sets.
0: 		if (! tableLocked)
0: 		{
0: 			this.lockMode = TransactionController.MODE_RECORD;
0: 		}else
0: 		{
0: 			this.lockMode = lockMode;
0: 		}
0: 
0: 
0: 		//Because the scan for the tables in this result set are done
0: 		//internally for delete cascades, isolation should be set to
0: 		//REPEATABLE READ irrespective what the user level isolation level is.
0: 		this.isolationLevel = TransactionController.ISOLATION_REPEATABLE_READ;
0: 
0: 		this.closeCleanup = closeCleanup;
0: 
0: 		runTimeStatisticsOn = (activation != null &&
0: 							   activation.getLanguageConnectionContext().getRunTimeStatisticsMode());
0: 
0: 		/* Only call row allocators once */
0: 		candidate = (ExecRow) resultRowAllocator.invoke(activation);
0: 		
0: 
0: 		tc = activation.getTransactionController();
0: 		//values required to scan the forein key index.
0: 		indexDcoci = tc.getDynamicCompiledConglomInfo(fkIndexConglomId);
0: 		indexScoci = tc.getStaticCompiledConglomInfo(fkIndexConglomId);
0: 		
0: 		this.parentResultSetId = parentResultSetId;
0: 		this.fkColArray = (int[])(activation.getPreparedStatement().
0: 						getSavedObject(fkColArrayItem));
0: 
0: 		this.rowLocation = (RowLocation)(activation.getPreparedStatement().
0: 										 getSavedObject(rltItem));
0: 		numFkColumns = fkColArray.length;
0: 		indexQualifierRow = new IndexRow(numFkColumns);
0: 		constructorTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Get a scan controller positioned using searchRow as
0: 	 * the start/stop position.  The assumption is that searchRow
0: 	 * is of the same format as the index being opened. 
0: 	 * @param searchRow			the row to match
0: 	 * @exception StandardException on error
0: 	 */
0: 
0: 
0: 	private ScanController openIndexScanController(ExecRow searchRow)	throws StandardException
0: 	{
0: 		setupQualifierRow(searchRow);
0: 		indexSC = tc.openCompiledScan(
0: 					  false,                       				// hold 
0: 					  TransactionController.OPENMODE_FORUPDATE, // update only
0:                       lockMode,									// lock Mode
0: 					  isolationLevel,                           //isolation level
0:                       (FormatableBitSet)null, 							// retrieve all fields
0:                       indexQualifierRow.getRowArray(),    		// startKeyValue
0:                       ScanController.GE,            			// startSearchOp
0:                       null,                         			// qualifier
0:                       indexQualifierRow.getRowArray(),    		// stopKeyValue
0:                       ScanController.GT,             			// stopSearchOp 
0: 					  indexScoci,
0: 					  indexDcoci
0:                       );
0: 
0: 		return indexSC;
0: 
0: 	}
0: 
0: 	
0: 	//reopen the scan with a differnt search row
0: 	private void reopenIndexScanController(ExecRow searchRow)	throws   StandardException
0: 	{
0: 
0: 		setupQualifierRow(searchRow);
0: 		indexSC.reopenScan(
0: 						indexQualifierRow.getRowArray(),    	// startKeyValue
0: 						ScanController.GE,            		// startSearchOp
0: 						null,                         		// qualifier
0: 						indexQualifierRow.getRowArray(), 		// stopKeyValue
0: 						ScanController.GT             		// stopSearchOp 
0: 						);
0: 	}
0: 
0: 	
0: 	/*
0: 	** Do reference copy for the qualifier row.  No cloning.
0: 	** So we cannot get another row until we are done with
0: 	** this one.
0: 	*/
0: 	private void setupQualifierRow(ExecRow searchRow)
0: 	{
0: 		Object[] indexColArray = indexQualifierRow.getRowArray();
0: 		Object[] baseColArray = searchRow.getRowArray();
0: 
0: 		for (int i = 0; i < numFkColumns; i++)
0: 		{
0: 			indexColArray[i] = baseColArray[fkColArray[i] - 1];
0: 		}
0: 	}
0: 
0: 
0: 	private void  openIndexScan(ExecRow searchRow) throws StandardException
0: 	{
0: 
0: 		if (indexSC == null)
0: 		{
0: 			indexSC =  openIndexScanController(searchRow);
0: 			//create a template for the index row
0: 			indexRow = indexQualifierRow.getClone();
0: 			indexRow.setColumn(numFkColumns + 1, rowLocation.getClone());	
0: 
0: 		}else
0: 		{
0: 			reopenIndexScanController(searchRow);
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 	  Fetch a row from the index scan.
0: 
0: 	  @return The row or null. Note that the next call to fetch will
0: 	  replace the columns in the returned row.
0: 	  @exception StandardException Ooops
0: 	  */
0: 	private ExecRow fetchIndexRow()
0: 		 throws StandardException
0: 	{ 
0: 		if (!indexSC.next())
0: 		{
0: 			return null;
0: 		}
0: 		indexSC.fetch(indexRow.getRowArray());
0: 		return indexRow;
0: 	}
0: 
0: 	
0: 
0: 	/**
0: 	  Fetch the base row corresponding to the current index row
0: 
0: 	  @return The base row row or null.
0: 	  @exception StandardException Ooops
0: 	  */
0: 	private ExecRow fetchBaseRow()
0: 		 throws StandardException
0: 	{ 
0: 
0: 		if (currentRow == null)
0: 		{
0: 			currentRow =
0: 				getCompactRow(candidate, accessedCols, (FormatableBitSet) null, isKeyed);
0: 		} 
0: 
0: 		baseRowLocation = (RowLocation) indexRow.getColumn(indexRow.getRowArray().length);
0: 		boolean base_row_exists = 
0:             heapCC.fetch(
0:                 baseRowLocation, candidate.getRowArray(),accessedCols);
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(base_row_exists, "base row disappeared.");
0:         }
0: 
0: 		return currentRow;
0: 	}
0: 	
0: 
0: 	ExecRow searchRow = null; //the current row we are searching for
0: 
0: 	//this function will return an index row on dependent table 
0: 	public ExecRow	getNextRowCore() throws StandardException 
0: 	{
0: 		
0: 		beginTime = getCurrentTimeMillis();
0: 		if (searchRow == null)
0: 		{
0: 			//we are searching for a row first time
0: 			if((searchRow = getNextParentRow())!=null)
0: 			   openIndexScan(searchRow);
0: 		}	
0: 	
0: 		ExecRow currentIndexRow = null;
0: 	    while(searchRow != null)
0: 		{
0: 			//get if the current search row has  more 
0: 			//than one row in the dependent tables
0: 			currentIndexRow = fetchIndexRow();
0: 	
0: 			if(currentIndexRow !=null)
0: 				break;
0: 			if((searchRow = getNextParentRow())!=null)
0: 			   openIndexScan(searchRow);
0: 		}
0: 
0: 		nextTime += getElapsedMillis(beginTime);
0: 		if(currentIndexRow!= null)
0: 		{
0: 			rowsSeen++;
0: 			return fetchBaseRow();
0: 		}else
0: 		{
0: 			return currentIndexRow;
0: 		}
0: 		
0: 		
0: 	}
0: 
0: 
0: 	//this function will return the rows from the parent result sets 
0: 	private ExecRow	getNextParentRow() throws StandardException 
0: 	{
0: 
0: 		ExecRow cRow;
0: 		TemporaryRowHolder rowHolder;
0: 
0: 		if(sourceOpened[sArrayIndex] == 0)
0: 		{
0: 			rowHolder = sourceRowHolders[sArrayIndex];
0: 			source = (TemporaryRowHolderResultSet)rowHolder.getResultSet();
0: 			source.open(); //open the cursor result set
0: 			sourceOpened[sArrayIndex] = -1;
0: 			sourceResultSets[sArrayIndex] = source;
0: 		}
0: 
0: 		if(sourceOpened[sArrayIndex] == 1)
0: 		{
0: 			source = sourceResultSets[sArrayIndex];
0: 			source.reStartScan(sourceRowHolders[sArrayIndex].getTemporaryConglomId(),
0: 							  sourceRowHolders[sArrayIndex].getPositionIndexConglomId());
0: 			sourceOpened[sArrayIndex] = -1;
0: 			
0: 		}
0: 
0: 		if(sVector.size() > sourceRowHolders.length)
0: 		{
0: 			addNewSources();
0: 		}
0: 
0: 		cRow = source.getNextRow();
0: 		while(cRow == null &&  (sArrayIndex+1) <  sourceRowHolders.length)
0: 		{
0: 
0: 			//opening the next source;
0: 			sArrayIndex++;
0: 			if(sourceOpened[sArrayIndex] == 0)
0: 			{
0: 				rowHolder = sourceRowHolders[sArrayIndex];
0: 				source = (TemporaryRowHolderResultSet)rowHolder.getResultSet();
0: 				source.open(); //open the cursor result set
0: 				sourceOpened[sArrayIndex] = -1;
0: 				sourceResultSets[sArrayIndex] = source;
0: 			}
0: 
0: 			if(sourceOpened[sArrayIndex] == 1)
0: 			{
0: 				source = sourceResultSets[sArrayIndex];
0: 				source.reStartScan(sourceRowHolders[sArrayIndex].getTemporaryConglomId(),
0: 								  sourceRowHolders[sArrayIndex].getPositionIndexConglomId());
0: 				sourceOpened[sArrayIndex] = -1;
0: 			}
0: 		
0: 			cRow = source.getNextRow();
0: 		}
0: 
0: 		if(cRow == null)
0: 		{
0: 			//which means no source has any more  currently rows.
0: 			sArrayIndex = 0;
0: 			//mark all the sources to  restartScan.
0: 			for(int i =0 ; i < sourceOpened.length ; i++)
0: 				sourceOpened[i] = 1;
0: 		}
0: 		
0: 		return cRow;
0: 	}
0: 
0: 
0: 
0: 	/*
0: 	** Open the heap Conglomerate controller
0: 	**
0: 	** @param transaction controller will open one if null
0: 	*/
0: 	public ConglomerateController openHeapConglomerateController()
0: 		throws StandardException
0: 	{
0: 		return tc.openCompiledConglomerate(
0:                     false,
0: 				    TransactionController.OPENMODE_FORUPDATE,
0: 					lockMode,
0: 					isolationLevel,
0: 					heapScoci,
0: 					heapDcoci);
0: 	}
0: 
0: 
0: 
0: 
0: 	/**
0: 	  Close the all the opens we did in this result set.
0: 	  */
0: 	public void close()
0:         throws StandardException
0: 	{
0: 		//save the information for the runtime stastics
0: 		// This is where we get the scan properties for the reference index scans
0: 		if (runTimeStatisticsOn)
0: 		{
0: 			startPositionString = printStartPosition();
0: 			stopPositionString = printStopPosition();
0: 			scanProperties = getScanProperties();
0: 		}
0: 
0: 		if (indexSC != null) 
0: 		{
0: 			indexSC.close();
0: 			indexSC = null;
0: 		}
0: 
0: 		if ( heapCC != null )
0: 		{
0: 			heapCC.close();
0: 			heapCC = null;
0: 		}
0: 		if(isOpen)
0: 		{
0: 			source.close();  
0: 		}
0: 		
0: 		closeTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	public void	finish() throws StandardException
0: 	{
0: 		if (source != null)
0: 			source.finish();
0: 		finishAndRTS();
0: 	}
0: 
0: 	public void openCore() throws StandardException
0: 	{
0: 
0: 		sVector = activation.getParentResultSet(parentResultSetId);
0: 		int size = sVector.size();
0: 		sourceRowHolders = new TemporaryRowHolder[size];
0: 		sourceOpened = new int[size];
0: 		sourceResultSets = new TemporaryRowHolderResultSet[size];
0: 		for(int i = 0 ; i < size ; i++)
0: 		{
0: 			sourceRowHolders[i] = (TemporaryRowHolder)sVector.elementAt(i);
0: 			sourceOpened[i] = 0;
0: 		}
0: 
0: 		//open the table scan
0: 		heapCC = openHeapConglomerateController();
0: 		numOpens++;
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 
0: 	private void addNewSources()
0: 	{
0: 		int size = sVector.size();
0: 		TemporaryRowHolder[] tsourceRowHolders = new TemporaryRowHolder[size];
0: 		int[] tsourceOpened = new int[size];
0: 		TemporaryRowHolderResultSet[] tsourceResultSets = new TemporaryRowHolderResultSet[size];
0: 		
0: 		//copy the source we have now
0: 		System.arraycopy(sourceRowHolders, 0, tsourceRowHolders, 0 , sourceRowHolders.length);
0: 		System.arraycopy(sourceOpened, 0, tsourceOpened , 0 ,sourceOpened.length);
0: 		System.arraycopy(sourceResultSets , 0, tsourceResultSets ,0 ,sourceResultSets.length);
0: 
0: 		//copy the new sources
0: 		for(int i = sourceRowHolders.length; i < size ; i++)
0: 		{
0: 			tsourceRowHolders[i] = (TemporaryRowHolder)sVector.elementAt(i);
0: 			tsourceOpened[i] = 0;
0: 		}
0: 
0: 		sourceRowHolders = tsourceRowHolders;
0: 		sourceOpened = tsourceOpened ;
0: 		sourceResultSets = tsourceResultSets;
0: 	}
0: 
0: 
0: 
0: 	/**
0: 	 * Can we get instantaneous locks when getting share row
0: 	 * locks at READ COMMITTED.
0: 	 */
0: 	private boolean canGetInstantaneousLocks()
0: 	{
0: 		return false;
0: 	}
0: 
0: 
0: 	public long getTimeSpent(int type)
0: 	{
0: 		return constructorTime + openTime + nextTime + closeTime;
0: 	}
0: 
0: 
0: 	//Cursor result set information.
0: 	public RowLocation getRowLocation() throws StandardException
0: 	{
0: 		return baseRowLocation;
0: 	}
0: 
0: 	public ExecRow getCurrentRow() throws StandardException 
0: 	{
0: 		return currentRow;
0: 	}
0: 
0: 
0: 	public Properties getScanProperties()
0: 	{
0: 		if (scanProperties == null)
0: 		{
0: 			scanProperties = new Properties();
0: 		}
0: 		try
0: 		{
0: 			if (indexSC != null)
0: 			{
0: 				indexSC.getScanInfo().getAllScanInfo(scanProperties);
0: 				/* Did we get a coarser lock due to
0: 				 * a covering lock, lock escalation
0: 				 * or configuration?
0: 				 */
0: 				coarserLock = indexSC.isTableLocked() && 
0: 					(lockMode == TransactionController.MODE_RECORD);
0: 			}
0: 		}
0: 		catch(StandardException se)
0: 		{
0: 				// ignore
0: 		}
0: 
0: 		return scanProperties;
0: 	}
0: 
0: 	public String printStartPosition()
0: 	{
0: 		return printPosition(ScanController.GE, indexQualifierRow);
0: 	}
0: 
0: 	public String printStopPosition()
0: 	{
0: 		return printPosition(ScanController.GT, indexQualifierRow);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Return a start or stop positioner as a String.
0: 	 *
0: 	 * If we already generated the information, then use
0: 	 * that.  Otherwise, invoke the activation to get it.
0: 	 */
0: 	private String printPosition(int searchOperator, ExecIndexRow positioner)
0: 	{
0: 		String idt = "";
0: 		String output = "";
0: 
0: 		String searchOp = null;
0: 		switch (searchOperator)
0: 		{
0: 			case ScanController.GE:
0: 				searchOp = ">=";
0: 				break;
0: 
0: 			case ScanController.GT:
0: 				searchOp = ">";
0: 				break;
0: 
0: 			default:
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT("Unknown search operator " +
0: 												searchOperator);
0: 				}
0: 
0: 				// NOTE: This does not have to be internationalized because
0: 				// this code should never be reached.
0: 				searchOp = "unknown value (" + searchOperator + ")";
0: 				break;
0: 		}
0: 
0: 		if(positioner !=null)
0: 		{
0: 			output = output + "\t" +
0: 				MessageService.getTextMessage(
0: 										  SQLState.LANG_POSITIONER,
0: 										  searchOp,
0: 										  String.valueOf(positioner.nColumns())) +
0: 				"\n";
0: 
0: 			output = output + "\t" +
0: 				MessageService.getTextMessage(
0: 											  SQLState.LANG_ORDERED_NULL_SEMANTICS) +
0: 				"\n";
0: 			for (int position = 0; position < positioner.nColumns(); position++)
0: 			{
0: 				if (positioner.areNullsOrdered(position))
0: 				{
0: 					output = output + position + " ";
0: 				}
0: 			}
0: 	
0: 		}
0: 	
0: 		return output + "\n";
0: 	}
0: 
0: 
0: 	/**
0: 	 * Return an array of Qualifiers as a String
0: 	 */
0: 	public String printQualifiers()
0: 	{
0: 		//There are no qualifiers in thie result set for index scans.
0: 		String idt = "";
0: 		return idt + MessageService.getTextMessage(SQLState.LANG_NONE);
0: 	}
0: }
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
============================================================================