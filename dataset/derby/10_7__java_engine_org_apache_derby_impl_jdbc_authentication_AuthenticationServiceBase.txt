1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.jdbc.authentication.AuthenticationServiceBase
1:1ede0a8: 
1:88a3cb9:    Licensed to the Apache Software Foundation (ASF) under one or more
1:88a3cb9:    contributor license agreements.  See the NOTICE file distributed with
1:88a3cb9:    this work for additional information regarding copyright ownership.
1:88a3cb9:    The ASF licenses this file to you under the Apache License, Version 2.0
1:88a3cb9:    (the "License"); you may not use this file except in compliance with
1:88a3cb9:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
13:eac0369:  */
1:60edeb0: 
1:eac0369: package org.apache.derby.impl.jdbc.authentication;
28:eac0369: 
1:eac0369: import org.apache.derby.authentication.UserAuthenticator;
1:eac0369: import org.apache.derby.iapi.reference.Property;
1:eac0369: import org.apache.derby.iapi.jdbc.AuthenticationService;
1:eac0369: 
1:b1f84c1: import org.apache.derby.iapi.reference.Limits;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:a0dbbd7: import org.apache.derby.iapi.services.context.Context;
1:eac0369: import org.apache.derby.iapi.services.context.ContextService;
1:eac0369: import org.apache.derby.iapi.services.daemon.Serviceable;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleControl;
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:eac0369: import org.apache.derby.iapi.store.access.AccessFactory;
1:eac0369: import org.apache.derby.iapi.services.property.PropertyFactory;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.services.property.PropertySetCallback;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.Attribute;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.property.PropertyUtil;
1:eac0369: import org.apache.derby.iapi.util.StringUtil;
1:eac0369: 
1:60edeb0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:60edeb0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:a84fc26: import org.apache.derby.iapi.sql.dictionary.PasswordHasher;
1:c0399dc: import org.apache.derby.iapi.sql.dictionary.UserDescriptor;
1:60edeb0: 
1:eac0369: import java.security.MessageDigest;
1:eac0369: import java.security.NoSuchAlgorithmException;
1:a0dbbd7: import java.security.PrivilegedAction;
1:a0dbbd7: import java.security.AccessController;
1:eac0369: 
1:eac0369: import java.io.Serializable;
1:60edeb0: import java.io.UnsupportedEncodingException;
1:1ede0a8: import java.security.SecureRandom;
1:eac0369: import java.util.Dictionary;
1:eac0369: import java.util.Properties;
1:60edeb0: import org.apache.derby.iapi.reference.SQLState;
1:60edeb0: 
1:7233e33: /**
1:60edeb0:  * <p>
1:eac0369:  * This is the authentication service base class.
1:1ede0a8:  * </p>
1:1ede0a8: 
2:60edeb0:  * <p>
1:94f158a:  * There can be 1 Authentication Service for the whole Derby
1:eac0369:  * system and/or 1 authentication per database.
1:eac0369:  * In a near future, we intend to allow multiple authentication services
1:eac0369:  * per system and/or per database.
1:60edeb0:  * </p>
1:1ede0a8:  *
1:1ede0a8:  * <p>
1:eac0369:  * It should be extended by the specialized authentication services.
1:60edeb0:  * </p>
1:60edeb0:  *
1:60edeb0:  * <p><strong>IMPORTANT NOTE:</strong></p>
1:60edeb0:  *
1:60edeb0:  * <p>
1:5d3b815:  * User passwords are hashed using a message digest algorithm
1:5d3b815:  * if they're stored in the database. They are not hashed
1:eac0369:  * if they were defined at the system level.
1:60edeb0:  * </p>
1:60edeb0:  *
1:60edeb0:  * <p>
1:5d3b815:  * The passwords can be hashed using two different schemes:
1:60edeb0:  * </p>
6:eac0369:  *
1:60edeb0:  * <ul>
1:60edeb0:  * <li>The SHA-1 authentication scheme, which was the only available scheme
1:60edeb0:  * in Derby 10.5 and earlier. This scheme uses the SHA-1 message digest
1:60edeb0:  * algorithm.</li>
1:60edeb0:  * <li>The configurable hash authentication scheme, which allows the users to
1:60edeb0:  * specify which message digest algorithm to use.</li>
1:60edeb0:  * </ul>
1:60edeb0:  *
1:60edeb0:  * <p>
1:60edeb0:  * In order to use the configurable hash authentication scheme, the users have
1:60edeb0:  * to set the {@code derby.authentication.builtin.algorithm} property (on
1:60edeb0:  * system level or database level) to the name of an algorithm that's available
1:60edeb0:  * in one of the security providers registered on the system. If this property
1:60edeb0:  * is not set, or if it's set to NULL or an empty string, the SHA-1
1:60edeb0:  * authentication scheme is used.
1:60edeb0:  * </p>
1:60edeb0:  *
1:60edeb0:  * <p>
1:60edeb0:  * Which scheme to use is decided when a password is about to be stored in the
1:60edeb0:  * database. One database may therefore contain passwords stored using
1:60edeb0:  * different schemes. In order to determine which scheme to use when comparing
1:60edeb0:  * a user's credentials with those stored in the database, the stored password
1:60edeb0:  * is prefixed with an identifier that tells which scheme is being used.
1:60edeb0:  * Passwords stored using the SHA-1 authentication scheme are prefixed with
1:a84fc26:  * {@link PasswordHasher#ID_PATTERN_SHA1_SCHEME}. Passwords that are stored using the
1:60edeb0:  * configurable hash authentication scheme are prefixed with
1:a84fc26:  * {@link PasswordHasher#ID_PATTERN_CONFIGURABLE_HASH_SCHEME} and suffixed with the name of
1:60edeb0:  * the message digest algorithm.
1:60edeb0:  * </p>
1:1ede0a8:  */
1:eac0369: public abstract class AuthenticationServiceBase
1:eac0369: 	implements AuthenticationService, ModuleControl, ModuleSupportable, PropertySetCallback {
1:eac0369: 
1:eac0369: 	protected UserAuthenticator authenticationScheme; 
1:eac0369: 
1:eac0369: 	// required to retrieve service properties
1:eac0369: 	private AccessFactory store;
1:eac0369: 
1:1ede0a8: 	/**
1:eac0369: 		Trace flag to trace authentication operations
1:60edeb0: 	*/
1:eac0369: 	public static final String AuthenticationTrace =
1:eac0369: 						SanityManager.DEBUG ? "AuthenticationTrace" : null;
1:60edeb0: 
1:60edeb0:     /**
1:7233e33:         Userid with Strong password substitute DRDA security mechanism
1:7233e33:     */
1:7233e33:     protected static final int SECMEC_USRSSBPWD = 8;
1:60edeb0: 
1:eac0369: 	//
1:eac0369: 	// constructor
1:eac0369: 	//
1:eac0369: 	public AuthenticationServiceBase() {
1:1ede0a8: 	}
1:a0dbbd7: 
1:eac0369: 	protected void setAuthenticationService(UserAuthenticator aScheme) {
1:eac0369: 		// specialized class is the principal caller.
1:eac0369: 		this.authenticationScheme = aScheme;
1:1ede0a8: 
1:eac0369: 		if (SanityManager.DEBUG)
1:a0dbbd7: 		{
1:eac0369: 			SanityManager.ASSERT(this.authenticationScheme != null, 
1:eac0369: 				"There is no authentication scheme for that service!");
1:1ede0a8: 		
1:eac0369: 			if (SanityManager.DEBUG_ON(AuthenticationTrace)) {
1:1ede0a8: 
1:eac0369: 				java.io.PrintWriter iDbgStream =
1:eac0369: 					SanityManager.GET_DEBUG_STREAM();
1:eac0369: 
1:eac0369: 				iDbgStream.println("Authentication Service: [" +
1:eac0369: 								this.toString() + "]");
1:eac0369: 				iDbgStream.println("Authentication Scheme : [" +
1:eac0369: 								this.authenticationScheme.toString() + "]");
1:1ede0a8: 			}
1:1ede0a8: 		}
1:1ede0a8: 	}
1:eac0369: 
1:a0dbbd7: 	/**
1:eac0369: 	/*
1:eac0369: 	** Methods of module control - To be overriden
1:1ede0a8: 	*/
1:eac0369: 
1:60edeb0: 	/**
1:eac0369: 		Start this module.  In this case, nothing needs to be done.
1:eac0369: 		@see org.apache.derby.iapi.services.monitor.ModuleControl#boot
1:eac0369: 
1:eac0369: 		@exception StandardException upon failure to load/boot
1:eac0369: 		the expected authentication service.
1:60edeb0: 	 */
1:eac0369: 	 public void boot(boolean create, Properties properties)
1:60edeb0: 	  throws StandardException
1:a0dbbd7: 	 {
1:eac0369: 			//
1:eac0369: 			// we expect the Access factory to be available since we're
1:eac0369: 			// at boot stage.
1:eac0369: 			//
1:eac0369: 			store = (AccessFactory)
1:56c1dc2: 				getServiceModule(this, AccessFactory.MODULE);
1:eac0369: 			// register to be notified upon db properties changes
1:eac0369: 			// _only_ if we're on a database context of course :)
1:eac0369: 
1:eac0369: 			PropertyFactory pf = (PropertyFactory)
1:56c1dc2: 				getServiceModule(this, org.apache.derby.iapi.reference.Module.PropertyFactory);
1:eac0369: 			if (pf != null)
1:eac0369: 				pf.addPropertySetNotification(this);
1:eac0369: 
1:60edeb0: 	 }
1:eac0369: 
1:60edeb0: 	/**
1:eac0369: 	 * @see org.apache.derby.iapi.services.monitor.ModuleControl#stop
1:60edeb0: 	 */
1:eac0369: 	public void stop() {
1:eac0369: 
1:eac0369: 		// nothing special to be done yet.
1:60edeb0: 	}
1:eac0369: 	/*
1:eac0369: 	** Methods of AuthenticationService
1:60edeb0: 	*/
1:eac0369: 
1:60edeb0: 	/**
1:eac0369: 	 * Authenticate a User inside JBMS.T his is an overload method.
1:1ede0a8: 	 *
1:eac0369: 	 * We're passed-in a Properties object containing user credentials information
1:eac0369: 	 * (as well as database name if user needs to be validated for a certain
1:eac0369: 	 * database access).
1:60edeb0: 	 *
1:eac0369: 	 * @see
1:eac0369: 	 * org.apache.derby.iapi.jdbc.AuthenticationService#authenticate
1:60edeb0: 	 *
1:eac0369: 	 *
1:60edeb0: 	 */
1:eac0369: 	public boolean authenticate(String databaseName, Properties userInfo) throws java.sql.SQLException
1:c0399dc: 	{
1:eac0369: 		if (userInfo == (Properties) null)
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		String userName = userInfo.getProperty(Attribute.USERNAME_ATTR);
1:43e6876: 		if ((userName != null) && userName.length() > Limits.MAX_IDENTIFIER_LENGTH) {
1:eac0369: 			return false;
1:60edeb0: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:c0399dc: 		{
1:eac0369: 			if (SanityManager.DEBUG_ON(AuthenticationTrace)) {
1:eac0369: 
1:eac0369: 				java.io.PrintWriter iDbgStream =
1:eac0369: 					SanityManager.GET_DEBUG_STREAM();
1:eac0369: 
1:eac0369: 				iDbgStream.println(
1:eac0369: 								" - Authentication request: user [" +
1:eac0369: 							    userName + "]"+ ", database [" +
1:eac0369: 							    databaseName + "]");
1:eac0369: 				// The following will print the stack trace of the
1:eac0369: 				// authentication request to the log.  
1:eac0369: 				//Throwable t = new Throwable();
1:eac0369: 				//istream.println("Authentication Request Stack trace:");
1:eac0369: 				//t.printStackTrace(istream.getPrintWriter());
27:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return this.authenticationScheme.authenticateUser(userName,
1:eac0369: 						  userInfo.getProperty(Attribute.PASSWORD_ATTR),
1:eac0369: 						  databaseName,
1:eac0369: 						  userInfo
1:a0dbbd7: 						 );
1:eac0369: 	}
1:7233e33: 
1:5107349:     public  String  getSystemCredentialsDatabaseName()    { return null; }
1:5107349: 
13:eac0369: 	/**
1:eac0369: 	 * Returns a property if it was set at the database or
1:eac0369: 	 * system level. Treated as SERVICE property by default.
1:eac0369: 	 *
1:eac0369: 	 * @return a property string value.
1:eac0369: 	 **/
1:eac0369: 	public String getProperty(String key) {
1:eac0369: 
1:eac0369: 		String propertyValue = null;
1:eac0369: 		TransactionController tc = null;
1:eac0369: 
1:1ede0a8: 		try {
1:1ede0a8: 
1:5107349:           tc = getTransaction();
1:1ede0a8: 
1:eac0369: 		  propertyValue =
1:eac0369: 			PropertyUtil.getServiceProperty(tc,
1:eac0369: 											key,
1:eac0369: 											(String) null);
1:eac0369: 		  if (tc != null) {
1:eac0369: 			tc.commit();
1:eac0369: 			tc = null;
1:1ede0a8: 		  }
1:1ede0a8: 
1:eac0369: 		} catch (StandardException se) {
1:eac0369: 			// Do nothing and just return
1:1ede0a8: 		}
1:1ede0a8: 
1:eac0369: 		return propertyValue;
1:5107349: 	}
1:60edeb0: 
1:5107349:     /**
1:5107349:      * <p>
1:5107349:      * Get a transaction for performing authentication at the database level.
1:5107349:      * </p>
1:5107349:      */
1:5107349:     protected   TransactionController   getTransaction()
1:5107349:         throws StandardException
1:5107349:     {
1:5107349:         if ( store == null ) { return null; }
1:a0dbbd7:         else
1:a0dbbd7:         {
1:a0dbbd7:             return store.getTransaction( getContextService().getCurrentContextManager() );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:5107349: 
1:5107349:     /**
1:dcd69d3:      * Get all the database properties.
1:dcd69d3:      * @return the database properties, or {@code null} if there is no
1:dcd69d3:      * access factory
1:dcd69d3:      */
1:dcd69d3:     Properties getDatabaseProperties() throws StandardException {
1:dcd69d3:         Properties props = null;
1:dcd69d3: 
1:dcd69d3:         TransactionController tc = getTransaction();
1:dcd69d3:         if (tc != null) {
1:dcd69d3:             try {
1:dcd69d3:                 props = tc.getProperties();
1:dcd69d3:             } finally {
1:dcd69d3:                 tc.commit();
1:a0dbbd7:             }
1:a0dbbd7:         }
1:dcd69d3: 
1:dcd69d3:         return props;
1:5107349:     }
1:dcd69d3: 
1:dcd69d3:     /**
1:5107349:      * <p>
1:5107349:      * Get the name of the database if we are performing authentication at the database level.
1:5107349:      * </p>
1:5107349:      */
1:5107349:     protected   String  getServiceName()
1:a0dbbd7:     {
1:5107349:         if ( store == null ) { return null; }
1:56c1dc2:         else { return getServiceName( store ); }
1:5107349:     }
1:5107349: 
1:eac0369: 	public String getDatabaseProperty(String key) {
1:eac0369: 
1:eac0369: 		String propertyValue = null;
1:eac0369: 		TransactionController tc = null;
1:eac0369: 
1:1ede0a8: 		try {
1:eac0369: 
2:eac0369: 		  if (store != null)
2:eac0369: 			tc = store.getTransaction(
1:a0dbbd7:                 getContextService().getCurrentContextManager());
1:eac0369: 
1:eac0369: 		  propertyValue =
1:eac0369: 			PropertyUtil.getDatabaseProperty(tc, key);
1:eac0369: 
1:eac0369: 		  if (tc != null) {
1:eac0369: 			tc.commit();
1:eac0369: 			tc = null;
1:dcd69d3: 		  }
1:eac0369: 
1:eac0369: 		} catch (StandardException se) {
1:eac0369: 			// Do nothing and just return
1:dcd69d3: 		}
1:eac0369: 
1:eac0369: 		return propertyValue;
1:dcd69d3: 	}
1:eac0369: 
1:eac0369: 	public String getSystemProperty(String key) {
1:eac0369: 
1:eac0369: 		boolean dbOnly = false;
1:eac0369: 		dbOnly = Boolean.valueOf(
1:eac0369: 					this.getDatabaseProperty(
1:eac0369: 							Property.DATABASE_PROPERTIES_ONLY)).booleanValue();
1:eac0369: 
1:eac0369: 		if (dbOnly)
1:60edeb0: 			return null;
1:60edeb0: 
1:eac0369: 		return PropertyUtil.getSystemProperty(key);
1:1ede0a8: 	}
1:60edeb0: 
1:eac0369: 	/*
1:eac0369: 	** Methods of PropertySetCallback
1:60edeb0: 	*/
1:eac0369: 	public void init(boolean dbOnly, Dictionary p) {
1:eac0369: 		// not called yet ...
1:1ede0a8: 	}
1:60edeb0: 
1:1ede0a8: 	/**
1:eac0369: 	  @see PropertySetCallback#validate
1:eac0369: 	*/
1:c0399dc: 	public boolean validate(String key, Serializable value, Dictionary p)
1:c0399dc:         throws StandardException
1:a0dbbd7:     {
1:c0399dc: 
1:c0399dc:         // user password properties need to be remapped. nothing else needs remapping.
1:c0399dc: 		if ( key.startsWith(org.apache.derby.iapi.reference.Property.USER_PROPERTY_PREFIX) ) { return true; }
1:c0399dc: 
1:c0399dc:         String      stringValue = (String) value;
1:c0399dc:         boolean     settingToNativeLocal = Property.AUTHENTICATION_PROVIDER_NATIVE_LOCAL.equals( stringValue );
1:c0399dc:         
1:c0399dc:         if ( Property.AUTHENTICATION_PROVIDER_PARAMETER.equals( key ) )
1:a0dbbd7:         {
1:c0399dc:             // NATIVE + LOCAL is the only value of this property which can be persisted
1:c0399dc:             if (
1:c0399dc:                 ( stringValue != null ) &&
1:c0399dc:                 ( stringValue.startsWith( Property.AUTHENTICATION_PROVIDER_NATIVE ) )&&
1:c0399dc:                 !settingToNativeLocal
1:c0399dc:                 )
1:2489f47:             {
1:65bdc4d:                 throw  StandardException.newException( SQLState.PROPERTY_DBO_LACKS_CREDENTIALS );
1:2489f47:             }
1:c0399dc: 
1:c0399dc:             // once set to NATIVE authentication, you can't change it
1:c0399dc:             String  oldValue = (String) p.get( Property.AUTHENTICATION_PROVIDER_PARAMETER );
1:c0399dc:             if ( (oldValue != null) && oldValue.startsWith( Property.AUTHENTICATION_PROVIDER_NATIVE ) )
1:2489f47:             {
1:2489f47:                 throw StandardException.newException( SQLState.PROPERTY_CANT_UNDO_NATIVE );
1:2489f47:             }
1:c0399dc: 
1:c0399dc:             // can't turn on NATIVE + LOCAL authentication unless the DBO's credentials are already stored.
1:c0399dc:             // this should prevent setting NATIVE + LOCAL authentication in pre-10.9 databases too
1:c0399dc:             // because you can't store credentials in a pre-10.9 database.
1:c0399dc:             if ( settingToNativeLocal )
1:c0399dc:             {
1:c0399dc:                 DataDictionary  dd = getDataDictionary();
1:c0399dc:                 String              dbo = dd.getAuthorizationDatabaseOwner();
1:c0399dc:                 UserDescriptor  userCredentials = dd.getUser( dbo );
1:c0399dc: 
1:2489f47:                 if ( userCredentials == null )
1:2489f47:                 {
1:2489f47:                     throw StandardException.newException( SQLState.PROPERTY_DBO_LACKS_CREDENTIALS );
1:2489f47:                 }
1:c0399dc:             }
1:c0399dc:         }
1:c0399dc: 
1:49901a4:         if ( Property.AUTHENTICATION_NATIVE_PASSWORD_LIFETIME.equals( key ) )
1:49901a4:         {
1:49901a4:             if ( parsePasswordLifetime( stringValue ) == null )
1:49901a4:             {
1:49901a4:                 throw StandardException.newException
1:49901a4:                     ( SQLState.BAD_PASSWORD_LIFETIME, Property.AUTHENTICATION_NATIVE_PASSWORD_LIFETIME );
1:49901a4:             }
1:49901a4:         }
1:49901a4:         
1:49901a4:         if ( Property.AUTHENTICATION_PASSWORD_EXPIRATION_THRESHOLD.equals( key ) )
1:49901a4:         {
1:49901a4:             if ( parsePasswordThreshold( stringValue ) == null )
1:49901a4:             {
1:49901a4:                 throw StandardException.newException
1:49901a4:                     ( SQLState.BAD_PASSWORD_LIFETIME, Property.AUTHENTICATION_PASSWORD_EXPIRATION_THRESHOLD );
1:49901a4:             }
1:49901a4:         }
1:49901a4:         
1:c0399dc:         return false;
1:c0399dc: 	}
1:49901a4:     /** Parse the value of the password lifetime property. Return null if it is bad. */
1:49901a4:     protected   Long    parsePasswordLifetime( String passwordLifetimeString )
1:49901a4:     {
1:49901a4:             try {
1:49901a4:                 long    passwordLifetime = Long.parseLong( passwordLifetimeString );
1:49901a4: 
1:49901a4:                 if ( passwordLifetime < 0L ) { passwordLifetime = 0L; }
1:49901a4: 
1:ce40a31:                 return passwordLifetime;
1:49901a4:             } catch (Exception e) { return null; }
1:49901a4:     }
1:49901a4:     /** Parse the value of the password expiration threshold property. Return null if it is bad. */
1:49901a4:     protected   Double  parsePasswordThreshold( String expirationThresholdString )
1:49901a4:     {
1:49901a4:             try {
1:49901a4:                 double  expirationThreshold = Double.parseDouble( expirationThresholdString );
1:49901a4: 
1:49901a4:                 if ( expirationThreshold <= 0L ) { return null; }
1:ce40a31:                 else { return expirationThreshold; }
1:49901a4:             } catch (Exception e) { return null; }
1:49901a4:     }
1:c0399dc:     
1:60edeb0: 	/**
1:eac0369: 	  @see PropertySetCallback#validate
1:eac0369: 	*/
1:eac0369: 	public Serviceable apply(String key,Serializable value,Dictionary p)
1:c0399dc: 	{
2:eac0369: 		return null;
1:1ede0a8: 	}
1:eac0369: 	/**
1:eac0369: 	  @see PropertySetCallback#map
1:eac0369: 	  @exception StandardException Thrown on error.
1:eac0369: 	*/
1:eac0369: 	public Serializable map(String key, Serializable value, Dictionary p)
2:eac0369: 		throws StandardException
1:5107349: 	{
1:eac0369: 		// We only care for "derby.user." property changes
1:eac0369: 		// at the moment.
1:eac0369: 		if (!key.startsWith(org.apache.derby.iapi.reference.Property.USER_PROPERTY_PREFIX)) return null;
1:5d3b815: 		// We do not hash 'derby.user.<userName>' password if
1:eac0369: 		// the configured authentication service is LDAP as the
1:eac0369: 		// same property could be used to store LDAP user full DN (X500).
1:eac0369: 		// In performing this check we only consider database properties
1:eac0369: 		// not system, service or application properties.
1:60edeb0: 
1:eac0369: 		String authService =
1:eac0369: 			(String)p.get(org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_PARAMETER);
1:60edeb0: 
1:eac0369: 		if ((authService != null) &&
1:eac0369: 			 (StringUtil.SQLEqualsIgnoreCase(authService, org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_LDAP)))
1:eac0369: 			return null;
1:60edeb0: 
1:5d3b815: 		// Ok, we can hash this password in the db
1:eac0369: 		String userPassword = (String) value;
1:eac0369: 
1:eac0369: 		if (userPassword != null) {
1:5d3b815: 			// hash (digest) the password
1:eac0369: 			// the caller will retrieve the new value
1:60edeb0:             String userName =
1:60edeb0:                     key.substring(Property.USER_PROPERTY_PREFIX.length());
1:60edeb0:             userPassword =
1:5d3b815:                     hashUsingDefaultAlgorithm(userName, userPassword, p);
1:23f97a5: 		}
1:eac0369: 
1:eac0369: 		return userPassword;
1:60edeb0: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	// Class implementation
1:eac0369: 
1:eac0369: 	protected final boolean requireAuthentication(Properties properties) {
1:eac0369: 
1:eac0369: 		//
1:eac0369: 		// we check if derby.connection.requireAuthentication system
1:eac0369: 		// property is set to true, otherwise we are the authentication
1:eac0369: 		// service that should be run.
1:eac0369: 		//
1:eac0369: 		String requireAuthentication = PropertyUtil.getPropertyFromSet(
1:eac0369: 					properties,
1:eac0369: 					org.apache.derby.iapi.reference.Property.REQUIRE_AUTHENTICATION_PARAMETER
1:a0dbbd7: 														);
1:5107349: 		if ( Boolean.valueOf(requireAuthentication).booleanValue() ) { return true; }
1:5107349: 
1:5107349:         //
1:5107349:         // NATIVE authentication does not require that you set REQUIRE_AUTHENTICATION_PARAMETER.
1:5107349:         //
1:5107349:         return PropertyUtil.nativeAuthenticationEnabled( properties );
1:60edeb0: 	}
1:eac0369: 
1:eac0369: 	/**
1:60edeb0:      * <p>
1:5d3b815: 	 * This method hashes a clear user password using a
1:eac0369: 	 * Single Hash algorithm such as SHA-1 (SHA equivalent)
1:eac0369: 	 * (it is a 160 bits digest)
1:60edeb0:      * </p>
1:1ede0a8: 	 *
1:60edeb0:      * <p>
1:eac0369: 	 * The digest is returned as an object string.
1:60edeb0:      * </p>
1:60edeb0:      *
1:60edeb0:      * <p>
1:60edeb0:      * This method is only used by the SHA-1 authentication scheme.
1:60edeb0:      * </p>
1:eac0369: 	 *
1:eac0369: 	 * @param plainTxtUserPassword Plain text user password
1:eac0369: 	 *
1:5d3b815: 	 * @return hashed user password (digest) as a String object
1:60edeb0:      *         or {@code null} if the plaintext password is {@code null}
1:eac0369: 	 */
1:5d3b815: 	protected String hashPasswordSHA1Scheme(String plainTxtUserPassword)
1:5107349: 	{
1:eac0369: 		if (plainTxtUserPassword == null)
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 		MessageDigest algorithm = null;
1:eac0369: 		try
1:60edeb0: 		{
1:eac0369: 			algorithm = MessageDigest.getInstance("SHA-1");
1:eac0369: 		} catch (NoSuchAlgorithmException nsae)
12:eac0369: 		{
1:eac0369: 					// Ignore as we checked already during service boot-up
1:60edeb0: 		}
1:eac0369: 
1:eac0369: 		algorithm.reset();
1:eac0369: 		byte[] bytePasswd = null;
1:178ca0c:         bytePasswd = toHexByte(plainTxtUserPassword);
1:eac0369: 		algorithm.update(bytePasswd);
1:5d3b815: 		byte[] hashedVal = algorithm.digest();
1:a84fc26:         String hexString = PasswordHasher.ID_PATTERN_SHA1_SCHEME +
1:5d3b815:                 StringUtil.toHexString(hashedVal, 0, hashedVal.length);
1:eac0369: 		return (hexString);
1:60edeb0: 
1:60edeb0: 	}
1:60edeb0: 
1:7233e33:     /**
1:60edeb0:      * <p>
1:178ca0c:      * Convert a string into a byte array in hex format.
1:178ca0c:      * </p>
1:178ca0c:      *
1:178ca0c:      * <p>
1:178ca0c:      * For each character (b) two bytes are generated, the first byte
1:178ca0c:      * represents the high nibble (4 bits) in hexadecimal ({@code b & 0xf0}),
1:178ca0c:      * the second byte represents the low nibble ({@code b & 0x0f}).
1:178ca0c:      * </p>
1:178ca0c:      *
1:178ca0c:      * <p>
1:178ca0c:      * The character at {@code str.charAt(0)} is represented by the first two
1:178ca0c:      * bytes in the returned String.
1:178ca0c:      * </p>
1:178ca0c:      *
1:178ca0c:      * <p>
1:178ca0c:      * New code is encouraged to use {@code String.getBytes(String)} or similar
1:178ca0c:      * methods instead, since this method does not preserve all bits for
1:178ca0c:      * characters whose codepoint exceeds 8 bits. This method is preserved for
1:178ca0c:      * compatibility with the SHA-1 authentication scheme.
1:178ca0c:      * </p>
1:178ca0c:      *
1:178ca0c:      * @param str string
1:178ca0c:      * @return the byte[] (with hexadecimal format) form of the string (str)
1:178ca0c:      */
1:178ca0c:     private static byte[] toHexByte(String str)
1:178ca0c:     {
1:178ca0c:         byte[] data = new byte[str.length() * 2];
1:178ca0c: 
1:178ca0c:         for (int i = 0; i < str.length(); i++)
1:178ca0c:         {
1:178ca0c:             char ch = str.charAt(i);
1:178ca0c:             int high_nibble = (ch & 0xf0) >>> 4;
1:178ca0c:             int low_nibble = (ch & 0x0f);
1:178ca0c:             data[i] = (byte)high_nibble;
1:178ca0c:             data[i+1] = (byte)low_nibble;
1:178ca0c:         }
1:178ca0c:         return data;
1:178ca0c:     }
1:178ca0c: 
1:178ca0c:     /**
1:178ca0c:      * <p>
1:5d3b815:      * Hash a password using the default message digest algorithm for this
1:5d3b815:      * system before it's stored in the database.
1:60edeb0:      * </p>
1:60edeb0:      *
1:60edeb0:      * <p>
1:60edeb0:      * If the data dictionary supports the configurable hash authentication
1:60edeb0:      * scheme, and the property {@code derby.authentication.builtin.algorithm}
1:5d3b815:      * is a non-empty string, the password will be hashed using the
1:60edeb0:      * algorithm specified by that property. Otherwise, we fall back to the new
1:60edeb0:      * authentication scheme based on SHA-1. The algorithm used is encoded in
1:60edeb0:      * the returned token so that the code that validates a user's credentials
1:60edeb0:      * knows which algorithm to use.
4:60edeb0:      * </p>
1:60edeb0:      *
1:5d3b815:      * @param user the user whose password to hash
2:60edeb0:      * @param password the plain text password
1:1ede0a8:      * @param props database properties
2:60edeb0:      * @return a digest of the user name and password formatted as a string,
2:60edeb0:      *         or {@code null} if {@code password} is {@code null}
2:60edeb0:      * @throws StandardException if the specified algorithm is not supported
1:1ede0a8:      */
1:5d3b815:     String hashUsingDefaultAlgorithm(String user,
1:60edeb0:                                                 String password,
1:60edeb0:                                                 Dictionary props)
1:a84fc26:             throws StandardException
1:a84fc26:     {
1:a84fc26:         if ( password ==  null ) { return null; }
1:1ede0a8: 
1:a84fc26:         PasswordHasher  hasher = getDataDictionary().makePasswordHasher( props );
1:1ede0a8: 
1:a84fc26:         if ( hasher != null ) { return hasher.hashAndEncode( user, password ); }
1:5d3b815:         else { return hashPasswordSHA1Scheme(password); }
1:1ede0a8:     }
1:1ede0a8: 
1:1ede0a8:     /**
1:60edeb0:      * Find the data dictionary for the current connection.
1:60edeb0:      *
1:60edeb0:      * @return the {@code DataDictionary} for the current connection
1:60edeb0:      */
1:60edeb0:     private static DataDictionary getDataDictionary() {
1:60edeb0:         LanguageConnectionContext lcc = (LanguageConnectionContext)
1:a0dbbd7:             getContext(LanguageConnectionContext.CONTEXT_ID);
1:60edeb0:         return lcc.getDataDictionary();
1:60edeb0:     }
1:60edeb0: 
1:60edeb0:     /**
1:7233e33:      * Strong Password Substitution (USRSSBPWD).
1:7233e33:      *
1:23f97a5:      * This method generates a password substitute to authenticate a client
1:7233e33:      * which is using a DRDA security mechanism such as SECMEC_USRSSBPWD.
1:7233e33:      *
1:7233e33:      * Depending how the user is defined in Derby and if BUILTIN
1:7233e33:      * is used, the stored password can be in clear-text (system level)
1:7233e33:      * or encrypted (hashed - *not decryptable*)) (database level) - If the
1:7233e33:      * user has authenticated at the network level via SECMEC_USRSSBPWD, it
1:7233e33:      * means we're presented with a password substitute and we need to
1:7233e33:      * generate a substitute password coming from the store to compare with
1:7233e33:      * the one passed-in.
1:7233e33:      *
1:23f97a5:      * The substitution algorithm used is the same as the one used in the
1:a84fc26:      * SHA-1 authentication scheme ({@link PasswordHasher#ID_PATTERN_SHA1_SCHEME}), so in
1:23f97a5:      * the case of database passwords stored using that scheme, we can simply
1:23f97a5:      * compare the received hash with the stored hash. If the configurable
1:a84fc26:      * hash authentication scheme {@link PasswordHasher#ID_PATTERN_CONFIGURABLE_HASH_SCHEME}
1:23f97a5:      * is used, we have no way to find out if the received hash matches the
1:23f97a5:      * stored password, since we cannot decrypt the hashed passwords and
1:23f97a5:      * re-apply another hash algorithm. Therefore, strong password substitution
1:23f97a5:      * only works if the database-level passwords are stored with the SHA-1
1:23f97a5:      * scheme.
1:23f97a5:      *
1:7233e33:      * NOTE: A lot of this logic could be shared with the DRDA decryption
1:7233e33:      *       and client encryption managers - This will be done _once_
1:7233e33:      *       code sharing along with its rules are defined between the
1:7233e33:      *       Derby engine, client and network code (PENDING).
1:7233e33:      * 
1:7233e33:      * Substitution algorithm works as follow:
1:7233e33:      *
1:7233e33:      * PW_TOKEN = SHA-1(PW, ID)
1:7233e33:      * The password (PW) and user name (ID) can be of any length greater
1:7233e33:      * than or equal to 1 byte.
1:7233e33:      * The client generates a 20-byte password substitute (PW_SUB) as follows:
1:7233e33:      * PW_SUB = SHA-1(PW_TOKEN, RDr, RDs, ID, PWSEQs)
1:7233e33:      * 
1:7233e33:      * w/ (RDs) as the random client seed and (RDr) as the server one.
1:7233e33:      * 
1:7233e33:      * See PWDSSB - Strong Password Substitution Security Mechanism
1:7233e33:      * (DRDA Vol.3 - P.650)
1:7233e33:      *
1:7233e33: 	 * @return a substituted password.
1:7233e33:      */
1:7233e33:     protected String substitutePassword(
1:7233e33:                 String userName,
1:7233e33:                 String password,
1:7233e33:                 Properties info,
1:7233e33:                 boolean databaseUser) {
1:60edeb0: 
1:7233e33:         MessageDigest messageDigest = null;
1:7233e33: 
1:7233e33:         // PWSEQs's 8-byte value constant - See DRDA Vol 3
1:7233e33:         byte SECMEC_USRSSBPWD_PWDSEQS[] = {
1:7233e33:                 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
1:7233e33:                 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01
1:7233e33:                 };
1:7233e33:         
1:7233e33:         // Generated password substitute
1:7233e33:         byte[] passwordSubstitute;
1:7233e33: 
1:7233e33:         try
1:7233e33:         {
1:7233e33:             messageDigest = MessageDigest.getInstance("SHA-1");
1:7233e33:         } catch (NoSuchAlgorithmException nsae)
1:7233e33:         {
1:7233e33:             // Ignore as we checked already during service boot-up
1:7233e33:         }
1:7233e33:         // IMPORTANT NOTE: As the password is stored single-hashed in the
1:7233e33:         // database, it is impossible for us to decrypt the password and
1:7233e33:         // recompute a substitute to compare with one generated on the source
1:7233e33:         // side - Hence, we have to generate a password substitute.
1:7233e33:         // In other words, we cannot figure what the original password was -
1:7233e33:         // Strong Password Substitution (USRSSBPWD) cannot be supported for
1:7233e33:         // targets which can't access or decrypt passwords on their side.
1:7233e33:         //
1:7233e33:         messageDigest.reset();
1:7233e33: 
1:7233e33:         byte[] bytePasswd = null;
1:178ca0c:         byte[] userBytes = toHexByte(userName);
1:7233e33: 
1:7233e33:         if (SanityManager.DEBUG)
1:7233e33:         {
1:7233e33:             // We must have a source and target seed 
1:7233e33:             SanityManager.ASSERT(
1:7233e33:               (((String) info.getProperty(Attribute.DRDA_SECTKN_IN) != null) &&
1:7233e33:               ((String) info.getProperty(Attribute.DRDA_SECTKN_OUT) != null)), 
1:7233e33:                 "Unexpected: Requester or server seed not available");
1:7233e33:         }
1:7233e33: 
1:7233e33:         // Retrieve source (client)  and target 8-byte seeds
1:7233e33:         String sourceSeedstr = info.getProperty(Attribute.DRDA_SECTKN_IN);
1:7233e33:         String targetSeedstr = info.getProperty(Attribute.DRDA_SECTKN_OUT);
1:7233e33: 
1:7233e33:         byte[] sourceSeed_ =
1:7233e33:             StringUtil.fromHexString(sourceSeedstr, 0, sourceSeedstr.length());
1:7233e33:         byte[] targetSeed_ =
1:7233e33:             StringUtil.fromHexString(targetSeedstr, 0, targetSeedstr.length());
1:7233e33: 
1:7233e33:         String hexString = null;
1:5d3b815:         // If user is at the database level, we don't hash the password
1:5d3b815:         // as it is already hashed (BUILTIN scheme) - we only do the
1:5d3b815:         // BUILTIN hashing if the user is defined at the system level
1:7233e33:         // only - this is required beforehands so that we can do the password
1:7233e33:         // substitute generation right afterwards.
1:7233e33:         if (!databaseUser)
1:7233e33:         {
1:178ca0c:             bytePasswd = toHexByte(password);
1:7233e33:             messageDigest.update(bytePasswd);
1:5d3b815:             byte[] hashedVal = messageDigest.digest();
1:a84fc26:             hexString = PasswordHasher.ID_PATTERN_SHA1_SCHEME +
1:5d3b815:                 StringUtil.toHexString(hashedVal, 0, hashedVal.length);
1:7233e33:         }
1:a0dbbd7:         else
1:23f97a5:         {
1:5d3b815:             // Already hashed from the database store
1:23f97a5:             // NOTE: If the password was stored with the configurable hash
1:23f97a5:             // authentication scheme, the stored password will have been hashed
1:23f97a5:             // with a different algorithm than the hashed password sent from
1:23f97a5:             // the client. Since there's no way to decrypt the stored password
1:23f97a5:             // and rehash it with the algorithm that the client uses, we are
1:23f97a5:             // not able to compare the passwords, and the connection attempt
1:23f97a5:             // will fail.
1:7233e33:             hexString = password;
1:7233e33:         }
1:7233e33: 
1:7233e33:         // Generate the password substitute now
1:7233e33: 
1:7233e33:         // Generate some 20-byte password token
1:7233e33:         messageDigest.update(userBytes);
1:178ca0c:         messageDigest.update(toHexByte(hexString));
1:7233e33:         byte[] passwordToken = messageDigest.digest();
1:7233e33:         
1:7233e33:         // Now we generate the 20-byte password substitute
1:7233e33:         messageDigest.update(passwordToken);
1:7233e33:         messageDigest.update(targetSeed_);
1:7233e33:         messageDigest.update(sourceSeed_);
1:7233e33:         messageDigest.update(userBytes);
1:7233e33:         messageDigest.update(SECMEC_USRSSBPWD_PWDSEQS);
1:7233e33: 
1:7233e33:         passwordSubstitute = messageDigest.digest();
1:7233e33: 
1:7233e33:         return StringUtil.toHexString(passwordSubstitute, 0,
1:7233e33:                                       passwordSubstitute.length);
1:a0dbbd7:     }
1:60edeb0: 
1:60edeb0:     /**
1:a0dbbd7:      * Privileged lookup of the ContextService. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  ContextService    getContextService()
1:a0dbbd7:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ContextService>()
1:56c1dc2:              {
1:56c1dc2:                  public ContextService run()
1:a0dbbd7:                  {
1:56c1dc2:                      return ContextService.getFactory();
1:56c1dc2:                  }
1:a0dbbd7:              }
1:56c1dc2:              );
1:a0dbbd7:     }
1:a0dbbd7: 
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of a Context. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  Context    getContext( final String contextID )
1:a0dbbd7:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<Context>()
1:56c1dc2:              {
1:56c1dc2:                  public Context run()
1:a0dbbd7:                  {
1:56c1dc2:                      return ContextService.getContext( contextID );
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:a0dbbd7:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged service name lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  String getServiceName( final Object serviceModule )
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<String>()
1:56c1dc2:              {
1:56c1dc2:                  public String run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getServiceName( serviceModule );
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged module lookup. Must be package protected so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     static  Object getServiceModule( final Object serviceModule, final String factoryInterface )
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<Object>()
1:56c1dc2:              {
1:56c1dc2:                  public Object run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getServiceModule( serviceModule, factoryInterface );
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:a0dbbd7:     }
1:a0dbbd7: 
1:a0dbbd7: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                 return passwordLifetime;
/////////////////////////////////////////////////////////////////////////
1:                 else { return expirationThreshold; }
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: 				getServiceModule(this, AccessFactory.MODULE);
1: 				getServiceModule(this, org.apache.derby.iapi.reference.Module.PropertyFactory);
/////////////////////////////////////////////////////////////////////////
1:         else { return getServiceName( store ); }
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ContextService>()
1:              {
1:                  public ContextService run()
1:                      return ContextService.getFactory();
1:              }
1:              );
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<Context>()
1:              {
1:                  public Context run()
1:                      return ContextService.getContext( contextID );
1:              }
1:              );
1:     }
1: 
1:     /**
1:      * Privileged service name lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  String getServiceName( final Object serviceModule )
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<String>()
1:              {
1:                  public String run()
1:                  {
1:                      return Monitor.getServiceName( serviceModule );
1:                  }
1:              }
1:              );
1:     }
1: 
1:     /**
1:      * Privileged module lookup. Must be package protected so that user code
1:      * can't call this entry point.
1:      */
1:     static  Object getServiceModule( final Object serviceModule, final String factoryInterface )
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<Object>()
1:              {
1:                  public Object run()
1:                  {
1:                      return Monitor.getServiceModule( serviceModule, factoryInterface );
1:                  }
1:              }
1:              );
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.Context;
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
1: import java.security.AccessController;
/////////////////////////////////////////////////////////////////////////
1:             return store.getTransaction( getContextService().getCurrentContextManager() );
/////////////////////////////////////////////////////////////////////////
1:                 getContextService().getCurrentContextManager());
/////////////////////////////////////////////////////////////////////////
1:             getContext(LanguageConnectionContext.CONTEXT_ID);
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Privileged lookup of the ContextService. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ContextService    getContextService()
1:     {
0:         if ( System.getSecurityManager() == null )
1:         {
0:             return ContextService.getFactory();
1:         }
1:         else
1:         {
0:             return AccessController.doPrivileged
0:                 (
0:                  new PrivilegedAction<ContextService>()
1:                  {
0:                      public ContextService run()
1:                      {
0:                          return ContextService.getFactory();
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
1:     /**
1:      * Privileged lookup of a Context. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Context    getContext( final String contextID )
1:     {
0:         if ( System.getSecurityManager() == null )
1:         {
0:             return ContextService.getContext( contextID );
1:         }
1:         else
1:         {
0:             return AccessController.doPrivileged
0:                 (
0:                  new PrivilegedAction<Context>()
1:                  {
0:                      public Context run()
1:                      {
0:                          return ContextService.getContext( contextID );
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
commit:65bdc4d
/////////////////////////////////////////////////////////////////////////
1:                 throw  StandardException.newException( SQLState.PROPERTY_DBO_LACKS_CREDENTIALS );
commit:2489f47
/////////////////////////////////////////////////////////////////////////
1:             {
0:                 throw  StandardException.newException( SQLState.PROPERTY_BAD_NATIVE_VALUE );
1:             }
1:             {
1:                 throw StandardException.newException( SQLState.PROPERTY_CANT_UNDO_NATIVE );
1:             }
/////////////////////////////////////////////////////////////////////////
1:                 if ( userCredentials == null )
1:                 {
1:                     throw StandardException.newException( SQLState.PROPERTY_DBO_LACKS_CREDENTIALS );
1:                 }
/////////////////////////////////////////////////////////////////////////
commit:49901a4
/////////////////////////////////////////////////////////////////////////
1:         if ( Property.AUTHENTICATION_NATIVE_PASSWORD_LIFETIME.equals( key ) )
1:         {
1:             if ( parsePasswordLifetime( stringValue ) == null )
1:             {
1:                 throw StandardException.newException
1:                     ( SQLState.BAD_PASSWORD_LIFETIME, Property.AUTHENTICATION_NATIVE_PASSWORD_LIFETIME );
1:             }
1:         }
1:         
1:         if ( Property.AUTHENTICATION_PASSWORD_EXPIRATION_THRESHOLD.equals( key ) )
1:         {
1:             if ( parsePasswordThreshold( stringValue ) == null )
1:             {
1:                 throw StandardException.newException
1:                     ( SQLState.BAD_PASSWORD_LIFETIME, Property.AUTHENTICATION_PASSWORD_EXPIRATION_THRESHOLD );
1:             }
1:         }
1:         
1:     /** Parse the value of the password lifetime property. Return null if it is bad. */
1:     protected   Long    parsePasswordLifetime( String passwordLifetimeString )
1:     {
1:             try {
1:                 long    passwordLifetime = Long.parseLong( passwordLifetimeString );
1: 
1:                 if ( passwordLifetime < 0L ) { passwordLifetime = 0L; }
1: 
0:                 return new Long( passwordLifetime );
1:             } catch (Exception e) { return null; }
1:     }
1:     /** Parse the value of the password expiration threshold property. Return null if it is bad. */
1:     protected   Double  parsePasswordThreshold( String expirationThresholdString )
1:     {
1:             try {
1:                 double  expirationThreshold = Double.parseDouble( expirationThresholdString );
1: 
1:                 if ( expirationThreshold <= 0L ) { return null; }
0:                 else { return new Double( expirationThreshold ); }
1:             } catch (Exception e) { return null; }
1:     }
commit:c0399dc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.UserDescriptor;
/////////////////////////////////////////////////////////////////////////
1: 	public boolean validate(String key, Serializable value, Dictionary p)
1:         throws StandardException
1:     {
1: 
1:         // user password properties need to be remapped. nothing else needs remapping.
1: 		if ( key.startsWith(org.apache.derby.iapi.reference.Property.USER_PROPERTY_PREFIX) ) { return true; }
1: 
1:         String      stringValue = (String) value;
1:         boolean     settingToNativeLocal = Property.AUTHENTICATION_PROVIDER_NATIVE_LOCAL.equals( stringValue );
1:         
1:         if ( Property.AUTHENTICATION_PROVIDER_PARAMETER.equals( key ) )
1:         {
1:             // NATIVE + LOCAL is the only value of this property which can be persisted
1:             if (
1:                 ( stringValue != null ) &&
1:                 ( stringValue.startsWith( Property.AUTHENTICATION_PROVIDER_NATIVE ) )&&
1:                 !settingToNativeLocal
1:                 )
0:             { throw badNativeAuthenticationChange(); }
1: 
1:             // once set to NATIVE authentication, you can't change it
1:             String  oldValue = (String) p.get( Property.AUTHENTICATION_PROVIDER_PARAMETER );
1:             if ( (oldValue != null) && oldValue.startsWith( Property.AUTHENTICATION_PROVIDER_NATIVE ) )
0:             { throw badNativeAuthenticationChange(); }
1: 
1:             // can't turn on NATIVE + LOCAL authentication unless the DBO's credentials are already stored.
1:             // this should prevent setting NATIVE + LOCAL authentication in pre-10.9 databases too
1:             // because you can't store credentials in a pre-10.9 database.
1:             if ( settingToNativeLocal )
1:             {
1:                 DataDictionary  dd = getDataDictionary();
1:                 String              dbo = dd.getAuthorizationDatabaseOwner();
1:                 UserDescriptor  userCredentials = dd.getUser( dbo );
1: 
0:                 if ( userCredentials == null ) { throw badNativeAuthenticationChange(); }
1:             }
1:         }
1: 
1:         return false;
0:     private StandardException   badNativeAuthenticationChange()
1:     {
0:         return StandardException.newException( SQLState.PROPERTY_BAD_NATIVE_CHANGE );
1:     }
1:     
commit:5107349
/////////////////////////////////////////////////////////////////////////
1:     public  String  getSystemCredentialsDatabaseName()    { return null; }
1: 
/////////////////////////////////////////////////////////////////////////
1:           tc = getTransaction();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Get a transaction for performing authentication at the database level.
1:      * </p>
1:      */
1:     protected   TransactionController   getTransaction()
1:         throws StandardException
1:     {
1:         if ( store == null ) { return null; }
0:         else
1:         {
0:             return store.getTransaction( ContextService.getFactory().getCurrentContextManager() );
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Get the name of the database if we are performing authentication at the database level.
1:      * </p>
1:      */
1:     protected   String  getServiceName()
1:     {
1:         if ( store == null ) { return null; }
0:         else { return Monitor.getServiceName( store ); }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		if ( Boolean.valueOf(requireAuthentication).booleanValue() ) { return true; }
1: 
1:         //
1:         // NATIVE authentication does not require that you set REQUIRE_AUTHENTICATION_PARAMETER.
1:         //
1:         return PropertyUtil.nativeAuthenticationEnabled( properties );
commit:a84fc26
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.PasswordHasher;
/////////////////////////////////////////////////////////////////////////
1:  * {@link PasswordHasher#ID_PATTERN_SHA1_SCHEME}. Passwords that are stored using the
1:  * {@link PasswordHasher#ID_PATTERN_CONFIGURABLE_HASH_SCHEME} and suffixed with the name of
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         String hexString = PasswordHasher.ID_PATTERN_SHA1_SCHEME +
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             throws StandardException
1:     {
1:         if ( password ==  null ) { return null; }
1:         PasswordHasher  hasher = getDataDictionary().makePasswordHasher( props );
1:         if ( hasher != null ) { return hasher.hashAndEncode( user, password ); }
0:         else { return encryptPasswordSHA1Scheme(password); }
/////////////////////////////////////////////////////////////////////////
1:      * SHA-1 authentication scheme ({@link PasswordHasher#ID_PATTERN_SHA1_SCHEME}), so in
1:      * hash authentication scheme {@link PasswordHasher#ID_PATTERN_CONFIGURABLE_HASH_SCHEME}
/////////////////////////////////////////////////////////////////////////
1:             hexString = PasswordHasher.ID_PATTERN_SHA1_SCHEME +
commit:7233e33
/////////////////////////////////////////////////////////////////////////
1:     /**
1:         Userid with Strong password substitute DRDA security mechanism
1:     */
1:     protected static final int SECMEC_USRSSBPWD = 8;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         bytePasswd = StringUtil.toHexByte(
0:                 plainTxtUserPassword,0,plainTxtUserPassword.length());
0:         String hexString = ID_PATTERN_NEW_SCHEME +
0:                 StringUtil.toHexString(encryptVal,0,encryptVal.length);
1:     /**
1:      * Strong Password Substitution (USRSSBPWD).
1:      *
0:      * This method generate a password subtitute to authenticate a client
1:      * which is using a DRDA security mechanism such as SECMEC_USRSSBPWD.
1:      *
1:      * Depending how the user is defined in Derby and if BUILTIN
1:      * is used, the stored password can be in clear-text (system level)
1:      * or encrypted (hashed - *not decryptable*)) (database level) - If the
1:      * user has authenticated at the network level via SECMEC_USRSSBPWD, it
1:      * means we're presented with a password substitute and we need to
1:      * generate a substitute password coming from the store to compare with
1:      * the one passed-in.
1:      *
1:      * NOTE: A lot of this logic could be shared with the DRDA decryption
1:      *       and client encryption managers - This will be done _once_
1:      *       code sharing along with its rules are defined between the
1:      *       Derby engine, client and network code (PENDING).
1:      * 
1:      * Substitution algorithm works as follow:
1:      *
1:      * PW_TOKEN = SHA-1(PW, ID)
1:      * The password (PW) and user name (ID) can be of any length greater
1:      * than or equal to 1 byte.
1:      * The client generates a 20-byte password substitute (PW_SUB) as follows:
1:      * PW_SUB = SHA-1(PW_TOKEN, RDr, RDs, ID, PWSEQs)
1:      * 
1:      * w/ (RDs) as the random client seed and (RDr) as the server one.
1:      * 
1:      * See PWDSSB - Strong Password Substitution Security Mechanism
1:      * (DRDA Vol.3 - P.650)
1:      *
1: 	 * @return a substituted password.
1:      */
1:     protected String substitutePassword(
1:                 String userName,
1:                 String password,
1:                 Properties info,
1:                 boolean databaseUser) {
1:         MessageDigest messageDigest = null;
0:         // Pattern that is prefixed to the BUILTIN encrypted password
0:         String ID_PATTERN_NEW_SCHEME = "3b60";
1: 
1:         // PWSEQs's 8-byte value constant - See DRDA Vol 3
1:         byte SECMEC_USRSSBPWD_PWDSEQS[] = {
1:                 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
1:                 (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01
1:                 };
1:         
1:         // Generated password substitute
1:         byte[] passwordSubstitute;
1: 
1:         try
1:         {
1:             messageDigest = MessageDigest.getInstance("SHA-1");
1:         } catch (NoSuchAlgorithmException nsae)
1:         {
1:             // Ignore as we checked already during service boot-up
1:         }
1:         // IMPORTANT NOTE: As the password is stored single-hashed in the
1:         // database, it is impossible for us to decrypt the password and
1:         // recompute a substitute to compare with one generated on the source
1:         // side - Hence, we have to generate a password substitute.
1:         // In other words, we cannot figure what the original password was -
1:         // Strong Password Substitution (USRSSBPWD) cannot be supported for
1:         // targets which can't access or decrypt passwords on their side.
1:         //
1:         messageDigest.reset();
1: 
1:         byte[] bytePasswd = null;
0:         byte[] userBytes = StringUtil.toHexByte(userName, 0, userName.length());
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             // We must have a source and target seed 
1:             SanityManager.ASSERT(
1:               (((String) info.getProperty(Attribute.DRDA_SECTKN_IN) != null) &&
1:               ((String) info.getProperty(Attribute.DRDA_SECTKN_OUT) != null)), 
1:                 "Unexpected: Requester or server seed not available");
1:         }
1: 
1:         // Retrieve source (client)  and target 8-byte seeds
1:         String sourceSeedstr = info.getProperty(Attribute.DRDA_SECTKN_IN);
1:         String targetSeedstr = info.getProperty(Attribute.DRDA_SECTKN_OUT);
1: 
1:         byte[] sourceSeed_ =
1:             StringUtil.fromHexString(sourceSeedstr, 0, sourceSeedstr.length());
1:         byte[] targetSeed_ =
1:             StringUtil.fromHexString(targetSeedstr, 0, targetSeedstr.length());
1: 
1:         String hexString = null;
0:         // If user is at the database level, we don't encrypt the password
0:         // as it is already encrypted (BUILTIN scheme) - we only do the
0:         // BUILTIN encryption if the user is defined at the system level
1:         // only - this is required beforehands so that we can do the password
1:         // substitute generation right afterwards.
1:         if (!databaseUser)
1:         {
0:             bytePasswd = StringUtil.toHexByte(password, 0, password.length());
1:             messageDigest.update(bytePasswd);
0:             byte[] encryptVal = messageDigest.digest();
0:             hexString = ID_PATTERN_NEW_SCHEME +
0:                 StringUtil.toHexString(encryptVal, 0, encryptVal.length);
1:         }
0:         else
0:             // Already encrypted from the database store
1:             hexString = password;
1: 
1:         // Generate the password substitute now
1: 
1:         // Generate some 20-byte password token
1:         messageDigest.update(userBytes);
0:         messageDigest.update(
0:                 StringUtil.toHexByte(hexString, 0, hexString.length()));
1:         byte[] passwordToken = messageDigest.digest();
1:         
1:         // Now we generate the 20-byte password substitute
1:         messageDigest.update(passwordToken);
1:         messageDigest.update(targetSeed_);
1:         messageDigest.update(sourceSeed_);
1:         messageDigest.update(userBytes);
1:         messageDigest.update(SECMEC_USRSSBPWD_PWDSEQS);
1: 
1:         passwordSubstitute = messageDigest.digest();
1: 
1:         return StringUtil.toHexString(passwordSubstitute, 0,
1:                                       passwordSubstitute.length);
1:     }
commit:88a3cb9
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:43e6876
/////////////////////////////////////////////////////////////////////////
1: 		if ((userName != null) && userName.length() > Limits.MAX_IDENTIFIER_LENGTH) {
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5d3b815
/////////////////////////////////////////////////////////////////////////
1:  * User passwords are hashed using a message digest algorithm
1:  * if they're stored in the database. They are not hashed
1:  * The passwords can be hashed using two different schemes:
/////////////////////////////////////////////////////////////////////////
1: 		// We do not hash 'derby.user.<userName>' password if
/////////////////////////////////////////////////////////////////////////
1: 		// Ok, we can hash this password in the db
1: 			// hash (digest) the password
1:                     hashUsingDefaultAlgorithm(userName, userPassword, p);
/////////////////////////////////////////////////////////////////////////
1: 	 * This method hashes a clear user password using a
/////////////////////////////////////////////////////////////////////////
1: 	 * @return hashed user password (digest) as a String object
1: 	protected String hashPasswordSHA1Scheme(String plainTxtUserPassword)
/////////////////////////////////////////////////////////////////////////
1: 		byte[] hashedVal = algorithm.digest();
1:                 StringUtil.toHexString(hashedVal, 0, hashedVal.length);
/////////////////////////////////////////////////////////////////////////
1:      * Hash a password using the default message digest algorithm for this
1:      * system before it's stored in the database.
1:      * is a non-empty string, the password will be hashed using the
1:      * @param user the user whose password to hash
1:     String hashUsingDefaultAlgorithm(String user,
/////////////////////////////////////////////////////////////////////////
1:         else { return hashPasswordSHA1Scheme(password); }
/////////////////////////////////////////////////////////////////////////
1:         // If user is at the database level, we don't hash the password
1:         // as it is already hashed (BUILTIN scheme) - we only do the
1:         // BUILTIN hashing if the user is defined at the system level
1:             byte[] hashedVal = messageDigest.digest();
1:                 StringUtil.toHexString(hashedVal, 0, hashedVal.length);
1:             // Already hashed from the database store
commit:dcd69d3
/////////////////////////////////////////////////////////////////////////
1:      * Get all the database properties.
1:      * @return the database properties, or {@code null} if there is no
1:      * access factory
1:      */
1:     Properties getDatabaseProperties() throws StandardException {
1:         Properties props = null;
1: 
1:         TransactionController tc = getTransaction();
1:         if (tc != null) {
1:             try {
1:                 props = tc.getProperties();
1:             } finally {
1:                 tc.commit();
1:             }
1:         }
1: 
1:         return props;
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
0:     String encryptUsingDefaultAlgorithm(String user,
commit:1ede0a8
/////////////////////////////////////////////////////////////////////////
1: import java.security.SecureRandom;
/////////////////////////////////////////////////////////////////////////
0:      * Pattern that is prefixed to the stored password in the configurable
0:      * hash authentication scheme if key stretching has been applied. This
0:      * scheme extends the configurable hash scheme by adding a random salt and
0:      * applying the hash function multiple times when generating the hashed
0:      * token.
1:      */
0:     public static final String
0:             ID_PATTERN_CONFIGURABLE_STRETCHED_SCHEME = "3b62";
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
0:      * Hash credentials using the specified hash algorithm, possibly performing
0:      * key stretching by adding random salt and applying the hash function
0:      * multiple times.
1:      * </p>
1:      *
1:      * <p>
0:      * The algorithm must be supported by one of the registered security
0:      * providers in the JVM.
/////////////////////////////////////////////////////////////////////////
0:      * @param salt random salt to add to the credentials (possibly {@code null})
0:      * @param iterations the number of times to apply the hash function
0:             String user, String password, String algorithm,
0:             byte[] salt, int iterations)
0:         byte[] userBytes;
0:         byte[] passwordBytes;
1:         try {
0:             userBytes = user.getBytes(ENCODING);
0:             passwordBytes = password.getBytes(ENCODING);
0:         } catch (UnsupportedEncodingException uee) {
0:             // UTF-8 should always be available, so this should never happen.
0:             throw StandardException.plainWrapException(uee);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         byte[] digest = null;
0:         for (int i = 0; i < iterations; i++) {
0:             md.reset();
0:             if (digest != null) {
0:                 md.update(digest);
1:             }
0:             md.update(userBytes);
0:             md.update(passwordBytes);
0:             if (salt != null) {
0:                 md.update(salt);
1:             }
0:             digest = md.digest();
0:         if ((salt == null || salt.length == 0) && iterations == 1) {
0:             // No salt was used, and only a single iteration, which is
0:             // identical to the default hashing scheme in 10.6-10.8. Generate
0:             // a token on a format compatible with those old versions.
0:             return ID_PATTERN_CONFIGURABLE_HASH_SCHEME +
0:         } else {
0:             // Salt and/or multiple iterations was used, so we need to add
0:             // those parameters to the token in order to verify the credentials
0:             // later.
0:             return ID_PATTERN_CONFIGURABLE_STRETCHED_SCHEME +
0:                 StringUtil.toHexString(digest, 0, digest.length) +
0:                 SEPARATOR_CHAR + StringUtil.toHexString(salt, 0, salt.length) +
0:                 SEPARATOR_CHAR + iterations + SEPARATOR_CHAR + algorithm;
1:         }
/////////////////////////////////////////////////////////////////////////
0:         DataDictionary dd = getDataDictionary();
0:                 dd.checkVersion(DataDictionary.DD_VERSION_DERBY_10_6, null);
1: 
0:         // Support for key stretching was added in Derby 10.9, so don't use it
0:         // if the database may still be used with an older version.
0:         boolean supportKeyStretching =
0:                 dd.checkVersion(DataDictionary.DD_VERSION_DERBY_10_9, null);
/////////////////////////////////////////////////////////////////////////
0:                 byte[] salt = null;
0:                 int iterations = 1;
1: 
0:                 if (supportKeyStretching) {
0:                     salt = generateRandomSalt(props);
0:                     iterations = getIntProperty(
0:                             props,
0:                             Property.AUTHENTICATION_BUILTIN_ITERATIONS,
0:                             Property.AUTHENTICATION_BUILTIN_ITERATIONS_DEFAULT,
0:                             1, Integer.MAX_VALUE);
1:                 }
1: 
0:                         user, password, algorithm, salt, iterations);
/////////////////////////////////////////////////////////////////////////
0:      * Get the value of an integer property.
1:      *
1:      * @param props database properties
0:      * @param key the key of the property
0:      * @param defaultValue which value to return if the property is not set,
0:      *   or if the property value is not in the valid range
0:      * @param minValue lowest property value to accept
0:      * @param maxValue highest property value to accept
0:      * @return the value of the property
1:      */
0:     private int getIntProperty(
0:             Dictionary props, String key,
0:             int defaultValue, int minValue, int maxValue) {
1: 
0:         String sVal = (String) PropertyUtil.getPropertyFromSet(props, key);
1: 
0:         if (sVal != null) {
1:             try {
0:                 int i = Integer.parseInt(sVal);
0:                 if (i >= minValue && i <= maxValue) {
0:                     return i;
1:                 }
0:             } catch (NumberFormatException nfe) {
0:                 // By convention, Derby ignores property values that cannot be
0:                 // parsed. Use the default value instead.
1:             }
1:         }
1: 
0:         return defaultValue;
1:     }
1: 
1:     /**
0:      * Generate an array of random bytes to use as salt when hashing
0:      * credentials.
1:      *
0:      * @param props database properties that possibly specify the desired
0:      *   length of the salt
0:      * @return random bytes
1:      */
0:     private byte[] generateRandomSalt(Dictionary props) {
0:         int saltLength = getIntProperty(
0:                 props,
0:                 Property.AUTHENTICATION_BUILTIN_SALT_LENGTH,
0:                 Property.AUTHENTICATION_BUILTIN_SALT_LENGTH_DEFAULT,
0:                 0, Integer.MAX_VALUE);
1: 
0:         SecureRandom random = new SecureRandom();
0:         byte[] salt = new byte[saltLength];
0:         random.nextBytes(salt);
1: 
0:         return salt;
1:     }
1: 
1:     /**
commit:178ca0c
/////////////////////////////////////////////////////////////////////////
1:         bytePasswd = toHexByte(plainTxtUserPassword);
/////////////////////////////////////////////////////////////////////////
1:      * Convert a string into a byte array in hex format.
1:      * </p>
1:      *
1:      * <p>
1:      * For each character (b) two bytes are generated, the first byte
1:      * represents the high nibble (4 bits) in hexadecimal ({@code b & 0xf0}),
1:      * the second byte represents the low nibble ({@code b & 0x0f}).
1:      * </p>
1:      *
1:      * <p>
1:      * The character at {@code str.charAt(0)} is represented by the first two
1:      * bytes in the returned String.
1:      * </p>
1:      *
1:      * <p>
1:      * New code is encouraged to use {@code String.getBytes(String)} or similar
1:      * methods instead, since this method does not preserve all bits for
1:      * characters whose codepoint exceeds 8 bits. This method is preserved for
1:      * compatibility with the SHA-1 authentication scheme.
1:      * </p>
1:      *
1:      * @param str string
1:      * @return the byte[] (with hexadecimal format) form of the string (str)
1:      */
1:     private static byte[] toHexByte(String str)
1:     {
1:         byte[] data = new byte[str.length() * 2];
1: 
1:         for (int i = 0; i < str.length(); i++)
1:         {
1:             char ch = str.charAt(i);
1:             int high_nibble = (ch & 0xf0) >>> 4;
1:             int low_nibble = (ch & 0x0f);
1:             data[i] = (byte)high_nibble;
1:             data[i+1] = (byte)low_nibble;
1:         }
1:         return data;
1:     }
1: 
1:     /**
1:      * <p>
/////////////////////////////////////////////////////////////////////////
1:         byte[] userBytes = toHexByte(userName);
/////////////////////////////////////////////////////////////////////////
1:             bytePasswd = toHexByte(password);
/////////////////////////////////////////////////////////////////////////
1:         messageDigest.update(toHexByte(hexString));
commit:23f97a5
/////////////////////////////////////////////////////////////////////////
1:      * This method generates a password substitute to authenticate a client
/////////////////////////////////////////////////////////////////////////
1:      * The substitution algorithm used is the same as the one used in the
0:      * SHA-1 authentication scheme ({@link #ID_PATTERN_SHA1_SCHEME}), so in
1:      * the case of database passwords stored using that scheme, we can simply
1:      * compare the received hash with the stored hash. If the configurable
0:      * hash authentication scheme {@link #ID_PATTERN_CONFIGURABLE_HASH_SCHEME}
1:      * is used, we have no way to find out if the received hash matches the
1:      * stored password, since we cannot decrypt the hashed passwords and
1:      * re-apply another hash algorithm. Therefore, strong password substitution
1:      * only works if the database-level passwords are stored with the SHA-1
1:      * scheme.
1:      *
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             hexString = ID_PATTERN_SHA1_SCHEME +
1:         {
1:             // NOTE: If the password was stored with the configurable hash
1:             // authentication scheme, the stored password will have been hashed
1:             // with a different algorithm than the hashed password sent from
1:             // the client. Since there's no way to decrypt the stored password
1:             // and rehash it with the algorithm that the client uses, we are
1:             // not able to compare the passwords, and the connection attempt
1:             // will fail.
1:         }
commit:60edeb0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: 
1: import java.io.UnsupportedEncodingException;
1: import org.apache.derby.iapi.reference.SQLState;
1:  * <p>
1:  * </p>
1: 
1:  * </p>
1:  *
1:  * </p>
1:  * <p><strong>IMPORTANT NOTE:</strong></p>
1:  *
1:  * <p>
0:  * User passwords are encrypted using a message digest algorithm
1:  * </p>
1:  * <p>
0:  * The passwords can be encrypted using two different schemes:
1:  * </p>
1:  *
1:  * <ul>
1:  * <li>The SHA-1 authentication scheme, which was the only available scheme
1:  * in Derby 10.5 and earlier. This scheme uses the SHA-1 message digest
1:  * algorithm.</li>
1:  * <li>The configurable hash authentication scheme, which allows the users to
1:  * specify which message digest algorithm to use.</li>
1:  * </ul>
1:  *
1:  * <p>
1:  * In order to use the configurable hash authentication scheme, the users have
1:  * to set the {@code derby.authentication.builtin.algorithm} property (on
1:  * system level or database level) to the name of an algorithm that's available
1:  * in one of the security providers registered on the system. If this property
1:  * is not set, or if it's set to NULL or an empty string, the SHA-1
1:  * authentication scheme is used.
1:  * </p>
1:  *
1:  * <p>
1:  * Which scheme to use is decided when a password is about to be stored in the
1:  * database. One database may therefore contain passwords stored using
1:  * different schemes. In order to determine which scheme to use when comparing
1:  * a user's credentials with those stored in the database, the stored password
1:  * is prefixed with an identifier that tells which scheme is being used.
1:  * Passwords stored using the SHA-1 authentication scheme are prefixed with
0:  * {@link #ID_PATTERN_SHA1_SCHEME}. Passwords that are stored using the
1:  * configurable hash authentication scheme are prefixed with
0:  * {@link #ID_PATTERN_CONFIGURABLE_HASH_SCHEME} and suffixed with the name of
1:  * the message digest algorithm.
1:  * </p>
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Pattern that is prefixed to the stored password in the SHA-1
0:      * authentication scheme.
1:      */
0:     public static final String ID_PATTERN_SHA1_SCHEME = "3b60";
1: 
1:     /**
0:      * Pattern that is prefixed to the stored password in the configurable
0:      * hash authentication scheme.
1:      */
0:     public static final String ID_PATTERN_CONFIGURABLE_HASH_SCHEME = "3b61";
1:     /**
0:      * The encoding to use when converting the credentials to a byte array
0:      * that can be passed to the hash function in the configurable hash scheme.
1:      */
0:     private static final String ENCODING = "UTF-8";
1: 
1:     /**
0:      * Character that separates the hash value from the name of the hash
0:      * algorithm in the stored password generated by the configurable hash
0:      * authentication scheme.
1:      */
0:     static final char SEPARATOR_CHAR = ':';
/////////////////////////////////////////////////////////////////////////
1:             String userName =
1:                     key.substring(Property.USER_PROPERTY_PREFIX.length());
1:             userPassword =
0:                     encryptUsingDefaultAlgorithm(userName, userPassword, p);
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * </p>
1:      * <p>
1:      * </p>
1:      *
1:      * <p>
1:      * This method is only used by the SHA-1 authentication scheme.
1:      * </p>
1:      *         or {@code null} if the plaintext password is {@code null}
0: 	protected String encryptPasswordSHA1Scheme(String plainTxtUserPassword)
/////////////////////////////////////////////////////////////////////////
0:         String hexString = ID_PATTERN_SHA1_SCHEME +
1:      * <p>
0:      * Encrypt a password using the specified hash algorithm and with the
0:      * user name as extra salt. The algorithm must be supported by one of
0:      * the registered security providers in the JVM.
1:      * </p>
1:      *
1:      * <p>
0:      * This method is only used by the configurable hash authentication scheme.
1:      * </p>
1:      *
0:      * @param user the user whose password to encrypt
1:      * @param password the plain text password
0:      * @param algorithm the hash algorithm to use
1:      * @return a digest of the user name and password formatted as a string,
1:      *         or {@code null} if {@code password} is {@code null}
1:      * @throws StandardException if the specified algorithm is not supported
1:      */
0:     String encryptPasswordConfigurableScheme(
0:             String user, String password, String algorithm)
1:             throws StandardException
1:     {
0:         if (password == null) {
1:             return null;
1:         }
1: 
0:         MessageDigest md;
0:         try {
0:             md = MessageDigest.getInstance(algorithm);
0:         } catch (NoSuchAlgorithmException nsae) {
0:             throw StandardException.newException(
0:                     SQLState.DIGEST_NO_SUCH_ALGORITHM, nsae, algorithm);
1:         }
1: 
0:         md.reset();
1: 
0:         try {
0:             md.update(user.getBytes(ENCODING));
0:             md.update(password.getBytes(ENCODING));
0:         } catch (UnsupportedEncodingException uee) {
0:             // UTF-8 should always be available, so this should never happen.
0:             throw StandardException.plainWrapException(uee);
1:         }
1: 
0:         byte[] digest = md.digest();
1: 
0:         return ID_PATTERN_CONFIGURABLE_HASH_SCHEME +
0:                 StringUtil.toHexString(digest, 0, digest.length) +
0:                 SEPARATOR_CHAR + algorithm;
1:     }
1: 
1:     /**
1:      * <p>
0:      * Encrypt a password using the default hash algorithm for this system
0:      * before it's stored in the database.
1:      * </p>
1:      *
1:      * <p>
1:      * If the data dictionary supports the configurable hash authentication
1:      * scheme, and the property {@code derby.authentication.builtin.algorithm}
0:      * is a non-empty string, the password will be encrypted using the
1:      * algorithm specified by that property. Otherwise, we fall back to the new
1:      * authentication scheme based on SHA-1. The algorithm used is encoded in
1:      * the returned token so that the code that validates a user's credentials
1:      * knows which algorithm to use.
1:      * </p>
1:      *
0:      * @param user the user whose password to encrypt
1:      * @param password the plain text password
0:      * @param props database properties
1:      * @return a digest of the user name and password formatted as a string,
1:      *         or {@code null} if {@code password} is {@code null}
1:      * @throws StandardException if the specified algorithm is not supported
1:      */
0:     private String encryptUsingDefaultAlgorithm(String user,
1:                                                 String password,
1:                                                 Dictionary props)
0:             throws StandardException {
1: 
0:         // Support for configurable hash algorithm was added in Derby 10.6, so
0:         // we don't want to store a hash using the new scheme if the database
0:         // is running in soft upgrade and may be used with an older version
0:         // later.
0:         boolean supportConfigurableHash =
0:                 getDataDictionary().checkVersion(
0:                         DataDictionary.DD_VERSION_DERBY_10_6, null);
1: 
0:         if (supportConfigurableHash) {
0:             String algorithm = (String)
0:                     PropertyUtil.getPropertyFromSet(
0:                         props,
0:                         Property.AUTHENTICATION_BUILTIN_ALGORITHM);
1: 
0:             if (algorithm != null && algorithm.length() > 0) {
0:                 return encryptPasswordConfigurableScheme(
0:                         user, password, algorithm);
1:             }
1:         }
1: 
0:         return encryptPasswordSHA1Scheme(password);
1:     }
1: 
1:     /**
1:      * Find the data dictionary for the current connection.
1:      *
1:      * @return the {@code DataDictionary} for the current connection
1:      */
1:     private static DataDictionary getDataDictionary() {
1:         LanguageConnectionContext lcc = (LanguageConnectionContext)
0:             ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
1:         return lcc.getDataDictionary();
1:     }
1: 
1:     /**
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1:  * There can be 1 Authentication Service for the whole Derby
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
0: 		if ((userName != null) && userName.length() > Limits.DB2_MAX_USERID_LENGTH) {
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.jdbc.authentication.AuthenticationServiceBase
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc.authentication
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.jdbc.authentication;
1: 
1: import org.apache.derby.authentication.UserAuthenticator;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.jdbc.AuthenticationService;
1: 
0: import org.apache.derby.iapi.reference.DB2Limit;
1: 
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
1: 
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.daemon.Serviceable;
1: 
1: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1: import org.apache.derby.iapi.services.monitor.ModuleControl;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.store.access.AccessFactory;
1: import org.apache.derby.iapi.services.property.PropertyFactory;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.services.property.PropertySetCallback;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.reference.Attribute;
1: 
1: import org.apache.derby.iapi.services.property.PropertyUtil;
1: import org.apache.derby.iapi.util.StringUtil;
1: 
1: import java.security.MessageDigest;
1: import java.security.NoSuchAlgorithmException;
1: 
1: import java.io.Serializable;
1: import java.util.Dictionary;
1: import java.util.Properties;
0: import java.util.Date;
1: 
1: /**
1:  * This is the authentication service base class.
0:  * <p>
0:  * There can be 1 Authentication Service for the whole Cloudscape
1:  * system and/or 1 authentication per database.
1:  * In a near future, we intend to allow multiple authentication services
1:  * per system and/or per database.
0:  * <p>
1:  * It should be extended by the specialized authentication services.
1:  *
0:  * IMPORTANT NOTE:
0:  * --------------
0:  * User passwords are encrypted using SHA-1 message digest algorithm
0:  * if they're stored in the database; otherwise they are not encrypted
1:  * if they were defined at the system level.
0:  * SHA-1 digest is single hash (one way) digest and is considered very
0:  * secure (160 bits).
1:  *
0:  * @author Francois
1:  */
1: public abstract class AuthenticationServiceBase
1: 	implements AuthenticationService, ModuleControl, ModuleSupportable, PropertySetCallback {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
1: 	protected UserAuthenticator authenticationScheme; 
1: 
1: 	// required to retrieve service properties
1: 	private AccessFactory store;
1: 
1: 	/**
1: 		Trace flag to trace authentication operations
1: 	*/
1: 	public static final String AuthenticationTrace =
1: 						SanityManager.DEBUG ? "AuthenticationTrace" : null;
1: 	/**
0: 		Pattern that is prefixed to the stored password in the new authentication scheme
1: 	*/
0: 	public static final String ID_PATTERN_NEW_SCHEME = "3b60";
1: 
1: 
1: 	/**
0: 		Length of the encrypted password in the new authentication scheme
0: 		See Beetle4601
1: 	*/
0: 	public static final int MAGICLEN_NEWENCRYPT_SCHEME=44;
1: 
1: 	//
1: 	// constructor
1: 	//
1: 	public AuthenticationServiceBase() {
1: 	}
1: 
1: 	protected void setAuthenticationService(UserAuthenticator aScheme) {
1: 		// specialized class is the principal caller.
1: 		this.authenticationScheme = aScheme;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(this.authenticationScheme != null, 
1: 				"There is no authentication scheme for that service!");
1: 		
1: 			if (SanityManager.DEBUG_ON(AuthenticationTrace)) {
1: 
1: 				java.io.PrintWriter iDbgStream =
1: 					SanityManager.GET_DEBUG_STREAM();
1: 
1: 				iDbgStream.println("Authentication Service: [" +
1: 								this.toString() + "]");
1: 				iDbgStream.println("Authentication Scheme : [" +
1: 								this.authenticationScheme.toString() + "]");
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	/*
1: 	** Methods of module control - To be overriden
1: 	*/
1: 
1: 	/**
1: 		Start this module.  In this case, nothing needs to be done.
1: 		@see org.apache.derby.iapi.services.monitor.ModuleControl#boot
1: 
1: 		@exception StandardException upon failure to load/boot
1: 		the expected authentication service.
1: 	 */
1: 	 public void boot(boolean create, Properties properties)
1: 	  throws StandardException
1: 	 {
1: 			//
1: 			// we expect the Access factory to be available since we're
1: 			// at boot stage.
1: 			//
1: 			store = (AccessFactory)
0: 				Monitor.getServiceModule(this, AccessFactory.MODULE);
1: 			// register to be notified upon db properties changes
1: 			// _only_ if we're on a database context of course :)
1: 
1: 			PropertyFactory pf = (PropertyFactory)
0: 				Monitor.getServiceModule(this, org.apache.derby.iapi.reference.Module.PropertyFactory);
1: 			if (pf != null)
1: 				pf.addPropertySetNotification(this);
1: 
1: 	 }
1: 
1: 	/**
1: 	 * @see org.apache.derby.iapi.services.monitor.ModuleControl#stop
1: 	 */
1: 	public void stop() {
1: 
1: 		// nothing special to be done yet.
1: 	}
1: 	/*
1: 	** Methods of AuthenticationService
1: 	*/
1: 
1: 	/**
1: 	 * Authenticate a User inside JBMS.T his is an overload method.
1: 	 *
1: 	 * We're passed-in a Properties object containing user credentials information
1: 	 * (as well as database name if user needs to be validated for a certain
1: 	 * database access).
1: 	 *
1: 	 * @see
1: 	 * org.apache.derby.iapi.jdbc.AuthenticationService#authenticate
1: 	 *
1: 	 *
1: 	 */
1: 	public boolean authenticate(String databaseName, Properties userInfo) throws java.sql.SQLException
1: 	{
1: 		if (userInfo == (Properties) null)
1: 			return false;
1: 
1: 		String userName = userInfo.getProperty(Attribute.USERNAME_ATTR);
0: 		if ((userName != null) && userName.length() > DB2Limit.MAX_USERID_LENGTH) {
0: 		// DB2 has limits on length of the user id, so we enforce the same.
0: 		// This used to be error 28000 "Invalid authorization ID", but with v82,
0: 		// DB2 changed the behavior to return a normal "authorization failure
0: 		// occurred" error; so that means just return "false" and the correct
0: 		// exception will be thrown as usual.
1: 			return false;
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (SanityManager.DEBUG_ON(AuthenticationTrace)) {
1: 
1: 				java.io.PrintWriter iDbgStream =
1: 					SanityManager.GET_DEBUG_STREAM();
1: 
1: 				iDbgStream.println(
1: 								" - Authentication request: user [" +
1: 							    userName + "]"+ ", database [" +
1: 							    databaseName + "]");
1: 				// The following will print the stack trace of the
1: 				// authentication request to the log.  
1: 				//Throwable t = new Throwable();
1: 				//istream.println("Authentication Request Stack trace:");
1: 				//t.printStackTrace(istream.getPrintWriter());
1: 			}
1: 		}
1: 		return this.authenticationScheme.authenticateUser(userName,
1: 						  userInfo.getProperty(Attribute.PASSWORD_ATTR),
1: 						  databaseName,
1: 						  userInfo
0: 						 );
1: 	}
1: 
1: 	/**
1: 	 * Returns a property if it was set at the database or
1: 	 * system level. Treated as SERVICE property by default.
1: 	 *
1: 	 * @return a property string value.
1: 	 **/
1: 	public String getProperty(String key) {
1: 
1: 		String propertyValue = null;
1: 		TransactionController tc = null;
1: 
0: 		try {
1: 
1: 		  if (store != null)
1:           {
1:             tc = store.getTransaction(
0:                 ContextService.getFactory().getCurrentContextManager());
1:           }
1: 
1: 		  propertyValue =
1: 			PropertyUtil.getServiceProperty(tc,
1: 											key,
1: 											(String) null);
1: 		  if (tc != null) {
1: 			tc.commit();
1: 			tc = null;
1: 		  }
1: 
1: 		} catch (StandardException se) {
1: 			// Do nothing and just return
1: 		}
1: 
1: 		return propertyValue;
1: 	}
1: 
1: 	public String getDatabaseProperty(String key) {
1: 
1: 		String propertyValue = null;
1: 		TransactionController tc = null;
1: 
0: 		try {
1: 
1: 		  if (store != null)
1: 			tc = store.getTransaction(
0:                 ContextService.getFactory().getCurrentContextManager());
1: 
1: 		  propertyValue =
1: 			PropertyUtil.getDatabaseProperty(tc, key);
1: 
1: 		  if (tc != null) {
1: 			tc.commit();
1: 			tc = null;
1: 		  }
1: 
1: 		} catch (StandardException se) {
1: 			// Do nothing and just return
1: 		}
1: 
1: 		return propertyValue;
1: 	}
1: 
1: 	public String getSystemProperty(String key) {
1: 
1: 		boolean dbOnly = false;
1: 		dbOnly = Boolean.valueOf(
1: 					this.getDatabaseProperty(
1: 							Property.DATABASE_PROPERTIES_ONLY)).booleanValue();
1: 
1: 		if (dbOnly)
1: 			return null;
1: 
1: 		return PropertyUtil.getSystemProperty(key);
1: 	}
1: 
1: 	/*
1: 	** Methods of PropertySetCallback
1: 	*/
1: 	public void init(boolean dbOnly, Dictionary p) {
1: 		// not called yet ...
1: 	}
1: 
1: 	/**
1: 	  @see PropertySetCallback#validate
1: 	*/
0: 	public boolean validate(String key, Serializable value, Dictionary p)	{
0: 		return key.startsWith(org.apache.derby.iapi.reference.Property.USER_PROPERTY_PREFIX);
1: 	}
1: 	/**
1: 	  @see PropertySetCallback#validate
1: 	*/
1: 	public Serviceable apply(String key,Serializable value,Dictionary p)
1: 	{
1: 		return null;
1: 	}
1: 	/**
1: 	  @see PropertySetCallback#map
1: 	  @exception StandardException Thrown on error.
1: 	*/
1: 	public Serializable map(String key, Serializable value, Dictionary p)
1: 		throws StandardException
1: 	{
1: 		// We only care for "derby.user." property changes
1: 		// at the moment.
1: 		if (!key.startsWith(org.apache.derby.iapi.reference.Property.USER_PROPERTY_PREFIX)) return null;
0: 		// We do not encrypt 'derby.user.<userName>' password if
1: 		// the configured authentication service is LDAP as the
1: 		// same property could be used to store LDAP user full DN (X500).
1: 		// In performing this check we only consider database properties
1: 		// not system, service or application properties.
1: 
1: 		String authService =
1: 			(String)p.get(org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_PARAMETER);
1: 
1: 		if ((authService != null) &&
1: 			 (StringUtil.SQLEqualsIgnoreCase(authService, org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_LDAP)))
1: 			return null;
1: 
0: 		// Ok, we can encrypt this password in the db
1: 		String userPassword = (String) value;
1: 
1: 		if (userPassword != null) {
0: 			// encrypt (digest) the password
1: 			// the caller will retrieve the new value
0: 			userPassword = encryptPassword(userPassword);
1: 		}
1: 
1: 		return userPassword;
1: 	}
1: 
1: 
1: 	// Class implementation
1: 
1: 	protected final boolean requireAuthentication(Properties properties) {
1: 
1: 		//
1: 		// we check if derby.connection.requireAuthentication system
1: 		// property is set to true, otherwise we are the authentication
1: 		// service that should be run.
1: 		//
1: 		String requireAuthentication = PropertyUtil.getPropertyFromSet(
1: 					properties,
1: 					org.apache.derby.iapi.reference.Property.REQUIRE_AUTHENTICATION_PARAMETER
0: 														);
0: 		return Boolean.valueOf(requireAuthentication).booleanValue();
1: 	}
1: 	/**
0: 	 * This method encrypts a clear user password using a
1: 	 * Single Hash algorithm such as SHA-1 (SHA equivalent)
1: 	 * (it is a 160 bits digest)
1: 	 *
1: 	 * The digest is returned as an object string.
1: 	 *
1: 	 * @param plainTxtUserPassword Plain text user password
1: 	 *
0: 	 * @return encrypted user password (digest) as a String object
1: 	 */
0: 	protected String encryptPassword(String plainTxtUserPassword)
1: 	{
1: 		if (plainTxtUserPassword == null)
1: 			return null;
1: 
1: 		MessageDigest algorithm = null;
1: 		try
1: 		{
1: 			algorithm = MessageDigest.getInstance("SHA-1");
1: 		} catch (NoSuchAlgorithmException nsae)
1: 		{
1: 					// Ignore as we checked already during service boot-up
1: 		}
1: 
1: 		algorithm.reset();
1: 		byte[] bytePasswd = null;
0: 		bytePasswd = AuthenticationServiceBase.toHexByte(plainTxtUserPassword,0,plainTxtUserPassword.length());
1: 		algorithm.update(bytePasswd);
0: 		byte[] encryptVal = algorithm.digest();
0: 		String hexString = ID_PATTERN_NEW_SCHEME + org.apache.derby.iapi.util.StringUtil.toHexString(encryptVal,0,encryptVal.length);
1: 		return (hexString);
1: 
1: 	}
1: 	/**
1:   
0: 	   Convert a string into a byte array in hex format.
0: 	   <BR>
0: 	   For each character (b) two bytes are generated, the first byte 
0: 	   represents the high nibble (4 bits) in hexidecimal (<code>b & 0xf0</code>),
0:            the second byte 
0: 	   represents the low nibble (<code>b & 0x0f</code>).
0: 	   <BR>
0: 	   The character at <code>str.charAt(0)</code> is represented by the first two bytes 
0: 	   in the returned String.
1: 
0: 	   @param	str string 
0: 	   @param	offset	starting character (zero based) to convert.
0: 	   @param	length	number of characters to convert.
1: 
0: 	   @return the byte[]  (with hexidecimal format) form of the string (str) 
1: 	*/
0: 	public static byte[] toHexByte(String str, int offset, int length)
1: 	{
0:   	    byte[] data = new byte[(length - offset) * 2];
0: 	    int end = offset+length;
1: 
0:             for (int i = offset; i < end; i++)
1:  	    {
0: 	        char ch = str.charAt(i);
0: 		int high_nibble = (ch & 0xf0) >>> 4;
0: 		int low_nibble = (ch & 0x0f);
0: 		data[i] = (byte)high_nibble;
0: 		data[i+1] = (byte)low_nibble;
1: 	    }
0: 	    return data;
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc.authentication
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.jdbc.authentication;
0: 
0: import org.apache.derby.authentication.UserAuthenticator;
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.jdbc.AuthenticationService;
0: 
0: import org.apache.derby.iapi.reference.DB2Limit;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.daemon.Serviceable;
0: 
0: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
0: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.store.access.AccessFactory;
0: import org.apache.derby.iapi.services.property.PropertyFactory;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.services.property.PropertySetCallback;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.reference.Attribute;
0: 
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import java.security.MessageDigest;
0: import java.security.NoSuchAlgorithmException;
0: 
0: import java.io.Serializable;
0: import java.util.Dictionary;
0: import java.util.Properties;
0: import java.util.Date;
0: 
0: /**
0:  * This is the authentication service base class.
0:  * <p>
0:  * There can be 1 Authentication Service for the whole Cloudscape
0:  * system and/or 1 authentication per database.
0:  * In a near future, we intend to allow multiple authentication services
0:  * per system and/or per database.
0:  * <p>
0:  * It should be extended by the specialized authentication services.
0:  *
0:  * IMPORTANT NOTE:
0:  * --------------
0:  * User passwords are encrypted using SHA-1 message digest algorithm
0:  * if they're stored in the database; otherwise they are not encrypted
0:  * if they were defined at the system level.
0:  * SHA-1 digest is single hash (one way) digest and is considered very
0:  * secure (160 bits).
0:  *
0:  * @author Francois
0:  */
0: public abstract class AuthenticationServiceBase
0: 	implements AuthenticationService, ModuleControl, ModuleSupportable, PropertySetCallback {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0: 	protected UserAuthenticator authenticationScheme; 
0: 
0: 	// required to retrieve service properties
0: 	private AccessFactory store;
0: 
0: 	/**
0: 		Trace flag to trace authentication operations
0: 	*/
0: 	public static final String AuthenticationTrace =
0: 						SanityManager.DEBUG ? "AuthenticationTrace" : null;
0: 	/**
0: 		Pattern that is prefixed to the stored password in the new authentication scheme
0: 	*/
0: 	public static final String ID_PATTERN_NEW_SCHEME = "3b60";
0: 
0: 
0: 	/**
0: 		Length of the encrypted password in the new authentication scheme
0: 		See Beetle4601
0: 	*/
0: 	public static final int MAGICLEN_NEWENCRYPT_SCHEME=44;
0: 
0: 	//
0: 	// constructor
0: 	//
0: 	public AuthenticationServiceBase() {
0: 	}
0: 
0: 	protected void setAuthenticationService(UserAuthenticator aScheme) {
0: 		// specialized class is the principal caller.
0: 		this.authenticationScheme = aScheme;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(this.authenticationScheme != null, 
0: 				"There is no authentication scheme for that service!");
0: 		
0: 			if (SanityManager.DEBUG_ON(AuthenticationTrace)) {
0: 
0: 				java.io.PrintWriter iDbgStream =
0: 					SanityManager.GET_DEBUG_STREAM();
0: 
0: 				iDbgStream.println("Authentication Service: [" +
0: 								this.toString() + "]");
0: 				iDbgStream.println("Authentication Scheme : [" +
0: 								this.authenticationScheme.toString() + "]");
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	/*
0: 	** Methods of module control - To be overriden
0: 	*/
0: 
0: 	/**
0: 		Start this module.  In this case, nothing needs to be done.
0: 		@see org.apache.derby.iapi.services.monitor.ModuleControl#boot
0: 
0: 		@exception StandardException upon failure to load/boot
0: 		the expected authentication service.
0: 	 */
0: 	 public void boot(boolean create, Properties properties)
0: 	  throws StandardException
0: 	 {
0: 			//
0: 			// we expect the Access factory to be available since we're
0: 			// at boot stage.
0: 			//
0: 			store = (AccessFactory)
0: 				Monitor.getServiceModule(this, AccessFactory.MODULE);
0: 			// register to be notified upon db properties changes
0: 			// _only_ if we're on a database context of course :)
0: 
0: 			PropertyFactory pf = (PropertyFactory)
0: 				Monitor.getServiceModule(this, org.apache.derby.iapi.reference.Module.PropertyFactory);
0: 			if (pf != null)
0: 				pf.addPropertySetNotification(this);
0: 
0: 	 }
0: 
0: 	/**
0: 	 * @see org.apache.derby.iapi.services.monitor.ModuleControl#stop
0: 	 */
0: 	public void stop() {
0: 
0: 		// nothing special to be done yet.
0: 	}
0: 	/*
0: 	** Methods of AuthenticationService
0: 	*/
0: 
0: 	/**
0: 	 * Authenticate a User inside JBMS.T his is an overload method.
0: 	 *
0: 	 * We're passed-in a Properties object containing user credentials information
0: 	 * (as well as database name if user needs to be validated for a certain
0: 	 * database access).
0: 	 *
0: 	 * @see
0: 	 * org.apache.derby.iapi.jdbc.AuthenticationService#authenticate
0: 	 *
0: 	 *
0: 	 */
0: 	public boolean authenticate(String databaseName, Properties userInfo) throws java.sql.SQLException
0: 	{
0: 		if (userInfo == (Properties) null)
0: 			return false;
0: 
0: 		String userName = userInfo.getProperty(Attribute.USERNAME_ATTR);
0: 		if ((userName != null) && userName.length() > DB2Limit.MAX_USERID_LENGTH) {
0: 		// DB2 has limits on length of the user id, so we enforce the same.
0: 		// This used to be error 28000 "Invalid authorization ID", but with v82,
0: 		// DB2 changed the behavior to return a normal "authorization failure
0: 		// occurred" error; so that means just return "false" and the correct
0: 		// exception will be thrown as usual.
0: 			return false;
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (SanityManager.DEBUG_ON(AuthenticationTrace)) {
0: 
0: 				java.io.PrintWriter iDbgStream =
0: 					SanityManager.GET_DEBUG_STREAM();
0: 
0: 				iDbgStream.println(
0: 								" - Authentication request: user [" +
0: 							    userName + "]"+ ", database [" +
0: 							    databaseName + "]");
0: 				// The following will print the stack trace of the
0: 				// authentication request to the log.  
0: 				//Throwable t = new Throwable();
0: 				//istream.println("Authentication Request Stack trace:");
0: 				//t.printStackTrace(istream.getPrintWriter());
0: 			}
0: 		}
0: 		return this.authenticationScheme.authenticateUser(userName,
0: 						  userInfo.getProperty(Attribute.PASSWORD_ATTR),
0: 						  databaseName,
0: 						  userInfo
0: 						 );
0: 	}
0: 
0: 	/**
0: 	 * Returns a property if it was set at the database or
0: 	 * system level. Treated as SERVICE property by default.
0: 	 *
0: 	 * @return a property string value.
0: 	 **/
0: 	public String getProperty(String key) {
0: 
0: 		String propertyValue = null;
0: 		TransactionController tc = null;
0: 
0: 		try {
0: 
0: 		  if (store != null)
0:           {
0:             tc = store.getTransaction(
0:                 ContextService.getFactory().getCurrentContextManager());
0:           }
0: 
0: 		  propertyValue =
0: 			PropertyUtil.getServiceProperty(tc,
0: 											key,
0: 											(String) null);
0: 		  if (tc != null) {
0: 			tc.commit();
0: 			tc = null;
0: 		  }
0: 
0: 		} catch (StandardException se) {
0: 			// Do nothing and just return
0: 		}
0: 
0: 		return propertyValue;
0: 	}
0: 
0: 	public String getDatabaseProperty(String key) {
0: 
0: 		String propertyValue = null;
0: 		TransactionController tc = null;
0: 
0: 		try {
0: 
0: 		  if (store != null)
0: 			tc = store.getTransaction(
0:                 ContextService.getFactory().getCurrentContextManager());
0: 
0: 		  propertyValue =
0: 			PropertyUtil.getDatabaseProperty(tc, key);
0: 
0: 		  if (tc != null) {
0: 			tc.commit();
0: 			tc = null;
0: 		  }
0: 
0: 		} catch (StandardException se) {
0: 			// Do nothing and just return
0: 		}
0: 
0: 		return propertyValue;
0: 	}
0: 
0: 	public String getSystemProperty(String key) {
0: 
0: 		boolean dbOnly = false;
0: 		dbOnly = Boolean.valueOf(
0: 					this.getDatabaseProperty(
0: 							Property.DATABASE_PROPERTIES_ONLY)).booleanValue();
0: 
0: 		if (dbOnly)
0: 			return null;
0: 
0: 		return PropertyUtil.getSystemProperty(key);
0: 	}
0: 
0: 	/*
0: 	** Methods of PropertySetCallback
0: 	*/
0: 	public void init(boolean dbOnly, Dictionary p) {
0: 		// not called yet ...
0: 	}
0: 
0: 	/**
0: 	  @see PropertySetCallback#validate
0: 	*/
0: 	public boolean validate(String key, Serializable value, Dictionary p)	{
0: 		return key.startsWith(org.apache.derby.iapi.reference.Property.USER_PROPERTY_PREFIX);
0: 	}
0: 	/**
0: 	  @see PropertySetCallback#validate
0: 	*/
0: 	public Serviceable apply(String key,Serializable value,Dictionary p)
0: 	{
0: 		return null;
0: 	}
0: 	/**
0: 	  @see PropertySetCallback#map
0: 	  @exception StandardException Thrown on error.
0: 	*/
0: 	public Serializable map(String key, Serializable value, Dictionary p)
0: 		throws StandardException
0: 	{
0: 		// We only care for "derby.user." property changes
0: 		// at the moment.
0: 		if (!key.startsWith(org.apache.derby.iapi.reference.Property.USER_PROPERTY_PREFIX)) return null;
0: 		// We do not encrypt 'derby.user.<userName>' password if
0: 		// the configured authentication service is LDAP as the
0: 		// same property could be used to store LDAP user full DN (X500).
0: 		// In performing this check we only consider database properties
0: 		// not system, service or application properties.
0: 
0: 		String authService =
0: 			(String)p.get(org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_PARAMETER);
0: 
0: 		if ((authService != null) &&
0: 			 (StringUtil.SQLEqualsIgnoreCase(authService, org.apache.derby.iapi.reference.Property.AUTHENTICATION_PROVIDER_LDAP)))
0: 			return null;
0: 
0: 		// Ok, we can encrypt this password in the db
0: 		String userPassword = (String) value;
0: 
0: 		if (userPassword != null) {
0: 			// encrypt (digest) the password
0: 			// the caller will retrieve the new value
0: 			userPassword = encryptPassword(userPassword);
0: 		}
0: 
0: 		return userPassword;
0: 	}
0: 
0: 
0: 	// Class implementation
0: 
0: 	protected final boolean requireAuthentication(Properties properties) {
0: 
0: 		//
0: 		// we check if derby.connection.requireAuthentication system
0: 		// property is set to true, otherwise we are the authentication
0: 		// service that should be run.
0: 		//
0: 		String requireAuthentication = PropertyUtil.getPropertyFromSet(
0: 					properties,
0: 					org.apache.derby.iapi.reference.Property.REQUIRE_AUTHENTICATION_PARAMETER
0: 														);
0: 		return Boolean.valueOf(requireAuthentication).booleanValue();
0: 	}
0: 	/**
0: 	 * This method encrypts a clear user password using a
0: 	 * Single Hash algorithm such as SHA-1 (SHA equivalent)
0: 	 * (it is a 160 bits digest)
0: 	 *
0: 	 * The digest is returned as an object string.
0: 	 *
0: 	 * @param plainTxtUserPassword Plain text user password
0: 	 *
0: 	 * @return encrypted user password (digest) as a String object
0: 	 */
0: 	protected String encryptPassword(String plainTxtUserPassword)
0: 	{
0: 		if (plainTxtUserPassword == null)
0: 			return null;
0: 
0: 		MessageDigest algorithm = null;
0: 		try
0: 		{
0: 			algorithm = MessageDigest.getInstance("SHA-1");
0: 		} catch (NoSuchAlgorithmException nsae)
0: 		{
0: 					// Ignore as we checked already during service boot-up
0: 		}
0: 
0: 		algorithm.reset();
0: 		byte[] bytePasswd = null;
0: 		bytePasswd = AuthenticationServiceBase.toHexByte(plainTxtUserPassword,0,plainTxtUserPassword.length());
0: 		algorithm.update(bytePasswd);
0: 		byte[] encryptVal = algorithm.digest();
0: 		String hexString = ID_PATTERN_NEW_SCHEME + org.apache.derby.iapi.util.StringUtil.toHexString(encryptVal,0,encryptVal.length);
0: 		return (hexString);
0: 
0: 	}
0: 	/**
0:   
0: 	   Convert a string into a byte array in hex format.
0: 	   <BR>
0: 	   For each character (b) two bytes are generated, the first byte 
0: 	   represents the high nibble (4 bits) in hexidecimal (<code>b & 0xf0</code>),
0:            the second byte 
0: 	   represents the low nibble (<code>b & 0x0f</code>).
0: 	   <BR>
0: 	   The character at <code>str.charAt(0)</code> is represented by the first two bytes 
0: 	   in the returned String.
0: 
0: 	   @param	str string 
0: 	   @param	offset	starting character (zero based) to convert.
0: 	   @param	length	number of characters to convert.
0: 
0: 	   @return the byte[]  (with hexidecimal format) form of the string (str) 
0: 	*/
0: 	public static byte[] toHexByte(String str, int offset, int length)
0: 	{
0:   	    byte[] data = new byte[(length - offset) * 2];
0: 	    int end = offset+length;
0: 
0:             for (int i = offset; i < end; i++)
0:  	    {
0: 	        char ch = str.charAt(i);
0: 		int high_nibble = (ch & 0xf0) >>> 4;
0: 		int low_nibble = (ch & 0x0f);
0: 		data[i] = (byte)high_nibble;
0: 		data[i+1] = (byte)low_nibble;
0: 	    }
0: 	    return data;
0: 	}
0: }
============================================================================