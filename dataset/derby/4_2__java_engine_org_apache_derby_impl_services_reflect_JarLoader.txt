2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.services.reflect.JarLoader
1:cce33f1: 
1:93fea34:    Licensed to the Apache Software Foundation (ASF) under one or more
1:93fea34:    contributor license agreements.  See the NOTICE file distributed with
1:93fea34:    this work for additional information regarding copyright ownership.
1:93fea34:    The ASF licenses this file to you under the Apache License, Version 2.0
1:93fea34:    (the "License"); you may not use this file except in compliance with
1:93fea34:    the License.  You may obtain a copy of the License at
1:6ae3022: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
4:eac0369:  */
1:345de35: 
1:eac0369: package org.apache.derby.impl.services.reflect;
18:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:cce33f1: import java.io.ByteArrayOutputStream;
1:eac0369: import java.io.File;
1:2b7530f: import java.io.FileNotFoundException;
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.IOException;
1:eac0369: 
1:6fc71fb: import java.security.AccessController;
1:46ecfcf: import java.security.CodeSource;
1:cce33f1: import java.security.GeneralSecurityException;
1:6fc71fb: import java.security.PrivilegedActionException;
1:46ecfcf: import java.security.SecureClassLoader;
1:cce33f1: import java.security.cert.Certificate;
1:cce33f1: import java.security.cert.X509Certificate;
1:f1599ea: import java.util.jar.JarEntry;
1:f1599ea: import java.util.jar.JarFile;
1:f1599ea: import java.util.jar.JarInputStream;
1:eac0369: 
1:5a15941: import org.apache.derby.iapi.services.io.AccessibleByteArrayOutputStream;
1:cce33f1: import org.apache.derby.iapi.services.io.InputStreamUtil;
1:eac0369: import org.apache.derby.iapi.services.io.LimitInputStream;
1:eac0369: import org.apache.derby.iapi.util.IdUtil;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.MessageId;
1:eac0369: import org.apache.derby.iapi.services.i18n.MessageService;
1:2b7530f: import org.apache.derby.io.StorageFile;
1:eac0369: 
1:eac0369: 
1:c722b36: final class JarLoader extends SecureClassLoader {
1:eac0369:     
1:cce33f1:     /**
1:cce33f1:      * Two part name for the jar file.
1:cce33f1:      */
1:cce33f1:     private final String[] name;
1:cce33f1:     
1:cce33f1:     /**
1:2b7530f:      * Handle to the installed jar file.
1:2b7530f:      */
1:2b7530f:     private StorageFile installedJar;
1:2b7530f:     
1:2b7530f:     /**
1:cce33f1:      * When the jar file can be manipulated as a java.util.JarFile
1:cce33f1:      * this holds the reference to the open jar. When the jar can
1:cce33f1:      * only be manipulated as an InputStream (because the jar is itself
1:cce33f1:      * in a database jar) then this will be null.
1:cce33f1:      */
1:cce33f1:     private JarFile jar;
1:cce33f1:     
1:cce33f1:     /**
1:cce33f1:      * True if the jar can only be accessed using a stream, because
1:cce33f1:      * the jar is itself in a database jar. When fals the jar is accessed
1:cce33f1:      * using the jar field.
1:cce33f1:      */
1:cce33f1:     private boolean isStream;
1:eac0369: 
1:eac0369: 	private UpdateLoader updateLoader;
1:eac0369: 	private HeaderPrintWriter vs;
1:eac0369: 
1:eac0369: 	JarLoader(UpdateLoader updateLoader, String[] name, HeaderPrintWriter vs) {
1:eac0369: 
1:eac0369: 		this.updateLoader = updateLoader;
1:cce33f1:         this.name = name;
1:eac0369: 		this.vs = vs;
11:eac0369: 	}
1:eac0369: 
1:2b7530f: 	/**
1:2b7530f: 	 *  Initialize the class loader so it knows if it
1:2b7530f: 	 *  is loading from a ZipFile or an InputStream
1:2b7530f: 	 */
1:eac0369: 	void initialize() {
1:eac0369: 
1:2b7530f: 		String schemaName = name[IdUtil.DBCP_SCHEMA_NAME];
1:2b7530f: 		String sqlName = name[IdUtil.DBCP_SQL_JAR_NAME];
1:eac0369: 
1:2b7530f: 		Exception e;
5:eac0369: 		try {
1:2b7530f: 			installedJar =
1:2b7530f: 				updateLoader.getJarReader().getJarFile(
1:2b7530f: 					schemaName, sqlName);
1:eac0369: 
1:2b7530f: 			if (installedJar instanceof File) {
1:6fc71fb:                 try {
1:a15a470:                     jar = AccessController.doPrivileged
1:a15a470:                     (new java.security.PrivilegedExceptionAction<JarFile>(){
1:6fc71fb: 
1:a15a470:                         public JarFile run() throws IOException {
1:6fc71fb:                         return new JarFile((File) installedJar);
1:6fc71fb: 
1:6fc71fb:                         }
1:6fc71fb: 
1:6fc71fb:                     }
1:6fc71fb:                      );
1:6fc71fb:                 } catch (PrivilegedActionException pae) {
1:6fc71fb:                     throw (IOException) pae.getException();
1:6fc71fb:                 }
2:eac0369: 				return;
1:eac0369: 			}
1:eac0369: 
1:2b7530f: 			// Jar is only accessible as an InputStream,
1:2b7530f: 			// which means we need to re-open the stream for
1:2b7530f: 			// each access.
1:2b7530f: 
1:2b7530f: 			isStream = true;
1:2b7530f: 			return;
1:2b7530f: 
2:eac0369: 		} catch (IOException ioe) {
1:2b7530f: 			e = ioe;
1:2b7530f: 		} catch (StandardException se) {
1:2b7530f: 			e = se;
1:eac0369: 		}
1:eac0369: 
1:2b7530f: 		if (vs != null)
1:2b7530f: 			vs.println(MessageService.getTextMessage(
1:2b7530f: 					MessageId.CM_LOAD_JAR_EXCEPTION, getJarName(), e));
1:2b7530f: 
1:eac0369: 		// No such zip.
1:2b7530f: 		setInvalid();
1:eac0369: 	}
1:eac0369: 
1:cce33f1: 	/**
1:2b7530f: 	 * Handle all requests to the top-level loader.
1:2b7530f: 	 * 
1:2b7530f: 	 * @exception ClassNotFoundException
1:2b7530f: 	 *                Class can not be found
1:2b7530f: 	 */
1:c722b36: 	protected Class loadClass(String className, boolean resolve) 
1:eac0369: 		throws ClassNotFoundException {
1:c33ef39:         
1:c33ef39:         // Classes in installed jars cannot reference
1:c33ef39:         // Derby internal code. This is to avoid
1:c33ef39:         // code in installed jars bypassing SQL
1:c33ef39:         // authorization by calling Derby's internal methods.
1:c33ef39:         //
1:c33ef39:         // Any classes in the org.apache.derby.jdbc package
1:c33ef39:         // are allowed as it allows routines to make JDBC
1:c33ef39:         // connections to other databases. This does expose
1:c33ef39:         // public classes in that package that are not part
1:c33ef39:         // of the public api to attacks. One could attempt
1:c33ef39:         // further limiting allowed classes to those starting
1:c33ef39:         // with Embedded (and Client) but when fetching the
1:c33ef39:         // default connection in a routine (jdbc:default:connection)
1:c33ef39:         // the DriverManager attempts a load of the already loaded
1:c33ef39:         // AutoloadDriver, I think to establish the calling class
1:c33ef39:         // has access to the driver.
1:c33ef39:         //
1:c33ef39:         // This check in addition to the one in UpdateLoader
1:c33ef39:         // that prevents restricted classes from being loaded
1:c33ef39:         // from installed jars. The checks should be seen as
1:c33ef39:         // independent, ie. the restricted load check should
1:c33ef39:         // not make assumptions about this check reducing the
1:c33ef39:         // number of classes it has to check for.
1:c33ef39:         if (className.startsWith("org.apache.derby.")
1:a7016bf:                 && !className.startsWith("org.apache.derby.jdbc.")
1:b3834d3:                 && !className.startsWith("org.apache.derby.vti.")
1:b3834d3:                 && !className.startsWith("org.apache.derby.agg.")
1:a409436:                 && !className.startsWith("org.apache.derby.optional.")
1:ea335da:                 && !className.startsWith("org.apache.derby.impl.tools.optional.")
1:b3834d3:             )
1:c33ef39:         {
1:c33ef39:             ClassNotFoundException cnfe = new ClassNotFoundException(className);
1:c33ef39:             //cnfe.printStackTrace(System.out);
1:c33ef39:             throw cnfe;
1:c33ef39:         }
1:eac0369: 
1:eac0369: 		// we attempt the system class load even if we
1:eac0369: 		// are stale because otherwise we will fail
1:eac0369: 		// to load java.* classes which confuses some VMs
1:eac0369: 		try {
1:eac0369: 			return Class.forName(className);
1:eac0369: 		} catch (ClassNotFoundException cnfe) {
1:eac0369: 
1:eac0369: 			if (updateLoader == null)
1:eac0369: 				throw new ClassNotFoundException(MessageService.getTextMessage(MessageId.CM_STALE_LOADER, className));
1:eac0369: 
1:eac0369: 			Class c = updateLoader.loadClass(className, resolve);
1:eac0369: 			if (c == null)
1:eac0369: 				throw cnfe;
1:eac0369: 			return c;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:5739bce: 	/**
1:eac0369: 		
1:eac0369: 	*/
1:eac0369: 	public InputStream getResourceAsStream(String name) {
1:eac0369: 		if (updateLoader == null)
2:eac0369: 			return null;
1:eac0369: 		return updateLoader.getResourceAsStream(name);
1:eac0369: 	}
1:cce33f1: 
1:cce33f1:     /**
1:cce33f1:      * Return the SQL name for the installed jar.
1:cce33f1:      * Used for error and informational messages.
1:cce33f1:      */
1:cce33f1:     final String getJarName() {
1:cce33f1:         return IdUtil.mkQualifiedName(name);
1:cce33f1:     }
1:cce33f1: 
1:eac0369: 	Class loadClassData(String className, String jvmClassName, boolean resolve) {
1:f1599ea: 
1:eac0369: 		if (updateLoader == null)
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 		try {
1:f1599ea: 			if (jar != null)
1:cce33f1: 				return loadClassDataFromJar(className, jvmClassName, resolve);
1:eac0369: 
1:cce33f1: 			if (isStream) {
1:eac0369: 				// have to use a new stream each time
1:2b7530f: 				return loadClassData(installedJar.getInputStream(),
1:eac0369: 						className, jvmClassName, resolve);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return null;
1:2b7530f: 		} catch (FileNotFoundException fnfe) {
1:2b7530f: 			// No such entry.
1:2b7530f: 			return null;
1:eac0369: 		} catch (IOException ioe) {
3:eac0369: 			if (vs != null)
1:eac0369: 				vs.println(MessageService.getTextMessage(MessageId.CM_CLASS_LOAD_EXCEPTION, className, getJarName(), ioe));
1:eac0369: 			return null;
1:eac0369: 		}	
1:eac0369: 	}
1:eac0369: 
1:cce33f1: 	/**
1:eac0369: 		Get an InputStream for the given resource.
1:eac0369: 	*/
1:eac0369: 	InputStream getStream(String name) {
1:eac0369: 
1:eac0369: 		if (updateLoader == null)
1:eac0369: 			return null;
1:eac0369:      
1:f1599ea: 		if (jar != null)
1:cce33f1: 			return getRawStream(name);
1:eac0369: 
1:cce33f1: 		if (isStream) {
1:2b7530f: 			try {
1:2b7530f: 				return getRawStream(installedJar.getInputStream(), name);
1:2b7530f: 			} catch (FileNotFoundException e) {
1:2b7530f: 				// no such entry
1:2b7530f: 			}
1:eac0369: 		}
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Private api
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 
1:f1599ea:     /**
1:f1599ea:      * Load the class data when the installed jar is accessible
1:f1599ea:      * as a java.util.jarFile.
1:f1599ea:      */
1:f1599ea: 	private Class loadClassDataFromJar(
1:f1599ea:             String className, String jvmClassName, boolean resolve) 
1:eac0369: 		throws IOException {
1:eac0369: 
1:f1599ea: 		JarEntry e = jar.getJarEntry(jvmClassName);
1:f1599ea: 		if (e == null)
1:eac0369: 			return null;
1:eac0369: 
1:f1599ea: 		InputStream in = jar.getInputStream(e);
1:eac0369: 
1:eac0369: 		try {
1:f1599ea: 			return loadClassData(e, in, className, resolve);
1:eac0369: 		} finally {
1:eac0369: 			in.close();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:f1599ea:     /**
1:f1599ea:      * Load the class data when the installed jar is accessible
1:f1599ea:      * only as an input stream (the jar is itself in a database jar).
1:f1599ea:      */
1:eac0369: 	private Class loadClassData(
1:eac0369: 		InputStream in, String className, String jvmClassName, boolean resolve) 
1:eac0369: 		throws IOException {
1:eac0369: 
1:f1599ea:         JarInputStream jarIn = new JarInputStream(in);
1:eac0369: 
1:eac0369: 		for (;;) {
1:eac0369: 
1:f1599ea: 			JarEntry e = jarIn.getNextJarEntry();
1:f1599ea: 			if (e == null) {
1:f1599ea: 				jarIn.close();
1:eac0369: 				return null;
1:eac0369: 			}
1:eac0369: 
1:f1599ea: 			if (e.getName().equals(jvmClassName)) {
1:f1599ea: 				Class c = loadClassData(e, jarIn, className, resolve);
1:f1599ea: 				jarIn.close();
1:eac0369: 				return c;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 	}
1:eac0369: 
2:eac0369:     /**
1:cce33f1:      * Load and optionally resolve the class given its
1:cce33f1:      * JarEntry and an InputStream to the class fiel format.
1:cce33f1:      * This is common code for when the jar is accessed
1:cce33f1:      * directly using JarFile or through InputStream.
1:cce33f1:      */
1:f1599ea: 	private Class loadClassData(JarEntry e, InputStream in,
1:eac0369: 		String className, boolean resolve) throws IOException {
1:eac0369: 
1:cce33f1: 		byte[] data = readData(e, in, className);
1:eac0369: 
1:46ecfcf: 		Certificate[] signers = getSigners(className, e);
1:eac0369: 
1:eac0369: 		synchronized (updateLoader) {
1:eac0369: 			// see if someone else loaded it while we
1:eac0369: 			// were getting the bytes ...
1:eac0369: 			Class c = updateLoader.checkLoaded(className, resolve);
1:eac0369: 			if (c == null) {
1:46ecfcf: 				c = defineClass(className, data, 0, data.length, (CodeSource) null);
1:eac0369: 				if (signers != null) {
1:eac0369: 					setSigners(c, signers);
1:eac0369: 				}
1:eac0369: 				if (resolve)
1:eac0369: 					resolveClass(c);
1:eac0369: 			}
1:eac0369: 			return c;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	Class checkLoaded(String className, boolean resolve) {
1:eac0369: 		if (updateLoader == null)
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 		Class c = findLoadedClass(className);
1:eac0369: 		if ((c != null) && resolve)
1:eac0369: 			resolveClass(c);
1:eac0369: 		return c;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:5739bce:      * Set this loader to be invaid so that it will not
1:5739bce:      * resolve any classes or resources.
1:5739bce:      *
1:5739bce:      */
1:5739bce: 	void setInvalid() {
1:eac0369: 		updateLoader = null;
1:cce33f1:         if (jar != null) {
1:cce33f1:             try {
1:cce33f1:                 jar.close();
1:cce33f1:             } catch (IOException ioe) {
1:cce33f1:             }
1:cce33f1:             jar = null;
1:cce33f1: 
1:cce33f1:         }
1:cce33f1:         isStream = false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Routines to get an InputStream for a namedResource
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:f1599ea: 		Get a stream for a resource directly from a JarFile.
1:eac0369: 		In this case we can safely return the stream directly.
1:eac0369: 		It's a new stream set up by the zip code to read just
1:eac0369: 		the contents of this entry.
1:eac0369: 	*/
1:cce33f1: 	private InputStream getRawStream(String name) {
1:eac0369: 
1:eac0369: 		try {
1:f1599ea: 			JarEntry e = jar.getJarEntry(name);
1:f1599ea: 			if (e == null)
1:eac0369: 				return null;
1:eac0369: 
1:f1599ea: 			return jar.getInputStream(e);
1:eac0369: 		} catch (IOException ioe) {
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a stream from a zip file that is itself a stream.
1:5a15941:         We copy to the contents to a byte array and return a
1:5a15941:         stream around that to the caller. Though a copy is
1:5a15941:         involved it has the benefit of:
1:5a15941:         <UL>
1:5a15941:         <LI> Isolating the application from the JarInputStream, thus
1:5a15941:         denying any possibility of the application reading more of the
1:5a15941:         jar that it should be allowed to. E.g. the contents class files are not
1:5a15941:         exposed through getResource.
1:5a15941:         <LI> Avoids any possibility of the application holding onto
1:5a15941:         the open stream beyond shutdown of the database, thus leading
1:5a15941:         to leaked file descriptors or inability to remove the jar.
1:5a15941:         </UL>
1:eac0369: 	*/
1:eac0369: 	private InputStream getRawStream(InputStream in, String name) { 
1:eac0369: 
1:f1599ea: 		JarInputStream jarIn = null;
1:eac0369: 		try {
1:f1599ea: 			jarIn = new JarInputStream(in);
1:eac0369: 
1:f1599ea: 		    JarEntry e;
1:f1599ea: 			while ((e = jarIn.getNextJarEntry()) != null) {
1:eac0369: 
1:f1599ea: 				if (e.getName().equals(name)) {
1:5a15941:                     int size = (int) e.getSize();
1:5a15941:                     if (size == -1)
1:5a15941:                     {
1:5a15941:                         // unknown size so just pick a good buffer size.
1:5a15941:                         size = 8192;
1:5a15941:                     }
1:5a15941:                     return AccessibleByteArrayOutputStream.copyStream(jarIn, size);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		} catch (IOException ioe) {
1:5a15941:             // can't read the jar file just assume it doesn't exist.
1:eac0369: 		}
1:5a15941:         finally {
1:5a15941:             if (jarIn != null) {
1:5a15941:                 try {
1:5a15941:                     jarIn.close();
1:5a15941:                 } catch (IOException ioe2) {
1:5a15941:                 }
1:5a15941:             }            
1:5a15941:         }
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369:     
1:eac0369:     /**
1:cce33f1:      * Read the raw data for the class file format
1:cce33f1:      * into a byte array that can be used for loading the class.
1:cce33f1:      * If this is a signed class and it has been compromised then
1:cce33f1:      * a SecurityException will be thrown.
1:cce33f1:      */
1:cce33f1:     byte[] readData(JarEntry ze, InputStream in, String className)
1:cce33f1:             throws IOException {
1:cce33f1: 
1:cce33f1:         try {
1:cce33f1:             int size = (int) ze.getSize();
1:cce33f1: 
1:cce33f1:             if (size != -1) {
1:cce33f1:                 byte[] data = new byte[size];
1:cce33f1: 
1:cce33f1:                 InputStreamUtil.readFully(in, data, 0, size);
1:cce33f1: 
1:cce33f1:                 return data;
1:cce33f1:             }
1:cce33f1: 
1:cce33f1:             // unknown size
1:cce33f1:             byte[] data = new byte[1024];
1:cce33f1:             ByteArrayOutputStream os = new ByteArrayOutputStream(1024);
1:cce33f1:             int r;
1:cce33f1:             while ((r = in.read(data)) != -1) {
1:cce33f1:                 os.write(data, 0, r);
1:cce33f1:             }
1:cce33f1: 
1:cce33f1:             data = os.toByteArray();
1:cce33f1:             return data;
1:cce33f1:         } catch (SecurityException se) {
1:cce33f1:             throw handleException(se, className);
1:cce33f1:         }
1:cce33f1:     }
1:cce33f1: 
1:cce33f1:     /**
1:cce33f1:      * Validate the security certificates (signers) for the class data.
1:cce33f1:      */
1:46ecfcf:     private Certificate[] getSigners(String className, JarEntry je) throws IOException {
1:cce33f1: 
1:cce33f1:         try {
1:cce33f1:             Certificate[] list = je.getCertificates();
1:cce33f1:             if ((list == null) || (list.length == 0)) {
1:cce33f1:                 return null;
1:cce33f1:             }
1:cce33f1: 
1:cce33f1:             for (int i = 0; i < list.length; i++) {
1:cce33f1:                 if (!(list[i] instanceof X509Certificate)) {
1:cce33f1:                     String msg = MessageService.getTextMessage(
1:cce33f1:                             MessageId.CM_UNKNOWN_CERTIFICATE, className,
1:cce33f1:                             getJarName());
1:cce33f1: 
1:cce33f1:                     throw new SecurityException(msg);
1:cce33f1:                 }
1:cce33f1: 
1:cce33f1:                 X509Certificate cert = (X509Certificate) list[i];
1:cce33f1: 
1:cce33f1:                 cert.checkValidity();
1:cce33f1:             }
1:cce33f1: 
1:cce33f1:             return list;
1:cce33f1: 
1:cce33f1:         } catch (GeneralSecurityException gse) {
1:cce33f1:             // convert this into an unchecked security
1:cce33f1:             // exception. Unchecked as eventually it has
1:cce33f1:             // to pass through a method that's only throwing
1:cce33f1:             // ClassNotFoundException
1:cce33f1:             throw handleException(gse, className);
1:cce33f1:         }
1:cce33f1:         
1:cce33f1:     }
1:cce33f1: 
1:cce33f1:     /**
1:cce33f1:      * Provide a SecurityManager with information about the class name
1:cce33f1:      * and the jar file.
1:cce33f1:      */
1:cce33f1:     private SecurityException handleException(Exception e, String className) {
1:cce33f1:         String msg = MessageService.getTextMessage(
1:cce33f1:                 MessageId.CM_SECURITY_EXCEPTION, className, getJarName(), e
1:cce33f1:                         .getLocalizedMessage());
1:cce33f1:         return new SecurityException(msg);
1:cce33f1:     }
1:c722b36:     
1:c722b36:     /**
1:c722b36:      * Return the jar name if toString() is called
1:c722b36:      * on this class loader.
1:c722b36:      */
1:c722b36:     public String toString()
1:c722b36:     {
1:c722b36:         return getJarName() + ":" + super.toString();
1:c722b36:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a409436
/////////////////////////////////////////////////////////////////////////
1:                 && !className.startsWith("org.apache.derby.optional.")
commit:a15a470
/////////////////////////////////////////////////////////////////////////
1:                     jar = AccessController.doPrivileged
1:                     (new java.security.PrivilegedExceptionAction<JarFile>(){
1:                         public JarFile run() throws IOException {
commit:ea335da
/////////////////////////////////////////////////////////////////////////
1:                 && !className.startsWith("org.apache.derby.impl.tools.optional.")
commit:b3834d3
/////////////////////////////////////////////////////////////////////////
1:                 && !className.startsWith("org.apache.derby.vti.")
1:                 && !className.startsWith("org.apache.derby.agg.")
1:             )
commit:a7016bf
/////////////////////////////////////////////////////////////////////////
1:                 && !className.startsWith("org.apache.derby.jdbc.")
0:                 && !className.startsWith("org.apache.derby.vti."))
commit:93fea34
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:c33ef39
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Classes in installed jars cannot reference
1:         // Derby internal code. This is to avoid
1:         // code in installed jars bypassing SQL
1:         // authorization by calling Derby's internal methods.
1:         //
1:         // Any classes in the org.apache.derby.jdbc package
1:         // are allowed as it allows routines to make JDBC
1:         // connections to other databases. This does expose
1:         // public classes in that package that are not part
1:         // of the public api to attacks. One could attempt
1:         // further limiting allowed classes to those starting
1:         // with Embedded (and Client) but when fetching the
1:         // default connection in a routine (jdbc:default:connection)
1:         // the DriverManager attempts a load of the already loaded
1:         // AutoloadDriver, I think to establish the calling class
1:         // has access to the driver.
1:         //
1:         // This check in addition to the one in UpdateLoader
1:         // that prevents restricted classes from being loaded
1:         // from installed jars. The checks should be seen as
1:         // independent, ie. the restricted load check should
1:         // not make assumptions about this check reducing the
1:         // number of classes it has to check for.
1:         if (className.startsWith("org.apache.derby.")
0:                 && !className.startsWith("org.apache.derby.jdbc."))
1:         {
1:             ClassNotFoundException cnfe = new ClassNotFoundException(className);
1:             //cnfe.printStackTrace(System.out);
1:             throw cnfe;
1:         }
commit:c722b36
/////////////////////////////////////////////////////////////////////////
1: final class JarLoader extends SecureClassLoader {
/////////////////////////////////////////////////////////////////////////
1: 	protected Class loadClass(String className, boolean resolve) 
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Return the jar name if toString() is called
1:      * on this class loader.
1:      */
1:     public String toString()
1:     {
1:         return getJarName() + ":" + super.toString();
1:     }
commit:6fc71fb
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
/////////////////////////////////////////////////////////////////////////
1:                 try {
0:                     jar = (JarFile) AccessController.doPrivileged
0:                     (new java.security.PrivilegedExceptionAction(){
1: 
0:                         public Object run() throws IOException {
1:                         return new JarFile((File) installedJar);
1: 
1:                         }
1: 
1:                     }
1:                      );
1:                 } catch (PrivilegedActionException pae) {
1:                     throw (IOException) pae.getException();
1:                 }
commit:46ecfcf
/////////////////////////////////////////////////////////////////////////
1: import java.security.CodeSource;
1: import java.security.SecureClassLoader;
/////////////////////////////////////////////////////////////////////////
0: class JarLoader extends SecureClassLoader {
/////////////////////////////////////////////////////////////////////////
1: 		Certificate[] signers = getSigners(className, e);
1: 				c = defineClass(className, data, 0, data.length, (CodeSource) null);
/////////////////////////////////////////////////////////////////////////
1:     private Certificate[] getSigners(String className, JarEntry je) throws IOException {
commit:2b7530f
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileNotFoundException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.io.StorageFile;
/////////////////////////////////////////////////////////////////////////
1:      * Handle to the installed jar file.
1:      */
1:     private StorageFile installedJar;
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 *  Initialize the class loader so it knows if it
1: 	 *  is loading from a ZipFile or an InputStream
1: 	 */
1: 		String schemaName = name[IdUtil.DBCP_SCHEMA_NAME];
1: 		String sqlName = name[IdUtil.DBCP_SQL_JAR_NAME];
1: 		Exception e;
1: 			installedJar =
1: 				updateLoader.getJarReader().getJarFile(
1: 					schemaName, sqlName);
1: 			if (installedJar instanceof File) {
0: 				jar = new JarFile((File) installedJar);
1: 			// Jar is only accessible as an InputStream,
1: 			// which means we need to re-open the stream for
1: 			// each access.
1: 
1: 			isStream = true;
1: 			return;
1: 
1: 			e = ioe;
1: 		} catch (StandardException se) {
1: 			e = se;
1: 		if (vs != null)
1: 			vs.println(MessageService.getTextMessage(
1: 					MessageId.CM_LOAD_JAR_EXCEPTION, getJarName(), e));
1: 
1: 		setInvalid();
1: 	 * Handle all requests to the top-level loader.
1: 	 * 
1: 	 * @exception ClassNotFoundException
1: 	 *                Class can not be found
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 				return loadClassData(installedJar.getInputStream(),
1: 		} catch (FileNotFoundException fnfe) {
1: 			// No such entry.
1: 			return null;
/////////////////////////////////////////////////////////////////////////
1: 			try {
1: 				return getRawStream(installedJar.getInputStream(), name);
1: 			} catch (FileNotFoundException e) {
1: 				// no such entry
1: 			}
/////////////////////////////////////////////////////////////////////////
commit:5a15941
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.AccessibleByteArrayOutputStream;
/////////////////////////////////////////////////////////////////////////
1:         We copy to the contents to a byte array and return a
1:         stream around that to the caller. Though a copy is
1:         involved it has the benefit of:
1:         <UL>
1:         <LI> Isolating the application from the JarInputStream, thus
1:         denying any possibility of the application reading more of the
1:         jar that it should be allowed to. E.g. the contents class files are not
1:         exposed through getResource.
1:         <LI> Avoids any possibility of the application holding onto
1:         the open stream beyond shutdown of the database, thus leading
1:         to leaked file descriptors or inability to remove the jar.
1:         </UL>
/////////////////////////////////////////////////////////////////////////
1:                     int size = (int) e.getSize();
1:                     if (size == -1)
1:                     {
1:                         // unknown size so just pick a good buffer size.
1:                         size = 8192;
1:                     }
1:                     return AccessibleByteArrayOutputStream.copyStream(jarIn, size);
1:             // can't read the jar file just assume it doesn't exist.
1:         finally {
1:             if (jarIn != null) {
1:                 try {
1:                     jarIn.close();
1:                 } catch (IOException ioe2) {
1:                 }
1:             }            
1:         }
commit:cce33f1
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayOutputStream;
1: import java.security.GeneralSecurityException;
1: import java.security.cert.Certificate;
1: import java.security.cert.X509Certificate;
1: import org.apache.derby.iapi.services.io.InputStreamUtil;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Two part name for the jar file.
1:      */
1:     private final String[] name;
1:     
1:     /**
1:      * When the jar file can be manipulated as a java.util.JarFile
1:      * this holds the reference to the open jar. When the jar can
1:      * only be manipulated as an InputStream (because the jar is itself
1:      * in a database jar) then this will be null.
1:      */
1:     private JarFile jar;
1:     
1:     /**
1:      * True if the jar can only be accessed using a stream, because
1:      * the jar is itself in a database jar. When fals the jar is accessed
1:      * using the jar field.
1:      */
1:     private boolean isStream;
1:         this.name = name;
/////////////////////////////////////////////////////////////////////////
0:                 jar = new JarFile((File) zipData);
0:             // Jar is only accessible as an INputStream,
0:             // which means we need to re-open the stream for
0:             // each access. Thus we close the stream now as we have
0:             // no further use for it.
0: 				isStream = true;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return the SQL name for the installed jar.
1:      * Used for error and informational messages.
1:      */
1:     final String getJarName() {
1:         return IdUtil.mkQualifiedName(name);
1:     }
/////////////////////////////////////////////////////////////////////////
1: 				return loadClassDataFromJar(className, jvmClassName, resolve);
1: 			if (isStream) {
/////////////////////////////////////////////////////////////////////////
1:      
1: 			return getRawStream(name);
1: 		if (isStream) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Load and optionally resolve the class given its
1:      * JarEntry and an InputStream to the class fiel format.
1:      * This is common code for when the jar is accessed
1:      * directly using JarFile or through InputStream.
1:      */
1: 		byte[] data = readData(e, in, className);
0: 		Object[] signers = getSigners(className, e);
/////////////////////////////////////////////////////////////////////////
0: 		String[] dbJarName = name;
/////////////////////////////////////////////////////////////////////////
0: 				vs.println(MessageService.getTextMessage(MessageId.CM_LOAD_JAR_EXCEPTION, getJarName(), se));
/////////////////////////////////////////////////////////////////////////
1:         if (jar != null) {
1:             try {
1:                 jar.close();
1:             } catch (IOException ioe) {
1:             }
1:             jar = null;
1: 
1:         }
1:         isStream = false;
/////////////////////////////////////////////////////////////////////////
1: 	private InputStream getRawStream(String name) {
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Read the raw data for the class file format
1:      * into a byte array that can be used for loading the class.
1:      * If this is a signed class and it has been compromised then
1:      * a SecurityException will be thrown.
1:      */
1:     byte[] readData(JarEntry ze, InputStream in, String className)
1:             throws IOException {
1: 
1:         try {
1:             int size = (int) ze.getSize();
1: 
1:             if (size != -1) {
1:                 byte[] data = new byte[size];
1: 
1:                 InputStreamUtil.readFully(in, data, 0, size);
1: 
1:                 return data;
1:             }
1: 
1:             // unknown size
1:             byte[] data = new byte[1024];
1:             ByteArrayOutputStream os = new ByteArrayOutputStream(1024);
1:             int r;
1:             while ((r = in.read(data)) != -1) {
1:                 os.write(data, 0, r);
1:             }
1: 
1:             data = os.toByteArray();
1:             return data;
1:         } catch (SecurityException se) {
1:             throw handleException(se, className);
1:         }
1:     }
1: 
1:     /**
1:      * Validate the security certificates (signers) for the class data.
1:      */
0:     Object[] getSigners(String className, JarEntry je) throws IOException {
1: 
1:         try {
1:             Certificate[] list = je.getCertificates();
1:             if ((list == null) || (list.length == 0)) {
1:                 return null;
1:             }
1: 
1:             for (int i = 0; i < list.length; i++) {
1:                 if (!(list[i] instanceof X509Certificate)) {
1:                     String msg = MessageService.getTextMessage(
1:                             MessageId.CM_UNKNOWN_CERTIFICATE, className,
1:                             getJarName());
1: 
1:                     throw new SecurityException(msg);
1:                 }
1: 
1:                 X509Certificate cert = (X509Certificate) list[i];
1: 
1:                 cert.checkValidity();
1:             }
1: 
1:             return list;
1: 
1:         } catch (GeneralSecurityException gse) {
1:             // convert this into an unchecked security
1:             // exception. Unchecked as eventually it has
1:             // to pass through a method that's only throwing
1:             // ClassNotFoundException
1:             throw handleException(gse, className);
1:         }
1:         
1:     }
1: 
1:     /**
1:      * Provide a SecurityManager with information about the class name
1:      * and the jar file.
1:      */
1:     private SecurityException handleException(Exception e, String className) {
1:         String msg = MessageService.getTextMessage(
1:                 MessageId.CM_SECURITY_EXCEPTION, className, getJarName(), e
1:                         .getLocalizedMessage());
1:         return new SecurityException(msg);
1:     }
commit:5739bce
/////////////////////////////////////////////////////////////////////////
0: 		setInvalid();	
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Set this loader to be invaid so that it will not
1:      * resolve any classes or resources.
1:      *
1:      */
1: 	void setInvalid() {
commit:f1599ea
/////////////////////////////////////////////////////////////////////////
1: import java.util.jar.JarEntry;
1: import java.util.jar.JarFile;
1: import java.util.jar.JarInputStream;
/////////////////////////////////////////////////////////////////////////
0:             JarFile jar = jf.getJarFile();
1: 			if (jar != null)
0: 				return loadClassDataFromJar(jar, className, jvmClassName, resolve);
/////////////////////////////////////////////////////////////////////////
1:         
0:         JarFile jar = jf.getJarFile();
1: 		if (jar != null)
0: 			return getRawStream(jar, name);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Load the class data when the installed jar is accessible
1:      * as a java.util.jarFile.
1:      */
1: 	private Class loadClassDataFromJar(
0:             JarFile jar,
1:             String className, String jvmClassName, boolean resolve) 
1: 		JarEntry e = jar.getJarEntry(jvmClassName);
1: 		if (e == null)
1: 		InputStream in = jar.getInputStream(e);
1: 			return loadClassData(e, in, className, resolve);
1:     /**
1:      * Load the class data when the installed jar is accessible
1:      * only as an input stream (the jar is itself in a database jar).
1:      */
1:         JarInputStream jarIn = new JarInputStream(in);
1: 			JarEntry e = jarIn.getNextJarEntry();
1: 			if (e == null) {
1: 				jarIn.close();
1: 			if (e.getName().equals(jvmClassName)) {
1: 				Class c = loadClassData(e, jarIn, className, resolve);
1: 				jarIn.close();
1: 	private Class loadClassData(JarEntry e, InputStream in,
0: 		byte[] data = jf.readData(e, in, className);
0: 		Object[] signers = jf.getSigners(className, e);
/////////////////////////////////////////////////////////////////////////
1: 		Get a stream for a resource directly from a JarFile.
0: 	private InputStream getRawStream(JarFile jar, String name) {
1: 			JarEntry e = jar.getJarEntry(name);
1: 			if (e == null)
1: 			return jar.getInputStream(e);
/////////////////////////////////////////////////////////////////////////
1: 		JarInputStream jarIn = null;
1: 			jarIn = new JarInputStream(in);
1: 		    JarEntry e;
1: 			while ((e = jarIn.getNextJarEntry()) != null) {
1: 				if (e.getName().equals(name)) {
0: 					LimitInputStream lis = new LimitInputStream(jarIn);
0: 					lis.setLimit((int) e.getSize());
0: 			jarIn.close();
0: 			if (jarIn != null) {
0: 					jarIn.close();
commit:3bd9135
/////////////////////////////////////////////////////////////////////////
0: 		this.jf = new InstalledJar(name);
/////////////////////////////////////////////////////////////////////////
0: 		return newJarFile ? new InstalledJar(jf.name) : null;
commit:e33b3b6
/////////////////////////////////////////////////////////////////////////
0: 	private InstalledJar jf;
/////////////////////////////////////////////////////////////////////////
0: 	InstalledJar setInvalid(boolean newJarFile) {
commit:6fd0016
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		this.jf = new JarFileJava2(name);
/////////////////////////////////////////////////////////////////////////
0: 		return newJarFile ? new JarFileJava2(jf.name) : null;
commit:4d73a7a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: class JarLoader extends ClassLoader {
commit:6ae3022
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0: 		// 
0: 		jarFileFactory = new JarFileJava2();
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.services.reflect.JarLoader
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.services.reflect
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.services.reflect;
1: 
0: import org.apache.derby.impl.sql.execute.JarUtil;
1: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import java.io.File;
1: import java.io.InputStream;
1: import java.io.IOException;
1: 
0: import java.util.zip.ZipFile;
0: import java.util.zip.ZipInputStream;
0: import java.util.zip.ZipEntry;
1: 
0: import java.sql.*;
1: import org.apache.derby.iapi.services.io.LimitInputStream;
1: import org.apache.derby.iapi.util.IdUtil;
1: 
0: import org.apache.derby.iapi.services.info.JVMInfo;
1: 
1: import org.apache.derby.iapi.reference.MessageId;
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: 
1: 
0: public class JarLoader extends ClassLoader {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
0: 	private static final JarFile jarFileFactory;
1: 
0: 	static {
0: 		JarFile jf = null;
1: 
0: 		if (JVMInfo.JDK_ID >= 2) {
1: 			try {
0: 				Class jf2c = Class.forName("org.apache.derby.impl.services.reflect.JarFileJava2");
0: 				jf = (JarFile) jf2c.newInstance();
0: 			} catch (Exception e) {
0: 				throw new ExceptionInInitializerError(e);
1: 			}
0: 		} else {	
0: 			jf = new JarFile();
1: 		}
1: 
0: 		jarFileFactory = jf;
1: 	}
1: 
1: 	private UpdateLoader updateLoader;
0: 	private JarFile jf;
1: 	private HeaderPrintWriter vs;
1: 
1: 	JarLoader(UpdateLoader updateLoader, String[] name, HeaderPrintWriter vs) {
1: 
1: 		this.updateLoader = updateLoader;
0: 		this.jf = jarFileFactory.newJarFile(name);
1: 		this.vs = vs;
1: 	}
1: 
0: 	// Initialize the class loader so it knows if it
0: 	// is loading from a ZipFile or an InputStream
1: 	void initialize() {
1: 
0: 		Object zipData = load();
1: 
1: 		try {
1: 
0: 			if (zipData instanceof File) {
0: 				jf.initialize((File) zipData);
1: 				return;
1: 			}
1: 
0: 			if (zipData instanceof InputStream) {
0: 				jf.isStream = true;
1: 				try {
0: 					((InputStream) zipData).close();
1: 				} catch (IOException ioe) {
1: 				}
1: 				return;
1: 			}
1: 		} catch (IOException ioe) {
1: 			if (vs != null)
0: 				vs.println(MessageService.getTextMessage(MessageId.CM_LOAD_JAR_EXCEPTION, getJarName(), ioe));
1: 		}
1: 
1: 		// No such zip.
0: 		setInvalid(false);	
1: 	}
1: 
1: 	/**
0: 		Handle all requests to the top-level loader.
1: 
0: 		@exception ClassNotFoundException Class can not be found
1: 	*/
0: 	public Class loadClass(String className, boolean resolve) 
1: 		throws ClassNotFoundException {
1: 
1: 		// we attempt the system class load even if we
1: 		// are stale because otherwise we will fail
1: 		// to load java.* classes which confuses some VMs
1: 		try {
1: 			return Class.forName(className);
1: 		} catch (ClassNotFoundException cnfe) {
1: 
1: 			if (updateLoader == null)
1: 				throw new ClassNotFoundException(MessageService.getTextMessage(MessageId.CM_STALE_LOADER, className));
1: 
1: 			Class c = updateLoader.loadClass(className, resolve);
1: 			if (c == null)
1: 				throw cnfe;
1: 			return c;
1: 		}
1: 	}
1: 
1: 	/**
1: 		
1: 	*/
1: 	public InputStream getResourceAsStream(String name) {
1: 		if (updateLoader == null)
1: 			return null;
1: 		return updateLoader.getResourceAsStream(name);
1: 	}
1: 
1: 	/*
0: 	** Package level api
1: 	*/
0: 	final String getJarName() {
0: 		return jf.getJarName();
1: 	}
1: 
1: 	Class loadClassData(String className, String jvmClassName, boolean resolve) {
1: 
1: 		if (updateLoader == null)
1: 			return null;
1: 
1: 		try {
0: 			if (jf.isZip())
0: 				return loadClassDataFromJar(className, jvmClassName, resolve);
1: 
0: 			if (jf.isStream) {
1: 				// have to use a new stream each time
0: 				return loadClassData((InputStream) load(),
1: 						className, jvmClassName, resolve);
1: 			}
1: 
1: 			return null;
1: 		} catch (IOException ioe) {
1: 			if (vs != null)
1: 				vs.println(MessageService.getTextMessage(MessageId.CM_CLASS_LOAD_EXCEPTION, className, getJarName(), ioe));
1: 			return null;
1: 		}	
1: 	}
1: 
1: 	/**
1: 		Get an InputStream for the given resource.
1: 	*/
1: 	InputStream getStream(String name) {
1: 
1: 		if (updateLoader == null)
1: 			return null;
1: 
0: 		if (jf.isZip())
0: 			return getRawStream(jf.getZip(), name);
1: 
0: 		if (jf.isStream) {
0: 			return getRawStream((InputStream) load(), name);
1: 		}
1: 		return null;
1: 	}
1: 
1: 
1: 	/*
1: 	** Private api
1: 	*/
1: 
1: 
0: 	private Class loadClassDataFromJar(String className, String jvmClassName, boolean resolve) 
1: 		throws IOException {
1: 
0: 		ZipEntry ze = jf.getEntry(jvmClassName);
0: 		if (ze == null)
1: 			return null;
1: 
0: 		InputStream in = jf.getZip().getInputStream(ze);
1: 
1: 		try {
0: 			return loadClassData(ze, in, className, resolve);
1: 		} finally {
1: 			in.close();
1: 		}
1: 	}
1: 
1: 	private Class loadClassData(
1: 		InputStream in, String className, String jvmClassName, boolean resolve) 
1: 		throws IOException {
1: 
0: 		ZipInputStream zipIn = jf.getZipOnStream(in);
1: 
1: 		for (;;) {
1: 
0: 			ZipEntry ze = jf.getNextEntry(zipIn);
0: 			if (ze == null) {
0: 				zipIn.close();
1: 				return null;
1: 			}
1: 
0: 			if (ze.getName().equals(jvmClassName)) {
0: 				Class c = loadClassData(ze, zipIn, className, resolve);
0: 				zipIn.close();
1: 				return c;
1: 			}
1: 		}
1: 		
1: 	}
1: 
0: 	private Class loadClassData(ZipEntry ze, InputStream in,
1: 		String className, boolean resolve) throws IOException {
1: 
0: 		byte[] data = jf.readData(ze, in, className);
1: 
0: 		Object[] signers = jf.getSigners(className, ze);
1: 
1: 		synchronized (updateLoader) {
1: 			// see if someone else loaded it while we
1: 			// were getting the bytes ...
1: 			Class c = updateLoader.checkLoaded(className, resolve);
1: 			if (c == null) {
0: 				c = defineClass(className, data, 0, data.length);
1: 				if (signers != null) {
1: 					setSigners(c, signers);
1: 				}
1: 				if (resolve)
1: 					resolveClass(c);
1: 			}
1: 			return c;
1: 
1: 		}
1: 	}
1: 
1: 	Class checkLoaded(String className, boolean resolve) {
1: 		if (updateLoader == null)
1: 			return null;
1: 
1: 		Class c = findLoadedClass(className);
1: 		if ((c != null) && resolve)
1: 			resolveClass(c);
1: 		return c;
1: 	}
1: 
0: 	private Object load() {
1: 
0: 		String[] dbJarName = jf.name;
1: 
0: 		String schemaName = dbJarName[IdUtil.DBCP_SCHEMA_NAME];
0: 		String sqlName = dbJarName[IdUtil.DBCP_SQL_JAR_NAME];
1: 
0: 		// don't need a connection, just call the code directly
1: 		try {
0: 			return updateLoader.getJarReader().readJarFile(schemaName, sqlName);
0: 		} catch (StandardException se) {
1: 			if (vs != null)
0: 				vs.println(MessageService.getTextMessage(MessageId.CM_LOAD_JAR_EXCEPTION, jf.getJarName(), se));
1: 			return null;
1: 		}
1: 
1: 	}
1: 
0: 	JarFile setInvalid(boolean newJarFile) {
1: 
0: 		jf.setInvalid();
1: 		updateLoader = null;
0: 		return newJarFile ? jarFileFactory.newJarFile(jf.name) : null;
1: 	}
1: 
1: 	/*
1: 	** Routines to get an InputStream for a namedResource
1: 	*/
1: 
1: 	/**
0: 		Get a stream directly from a ZipFile.
1: 		In this case we can safely return the stream directly.
1: 		It's a new stream set up by the zip code to read just
1: 		the contents of this entry.
1: 	*/
0: 	private InputStream getRawStream(ZipFile zip, String name) {
1: 
1: 		try {
0: 			ZipEntry ze = zip.getEntry(name);
0: 			if (ze == null)
1: 				return null;
1: 
0: 			return zip.getInputStream(ze);
1: 		} catch (IOException ioe) {
1: 			return null;
1: 		}
1: 	}
1: 
1: 	/**
1: 		Get a stream from a zip file that is itself a stream.
0: 		Here we need to get the size of the zip entry and
0: 		put a limiting stream around it. Otherwise the
0: 		caller would end up reading the entire zip file!
1: 	*/
1: 	private InputStream getRawStream(InputStream in, String name) { 
1: 
0: 		ZipInputStream zipIn = null;
1: 		try {
0: 			zipIn = new ZipInputStream(in);
1: 
0: 			ZipEntry ze;
0: 			while ((ze = jf.getNextEntry(zipIn)) != null) {
1: 
0: 				if (ze.getName().equals(name)) {
0: 					LimitInputStream lis = new LimitInputStream(zipIn);
0: 					lis.setLimit((int) ze.getSize());
0: 					return lis;
1: 				}
1: 			}
1: 
0: 			zipIn.close();
1: 
1: 		} catch (IOException ioe) {
0: 			if (zipIn != null) {
1: 				try {
0: 					zipIn.close();
0: 				} catch (IOException ioe2) {
1: 				}
1: 			}
1: 		}
1: 		return null;
1: 	}
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.services.reflect
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.services.reflect;
0: 
0: import org.apache.derby.impl.sql.execute.JarUtil;
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import java.io.File;
0: import java.io.InputStream;
0: import java.io.IOException;
0: 
0: import java.util.zip.ZipFile;
0: import java.util.zip.ZipInputStream;
0: import java.util.zip.ZipEntry;
0: 
0: import java.sql.*;
0: import org.apache.derby.iapi.services.io.LimitInputStream;
0: import org.apache.derby.iapi.util.IdUtil;
0: 
0: import org.apache.derby.iapi.services.info.JVMInfo;
0: 
0: import org.apache.derby.iapi.reference.MessageId;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: 
0: 
0: public class JarLoader extends ClassLoader {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0: 	private static final JarFile jarFileFactory;
0: 
0: 	static {
0: 		JarFile jf = null;
0: 
0: 		if (JVMInfo.JDK_ID >= 2) {
0: 			try {
0: 				Class jf2c = Class.forName("org.apache.derby.impl.services.reflect.JarFileJava2");
0: 				jf = (JarFile) jf2c.newInstance();
0: 			} catch (Exception e) {
0: 				throw new ExceptionInInitializerError(e);
0: 			}
0: 		} else {	
0: 			jf = new JarFile();
0: 		}
0: 
0: 		jarFileFactory = jf;
0: 	}
0: 
0: 	private UpdateLoader updateLoader;
0: 	private JarFile jf;
0: 	private HeaderPrintWriter vs;
0: 
0: 	JarLoader(UpdateLoader updateLoader, String[] name, HeaderPrintWriter vs) {
0: 
0: 		this.updateLoader = updateLoader;
0: 		this.jf = jarFileFactory.newJarFile(name);
0: 		this.vs = vs;
0: 	}
0: 
0: 	// Initialize the class loader so it knows if it
0: 	// is loading from a ZipFile or an InputStream
0: 	void initialize() {
0: 
0: 		Object zipData = load();
0: 
0: 		try {
0: 
0: 			if (zipData instanceof File) {
0: 				jf.initialize((File) zipData);
0: 				return;
0: 			}
0: 
0: 			if (zipData instanceof InputStream) {
0: 				jf.isStream = true;
0: 				try {
0: 					((InputStream) zipData).close();
0: 				} catch (IOException ioe) {
0: 				}
0: 				return;
0: 			}
0: 		} catch (IOException ioe) {
0: 			if (vs != null)
0: 				vs.println(MessageService.getTextMessage(MessageId.CM_LOAD_JAR_EXCEPTION, getJarName(), ioe));
0: 		}
0: 
0: 		// No such zip.
0: 		setInvalid(false);	
0: 	}
0: 
0: 	/**
0: 		Handle all requests to the top-level loader.
0: 
0: 		@exception ClassNotFoundException Class can not be found
0: 	*/
0: 	public Class loadClass(String className, boolean resolve) 
0: 		throws ClassNotFoundException {
0: 
0: 		// we attempt the system class load even if we
0: 		// are stale because otherwise we will fail
0: 		// to load java.* classes which confuses some VMs
0: 		try {
0: 			return Class.forName(className);
0: 		} catch (ClassNotFoundException cnfe) {
0: 
0: 			if (updateLoader == null)
0: 				throw new ClassNotFoundException(MessageService.getTextMessage(MessageId.CM_STALE_LOADER, className));
0: 
0: 			Class c = updateLoader.loadClass(className, resolve);
0: 			if (c == null)
0: 				throw cnfe;
0: 			return c;
0: 		}
0: 	}
0: 
0: 	/**
0: 		
0: 	*/
0: 	public InputStream getResourceAsStream(String name) {
0: 		if (updateLoader == null)
0: 			return null;
0: 		return updateLoader.getResourceAsStream(name);
0: 	}
0: 
0: 	/*
0: 	** Package level api
0: 	*/
0: 	final String getJarName() {
0: 		return jf.getJarName();
0: 	}
0: 
0: 	Class loadClassData(String className, String jvmClassName, boolean resolve) {
0: 
0: 		if (updateLoader == null)
0: 			return null;
0: 
0: 		try {
0: 			if (jf.isZip())
0: 				return loadClassDataFromJar(className, jvmClassName, resolve);
0: 
0: 			if (jf.isStream) {
0: 				// have to use a new stream each time
0: 				return loadClassData((InputStream) load(),
0: 						className, jvmClassName, resolve);
0: 			}
0: 
0: 			return null;
0: 		} catch (IOException ioe) {
0: 			if (vs != null)
0: 				vs.println(MessageService.getTextMessage(MessageId.CM_CLASS_LOAD_EXCEPTION, className, getJarName(), ioe));
0: 			return null;
0: 		}	
0: 	}
0: 
0: 	/**
0: 		Get an InputStream for the given resource.
0: 	*/
0: 	InputStream getStream(String name) {
0: 
0: 		if (updateLoader == null)
0: 			return null;
0: 
0: 		if (jf.isZip())
0: 			return getRawStream(jf.getZip(), name);
0: 
0: 		if (jf.isStream) {
0: 			return getRawStream((InputStream) load(), name);
0: 		}
0: 		return null;
0: 	}
0: 
0: 
0: 	/*
0: 	** Private api
0: 	*/
0: 
0: 
0: 	private Class loadClassDataFromJar(String className, String jvmClassName, boolean resolve) 
0: 		throws IOException {
0: 
0: 		ZipEntry ze = jf.getEntry(jvmClassName);
0: 		if (ze == null)
0: 			return null;
0: 
0: 		InputStream in = jf.getZip().getInputStream(ze);
0: 
0: 		try {
0: 			return loadClassData(ze, in, className, resolve);
0: 		} finally {
0: 			in.close();
0: 		}
0: 	}
0: 
0: 	private Class loadClassData(
0: 		InputStream in, String className, String jvmClassName, boolean resolve) 
0: 		throws IOException {
0: 
0: 		ZipInputStream zipIn = jf.getZipOnStream(in);
0: 
0: 		for (;;) {
0: 
0: 			ZipEntry ze = jf.getNextEntry(zipIn);
0: 			if (ze == null) {
0: 				zipIn.close();
0: 				return null;
0: 			}
0: 
0: 			if (ze.getName().equals(jvmClassName)) {
0: 				Class c = loadClassData(ze, zipIn, className, resolve);
0: 				zipIn.close();
0: 				return c;
0: 			}
0: 		}
0: 		
0: 	}
0: 
0: 	private Class loadClassData(ZipEntry ze, InputStream in,
0: 		String className, boolean resolve) throws IOException {
0: 
0: 		byte[] data = jf.readData(ze, in, className);
0: 
0: 		Object[] signers = jf.getSigners(className, ze);
0: 
0: 		synchronized (updateLoader) {
0: 			// see if someone else loaded it while we
0: 			// were getting the bytes ...
0: 			Class c = updateLoader.checkLoaded(className, resolve);
0: 			if (c == null) {
0: 				c = defineClass(className, data, 0, data.length);
0: 				if (signers != null) {
0: 					setSigners(c, signers);
0: 				}
0: 				if (resolve)
0: 					resolveClass(c);
0: 			}
0: 			return c;
0: 
0: 		}
0: 	}
0: 
0: 	Class checkLoaded(String className, boolean resolve) {
0: 		if (updateLoader == null)
0: 			return null;
0: 
0: 		Class c = findLoadedClass(className);
0: 		if ((c != null) && resolve)
0: 			resolveClass(c);
0: 		return c;
0: 	}
0: 
0: 	private Object load() {
0: 
0: 		String[] dbJarName = jf.name;
0: 
0: 		String schemaName = dbJarName[IdUtil.DBCP_SCHEMA_NAME];
0: 		String sqlName = dbJarName[IdUtil.DBCP_SQL_JAR_NAME];
0: 
0: 		// don't need a connection, just call the code directly
0: 		try {
0: 			return updateLoader.getJarReader().readJarFile(schemaName, sqlName);
0: 		} catch (StandardException se) {
0: 			if (vs != null)
0: 				vs.println(MessageService.getTextMessage(MessageId.CM_LOAD_JAR_EXCEPTION, jf.getJarName(), se));
0: 			return null;
0: 		}
0: 
0: 	}
0: 
0: 	JarFile setInvalid(boolean newJarFile) {
0: 
0: 		jf.setInvalid();
0: 		updateLoader = null;
0: 		return newJarFile ? jarFileFactory.newJarFile(jf.name) : null;
0: 	}
0: 
0: 	/*
0: 	** Routines to get an InputStream for a namedResource
0: 	*/
0: 
0: 	/**
0: 		Get a stream directly from a ZipFile.
0: 		In this case we can safely return the stream directly.
0: 		It's a new stream set up by the zip code to read just
0: 		the contents of this entry.
0: 	*/
0: 	private InputStream getRawStream(ZipFile zip, String name) {
0: 
0: 		try {
0: 			ZipEntry ze = zip.getEntry(name);
0: 			if (ze == null)
0: 				return null;
0: 
0: 			return zip.getInputStream(ze);
0: 		} catch (IOException ioe) {
0: 			return null;
0: 		}
0: 	}
0: 
0: 	/**
0: 		Get a stream from a zip file that is itself a stream.
0: 		Here we need to get the size of the zip entry and
0: 		put a limiting stream around it. Otherwise the
0: 		caller would end up reading the entire zip file!
0: 	*/
0: 	private InputStream getRawStream(InputStream in, String name) { 
0: 
0: 		ZipInputStream zipIn = null;
0: 		try {
0: 			zipIn = new ZipInputStream(in);
0: 
0: 			ZipEntry ze;
0: 			while ((ze = jf.getNextEntry(zipIn)) != null) {
0: 
0: 				if (ze.getName().equals(name)) {
0: 					LimitInputStream lis = new LimitInputStream(zipIn);
0: 					lis.setLimit((int) ze.getSize());
0: 					return lis;
0: 				}
0: 			}
0: 
0: 			zipIn.close();
0: 
0: 		} catch (IOException ioe) {
0: 			if (zipIn != null) {
0: 				try {
0: 					zipIn.close();
0: 				} catch (IOException ioe2) {
0: 				}
0: 			}
0: 		}
0: 		return null;
0: 	}
0: }
============================================================================