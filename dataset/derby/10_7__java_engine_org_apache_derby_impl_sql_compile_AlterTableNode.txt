1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.AlterTableNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
27:eac0369: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:b1f84c1: import org.apache.derby.iapi.reference.Limits;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:c0342de: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:e126f58: import org.apache.derby.iapi.sql.compile.Visitor;
1:963d9f4: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:9bfc704: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:eac0369: import org.apache.derby.impl.sql.execute.ColumnInfo;
1:eac0369: import org.apache.derby.impl.sql.execute.ConstraintConstantAction;
1:9bfc704: import org.apache.derby.impl.sql.execute.CreateConstraintConstantAction;
1:eac0369: 
5:eac0369: /**
1:eac0369:  * A AlterTableNode represents a DDL statement that alters a table.
1:eac0369:  * It contains the name of the object to be created.
7:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:3bb140c: class AlterTableNode extends DDLStatementNode
1:818fd27: {
1:eac0369: 	// The alter table action
1:eac0369: 	public	TableElementList	tableElementList = null;
1:3bb140c:      char               lockGranularity;
1:963d9f4: 
1:963d9f4: 	/**
1:963d9f4: 	 * updateStatistics will indicate that we are here for updating the
1:963d9f4: 	 * statistics. It could be statistics of just one index or all the
1:963d9f4: 	 * indexes on a given table. 
1:963d9f4: 	 */
1:963d9f4: 	private	boolean				updateStatistics = false;
1:963d9f4: 	/**
1:963d9f4: 	 * The flag updateStatisticsAll will tell if we are going to update the 
1:963d9f4: 	 * statistics of all indexes or just one index on a table. 
1:963d9f4: 	 */
1:963d9f4: 	private	boolean				updateStatisticsAll = false;
1:963d9f4: 	/**
1:a6a0733: 	 * dropStatistics will indicate that we are here for dropping the
1:a6a0733: 	 * statistics. It could be statistics of just one index or all the
1:a6a0733: 	 * indexes on a given table. 
1:963d9f4: 	 */
1:a6a0733: 	private	    boolean					    dropStatistics;
1:a6a0733: 	/**
1:a6a0733: 	 * The flag dropStatisticsAll will tell if we are going to drop the 
1:a6a0733: 	 * statistics of all indexes or just one index on a table. 
1:a6a0733: 	 */
1:a6a0733: 	private	    boolean					    dropStatisticsAll;
1:a6a0733: 	/**
1:a6a0733: 	 * If statistic is getting updated/dropped for just one index, then 
1:a6a0733: 	 * indexNameForStatistics will tell the name of the specific index 
1:a6a0733: 	 * whose statistics need to be updated/dropped.
1:a6a0733: 	 */
1:a6a0733: 	private	String				indexNameForStatistics;
1:963d9f4: 	
1:eac0369: 	public	boolean				compressTable = false;
1:eac0369: 	public	boolean				sequential = false;
1:818fd27: 	//The following three (purge, defragment and truncateEndOfTable) apply for 
1:818fd27: 	//inplace compress
1:818fd27: 	public	boolean				purge = false;
1:818fd27: 	public	boolean				defragment = false;
1:818fd27: 	public	boolean				truncateEndOfTable = false;
1:818fd27: 	
1:eac0369: 	public	int					behavior;	// currently for drop column
1:818fd27: 
1:eac0369: 	public	TableDescriptor		baseTable;
1:eac0369: 
1:eac0369: 	protected	int						numConstraints;
1:eac0369: 
1:eac0369: 	private		int				changeType = UNKNOWN_TYPE;
1:eac0369: 
1:eac0369: 	private boolean             truncateTable = false;
1:eac0369: 
1:eac0369: 	// constant action arguments
1:eac0369: 
1:eac0369: 	protected	SchemaDescriptor			schemaDescriptor = null;
1:eac0369: 	protected	ColumnInfo[] 				colInfos = null;
1:eac0369: 	protected	ConstraintConstantAction[]	conActions = null;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for TRUNCATE TABLE
1:818fd27: 	 *
1:3bb140c:      * @param tableName The name of the table being truncated
1:3bb140c:      * @param cm Context manager
1:3bb140c:      * @exception StandardException
1:eac0369: 	 */
1:3bb140c:     AlterTableNode(TableName tableName,
1:3bb140c:                    ContextManager cm) throws StandardException {
1:3bb140c:         super(tableName, cm);
1:3a4b2df: 		truncateTable = true;
1:3a4b2df: 		schemaDescriptor = getSchemaDescriptor();
5:eac0369: 	}
1:818fd27: 	
1:c9a1206: 	/**
1:3bb140c:      * Constructor  for COMPRESS using temporary tables
1:3bb140c:      * rather than in place compress
1:a6a0733: 	 *
1:3bb140c:      * @param tableName The name of the table being altered
1:3bb140c:      * @param sequential Whether or not the COMPRESS is SEQUENTIAL
1:3bb140c:      * @param cm Context manager
1:963d9f4: 	 *
1:963d9f4: 	 * @exception StandardException		Thrown on error
1:963d9f4: 	 */
1:3bb140c:     AlterTableNode(TableName tableName,
1:3bb140c:                    boolean sequential,
1:3bb140c:                    ContextManager cm) throws StandardException {
1:3bb140c:         super(tableName, cm);
1:3bb140c:         this.sequential = sequential;
1:818fd27: 		compressTable = true;
1:963d9f4: 		schemaDescriptor = getSchemaDescriptor();
1:eac0369: 	}
1:a6a0733: 
1:e126f58: 	/**
1:3bb140c:      * Constructor for INPLACE COMPRESS
1:963d9f4: 	 *
1:3bb140c:      * @param tableName The name of the table being altered
1:3bb140c:      * @param purge PURGE during INPLACE COMPRESS?
1:3bb140c:      * @param defragment DEFRAGMENT during INPLACE COMPRESS?
1:3bb140c:      * @param truncateEndOfTable TRUNCATE END during INPLACE COMPRESS?
1:3bb140c:      * @param cm Context manager
1:818fd27: 	 *
1:818fd27: 	 * @exception StandardException		Thrown on error
1:818fd27: 	 */
1:3bb140c:     AlterTableNode(TableName tableName,
1:3bb140c:                    boolean purge,
1:3bb140c:                    boolean defragment,
1:3bb140c:                    boolean truncateEndOfTable,
1:3bb140c:                    ContextManager cm) throws StandardException {
1:3bb140c:         super(tableName, cm);
1:3bb140c:         this.purge = purge;
1:3bb140c:         this.defragment = defragment;
1:3bb140c:         this.truncateEndOfTable = truncateEndOfTable;
1:eac0369: 		compressTable = true;
1:818fd27: 		schemaDescriptor = getSchemaDescriptor(true, false);
1:818fd27: 	}
1:a6a0733: 
1:3bb140c:     /**
1:3bb140c:      * Constructor for UPDATE_STATISTICS or DROP_STATISTICS
1:3bb140c:      *
1:3bb140c:      * @param tableName The name of the table being altered
1:3bb140c:      * @param changeType update or drop statistics
1:3bb140c:      * @param statsAll {@code true} means update or drop
1:3bb140c:      *        the statistics of all the indexes on the table.
1:3bb140c:      *        {@code false} means update or drop the statistics of
1:3bb140c:      *        only the index name provided by next parameter.
1:3bb140c:      * @param indexName Name of the index for which statistics is to be updated
1:3bb140c:      *                  or dropped
1:3bb140c:      * @param cm Context manager
1:3bb140c:      * @throws StandardException
1:3bb140c:      */
1:3bb140c:     AlterTableNode(
1:3bb140c:             TableName tableName,
1:3bb140c:             int changeType,
1:3bb140c:             boolean statsAll,
1:3bb140c:             String indexName,
1:3bb140c:             ContextManager cm) throws StandardException {
1:3bb140c:         super(tableName, cm);
1:3bb140c:         this.changeType = changeType;
1:3bb140c:         this.indexNameForStatistics = indexName;
1:818fd27: 
1:3bb140c:         switch (changeType) {
1:3bb140c:             case UPDATE_STATISTICS:
1:3bb140c:                 this.updateStatisticsAll = statsAll;
1:3bb140c:                 updateStatistics = true;
1:3bb140c:                 break;
1:3bb140c:             case DROP_STATISTICS:
1:3bb140c:                 this.dropStatisticsAll = statsAll;
1:3bb140c:                 dropStatistics = true;
1:3bb140c:                 break;
1:3bb140c:             default:
1:3bb140c:                 if (SanityManager.DEBUG) {
1:3bb140c:                     SanityManager.NOTREACHED();
1:3bb140c:                 }
1:3bb140c:         }
1:3bb140c: 
1:3bb140c:         schemaDescriptor = getSchemaDescriptor();
1:3bb140c:     }
1:3bb140c: 
1:3bb140c:     /**
1:3bb140c:      * Constructor for ADD_TYPE, DROP_TYPE, MODIFY_TYPE and LOCK_TYPE
1:3bb140c:      * @param tableName  The name of the table being altered
1:3bb140c:      * @param changeType add, drop, modify or lock
1:3bb140c:      * @param impactedElements list of table elements impacted
1:3bb140c:      * @param lockGranularity lock granularity encoded in a single character
1:3bb140c:      * @param behavior cascade or restrict (for DROP_TYPE)
1:3bb140c:      * @param cm Context Manager
1:3bb140c:      * @throws StandardException
1:3bb140c:      */
1:3bb140c:     AlterTableNode(
1:3bb140c:             TableName tableName,
1:3bb140c:             int changeType,
1:3bb140c:             TableElementList impactedElements,
1:3bb140c:             char lockGranularity,
1:3bb140c:             int behavior,
1:3bb140c:             ContextManager cm) throws StandardException {
1:3bb140c:         super(tableName, cm);
1:3bb140c:         this.changeType = changeType;
1:3bb140c: 
1:3bb140c:         switch (changeType) {
1:3bb140c:             case ADD_TYPE:
1:eac0369: 		    case DROP_TYPE:
1:eac0369: 		    case MODIFY_TYPE:
1:eac0369: 		    case LOCKING_TYPE:
1:3bb140c:                 this.tableElementList = impactedElements;
1:3bb140c:                 this.lockGranularity = lockGranularity;
1:3bb140c:                 this.behavior = behavior;
2:a6a0733: 				break;
1:eac0369: 		    default:
1:3bb140c:                 if (SanityManager.DEBUG) {
1:3bb140c:                     SanityManager.NOTREACHED();
1:3bb140c:                 }
1:3bb140c:         }
1:3bb140c:         schemaDescriptor = getSchemaDescriptor();
1:3bb140c:     }
1:eac0369: 
1:3bb140c:     /**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:963d9f4: 	{
2:eac0369: 		if (SanityManager.DEBUG)
10:eac0369: 		{
1:eac0369: 			return super.toString() +
1:c9a1206: 				"objectName: " + getObjectName() + "\n" +
1:c9a1206: 				"lockGranularity: " + lockGranularity + "\n" +
1:c9a1206: 				"compressTable: " + compressTable + "\n" +
1:c9a1206: 				"sequential: " + sequential + "\n" +
1:c9a1206: 				"truncateTable: " + truncateTable + "\n" +
1:c9a1206: 				"purge: " + purge + "\n" +
1:c9a1206: 				"defragment: " + defragment + "\n" +
1:c9a1206: 				"truncateEndOfTable: " + truncateEndOfTable + "\n" +
1:c9a1206: 				"updateStatistics: " + updateStatistics + "\n" +
1:c9a1206: 				"updateStatisticsAll: " + updateStatisticsAll + "\n" +
1:a6a0733: 				"dropStatistics: " + dropStatistics + "\n" +
1:a6a0733: 				"dropStatisticsAll: " + dropStatisticsAll + "\n" +
1:a6a0733: 				"indexNameForStatistics: " +
1:a6a0733: 				indexNameForStatistics + "\n";
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:818fd27: 	/**
1:c9a1206: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:c9a1206: 	 * how tree printing is supposed to work.
1:c9a1206: 	 * @param depth		The depth to indent the sub-nodes
1:c9a1206: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth) {
1:c9a1206: 		if (SanityManager.DEBUG) {
1:2060c4a: 			if (tableElementList != null) {
1:2060c4a: 				printLabel(depth, "tableElementList: ");
1:2060c4a: 				tableElementList.treePrint(depth + 1);
1:2060c4a: 			}
1:2060c4a: 
1:c9a1206: 		}
1:c9a1206: 	}
1:c9a1206: 
1:c9a1206: public String statementToString()
1:eac0369: 	{
1:eac0369: 		if(truncateTable)
1:eac0369: 			return "TRUNCATE TABLE";
1:eac0369: 		else
1:eac0369: 			return "ALTER TABLE";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public	int	getChangeType() { return changeType; }
1:eac0369: 
1:eac0369: 	// We inherit the generate() method from DDLStatementNode.
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this AlterTableNode.  This means doing any static error
1:eac0369: 	 * checking that can be done before actually creating the table.
1:eac0369: 	 * For example, verifying that the user is not trying to add a 
1:eac0369: 	 * non-nullable column.
1:eac0369: 	 *
1:eac0369: 	 *
4:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:cc770d8: 	public void bindStatement() throws StandardException
1:eac0369: 	{
1:eac0369: 		DataDictionary	dd = getDataDictionary();
1:eac0369: 		int					numCheckConstraints = 0;
1:c0342de: 		int numReferenceConstraints = 0;
1:95a483d:         int numGenerationClauses = 0;
1:eac0369: 		int numBackingIndexes = 0;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Get the table descriptor.  Checks the schema
1:eac0369: 		** and the table.
1:eac0369: 		*/
1:818fd27: 		if(compressTable && (purge || defragment || truncateEndOfTable)) {
1:818fd27: 			//We are dealing with inplace compress here and inplace compress is 
1:818fd27: 			//allowed on system schemas. In order to support inplace compress
1:818fd27: 			//on user as well as system tables, we need to use special 
1:818fd27: 			//getTableDescriptor(boolean) call to get TableDescriptor. This
1:818fd27: 			//getTableDescriptor(boolean) allows getting TableDescriptor for
1:818fd27: 			//system tables without throwing an exception.
1:818fd27: 			baseTable = getTableDescriptor(false);
1:818fd27: 		} else
1:818fd27: 			baseTable = getTableDescriptor();
1:818fd27: 
1:eac0369: 		//throw an exception if user is attempting to alter a temporary table
1:eac0369: 		if (baseTable.getTableType() == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
1:eac0369: 		{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_NOT_ALLOWED_FOR_DECLARED_GLOBAL_TEMP_TABLE);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Statement is dependent on the TableDescriptor */
1:eac0369: 		getCompilerContext().createDependency(baseTable);
1:eac0369: 
1:6e48cbe: 		//If we are dealing with add column character type, then set that 
1:6e48cbe: 		//column's collation type to be the collation type of the schema.
1:6e48cbe: 		//The collation derivation of such a column would be "implicit".
1:6e48cbe: 		if (changeType == ADD_TYPE) {//the action is of type add.
1:6e48cbe: 			if (tableElementList != null) {//check if is is add column
1:6e48cbe: 				for (int i=0; i<tableElementList.size();i++) {
1:6e48cbe: 					if (tableElementList.elementAt(i) instanceof ColumnDefinitionNode) {
1:6e48cbe: 						ColumnDefinitionNode cdn = (ColumnDefinitionNode) tableElementList.elementAt(i);
1:6e48cbe: 						//check if we are dealing with add character column
1:fce10ba:                         //
1:fce10ba:                         // For generated columns which omit an explicit
1:fce10ba:                         // datatype, we have to defer this work until we bind
1:fce10ba:                         // the generation clause
1:fce10ba:                         //
1:fce10ba: 
1:fce10ba:                         if ( cdn.hasGenerationClause() && ( cdn.getType() == null ) ) { continue; }
1:feeb7eb: 
1:feeb7eb:                         if ( cdn.getType() == null )
1:feeb7eb:                         {
1:feeb7eb:                             throw StandardException.newException
1:feeb7eb:                                 ( SQLState.LANG_NEEDS_DATATYPE, cdn.getColumnName() );
1:feeb7eb:                         }
1:fce10ba:                         
1:7dda5d5: 						if (cdn.getType().getTypeId().isStringTypeId()) {
1:6e48cbe: 							//we found what we are looking for. Set the 
1:6e48cbe: 							//collation type of this column to be the same as
1:6e48cbe: 							//schema descriptor's collation. Set the collation
1:6e48cbe: 							//derivation as implicit
1:9ed7c4d: 							cdn.setCollationType(schemaDescriptor.getCollationType());
1:6e48cbe: 			        	}						
1:6e48cbe: 					}
1:6e48cbe: 				}
1:6e48cbe: 				
1:6e48cbe: 			}
1:6e48cbe: 		}
1:eac0369: 		if (tableElementList != null)
1:eac0369: 		{
1:eac0369: 			tableElementList.validate(this, dd, baseTable);
1:eac0369: 
1:eac0369: 			/* Only 1012 columns allowed per table */
1:b1f84c1: 			if ((tableElementList.countNumberOfColumns() + baseTable.getNumberOfColumns()) > Limits.DB2_MAX_COLUMNS_IN_TABLE)
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_TOO_MANY_COLUMNS_IN_TABLE_OR_VIEW,
1:eac0369: 					String.valueOf(tableElementList.countNumberOfColumns() + baseTable.getNumberOfColumns()),
1:eac0369: 					getRelativeName(),
1:b1f84c1: 					String.valueOf(Limits.DB2_MAX_COLUMNS_IN_TABLE));
1:eac0369: 			}
1:eac0369: 			/* Number of backing indexes in the alter table statment */
1:eac0369: 			numBackingIndexes = tableElementList.countConstraints(DataDictionary.PRIMARYKEY_CONSTRAINT) +
1:eac0369: 									tableElementList.countConstraints(DataDictionary.FOREIGNKEY_CONSTRAINT) +
1:eac0369: 									tableElementList.countConstraints(DataDictionary.UNIQUE_CONSTRAINT);
1:eac0369: 			/* Check the validity of all check constraints */
1:eac0369: 			numCheckConstraints = tableElementList.countConstraints(
1:eac0369: 									DataDictionary.CHECK_CONSTRAINT);
1:95a483d:             
1:c0342de:             numReferenceConstraints = tableElementList.countConstraints(
1:c0342de: 									DataDictionary.FOREIGNKEY_CONSTRAINT);
1:c0342de:             
1:95a483d:             numGenerationClauses = tableElementList.countGenerationClauses();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		//If the sum of backing indexes for constraints in alter table statement and total number of indexes on the table
1:eac0369: 		//so far is more than 32767, then we need to throw an exception 
1:b1f84c1: 		if ((numBackingIndexes + baseTable.getTotalNumberOfIndexes()) > Limits.DB2_MAX_INDEXES_ON_TABLE)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_INDEXES_ON_TABLE, 
1:eac0369: 				String.valueOf(numBackingIndexes + baseTable.getTotalNumberOfIndexes()),
1:eac0369: 				getRelativeName(),
1:b1f84c1: 				String.valueOf(Limits.DB2_MAX_INDEXES_ON_TABLE));
1:eac0369: 		}
1:eac0369: 
1:c0342de: 		if ( (numCheckConstraints > 0) || (numGenerationClauses > 0) || (numReferenceConstraints > 0))
1:eac0369: 		{
1:95a483d: 			/* In order to check the validity of the check constraints and
1:95a483d: 			 * generation clauses
1:eac0369: 			 * we must goober up a FromList containing a single table, 
1:eac0369: 			 * the table being alter, with an RCL containing the existing and
1:eac0369: 			 * new columns and their types.  This will allow us to
1:eac0369: 			 * bind the constraint definition trees against that
1:eac0369: 			 * FromList.  When doing this, we verify that there are
1:eac0369: 			 * no nodes which can return non-deterministic results.
1:eac0369: 			 */
1:95a483d: 			FromList fromList = makeFromList( dd, tableElementList, false );
1:c0342de:             FormatableBitSet    generatedColumns = baseTable.makeColumnMap( baseTable.getGeneratedColumns() );
1:eac0369: 
1:eac0369: 			/* Now that we've finally goobered stuff up, bind and validate
1:95a483d: 			 * the check constraints and generation clauses.
1:eac0369: 			 */
1:2a0827a: 			if  (numGenerationClauses > 0)
1:7168d7d:             { tableElementList.bindAndValidateGenerationClauses( schemaDescriptor, fromList, generatedColumns, baseTable ); }
1:b8b524c: 			if  (numCheckConstraints > 0) { tableElementList.bindAndValidateCheckConstraints(fromList); }
1:c0342de:             if ( numReferenceConstraints > 0) { tableElementList.validateForeignKeysOnGenerationClauses( fromList, generatedColumns ); }
1:eac0369: 		}
1:eac0369: 
1:b8b524c:         // must be done after resolving the datatypes of the generation clauses
1:b8b524c:         if (tableElementList != null) { tableElementList.validatePrimaryKeyNullability(); }
1:b8b524c: 
1:a6a0733: 		//Check if we are in alter table to update/drop the statistics. If yes,
1:a6a0733: 		// then check if we are here to update/drop the statistics of a specific
1:a6a0733: 		// index. If yes, then verify that the indexname provided is a valid one.
1:a6a0733: 		if ((updateStatistics && !updateStatisticsAll) || (dropStatistics && !dropStatisticsAll))
1:eac0369: 		{
1:963d9f4: 			ConglomerateDescriptor	cd = null;
1:963d9f4: 			if (schemaDescriptor.getUUID() != null) 
1:a6a0733: 				cd = dd.getConglomerateDescriptor(indexNameForStatistics, schemaDescriptor, false);
1:963d9f4: 
1:963d9f4: 			if (cd == null)
1:963d9f4: 			{
1:963d9f4: 				throw StandardException.newException(
1:963d9f4: 						SQLState.LANG_INDEX_NOT_FOUND, 
1:a6a0733: 						schemaDescriptor.getSchemaName() + "." + indexNameForStatistics);
1:963d9f4: 			}			
1:963d9f4: 		}
1:963d9f4: 
1:eac0369: 		/* Unlike most other DDL, we will make this ALTER TABLE statement
1:eac0369: 		 * dependent on the table being altered.  In general, we try to
1:eac0369: 		 * avoid this for DDL, but we are already requiring the table to
1:eac0369: 		 * exist at bind time (not required for create index) and we don't
1:eac0369: 		 * want the column ids to change out from under us before
1:eac0369: 		 * execution.
1:eac0369: 		 */
1:eac0369: 		getCompilerContext().createDependency(baseTable);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1:eac0369: 	 *
1:eac0369: 	 * @return	true if references SESSION schema tables, else false
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public boolean referencesSessionSchema()
1:963d9f4: 		throws StandardException
1:963d9f4: 	{
1:eac0369: 		//If alter table is on a SESSION schema table, then return true. 
1:eac0369: 		return isSessionSchema(baseTable.getSchemaName());
1:963d9f4: 	}
1:a6a0733: 
1:963d9f4: 	/**
1:eac0369: 	 * Create the Constant information that will drive the guts of Execution.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     public ConstantAction makeConstantAction() throws StandardException
1:3a4b2df: 	{
1:eac0369: 		prepConstantAction();
1:963d9f4: 
1:eac0369: 		return	getGenericConstantActionFactory().getAlterTableConstantAction(schemaDescriptor,
1:eac0369: 											 getRelativeName(),
1:eac0369: 											 baseTable.getUUID(),
1:eac0369: 											 baseTable.getHeapConglomerateId(),
1:eac0369: 											 TableDescriptor.BASE_TABLE_TYPE,
1:eac0369: 											 colInfos,
1:eac0369: 											 conActions,
1:eac0369: 											 lockGranularity,
1:eac0369: 											 compressTable,
1:eac0369: 											 behavior,
1:eac0369:         								     sequential,
1:818fd27:  										     truncateTable,
1:818fd27:  										     purge,
1:818fd27:  										     defragment,
1:963d9f4:  										     truncateEndOfTable,
1:963d9f4:  										     updateStatistics,
1:963d9f4:  										     updateStatisticsAll,
1:a6a0733:  										     dropStatistics,
1:a6a0733:  										     dropStatisticsAll,
1:a6a0733:  										     indexNameForStatistics);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Generate arguments to constant action. Called by makeConstantAction() in this class and in
1:eac0369: 	  *	our subclass RepAlterTableNode.
1:eac0369: 	  *
1:eac0369: 	  *
1:eac0369: 	  * @exception StandardException		Thrown on failure
1:eac0369: 	  */
1:68db840: 	private void	prepConstantAction() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (tableElementList != null)
1:eac0369: 		{
1:eac0369: 			genColumnInfo();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* If we've seen a constraint, then build a constraint list */
1:eac0369: 
1:eac0369: 		if (numConstraints > 0)
1:eac0369: 		{
1:eac0369: 			conActions = new ConstraintConstantAction[numConstraints];
1:eac0369: 
1:68db840: 			tableElementList.genConstraintActions(false, conActions, getRelativeName(), schemaDescriptor,
1:eac0369: 												  getDataDictionary());
1:9bfc704: 
1:9bfc704: 			for (int conIndex = 0; conIndex < conActions.length; conIndex++)
1:9bfc704: 			{
1:9bfc704: 				ConstraintConstantAction cca = conActions[conIndex];
1:9bfc704: 
1:9bfc704: 				if (cca instanceof CreateConstraintConstantAction)
1:9bfc704: 				{
1:9bfc704: 					int constraintType = cca.getConstraintType();
1:9bfc704: 					if (constraintType == DataDictionary.PRIMARYKEY_CONSTRAINT)
1:9bfc704: 					{
1:9bfc704: 						DataDictionary dd = getDataDictionary();
1:9bfc704: 						// Check to see if a constraint of the same type 
1:9bfc704: 						// already exists
1:9bfc704: 						ConstraintDescriptorList cdl = 
1:9bfc704:                                 dd.getConstraintDescriptors(baseTable);
1:9bfc704: 
1:9bfc704: 						if (cdl.getPrimaryKey() != null)
1:9bfc704: 						{
1:9bfc704: 							throw StandardException.newException(
1:9bfc704:                                     SQLState.LANG_ADD_PRIMARY_KEY_FAILED1, 
1:9bfc704:                                     baseTable.getQualifiedName());
1:9bfc704: 						}
1:9bfc704: 					}
1:9bfc704: 				}
1:9bfc704: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	  
1:eac0369: 	/**
1:eac0369: 	  *	Generate the ColumnInfo argument for the constant action. Return the number of constraints.
1:eac0369: 	  */
1:eac0369: 	public	void	genColumnInfo()
1:818fd27:         throws StandardException
1:eac0369: 	{
1:eac0369: 		// for each column, stuff system.column
1:eac0369: 		colInfos = new ColumnInfo[tableElementList.countNumberOfColumns()]; 
1:eac0369: 
1:eac0369: 	    numConstraints = tableElementList.genColumnInfos(colInfos);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:e126f58: 	 * Accept the visitor for all visitable children of this node.
1:e126f58: 	 * 
1:e126f58: 	 * @param v the visitor
1:e126f58: 	 *
1:e126f58: 	 * @exception StandardException on error
1:e126f58: 	 */
1:3bb140c:     @Override
1:e126f58: 	void acceptChildren(Visitor v)
1:e126f58: 		throws StandardException
1:e126f58: 	{
1:e126f58: 		super.acceptChildren(v);
1:e126f58: 
1:e126f58: 		if (tableElementList != null)
1:e126f58: 		{
1:e126f58: 			tableElementList.accept(v);
1:e126f58: 		}
1:e126f58: 	}
1:e126f58: 
1:eac0369: 	/*
1:eac0369: 	 * class interface
1:eac0369: 	 */
1:eac0369: }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:9bfc704
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptorList;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.sql.execute.CreateConstraintConstantAction;
/////////////////////////////////////////////////////////////////////////
1: 
1: 			for (int conIndex = 0; conIndex < conActions.length; conIndex++)
1: 			{
1: 				ConstraintConstantAction cca = conActions[conIndex];
1: 
1: 				if (cca instanceof CreateConstraintConstantAction)
1: 				{
1: 					int constraintType = cca.getConstraintType();
1: 					if (constraintType == DataDictionary.PRIMARYKEY_CONSTRAINT)
1: 					{
1: 						DataDictionary dd = getDataDictionary();
1: 						// Check to see if a constraint of the same type 
1: 						// already exists
1: 						ConstraintDescriptorList cdl = 
1:                                 dd.getConstraintDescriptors(baseTable);
1: 
1: 						if (cdl.getPrimaryKey() != null)
1: 						{
1: 							throw StandardException.newException(
1:                                     SQLState.LANG_ADD_PRIMARY_KEY_FAILED1, 
1:                                     baseTable.getQualifiedName());
1: 						}
1: 					}
1: 				}
1: 			}
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.ContextManager;
/////////////////////////////////////////////////////////////////////////
1: class AlterTableNode extends DDLStatementNode
1:      char               lockGranularity;
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for TRUNCATE TABLE
1:      * @param tableName The name of the table being truncated
1:      * @param cm Context manager
1:      * @exception StandardException
1:     AlterTableNode(TableName tableName,
1:                    ContextManager cm) throws StandardException {
1:         super(tableName, cm);
0:         setNodeType(C_NodeTypes.ALTER_TABLE_NODE);
1:      * Constructor  for COMPRESS using temporary tables
1:      * rather than in place compress
1:      * @param tableName The name of the table being altered
1:      * @param sequential Whether or not the COMPRESS is SEQUENTIAL
1:      * @param cm Context manager
1:     AlterTableNode(TableName tableName,
1:                    boolean sequential,
1:                    ContextManager cm) throws StandardException {
1:         super(tableName, cm);
1:         this.sequential = sequential;
0:         setNodeType(C_NodeTypes.ALTER_TABLE_NODE);
1:      * Constructor for INPLACE COMPRESS
1:      * @param tableName The name of the table being altered
1:      * @param purge PURGE during INPLACE COMPRESS?
1:      * @param defragment DEFRAGMENT during INPLACE COMPRESS?
1:      * @param truncateEndOfTable TRUNCATE END during INPLACE COMPRESS?
1:      * @param cm Context manager
1:     AlterTableNode(TableName tableName,
1:                    boolean purge,
1:                    boolean defragment,
1:                    boolean truncateEndOfTable,
1:                    ContextManager cm) throws StandardException {
1:         super(tableName, cm);
1:         this.purge = purge;
1:         this.defragment = defragment;
1:         this.truncateEndOfTable = truncateEndOfTable;
0:         setNodeType(C_NodeTypes.ALTER_TABLE_NODE);
1:     /**
1:      * Constructor for UPDATE_STATISTICS or DROP_STATISTICS
1:      *
1:      * @param tableName The name of the table being altered
1:      * @param changeType update or drop statistics
1:      * @param statsAll {@code true} means update or drop
1:      *        the statistics of all the indexes on the table.
1:      *        {@code false} means update or drop the statistics of
1:      *        only the index name provided by next parameter.
1:      * @param indexName Name of the index for which statistics is to be updated
1:      *                  or dropped
1:      * @param cm Context manager
1:      * @throws StandardException
1:      */
1:     AlterTableNode(
1:             TableName tableName,
1:             int changeType,
1:             boolean statsAll,
1:             String indexName,
1:             ContextManager cm) throws StandardException {
1:         super(tableName, cm);
1:         this.changeType = changeType;
1:         this.indexNameForStatistics = indexName;
1:         switch (changeType) {
1:             case UPDATE_STATISTICS:
1:                 this.updateStatisticsAll = statsAll;
1:                 updateStatistics = true;
1:                 break;
1:             case DROP_STATISTICS:
1:                 this.dropStatisticsAll = statsAll;
1:                 dropStatistics = true;
1:                 break;
1:             default:
1:                 if (SanityManager.DEBUG) {
1:                     SanityManager.NOTREACHED();
1:                 }
1:         }
1: 
1:         schemaDescriptor = getSchemaDescriptor();
0:         setNodeType(C_NodeTypes.ALTER_TABLE_NODE);
1:     }
1: 
1:     /**
1:      * Constructor for ADD_TYPE, DROP_TYPE, MODIFY_TYPE and LOCK_TYPE
1:      * @param tableName  The name of the table being altered
1:      * @param changeType add, drop, modify or lock
1:      * @param impactedElements list of table elements impacted
1:      * @param lockGranularity lock granularity encoded in a single character
1:      * @param behavior cascade or restrict (for DROP_TYPE)
1:      * @param cm Context Manager
1:      * @throws StandardException
1:      */
1:     AlterTableNode(
1:             TableName tableName,
1:             int changeType,
1:             TableElementList impactedElements,
1:             char lockGranularity,
1:             int behavior,
1:             ContextManager cm) throws StandardException {
1:         super(tableName, cm);
1:         this.changeType = changeType;
1: 
1:         switch (changeType) {
1:             case ADD_TYPE:
1:                 this.tableElementList = impactedElements;
1:                 this.lockGranularity = lockGranularity;
1:                 this.behavior = behavior;
1:                 if (SanityManager.DEBUG) {
1:                     SanityManager.NOTREACHED();
1:                 }
1:         }
1:         schemaDescriptor = getSchemaDescriptor();
0:         setNodeType(C_NodeTypes.ALTER_TABLE_NODE);
1:     }
1:     /**
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public ConstantAction makeConstantAction() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:2060c4a
/////////////////////////////////////////////////////////////////////////
1: 			if (tableElementList != null) {
1: 				printLabel(depth, "tableElementList: ");
1: 				tableElementList.treePrint(depth + 1);
1: 			}
1: 
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
1: 				"objectName: " + getObjectName() + "\n" +
1: 				"lockGranularity: " + lockGranularity + "\n" +
1: 				"compressTable: " + compressTable + "\n" +
1: 				"sequential: " + sequential + "\n" +
1: 				"truncateTable: " + truncateTable + "\n" +
1: 				"purge: " + purge + "\n" +
1: 				"defragment: " + defragment + "\n" +
1: 				"truncateEndOfTable: " + truncateEndOfTable + "\n" +
1: 				"updateStatistics: " + updateStatistics + "\n" +
1: 				"updateStatisticsAll: " + updateStatisticsAll + "\n" +
0: 				"indexNameForUpdateStatistics: " +
0: 				     indexNameForUpdateStatistics + "\n";
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 * @param depth		The depth to indent the sub-nodes
1: 	 */
0: 	public void printSubNodes(int depth) {
1: 		if (SanityManager.DEBUG) {
0: 			printLabel(depth, "tableElementList: ");
0: 			tableElementList.treePrint(depth + 1);
1: 		}
1: 	}
1: 
1: public String statementToString()
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:a6a0733
/////////////////////////////////////////////////////////////////////////
1: 	 * dropStatistics will indicate that we are here for dropping the
1: 	 * statistics. It could be statistics of just one index or all the
1: 	 * indexes on a given table. 
1: 	private	    boolean					    dropStatistics;
1: 	/**
1: 	 * The flag dropStatisticsAll will tell if we are going to drop the 
1: 	 * statistics of all indexes or just one index on a table. 
1: 	 */
1: 	private	    boolean					    dropStatisticsAll;
1: 	/**
1: 	 * If statistic is getting updated/dropped for just one index, then 
1: 	 * indexNameForStatistics will tell the name of the specific index 
1: 	 * whose statistics need to be updated/dropped.
1: 	 */
1: 	private	String				indexNameForStatistics;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	 * Initializer for a AlterTableNode. The parameter values have different
0: 	 *  meanings based on what kind of ALTER TABLE is taking place. 
1: 	 *  
0: 	 * @param changeType		ADD_TYPE or DROP_TYPE or UPDATE_STATISTICS or
0: 	 *                          or DROP_STATISTICS
0: 	 * @param param1 			For ADD_TYPE or DROP_TYPE, param1 gives the
0: 	 *                          elements impacted by ALTER TABLE.
0: 	 *                          For UPDATE_STATISTICS or or DROP_STATISTICS,
0: 	 *                          param1 is boolean - true means update or drop
0: 	 *                          the statistics of all the indexes on the table.
0: 	 *                          False means, update or drop the statistics of
0: 	 *                          only the index name provided by next parameter.
0: 	 * @param param2 			For ADD_TYPE or DROP_TYPE, param2 gives the
0: 	 *                          new lock granularity, if any
0: 	 *                          For UPDATE_STATISTICS or DROP_STATISTICS,
0: 	 *                          param2 can be the name of the specific index
0: 	 *                          whose statistics will be dropped/updated. This
0: 	 *                          param is used only if param1 is set to false
0: 	 * @param param3			For DROP_TYPE, param3 can indicate if the drop
0: 	 *                          column is CASCADE or RESTRICTED. This param is
0: 	 *                          ignored for all the other changeType.
0: 							Object param1,
0: 							Object param2,
0: 							Object param3 )
1: 		
0: 		int[]	ct = (int[]) changeType;
1: 		
0: 				this.tableElementList = (TableElementList) param1;
0: 				this.lockGranularity = ((Character) param2).charValue();
0: 				int[]	bh = (int[]) param3;
0: 				this.behavior = bh[0];
1: 				break;
0: 		    case UPDATE_STATISTICS:
0: 				this.updateStatisticsAll = ((Boolean) param1).booleanValue();
0: 				this.indexNameForStatistics = (String)param2;
0: 				updateStatistics = true;
1: 				break;
1: 
0: 		    case DROP_STATISTICS:
0: 				this.dropStatisticsAll = ((Boolean) param1).booleanValue();
0: 				this.indexNameForStatistics = (String)param2;
0: 				dropStatistics = true;
/////////////////////////////////////////////////////////////////////////
1: 				"dropStatistics: " + dropStatistics + "\n" +
1: 				"dropStatisticsAll: " + dropStatisticsAll + "\n" +
1: 				"indexNameForStatistics: " +
1: 				indexNameForStatistics + "\n";
/////////////////////////////////////////////////////////////////////////
1: 		//Check if we are in alter table to update/drop the statistics. If yes,
1: 		// then check if we are here to update/drop the statistics of a specific
1: 		// index. If yes, then verify that the indexname provided is a valid one.
1: 		if ((updateStatistics && !updateStatisticsAll) || (dropStatistics && !dropStatisticsAll))
1: 				cd = dd.getConglomerateDescriptor(indexNameForStatistics, schemaDescriptor, false);
1: 						schemaDescriptor.getSchemaName() + "." + indexNameForStatistics);
/////////////////////////////////////////////////////////////////////////
1:  										     dropStatistics,
1:  										     dropStatisticsAll,
1:  										     indexNameForStatistics);
commit:963d9f4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * updateStatistics will indicate that we are here for updating the
1: 	 * statistics. It could be statistics of just one index or all the
1: 	 * indexes on a given table. 
1: 	 */
1: 	private	boolean				updateStatistics = false;
1: 	/**
1: 	 * The flag updateStatisticsAll will tell if we are going to update the 
1: 	 * statistics of all indexes or just one index on a table. 
1: 	 */
1: 	private	boolean				updateStatisticsAll = false;
1: 	/**
0: 	 * If statistic is getting updated for just one index, then 
0: 	 * indexNameForUpdateStatistics will tell the name of the specific index 
0: 	 * whose statistics need to be updated.
1: 	 */
0: 	private	String				indexNameForUpdateStatistics;
1: 	
/////////////////////////////////////////////////////////////////////////
0: 	 * Initializer for a AlterTableNode for updating the statistics. The user
0: 	 * can ask for update statistic of all the indexes or only a specific index
1: 	 *
0: 	 * @param objectName		The name of the table whose index(es) will have
0: 	 *                          their statistics updated.
0: 	 * @param updateStatisticsAll	If true then update the statistics of all 
0: 	 *                          the indexes on the table. If false, then update
0: 	 *                          the statistics of only the index provided as
0: 	 *                          3rd parameter here
0: 	 * @param indexName			Only used if updateStatisticsAll is set to 
0: 	 *                          false. 
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object objectName,
0: 			Object updateStatisticsAll,
0: 			Object indexName)
1: 	throws StandardException
1: 	{
0: 		initAndCheck(objectName);
0: 		this.updateStatisticsAll = ((Boolean) updateStatisticsAll).booleanValue();
0: 		this.indexNameForUpdateStatistics = (String)indexName;
1: 		schemaDescriptor = getSchemaDescriptor();
0: 		updateStatistics = true;
1: 	}
1: 	
1: 	/**
/////////////////////////////////////////////////////////////////////////
0: 				"truncateEndOfTable: " + "\n" + truncateEndOfTable + "\n" +
0: 				"updateStatistics: " + "\n" + updateStatistics + "\n" +
0: 				"updateStatisticsAll: " + "\n" + updateStatisticsAll + "\n" +
0: 				"indexNameForUpdateStatistics: " + "\n" + indexNameForUpdateStatistics + "\n";
/////////////////////////////////////////////////////////////////////////
0: 		//Check if we are in alter table to update the statistics. If yes, then
0: 		//check if we are here to update the statistics of a specific index. If
0: 		//yes, then verify that the indexname provided is a valid one.
0: 		if (updateStatistics && !updateStatisticsAll)
1: 		{
1: 			ConglomerateDescriptor	cd = null;
1: 			if (schemaDescriptor.getUUID() != null) 
0: 				cd = dd.getConglomerateDescriptor(indexNameForUpdateStatistics, schemaDescriptor, false);
1: 
1: 			if (cd == null)
1: 			{
1: 				throw StandardException.newException(
1: 						SQLState.LANG_INDEX_NOT_FOUND, 
0: 						schemaDescriptor.getSchemaName() + "." + indexNameForUpdateStatistics);
1: 			}			
1: 		}
1: 
/////////////////////////////////////////////////////////////////////////
1:  										     truncateEndOfTable,
1:  										     updateStatistics,
1:  										     updateStatisticsAll,
0:  										     indexNameForUpdateStatistics);
commit:7bf9b22
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 							Object behavior )
/////////////////////////////////////////////////////////////////////////
commit:818fd27
/////////////////////////////////////////////////////////////////////////
1: 	//The following three (purge, defragment and truncateEndOfTable) apply for 
1: 	//inplace compress
1: 	public	boolean				purge = false;
1: 	public	boolean				defragment = false;
1: 	public	boolean				truncateEndOfTable = false;
1: 	
/////////////////////////////////////////////////////////////////////////
0: 	 * Initializer for a AlterTableNode for COMPRESS using temporary tables
0: 	 * rather than inplace compress
/////////////////////////////////////////////////////////////////////////
0: 	 * Initializer for a AlterTableNode for INPLACE COMPRESS
1: 	 *
0: 	 * @param objectName			The name of the table being altered
0: 	 * @param purge					PURGE during INPLACE COMPRESS?
0: 	 * @param defragment			DEFRAGMENT during INPLACE COMPRESS?
0: 	 * @param truncateEndOfTable	TRUNCATE END during INPLACE COMPRESS?
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void init(Object objectName,
0: 			 Object purge,
0: 			 Object defragment,
0: 			 Object truncateEndOfTable)
1: 		throws StandardException
1: 	{
0: 		initAndCheck(objectName);
1: 
0: 		this.purge = ((Boolean) purge).booleanValue();
0: 		this.defragment = ((Boolean) defragment).booleanValue();
0: 		this.truncateEndOfTable = ((Boolean) truncateEndOfTable).booleanValue();
1: 		compressTable = true;
1: 		schemaDescriptor = getSchemaDescriptor(true, false);
1: 	}
1: 
1: 	/**
0: 	 * @param behavior			If drop column is CASCADE or RESTRICTED
0: 	 * @param sequential		Whether or not the COMPRESS is SEQUENTIAL
0: 	 * @param purge				PURGE during INPLACE COMPRESS?
0: 	 * @param defragment		DEFRAGMENT during INPLACE COMPRESS?
0: 	 * @param truncateEndOfTable	TRUNCATE END during INPLACE COMPRESS?
/////////////////////////////////////////////////////////////////////////
0: 							Object sequential,
0: 							Object purge,
0: 							Object defragment,
0: 							Object truncateEndOfTable )
/////////////////////////////////////////////////////////////////////////
0: 		boolean[]	booleanPurge = (boolean[]) purge;
0: 		this.purge = booleanPurge[0];
0: 		boolean[]	booleanDefragment = (boolean[]) defragment;
0: 		this.defragment = booleanDefragment[0];
0: 		boolean[]	booleanTruncateEndOfTable = (boolean[]) truncateEndOfTable;
0: 		this.truncateEndOfTable = booleanTruncateEndOfTable[0];
/////////////////////////////////////////////////////////////////////////
0: 				"truncateTable: " + "\n" + truncateTable + "\n" +
0: 				"purge: " + "\n" + purge + "\n" +
0: 				"defragment: " + "\n" + defragment + "\n" +
0: 				"truncateEndOfTable: " + "\n" + truncateEndOfTable + "\n";
/////////////////////////////////////////////////////////////////////////
1: 		if(compressTable && (purge || defragment || truncateEndOfTable)) {
1: 			//We are dealing with inplace compress here and inplace compress is 
1: 			//allowed on system schemas. In order to support inplace compress
1: 			//on user as well as system tables, we need to use special 
1: 			//getTableDescriptor(boolean) call to get TableDescriptor. This
1: 			//getTableDescriptor(boolean) allows getting TableDescriptor for
1: 			//system tables without throwing an exception.
1: 			baseTable = getTableDescriptor(false);
1: 		} else
1: 			baseTable = getTableDescriptor();
1: 
/////////////////////////////////////////////////////////////////////////
1:  										     truncateTable,
1:  										     purge,
1:  										     defragment,
0:  										     truncateEndOfTable );
commit:6e48cbe
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
1: 		//If we are dealing with add column character type, then set that 
1: 		//column's collation type to be the collation type of the schema.
1: 		//The collation derivation of such a column would be "implicit".
1: 		if (changeType == ADD_TYPE) {//the action is of type add.
1: 			if (tableElementList != null) {//check if is is add column
1: 				for (int i=0; i<tableElementList.size();i++) {
1: 					if (tableElementList.elementAt(i) instanceof ColumnDefinitionNode) {
1: 						ColumnDefinitionNode cdn = (ColumnDefinitionNode) tableElementList.elementAt(i);
1: 						//check if we are dealing with add character column
0: 						if (cdn.getDataTypeServices().getTypeId().isStringTypeId()) {
1: 							//we found what we are looking for. Set the 
1: 							//collation type of this column to be the same as
1: 							//schema descriptor's collation. Set the collation
1: 							//derivation as implicit
0: 							cdn.getDataTypeServices().setCollationType(schemaDescriptor.getCollationType());
0: 							cdn.getDataTypeServices().setCollationDerivation(StringDataValue.COLLATION_DERIVATION_IMPLICIT);
1: 			        	}						
1: 					}
1: 				}
1: 				
1: 			}
1: 		}
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:feeb7eb
/////////////////////////////////////////////////////////////////////////
1: 
1:                         if ( cdn.getType() == null )
1:                         {
1:                             throw StandardException.newException
1:                                 ( SQLState.LANG_NEEDS_DATATYPE, cdn.getColumnName() );
1:                         }
commit:3a4b2df
/////////////////////////////////////////////////////////////////////////
1: 	{		
0: 		initAndCheck(objectName);
0: 		/* For now, this init() only called for truncate table */
1: 		truncateTable = true;
1: 		schemaDescriptor = getSchemaDescriptor();
commit:e126f58
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.compile.Visitable;
1: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Accept the visitor for all visitable children of this node.
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	void acceptChildren(Visitor v)
1: 		throws StandardException
1: 	{
1: 		super.acceptChildren(v);
1: 
1: 		if (tableElementList != null)
1: 		{
1: 			tableElementList.accept(v);
1: 		}
1: 	}
1: 
commit:7168d7d
/////////////////////////////////////////////////////////////////////////
1:             { tableElementList.bindAndValidateGenerationClauses( schemaDescriptor, fromList, generatedColumns, baseTable ); }
commit:b8b524c
/////////////////////////////////////////////////////////////////////////
1: 			if  (numCheckConstraints > 0) { tableElementList.bindAndValidateCheckConstraints(fromList); }
1:         // must be done after resolving the datatypes of the generation clauses
1:         if (tableElementList != null) { tableElementList.validatePrimaryKeyNullability(); }
1: 
commit:fce10ba
/////////////////////////////////////////////////////////////////////////
1:                         //
1:                         // For generated columns which omit an explicit
1:                         // datatype, we have to defer this work until we bind
1:                         // the generation clause
1:                         //
1: 
1:                         if ( cdn.hasGenerationClause() && ( cdn.getType() == null ) ) { continue; }
1:                         
/////////////////////////////////////////////////////////////////////////
0:             { tableElementList.bindAndValidateGenerationClauses( schemaDescriptor, fromList, generatedColumns ); }
commit:3c09be7
/////////////////////////////////////////////////////////////////////////
0:         throws StandardException
commit:c0342de
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
/////////////////////////////////////////////////////////////////////////
1: 		int numReferenceConstraints = 0;
/////////////////////////////////////////////////////////////////////////
1:             numReferenceConstraints = tableElementList.countConstraints(
1: 									DataDictionary.FOREIGNKEY_CONSTRAINT);
1:             
/////////////////////////////////////////////////////////////////////////
1: 		if ( (numCheckConstraints > 0) || (numGenerationClauses > 0) || (numReferenceConstraints > 0))
/////////////////////////////////////////////////////////////////////////
1:             FormatableBitSet    generatedColumns = baseTable.makeColumnMap( baseTable.getGeneratedColumns() );
0:             { tableElementList.bindAndValidateGenerationClauses(fromList, generatedColumns ); }
1:             if ( numReferenceConstraints > 0) { tableElementList.validateForeignKeysOnGenerationClauses( fromList, generatedColumns ); }
commit:2a0827a
/////////////////////////////////////////////////////////////////////////
1: 			if  (numGenerationClauses > 0)
0:             { tableElementList.bindAndValidateGenerationClauses(fromList, baseTable.makeColumnMap( baseTable.getGeneratedColumns() ) ); }
commit:95a483d
/////////////////////////////////////////////////////////////////////////
1:         int numGenerationClauses = 0;
/////////////////////////////////////////////////////////////////////////
1:             
1:             numGenerationClauses = tableElementList.countGenerationClauses();
/////////////////////////////////////////////////////////////////////////
0: 		if ( (numCheckConstraints > 0) || (numGenerationClauses > 0) )
1: 			/* In order to check the validity of the check constraints and
1: 			 * generation clauses
/////////////////////////////////////////////////////////////////////////
1: 			FromList fromList = makeFromList( dd, tableElementList, false );
1: 			 * the check constraints and generation clauses.
0: 			if  (numCheckConstraints > 0) { tableElementList.bindAndValidateCheckConstraints(fromList); }
0: 			if  (numGenerationClauses > 0) { tableElementList.bindAndValidateGenerationClauses(fromList); }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9ed7c4d
/////////////////////////////////////////////////////////////////////////
1: 							cdn.setCollationType(schemaDescriptor.getCollationType());
commit:68db840
/////////////////////////////////////////////////////////////////////////
1: 	private void	prepConstantAction() throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 			tableElementList.genConstraintActions(false, conActions, getRelativeName(), schemaDescriptor,
commit:7dda5d5
/////////////////////////////////////////////////////////////////////////
1: 						if (cdn.getType().getTypeId().isStringTypeId()) {
0: 							cdn.getType().setCollationType(schemaDescriptor.getCollationType());
0: 							cdn.getType().setCollationDerivation(StringDataValue.COLLATION_DERIVATION_IMPLICIT);
commit:cc770d8
/////////////////////////////////////////////////////////////////////////
1: 	public void bindStatement() throws StandardException
/////////////////////////////////////////////////////////////////////////
commit:6d698f7
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.AlterTableNode
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.DB2Limit;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: 
1: import org.apache.derby.impl.sql.execute.ColumnInfo;
1: import org.apache.derby.impl.sql.execute.ConstraintConstantAction;
1: 
1: /**
1:  * A AlterTableNode represents a DDL statement that alters a table.
1:  * It contains the name of the object to be created.
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
0: public class AlterTableNode extends DDLStatementNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	// The alter table action
1: 	public	TableElementList	tableElementList = null;
0: 	public  char				lockGranularity;
1: 	public	boolean				compressTable = false;
1: 	public	boolean				sequential = false;
1: 	public	int					behavior;	// currently for drop column
1: 
1: 	public	TableDescriptor		baseTable;
1: 
1: 	protected	int						numConstraints;
1: 
1: 	private		int				changeType = UNKNOWN_TYPE;
1: 
1: 	private boolean             truncateTable = false;
1: 
1: 	// constant action arguments
1: 
1: 	protected	SchemaDescriptor			schemaDescriptor = null;
1: 	protected	ColumnInfo[] 				colInfos = null;
1: 	protected	ConstraintConstantAction[]	conActions = null;
1: 
1: 
1: 	/**
0: 	 * Initializer for a TRUNCATE TABLE
1: 	 *
0: 	 * @param objectName		The name of the table being truncated
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void init(Object objectName)
0: 		throws StandardException
1: 	{
1: 
0: 		//truncate table is not suppotted in this release
0: 		//semantics are not yet clearly defined by SQL Council yet
0: 		//truncate will be allowed only in DEBUG builds for testing purposes.
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			initAndCheck(objectName);
0: 			/* For now, this init() only called for truncate table */
0: 			truncateTable = true;
0: 			schemaDescriptor = getSchemaDescriptor();
0: 		}else
1: 		{
0: 			throw StandardException.newException(SQLState.NOT_IMPLEMENTED,
0: 												 "truncate table");
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Initializer for a AlterTableNode for COMPRESS
1: 	 *
0: 	 * @param objectName		The name of the table being altered
0: 	 * @param sequential		Whether or not the COMPRESS is SEQUENTIAL
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void init(Object objectName,
0: 					 Object sequential)
0: 		throws StandardException
1: 	{
0: 		initAndCheck(objectName);
1: 
0: 		this.sequential = ((Boolean) sequential).booleanValue();
0: 		/* For now, this init() only called for compress table */
1: 		compressTable = true;
1: 
0: 		schemaDescriptor = getSchemaDescriptor();
1: 	}
1: 
1: 	/**
0: 	 * Initializer for a AlterTableNode
1: 	 *
0: 	 * @param objectName		The name of the table being altered
0: 	 * @param tableElementList	The alter table action
0: 	 * @param lockGranularity	The new lock granularity, if any
0: 	 * @param changeType		ADD_TYPE or DROP_TYPE
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void init(
0: 							Object objectName,
0: 							Object tableElementList,
0: 							Object lockGranularity,
0: 							Object changeType,
0: 							Object behavior,
0: 							Object sequential )
0: 		throws StandardException
1: 	{
0: 		initAndCheck(objectName);
0: 		this.tableElementList = (TableElementList) tableElementList;
0: 		this.lockGranularity = ((Character) lockGranularity).charValue();
1: 
0: 		int[]	ct = (int[]) changeType, bh = (int[]) behavior;
0: 		this.changeType = ct[0];
0: 		this.behavior = bh[0];
0: 		boolean[]	seq = (boolean[]) sequential;
0: 		this.sequential = seq[0];
0: 		switch ( this.changeType )
1: 		{
0: 		    case ADD_TYPE:
1: 		    case DROP_TYPE:
1: 		    case MODIFY_TYPE:
1: 		    case LOCKING_TYPE:
1: 
0: 				break;
1: 
1: 		    default:
1: 
0: 				throw StandardException.newException(SQLState.NOT_IMPLEMENTED);
1: 		}
1: 
0: 		schemaDescriptor = getSchemaDescriptor();
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return super.toString() +
0: 				"objectName: " + "\n" + getObjectName() + "\n" +
0: 				"tableElementList: " + "\n" + tableElementList + "\n" +
0: 				"lockGranularity: " + "\n" + lockGranularity + "\n" +
0: 				"compressTable: " + "\n" + compressTable + "\n" +
0: 				"sequential: " + "\n" + sequential + "\n" +
0: 				"truncateTable: " + "\n" + truncateTable + "\n";
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
0: 	public String statementToString()
1: 	{
1: 		if(truncateTable)
1: 			return "TRUNCATE TABLE";
1: 		else
1: 			return "ALTER TABLE";
1: 	}
1: 
1: 	public	int	getChangeType() { return changeType; }
1: 
1: 	// We inherit the generate() method from DDLStatementNode.
1: 
1: 	/**
1: 	 * Bind this AlterTableNode.  This means doing any static error
1: 	 * checking that can be done before actually creating the table.
1: 	 * For example, verifying that the user is not trying to add a 
1: 	 * non-nullable column.
1: 	 *
0: 	 * @return	The bound query tree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public QueryTreeNode bind() throws StandardException
1: 	{
1: 		DataDictionary	dd = getDataDictionary();
1: 		int					numCheckConstraints = 0;
1: 		int numBackingIndexes = 0;
1: 
1: 		/*
1: 		** Get the table descriptor.  Checks the schema
1: 		** and the table.
1: 		*/
0: 		baseTable = getTableDescriptor();
1: 		//throw an exception if user is attempting to alter a temporary table
1: 		if (baseTable.getTableType() == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
1: 		{
1: 				throw StandardException.newException(SQLState.LANG_NOT_ALLOWED_FOR_DECLARED_GLOBAL_TEMP_TABLE);
1: 		}
1: 
1: 		/* Statement is dependent on the TableDescriptor */
1: 		getCompilerContext().createDependency(baseTable);
1: 
1: 		if (tableElementList != null)
1: 		{
1: 			tableElementList.validate(this, dd, baseTable);
1: 
1: 			/* Only 1012 columns allowed per table */
0: 			if ((tableElementList.countNumberOfColumns() + baseTable.getNumberOfColumns()) > DB2Limit.DB2_MAX_COLUMNS_IN_TABLE)
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_TOO_MANY_COLUMNS_IN_TABLE_OR_VIEW,
1: 					String.valueOf(tableElementList.countNumberOfColumns() + baseTable.getNumberOfColumns()),
1: 					getRelativeName(),
0: 					String.valueOf(DB2Limit.DB2_MAX_COLUMNS_IN_TABLE));
1: 			}
1: 			/* Number of backing indexes in the alter table statment */
1: 			numBackingIndexes = tableElementList.countConstraints(DataDictionary.PRIMARYKEY_CONSTRAINT) +
1: 									tableElementList.countConstraints(DataDictionary.FOREIGNKEY_CONSTRAINT) +
1: 									tableElementList.countConstraints(DataDictionary.UNIQUE_CONSTRAINT);
1: 			/* Check the validity of all check constraints */
1: 			numCheckConstraints = tableElementList.countConstraints(
1: 									DataDictionary.CHECK_CONSTRAINT);
1: 		}
1: 
1: 		//If the sum of backing indexes for constraints in alter table statement and total number of indexes on the table
1: 		//so far is more than 32767, then we need to throw an exception 
0: 		if ((numBackingIndexes + baseTable.getTotalNumberOfIndexes()) > DB2Limit.DB2_MAX_INDEXES_ON_TABLE)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_INDEXES_ON_TABLE, 
1: 				String.valueOf(numBackingIndexes + baseTable.getTotalNumberOfIndexes()),
1: 				getRelativeName(),
0: 				String.valueOf(DB2Limit.DB2_MAX_INDEXES_ON_TABLE));
1: 		}
1: 
0: 		if (numCheckConstraints > 0)
1: 		{
0: 			/* In order to check the validity of the check constraints
1: 			 * we must goober up a FromList containing a single table, 
1: 			 * the table being alter, with an RCL containing the existing and
1: 			 * new columns and their types.  This will allow us to
1: 			 * bind the constraint definition trees against that
1: 			 * FromList.  When doing this, we verify that there are
1: 			 * no nodes which can return non-deterministic results.
1: 			 */
0: 			FromList fromList = (FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager());
0: 			FromBaseTable table = (FromBaseTable)
0: 									getNodeFactory().getNode(
0: 										C_NodeTypes.FROM_BASE_TABLE,
0: 										getObjectName(),
0: 										null,
0: 										null,
0: 										null,
0: 										getContextManager());
0: 			fromList.addFromTable(table);
0: 			fromList.bindTables(dd,
0: 							(FromList) getNodeFactory().getNode(
0: 								C_NodeTypes.FROM_LIST,
0: 								getNodeFactory().doJoinOrderOptimization(),
0: 								getContextManager()));
0: 			tableElementList.appendNewColumnsToRCL(table);
1: 
1: 			/* Now that we've finally goobered stuff up, bind and validate
0: 			 * the check constraints.
1: 			 */
0: 			tableElementList.bindAndValidateCheckConstraints(fromList);
1: 
1: 		}
1: 
1: 		/* Unlike most other DDL, we will make this ALTER TABLE statement
1: 		 * dependent on the table being altered.  In general, we try to
1: 		 * avoid this for DDL, but we are already requiring the table to
1: 		 * exist at bind time (not required for create index) and we don't
1: 		 * want the column ids to change out from under us before
1: 		 * execution.
1: 		 */
1: 		getCompilerContext().createDependency(baseTable);
1: 
0: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1: 	 *
1: 	 * @return	true if references SESSION schema tables, else false
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean referencesSessionSchema()
0: 		throws StandardException
1: 	{
1: 		//If alter table is on a SESSION schema table, then return true. 
1: 		return isSessionSchema(baseTable.getSchemaName());
1: 	}
1: 
1: 	/**
1: 	 * Create the Constant information that will drive the guts of Execution.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public ConstantAction	makeConstantAction() throws StandardException
1: 	{
1: 		prepConstantAction();
1: 
1: 		return	getGenericConstantActionFactory().getAlterTableConstantAction(schemaDescriptor,
1: 											 getRelativeName(),
1: 											 baseTable.getUUID(),
1: 											 baseTable.getHeapConglomerateId(),
1: 											 TableDescriptor.BASE_TABLE_TYPE,
1: 											 colInfos,
1: 											 conActions,
0: 											 null, null, null, null, null, null,
1: 											 lockGranularity,
1: 											 compressTable,
1: 											 behavior,
1:         								     sequential,
0:  										     truncateTable);
1: 	}
1: 
1: 	/**
1: 	  *	Generate arguments to constant action. Called by makeConstantAction() in this class and in
1: 	  *	our subclass RepAlterTableNode.
1: 	  *
1: 	  *
1: 	  * @exception StandardException		Thrown on failure
1: 	  */
0: 	public void	prepConstantAction() throws StandardException
1: 	{
1: 		if (tableElementList != null)
1: 		{
1: 			genColumnInfo();
1: 		}
1: 
1: 		/* If we've seen a constraint, then build a constraint list */
1: 
1: 		if (numConstraints > 0)
1: 		{
1: 			conActions = new ConstraintConstantAction[numConstraints];
1: 
0: 			tableElementList.genConstraintActions(conActions, getRelativeName(), schemaDescriptor,
1: 												  getDataDictionary());
1: 		}
1: 	}
1: 	  
1: 	/**
1: 	  *	Generate the ColumnInfo argument for the constant action. Return the number of constraints.
1: 	  *
0: 	  *	@return	number of constraints
1: 	  */
1: 	public	void	genColumnInfo()
1: 	{
1: 		// for each column, stuff system.column
1: 		colInfos = new ColumnInfo[tableElementList.countNumberOfColumns()]; 
1: 
1: 	    numConstraints = tableElementList.genColumnInfos(colInfos);
1: 	}
1: 
1: 
1: 	/*
1: 	 * class interface
1: 	 */
1: }
1: 
1: 
1: 
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
1: 			if ((tableElementList.countNumberOfColumns() + baseTable.getNumberOfColumns()) > Limits.DB2_MAX_COLUMNS_IN_TABLE)
1: 					String.valueOf(Limits.DB2_MAX_COLUMNS_IN_TABLE));
/////////////////////////////////////////////////////////////////////////
1: 		if ((numBackingIndexes + baseTable.getTotalNumberOfIndexes()) > Limits.DB2_MAX_INDEXES_ON_TABLE)
1: 				String.valueOf(Limits.DB2_MAX_INDEXES_ON_TABLE));
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.DB2Limit;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: 
0: import org.apache.derby.impl.sql.execute.ColumnInfo;
0: import org.apache.derby.impl.sql.execute.ConstraintConstantAction;
0: 
0: /**
0:  * A AlterTableNode represents a DDL statement that alters a table.
0:  * It contains the name of the object to be created.
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public class AlterTableNode extends DDLStatementNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	// The alter table action
0: 	public	TableElementList	tableElementList = null;
0: 	public  char				lockGranularity;
0: 	public	boolean				compressTable = false;
0: 	public	boolean				sequential = false;
0: 	public	int					behavior;	// currently for drop column
0: 
0: 	public	TableDescriptor		baseTable;
0: 
0: 	protected	int						numConstraints;
0: 
0: 	private		int				changeType = UNKNOWN_TYPE;
0: 
0: 	private boolean             truncateTable = false;
0: 
0: 	// constant action arguments
0: 
0: 	protected	SchemaDescriptor			schemaDescriptor = null;
0: 	protected	ColumnInfo[] 				colInfos = null;
0: 	protected	ConstraintConstantAction[]	conActions = null;
0: 
0: 
0: 	/**
0: 	 * Initializer for a TRUNCATE TABLE
0: 	 *
0: 	 * @param objectName		The name of the table being truncated
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void init(Object objectName)
0: 		throws StandardException
0: 	{
0: 
0: 		//truncate table is not suppotted in this release
0: 		//semantics are not yet clearly defined by SQL Council yet
0: 		//truncate will be allowed only in DEBUG builds for testing purposes.
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			initAndCheck(objectName);
0: 			/* For now, this init() only called for truncate table */
0: 			truncateTable = true;
0: 			schemaDescriptor = getSchemaDescriptor();
0: 		}else
0: 		{
0: 			throw StandardException.newException(SQLState.NOT_IMPLEMENTED,
0: 												 "truncate table");
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Initializer for a AlterTableNode for COMPRESS
0: 	 *
0: 	 * @param objectName		The name of the table being altered
0: 	 * @param sequential		Whether or not the COMPRESS is SEQUENTIAL
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void init(Object objectName,
0: 					 Object sequential)
0: 		throws StandardException
0: 	{
0: 		initAndCheck(objectName);
0: 
0: 		this.sequential = ((Boolean) sequential).booleanValue();
0: 		/* For now, this init() only called for compress table */
0: 		compressTable = true;
0: 
0: 		schemaDescriptor = getSchemaDescriptor();
0: 	}
0: 
0: 	/**
0: 	 * Initializer for a AlterTableNode
0: 	 *
0: 	 * @param objectName		The name of the table being altered
0: 	 * @param tableElementList	The alter table action
0: 	 * @param lockGranularity	The new lock granularity, if any
0: 	 * @param changeType		ADD_TYPE or DROP_TYPE
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void init(
0: 							Object objectName,
0: 							Object tableElementList,
0: 							Object lockGranularity,
0: 							Object changeType,
0: 							Object behavior,
0: 							Object sequential )
0: 		throws StandardException
0: 	{
0: 		initAndCheck(objectName);
0: 		this.tableElementList = (TableElementList) tableElementList;
0: 		this.lockGranularity = ((Character) lockGranularity).charValue();
0: 
0: 		int[]	ct = (int[]) changeType, bh = (int[]) behavior;
0: 		this.changeType = ct[0];
0: 		this.behavior = bh[0];
0: 		boolean[]	seq = (boolean[]) sequential;
0: 		this.sequential = seq[0];
0: 		switch ( this.changeType )
0: 		{
0: 		    case ADD_TYPE:
0: 		    case DROP_TYPE:
0: 		    case MODIFY_TYPE:
0: 		    case LOCKING_TYPE:
0: 
0: 				break;
0: 
0: 		    default:
0: 
0: 				throw StandardException.newException(SQLState.NOT_IMPLEMENTED);
0: 		}
0: 
0: 		schemaDescriptor = getSchemaDescriptor();
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return super.toString() +
0: 				"objectName: " + "\n" + getObjectName() + "\n" +
0: 				"tableElementList: " + "\n" + tableElementList + "\n" +
0: 				"lockGranularity: " + "\n" + lockGranularity + "\n" +
0: 				"compressTable: " + "\n" + compressTable + "\n" +
0: 				"sequential: " + "\n" + sequential + "\n" +
0: 				"truncateTable: " + "\n" + truncateTable + "\n";
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	public String statementToString()
0: 	{
0: 		if(truncateTable)
0: 			return "TRUNCATE TABLE";
0: 		else
0: 			return "ALTER TABLE";
0: 	}
0: 
0: 	public	int	getChangeType() { return changeType; }
0: 
0: 	// We inherit the generate() method from DDLStatementNode.
0: 
0: 	/**
0: 	 * Bind this AlterTableNode.  This means doing any static error
0: 	 * checking that can be done before actually creating the table.
0: 	 * For example, verifying that the user is not trying to add a 
0: 	 * non-nullable column.
0: 	 *
0: 	 * @return	The bound query tree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public QueryTreeNode bind() throws StandardException
0: 	{
0: 		DataDictionary	dd = getDataDictionary();
0: 		int					numCheckConstraints = 0;
0: 		int numBackingIndexes = 0;
0: 
0: 		/*
0: 		** Get the table descriptor.  Checks the schema
0: 		** and the table.
0: 		*/
0: 		baseTable = getTableDescriptor();
0: 		//throw an exception if user is attempting to alter a temporary table
0: 		if (baseTable.getTableType() == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
0: 		{
0: 				throw StandardException.newException(SQLState.LANG_NOT_ALLOWED_FOR_DECLARED_GLOBAL_TEMP_TABLE);
0: 		}
0: 
0: 		/* Statement is dependent on the TableDescriptor */
0: 		getCompilerContext().createDependency(baseTable);
0: 
0: 		if (tableElementList != null)
0: 		{
0: 			tableElementList.validate(this, dd, baseTable);
0: 
0: 			/* Only 1012 columns allowed per table */
0: 			if ((tableElementList.countNumberOfColumns() + baseTable.getNumberOfColumns()) > DB2Limit.DB2_MAX_COLUMNS_IN_TABLE)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_TOO_MANY_COLUMNS_IN_TABLE_OR_VIEW,
0: 					String.valueOf(tableElementList.countNumberOfColumns() + baseTable.getNumberOfColumns()),
0: 					getRelativeName(),
0: 					String.valueOf(DB2Limit.DB2_MAX_COLUMNS_IN_TABLE));
0: 			}
0: 			/* Number of backing indexes in the alter table statment */
0: 			numBackingIndexes = tableElementList.countConstraints(DataDictionary.PRIMARYKEY_CONSTRAINT) +
0: 									tableElementList.countConstraints(DataDictionary.FOREIGNKEY_CONSTRAINT) +
0: 									tableElementList.countConstraints(DataDictionary.UNIQUE_CONSTRAINT);
0: 			/* Check the validity of all check constraints */
0: 			numCheckConstraints = tableElementList.countConstraints(
0: 									DataDictionary.CHECK_CONSTRAINT);
0: 		}
0: 
0: 		//If the sum of backing indexes for constraints in alter table statement and total number of indexes on the table
0: 		//so far is more than 32767, then we need to throw an exception 
0: 		if ((numBackingIndexes + baseTable.getTotalNumberOfIndexes()) > DB2Limit.DB2_MAX_INDEXES_ON_TABLE)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_INDEXES_ON_TABLE, 
0: 				String.valueOf(numBackingIndexes + baseTable.getTotalNumberOfIndexes()),
0: 				getRelativeName(),
0: 				String.valueOf(DB2Limit.DB2_MAX_INDEXES_ON_TABLE));
0: 		}
0: 
0: 		if (numCheckConstraints > 0)
0: 		{
0: 			/* In order to check the validity of the check constraints
0: 			 * we must goober up a FromList containing a single table, 
0: 			 * the table being alter, with an RCL containing the existing and
0: 			 * new columns and their types.  This will allow us to
0: 			 * bind the constraint definition trees against that
0: 			 * FromList.  When doing this, we verify that there are
0: 			 * no nodes which can return non-deterministic results.
0: 			 */
0: 			FromList fromList = (FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager());
0: 			FromBaseTable table = (FromBaseTable)
0: 									getNodeFactory().getNode(
0: 										C_NodeTypes.FROM_BASE_TABLE,
0: 										getObjectName(),
0: 										null,
0: 										null,
0: 										null,
0: 										getContextManager());
0: 			fromList.addFromTable(table);
0: 			fromList.bindTables(dd,
0: 							(FromList) getNodeFactory().getNode(
0: 								C_NodeTypes.FROM_LIST,
0: 								getNodeFactory().doJoinOrderOptimization(),
0: 								getContextManager()));
0: 			tableElementList.appendNewColumnsToRCL(table);
0: 
0: 			/* Now that we've finally goobered stuff up, bind and validate
0: 			 * the check constraints.
0: 			 */
0: 			tableElementList.bindAndValidateCheckConstraints(fromList);
0: 
0: 		}
0: 
0: 		/* Unlike most other DDL, we will make this ALTER TABLE statement
0: 		 * dependent on the table being altered.  In general, we try to
0: 		 * avoid this for DDL, but we are already requiring the table to
0: 		 * exist at bind time (not required for create index) and we don't
0: 		 * want the column ids to change out from under us before
0: 		 * execution.
0: 		 */
0: 		getCompilerContext().createDependency(baseTable);
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
0: 	 *
0: 	 * @return	true if references SESSION schema tables, else false
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean referencesSessionSchema()
0: 		throws StandardException
0: 	{
0: 		//If alter table is on a SESSION schema table, then return true. 
0: 		return isSessionSchema(baseTable.getSchemaName());
0: 	}
0: 
0: 	/**
0: 	 * Create the Constant information that will drive the guts of Execution.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public ConstantAction	makeConstantAction() throws StandardException
0: 	{
0: 		prepConstantAction();
0: 
0: 		return	getGenericConstantActionFactory().getAlterTableConstantAction(schemaDescriptor,
0: 											 getRelativeName(),
0: 											 baseTable.getUUID(),
0: 											 baseTable.getHeapConglomerateId(),
0: 											 TableDescriptor.BASE_TABLE_TYPE,
0: 											 colInfos,
0: 											 conActions,
0: 											 null, null, null, null, null, null,
0: 											 lockGranularity,
0: 											 compressTable,
0: 											 behavior,
0:         								     sequential,
0:  										     truncateTable);
0: 	}
0: 
0: 	/**
0: 	  *	Generate arguments to constant action. Called by makeConstantAction() in this class and in
0: 	  *	our subclass RepAlterTableNode.
0: 	  *
0: 	  *
0: 	  * @exception StandardException		Thrown on failure
0: 	  */
0: 	public void	prepConstantAction() throws StandardException
0: 	{
0: 		if (tableElementList != null)
0: 		{
0: 			genColumnInfo();
0: 		}
0: 
0: 		/* If we've seen a constraint, then build a constraint list */
0: 
0: 		if (numConstraints > 0)
0: 		{
0: 			conActions = new ConstraintConstantAction[numConstraints];
0: 
0: 			tableElementList.genConstraintActions(conActions, getRelativeName(), schemaDescriptor,
0: 												  getDataDictionary());
0: 		}
0: 	}
0: 	  
0: 	/**
0: 	  *	Generate the ColumnInfo argument for the constant action. Return the number of constraints.
0: 	  *
0: 	  *	@return	number of constraints
0: 	  */
0: 	public	void	genColumnInfo()
0: 	{
0: 		// for each column, stuff system.column
0: 		colInfos = new ColumnInfo[tableElementList.countNumberOfColumns()]; 
0: 
0: 	    numConstraints = tableElementList.genColumnInfos(colInfos);
0: 	}
0: 
0: 
0: 	/*
0: 	 * class interface
0: 	 */
0: }
0: 
0: 
0: 
0: 
============================================================================