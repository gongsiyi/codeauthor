1:eac0369: /*
1:eac0369: 
1:345de35:    Derby - Class org.apache.derby.catalog.types.TypeDescriptorImpl
1:345de35: 
1:2f36947:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2f36947:    contributor license agreements.  See the NOTICE file distributed with
1:2f36947:    this work for additional information regarding copyright ownership.
1:2f36947:    The ASF licenses this file to You under the Apache License, Version 2.0
1:2f36947:    (the "License"); you may not use this file except in compliance with
1:2f36947:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.catalog.types;
1:2d3677b: 
1:fbb0d4f: import java.io.IOException;
1:fbb0d4f: import java.io.ObjectInput;
1:fbb0d4f: import java.io.ObjectOutput;
1:fbb0d4f: import java.sql.Types;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.TypeDescriptor;
1:e33b8d8: import org.apache.derby.iapi.reference.JDBC40Translation;
1:fbb0d4f: import org.apache.derby.iapi.services.io.Formatable;
1:fbb0d4f: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:96a630c: import org.apache.derby.iapi.types.StringDataValue;
1:e33b8d8: 
1:eac0369: public class TypeDescriptorImpl implements TypeDescriptor, Formatable
1:eac0369: {
1:eac0369: 	/********************************************************
1:eac0369: 	**
1:eac0369: 	**	This class implements Formatable. That means that it
1:eac0369: 	**	can write itself to and from a formatted stream. If
1:eac0369: 	**	you add more fields to this class, make sure that you
1:eac0369: 	**	also write/read them with the writeExternal()/readExternal()
1:eac0369: 	**	methods.
1:eac0369: 	**
1:eac0369: 	**	If, inbetween releases, you add more fields to this class,
1:eac0369: 	**	then you should bump the version number emitted by the getTypeFormatId()
1:eac0369: 	**	method.
1:eac0369: 	**
1:eac0369: 	********************************************************/
1:eac0369: 
1:eac0369: 	private BaseTypeIdImpl		typeId;
1:eac0369: 	private int						precision;
1:eac0369: 	private int						scale;
1:eac0369: 	private boolean					isNullable;
1:eac0369: 	private int						maximumWidth;
1:96a630c: 	/** @see TypeDescriptor#getCollationType() */
1:f19b703: 	private int	collationType = StringDataValue.COLLATION_TYPE_UCS_BASIC;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Public niladic constructor. Needed for Formatable interface to work.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369:     public	TypeDescriptorImpl() {}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor for use with numeric types
1:eac0369: 	 *
1:eac0369: 	 * @param typeId	The typeId of the type being described
1:eac0369: 	 * @param precision	The number of decimal digits.
1:eac0369: 	 * @param scale		The number of digits after the decimal point.
1:eac0369: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1:eac0369: 	 *			it definitely cannot contain NULL.
1:eac0369: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1:eac0369: 	 */
1:eac0369: 	public TypeDescriptorImpl(
1:eac0369: 		BaseTypeIdImpl typeId,
1:eac0369: 		int precision,
1:eac0369: 		int scale,
1:eac0369: 		boolean isNullable,
1:eac0369: 		int maximumWidth)
1:eac0369: 	{
1:eac0369: 		this.typeId = typeId;
1:eac0369: 		this.precision = precision;
1:eac0369: 		this.scale = scale;
1:eac0369: 		this.isNullable = isNullable;
1:eac0369: 		this.maximumWidth = maximumWidth;
1:eac0369: 	}
1:506f4c8: 
1:4aef9b0: 	/**
1:68f9f47: 	 * Constructor to use when the caller doesn't know if it is requesting
1:68f9f47: 	 * numeric or no-numeric DTD. For instance, when dealing with MAX/MIN 
1:68f9f47: 	 * aggregrate operators, AggregateNode.bindExpression could be dealing
1:68f9f47: 	 * with a character string operand or a numeric operand. The result of
1:68f9f47: 	 * MAX/MIN will depend on the type of it's operand. And hence when this
1:68f9f47: 	 * constructor gets called by AggregateNode.bindExpression, we don't know 
1:68f9f47: 	 * what type we are constructing and hence this constructor supports 
1:68f9f47: 	 * arguments for both numeric and non-numeric types.
1:f90d449: 	 *
1:f90d449: 	 * @param typeId	The typeId of the type being described
1:f90d449: 	 * @param precision	The number of decimal digits.
1:f90d449: 	 * @param scale		The number of digits after the decimal point.
1:f90d449: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1:f90d449: 	 *			it definitely cannot contain NULL.
1:f90d449: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1:f90d449: 	 * @param collationType The collation type of a string data type
1:eac0369: 	 */
1:f90d449: 	public TypeDescriptorImpl(
1:f90d449: 		BaseTypeIdImpl typeId,
1:f90d449: 		int precision,
1:f90d449: 		int scale,
1:f90d449: 		boolean isNullable,
1:f90d449: 		int maximumWidth,
1:c0c33cd: 		int collationType)
1:f90d449: 	{
1:f90d449: 		this.typeId = typeId;
1:f90d449: 		this.precision = precision;
1:f90d449: 		this.scale = scale;
1:f90d449: 		this.isNullable = isNullable;
1:f90d449: 		this.maximumWidth = maximumWidth;
1:f90d449: 		this.collationType = collationType;
1:f90d449: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor for use with non-numeric types
1:eac0369: 	 *
1:eac0369: 	 * @param typeId	The typeId of the type being described
1:eac0369: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1:eac0369: 	 *			it definitely cannot contain NULL.
1:eac0369: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1:eac0369: 	 */
1:eac0369: 	public TypeDescriptorImpl(
1:eac0369: 		BaseTypeIdImpl typeId,
1:eac0369: 		boolean isNullable,
1:eac0369: 		int maximumWidth)
1:eac0369: 	{
1:eac0369: 		this.typeId = typeId;
1:eac0369: 		this.isNullable = isNullable;
1:eac0369: 		this.maximumWidth = maximumWidth;
1:eac0369: 
1:e33b8d8:         this.scale = JDBC40Translation.UNKNOWN_SCALE;
1:e33b8d8:         this.precision = JDBC40Translation.UNKNOWN_PRECISION;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor for internal uses only.  
1:eac0369: 	 * (This is useful when the precision and scale are potentially wider than
1:eac0369: 	 * those in the source, like when determining the dominant data type.)
1:eac0369: 	 *
1:eac0369: 	 * @param source	The DTSI to copy
1:eac0369: 	 * @param precision	The number of decimal digits.
1:eac0369: 	 * @param scale		The number of digits after the decimal point.
1:eac0369: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1:eac0369: 	 *			it definitely cannot contain NULL.
1:eac0369: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1:eac0369: 	 */
1:eac0369: 	public TypeDescriptorImpl(
1:eac0369: 		TypeDescriptorImpl source, 
1:eac0369: 		int precision,
1:eac0369: 		int scale,
1:eac0369: 		boolean isNullable,
1:eac0369: 		int maximumWidth)
1:eac0369: 	{
1:eac0369: 		this.typeId = source.typeId;
1:eac0369: 		this.precision = precision;
1:eac0369: 		this.scale = scale;
1:eac0369: 		this.isNullable = isNullable;
1:eac0369: 		this.maximumWidth = maximumWidth;
1:eac0369: 	}
1:eac0369: 
1:3841b98: 	public TypeDescriptorImpl(
1:3841b98: 			TypeDescriptorImpl source, 
1:3841b98: 			int precision,
1:3841b98: 			int scale,
1:3841b98: 			boolean isNullable,
1:3841b98: 			int maximumWidth,
1:c0c33cd: 			int collationType)
1:3841b98: 		{
1:3841b98: 			this.typeId = source.typeId;
1:3841b98: 			this.precision = precision;
1:3841b98: 			this.scale = scale;
1:3841b98: 			this.isNullable = isNullable;
1:3841b98: 			this.maximumWidth = maximumWidth;
1:3841b98: 			this.collationType = collationType;
1:3841b98: 		}
1:eac0369: 	
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Constructor for internal uses only
1:eac0369: 	 *
1:eac0369: 	 * @param source	The DTSI to copy
1:eac0369: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1:eac0369: 	 *			it definitely cannot contain NULL.
1:eac0369: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1:eac0369: 	 */
1:eac0369: 	public TypeDescriptorImpl(
1:eac0369: 		TypeDescriptorImpl source,
1:eac0369: 		boolean isNullable,
1:eac0369: 		int maximumWidth)
1:eac0369: 	{
1:eac0369: 		this.typeId = source.typeId;
1:eac0369: 		this.precision = source.precision;
1:eac0369: 		this.scale = source.scale;
1:eac0369: 		this.isNullable = isNullable;
1:eac0369: 		this.maximumWidth = maximumWidth;
1:eac0369: 	}
1:eac0369: 
1:57465ef:     /** copy an array of type descriptors */
1:57465ef:     public  static TypeDescriptor[]    copyTypeDescriptors( TypeDescriptor[] original )
1:57465ef:     {
1:57465ef:         return (original == null) ? null : (TypeDescriptor[]) original.clone();
1:57465ef:     }
1:57465ef:     
1:eac0369: 	/**
1:eac0369: 	 * @see TypeDescriptor#getMaximumWidth
1:eac0369: 	 */
1:eac0369: 	public int	getMaximumWidth()
1:eac0369: 	{
1:eac0369: 		return maximumWidth;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:09c8a0d: 	 * Return the length of this type in bytes.  Note that
1:09c8a0d: 	 * while the JDBC API _does_ define a need for
1:09c8a0d: 	 * returning length in bytes of a type, it doesn't
1:09c8a0d: 	 * state clearly what that means for the various
1:09c8a0d: 	 * types.  We assume therefore that the values here
1:09c8a0d: 	 * are meant to match those specified by the ODBC
1:09c8a0d: 	 * specification (esp. since ODBC clients are more
1:09c8a0d: 	 * likely to need this value than a Java client).
1:09c8a0d: 	 * The ODBC spec that defines the values we use here
1:09c8a0d: 	 * can be found at the following link:
1:eac0369: 	 * 
1:09c8a0d: 	 * http://msdn.microsoft.com/library/default.asp?url=/library/
1:09c8a0d: 	 * en-us/odbc/htm/odbctransfer_octet_length.asp
2:ec2b8d1: 	 *
1:09c8a0d: 	 * @see TypeDescriptor#getMaximumWidthInBytes
1:eac0369: 	 */
1:09c8a0d: 	public int	getMaximumWidthInBytes()
3:7752cf6: 	{
1:09c8a0d: 		switch (typeId.getJDBCTypeId()) {
1:eac0369: 
1:09c8a0d: 			case Types.BIT:
1:09c8a0d: 			case Types.TINYINT:
1:09c8a0d: 			case Types.SMALLINT:
1:09c8a0d: 			case Types.INTEGER:
1:09c8a0d: 			case Types.REAL:
1:09c8a0d: 			case Types.DOUBLE:
1:09c8a0d: 			case Types.FLOAT:
1:09c8a0d: 			case Types.BINARY:
1:09c8a0d: 			case Types.VARBINARY:
1:09c8a0d: 			case Types.LONGVARBINARY:
1:09c8a0d: 			case Types.BLOB:
1:f90d449: 
1:09c8a0d: 				// For all of these, just take the maximumWidth,
1:09c8a0d: 				// since that already holds the length in bytes.
1:09c8a0d: 				return maximumWidth;
1:3841b98: 
1:09c8a0d: 			// For BIGINT values, ODBC spec says to return
1:09c8a0d: 			// 40 because max length of a C/C++ BIGINT in
1:09c8a0d: 			// string form is 20 and we assume the client
1:09c8a0d: 			// character set is Unicode (spec says to
1:09c8a0d: 			// multiply by 2 for unicode).
1:09c8a0d: 			case Types.BIGINT:
1:09c8a0d: 				return 40;
1:3841b98: 
1:09c8a0d: 			// ODBC spec explicitly declares what the lengths
1:09c8a0d: 			// should be for datetime values, based on the
1:09c8a0d: 			// declared fields of SQL_DATE_STRUCT, SQL_TIME_STRUCT,
1:09c8a0d: 			// and SQL_TIMESTAMP_STRUCT.  So we just use those
1:09c8a0d: 			// values.
1:09c8a0d: 			case Types.DATE:
1:09c8a0d: 			case Types.TIME:
1:09c8a0d: 				return 6;
1:96a630c: 
1:09c8a0d: 			case Types.TIMESTAMP:
1:09c8a0d: 				return 16;
1:7752cf6: 
1:09c8a0d: 			// ODBC spec says that for numeric/decimal values,
1:09c8a0d: 			// we should use max number of digits plus 2
1:09c8a0d: 			// (for sign and decimal point), since that's
1:09c8a0d: 			// the length of a decimal value in string form.
1:09c8a0d: 			// And since we assume client character set
1:09c8a0d: 			// is unicode, we have to multiply by 2 to
1:09c8a0d: 			// get the number of bytes.
1:09c8a0d: 			case Types.NUMERIC:
1:09c8a0d: 			case Types.DECIMAL:
1:09c8a0d: 				return 2 * (precision + 2);
1:7752cf6: 
1:09c8a0d: 			// ODBC spec says to use length in chars
1:09c8a0d: 			// for character types, times two if we
1:09c8a0d: 			// assume client character set is unicode.
1:09c8a0d: 			// If 2 * character length is greater than
1:09c8a0d: 			// variable type (in this case, integer),
1:09c8a0d: 			// then we return the max value for an
1:09c8a0d: 			// integer.
1:09c8a0d: 			case Types.CHAR:
1:09c8a0d: 			case Types.VARCHAR:
1:09c8a0d: 			case Types.LONGVARCHAR:
1:09c8a0d: 			case Types.CLOB:
1:09c8a0d: 				if ((maximumWidth > 0) && (2 * maximumWidth < 0))
1:09c8a0d: 				// integer overflow; return max integer possible.
1:09c8a0d: 					return Integer.MAX_VALUE;
1:09c8a0d: 				else
1:09c8a0d: 					return 2 * maximumWidth;
1:7752cf6: 
1:ff8ae29: 			// ODBC does not define a BOOLEAN data type.
1:ff8ae29:             // However, 1 seems to me like a reasonable byte length for a BOOLEAN.
1:ff8ae29:             case Types.BOOLEAN: return 1;
1:ff8ae29:                 
1:09c8a0d: 			case Types.ARRAY:
1:09c8a0d: 			case Types.DISTINCT:
1:09c8a0d: 			case Types.NULL:
1:09c8a0d: 			case Types.OTHER:
1:09c8a0d: 			case Types.REF:
1:09c8a0d: 			case Types.STRUCT:
1:09c8a0d: 			case Types.JAVA_OBJECT:
1:09c8a0d: 			default:
1:7752cf6: 
1:09c8a0d: 				// For these we don't know, so return the "don't-know"
1:09c8a0d: 				// indicator.
1:09c8a0d: 				return -1;
1:7752cf6: 
1:7752cf6: 		}
1:ec2b8d1: 
1:7752cf6: 	}
12:09c8a0d: 
1:eac0369: 	/**
1:2d3677b: 	 * Report whether this type is a string type.
1:2d3677b: 	 */
1:2d3677b: 	public boolean  isStringType()
1:2d3677b: 	{
1:2d3677b: 		switch (typeId.getJDBCTypeId())
1:2d3677b:         {
1:2d3677b: 			case Types.CHAR:
1:2d3677b: 			case Types.VARCHAR:
1:2d3677b: 			case Types.LONGVARCHAR:
1:2d3677b: 			case Types.CLOB:
1:2d3677b:                 return true;
1:2d3677b:                 
1:2d3677b: 			default:
1:2d3677b: 				return false;
1:2d3677b: 		}
1:2d3677b: 	}
1:2d3677b: 
1:2d3677b: 	/**
1:eac0369: 	 * Get the jdbc type id for this type.  JDBC type can be
1:eac0369: 	 * found in java.sql.Types. 
1:eac0369: 	 *
1:eac0369: 	 * @return	a jdbc type, e.g. java.sql.Types.DECIMAL 
1:eac0369: 	 *
1:eac0369: 	 * @see Types
1:eac0369: 	 */
1:eac0369: 	public int getJDBCTypeId()
1:eac0369: 	{
1:eac0369: 		return typeId.getJDBCTypeId();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the name of this datatype.
1:eac0369: 	 * 
1:eac0369: 	 *
1:eac0369: 	 *  @return	the name of this datatype
1:eac0369: 	 */
1:eac0369: 	public	String		getTypeName()
1:eac0369: 	{
1:eac0369: 		return typeId.getSQLTypeName();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the number of decimal digits for the datatype, if applicable.
1:eac0369: 	 *
1:eac0369: 	 * @return	The number of decimal digits for the datatype.  Returns
1:eac0369: 	 *		zero for non-numeric datatypes.
1:eac0369: 	 */
1:eac0369: 	public int	getPrecision()
1:eac0369: 	{
1:eac0369: 		return precision;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the number of digits to the right of the decimal for
1:eac0369: 	 * the datatype, if applicable.
1:eac0369: 	 *
1:eac0369: 	 * @return	The number of digits to the right of the decimal for
1:eac0369: 	 *		the datatype.  Returns zero for non-numeric datatypes.
1:eac0369: 	 */
1:eac0369: 	public int	getScale()
1:eac0369: 	{
1:eac0369: 		return scale;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns TRUE if the datatype can contain NULL, FALSE if not.
1:eac0369: 	 * JDBC supports a return value meaning "nullability unknown" -
1:eac0369: 	 * I assume we will never have columns where the nullability is unknown.
1:eac0369: 	 *
1:eac0369: 	 * @return	TRUE if the datatype can contain NULL, FALSE if not.
1:eac0369: 	 */
1:eac0369: 	public boolean	isNullable()
1:eac0369: 	{
1:eac0369: 		return isNullable;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:4aef9b0: 	* @see TypeDescriptor#isRowMultiSet
1:4aef9b0: 	 */
1:4aef9b0: 	public	boolean isRowMultiSet()
1:4aef9b0: 	{
1:d66ce7b: 		return typeId instanceof RowMultiSetImpl;
1:4aef9b0: 	}
1:4aef9b0: 
1:d039ced: 	/**
1:d039ced: 	* @see TypeDescriptor#isUserDefinedType
1:d039ced: 	 */
1:d039ced:     public	boolean isUserDefinedType()
1:d039ced:     {
1:d039ced:         return typeId.userType();
1:d039ced:     }
1:d039ced: 
1:d039ced: 
1:96a630c: 	/** @see TypeDescriptor#getCollationType() */
1:7752cf6: 	public int	getCollationType()
1:eac0369: 	{
1:7752cf6: 		return collationType;
1:eac0369: 	}
1:eac0369: 
1:7752cf6: 	public void	setCollationType(int collationTypeValue)
1:7752cf6: 	{
1:7752cf6: 		collationType = collationTypeValue;
1:7752cf6: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Converts this data type descriptor (including length/precision)
1:eac0369: 	 * to a string. E.g.
1:eac0369: 	 *
1:eac0369: 	 *			VARCHAR(30)
1:eac0369: 	 *
1:eac0369: 	 *	or
1:eac0369: 	 *
1:eac0369: 	 *			 java.util.Hashtable 
1:eac0369: 	 *
1:eac0369: 	 * @return	String version of datatype, suitable for running through
1:eac0369: 	 *			the Parser.
1:eac0369: 	 */
1:eac0369: 	public String	getSQLstring()
1:eac0369: 	{
1:eac0369: 		return typeId.toParsableString( this );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String	toString()
1:eac0369: 	{
1:eac0369: 		String s = getSQLstring();
1:eac0369: 		if (!isNullable())
1:eac0369: 			return s + " NOT NULL";
1:eac0369: 		return s;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the type Id stored within this type descriptor.
1:eac0369: 	 */
1:eac0369: 	public BaseTypeIdImpl getTypeId()
1:eac0369: 	{
1:eac0369: 		return typeId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Compare if two TypeDescriptors are exactly the same
1:d1d5ad1: 	  @param object the dataTypeDescriptor to compare to.
1:eac0369: 	  */
1:eac0369: 	public boolean equals(Object object)
1:eac0369: 	{
1:eac0369: 		TypeDescriptor typeDescriptor = (TypeDescriptor)object;
1:eac0369: 
1:eac0369: 		if(!this.getTypeName().equals(typeDescriptor.getTypeName()) ||
1:eac0369: 		   this.precision != typeDescriptor.getPrecision() ||
1:eac0369: 		   this.scale != typeDescriptor.getScale() ||
1:eac0369: 		   this.isNullable != typeDescriptor.isNullable() ||
1:eac0369: 		   this.maximumWidth != typeDescriptor.getMaximumWidth())
1:4aef9b0: 		   return false;
1:eac0369: 	    else
1:13117b0: 	    {
1:13117b0: 			switch (typeId.getJDBCTypeId()) {
1:13117b0: 			case Types.CHAR:
1:13117b0: 			case Types.VARCHAR:
1:13117b0: 			case Types.LONGVARCHAR:
1:13117b0: 			case Types.CLOB:
1:13117b0: 				//if we are dealing with character types, then we should 
1:13117b0: 				//also compare the collation information on them.
1:c0c33cd: 				if(this.collationType != typeDescriptor.getCollationType())
1:eac0369: 					return false;
1:13117b0: 				else
1:eac0369: 					return true;
1:13117b0: 			default:
1:13117b0: 				//no collation checking required if we are dealing with 
1:13117b0: 				//non-char datatypes.
2:13117b0: 				return true;
1:eac0369: 			}
1:13117b0: 	    }
1:13117b0: 	}						   
1:eac0369: 
1:eac0369: 	// Formatable methods
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Read this object from a stream of stored objects.
1:eac0369: 	 *
1:eac0369: 	 * @param in read this.
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException					thrown on error
1:eac0369: 	 * @exception ClassNotFoundException		thrown on error
1:eac0369: 	 */
1:eac0369: 	public void readExternal( ObjectInput in )
1:eac0369: 		 throws IOException, ClassNotFoundException
1:eac0369: 	{
1:eac0369: 		typeId = (BaseTypeIdImpl) in.readObject();
1:eac0369: 		precision = in.readInt();
1:eac0369: 		
1:96a630c: 		//Scale does not apply to character data types. Starting 10.3 release,
1:96a630c: 		//the scale field in TypeDescriptor in SYSCOLUMNS will be used to save
1:96a630c: 		//the collation type of the character data types. Because of this, in
1:96a630c: 		//this method, we check if we are dealing with character types. If yes,
1:96a630c: 		//then read the on-disk scale field of TypeDescriptor into collation
1:96a630c: 		//type. In other words, the on-disk scale field has 2 different 
1:96a630c: 		//meanings depending on what kind of data type we are dealing with.
1:96a630c: 		//For character data types, it really represents the collation type of
1:96a630c: 		//the character data type. For all the other data types, it represents
1:96a630c: 		//the scale of that data type.
1:7752cf6: 		switch (typeId.getJDBCTypeId()) {
1:7752cf6: 		case Types.CHAR:
1:7752cf6: 		case Types.VARCHAR:
1:7752cf6: 		case Types.LONGVARCHAR:
1:7752cf6: 		case Types.CLOB:
1:7752cf6: 			scale = 0;
1:7752cf6: 			collationType = in.readInt();
1:7752cf6: 			break;
1:7752cf6: 		default:
1:eac0369: 			scale = in.readInt();
1:7752cf6: 			collationType = 0;
1:7752cf6: 			break;
1:7752cf6: 		}
1:7752cf6: 		
1:eac0369: 		isNullable = in.readBoolean();
1:eac0369: 		maximumWidth = in.readInt();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Write this object to a stream of stored objects.
1:eac0369: 	 *
1:eac0369: 	 * @param out write bytes here.
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException		thrown on error
1:eac0369: 	 */
1:eac0369: 	public void writeExternal( ObjectOutput out )
1:eac0369: 		 throws IOException
1:eac0369: 	{
1:eac0369: 		out.writeObject( typeId );
1:eac0369: 		out.writeInt( precision );
1:7752cf6: 
1:96a630c: 		//Scale does not apply to character data types. Starting 10.3 release,
1:96a630c: 		//the scale field in TypeDescriptor in SYSCOLUMNS will be used to save
1:96a630c: 		//the collation type of the character data types. Because of this, in
1:96a630c: 		//this method, we check if we are dealing with character types. If yes,
1:96a630c: 		//then write the collation type into the on-disk scale field of 
1:96a630c: 		//TypeDescriptor. But if we are dealing with non-character data types,
1:96a630c: 		//then write the scale of that data type into the on-disk scale field
1:96a630c: 		//of TypeDescriptor. In other words, the on-disk scale field has 2 
1:96a630c: 		//different meanings depending on what kind of data type we are dealing 
1:96a630c: 		//with. For character data types, it really represents the collation 
1:96a630c: 		//type of the character data type. For all the other data types, it 
1:96a630c: 		//represents the scale of that data type.
1:7752cf6: 		switch (typeId.getJDBCTypeId()) {
1:7752cf6: 		case Types.CHAR:
1:7752cf6: 		case Types.VARCHAR:
1:7752cf6: 		case Types.LONGVARCHAR:
1:7752cf6: 		case Types.CLOB:
1:7752cf6: 			out.writeInt( collationType );
1:7752cf6: 			break;
1:7752cf6: 		default:
1:eac0369: 			out.writeInt( scale );
1:7752cf6: 			break;
1:7752cf6: 		}		
1:7752cf6: 		
1:eac0369: 		out.writeBoolean( isNullable );
1:eac0369: 		out.writeInt( maximumWidth );
1:eac0369: 	}
1:eac0369:  
1:eac0369: 	/**
1:eac0369: 	 * Get the formatID which corresponds to this class.
1:eac0369: 	 *
1:eac0369: 	 *	@return	the formatID of this class
1:eac0369: 	 */
1:eac0369: 	public	int	getTypeFormatId()	{ return StoredFormatIds.DATA_TYPE_IMPL_DESCRIPTOR_V01_ID; }
1:d66ce7b: 
1:d66ce7b:     public String[] getRowColumnNames() {
1:d66ce7b:         if (!isRowMultiSet())
1:d66ce7b:             return null;
1:d66ce7b: 
1:d66ce7b:         return ((RowMultiSetImpl) typeId).getColumnNames();
1:d66ce7b:     }
1:d66ce7b: 
1:d66ce7b:     public TypeDescriptor[] getRowTypes() {
1:d66ce7b:         if (!isRowMultiSet())
1:d66ce7b:             return null;
1:d66ce7b: 
1:d66ce7b:         return ((RowMultiSetImpl) typeId).getTypes();
1:d66ce7b:     }
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.JDBC40Translation;
1: 
/////////////////////////////////////////////////////////////////////////
1:         this.scale = JDBC40Translation.UNKNOWN_SCALE;
1:         this.precision = JDBC40Translation.UNKNOWN_PRECISION;
commit:2d1e64e
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:57465ef
/////////////////////////////////////////////////////////////////////////
1:     /** copy an array of type descriptors */
1:     public  static TypeDescriptor[]    copyTypeDescriptors( TypeDescriptor[] original )
1:     {
1:         return (original == null) ? null : (TypeDescriptor[]) original.clone();
1:     }
1:     
commit:ff8ae29
/////////////////////////////////////////////////////////////////////////
1: 			// ODBC does not define a BOOLEAN data type.
1:             // However, 1 seems to me like a reasonable byte length for a BOOLEAN.
1:             case Types.BOOLEAN: return 1;
1:                 
commit:506f4c8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.reference.JDBC30Translation;
/////////////////////////////////////////////////////////////////////////
1: 
0:         this.scale = JDBC30Translation.UNKNOWN_SCALE;
0:         this.precision = JDBC30Translation.UNKNOWN_PRECISION;
commit:d039ced
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	* @see TypeDescriptor#isUserDefinedType
1: 	 */
1:     public	boolean isUserDefinedType()
1:     {
1:         return typeId.userType();
1:     }
1: 
1: 
commit:2d3677b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.reference.JDBC40Translation;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 * Report whether this type is a string type.
1: 	 */
1: 	public boolean  isStringType()
1: 	{
1: 		switch (typeId.getJDBCTypeId())
1:         {
1: 			case Types.CHAR:
1: 			case Types.VARCHAR:
1: 			case Types.LONGVARCHAR:
1: 			case Types.CLOB:
0: 			case JDBC40Translation.NCHAR:
0: 			case JDBC40Translation.NVARCHAR:
0: 			case JDBC40Translation.LONGNVARCHAR:
0: 			case JDBC40Translation.NCLOB:
1:                 return true;
1:                 
1: 			default:
1: 				return false;
1: 		}
1: 	}
1: 
1: 	/**
commit:4aef9b0
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	* @see TypeDescriptor#isRowMultiSet
1: 	 */
1: 	public	boolean isRowMultiSet()
1: 	{
1: 		return false;
1: 	}
1: 
commit:83deb87
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
/////////////////////////////////////////////////////////////////////////
0: 	/** @see DataTypeDescriptor#setCollationType(int) */
/////////////////////////////////////////////////////////////////////////
0: 	/** @see DataTypeDescriptor#setCollationDerivation(int) */
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:fbb0d4f
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.ObjectInput;
1: import java.io.ObjectOutput;
1: import java.sql.Types;
1: import org.apache.derby.iapi.services.io.Formatable;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
commit:01b5961
/////////////////////////////////////////////////////////////////////////
commit:d66ce7b
/////////////////////////////////////////////////////////////////////////
1: 		return typeId instanceof RowMultiSetImpl;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public String[] getRowColumnNames() {
1:         if (!isRowMultiSet())
1:             return null;
1: 
1:         return ((RowMultiSetImpl) typeId).getColumnNames();
1:     }
1: 
1:     public TypeDescriptor[] getRowTypes() {
1:         if (!isRowMultiSet())
1:             return null;
1: 
1:         return ((RowMultiSetImpl) typeId).getTypes();
1:     }
commit:ae196bc
/////////////////////////////////////////////////////////////////////////
commit:c0c33cd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		int collationType)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			int collationType)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				if(this.collationType != typeDescriptor.getCollationType())
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.catalog.types.TypeDescriptorImpl
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:4dede3b
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.catalog.types
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.catalog.types;
1: 
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.io.Formatable;
1: 
1: import org.apache.derby.catalog.TypeDescriptor;
1: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: import java.sql.Types;
1:                              
1: public class TypeDescriptorImpl implements TypeDescriptor, Formatable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	/********************************************************
1: 	**
1: 	**	This class implements Formatable. That means that it
1: 	**	can write itself to and from a formatted stream. If
1: 	**	you add more fields to this class, make sure that you
1: 	**	also write/read them with the writeExternal()/readExternal()
1: 	**	methods.
1: 	**
1: 	**	If, inbetween releases, you add more fields to this class,
1: 	**	then you should bump the version number emitted by the getTypeFormatId()
1: 	**	method.
1: 	**
1: 	********************************************************/
1: 
1: 	private BaseTypeIdImpl		typeId;
1: 	private int						precision;
1: 	private int						scale;
1: 	private boolean					isNullable;
1: 	private int						maximumWidth;
1: 
1: 	/**
1: 	 * Public niladic constructor. Needed for Formatable interface to work.
1: 	 *
1: 	 */
1:     public	TypeDescriptorImpl() {}
1: 
1: 	/**
1: 	 * Constructor for use with numeric types
1: 	 *
1: 	 * @param typeId	The typeId of the type being described
1: 	 * @param precision	The number of decimal digits.
1: 	 * @param scale		The number of digits after the decimal point.
1: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1: 	 *			it definitely cannot contain NULL.
1: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1: 	 */
1: 	public TypeDescriptorImpl(
1: 		BaseTypeIdImpl typeId,
1: 		int precision,
1: 		int scale,
1: 		boolean isNullable,
1: 		int maximumWidth)
1: 	{
1: 		this.typeId = typeId;
1: 		this.precision = precision;
1: 		this.scale = scale;
1: 		this.isNullable = isNullable;
1: 		this.maximumWidth = maximumWidth;
1: 	}
1: 
1: 	/**
1: 	 * Constructor for use with non-numeric types
1: 	 *
1: 	 * @param typeId	The typeId of the type being described
1: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1: 	 *			it definitely cannot contain NULL.
1: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1: 	 */
1: 	public TypeDescriptorImpl(
1: 		BaseTypeIdImpl typeId,
1: 		boolean isNullable,
1: 		int maximumWidth)
1: 	{
1: 		this.typeId = typeId;
1: 		this.isNullable = isNullable;
1: 		this.maximumWidth = maximumWidth;
1: 	}
1: 
1: 	/**
1: 	 * Constructor for internal uses only.  
1: 	 * (This is useful when the precision and scale are potentially wider than
1: 	 * those in the source, like when determining the dominant data type.)
1: 	 *
1: 	 * @param source	The DTSI to copy
1: 	 * @param precision	The number of decimal digits.
1: 	 * @param scale		The number of digits after the decimal point.
1: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1: 	 *			it definitely cannot contain NULL.
1: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1: 	 */
1: 	public TypeDescriptorImpl(
1: 		TypeDescriptorImpl source, 
1: 		int precision,
1: 		int scale,
1: 		boolean isNullable,
1: 		int maximumWidth)
1: 	{
1: 		this.typeId = source.typeId;
1: 		this.precision = precision;
1: 		this.scale = scale;
1: 		this.isNullable = isNullable;
1: 		this.maximumWidth = maximumWidth;
1: 	}
1: 
1: 	/**
1: 	 * Constructor for internal uses only
1: 	 *
1: 	 * @param source	The DTSI to copy
1: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1: 	 *			it definitely cannot contain NULL.
1: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1: 	 */
1: 	public TypeDescriptorImpl(
1: 		TypeDescriptorImpl source,
1: 		boolean isNullable,
1: 		int maximumWidth)
1: 	{
1: 		this.typeId = source.typeId;
1: 		this.precision = source.precision;
1: 		this.scale = source.scale;
1: 		this.isNullable = isNullable;
1: 		this.maximumWidth = maximumWidth;
1: 	}
1: 
1: 	/**
1: 	 * @see TypeDescriptor#getMaximumWidth
1: 	 */
1: 	public int	getMaximumWidth()
1: 	{
1: 		return maximumWidth;
1: 	}
1: 
1: 	/**
1: 	 * Get the jdbc type id for this type.  JDBC type can be
1: 	 * found in java.sql.Types. 
1: 	 *
1: 	 * @return	a jdbc type, e.g. java.sql.Types.DECIMAL 
1: 	 *
1: 	 * @see Types
1: 	 */
1: 	public int getJDBCTypeId()
1: 	{
1: 		return typeId.getJDBCTypeId();
1: 	}
1: 
1: 	/**
1: 	 * Gets the name of this datatype.
1: 	 * 
1: 	 *
1: 	 *  @return	the name of this datatype
1: 	 */
1: 	public	String		getTypeName()
1: 	{
1: 		return typeId.getSQLTypeName();
1: 	}
1: 
1: 	/**
1: 	 * Returns the number of decimal digits for the datatype, if applicable.
1: 	 *
1: 	 * @return	The number of decimal digits for the datatype.  Returns
1: 	 *		zero for non-numeric datatypes.
1: 	 */
1: 	public int	getPrecision()
1: 	{
1: 		return precision;
1: 	}
1: 
1: 	/**
1: 	 * Returns the number of digits to the right of the decimal for
1: 	 * the datatype, if applicable.
1: 	 *
1: 	 * @return	The number of digits to the right of the decimal for
1: 	 *		the datatype.  Returns zero for non-numeric datatypes.
1: 	 */
1: 	public int	getScale()
1: 	{
1: 		return scale;
1: 	}
1: 
1: 	/**
1: 	 * Returns TRUE if the datatype can contain NULL, FALSE if not.
1: 	 * JDBC supports a return value meaning "nullability unknown" -
1: 	 * I assume we will never have columns where the nullability is unknown.
1: 	 *
1: 	 * @return	TRUE if the datatype can contain NULL, FALSE if not.
1: 	 */
1: 	public boolean	isNullable()
1: 	{
1: 		return isNullable;
1: 	}
1: 
1: 	/**
0: 	 * Set the nullability of the datatype described by this descriptor
1: 	 *
0: 	 * @param nullable	TRUE means set nullability to TRUE, FALSE
0: 	 *					means set it to FALSE
1: 	 */
0: 	public void setNullability(boolean nullable)
1: 	{
0: 		isNullable = nullable;
1: 	}
1: 
1: 	/**
1: 	 * Converts this data type descriptor (including length/precision)
1: 	 * to a string. E.g.
1: 
1: 
1: 	 *
1: 	 *			VARCHAR(30)
1: 	 *
1: 	 *	or
1: 	 *
1: 	 *			 java.util.Hashtable 
1: 	 *
1: 	 * @return	String version of datatype, suitable for running through
1: 	 *			the Parser.
1: 	 */
1: 	public String	getSQLstring()
1: 	{
1: 		return typeId.toParsableString( this );
1: 	}
1: 
1: 	public String	toString()
1: 	{
1: 		String s = getSQLstring();
1: 		if (!isNullable())
1: 			return s + " NOT NULL";
1: 		return s;
1: 	}
1: 
1: 	/**
1: 	 * Get the type Id stored within this type descriptor.
1: 	 */
1: 	public BaseTypeIdImpl getTypeId()
1: 	{
1: 		return typeId;
1: 	}
1: 
1: 	/**
1: 	  Compare if two TypeDescriptors are exactly the same
0: 	  @param typeDescriptor the dataTypeDescriptor to compare to.
1: 	  */
1: 	public boolean equals(Object object)
1: 	{
1: 		TypeDescriptor typeDescriptor = (TypeDescriptor)object;
1: 
1: 		if(!this.getTypeName().equals(typeDescriptor.getTypeName()) ||
1: 		   this.precision != typeDescriptor.getPrecision() ||
1: 		   this.scale != typeDescriptor.getScale() ||
1: 		   this.isNullable != typeDescriptor.isNullable() ||
1: 		   this.maximumWidth != typeDescriptor.getMaximumWidth())
1: 		   return false;
1: 	    else
1: 			return true;
1: 	}						   
1: 
1: 	// Formatable methods
1: 
1: 	/**
1: 	 * Read this object from a stream of stored objects.
1: 	 *
1: 	 * @param in read this.
1: 	 *
1: 	 * @exception IOException					thrown on error
1: 	 * @exception ClassNotFoundException		thrown on error
1: 	 */
1: 	public void readExternal( ObjectInput in )
1: 		 throws IOException, ClassNotFoundException
1: 	{
1: 		typeId = (BaseTypeIdImpl) in.readObject();
1: 		precision = in.readInt();
1: 		scale = in.readInt();
1: 		isNullable = in.readBoolean();
1: 		maximumWidth = in.readInt();
1: 	}
1: 
1: 	/**
1: 	 * Write this object to a stream of stored objects.
1: 	 *
1: 	 * @param out write bytes here.
1: 	 *
1: 	 * @exception IOException		thrown on error
1: 	 */
1: 	public void writeExternal( ObjectOutput out )
1: 		 throws IOException
1: 	{
1: 		out.writeObject( typeId );
1: 		out.writeInt( precision );
1: 		out.writeInt( scale );
1: 		out.writeBoolean( isNullable );
1: 		out.writeInt( maximumWidth );
1: 	}
1:  
1: 	/**
1: 	 * Get the formatID which corresponds to this class.
1: 	 *
1: 	 *	@return	the formatID of this class
1: 	 */
1: 	public	int	getTypeFormatId()	{ return StoredFormatIds.DATA_TYPE_IMPL_DESCRIPTOR_V01_ID; }
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:111785f
/////////////////////////////////////////////////////////////////////////
commit:12f2b05
/////////////////////////////////////////////////////////////////////////
0: 	 * Gets the name of the collation type in this descriptor if the collation
0: 	 * derivation is not NONE. If the collation derivation is NONE, then this
0: 	 * method will return "NONE".
0:      * This method is used for generating error messages which will use correct
0:      * string describing collation type/derivation.
/////////////////////////////////////////////////////////////////////////
0:         		collationDerivation == StringDataValue.COLLATION_DERIVATION_NONE ?
0:         				Property.COLLATION_NONE :
0:         		collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC ?
0:         				Property.UCS_BASIC_COLLATION :
0:         				Property.TERRITORY_BASED_COLLATION);
commit:a9dbcce
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.Property;
/////////////////////////////////////////////////////////////////////////
0:                 Property.UCS_BASIC_COLLATION : 
0:                 Property.TERRITORY_BASED_COLLATION);
commit:68f9f47
/////////////////////////////////////////////////////////////////////////
1: 	 * Constructor to use when the caller doesn't know if it is requesting
1: 	 * numeric or no-numeric DTD. For instance, when dealing with MAX/MIN 
1: 	 * aggregrate operators, AggregateNode.bindExpression could be dealing
1: 	 * with a character string operand or a numeric operand. The result of
1: 	 * MAX/MIN will depend on the type of it's operand. And hence when this
1: 	 * constructor gets called by AggregateNode.bindExpression, we don't know 
1: 	 * what type we are constructing and hence this constructor supports 
1: 	 * arguments for both numeric and non-numeric types.
commit:f90d449
/////////////////////////////////////////////////////////////////////////
0: 	 * Constructor for use with numeric types/non-numeric types. For instance,
0: 	 * when dealing with MAX/MIN aggregrade operators, we do not if we are
0: 	 * working with numeric or non-numeric types. Such a constructor will be
0: 	 * used in those cases. 
1: 	 *
1: 	 * @param typeId	The typeId of the type being described
1: 	 * @param precision	The number of decimal digits.
1: 	 * @param scale		The number of digits after the decimal point.
1: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1: 	 *			it definitely cannot contain NULL.
1: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1: 	 * @param collationType The collation type of a string data type
0: 	 * @param collationDerivation Collation Derivation of a string data type
0: 	 */
1: 	public TypeDescriptorImpl(
1: 		BaseTypeIdImpl typeId,
1: 		int precision,
1: 		int scale,
1: 		boolean isNullable,
1: 		int maximumWidth,
0: 		int collationType,
0: 		int collationDerivation)
1: 	{
1: 		this.typeId = typeId;
1: 		this.precision = precision;
1: 		this.scale = scale;
1: 		this.isNullable = isNullable;
1: 		this.maximumWidth = maximumWidth;
1: 		this.collationType = collationType;
0: 		this.collationDerivation = collationDerivation;
1: 	}
1: 
0: 	/**
commit:3841b98
/////////////////////////////////////////////////////////////////////////
1: 	public TypeDescriptorImpl(
1: 			TypeDescriptorImpl source, 
1: 			int precision,
1: 			int scale,
1: 			boolean isNullable,
1: 			int maximumWidth,
0: 			int collationType,
0: 			int collationDerivation)
1: 		{
1: 			this.typeId = source.typeId;
1: 			this.precision = precision;
1: 			this.scale = scale;
1: 			this.isNullable = isNullable;
1: 			this.maximumWidth = maximumWidth;
1: 			this.collationType = collationType;
0: 			this.collationDerivation = collationDerivation;
1: 		}
1: 	
1: 	
commit:f19b703
/////////////////////////////////////////////////////////////////////////
1: 	private int	collationType = StringDataValue.COLLATION_TYPE_UCS_BASIC;
0: 	private int	collationDerivation = StringDataValue.COLLATION_DERIVATION_IMPLICIT;
commit:2bb198a
/////////////////////////////////////////////////////////////////////////
0: 	private int					collationDerivation = StringDataValue.COLLATION_DERIVATION_IMPLICIT;
commit:13117b0
/////////////////////////////////////////////////////////////////////////
1: 	    {
1: 			switch (typeId.getJDBCTypeId()) {
1: 			case Types.CHAR:
1: 			case Types.VARCHAR:
1: 			case Types.LONGVARCHAR:
1: 			case Types.CLOB:
1: 				//if we are dealing with character types, then we should 
1: 				//also compare the collation information on them.
0: 				if(this.collationDerivation != typeDescriptor.getCollationDerivation() ||
0: 						this.collationType != typeDescriptor.getCollationType())
0: 					return false;
1: 				else
1: 					return true;
1: 			default:
1: 				//no collation checking required if we are dealing with 
1: 				//non-char datatypes.
1: 				return true;
1: 			}
1: 	    }
commit:bb11794
/////////////////////////////////////////////////////////////////////////
0: 	private int					collationDerivation = StringDataValue.COLLATION_DERIVATION_NONE;
commit:96a630c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.StringDataValue;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	/** @see TypeDescriptor#getCollationType() */
0: 	/** @see TypeDescriptor#getCollationDerivation() */
0: 	private int					collationDerivation = StringDataValue.COLLATION_DERIVATION_IMPLICIT;
/////////////////////////////////////////////////////////////////////////
1: 	/** @see TypeDescriptor#getCollationType() */
0: 	/** @see TypeDescriptor#setCollationType(int) */
0: 	/** @see TypeDescriptor#getCollationDerivation() */
0: 	public int	getCollationDerivation()
0: 	/** @see TypeDescriptor#setCollationDerivation(int) */
0: 	public void	setCollationDerivation(int collationDerivationValue)
/////////////////////////////////////////////////////////////////////////
0: 		   this.collationDerivation == typeDescriptor.getCollationDerivation() ||
/////////////////////////////////////////////////////////////////////////
1: 		//Scale does not apply to character data types. Starting 10.3 release,
1: 		//the scale field in TypeDescriptor in SYSCOLUMNS will be used to save
1: 		//the collation type of the character data types. Because of this, in
1: 		//this method, we check if we are dealing with character types. If yes,
1: 		//then read the on-disk scale field of TypeDescriptor into collation
1: 		//type. In other words, the on-disk scale field has 2 different 
1: 		//meanings depending on what kind of data type we are dealing with.
1: 		//For character data types, it really represents the collation type of
1: 		//the character data type. For all the other data types, it represents
1: 		//the scale of that data type.
/////////////////////////////////////////////////////////////////////////
0: 			collationDerivation = StringDataValue.COLLATION_DERIVATION_IMPLICIT;
0: 			collationDerivation = StringDataValue.COLLATION_DERIVATION_IMPLICIT;
/////////////////////////////////////////////////////////////////////////
1: 		//Scale does not apply to character data types. Starting 10.3 release,
1: 		//the scale field in TypeDescriptor in SYSCOLUMNS will be used to save
1: 		//the collation type of the character data types. Because of this, in
1: 		//this method, we check if we are dealing with character types. If yes,
1: 		//then write the collation type into the on-disk scale field of 
1: 		//TypeDescriptor. But if we are dealing with non-character data types,
1: 		//then write the scale of that data type into the on-disk scale field
1: 		//of TypeDescriptor. In other words, the on-disk scale field has 2 
1: 		//different meanings depending on what kind of data type we are dealing 
1: 		//with. For character data types, it really represents the collation 
1: 		//type of the character data type. For all the other data types, it 
1: 		//represents the scale of that data type.
commit:7752cf6
/////////////////////////////////////////////////////////////////////////
0: 	/** @see TypeDescriptor.getCollationType */
0: 	private int						collationType;
0: 	/** @see TypeDescriptor.getCollationDerivation() */
0: 	private String					collationDerivation = TypeDescriptor.COLLATION_DERIVATION_INCORRECT;
/////////////////////////////////////////////////////////////////////////
0: 	/** @see TypeDescriptor.getCollationType */
1: 	public int	getCollationType()
1: 	{
1: 		return collationType;
1: 	}
1: 
0: 	/** @see TypeDescriptor.setCollationType */
1: 	public void	setCollationType(int collationTypeValue)
1: 	{
1: 		collationType = collationTypeValue;
1: 	}
1: 
0: 	/** @see TypeDescriptor.getCollationDerivation */
0: 	public String	getCollationDerivation()
1: 	{
0: 		return collationDerivation;
1: 	}
1: 
0: 	/** @see TypeDescriptor.setCollationDerivation */
0: 	public void	setCollationDerivation(String collationDerivationValue)
1: 	{
0: 		collationDerivation = collationDerivationValue;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
0: 		   this.collationDerivation.equals(typeDescriptor.getCollationDerivation()) ||
0: 		   this.collationType == typeDescriptor.getCollationType() || 
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		switch (typeId.getJDBCTypeId()) {
1: 		case Types.CHAR:
1: 		case Types.VARCHAR:
1: 		case Types.LONGVARCHAR:
1: 		case Types.CLOB:
1: 			scale = 0;
1: 			collationType = in.readInt();
0: 			//I am assuming that the readExternal gets called only on 
0: 			//persistent columns. Since all persistent character string type
0: 			//columns always have the collation derivation of implicit, I will 
0: 			//simply use that value for collation derivation here for character 
0: 			//string type columns.
0: 			collationDerivation = TypeDescriptor.COLLATION_DERIVATION_IMPLICIT;
1: 			break;
1: 		default:
0: 			scale = in.readInt();
1: 			collationType = 0;
0: 			collationDerivation = TypeDescriptor.COLLATION_DERIVATION_INCORRECT;
1: 			break;
1: 		}
1: 		
/////////////////////////////////////////////////////////////////////////
1: 
1: 		switch (typeId.getJDBCTypeId()) {
1: 		case Types.CHAR:
1: 		case Types.VARCHAR:
1: 		case Types.LONGVARCHAR:
1: 		case Types.CLOB:
1: 			out.writeInt( collationType );
1: 			break;
1: 		default:
0: 			out.writeInt( scale );
1: 			break;
0: 		}		
1: 		
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:bc739f7
/////////////////////////////////////////////////////////////////////////
commit:ec2b8d1
/////////////////////////////////////////////////////////////////////////
0: 	 * Gets the name of the collation type in this descriptor.
0:      * <p>
0:      * Used to generate strings decribing collation type for error messages.
1: 	 * 
1: 	 *
0: 	 *  @return	the name of the collation being used in this type.
0: 	 */
0: 	public String getCollationName()
0:     {
0:         return(
0:             collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC ? 
0:                 StringDataValue.COLLATION_TYPE_UCS_BASIC_STRING : 
0:                 StringDataValue.COLLATION_TYPE_TERRITORY_BASED_STRING);
0:     }
1: 
0: 	/**
commit:d1d5ad1
/////////////////////////////////////////////////////////////////////////
1: 	  @param object the dataTypeDescriptor to compare to.
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:2f36947
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:09c8a0d
/////////////////////////////////////////////////////////////////////////
1: 	 * Return the length of this type in bytes.  Note that
1: 	 * while the JDBC API _does_ define a need for
1: 	 * returning length in bytes of a type, it doesn't
1: 	 * state clearly what that means for the various
1: 	 * types.  We assume therefore that the values here
1: 	 * are meant to match those specified by the ODBC
1: 	 * specification (esp. since ODBC clients are more
1: 	 * likely to need this value than a Java client).
1: 	 * The ODBC spec that defines the values we use here
1: 	 * can be found at the following link:
0: 	 * 
1: 	 * http://msdn.microsoft.com/library/default.asp?url=/library/
1: 	 * en-us/odbc/htm/odbctransfer_octet_length.asp
0: 	 *
1: 	 * @see TypeDescriptor#getMaximumWidthInBytes
0: 	 */
1: 	public int	getMaximumWidthInBytes()
0: 	{
1: 		switch (typeId.getJDBCTypeId()) {
1: 
1: 			case Types.BIT:
1: 			case Types.TINYINT:
1: 			case Types.SMALLINT:
1: 			case Types.INTEGER:
1: 			case Types.REAL:
1: 			case Types.DOUBLE:
1: 			case Types.FLOAT:
1: 			case Types.BINARY:
1: 			case Types.VARBINARY:
1: 			case Types.LONGVARBINARY:
1: 			case Types.BLOB:
1: 
1: 				// For all of these, just take the maximumWidth,
1: 				// since that already holds the length in bytes.
1: 				return maximumWidth;
1: 
1: 			// For BIGINT values, ODBC spec says to return
1: 			// 40 because max length of a C/C++ BIGINT in
1: 			// string form is 20 and we assume the client
1: 			// character set is Unicode (spec says to
1: 			// multiply by 2 for unicode).
1: 			case Types.BIGINT:
1: 				return 40;
1: 
1: 			// ODBC spec explicitly declares what the lengths
1: 			// should be for datetime values, based on the
1: 			// declared fields of SQL_DATE_STRUCT, SQL_TIME_STRUCT,
1: 			// and SQL_TIMESTAMP_STRUCT.  So we just use those
1: 			// values.
1: 			case Types.DATE:
1: 			case Types.TIME:
1: 				return 6;
1: 
1: 			case Types.TIMESTAMP:
1: 				return 16;
1: 
1: 			// ODBC spec says that for numeric/decimal values,
1: 			// we should use max number of digits plus 2
1: 			// (for sign and decimal point), since that's
1: 			// the length of a decimal value in string form.
1: 			// And since we assume client character set
1: 			// is unicode, we have to multiply by 2 to
1: 			// get the number of bytes.
1: 			case Types.NUMERIC:
1: 			case Types.DECIMAL:
1: 				return 2 * (precision + 2);
1: 
1: 			// ODBC spec says to use length in chars
1: 			// for character types, times two if we
1: 			// assume client character set is unicode.
1: 			// If 2 * character length is greater than
1: 			// variable type (in this case, integer),
1: 			// then we return the max value for an
1: 			// integer.
1: 			case Types.CHAR:
1: 			case Types.VARCHAR:
1: 			case Types.LONGVARCHAR:
1: 			case Types.CLOB:
1: 				if ((maximumWidth > 0) && (2 * maximumWidth < 0))
1: 				// integer overflow; return max integer possible.
1: 					return Integer.MAX_VALUE;
1: 				else
1: 					return 2 * maximumWidth;
1: 
1: 			case Types.ARRAY:
1: 			case Types.DISTINCT:
1: 			case Types.NULL:
1: 			case Types.OTHER:
1: 			case Types.REF:
1: 			case Types.STRUCT:
1: 			case Types.JAVA_OBJECT:
1: 			default:
1: 
1: 				// For these we don't know, so return the "don't-know"
1: 				// indicator.
1: 				return -1;
1: 
0: 		}
1: 
0: 	}
1: 
0: 	/**
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.catalog.types
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.catalog.types;
0: 
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.io.Formatable;
0: 
0: import org.apache.derby.catalog.TypeDescriptor;
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: import java.sql.Types;
0:                              
0: public class TypeDescriptorImpl implements TypeDescriptor, Formatable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	/********************************************************
0: 	**
0: 	**	This class implements Formatable. That means that it
0: 	**	can write itself to and from a formatted stream. If
0: 	**	you add more fields to this class, make sure that you
0: 	**	also write/read them with the writeExternal()/readExternal()
0: 	**	methods.
0: 	**
0: 	**	If, inbetween releases, you add more fields to this class,
0: 	**	then you should bump the version number emitted by the getTypeFormatId()
0: 	**	method.
0: 	**
0: 	********************************************************/
0: 
0: 	private BaseTypeIdImpl		typeId;
0: 	private int						precision;
0: 	private int						scale;
0: 	private boolean					isNullable;
0: 	private int						maximumWidth;
0: 
0: 	/**
0: 	 * Public niladic constructor. Needed for Formatable interface to work.
0: 	 *
0: 	 */
0:     public	TypeDescriptorImpl() {}
0: 
0: 	/**
0: 	 * Constructor for use with numeric types
0: 	 *
0: 	 * @param typeId	The typeId of the type being described
0: 	 * @param precision	The number of decimal digits.
0: 	 * @param scale		The number of digits after the decimal point.
0: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
0: 	 *			it definitely cannot contain NULL.
0: 	 * @param maximumWidth	The maximum number of bytes for this datatype
0: 	 */
0: 	public TypeDescriptorImpl(
0: 		BaseTypeIdImpl typeId,
0: 		int precision,
0: 		int scale,
0: 		boolean isNullable,
0: 		int maximumWidth)
0: 	{
0: 		this.typeId = typeId;
0: 		this.precision = precision;
0: 		this.scale = scale;
0: 		this.isNullable = isNullable;
0: 		this.maximumWidth = maximumWidth;
0: 	}
0: 
0: 	/**
0: 	 * Constructor for use with non-numeric types
0: 	 *
0: 	 * @param typeId	The typeId of the type being described
0: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
0: 	 *			it definitely cannot contain NULL.
0: 	 * @param maximumWidth	The maximum number of bytes for this datatype
0: 	 */
0: 	public TypeDescriptorImpl(
0: 		BaseTypeIdImpl typeId,
0: 		boolean isNullable,
0: 		int maximumWidth)
0: 	{
0: 		this.typeId = typeId;
0: 		this.isNullable = isNullable;
0: 		this.maximumWidth = maximumWidth;
0: 	}
0: 
0: 	/**
0: 	 * Constructor for internal uses only.  
0: 	 * (This is useful when the precision and scale are potentially wider than
0: 	 * those in the source, like when determining the dominant data type.)
0: 	 *
0: 	 * @param source	The DTSI to copy
0: 	 * @param precision	The number of decimal digits.
0: 	 * @param scale		The number of digits after the decimal point.
0: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
0: 	 *			it definitely cannot contain NULL.
0: 	 * @param maximumWidth	The maximum number of bytes for this datatype
0: 	 */
0: 	public TypeDescriptorImpl(
0: 		TypeDescriptorImpl source, 
0: 		int precision,
0: 		int scale,
0: 		boolean isNullable,
0: 		int maximumWidth)
0: 	{
0: 		this.typeId = source.typeId;
0: 		this.precision = precision;
0: 		this.scale = scale;
0: 		this.isNullable = isNullable;
0: 		this.maximumWidth = maximumWidth;
0: 	}
0: 
0: 	/**
0: 	 * Constructor for internal uses only
0: 	 *
0: 	 * @param source	The DTSI to copy
0: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
0: 	 *			it definitely cannot contain NULL.
0: 	 * @param maximumWidth	The maximum number of bytes for this datatype
0: 	 */
0: 	public TypeDescriptorImpl(
0: 		TypeDescriptorImpl source,
0: 		boolean isNullable,
0: 		int maximumWidth)
0: 	{
0: 		this.typeId = source.typeId;
0: 		this.precision = source.precision;
0: 		this.scale = source.scale;
0: 		this.isNullable = isNullable;
0: 		this.maximumWidth = maximumWidth;
0: 	}
0: 
0: 	/**
0: 	 * @see TypeDescriptor#getMaximumWidth
0: 	 */
0: 	public int	getMaximumWidth()
0: 	{
0: 		return maximumWidth;
0: 	}
0: 
0: 	/**
0: 	 * Get the jdbc type id for this type.  JDBC type can be
0: 	 * found in java.sql.Types. 
0: 	 *
0: 	 * @return	a jdbc type, e.g. java.sql.Types.DECIMAL 
0: 	 *
0: 	 * @see Types
0: 	 */
0: 	public int getJDBCTypeId()
0: 	{
0: 		return typeId.getJDBCTypeId();
0: 	}
0: 
0: 	/**
0: 	 * Gets the name of this datatype.
0: 	 * 
0: 	 *
0: 	 *  @return	the name of this datatype
0: 	 */
0: 	public	String		getTypeName()
0: 	{
0: 		return typeId.getSQLTypeName();
0: 	}
0: 
0: 	/**
0: 	 * Returns the number of decimal digits for the datatype, if applicable.
0: 	 *
0: 	 * @return	The number of decimal digits for the datatype.  Returns
0: 	 *		zero for non-numeric datatypes.
0: 	 */
0: 	public int	getPrecision()
0: 	{
0: 		return precision;
0: 	}
0: 
0: 	/**
0: 	 * Returns the number of digits to the right of the decimal for
0: 	 * the datatype, if applicable.
0: 	 *
0: 	 * @return	The number of digits to the right of the decimal for
0: 	 *		the datatype.  Returns zero for non-numeric datatypes.
0: 	 */
0: 	public int	getScale()
0: 	{
0: 		return scale;
0: 	}
0: 
0: 	/**
0: 	 * Returns TRUE if the datatype can contain NULL, FALSE if not.
0: 	 * JDBC supports a return value meaning "nullability unknown" -
0: 	 * I assume we will never have columns where the nullability is unknown.
0: 	 *
0: 	 * @return	TRUE if the datatype can contain NULL, FALSE if not.
0: 	 */
0: 	public boolean	isNullable()
0: 	{
0: 		return isNullable;
0: 	}
0: 
0: 	/**
0: 	 * Set the nullability of the datatype described by this descriptor
0: 	 *
0: 	 * @param nullable	TRUE means set nullability to TRUE, FALSE
0: 	 *					means set it to FALSE
0: 	 */
0: 	public void setNullability(boolean nullable)
0: 	{
0: 		isNullable = nullable;
0: 	}
0: 
0: 	/**
0: 	 * Converts this data type descriptor (including length/precision)
0: 	 * to a string. E.g.
0: 
0: 
0: 	 *
0: 	 *			VARCHAR(30)
0: 	 *
0: 	 *	or
0: 	 *
0: 	 *			 java.util.Hashtable 
0: 	 *
0: 	 * @return	String version of datatype, suitable for running through
0: 	 *			the Parser.
0: 	 */
0: 	public String	getSQLstring()
0: 	{
0: 		return typeId.toParsableString( this );
0: 	}
0: 
0: 	public String	toString()
0: 	{
0: 		String s = getSQLstring();
0: 		if (!isNullable())
0: 			return s + " NOT NULL";
0: 		return s;
0: 	}
0: 
0: 	/**
0: 	 * Get the type Id stored within this type descriptor.
0: 	 */
0: 	public BaseTypeIdImpl getTypeId()
0: 	{
0: 		return typeId;
0: 	}
0: 
0: 	/**
0: 	  Compare if two TypeDescriptors are exactly the same
0: 	  @param typeDescriptor the dataTypeDescriptor to compare to.
0: 	  */
0: 	public boolean equals(Object object)
0: 	{
0: 		TypeDescriptor typeDescriptor = (TypeDescriptor)object;
0: 
0: 		if(!this.getTypeName().equals(typeDescriptor.getTypeName()) ||
0: 		   this.precision != typeDescriptor.getPrecision() ||
0: 		   this.scale != typeDescriptor.getScale() ||
0: 		   this.isNullable != typeDescriptor.isNullable() ||
0: 		   this.maximumWidth != typeDescriptor.getMaximumWidth())
0: 		   return false;
0: 	    else
0: 			return true;
0: 	}						   
0: 
0: 	// Formatable methods
0: 
0: 	/**
0: 	 * Read this object from a stream of stored objects.
0: 	 *
0: 	 * @param in read this.
0: 	 *
0: 	 * @exception IOException					thrown on error
0: 	 * @exception ClassNotFoundException		thrown on error
0: 	 */
0: 	public void readExternal( ObjectInput in )
0: 		 throws IOException, ClassNotFoundException
0: 	{
0: 		typeId = (BaseTypeIdImpl) in.readObject();
0: 		precision = in.readInt();
0: 		scale = in.readInt();
0: 		isNullable = in.readBoolean();
0: 		maximumWidth = in.readInt();
0: 	}
0: 
0: 	/**
0: 	 * Write this object to a stream of stored objects.
0: 	 *
0: 	 * @param out write bytes here.
0: 	 *
0: 	 * @exception IOException		thrown on error
0: 	 */
0: 	public void writeExternal( ObjectOutput out )
0: 		 throws IOException
0: 	{
0: 		out.writeObject( typeId );
0: 		out.writeInt( precision );
0: 		out.writeInt( scale );
0: 		out.writeBoolean( isNullable );
0: 		out.writeInt( maximumWidth );
0: 	}
0:  
0: 	/**
0: 	 * Get the formatID which corresponds to this class.
0: 	 *
0: 	 *	@return	the formatID of this class
0: 	 */
0: 	public	int	getTypeFormatId()	{ return StoredFormatIds.DATA_TYPE_IMPL_DESCRIPTOR_V01_ID; }
0: }
============================================================================