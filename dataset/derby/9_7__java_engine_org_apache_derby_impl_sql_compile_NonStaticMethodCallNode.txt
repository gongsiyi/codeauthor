1:eac0369: /*
22:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.NonStaticMethodCallNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import java.lang.reflect.Modifier;
1:f33fbaf: import java.util.List;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:3bb140c: import org.apache.derby.iapi.services.loader.ClassInspector;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:3bb140c: import org.apache.derby.iapi.store.access.Qualifier;
1:3bb140c: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * A NonStaticMethodCallNode is really a node to represent a (static or non-static)
1:eac0369:  * method call from an object (as opposed to a static method call from a class.
1:eac0369:  */
1:3bb140c: class NonStaticMethodCallNode extends MethodCallNode
2:eac0369: {
1:eac0369: 	/*
1:eac0369: 	** The receiver for a non-static method call is an object, represented
1:eac0369: 	** by a ValueNode.
1:eac0369: 	*/
1:eac0369: 	JavaValueNode	receiver;	
1:eac0369: 
1:eac0369: 	/* Is this a static method call? Assume non-static call */
1:eac0369: 	private boolean isStatic;
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for a NonStaticMethodCallNode
3:eac0369: 	 *
1:eac0369: 	 * @param methodName	The name of the method to call
1:eac0369: 	 * @param receiver		A JavaValueNode representing the receiving object
1:3bb140c:      * @param cm            The context manager
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     NonStaticMethodCallNode(String methodName,
1:3bb140c:                             ValueNode receiver,
1:3bb140c:                             ContextManager cm)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:3bb140c:         super(methodName, cm);
1:eac0369: 		/*
1:eac0369: 		** If the receiver is a Java value that has been converted to a
1:eac0369: 		** SQL value, get rid of the conversion and just use the Java value
1:eac0369: 		** as-is.  If the receiver is a "normal" SQL value, then convert
1:eac0369: 		** it to a Java value to use as the receiver.
1:eac0369: 		*/
1:eac0369: 		if (receiver instanceof JavaToSQLValueNode)
1:eac0369: 		{
1:eac0369: 			this.receiver = ((JavaToSQLValueNode) receiver).
1:eac0369: 										getJavaValueNode();
2:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:3bb140c:             this.receiver =
1:3bb140c:                 new SQLToJavaValueNode(receiver, getContextManager());
1:eac0369: //            System.out.println("NonStaticMethodCallNode.init() receiver = "+receiver);
1:eac0369: // get nulpointer because not .bind?
1:eac0369: //            System.out.println("\ttypecompiler = "+((ValueNode)receiver).getTypeCompiler());
1:eac0369: //            System.out.println("\tdtd = "+((ValueNode)receiver).getTypeServices());
1:eac0369: //            System.out.println("\ttypeid = "+((ValueNode)receiver).getTypeServices().getTypeId());
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this expression.  This means binding the sub-expressions,
1:eac0369: 	 * as well as figuring out what the return type is for this expression.
1:eac0369: 	 *
1:eac0369: 	 * @param fromList		The FROM list for the query this
1:09c2697:      *                      expression is in, for binding columns.
1:09c2697:      * @param subqueryList  The subquery list being built as we find SubqueryNodes
1:09c2697:      * @param aggregates    The aggregate list being built as we find AggregateNodes
1:eac0369: 	 *
1:eac0369: 	 * @return	this
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:09c2697:     JavaValueNode bindExpression(
1:71c8e86:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		/* NULL and ? not allowed as receivers */
1:eac0369: 		if (receiver instanceof SQLToJavaValueNode)
1:eac0369: 		{
1:eac0369: 			ValueNode	SQLValue =
1:eac0369: 							((SQLToJavaValueNode) receiver).getSQLValueNode();
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!(SQLValue instanceof UntypedNullConstantNode),
1:eac0369: 				"UntypedNullConstantNode found as a receiver of a non-static method call");
1:eac0369: 
1:eac0369: 			//
1:eac0369: 			//	We don't allow methods off of naked unnamed "?" parameters.
1:eac0369: 			//	This is because we have no way of knowing the data type of
1:eac0369: 			//	a naked "?" parameter.
1:eac0369: 			//
1:eac0369: 			//	However, if this "?" has actually been associated with a
1:eac0369: 			//	named "?paramName" parameter in a COPY PUBLICATION statement,
1:eac0369: 			//	then we have a type for it. Binding can continue.
1:eac0369: 			//
1:eac0369: 
1:d5bc20f: 			if (SQLValue.requiresTypeFromContext())
1:eac0369: 			{
1:d5bc20f: 				if ( SQLValue.getTypeServices() == null )
1:eac0369: 				{ throw StandardException.newException(SQLState.LANG_PARAMETER_RECEIVER, methodName); }
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:09c2697:         bindParameters(fromList, subqueryList, aggregates);
1:eac0369: 
1:eac0369: 		/* Now we don't allow an alias static method call here (that has to
1:eac0369: 		 * use :: sign for any static call).  If it gets here, it can't be
1:eac0369: 		 * alias static method call.
1:eac0369: 		 */
1:09c2697:         receiver = receiver.bindExpression(fromList, subqueryList, aggregates);
1:eac0369: 
1:eac0369:         // Don't allow LOB types to be used as a method receiver
1:eac0369:         String type = receiver.getJSQLType().getSQLType().getTypeId().getSQLTypeName();
1:eac0369:         if ( type.equals("BLOB") || type.equals("CLOB") || type.equals("NCLOB") ) {
1:eac0369:             throw StandardException.newException(SQLState.LOB_AS_METHOD_ARGUMENT_OR_RECEIVER);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		javaClassName = receiver.getJavaTypeName();
1:eac0369: 
1:eac0369: 		/* Not allowed to use a primitive type as a method receiver */
1:eac0369: 		if (ClassInspector.primitiveType(javaClassName))
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_PRIMITIVE_RECEIVER, methodName, javaClassName);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Resolve the method call */
1:eac0369: 		resolveMethodCall(javaClassName, false);
1:eac0369: 
1:eac0369: 		/* Remember if method is static */
1:eac0369: 		isStatic = Modifier.isStatic(method.getModifiers());
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Categorize this predicate.  Initially, this means
1:eac0369: 	 * building a bit map of the referenced tables for each predicate.
1:eac0369: 	 * If the source of this ColumnReference (at the next underlying level) 
1:eac0369: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1:eac0369: 	 * will not be pushed down.
1:eac0369: 	 *
1:eac0369: 	 * For example, in:
1:eac0369: 	 *		select * from (select 1 from s) a (x) where x = 1
1:eac0369: 	 * we will not push down x = 1.
1:eac0369: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1:eac0369: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1:eac0369: 	 * that tree into the pushed predicate, and that tree could contain
1:eac0369: 	 * subqueries and method calls.
1:eac0369: 	 * RESOLVE - revisit this issue once we have views.
1:eac0369: 	 *
1:eac0369: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1:eac0369: 	 * @param simplePredsOnly	Whether or not to consider method
1:eac0369: 	 *							calls, field references and conditional nodes
1:eac0369: 	 *							when building bit map
1:eac0369: 	 *
1:eac0369: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1:eac0369: 	 *						or a VirtualColumnNode.
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:9f2ed7d:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* We stop here when only considering simple predicates
1:eac0369: 		 *  as we don't consider method calls when looking
1:eac0369: 		 * for null invariant predicates.
1:eac0369: 		 */
1:eac0369: 		if (simplePredsOnly)
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		boolean pushable = true;
1:eac0369: 
1:eac0369: 		pushable = pushable && super.categorize(referencedTabs, simplePredsOnly);
1:eac0369: 
1:eac0369: 		if (receiver != null)
1:eac0369: 		{
1:eac0369: 			pushable = pushable && receiver.categorize(referencedTabs, simplePredsOnly);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return pushable;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the variant type for the underlying expression.
1:eac0369: 	 * The variant type can be:
1:eac0369: 	 *		VARIANT				- variant within a scan
1:eac0369: 	 *							  (non-static field access)
1:eac0369: 	 *		SCAN_INVARIANT		- invariant within a scan
1:eac0369: 	 *							  (column references from outer tables)
1:eac0369: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1:eac0369: 	 *							  (constant expressions)
1:eac0369: 	 *
1:eac0369: 	 * @return	The variant type for the underlying expression.
1:eac0369: 	 */
1:3bb140c:     @Override
1:9f2ed7d:     int getOrderableVariantType() throws StandardException
1:eac0369: 	{
1:eac0369: 		int receiverVariant = receiver.getOrderableVariantType();
1:eac0369: 
1:eac0369: 		if (receiverVariant > Qualifier.SCAN_INVARIANT) {
1:eac0369: 			
1:eac0369: 			// If the method call is related to a trigger then the return
1:eac0369: 			// values are SCAN_INVARIANT even though their calls look QUERY_INVARIANT
1:eac0369: 			// because they take no parameters.
1:eac0369: 			if (receiver.getJavaTypeName().equals("org.apache.derby.iapi.db.TriggerExecutionContext"))
1:eac0369: 				receiverVariant = Qualifier.SCAN_INVARIANT;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		int thisVariant = super.getOrderableVariantType();
1:eac0369: 		if (receiverVariant < thisVariant)	//return the more variant one
1:eac0369: 			return receiverVariant;
1:eac0369: 		return thisVariant;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remap all ColumnReferences in this tree to be clones of the
1:eac0369: 	 * underlying expression.
1:eac0369: 	 *
1:eac0369: 	 * @return JavaValueNode			The remapped expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:9f2ed7d:     JavaValueNode remapColumnReferencesToExpressions()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (receiver != null)
1:eac0369: 		{
1:eac0369: 			receiver.remapColumnReferencesToExpressions();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return super.remapColumnReferencesToExpressions();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			int	parm;
1:eac0369: 
1:eac0369: 			super.printSubNodes(depth);
1:eac0369: 			if (receiver != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "receiver :");
1:eac0369: 				receiver.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Preprocess an expression tree.  We do a number of transformations
1:eac0369: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1:eac0369: 	 * subquery flattening.
1:eac0369: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1:eac0369: 	 *
1:eac0369: 	 * @param	numTables			Number of tables in the DML Statement
1:eac0369: 	 * @param	outerFromList		FromList from outer query block
1:eac0369: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1:eac0369: 	 * @param	outerPredicateList	PredicateList from outer query block
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:9f2ed7d:     void preprocess(int numTables,
1:eac0369: 							FromList outerFromList,
1:eac0369: 							SubqueryList outerSubqueryList,
1:eac0369: 							PredicateList outerPredicateList) 
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		super.preprocess(numTables,
1:eac0369: 						 outerFromList, outerSubqueryList,
1:eac0369: 						 outerPredicateList);
1:eac0369: 		receiver.preprocess(numTables,
1:eac0369: 							outerFromList, outerSubqueryList,
1:eac0369: 							outerPredicateList);
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do code generation for this method call
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1:eac0369: 	 * @param mb	The method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:9f2ed7d:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean inConditional = false;
1:eac0369: 		/*
1:eac0369: 		** If this method returns its value to the Java domain,
1:eac0369: 		** generate the receiver and put the value in a field (only if
1:eac0369: 		** this method does not return a primitive type).  If it
1:eac0369: 		** returns its value to the SQL domain, it's up to the JavaToSQLNode
1:eac0369: 		** to call generateReceiver().
1:eac0369: 		**
1:eac0369: 		** Also, don't do this if the return value from this method
1:eac0369: 		** call will be discarded.  This is the case for a CALL statement.
1:eac0369: 		** One reason we don't want to do this for a CALL statement
1:eac0369: 		** is that the ?: operator cannot be made into a statement.
1:eac0369: 		*/
1:eac0369: 		if ( ( ! valueReturnedToSQLDomain()) && ( ! returnValueDiscarded()))
1:eac0369: 		{
1:eac0369: 			if (generateReceiver(acb, mb, receiver))
1:eac0369: 			{
1:eac0369: 				/*
1:eac0369: 				** If the above did generate the expression, let's test it for
1:eac0369: 				** a null value.
1:eac0369: 				*/
1:eac0369: 				/*
1:eac0369: 				** Generate the following to test for null:
1:eac0369: 				**
1:eac0369: 				**		(receiverExpression == null) ?
1:eac0369: 				*/
1:eac0369: 
1:eac0369: 				inConditional = true;
1:eac0369: 				mb.conditionalIfNull();
1:eac0369: 				mb.pushNull(getJavaTypeName());
1:eac0369: 				mb.startElseCode();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Generate the following:
1:eac0369: 		**
1:eac0369: 		** <receiver>.<method name>(<param> (, <param> )* )
1:eac0369: 		**
1:eac0369: 		** for non-static calls.
1:eac0369: 		**
1:eac0369: 		** Refer to the field holding the receiver, if there is any.
1:eac0369: 		*/
1:eac0369: 
1:e1f49ca:         Class<?> declaringClass = method.getDeclaringClass();
1:eac0369: 		
1:eac0369: 		/*
1:eac0369: 		** If it's an interface, generate an interface method call, if it's a static,
1:eac0369: 		** generate a static method call, otherwise generate a regular method call.
1:eac0369: 		*/
1:eac0369: 
1:eac0369: 		short methodType;
1:eac0369: 
1:eac0369: 		if (declaringClass.isInterface())
1:eac0369: 			methodType = VMOpcode.INVOKEINTERFACE;
1:eac0369: 		else if (isStatic)
1:eac0369: 			methodType = VMOpcode.INVOKESTATIC;
1:eac0369: 		else
1:eac0369: 			methodType = VMOpcode.INVOKEVIRTUAL;
1:eac0369: 
1:eac0369: 		getReceiverExpression(acb, mb, receiver);
1:eac0369: 		if (isStatic)
1:eac0369: 			mb.endStatement(); // PUSHCOMPILER ???
1:eac0369: 
1:eac0369: 		int nargs = generateParameters(acb, mb);
1:eac0369: 
1:eac0369: 		mb.callMethod(methodType, declaringClass.getName(), methodName, getJavaTypeName(), nargs);
1:eac0369: 
1:eac0369: 		if (inConditional)
1:eac0369: 			mb.completeConditional();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the expression that evaluates to the receiver. This is
1:eac0369: 	 * for the case where a java expression is being returned to the SQL
1:eac0369: 	 * domain, and we need to check whether the receiver is null (if so,
1:eac0369: 	 * the SQL value should be set to null, and this Java expression
1:eac0369: 	 * not evaluated). Instance method calls and field references have
1:eac0369: 	 * receivers, while class method calls and calls to constructors do
1:eac0369: 	 * not. If this Java expression does not have a receiver, this method
1:eac0369: 	 * returns null.
1:eac0369: 	 *
1:eac0369: 	 * Only generate the receiver once and cache it in a field. This is
1:eac0369: 	 * because there will be two references to the receiver, and we want
1:eac0369: 	 * to evaluate it only once.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class being built
1:eac0369: 	 * @param mb	The method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 * @return		true if compiled receiver, false otherwise.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:9f2ed7d:     boolean generateReceiver(ExpressionClassBuilder acb,
2:eac0369: 											MethodBuilder mb)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Let's pretend that a call to a static method doesn't have a
1:eac0369: 		** receiver, since the method call is actually to the class,
1:eac0369: 		** and can be made even if the receiver is null (that is, we
1:eac0369: 		** always want to call a static method, even if the receiver is null).
1:eac0369: 		*/
1:eac0369: 		if (isStatic)
1:eac0369: 			return false;
1:eac0369: 		
1:eac0369: 		return generateReceiver(acb, mb, receiver);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:eac0369: 	 * 
1:eac0369: 	 * @param v the visitor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:eac0369: 
1:aebfb28: 		if (receiver != null)
1:eac0369: 		{
1:eac0369: 			receiver = (JavaValueNode)receiver.accept(v);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:         Class<?> declaringClass = method.getDeclaringClass();
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.loader.ClassInspector;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.util.JBitSet;
1: class NonStaticMethodCallNode extends MethodCallNode
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a NonStaticMethodCallNode
1:      * @param cm            The context manager
1:     NonStaticMethodCallNode(String methodName,
1:                             ValueNode receiver,
1:                             ContextManager cm)
1:         super(methodName, cm);
0:         setNodeType(C_NodeTypes.NON_STATIC_METHOD_CALL_NODE);
/////////////////////////////////////////////////////////////////////////
1:             this.receiver =
1:                 new SQLToJavaValueNode(receiver, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
1:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
/////////////////////////////////////////////////////////////////////////
1:     int getOrderableVariantType() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     JavaValueNode remapColumnReferencesToExpressions()
/////////////////////////////////////////////////////////////////////////
1:     void preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
/////////////////////////////////////////////////////////////////////////
1:     boolean generateReceiver(ExpressionClassBuilder acb,
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      *                      expression is in, for binding columns.
1:      * @param subqueryList  The subquery list being built as we find SubqueryNodes
1:      * @param aggregates    The aggregate list being built as we find AggregateNodes
1:     JavaValueNode bindExpression(
0:         FromList fromList, SubqueryList subqueryList, List aggregates)
/////////////////////////////////////////////////////////////////////////
1:         bindParameters(fromList, subqueryList, aggregates);
1:         receiver = receiver.bindExpression(fromList, subqueryList, aggregates);
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 		List aggregateVector)
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
1: 		if (receiver != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
1: 			if (SQLValue.requiresTypeFromContext())
1: 				if ( SQLValue.getTypeServices() == null )
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.NonStaticMethodCallNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.Qualifier;
1: 
1: 
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.services.loader.ClassInspector;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.types.JSQLType;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import org.apache.derby.catalog.AliasInfo;
1: 
1: import java.lang.reflect.Modifier;
1: 
0: import java.util.Vector;
1: 
1: /**
1:  * A NonStaticMethodCallNode is really a node to represent a (static or non-static)
1:  * method call from an object (as opposed to a static method call from a class.
1:  */
0: public class NonStaticMethodCallNode extends MethodCallNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/*
1: 	** The receiver for a non-static method call is an object, represented
1: 	** by a ValueNode.
1: 	*/
1: 	JavaValueNode	receiver;	
1: 
1: 	/* Is this a static method call? Assume non-static call */
1: 	private boolean isStatic;
1: 
1: 	/**
0: 	 * Initializer for a NonStaticMethodCallNode
1: 	 *
1: 	 * @param methodName	The name of the method to call
1: 	 * @param receiver		A JavaValueNode representing the receiving object
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(
0: 							Object methodName,
0: 							Object receiver)
1: 			throws StandardException
1: 	{
0: 		super.init(methodName);
1: 
1: 		/*
1: 		** If the receiver is a Java value that has been converted to a
1: 		** SQL value, get rid of the conversion and just use the Java value
1: 		** as-is.  If the receiver is a "normal" SQL value, then convert
1: 		** it to a Java value to use as the receiver.
1: 		*/
1: 		if (receiver instanceof JavaToSQLValueNode)
1: 		{
1: 			this.receiver = ((JavaToSQLValueNode) receiver).
1: 										getJavaValueNode();
1: 		}
1: 		else
1: 		{
0: 			this.receiver = (JavaValueNode) getNodeFactory().
0: 								getNode(
0: 									C_NodeTypes.SQL_TO_JAVA_VALUE_NODE,
0: 									receiver,
0: 									getContextManager());
1: //            System.out.println("NonStaticMethodCallNode.init() receiver = "+receiver);
1: // get nulpointer because not .bind?
1: //            System.out.println("\ttypecompiler = "+((ValueNode)receiver).getTypeCompiler());
1: //            System.out.println("\tdtd = "+((ValueNode)receiver).getTypeServices());
1: //            System.out.println("\ttypeid = "+((ValueNode)receiver).getTypeServices().getTypeId());
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind this expression.  This means binding the sub-expressions,
1: 	 * as well as figuring out what the return type is for this expression.
1: 	 *
1: 	 * @param fromList		The FROM list for the query this
0: 	 *				expression is in, for binding columns.
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
1: 	 * @return	this
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public JavaValueNode bindExpression(
0: 		FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector) 
1: 			throws StandardException
1: 	{
0: 		boolean		nullParameter = false;
0: 		String[]	parmTypeNames;
1: 
1: 		/* NULL and ? not allowed as receivers */
1: 		if (receiver instanceof SQLToJavaValueNode)
1: 		{
1: 			ValueNode	SQLValue =
1: 							((SQLToJavaValueNode) receiver).getSQLValueNode();
1: 
1: 			if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!(SQLValue instanceof UntypedNullConstantNode),
1: 				"UntypedNullConstantNode found as a receiver of a non-static method call");
1: 
1: 			//
1: 			//	We don't allow methods off of naked unnamed "?" parameters.
1: 			//	This is because we have no way of knowing the data type of
1: 			//	a naked "?" parameter.
1: 			//
1: 			//	However, if this "?" has actually been associated with a
1: 			//	named "?paramName" parameter in a COPY PUBLICATION statement,
1: 			//	then we have a type for it. Binding can continue.
1: 			//
1: 
0: 			if (SQLValue.isParameterNode())
1: 			{
0: 				ParameterNode	unnamedParameter = (ParameterNode) SQLValue;
1: 
0: 				if ( unnamedParameter.getTypeServices() == null )
1: 				{ throw StandardException.newException(SQLState.LANG_PARAMETER_RECEIVER, methodName); }
1: 			}
1: 		}
1: 
0: 		bindParameters(fromList, subqueryList, aggregateVector);
1: 
1: 		/* Now we don't allow an alias static method call here (that has to
1: 		 * use :: sign for any static call).  If it gets here, it can't be
1: 		 * alias static method call.
1: 		 */
0: 		receiver = receiver.bindExpression(fromList, subqueryList, aggregateVector);
1: 
1:         // Don't allow LOB types to be used as a method receiver
1:         String type = receiver.getJSQLType().getSQLType().getTypeId().getSQLTypeName();
1:         if ( type.equals("BLOB") || type.equals("CLOB") || type.equals("NCLOB") ) {
1:             throw StandardException.newException(SQLState.LOB_AS_METHOD_ARGUMENT_OR_RECEIVER);
1:         }
1: 
1: 		javaClassName = receiver.getJavaTypeName();
1: 
1: 		/* Not allowed to use a primitive type as a method receiver */
1: 		if (ClassInspector.primitiveType(javaClassName))
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_PRIMITIVE_RECEIVER, methodName, javaClassName);
1: 		}
1: 
1: 		/* Resolve the method call */
1: 		resolveMethodCall(javaClassName, false);
1: 
1: 		/* Remember if method is static */
1: 		isStatic = Modifier.isStatic(method.getModifiers());
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Categorize this predicate.  Initially, this means
1: 	 * building a bit map of the referenced tables for each predicate.
1: 	 * If the source of this ColumnReference (at the next underlying level) 
1: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1: 	 * will not be pushed down.
1: 	 *
1: 	 * For example, in:
1: 	 *		select * from (select 1 from s) a (x) where x = 1
1: 	 * we will not push down x = 1.
1: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1: 	 * that tree into the pushed predicate, and that tree could contain
1: 	 * subqueries and method calls.
1: 	 * RESOLVE - revisit this issue once we have views.
1: 	 *
1: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1: 	 * @param simplePredsOnly	Whether or not to consider method
1: 	 *							calls, field references and conditional nodes
1: 	 *							when building bit map
1: 	 *
1: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1: 	 *						or a VirtualColumnNode.
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1: 		throws StandardException
1: 	{
1: 		/* We stop here when only considering simple predicates
1: 		 *  as we don't consider method calls when looking
1: 		 * for null invariant predicates.
1: 		 */
1: 		if (simplePredsOnly)
1: 		{
1: 			return false;
1: 		}
1: 
1: 		boolean pushable = true;
1: 
1: 		pushable = pushable && super.categorize(referencedTabs, simplePredsOnly);
1: 
1: 		if (receiver != null)
1: 		{
1: 			pushable = pushable && receiver.categorize(referencedTabs, simplePredsOnly);
1: 		}
1: 
1: 		return pushable;
1: 	}
1: 
1: 	/**
1: 	 * Return the variant type for the underlying expression.
1: 	 * The variant type can be:
1: 	 *		VARIANT				- variant within a scan
1: 	 *							  (non-static field access)
1: 	 *		SCAN_INVARIANT		- invariant within a scan
1: 	 *							  (column references from outer tables)
1: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1: 	 *							  (constant expressions)
1: 	 *
1: 	 * @return	The variant type for the underlying expression.
1: 	 */
0: 	protected int getOrderableVariantType() throws StandardException
1: 	{
1: 		int receiverVariant = receiver.getOrderableVariantType();
1: 
1: 		if (receiverVariant > Qualifier.SCAN_INVARIANT) {
1: 			
1: 			// If the method call is related to a trigger then the return
1: 			// values are SCAN_INVARIANT even though their calls look QUERY_INVARIANT
1: 			// because they take no parameters.
1: 			if (receiver.getJavaTypeName().equals("org.apache.derby.iapi.db.TriggerExecutionContext"))
1: 				receiverVariant = Qualifier.SCAN_INVARIANT;
1: 		}
1: 
1: 
1: 		int thisVariant = super.getOrderableVariantType();
1: 		if (receiverVariant < thisVariant)	//return the more variant one
1: 			return receiverVariant;
1: 		return thisVariant;
1: 	}
1: 
1: 	/**
1: 	 * Remap all ColumnReferences in this tree to be clones of the
1: 	 * underlying expression.
1: 	 *
1: 	 * @return JavaValueNode			The remapped expression tree.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public JavaValueNode remapColumnReferencesToExpressions()
1: 		throws StandardException
1: 	{
1: 		if (receiver != null)
1: 		{
1: 			receiver.remapColumnReferencesToExpressions();
1: 		}
1: 
1: 		return super.remapColumnReferencesToExpressions();
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			int	parm;
1: 
1: 			super.printSubNodes(depth);
1: 			if (receiver != null)
1: 			{
1: 				printLabel(depth, "receiver :");
1: 				receiver.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Preprocess an expression tree.  We do a number of transformations
1: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1: 	 * subquery flattening.
1: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1: 	 *
1: 	 * @param	numTables			Number of tables in the DML Statement
1: 	 * @param	outerFromList		FromList from outer query block
1: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1: 	 * @param	outerPredicateList	PredicateList from outer query block
1: 	 *
0: 	 * @return	Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void preprocess(int numTables,
1: 							FromList outerFromList,
1: 							SubqueryList outerSubqueryList,
1: 							PredicateList outerPredicateList) 
1: 							throws StandardException
1: 	{
1: 		super.preprocess(numTables,
1: 						 outerFromList, outerSubqueryList,
1: 						 outerPredicateList);
1: 		receiver.preprocess(numTables,
1: 							outerFromList, outerSubqueryList,
1: 							outerPredicateList);
1: 
1: 	}
1: 
1: 	/**
1: 	 * Do code generation for this method call
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb	The method the expression will go into
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
1: 											MethodBuilder mb)
1: 									throws StandardException
1: 	{
1: 		boolean inConditional = false;
1: 		/*
1: 		** If this method returns its value to the Java domain,
1: 		** generate the receiver and put the value in a field (only if
1: 		** this method does not return a primitive type).  If it
1: 		** returns its value to the SQL domain, it's up to the JavaToSQLNode
1: 		** to call generateReceiver().
1: 		**
1: 		** Also, don't do this if the return value from this method
1: 		** call will be discarded.  This is the case for a CALL statement.
1: 		** One reason we don't want to do this for a CALL statement
1: 		** is that the ?: operator cannot be made into a statement.
1: 		*/
1: 		if ( ( ! valueReturnedToSQLDomain()) && ( ! returnValueDiscarded()))
1: 		{
1: 			if (generateReceiver(acb, mb, receiver))
1: 			{
1: 				/*
1: 				** If the above did generate the expression, let's test it for
1: 				** a null value.
1: 				*/
1: 				/*
1: 				** Generate the following to test for null:
1: 				**
1: 				**		(receiverExpression == null) ?
1: 				*/
1: 
1: 				inConditional = true;
1: 				mb.conditionalIfNull();
1: 				mb.pushNull(getJavaTypeName());
1: 				mb.startElseCode();
1: 			}
1: 		}
1: 
1: 		/*
1: 		** Generate the following:
1: 		**
1: 		** <receiver>.<method name>(<param> (, <param> )* )
1: 		**
1: 		** for non-static calls.
1: 		**
1: 		** Refer to the field holding the receiver, if there is any.
1: 		*/
1: 
0: 		Class declaringClass = method.getDeclaringClass();
1: 		
1: 		/*
1: 		** If it's an interface, generate an interface method call, if it's a static,
1: 		** generate a static method call, otherwise generate a regular method call.
1: 		*/
1: 
1: 		short methodType;
1: 
1: 		if (declaringClass.isInterface())
1: 			methodType = VMOpcode.INVOKEINTERFACE;
1: 		else if (isStatic)
1: 			methodType = VMOpcode.INVOKESTATIC;
1: 		else
1: 			methodType = VMOpcode.INVOKEVIRTUAL;
1: 
1: 		getReceiverExpression(acb, mb, receiver);
1: 		if (isStatic)
1: 			mb.endStatement(); // PUSHCOMPILER ???
1: 
1: 		int nargs = generateParameters(acb, mb);
1: 
1: 		mb.callMethod(methodType, declaringClass.getName(), methodName, getJavaTypeName(), nargs);
1: 
1: 		if (inConditional)
1: 			mb.completeConditional();
1: 	}
1: 
1: 	/**
1: 	 * Generate the expression that evaluates to the receiver. This is
1: 	 * for the case where a java expression is being returned to the SQL
1: 	 * domain, and we need to check whether the receiver is null (if so,
1: 	 * the SQL value should be set to null, and this Java expression
1: 	 * not evaluated). Instance method calls and field references have
1: 	 * receivers, while class method calls and calls to constructors do
1: 	 * not. If this Java expression does not have a receiver, this method
1: 	 * returns null.
1: 	 *
1: 	 * Only generate the receiver once and cache it in a field. This is
1: 	 * because there will be two references to the receiver, and we want
1: 	 * to evaluate it only once.
1: 	 *
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb	The method the expression will go into
1: 	 *
1: 	 * @return		true if compiled receiver, false otherwise.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	protected boolean generateReceiver(ExpressionClassBuilder acb,
1: 											MethodBuilder mb)
1: 									throws StandardException
1: 	{
1: 		/*
1: 		** Let's pretend that a call to a static method doesn't have a
1: 		** receiver, since the method call is actually to the class,
1: 		** and can be made even if the receiver is null (that is, we
1: 		** always want to call a static method, even if the receiver is null).
1: 		*/
1: 		if (isStatic)
1: 			return false;
1: 		
1: 		return generateReceiver(acb, mb, receiver);
1: 	}
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		if (v.skipChildren(this))
1: 		{
0: 			return v.visit(this);
1: 		}
1: 
0: 		Visitable returnNode = super.accept(v);
1: 
0: 		if (receiver != null && !v.stopTraversal())
1: 		{
1: 			receiver = (JavaValueNode)receiver.accept(v);
1: 		}
1: 
0: 		return returnNode;
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: 
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.types.JSQLType;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import org.apache.derby.catalog.AliasInfo;
0: 
0: import java.lang.reflect.Modifier;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * A NonStaticMethodCallNode is really a node to represent a (static or non-static)
0:  * method call from an object (as opposed to a static method call from a class.
0:  */
0: public class NonStaticMethodCallNode extends MethodCallNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/*
0: 	** The receiver for a non-static method call is an object, represented
0: 	** by a ValueNode.
0: 	*/
0: 	JavaValueNode	receiver;	
0: 
0: 	/* Is this a static method call? Assume non-static call */
0: 	private boolean isStatic;
0: 
0: 	/**
0: 	 * Initializer for a NonStaticMethodCallNode
0: 	 *
0: 	 * @param methodName	The name of the method to call
0: 	 * @param receiver		A JavaValueNode representing the receiving object
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(
0: 							Object methodName,
0: 							Object receiver)
0: 			throws StandardException
0: 	{
0: 		super.init(methodName);
0: 
0: 		/*
0: 		** If the receiver is a Java value that has been converted to a
0: 		** SQL value, get rid of the conversion and just use the Java value
0: 		** as-is.  If the receiver is a "normal" SQL value, then convert
0: 		** it to a Java value to use as the receiver.
0: 		*/
0: 		if (receiver instanceof JavaToSQLValueNode)
0: 		{
0: 			this.receiver = ((JavaToSQLValueNode) receiver).
0: 										getJavaValueNode();
0: 		}
0: 		else
0: 		{
0: 			this.receiver = (JavaValueNode) getNodeFactory().
0: 								getNode(
0: 									C_NodeTypes.SQL_TO_JAVA_VALUE_NODE,
0: 									receiver,
0: 									getContextManager());
0: //            System.out.println("NonStaticMethodCallNode.init() receiver = "+receiver);
0: // get nulpointer because not .bind?
0: //            System.out.println("\ttypecompiler = "+((ValueNode)receiver).getTypeCompiler());
0: //            System.out.println("\tdtd = "+((ValueNode)receiver).getTypeServices());
0: //            System.out.println("\ttypeid = "+((ValueNode)receiver).getTypeServices().getTypeId());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind this expression.  This means binding the sub-expressions,
0: 	 * as well as figuring out what the return type is for this expression.
0: 	 *
0: 	 * @param fromList		The FROM list for the query this
0: 	 *				expression is in, for binding columns.
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return	this
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public JavaValueNode bindExpression(
0: 		FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector) 
0: 			throws StandardException
0: 	{
0: 		boolean		nullParameter = false;
0: 		String[]	parmTypeNames;
0: 
0: 		/* NULL and ? not allowed as receivers */
0: 		if (receiver instanceof SQLToJavaValueNode)
0: 		{
0: 			ValueNode	SQLValue =
0: 							((SQLToJavaValueNode) receiver).getSQLValueNode();
0: 
0: 			if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!(SQLValue instanceof UntypedNullConstantNode),
0: 				"UntypedNullConstantNode found as a receiver of a non-static method call");
0: 
0: 			//
0: 			//	We don't allow methods off of naked unnamed "?" parameters.
0: 			//	This is because we have no way of knowing the data type of
0: 			//	a naked "?" parameter.
0: 			//
0: 			//	However, if this "?" has actually been associated with a
0: 			//	named "?paramName" parameter in a COPY PUBLICATION statement,
0: 			//	then we have a type for it. Binding can continue.
0: 			//
0: 
0: 			if (SQLValue.isParameterNode())
0: 			{
0: 				ParameterNode	unnamedParameter = (ParameterNode) SQLValue;
0: 
0: 				if ( unnamedParameter.getTypeServices() == null )
0: 				{ throw StandardException.newException(SQLState.LANG_PARAMETER_RECEIVER, methodName); }
0: 			}
0: 		}
0: 
0: 		bindParameters(fromList, subqueryList, aggregateVector);
0: 
0: 		/* Now we don't allow an alias static method call here (that has to
0: 		 * use :: sign for any static call).  If it gets here, it can't be
0: 		 * alias static method call.
0: 		 */
0: 		receiver = receiver.bindExpression(fromList, subqueryList, aggregateVector);
0: 
0:         // Don't allow LOB types to be used as a method receiver
0:         String type = receiver.getJSQLType().getSQLType().getTypeId().getSQLTypeName();
0:         if ( type.equals("BLOB") || type.equals("CLOB") || type.equals("NCLOB") ) {
0:             throw StandardException.newException(SQLState.LOB_AS_METHOD_ARGUMENT_OR_RECEIVER);
0:         }
0: 
0: 		javaClassName = receiver.getJavaTypeName();
0: 
0: 		/* Not allowed to use a primitive type as a method receiver */
0: 		if (ClassInspector.primitiveType(javaClassName))
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_PRIMITIVE_RECEIVER, methodName, javaClassName);
0: 		}
0: 
0: 		/* Resolve the method call */
0: 		resolveMethodCall(javaClassName, false);
0: 
0: 		/* Remember if method is static */
0: 		isStatic = Modifier.isStatic(method.getModifiers());
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Categorize this predicate.  Initially, this means
0: 	 * building a bit map of the referenced tables for each predicate.
0: 	 * If the source of this ColumnReference (at the next underlying level) 
0: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
0: 	 * will not be pushed down.
0: 	 *
0: 	 * For example, in:
0: 	 *		select * from (select 1 from s) a (x) where x = 1
0: 	 * we will not push down x = 1.
0: 	 * NOTE: It would be easy to handle the case of a constant, but if the
0: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
0: 	 * that tree into the pushed predicate, and that tree could contain
0: 	 * subqueries and method calls.
0: 	 * RESOLVE - revisit this issue once we have views.
0: 	 *
0: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
0: 	 * @param simplePredsOnly	Whether or not to consider method
0: 	 *							calls, field references and conditional nodes
0: 	 *							when building bit map
0: 	 *
0: 	 * @return boolean		Whether or not source.expression is a ColumnReference
0: 	 *						or a VirtualColumnNode.
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
0: 		throws StandardException
0: 	{
0: 		/* We stop here when only considering simple predicates
0: 		 *  as we don't consider method calls when looking
0: 		 * for null invariant predicates.
0: 		 */
0: 		if (simplePredsOnly)
0: 		{
0: 			return false;
0: 		}
0: 
0: 		boolean pushable = true;
0: 
0: 		pushable = pushable && super.categorize(referencedTabs, simplePredsOnly);
0: 
0: 		if (receiver != null)
0: 		{
0: 			pushable = pushable && receiver.categorize(referencedTabs, simplePredsOnly);
0: 		}
0: 
0: 		return pushable;
0: 	}
0: 
0: 	/**
0: 	 * Return the variant type for the underlying expression.
0: 	 * The variant type can be:
0: 	 *		VARIANT				- variant within a scan
0: 	 *							  (non-static field access)
0: 	 *		SCAN_INVARIANT		- invariant within a scan
0: 	 *							  (column references from outer tables)
0: 	 *		QUERY_INVARIANT		- invariant within the life of a query
0: 	 *							  (constant expressions)
0: 	 *
0: 	 * @return	The variant type for the underlying expression.
0: 	 */
0: 	protected int getOrderableVariantType() throws StandardException
0: 	{
0: 		int receiverVariant = receiver.getOrderableVariantType();
0: 
0: 		if (receiverVariant > Qualifier.SCAN_INVARIANT) {
0: 			
0: 			// If the method call is related to a trigger then the return
0: 			// values are SCAN_INVARIANT even though their calls look QUERY_INVARIANT
0: 			// because they take no parameters.
0: 			if (receiver.getJavaTypeName().equals("org.apache.derby.iapi.db.TriggerExecutionContext"))
0: 				receiverVariant = Qualifier.SCAN_INVARIANT;
0: 		}
0: 
0: 
0: 		int thisVariant = super.getOrderableVariantType();
0: 		if (receiverVariant < thisVariant)	//return the more variant one
0: 			return receiverVariant;
0: 		return thisVariant;
0: 	}
0: 
0: 	/**
0: 	 * Remap all ColumnReferences in this tree to be clones of the
0: 	 * underlying expression.
0: 	 *
0: 	 * @return JavaValueNode			The remapped expression tree.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public JavaValueNode remapColumnReferencesToExpressions()
0: 		throws StandardException
0: 	{
0: 		if (receiver != null)
0: 		{
0: 			receiver.remapColumnReferencesToExpressions();
0: 		}
0: 
0: 		return super.remapColumnReferencesToExpressions();
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			int	parm;
0: 
0: 			super.printSubNodes(depth);
0: 			if (receiver != null)
0: 			{
0: 				printLabel(depth, "receiver :");
0: 				receiver.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Preprocess an expression tree.  We do a number of transformations
0: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
0: 	 * subquery flattening.
0: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
0: 	 *
0: 	 * @param	numTables			Number of tables in the DML Statement
0: 	 * @param	outerFromList		FromList from outer query block
0: 	 * @param	outerSubqueryList	SubqueryList from outer query block
0: 	 * @param	outerPredicateList	PredicateList from outer query block
0: 	 *
0: 	 * @return	Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void preprocess(int numTables,
0: 							FromList outerFromList,
0: 							SubqueryList outerSubqueryList,
0: 							PredicateList outerPredicateList) 
0: 							throws StandardException
0: 	{
0: 		super.preprocess(numTables,
0: 						 outerFromList, outerSubqueryList,
0: 						 outerPredicateList);
0: 		receiver.preprocess(numTables,
0: 							outerFromList, outerSubqueryList,
0: 							outerPredicateList);
0: 
0: 	}
0: 
0: 	/**
0: 	 * Do code generation for this method call
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		boolean inConditional = false;
0: 		/*
0: 		** If this method returns its value to the Java domain,
0: 		** generate the receiver and put the value in a field (only if
0: 		** this method does not return a primitive type).  If it
0: 		** returns its value to the SQL domain, it's up to the JavaToSQLNode
0: 		** to call generateReceiver().
0: 		**
0: 		** Also, don't do this if the return value from this method
0: 		** call will be discarded.  This is the case for a CALL statement.
0: 		** One reason we don't want to do this for a CALL statement
0: 		** is that the ?: operator cannot be made into a statement.
0: 		*/
0: 		if ( ( ! valueReturnedToSQLDomain()) && ( ! returnValueDiscarded()))
0: 		{
0: 			if (generateReceiver(acb, mb, receiver))
0: 			{
0: 				/*
0: 				** If the above did generate the expression, let's test it for
0: 				** a null value.
0: 				*/
0: 				/*
0: 				** Generate the following to test for null:
0: 				**
0: 				**		(receiverExpression == null) ?
0: 				*/
0: 
0: 				inConditional = true;
0: 				mb.conditionalIfNull();
0: 				mb.pushNull(getJavaTypeName());
0: 				mb.startElseCode();
0: 			}
0: 		}
0: 
0: 		/*
0: 		** Generate the following:
0: 		**
0: 		** <receiver>.<method name>(<param> (, <param> )* )
0: 		**
0: 		** for non-static calls.
0: 		**
0: 		** Refer to the field holding the receiver, if there is any.
0: 		*/
0: 
0: 		Class declaringClass = method.getDeclaringClass();
0: 		
0: 		/*
0: 		** If it's an interface, generate an interface method call, if it's a static,
0: 		** generate a static method call, otherwise generate a regular method call.
0: 		*/
0: 
0: 		short methodType;
0: 
0: 		if (declaringClass.isInterface())
0: 			methodType = VMOpcode.INVOKEINTERFACE;
0: 		else if (isStatic)
0: 			methodType = VMOpcode.INVOKESTATIC;
0: 		else
0: 			methodType = VMOpcode.INVOKEVIRTUAL;
0: 
0: 		getReceiverExpression(acb, mb, receiver);
0: 		if (isStatic)
0: 			mb.endStatement(); // PUSHCOMPILER ???
0: 
0: 		int nargs = generateParameters(acb, mb);
0: 
0: 		mb.callMethod(methodType, declaringClass.getName(), methodName, getJavaTypeName(), nargs);
0: 
0: 		if (inConditional)
0: 			mb.completeConditional();
0: 	}
0: 
0: 	/**
0: 	 * Generate the expression that evaluates to the receiver. This is
0: 	 * for the case where a java expression is being returned to the SQL
0: 	 * domain, and we need to check whether the receiver is null (if so,
0: 	 * the SQL value should be set to null, and this Java expression
0: 	 * not evaluated). Instance method calls and field references have
0: 	 * receivers, while class method calls and calls to constructors do
0: 	 * not. If this Java expression does not have a receiver, this method
0: 	 * returns null.
0: 	 *
0: 	 * Only generate the receiver once and cache it in a field. This is
0: 	 * because there will be two references to the receiver, and we want
0: 	 * to evaluate it only once.
0: 	 *
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 * @return		true if compiled receiver, false otherwise.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected boolean generateReceiver(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		/*
0: 		** Let's pretend that a call to a static method doesn't have a
0: 		** receiver, since the method call is actually to the class,
0: 		** and can be made even if the receiver is null (that is, we
0: 		** always want to call a static method, even if the receiver is null).
0: 		*/
0: 		if (isStatic)
0: 			return false;
0: 		
0: 		return generateReceiver(acb, mb, receiver);
0: 	}
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		if (v.skipChildren(this))
0: 		{
0: 			return v.visit(this);
0: 		}
0: 
0: 		Visitable returnNode = super.accept(v);
0: 
0: 		if (receiver != null && !v.stopTraversal())
0: 		{
0: 			receiver = (JavaValueNode)receiver.accept(v);
0: 		}
0: 
0: 		return returnNode;
0: 	}
0: }
============================================================================