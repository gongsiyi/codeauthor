1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.compile.Optimizable
1:7ecc1f2: 
1:d4580ab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:d4580ab:    contributor license agreements.  See the NOTICE file distributed with
1:d4580ab:    this work for additional information regarding copyright ownership.
1:d4580ab:    The ASF licenses this file to you under the Apache License, Version 2.0
1:d4580ab:    (the "License"); you may not use this file except in compliance with
1:d4580ab:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.sql.compile;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
1:eac0369: import java.util.Properties;
1:eac0369: 
1:eac0369: /**
1:eac0369:  * Optimizable provides services for optimizing a table in a query.
1:eac0369:  */
1:eac0369: 
1:05623b6: public interface Optimizable extends Visitable {
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Choose the next access path to evaluate for this Optimizable.
1:eac0369: 	 *
1:eac0369: 	 * @param optimizer	Optimizer to use.
1:eac0369: 	 * @param predList	The predicate list for this optimizable.
1:eac0369: 	 *					The optimizer always passes null, and it is up
1:eac0369: 	 *					to the optimizable object to pass along its
1:eac0369: 	 *					own predicate list, if appropriate, when delegating
1:eac0369: 	 *					this method.
1:eac0369: 	 * @param rowOrdering	The row ordering for all the outer tables in
1:eac0369: 	 *						the join order.  This method will add the ordering
1:eac0369: 	 *						of the next access path to the given RowOrdering.
1:eac0369: 	 *
1:eac0369: 	 * @return	true means another access path was chosen, false means
1:eac0369: 	 *			no more access paths to evaluate.
1:eac0369: 	 *
2:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	boolean nextAccessPath(Optimizer optimizer,
1:eac0369: 							OptimizablePredicateList predList,
1:eac0369: 							RowOrdering rowOrdering)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Choose the best access path for this Optimizable.
1:eac0369: 	 *
1:eac0369: 	 * @param optimizer	Optimizer to use.
1:eac0369: 	 * @param predList	The predicate list to optimize against
1:eac0369: 	 * @param outerCost	The CostEstimate for the outer tables in the join order,
1:eac0369: 	 *					telling how many times this Optimizable will be scanned.
1:eac0369: 	 * @param	rowOrdering The row ordering for all the tables in the
1:eac0369: 	 *						join order, including this one.
1:eac0369: 	 *
1:eac0369: 	 * @return The optimizer's estimated cost of the best access path.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	CostEstimate optimizeIt(
1:eac0369: 					Optimizer optimizer,
1:eac0369: 					OptimizablePredicateList predList,
1:eac0369: 					CostEstimate outerCost,
1:eac0369: 					RowOrdering rowOrdering)
1:eac0369: 				throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the current access path under consideration for this Optimizable
1:eac0369: 	 */
1:eac0369: 	AccessPath getCurrentAccessPath();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the best access path for this Optimizable.
1:eac0369: 	 */
1:eac0369: 	AccessPath getBestAccessPath();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the best sort-avoidance path for this Optimizable.
1:eac0369: 	 */
1:eac0369: 	AccessPath getBestSortAvoidancePath();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the best access path overall for this Optimizable.
1:eac0369: 	 */
1:eac0369: 	AccessPath getTrulyTheBestAccessPath();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark this optimizable so that its sort avoidance path will be
1:eac0369: 	 * considered.
1:eac0369: 	 */
1:eac0369: 	void rememberSortAvoidancePath();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check whether this optimizable's sort avoidance path should
1:eac0369: 	 * be considered.
1:eac0369: 	 */
1:eac0369: 	boolean considerSortAvoidancePath();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remember the current join strategy as the best one so far in this
1:eac0369: 	 * join order.
1:eac0369: 	 */
1:eac0369: 	void rememberJoinStrategyAsBest(AccessPath ap);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the table descriptor for this table (if any).  Only base tables
1:eac0369: 	 * have table descriptors - for the rest of the optimizables, this
1:eac0369: 	 * method returns null.
1:eac0369: 	 */
1:eac0369: 	TableDescriptor getTableDescriptor();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the map of referenced tables for this Optimizable.
1:eac0369: 	 *
1:eac0369: 	 * @return JBitSet	Referenced table map.
1:eac0369: 	 */
1:eac0369: 	JBitSet getReferencedTableMap();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Push an OptimizablePredicate down, if this node accepts it.
1:eac0369: 	 *
1:6b50965: 	 * @param optimizablePredicate	OptimizablePredicate to push down.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not the predicate was pushed down.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Pull all the OptimizablePredicates from this Optimizable and put them
1:eac0369: 	 * in the given OptimizablePredicateList.
1:eac0369: 	 *
1:eac0369: 	 * @param optimizablePredicates		The list to put the pulled predicates
1:eac0369: 	 *									in.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void pullOptPredicates(OptimizablePredicateList optimizablePredicates)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Modify the access path for this Optimizable, as necessary.  This includes
1:eac0369: 	 * things like adding a result set to translate from index rows to base rows
1:eac0369: 	 *
1:eac0369: 	 * @param outerTables	Bit map of the tables that are outer to this one
1:eac0369: 	 *						in the join order.
1:eac0369: 	 * 
1:eac0369: 	 * @return	The (potentially new) Optimizable at the top of the tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not this is a covering index.  We expect to call this
1:eac0369: 	 * during generation, after access path selection is complete.
1:eac0369: 	 *
1:eac0369: 	 * @param cd			ConglomerateDesriptor for index to consider
1:eac0369: 	 *
1:eac0369: 	 * @return boolean		Whether or not this is a covering index.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean isCoveringIndex(ConglomerateDescriptor cd) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:c7248d5: 	 * Get the Properties list, if any, associated with this optimizable.
1:eac0369: 	 *
1:eac0369: 	 * @return The Properties list, if any, associated with this optimizable.
1:eac0369: 	 */
1:eac0369: 	public Properties getProperties();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the Properties list for this optimizalbe.
1:eac0369: 	 *
1:eac0369: 	 * @param tableProperties The Properties list for this optimizable.
1:eac0369: 	 */
1:eac0369: 	public void setProperties(Properties tableProperties);
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Verify that the Properties list with optimizer overrides, if specified, is valid
1:eac0369: 	 *
1:eac0369: 	 * @param dDictionary	The DataDictionary  to use.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void verifyProperties(DataDictionary dDictionary) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the (exposed) name of this Optimizable
1:eac0369: 	 *
1:eac0369: 	 * @return	The name of this Optimizable.
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public String getName() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the table name of this Optimizable.  Only base tables have
1:eac0369: 	 * table names (by the time we use this method, all views will have
1:eac0369: 	 * been resolved).
1:eac0369: 	 */
1:eac0369: 	public String getBaseTableName();
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 *  Convert an absolute to a relative 0-based column position.
1:eac0369: 	 *  This is useful when generating qualifiers for partial rows 
1:eac0369: 	 *  from the store.
1:eac0369: 	 *
1:eac0369: 	 * @param absolutePosition	The absolute 0-based column position for the column.
1:eac0369: 	 *
1:eac0369: 	 *  @return The relative 0-based column position for the column.
1:eac0369: 	 */
1:eac0369: 	public int convertAbsoluteToRelativeColumnPosition(int absolutePosition);
1:eac0369: 
1:eac0369: 	/**
1:62d4560: 	 * When remembering "truly the best" access path for an Optimizable, we
1:62d4560: 	 * have to keep track of which OptimizerImpl the "truly the best" access
1:62d4560: 	 * is for.  In most queries there will only be one OptimizerImpl in
1:62d4560: 	 * question, but in cases where there are nested subqueries, there will be
1:62d4560: 	 * one OptimizerImpl for every level of nesting, and each OptimizerImpl
1:62d4560: 	 * might have its own idea of what this Optimizable's "truly the best path"
1:e07631a: 	 * access path really is.  In addition, there could be Optimizables
1:e07631a: 	 * above this Optimizable that might need to override the best path
1:e07631a: 	 * chosen during optimization.  So whenever we save a "truly the best" path,
1:e07631a: 	 * we take note of which Optimizer/Optimizable told us to do so.  Then
1:e07631a: 	 * as each level of subquery finishes optimization, the corresponding
1:e07631a: 	 * OptimizerImpl/Optimizable can load its preferred access path into this
1:e07631a: 	 * Optimizable's trulyTheBestAccessPath field and pass it up the tree, until
1:e07631a: 	 * eventually the outer-most OptimizerImpl can choose to either use the best
1:e07631a: 	 * path that it received from below (by calling "rememberAsBest()") or else
1:62d4560: 	 * use the path that it found to be "best" for itself.
1:eac0369: 	 *
1:e07631a: 	 * This method is what allows us to keep track of which OptimizerImpl or
1:e07631a: 	 * Optimizable saved which "best plan", and allows us to load the
1:e07631a: 	 * appropriate plans after each round of optimization.
2:62d4560: 	 * 
1:acdff3c: 	 * @param action Indicates whether we're adding, loading, or removing
1:acdff3c: 	 *  a best plan for the OptimizerImpl/Optimizable.
1:e07631a: 	 * @param planKey Object to use as the map key when adding/looking up
1:e07631a: 	 *  a plan.  If it is an instance of OptimizerImpl then it corresponds
1:e07631a: 	 *  to an outer query; otherwise it's some Optimizable above this
1:e07631a: 	 *  Optimizable that could potentially reject plans chosen by the
1:e07631a: 	 *  OptimizerImpl to which this Optimizable belongs.
1:eac0369: 	 */
1:acdff3c: 	public void updateBestPlanMap(short action,
1:e07631a: 		Object planKey) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remember the current access path as the best one (so far).
1:eac0369: 	 *
1:eac0369: 	 * @param planType	The type of plan (one of Optimizer.NORMAL_PLAN
1:eac0369: 	 *					or Optimizer.SORT_AVOIDANCE_PLAN)
1:62d4560: 	 * @param optimizer The OptimizerImpl that is telling this Optimizable
1:62d4560: 	 *	to remember its current path as "truly the best".
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error.
1:eac0369: 	 */
1:62d4560: 	public void rememberAsBest(int planType, Optimizer optimizer)
1:62d4560: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Begin the optimization process for this Optimizable.  This can be
1:eac0369: 	 * called many times for an Optimizable while optimizing a query -
1:eac0369: 	 * it will typically be called every time the Optimizable is placed
1:eac0369: 	 * in a potential join order.
1:eac0369: 	 */
1:eac0369: 	public void startOptimizing(Optimizer optimizer, RowOrdering rowOrdering);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Estimate the cost of scanning this Optimizable using the given
1:eac0369: 	 * predicate list with the given conglomerate.  It is assumed that the
1:eac0369: 	 * predicate list has already been classified.  This cost estimate is
1:eac0369: 	 * just for one scan, not for the life of the query.
1:eac0369: 	 *
1:eac0369: 	 * @see OptimizablePredicateList#classify
1:eac0369: 	 *
1:eac0369: 	 * @param	predList	The predicate list to optimize against
1:eac0369: 	 * @param	cd			The conglomerate descriptor to get the cost of
1:eac0369: 	 * @param	outerCost	The estimated cost of the part of the plan outer
1:eac0369: 	 *						to this optimizable.
1:eac0369: 	 * @param	optimizer	The optimizer to use to help estimate the cost
1:eac0369: 	 * @param	rowOrdering The row ordering for all the tables in the
1:eac0369: 	 *						join order, including this one.
1:eac0369: 	 *
1:eac0369: 	 * @return	The estimated cost of doing the scan
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	CostEstimate estimateCost(OptimizablePredicateList predList,
1:eac0369: 								ConglomerateDescriptor cd,
1:eac0369: 								CostEstimate outerCost,
1:eac0369: 								Optimizer optimizer,
1:eac0369: 								RowOrdering rowOrdering)
1:eac0369: 					throws StandardException;
1:eac0369: 
1:eac0369: 	/** Tell whether this Optimizable represents a base table */
1:eac0369: 	boolean isBaseTable();
1:eac0369: 
1:eac0369: 	/** Tell whether this Optimizable is materializable 
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	boolean isMaterializable() throws StandardException;
1:eac0369: 
1:eac0369: 	/** Tell whether this Optimizable can be instantiated multiple times */
1:eac0369: 	boolean supportsMultipleInstantiations();
1:eac0369: 
1:ec6fcf1:     /** Tell whether this Optimizable has any large object (LOB) columns. */
1:ec6fcf1:     boolean hasLargeObjectColumns();
1:ec6fcf1: 
1:eac0369: 	/** Get this Optimizable's result set number */
1:eac0369: 	int getResultSetNumber();
1:eac0369: 
1:eac0369: 	/** Get this Optimizable's table number */
1:eac0369: 	int getTableNumber();
1:eac0369: 
1:eac0369: 	/** Return true if this Optimizable has a table number */
1:eac0369: 	boolean hasTableNumber();
1:eac0369: 
1:eac0369: 	/** Return true if this is the target table of an update */
1:eac0369: 	public boolean forUpdate();
1:eac0369: 
1:eac0369: 	/** Return the initial capacity of the hash table, for hash join strategy */
1:eac0369: 	public int initialCapacity();
1:eac0369: 
1:eac0369: 	/** Return the load factor of the hash table, for hash join strategy */
1:eac0369: 	public float loadFactor();
1:eac0369: 
1:eac0369: 	/** Return the hash key column numbers, for hash join strategy */
1:eac0369: 	public int[] hashKeyColumns();
1:eac0369: 
1:eac0369: 	/** Set the hash key column numbers, for hash join strategy */
1:eac0369: 	public void setHashKeyColumns(int[] columnNumbers);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is the current proposed join strategy for this optimizable feasible
1:eac0369: 	 * given the predicate list?
1:eac0369: 	 *
1:eac0369: 	 * @param predList	The predicate list that has been pushed down to
1:eac0369: 	 *					this optimizable
1:eac0369: 	 * @param optimizer	The optimizer to use.
1:eac0369: 	 *
1:eac0369: 	 * @return	true means feasible
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean feasibleJoinStrategy(OptimizablePredicateList predList,
1:eac0369: 										Optimizer optimizer)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:b223f72:      * @param rowCount
1:b223f72:      * @param maxMemoryPerTable
1:b223f72:      * @return true if the memory usage of the proposed access path is OK, false if not.
1:eac0369:      *
1:b223f72:      * @exception StandardException standard error policy
1:eac0369:      */
1:b223f72:     public boolean memoryUsageOK( double rowCount, int maxMemoryPerTable)
1:b223f72: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:b223f72:      * Return the maximum capacity of the hash table, for hash join strategy
1:eac0369:      *
1:b223f72:      * @param maxMemoryPerTable The maximum number of bytes to be used. Ignored if the user has set a maximum
1:b223f72:      *                          number of rows for the Optimizable.
1:eac0369:      *
1:b223f72:      * @exception StandardException Standard error policy
1:62d4560:      */
1:b223f72: 	public int maxCapacity( JoinStrategy joinStrategy, int maxMemoryPerTable) throws StandardException;
1:eac0369: 
1:62d4560: 	/**
1:eac0369: 	 * Can this Optimizable appear at the current location in the join order.
1:eac0369: 	 * In other words, have the Optimizable's dependencies been satisfied?
1:eac0369: 	 *
1:eac0369: 	 * @param assignedTableMap	The tables that have been placed so far in the join order.
1:eac0369: 	 *
1:eac0369: 	 * @return	Where or not this Optimizable can appear at the current location in the join order.
1:eac0369: 	 */
1:eac0369: 	public boolean legalJoinOrder(JBitSet assignedTableMap);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the DataDictionary from this Optimizable.  This is useful for code generation
1:eac0369: 	 * because we need to get the constraint name if scanning a back index so that
1:eac0369: 	 * RunTimeStatistics can display the correct info.
1:eac0369: 	 *
1:eac0369: 	 * @return The DataDictionary to use.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public DataDictionary getDataDictionary() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is the optimizable the target table of an update or delete?
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not the optimizable the target table of an update or delete.
1:eac0369: 	 */
1:eac0369: 	public boolean isTargetTable();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the number of the number of columns returned by this Optimizable.
1:eac0369: 	 *
1:eac0369: 	 * @return The number of the number of columns returned by this Optimizable.
1:eac0369: 	 */
1:eac0369: 	public int getNumColumnsReturned();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Will the optimizable return at most 1 row per scan?
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not the optimizable will return at most 1 row per scan?
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean isOneRowScan() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Init the access paths for this optimizable.
1:eac0369: 	 *
1:eac0369: 	 * @param optimizer The optimizer being used.
1:eac0369: 	 */
1:eac0369: 	public void initAccessPaths(Optimizer optimizer);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Does this optimizable have a uniqueness condition on the
1:eac0369: 	 * given predicate list, and if so, how many unique keys will be
1:eac0369: 	 * returned per scan.
1:eac0369: 	 *
1:eac0369: 	 * @param predList		The predicate list to check
1:eac0369: 	 *
1:dbed020: 	 * @return	&lt;= 0 means there is no uniqueness condition
1:dbed020: 	 *			&gt; 0 means there is a uniqueness condition,
1:eac0369: 	 *			and the return value is the number of rows per scan.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public double uniqueJoin(OptimizablePredicateList predList)
1:eac0369: 								throws StandardException;
1:9881ca4: 
1:9881ca4:     /** Get the optimizer tracer, if any */
1:9881ca4:     public  OptTrace    getOptimizerTracer();
1:9881ca4:     
1:9881ca4:     /** Report whether optimizer tracing is on */
1:9881ca4:     public  boolean optimizerTracingIsOn();
1:9881ca4:     
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 * @return	&lt;= 0 means there is no uniqueness condition
1: 	 *			&gt; 0 means there is a uniqueness condition,
commit:9881ca4
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** Get the optimizer tracer, if any */
1:     public  OptTrace    getOptimizerTracer();
1:     
1:     /** Report whether optimizer tracing is on */
1:     public  boolean optimizerTracingIsOn();
1:     
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:05623b6
/////////////////////////////////////////////////////////////////////////
1: public interface Optimizable extends Visitable {
commit:ec6fcf1
/////////////////////////////////////////////////////////////////////////
1:     /** Tell whether this Optimizable has any large object (LOB) columns. */
1:     boolean hasLargeObjectColumns();
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:acdff3c
/////////////////////////////////////////////////////////////////////////
1: 	 * @param action Indicates whether we're adding, loading, or removing
1: 	 *  a best plan for the OptimizerImpl/Optimizable.
1: 	public void updateBestPlanMap(short action,
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.compile.Optimizable
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.compile;
1: 
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
1: 
1: import java.util.Properties;
1: 
1: /**
1:  * Optimizable provides services for optimizing a table in a query.
1:  */
1: 
0: public interface Optimizable {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/**
1: 	 * Choose the next access path to evaluate for this Optimizable.
1: 	 *
1: 	 * @param optimizer	Optimizer to use.
1: 	 * @param predList	The predicate list for this optimizable.
1: 	 *					The optimizer always passes null, and it is up
1: 	 *					to the optimizable object to pass along its
1: 	 *					own predicate list, if appropriate, when delegating
1: 	 *					this method.
1: 	 * @param rowOrdering	The row ordering for all the outer tables in
1: 	 *						the join order.  This method will add the ordering
1: 	 *						of the next access path to the given RowOrdering.
1: 	 *
1: 	 * @return	true means another access path was chosen, false means
1: 	 *			no more access paths to evaluate.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	boolean nextAccessPath(Optimizer optimizer,
1: 							OptimizablePredicateList predList,
1: 							RowOrdering rowOrdering)
1: 			throws StandardException;
1: 
1: 	/**
1: 	 * Choose the best access path for this Optimizable.
1: 	 *
1: 	 * @param optimizer	Optimizer to use.
1: 	 * @param predList	The predicate list to optimize against
1: 	 * @param outerCost	The CostEstimate for the outer tables in the join order,
1: 	 *					telling how many times this Optimizable will be scanned.
1: 	 * @param	rowOrdering The row ordering for all the tables in the
1: 	 *						join order, including this one.
1: 	 *
1: 	 * @return The optimizer's estimated cost of the best access path.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	CostEstimate optimizeIt(
1: 					Optimizer optimizer,
1: 					OptimizablePredicateList predList,
1: 					CostEstimate outerCost,
1: 					RowOrdering rowOrdering)
1: 				throws StandardException;
1: 
1: 	/**
1: 	 * Get the current access path under consideration for this Optimizable
1: 	 */
1: 	AccessPath getCurrentAccessPath();
1: 
1: 	/**
1: 	 * Get the best access path for this Optimizable.
1: 	 */
1: 	AccessPath getBestAccessPath();
1: 
1: 	/**
1: 	 * Get the best sort-avoidance path for this Optimizable.
1: 	 */
1: 	AccessPath getBestSortAvoidancePath();
1: 
1: 	/**
1: 	 * Get the best access path overall for this Optimizable.
1: 	 */
1: 	AccessPath getTrulyTheBestAccessPath();
1: 
1: 	/**
1: 	 * Mark this optimizable so that its sort avoidance path will be
1: 	 * considered.
1: 	 */
1: 	void rememberSortAvoidancePath();
1: 
1: 	/**
1: 	 * Check whether this optimizable's sort avoidance path should
1: 	 * be considered.
1: 	 */
1: 	boolean considerSortAvoidancePath();
1: 
1: 	/**
1: 	 * Remember the current join strategy as the best one so far in this
1: 	 * join order.
1: 	 */
1: 	void rememberJoinStrategyAsBest(AccessPath ap);
1: 
1: 	/**
1: 	 * Get the table descriptor for this table (if any).  Only base tables
1: 	 * have table descriptors - for the rest of the optimizables, this
1: 	 * method returns null.
1: 	 */
1: 	TableDescriptor getTableDescriptor();
1: 
1: 	/**
1: 	 * Get the map of referenced tables for this Optimizable.
1: 	 *
1: 	 * @return JBitSet	Referenced table map.
1: 	 */
1: 	JBitSet getReferencedTableMap();
1: 
1: 	/**
1: 	 * Push an OptimizablePredicate down, if this node accepts it.
1: 	 *
0: 	 * @param optPred	OptimizablePredicate to push down.
1: 	 *
1: 	 * @return Whether or not the predicate was pushed down.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
1: 			throws StandardException;
1: 
1: 	/**
1: 	 * Pull all the OptimizablePredicates from this Optimizable and put them
1: 	 * in the given OptimizablePredicateList.
1: 	 *
1: 	 * @param optimizablePredicates		The list to put the pulled predicates
1: 	 *									in.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void pullOptPredicates(OptimizablePredicateList optimizablePredicates)
1: 			throws StandardException;
1: 
1: 	/**
1: 	 * Modify the access path for this Optimizable, as necessary.  This includes
1: 	 * things like adding a result set to translate from index rows to base rows
1: 	 *
1: 	 * @param outerTables	Bit map of the tables that are outer to this one
1: 	 *						in the join order.
1: 	 * 
1: 	 * @return	The (potentially new) Optimizable at the top of the tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException;
1: 
1: 	/**
1: 	 * Return whether or not this is a covering index.  We expect to call this
1: 	 * during generation, after access path selection is complete.
1: 	 *
1: 	 * @param cd			ConglomerateDesriptor for index to consider
1: 	 *
1: 	 * @return boolean		Whether or not this is a covering index.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean isCoveringIndex(ConglomerateDescriptor cd) throws StandardException;
1: 
1: 	/**
0: 	 * Get the Properties list, if any, associated with this optimizalbe.
1: 	 *
1: 	 * @return The Properties list, if any, associated with this optimizable.
1: 	 */
1: 	public Properties getProperties();
1: 
1: 	/**
1: 	 * Set the Properties list for this optimizalbe.
1: 	 *
1: 	 * @param tableProperties The Properties list for this optimizable.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void setProperties(Properties tableProperties);
1: 
1: 	/** 
1: 	 * Verify that the Properties list with optimizer overrides, if specified, is valid
1: 	 *
1: 	 * @param dDictionary	The DataDictionary  to use.
1: 	 *
0: 	 * @return Nothing.
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void verifyProperties(DataDictionary dDictionary) throws StandardException;
1: 
1: 	/**
1: 	 * Get the (exposed) name of this Optimizable
1: 	 *
1: 	 * @return	The name of this Optimizable.
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public String getName() throws StandardException;
1: 
1: 	/**
1: 	 * Get the table name of this Optimizable.  Only base tables have
1: 	 * table names (by the time we use this method, all views will have
1: 	 * been resolved).
1: 	 */
1: 	public String getBaseTableName();
1: 
1: 	/** 
1: 	 *  Convert an absolute to a relative 0-based column position.
1: 	 *  This is useful when generating qualifiers for partial rows 
1: 	 *  from the store.
1: 	 *
1: 	 * @param absolutePosition	The absolute 0-based column position for the column.
1: 	 *
1: 	 *  @return The relative 0-based column position for the column.
1: 	 */
1: 	public int convertAbsoluteToRelativeColumnPosition(int absolutePosition);
1: 
1: 	/**
1: 	 * Remember the current access path as the best one (so far).
1: 	 *
1: 	 * @param planType	The type of plan (one of Optimizer.NORMAL_PLAN
1: 	 *					or Optimizer.SORT_AVOIDANCE_PLAN)
1: 	 *
1: 	 * @exception StandardException thrown on error.
1: 	 */
0: 	public void rememberAsBest(int planType) throws StandardException;
1: 
1: 	/**
1: 	 * Begin the optimization process for this Optimizable.  This can be
1: 	 * called many times for an Optimizable while optimizing a query -
1: 	 * it will typically be called every time the Optimizable is placed
1: 	 * in a potential join order.
1: 	 */
1: 	public void startOptimizing(Optimizer optimizer, RowOrdering rowOrdering);
1: 
1: 	/**
1: 	 * Estimate the cost of scanning this Optimizable using the given
1: 	 * predicate list with the given conglomerate.  It is assumed that the
1: 	 * predicate list has already been classified.  This cost estimate is
1: 	 * just for one scan, not for the life of the query.
1: 	 *
1: 	 * @see OptimizablePredicateList#classify
1: 	 *
1: 	 * @param	predList	The predicate list to optimize against
1: 	 * @param	cd			The conglomerate descriptor to get the cost of
1: 	 * @param	outerCost	The estimated cost of the part of the plan outer
1: 	 *						to this optimizable.
1: 	 * @param	optimizer	The optimizer to use to help estimate the cost
1: 	 * @param	rowOrdering The row ordering for all the tables in the
1: 	 *						join order, including this one.
1: 	 *
1: 	 * @return	The estimated cost of doing the scan
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	CostEstimate estimateCost(OptimizablePredicateList predList,
1: 								ConglomerateDescriptor cd,
1: 								CostEstimate outerCost,
1: 								Optimizer optimizer,
1: 								RowOrdering rowOrdering)
1: 					throws StandardException;
1: 
1: 	/** Tell whether this Optimizable represents a base table */
1: 	boolean isBaseTable();
1: 
1: 	/** Tell whether this Optimizable is materializable 
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	boolean isMaterializable() throws StandardException;
1: 
1: 	/** Tell whether this Optimizable can be instantiated multiple times */
1: 	boolean supportsMultipleInstantiations();
1: 
1: 	/** Get this Optimizable's result set number */
1: 	int getResultSetNumber();
1: 
1: 	/** Get this Optimizable's table number */
1: 	int getTableNumber();
1: 
1: 	/** Return true if this Optimizable has a table number */
1: 	boolean hasTableNumber();
1: 
1: 	/** Return true if this is the target table of an update */
1: 	public boolean forUpdate();
1: 
1: 	/** Return the initial capacity of the hash table, for hash join strategy */
1: 	public int initialCapacity();
1: 
1: 	/** Return the load factor of the hash table, for hash join strategy */
1: 	public float loadFactor();
1: 
0: 	/** Return the maximum capacity of the hash table, for hash join strategy */
0: 	public int maxCapacity();
1: 
1: 	/** Return the hash key column numbers, for hash join strategy */
1: 	public int[] hashKeyColumns();
1: 
1: 	/** Set the hash key column numbers, for hash join strategy */
1: 	public void setHashKeyColumns(int[] columnNumbers);
1: 
1: 	/**
1: 	 * Is the current proposed join strategy for this optimizable feasible
1: 	 * given the predicate list?
1: 	 *
1: 	 * @param predList	The predicate list that has been pushed down to
1: 	 *					this optimizable
1: 	 * @param optimizer	The optimizer to use.
1: 	 *
1: 	 * @return	true means feasible
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean feasibleJoinStrategy(OptimizablePredicateList predList,
1: 										Optimizer optimizer)
1: 			throws StandardException;
1: 
1: 	/**
0: 	 * What is the memory usage in bytes of the proposed access path for this
0: 	 * optimizable?
1: 	 *
0: 	 * @param rowCount	The estimated number of rows returned by a single
0: 	 *					scan of this optimizable
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public double memoryUsage(double rowCount) throws StandardException;
1: 
1: 	/**
1: 	 * Can this Optimizable appear at the current location in the join order.
1: 	 * In other words, have the Optimizable's dependencies been satisfied?
1: 	 *
1: 	 * @param assignedTableMap	The tables that have been placed so far in the join order.
1: 	 *
1: 	 * @return	Where or not this Optimizable can appear at the current location in the join order.
1: 	 */
1: 	public boolean legalJoinOrder(JBitSet assignedTableMap);
1: 
1: 	/**
1: 	 * Get the DataDictionary from this Optimizable.  This is useful for code generation
1: 	 * because we need to get the constraint name if scanning a back index so that
1: 	 * RunTimeStatistics can display the correct info.
1: 	 *
1: 	 * @return The DataDictionary to use.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public DataDictionary getDataDictionary() throws StandardException;
1: 
1: 	/**
1: 	 * Is the optimizable the target table of an update or delete?
1: 	 *
1: 	 * @return Whether or not the optimizable the target table of an update or delete.
1: 	 */
1: 	public boolean isTargetTable();
1: 
1: 	/**
1: 	 * Get the number of the number of columns returned by this Optimizable.
1: 	 *
1: 	 * @return The number of the number of columns returned by this Optimizable.
1: 	 */
1: 	public int getNumColumnsReturned();
1: 
1: 	/**
1: 	 * Will the optimizable return at most 1 row per scan?
1: 	 *
1: 	 * @return Whether or not the optimizable will return at most 1 row per scan?
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean isOneRowScan() throws StandardException;
1: 
1: 	/**
1: 	 * Init the access paths for this optimizable.
1: 	 *
1: 	 * @param optimizer The optimizer being used.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void initAccessPaths(Optimizer optimizer);
1: 
1: 	/**
1: 	 * Does this optimizable have a uniqueness condition on the
1: 	 * given predicate list, and if so, how many unique keys will be
1: 	 * returned per scan.
1: 	 *
1: 	 * @param predList		The predicate list to check
1: 	 *
0: 	 * @return	<= 0 means there is no uniqueness condition
0: 	 *			> 0 means there is a uniqueness condition,
1: 	 *			and the return value is the number of rows per scan.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public double uniqueJoin(OptimizablePredicateList predList)
1: 								throws StandardException;
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:d4580ab
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param optimizablePredicate	OptimizablePredicate to push down.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:e07631a
/////////////////////////////////////////////////////////////////////////
1: 	 * access path really is.  In addition, there could be Optimizables
1: 	 * above this Optimizable that might need to override the best path
1: 	 * chosen during optimization.  So whenever we save a "truly the best" path,
1: 	 * we take note of which Optimizer/Optimizable told us to do so.  Then
1: 	 * as each level of subquery finishes optimization, the corresponding
1: 	 * OptimizerImpl/Optimizable can load its preferred access path into this
1: 	 * Optimizable's trulyTheBestAccessPath field and pass it up the tree, until
1: 	 * eventually the outer-most OptimizerImpl can choose to either use the best
1: 	 * path that it received from below (by calling "rememberAsBest()") or else
1: 	 * This method is what allows us to keep track of which OptimizerImpl or
1: 	 * Optimizable saved which "best plan", and allows us to load the
1: 	 * appropriate plans after each round of optimization.
0: 	 * @param doAdd True if we're saving a best plan for the OptimizerImpl/
0: 	 *  Optimizable; false if we're loading/retrieving the best plan.
1: 	 * @param planKey Object to use as the map key when adding/looking up
1: 	 *  a plan.  If it is an instance of OptimizerImpl then it corresponds
1: 	 *  to an outer query; otherwise it's some Optimizable above this
1: 	 *  Optimizable that could potentially reject plans chosen by the
1: 	 *  OptimizerImpl to which this Optimizable belongs.
1: 		Object planKey) throws StandardException;
commit:62d4560
/////////////////////////////////////////////////////////////////////////
1: 	 * When remembering "truly the best" access path for an Optimizable, we
1: 	 * have to keep track of which OptimizerImpl the "truly the best" access
1: 	 * is for.  In most queries there will only be one OptimizerImpl in
1: 	 * question, but in cases where there are nested subqueries, there will be
1: 	 * one OptimizerImpl for every level of nesting, and each OptimizerImpl
1: 	 * might have its own idea of what this Optimizable's "truly the best path"
0: 	 * access path really is.  So whenever we save a "truly the best" path,
0: 	 * we take note of which Optimizer told us to do so.  Then as each level
0: 	 * of subquery finishes optimization, the corresponding OptimizerImpl
0: 	 * can load its preferred access path into this Optimizable's
0: 	 * trulyTheBestAccessPath field and pass it up the tree, until eventually
0: 	 * the outer-most OptimizerImpl can choose to either use the best path
0: 	 * that it received from below (by calling "rememberAsBest()") or else
1: 	 * use the path that it found to be "best" for itself.
1: 	 *
0: 	 * This method is what allows us to keep track of which OptimizerImpl
0: 	 * saved which "best plan", and allows us to load the appropriate plans
0: 	 * after each round of optimization.
1: 	 * 
0: 	 * @param doAdd True if we're saving a best plan for the OptimizerImpl,
0: 	 *  false if we're loading/retrieving the best plan for the OptimizerImpl.
0: 	 * @param optimizer The OptimizerImpl for which we're saving/loading
0: 	 *  the "truly the best" path.
1: 	 */
0: 	public void addOrLoadBestPlanMapping(boolean doAdd,
0: 		Optimizer optimizer) throws StandardException;
0: 
1: 	/**
1: 	 * @param optimizer The OptimizerImpl that is telling this Optimizable
1: 	 *	to remember its current path as "truly the best".
1: 	public void rememberAsBest(int planType, Optimizer optimizer)
1: 		throws StandardException;
commit:c7248d5
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the Properties list, if any, associated with this optimizable.
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b223f72
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * @param rowCount
1:      * @param maxMemoryPerTable
1:      * @return true if the memory usage of the proposed access path is OK, false if not.
0:      *
1:      * @exception StandardException standard error policy
0:      */
1:     public boolean memoryUsageOK( double rowCount, int maxMemoryPerTable)
1: 			throws StandardException;
0: 
1:      * Return the maximum capacity of the hash table, for hash join strategy
0:      *
1:      * @param maxMemoryPerTable The maximum number of bytes to be used. Ignored if the user has set a maximum
1:      *                          number of rows for the Optimizable.
0:      *
1:      * @exception StandardException Standard error policy
0:      */
1: 	public int maxCapacity( JoinStrategy joinStrategy, int maxMemoryPerTable) throws StandardException;
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: 
0: import java.util.Properties;
0: 
0: /**
0:  * Optimizable provides services for optimizing a table in a query.
0:  */
0: 
0: public interface Optimizable {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/**
0: 	 * Choose the next access path to evaluate for this Optimizable.
0: 	 *
0: 	 * @param optimizer	Optimizer to use.
0: 	 * @param predList	The predicate list for this optimizable.
0: 	 *					The optimizer always passes null, and it is up
0: 	 *					to the optimizable object to pass along its
0: 	 *					own predicate list, if appropriate, when delegating
0: 	 *					this method.
0: 	 * @param rowOrdering	The row ordering for all the outer tables in
0: 	 *						the join order.  This method will add the ordering
0: 	 *						of the next access path to the given RowOrdering.
0: 	 *
0: 	 * @return	true means another access path was chosen, false means
0: 	 *			no more access paths to evaluate.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	boolean nextAccessPath(Optimizer optimizer,
0: 							OptimizablePredicateList predList,
0: 							RowOrdering rowOrdering)
0: 			throws StandardException;
0: 
0: 	/**
0: 	 * Choose the best access path for this Optimizable.
0: 	 *
0: 	 * @param optimizer	Optimizer to use.
0: 	 * @param predList	The predicate list to optimize against
0: 	 * @param outerCost	The CostEstimate for the outer tables in the join order,
0: 	 *					telling how many times this Optimizable will be scanned.
0: 	 * @param	rowOrdering The row ordering for all the tables in the
0: 	 *						join order, including this one.
0: 	 *
0: 	 * @return The optimizer's estimated cost of the best access path.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	CostEstimate optimizeIt(
0: 					Optimizer optimizer,
0: 					OptimizablePredicateList predList,
0: 					CostEstimate outerCost,
0: 					RowOrdering rowOrdering)
0: 				throws StandardException;
0: 
0: 	/**
0: 	 * Get the current access path under consideration for this Optimizable
0: 	 */
0: 	AccessPath getCurrentAccessPath();
0: 
0: 	/**
0: 	 * Get the best access path for this Optimizable.
0: 	 */
0: 	AccessPath getBestAccessPath();
0: 
0: 	/**
0: 	 * Get the best sort-avoidance path for this Optimizable.
0: 	 */
0: 	AccessPath getBestSortAvoidancePath();
0: 
0: 	/**
0: 	 * Get the best access path overall for this Optimizable.
0: 	 */
0: 	AccessPath getTrulyTheBestAccessPath();
0: 
0: 	/**
0: 	 * Mark this optimizable so that its sort avoidance path will be
0: 	 * considered.
0: 	 */
0: 	void rememberSortAvoidancePath();
0: 
0: 	/**
0: 	 * Check whether this optimizable's sort avoidance path should
0: 	 * be considered.
0: 	 */
0: 	boolean considerSortAvoidancePath();
0: 
0: 	/**
0: 	 * Remember the current join strategy as the best one so far in this
0: 	 * join order.
0: 	 */
0: 	void rememberJoinStrategyAsBest(AccessPath ap);
0: 
0: 	/**
0: 	 * Get the table descriptor for this table (if any).  Only base tables
0: 	 * have table descriptors - for the rest of the optimizables, this
0: 	 * method returns null.
0: 	 */
0: 	TableDescriptor getTableDescriptor();
0: 
0: 	/**
0: 	 * Get the map of referenced tables for this Optimizable.
0: 	 *
0: 	 * @return JBitSet	Referenced table map.
0: 	 */
0: 	JBitSet getReferencedTableMap();
0: 
0: 	/**
0: 	 * Push an OptimizablePredicate down, if this node accepts it.
0: 	 *
0: 	 * @param optPred	OptimizablePredicate to push down.
0: 	 *
0: 	 * @return Whether or not the predicate was pushed down.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
0: 			throws StandardException;
0: 
0: 	/**
0: 	 * Pull all the OptimizablePredicates from this Optimizable and put them
0: 	 * in the given OptimizablePredicateList.
0: 	 *
0: 	 * @param optimizablePredicates		The list to put the pulled predicates
0: 	 *									in.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void pullOptPredicates(OptimizablePredicateList optimizablePredicates)
0: 			throws StandardException;
0: 
0: 	/**
0: 	 * Modify the access path for this Optimizable, as necessary.  This includes
0: 	 * things like adding a result set to translate from index rows to base rows
0: 	 *
0: 	 * @param outerTables	Bit map of the tables that are outer to this one
0: 	 *						in the join order.
0: 	 * 
0: 	 * @return	The (potentially new) Optimizable at the top of the tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException;
0: 
0: 	/**
0: 	 * Return whether or not this is a covering index.  We expect to call this
0: 	 * during generation, after access path selection is complete.
0: 	 *
0: 	 * @param cd			ConglomerateDesriptor for index to consider
0: 	 *
0: 	 * @return boolean		Whether or not this is a covering index.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean isCoveringIndex(ConglomerateDescriptor cd) throws StandardException;
0: 
0: 	/**
0: 	 * Get the Properties list, if any, associated with this optimizalbe.
0: 	 *
0: 	 * @return The Properties list, if any, associated with this optimizable.
0: 	 */
0: 	public Properties getProperties();
0: 
0: 	/**
0: 	 * Set the Properties list for this optimizalbe.
0: 	 *
0: 	 * @param tableProperties The Properties list for this optimizable.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setProperties(Properties tableProperties);
0: 
0: 	/** 
0: 	 * Verify that the Properties list with optimizer overrides, if specified, is valid
0: 	 *
0: 	 * @param dDictionary	The DataDictionary  to use.
0: 	 *
0: 	 * @return Nothing.
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void verifyProperties(DataDictionary dDictionary) throws StandardException;
0: 
0: 	/**
0: 	 * Get the (exposed) name of this Optimizable
0: 	 *
0: 	 * @return	The name of this Optimizable.
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public String getName() throws StandardException;
0: 
0: 	/**
0: 	 * Get the table name of this Optimizable.  Only base tables have
0: 	 * table names (by the time we use this method, all views will have
0: 	 * been resolved).
0: 	 */
0: 	public String getBaseTableName();
0: 
0: 	/** 
0: 	 *  Convert an absolute to a relative 0-based column position.
0: 	 *  This is useful when generating qualifiers for partial rows 
0: 	 *  from the store.
0: 	 *
0: 	 * @param absolutePosition	The absolute 0-based column position for the column.
0: 	 *
0: 	 *  @return The relative 0-based column position for the column.
0: 	 */
0: 	public int convertAbsoluteToRelativeColumnPosition(int absolutePosition);
0: 
0: 	/**
0: 	 * Remember the current access path as the best one (so far).
0: 	 *
0: 	 * @param planType	The type of plan (one of Optimizer.NORMAL_PLAN
0: 	 *					or Optimizer.SORT_AVOIDANCE_PLAN)
0: 	 *
0: 	 * @exception StandardException thrown on error.
0: 	 */
0: 	public void rememberAsBest(int planType) throws StandardException;
0: 
0: 	/**
0: 	 * Begin the optimization process for this Optimizable.  This can be
0: 	 * called many times for an Optimizable while optimizing a query -
0: 	 * it will typically be called every time the Optimizable is placed
0: 	 * in a potential join order.
0: 	 */
0: 	public void startOptimizing(Optimizer optimizer, RowOrdering rowOrdering);
0: 
0: 	/**
0: 	 * Estimate the cost of scanning this Optimizable using the given
0: 	 * predicate list with the given conglomerate.  It is assumed that the
0: 	 * predicate list has already been classified.  This cost estimate is
0: 	 * just for one scan, not for the life of the query.
0: 	 *
0: 	 * @see OptimizablePredicateList#classify
0: 	 *
0: 	 * @param	predList	The predicate list to optimize against
0: 	 * @param	cd			The conglomerate descriptor to get the cost of
0: 	 * @param	outerCost	The estimated cost of the part of the plan outer
0: 	 *						to this optimizable.
0: 	 * @param	optimizer	The optimizer to use to help estimate the cost
0: 	 * @param	rowOrdering The row ordering for all the tables in the
0: 	 *						join order, including this one.
0: 	 *
0: 	 * @return	The estimated cost of doing the scan
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	CostEstimate estimateCost(OptimizablePredicateList predList,
0: 								ConglomerateDescriptor cd,
0: 								CostEstimate outerCost,
0: 								Optimizer optimizer,
0: 								RowOrdering rowOrdering)
0: 					throws StandardException;
0: 
0: 	/** Tell whether this Optimizable represents a base table */
0: 	boolean isBaseTable();
0: 
0: 	/** Tell whether this Optimizable is materializable 
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	boolean isMaterializable() throws StandardException;
0: 
0: 	/** Tell whether this Optimizable can be instantiated multiple times */
0: 	boolean supportsMultipleInstantiations();
0: 
0: 	/** Get this Optimizable's result set number */
0: 	int getResultSetNumber();
0: 
0: 	/** Get this Optimizable's table number */
0: 	int getTableNumber();
0: 
0: 	/** Return true if this Optimizable has a table number */
0: 	boolean hasTableNumber();
0: 
0: 	/** Return true if this is the target table of an update */
0: 	public boolean forUpdate();
0: 
0: 	/** Return the initial capacity of the hash table, for hash join strategy */
0: 	public int initialCapacity();
0: 
0: 	/** Return the load factor of the hash table, for hash join strategy */
0: 	public float loadFactor();
0: 
0: 	/** Return the maximum capacity of the hash table, for hash join strategy */
0: 	public int maxCapacity();
0: 
0: 	/** Return the hash key column numbers, for hash join strategy */
0: 	public int[] hashKeyColumns();
0: 
0: 	/** Set the hash key column numbers, for hash join strategy */
0: 	public void setHashKeyColumns(int[] columnNumbers);
0: 
0: 	/**
0: 	 * Is the current proposed join strategy for this optimizable feasible
0: 	 * given the predicate list?
0: 	 *
0: 	 * @param predList	The predicate list that has been pushed down to
0: 	 *					this optimizable
0: 	 * @param optimizer	The optimizer to use.
0: 	 *
0: 	 * @return	true means feasible
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean feasibleJoinStrategy(OptimizablePredicateList predList,
0: 										Optimizer optimizer)
0: 			throws StandardException;
0: 
0: 	/**
0: 	 * What is the memory usage in bytes of the proposed access path for this
0: 	 * optimizable?
0: 	 *
0: 	 * @param rowCount	The estimated number of rows returned by a single
0: 	 *					scan of this optimizable
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public double memoryUsage(double rowCount) throws StandardException;
0: 
0: 	/**
0: 	 * Can this Optimizable appear at the current location in the join order.
0: 	 * In other words, have the Optimizable's dependencies been satisfied?
0: 	 *
0: 	 * @param assignedTableMap	The tables that have been placed so far in the join order.
0: 	 *
0: 	 * @return	Where or not this Optimizable can appear at the current location in the join order.
0: 	 */
0: 	public boolean legalJoinOrder(JBitSet assignedTableMap);
0: 
0: 	/**
0: 	 * Get the DataDictionary from this Optimizable.  This is useful for code generation
0: 	 * because we need to get the constraint name if scanning a back index so that
0: 	 * RunTimeStatistics can display the correct info.
0: 	 *
0: 	 * @return The DataDictionary to use.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public DataDictionary getDataDictionary() throws StandardException;
0: 
0: 	/**
0: 	 * Is the optimizable the target table of an update or delete?
0: 	 *
0: 	 * @return Whether or not the optimizable the target table of an update or delete.
0: 	 */
0: 	public boolean isTargetTable();
0: 
0: 	/**
0: 	 * Get the number of the number of columns returned by this Optimizable.
0: 	 *
0: 	 * @return The number of the number of columns returned by this Optimizable.
0: 	 */
0: 	public int getNumColumnsReturned();
0: 
0: 	/**
0: 	 * Will the optimizable return at most 1 row per scan?
0: 	 *
0: 	 * @return Whether or not the optimizable will return at most 1 row per scan?
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean isOneRowScan() throws StandardException;
0: 
0: 	/**
0: 	 * Init the access paths for this optimizable.
0: 	 *
0: 	 * @param optimizer The optimizer being used.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void initAccessPaths(Optimizer optimizer);
0: 
0: 	/**
0: 	 * Does this optimizable have a uniqueness condition on the
0: 	 * given predicate list, and if so, how many unique keys will be
0: 	 * returned per scan.
0: 	 *
0: 	 * @param predList		The predicate list to check
0: 	 *
0: 	 * @return	<= 0 means there is no uniqueness condition
0: 	 *			> 0 means there is a uniqueness condition,
0: 	 *			and the return value is the number of rows per scan.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public double uniqueJoin(OptimizablePredicateList predList)
0: 								throws StandardException;
0: }
============================================================================