1:33776ff: /*
15:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.am.LogicalConnection
1:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:33776ff: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.am;
1:33776ff: 
1:9a0cdf1: import java.sql.Array;
1:9a0cdf1: import java.sql.Blob;
1:69e3d06: import java.sql.CallableStatement;
1:9a0cdf1: import java.sql.Clob;
1:69e3d06: import java.sql.Connection;
1:69e3d06: import java.sql.DatabaseMetaData;
1:9a0cdf1: import java.sql.NClob;
1:69e3d06: import java.sql.PreparedStatement;
1:9a0cdf1: import java.sql.SQLClientInfoException;
1:d506170: import java.sql.SQLException;
1:69e3d06: import java.sql.SQLWarning;
1:9a0cdf1: import java.sql.SQLXML;
1:69e3d06: import java.sql.Savepoint;
1:69e3d06: import java.sql.Statement;
1:9a0cdf1: import java.sql.Struct;
1:4772c7e: import java.util.Map;
1:9a0cdf1: import java.util.Properties;
1:9a0cdf1: import java.util.concurrent.Executor;
1:b13b17c: import org.apache.derby.client.ClientPooledConnection;
1:4772c7e: import org.apache.derby.shared.common.reference.SQLState;
1:d506170: 
1:06a9c55: /**
1:06a9c55:  * A simple delegation wrapper handle for a physical connection.
1:06a9c55:  * <p>
1:06a9c55:  * All methods of the {@code Connection} interface are forwarded to the
1:06a9c55:  * underlying physical connection, except for {@link #close()} and
1:06a9c55:  * {@link #isClosed()}. When a physical connection is wrapped, it is non-null,
1:06a9c55:  * when the logical connection is closed, the wrapped physical connection is
1:06a9c55:  * always set to {@code null}.
1:06a9c55:  * Both the finalizer and the {@code close}-methods will always set the 
1:06a9c55:  * physical connection to {@code null}. After the physical connection has been
1:06a9c55:  * nulled out, only the {@code PooledConnection} instance will maintain a
1:06a9c55:  * handle to the physical connection.
1:06a9c55:  */
1:69e3d06: public class LogicalConnection implements Connection {
1:06a9c55:     /**
1:06a9c55:      * Underlying physical connection for this logical connection.
1:06a9c55:      * <p>
1:06a9c55:      * Set to {@code null} when this logical connection is closed.
1:06a9c55:      */
1:69e3d06:     ClientConnection physicalConnection_;
1:b13b17c:     private ClientPooledConnection pooledConnection_ = null;
1:06a9c55:     /**
1:ef81d0e:      * Logical database metadata object created on demand and then cached.
1:ef81d0e:      * The lifetime of the metadata object is the same as this logical
1:ef81d0e:      * connection, in the sense that it will raise exceptions on method
1:ef81d0e:      * invocations after the logical connection has been closed.
1:ef81d0e:      */
1:ef81d0e:     private LogicalDatabaseMetaData logicalDatabaseMetaData = null;
1:33776ff: 
1:b13b17c:     public LogicalConnection(
1:69e3d06:             ClientConnection physicalConnection,
1:b13b17c:             ClientPooledConnection pooledConnection) throws SqlException {
1:b13b17c: 
1:70f7692:         physicalConnection_ = physicalConnection;
1:70f7692:         pooledConnection_ = pooledConnection;
1:1837822:         try {
2:1837822:             checkForNullPhysicalConnection();
1:d506170:         } catch ( SQLException se ) {
1:d506170:             throw new SqlException(se);
1:d506170:         }
1:cb47a36:     }
1:70f7692: 
1:69e3d06:     protected void finalize() throws Throwable {
1:70f7692:         close();
42:70f7692:     }
1:33776ff: 
1:70f7692:     // Used by ClientPooledConnection close when it disassociates itself from the LogicalConnection
1:70f7692:     synchronized public void nullPhysicalConnection() {
3:70f7692:         physicalConnection_ = null;
1:70f7692:     }
1:33776ff: 
1:70f7692:     // ------------------------ logical connection close -------------------------
1:70f7692:     // All methods are simply forwarded to the physical connection, except for close() and isClosed().
1:33776ff: 
1:b417710:     public void close() throws SQLException {
1:b417710:         // The pooledConnection owns this LogicalConnection.  To ensure that
1:b417710:         //  there is no deadlock when calling back into the pooledConnection_.recycleConnection
1:b417710:         //  below, we first synchronize on the pooledConnection and then on this
1:b417710:         //  LogicalConnection
1:b417710:         synchronized (pooledConnection_) {
1:b417710:             synchronized (this) {
1:b417710:                 try {
1:b417710:                     // we also need to loop thru all the logicalStatements and close them
1:b417710:                     if (physicalConnection_ == null) {
1:b417710:                         return;
1:b417710:                     }
1:b417710:                     if (physicalConnection_.agent_.loggingEnabled()) {
1:b417710:                         physicalConnection_.agent_.logWriter_.traceEntry(this, "close");
1:b417710:                     }
1:d506170: 
1:b417710:                     if (physicalConnection_.isClosed()) // connection is closed or has become stale
1:b417710:                     {
1:b417710:                         pooledConnection_.informListeners(new SqlException(null,
1:b417710:                                 new ClientMessageId(
1:b417710:                                 SQLState.PHYSICAL_CONNECTION_ALREADY_CLOSED)));
1:b417710:                     } else {
1:902041a:                         physicalConnection_.checkForTransactionInProgress();
1:b417710:                         physicalConnection_.closeForReuse(
1:b417710:                                 pooledConnection_.isStatementPoolingEnabled());
1:b417710:                         if (!physicalConnection_.isGlobalPending_()) {
1:b417710:                             pooledConnection_.recycleConnection();
1:b417710:                         }
1:b417710:                     }
1:b417710:                     physicalConnection_ = null;
1:b417710:                     pooledConnection_.nullLogicalConnection();
1:b417710:                 } catch (SqlException se) {
1:b417710:                     throw se.getSQLException();
1:d506170:                 }
1:d506170:             }
1:d506170:         }
1:d506170:     }
1:33776ff: 
1:70f7692:     synchronized public void closeWithoutRecyclingToPool() throws SqlException {
1:d506170:         if (physicalConnection_ == null) {
1:d506170:             return;
1:d506170:         }
1:b417710:         physicalConnection_.checkForTransactionInProgress();
1:6eb29f6:         try {
1:d506170:             if (physicalConnection_.isClosed()) // connection is closed or has become stale
1:6eb29f6:             {
1:4ac6a1c:                 throw new SqlException(null, 
1:4397a19:                     new ClientMessageId(SQLState.NO_CURRENT_CONNECTION)); // no call to informListeners()
1:d506170:             } else {
1:70f7692:                 ; // no call to recycleConnection()
1:70f7692:             }
1:70f7692:         } finally {
1:76af6ed:             physicalConnection_.closeForReuse(
1:76af6ed:                     pooledConnection_.isStatementPoolingEnabled());  //poolfix
1:d506170:             physicalConnection_ = null;
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean isClosed() throws SQLException {
3:70f7692:         if (physicalConnection_ == null) {
1:70f7692:             return true;
1:70f7692:         }
1:70f7692:         return physicalConnection_.isClosed();
1:70f7692:     }
1:33776ff: 
1:70f7692:     // --------------------------- helper methods --------------------------------
1:33776ff: 
1:89c399d:     /**
1:06a9c55:      * Verifies that there is an underlying physical connection for this
1:06a9c55:      * logical connection.
1:06a9c55:      * <p>
1:06a9c55:      * If the physical connection has been nulled out it means that this
1:06a9c55:      * logical connection has been closed.
1:06a9c55:      *
1:06a9c55:      * @throws SQLException if this logical connection has been closed
1:06a9c55:      */
1:06a9c55:     protected final void checkForNullPhysicalConnection()
1:06a9c55:             throws SQLException {
1:70f7692:         if (physicalConnection_ == null) {
1:4ac6a1c:             SqlException se = new SqlException(null, 
1:e65b4db:                 new ClientMessageId(SQLState.NO_CURRENT_CONNECTION));
1:4ac6a1c:             throw se.getSQLException();
1:cb47a36:         }
1:70f7692:     }
1:33776ff: 
1:ef81d0e:     /**
1:06a9c55:      * Notifies listeners about exceptions of session level severity or higher.
1:06a9c55:      * <p>
1:06a9c55:      * The exception, even if the severity is sufficiently high, is ignored if
1:06a9c55:      * the underlying physical connection has been nulled out. Otherwise a 
1:06a9c55:      * {@code connectionErrorOccurred}-event is sent to all the registered
1:06a9c55:      * listeners.
1:cb47a36:      * 
1:06a9c55:      * @param sqle the cause of the notification
1:cb47a36:      */
1:6eb29f6:     final void notifyException(SQLException sqle) {
1:cb47a36:         if (physicalConnection_ != null) 
1:6eb29f6:             pooledConnection_.informListeners(new SqlException(sqle));
1:6eb29f6:     }
1:cb47a36: 
1:70f7692:     // ---------------------- wrapped public entry points ------------------------
1:70f7692:     // All methods are forwarded to the physical connection in a standard way
1:33776ff: 
1:69e3d06:     synchronized public Statement createStatement() throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.createStatement();
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:1837822:     }
1:9a0cdf1: 
1:69e3d06:     synchronized public PreparedStatement prepareStatement(String sql)
1:69e3d06:             throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.prepareStatement(sql);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:69e3d06:     synchronized public CallableStatement prepareCall(String sql)
1:69e3d06:             throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.prepareCall(sql);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:5e39436:     synchronized public String nativeSQL(String sql) throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.nativeSQL(sql);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:d506170:     synchronized public void setAutoCommit(boolean autoCommit) throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             physicalConnection_.setAutoCommit(autoCommit);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:5e39436:     synchronized public boolean getAutoCommit() throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.getAutoCommit();
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:d506170:     synchronized public void commit() throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             physicalConnection_.commit();
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:d506170:     synchronized public void rollback() throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             physicalConnection_.rollback();
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:d506170:     synchronized public void setTransactionIsolation(int level) throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             physicalConnection_.setTransactionIsolation(level);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:5e39436:     synchronized public int getTransactionIsolation() throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.getTransactionIsolation();
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:69e3d06:     synchronized public SQLWarning getWarnings() throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.getWarnings();
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:d506170:     synchronized public void clearWarnings() throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             physicalConnection_.clearWarnings();
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:ef81d0e:     /**
1:ef81d0e:      * Retrieves a {@code DatabaseMetaData} object that contains metadata about
1:ef81d0e:      * the database to which this {@code Connection} object represents a
1:ef81d0e:      * connection.
1:ef81d0e:      * <p>
1:ef81d0e:      * The database metadata object is logical in the sense that it has the
1:ef81d0e:      * same lifetime as the logical connection. If the logical connection is
1:ef81d0e:      * closed, the underlying physical connection will not be accessed to
1:ef81d0e:      * obtain metadata, even if it is still open. Also, the reference to the
1:ef81d0e:      * logical connection instead of the underlying physical connection will be
1:ef81d0e:      * returned by {@link LogicalDatabaseMetaData#getConnection}.
1:ef81d0e:      *
1:ef81d0e:      * @return A database metadata object.
1:ef81d0e:      * @throws SQLException if an error occurs
1:ef81d0e:      */
1:69e3d06:     public synchronized DatabaseMetaData getMetaData()
1:ef81d0e:             throws SQLException {
1:1837822:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:ef81d0e:             // Create metadata object on demand, then cache it for later use.
1:ef81d0e:             if (this.logicalDatabaseMetaData == null) {
1:ef81d0e:                 this.logicalDatabaseMetaData = newLogicalDatabaseMetaData();
1:ef81d0e:             }
1:ef81d0e:             return this.logicalDatabaseMetaData;
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:ef81d0e:     /**
1:ef81d0e:      * Returns a newly created logical database metadata object.
1:ef81d0e:      * <p>
1:ef81d0e:      * Subclasses should override this method to return an instance of the
1:ef81d0e:      * correct implementation class of the logical metadata object.
1:ef81d0e:      *
1:ef81d0e:      * @return A logical database metadata object.
1:ef81d0e:      */
1:ef81d0e:     protected LogicalDatabaseMetaData newLogicalDatabaseMetaData()
1:ef81d0e:             throws SQLException {
1:ef81d0e:         return new LogicalDatabaseMetaData(
1:ef81d0e:                                 this, physicalConnection_.agent_.logWriter_);
1:ef81d0e:     }
1:ef81d0e: 
1:ef81d0e:     /**
1:ef81d0e:      * Returns the real underlying database metadata object.
1:ef81d0e:      *
1:ef81d0e:      * @return The metadata object from the underlying physical connection.
1:ef81d0e:      * @throws SQLException if the logical connection has been closed
1:ef81d0e:      */
1:69e3d06:     final synchronized DatabaseMetaData getRealMetaDataObject()
1:ef81d0e:             throws SQLException {
1:ef81d0e:         // Check if the logical connection has been closed.
1:ef81d0e:         // isClosed also checks if physicalConnection_ is null.
1:ef81d0e:         if (isClosed()) {
1:ef81d0e:             throw new SqlException(
1:ef81d0e:                     // Log this if we can.
1:ef81d0e:                     this.physicalConnection_ == null ?
1:ef81d0e:                         null :
1:ef81d0e:                         this.physicalConnection_.agent_.logWriter_,
1:ef81d0e:                     new ClientMessageId(SQLState.NO_CURRENT_CONNECTION)
1:ef81d0e:                 ).getSQLException();
1:ef81d0e:         }
1:ef81d0e:         return this.physicalConnection_.getMetaData();
1:ef81d0e:     }
1:ef81d0e: 
1:d506170:     synchronized public void setReadOnly(boolean readOnly) throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             physicalConnection_.setReadOnly(readOnly);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:5e39436:     synchronized public boolean isReadOnly() throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.isReadOnly();
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:d506170:     synchronized public void setCatalog(String catalog) throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             physicalConnection_.setCatalog(catalog);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:5e39436:     synchronized public String getCatalog() throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.getCatalog();
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:69e3d06:     synchronized public Statement createStatement(int resultSetType,
1:d506170:                                                            int resultSetConcurrency) throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.createStatement(resultSetType, resultSetConcurrency);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:69e3d06:     synchronized public PreparedStatement prepareStatement(String sql,
1:70f7692:                                                                     int resultSetType,
1:d506170:                                                                     int resultSetConcurrency) throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.prepareStatement(sql, resultSetType, resultSetConcurrency);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:69e3d06:     synchronized public CallableStatement prepareCall(String sql,
1:70f7692:                                                                int resultSetType,
1:d506170:                                                                int resultSetConcurrency) throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.prepareCall(sql, resultSetType, resultSetConcurrency);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:4772c7e:     synchronized public Map<String, Class<?>> getTypeMap() throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.getTypeMap();
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:4772c7e:     synchronized public void setTypeMap(Map map) throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             physicalConnection_.setTypeMap(map);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:69e3d06:     synchronized public Statement createStatement(
1:69e3d06:             int resultSetType,
1:69e3d06:             int resultSetConcurrency,
1:69e3d06:             int resultSetHoldability) throws SQLException {
1:69e3d06: 
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:69e3d06:     synchronized public CallableStatement prepareCall(
1:69e3d06:             String sql,
1:69e3d06:             int resultSetType,
1:69e3d06:             int resultSetConcurrency,
1:69e3d06:             int resultSetHoldability) throws SQLException {
1:69e3d06: 
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:69e3d06: 
1:69e3d06:     synchronized public PreparedStatement prepareStatement(
1:69e3d06:             String sql,
1:69e3d06:             int resultSetType,
1:69e3d06:             int resultSetConcurrency,
1:69e3d06:             int resultSetHoldability) throws SQLException {
1:69e3d06: 
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.prepareStatement(sql, resultSetType, resultSetConcurrency,
1:6eb29f6:                     resultSetHoldability);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:69e3d06:     synchronized public PreparedStatement prepareStatement(
1:69e3d06:             String sql,
1:69e3d06:             int autoGeneratedKeys) throws SQLException {
1:69e3d06: 
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.prepareStatement(sql, autoGeneratedKeys);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:69e3d06:     synchronized public PreparedStatement prepareStatement(
1:69e3d06:             String sql,
1:69e3d06:             int columnIndexes[]) throws SQLException {
1:69e3d06: 
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.prepareStatement(sql, columnIndexes);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:69e3d06:     synchronized public PreparedStatement prepareStatement(
1:69e3d06:             String sql,
1:69e3d06:             String columnNames[]) throws SQLException {
1:69e3d06: 
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.prepareStatement(sql, columnNames);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:5e39436:     synchronized public void setHoldability(int holdability) throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             physicalConnection_.setHoldability(holdability);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:5e39436:     synchronized public int getHoldability() throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.getHoldability();
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:33776ff: 
1:69e3d06:     synchronized public Savepoint setSavepoint() throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.setSavepoint();
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:70f7692: 
1:69e3d06:     synchronized public Savepoint setSavepoint(String name)
1:69e3d06:             throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.setSavepoint(name);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:70f7692: 
1:69e3d06:     synchronized public void rollback(Savepoint savepoint) throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             physicalConnection_.rollback(savepoint);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:70f7692: 
1:69e3d06:     synchronized public void releaseSavepoint(Savepoint savepoint)
1:69e3d06:             throws SQLException {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             physicalConnection_.releaseSavepoint(savepoint);
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:cb47a36:     }
1:70f7692: 
1:cb47a36:     /**
1:89c399d:      * Returns the client-side transaction id from am.Connection. 
1:89c399d:      * <p>
1:89c399d:      * <em>NOTE:</em> This method was added for testing purposes. Avoid use in
1:89c399d:      * production code if possible.
1:89c399d:      **/
1:89c399d:     public int getTransactionID() {
1:89c399d:         if (physicalConnection_ == null) {
1:89c399d:             return -1;
1:89c399d:         } else {
1:89c399d:             return physicalConnection_.getTransactionID();
1:89c399d:         }
1:89c399d:     }
1:89c399d:     
1:70f7692:     //----------------------------------------------------------------------------
1:70f7692: 
1:70f7692:     public int getServerVersion() {
1:70f7692:         if (physicalConnection_ == null) {
1:70f7692:             return -1;
3:70f7692:         } else {
1:70f7692:             return physicalConnection_.getServerVersion();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:1837822:     ////////////////////////////////////////////////////////////////////
1:1837822:     //
1:9a0cdf1:     // INTRODUCED BY JDBC 4.0 IN JAVA 6
1:9a0cdf1:     //
1:9a0cdf1:     ////////////////////////////////////////////////////////////////////
1:9a0cdf1:     public Array createArrayOf(String typeName, Object[] elements)
1:9a0cdf1:         throws SQLException {
1:9a0cdf1:         try
1:9a0cdf1:         {
1:9a0cdf1:             checkForNullPhysicalConnection();
1:9a0cdf1:             return physicalConnection_.createArrayOf( typeName, elements );
1:9a0cdf1:         } catch (SQLException sqle) {
1:9a0cdf1:             notifyException(sqle);
1:9a0cdf1:             throw sqle;
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public Blob createBlob()
1:9a0cdf1:         throws SQLException {
1:9a0cdf1:         try
1:9a0cdf1:         {
1:9a0cdf1:             checkForNullPhysicalConnection();
1:9a0cdf1:             return physicalConnection_.createBlob();
1:9a0cdf1:         } catch (SQLException sqle) {
1:9a0cdf1:             notifyException(sqle);
1:9a0cdf1:             throw sqle;
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public Clob createClob()
1:9a0cdf1:         throws SQLException {
1:9a0cdf1:         try
1:9a0cdf1:         {
1:9a0cdf1:             checkForNullPhysicalConnection();
1:9a0cdf1:             return physicalConnection_.createClob();
1:9a0cdf1:         } catch (SQLException sqle) {
1:9a0cdf1:             notifyException(sqle);
1:9a0cdf1:             throw sqle;
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public NClob createNClob()
1:9a0cdf1:         throws SQLException {
1:9a0cdf1:         try
1:9a0cdf1:         {
1:9a0cdf1:             checkForNullPhysicalConnection();
1:9a0cdf1:             return physicalConnection_.createNClob();
1:9a0cdf1:         } catch (SQLException sqle) {
1:9a0cdf1:             notifyException(sqle);
1:9a0cdf1:             throw sqle;
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public SQLXML createSQLXML()
1:9a0cdf1:         throws SQLException {
1:9a0cdf1:         try
1:9a0cdf1:         {
1:9a0cdf1:             checkForNullPhysicalConnection();
1:9a0cdf1:             return physicalConnection_.createSQLXML();
1:9a0cdf1:         } catch (SQLException sqle) {
1:9a0cdf1:             notifyException(sqle);
1:9a0cdf1:             throw sqle;
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public Struct createStruct(String typeName, Object[] attributes)
1:9a0cdf1:         throws SQLException {
1:9a0cdf1:         try
1:9a0cdf1:         {
1:9a0cdf1:             checkForNullPhysicalConnection();
1:9a0cdf1:             return physicalConnection_.createStruct( typeName, attributes );
1:9a0cdf1:         } catch (SQLException sqle) {
1:9a0cdf1:             notifyException(sqle);
1:9a0cdf1:             throw sqle;
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     /**
1:9a0cdf1:      * <code>getClientInfo</code> forwards to
1:9a0cdf1:      * <code>physicalConnection_</code>.
1:9a0cdf1:      * <code>getClientInfo</code> always returns an empty
1:9a0cdf1:      * <code>Properties</code> object since Derby doesn't support
1:9a0cdf1:      * ClientInfoProperties.
1:9a0cdf1:      *
1:9a0cdf1:      * @return an empty <code>Properties</code> object
2:9a0cdf1:      * @exception SQLException if an error occurs
1:9a0cdf1:      */
1:9a0cdf1:     public Properties getClientInfo()
1:9a0cdf1:         throws SQLException {
1:9a0cdf1:         try
1:9a0cdf1:         {
1:9a0cdf1:             checkForNullPhysicalConnection();
1:9a0cdf1:             return physicalConnection_.getClientInfo();
1:9a0cdf1:         } catch (SQLException sqle) {
1:9a0cdf1:             notifyException(sqle);
1:9a0cdf1:             throw sqle;
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     /**
1:9a0cdf1:      * <code>getClientInfo</code> forwards to
1:9a0cdf1:      * <code>physicalConnection_</code>. Always returns a <code>null
1:9a0cdf1:      * String</code> since Derby does not support
1:9a0cdf1:      * ClientInfoProperties.
1:9a0cdf1:      *
1:9a0cdf1:      * @param name a property key to get <code>String</code>
1:9a0cdf1:      * @return a property value <code>String</code>
1:9a0cdf1:      * @exception SQLException if an error occurs
1:9a0cdf1:      */
1:9a0cdf1:     public String getClientInfo(String name)
1:9a0cdf1:         throws SQLException {
1:9a0cdf1:         try
1:9a0cdf1:         {
1:9a0cdf1:             checkForNullPhysicalConnection();
1:9a0cdf1:             return physicalConnection_.getClientInfo(name);
1:9a0cdf1:         } catch (SQLException sqle) {
1:9a0cdf1:             notifyException(sqle);
1:9a0cdf1:             throw sqle;
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     /**
1:9a0cdf1:      * Checks if the connection has not been closed and is still valid.
1:9a0cdf1:      * The validity is checked by running a simple query against the
1:9a0cdf1:      * database.
1:9a0cdf1:      *
1:9a0cdf1:      * @param timeout The time in seconds to wait for the database
1:9a0cdf1:      * operation used to validate the connection to complete. If the
1:9a0cdf1:      * timeout period expires before the operation completes, this
1:9a0cdf1:      * method returns false. A value of 0 indicates a timeout is not
1:9a0cdf1:      * applied to the database operation.
1:9a0cdf1:      * @return true if the connection is valid, false otherwise
1:9a0cdf1:      * @throws SQLException if the call on the physical connection throws an
1:9a0cdf1:      * exception.
1:9a0cdf1:      */
1:9a0cdf1:     synchronized public boolean isValid(int timeout) throws SQLException {
1:9a0cdf1:         try
1:9a0cdf1:         {
1:9a0cdf1:             // Check if we have a underlying physical connection
1:9a0cdf1:             if (physicalConnection_ == null) {
1:9a0cdf1:                 return false;
1:9a0cdf1:             }
1:9a0cdf1:             return physicalConnection_.isValid(timeout);
1:9a0cdf1:         } catch (SQLException sqle) {
1:9a0cdf1:             notifyException(sqle);
1:9a0cdf1:             throw sqle;
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1: 
1:9a0cdf1:     public boolean isWrapperFor(Class<?> interfaces)
1:9a0cdf1:         throws SQLException {
1:9a0cdf1:         try
1:9a0cdf1:         {
1:9a0cdf1:             checkForNullPhysicalConnection();
1:9a0cdf1:             return interfaces.isInstance(this);
1:9a0cdf1:         } catch (SQLException sqle) {
1:9a0cdf1:             notifyException(sqle);
1:9a0cdf1:             throw sqle;
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     /**
1:9a0cdf1:      * <code>setClientInfo</code> forwards to
1:9a0cdf1:      * <code>physicalConnection_</code>.
1:9a0cdf1:      *
1:9a0cdf1:      * @param properties a <code>Properties</code> object with the
1:9a0cdf1:      * properties to set
1:9a0cdf1:      * @exception SQLClientInfoException if an error occurs
1:9a0cdf1:      */
1:9a0cdf1:     public void setClientInfo(Properties properties)
1:9a0cdf1:         throws SQLClientInfoException {
1:9a0cdf1:         try
1:9a0cdf1:         {
1:9a0cdf1:             checkForNullPhysicalConnection();
1:9a0cdf1:             physicalConnection_.setClientInfo(properties);
1:9a0cdf1:         } catch (SQLClientInfoException cie) {
1:9a0cdf1:             notifyException(cie);
1:9a0cdf1:             throw cie;
1:9a0cdf1:         } catch (SQLException sqle) {
1:9a0cdf1:             notifyException(sqle);
1:9a0cdf1:             throw new SQLClientInfoException
1:9a0cdf1:             (sqle.getMessage(), sqle.getSQLState(),
1:9a0cdf1:                     sqle.getErrorCode(),
1:9a0cdf1:                     (new FailedProperties40(properties)).getProperties());
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     /**
1:9a0cdf1:      * <code>setClientInfo</code> forwards to
1:9a0cdf1:      * <code>physicalConnection_</code>.
1:9a0cdf1:      *
1:9a0cdf1:      * @param name a property key <code>String</code>
1:9a0cdf1:      * @param value a property value <code>String</code>
1:f668d94:      * @exception SQLClientInfoException if an error occurs
1:9a0cdf1:      */
1:9a0cdf1:     public void setClientInfo(String name, String value)
1:9a0cdf1:         throws SQLClientInfoException {
1:9a0cdf1:         try
1:9a0cdf1:         {
1:9a0cdf1:             checkForNullPhysicalConnection();
1:9a0cdf1:             physicalConnection_.setClientInfo(name, value);
1:9a0cdf1:         } catch (SQLClientInfoException cie) {
1:9a0cdf1:             notifyException(cie);
1:9a0cdf1:             throw cie;
1:9a0cdf1:         } catch (SQLException sqle) {
1:9a0cdf1:             notifyException(sqle);
1:9a0cdf1:             throw new SQLClientInfoException
1:9a0cdf1:             (sqle.getMessage(), sqle.getSQLState(),
1:9a0cdf1:                     sqle.getErrorCode(),
1:9a0cdf1:              new FailedProperties40
1:9a0cdf1:              (FailedProperties40.makeProperties
1:9a0cdf1:               (name,value)).getProperties());
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public <T>T unwrap(Class<T> interfaces)
1:9a0cdf1:         throws SQLException {
1:9a0cdf1:         try
1:9a0cdf1:         {
1:9a0cdf1:             checkForNullPhysicalConnection();
1:9a0cdf1:             // Derby does not implement non-standard methods on JDBC objects
1:9a0cdf1:             try {
1:9a0cdf1:                 return interfaces.cast(this);
1:9a0cdf1:             } catch (ClassCastException cce) {
1:9a0cdf1:                 throw new SqlException(null,
1:9a0cdf1:                                        new ClientMessageId(SQLState.UNABLE_TO_UNWRAP),
1:9a0cdf1:                                        interfaces).getSQLException();
1:9a0cdf1:             }
1:9a0cdf1:         } catch (SQLException sqle) {
1:9a0cdf1:             notifyException(sqle);
1:9a0cdf1:             throw sqle;
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     ////////////////////////////////////////////////////////////////////
1:9a0cdf1:     //
1:1837822:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:1837822:     //
1:1837822:     ////////////////////////////////////////////////////////////////////
1:1837822: 
1:1837822:     /**
1:1837822:      * Get the name of the current schema.
1:1837822:      */
1:5e39436:     synchronized public String   getSchema() throws SQLException
1:9a0cdf1:     {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             return physicalConnection_.getSchema();
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:1837822:     }
1:1837822:     
1:1837822:     /**
1:1837822:      * Set the default schema for the Connection.
1:1837822:      */
1:5e39436:     synchronized public void   setSchema(  String schemaName ) throws SQLException
1:6eb29f6:     {
1:6eb29f6:         try {
1:6eb29f6:             checkForNullPhysicalConnection();
1:6eb29f6:             physicalConnection_.setSchema( schemaName );
1:6eb29f6:         } catch (SQLException sqle) {
1:6eb29f6:             notifyException(sqle);
1:6eb29f6:             throw sqle;
1:6eb29f6:         }
1:1837822:     }
1:1837822: 
1:9a0cdf1:     public  void    abort( Executor executor )  throws SQLException
1:9a0cdf1:     {
1:9a0cdf1:         try
1:9a0cdf1:         {
1:9a0cdf1:             if ( physicalConnection_ != null )
1:9a0cdf1:             {
1:9a0cdf1:                 physicalConnection_.abort( executor );
1:9a0cdf1:             }
1:9a0cdf1:         } catch (SQLException sqle) {
1:9a0cdf1:             notifyException(sqle);
1:9a0cdf1:             throw sqle;
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public int getNetworkTimeout() throws SQLException
1:9a0cdf1:     {
1:9a0cdf1:         try
1:9a0cdf1:         {
1:9a0cdf1:             checkForNullPhysicalConnection();
1:9a0cdf1:             return physicalConnection_.getNetworkTimeout();
1:9a0cdf1:         } catch (SQLException sqle) {
1:9a0cdf1:             notifyException(sqle);
1:9a0cdf1:             throw sqle;
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setNetworkTimeout( Executor executor, int milliseconds ) throws SQLException
1:9a0cdf1:     {
1:9a0cdf1:         try
2:1837822:         {
1:9a0cdf1:             checkForNullPhysicalConnection();
1:9a0cdf1:             physicalConnection_.setNetworkTimeout( executor, milliseconds );
1:9a0cdf1:         } catch (SQLException sqle) {
1:9a0cdf1:             notifyException(sqle);
1:9a0cdf1:             throw sqle;
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:1837822: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f668d94
/////////////////////////////////////////////////////////////////////////
1:      * @exception SQLClientInfoException if an error occurs
commit:9a0cdf1
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Array;
1: import java.sql.Blob;
1: import java.sql.Clob;
1: import java.sql.NClob;
1: import java.sql.SQLClientInfoException;
1: import java.sql.SQLXML;
1: import java.sql.Struct;
1: import java.util.Properties;
1: import java.util.concurrent.Executor;
/////////////////////////////////////////////////////////////////////////
1:     // INTRODUCED BY JDBC 4.0 IN JAVA 6
1:     //
1:     ////////////////////////////////////////////////////////////////////
1:     public Array createArrayOf(String typeName, Object[] elements)
1:         throws SQLException {
1:         try
1:         {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.createArrayOf( typeName, elements );
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     public Blob createBlob()
1:         throws SQLException {
1:         try
1:         {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.createBlob();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     public Clob createClob()
1:         throws SQLException {
1:         try
1:         {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.createClob();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     public NClob createNClob()
1:         throws SQLException {
1:         try
1:         {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.createNClob();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     public SQLXML createSQLXML()
1:         throws SQLException {
1:         try
1:         {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.createSQLXML();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     public Struct createStruct(String typeName, Object[] attributes)
1:         throws SQLException {
1:         try
1:         {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.createStruct( typeName, attributes );
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     /**
1:      * <code>getClientInfo</code> forwards to
1:      * <code>physicalConnection_</code>.
1:      * <code>getClientInfo</code> always returns an empty
1:      * <code>Properties</code> object since Derby doesn't support
1:      * ClientInfoProperties.
1:      *
1:      * @return an empty <code>Properties</code> object
1:      * @exception SQLException if an error occurs
1:      */
1:     public Properties getClientInfo()
1:         throws SQLException {
1:         try
1:         {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.getClientInfo();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     /**
1:      * <code>getClientInfo</code> forwards to
1:      * <code>physicalConnection_</code>. Always returns a <code>null
1:      * String</code> since Derby does not support
1:      * ClientInfoProperties.
1:      *
1:      * @param name a property key to get <code>String</code>
1:      * @return a property value <code>String</code>
1:      * @exception SQLException if an error occurs
1:      */
1:     public String getClientInfo(String name)
1:         throws SQLException {
1:         try
1:         {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.getClientInfo(name);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     /**
1:      * Checks if the connection has not been closed and is still valid.
1:      * The validity is checked by running a simple query against the
1:      * database.
1:      *
1:      * @param timeout The time in seconds to wait for the database
1:      * operation used to validate the connection to complete. If the
1:      * timeout period expires before the operation completes, this
1:      * method returns false. A value of 0 indicates a timeout is not
1:      * applied to the database operation.
1:      * @return true if the connection is valid, false otherwise
1:      * @throws SQLException if the call on the physical connection throws an
1:      * exception.
1:      */
1:     synchronized public boolean isValid(int timeout) throws SQLException {
1:         try
1:         {
1:             // Check if we have a underlying physical connection
1:             if (physicalConnection_ == null) {
1:                 return false;
1:             }
1:             return physicalConnection_.isValid(timeout);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1: 
1:     public boolean isWrapperFor(Class<?> interfaces)
1:         throws SQLException {
1:         try
1:         {
1:             checkForNullPhysicalConnection();
1:             return interfaces.isInstance(this);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     /**
1:      * <code>setClientInfo</code> forwards to
1:      * <code>physicalConnection_</code>.
1:      *
1:      * @param properties a <code>Properties</code> object with the
1:      * properties to set
1:      * @exception SQLClientInfoException if an error occurs
1:      */
1:     public void setClientInfo(Properties properties)
1:         throws SQLClientInfoException {
1:         try
1:         {
1:             checkForNullPhysicalConnection();
1:             physicalConnection_.setClientInfo(properties);
1:         } catch (SQLClientInfoException cie) {
1:             notifyException(cie);
1:             throw cie;
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw new SQLClientInfoException
1:             (sqle.getMessage(), sqle.getSQLState(),
1:                     sqle.getErrorCode(),
1:                     (new FailedProperties40(properties)).getProperties());
1:         }
1:     }
1: 
1:     /**
1:      * <code>setClientInfo</code> forwards to
1:      * <code>physicalConnection_</code>.
1:      *
1:      * @param name a property key <code>String</code>
1:      * @param value a property value <code>String</code>
1:      * @exception SQLException if an error occurs
1:      */
1:     public void setClientInfo(String name, String value)
1:         throws SQLClientInfoException {
1:         try
1:         {
1:             checkForNullPhysicalConnection();
1:             physicalConnection_.setClientInfo(name, value);
1:         } catch (SQLClientInfoException cie) {
1:             notifyException(cie);
1:             throw cie;
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw new SQLClientInfoException
1:             (sqle.getMessage(), sqle.getSQLState(),
1:                     sqle.getErrorCode(),
1:              new FailedProperties40
1:              (FailedProperties40.makeProperties
1:               (name,value)).getProperties());
1:         }
1:     }
1: 
1:     public <T>T unwrap(Class<T> interfaces)
1:         throws SQLException {
1:         try
1:         {
1:             checkForNullPhysicalConnection();
1:             // Derby does not implement non-standard methods on JDBC objects
1:             try {
1:                 return interfaces.cast(this);
1:             } catch (ClassCastException cce) {
1:                 throw new SqlException(null,
1:                                        new ClientMessageId(SQLState.UNABLE_TO_UNWRAP),
1:                                        interfaces).getSQLException();
1:             }
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////
1:     //
/////////////////////////////////////////////////////////////////////////
1: 
1:     public  void    abort( Executor executor )  throws SQLException
1:     {
1:         try
1:         {
1:             if ( physicalConnection_ != null )
1:             {
1:                 physicalConnection_.abort( executor );
1:             }
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     public int getNetworkTimeout() throws SQLException
1:     {
1:         try
1:         {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.getNetworkTimeout();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     public void setNetworkTimeout( Executor executor, int milliseconds ) throws SQLException
1:     {
1:         try
1:         {
1:             checkForNullPhysicalConnection();
1:             physicalConnection_.setNetworkTimeout( executor, milliseconds );
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
commit:4772c7e
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
1: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:     synchronized public Map<String, Class<?>> getTypeMap() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized public void setTypeMap(Map map) throws SQLException {
commit:902041a
/////////////////////////////////////////////////////////////////////////
1:                 physicalConnection_.checkForTransactionInProgress();
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:b417710
/////////////////////////////////////////////////////////////////////////
1:     public void close() throws SQLException {
1:         // The pooledConnection owns this LogicalConnection.  To ensure that
1:         //  there is no deadlock when calling back into the pooledConnection_.recycleConnection
1:         //  below, we first synchronize on the pooledConnection and then on this
1:         //  LogicalConnection
1:         synchronized (pooledConnection_) {
1:             synchronized (this) {
1:                 try {
1:                     // we also need to loop thru all the logicalStatements and close them
1:                     if (physicalConnection_ == null) {
1:                         return;
1:                     }
1:                     if (physicalConnection_.agent_.loggingEnabled()) {
1:                         physicalConnection_.agent_.logWriter_.traceEntry(this, "close");
1:                     }
1:                     if (physicalConnection_.isClosed()) // connection is closed or has become stale
1:                     {
1:                         pooledConnection_.informListeners(new SqlException(null,
1:                                 new ClientMessageId(
1:                                 SQLState.PHYSICAL_CONNECTION_ALREADY_CLOSED)));
1:                     } else {
1:                         physicalConnection_.checkForTransactionInProgress();
1:                         physicalConnection_.closeForReuse(
1:                                 pooledConnection_.isStatementPoolingEnabled());
1:                         if (!physicalConnection_.isGlobalPending_()) {
1:                             pooledConnection_.recycleConnection();
1:                         }
1:                     }
1:                     physicalConnection_ = null;
1:                     pooledConnection_.nullLogicalConnection();
1:                 } catch (SqlException se) {
1:                     throw se.getSQLException();
commit:6eb29f6
/////////////////////////////////////////////////////////////////////////
1:     final void notifyException(SQLException sqle) {
1:             pooledConnection_.informListeners(new SqlException(sqle));
1:     }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.createStatement();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.prepareStatement(sql);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.prepareCall(sql);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.nativeSQL(sql);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             physicalConnection_.setAutoCommit(autoCommit);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.getAutoCommit();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             physicalConnection_.commit();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             physicalConnection_.rollback();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             physicalConnection_.setTransactionIsolation(level);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.getTransactionIsolation();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.getWarnings();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             physicalConnection_.clearWarnings();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             checkForNullPhysicalConnection();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             checkForNullPhysicalConnection();
1:             physicalConnection_.setReadOnly(readOnly);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.isReadOnly();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             physicalConnection_.setCatalog(catalog);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.getCatalog();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.createStatement(resultSetType, resultSetConcurrency);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.prepareStatement(sql, resultSetType, resultSetConcurrency);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.prepareCall(sql, resultSetType, resultSetConcurrency);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.getTypeMap();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             physicalConnection_.setTypeMap(map);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.prepareStatement(sql, resultSetType, resultSetConcurrency,
1:                     resultSetHoldability);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.prepareStatement(sql, autoGeneratedKeys);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.prepareStatement(sql, columnIndexes);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.prepareStatement(sql, columnNames);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             physicalConnection_.setHoldability(holdability);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.getHoldability();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.setSavepoint();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.setSavepoint(name);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             physicalConnection_.rollback(savepoint);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:         try {
1:             checkForNullPhysicalConnection();
1:             physicalConnection_.releaseSavepoint(savepoint);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
/////////////////////////////////////////////////////////////////////////
1:     {
1:         try {
1:             checkForNullPhysicalConnection();
1:             return physicalConnection_.getSchema();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     {
1:         try {
1:             checkForNullPhysicalConnection();
1:             physicalConnection_.setSchema( schemaName );
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
commit:89c399d
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns the client-side transaction id from am.Connection. 
1:      * <p>
1:      * <em>NOTE:</em> This method was added for testing purposes. Avoid use in
1:      * production code if possible.
1:      **/
1:     public int getTransactionID() {
1:         if (physicalConnection_ == null) {
1:             return -1;
1:         } else {
1:             return physicalConnection_.getTransactionID();
1:         }
1:     }
1:     
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.sql.CallableStatement;
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLWarning;
1: import java.sql.Savepoint;
1: import java.sql.Statement;
/////////////////////////////////////////////////////////////////////////
1: public class LogicalConnection implements Connection {
1:     ClientConnection physicalConnection_;
/////////////////////////////////////////////////////////////////////////
1:             ClientConnection physicalConnection,
/////////////////////////////////////////////////////////////////////////
1:     protected void finalize() throws Throwable {
/////////////////////////////////////////////////////////////////////////
1:     synchronized public Statement createStatement() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized public PreparedStatement prepareStatement(String sql)
1:             throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     synchronized
0:         public ClientPreparedStatement preparePositionedUpdateStatement(
1:             String sql,
0:             Section querySection) throws SqlException {
1: 
/////////////////////////////////////////////////////////////////////////
1:     synchronized public CallableStatement prepareCall(String sql)
1:             throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized public SQLWarning getWarnings() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public synchronized DatabaseMetaData getMetaData()
/////////////////////////////////////////////////////////////////////////
1:     final synchronized DatabaseMetaData getRealMetaDataObject()
/////////////////////////////////////////////////////////////////////////
1:     synchronized public Statement createStatement(int resultSetType,
/////////////////////////////////////////////////////////////////////////
1:     synchronized public PreparedStatement prepareStatement(String sql,
/////////////////////////////////////////////////////////////////////////
1:     synchronized public CallableStatement prepareCall(String sql,
/////////////////////////////////////////////////////////////////////////
1:     synchronized public Statement createStatement(
1:             int resultSetType,
1:             int resultSetConcurrency,
1:             int resultSetHoldability) throws SQLException {
1: 
/////////////////////////////////////////////////////////////////////////
1:     synchronized public CallableStatement prepareCall(
1:             String sql,
1:             int resultSetType,
1:             int resultSetConcurrency,
1:             int resultSetHoldability) throws SQLException {
1: 
/////////////////////////////////////////////////////////////////////////
1:     synchronized public PreparedStatement prepareStatement(
1:             String sql,
1:             int resultSetType,
1:             int resultSetConcurrency,
1:             int resultSetHoldability) throws SQLException {
1: 
/////////////////////////////////////////////////////////////////////////
1:     synchronized public PreparedStatement prepareStatement(
1:             String sql,
1:             int autoGeneratedKeys) throws SQLException {
1: 
/////////////////////////////////////////////////////////////////////////
1:     synchronized public PreparedStatement prepareStatement(
1:             String sql,
1:             int columnIndexes[]) throws SQLException {
1: 
/////////////////////////////////////////////////////////////////////////
1:     synchronized public PreparedStatement prepareStatement(
0:             String sql,
1:             String columnNames[]) throws SQLException {
1: 
/////////////////////////////////////////////////////////////////////////
1:     synchronized public Savepoint setSavepoint() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized public Savepoint setSavepoint(String name)
1:             throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized public void rollback(Savepoint savepoint) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized public void releaseSavepoint(Savepoint savepoint)
1:             throws SQLException {
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.ClientPooledConnection;
/////////////////////////////////////////////////////////////////////////
1:     private ClientPooledConnection pooledConnection_ = null;
/////////////////////////////////////////////////////////////////////////
1:     public LogicalConnection(
0:             Connection physicalConnection,
1:             ClientPooledConnection pooledConnection) throws SqlException {
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:06a9c55
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * A simple delegation wrapper handle for a physical connection.
1:  * <p>
1:  * All methods of the {@code Connection} interface are forwarded to the
1:  * underlying physical connection, except for {@link #close()} and
1:  * {@link #isClosed()}. When a physical connection is wrapped, it is non-null,
1:  * when the logical connection is closed, the wrapped physical connection is
1:  * always set to {@code null}.
1:  * Both the finalizer and the {@code close}-methods will always set the 
1:  * physical connection to {@code null}. After the physical connection has been
1:  * nulled out, only the {@code PooledConnection} instance will maintain a
1:  * handle to the physical connection.
1:  */
1:     /**
1:      * Underlying physical connection for this logical connection.
1:      * <p>
1:      * Set to {@code null} when this logical connection is closed.
1:      */
0:     Connection physicalConnection_;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verifies that there is an underlying physical connection for this
1:      * logical connection.
1:      * <p>
1:      * If the physical connection has been nulled out it means that this
1:      * logical connection has been closed.
1:      *
1:      * @throws SQLException if this logical connection has been closed
1:      */
1:     protected final void checkForNullPhysicalConnection()
1:             throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:      * Notifies listeners about exceptions of session level severity or higher.
1:      * <p>
1:      * The exception, even if the severity is sufficiently high, is ignored if
1:      * the underlying physical connection has been nulled out. Otherwise a 
1:      * {@code connectionErrorOccurred}-event is sent to all the registered
1:      * listeners.
1:      * @param sqle the cause of the notification
commit:5e39436
/////////////////////////////////////////////////////////////////////////
1:     synchronized public String nativeSQL(String sql) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized public boolean getAutoCommit() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized public int getTransactionIsolation() throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public java.sql.SQLWarning getWarnings() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized public boolean isReadOnly() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized public String getCatalog() throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public java.util.Map getTypeMap() throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public java.sql.Statement createStatement(int resultSetType, int resultSetConcurrency,
/////////////////////////////////////////////////////////////////////////
0:     synchronized public java.sql.CallableStatement prepareCall(String sql, int resultSetType,
/////////////////////////////////////////////////////////////////////////
0:     synchronized public java.sql.PreparedStatement prepareStatement(String sql, int resultSetType,
/////////////////////////////////////////////////////////////////////////
0:     synchronized public java.sql.PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
/////////////////////////////////////////////////////////////////////////
0:     synchronized public java.sql.PreparedStatement prepareStatement(String sql, int columnIndexes[])
/////////////////////////////////////////////////////////////////////////
0:     synchronized public java.sql.PreparedStatement prepareStatement(String sql, String columnNames[])
/////////////////////////////////////////////////////////////////////////
1:     synchronized public void setHoldability(int holdability) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized public int getHoldability() throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public java.sql.Savepoint setSavepoint() throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public java.sql.Savepoint setSavepoint(String name) throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void rollback(java.sql.Savepoint savepoint) throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void releaseSavepoint(java.sql.Savepoint savepoint) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized public String   getSchema() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:     synchronized public void   setSchema(  String schemaName ) throws SQLException
commit:ef81d0e
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Logical database metadata object created on demand and then cached.
1:      * The lifetime of the metadata object is the same as this logical
1:      * connection, in the sense that it will raise exceptions on method
1:      * invocations after the logical connection has been closed.
1:      */
1:     private LogicalDatabaseMetaData logicalDatabaseMetaData = null;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Retrieves a {@code DatabaseMetaData} object that contains metadata about
1:      * the database to which this {@code Connection} object represents a
1:      * connection.
1:      * <p>
1:      * The database metadata object is logical in the sense that it has the
1:      * same lifetime as the logical connection. If the logical connection is
1:      * closed, the underlying physical connection will not be accessed to
1:      * obtain metadata, even if it is still open. Also, the reference to the
1:      * logical connection instead of the underlying physical connection will be
1:      * returned by {@link LogicalDatabaseMetaData#getConnection}.
1:      *
1:      * @return A database metadata object.
1:      * @throws SQLException if an error occurs
1:      */
0:     public synchronized java.sql.DatabaseMetaData getMetaData()
1:             throws SQLException {
1:             // Create metadata object on demand, then cache it for later use.
1:             if (this.logicalDatabaseMetaData == null) {
1:                 this.logicalDatabaseMetaData = newLogicalDatabaseMetaData();
1:             }
1:             return this.logicalDatabaseMetaData;
1:     /**
1:      * Returns a newly created logical database metadata object.
1:      * <p>
1:      * Subclasses should override this method to return an instance of the
1:      * correct implementation class of the logical metadata object.
1:      *
1:      * @return A logical database metadata object.
1:      */
1:     protected LogicalDatabaseMetaData newLogicalDatabaseMetaData()
1:             throws SQLException {
1:         return new LogicalDatabaseMetaData(
1:                                 this, physicalConnection_.agent_.logWriter_);
1:     }
1: 
1:     /**
1:      * Returns the real underlying database metadata object.
1:      *
1:      * @return The metadata object from the underlying physical connection.
1:      * @throws SQLException if the logical connection has been closed
1:      */
0:     final synchronized java.sql.DatabaseMetaData getRealMetaDataObject()
1:             throws SQLException {
1:         // Check if the logical connection has been closed.
1:         // isClosed also checks if physicalConnection_ is null.
1:         if (isClosed()) {
1:             throw new SqlException(
1:                     // Log this if we can.
1:                     this.physicalConnection_ == null ?
1:                         null :
1:                         this.physicalConnection_.agent_.logWriter_,
1:                     new ClientMessageId(SQLState.NO_CURRENT_CONNECTION)
1:                 ).getSQLException();
1:         }
1:         return this.physicalConnection_.getMetaData();
1:     }
1: 
commit:76af6ed
/////////////////////////////////////////////////////////////////////////
1:                 physicalConnection_.closeForReuse(
0:                         pooledConnection_.isStatementPoolingEnabled());
/////////////////////////////////////////////////////////////////////////
0:             physicalConnection_.closeForReuse(
1:                     pooledConnection_.isStatementPoolingEnabled());  //poolfix
commit:4397a19
/////////////////////////////////////////////////////////////////////////
0:                 pooledConnection_.informListeners(new SqlException(null, 
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId(SQLState.NO_CURRENT_CONNECTION)); // no call to informListeners()
/////////////////////////////////////////////////////////////////////////
0:         	pooledConnection_.informListeners(new SqlException(sqle));
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:1837822
/////////////////////////////////////////////////////////////////////////
1:     ////////////////////////////////////////////////////////////////////
1:     //
1:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:     //
1:     ////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Get the name of the current schema.
1:      */
0:     public String   getSchema() throws SQLException
1: 	{
1: 		try {
1: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.getSchema();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
1:     }
1:     
1:     /**
1:      * Set the default schema for the Connection.
1:      */
0:     public void   setSchema(  String schemaName ) throws SQLException
1: 	{
1: 		try {
1: 	        checkForNullPhysicalConnection();
0: 	        physicalConnection_.setSchema( schemaName );
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
1:     }
1:     
commit:b64ccfc
/////////////////////////////////////////////////////////////////////////
0:     protected Connection physicalConnection_ = null; // reset to null when the logical connection is closed.
/////////////////////////////////////////////////////////////////////////
0:     protected void checkForNullPhysicalConnection() throws SQLException {
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:cb47a36
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * This method checks if the physcial connection underneath is null and
0:      * if yes, then it simply returns.
0:      * Otherwise, if the severity of exception is greater than equal to
0:      * ExceptionSeverity.SESSION_SEVERITY, then we will send 
0:      * connectionErrorOccurred event to all the registered listeners.
1:      * 
0:      * @param sqle SQLException An event will be sent to the listeners if the
0:      * exception's severity is >= ExceptionSeverity.SESSION_SEVERITY.
1:      */
0: 	final void notifyException(SQLException sqle) {
1:         if (physicalConnection_ != null) 
0:         	pooledConnection_.trashConnection(new SqlException(sqle));
1: 	}
1: 
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.createStatement();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.prepareStatement(sql);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
/////////////////////////////////////////////////////////////////////////
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.prepareCall(sql);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.nativeSQL(sql);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        physicalConnection_.setAutoCommit(autoCommit);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.getAutoCommit();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        physicalConnection_.commit();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        physicalConnection_.rollback();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        physicalConnection_.setTransactionIsolation(level);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.getTransactionIsolation();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.getWarnings();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        physicalConnection_.clearWarnings();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.getMetaData();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        physicalConnection_.setReadOnly(readOnly);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.isReadOnly();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        physicalConnection_.setCatalog(catalog);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.getCatalog();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.createStatement(resultSetType, resultSetConcurrency);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.prepareStatement(sql, resultSetType, resultSetConcurrency);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.prepareCall(sql, resultSetType, resultSetConcurrency);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.getTypeMap();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        physicalConnection_.setTypeMap(map);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.prepareStatement(sql, resultSetType, resultSetConcurrency,
0: 	                resultSetHoldability);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.prepareStatement(sql, autoGeneratedKeys);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.prepareStatement(sql, columnIndexes);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.prepareStatement(sql, columnNames);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        physicalConnection_.setHoldability(holdability);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.getHoldability();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.setSavepoint();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        return physicalConnection_.setSavepoint(name);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        physicalConnection_.rollback(savepoint);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
0: 		try {
0: 	        checkForNullPhysicalConnection();
0: 	        physicalConnection_.releaseSavepoint(savepoint);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
1: 		}
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:b2a1747
/////////////////////////////////////////////////////////////////////////
0:                 pooledConnection_.trashConnection(new SqlException(null, 
0:                     new ClientMessageId(
0:                         SQLState.PHYSICAL_CONNECTION_ALREADY_CLOSED)));
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.NO_CURRENT_CONNECTION)); // no call to trashConnection()
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.NO_CURRENT_CONNECTION));
commit:4ac6a1c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(null, 
0:                     new MessageId(SQLState.NO_CURRENT_CONNECTION)); // no call to trashConnection()
/////////////////////////////////////////////////////////////////////////
1:             SqlException se = new SqlException(null, 
0:                 new MessageId(SQLState.NO_CURRENT_CONNECTION));
1:             throw se.getSQLException();
commit:d506170
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: 
/////////////////////////////////////////////////////////////////////////
0:         try {
0:             checkForNullPhysicalConnection();
1:         } catch ( SQLException se ) {
1:             throw new SqlException(se);
1:         }
/////////////////////////////////////////////////////////////////////////
0:     synchronized public void close() throws SQLException {
0:         try
0:             // we also need to loop thru all the logicalStatements and close them
1:             if (physicalConnection_ == null) {
1:                 return;
0:             if (physicalConnection_.agent_.loggingEnabled()) {
0:                 physicalConnection_.agent_.logWriter_.traceEntry(this, "close");
1:             }
1: 
1:             if (physicalConnection_.isClosed()) // connection is closed or has become stale
0:             {
0:                 pooledConnection_.trashConnection(new SqlException(null, "Connection is stale."));
1:             } else {
0:                 physicalConnection_.closeForReuse();
0:                 if (!physicalConnection_.isGlobalPending_()) {
0:                     pooledConnection_.recycleConnection();
1:                 }
1:             }
1:             physicalConnection_ = null;
0:             pooledConnection_.nullLogicalConnection();
0:         catch ( SqlException se )
0:         {
0:             throw se.getSQLException();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     public boolean isClosed() throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     private void checkForNullPhysicalConnection() throws SQLException {
0:             throw new SqlException(null, " Attempt to use a closed connection. ").getSQLException();
0:     synchronized public java.sql.Statement createStatement() throws SQLException {
0:     synchronized public java.sql.PreparedStatement prepareStatement(String sql) throws SQLException {
0:         try {
0:             checkForNullPhysicalConnection();
0:         } catch ( SQLException se ) {
0:             throw new SqlException(se);
1:         }
0:     synchronized public java.sql.CallableStatement prepareCall(String sql) throws SQLException {
0:     public String nativeSQL(String sql) throws SQLException {
1:     synchronized public void setAutoCommit(boolean autoCommit) throws SQLException {
0:     public boolean getAutoCommit() throws SQLException {
1:     synchronized public void commit() throws SQLException {
1:     synchronized public void rollback() throws SQLException {
1:     synchronized public void setTransactionIsolation(int level) throws SQLException {
0:     public int getTransactionIsolation() throws SQLException {
0:     public java.sql.SQLWarning getWarnings() throws SQLException {
1:     synchronized public void clearWarnings() throws SQLException {
0:     public java.sql.DatabaseMetaData getMetaData() throws SQLException {
1:     synchronized public void setReadOnly(boolean readOnly) throws SQLException {
0:     public boolean isReadOnly() throws SQLException {
1:     synchronized public void setCatalog(String catalog) throws SQLException {
0:     public String getCatalog() throws SQLException {
1:                                                            int resultSetConcurrency) throws SQLException {
1:                                                                     int resultSetConcurrency) throws SQLException {
1:                                                                int resultSetConcurrency) throws SQLException {
0:     public java.util.Map getTypeMap() throws SQLException {
0:     synchronized public void setTypeMap(java.util.Map map) throws SQLException {
0:                                               int resultSetHoldability) throws SQLException {
0:                                                   int resultSetHoldability) throws SQLException {
0:             throws SQLException {
0:             throws SQLException {
0:             throws SQLException {
0:             throws SQLException {
0:     public void setHoldability(int holdability) throws SQLException {
0:     public int getHoldability() throws SQLException {
0:     public java.sql.Savepoint setSavepoint() throws SQLException {
0:     public java.sql.Savepoint setSavepoint(String name) throws SQLException {
0:     public void rollback(java.sql.Savepoint savepoint) throws SQLException {
0:     public void releaseSavepoint(java.sql.Savepoint savepoint) throws SQLException {
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
0: public class LogicalConnection implements java.sql.Connection {
0:     private Connection physicalConnection_ = null; // reset to null when the logical connection is closed.
0:     private org.apache.derby.client.ClientPooledConnection pooledConnection_ = null;
0:     public LogicalConnection(Connection physicalConnection,
0:                              org.apache.derby.client.ClientPooledConnection pooledConnection) throws SqlException {
1:         physicalConnection_ = physicalConnection;
1:         pooledConnection_ = pooledConnection;
0:         checkForNullPhysicalConnection();
1: 
0:     protected void finalize() throws java.lang.Throwable {
1:         close();
1:     // Used by ClientPooledConnection close when it disassociates itself from the LogicalConnection
1:     synchronized public void nullPhysicalConnection() {
1:         physicalConnection_ = null;
1:     }
1:     // ------------------------ logical connection close -------------------------
1:     // All methods are simply forwarded to the physical connection, except for close() and isClosed().
0:     synchronized public void close() throws SqlException {
0:         // we also need to loop thru all the logicalStatements and close them
1:         if (physicalConnection_ == null) {
0:             return;
1:         }
0:         if (physicalConnection_.agent_.loggingEnabled()) {
0:             physicalConnection_.agent_.logWriter_.traceEntry(this, "close");
1:         }
0:         if (physicalConnection_.isClosed()) // connection is closed or has become stale
0:         {
0:             pooledConnection_.trashConnection(new SqlException(null, "Connection is stale."));
1:         } else {
0:             physicalConnection_.closeForReuse();
0:             if (!physicalConnection_.isGlobalPending_()) {
0:                 pooledConnection_.recycleConnection();
1:             }
1:         }
1:         physicalConnection_ = null;
0:         pooledConnection_.nullLogicalConnection();
1:     }
1:     synchronized public void closeWithoutRecyclingToPool() throws SqlException {
1:         if (physicalConnection_ == null) {
0:             return;
1:         }
0:         physicalConnection_.checkForTransactionInProgress();
0:         try {
0:             if (physicalConnection_.isClosed()) // connection is closed or has become stale
0:             {
0:                 throw new SqlException(null, "Connection is stale."); // no call to trashConnection()
1:             } else {
1:                 ; // no call to recycleConnection()
1:             }
1:         } finally {
0:             physicalConnection_.closeForReuse();  //poolfix
1:             physicalConnection_ = null;
1:         }
1:     }
0:     public boolean isClosed() throws SqlException {
1:         if (physicalConnection_ == null) {
1:             return true;
1:         }
1:         return physicalConnection_.isClosed();
1:     }
1:     // --------------------------- helper methods --------------------------------
0:     // this method doesn't wrap in the standard way, because it went out without a throws clause.
0:     // Unlike all other LogicalConnection methods, if the physical connection is null, it won't throw an exception, but will return false.
0:     private void checkForNullPhysicalConnection() throws SqlException {
1:         if (physicalConnection_ == null) {
0:             throw new SqlException(null, " Attempt to use a closed connection. ");
1:         }
1:     }
1:     // ---------------------- wrapped public entry points ------------------------
1:     // All methods are forwarded to the physical connection in a standard way
0:     synchronized public java.sql.Statement createStatement() throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.createStatement();
1:     }
0:     synchronized public java.sql.PreparedStatement prepareStatement(String sql) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.prepareStatement(sql);
1:     }
0:     synchronized public PreparedStatement preparePositionedUpdateStatement(String sql, Section querySection) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.preparePositionedUpdateStatement(sql, querySection);
1:     }
0:     synchronized public java.sql.CallableStatement prepareCall(String sql) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.prepareCall(sql);
1:     }
0:     public String nativeSQL(String sql) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.nativeSQL(sql);
1:     }
0:     synchronized public void setAutoCommit(boolean autoCommit) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         physicalConnection_.setAutoCommit(autoCommit);
1:     }
0:     public boolean getAutoCommit() throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.getAutoCommit();
1:     }
0:     synchronized public void commit() throws SqlException {
0:         checkForNullPhysicalConnection();
0:         physicalConnection_.commit();
1:     }
0:     synchronized public void rollback() throws SqlException {
0:         checkForNullPhysicalConnection();
0:         physicalConnection_.rollback();
1:     }
0:     synchronized public void setTransactionIsolation(int level) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         physicalConnection_.setTransactionIsolation(level);
1:     }
0:     public int getTransactionIsolation() throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.getTransactionIsolation();
1:     }
0:     public java.sql.SQLWarning getWarnings() throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.getWarnings();
1:     }
0:     synchronized public void clearWarnings() throws SqlException {
0:         checkForNullPhysicalConnection();
0:         physicalConnection_.clearWarnings();
1:     }
0:     public java.sql.DatabaseMetaData getMetaData() throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.getMetaData();
1:     }
0:     synchronized public void setReadOnly(boolean readOnly) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         physicalConnection_.setReadOnly(readOnly);
1:     }
0:     public boolean isReadOnly() throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.isReadOnly();
1:     }
0:     synchronized public void setCatalog(String catalog) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         physicalConnection_.setCatalog(catalog);
1:     }
0:     public String getCatalog() throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.getCatalog();
1:     }
0:     synchronized public java.sql.Statement createStatement(int resultSetType,
0:                                                            int resultSetConcurrency) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.createStatement(resultSetType, resultSetConcurrency);
1:     }
0:     synchronized public java.sql.PreparedStatement prepareStatement(String sql,
1:                                                                     int resultSetType,
0:                                                                     int resultSetConcurrency) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.prepareStatement(sql, resultSetType, resultSetConcurrency);
1:     }
0:     synchronized public java.sql.CallableStatement prepareCall(String sql,
1:                                                                int resultSetType,
0:                                                                int resultSetConcurrency) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.prepareCall(sql, resultSetType, resultSetConcurrency);
1:     }
0:     public java.util.Map getTypeMap() throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.getTypeMap();
1:     }
0:     synchronized public void setTypeMap(java.util.Map map) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         physicalConnection_.setTypeMap(map);
1:     }
0:     public java.sql.Statement createStatement(int resultSetType, int resultSetConcurrency,
0:                                               int resultSetHoldability) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
1:     }
0:     public java.sql.CallableStatement prepareCall(String sql, int resultSetType,
0:                                                   int resultSetConcurrency,
0:                                                   int resultSetHoldability) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
1:     }
0:     public java.sql.PreparedStatement prepareStatement(String sql, int resultSetType,
0:                                                        int resultSetConcurrency, int resultSetHoldability)
0:             throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.prepareStatement(sql, resultSetType, resultSetConcurrency,
0:                 resultSetHoldability);
1:     }
0:     public java.sql.PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
0:             throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.prepareStatement(sql, autoGeneratedKeys);
1:     }
0:     public java.sql.PreparedStatement prepareStatement(String sql, int columnIndexes[])
0:             throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.prepareStatement(sql, columnIndexes);
1:     }
0:     public java.sql.PreparedStatement prepareStatement(String sql, String columnNames[])
0:             throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.prepareStatement(sql, columnNames);
1:     }
0:     public void setHoldability(int holdability) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         physicalConnection_.setHoldability(holdability);
1:     }
0:     public int getHoldability() throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.getHoldability();
1:     }
0:     public java.sql.Savepoint setSavepoint() throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.setSavepoint();
1:     }
1: 
0:     public java.sql.Savepoint setSavepoint(String name) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         return physicalConnection_.setSavepoint(name);
1:     }
1: 
0:     public void rollback(java.sql.Savepoint savepoint) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         physicalConnection_.rollback(savepoint);
1:     }
1: 
0:     public void releaseSavepoint(java.sql.Savepoint savepoint) throws SqlException {
0:         checkForNullPhysicalConnection();
0:         physicalConnection_.releaseSavepoint(savepoint);
1:     }
1: 
1:     //----------------------------------------------------------------------------
1: 
1:     public int getServerVersion() {
1:         if (physicalConnection_ == null) {
1:             return -1;
1:         } else {
1:             return physicalConnection_.getServerVersion();
1:         }
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.am.LogicalConnection
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.client.am;
1: 
1: 
0: // A simple delegation wrapper handle for a physical connection.
0: // All methods are forwarded to the underlying physical connection except for close() and isClosed().
0: // When a physical connection is wrapped, it is non-null, when the logical connection
0: // is closed, the wrapped physical connection is always set to null.
0: // Both the finalizer and close() methods will always set the physical connection to null.
0: // After the physical conneciton is set to null,
0: // only the Pooled Connection instance will maintain a handle to the physical connection.
0: public class LogicalConnection implements java.sql.Connection
0: {
0:   private Connection physicalConnection_ = null; // reset to null when the logical connection is closed.
0:   private org.apache.derby.client.ClientPooledConnection pooledConnection_ = null;
1: 
0:   public LogicalConnection (Connection physicalConnection,
0:                             org.apache.derby.client.ClientPooledConnection pooledConnection) throws SqlException
0:   {
0:     physicalConnection_ = physicalConnection;
0:     pooledConnection_ = pooledConnection;
0:     checkForNullPhysicalConnection();
0:   }
1: 
0:   protected void finalize () throws java.lang.Throwable
0:   {
0:     close();
0:   }
1: 
0:   // Used by ClientPooledConnection close when it disassociates itself from the LogicalConnection
0:   synchronized public void nullPhysicalConnection ()
0:   {
0:     physicalConnection_ = null;
0:   }
1: 
0:   // ------------------------ logical connection close -------------------------
0:   // All methods are simply forwarded to the physical connection, except for close() and isClosed().
1: 
0:   synchronized public void close () throws SqlException
0:   {
0:     // we also need to loop thru all the logicalStatements and close them
0:     if (physicalConnection_ == null) return;
0:     if (physicalConnection_.agent_.loggingEnabled())
0:       physicalConnection_.agent_.logWriter_.traceEntry (this, "close");
1: 
0:       if (physicalConnection_.isClosed()) // connection is closed or has become stale
0:         pooledConnection_.trashConnection (new SqlException (null, "Connection is stale."));
1: 
0:       else {
0:       physicalConnection_.closeForReuse();
0:       if ( ! physicalConnection_.isGlobalPending_() )
0:         pooledConnection_.recycleConnection();
0:       }
0:       physicalConnection_ = null;
0:     pooledConnection_.nullLogicalConnection();
0:   }
1: 
0:   synchronized public void closeWithoutRecyclingToPool () throws SqlException
0:   {
0:     if (physicalConnection_ == null) return;
0:     physicalConnection_.checkForTransactionInProgress();
0:     try {
0:       if (physicalConnection_.isClosed()) // connection is closed or has become stale
0:         throw new SqlException (null, "Connection is stale."); // no call to trashConnection()
0:       else {
0:         ; // no call to recycleConnection()
0:       }
0:     }
0:     finally {
0:       physicalConnection_.closeForReuse();  //poolfix
0:       physicalConnection_ = null;
0:     }
0:   }
1: 
0:   public boolean isClosed () throws SqlException
0:   {
0:     if (physicalConnection_ == null) return true;
0:     return physicalConnection_.isClosed();
0:   }
1: 
0:   // --------------------------- helper methods --------------------------------
1: 
0:   // this method doesn't wrap in the standard way, because it went out without a throws clause.
0:   // Unlike all other LogicalConnection methods, if the physical connection is null, it won't throw an exception, but will return false.
1: 
0:   private void checkForNullPhysicalConnection () throws SqlException
0:   {
0:     if (physicalConnection_ == null)
0:       throw new SqlException (null, " Attempt to use a closed connection. ");
0:   }
1: 
0:   // ---------------------- wrapped public entry points ------------------------
0:   // All methods are forwarded to the physical connection in a standard way
1: 
0:   synchronized public java.sql.Statement createStatement () throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.createStatement();
0:   }
1: 
0:   synchronized public java.sql.PreparedStatement prepareStatement (String sql) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.prepareStatement(sql);
0:   }
1: 
0:   synchronized public PreparedStatement preparePositionedUpdateStatement (String sql, Section querySection) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.preparePositionedUpdateStatement (sql, querySection);
0:   }
1: 
0:   synchronized public java.sql.CallableStatement prepareCall (String sql) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.prepareCall(sql);
0:   }
1: 
0:   public String nativeSQL (String sql) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.nativeSQL(sql);
0:   }
1: 
0:   synchronized public void setAutoCommit (boolean autoCommit) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     physicalConnection_.setAutoCommit(autoCommit);
0:   }
1: 
0:   public boolean getAutoCommit () throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.getAutoCommit();
0:   }
1: 
0:   synchronized public void commit () throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     physicalConnection_.commit();
0:   }
1: 
0:   synchronized public void rollback () throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     physicalConnection_.rollback();
0:   }
1: 
0:   synchronized public void setTransactionIsolation (int level) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     physicalConnection_.setTransactionIsolation(level);
0:   }
1: 
0:   public int getTransactionIsolation () throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.getTransactionIsolation();
0:   }
1: 
0:   public java.sql.SQLWarning getWarnings () throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.getWarnings();
0:   }
1: 
0:   synchronized public void clearWarnings () throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     physicalConnection_.clearWarnings();
0:   }
1: 
0:   public java.sql.DatabaseMetaData getMetaData () throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.getMetaData();
0:   }
1: 
0:   synchronized public void setReadOnly (boolean readOnly) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     physicalConnection_.setReadOnly (readOnly);
0:   }
1: 
0:   public boolean isReadOnly () throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.isReadOnly();
0:   }
1: 
0:   synchronized public void setCatalog (String catalog) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     physicalConnection_.setCatalog(catalog);
0:   }
1: 
0:   public String getCatalog () throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.getCatalog();
0:   }
1: 
0:   synchronized public java.sql.Statement createStatement (int resultSetType,
0:                                                           int resultSetConcurrency) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.createStatement(resultSetType, resultSetConcurrency);
0:   }
1: 
0:   synchronized public java.sql.PreparedStatement prepareStatement (String sql,
0:                                                                    int resultSetType,
0:                                                                    int resultSetConcurrency) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.prepareStatement(sql, resultSetType, resultSetConcurrency);
0:   }
1: 
0:   synchronized public java.sql.CallableStatement prepareCall (String sql,
0:                                                               int resultSetType,
0:                                                               int resultSetConcurrency) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.prepareCall(sql,  resultSetType, resultSetConcurrency);
0:   }
1: 
0:   public java.util.Map getTypeMap () throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.getTypeMap();
0:   }
1: 
0:   synchronized public void setTypeMap (java.util.Map map) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     physicalConnection_.setTypeMap(map);
0:   }
1: 
0:   public java.sql.Statement createStatement(int resultSetType, int resultSetConcurrency,
0: 			      int resultSetHoldability) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
0:   }
1: 
0:   public java.sql.CallableStatement prepareCall(String sql, int resultSetType,
0: 				  int resultSetConcurrency,
0: 				  int resultSetHoldability) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
0:   }
1: 
0:   public java.sql.PreparedStatement prepareStatement(String sql, int resultSetType,
0: 				       int resultSetConcurrency, int resultSetHoldability)
0: 	throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.prepareStatement(sql, resultSetType, resultSetConcurrency,
0:       resultSetHoldability);
0:   }
1: 
0:   public java.sql.PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
0: 	throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.prepareStatement(sql, autoGeneratedKeys);
0:   }
1: 
0:   public java.sql.PreparedStatement prepareStatement(String sql, int columnIndexes[])
0: 	throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.prepareStatement(sql, columnIndexes);
0:   }
1: 
0:   public java.sql.PreparedStatement prepareStatement(String sql, String columnNames[])
0: 	throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.prepareStatement(sql, columnNames);
0:   }
1: 
0:   public void setHoldability(int holdability) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     physicalConnection_.setHoldability(holdability);
0:   }
1: 
0:   public int getHoldability() throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.getHoldability();
0:   }
1: 
0:   public java.sql.Savepoint setSavepoint() throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.setSavepoint ();
0:   }
1: 
0:   public java.sql.Savepoint setSavepoint(String name) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     return physicalConnection_.setSavepoint (name);
0:   }
1: 
0:   public void rollback(java.sql.Savepoint savepoint) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     physicalConnection_.rollback (savepoint);
0:   }
1: 
0:   public void releaseSavepoint(java.sql.Savepoint savepoint) throws SqlException
0:   {
0:     checkForNullPhysicalConnection();
0:     physicalConnection_.releaseSavepoint (savepoint);
0:   }
1: 
0:   //----------------------------------------------------------------------------
1: 
0:   public int getServerVersion()
0:   {
0:     if (physicalConnection_ == null)
0:       return -1;
0:     else
0:       return physicalConnection_.getServerVersion();
0:   }
1: 
0: }
============================================================================