1:a69fa12: /*
4:a69fa12: 
1:a69fa12:    Derby - Class org.apache.derbyTesting.functionTests.tests.compatibility.VersionCombinationConfigurator
1:a69fa12: 
1:a69fa12:    Licensed to the Apache Software Foundation (ASF) under one or more
1:a69fa12:    contributor license agreements.  See the NOTICE file distributed with
1:a69fa12:    this work for additional information regarding copyright ownership.
1:a69fa12:    The ASF licenses this file to you under the Apache License, Version 2.0
1:a69fa12:    (the "License"); you may not use this file except in compliance with
1:a69fa12:    the License.  You may obtain a copy of the License at
1:a69fa12: 
1:a69fa12:       http://www.apache.org/licenses/LICENSE-2.0
1:a69fa12: 
1:a69fa12:    Unless required by applicable law or agreed to in writing, software
1:a69fa12:    distributed under the License is distributed on an "AS IS" BASIS,
1:a69fa12:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a69fa12:    See the License for the specific language governing permissions and
1:a69fa12:    limitations under the License.
1:a69fa12: 
1:a69fa12:  */
1:a69fa12: package org.apache.derbyTesting.functionTests.tests.compatibility;
1:a69fa12: 
1:a69fa12: import java.io.File;
1:8294912: import java.net.URI;
1:1ae02c9: import java.net.URISyntaxException;
1:a69fa12: import java.security.AccessController;
1:8294912: import java.security.CodeSource;
1:a69fa12: import java.security.PrivilegedAction;
1:a69fa12: import java.util.ArrayList;
1:a69fa12: import java.util.Collections;
1:a69fa12: import java.util.List;
1:a69fa12: import junit.extensions.TestSetup;
1:a69fa12: import org.apache.derby.tools.sysinfo;
1:a69fa12: import org.apache.derbyTesting.junit.BaseTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:a69fa12: import org.apache.derbyTesting.junit.DerbyDistribution;
1:a69fa12: import org.apache.derbyTesting.junit.DerbyVersion;
1:4131bd7: import org.apache.derbyTesting.junit.JDBC;
1:a69fa12: import org.apache.derbyTesting.junit.TestConfiguration;
1:a69fa12: 
1:a69fa12: /**
1:a69fa12:  * Generates a set of client-server combinations to run the compatibility
1:a69fa12:  * tests for.
1:a69fa12:  * <p>
1:a69fa12:  * Due to the requirement for running with a variety of Derby versions, the
1:a69fa12:  * compatibility test suite is run as multiple processes. The test is
1:a69fa12:  * controlled from the main process (the process in which the test/suite is
1:a69fa12:  * started), and this process spawns additional processes for each server
1:a69fa12:  * version and each client version. In some cases it also has to spawn
1:a69fa12:  * additional processes to accomplish other tasks.
1:a69fa12:  * <p>
1:a69fa12:  * For development purposes the default MATS suite is sufficient for ongoing
1:a69fa12:  * work. Eventually, and at least before cutting a new release, the full
1:a69fa12:  * development suite should be run, since it will test the trunk against all
1:a69fa12:  * previous releases. The other suites will test old releases against each
1:a69fa12:  * other, and as such they are of less interest since the old releases don't
1:a69fa12:  * change. Note however that these suites can be used to test releases on
1:a69fa12:  * branches where this version of the compatibility test doesn't exist (just
1:a69fa12:  * add the JARs to the release repository and configure includes or excludes
1:a69fa12:  * to suite your needs).
1:a69fa12:  * <p>
1:a69fa12:  * <strong>NOTE 1</strong>: The set of combinations computed by this class
1:a69fa12:  * depends on the number of old releases available on the local computer. If
1:a69fa12:  * there are no old releases available a warning will be emitted, but the test
1:a69fa12:  * won't fail (it will test trunk vs trunk).
1:a69fa12:  * <p>
1:a69fa12:  * <strong>NOTE 2</strong>: trunk is defined as a distribution, although it
1:a69fa12:  * hasn't been released yet. The reason is simple: we always want to test trunk
1:a69fa12:  * for incompatibilities against older versions.
1:a69fa12:  */
1:a69fa12: public class VersionCombinationConfigurator {
1:a69fa12: 
1:572f3e8:     private static final String EMB_DRIVER =
1:572f3e8:                                     "org.apache.derby.jdbc.EmbeddedDriver";
1:572f3e8: 
1:a69fa12:     /** Name of the configuration, only used for informational purposes. */
1:a69fa12:     private final String name;
1:a69fa12:     /** Decides if combinations have to involve trunk (as server or client). */
1:a69fa12:     private final boolean limitToTrunk;
1:a69fa12:     /** Decides if only the latest branch release is eligible for inclusion. */
1:a69fa12:     private final boolean newestFixpackOnly;
1:a69fa12:     private List<DerbyVersion> toInclude = Collections.emptyList();
1:a69fa12:     private List<DerbyVersion> toExclude = Collections.emptyList();
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Returns the default configuration intended to be run as part of
1:a69fa12:      * <tt>suites.all</tt>, which is a kind of minimal acceptance test (MATS).
1:a69fa12:      * <p>
1:a69fa12:      * The default configuration is defined to be all combinations that have
1:a69fa12:      * trunk as either the server or the client.
1:a69fa12:      *
1:a69fa12:      * @return A configurator generating the default set of tests.
1:a69fa12:      */
1:a69fa12:     public static VersionCombinationConfigurator getInstanceDevMATS() {
1:a69fa12:         return new VersionCombinationConfigurator(
1:a69fa12:                 "default/MATS configuration", true, true);
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Returns a configuration that will test trunk against all other available
1:a69fa12:      * releases.
1:a69fa12:      *
1:a69fa12:      * @return A configurator generating the default set of tests.
1:a69fa12:      */
1:a69fa12:     public static VersionCombinationConfigurator getInstanceDevFull() {
1:a69fa12:         return new VersionCombinationConfigurator(
1:a69fa12:                 "full development configuration", true, false);
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Returns a configuration where the newest releases within each
1:a69fa12:      * major-minor version are tested against each other.
1:a69fa12:      * <p>
1:a69fa12:      * Given releases designated <tt>M.m.f.p</tt> (i.e. 10.8.1.2), this
1:a69fa12:      * configuration will include all major-minor releases with the highest
1:a69fa12:      * <ff>f</ff>.
1:a69fa12:      *
1:a69fa12:      * @return A configurator generating a reasonably sized test set.
1:a69fa12:      */
1:a69fa12:     public static VersionCombinationConfigurator getInstanceOld() {
1:a69fa12:         return new VersionCombinationConfigurator(
1:a69fa12:                 "historical configuration", false, true);
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Returns a configuration where all versions found are tested against
1:a69fa12:      * each other.
1:a69fa12:      *
1:a69fa12:      * @return  A configurator generating the full set of tests.
1:a69fa12:      */
1:a69fa12:     public static VersionCombinationConfigurator getInstanceOldFull() {
1:a69fa12:         return new VersionCombinationConfigurator(
1:a69fa12:                 "full historical configuration", false, false);
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Creates a version combination configurator.
1:a69fa12:      *
1:a69fa12:      * @param name name of the configurator
1:a69fa12:      * @param limitToTrunk if true, only add combinations including trunk
1:a69fa12:      * @param newestFixpackOnly whether or not to only include the newest
1:a69fa12:      *      release within each pair of major-minor version.
1:a69fa12:      */
1:a69fa12:     private VersionCombinationConfigurator(String name,
1:a69fa12:                                            boolean limitToTrunk,
1:a69fa12:                                            boolean newestFixpackOnly) {
1:a69fa12:         this.name = name;
1:a69fa12:         this.limitToTrunk = limitToTrunk;
1:a69fa12:         this.newestFixpackOnly = newestFixpackOnly;
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     public String getName() {
1:a69fa12:         return name;
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Adds compatibility tests to the specified suite.
1:a69fa12:      * <p>
1:a69fa12:      * The following determines how many tests are added:
1:a69fa12:      * <ul> <li>available distributions locally (release repository)</li>
1:a69fa12:      *      <li>list of includes and/or excludes (by default empty)</li>
1:a69fa12:      *      <li>the configurator's current settings</li>
1:a69fa12:      * </ul>
1:a69fa12:      *
1:a69fa12:      * @param suite the suite to add the tests to
1:a69fa12:      * @return Number of compatibility runs added.
1:a69fa12:      */
1:1ae02c9:     public int addTests(BaseTestSuite suite) {
1:a69fa12:         int runsAdded = 0;
1:a69fa12:         List<DerbyDistribution> dists = filterVersions();
1:a69fa12:         DerbyDistribution newestDist = dists.get(0);
1:a69fa12:         String newestTestingCode = newestDist.getTestingClasspath();
1:a69fa12:         // Generate a list of all the combinations.
1:a69fa12:         for (DerbyDistribution server : dists) {
1:a69fa12:             DerbyVersion serverVersion = server.getVersion();
1:4131bd7: 
1:4131bd7:             // Check if testing of this server version should be skipped.
1:4131bd7:             if (skipServerVersion(serverVersion)) {
1:4131bd7:                 continue;
1:4131bd7:             }
1:4131bd7: 
1:1ae02c9:             BaseTestSuite clientSuites = new BaseTestSuite(
1:a69fa12:                     "Client runs against server " + serverVersion.toString());
1:a69fa12:             for (DerbyDistribution client : dists) {
1:a69fa12:                 if (limitToTrunk && !server.equals(newestDist) &&
1:a69fa12:                         !client.equals(newestDist)) {
1:a69fa12:                     continue;
1:a69fa12:                 }
1:a69fa12:                 clientSuites.addTest(
1:a69fa12:                         new ClientCompatibilityRunControl(
1:a69fa12:                                     client, newestTestingCode, serverVersion));
1:a69fa12:                 runsAdded++;
1:a69fa12:             }
1:a69fa12:             TestSetup setup = new VersionedNetworkServerTestSetup(
1:a69fa12:                     clientSuites, server, newestTestingCode);
1:a69fa12:             suite.addTest(setup);
1:a69fa12:         }
1:a69fa12:         return runsAdded;
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     public void setIncludes(List<DerbyVersion> toInclude) {
1:a69fa12:         if (toInclude != null) {
1:a69fa12:             this.toInclude = toInclude;
1:a69fa12:         }
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     public void setExcludes(List<DerbyVersion> toExclude) {
1:a69fa12:         if (toExclude != null) {
1:a69fa12:             this.toExclude = toExclude;
1:a69fa12:         }
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:4131bd7:      * Check if a certain server version should be skipped due to bugs that
1:4131bd7:      * prevent it from working in the current environment.
1:4131bd7:      *
1:4131bd7:      * @param version the server version to check
1:4131bd7:      * @return {@code true} if the specified version should be skipped, or
1:4131bd7:      * {@code false} otherwise
1:4131bd7:      */
1:4131bd7:     private boolean skipServerVersion(DerbyVersion version) {
1:4131bd7: 
1:4131bd7:         // DERBY-6098: Skip testing of server versions less than 10.10 if
1:4131bd7:         // the JVM doesn't support JNDI. Earlier versions of the server don't
1:4131bd7:         // accept connections if JNDI is not present.
1:4131bd7:         if (!JDBC.vmSupportsJNDI() && version.lessThan(DerbyVersion._10_10)) {
1:4131bd7:             println("Server version " + version + " was skipped because " +
1:4131bd7:                     "it requires JNDI to run.");
1:4131bd7:             return true;
1:4131bd7:         }
1:4131bd7: 
1:4131bd7:         // Default: don't skip
1:4131bd7:         return false;
1:4131bd7:     }
1:4131bd7: 
1:4131bd7:     /**
1:a69fa12:      * Filters Derby distributions available in the distribution repository.
1:a69fa12:      *
1:a69fa12:      * @return A list of available and accepted Derby distributions.
1:a69fa12:      */
1:a69fa12:     private List<DerbyDistribution> filterVersions() {
1:a69fa12:         DerbyDistribution[] dists =
1:a69fa12:                 TestConfiguration.getReleaseRepository().getDistributions();
1:a69fa12:         List<DerbyDistribution> qualifiedDists =
1:a69fa12:                 new ArrayList<DerbyDistribution>();
1:a69fa12:         for (DerbyDistribution dist: dists) {
1:a69fa12:             // Handle includes and excludes.
1:a69fa12:             DerbyVersion version = dist.getVersion();
1:a69fa12:             if (!toInclude.isEmpty() && !toInclude.contains(version)) {
1:a69fa12:                 println(version.toString() + " not in include list");
1:a69fa12:                 continue;
1:a69fa12:             }
1:a69fa12:             if (!toExclude.isEmpty() && toExclude.contains(version)) {
1:a69fa12:                 println(version.toString() + " in exclude list");
1:a69fa12:                 continue;
1:a69fa12:             }
1:a69fa12: 
1:a69fa12:             qualifiedDists.add(dist);
1:a69fa12:         }
1:a69fa12:         // If there are no qualified old distributions at this point, sound the
1:a69fa12:         // alarm as we're probably looking at a misconfiguration.
1:a69fa12:         if (qualifiedDists.isEmpty()) {
1:a69fa12:             alarm("No old releases found for current configuration/environment");
1:a69fa12:         }
1:a69fa12: 
1:a69fa12:         // Now add the version we are running off.
1:a69fa12:         DerbyDistribution runningDist = getRunningDistribution();
1:a69fa12:         if (!qualifiedDists.contains(runningDist)) {
1:a69fa12:             qualifiedDists.add(runningDist);
1:a69fa12:         }
1:a69fa12:         qualifiedDists = sortAndFilterVersions(qualifiedDists);
1:a69fa12: 
1:a69fa12:         println("--- " + qualifiedDists.size() + " distributions qualified");
1:a69fa12:         for (DerbyDistribution d : qualifiedDists) {
1:a69fa12:             println(d.getVersion().toString());
1:a69fa12:         }
1:a69fa12: 
1:a69fa12:         return qualifiedDists;
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:a69fa12:      * Returns the running distribution, which is typically trunk.
1:a69fa12:      *
1:a69fa12:      * @return Information about the running distribution.
1:572f3e8:      * @throws IllegalStateException if parsing the version string fails, if
1:572f3e8:      *      required Derby classes are missing, or if trunk is run off the
1:572f3e8:      *      classes directory
1:a69fa12:      */
1:a69fa12:     private DerbyDistribution getRunningDistribution() {
1:572f3e8:         File libDir;
1:572f3e8:         try {
1:572f3e8:             libDir = getJarDirectoryOf(Class.forName(EMB_DRIVER));
1:572f3e8:         } catch (ClassNotFoundException cnfe) {
1:572f3e8:             // Add relevant information to the error message, the cause and
1:572f3e8:             // its stack trace is not printed by default in this context.
1:572f3e8:             throw new IllegalStateException(
1:572f3e8:                     "missing Derby class: " + cnfe.getMessage(), cnfe);
1:a69fa12:         }
1:572f3e8:         File testingDir = getJarDirectoryOf(getClass());
1:a69fa12:         DerbyVersion version = DerbyVersion.parseVersionString(
1:a69fa12:                 sysinfo.getVersionString());
1:572f3e8:         DerbyDistribution dist = DerbyDistribution.newInstance(
1:572f3e8:                                                 version, libDir, testingDir);
1:8294912:         if (dist == null) {
1:8294912:             throw new IllegalStateException(
1:8294912:                     "failed to get running distribution (programming error?)");
1:8294912:         }
1:8294912:         return dist;
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:572f3e8:      * Returns the directory for the JAR file containing the given class.
1:572f3e8:      *
1:572f3e8:      * @return A directory path.
1:572f3e8:      * @throws IllegalStateException if the class isn't loaded from a JAR
1:572f3e8:      */
1:572f3e8:     private File getJarDirectoryOf(Class clazz) {
1:572f3e8:         File jarPath = new File(getClassURI(clazz));
1:572f3e8:         if (jarPath.isDirectory()) {
1:572f3e8:             throw new IllegalStateException("only running off jars is " +
1:572f3e8:                     "supported, currently running off directory " + jarPath);
1:572f3e8:         }
1:572f3e8:         // Get the directory the JAR file is living in.
1:572f3e8:         return jarPath.getParentFile();
1:572f3e8:     }
1:572f3e8: 
1:572f3e8:     /**
1:a69fa12:      * Sorts and filters out distributions based on the configurator settings.
1:a69fa12:      *
1:a69fa12:      * @param distributions list of distributions to filter
1:a69fa12:      * @return A filtered list of distributions.
1:a69fa12:      */
1:a69fa12:     private List<DerbyDistribution> sortAndFilterVersions(
1:a69fa12:             List<DerbyDistribution> distributions) {
1:a69fa12:         // Sort the releases based on the version number (highest first).
1:a69fa12:         Collections.sort(distributions);
1:a69fa12:         Collections.reverse(distributions);
1:a69fa12: 
1:a69fa12:         DerbyDistribution prev = null;
1:a69fa12:         if (newestFixpackOnly) {
1:a69fa12:             List<DerbyDistribution> filtered =
1:a69fa12:                     new ArrayList<DerbyDistribution>();
1:a69fa12:             for (DerbyDistribution d : distributions) {
1:a69fa12:                 DerbyVersion ver = d.getVersion();
1:a69fa12:                 if (prev == null || prev.getVersion().greaterMinorThan(ver)) {
1:a69fa12:                     filtered.add(d);
1:a69fa12:                 } else {
1:a69fa12:                     println("ignored " + ver.toString() +
1:a69fa12:                             ", not the newest fixpack version for " +
1:a69fa12:                             ver.getMajor() + "." + ver.getMinor());
1:a69fa12:                 }
1:a69fa12:                 prev = d;
1:a69fa12:             }
1:a69fa12:             distributions = filtered;
1:a69fa12:         }
1:a69fa12:         return distributions;
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     /**
1:8294912:      * Returns the URI of the source for the specified class.
1:a69fa12:      *
1:a69fa12:      * @param cl class to find the source for
1:8294912:      * @return A {@code URI} pointing to the source, or {@code null} it cannot
1:a69fa12:      *      be obtained.
1:a69fa12:      */
1:8294912:     static URI getClassURI(final Class cl) {
1:8294912:         return AccessController.doPrivileged(new PrivilegedAction<URI>() {
1:8294912:             public URI run() {
1:8294912:                 CodeSource cs = cl.getProtectionDomain().getCodeSource();
1:8294912:                 if (cs != null) {
1:8294912:                     try {
1:8294912:                         return cs.getLocation().toURI();
1:8294912:                     } catch (URISyntaxException use) {
1:8294912:                         // Shouldn't happen, fall through and return null.
1:8294912:                         BaseTestCase.alarm("bad URI: " + use.getMessage());
1:8294912:                     }
1:a69fa12:                 }
1:8294912:                 return null;
1:a69fa12:             }
1:a69fa12:         });
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     // Forwarding convenience methods
1:a69fa12: 
1:a69fa12:     private static void println(String msg) {
1:a69fa12:         BaseTestCase.println(msg);
1:a69fa12:     }
1:a69fa12: 
1:a69fa12:     private static void alarm(String msg) {
1:a69fa12:         BaseTestCase.alarm(msg);
1:a69fa12:     }
1:a69fa12: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.net.URISyntaxException;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:     public int addTests(BaseTestSuite suite) {
/////////////////////////////////////////////////////////////////////////
1:             BaseTestSuite clientSuites = new BaseTestSuite(
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:572f3e8
/////////////////////////////////////////////////////////////////////////
1:     private static final String EMB_DRIVER =
1:                                     "org.apache.derby.jdbc.EmbeddedDriver";
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @throws IllegalStateException if parsing the version string fails, if
1:      *      required Derby classes are missing, or if trunk is run off the
1:      *      classes directory
1:         File libDir;
1:         try {
1:             libDir = getJarDirectoryOf(Class.forName(EMB_DRIVER));
1:         } catch (ClassNotFoundException cnfe) {
1:             // Add relevant information to the error message, the cause and
1:             // its stack trace is not printed by default in this context.
1:             throw new IllegalStateException(
1:                     "missing Derby class: " + cnfe.getMessage(), cnfe);
1:         File testingDir = getJarDirectoryOf(getClass());
1:         DerbyDistribution dist = DerbyDistribution.newInstance(
1:                                                 version, libDir, testingDir);
/////////////////////////////////////////////////////////////////////////
1:      * Returns the directory for the JAR file containing the given class.
1:      *
1:      * @return A directory path.
1:      * @throws IllegalStateException if the class isn't loaded from a JAR
1:      */
1:     private File getJarDirectoryOf(Class clazz) {
1:         File jarPath = new File(getClassURI(clazz));
1:         if (jarPath.isDirectory()) {
1:             throw new IllegalStateException("only running off jars is " +
1:                     "supported, currently running off directory " + jarPath);
1:         }
1:         // Get the directory the JAR file is living in.
1:         return jarPath.getParentFile();
1:     }
1: 
1:     /**
commit:a784994
/////////////////////////////////////////////////////////////////////////
commit:4131bd7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1: 
1:             // Check if testing of this server version should be skipped.
1:             if (skipServerVersion(serverVersion)) {
1:                 continue;
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Check if a certain server version should be skipped due to bugs that
1:      * prevent it from working in the current environment.
1:      *
1:      * @param version the server version to check
1:      * @return {@code true} if the specified version should be skipped, or
1:      * {@code false} otherwise
1:      */
1:     private boolean skipServerVersion(DerbyVersion version) {
1: 
1:         // DERBY-6098: Skip testing of server versions less than 10.10 if
1:         // the JVM doesn't support JNDI. Earlier versions of the server don't
1:         // accept connections if JNDI is not present.
1:         if (!JDBC.vmSupportsJNDI() && version.lessThan(DerbyVersion._10_10)) {
1:             println("Server version " + version + " was skipped because " +
1:                     "it requires JNDI to run.");
1:             return true;
1:         }
1: 
1:         // Default: don't skip
1:         return false;
1:     }
1: 
1:     /**
commit:654f47f
/////////////////////////////////////////////////////////////////////////
0:         return AccessController.doPrivileged(new PrivilegedAction<URL>() {
0:             public URL run() {
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:8294912
/////////////////////////////////////////////////////////////////////////
0: import java.net.URISyntaxException;
1: import java.net.URI;
1: import java.security.CodeSource;
/////////////////////////////////////////////////////////////////////////
0:         File libDir = new File(getClassURI(getClass()));
/////////////////////////////////////////////////////////////////////////
0:         DerbyDistribution dist = DerbyDistribution.getInstance(libDir, version);
1:         if (dist == null) {
1:             throw new IllegalStateException(
1:                     "failed to get running distribution (programming error?)");
1:         }
1:         return dist;
/////////////////////////////////////////////////////////////////////////
1:      * Returns the URI of the source for the specified class.
1:      * @return A {@code URI} pointing to the source, or {@code null} it cannot
1:     static URI getClassURI(final Class cl) {
1:         return AccessController.doPrivileged(new PrivilegedAction<URI>() {
1:             public URI run() {
1:                 CodeSource cs = cl.getProtectionDomain().getCodeSource();
1:                 if (cs != null) {
1:                     try {
1:                         return cs.getLocation().toURI();
1:                     } catch (URISyntaxException use) {
1:                         // Shouldn't happen, fall through and return null.
1:                         BaseTestCase.alarm("bad URI: " + use.getMessage());
1:                     }
1:                 return null;
commit:a69fa12
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.compatibility.VersionCombinationConfigurator
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.compatibility;
1: 
1: import java.io.File;
0: import java.net.URL;
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import java.util.ArrayList;
1: import java.util.Collections;
1: import java.util.List;
1: 
1: import junit.extensions.TestSetup;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derby.tools.sysinfo;
1: import org.apache.derbyTesting.junit.BaseTestCase;
1: import org.apache.derbyTesting.junit.DerbyDistribution;
1: import org.apache.derbyTesting.junit.DerbyVersion;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Generates a set of client-server combinations to run the compatibility
1:  * tests for.
1:  * <p>
1:  * Due to the requirement for running with a variety of Derby versions, the
1:  * compatibility test suite is run as multiple processes. The test is
1:  * controlled from the main process (the process in which the test/suite is
1:  * started), and this process spawns additional processes for each server
1:  * version and each client version. In some cases it also has to spawn
1:  * additional processes to accomplish other tasks.
1:  * <p>
1:  * For development purposes the default MATS suite is sufficient for ongoing
1:  * work. Eventually, and at least before cutting a new release, the full
1:  * development suite should be run, since it will test the trunk against all
1:  * previous releases. The other suites will test old releases against each
1:  * other, and as such they are of less interest since the old releases don't
1:  * change. Note however that these suites can be used to test releases on
1:  * branches where this version of the compatibility test doesn't exist (just
1:  * add the JARs to the release repository and configure includes or excludes
1:  * to suite your needs).
1:  * <p>
1:  * <strong>NOTE 1</strong>: The set of combinations computed by this class
1:  * depends on the number of old releases available on the local computer. If
1:  * there are no old releases available a warning will be emitted, but the test
1:  * won't fail (it will test trunk vs trunk).
1:  * <p>
1:  * <strong>NOTE 2</strong>: trunk is defined as a distribution, although it
1:  * hasn't been released yet. The reason is simple: we always want to test trunk
1:  * for incompatibilities against older versions.
1:  */
1: public class VersionCombinationConfigurator {
1: 
1:     /** Name of the configuration, only used for informational purposes. */
1:     private final String name;
1:     /** Decides if combinations have to involve trunk (as server or client). */
1:     private final boolean limitToTrunk;
1:     /** Decides if only the latest branch release is eligible for inclusion. */
1:     private final boolean newestFixpackOnly;
1:     private List<DerbyVersion> toInclude = Collections.emptyList();
1:     private List<DerbyVersion> toExclude = Collections.emptyList();
1: 
1:     /**
1:      * Returns the default configuration intended to be run as part of
1:      * <tt>suites.all</tt>, which is a kind of minimal acceptance test (MATS).
1:      * <p>
1:      * The default configuration is defined to be all combinations that have
1:      * trunk as either the server or the client.
1:      *
1:      * @return A configurator generating the default set of tests.
1:      */
1:     public static VersionCombinationConfigurator getInstanceDevMATS() {
1:         return new VersionCombinationConfigurator(
1:                 "default/MATS configuration", true, true);
1:     }
1: 
1:     /**
1:      * Returns a configuration that will test trunk against all other available
1:      * releases.
1:      *
1:      * @return A configurator generating the default set of tests.
1:      */
1:     public static VersionCombinationConfigurator getInstanceDevFull() {
1:         return new VersionCombinationConfigurator(
1:                 "full development configuration", true, false);
1:     }
1: 
1:     /**
1:      * Returns a configuration where the newest releases within each
1:      * major-minor version are tested against each other.
1:      * <p>
1:      * Given releases designated <tt>M.m.f.p</tt> (i.e. 10.8.1.2), this
1:      * configuration will include all major-minor releases with the highest
1:      * <ff>f</ff>.
1:      *
1:      * @return A configurator generating a reasonably sized test set.
1:      */
1:     public static VersionCombinationConfigurator getInstanceOld() {
1:         return new VersionCombinationConfigurator(
1:                 "historical configuration", false, true);
1:     }
1: 
1:     /**
1:      * Returns a configuration where all versions found are tested against
1:      * each other.
1:      *
1:      * @return  A configurator generating the full set of tests.
1:      */
1:     public static VersionCombinationConfigurator getInstanceOldFull() {
1:         return new VersionCombinationConfigurator(
1:                 "full historical configuration", false, false);
1:     }
1: 
1:     /**
1:      * Creates a version combination configurator.
1:      *
1:      * @param name name of the configurator
1:      * @param limitToTrunk if true, only add combinations including trunk
1:      * @param newestFixpackOnly whether or not to only include the newest
1:      *      release within each pair of major-minor version.
1:      */
1:     private VersionCombinationConfigurator(String name,
1:                                            boolean limitToTrunk,
1:                                            boolean newestFixpackOnly) {
1:         this.name = name;
1:         this.limitToTrunk = limitToTrunk;
1:         this.newestFixpackOnly = newestFixpackOnly;
1:     }
1: 
1:     public String getName() {
1:         return name;
1:     }
1: 
1:     /**
1:      * Adds compatibility tests to the specified suite.
1:      * <p>
1:      * The following determines how many tests are added:
1:      * <ul> <li>available distributions locally (release repository)</li>
1:      *      <li>list of includes and/or excludes (by default empty)</li>
1:      *      <li>the configurator's current settings</li>
1:      * </ul>
1:      *
1:      * @param suite the suite to add the tests to
1:      * @return Number of compatibility runs added.
1:      */
0:     public int addTests(TestSuite suite) {
1:         int runsAdded = 0;
1:         List<DerbyDistribution> dists = filterVersions();
1:         DerbyDistribution newestDist = dists.get(0);
1:         String newestTestingCode = newestDist.getTestingClasspath();
1:         // Generate a list of all the combinations.
1:         for (DerbyDistribution server : dists) {
1:             DerbyVersion serverVersion = server.getVersion();
0:             TestSuite clientSuites = new TestSuite(
1:                     "Client runs against server " + serverVersion.toString());
1:             for (DerbyDistribution client : dists) {
1:                 if (limitToTrunk && !server.equals(newestDist) &&
1:                         !client.equals(newestDist)) {
1:                     continue;
1:                 }
1:                 clientSuites.addTest(
1:                         new ClientCompatibilityRunControl(
1:                                     client, newestTestingCode, serverVersion));
1:                 runsAdded++;
1:             }
1:             TestSetup setup = new VersionedNetworkServerTestSetup(
1:                     clientSuites, server, newestTestingCode);
1:             suite.addTest(setup);
1:         }
1:         return runsAdded;
1:     }
1: 
1:     public void setIncludes(List<DerbyVersion> toInclude) {
1:         if (toInclude != null) {
1:             this.toInclude = toInclude;
1:         }
1:     }
1: 
1:     public void setExcludes(List<DerbyVersion> toExclude) {
1:         if (toExclude != null) {
1:             this.toExclude = toExclude;
1:         }
1:     }
1: 
1:     /**
1:      * Filters Derby distributions available in the distribution repository.
1:      *
1:      * @return A list of available and accepted Derby distributions.
1:      */
1:     private List<DerbyDistribution> filterVersions() {
1:         DerbyDistribution[] dists =
1:                 TestConfiguration.getReleaseRepository().getDistributions();
1:         List<DerbyDistribution> qualifiedDists =
1:                 new ArrayList<DerbyDistribution>();
1:         for (DerbyDistribution dist: dists) {
1:             // Handle includes and excludes.
1:             DerbyVersion version = dist.getVersion();
1:             if (!toInclude.isEmpty() && !toInclude.contains(version)) {
1:                 println(version.toString() + " not in include list");
1:                 continue;
1:             }
1:             if (!toExclude.isEmpty() && toExclude.contains(version)) {
1:                 println(version.toString() + " in exclude list");
1:                 continue;
1:             }
1: 
1:             qualifiedDists.add(dist);
1:         }
1:         // If there are no qualified old distributions at this point, sound the
1:         // alarm as we're probably looking at a misconfiguration.
1:         if (qualifiedDists.isEmpty()) {
1:             alarm("No old releases found for current configuration/environment");
1:         }
1: 
1:         // Now add the version we are running off.
1:         DerbyDistribution runningDist = getRunningDistribution();
1:         if (!qualifiedDists.contains(runningDist)) {
1:             qualifiedDists.add(runningDist);
1:         }
1:         qualifiedDists = sortAndFilterVersions(qualifiedDists);
1: 
1:         println("--- " + qualifiedDists.size() + " distributions qualified");
1:         for (DerbyDistribution d : qualifiedDists) {
1:             println(d.getVersion().toString());
1:         }
1: 
1:         return qualifiedDists;
1:     }
1: 
1:     /**
1:      * Returns the running distribution, which is typically trunk.
1:      *
1:      * @return Information about the running distribution.
0:      * @throws IllegalArgumentException if parsing the version string fails, or
0:      *      if trunk is run off the classes directory
1:      */
1:     private DerbyDistribution getRunningDistribution() {
0:         URL testingURL = getClassURL(getClass());
0:         File libDir = new File(testingURL.getPath());
0:         if (libDir.isDirectory()) {
0:             throw new IllegalStateException("only running off jars is " +
0:                     "supported, currently running off " + libDir);
1:         }
0:         // Get the directory the JAR file is living in.
0:         libDir = libDir.getParentFile();
1:         DerbyVersion version = DerbyVersion.parseVersionString(
1:                 sysinfo.getVersionString());
0:         return DerbyDistribution.getInstance(libDir, version);
1:     }
1: 
1:     /**
1:      * Sorts and filters out distributions based on the configurator settings.
1:      *
1:      * @param distributions list of distributions to filter
1:      * @return A filtered list of distributions.
1:      */
1:     private List<DerbyDistribution> sortAndFilterVersions(
1:             List<DerbyDistribution> distributions) {
1:         // Sort the releases based on the version number (highest first).
1:         Collections.sort(distributions);
1:         Collections.reverse(distributions);
1: 
1:         DerbyDistribution prev = null;
1:         if (newestFixpackOnly) {
1:             List<DerbyDistribution> filtered =
1:                     new ArrayList<DerbyDistribution>();
1:             for (DerbyDistribution d : distributions) {
1:                 DerbyVersion ver = d.getVersion();
1:                 if (prev == null || prev.getVersion().greaterMinorThan(ver)) {
1:                     filtered.add(d);
1:                 } else {
1:                     println("ignored " + ver.toString() +
1:                             ", not the newest fixpack version for " +
1:                             ver.getMajor() + "." + ver.getMinor());
1:                 }
1:                 prev = d;
1:             }
1:             distributions = filtered;
1:         }
1:         return distributions;
1:     }
1: 
1:     /**
0:      * Returns the URL of the source for the specified class.
1:      *
1:      * @param cl class to find the source for
0:      * @return A {@code URL} pointing to the source, or {@code null} it cannot
1:      *      be obtained.
1:      */
0:     static URL getClassURL(final Class cl) {
0:         return (URL)
0:            AccessController.doPrivileged(new PrivilegedAction() {
1: 
0:             public Object run() {
0:                 if (cl.getProtectionDomain().getCodeSource() == null) {
0:                     return null;
1:                 }
0:                 return cl.getProtectionDomain().getCodeSource().getLocation();
1:             }
1:         });
1:     }
1: 
1:     // Forwarding convenience methods
1: 
1:     private static void println(String msg) {
1:         BaseTestCase.println(msg);
1:     }
1: 
1:     private static void alarm(String msg) {
1:         BaseTestCase.alarm(msg);
1:     }
1: }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ffa2d1b
/////////////////////////////////////////////////////////////////////////
0:      * We suppress warnings here because DerbyDistribution needs to
0:      * implement Comparable<DerbyVersion> and not just Comparable. But DerbyDistribution
0:      * lives in a package which has to compile at level 1.4 and so cannot be
0:      * declared that way.
0:      *
0:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
0:            AccessController.doPrivileged(new PrivilegedAction<Object>() {
============================================================================