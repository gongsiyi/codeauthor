1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.services.jce.JCECipherProvider
1:345de35: 
1:93fea34:    Licensed to the Apache Software Foundation (ASF) under one or more
1:93fea34:    contributor license agreements.  See the NOTICE file distributed with
1:93fea34:    this work for additional information regarding copyright ownership.
1:93fea34:    The ASF licenses this file to you under the Apache License, Version 2.0
1:93fea34:    (the "License"); you may not use this file except in compliance with
1:93fea34:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
2:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.services.jce;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.crypto.CipherFactory;
1:eac0369: import org.apache.derby.iapi.services.crypto.CipherProvider;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import java.security.Key;
1:eac0369: import java.security.InvalidKeyException;
1:eac0369: import java.security.NoSuchAlgorithmException;
1:eac0369: import java.security.GeneralSecurityException;
1:eac0369: import java.security.NoSuchProviderException;
1:eac0369: 
1:eac0369: import javax.crypto.Cipher;
1:eac0369: import javax.crypto.spec.IvParameterSpec;
1:eac0369: import javax.crypto.SecretKeyFactory;
1:eac0369: import javax.crypto.spec.SecretKeySpec;
1:eac0369: import javax.crypto.SecretKey;
1:eac0369: 
1:eac0369: 
2:eac0369: /**
1:eac0369: 	This is a wrapper for a Cipher
1:eac0369: 
1:eac0369: 	@see CipherFactory
1:eac0369:  */
1:eac0369: class JCECipherProvider implements CipherProvider
1:eac0369: {
1:eac0369: 	private Cipher cipher;
1:eac0369: 	private int mode;
1:eac0369:     private boolean ivUsed = true;
1:eac0369:     private final IvParameterSpec ivspec;
1:eac0369:     private final int encryptionBlockSize;
1:eac0369:     private boolean sunjce; //default of bool is false
1:eac0369: 
1:eac0369:     // other provider workaround, we need to re-init the cipher before every encrypt/decrypt
1:eac0369:     private SecretKey cryptixKey;
1:eac0369: 
1:eac0369: 	JCECipherProvider(int mode, SecretKey secretKey, byte[] iv, String algorithm, String provider)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		Throwable t;
1:eac0369: 		ivspec = new IvParameterSpec(iv);
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 
1:eac0369: 
1:eac0369: 			if (provider == null)
1:eac0369: 			{
1:eac0369: 				cipher = Cipher.getInstance(algorithm);
1:eac0369: 
1:eac0369: 				// see below.
1:eac0369: 				if ("SunJCE".equals(cipher.getProvider().getName()))
1:eac0369: 					sunjce = true;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				/* The Sun encryption provider does not need to re-init the cipher
1:eac0369: 				 * after each encrypt/decrypt.  This is a speed up trick.
1:eac0369: 				 * Other crypto providers needs this because the encrypt/decrypt
1:eac0369: 				 * ciphers becomes out of sync after an encrypt/decrypt operation.
1:eac0369: 				 */
1:eac0369: 				if( provider.equals("SunJCE") )
1:eac0369: 				{
1:eac0369: 					sunjce = true;
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					/* The BouncyCastle encryption provider is named "BC".
1:eac0369: 					 * The full "BouncyCastleProvider" name used to work until
1:eac0369: 					 * version 103 came out.  (ie. Beta3 and Beta4 works fine)
1:eac0369: 					 * This trick is so that Cipher.getInstance(algo, prov) will
1:eac0369: 					 * not throw an exception.  Resolve 3765.
1:eac0369: 					 */
1:eac0369: 					if( provider.equals( "BouncyCastleProvider" ) )
1:eac0369: 						provider = "BC";
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				cipher = Cipher.getInstance(algorithm,provider);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// At creation time, the encryption block size is stored in order
1:eac0369: 			// to do appropriate padding
1:eac0369: 			encryptionBlockSize = cipher.getBlockSize();
1:eac0369: 
1:eac0369: 			this.mode = mode;
1:eac0369: 			try {
1:eac0369: 
1:eac0369: 				// ECB feedback mode does not require an IV
1:eac0369: 				if (mode == CipherFactory.ENCRYPT)
1:eac0369: 				{
1:eac0369: 					if ((algorithm.indexOf("/ECB") > -1))
1:eac0369: 						cipher.init(Cipher.ENCRYPT_MODE, secretKey);
1:eac0369: 					else
1:eac0369: 						cipher.init(Cipher.ENCRYPT_MODE, secretKey,ivspec);
1:eac0369: 				}
1:eac0369: 				else if (mode == CipherFactory.DECRYPT)
1:eac0369: 				{
1:eac0369: 					if ((algorithm.indexOf("/ECB") > -1))
1:eac0369: 						cipher.init(Cipher.DECRYPT_MODE, secretKey);
1:eac0369: 					else
1:eac0369: 						cipher.init(Cipher.DECRYPT_MODE, secretKey,ivspec);
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 					throw StandardException.newException(SQLState.ILLEGAL_CIPHER_MODE);
1:eac0369: 			} catch (InvalidKeyException ike) {
1:eac0369: 
1:eac0369: 				if (algorithm.startsWith("DES")) {
1:eac0369: 
1:eac0369: 					SecretKeyFactory skf;
1:eac0369: 					if (provider == null)
1:eac0369: 						skf = SecretKeyFactory.getInstance(secretKey.getAlgorithm());
1:eac0369: 					else
1:eac0369: 						skf = SecretKeyFactory.getInstance(secretKey.getAlgorithm(), provider);
1:eac0369: 
1:eac0369: 
1:eac0369: 					// Since the key may be a series of bytes generated by an arbitary means
1:eac0369: 					// we need to translate it into a key suitable for the algorithm.
1:eac0369: 					secretKey = skf.translateKey(new SecretKeySpec(secretKey.getEncoded(), secretKey.getAlgorithm()));
1:eac0369: 
1:eac0369: 					// ECB mode does not require IV
1:eac0369: 					if (mode == CipherFactory.ENCRYPT )
1:eac0369: 					{
1:eac0369: 						if ((algorithm.indexOf("/ECB") > -1))
1:eac0369: 							cipher.init(Cipher.ENCRYPT_MODE, secretKey);
1:eac0369: 						else
1:eac0369: 							cipher.init(Cipher.ENCRYPT_MODE, secretKey,ivspec);
1:eac0369: 					}
1:eac0369: 					else if (mode == CipherFactory.DECRYPT)
1:eac0369: 					{
1:eac0369: 						if ((algorithm.indexOf("/ECB") > -1))
1:eac0369: 							cipher.init(Cipher.DECRYPT_MODE, secretKey);
1:eac0369: 						else
1:eac0369: 							cipher.init(Cipher.DECRYPT_MODE, secretKey,ivspec);
1:eac0369: 					}
1:eac0369: 
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 					throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, ike);
1:eac0369: 			}
1:eac0369:             cryptixKey = secretKey;
1:eac0369: 
1:eac0369:             if (cipher.getIV() == null)
1:eac0369:                 ivUsed = false;
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.ASSERT(verifyIV(iv));
1:eac0369: 
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 		catch (InvalidKeyException ike)
1:eac0369: 		{
1:eac0369: 			t = ike;
1:eac0369: 		}
1:eac0369: 		catch (NoSuchAlgorithmException nsae)
1:eac0369: 		{
1:eac0369:     		throw StandardException.newException(SQLState.ENCRYPTION_NOSUCH_ALGORITHM, algorithm, JCECipherFactory.providerErrorName(provider));
1:eac0369: 		}
1:eac0369:         catch (NoSuchProviderException nspe)
1:eac0369:         {
1:eac0369:     		throw StandardException.newException(SQLState.ENCRYPTION_BAD_PROVIDER, JCECipherFactory.providerErrorName(provider));
1:eac0369:         }
1:eac0369: 		catch (GeneralSecurityException gse)
1:eac0369: 		{
1:eac0369: 			t = gse;
1:eac0369: 		}
1:eac0369: 		throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, t);
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see CipherProvider#encrypt
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby Error Policy
1:eac0369: 	 */
1:eac0369: 	public int encrypt(byte[] cleartext, int offset, int length,
1:eac0369: 					   byte[] ciphertext, int outputOffset)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(mode == CipherFactory.ENCRYPT,
1:eac0369: 								 "calling encrypt on a decryption engine");
1:eac0369: 			SanityManager.ASSERT(cleartext != null, "encrypting null cleartext");
1:eac0369: 			SanityManager.ASSERT(offset >= 0, "offset < 0");
1:eac0369: 			SanityManager.ASSERT(length > 0, "length <= 0");
1:eac0369: 			SanityManager.ASSERT(offset+length <= cleartext.length,
1:eac0369: 								 "offset+length > cleartext.length");
1:eac0369: 			SanityManager.ASSERT(length <= ciphertext.length-outputOffset,
1:eac0369: 								 "provided ciphertext buffer insufficient");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		int retval = 0;
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			// this same cipher is shared across the entire raw store, make it
1:eac0369: 			// MT safe
1:eac0369: 			synchronized(this)
1:eac0369: 			{
1:eac0369:                 if( !sunjce )
1:eac0369:                 {
1:eac0369:                     // this code is a workaround for other providers
1:eac0369:                     try
1:eac0369:                     {
1:eac0369: 			            //ivspec = new IvParameterSpec(cipher.getIV());
1:eac0369:     			        if (mode == CipherFactory.ENCRYPT)
1:eac0369:     			        {
1:eac0369: 							if (ivUsed)
1:eac0369: 	    			        	cipher.init(Cipher.ENCRYPT_MODE, cryptixKey, ivspec);
1:eac0369: 	    			        else
1:eac0369: 	    			    		cipher.init(Cipher.ENCRYPT_MODE,cryptixKey);
1:eac0369: 						}
1:eac0369: 	    			    else if (mode == CipherFactory.DECRYPT)
1:eac0369: 	    			    {
1:eac0369: 							if (ivUsed)
1:eac0369: 			    	        	cipher.init(Cipher.DECRYPT_MODE, cryptixKey, ivspec);
1:eac0369: 			    	    	else
1:eac0369: 								cipher.init(Cipher.DECRYPT_MODE, cryptixKey);
1:eac0369: 						}
1:eac0369: 
1:eac0369:                     }
1:eac0369:             		catch (InvalidKeyException ike)
1:eac0369: 		            {
1:eac0369: 						System.out.println("A " + ike);
1:eac0369: 			            throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, ike);
1:eac0369: 		            }
1:eac0369:                 }
1:eac0369: 
1:eac0369: 				retval = cipher.doFinal(cleartext, offset, length, ciphertext, outputOffset);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		catch (IllegalStateException ise)
1:eac0369: 		{
1:eac0369: 			// should never happen
1:eac0369: 			if (SanityManager.DEBUG)
1:e7d2a42: 				SanityManager.THROWASSERT(ise);
1:eac0369: 		}
1:eac0369: 		catch (GeneralSecurityException gse)
1:eac0369: 		{
1:eac0369: 						System.out.println("B " + gse);
1:eac0369: 			throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, gse);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(retval == length, "ciphertext length != length");
1:eac0369: 
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see CipherProvider#decrypt
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby Error Policy
1:eac0369: 	 */
1:eac0369: 	public int decrypt(byte[] ciphertext, int offset, int length,
1:eac0369: 					   byte[] cleartext, int outputOffset)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(mode == CipherFactory.DECRYPT,
1:eac0369: 								 "calling decrypt on a encryption engine");
1:eac0369: 			SanityManager.ASSERT(ciphertext != null, "decrypting null ciphertext");
1:eac0369: 			SanityManager.ASSERT(offset >= 0, "offset < 0");
1:eac0369: 			SanityManager.ASSERT(length > 0, "length <= 0");
1:eac0369: 			SanityManager.ASSERT(offset+length <= ciphertext.length,
1:eac0369: 								 "offset+length > ciphertext.length");
1:eac0369: 			SanityManager.ASSERT(length <= cleartext.length-outputOffset,
1:eac0369: 								 "provided cleartexte buffer insufficient");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		int retval = 0;
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			// this same cipher is shared across the entire raw store, make it
1:eac0369: 			// MT safe
1:eac0369: 			synchronized(this)
1:eac0369: 			{
1:eac0369:                 if( !sunjce )
1:eac0369:                 {
1:eac0369:                     // this code is a workaround for other providers
1:eac0369:                     try
1:eac0369:                     {
1:eac0369: 			            //ivspec = new IvParameterSpec(cipher.getIV());
1:eac0369: 
1:eac0369: 			            if (mode == CipherFactory.ENCRYPT)
1:eac0369: 						{
1:eac0369: 							if (ivUsed)
1:eac0369: 								cipher.init(Cipher.ENCRYPT_MODE, cryptixKey, ivspec);
1:eac0369: 							else
1:eac0369: 								cipher.init(Cipher.ENCRYPT_MODE,cryptixKey);
1:eac0369: 						}
1:eac0369: 						else if (mode == CipherFactory.DECRYPT)
1:eac0369: 						{
1:eac0369: 							if (ivUsed)
1:eac0369: 								cipher.init(Cipher.DECRYPT_MODE, cryptixKey, ivspec);
1:eac0369: 							else
1:eac0369: 								cipher.init(Cipher.DECRYPT_MODE, cryptixKey);
1:eac0369: 						}
1:eac0369: 
1:eac0369:                     }
1:eac0369:             		catch (InvalidKeyException ike)
1:eac0369: 		            {
1:eac0369: 						System.out.println("C " + ike);
1:eac0369: 			            throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, ike);
1:eac0369: 		            }
1:eac0369: 
1:eac0369:                 }
1:eac0369: 
1:eac0369: 				retval = cipher.doFinal(ciphertext, offset, length, cleartext, outputOffset);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		catch (IllegalStateException ise)
1:eac0369: 		{
1:eac0369: 			// should never happen
1:eac0369: 			if (SanityManager.DEBUG)
1:e7d2a42: 				SanityManager.THROWASSERT(ise);
1:eac0369: 		}
1:eac0369: 		catch (GeneralSecurityException gse)
1:eac0369: 		{
1:eac0369: 						System.out.println("D " + gse);
1:eac0369: 			throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, gse);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(retval == length,
1:eac0369: 								 "cleartext length != length");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	boolean verifyIV(byte[] IV)
1:eac0369: 	{
1:eac0369: 		byte[] myIV = cipher.getIV();
1:eac0369:         // null IV is OK only if IV is not used
1:eac0369:         if (myIV == null)
1:eac0369:             return !ivUsed;
1:eac0369: 		if (myIV.length != IV.length)
1:eac0369: 			return false;
1:eac0369: 		for (int i = 0; i < IV.length; i++)
1:eac0369: 			if (myIV[i] != IV[i])
1:eac0369: 				return false;
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int getEncryptionBlockSize()
1:eac0369: 	{
1:eac0369: 		return encryptionBlockSize;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e7d2a42
/////////////////////////////////////////////////////////////////////////
1: 				SanityManager.THROWASSERT(ise);
/////////////////////////////////////////////////////////////////////////
1: 				SanityManager.THROWASSERT(ise);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby Error Policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby Error Policy
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:93fea34
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.services.jce.JCECipherProvider
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.services.jce
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.services.jce;
1: 
1: import org.apache.derby.iapi.services.crypto.CipherFactory;
1: import org.apache.derby.iapi.services.crypto.CipherProvider;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import java.security.Key;
1: import java.security.InvalidKeyException;
1: import java.security.NoSuchAlgorithmException;
1: import java.security.GeneralSecurityException;
1: import java.security.NoSuchProviderException;
1: 
1: import javax.crypto.Cipher;
1: import javax.crypto.spec.IvParameterSpec;
1: import javax.crypto.SecretKeyFactory;
1: import javax.crypto.spec.SecretKeySpec;
1: import javax.crypto.SecretKey;
1: 
1: 
1: /**
1: 	This is a wrapper for a Cipher
1: 
1: 	@see CipherFactory
1:  */
1: class JCECipherProvider implements CipherProvider
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
1: 	private Cipher cipher;
1: 	private int mode;
1:     private boolean ivUsed = true;
1:     private final IvParameterSpec ivspec;
1:     private final int encryptionBlockSize;
1:     private boolean sunjce; //default of bool is false
1: 
1:     // other provider workaround, we need to re-init the cipher before every encrypt/decrypt
1:     private SecretKey cryptixKey;
1: 
1: 	JCECipherProvider(int mode, SecretKey secretKey, byte[] iv, String algorithm, String provider)
1: 		 throws StandardException
1: 	{
1: 		Throwable t;
1: 		ivspec = new IvParameterSpec(iv);
1: 		try
1: 		{
1: 
1: 
1: 			if (provider == null)
1: 			{
1: 				cipher = Cipher.getInstance(algorithm);
1: 
1: 				// see below.
1: 				if ("SunJCE".equals(cipher.getProvider().getName()))
1: 					sunjce = true;
1: 			}
1: 			else
1: 			{
1: 				/* The Sun encryption provider does not need to re-init the cipher
1: 				 * after each encrypt/decrypt.  This is a speed up trick.
1: 				 * Other crypto providers needs this because the encrypt/decrypt
1: 				 * ciphers becomes out of sync after an encrypt/decrypt operation.
1: 				 */
1: 				if( provider.equals("SunJCE") )
1: 				{
1: 					sunjce = true;
1: 				}
1: 				else
1: 				{
1: 					/* The BouncyCastle encryption provider is named "BC".
1: 					 * The full "BouncyCastleProvider" name used to work until
1: 					 * version 103 came out.  (ie. Beta3 and Beta4 works fine)
1: 					 * This trick is so that Cipher.getInstance(algo, prov) will
1: 					 * not throw an exception.  Resolve 3765.
1: 					 */
1: 					if( provider.equals( "BouncyCastleProvider" ) )
1: 						provider = "BC";
1: 				}
1: 
1: 				cipher = Cipher.getInstance(algorithm,provider);
1: 			}
1: 
1: 			// At creation time, the encryption block size is stored in order
1: 			// to do appropriate padding
1: 			encryptionBlockSize = cipher.getBlockSize();
1: 
1: 			this.mode = mode;
1: 			try {
1: 
1: 				// ECB feedback mode does not require an IV
1: 				if (mode == CipherFactory.ENCRYPT)
1: 				{
1: 					if ((algorithm.indexOf("/ECB") > -1))
1: 						cipher.init(Cipher.ENCRYPT_MODE, secretKey);
1: 					else
1: 						cipher.init(Cipher.ENCRYPT_MODE, secretKey,ivspec);
1: 				}
1: 				else if (mode == CipherFactory.DECRYPT)
1: 				{
1: 					if ((algorithm.indexOf("/ECB") > -1))
1: 						cipher.init(Cipher.DECRYPT_MODE, secretKey);
1: 					else
1: 						cipher.init(Cipher.DECRYPT_MODE, secretKey,ivspec);
1: 				}
1: 				else
1: 					throw StandardException.newException(SQLState.ILLEGAL_CIPHER_MODE);
1: 			} catch (InvalidKeyException ike) {
1: 
1: 				if (algorithm.startsWith("DES")) {
1: 
1: 					SecretKeyFactory skf;
1: 					if (provider == null)
1: 						skf = SecretKeyFactory.getInstance(secretKey.getAlgorithm());
1: 					else
1: 						skf = SecretKeyFactory.getInstance(secretKey.getAlgorithm(), provider);
1: 
1: 
1: 					// Since the key may be a series of bytes generated by an arbitary means
1: 					// we need to translate it into a key suitable for the algorithm.
1: 					secretKey = skf.translateKey(new SecretKeySpec(secretKey.getEncoded(), secretKey.getAlgorithm()));
1: 
1: 					// ECB mode does not require IV
1: 					if (mode == CipherFactory.ENCRYPT )
1: 					{
1: 						if ((algorithm.indexOf("/ECB") > -1))
1: 							cipher.init(Cipher.ENCRYPT_MODE, secretKey);
1: 						else
1: 							cipher.init(Cipher.ENCRYPT_MODE, secretKey,ivspec);
1: 					}
1: 					else if (mode == CipherFactory.DECRYPT)
1: 					{
1: 						if ((algorithm.indexOf("/ECB") > -1))
1: 							cipher.init(Cipher.DECRYPT_MODE, secretKey);
1: 						else
1: 							cipher.init(Cipher.DECRYPT_MODE, secretKey,ivspec);
1: 					}
1: 
1: 				}
1: 				else
1: 					throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, ike);
1: 			}
1:             cryptixKey = secretKey;
1: 
1:             if (cipher.getIV() == null)
1:                 ivUsed = false;
1: 
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(verifyIV(iv));
1: 
1: 			return;
1: 
1: 		}
1: 		catch (InvalidKeyException ike)
1: 		{
1: 			t = ike;
1: 		}
1: 		catch (NoSuchAlgorithmException nsae)
1: 		{
1:     		throw StandardException.newException(SQLState.ENCRYPTION_NOSUCH_ALGORITHM, algorithm, JCECipherFactory.providerErrorName(provider));
1: 		}
1:         catch (NoSuchProviderException nspe)
1:         {
1:     		throw StandardException.newException(SQLState.ENCRYPTION_BAD_PROVIDER, JCECipherFactory.providerErrorName(provider));
1:         }
1: 		catch (GeneralSecurityException gse)
1: 		{
1: 			t = gse;
1: 		}
1: 		throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, t);
1: 
1: 	}
1: 
1: 	/**
1: 		@see CipherProvider#encrypt
1: 
0: 		@exception StandardException Standard Cloudscape Error Policy
1: 	 */
1: 	public int encrypt(byte[] cleartext, int offset, int length,
1: 					   byte[] ciphertext, int outputOffset)
1: 		 throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(mode == CipherFactory.ENCRYPT,
1: 								 "calling encrypt on a decryption engine");
1: 			SanityManager.ASSERT(cleartext != null, "encrypting null cleartext");
1: 			SanityManager.ASSERT(offset >= 0, "offset < 0");
1: 			SanityManager.ASSERT(length > 0, "length <= 0");
1: 			SanityManager.ASSERT(offset+length <= cleartext.length,
1: 								 "offset+length > cleartext.length");
1: 			SanityManager.ASSERT(length <= ciphertext.length-outputOffset,
1: 								 "provided ciphertext buffer insufficient");
1: 		}
1: 
1: 		int retval = 0;
1: 		try
1: 		{
1: 			// this same cipher is shared across the entire raw store, make it
1: 			// MT safe
1: 			synchronized(this)
1: 			{
1:                 if( !sunjce )
1:                 {
1:                     // this code is a workaround for other providers
1:                     try
1:                     {
1: 			            //ivspec = new IvParameterSpec(cipher.getIV());
1:     			        if (mode == CipherFactory.ENCRYPT)
1:     			        {
1: 							if (ivUsed)
1: 	    			        	cipher.init(Cipher.ENCRYPT_MODE, cryptixKey, ivspec);
1: 	    			        else
1: 	    			    		cipher.init(Cipher.ENCRYPT_MODE,cryptixKey);
1: 						}
1: 	    			    else if (mode == CipherFactory.DECRYPT)
1: 	    			    {
1: 							if (ivUsed)
1: 			    	        	cipher.init(Cipher.DECRYPT_MODE, cryptixKey, ivspec);
1: 			    	    	else
1: 								cipher.init(Cipher.DECRYPT_MODE, cryptixKey);
1: 						}
1: 
1:                     }
1:             		catch (InvalidKeyException ike)
1: 		            {
1: 						System.out.println("A " + ike);
1: 			            throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, ike);
1: 		            }
1:                 }
1: 
1: 				retval = cipher.doFinal(cleartext, offset, length, ciphertext, outputOffset);
1: 			}
1: 		}
1: 		catch (IllegalStateException ise)
1: 		{
1: 			// should never happen
1: 			if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT("Illegal state exception");
1: 		}
1: 		catch (GeneralSecurityException gse)
1: 		{
1: 						System.out.println("B " + gse);
1: 			throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, gse);
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(retval == length, "ciphertext length != length");
1: 
1: 		return retval;
1: 	}
1: 
1: 
1: 	/**
1: 		@see CipherProvider#decrypt
1: 
0: 		@exception StandardException Standard Cloudscape Error Policy
1: 	 */
1: 	public int decrypt(byte[] ciphertext, int offset, int length,
1: 					   byte[] cleartext, int outputOffset)
1: 		 throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(mode == CipherFactory.DECRYPT,
1: 								 "calling decrypt on a encryption engine");
1: 			SanityManager.ASSERT(ciphertext != null, "decrypting null ciphertext");
1: 			SanityManager.ASSERT(offset >= 0, "offset < 0");
1: 			SanityManager.ASSERT(length > 0, "length <= 0");
1: 			SanityManager.ASSERT(offset+length <= ciphertext.length,
1: 								 "offset+length > ciphertext.length");
1: 			SanityManager.ASSERT(length <= cleartext.length-outputOffset,
1: 								 "provided cleartexte buffer insufficient");
1: 		}
1: 
1: 		int retval = 0;
1: 		try
1: 		{
1: 			// this same cipher is shared across the entire raw store, make it
1: 			// MT safe
1: 			synchronized(this)
1: 			{
1:                 if( !sunjce )
1:                 {
1:                     // this code is a workaround for other providers
1:                     try
1:                     {
1: 			            //ivspec = new IvParameterSpec(cipher.getIV());
1: 
1: 			            if (mode == CipherFactory.ENCRYPT)
1: 						{
1: 							if (ivUsed)
1: 								cipher.init(Cipher.ENCRYPT_MODE, cryptixKey, ivspec);
1: 							else
1: 								cipher.init(Cipher.ENCRYPT_MODE,cryptixKey);
1: 						}
1: 						else if (mode == CipherFactory.DECRYPT)
1: 						{
1: 							if (ivUsed)
1: 								cipher.init(Cipher.DECRYPT_MODE, cryptixKey, ivspec);
1: 							else
1: 								cipher.init(Cipher.DECRYPT_MODE, cryptixKey);
1: 						}
1: 
1:                     }
1:             		catch (InvalidKeyException ike)
1: 		            {
1: 						System.out.println("C " + ike);
1: 			            throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, ike);
1: 		            }
1: 
1:                 }
1: 
1: 				retval = cipher.doFinal(ciphertext, offset, length, cleartext, outputOffset);
1: 			}
1: 		}
1: 		catch (IllegalStateException ise)
1: 		{
1: 			// should never happen
1: 			if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT("Illegal state exception");
1: 		}
1: 		catch (GeneralSecurityException gse)
1: 		{
1: 						System.out.println("D " + gse);
1: 			throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, gse);
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(retval == length,
1: 								 "cleartext length != length");
1: 		}
1: 
1: 		return retval;
1: 	}
1: 
1: 	boolean verifyIV(byte[] IV)
1: 	{
1: 		byte[] myIV = cipher.getIV();
1:         // null IV is OK only if IV is not used
1:         if (myIV == null)
1:             return !ivUsed;
1: 		if (myIV.length != IV.length)
1: 			return false;
1: 		for (int i = 0; i < IV.length; i++)
1: 			if (myIV[i] != IV[i])
1: 				return false;
1: 		return true;
1: 	}
1: 
1: 	public int getEncryptionBlockSize()
1: 	{
1: 		return encryptionBlockSize;
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.services.jce
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.services.jce;
0: 
0: import org.apache.derby.iapi.services.crypto.CipherFactory;
0: import org.apache.derby.iapi.services.crypto.CipherProvider;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import java.security.Key;
0: import java.security.InvalidKeyException;
0: import java.security.NoSuchAlgorithmException;
0: import java.security.GeneralSecurityException;
0: import java.security.NoSuchProviderException;
0: 
0: import javax.crypto.Cipher;
0: import javax.crypto.spec.IvParameterSpec;
0: import javax.crypto.SecretKeyFactory;
0: import javax.crypto.spec.SecretKeySpec;
0: import javax.crypto.SecretKey;
0: 
0: 
0: /**
0: 	This is a wrapper for a Cipher
0: 
0: 	@see CipherFactory
0:  */
0: class JCECipherProvider implements CipherProvider
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0: 	private Cipher cipher;
0: 	private int mode;
0:     private boolean ivUsed = true;
0:     private final IvParameterSpec ivspec;
0:     private final int encryptionBlockSize;
0:     private boolean sunjce; //default of bool is false
0: 
0:     // other provider workaround, we need to re-init the cipher before every encrypt/decrypt
0:     private SecretKey cryptixKey;
0: 
0: 	JCECipherProvider(int mode, SecretKey secretKey, byte[] iv, String algorithm, String provider)
0: 		 throws StandardException
0: 	{
0: 		Throwable t;
0: 		ivspec = new IvParameterSpec(iv);
0: 		try
0: 		{
0: 
0: 
0: 			if (provider == null)
0: 			{
0: 				cipher = Cipher.getInstance(algorithm);
0: 
0: 				// see below.
0: 				if ("SunJCE".equals(cipher.getProvider().getName()))
0: 					sunjce = true;
0: 			}
0: 			else
0: 			{
0: 				/* The Sun encryption provider does not need to re-init the cipher
0: 				 * after each encrypt/decrypt.  This is a speed up trick.
0: 				 * Other crypto providers needs this because the encrypt/decrypt
0: 				 * ciphers becomes out of sync after an encrypt/decrypt operation.
0: 				 */
0: 				if( provider.equals("SunJCE") )
0: 				{
0: 					sunjce = true;
0: 				}
0: 				else
0: 				{
0: 					/* The BouncyCastle encryption provider is named "BC".
0: 					 * The full "BouncyCastleProvider" name used to work until
0: 					 * version 103 came out.  (ie. Beta3 and Beta4 works fine)
0: 					 * This trick is so that Cipher.getInstance(algo, prov) will
0: 					 * not throw an exception.  Resolve 3765.
0: 					 */
0: 					if( provider.equals( "BouncyCastleProvider" ) )
0: 						provider = "BC";
0: 				}
0: 
0: 				cipher = Cipher.getInstance(algorithm,provider);
0: 			}
0: 
0: 			// At creation time, the encryption block size is stored in order
0: 			// to do appropriate padding
0: 			encryptionBlockSize = cipher.getBlockSize();
0: 
0: 			this.mode = mode;
0: 			try {
0: 
0: 				// ECB feedback mode does not require an IV
0: 				if (mode == CipherFactory.ENCRYPT)
0: 				{
0: 					if ((algorithm.indexOf("/ECB") > -1))
0: 						cipher.init(Cipher.ENCRYPT_MODE, secretKey);
0: 					else
0: 						cipher.init(Cipher.ENCRYPT_MODE, secretKey,ivspec);
0: 				}
0: 				else if (mode == CipherFactory.DECRYPT)
0: 				{
0: 					if ((algorithm.indexOf("/ECB") > -1))
0: 						cipher.init(Cipher.DECRYPT_MODE, secretKey);
0: 					else
0: 						cipher.init(Cipher.DECRYPT_MODE, secretKey,ivspec);
0: 				}
0: 				else
0: 					throw StandardException.newException(SQLState.ILLEGAL_CIPHER_MODE);
0: 			} catch (InvalidKeyException ike) {
0: 
0: 				if (algorithm.startsWith("DES")) {
0: 
0: 					SecretKeyFactory skf;
0: 					if (provider == null)
0: 						skf = SecretKeyFactory.getInstance(secretKey.getAlgorithm());
0: 					else
0: 						skf = SecretKeyFactory.getInstance(secretKey.getAlgorithm(), provider);
0: 
0: 
0: 					// Since the key may be a series of bytes generated by an arbitary means
0: 					// we need to translate it into a key suitable for the algorithm.
0: 					secretKey = skf.translateKey(new SecretKeySpec(secretKey.getEncoded(), secretKey.getAlgorithm()));
0: 
0: 					// ECB mode does not require IV
0: 					if (mode == CipherFactory.ENCRYPT )
0: 					{
0: 						if ((algorithm.indexOf("/ECB") > -1))
0: 							cipher.init(Cipher.ENCRYPT_MODE, secretKey);
0: 						else
0: 							cipher.init(Cipher.ENCRYPT_MODE, secretKey,ivspec);
0: 					}
0: 					else if (mode == CipherFactory.DECRYPT)
0: 					{
0: 						if ((algorithm.indexOf("/ECB") > -1))
0: 							cipher.init(Cipher.DECRYPT_MODE, secretKey);
0: 						else
0: 							cipher.init(Cipher.DECRYPT_MODE, secretKey,ivspec);
0: 					}
0: 
0: 				}
0: 				else
0: 					throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, ike);
0: 			}
0:             cryptixKey = secretKey;
0: 
0:             if (cipher.getIV() == null)
0:                 ivUsed = false;
0: 
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(verifyIV(iv));
0: 
0: 			return;
0: 
0: 		}
0: 		catch (InvalidKeyException ike)
0: 		{
0: 			t = ike;
0: 		}
0: 		catch (NoSuchAlgorithmException nsae)
0: 		{
0:     		throw StandardException.newException(SQLState.ENCRYPTION_NOSUCH_ALGORITHM, algorithm, JCECipherFactory.providerErrorName(provider));
0: 		}
0:         catch (NoSuchProviderException nspe)
0:         {
0:     		throw StandardException.newException(SQLState.ENCRYPTION_BAD_PROVIDER, JCECipherFactory.providerErrorName(provider));
0:         }
0: 		catch (GeneralSecurityException gse)
0: 		{
0: 			t = gse;
0: 		}
0: 		throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, t);
0: 
0: 	}
0: 
0: 	/**
0: 		@see CipherProvider#encrypt
0: 
0: 		@exception StandardException Standard Cloudscape Error Policy
0: 	 */
0: 	public int encrypt(byte[] cleartext, int offset, int length,
0: 					   byte[] ciphertext, int outputOffset)
0: 		 throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(mode == CipherFactory.ENCRYPT,
0: 								 "calling encrypt on a decryption engine");
0: 			SanityManager.ASSERT(cleartext != null, "encrypting null cleartext");
0: 			SanityManager.ASSERT(offset >= 0, "offset < 0");
0: 			SanityManager.ASSERT(length > 0, "length <= 0");
0: 			SanityManager.ASSERT(offset+length <= cleartext.length,
0: 								 "offset+length > cleartext.length");
0: 			SanityManager.ASSERT(length <= ciphertext.length-outputOffset,
0: 								 "provided ciphertext buffer insufficient");
0: 		}
0: 
0: 		int retval = 0;
0: 		try
0: 		{
0: 			// this same cipher is shared across the entire raw store, make it
0: 			// MT safe
0: 			synchronized(this)
0: 			{
0:                 if( !sunjce )
0:                 {
0:                     // this code is a workaround for other providers
0:                     try
0:                     {
0: 			            //ivspec = new IvParameterSpec(cipher.getIV());
0:     			        if (mode == CipherFactory.ENCRYPT)
0:     			        {
0: 							if (ivUsed)
0: 	    			        	cipher.init(Cipher.ENCRYPT_MODE, cryptixKey, ivspec);
0: 	    			        else
0: 	    			    		cipher.init(Cipher.ENCRYPT_MODE,cryptixKey);
0: 						}
0: 	    			    else if (mode == CipherFactory.DECRYPT)
0: 	    			    {
0: 							if (ivUsed)
0: 			    	        	cipher.init(Cipher.DECRYPT_MODE, cryptixKey, ivspec);
0: 			    	    	else
0: 								cipher.init(Cipher.DECRYPT_MODE, cryptixKey);
0: 						}
0: 
0:                     }
0:             		catch (InvalidKeyException ike)
0: 		            {
0: 						System.out.println("A " + ike);
0: 			            throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, ike);
0: 		            }
0:                 }
0: 
0: 				retval = cipher.doFinal(cleartext, offset, length, ciphertext, outputOffset);
0: 			}
0: 		}
0: 		catch (IllegalStateException ise)
0: 		{
0: 			// should never happen
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT("Illegal state exception");
0: 		}
0: 		catch (GeneralSecurityException gse)
0: 		{
0: 						System.out.println("B " + gse);
0: 			throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, gse);
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(retval == length, "ciphertext length != length");
0: 
0: 		return retval;
0: 	}
0: 
0: 
0: 	/**
0: 		@see CipherProvider#decrypt
0: 
0: 		@exception StandardException Standard Cloudscape Error Policy
0: 	 */
0: 	public int decrypt(byte[] ciphertext, int offset, int length,
0: 					   byte[] cleartext, int outputOffset)
0: 		 throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(mode == CipherFactory.DECRYPT,
0: 								 "calling decrypt on a encryption engine");
0: 			SanityManager.ASSERT(ciphertext != null, "decrypting null ciphertext");
0: 			SanityManager.ASSERT(offset >= 0, "offset < 0");
0: 			SanityManager.ASSERT(length > 0, "length <= 0");
0: 			SanityManager.ASSERT(offset+length <= ciphertext.length,
0: 								 "offset+length > ciphertext.length");
0: 			SanityManager.ASSERT(length <= cleartext.length-outputOffset,
0: 								 "provided cleartexte buffer insufficient");
0: 		}
0: 
0: 		int retval = 0;
0: 		try
0: 		{
0: 			// this same cipher is shared across the entire raw store, make it
0: 			// MT safe
0: 			synchronized(this)
0: 			{
0:                 if( !sunjce )
0:                 {
0:                     // this code is a workaround for other providers
0:                     try
0:                     {
0: 			            //ivspec = new IvParameterSpec(cipher.getIV());
0: 
0: 			            if (mode == CipherFactory.ENCRYPT)
0: 						{
0: 							if (ivUsed)
0: 								cipher.init(Cipher.ENCRYPT_MODE, cryptixKey, ivspec);
0: 							else
0: 								cipher.init(Cipher.ENCRYPT_MODE,cryptixKey);
0: 						}
0: 						else if (mode == CipherFactory.DECRYPT)
0: 						{
0: 							if (ivUsed)
0: 								cipher.init(Cipher.DECRYPT_MODE, cryptixKey, ivspec);
0: 							else
0: 								cipher.init(Cipher.DECRYPT_MODE, cryptixKey);
0: 						}
0: 
0:                     }
0:             		catch (InvalidKeyException ike)
0: 		            {
0: 						System.out.println("C " + ike);
0: 			            throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, ike);
0: 		            }
0: 
0:                 }
0: 
0: 				retval = cipher.doFinal(ciphertext, offset, length, cleartext, outputOffset);
0: 			}
0: 		}
0: 		catch (IllegalStateException ise)
0: 		{
0: 			// should never happen
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT("Illegal state exception");
0: 		}
0: 		catch (GeneralSecurityException gse)
0: 		{
0: 						System.out.println("D " + gse);
0: 			throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, gse);
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(retval == length,
0: 								 "cleartext length != length");
0: 		}
0: 
0: 		return retval;
0: 	}
0: 
0: 	boolean verifyIV(byte[] IV)
0: 	{
0: 		byte[] myIV = cipher.getIV();
0:         // null IV is OK only if IV is not used
0:         if (myIV == null)
0:             return !ivUsed;
0: 		if (myIV.length != IV.length)
0: 			return false;
0: 		for (int i = 0; i < IV.length; i++)
0: 			if (myIV[i] != IV[i])
0: 				return false;
0: 		return true;
0: 	}
0: 
0: 	public int getEncryptionBlockSize()
0: 	{
0: 		return encryptionBlockSize;
0: 	}
0: }
============================================================================