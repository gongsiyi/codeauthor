2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.DDLStatementNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
11:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:3bb140c: import org.apache.derby.catalog.UUID;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:eac0369: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:69f8afa: import org.apache.derby.iapi.sql.compile.Visitor;
1:3bb140c: import org.apache.derby.iapi.sql.conn.Authorizer;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * A DDLStatementNode represents any type of DDL statement: CREATE TABLE,
1:eac0369:  * CREATE INDEX, ALTER TABLE, etc.
2:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:0061383: abstract class DDLStatementNode extends StatementNode
1:eac0369: {
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	CONSTANTS
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	public	static	final	int	UNKNOWN_TYPE = 0;
1:eac0369: 	public	static	final	int	ADD_TYPE = 1;
1:eac0369: 	public	static	final	int	DROP_TYPE = 2;
1:eac0369: 	public	static	final	int	MODIFY_TYPE = 3;
1:eac0369: 	public	static	final	int	LOCKING_TYPE = 4;
1:a6a0733: 	public	static	final	int	UPDATE_STATISTICS = 5;
1:a6a0733: 	public	static	final	int DROP_STATISTICS = 6;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	STATE
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:3bb140c:     private TableName   tableName;
1:eac0369: 	private boolean		initOk;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		sub-classes can set this to be true to allow implicit
1:eac0369: 		creation of the main object's schema at execution time.
1:eac0369: 	*/
1:eac0369: 	boolean implicitCreateSchema;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	BEHAVIOR
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:3bb140c:     DDLStatementNode(TableName tableName, ContextManager cm) {
1:3bb140c:         super(cm);
1:3bb140c:         this.tableName = tableName;
1:3bb140c:         initOk = true;
1:3bb140c:     }
1:3bb140c: 
1:3bb140c:     DDLStatementNode(ContextManager cm) {
1:3bb140c:         super(cm);
1:3bb140c:     }
1:3bb140c: 
1:95a483d: 
1:818fd27: 	/**
1:eac0369: 		Initialize the object name we will be performing the DDL
1:eac0369: 		on and check that we are not in the system schema
1:eac0369: 		and that DDL is allowed.
1:eac0369: 	*/
1:eac0369: 	protected void initAndCheck(Object objectName)
2:eac0369: 		throws StandardException {
1:eac0369: 
1:3bb140c:         this.tableName = (TableName) objectName;
1:eac0369: 
1:eac0369: 		initOk = true;
2:eac0369: 	}
1:eac0369: 
1:95a483d: 	/**
1:eac0369: 	 * A DDL statement is always atomic
1:eac0369: 	 *
1:eac0369: 	 * @return true 
1:eac0369: 	 */	
1:3bb140c:     @Override
1:eac0369: 	public boolean isAtomic()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the name of the table being dropped.
1:eac0369: 	 * This is the unqualified table name.
1:eac0369: 	 *
1:eac0369: 	 * @return the relative name
1:eac0369: 	 */
1:3bb140c:     String getRelativeName()
1:eac0369: 	{
1:3bb140c:         return tableName.getTableName() ;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the full dot expression name of the 
1:eac0369: 	 * object being dropped.
1:eac0369: 	 * 
1:eac0369: 	 * @return the full name
1:eac0369: 	 */
1:3bb140c:     String getFullName()
1:eac0369: 	{
1:3bb140c:         return tableName.getFullTableName() ;
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     public  final TableName getObjectName() { return tableName; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:3bb140c:             return ((tableName==null)?"":
1:3bb140c:                     "name: " + tableName.toString() +"\n") + super.toString();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	int activationKind()
1:eac0369: 	{
1:eac0369: 		   return StatementNode.NEED_DDL_ACTIVATION;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generic generate code for all DDL statements.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ActivationClassBuilder for the class being built
1:eac0369: 	 * @param mb	The execute() method to be built
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     final void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			if (!initOk)
1:eac0369: 				SanityManager.THROWASSERT(getClass() + " never called initAndCheck()");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// The generated java is the expression:
1:eac0369: 		// return ResultSetFactory.getDDLResultSet(this)
1:eac0369: 		//		                       
1:eac0369: 
1:eac0369: 		acb.pushGetResultSetFactoryExpression(mb); // instance for getDDLResultSet
1:eac0369: 		acb.pushThisAsActivation(mb); // first arg
1:eac0369: 
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getDDLResultSet", ClassName.ResultSet, 1);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	* Get a schema descriptor for this DDL object.
1:eac0369: 	* Uses this.objectName.  Always returns a schema,
1:eac0369: 	* we lock in the schema name prior to execution.
1:c45f5b1: 	* Checks if current authorizationID is owner of the schema.
1:eac0369: 	*
1:eac0369: 	* @return Schema Descriptor
1:eac0369: 	*
1:eac0369: 	* @exception	StandardException	throws on schema name
1:eac0369: 	*						that doesn't exist	
1:eac0369: 	*/
1:eac0369: 	protected final SchemaDescriptor getSchemaDescriptor() throws StandardException
1:eac0369: 	{
1:818fd27: 		return getSchemaDescriptor(true, true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:c45f5b1: 	* Get a schema descriptor for this DDL object.
1:c45f5b1: 	* Uses this.objectName.  Always returns a schema,
1:c45f5b1: 	* we lock in the schema name prior to execution.
1:818fd27: 	* 
1:818fd27: 	* The most common call to this method is with 2nd 
1:818fd27: 	* parameter true which says that SchemaDescriptor
1:818fd27: 	* should not be requested for system schema. The only
1:818fd27: 	* time this method will get called with 2nd parameter
1:818fd27: 	* set to false will be when user has requested for
1:818fd27: 	* inplace compress using 
1:818fd27: 	* SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE
1:818fd27: 	* Above inplace compress can be invoked on system tables.
1:818fd27: 	* A call to SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE 
1:818fd27: 	* internally gets translated into ALTER TABLE sql.
1:818fd27: 	* When ALTER TABLE is executed for SYSCS_INPLACE_COMPRESS_TABLE,
1:818fd27: 	* we want to allow SchemaDescriptor request for system
1:818fd27: 	* tables. DERBY-1062
1:eac0369: 	*
1:c45f5b1: 	* @param ownerCheck		If check for schema owner is needed
1:818fd27: 	* @param doSystemSchemaCheck   If check for system schema is needed.
1:818fd27: 	*    If set to true, then throw an exception if schema descriptor
1:818fd27: 	*    is requested for a system schema. The only time this param 
1:818fd27: 	*    will be set to false is when user is asking for inplace
1:818fd27: 	*    compress of a system table. DERBY-1062
1:eac0369: 	*
1:c45f5b1: 	* @return Schema Descriptor
1:eac0369: 	*
1:c45f5b1: 	* @exception	StandardException	throws on schema name
1:c45f5b1: 	*						that doesn't exist	
1:eac0369: 	*/
1:818fd27: 	protected final SchemaDescriptor getSchemaDescriptor(boolean ownerCheck,
1:818fd27: 			boolean doSystemSchemaCheck)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:3bb140c:         String schemaName = tableName.getSchemaName();
1:eac0369: 		//boolean needError = !(implicitCreateSchema || (schemaName == null));
1:eac0369: 		boolean needError = !implicitCreateSchema;
1:eac0369: 		SchemaDescriptor sd = getSchemaDescriptor(schemaName, needError);
1:d78ad2e: 		CompilerContext cc = getCompilerContext();
1:eac0369: 
1:eac0369: 		if (sd == null) {
1:eac0369: 			/* Disable creating schemas starting with SYS */
1:eac0369: 			if (schemaName.startsWith("SYS"))
1:50ba36b: 				throw StandardException.newException(
1:50ba36b: 					SQLState.LANG_NO_USER_DDL_IN_SYSTEM_SCHEMA,
1:50ba36b: 					statementToString(),
1:50ba36b: 					schemaName);
1:eac0369: 
1:eac0369: 			sd  = new SchemaDescriptor(getDataDictionary(), schemaName,
1:eac0369: 				(String) null, (UUID)null, false);
1:eac0369: 
1:2d2e717: 			if (isPrivilegeCollectionRequired())
1:2d2e717: 				cc.addRequiredSchemaPriv(schemaName, null, Authorizer.CREATE_SCHEMA_PRIV);
1:eac0369: 		}
1:eac0369: 
1:2d2e717: 		if (ownerCheck && isPrivilegeCollectionRequired())
1:d78ad2e: 			cc.addRequiredSchemaPriv(sd.getSchemaName(), null,
1:50ba36b: 						Authorizer.MODIFY_SCHEMA_PRIV);
1:eac0369: 
1:eac0369: 		/*
1:818fd27: 		** Catch the system schema here if the caller wants us to.
1:818fd27: 		** Currently, the only time we allow system schema is for inplace
1:818fd27: 		** compress table calls.
1:eac0369: 		*/	 
1:818fd27: 		if (doSystemSchemaCheck && sd.isSystemSchema())
1:eac0369: 		{
2:eac0369: 			throw StandardException.newException(SQLState.LANG_NO_USER_DDL_IN_SYSTEM_SCHEMA,
1:eac0369: 							statementToString(), sd);
1:eac0369: 		}
1:eac0369: 		return sd;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected final TableDescriptor getTableDescriptor()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:3bb140c:         return getTableDescriptor(tableName);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:818fd27: 	 * Validate that the table is ok for DDL -- e.g.
1:818fd27: 	 * that it exists, it is not a view. It is ok for
1:818fd27: 	 * it to be a system table. Also check that its 
1:818fd27: 	 * schema is ok. Currently, the only time this method
1:818fd27: 	 * is called is when user has asked for inplace 
1:818fd27: 	 * compress. eg
1:818fd27: 	 * call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('SYS','SYSTABLES',1,1,1);
1:818fd27: 	 * Inplace compress is allowed on both system and
1:818fd27: 	 * user tables.
1:818fd27: 	 *
1:818fd27: 	 * @return the validated table descriptor, never null
1:818fd27: 	 *
1:818fd27: 	 * @exception StandardException on error
1:818fd27: 	 */
1:818fd27: 	protected final TableDescriptor getTableDescriptor(boolean doSystemTableCheck)
1:818fd27: 	throws StandardException
1:818fd27: 	{
1:3bb140c:         TableDescriptor td = justGetDescriptor(tableName);
1:818fd27: 		td = checkTableDescriptor(td,doSystemTableCheck);
1:818fd27: 		return td;
1:818fd27: 	}
1:818fd27: 
1:eac0369: 	protected final TableDescriptor getTableDescriptor(UUID tableId)
1:eac0369: 		throws StandardException {
1:eac0369: 
1:eac0369: 		TableDescriptor td = getDataDictionary().getTableDescriptor(tableId);
1:eac0369: 
1:818fd27: 		td = checkTableDescriptor(td,true);
1:eac0369: 		return td;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Validate that the table is ok for DDL -- e.g.
1:eac0369: 	 * that it exists, it is not a view, and is not
1:eac0369: 	 * a system table, and that its schema is ok.
1:eac0369: 	 *
1:eac0369: 	 * @return the validated table descriptor, never null
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	protected final TableDescriptor getTableDescriptor(TableName tableName)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:818fd27: 		TableDescriptor td = justGetDescriptor(tableName);
1:818fd27: 
1:818fd27: 		/* beetle 4444, td may have changed when we obtain shared lock */
1:818fd27: 		td = checkTableDescriptor(td, true);
1:818fd27: 		return td;
1:818fd27: 
1:818fd27: 	}
1:818fd27: 
1:818fd27: 	/**
1:818fd27: 	 * Just get the table descriptor. Don't worry if it belongs to a view,
1:818fd27: 	 * system table, synonym or a real table. Let the caller decide what
1:818fd27: 	 * to do.
1:818fd27: 	 * 
1:818fd27: 	 * @param tableName
1:818fd27: 	 * 
1:818fd27: 	 * @return TableDescriptor for the give TableName
1:818fd27: 	 * 
1:818fd27: 	 * @throws StandardException on error
1:818fd27: 	 */
1:818fd27: 	private TableDescriptor justGetDescriptor(TableName tableName)
1:818fd27: 	throws StandardException
1:818fd27: 	{
1:eac0369: 		String schemaName = tableName.getSchemaName();
1:eac0369: 		SchemaDescriptor sd = getSchemaDescriptor(schemaName);
1:eac0369: 		
1:eac0369: 		TableDescriptor td = getTableDescriptor(tableName.getTableName(), sd);
1:eac0369: 
1:eac0369: 		if (td == null)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_OBJECT_DOES_NOT_EXIST, 
1:eac0369: 						statementToString(), tableName);
1:eac0369: 		}
1:eac0369: 		return td;
1:eac0369: 	}
1:eac0369: 
1:818fd27: 	private TableDescriptor checkTableDescriptor(TableDescriptor td, 
1:818fd27: 			boolean doSystemTableCheck)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		String sqlState = null;
1:eac0369: 
1:eac0369: 		switch (td.getTableType()) {
1:ddc6f41: 		case TableDescriptor.VTI_TYPE:
1:eac0369: 			sqlState = SQLState.LANG_INVALID_OPERATION_ON_SYSTEM_TABLE;
1:eac0369: 			break;
1:eac0369: 
1:818fd27: 		case TableDescriptor.SYSTEM_TABLE_TYPE:
1:818fd27: 			if (doSystemTableCheck)
1:818fd27: 				/*
1:818fd27: 				** Not on system tables (though there are no constraints on
1:818fd27: 				** system tables as of the time this is writen
1:818fd27: 				*/
1:818fd27: 				sqlState = SQLState.LANG_INVALID_OPERATION_ON_SYSTEM_TABLE;
1:818fd27: 			else
1:818fd27: 				//allow system table. The only time this happens currently is
1:818fd27: 				//when user is requesting inplace compress on system table
1:818fd27: 				return td;
1:818fd27: 			break;
1:818fd27: 
1:eac0369: 		case TableDescriptor.BASE_TABLE_TYPE:
1:eac0369: 			/* need to IX lock table if we are a reader in DDL datadictionary
1:eac0369: 			 * cache mode, otherwise we may interfere with another DDL thread
1:eac0369: 			 * that is in execution phase; beetle 4343, also see $WS/docs/
1:eac0369: 			 * language/SolutionsToConcurrencyIssues.txt (point f)
1:eac0369: 			 */
1:eac0369: 			return lockTableForCompilation(td);
1:eac0369: 
1:eac0369: 		case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:
1:eac0369: 			return td;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Make sure it is not a view
1:eac0369: 		*/
1:eac0369: 		case TableDescriptor.VIEW_TYPE:
1:eac0369: 			sqlState = SQLState.LANG_INVALID_OPERATION_ON_VIEW;
1:eac0369: 			break;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		
1:eac0369: 		throw StandardException.newException(sqlState, 
1:eac0369: 				statementToString(), td.getQualifiedName());
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:95a483d: 	  *	Make a from list for binding query fragments in a CREATE/ALTER TABLE
1:95a483d:       *     statement.
1:95a483d:       *
1:15b837e:       * @param dd  Metadata.
1:15b837e:       * @param tableElementList the parenthesized list of columns and constraints in a CREATE/ALTER TABLE statement
1:95a483d:       * @param creatingTable true if this is for CREATE TABLE. false if this is for ALTER TABLE
1:95a483d:       */
1:95a483d: 	FromList	makeFromList( DataDictionary dd, TableElementList tableElementList, boolean creatingTable )
1:95a483d:         throws StandardException
1:95a483d: 	{
1:95a483d:         // DERBY-3043: To avoid a no-such-schema error when
1:95a483d:         // binding the check constraint, ensure that the
1:95a483d:         // table we bind against has a schema name specified.
1:95a483d:         // If it doesn't, fill in the schema name now.
1:95a483d:         //
1:95a483d:         TableName tableName = getObjectName();
1:95a483d:         if (tableName.getSchemaName() == null)
1:95a483d:         { tableName.setSchemaName(getSchemaDescriptor().getSchemaName()); }
1:95a483d:         
1:3bb140c:         FromList fromList = new FromList(
1:3bb140c:                 getOptimizerFactory().doJoinOrderOptimization(),
1:3bb140c:                 getContextManager());
1:3bb140c: 
1:3bb140c:         FromBaseTable table = new FromBaseTable(
1:95a483d:              tableName,
1:95a483d:              null,
1:95a483d:              null,
1:95a483d:              null,
4:95a483d:              getContextManager()
4:95a483d:              );
1:95a483d: 
1:95a483d:         if ( creatingTable )
1:95a483d:         {
1:95a483d:             table.setTableNumber(0);
1:95a483d: 			fromList.addFromTable(table);
1:3bb140c:             table.setResultColumns(new ResultColumnList(getContextManager()));
1:95a483d:         }
1:95a483d:         else // ALTER TABLE
1:95a483d:         {
1:95a483d:             fromList.addFromTable(table);
1:3bb140c:             fromList.bindTables(
1:95a483d:                  dd,
1:3bb140c:                  new FromList(
1:3bb140c:                     getOptimizerFactory().doJoinOrderOptimization(),
1:3bb140c:                     getContextManager()));
1:95a483d:         }
1:95a483d:         
1:95a483d:         tableElementList.appendNewColumnsToRCL(table);
1:95a483d: 
1:95a483d:         return fromList;
1:95a483d: 	}
1:95a483d:     
1:69f8afa:     @Override
1:69f8afa:     void acceptChildren(Visitor v) throws StandardException {
1:69f8afa:         super.acceptChildren(v);
1:69f8afa: 
1:69f8afa:         if (tableName != null) {
1:69f8afa:             tableName = (TableName) tableName.accept(v);
1:69f8afa:         }
1:69f8afa:     }
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:eab88ec
/////////////////////////////////////////////////////////////////////////
commit:69f8afa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void acceptChildren(Visitor v) throws StandardException {
1:         super.acceptChildren(v);
1: 
1:         if (tableName != null) {
1:             tableName = (TableName) tableName.accept(v);
1:         }
1:     }
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     final void generate(ActivationClassBuilder acb, MethodBuilder mb)
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.conn.Authorizer;
/////////////////////////////////////////////////////////////////////////
1:     private TableName   tableName;
/////////////////////////////////////////////////////////////////////////
1:     DDLStatementNode(TableName tableName, ContextManager cm) {
1:         super(cm);
1:         this.tableName = tableName;
1:         initOk = true;
1:     }
1: 
1:     DDLStatementNode(ContextManager cm) {
1:         super(cm);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         this.tableName = (TableName) objectName;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     String getRelativeName()
1:         return tableName.getTableName() ;
/////////////////////////////////////////////////////////////////////////
1:     String getFullName()
1:         return tableName.getFullTableName() ;
1:     public  final TableName getObjectName() { return tableName; }
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:             return ((tableName==null)?"":
1:                     "name: " + tableName.toString() +"\n") + super.toString();
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         String schemaName = tableName.getSchemaName();
/////////////////////////////////////////////////////////////////////////
1:         return getTableDescriptor(tableName);
/////////////////////////////////////////////////////////////////////////
1:         TableDescriptor td = justGetDescriptor(tableName);
/////////////////////////////////////////////////////////////////////////
0:         if (tableName != null)
0:             tableName.bind( dataDictionary );
/////////////////////////////////////////////////////////////////////////
1:         FromList fromList = new FromList(
1:                 getOptimizerFactory().doJoinOrderOptimization(),
1:                 getContextManager());
1: 
1:         FromBaseTable table = new FromBaseTable(
/////////////////////////////////////////////////////////////////////////
1:             table.setResultColumns(new ResultColumnList(getContextManager()));
1:             fromList.bindTables(
1:                  new FromList(
1:                     getOptimizerFactory().doJoinOrderOptimization(),
1:                     getContextManager()));
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
0: 			return ((objectName==null)?"":
0: 					"name: " + objectName.toString() +"\n") + super.toString();
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:a6a0733
/////////////////////////////////////////////////////////////////////////
1: 	public	static	final	int	UPDATE_STATISTICS = 5;
1: 	public	static	final	int DROP_STATISTICS = 6;
commit:818fd27
/////////////////////////////////////////////////////////////////////////
1: 		return getSchemaDescriptor(true, true);
1: 	* 
1: 	* The most common call to this method is with 2nd 
1: 	* parameter true which says that SchemaDescriptor
1: 	* should not be requested for system schema. The only
1: 	* time this method will get called with 2nd parameter
1: 	* set to false will be when user has requested for
1: 	* inplace compress using 
1: 	* SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE
1: 	* Above inplace compress can be invoked on system tables.
1: 	* A call to SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE 
1: 	* internally gets translated into ALTER TABLE sql.
1: 	* When ALTER TABLE is executed for SYSCS_INPLACE_COMPRESS_TABLE,
1: 	* we want to allow SchemaDescriptor request for system
1: 	* tables. DERBY-1062
1: 	* @param doSystemSchemaCheck   If check for system schema is needed.
1: 	*    If set to true, then throw an exception if schema descriptor
1: 	*    is requested for a system schema. The only time this param 
1: 	*    will be set to false is when user is asking for inplace
1: 	*    compress of a system table. DERBY-1062
1: 	protected final SchemaDescriptor getSchemaDescriptor(boolean ownerCheck,
1: 			boolean doSystemSchemaCheck)
/////////////////////////////////////////////////////////////////////////
1: 		** Catch the system schema here if the caller wants us to.
1: 		** Currently, the only time we allow system schema is for inplace
1: 		** compress table calls.
1: 		if (doSystemSchemaCheck && sd.isSystemSchema())
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Validate that the table is ok for DDL -- e.g.
1: 	 * that it exists, it is not a view. It is ok for
1: 	 * it to be a system table. Also check that its 
1: 	 * schema is ok. Currently, the only time this method
1: 	 * is called is when user has asked for inplace 
1: 	 * compress. eg
1: 	 * call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE('SYS','SYSTABLES',1,1,1);
1: 	 * Inplace compress is allowed on both system and
1: 	 * user tables.
1: 	 *
1: 	 * @return the validated table descriptor, never null
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	protected final TableDescriptor getTableDescriptor(boolean doSystemTableCheck)
1: 	throws StandardException
1: 	{
0: 		TableDescriptor td = justGetDescriptor(objectName);
1: 		td = checkTableDescriptor(td,doSystemTableCheck);
1: 		return td;
1: 	}
1: 
1: 		td = checkTableDescriptor(td,true);
/////////////////////////////////////////////////////////////////////////
1: 		TableDescriptor td = justGetDescriptor(tableName);
1: 
1: 		/* beetle 4444, td may have changed when we obtain shared lock */
1: 		td = checkTableDescriptor(td, true);
1: 		return td;
1: 
1: 	}
1: 
1: 	/**
1: 	 * Just get the table descriptor. Don't worry if it belongs to a view,
1: 	 * system table, synonym or a real table. Let the caller decide what
1: 	 * to do.
1: 	 * 
1: 	 * @param tableName
1: 	 * 
1: 	 * @return TableDescriptor for the give TableName
1: 	 * 
1: 	 * @throws StandardException on error
1: 	 */
1: 	private TableDescriptor justGetDescriptor(TableName tableName)
1: 	throws StandardException
1: 	{
/////////////////////////////////////////////////////////////////////////
1: 	private TableDescriptor checkTableDescriptor(TableDescriptor td, 
1: 			boolean doSystemTableCheck)
1: 		case TableDescriptor.SYSTEM_TABLE_TYPE:
1: 			if (doSystemTableCheck)
1: 				/*
1: 				** Not on system tables (though there are no constraints on
1: 				** system tables as of the time this is writen
1: 				*/
1: 				sqlState = SQLState.LANG_INVALID_OPERATION_ON_SYSTEM_TABLE;
1: 			else
1: 				//allow system table. The only time this happens currently is
1: 				//when user is requesting inplace compress on system table
1: 				return td;
1: 			break;
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:15b837e
/////////////////////////////////////////////////////////////////////////
1:       * @param dd  Metadata.
1:       * @param tableElementList the parenthesized list of columns and constraints in a CREATE/ALTER TABLE statement
commit:95a483d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	  *	Make a from list for binding query fragments in a CREATE/ALTER TABLE
1:       *     statement.
1:       *
1:       * @param creatingTable true if this is for CREATE TABLE. false if this is for ALTER TABLE
1:       */
1: 	FromList	makeFromList( DataDictionary dd, TableElementList tableElementList, boolean creatingTable )
1:         throws StandardException
1: 	{
1:         // DERBY-3043: To avoid a no-such-schema error when
1:         // binding the check constraint, ensure that the
1:         // table we bind against has a schema name specified.
1:         // If it doesn't, fill in the schema name now.
1:         //
1:         TableName tableName = getObjectName();
1:         if (tableName.getSchemaName() == null)
1:         { tableName.setSchemaName(getSchemaDescriptor().getSchemaName()); }
1:         
0:         FromList fromList = (FromList) getNodeFactory().getNode
0:             (
0:              C_NodeTypes.FROM_LIST,
0:              getNodeFactory().doJoinOrderOptimization(),
1:              getContextManager()
1:              );
0:         FromBaseTable table = (FromBaseTable) getNodeFactory().getNode
0:             (
0:              C_NodeTypes.FROM_BASE_TABLE,
1:              tableName,
1:              null,
1:              null,
1:              null,
1:              getContextManager()
1:              );
1: 
1:         if ( creatingTable )
1:         {
1:             table.setTableNumber(0);
1: 			fromList.addFromTable(table);
0: 			table.setResultColumns
0:                 ((ResultColumnList) getNodeFactory().getNode
0:                  (
0:                   C_NodeTypes.RESULT_COLUMN_LIST,
1:                   getContextManager()
0:                   )
1:                  );
1:         }
1:         else // ALTER TABLE
1:         {
1:             fromList.addFromTable(table);
0:             fromList.bindTables
0:                 (
1:                  dd,
0:                  (FromList) getNodeFactory().getNode
0:                  (
0:                   C_NodeTypes.FROM_LIST,
0:                   getNodeFactory().doJoinOrderOptimization(),
1:                   getContextManager()
0:                   )
1:                  );
1:         }
1:         
1:         tableElementList.appendNewColumnsToRCL(table);
1: 
1:         return fromList;
1: 	}
1:     
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:cc770d8
/////////////////////////////////////////////////////////////////////////
0: 	void	bindName( DataDictionary	dataDictionary )
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
1: 			if (isPrivilegeCollectionRequired())
1: 				cc.addRequiredSchemaPriv(schemaName, null, Authorizer.CREATE_SCHEMA_PRIV);
1: 		if (ownerCheck && isPrivilegeCollectionRequired())
commit:0061383
/////////////////////////////////////////////////////////////////////////
1: abstract class DDLStatementNode extends StatementNode
commit:ddc6f41
/////////////////////////////////////////////////////////////////////////
1: 		case TableDescriptor.VTI_TYPE:
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.DDLStatementNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: import org.apache.derby.catalog.UUID;
1: 
1: /**
1:  * A DDLStatementNode represents any type of DDL statement: CREATE TABLE,
1:  * CREATE INDEX, ALTER TABLE, etc.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public abstract class DDLStatementNode extends StatementNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	CONSTANTS
1: 	//
1: 	/////////////////////////////////////////////////////////////////////////
1: 
1: 	public	static	final	int	UNKNOWN_TYPE = 0;
1: 	public	static	final	int	ADD_TYPE = 1;
1: 	public	static	final	int	DROP_TYPE = 2;
1: 	public	static	final	int	MODIFY_TYPE = 3;
1: 	public	static	final	int	LOCKING_TYPE = 4;
1: 
1: 
1: 	/////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	STATE
1: 	//
1: 	/////////////////////////////////////////////////////////////////////////
1: 
0: 	private TableName	objectName;
1: 	private boolean		initOk;
1: 
1: 	/**
1: 		sub-classes can set this to be true to allow implicit
1: 		creation of the main object's schema at execution time.
1: 	*/
1: 	boolean implicitCreateSchema;
1: 
1: 
1: 	/////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	BEHAVIOR
1: 	//
1: 	/////////////////////////////////////////////////////////////////////////
1: 
0: 	public void init(Object objectName)
1: 		throws StandardException {
0: 		initAndCheck(objectName);
1: 	}
1: 
1: 	/**
1: 		Initialize the object name we will be performing the DDL
1: 		on and check that we are not in the system schema
1: 		and that DDL is allowed.
1: 	*/
1: 	protected void initAndCheck(Object objectName)
1: 		throws StandardException {
1: 
0: 		this.objectName = (TableName) objectName;
1: 
1: 		initOk = true;
1: 	}
1: 
1: 	/**
1: 	 * A DDL statement is always atomic
1: 	 *
1: 	 * @return true 
1: 	 */	
1: 	public boolean isAtomic()
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Return the name of the table being dropped.
1: 	 * This is the unqualified table name.
1: 	 *
1: 	 * @return the relative name
1: 	 */
0: 	public String getRelativeName()
1: 	{
0: 		return objectName.getTableName() ;
1: 	}
1: 
1: 	/**
1: 	 * Return the full dot expression name of the 
1: 	 * object being dropped.
1: 	 * 
1: 	 * @return the full name
1: 	 */
0: 	public String getFullName()
1: 	{
0: 		return objectName.getFullTableName() ;
1: 	}
1: 
0:     public	final TableName	getObjectName() { return objectName; }
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			return objectName.toString() + super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	int activationKind()
1: 	{
1: 		   return StatementNode.NEED_DDL_ACTIVATION;
1: 	}
1: 
1: 	/**
1: 	 * Generic generate code for all DDL statements.
1: 	 *
1: 	 * @param acb	The ActivationClassBuilder for the class being built
1: 	 * @param mb	The execute() method to be built
1: 	 *
0: 	 * @return		A compiled expression returning the RepCreatePublicationResultSet
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public final void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG) {
1: 			if (!initOk)
1: 				SanityManager.THROWASSERT(getClass() + " never called initAndCheck()");
1: 		}
1: 
1: 		// The generated java is the expression:
1: 		// return ResultSetFactory.getDDLResultSet(this)
1: 		//		                       
1: 
1: 		acb.pushGetResultSetFactoryExpression(mb); // instance for getDDLResultSet
1: 		acb.pushThisAsActivation(mb); // first arg
1: 
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getDDLResultSet", ClassName.ResultSet, 1);
1: 	}
1: 
1: 	 
1: 
1: 	/**
1: 	* Get a schema descriptor for this DDL object.
1: 	* Uses this.objectName.  Always returns a schema,
1: 	* we lock in the schema name prior to execution.
1: 	*
1: 	* @return Schema Descriptor
1: 	*
1: 	* @exception	StandardException	throws on schema name
1: 	*						that doesn't exist	
1: 	*/
1: 	protected final SchemaDescriptor getSchemaDescriptor() throws StandardException
1: 	{
0: 		String schemaName = objectName.getSchemaName();
1: 		//boolean needError = !(implicitCreateSchema || (schemaName == null));
1: 		boolean needError = !implicitCreateSchema;
1: 		SchemaDescriptor sd = getSchemaDescriptor(schemaName, needError);
1: 
1: 		if (sd == null) {
1: 			/* Disable creating schemas starting with SYS */
1: 			if (schemaName.startsWith("SYS"))
1: 				throw StandardException.newException(SQLState.LANG_NO_USER_DDL_IN_SYSTEM_SCHEMA,
0: 					statementToString(), schemaName);
1: 
1: 			sd  = new SchemaDescriptor(getDataDictionary(), schemaName,
1: 				(String) null, (UUID)null, false);
1: 		}
1: 
1: 		/*
0: 		** Catch the system schema here.
1: 		*/	 
0: 		if (sd.isSystemSchema())
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_NO_USER_DDL_IN_SYSTEM_SCHEMA,
1: 							statementToString(), sd);
1: 		}
1: 		return sd;
1: 	}
1: 
1: 	protected final TableDescriptor getTableDescriptor()
1: 		throws StandardException
1: 	{
0: 		return getTableDescriptor(objectName);
1: 	}
1: 
1: 	protected final TableDescriptor getTableDescriptor(UUID tableId)
1: 		throws StandardException {
1: 
1: 		TableDescriptor td = getDataDictionary().getTableDescriptor(tableId);
1: 
0: 		td = checkTableDescriptor(td);
1: 		return td;
1: 
1: 	}
1: 
1: 
1: 	/**
1: 	 * Validate that the table is ok for DDL -- e.g.
1: 	 * that it exists, it is not a view, and is not
1: 	 * a system table, and that its schema is ok.
1: 	 *
0: 	 * @param tableDescriptor td
1: 	 *
1: 	 * @return the validated table descriptor, never null
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	protected final TableDescriptor getTableDescriptor(TableName tableName)
1: 		throws StandardException
1: 	{
1: 		String schemaName = tableName.getSchemaName();
1: 		SchemaDescriptor sd = getSchemaDescriptor(schemaName);
1: 		
1: 		TableDescriptor td = getTableDescriptor(tableName.getTableName(), sd);
1: 
1: 		if (td == null)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_OBJECT_DOES_NOT_EXIST, 
1: 						statementToString(), tableName);
1: 		}
1: 
0: 		/* beetle 4444, td may have changed when we obtain shared lock */
0: 		td = checkTableDescriptor(td);
1: 		return td;
1: 
1: 	}
1: 
0: 	private TableDescriptor checkTableDescriptor(TableDescriptor td)
1: 		throws StandardException
1: 	{
1: 		String sqlState = null;
1: 
1: 		switch (td.getTableType()) {
0: 		case TableDescriptor.SYSTEM_TABLE_TYPE:
1: 
1: 			/*
0: 			** Not on system tables (though there are no constraints on
0: 			** system tables as of the time this is writen
1: 			*/
1: 			sqlState = SQLState.LANG_INVALID_OPERATION_ON_SYSTEM_TABLE;
1: 			break;
1: 
1: 		case TableDescriptor.BASE_TABLE_TYPE:
1: 			/* need to IX lock table if we are a reader in DDL datadictionary
1: 			 * cache mode, otherwise we may interfere with another DDL thread
1: 			 * that is in execution phase; beetle 4343, also see $WS/docs/
1: 			 * language/SolutionsToConcurrencyIssues.txt (point f)
1: 			 */
1: 			return lockTableForCompilation(td);
1: 
1: 		case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:
1: 			return td;
1: 
1: 		/*
1: 		** Make sure it is not a view
1: 		*/
1: 		case TableDescriptor.VIEW_TYPE:
1: 			sqlState = SQLState.LANG_INVALID_OPERATION_ON_VIEW;
1: 			break;
1: 		}
1: 
1: 		
1: 		throw StandardException.newException(sqlState, 
1: 				statementToString(), td.getQualifiedName());
1: 
1: 	}
1: 
1: 	/**
0: 	  *	Bind the  object Name. This means filling in the schema name if it
0: 	  *	wasn't specified.
1: 	  *
0: 	  *	@param	dataDictionary	Data dictionary to bind against.
1: 	  *
0: 	  *	@exception StandardException		Thrown on error
1: 	  */
0: 	public	void	bindName( DataDictionary	dataDictionary )
1: 		                       throws StandardException
1: 	{
0: 		if (objectName != null)
0: 			objectName.bind( dataDictionary );
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d78ad2e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
/////////////////////////////////////////////////////////////////////////
1: 		CompilerContext cc = getCompilerContext();
/////////////////////////////////////////////////////////////////////////
0: 
0: 			cc.addRequiredSchemaPriv(schemaName, null, Authorizer.CREATE_SCHEMA_PRIV);
1: 			cc.addRequiredSchemaPriv(sd.getSchemaName(), null,
commit:b973d2c
/////////////////////////////////////////////////////////////////////////
0: 			return ((objectName==null)?"":objectName.toString()) + super.toString();
commit:50ba36b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.conn.Authorizer;
/////////////////////////////////////////////////////////////////////////
1: 				throw StandardException.newException(
1: 					SQLState.LANG_NO_USER_DDL_IN_SYSTEM_SCHEMA,
1: 					statementToString(),
1: 					schemaName);
0: 			getCompilerContext().addRequiredSchemaPriv(sd.getSchemaName(), null,
1: 						Authorizer.MODIFY_SCHEMA_PRIV);
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
1: 	* Checks if current authorizationID is owner of the schema.
/////////////////////////////////////////////////////////////////////////
0: 		return getSchemaDescriptor(true);
0: 	}
0: 
0: 	/**
1: 	* Get a schema descriptor for this DDL object.
1: 	* Uses this.objectName.  Always returns a schema,
1: 	* we lock in the schema name prior to execution.
0: 	*
1: 	* @param ownerCheck		If check for schema owner is needed
0: 	*
1: 	* @return Schema Descriptor
0: 	*
1: 	* @exception	StandardException	throws on schema name
1: 	*						that doesn't exist	
0: 	*/
0: 	protected final SchemaDescriptor getSchemaDescriptor(boolean ownerCheck)
0: 		 throws StandardException
0: 	{
/////////////////////////////////////////////////////////////////////////
0: 		if (ownerCheck)
0: 			getCompilerContext().addRequiredSchemaPriv(sd);
0: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: import org.apache.derby.catalog.UUID;
0: 
0: /**
0:  * A DDLStatementNode represents any type of DDL statement: CREATE TABLE,
0:  * CREATE INDEX, ALTER TABLE, etc.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public abstract class DDLStatementNode extends StatementNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	CONSTANTS
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////
0: 
0: 	public	static	final	int	UNKNOWN_TYPE = 0;
0: 	public	static	final	int	ADD_TYPE = 1;
0: 	public	static	final	int	DROP_TYPE = 2;
0: 	public	static	final	int	MODIFY_TYPE = 3;
0: 	public	static	final	int	LOCKING_TYPE = 4;
0: 
0: 
0: 	/////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	STATE
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////
0: 
0: 	private TableName	objectName;
0: 	private boolean		initOk;
0: 
0: 	/**
0: 		sub-classes can set this to be true to allow implicit
0: 		creation of the main object's schema at execution time.
0: 	*/
0: 	boolean implicitCreateSchema;
0: 
0: 
0: 	/////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	BEHAVIOR
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////
0: 
0: 	public void init(Object objectName)
0: 		throws StandardException {
0: 		initAndCheck(objectName);
0: 	}
0: 
0: 	/**
0: 		Initialize the object name we will be performing the DDL
0: 		on and check that we are not in the system schema
0: 		and that DDL is allowed.
0: 	*/
0: 	protected void initAndCheck(Object objectName)
0: 		throws StandardException {
0: 
0: 		this.objectName = (TableName) objectName;
0: 
0: 		initOk = true;
0: 	}
0: 
0: 	/**
0: 	 * A DDL statement is always atomic
0: 	 *
0: 	 * @return true 
0: 	 */	
0: 	public boolean isAtomic()
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Return the name of the table being dropped.
0: 	 * This is the unqualified table name.
0: 	 *
0: 	 * @return the relative name
0: 	 */
0: 	public String getRelativeName()
0: 	{
0: 		return objectName.getTableName() ;
0: 	}
0: 
0: 	/**
0: 	 * Return the full dot expression name of the 
0: 	 * object being dropped.
0: 	 * 
0: 	 * @return the full name
0: 	 */
0: 	public String getFullName()
0: 	{
0: 		return objectName.getFullTableName() ;
0: 	}
0: 
0:     public	final TableName	getObjectName() { return objectName; }
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return objectName.toString() + super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	int activationKind()
0: 	{
0: 		   return StatementNode.NEED_DDL_ACTIVATION;
0: 	}
0: 
0: 	/**
0: 	 * Generic generate code for all DDL statements.
0: 	 *
0: 	 * @param acb	The ActivationClassBuilder for the class being built
0: 	 * @param mb	The execute() method to be built
0: 	 *
0: 	 * @return		A compiled expression returning the RepCreatePublicationResultSet
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public final void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG) {
0: 			if (!initOk)
0: 				SanityManager.THROWASSERT(getClass() + " never called initAndCheck()");
0: 		}
0: 
0: 		// The generated java is the expression:
0: 		// return ResultSetFactory.getDDLResultSet(this)
0: 		//		                       
0: 
0: 		acb.pushGetResultSetFactoryExpression(mb); // instance for getDDLResultSet
0: 		acb.pushThisAsActivation(mb); // first arg
0: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getDDLResultSet", ClassName.ResultSet, 1);
0: 	}
0: 
0: 	 
0: 
0: 	/**
0: 	* Get a schema descriptor for this DDL object.
0: 	* Uses this.objectName.  Always returns a schema,
0: 	* we lock in the schema name prior to execution.
0: 	*
0: 	* @return Schema Descriptor
0: 	*
0: 	* @exception	StandardException	throws on schema name
0: 	*						that doesn't exist	
0: 	*/
0: 	protected final SchemaDescriptor getSchemaDescriptor() throws StandardException
0: 	{
0: 		String schemaName = objectName.getSchemaName();
0: 		//boolean needError = !(implicitCreateSchema || (schemaName == null));
0: 		boolean needError = !implicitCreateSchema;
0: 		SchemaDescriptor sd = getSchemaDescriptor(schemaName, needError);
0: 
0: 		if (sd == null) {
0: 			/* Disable creating schemas starting with SYS */
0: 			if (schemaName.startsWith("SYS"))
0: 				throw StandardException.newException(SQLState.LANG_NO_USER_DDL_IN_SYSTEM_SCHEMA,
0: 					statementToString(), schemaName);
0: 
0: 			sd  = new SchemaDescriptor(getDataDictionary(), schemaName,
0: 				(String) null, (UUID)null, false);
0: 		}
0: 
0: 		/*
0: 		** Catch the system schema here.
0: 		*/	 
0: 		if (sd.isSystemSchema())
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_NO_USER_DDL_IN_SYSTEM_SCHEMA,
0: 							statementToString(), sd);
0: 		}
0: 		return sd;
0: 	}
0: 
0: 	protected final TableDescriptor getTableDescriptor()
0: 		throws StandardException
0: 	{
0: 		return getTableDescriptor(objectName);
0: 	}
0: 
0: 	protected final TableDescriptor getTableDescriptor(UUID tableId)
0: 		throws StandardException {
0: 
0: 		TableDescriptor td = getDataDictionary().getTableDescriptor(tableId);
0: 
0: 		td = checkTableDescriptor(td);
0: 		return td;
0: 
0: 	}
0: 
0: 
0: 	/**
0: 	 * Validate that the table is ok for DDL -- e.g.
0: 	 * that it exists, it is not a view, and is not
0: 	 * a system table, and that its schema is ok.
0: 	 *
0: 	 * @param tableDescriptor td
0: 	 *
0: 	 * @return the validated table descriptor, never null
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	protected final TableDescriptor getTableDescriptor(TableName tableName)
0: 		throws StandardException
0: 	{
0: 		String schemaName = tableName.getSchemaName();
0: 		SchemaDescriptor sd = getSchemaDescriptor(schemaName);
0: 		
0: 		TableDescriptor td = getTableDescriptor(tableName.getTableName(), sd);
0: 
0: 		if (td == null)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_OBJECT_DOES_NOT_EXIST, 
0: 						statementToString(), tableName);
0: 		}
0: 
0: 		/* beetle 4444, td may have changed when we obtain shared lock */
0: 		td = checkTableDescriptor(td);
0: 		return td;
0: 
0: 	}
0: 
0: 	private TableDescriptor checkTableDescriptor(TableDescriptor td)
0: 		throws StandardException
0: 	{
0: 		String sqlState = null;
0: 
0: 		switch (td.getTableType()) {
0: 		case TableDescriptor.SYSTEM_TABLE_TYPE:
0: 
0: 			/*
0: 			** Not on system tables (though there are no constraints on
0: 			** system tables as of the time this is writen
0: 			*/
0: 			sqlState = SQLState.LANG_INVALID_OPERATION_ON_SYSTEM_TABLE;
0: 			break;
0: 
0: 		case TableDescriptor.BASE_TABLE_TYPE:
0: 			/* need to IX lock table if we are a reader in DDL datadictionary
0: 			 * cache mode, otherwise we may interfere with another DDL thread
0: 			 * that is in execution phase; beetle 4343, also see $WS/docs/
0: 			 * language/SolutionsToConcurrencyIssues.txt (point f)
0: 			 */
0: 			return lockTableForCompilation(td);
0: 
0: 		case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:
0: 			return td;
0: 
0: 		/*
0: 		** Make sure it is not a view
0: 		*/
0: 		case TableDescriptor.VIEW_TYPE:
0: 			sqlState = SQLState.LANG_INVALID_OPERATION_ON_VIEW;
0: 			break;
0: 		}
0: 
0: 		
0: 		throw StandardException.newException(sqlState, 
0: 				statementToString(), td.getQualifiedName());
0: 
0: 	}
0: 
0: 	/**
0: 	  *	Bind the  object Name. This means filling in the schema name if it
0: 	  *	wasn't specified.
0: 	  *
0: 	  *	@param	dataDictionary	Data dictionary to bind against.
0: 	  *
0: 	  *	@exception StandardException		Thrown on error
0: 	  */
0: 	public	void	bindName( DataDictionary	dataDictionary )
0: 		                       throws StandardException
0: 	{
0: 		if (objectName != null)
0: 			objectName.bind( dataDictionary );
0: 	}
0: }
============================================================================