1:8bc3183: /*
1:8bc3183:  *
1:8badf99:  * Derby - Class org.apache.derbyTesting.junit.DatabasePropertyTestSetup
1:8bc3183:  *
1:8bc3183:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:8bc3183:  * contributor license agreements.  See the NOTICE file distributed with
1:8bc3183:  * this work for additional information regarding copyright ownership.
1:8bc3183:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:8bc3183:  * (the "License"); you may not use this file except in compliance with
1:8bc3183:  * the License.  You may obtain a copy of the License at
1:8bc3183:  *
1:8bc3183:  *    http://www.apache.org/licenses/LICENSE-2.0
1:8bc3183:  *
1:8bc3183:  * Unless required by applicable law or agreed to in writing, 
1:8bc3183:  * software distributed under the License is distributed on an 
1:8bc3183:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:8bc3183:  * either express or implied. See the License for the specific 
1:8bc3183:  * language governing permissions and limitations under the License.
1:8bc3183:  */
1:8bc3183: package org.apache.derbyTesting.junit;
1:8bc3183: 
1:8bc3183: import java.sql.CallableStatement;
1:8bc3183: import java.sql.Connection;
1:8bc3183: import java.sql.PreparedStatement;
1:8bc3183: import java.sql.ResultSet;
1:8bc3183: import java.sql.SQLException;
1:8bc3183: import java.util.Enumeration;
1:8bc3183: import java.util.Properties;
1:8bc3183: 
1:8bc3183: import junit.framework.Test;
1:8bc3183: 
1:f05a2f8: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
1:f05a2f8: 
1:64c254c: /**
1:8bc3183:  * Test decorator to set a set of database properties on setUp
1:8bc3183:  * and restore them to the previous values on tearDown.
1:8bc3183:  *
1:8bc3183:  */
1:8bc3183: public class DatabasePropertyTestSetup extends BaseJDBCTestSetup {
1:8bc3183: 	
1:8bc3183: 	private Properties newValues;
1:8bc3183: 	private Properties oldValues;
1:64c254c:     private final boolean staticProperties;
1:be115c4:     
1:be115c4:     /**
1:be115c4:      * Decorator to change the lock time outs.
1:be115c4:      * If either time is less than zero then that property is
1:be115c4:      * not modified by this decorator.
1:be115c4:      * The change is implemented by an instanceof DatabasePropertyTestSetup
1:be115c4:      * and thus is reset by the tearDown method.
1:be115c4:      * 
1:be115c4:      * @param test Test to decorate
1:be115c4:      * @param deadlockTime Time in seconds for derby.locks.deadlockTimeout.
1:be115c4:      * @param waitTime Time in seconds for derby.locks.waitTimeout
1:be115c4:      */
1:be115c4:     public static Test setLockTimeouts(Test test, int deadlockTime, int waitTime)
1:be115c4:     {
1:be115c4:         final Properties properties = new Properties();
1:be115c4:         if (deadlockTime >= 0)
1:be115c4:         {
1:be115c4:             properties.setProperty("derby.locks.deadlockTimeout",
1:be115c4:                 Integer.toString(deadlockTime));
1:be115c4:         }
1:be115c4:         if (waitTime >= 0) {
1:be115c4:             properties.setProperty("derby.locks.waitTimeout",
1:be115c4:                 Integer.toString(waitTime));
1:be115c4:         }
1:be115c4:         
1:be115c4:         // No change, no point to the decorator.
1:be115c4:         if (properties.isEmpty())
1:be115c4:             return test;
1:6da924f: 
1:64c254c:         return new DatabasePropertyTestSetup(test, properties, true);
1:64c254c:     }
1:64c254c:     
1:6da924f:     /**
1:64c254c:      * Decorate a test so that the database has authentication enabled
1:64c254c:      * using the BUILTIN provider and the set of users passed in.
1:4ee3a23:      * The password for each user is set to the user's name as set
1:4ee3a23:      * in the users array with the value of passwordToken appended.
1:4ee3a23:      * <BR>
1:4ee3a23:      * The user names in the users array are treated as SQL identifiers
1:4ee3a23:      * since that is the defined behaviour for derby.user.username.
1:4ee3a23:      * This means that the quoted identifiers can be passed, examples
1:4ee3a23:      * are (users[i] is shown as the contents of the Java string) with
1:4ee3a23:      * a password suffix of T63:
1:4ee3a23:      * <UL>
1:4ee3a23:      * <LI>users[i]=fred - normal user name FRED, password fredT63
1:4ee3a23:      * <LI>users[i]=FRED - normal user name FRED, passeword FREDT63
1:4ee3a23:      * <LI>users[i]="FRED" - normal user name FRED, passeword "FREDT63"
1:4ee3a23:      * <LI>users[i]="fred" - normal user name fred, passeword "fredT63"
1:4ee3a23:      * </UL>
1:4ee3a23:      * Thus with a quoted identifier the password will include the quotes.
1:4ee3a23:      * Note bug DERBY-3150 exists which means that the normalized user name
1:4ee3a23:      * to password mapping does not exist, thus a connection request must be
1:4ee3a23:      * made with the values passed in the users array, not any other form of the
1:4ee3a23:      * name.
1:af7f5e2:      * <BR>
1:af7f5e2:      * The decorated test can use BaseJDBCTestCase.openUserConnection(String user)
1:af7f5e2:      * method to simplify using authentication.
1:64c254c:      * <P>
1:64c254c:      * Assumption is that no authentication was enabled upon entry.
1:64c254c:      * <P>
1:af7f5e2:      * Current user is set to the first user in the list users[0].
1:af7f5e2:      * <P>
1:64c254c:      * The authentication is removed by the decorator's tearDown method.
1:64c254c:      * @param test Test to be decorated.
1:64c254c:      * @param users Set of users for authentication.
1:64c254c:      * @return Decorated test.
1:64c254c:      */
1:64c254c:     public static Test builtinAuthentication(Test test, String[] users,
1:64c254c:             String passwordToken)
1:f5bfd98:     {
1:64c254c:         final Properties userProps = new Properties();
1:64c254c:         final Properties authProps = new Properties();
1:64c254c:         
1:64c254c:         authProps.setProperty("derby.connection.requireAuthentication", "true");
1:64c254c:         authProps.setProperty("derby.authentication.provider", "BUILTIN");
1:64c254c:         
1:64c254c:         for (int i = 0; i < users.length; i++)
1:64c254c:         {
1:64c254c:             String user = users[i];
1:2346370:             userProps.setProperty("derby.user." + user,
1:2346370:                     TestConfiguration.getPassword(user, passwordToken));
1:64c254c:         }
1:64c254c:         
1:64c254c:         // Need to setup the decorators carefully.
1:64c254c:         // Need execution in this order:
1:64c254c:         // 1) add user definitions (no authentication enabled)
1:64c254c:         // 2) switch to a valid user
1:64c254c:         // 3) enable authentication with database reboot
1:64c254c:         // 4) disable authentication with database reboot
1:64c254c:         // 5) switch back to previous user
1:64c254c:         // 6) remove user defintions.
1:64c254c:         //
1:64c254c:         // Combining steps 1,3 does not work as no shutdown request
1:64c254c:         // is possible for step 4 as no valid users would be defined!
1:64c254c:         //
1:64c254c:         // Note the decorators are executed in order from
1:64c254c:         // outer (added last) to inner.
1:64c254c:         
1:64c254c:         test = new DatabasePropertyTestSetup(test, authProps, true);
1:2346370:         test = new ChangeUserSetup(test, users[0],
1:2346370:                 TestConfiguration.getPassword(users[0], passwordToken),
1:2346370:                 passwordToken);
1:64c254c:         test = new DatabasePropertyTestSetup(test, userProps, false);
1:be115c4:         
1:af7f5e2:         return test;
1:be115c4:     }
1:8bc3183:     
1:8bc3183:     /**
1:af7f5e2:      * Decorate a test so that the database has authentication enabled
1:af7f5e2:      * using the BUILTIN provider and the set of users passed in.
1:64c254c:      * The password for each user is set to the user's name with
1:64c254c:      * the value of passwordToken appended.
1:2346370:      * <BR>
1:2346370:      * The decorated test can use BaseJDBCTestCase.openUserConnection(String user)
1:2346370:      * method to simplify using authentication.
1:2346370:      * <P>
1:af7f5e2:      * Assumption is that no authentication was enabled upon entry.
1:af7f5e2:      * <P>
1:2346370:      * Current user is set to the first user in the list users[0].
1:af7f5e2:      * <P>
1:af7f5e2:      * In contrast to plain builtinAuthentication, here the
1:af7f5e2:      * authentication nor users are *NOT* removed by the decorator's
1:af7f5e2:      * tearDown method.
1:af7f5e2:      * @param test Test to be decorated.
1:af7f5e2:      * @param users Set of users for authentication.
1:af7f5e2:      * @return Decorated test.
1:af7f5e2:      */
1:af7f5e2:     public static Test builtinAuthenticationNoTeardown(Test test, String[] users,
1:af7f5e2:             String passwordToken)
1:64c254c:     {
1:af7f5e2:         final Properties userProps = new Properties();
1:af7f5e2:         final Properties authProps = new Properties();
1:64c254c: 
1:af7f5e2:         authProps.setProperty("derby.connection.requireAuthentication", "true");
1:af7f5e2:         authProps.setProperty("derby.authentication.provider", "BUILTIN");
1:af7f5e2: 
1:af7f5e2:         for (int i = 0; i < users.length; i++)
1:8bc3183:         {
1:af7f5e2:             String user = users[i];
1:af7f5e2:             userProps.setProperty("derby.user." + user,
1:af7f5e2:                     TestConfiguration.getPassword(user, passwordToken));
1:8bc3183:         }
1:af7f5e2: 
1:af7f5e2:         test = getNoTeardownInstance(test, authProps, true);
1:af7f5e2:         test = new ChangeUserSetup(test, users[0],
1:af7f5e2:                 TestConfiguration.getPassword(users[0], passwordToken),
1:af7f5e2:                 passwordToken);
1:af7f5e2:         test = getNoTeardownInstance(test, userProps, false);
1:64c254c:         return test;
1:8bc3183:     }
1:af7f5e2: 
1:fcaa724:     static DatabasePropertyTestSetup getNoTeardownInstance(
1:af7f5e2:         Test test, Properties p, boolean staticp)
3:af7f5e2:     {
1:af7f5e2:         return new DatabasePropertyTestSetup(test, p, staticp) {
1:af7f5e2:                 protected void tearDown()
1:af7f5e2:                         throws java.lang.Exception {
1:fcaa724:                     // We don't want to reset the properties, but we should
1:fcaa724:                     // still clear the reference to the default connection to
1:fcaa724:                     // allow it to be garbage collected.
1:fcaa724:                     clearConnection();
1:8bc3183:                 }
1:af7f5e2:             };
4:af7f5e2:     }
1:af7f5e2: 
1:8bc3183:     /**
1:6da924f:      * Decorate a test so that it sets a single database property
1:6da924f:      * at setUp and resets it at tearDown. Shorthand for
1:6da924f:      * using DatabasePropertyTestSetup when only a single property is needed.
1:6da924f:      * Does not perform a reboot of the database.
1:6da924f:      */
1:6da924f:     public static Test singleProperty(Test test, String property, String value)
1:6da924f:     {
1:a43ee19:         return singleProperty(test, property, value, false);
1:a43ee19:     }
1:a43ee19:     /**
1:a43ee19:      * Decorate a test so that it sets a single database property
1:a43ee19:      * at setUp and resets it at tearDown. Shorthand for
1:a43ee19:      * using DatabasePropertyTestSetup when only a single property is needed.
1:a43ee19:      * Optinally reboots the database.
1:a43ee19:      */
1:a43ee19:     public static Test singleProperty(Test test, String property, String value,
1:a43ee19:             boolean reboot)
1:a43ee19:     {
1:6da924f:         final Properties properties = new Properties();
1:6da924f:         properties.setProperty(property, value);
1:6da924f: 
1:a43ee19:         return new DatabasePropertyTestSetup(test, properties, reboot);
1:6da924f:     }    
1:af7f5e2: 	
1:af7f5e2: 	/**
1:8bc3183: 	 * Create a test decorator that sets and restores the passed
1:8bc3183: 	 * in properties. Assumption is that the contents of
1:8bc3183: 	 * properties and values will not change during execution.
1:8bc3183: 	 * @param test test to be decorated
1:8bc3183: 	 * @param newValues properties to be set
1:8bc3183: 	 */
1:8bc3183: 	public DatabasePropertyTestSetup(Test test,
1:8bc3183: 			Properties newValues)
1:8bc3183: 	{
1:64c254c:         this(test, newValues, false);
1:64c254c:     }
1:64c254c:     
1:64c254c:     /**
1:64c254c:      * Create a test decorator that sets and restores the passed
1:64c254c:      * in properties. Assumption is that the contents of
1:64c254c:      * properties and values will not change during execution.
1:64c254c:      * @param test test to be decorated
1:64c254c:      * @param newValues properties to be set
1:64c254c:      * @param staticProperties True if database needs to be shutdown after
1:64c254c:      * setting properties in setUp() and tearDown method().
1:64c254c:      */
1:64c254c:     public DatabasePropertyTestSetup(Test test,
1:64c254c:             Properties newValues, boolean staticProperties)
1:64c254c:     {
1:8bc3183: 		super(test);
1:8bc3183: 		this.newValues = newValues;
1:8bc3183: 		this.oldValues = new Properties();
1:64c254c:         this.staticProperties = staticProperties;
1:8bc3183: 	}
1:8bc3183: 
1:8bc3183: 	/**
1:8bc3183: 	 * For each property store the current value and
1:8bc3183: 	 * replace it with the new value, unless there is no change.
1:8bc3183: 	 */
1:8bc3183:     protected void setUp()
1:8bc3183:     throws java.lang.Exception
1:8bc3183:     {
1:8bc3183:     	setProperties(newValues);
1:64c254c:         if (staticProperties) {
1:9528482:             TestConfiguration.getCurrent().shutdownDatabase();
1:64c254c:         }
1:64c254c:     }
1:8bc3183: 
1:8bc3183:     /**
1:8bc3183:      * Revert the properties to their values prior to the setUp call.
1:8bc3183:      */
1:8bc3183:     protected void tearDown()
1:8bc3183:     throws java.lang.Exception
1:8bc3183:     {
1:8bc3183:         Connection conn = getConnection();
1:75e97c1:         try {
1:f5bfd98:             clearProperties(conn);
1:f05a2f8:         } catch (SQLException sqle) {
1:f5bfd98:             // To try to prevent the error situation of DERBY-5686, which
1:f5bfd98:             // cascades to many test failures, catch ERROR 25502, and if it occurs
1:f5bfd98:             // try to gather some information, close the connection,
1:f5bfd98:             // and retry the clearing of the properties on a new connection
1:f5bfd98:             if (sqle.getSQLState().equals("25502")) {
1:f5bfd98:                 // firstly, check on the state of the connection when we
1:f5bfd98:                 // get this error
1:75e97c1:                 System.out.println("Apparently this is a read-only connection in teardown()? Get some data:");
1:f5bfd98:                 System.out.println("conn.isClosed: " + conn.isClosed());
1:f5bfd98:                 System.out.println("conn.isReadOnly: " + conn.isReadOnly());
1:f5bfd98:                 System.out.println("conn.getHoldability: " + conn.getHoldability());
1:f5bfd98:                 System.out.println("conn.getTransactionIsolation: " + conn.getTransactionIsolation());
1:f5bfd98:                 System.out.println("conn.getAutoCommit: " + conn.getAutoCommit());
1:f5bfd98:                 // now try to close the connection, then try open a new one, 
1:f5bfd98:                 // and try to executeUpdate again.
1:15097dd:                 try {
1:15097dd:                     conn.close();
1:15097dd:                 } catch (SQLException isqle) {
1:15097dd:                     if (sqle.getSQLState()=="25001")
1:15097dd:                     {
1:15097dd:                         // the transaction is still active. let's commit what we have.
1:15097dd:                         conn.commit();
1:15097dd:                         conn.close();
1:15097dd:                     } else {
1:15097dd:                         System.out.println("close failed - see SQLState.");
1:15097dd:                         throw sqle;
1:15097dd:                     }
1:15097dd:                 }
1:f5bfd98:                 Connection conn2 = getConnection();
1:f5bfd98:                 // check if this second connection is read-only
1:f5bfd98:                 if (conn2.isReadOnly())
1:15097dd:                 {
1:f5bfd98:                     System.out.println("Sorry, conn2 is also read-only, won't retry");
1:f5bfd98:                     // give up
1:15097dd:                     throw sqle;
1:15097dd:                 }
1:f5bfd98:                 else
1:f5bfd98:                 {   
1:f5bfd98:                     // retry
1:f5bfd98:                     System.out.println("retrying clearing the Properties");
1:f5bfd98:                     clearProperties(conn2);
1:15097dd:                 }
1:f5bfd98:             }
1:f5bfd98:             else if(!sqle.getSQLState().equals(SQLStateConstants.PROPERTY_UNSUPPORTED_CHANGE))
1:f5bfd98:         		throw sqle;
1:f5bfd98:         }
1:8bc3183:     	// and then reset nay old values which will cause the commit.
1:8bc3183:     	setProperties(oldValues);
1:8bc3183:         super.tearDown();
1:8bc3183:         newValues = null;
1:8bc3183:         oldValues = null;
1:64c254c:         if (staticProperties) {
1:9528482:             TestConfiguration.getCurrent().shutdownDatabase();
1:64c254c:         }
1:64c254c:     }
1:15097dd:     
1:f5bfd98:     private void clearProperties(Connection conn) throws SQLException
1:f5bfd98:     {
1:f5bfd98:         conn.setAutoCommit(false);
1:f5bfd98:         CallableStatement setDBP =  conn.prepareCall(
1:f5bfd98:             "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, NULL)");
1:f5bfd98:         // Clear all the system properties set by the new set
1:f5bfd98:         // that will not be reset by the old set. Ignore any 
1:f5bfd98:         // invalid property values.
1:f5bfd98:         for (Enumeration e = newValues.propertyNames(); e.hasMoreElements();)
1:f5bfd98:         {
1:f5bfd98:             String key = (String) e.nextElement();
1:f5bfd98:             if (oldValues.getProperty(key) == null)
1:f5bfd98:             {
1:f5bfd98:                 setDBP.setString(1, key);
1:f5bfd98:                 setDBP.executeUpdate();
1:f5bfd98:             }
1:f5bfd98:         }
1:f5bfd98:     }
1:f5bfd98: 
1:8bc3183:     private void setProperties(Properties values) throws SQLException
1:8bc3183:     {
1:8bc3183:         Connection conn = getConnection();
1:15097dd:         try {
1:75e97c1:             attemptSetProperties(values, conn);
1:75e97c1:         } catch (SQLException sqle) {
1:75e97c1:             // To try to prevent the error situation of DERBY-5686, which
1:75e97c1:             // cascades to many test failures, catch ERROR 25502, and if it occurs
1:75e97c1:             // try to gather some information, close the connection,
1:75e97c1:             // and retry the clearing of the properties on a new connection
1:75e97c1:             if (sqle.getSQLState().equals("25502")) {
1:75e97c1:                 // firstly, check on the state of the connection when we
1:75e97c1:                 // get this error
1:75e97c1:                 System.out.println("Apparently this is a read-only connection? Get some data:");
1:75e97c1:                 System.out.println("conn.isClosed: " + conn.isClosed());
1:75e97c1:                 System.out.println("conn.isReadOnly: " + conn.isReadOnly());
1:75e97c1:                 System.out.println("conn.getHoldability: " + conn.getHoldability());
1:75e97c1:                 System.out.println("conn.getTransactionIsolation: " + conn.getTransactionIsolation());
1:75e97c1:                 System.out.println("conn.getAutoCommit: " + conn.getAutoCommit());
1:75e97c1:                 // now try to close the connection, then try open a new one, 
1:75e97c1:                 // and try to executeUpdate again.
1:64c254c:                 try {
1:15097dd:                     conn.close();
1:15097dd:                 } catch (SQLException isqle) {
1:15097dd:                     if (sqle.getSQLState()=="25001")
1:75e97c1:                     {
1:15097dd:                         // the transaction is still active. let's commit what we have.
1:15097dd:                         conn.commit();
1:15097dd:                         conn.close();
1:15097dd:                     } else {
1:15097dd:                         System.out.println("close failed - see SQLState.");
1:75e97c1:                         throw sqle;
1:75e97c1:                     }
1:f5bfd98:                 }
1:75e97c1:                 Connection conn2 = getConnection();
1:8bc3183: 
1:75e97c1:                 // check if this second connection is read-only
1:75e97c1:                 if (conn2.isReadOnly())
1:75e97c1:                 {
1:75e97c1:                     System.out.println("Sorry, conn2 is also read-only, won't retry");
1:75e97c1:                     // give up
1:f05a2f8:                     throw sqle;
1:8bc3183:                 }
1:75e97c1:                 else
1:8bc3183:                 {   
1:75e97c1:                     // retry
1:75e97c1:                     System.out.println("retrying to set the Properties");
1:75e97c1:                     attemptSetProperties(values, conn2);
1:75e97c1:                 }
1:75e97c1:             }
1:75e97c1:         }
1:75e97c1:     }
1:75e97c1:     
1:75e97c1:     private void attemptSetProperties(Properties values, Connection coonn) throws SQLException
1:75e97c1:     {
1:75e97c1:         Connection conn = getConnection();
2:8bc3183:         conn.setAutoCommit(false);
1:8bc3183:         
1:8bc3183:         PreparedStatement getDBP =  conn.prepareStatement(
1:8bc3183:             "VALUES SYSCS_UTIL.SYSCS_GET_DATABASE_PROPERTY(?)");
2:8bc3183:         CallableStatement setDBP =  conn.prepareCall(
1:8bc3183:             "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, ?)");
1:8bc3183:         
1:8bc3183:         
1:8bc3183:     	for (Enumeration e = values.propertyNames(); e.hasMoreElements();)
1:8bc3183:     	{
1:8bc3183:     		final String key = (String) e.nextElement();
1:8bc3183:     		final String value = values.getProperty(key);
1:8bc3183:             
1:8bc3183:             getDBP.setString(1, key);
1:8bc3183:             ResultSet rs = getDBP.executeQuery();
1:8bc3183:             rs.next();
1:8bc3183:             String old = rs.getString(1);
1:8bc3183:             rs.close();
1:8bc3183:                 		
1:8bc3183:     		boolean change;
1:8bc3183:     		if (old != null)
1:8bc3183:     		{
1:8bc3183:                 // set, might need to be changed.
1:8bc3183:                 change = !old.equals(value);
1:8bc3183:                 
1:8bc3183:                 // If we are not processing the oldValues
1:8bc3183:                 // then store in the oldValues. Reference equality is ok here.
1:8bc3183:     			if (change && (values != oldValues))
1:8bc3183:     			   oldValues.setProperty(key, old);
1:8bc3183:     		}
1:8bc3183:     		else {
1:8bc3183:     			// notset, needs to be set
1:8bc3183:     			change = true;
1:8bc3183:     		}
1:8bc3183:     		
1:8bc3183:     		if (change) {
2:8bc3183:                 setDBP.setString(1, key);
1:8bc3183:                 setDBP.setString(2, value);
2:8bc3183:                 setDBP.executeUpdate();
1:8bc3183:    		    }
1:8bc3183:     	}
1:8bc3183:         conn.commit();
1:8bc3183:         getDBP.close();
1:8bc3183:         setDBP.close();
1:75e97c1:         conn.close();
1:8bc3183:     }
1:8bc3183: }
============================================================================
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:15097dd
/////////////////////////////////////////////////////////////////////////
1:                 try {
1:                     conn.close();
1:                 } catch (SQLException isqle) {
1:                     if (sqle.getSQLState()=="25001")
1:                     {
1:                         // the transaction is still active. let's commit what we have.
1:                         conn.commit();
1:                         conn.close();
1:                     } else {
1:                         System.out.println("close failed - see SQLState.");
1:                         throw sqle;
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 try {
1:                     conn.close();
1:                 } catch (SQLException isqle) {
1:                     if (sqle.getSQLState()=="25001")
1:                     {
1:                         // the transaction is still active. let's commit what we have.
1:                         conn.commit();
1:                         conn.close();
1:                     } else {
1:                         System.out.println("close failed - see SQLState.");
1:                         throw sqle;
1:                     }
1:                 }
1: 
commit:75e97c1
/////////////////////////////////////////////////////////////////////////
1:                 System.out.println("Apparently this is a read-only connection in teardown()? Get some data:");
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             attemptSetProperties(values, conn);
1:         } catch (SQLException sqle) {
1:             // To try to prevent the error situation of DERBY-5686, which
1:             // cascades to many test failures, catch ERROR 25502, and if it occurs
1:             // try to gather some information, close the connection,
1:             // and retry the clearing of the properties on a new connection
1:             if (sqle.getSQLState().equals("25502")) {
1:                 // firstly, check on the state of the connection when we
1:                 // get this error
1:                 System.out.println("Apparently this is a read-only connection? Get some data:");
1:                 System.out.println("conn.isClosed: " + conn.isClosed());
1:                 System.out.println("conn.isReadOnly: " + conn.isReadOnly());
1:                 System.out.println("conn.getHoldability: " + conn.getHoldability());
1:                 System.out.println("conn.getTransactionIsolation: " + conn.getTransactionIsolation());
1:                 System.out.println("conn.getAutoCommit: " + conn.getAutoCommit());
1:                 // now try to close the connection, then try open a new one, 
1:                 // and try to executeUpdate again.
1:                 conn.close();
1:                 Connection conn2 = getConnection();
1:                 // check if this second connection is read-only
1:                 if (conn2.isReadOnly())
1:                 {
1:                     System.out.println("Sorry, conn2 is also read-only, won't retry");
1:                     // give up
1:                     throw sqle;
1:                 }
1:                 else
1:                 {   
1:                     // retry
1:                     System.out.println("retrying to set the Properties");
1:                     attemptSetProperties(values, conn2);
1:                 }
1:             }
1:         }
1:     }
1:     
1:     private void attemptSetProperties(Properties values, Connection coonn) throws SQLException
1:     {
1:         Connection conn = getConnection();
commit:f5bfd98
/////////////////////////////////////////////////////////////////////////
1:             clearProperties(conn);
1:             // To try to prevent the error situation of DERBY-5686, which
1:             // cascades to many test failures, catch ERROR 25502, and if it occurs
1:             // try to gather some information, close the connection,
1:             // and retry the clearing of the properties on a new connection
1:             if (sqle.getSQLState().equals("25502")) {
1:                 // firstly, check on the state of the connection when we
1:                 // get this error
0:                 System.out.println("Apparently this is a read-only connection? Get some data:");
1:                 System.out.println("conn.isClosed: " + conn.isClosed());
1:                 System.out.println("conn.isReadOnly: " + conn.isReadOnly());
1:                 System.out.println("conn.getHoldability: " + conn.getHoldability());
1:                 System.out.println("conn.getTransactionIsolation: " + conn.getTransactionIsolation());
1:                 System.out.println("conn.getAutoCommit: " + conn.getAutoCommit());
1:                 // now try to close the connection, then try open a new one, 
1:                 // and try to executeUpdate again.
0:                 conn.close();
1:                 Connection conn2 = getConnection();
1:                 // check if this second connection is read-only
1:                 if (conn2.isReadOnly())
1:                 {
1:                     System.out.println("Sorry, conn2 is also read-only, won't retry");
1:                     // give up
1:                     throw sqle;
1:                 }
1:                 else
1:                 {   
1:                     // retry
1:                     System.out.println("retrying clearing the Properties");
1:                     clearProperties(conn2);
1:                 }
1:             }
1:             else if(!sqle.getSQLState().equals(SQLStateConstants.PROPERTY_UNSUPPORTED_CHANGE))
/////////////////////////////////////////////////////////////////////////
1:     private void clearProperties(Connection conn) throws SQLException
1:     {
1:         conn.setAutoCommit(false);
1:         CallableStatement setDBP =  conn.prepareCall(
1:             "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, NULL)");
1:         // Clear all the system properties set by the new set
1:         // that will not be reset by the old set. Ignore any 
1:         // invalid property values.
1:         for (Enumeration e = newValues.propertyNames(); e.hasMoreElements();)
1:         {
1:             String key = (String) e.nextElement();
1:             if (oldValues.getProperty(key) == null)
1:             {
1:                 setDBP.setString(1, key);
1:                 setDBP.executeUpdate();
1:             }
1:         }
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:fcaa724
/////////////////////////////////////////////////////////////////////////
1:     static DatabasePropertyTestSetup getNoTeardownInstance(
1:                     // We don't want to reset the properties, but we should
1:                     // still clear the reference to the default connection to
1:                     // allow it to be garbage collected.
1:                     clearConnection();
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:8badf99
/////////////////////////////////////////////////////////////////////////
1:  * Derby - Class org.apache.derbyTesting.junit.DatabasePropertyTestSetup
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4ee3a23
/////////////////////////////////////////////////////////////////////////
1:      * The password for each user is set to the user's name as set
1:      * in the users array with the value of passwordToken appended.
1:      * <BR>
1:      * The user names in the users array are treated as SQL identifiers
1:      * since that is the defined behaviour for derby.user.username.
1:      * This means that the quoted identifiers can be passed, examples
1:      * are (users[i] is shown as the contents of the Java string) with
1:      * a password suffix of T63:
1:      * <UL>
1:      * <LI>users[i]=fred - normal user name FRED, password fredT63
1:      * <LI>users[i]=FRED - normal user name FRED, passeword FREDT63
1:      * <LI>users[i]="FRED" - normal user name FRED, passeword "FREDT63"
1:      * <LI>users[i]="fred" - normal user name fred, passeword "fredT63"
1:      * </UL>
1:      * Thus with a quoted identifier the password will include the quotes.
1:      * Note bug DERBY-3150 exists which means that the normalized user name
1:      * to password mapping does not exist, thus a connection request must be
1:      * made with the values passed in the users array, not any other form of the
1:      * name.
commit:a43ee19
/////////////////////////////////////////////////////////////////////////
1:         return singleProperty(test, property, value, false);
1:     }
1:     /**
1:      * Decorate a test so that it sets a single database property
1:      * at setUp and resets it at tearDown. Shorthand for
1:      * using DatabasePropertyTestSetup when only a single property is needed.
1:      * Optinally reboots the database.
1:      */
1:     public static Test singleProperty(Test test, String property, String value,
1:             boolean reboot)
1:     {
1:         return new DatabasePropertyTestSetup(test, properties, reboot);
commit:6da924f
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Decorate a test so that it sets a single database property
1:      * at setUp and resets it at tearDown. Shorthand for
1:      * using DatabasePropertyTestSetup when only a single property is needed.
1:      * Does not perform a reboot of the database.
1:      */
1:     public static Test singleProperty(Test test, String property, String value)
1:     {
1:         final Properties properties = new Properties();
1:         properties.setProperty(property, value);
1: 
0:         return new DatabasePropertyTestSetup(test, properties, false);
1:     }    
commit:2346370
/////////////////////////////////////////////////////////////////////////
1:      * <BR>
1:      * The decorated test can use BaseJDBCTestCase.openUserConnection(String user)
1:      * method to simplify using authentication.
1:      * Current user is set to the first user in the list users[0].
1:      * <P>
/////////////////////////////////////////////////////////////////////////
1:             userProps.setProperty("derby.user." + user,
1:                     TestConfiguration.getPassword(user, passwordToken));
/////////////////////////////////////////////////////////////////////////
1:         test = new ChangeUserSetup(test, users[0],
1:                 TestConfiguration.getPassword(users[0], passwordToken),
1:                 passwordToken);
commit:9528482
/////////////////////////////////////////////////////////////////////////
1:             TestConfiguration.getCurrent().shutdownDatabase();
/////////////////////////////////////////////////////////////////////////
1:             TestConfiguration.getCurrent().shutdownDatabase();
commit:64c254c
/////////////////////////////////////////////////////////////////////////
1:     private final boolean staticProperties;
/////////////////////////////////////////////////////////////////////////
1:         return new DatabasePropertyTestSetup(test, properties, true);
1:     }
1:     
1:     /**
1:      * Decorate a test so that the database has authentication enabled
1:      * using the BUILTIN provider and the set of users passed in.
1:      * The password for each user is set to the user's name with 
1:      * the value of passwordToken appended.
1:      * <P>
1:      * Assumption is that no authentication was enabled upon entry.
1:      * <P>
1:      * The authentication is removed by the decorator's tearDown method.
1:      * @param test Test to be decorated.
1:      * @param users Set of users for authentication.
1:      * @return Decorated test.
1:      */
1:     public static Test builtinAuthentication(Test test, String[] users,
1:             String passwordToken)
1:     {
1:         final Properties userProps = new Properties();
1:         final Properties authProps = new Properties();
1:         
1:         authProps.setProperty("derby.connection.requireAuthentication", "true");
1:         authProps.setProperty("derby.authentication.provider", "BUILTIN");
1:         
1:         for (int i = 0; i < users.length; i++)
1:         {
1:             String user = users[i];
0:             userProps.setProperty("derby.user." + user, user.concat(passwordToken));
1:         }
1:         
1:         // Need to setup the decorators carefully.
1:         // Need execution in this order:
1:         // 1) add user definitions (no authentication enabled)
1:         // 2) switch to a valid user
1:         // 3) enable authentication with database reboot
1:         // 4) disable authentication with database reboot
1:         // 5) switch back to previous user
1:         // 6) remove user defintions.
1:         //
1:         // Combining steps 1,3 does not work as no shutdown request
1:         // is possible for step 4 as no valid users would be defined!
1:         //
1:         // Note the decorators are executed in order from
1:         // outer (added last) to inner.
1:         
1:         test = new DatabasePropertyTestSetup(test, authProps, true);
0:         test = new ChangeUserSetup(test, users[0], users[0].concat(passwordToken));
1:         test = new DatabasePropertyTestSetup(test, userProps, false);
1:         
1:         return test;
/////////////////////////////////////////////////////////////////////////
1:         this(test, newValues, false);
1:     }
1:     
1:     /**
1:      * Create a test decorator that sets and restores the passed
1:      * in properties. Assumption is that the contents of
1:      * properties and values will not change during execution.
1:      * @param test test to be decorated
1:      * @param newValues properties to be set
1:      * @param staticProperties True if database needs to be shutdown after
1:      * setting properties in setUp() and tearDown method().
1:      */
1:     public DatabasePropertyTestSetup(Test test,
1:             Properties newValues, boolean staticProperties)
1:     {
1:         this.staticProperties = staticProperties;
/////////////////////////////////////////////////////////////////////////
1:         if (staticProperties) {
1:             try {
0:                 TestConfiguration.getCurrent().getDefaultConnection(
0:                         "shutdown=true");
0:                 fail("Database failed to shut down");
0:             } catch (SQLException e) {
0:                  BaseJDBCTestCase.assertSQLState("Database shutdown", "08006", e);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if (staticProperties) {
0:             try {
0:                 TestConfiguration.getCurrent().getDefaultConnection(
0:                         "shutdown=true");
0:                 fail("Database failed to shut down");
0:             } catch (SQLException e) {
0:                 BaseJDBCTestCase.assertSQLState("Database shutdown", "08006", e);
1:             }
1:         }
commit:be115c4
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Decorator to change the lock time outs.
1:      * If either time is less than zero then that property is
1:      * not modified by this decorator.
1:      * The change is implemented by an instanceof DatabasePropertyTestSetup
1:      * and thus is reset by the tearDown method.
1:      * 
1:      * @param test Test to decorate
1:      * @param deadlockTime Time in seconds for derby.locks.deadlockTimeout.
1:      * @param waitTime Time in seconds for derby.locks.waitTimeout
0:      * @return
1:      */
1:     public static Test setLockTimeouts(Test test, int deadlockTime, int waitTime)
1:     {
1:         final Properties properties = new Properties();
1:         if (deadlockTime >= 0)
1:         {
1:             properties.setProperty("derby.locks.deadlockTimeout",
1:                 Integer.toString(deadlockTime));
1:         }
1:         if (waitTime >= 0) {
1:             properties.setProperty("derby.locks.waitTimeout",
1:                 Integer.toString(waitTime));
1:         }
1:         
1:         // No change, no point to the decorator.
1:         if (properties.isEmpty())
1:             return test;
1: 
0:         return new DatabasePropertyTestSetup(test, properties);
1:     }
commit:8bc3183
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
0:  * Derby - Class org.apache.derbyTesting.functionTests.util.DatabasePropertyTestSetup
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.junit;
1: 
1: import java.sql.CallableStatement;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.util.Enumeration;
1: import java.util.Properties;
1: 
1: import junit.framework.Test;
1: 
1: /**
1:  * Test decorator to set a set of database properties on setUp
1:  * and restore them to the previous values on tearDown.
1:  *
1:  */
1: public class DatabasePropertyTestSetup extends BaseJDBCTestSetup {
1: 	
1: 	private Properties newValues;
1: 	private Properties oldValues;
1: 	
1: 	/**
1: 	 * Create a test decorator that sets and restores the passed
1: 	 * in properties. Assumption is that the contents of
1: 	 * properties and values will not change during execution.
1: 	 * @param test test to be decorated
1: 	 * @param newValues properties to be set
1: 	 */
1: 	public DatabasePropertyTestSetup(Test test,
1: 			Properties newValues)
1: 	{
1: 		super(test);
1: 		this.newValues = newValues;
1: 		this.oldValues = new Properties();
1: 	}
1: 
1: 	/**
1: 	 * For each property store the current value and
1: 	 * replace it with the new value, unless there is no change.
1: 	 */
1:     protected void setUp()
1:     throws java.lang.Exception
1:     {
1:     	setProperties(newValues);
1:     }
1: 
1:     /**
1:      * Revert the properties to their values prior to the setUp call.
1:      */
1:     protected void tearDown()
1:     throws java.lang.Exception
1:     {
1:         Connection conn = getConnection();
1:         conn.setAutoCommit(false);
1:         CallableStatement setDBP =  conn.prepareCall(
0:             "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, NULL)");
0:     	// Clear all the system properties set by the new set
0:     	// that will not be reset by the old set.
0:        	for (Enumeration e = newValues.propertyNames(); e.hasMoreElements();)
1:        	{
0:        		String key = (String) e.nextElement();
0:        		if (oldValues.getProperty(key) == null)
1:             {
1:                  setDBP.setString(1, key);
1:                  setDBP.executeUpdate();
1:              }
1:         }
1:     	// and then reset nay old values which will cause the commit.
1:     	setProperties(oldValues);
1:         super.tearDown();
1:         newValues = null;
1:         oldValues = null;
1:     }
1:     
1:     private void setProperties(Properties values) throws SQLException
1:     {
1:         Connection conn = getConnection();
1:         conn.setAutoCommit(false);
1:         
1:         PreparedStatement getDBP =  conn.prepareStatement(
1:             "VALUES SYSCS_UTIL.SYSCS_GET_DATABASE_PROPERTY(?)");
1:         CallableStatement setDBP =  conn.prepareCall(
1:             "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, ?)");
1:         
1:         
1:     	for (Enumeration e = values.propertyNames(); e.hasMoreElements();)
1:     	{
1:     		final String key = (String) e.nextElement();
1:     		final String value = values.getProperty(key);
1:             
1:             getDBP.setString(1, key);
1:             ResultSet rs = getDBP.executeQuery();
1:             rs.next();
1:             String old = rs.getString(1);
1:             rs.close();
1:                 		
1:     		boolean change;
1:     		if (old != null)
1:     		{
1:                 // set, might need to be changed.
1:                 change = !old.equals(value);
1:                 
1:                 // If we are not processing the oldValues
1:                 // then store in the oldValues. Reference equality is ok here.
1:     			if (change && (values != oldValues))
1:     			   oldValues.setProperty(key, old);
1:     		}
1:     		else {
1:     			// notset, needs to be set
1:     			change = true;
1:     		}
1:     		
1:     		if (change) {
1:                 setDBP.setString(1, key);
1:                 setDBP.setString(2, value);
1:                 setDBP.executeUpdate();
1:    		    }
1:     	}
1:         conn.commit();
1:         getDBP.close();
1:         setDBP.close();
0:         conn.close();
1:     }
1: }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:af7f5e2
/////////////////////////////////////////////////////////////////////////
1:      * Decorate a test so that the database has authentication enabled
1:      * using the BUILTIN provider and the set of users passed in.
0:      * The password for each user is set to the user's name with
0:      * the value of passwordToken appended.
1:      * <BR>
1:      * The decorated test can use BaseJDBCTestCase.openUserConnection(String user)
1:      * method to simplify using authentication.
1:      * <P>
1:      * Assumption is that no authentication was enabled upon entry.
1:      * <P>
1:      * Current user is set to the first user in the list users[0].
1:      * <P>
1:      * In contrast to plain builtinAuthentication, here the
1:      * authentication nor users are *NOT* removed by the decorator's
1:      * tearDown method.
1:      * @param test Test to be decorated.
1:      * @param users Set of users for authentication.
1:      * @return Decorated test.
1:      */
1:     public static Test builtinAuthenticationNoTeardown(Test test, String[] users,
1:             String passwordToken)
1:     {
1:         final Properties userProps = new Properties();
1:         final Properties authProps = new Properties();
1: 
1:         authProps.setProperty("derby.connection.requireAuthentication", "true");
1:         authProps.setProperty("derby.authentication.provider", "BUILTIN");
1: 
1:         for (int i = 0; i < users.length; i++)
1:         {
1:             String user = users[i];
1:             userProps.setProperty("derby.user." + user,
1:                     TestConfiguration.getPassword(user, passwordToken));
1:         }
1: 
1:         test = getNoTeardownInstance(test, authProps, true);
1:         test = new ChangeUserSetup(test, users[0],
1:                 TestConfiguration.getPassword(users[0], passwordToken),
1:                 passwordToken);
1:         test = getNoTeardownInstance(test, userProps, false);
1:         return test;
1:     }
1: 
0:     private static DatabasePropertyTestSetup getNoTeardownInstance(
1:         Test test, Properties p, boolean staticp)
1:     {
1:         return new DatabasePropertyTestSetup(test, p, staticp) {
1:                 protected void tearDown()
1:                         throws java.lang.Exception {
1:                 }
1:             };
1:     }
1: 
1:     /**
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:f05a2f8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
1: 
/////////////////////////////////////////////////////////////////////////
0:     	// that will not be reset by the old set. Ignore any 
0:         // invalid property values.
0:         try {
0:         	for (Enumeration e = newValues.propertyNames(); e.hasMoreElements();)
0:         	{
0:         		String key = (String) e.nextElement();
0:         		if (oldValues.getProperty(key) == null)
0:         		{
0:         			setDBP.setString(1, key);
0:         			setDBP.executeUpdate();
0:         		}
0:         	}
1:         } catch (SQLException sqle) {
0:         	if(!sqle.getSQLState().equals(SQLStateConstants.PROPERTY_UNSUPPORTED_CHANGE))
1:         		throw sqle;
============================================================================