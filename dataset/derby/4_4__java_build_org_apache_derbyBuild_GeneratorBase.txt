1:d76e238: /*  Derby - Class org.apache.derbyBuild.GeneratorBase
4:d76e238: 
1:d76e238: Licensed to the Apache Software Foundation (ASF) under one or more
1:d76e238: contributor license agreements.  See the NOTICE file distributed with
1:d76e238: this work for additional information regarding copyright ownership.
1:d76e238: The ASF licenses this file to You under the Apache License, Version 2.0
1:d76e238: (the "License"); you may not use this file except in compliance with
1:d76e238: the License.  You may obtain a copy of the License at
1:d76e238: 
1:d76e238: http://www.apache.org/licenses/LICENSE-2.0
1:d76e238: 
1:d76e238: Unless required by applicable law or agreed to in writing, software
1:d76e238: distributed under the License is distributed on an "AS IS" BASIS,
1:d76e238: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d76e238: See the License for the specific language governing permissions and
1:d76e238: limitations under the License.
1:d76e238: 
1:d76e238:  */
1:d76e238: package org.apache.derbyBuild;
1:d76e238: 
1:d76e238: import java.io.*;
1:d76e238: import java.util.*;
1:d76e238: import javax.xml.parsers.*;
1:d76e238: import javax.xml.transform.*;
1:d76e238: import javax.xml.transform.dom.*;
1:d76e238: import javax.xml.transform.stream.*;
1:d76e238: import org.w3c.dom.*;
1:d76e238: 
1:d76e238: import org.apache.tools.ant.BuildException;
1:d76e238: import org.apache.tools.ant.Project;
1:d76e238: import org.apache.tools.ant.Task;
1:d76e238: 
1:d76e238: /**
1:d76e238:  *
1:d76e238:  */
1:d76e238: public class GeneratorBase extends Task {
1:d76e238:     /////////////////////////////////////////////////////////////////////////
1:d76e238:     //
1:d76e238:     //  CONSTANTS
1:d76e238:     //
1:d76e238:     /////////////////////////////////////////////////////////////////////////
1:d76e238: 
1:d76e238:     // header levels
1:d76e238:     protected static final int BANNER_LEVEL = 1;
1:d76e238:     protected static final int MAIN_SECTION_LEVEL = BANNER_LEVEL + 1;
1:d76e238:     protected static final int ISSUE_DETAIL_LEVEL = MAIN_SECTION_LEVEL + 1;
1:d76e238:     // headlines
1:d76e238:     protected static final String DESCRIPTION_HEADLINE = "Description";
1:d76e238:     protected static final String ISSUE_ID_HEADLINE = "Issue Id";
1:d76e238: 
1:d76e238:     // formatting tags
1:d76e238:     private static final String ANCHOR = "a";
1:d76e238:     protected static final String BODY = "body";
1:d76e238:     private static final String BOLD = "b";
1:d76e238:     private static final String BORDER = "border";
1:d76e238:     private static final String COLUMN = "td";
1:086e817:     private static final String COLUMN_HEADER = "th";
1:d76e238:     private static final String HORIZONTAL_LINE = "hr";
1:d76e238:     protected static final String HTML = "html";
1:4a57be6:     private static final String DIVISION = "div";
1:d76e238:     private static final String LIST = "ul";
1:d76e238:     private static final String LIST_ELEMENT = "li";
1:d76e238:     private static final String NAME = "name";
1:d76e238:     protected static final String PARAGRAPH = "p";
1:d76e238:     private static final String ROW = "tr";
1:80e6765:     protected static final String SPAN = "span";
1:d76e238:     private static final String TABLE = "table";
1:d76e238: 
1:d76e238:     // tags in summary xml
1:d76e238:     private static final String SUM_PREVIOUS_RELEASE_ID = "previousReleaseID";
1:d76e238:     private static final String SUM_RELEASE_ID = "releaseID";
1:d76e238:     private static final String SUM_EXCLUDE_RELEASE_ID = "excludeReleaseID";
1:d76e238: 
1:d76e238:     // other html control
1:d76e238:     protected static final int DEFAULT_TABLE_BORDER_WIDTH = 2;
1:d76e238: 
1:d76e238:     protected DocumentBuilder docBldr =
1:d76e238:             DocumentBuilderFactory.newInstance().newDocumentBuilder();
1:d76e238:     /////////////////////////////////////////////////////////////////////////
1:d76e238:     //
1:d76e238:     //  STATE
1:d76e238:     //
1:d76e238:     /////////////////////////////////////////////////////////////////////////
1:d76e238:     // set on the command line or by ant
1:d76e238:     // Summary file
1:d76e238:     protected String summaryFileName;
1:d76e238:     protected Document summaryDoc;
1:d76e238:     protected ElementFacade summary;
1:d76e238:     // Bug list file
1:d76e238:     protected String bugListFileName;
1:e1aa9c0:     protected List bugList;
1:d76e238: 
1:d76e238:     // Output file
1:d76e238:     private String outputFileName;
1:d76e238:     protected Document outputDoc = docBldr.newDocument();
1:d76e238:     protected File outputFile;
1:d76e238: 
1:d76e238:     // computed at run time
1:adad5b1:     protected String releaseID;
1:d76e238:     protected String previousReleaseID;
1:38b9499:     protected List<String> excludeReleaseIDList;
1:d76e238:     protected final String branch;
1:38b9499:     protected ArrayList<String> errors = new ArrayList<String>();
1:d76e238: 
1:d76e238:     // misc
1:d76e238:     protected boolean _invokedByAnt = true;
1:d76e238: 
1:d76e238:     /**
1:adad5b1:      * Establishes state, including branch number.
1:d76e238:      * @throws java.lang.Exception
1:d76e238:      */
1:d76e238:     public GeneratorBase() throws Exception {
1:d76e238:         Properties r = new Properties();
1:d76e238:         r.load(new FileInputStream("../ant/properties/release.properties"));
1:d76e238:         int maint = Integer.parseInt(r.getProperty("maint"));
1:d76e238:         branch = r.getProperty("eversion");
1:d76e238:     }
1:d76e238: 
1:d76e238:     /////////////////////////////////////////////////////////////////////////
1:d76e238:     //
1:d76e238:     //  ANT Task BEHAVIOR
1:d76e238:     //
1:d76e238:     /////////////////////////////////////////////////////////////////////////
1:d76e238:     /**
1:d76e238:      * Ant accessor to set the name of the summary file prepared by the
1:d76e238:      * Release Manager
1:d76e238:      * @param summaryFileName name of xml file to use for the summary
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public void setSummaryFileName(String summaryFileName) throws Exception {
1:d76e238:         this.summaryFileName = summaryFileName;
1:d76e238:         summaryDoc = docBldr.parse(new File(summaryFileName));
1:d76e238:         summary = new ElementFacade(summaryDoc);
1:d76e238:         previousReleaseID = summary.getTextByTagName(SUM_PREVIOUS_RELEASE_ID);
1:d76e238: 
1:d76e238:         excludeReleaseIDList =
1:d76e238:                 summary.getTextListByTagName(SUM_EXCLUDE_RELEASE_ID);
1:b25a23f:         System.out.println("Summary file (input): " + summaryFileName);
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Ant mutator to set the name of the JIRA-generated list of bugs
1:d76e238:      * addressed by this release
1:d76e238:      * @param bugListFileName name of an xml file from a Jira filter/query
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public void setBugListFileName(String bugListFileName) throws Exception {
1:d76e238:         this.bugListFileName = bugListFileName;
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Ant mutator to set the name of the generated output file
1:d76e238:      * @param outputFileName name of file to use as pamphlet (output)
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public void setOutputFileName(String outputFileName) throws Exception {
1:d76e238:         this.outputFileName = outputFileName;
1:d76e238:         outputFile = new File(outputFileName);
1:d76e238:     }
1:d76e238: 
1:adad5b1:     /**
1:adad5b1:      * Ant mutator to set the id of the release
1:adad5b1:      */
1:adad5b1:     public void setReleaseId(String releaseID) throws Exception {
1:adad5b1:         this.releaseID = releaseID;
1:adad5b1:     }
1:adad5b1: 
1:d76e238:     /////////////////////////////////////////////////////////////////////////
1:d76e238:     //
1:d76e238:     //  MINIONS
1:d76e238:     //
1:d76e238:     /////////////////////////////////////////////////////////////////////////
1:d76e238:     /**
1:d76e238:      * Note that this release is a delta from the previous one.
1:d76e238:      * @param parent
1:d76e238:      * @throws java.lang.Exception
1:d76e238:      */
1:d76e238:     protected void buildDelta(Element parent)
1:d76e238:             throws Exception {
1:d76e238:         String deltaStatement =
1:1b5d924:                 "These notes describe the difference between Apache Derby release " +
1:d76e238:                 releaseID + " and the preceding release " +
1:d76e238:                 previousReleaseID + ".";
1:d76e238: 
1:d76e238:         addParagraph(parent, deltaStatement);
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Replace the known parameters with their corresponding text values.
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     protected void replaceVariables()
1:d76e238:             throws Exception {
1:d76e238:         replaceTag(outputDoc, SUM_RELEASE_ID, releaseID);
1:d76e238:         replaceTag(outputDoc, SUM_PREVIOUS_RELEASE_ID, previousReleaseID);
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Print the generated output document to the output file.
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     protected void printOutput() throws Exception {
1:d76e238:         Source source = new DOMSource(outputDoc);
1:d76e238: 
1:d76e238:         Result result = new StreamResult(outputFile);
1:d76e238:         Transformer transformer =
1:d76e238:                 TransformerFactory.newInstance().newTransformer();
1:d76e238: 
1:d76e238:         transformer.transform(source, result);
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Print accumulated errors.
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     protected void printErrors() throws Exception {
1:d76e238:         if (errors.isEmpty()) {
1:d76e238:             return;
1:d76e238:         }
1:d76e238: 
1:d76e238:         println("The following other errors occurred:");
1:d76e238: 
1:d76e238:         for (Iterator i = errors.iterator(); i.hasNext();) {
1:d76e238:             println("\n" + i.next());
1:d76e238:         }
1:d76e238:     }
1:d76e238: 
1:d76e238: 
1:d76e238:     ////////////////////////////////////////////////////////
1:d76e238:     //
1:d76e238:     // HTML MINIONS
1:d76e238:     //
1:d76e238:     ////////////////////////////////////////////////////////
1:d76e238:     /**
1:d76e238:      * Create a section at the end of a parent element and link to it from a
1:d76e238:      * table of contents.
1:d76e238:      * @param parent in document tree
1:d76e238:      * @param sectionLevel in document
1:d76e238:      * @param toc table of content element
1:d76e238:      * @param sectionName for section being created
1:d76e238:      * @param tocEntry key into table of content
1:d76e238:      * @return resulting Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element createSection(Element parent, int sectionLevel,
1:d76e238:             Element toc, String sectionName, String tocEntry)
1:d76e238:             throws Exception {
1:d76e238:         Document doc = parent.getOwnerDocument();
1:d76e238:         Text textNode = doc.createTextNode(tocEntry);
1:d76e238: 
1:d76e238:         return createSection(parent, sectionLevel, toc, sectionName, textNode);
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Create a section at the end of a parent element and link to it from a
1:d76e238:      * table of contents.
1:d76e238:      * @param parent in document tree
1:d76e238:      * @param sectionLevel in document
1:d76e238:      * @param toc table of content element
1:d76e238:      * @param sectionName for section being created
1:d76e238:      * @param visibleText text to show
1:d76e238:      * @return resulting Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element createSection(Element parent, int sectionLevel,
1:d76e238:             Element toc, String sectionName, Node visibleText)
1:d76e238:             throws Exception {
1:d76e238:         Document doc = parent.getOwnerDocument();
1:d76e238:         Element link = createLocalLink(doc, sectionName, visibleText);
1:d76e238: 
1:d76e238:         addListItem(toc, link);
1:d76e238: 
1:d76e238:         return createHeader(parent, sectionLevel, sectionName);
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Create a header at the end of the parent node. Return the block created
1:d76e238:      * to hold the text following this header.
1:d76e238:      * @param parent
1:d76e238:      * @param headerLevel
1:d76e238:      * @param text
1:d76e238:      * @return created header Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element createHeader(Element parent, int headerLevel,
1:d76e238:             String text) throws Exception {
1:d76e238:         Document doc = parent.getOwnerDocument();
1:d76e238:         Text textNode = doc.createTextNode(text);
1:d76e238:         Element header = doc.createElement(makeHeaderTag(headerLevel));
1:d76e238:         Element anchor = doc.createElement(ANCHOR);
1:4a57be6:         Element block = doc.createElement(DIVISION);
1:d76e238: 
1:d76e238:         parent.appendChild(header);
1:d76e238:         anchor.setAttribute(NAME, text);
1:d76e238:         header.appendChild(anchor);
1:d76e238:         header.appendChild(textNode);
1:d76e238:         parent.appendChild(block);
1:d76e238: 
1:d76e238:         return block;
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:086e817:      * Wraps the text content of the given node inside a div tag.
1:086e817:      *
1:086e817:      * @param node node currently containing the text
1:086e817:      * @return The new div-element which has been appended to {@code node}.
1:086e817:      * @throws DOMException 
1:086e817:      */
1:086e817:     private static Element wrapTextContentInDiv(Element node)
1:086e817:             throws DOMException {
1:086e817:         Document doc = node.getOwnerDocument();
1:086e817:         Element div = doc.createElement(DIVISION);
1:086e817:         div.setTextContent(node.getTextContent());
1:086e817:         node.setTextContent("");
1:086e817:         node.appendChild(div);
1:086e817:         return div;
1:086e817:     }
1:086e817: 
1:086e817:     /**
1:086e817:      * Sets/overwrites the specified attribute.
1:086e817:      *
1:086e817:      * @param node target node
1:086e817:      * @param name attribute name
1:086e817:      * @param value attribute value
1:086e817:      * @throws DOMException 
1:086e817:      */
1:086e817:     private static void setAttribute(Element node, String name, String value)
1:086e817:             throws DOMException {
1:086e817:         Node attr = node.getOwnerDocument().createAttribute(name);
1:086e817:         attr.setNodeValue(value);
1:086e817: 
1:086e817:         node.getAttributes().setNamedItem(attr);
1:086e817:     }
1:086e817:     
1:086e817:     /**
1:d76e238:      * Create an html text element.
1:d76e238:      * @param doc
1:d76e238:      * @param tag
1:d76e238:      * @param text
1:d76e238:      * @return created text Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element createTextElement(Document doc, String tag,
1:d76e238:             String text) throws Exception {
1:d76e238:         Element retval = doc.createElement(tag);
1:d76e238:         Text textNode = doc.createTextNode(text);
1:d76e238: 
1:d76e238:         retval.appendChild(textNode);
1:d76e238: 
1:d76e238:         return retval;
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Create a standard link to a local label.
1:d76e238:      * @param doc
1:d76e238:      * @param anchor
1:d76e238:      * @param text
1:d76e238:      * @return created link Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element createLocalLink(Document doc, String anchor,
1:d76e238:             String text) throws Exception {
1:d76e238:         Text textNode = doc.createTextNode(text);
1:d76e238: 
1:d76e238:         return createLocalLink(doc, anchor, textNode);
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Create a standard link to a local label.
1:d76e238:      * @param doc
1:d76e238:      * @param anchor
1:d76e238:      * @param visibleText
1:d76e238:      * @return created link Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element createLocalLink(Document doc, String anchor,
1:d76e238:             Node visibleText) throws Exception {
1:d76e238:         return createLink(doc, "#" + anchor, visibleText);
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Create a hotlink.
1:d76e238:      * @param doc
1:d76e238:      * @param label
1:d76e238:      * @param text
1:d76e238:      * @return created link Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element createLink(Document doc, String label, String text)
1:d76e238:             throws Exception {
1:d76e238:         Text textNode = doc.createTextNode(text);
1:d76e238: 
1:d76e238:         return createLink(doc, label, textNode);
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Create a hotlink.
1:d76e238:      * @param doc
1:d76e238:      * @param label
1:d76e238:      * @param visibleText
1:d76e238:      * @return created anchor Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element createLink(Document doc, String label,
1:d76e238:             Node visibleText) throws Exception {
1:d76e238:         Element hotlink = doc.createElement(ANCHOR);
1:d76e238: 
1:d76e238:         hotlink.setAttribute("href", label);
1:d76e238:         hotlink.appendChild(visibleText);
1:d76e238: 
1:d76e238:         return hotlink;
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Insert a list at the end of the parent element.
1:d76e238:      * @param parent
1:d76e238:      * @return created list Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element createList(Element parent)
1:d76e238:             throws Exception {
1:d76e238:         Document doc = parent.getOwnerDocument();
1:d76e238:         Element list = doc.createElement(LIST);
1:d76e238: 
1:d76e238:         parent.appendChild(list);
1:d76e238: 
1:d76e238:         return list;
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Add an item with a bold name to the end of a list.
1:d76e238:      * @param list
1:d76e238:      * @param headline
1:d76e238:      * @param text
1:d76e238:      * @return created headline Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element addHeadlinedItem(Element list, String headline,
1:d76e238:             String text) throws Exception {
1:d76e238:         Document doc = list.getOwnerDocument();
1:d76e238:         Element itemElement = doc.createElement(LIST_ELEMENT);
1:d76e238:         Element boldText = boldText(doc, headline);
1:d76e238:         Text textNode = doc.createTextNode(" - " + text);
1:d76e238: 
1:d76e238:         list.appendChild(itemElement);
1:d76e238:         itemElement.appendChild(boldText);
1:d76e238:         itemElement.appendChild(textNode);
1:d76e238: 
1:d76e238:         return itemElement;
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Make some bold text.
1:d76e238:      * @param doc
1:d76e238:      * @param text
1:d76e238:      * @return created bold Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element boldText(Document doc, String text)
1:d76e238:             throws Exception {
1:d76e238:         Element bold = createTextElement(doc, BOLD, text);
1:d76e238: 
1:d76e238:         return bold;
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Add an item to the end of a list.
1:d76e238:      * @param list
1:d76e238:      * @param item
1:d76e238:      * @return created item Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element addListItem(Element list, Node item)
1:d76e238:             throws Exception {
1:d76e238:         Document doc = list.getOwnerDocument();
1:d76e238:         Element itemElement = doc.createElement(LIST_ELEMENT);
1:d76e238: 
1:d76e238:         list.appendChild(itemElement);
1:d76e238:         itemElement.appendChild(item);
1:d76e238: 
1:d76e238:         return itemElement;
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Retrieve the indented block inside a section
1:d76e238:      * @param doc
1:d76e238:      * @param sectionLevel
1:d76e238:      * @param sectionName
1:d76e238:      * @return indented block Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element getSection(Document doc, int sectionLevel,
1:d76e238:             String sectionName) throws Exception {
1:d76e238:         String headerTag = makeHeaderTag(sectionLevel);
1:d76e238:         Element root = doc.getDocumentElement();
1:d76e238:         NodeList sectionList = root.getElementsByTagName(headerTag);
1:d76e238:         int count = sectionList.getLength();
1:d76e238: 
2:d76e238:         for (int i = 0; i < count; i++) {
1:d76e238:             Element section = (Element) sectionList.item(i);
1:d76e238:             Element sectionAnchor = getFirstChild(section, ANCHOR);
1:d76e238: 
1:d76e238:             if (sectionName.equals(sectionAnchor.getAttribute(NAME))) {
1:d76e238:                 // the next item after the section header, is the indented block
1:d76e238: 
1:d76e238:                 return (Element) section.getNextSibling();
1:d76e238:             }
1:d76e238:         }
1:d76e238: 
1:d76e238:         return null;
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Make the tag for a header, given its level
1:d76e238:      * @param headerLevel
1:d76e238:      * @return header tag at specified level
1:d76e238:      */
1:d76e238:     public static String makeHeaderTag(int headerLevel) {
1:d76e238:         return "h" + Integer.toString(headerLevel);
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Add a paragraph to the end of a parent element.
1:d76e238:      * @param parent
1:d76e238:      * @param text
1:d76e238:      * @return created paragraph Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element addParagraph(Element parent, String text)
1:d76e238:             throws Exception {
1:d76e238:         Document doc = parent.getOwnerDocument();
1:d76e238:         Text textNode = doc.createTextNode(text);
1:d76e238:         Element paragraph = doc.createElement(PARAGRAPH);
1:d76e238: 
1:d76e238:         parent.appendChild(paragraph);
1:d76e238:         paragraph.appendChild(textNode);
1:d76e238: 
1:d76e238:         return paragraph;
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Insert a table at the end of the parent element.
1:d76e238:      * @param parent
1:d76e238:      * @param borderWidth
1:d76e238:      * @param columnHeadings
1:d76e238:      * @return created table Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element createTable(Element parent, int borderWidth,
1:d76e238:             String[] columnHeadings) throws Exception {
1:d76e238:         Document doc = parent.getOwnerDocument();
1:d76e238:         Element table = doc.createElement(TABLE);
1:d76e238:         Element headingRow = insertRow(table);
1:d76e238: 
1:d76e238:         parent.appendChild(table);
1:d76e238:         table.setAttribute(BORDER, Integer.toString(borderWidth));
1:d76e238: 
1:086e817:         for (String headerText : columnHeadings) {
1:086e817:             Element headingColumn = insertColumnHeader(headingRow);
1:086e817:             headingColumn.setTextContent(headerText);
1:d76e238:         }
1:d76e238: 
1:d76e238:         return table;
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:086e817:      * Sets the width of the first column in the given table.
1:086e817:      *
1:086e817:      * @param table target table
1:086e817:      * @throws DOMException
1:086e817:      */
1:086e817:     protected void fixWidthOfFirstColumn(Element table)
1:086e817:             throws DOMException {
1:086e817:         NodeList headers = table.getElementsByTagName(COLUMN_HEADER);
1:086e817:         // Just fail if someone removes the th-elements.
1:086e817:         Element th = (Element)headers.item(0);
1:086e817:         Element div = wrapTextContentInDiv(th);
1:086e817:         setAttribute(div, "style", "width:110px;");
1:086e817:         th.appendChild(div);
1:086e817:     }
1:086e817:     
1:086e817:     /**
1:d76e238:      * Insert a row at the end of a table
1:d76e238:      * @param table
1:d76e238:      * @return created row Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element insertRow(Element table)
1:d76e238:             throws Exception {
1:086e817:         return insertTableElement(table, ROW);
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Insert a column at the end of a row
1:d76e238:      * @param row
1:d76e238:      * @return created column Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element insertColumn(Element row)
1:d76e238:             throws Exception {
1:086e817:         return insertTableElement(row, COLUMN);
1:086e817:     }
1:d76e238: 
1:086e817:     /**
1:086e817:      * Insert a header column at the end of the row.
1:086e817:      * @param row
1:086e817:      * @return Created column Element
1:086e817:      * @throws DOMException
1:086e817:      */
1:086e817:     public static Element insertColumnHeader(Element row)
1:086e817:             throws DOMException {
1:086e817:         return insertTableElement(row, COLUMN_HEADER);
1:086e817:     }
1:d76e238: 
1:086e817:     /**
1:086e817:      * Inserts the specified element to the parent element.
1:086e817:      *
1:086e817:      * @param parent enclosing element, typically a table or a row
1:086e817:      * @param type type of the new element to be inserted, typically a
1:086e817:      *      column value or a row
1:086e817:      * @return The newly inserted element.
1:086e817:      * @throws DOMException if modifying the DOM fails
1:086e817:      */
1:086e817:     private static Element insertTableElement(Element parent, String type)
1:086e817:             throws DOMException {
1:086e817:         Document doc = parent.getOwnerDocument();
1:086e817:         Element newElement = doc.createElement(type);
1:086e817:         parent.appendChild(newElement);
1:086e817: 
1:086e817:         return newElement;
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Insert a horizontal line at the end of the parent element.
1:d76e238:      * @param parent
1:d76e238:      * @return created line Element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element insertLine(Element parent)
1:d76e238:             throws Exception {
1:d76e238:         Document doc = parent.getOwnerDocument();
1:d76e238:         Element line = doc.createElement(HORIZONTAL_LINE);
1:d76e238: 
1:d76e238:         parent.appendChild(line);
1:d76e238: 
1:d76e238:         return line;
1:d76e238:     }
1:d76e238: 
1:d76e238:     ////////////////////////////////////////////////////////
1:d76e238:     //
1:d76e238:     // XML MINIONS
1:d76e238:     //
1:d76e238:     ////////////////////////////////////////////////////////
1:d76e238:     /**
1:d76e238:      * Search the tree rooted at <code>node</code> for nodes tagged with
1:d76e238:      * <code>childName</code>. Return the first such node, or throws an
1:d76e238:      * exception if none is found.
1:d76e238:      * @param node the node to search
1:d76e238:      * @param childName name of child node to get
1:d76e238:      * @return first child element
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static Element getFirstChild(Element node, String childName)
1:d76e238:             throws Exception {
1:d76e238:         Element retval = getOptionalChild(node, childName);
1:d76e238: 
1:d76e238:         if (retval == null) {
1:d76e238:             throw new BuildException("Could not find child element '" +
1:d76e238:                     childName + "' in parent element '" +
1:d76e238:                     node.getNodeName() + "'.");
1:d76e238:         }
1:d76e238:         return retval;
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Search the tree rooted at <code>node</code> for nodes tagged with
1:d76e238:      * <code>childName</code>.
1:d76e238:      * Return the index'th such node.
1:d76e238:      * @param node parent
1:d76e238:      * @param childName tag name of qualifying child nodes
1:d76e238:      * @param index of child node to return
1:d76e238:      * @return selected child node
1:d76e238:      * @throws java.lang.Exception
1:d76e238:      */
1:d76e238:     public static Element getNextChild(Element node, String childName,
1:d76e238:             int index) throws Exception {
1:d76e238:         Element retval = (Element) node.getElementsByTagName(childName).item(index);
1:d76e238: 
1:d76e238:         if (retval == null) {
1:d76e238:             throw new BuildException("Could not find child element '" +
1:d76e238:                     childName + "' in parent element '" +
1:d76e238:                     node.getNodeName() + "'.");
1:d76e238:         }
1:d76e238: 
1:d76e238:         return retval;
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Search the tree rooted at <code>node</code> for nodes tagged with
1:d76e238:      * <code>childName</code>. Return the first such node, or null if tag is
1:d76e238:      * not found.
1:d76e238:      * @param node root of subtree
1:d76e238:      * @param childName type of child (tag) to search for
1:d76e238:      * @return corresponding child if it exitsts, null otherwise.
1:d76e238:      * @throws java.lang.Exception
1:d76e238:      */
1:d76e238:     public static Element getOptionalChild(Element node, String childName)
1:d76e238:             throws Exception {
1:d76e238:         return (Element) node.getElementsByTagName(childName).item(0);
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Squeeze the text out of an Element.
1:d76e238:      * @param node with text child
1:d76e238:      * @return String representation of node's first child
1:d76e238:      * @throws java.lang.Exception
1:d76e238:      */
1:d76e238:     public static String squeezeText(Element node)
1:d76e238:             throws Exception {
1:d76e238:         return node.getFirstChild().getNodeValue();
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Clone all of the children of a source node and add them as children
1:d76e238:      * of a target node.
1:d76e238:      * @param source
1:d76e238:      * @param target
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static void cloneChildren(Node source, Node target)
1:d76e238:             throws Exception {
1:d76e238:         Document targetDoc = target.getOwnerDocument();
1:d76e238:         NodeList sourceChildren = source.getChildNodes();
1:d76e238:         int count = sourceChildren.getLength();
1:d76e238: 
1:d76e238:         for (int i = 0; i < count; i++) {
1:d76e238:             Node sourceChild = sourceChildren.item(i);
1:d76e238:             Node targetChild = targetDoc.importNode(sourceChild, true);
1:d76e238:             target.appendChild(targetChild);
1:d76e238:         }
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Replace all instances of the tag with the indicated text.
1:d76e238:      * @param doc
1:d76e238:      * @param tag
1:d76e238:      * @param replacementText
1:d76e238:      * @throws Exception
1:d76e238:      */
1:d76e238:     public static void replaceTag(Document doc, String tag,
1:d76e238:             String replacementText) throws Exception {
1:d76e238:         NodeList sourceChildren = doc.getElementsByTagName(tag);
1:d76e238:         int count = sourceChildren.getLength();
1:d76e238: 
1:d76e238:         for (int i = 0; i < count; i++) {
1:d76e238:             Node oldChild = sourceChildren.item(i);
1:d76e238:             Node newChild = doc.createTextNode(replacementText);
1:d76e238: 
1:d76e238:             if (oldChild != null) {
1:d76e238:                 Node parent = oldChild.getParentNode();
1:d76e238: 
1:d76e238:                 if (parent != null) {
1:d76e238:                     parent.insertBefore(newChild, oldChild);
1:d76e238:                 }
1:d76e238:             }
1:d76e238:         }
1:d76e238: 
1:d76e238:         for (int i = count - 1; i > -1; i--) {
1:d76e238:             Node oldChild = sourceChildren.item(i);
1:d76e238: 
1:d76e238:             if (oldChild != null) {
1:d76e238:                 Node parent = oldChild.getParentNode();
1:d76e238: 
1:d76e238:                 if (parent != null) {
1:d76e238:                     parent.removeChild(oldChild);
1:d76e238:                 }
1:d76e238:             }
1:d76e238:         }
1:d76e238:     }
1:d76e238: 
1:d76e238:     ////////////////////////////////////////////////////////
1:d76e238:     //
1:d76e238:     // EXCEPTION PROCESSING MINIONS
1:d76e238:     //
1:d76e238:     ////////////////////////////////////////////////////////
1:d76e238:     /**
1:d76e238:      * Format an error for later reporting.
1:d76e238:      * @param text description
1:d76e238:      * @param t execption that occured
1:d76e238:      * @return formatted error with stack trace
1:d76e238:      */
1:d76e238:     public static String formatError(String text, Throwable t) {
1:d76e238:         return (text + ": " + t.toString() + "\n" + stringifyStackTrace(t));
1:d76e238:     }
1:d76e238: 
1:d76e238:     /**
1:d76e238:      * Print a stack trace as a string.
1:d76e238:      * @param t exception to dump stack for
1:d76e238:      * @return String containing the stacl trace for the exception
1:d76e238:      */
1:d76e238:     public static String stringifyStackTrace(Throwable t) {
1:d76e238:         StringWriter sw = new StringWriter();
1:d76e238:         PrintWriter pw = new PrintWriter(sw, true);
1:d76e238: 
1:d76e238:         t.printStackTrace(pw);
1:d76e238:         pw.flush();
1:d76e238:         sw.flush();
1:d76e238: 
1:d76e238:         return sw.toString();
1:d76e238:     }
1:d76e238: 
1:d76e238:     ////////////////////////////////////////////////////////
1:d76e238:     //
1:d76e238:     // MISC MINIONS
1:d76e238:     //
1:d76e238:     ////////////////////////////////////////////////////////
1:d76e238:     /**
1:d76e238:      * Format a line of text.
1:d76e238:      * @param text the line to format
1:d76e238:      */
1:d76e238:     protected void println(String text) {
1:d76e238:         if (_invokedByAnt) {
1:d76e238:             log(text, Project.MSG_WARN);
1:d76e238:         } else {
1:d76e238:             System.out.println(text);
1:d76e238:         }
1:d76e238:     }
1:d76e238: }
1:d76e238: 
============================================================================
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:086e817
/////////////////////////////////////////////////////////////////////////
1:     private static final String COLUMN_HEADER = "th";
/////////////////////////////////////////////////////////////////////////
1:      * Wraps the text content of the given node inside a div tag.
1:      *
1:      * @param node node currently containing the text
1:      * @return The new div-element which has been appended to {@code node}.
1:      * @throws DOMException 
1:      */
1:     private static Element wrapTextContentInDiv(Element node)
1:             throws DOMException {
1:         Document doc = node.getOwnerDocument();
1:         Element div = doc.createElement(DIVISION);
1:         div.setTextContent(node.getTextContent());
1:         node.setTextContent("");
1:         node.appendChild(div);
1:         return div;
1:     }
1: 
1:     /**
1:      * Sets/overwrites the specified attribute.
1:      *
1:      * @param node target node
1:      * @param name attribute name
1:      * @param value attribute value
1:      * @throws DOMException 
1:      */
1:     private static void setAttribute(Element node, String name, String value)
1:             throws DOMException {
1:         Node attr = node.getOwnerDocument().createAttribute(name);
1:         attr.setNodeValue(value);
1: 
1:         node.getAttributes().setNamedItem(attr);
1:     }
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         for (String headerText : columnHeadings) {
1:             Element headingColumn = insertColumnHeader(headingRow);
1:             headingColumn.setTextContent(headerText);
1:      * Sets the width of the first column in the given table.
1:      *
1:      * @param table target table
1:      * @throws DOMException
1:      */
1:     protected void fixWidthOfFirstColumn(Element table)
1:             throws DOMException {
1:         NodeList headers = table.getElementsByTagName(COLUMN_HEADER);
1:         // Just fail if someone removes the th-elements.
1:         Element th = (Element)headers.item(0);
1:         Element div = wrapTextContentInDiv(th);
1:         setAttribute(div, "style", "width:110px;");
1:         th.appendChild(div);
1:     }
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         return insertTableElement(table, ROW);
/////////////////////////////////////////////////////////////////////////
1:         return insertTableElement(row, COLUMN);
1:     }
1:     /**
1:      * Insert a header column at the end of the row.
1:      * @param row
1:      * @return Created column Element
1:      * @throws DOMException
1:      */
1:     public static Element insertColumnHeader(Element row)
1:             throws DOMException {
1:         return insertTableElement(row, COLUMN_HEADER);
1:     }
1:     /**
1:      * Inserts the specified element to the parent element.
1:      *
1:      * @param parent enclosing element, typically a table or a row
1:      * @param type type of the new element to be inserted, typically a
1:      *      column value or a row
1:      * @return The newly inserted element.
1:      * @throws DOMException if modifying the DOM fails
1:      */
1:     private static Element insertTableElement(Element parent, String type)
1:             throws DOMException {
1:         Document doc = parent.getOwnerDocument();
1:         Element newElement = doc.createElement(type);
1:         parent.appendChild(newElement);
1: 
1:         return newElement;
commit:b25a23f
/////////////////////////////////////////////////////////////////////////
1:         System.out.println("Summary file (input): " + summaryFileName);
commit:e1aa9c0
/////////////////////////////////////////////////////////////////////////
1:     protected List bugList;
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:80e6765
/////////////////////////////////////////////////////////////////////////
1:     protected static final String SPAN = "span";
commit:38b9499
/////////////////////////////////////////////////////////////////////////
1:     protected List<String> excludeReleaseIDList;
1:     protected ArrayList<String> errors = new ArrayList<String>();
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4a57be6
/////////////////////////////////////////////////////////////////////////
1:     private static final String DIVISION = "div";
/////////////////////////////////////////////////////////////////////////
1:         Element block = doc.createElement(DIVISION);
commit:1b5d924
/////////////////////////////////////////////////////////////////////////
1:                 "These notes describe the difference between Apache Derby release " +
commit:adad5b1
/////////////////////////////////////////////////////////////////////////
1:     protected String releaseID;
/////////////////////////////////////////////////////////////////////////
1:      * Establishes state, including branch number.
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Ant mutator to set the id of the release
1:      */
1:     public void setReleaseId(String releaseID) throws Exception {
1:         this.releaseID = releaseID;
1:     }
1: 
commit:9c8b07b
/////////////////////////////////////////////////////////////////////////
0:     protected TagReader bugListDoc;
/////////////////////////////////////////////////////////////////////////
0:         bugListDoc = new TagReader( new FileInputStream(bugListFileName) );
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:d76e238
/////////////////////////////////////////////////////////////////////////
1: /*  Derby - Class org.apache.derbyBuild.GeneratorBase
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1: http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1:  */
1: package org.apache.derbyBuild;
1: 
1: import java.io.*;
1: import java.util.*;
1: import javax.xml.parsers.*;
1: import javax.xml.transform.*;
1: import javax.xml.transform.dom.*;
1: import javax.xml.transform.stream.*;
1: import org.w3c.dom.*;
1: 
1: import org.apache.tools.ant.BuildException;
1: import org.apache.tools.ant.Project;
1: import org.apache.tools.ant.Task;
1: 
1: /**
1:  *
1:  */
1: public class GeneratorBase extends Task {
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //  CONSTANTS
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
1:     // header levels
1:     protected static final int BANNER_LEVEL = 1;
1:     protected static final int MAIN_SECTION_LEVEL = BANNER_LEVEL + 1;
1:     protected static final int ISSUE_DETAIL_LEVEL = MAIN_SECTION_LEVEL + 1;
1:     // headlines
1:     protected static final String DESCRIPTION_HEADLINE = "Description";
1:     protected static final String ISSUE_ID_HEADLINE = "Issue Id";
1: 
1:     // formatting tags
1:     private static final String ANCHOR = "a";
1:     protected static final String BODY = "body";
1:     private static final String BOLD = "b";
1:     private static final String BORDER = "border";
1:     private static final String COLUMN = "td";
1:     private static final String HORIZONTAL_LINE = "hr";
1:     protected static final String HTML = "html";
0:     private static final String INDENT = "blockquote";
1:     private static final String LIST = "ul";
1:     private static final String LIST_ELEMENT = "li";
1:     private static final String NAME = "name";
1:     protected static final String PARAGRAPH = "p";
1:     private static final String ROW = "tr";
1:     private static final String TABLE = "table";
1: 
1:     // tags in summary xml
1:     private static final String SUM_PREVIOUS_RELEASE_ID = "previousReleaseID";
1:     private static final String SUM_RELEASE_ID = "releaseID";
1:     private static final String SUM_EXCLUDE_RELEASE_ID = "excludeReleaseID";
1: 
1:     // other html control
1:     protected static final int DEFAULT_TABLE_BORDER_WIDTH = 2;
1: 
1:     protected DocumentBuilder docBldr =
1:             DocumentBuilderFactory.newInstance().newDocumentBuilder();
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //  STATE
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1:     // set on the command line or by ant
1:     // Summary file
1:     protected String summaryFileName;
1:     protected Document summaryDoc;
1:     protected ElementFacade summary;
1:     // Bug list file
1:     protected String bugListFileName;
0:     protected Document bugListDoc;
1: 
1:     // Output file
1:     private String outputFileName;
1:     protected Document outputDoc = docBldr.newDocument();
1:     protected File outputFile;
1: 
1:     // computed at run time
0:     protected final String releaseID;
1:     protected String previousReleaseID;
0:     protected List excludeReleaseIDList;
1:     protected final String branch;
0:     protected ArrayList errors = new ArrayList();
1: 
1:     // misc
1:     protected boolean _invokedByAnt = true;
1: 
1:     /**
0:      * Establishes state, including currrent version number.
1:      * @throws java.lang.Exception
1:      */
1:     public GeneratorBase() throws Exception {
1:         Properties r = new Properties();
1:         r.load(new FileInputStream("../ant/properties/release.properties"));
1:         int maint = Integer.parseInt(r.getProperty("maint"));
0:         int thirdDigit = maint / 1000000;
0:         int fourthDigit = maint % 1000000;
1:         branch = r.getProperty("eversion");
0:         releaseID = branch + "." + thirdDigit + "." + fourthDigit;
1:     }
1: 
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //  ANT Task BEHAVIOR
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Ant accessor to set the name of the summary file prepared by the
1:      * Release Manager
1:      * @param summaryFileName name of xml file to use for the summary
1:      * @throws Exception
1:      */
1:     public void setSummaryFileName(String summaryFileName) throws Exception {
1:         this.summaryFileName = summaryFileName;
1:         summaryDoc = docBldr.parse(new File(summaryFileName));
1:         summary = new ElementFacade(summaryDoc);
1:         previousReleaseID = summary.getTextByTagName(SUM_PREVIOUS_RELEASE_ID);
1: 
1:         excludeReleaseIDList =
1:                 summary.getTextListByTagName(SUM_EXCLUDE_RELEASE_ID);
0:         System.out.println("setting summary file name to:" + summaryFileName +
0:                 " previousReleaseID: " + previousReleaseID +
0:                 " excludeReleaseIDList.size():" + excludeReleaseIDList.size());
1:     }
1: 
1:     /**
1:      * Ant mutator to set the name of the JIRA-generated list of bugs
1:      * addressed by this release
1:      * @param bugListFileName name of an xml file from a Jira filter/query
1:      * @throws Exception
1:      */
1:     public void setBugListFileName(String bugListFileName) throws Exception {
1:         this.bugListFileName = bugListFileName;
0:         bugListDoc = docBldr.parse(new File(bugListFileName));
1:     }
1: 
1:     /**
1:      * Ant mutator to set the name of the generated output file
1:      * @param outputFileName name of file to use as pamphlet (output)
1:      * @throws Exception
1:      */
1:     public void setOutputFileName(String outputFileName) throws Exception {
1:         this.outputFileName = outputFileName;
1:         outputFile = new File(outputFileName);
1:     }
1: 
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //  MINIONS
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Note that this release is a delta from the previous one.
1:      * @param parent
1:      * @throws java.lang.Exception
1:      */
1:     protected void buildDelta(Element parent)
1:             throws Exception {
1:         String deltaStatement =
0:                 "These notes describe the difference between Derby release " +
1:                 releaseID + " and the preceding release " +
1:                 previousReleaseID + ".";
1: 
1:         addParagraph(parent, deltaStatement);
1:     }
1: 
1:     /**
1:      * Replace the known parameters with their corresponding text values.
1:      * @throws Exception
1:      */
1:     protected void replaceVariables()
1:             throws Exception {
1:         replaceTag(outputDoc, SUM_RELEASE_ID, releaseID);
1:         replaceTag(outputDoc, SUM_PREVIOUS_RELEASE_ID, previousReleaseID);
1:     }
1: 
1:     /**
1:      * Print the generated output document to the output file.
1:      * @throws Exception
1:      */
1:     protected void printOutput() throws Exception {
1:         Source source = new DOMSource(outputDoc);
1: 
1:         Result result = new StreamResult(outputFile);
1:         Transformer transformer =
1:                 TransformerFactory.newInstance().newTransformer();
1: 
1:         transformer.transform(source, result);
1:     }
1: 
1:     /**
1:      * Print accumulated errors.
1:      * @throws Exception
1:      */
1:     protected void printErrors() throws Exception {
1:         if (errors.isEmpty()) {
1:             return;
1:         }
1: 
1:         println("The following other errors occurred:");
1: 
1:         for (Iterator i = errors.iterator(); i.hasNext();) {
1:             println("\n" + i.next());
1:         }
1:     }
1: 
1: 
1:     ////////////////////////////////////////////////////////
1:     //
1:     // HTML MINIONS
1:     //
1:     ////////////////////////////////////////////////////////
1:     /**
1:      * Create a section at the end of a parent element and link to it from a
1:      * table of contents.
1:      * @param parent in document tree
1:      * @param sectionLevel in document
1:      * @param toc table of content element
1:      * @param sectionName for section being created
1:      * @param tocEntry key into table of content
1:      * @return resulting Element
1:      * @throws Exception
1:      */
1:     public static Element createSection(Element parent, int sectionLevel,
1:             Element toc, String sectionName, String tocEntry)
1:             throws Exception {
1:         Document doc = parent.getOwnerDocument();
1:         Text textNode = doc.createTextNode(tocEntry);
1: 
1:         return createSection(parent, sectionLevel, toc, sectionName, textNode);
1:     }
1: 
1:     /**
1:      * Create a section at the end of a parent element and link to it from a
1:      * table of contents.
1:      * @param parent in document tree
1:      * @param sectionLevel in document
1:      * @param toc table of content element
1:      * @param sectionName for section being created
1:      * @param visibleText text to show
1:      * @return resulting Element
1:      * @throws Exception
1:      */
1:     public static Element createSection(Element parent, int sectionLevel,
1:             Element toc, String sectionName, Node visibleText)
1:             throws Exception {
1:         Document doc = parent.getOwnerDocument();
1:         Element link = createLocalLink(doc, sectionName, visibleText);
1: 
1:         addListItem(toc, link);
1: 
1:         return createHeader(parent, sectionLevel, sectionName);
1:     }
1: 
1:     /**
1:      * Create a header at the end of the parent node. Return the block created
1:      * to hold the text following this header.
1:      * @param parent
1:      * @param headerLevel
1:      * @param text
1:      * @return created header Element
1:      * @throws Exception
1:      */
1:     public static Element createHeader(Element parent, int headerLevel,
1:             String text) throws Exception {
1:         Document doc = parent.getOwnerDocument();
1:         Text textNode = doc.createTextNode(text);
1:         Element header = doc.createElement(makeHeaderTag(headerLevel));
1:         Element anchor = doc.createElement(ANCHOR);
0:         Element block = doc.createElement(INDENT);
1: 
1:         parent.appendChild(header);
1:         anchor.setAttribute(NAME, text);
1:         header.appendChild(anchor);
1:         header.appendChild(textNode);
1:         parent.appendChild(block);
1: 
1:         return block;
1:     }
1: 
1:     /**
1:      * Create an html text element.
1:      * @param doc
1:      * @param tag
1:      * @param text
1:      * @return created text Element
1:      * @throws Exception
1:      */
1:     public static Element createTextElement(Document doc, String tag,
1:             String text) throws Exception {
1:         Element retval = doc.createElement(tag);
1:         Text textNode = doc.createTextNode(text);
1: 
1:         retval.appendChild(textNode);
1: 
1:         return retval;
1:     }
1: 
1:     /**
1:      * Create a standard link to a local label.
1:      * @param doc
1:      * @param anchor
1:      * @param text
1:      * @return created link Element
1:      * @throws Exception
1:      */
1:     public static Element createLocalLink(Document doc, String anchor,
1:             String text) throws Exception {
1:         Text textNode = doc.createTextNode(text);
1: 
1:         return createLocalLink(doc, anchor, textNode);
1:     }
1: 
1:     /**
1:      * Create a standard link to a local label.
1:      * @param doc
1:      * @param anchor
1:      * @param visibleText
1:      * @return created link Element
1:      * @throws Exception
1:      */
1:     public static Element createLocalLink(Document doc, String anchor,
1:             Node visibleText) throws Exception {
1:         return createLink(doc, "#" + anchor, visibleText);
1:     }
1: 
1:     /**
1:      * Create a hotlink.
1:      * @param doc
1:      * @param label
1:      * @param text
1:      * @return created link Element
1:      * @throws Exception
1:      */
1:     public static Element createLink(Document doc, String label, String text)
1:             throws Exception {
1:         Text textNode = doc.createTextNode(text);
1: 
1:         return createLink(doc, label, textNode);
1:     }
1: 
1:     /**
1:      * Create a hotlink.
1:      * @param doc
1:      * @param label
1:      * @param visibleText
1:      * @return created anchor Element
1:      * @throws Exception
1:      */
1:     public static Element createLink(Document doc, String label,
1:             Node visibleText) throws Exception {
1:         Element hotlink = doc.createElement(ANCHOR);
1: 
1:         hotlink.setAttribute("href", label);
1:         hotlink.appendChild(visibleText);
1: 
1:         return hotlink;
1:     }
1: 
1:     /**
1:      * Insert a list at the end of the parent element.
1:      * @param parent
1:      * @return created list Element
1:      * @throws Exception
1:      */
1:     public static Element createList(Element parent)
1:             throws Exception {
1:         Document doc = parent.getOwnerDocument();
1:         Element list = doc.createElement(LIST);
1: 
1:         parent.appendChild(list);
1: 
1:         return list;
1:     }
1: 
1:     /**
1:      * Add an item with a bold name to the end of a list.
1:      * @param list
1:      * @param headline
1:      * @param text
1:      * @return created headline Element
1:      * @throws Exception
1:      */
1:     public static Element addHeadlinedItem(Element list, String headline,
1:             String text) throws Exception {
1:         Document doc = list.getOwnerDocument();
1:         Element itemElement = doc.createElement(LIST_ELEMENT);
1:         Element boldText = boldText(doc, headline);
1:         Text textNode = doc.createTextNode(" - " + text);
1: 
1:         list.appendChild(itemElement);
1:         itemElement.appendChild(boldText);
1:         itemElement.appendChild(textNode);
1: 
1:         return itemElement;
1:     }
1: 
1:     /**
1:      * Make some bold text.
1:      * @param doc
1:      * @param text
1:      * @return created bold Element
1:      * @throws Exception
1:      */
1:     public static Element boldText(Document doc, String text)
1:             throws Exception {
1:         Element bold = createTextElement(doc, BOLD, text);
1: 
1:         return bold;
1:     }
1: 
1:     /**
1:      * Add an item to the end of a list.
1:      * @param list
1:      * @param item
1:      * @return created item Element
1:      * @throws Exception
1:      */
1:     public static Element addListItem(Element list, Node item)
1:             throws Exception {
1:         Document doc = list.getOwnerDocument();
1:         Element itemElement = doc.createElement(LIST_ELEMENT);
1: 
1:         list.appendChild(itemElement);
1:         itemElement.appendChild(item);
1: 
1:         return itemElement;
1:     }
1: 
1:     /**
1:      * Retrieve the indented block inside a section
1:      * @param doc
1:      * @param sectionLevel
1:      * @param sectionName
1:      * @return indented block Element
1:      * @throws Exception
1:      */
1:     public static Element getSection(Document doc, int sectionLevel,
1:             String sectionName) throws Exception {
1:         String headerTag = makeHeaderTag(sectionLevel);
1:         Element root = doc.getDocumentElement();
1:         NodeList sectionList = root.getElementsByTagName(headerTag);
1:         int count = sectionList.getLength();
1: 
1:         for (int i = 0; i < count; i++) {
1:             Element section = (Element) sectionList.item(i);
1:             Element sectionAnchor = getFirstChild(section, ANCHOR);
1: 
1:             if (sectionName.equals(sectionAnchor.getAttribute(NAME))) {
1:                 // the next item after the section header, is the indented block
1: 
1:                 return (Element) section.getNextSibling();
1:             }
1:         }
1: 
1:         return null;
1:     }
1: 
1:     /**
1:      * Make the tag for a header, given its level
1:      * @param headerLevel
1:      * @return header tag at specified level
1:      */
1:     public static String makeHeaderTag(int headerLevel) {
1:         return "h" + Integer.toString(headerLevel);
1:     }
1: 
1:     /**
1:      * Add a paragraph to the end of a parent element.
1:      * @param parent
1:      * @param text
1:      * @return created paragraph Element
1:      * @throws Exception
1:      */
1:     public static Element addParagraph(Element parent, String text)
1:             throws Exception {
1:         Document doc = parent.getOwnerDocument();
1:         Text textNode = doc.createTextNode(text);
1:         Element paragraph = doc.createElement(PARAGRAPH);
1: 
1:         parent.appendChild(paragraph);
1:         paragraph.appendChild(textNode);
1: 
1:         return paragraph;
1:     }
1: 
1:     /**
1:      * Insert a table at the end of the parent element.
1:      * @param parent
1:      * @param borderWidth
1:      * @param columnHeadings
1:      * @return created table Element
1:      * @throws Exception
1:      */
1:     public static Element createTable(Element parent, int borderWidth,
1:             String[] columnHeadings) throws Exception {
1:         Document doc = parent.getOwnerDocument();
1:         Element table = doc.createElement(TABLE);
1:         Element headingRow = insertRow(table);
0:         int count = columnHeadings.length;
1: 
1:         parent.appendChild(table);
1:         table.setAttribute(BORDER, Integer.toString(borderWidth));
1: 
1:         for (int i = 0; i < count; i++) {
0:             Element headingColumn = insertColumn(headingRow);
0:             Element boldText = boldText(doc, columnHeadings[i]);
1: 
0:             headingColumn.appendChild(boldText);
1:         }
1: 
1:         return table;
1:     }
1: 
1:     /**
1:      * Insert a row at the end of a table
1:      * @param table
1:      * @return created row Element
1:      * @throws Exception
1:      */
1:     public static Element insertRow(Element table)
1:             throws Exception {
0:         Document doc = table.getOwnerDocument();
0:         Element row = doc.createElement(ROW);
1: 
0:         table.appendChild(row);
1: 
0:         return row;
1:     }
1: 
1:     /**
1:      * Insert a column at the end of a row
1:      * @param row
1:      * @return created column Element
1:      * @throws Exception
1:      */
1:     public static Element insertColumn(Element row)
1:             throws Exception {
0:         Document doc = row.getOwnerDocument();
0:         Element column = doc.createElement(COLUMN);
1: 
0:         row.appendChild(column);
1: 
0:         return column;
1:     }
1: 
1:     /**
1:      * Insert a horizontal line at the end of the parent element.
1:      * @param parent
1:      * @return created line Element
1:      * @throws Exception
1:      */
1:     public static Element insertLine(Element parent)
1:             throws Exception {
1:         Document doc = parent.getOwnerDocument();
1:         Element line = doc.createElement(HORIZONTAL_LINE);
1: 
1:         parent.appendChild(line);
1: 
1:         return line;
1:     }
1: 
1:     ////////////////////////////////////////////////////////
1:     //
1:     // XML MINIONS
1:     //
1:     ////////////////////////////////////////////////////////
1:     /**
1:      * Search the tree rooted at <code>node</code> for nodes tagged with
1:      * <code>childName</code>. Return the first such node, or throws an
1:      * exception if none is found.
1:      * @param node the node to search
1:      * @param childName name of child node to get
1:      * @return first child element
1:      * @throws Exception
1:      */
1:     public static Element getFirstChild(Element node, String childName)
1:             throws Exception {
1:         Element retval = getOptionalChild(node, childName);
1: 
1:         if (retval == null) {
1:             throw new BuildException("Could not find child element '" +
1:                     childName + "' in parent element '" +
1:                     node.getNodeName() + "'.");
1:         }
1:         return retval;
1:     }
1: 
1:     /**
1:      * Search the tree rooted at <code>node</code> for nodes tagged with
1:      * <code>childName</code>.
1:      * Return the index'th such node.
1:      * @param node parent
1:      * @param childName tag name of qualifying child nodes
1:      * @param index of child node to return
1:      * @return selected child node
1:      * @throws java.lang.Exception
1:      */
1:     public static Element getNextChild(Element node, String childName,
1:             int index) throws Exception {
1:         Element retval = (Element) node.getElementsByTagName(childName).item(index);
1: 
1:         if (retval == null) {
1:             throw new BuildException("Could not find child element '" +
1:                     childName + "' in parent element '" +
1:                     node.getNodeName() + "'.");
1:         }
1: 
1:         return retval;
1:     }
1: 
1:     /**
1:      * Search the tree rooted at <code>node</code> for nodes tagged with
1:      * <code>childName</code>. Return the first such node, or null if tag is
1:      * not found.
1:      * @param node root of subtree
1:      * @param childName type of child (tag) to search for
1:      * @return corresponding child if it exitsts, null otherwise.
1:      * @throws java.lang.Exception
1:      */
1:     public static Element getOptionalChild(Element node, String childName)
1:             throws Exception {
1:         return (Element) node.getElementsByTagName(childName).item(0);
1:     }
1: 
1:     /**
1:      * Squeeze the text out of an Element.
1:      * @param node with text child
1:      * @return String representation of node's first child
1:      * @throws java.lang.Exception
1:      */
1:     public static String squeezeText(Element node)
1:             throws Exception {
1:         return node.getFirstChild().getNodeValue();
1:     }
1: 
1:     /**
1:      * Clone all of the children of a source node and add them as children
1:      * of a target node.
1:      * @param source
1:      * @param target
1:      * @throws Exception
1:      */
1:     public static void cloneChildren(Node source, Node target)
1:             throws Exception {
1:         Document targetDoc = target.getOwnerDocument();
1:         NodeList sourceChildren = source.getChildNodes();
1:         int count = sourceChildren.getLength();
1: 
1:         for (int i = 0; i < count; i++) {
1:             Node sourceChild = sourceChildren.item(i);
1:             Node targetChild = targetDoc.importNode(sourceChild, true);
1:             target.appendChild(targetChild);
1:         }
1:     }
1: 
1:     /**
1:      * Replace all instances of the tag with the indicated text.
1:      * @param doc
1:      * @param tag
1:      * @param replacementText
1:      * @throws Exception
1:      */
1:     public static void replaceTag(Document doc, String tag,
1:             String replacementText) throws Exception {
1:         NodeList sourceChildren = doc.getElementsByTagName(tag);
1:         int count = sourceChildren.getLength();
1: 
1:         for (int i = 0; i < count; i++) {
1:             Node oldChild = sourceChildren.item(i);
1:             Node newChild = doc.createTextNode(replacementText);
1: 
1:             if (oldChild != null) {
1:                 Node parent = oldChild.getParentNode();
1: 
1:                 if (parent != null) {
1:                     parent.insertBefore(newChild, oldChild);
1:                 }
1:             }
1:         }
1: 
1:         for (int i = count - 1; i > -1; i--) {
1:             Node oldChild = sourceChildren.item(i);
1: 
1:             if (oldChild != null) {
1:                 Node parent = oldChild.getParentNode();
1: 
1:                 if (parent != null) {
1:                     parent.removeChild(oldChild);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     ////////////////////////////////////////////////////////
1:     //
1:     // EXCEPTION PROCESSING MINIONS
1:     //
1:     ////////////////////////////////////////////////////////
1:     /**
1:      * Format an error for later reporting.
1:      * @param text description
1:      * @param t execption that occured
1:      * @return formatted error with stack trace
1:      */
1:     public static String formatError(String text, Throwable t) {
1:         return (text + ": " + t.toString() + "\n" + stringifyStackTrace(t));
1:     }
1: 
1:     /**
1:      * Print a stack trace as a string.
1:      * @param t exception to dump stack for
1:      * @return String containing the stacl trace for the exception
1:      */
1:     public static String stringifyStackTrace(Throwable t) {
1:         StringWriter sw = new StringWriter();
1:         PrintWriter pw = new PrintWriter(sw, true);
1: 
1:         t.printStackTrace(pw);
1:         pw.flush();
1:         sw.flush();
1: 
1:         return sw.toString();
1:     }
1: 
1:     ////////////////////////////////////////////////////////
1:     //
1:     // MISC MINIONS
1:     //
1:     ////////////////////////////////////////////////////////
1:     /**
1:      * Format a line of text.
1:      * @param text the line to format
1:      */
1:     protected void println(String text) {
1:         if (_invokedByAnt) {
1:             log(text, Project.MSG_WARN);
1:         } else {
1:             System.out.println(text);
1:         }
1:     }
1: }
1: 
============================================================================