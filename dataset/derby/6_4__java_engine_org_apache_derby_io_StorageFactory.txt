1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.io.StorageFactory
1:345de35: 
1:2f36947:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2f36947:    contributor license agreements.  See the NOTICE file distributed with
1:2f36947:    this work for additional information regarding copyright ownership.
1:2f36947:    The ASF licenses this file to You under the Apache License, Version 2.0
1:2f36947:    (the "License"); you may not use this file except in compliance with
1:2f36947:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
2:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.io;
1:eac0369: 
1:eac0369: import java.io.IOException;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * This interface provides basic storage functions needed for read only databases. Most storage
1:eac0369:  * implementations will be read-write and implement the WritableStorageFactory extension of this
1:eac0369:  * interface.
1:eac0369:  *
1:eac0369:  *<p>
1:eac0369:  * The database engine uses this interface to access storage. The normal database engine
1:eac0369:  * implements this interface using disk files and the standard java.io classes.
1:eac0369:  *
1:eac0369:  *<p>
1:eac0369:  * The storage factory must implement writable temporary files, even if the database is read-only or
1:eac0369:  * if the storage factory is read-only (i.e. it does not implement the WritableStorageFactory extension of this
1:eac0369:  * interface). Temporary files are those created under the temporary file directory. See
1:eac0369:  * {@link #getTempDir method getTempDir()}.
1:eac0369:  *
1:eac0369:  *<p>The database engine can be turned into a RAM based engine by providing a RAM based implementation of this interface.
1:eac0369:  *
1:eac0369:  *<p>There is one instance of the StorageFactory per database if the log files are kept in the database directory.
1:eac0369:  * If the log files are kept on a separate device then a second StorageFactory is instantiated to hold the log files.
1:eac0369:  * The database or log device name is set when the init method is called.
1:eac0369:  * The init method is called once per instance, before any other StorageFactory method.
1:eac0369:  *
1:eac0369:  *<p>The class implementing this interface must have a public niladic constructor. The init method will be called
1:eac0369:  * before any other method to set the database directory name, to tell the factory to create the database
1:eac0369:  * directory if necessary, and to allow the implementation to perform any initializations it requires. The
1:eac0369:  * database name set in the init method forms a separate name space. Different StorageFactory instances, with
1:eac0369:  * different database directory names, must ensure that their files do not clash. So, for instance,
1:eac0369:  * storageFactory1.newStorageFile( "x") must be a separate file from storageFactory2.newStorageFile( "x").
1:eac0369:  *
1:eac0369:  *<p>The database engine will call this interface's methods from its own privilege blocks. This does not give
1:eac0369:  * a StorageFactory implementation carte blanche: a security manager can still forbid the implemeting class from
1:eac0369:  * executing a privileged action. However, the security manager will not look in the calling stack beyond the
1:eac0369:  * database engine.
1:eac0369:  *
1:eac0369:  *<p>Each StorageFactory instance may be concurrently used by multiple threads. Each StorageFactory implementation
1:eac0369:  * must be thread safe.
1:eac0369:  *
1:eac0369:  *<p>A StorageFactory implementation is plugged into the database engine via a sub-protocol. Sub-protocol <i>xxx</i> is
1:eac0369:  * tied to a StorageFactory implementation class via the derby.subSubProtocol.<i>xxx</i> system property. So,
1:eac0369:  * to use StorageFactory implementation class MyStorageFactory with database myDB you would set the system
1:eac0369:  * property "derby.subSubProtocol.mysf=MyStorageFactory" and use the URL "jdbc:derby:mysf:myDB" to
1:eac0369:  * connect to the database.
1:eac0369:  *
1:eac0369:  * @see WritableStorageFactory
1:eac0369:  * @see StorageFile
1:eac0369:  * @see StorageRandomAccessFile
1:eac0369:  * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/File.html">java.io.File</a>
1:eac0369:  * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/RandomAccessFile.html">java.io.RandomAccessFile</a>
1:eac0369:  * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/InputStream.html">java.io.InputStream</a>
1:eac0369:  * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/OutputStream.html">java.io.OutputStream</a>
1:eac0369:  */
1:eac0369: public interface StorageFactory
1:eac0369: {
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Classes implementing the StorageFactory interface must have a null
1:eac0369:      * constructor.  The init method is called when the database is booted up to
1:eac0369:      * initialize the class. It should perform all actions necessary to start the
1:eac0369:      * basic storage, such as creating a temporary file directory.
1:eac0369:      *
1:eac0369:      * This method should not create the database directory.
1:eac0369:      *<p>
1:eac0369:      * The init method will be called once, before any other method is called, and will not
1:eac0369:      * be called again.
1:eac0369:      *
1:eac0369:      * @param home The name of the directory containing the database. It comes from the system.home system property.
1:eac0369:      *             It may be null. A storage factory may decide to ignore this parameter. (For instance the classpath
1:eac0369:      *             storage factory ignores it).
1:eac0369:      * @param databaseName The name of the database (directory). The name does not include the subsubprotocol.
1:eac0369:      *                     If null then the storage factory will only be used to deal with the directory containing
1:eac0369:      *                     the databases.
1:eac0369:      * @param tempDirName The name of the temporary file directory set in properties. If null then a default
1:eac0369:      *                    directory should be used. Each database should get a separate temporary file
1:eac0369:      *                    directory within this one to avoid collisions.
1:eac0369:      * @param uniqueName A unique name that can be used to create the temporary file directory for this database.
1:eac0369:      *                   If null then temporary files will not be created in this StorageFactory instance, and the
1:eac0369:      *                   temporary file directory should not be created.
1:eac0369:      *
1:eac0369:      * @exception IOException
1:eac0369:      */
1:eac0369:     public void init( String home, String databaseName, String tempDirName, String uniqueName)
1:eac0369:         throws IOException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The shutdown method is called during the normal shutdown of the database. However, the database
1:eac0369:      * engine cannot guarantee that shutdown will be called. If the JVM terminates abnormally then it will
1:eac0369:      * not be called.
1:eac0369:      */
1:eac0369:     public void shutdown();
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the canonical name of the database. This is a name that uniquely identifies it. It is system dependent.
1:eac0369:      *
1:eac0369:      * The normal, disk based implementation uses method java.io.File.getCanonicalPath on the directory holding the
1:eac0369:      * database to construct the canonical name.
1:eac0369:      *
1:eac0369:      * @return the canonical name
1:eac0369:      *
1:eac0369:      * @exception IOException if an IO error occurred during the construction of the name.
1:eac0369:      */
1:eac0369:     public String getCanonicalName() throws IOException;
1:eac0369:     
1:eac0369:     /**
1:eac0369:      * Construct a StorageFile from a path name.
1:eac0369:      *
1:eac0369:      * @param path The path name of the file. If null then return the database directory.
1:eac0369:      *             If this parameter denotes the temp directory or a directory under the temp
1:eac0369:      *             directory then the resulting StorageFile denotes a temporary file. Otherwise
1:eac0369:      *             the path must be relative to the database and the resulting StorageFile denotes a
1:eac0369:      *             regular database file (non-temporary).
1:eac0369:      *
1:eac0369:      * @return A corresponding StorageFile object
1:eac0369:      */
1:eac0369:     public StorageFile newStorageFile( String path);
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Construct a non-temporary StorageFile from a directory and file name.
1:eac0369:      *
1:eac0369:      * @param directoryName The directory part of the path name. If this parameter denotes the
1:eac0369:      *                      temp directory or a directory under the temp directory then the resulting
1:eac0369:      *                      StorageFile denotes a temporary file. Otherwise the directory name must be
1:eac0369:      *                      relative to the database and the resulting StorageFile denotes a
1:eac0369:      *                      regular database file (non-temporary).
1:eac0369:      * @param fileName The name of the file within the directory.
1:eac0369:      *
1:eac0369:      * @return A corresponding StorageFile object
1:eac0369:      */
1:eac0369:     public StorageFile newStorageFile( String directoryName, String fileName);
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Construct a StorageFile from a directory and file name. The StorageFile may denote a temporary file
1:eac0369:      * or a non-temporary database file, depending upon the directoryName parameter.
1:eac0369:      *
1:eac0369:      * @param directoryName The directory part of the path name. If this parameter denotes the
1:eac0369:      *                      temp directory or a directory under the temp directory then the resulting
1:eac0369:      *                      StorageFile denotes a temporary file. Otherwise the resulting StorageFile denotes a
1:eac0369:      *                      regular database file (non-temporary).
1:eac0369:      * @param fileName The name of the file within the directory.
1:eac0369:      *
1:eac0369:      * @return A corresponding StorageFile object
1:eac0369:      */
1:eac0369:     public StorageFile newStorageFile( StorageFile directoryName, String fileName);
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the pathname separator character used by the StorageFile implementation. This is the
1:eac0369:      * separator that must be used in directory and file name strings.
1:eac0369:      *
1:eac0369:      * @return the pathname separator character. (Normally '/' or '\').
1:eac0369:      */
1:eac0369:     public char getSeparator();
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the abstract name of the directory that holds temporary files.
1:eac0369:      *<p>
1:eac0369:      * The StorageFactory implementation
1:eac0369:      * is not required to make temporary files persistent. That is, files created in the temp directory are
1:eac0369:      * not required to survive a shutdown of the database engine.
1:eac0369:      *<p>
1:eac0369:      * However, files created in the temp directory must be writable, <b>even if the database is
1:eac0369:      * otherwise read-only</b>.
1:eac0369:      *
1:eac0369:      * @return a directory name
1:eac0369:      */
1:eac0369:     public StorageFile getTempDir();
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * This method is used to determine whether the storage is fast (RAM based) or slow (disk based).
1:eac0369:      * It may be used by the database engine to determine the default size of the page cache.
1:eac0369:      *
1:eac0369:      * @return <b>true</b> if the storage is fast, <b>false</b> if it is slow.
1:eac0369:      */
1:eac0369:     public boolean isFast();
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Determine whether the database is read only. The database engine supports read-only databases, even
1:eac0369:      * in file systems that are writable.
1:eac0369:      *
1:eac0369:      * @return <b>true</b> if the storage is read only, <b>false</b> if it is writable.
1:eac0369:      */
1:eac0369:     public boolean isReadOnlyDatabase();
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Determine whether the storage supports random access. If random access is not supported then
1:eac0369:      * it will only be accessed using InputStreams and OutputStreams (if the database is writable).
1:eac0369:      *
1:eac0369:      * @return <b>true</b> if the storage supports random access, <b>false</b> if it is writable.
1:eac0369:      */
1:eac0369:     public boolean supportsRandomAccess();
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The version number of this version of the StorageFactory interface and its subsidiary interfaces.
1:eac0369:      */
1:eac0369:     int VERSION_NUMBER = 1;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * @return the StorageFactory version supported by this implementation
1:eac0369:      */
1:eac0369:     public int getStorageFactoryVersion();
1:b2b30ec: 
1:b2b30ec:     /**
1:b2b30ec:      * Create and returns a temporary file in temporary file system of database
1:b2b30ec:      * @param prefix String to prefix the random name generator. It can be null
1:b2b30ec:      * @param suffix String to suffix the random name generator. ".tmp" will be
1:b2b30ec:      *               used if null.
1:b2b30ec:      * @return StorageFile
1:b2b30ec:      */
1:b2b30ec:     public StorageFile createTemporaryFile (String prefix, String suffix)
1:b2b30ec:                                                             throws IOException;
1:0e00e5e:     
1:0e00e5e:     /**
1:0e00e5e:      * Set the canonicalName. May need adjustment due to DERBY-5096
1:0e00e5e:      * 
1:0e00e5e:      * @param name uniquely identifiable name for this database
1:0e00e5e:      */
1:0e00e5e:     public void setCanonicalName(String name);
1:0e00e5e:     
1:eac0369: }
============================================================================
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:0e00e5e
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Set the canonicalName. May need adjustment due to DERBY-5096
1:      * 
1:      * @param name uniquely identifiable name for this database
1:      */
1:     public void setCanonicalName(String name);
1:     
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b2b30ec
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Create and returns a temporary file in temporary file system of database
1:      * @param prefix String to prefix the random name generator. It can be null
1:      * @param suffix String to suffix the random name generator. ".tmp" will be
1:      *               used if null.
1:      * @return StorageFile
1:      */
1:     public StorageFile createTemporaryFile (String prefix, String suffix)
1:                                                             throws IOException;
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:2f36947
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.io.StorageFactory
1: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:4dede3b
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.io
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.io;
1: 
1: import java.io.IOException;
1: 
1: /**
1:  * This interface provides basic storage functions needed for read only databases. Most storage
1:  * implementations will be read-write and implement the WritableStorageFactory extension of this
1:  * interface.
1:  *
1:  *<p>
1:  * The database engine uses this interface to access storage. The normal database engine
1:  * implements this interface using disk files and the standard java.io classes.
1:  *
1:  *<p>
1:  * The storage factory must implement writable temporary files, even if the database is read-only or
1:  * if the storage factory is read-only (i.e. it does not implement the WritableStorageFactory extension of this
1:  * interface). Temporary files are those created under the temporary file directory. See
1:  * {@link #getTempDir method getTempDir()}.
1:  *
1:  *<p>The database engine can be turned into a RAM based engine by providing a RAM based implementation of this interface.
1:  *
1:  *<p>There is one instance of the StorageFactory per database if the log files are kept in the database directory.
1:  * If the log files are kept on a separate device then a second StorageFactory is instantiated to hold the log files.
1:  * The database or log device name is set when the init method is called.
1:  * The init method is called once per instance, before any other StorageFactory method.
1:  *
1:  *<p>The class implementing this interface must have a public niladic constructor. The init method will be called
1:  * before any other method to set the database directory name, to tell the factory to create the database
1:  * directory if necessary, and to allow the implementation to perform any initializations it requires. The
1:  * database name set in the init method forms a separate name space. Different StorageFactory instances, with
1:  * different database directory names, must ensure that their files do not clash. So, for instance,
1:  * storageFactory1.newStorageFile( "x") must be a separate file from storageFactory2.newStorageFile( "x").
1:  *
1:  *<p>The database engine will call this interface's methods from its own privilege blocks. This does not give
1:  * a StorageFactory implementation carte blanche: a security manager can still forbid the implemeting class from
1:  * executing a privileged action. However, the security manager will not look in the calling stack beyond the
1:  * database engine.
1:  *
1:  *<p>Each StorageFactory instance may be concurrently used by multiple threads. Each StorageFactory implementation
1:  * must be thread safe.
1:  *
1:  *<p>A StorageFactory implementation is plugged into the database engine via a sub-protocol. Sub-protocol <i>xxx</i> is
1:  * tied to a StorageFactory implementation class via the derby.subSubProtocol.<i>xxx</i> system property. So,
1:  * to use StorageFactory implementation class MyStorageFactory with database myDB you would set the system
1:  * property "derby.subSubProtocol.mysf=MyStorageFactory" and use the URL "jdbc:derby:mysf:myDB" to
1:  * connect to the database.
1:  *
1:  * @see WritableStorageFactory
1:  * @see StorageFile
1:  * @see StorageRandomAccessFile
1:  * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/File.html">java.io.File</a>
1:  * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/RandomAccessFile.html">java.io.RandomAccessFile</a>
1:  * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/InputStream.html">java.io.InputStream</a>
1:  * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/OutputStream.html">java.io.OutputStream</a>
1:  */
1: public interface StorageFactory
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
1: 
1:     /**
1:      * Classes implementing the StorageFactory interface must have a null
1:      * constructor.  The init method is called when the database is booted up to
1:      * initialize the class. It should perform all actions necessary to start the
1:      * basic storage, such as creating a temporary file directory.
1:      *
1:      * This method should not create the database directory.
1:      *<p>
1:      * The init method will be called once, before any other method is called, and will not
1:      * be called again.
1:      *
1:      * @param home The name of the directory containing the database. It comes from the system.home system property.
1:      *             It may be null. A storage factory may decide to ignore this parameter. (For instance the classpath
1:      *             storage factory ignores it).
1:      * @param databaseName The name of the database (directory). The name does not include the subsubprotocol.
1:      *                     If null then the storage factory will only be used to deal with the directory containing
1:      *                     the databases.
1:      * @param tempDirName The name of the temporary file directory set in properties. If null then a default
1:      *                    directory should be used. Each database should get a separate temporary file
1:      *                    directory within this one to avoid collisions.
1:      * @param uniqueName A unique name that can be used to create the temporary file directory for this database.
1:      *                   If null then temporary files will not be created in this StorageFactory instance, and the
1:      *                   temporary file directory should not be created.
1:      *
1:      * @exception IOException
1:      */
1:     public void init( String home, String databaseName, String tempDirName, String uniqueName)
1:         throws IOException;
1: 
1:     /**
1:      * The shutdown method is called during the normal shutdown of the database. However, the database
1:      * engine cannot guarantee that shutdown will be called. If the JVM terminates abnormally then it will
1:      * not be called.
1:      */
1:     public void shutdown();
1: 
1:     /**
1:      * Get the canonical name of the database. This is a name that uniquely identifies it. It is system dependent.
1:      *
1:      * The normal, disk based implementation uses method java.io.File.getCanonicalPath on the directory holding the
1:      * database to construct the canonical name.
1:      *
1:      * @return the canonical name
1:      *
1:      * @exception IOException if an IO error occurred during the construction of the name.
1:      */
1:     public String getCanonicalName() throws IOException;
1:     
1:     /**
1:      * Construct a StorageFile from a path name.
1:      *
1:      * @param path The path name of the file. If null then return the database directory.
1:      *             If this parameter denotes the temp directory or a directory under the temp
1:      *             directory then the resulting StorageFile denotes a temporary file. Otherwise
1:      *             the path must be relative to the database and the resulting StorageFile denotes a
1:      *             regular database file (non-temporary).
1:      *
1:      * @return A corresponding StorageFile object
1:      */
1:     public StorageFile newStorageFile( String path);
1: 
1:     /**
1:      * Construct a non-temporary StorageFile from a directory and file name.
1:      *
1:      * @param directoryName The directory part of the path name. If this parameter denotes the
1:      *                      temp directory or a directory under the temp directory then the resulting
1:      *                      StorageFile denotes a temporary file. Otherwise the directory name must be
1:      *                      relative to the database and the resulting StorageFile denotes a
1:      *                      regular database file (non-temporary).
1:      * @param fileName The name of the file within the directory.
1:      *
1:      * @return A corresponding StorageFile object
1:      */
1:     public StorageFile newStorageFile( String directoryName, String fileName);
1: 
1:     /**
1:      * Construct a StorageFile from a directory and file name. The StorageFile may denote a temporary file
1:      * or a non-temporary database file, depending upon the directoryName parameter.
1:      *
1:      * @param directoryName The directory part of the path name. If this parameter denotes the
1:      *                      temp directory or a directory under the temp directory then the resulting
1:      *                      StorageFile denotes a temporary file. Otherwise the resulting StorageFile denotes a
1:      *                      regular database file (non-temporary).
1:      * @param fileName The name of the file within the directory.
1:      *
1:      * @return A corresponding StorageFile object
1:      */
1:     public StorageFile newStorageFile( StorageFile directoryName, String fileName);
1: 
1:     /**
1:      * Get the pathname separator character used by the StorageFile implementation. This is the
1:      * separator that must be used in directory and file name strings.
1:      *
1:      * @return the pathname separator character. (Normally '/' or '\').
1:      */
1:     public char getSeparator();
1: 
1:     /**
1:      * Get the abstract name of the directory that holds temporary files.
1:      *<p>
1:      * The StorageFactory implementation
1:      * is not required to make temporary files persistent. That is, files created in the temp directory are
1:      * not required to survive a shutdown of the database engine.
1:      *<p>
1:      * However, files created in the temp directory must be writable, <b>even if the database is
1:      * otherwise read-only</b>.
1:      *
1:      * @return a directory name
1:      */
1:     public StorageFile getTempDir();
1: 
1:     /**
1:      * This method is used to determine whether the storage is fast (RAM based) or slow (disk based).
1:      * It may be used by the database engine to determine the default size of the page cache.
1:      *
1:      * @return <b>true</b> if the storage is fast, <b>false</b> if it is slow.
1:      */
1:     public boolean isFast();
1: 
1:     /**
1:      * Determine whether the database is read only. The database engine supports read-only databases, even
1:      * in file systems that are writable.
1:      *
1:      * @return <b>true</b> if the storage is read only, <b>false</b> if it is writable.
1:      */
1:     public boolean isReadOnlyDatabase();
1: 
1:     /**
1:      * Determine whether the storage supports random access. If random access is not supported then
1:      * it will only be accessed using InputStreams and OutputStreams (if the database is writable).
1:      *
1:      * @return <b>true</b> if the storage supports random access, <b>false</b> if it is writable.
1:      */
1:     public boolean supportsRandomAccess();
1: 
1:     /**
1:      * The version number of this version of the StorageFactory interface and its subsidiary interfaces.
1:      */
1:     int VERSION_NUMBER = 1;
1: 
1:     /**
1:      * @return the StorageFactory version supported by this implementation
1:      */
1:     public int getStorageFactoryVersion();
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.io
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.io;
0: 
0: import java.io.IOException;
0: 
0: /**
0:  * This interface provides basic storage functions needed for read only databases. Most storage
0:  * implementations will be read-write and implement the WritableStorageFactory extension of this
0:  * interface.
0:  *
0:  *<p>
0:  * The database engine uses this interface to access storage. The normal database engine
0:  * implements this interface using disk files and the standard java.io classes.
0:  *
0:  *<p>
0:  * The storage factory must implement writable temporary files, even if the database is read-only or
0:  * if the storage factory is read-only (i.e. it does not implement the WritableStorageFactory extension of this
0:  * interface). Temporary files are those created under the temporary file directory. See
0:  * {@link #getTempDir method getTempDir()}.
0:  *
0:  *<p>The database engine can be turned into a RAM based engine by providing a RAM based implementation of this interface.
0:  *
0:  *<p>There is one instance of the StorageFactory per database if the log files are kept in the database directory.
0:  * If the log files are kept on a separate device then a second StorageFactory is instantiated to hold the log files.
0:  * The database or log device name is set when the init method is called.
0:  * The init method is called once per instance, before any other StorageFactory method.
0:  *
0:  *<p>The class implementing this interface must have a public niladic constructor. The init method will be called
0:  * before any other method to set the database directory name, to tell the factory to create the database
0:  * directory if necessary, and to allow the implementation to perform any initializations it requires. The
0:  * database name set in the init method forms a separate name space. Different StorageFactory instances, with
0:  * different database directory names, must ensure that their files do not clash. So, for instance,
0:  * storageFactory1.newStorageFile( "x") must be a separate file from storageFactory2.newStorageFile( "x").
0:  *
0:  *<p>The database engine will call this interface's methods from its own privilege blocks. This does not give
0:  * a StorageFactory implementation carte blanche: a security manager can still forbid the implemeting class from
0:  * executing a privileged action. However, the security manager will not look in the calling stack beyond the
0:  * database engine.
0:  *
0:  *<p>Each StorageFactory instance may be concurrently used by multiple threads. Each StorageFactory implementation
0:  * must be thread safe.
0:  *
0:  *<p>A StorageFactory implementation is plugged into the database engine via a sub-protocol. Sub-protocol <i>xxx</i> is
0:  * tied to a StorageFactory implementation class via the derby.subSubProtocol.<i>xxx</i> system property. So,
0:  * to use StorageFactory implementation class MyStorageFactory with database myDB you would set the system
0:  * property "derby.subSubProtocol.mysf=MyStorageFactory" and use the URL "jdbc:derby:mysf:myDB" to
0:  * connect to the database.
0:  *
0:  * @see WritableStorageFactory
0:  * @see StorageFile
0:  * @see StorageRandomAccessFile
0:  * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/File.html">java.io.File</a>
0:  * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/RandomAccessFile.html">java.io.RandomAccessFile</a>
0:  * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/InputStream.html">java.io.InputStream</a>
0:  * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/OutputStream.html">java.io.OutputStream</a>
0:  */
0: public interface StorageFactory
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
0: 
0:     /**
0:      * Classes implementing the StorageFactory interface must have a null
0:      * constructor.  The init method is called when the database is booted up to
0:      * initialize the class. It should perform all actions necessary to start the
0:      * basic storage, such as creating a temporary file directory.
0:      *
0:      * This method should not create the database directory.
0:      *<p>
0:      * The init method will be called once, before any other method is called, and will not
0:      * be called again.
0:      *
0:      * @param home The name of the directory containing the database. It comes from the system.home system property.
0:      *             It may be null. A storage factory may decide to ignore this parameter. (For instance the classpath
0:      *             storage factory ignores it).
0:      * @param databaseName The name of the database (directory). The name does not include the subsubprotocol.
0:      *                     If null then the storage factory will only be used to deal with the directory containing
0:      *                     the databases.
0:      * @param tempDirName The name of the temporary file directory set in properties. If null then a default
0:      *                    directory should be used. Each database should get a separate temporary file
0:      *                    directory within this one to avoid collisions.
0:      * @param uniqueName A unique name that can be used to create the temporary file directory for this database.
0:      *                   If null then temporary files will not be created in this StorageFactory instance, and the
0:      *                   temporary file directory should not be created.
0:      *
0:      * @exception IOException
0:      */
0:     public void init( String home, String databaseName, String tempDirName, String uniqueName)
0:         throws IOException;
0: 
0:     /**
0:      * The shutdown method is called during the normal shutdown of the database. However, the database
0:      * engine cannot guarantee that shutdown will be called. If the JVM terminates abnormally then it will
0:      * not be called.
0:      */
0:     public void shutdown();
0: 
0:     /**
0:      * Get the canonical name of the database. This is a name that uniquely identifies it. It is system dependent.
0:      *
0:      * The normal, disk based implementation uses method java.io.File.getCanonicalPath on the directory holding the
0:      * database to construct the canonical name.
0:      *
0:      * @return the canonical name
0:      *
0:      * @exception IOException if an IO error occurred during the construction of the name.
0:      */
0:     public String getCanonicalName() throws IOException;
0:     
0:     /**
0:      * Construct a StorageFile from a path name.
0:      *
0:      * @param path The path name of the file. If null then return the database directory.
0:      *             If this parameter denotes the temp directory or a directory under the temp
0:      *             directory then the resulting StorageFile denotes a temporary file. Otherwise
0:      *             the path must be relative to the database and the resulting StorageFile denotes a
0:      *             regular database file (non-temporary).
0:      *
0:      * @return A corresponding StorageFile object
0:      */
0:     public StorageFile newStorageFile( String path);
0: 
0:     /**
0:      * Construct a non-temporary StorageFile from a directory and file name.
0:      *
0:      * @param directoryName The directory part of the path name. If this parameter denotes the
0:      *                      temp directory or a directory under the temp directory then the resulting
0:      *                      StorageFile denotes a temporary file. Otherwise the directory name must be
0:      *                      relative to the database and the resulting StorageFile denotes a
0:      *                      regular database file (non-temporary).
0:      * @param fileName The name of the file within the directory.
0:      *
0:      * @return A corresponding StorageFile object
0:      */
0:     public StorageFile newStorageFile( String directoryName, String fileName);
0: 
0:     /**
0:      * Construct a StorageFile from a directory and file name. The StorageFile may denote a temporary file
0:      * or a non-temporary database file, depending upon the directoryName parameter.
0:      *
0:      * @param directoryName The directory part of the path name. If this parameter denotes the
0:      *                      temp directory or a directory under the temp directory then the resulting
0:      *                      StorageFile denotes a temporary file. Otherwise the resulting StorageFile denotes a
0:      *                      regular database file (non-temporary).
0:      * @param fileName The name of the file within the directory.
0:      *
0:      * @return A corresponding StorageFile object
0:      */
0:     public StorageFile newStorageFile( StorageFile directoryName, String fileName);
0: 
0:     /**
0:      * Get the pathname separator character used by the StorageFile implementation. This is the
0:      * separator that must be used in directory and file name strings.
0:      *
0:      * @return the pathname separator character. (Normally '/' or '\').
0:      */
0:     public char getSeparator();
0: 
0:     /**
0:      * Get the abstract name of the directory that holds temporary files.
0:      *<p>
0:      * The StorageFactory implementation
0:      * is not required to make temporary files persistent. That is, files created in the temp directory are
0:      * not required to survive a shutdown of the database engine.
0:      *<p>
0:      * However, files created in the temp directory must be writable, <b>even if the database is
0:      * otherwise read-only</b>.
0:      *
0:      * @return a directory name
0:      */
0:     public StorageFile getTempDir();
0: 
0:     /**
0:      * This method is used to determine whether the storage is fast (RAM based) or slow (disk based).
0:      * It may be used by the database engine to determine the default size of the page cache.
0:      *
0:      * @return <b>true</b> if the storage is fast, <b>false</b> if it is slow.
0:      */
0:     public boolean isFast();
0: 
0:     /**
0:      * Determine whether the database is read only. The database engine supports read-only databases, even
0:      * in file systems that are writable.
0:      *
0:      * @return <b>true</b> if the storage is read only, <b>false</b> if it is writable.
0:      */
0:     public boolean isReadOnlyDatabase();
0: 
0:     /**
0:      * Determine whether the storage supports random access. If random access is not supported then
0:      * it will only be accessed using InputStreams and OutputStreams (if the database is writable).
0:      *
0:      * @return <b>true</b> if the storage supports random access, <b>false</b> if it is writable.
0:      */
0:     public boolean supportsRandomAccess();
0: 
0:     /**
0:      * The version number of this version of the StorageFactory interface and its subsidiary interfaces.
0:      */
0:     int VERSION_NUMBER = 1;
0: 
0:     /**
0:      * @return the StorageFactory version supported by this implementation
0:      */
0:     public int getStorageFactoryVersion();
0: }
============================================================================