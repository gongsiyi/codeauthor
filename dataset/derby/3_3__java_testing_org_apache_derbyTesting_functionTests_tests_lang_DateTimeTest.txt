1:e260f22: /*
4:e260f22: 
1:e260f22:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.DateTimeTest
1:e260f22: 
1:e260f22:        Licensed to the Apache Software Foundation (ASF) under one
1:e260f22:        or more contributor license agreements.  See the NOTICE file
1:e260f22:        distributed with this work for additional information
1:e260f22:        regarding copyright ownership.  The ASF licenses this file
1:e260f22:        to you under the Apache License, Version 2.0 (the
1:e260f22:        "License"); you may not use this file except in compliance
1:e260f22:        with the License.  You may obtain a copy of the License at
1:e260f22: 
1:e260f22:          http://www.apache.org/licenses/LICENSE-2.0
1:e260f22: 
1:e260f22:        Unless required by applicable law or agreed to in writing,
1:e260f22:        software distributed under the License is distributed on an
1:e260f22:        "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:e260f22:        KIND, either express or implied.  See the License for the
1:e260f22:        specific language governing permissions and limitations
1:e260f22:        under the License
1:e260f22: */
1:e260f22: package org.apache.derbyTesting.functionTests.tests.lang;
1:e260f22: 
1:95ad00d: import java.sql.Date;
1:e260f22: import java.sql.PreparedStatement;
1:e260f22: import java.sql.ResultSet;
1:e260f22: import java.sql.ResultSetMetaData;
1:e260f22: import java.sql.SQLException;
1:e260f22: import java.sql.Statement;
1:95ad00d: import java.sql.Time;
1:95ad00d: import java.sql.Timestamp;
1:95ad00d: import java.util.Calendar;
1:3d03e7d: import java.util.TimeZone;
1:e260f22: import junit.framework.Test;
1:e260f22: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:e260f22: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:e260f22: import org.apache.derbyTesting.junit.JDBC;
1:e260f22: import org.apache.derbyTesting.junit.TestConfiguration;
1:e260f22: 
1:e260f22: /**
1:e260f22:  * Test the builtin date/time types assumes these builtin types 
1:e260f22:  * exist: int, smallint, char, varchar, real other things we might test: 
1:e260f22:  * interaction with UUID and other user defined types 
1:e260f22:  * compatibility with dynamic parameters and JDBC getDate etc. methods.
1:e260f22:  */
1:e260f22: public final class DateTimeTest extends BaseJDBCTestCase {
1:e260f22: 
1:e260f22:     /**
1:e260f22:      * Public constructor required for running test as standalone JUnit.
1:e260f22:      */
1:e260f22:     public DateTimeTest(String name) {
1:e260f22:         super(name);
1:e260f22:     }
1:e260f22: 
1:e260f22:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("DateTimeTest");
1:e260f22:         suite.addTest(baseSuite("DateTimeTest:Embedded"));
1:e260f22:         suite.addTest(TestConfiguration
1:e260f22:                 .clientServerDecorator(baseSuite("DateTimeTest:Client")));
1:e260f22:         return suite;
1:e260f22:     }
1:e260f22: 
1:e260f22:     protected static Test baseSuite(String name) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:e260f22:         suite.addTestSuite(DateTimeTest.class);
1:e260f22:         return new CleanDatabaseTestSetup(suite) {
1:e260f22:             /**
1:e260f22:              * Creates the tables used in the test cases.
1:e260f22:              * @exception SQLException if a database error occurs
1:e260f22:              */
1:e260f22:             protected void decorateSQL(Statement stmt) throws SQLException {
1:e260f22:                 createTableForArithmeticTest(stmt);
1:e260f22:                 createTableForSyntaxTest(stmt);
1:e260f22:                 createTableForConversionTest(stmt);
1:e260f22:                 createTableForISOFormatTest(stmt);
1:e260f22:             }
1:e260f22:         };
1:e260f22:     }
1:e260f22:     
1:e260f22:     private static void createTableForISOFormatTest(Statement st)
1:e260f22:     throws SQLException{
1:e260f22:         st.executeUpdate(" create table ts (ts1 timestamp, ts2 timestamp)");   
1:e260f22:     }
1:e260f22:     
1:e260f22:     
1:e260f22:     private static void createTableForConversionTest(Statement st) throws SQLException{
1:e260f22:         st.executeUpdate(
1:e260f22:                 " create table convtest(d date, t time, ts timestamp)");
1:e260f22:         st.executeUpdate(" insert into convtest values(date('1932-03-21'),  "
1:e260f22:                 + "time('23:49:52'), timestamp('1832-09-24 10:11:43.32'))");
1:e260f22:         st.executeUpdate(" insert into convtest values(date('0001-03-21'),  "
1:e260f22:                 + "time('5:22:59'), timestamp('9999-12-31 23:59:59.999999'))");
1:e260f22:         st.executeUpdate(" insert into convtest values(null, null, null)");
1:e260f22:     }
1:e260f22:     
1:e260f22:     private static void createTableForSyntaxTest(Statement stmt) 
1:e260f22:     throws SQLException{
1:e260f22:         stmt.executeUpdate("create table source (i int, s smallint, c char(10), "
1:e260f22:                 + "v varchar(50), d double precision, r real, e date, "
1:e260f22:                 + "t time, p timestamp)");
1:e260f22: 
1:e260f22:         stmt.executeUpdate(" create table target (e date not null, t time not "
1:e260f22:                 + "null, p timestamp not null)");
1:e260f22:     }
1:e260f22:         
1:e260f22:     private static void createTableForArithmeticTest(Statement stmt)
1:e260f22:     throws SQLException{
1:e260f22:         stmt.executeUpdate("create table t (i int, s smallint, " +
1:e260f22:                 "c char(10), v varchar(50), d double precision," +
1:e260f22:                 " r real, e date, t time, p timestamp)");
1:e260f22: 
1:e260f22:         stmt.executeUpdate(" insert into t values (null, null, " +
1:e260f22:                 "null, null, null, null, null, null, null)");
1:e260f22: 
1:e260f22:         stmt.executeUpdate(" insert into t values (0, 100, 'hello', " +
1:e260f22:                 "'everyone is here', 200.0e0, 300.0e0, " +
1:e260f22:                 "date('1992-01-01'), time('12:30:30'), " +
1:e260f22:                 "timestamp('1992-01-01 12:30:30'))");
1:e260f22: 
1:e260f22:         stmt.executeUpdate(" insert into t values (-1, -100, " +
1:e260f22:                 "'goodbye', 'everyone is there', -200.0e0, " +
1:e260f22:                 "-300.0e0, date('1992-01-01'), time('12:30:30'), " +
1:e260f22:                 "timestamp('1992-01-01 12:30:45'))");
1:e260f22:     }
1:e260f22:     
1:e260f22:     /**
1:e260f22:      * date/times don't support math, show each combination.
1:e260f22:      */
1:e260f22:     public void testArithOpers_math() throws SQLException{
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         assertStatementError("42Y95", st, "select e + e from t");
1:e260f22: 
1:e260f22:         assertStatementError("42Y95", st, " select i + e from t");
1:e260f22: 
1:e260f22:         assertStatementError("42Y95", st, " select p / p from t");
1:e260f22: 
1:e260f22:         assertStatementError("42Y95", st, " select p * s from t");
1:e260f22: 
1:e260f22:         assertStatementError("42Y95", st, " select t - t from t");
1:e260f22: 
1:e260f22:         assertStatementError("42X37", st, " select -t from t");
1:e260f22: 
1:e260f22:         assertStatementError("42X37", st, " select +e from t");
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:79fec78:     
1:e260f22:     public void testArithOpers_Comarision() throws SQLException{
1:e260f22:         ResultSet rs = null;
1:e260f22:         Statement st = createStatement();
1:95ad00d: 
1:e260f22:         rs = st.executeQuery("select e from t where e = date('1992-01-01')");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "E" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "1992-01-01" }, { "1992-01-01" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select e from t where date('1992-01-01') = e");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "E" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "1992-01-01" }, { "1992-01-01" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select t from t where t > time('09:30:15')");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "T" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "12:30:30" }, { "12:30:30" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select t from t where time('09:30:15') < t");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "T" });
1:e260f22:         JDBC.assertFullResultSet(rs,
1:e260f22:                 new String[][] { { "12:30:30" }, { "12:30:30" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(
1:e260f22:                 "select p from t where p < timestamp('1997-06-30 01:01:01')");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "P" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "1992-01-01 12:30:30.0" },
1:e260f22:                 { "1992-01-01 12:30:45.0" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(
1:e260f22:                 "select p from t where timestamp('1997-06-30 01:01:01' )> p");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "P" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "1992-01-01 12:30:30.0" },
1:e260f22:                 { "1992-01-01 12:30:45.0" } }, true);
1:e260f22:         
1:e260f22:         rs = st.executeQuery("select e from t where e >= date('1990-01-01')");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "E" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "1992-01-01" }, { "1992-01-01" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select e from t where date('1990-01-01')<= e");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "E" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "1992-01-01" }, { "1992-01-01" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select t from t where t <= time('09:30:15')");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "T" });
1:e260f22:         JDBC.assertDrainResults(rs, 0);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select t from t where time('09:30:15') >= t");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "T" });
1:e260f22:         JDBC.assertDrainResults(rs, 0);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(
1:e260f22:                 "select p from t where p <> timestamp('1997-06-30 01:01:01')");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "P" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "1992-01-01 12:30:30.0" },
1:e260f22:                 { "1992-01-01 12:30:45.0" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(
1:e260f22:                 "select p from t where timestamp('1997-06-30 01:01:01' )<> p");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "P" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "1992-01-01 12:30:30.0" },
1:e260f22:                 { "1992-01-01 12:30:45.0" } }, true);
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:79fec78:     /**
1:e260f22:      * Show comparisons with mixed types don't work.
1:e260f22:      */
1:e260f22:     public void testArithOpers_CompraionOnMixedTypes() throws SQLException{
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         assertStatementError("42818", st, "select e from t where e <= i");
1:e260f22: 
1:e260f22:         assertStatementError("42818", st, " select e from t where t < s");
1:e260f22: 
1:e260f22:         assertStatementError("42818", st, " select e from t where p > d");
1:e260f22: 
1:e260f22:         assertStatementError("42818", st, " select e from t where e >= t");
1:e260f22: 
1:e260f22:         assertStatementError("42818", st, " select e from t where t <> p");
1:e260f22: 
1:e260f22:         assertStatementError("42818", st, " select e from t where p = e");
1:e260f22: 
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:95ad00d:     /**
1:e260f22:      * Look for a value that isn't in the table.
1:e260f22:      */
1:e260f22:     public void testArithOpers_CompraionOnNotExistingValue() 
1:e260f22:     throws SQLException{
1:e260f22:         ResultSet rs = null;
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         rs = st.executeQuery("select e from t where e <> date('1992-01-01')");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "E" });
1:e260f22:         JDBC.assertDrainResults(rs, 0);
1:e260f22: 
1:e260f22:         rs = st.executeQuery("select e from t where date('1992-01-01') <> e");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "E" });
1:e260f22:         JDBC.assertDrainResults(rs, 0);
1:e260f22: 
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     /**
1:e260f22:      * Show garbage in == errors out
1:e260f22:      */
1:e260f22:     public void testArithOpers_ComparisonOnGarbage() throws SQLException {
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         assertStatementError("22008", st, 
1:e260f22:                 "select date( 'xxxx') from t where p is null");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, 
1:e260f22:                 " select time( '') from t where p is null");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st,
1:e260f22:                 " select timestamp( 'is there anything here?' )from " +
1:e260f22:                 "t where p is null");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st,
1:e260f22:                 " select timestamp( '1992-01- there anything here?')" +
1:e260f22:                 "from t where p is null");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st,
1:e260f22:                 " select timestamp( '--::' )from t where p is null");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, 
1:e260f22:                 " select time('::::') from t where p is null");
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     /**
1:e260f22:      * Check limit values.
1:e260f22:      */
1:e260f22:     public void testArithOpers_ComparisonOnLimits() throws SQLException {
1:e260f22:         ResultSet rs = null;
1:e260f22:         Statement st = createStatement();
1:e260f22: 
1:e260f22:         rs = st.executeQuery("values( date('0001-1-1'), date('9999-12-31'), "
1:e260f22:                 + "date('2/29/2000'), date('29.2.2004'))");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1", "2", "3", "4" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "0001-01-01", 
1:e260f22:                 "9999-12-31", "2000-02-29", "2004-02-29" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" values( time('00:00:00'), time('23:59:59'))");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1", "2" });
1:e260f22:         JDBC.assertFullResultSet(rs,
1:e260f22:                 new String[][] { { "00:00:00", "23:59:59" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" values( time('00 AM'), time( '12:59 AM')," +
1:e260f22:         		" time('1 PM'), time('12:59 PM'))");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1", "2", "3", "4" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "00:00:00", 
1:e260f22:                 "00:59:00", "13:00:00", "12:59:00" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" values( time('00.00.00'), time('23.59.59'), " +
1:e260f22:                 "time('24.00.00'))");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1", "2", "3" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "00:00:00", 
1:e260f22:                 "23:59:59", "00:00:00" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" values( timestamp('0001-1-1 00:00:00'), "
1:e260f22:                 + "timestamp('9999-12-31 23:59:59.999999'))");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1", "2" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { 
1:e260f22:             "0001-01-01 00:00:00.0", "9999-12-31 23:59:59.999999" } }, true);
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     /**
1:e260f22:      * Show that overflow and underflow are not allowed
1:e260f22:      *  (SQL92 would have these report errors).
1:e260f22:      */
1:e260f22:     public void testArithOpers_ComparisonOnBeyondLimits() throws SQLException {
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         assertStatementError("22008", st , "values( date('0000-01-01'))");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st, " values( date('2000-00-01'))");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st, " values( date('2000-01-00'))");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st, " values( date('10000-01-01'))");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st, " values( date('2000-13-01'))");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st, " values( date('2000-01-32'))");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st, " values( date('1900-02-29'))");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st, " values( date('2001-02-29'))");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, " values( time('25.00.00'))");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, " values( time('24.00.01'))");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, " values( time('0:60:00'))");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, " values( time('00:00:60'))");
1:e260f22: 
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     public void testArithOpers_ComparisonOnNullAndNonNull() 
1:e260f22:     throws SQLException {
1:e260f22:         ResultSet rs = null;
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         rs = st.executeQuery("select e, t, p from t " +
1:e260f22:         		"where e = e or t = t or p = p");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "E", "T", "P" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "1992-01-01", 
1:e260f22:                 "12:30:30", "1992-01-01 12:30:30.0" }, { "1992-01-01",
1:e260f22:                 "12:30:30", "1992-01-01 12:30:45.0" } }, true);
1:e260f22:         
1:e260f22:         rs = st.executeQuery("select * from t where e is not null " +
1:e260f22:         		"and t is not " + "null and p is not null");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "I", "S", "C", "V",
1:e260f22:                 "D", "R", "E", "T", "P" });
1:e260f22:         JDBC.assertFullResultSet(rs,  new String[][] {
1:e260f22:                 { "0", "100", "hello", "everyone is here", "200.0", "300.0",
1:e260f22:                     "1992-01-01", "12:30:30", "1992-01-01 12:30:30.0" },
1:e260f22:                 { "-1", "-100", "goodbye", "everyone is there", "-200.0",
1:e260f22:                     "-300.0", "1992-01-01", "12:30:30", 
1:e260f22:                     "1992-01-01 12:30:45.0" } }, true);
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22: 
1:e260f22:     /**
1:e260f22:      * Test =SQ .
1:e260f22:      */
1:e260f22:     public void testArithOpers_ComparisonOnEqualSQ() throws SQLException{
1:e260f22:         ResultSet rs = null;
1:e260f22:         Statement st = createStatement();
1:e260f22: 
1:e260f22:         assertStatementError("21000", st,
1:e260f22:                 "select 'fail' from t where e = (select e from t)");
1:e260f22: 
1:e260f22:         rs = st.executeQuery("select 'pass' from t " +
1:e260f22:         		"where e = (select e from t where d=200)");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs,
1:e260f22:                 new String[][] { { "pass" }, { "pass" } }, true);
1:e260f22: 
1:e260f22:         assertStatementError("21000", st,
1:e260f22:                 "select 'fail' from t where t = (select t from t)");
1:e260f22: 
1:e260f22:         rs = st.executeQuery("select 'pass' from t " +
1:e260f22:         		"where t = (select t from t where d=200)");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "pass" }, { "pass" } }, true);
1:e260f22: 
1:e260f22:         assertStatementError("21000", st,
1:e260f22:                 "select 'fail' from t where p = (select p from t)");
1:e260f22: 
1:e260f22:         rs = st.executeQuery("select 'pass' from t " +
1:e260f22:         		"where p = (select p from t where d=200)");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "pass" } }, true);
1:e260f22: 
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     /**
1:e260f22:      * Test syntax: precision cannot be specified.
1:e260f22:      */
1:e260f22:     public void testSyntax_SpecifiedPrecision() throws SQLException{        
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         assertStatementError("42X01", st , 
1:e260f22:                 "create table wrong (t time(-100))");
1:e260f22: 
1:e260f22:         assertStatementError("42X01", st, 
1:e260f22:                 " create table wrong (t time(0))");
1:e260f22: 
1:e260f22:         assertStatementError("42X01", st, 
1:e260f22:                 " create table wrong (t time(23))");
1:e260f22: 
1:e260f22:         assertStatementError("42X01", st,
1:e260f22:                 " create table wrong (t timestamp(-100))");
1:e260f22: 
1:e260f22:         assertStatementError("42X01", st,
1:e260f22:                 " create table wrong (t timestamp(0))");
1:e260f22: 
1:e260f22:         assertStatementError("42X01", st,
1:e260f22:                 " create table wrong (t timestamp(6))");
1:e260f22: 
1:e260f22:         assertStatementError("42X01", st,
1:e260f22:                 " create table wrong (t timestamp(9))");
1:e260f22: 
1:e260f22:         assertStatementError("42X01", st,
1:e260f22:                 " create table wrong (t timestamp(23))");
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22: 
1:e260f22:     /**
1:e260f22:      * Test a variety of inserts.
1:e260f22:      */
1:e260f22:     public void testSyntax_Insert() throws SQLException{
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         st.executeUpdate("insert into source values (1, 2, '3', '4', 5, 6, "
1:e260f22:                 + "date('1997-07-07'), "
1:e260f22:                 + "time('08:08:08'),timestamp('1999-09-09 09:09:09'))");
1:e260f22:         
1:e260f22:         st.executeUpdate("insert into target select e,t,p from source");
1:e260f22:         
1:e260f22:         //wrong columns should fail
1:e260f22:         assertStatementError("42821", st,
1:e260f22:                 "insert into target select p,e,t from source");
1:e260f22:         
1:e260f22:         assertStatementError("42821", st,
1:e260f22:         " insert into target select i,s,d from source");
1:e260f22: 
1:e260f22:         assertStatementError("42821", st,
1:e260f22:             " insert into target (t,p) select c,r from source");
1:e260f22: 
1:e260f22:         assertUpdateCount(st, 1, " delete from source");
1:e260f22:         
1:e260f22:         
1:e260f22:         st.executeUpdate(" insert into source values (null, null, null, null, "
1:e260f22:                 + "null, null, null, null, null)");
1:e260f22: 
1:e260f22:         // these fail because the target won't take a null -- of any type
1:e260f22:         assertStatementError("23502", st,
1:e260f22:                 "insert into target values(null, null, null)");
1:e260f22: 
1:e260f22:         assertStatementError("23502", st,
1:e260f22:                 " insert into target select e,t,p from source");
1:e260f22:         
1:e260f22:         //these still fail with type errors:
1:e260f22:         assertStatementError("42821", st,
1:e260f22:                 "insert into target select p,e,t from source");
1:e260f22: 
1:e260f22:         assertStatementError("42821", st,
1:e260f22:                 " insert into target select i,s,d from source");
1:e260f22: 
1:e260f22:         assertStatementError("42821", st,
1:e260f22:                 " insert into target (t,p)select c,r from source");
1:e260f22: 
1:e260f22:         //expect 1 row in target.
1:e260f22:         ResultSet rs = st.executeQuery("select * from target");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "E", "T", "P" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { {
1:e260f22:                 "1997-07-07", "08:08:08", "1999-09-09 09:09:09.0" } }, true);
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     /**
1:e260f22:      * Test a variety of updates.
1:e260f22:      */
1:e260f22:     public void testSyntax_Update() throws SQLException{
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         //expect 1 row in target.
1:e260f22:         ResultSet rs = st.executeQuery("select * from target");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "E", "T", "P" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { {
1:e260f22:                 "1997-07-07", "08:08:08", "1999-09-09 09:09:09.0" } }, true);
1:e260f22:         
1:e260f22:         // unchanged:
1:e260f22:         assertUpdateCount(st, 1, "update target set e = e, t = t, p = p");
1:e260f22:         rs = st.executeQuery(" select * from target");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "E", "T", "P" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { 
1:e260f22:                 "1997-07-07", "08:08:08", "1999-09-09 09:09:09.0" } }, true);
1:e260f22: 
1:e260f22:         // alters the row:
1:e260f22:         assertUpdateCount(st, 1, "update target set e = date('1990-01-01')");
1:e260f22:         rs = st.executeQuery(" select * from target");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "E", "T", "P" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { {
1:e260f22:                 "1990-01-01", "08:08:08", "1999-09-09 09:09:09.0" } }, true);
1:e260f22:         
1:e260f22:         //not settable to null
1:e260f22:         assertStatementError("23502", st, "update target set e = null");
1:e260f22:         rs = st.executeQuery(" select * from target");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "E", "T", "P" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { 
1:e260f22:                 "1990-01-01", "08:08:08", "1999-09-09 09:09:09.0" } }, true);
1:e260f22:         
1:e260f22:         // nullable col can be set to null:
1:e260f22:         assertUpdateCount(st, 1, "update source set e = date('1492-10-01')");
1:e260f22:         rs = st.executeQuery(" select e from source");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "E" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "1492-10-01" } }, true);
1:e260f22: 
1:e260f22:         assertUpdateCount(st, 1, " update source set e = null");
1:e260f22:         rs = st.executeQuery(" select e from source");
1:e260f22:         JDBC.assertColumnNames(rs,  new String[] { "E" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1:e260f22:         
1:e260f22:         // these should get type errors
1:e260f22:         assertStatementError("42821", st, "update target set e = 1");
1:e260f22:         assertStatementError("42821", st, " update source set p = 1.4e10");
1:e260f22:         assertStatementError("42821", st,
1:e260f22:                 " update source set i = date('1001-01-01')");
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     public void testSyntax_CurrentFunctions() throws SQLException{
1:e260f22:         ResultSet rs = null;
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         // tests with current functions:
1:e260f22:         assertUpdateCount(st, 1, "delete from source");
1:e260f22:         assertUpdateCount(st, 1, " delete from target");
1:e260f22: 
1:e260f22:         st.executeUpdate(" insert into source values (1, 2, '3', " +
1:e260f22:         		"'4', 5, 6, date('1997-06-07'), time('08:08:08'), " +
1:e260f22:         		"timestamp('9999-09-09 09:09:09'))");
1:e260f22: 
1:e260f22:         // these tests are 'funny' so that the masters won't show 
1:e260f22:         // a diff every time.
1:e260f22:         rs = st.executeQuery("select 'pass' from source where current_date = "
1:e260f22:                 + "current_date and current_time = current_time and "
1:e260f22:                 + "current_timestamp = current_timestamp");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "pass" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select 'pass' from source where current_date > "
1:e260f22:                 + "date('1996-12-31') and current_time <= "
1:e260f22:                 + "time(        '23:59:59') -- may oopsie on leap second days "
1:e260f22:                 + "and current_timestamp <> timestamp( -- this comment "
1:e260f22:                 + "is just more whitespace '1996-12-31 00:00:00')");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });        
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "pass" } }, true);
1:e260f22: 
1:e260f22:         // test with DB2 compatible syntax
1:e260f22:         rs = st.executeQuery("select 'pass' from source where current date = "
1:e260f22:                 + "current date and current time = current time and "
1:e260f22:                 + "current timestamp = current timestamp");
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "pass" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select 'pass' from source where current date > "
1:e260f22:                 + "date('1996-12-31') and current time <= "
1:e260f22:                 + "time(        '23:59:59') -- may oopsie on leap second days "
1:e260f22:                 + "and current timestamp <> timestamp( -- this comment "
1:e260f22:                 + "is just more whitespace '1996-12-31 00:00:00')");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "pass" } }, true);
1:e260f22:     }
1:e260f22:     
1:e260f22:     public void testSyntax_EscapedFunctions() throws SQLException{
1:e260f22:         ResultSet rs = null;
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         //CURRENT_DATE escaped function not supported in DB2 UDB 
1:e260f22:         //CURRENT_TIME escaped function not supported in DB2 UDB
1:e260f22:         assertStatementError("42X01", st, "select 'pass' from source " +
1:e260f22:         		"where current_date = {fn current_date()} " +
1:e260f22:         		"and current_time = {fn current_time()} " +
1:e260f22:         		"and current_timestamp = current_timestamp");
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select 'pass' from source " +
1:e260f22:         		"where current_date = {fn curdate()} " +
1:e260f22:         		"and current_time = {fn curtime()} " +
1:e260f22:         		"and current_timestamp = current_timestamp");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "pass" } }, true);
1:e260f22: 
1:e260f22:         
1:e260f22:         // current_date() and current_time() not valid in DB2. 
1:e260f22:         // curdate() and curtime() are as escaped functions only.
1:e260f22:         assertStatementError("42Y03", st, "values curdate()");
1:e260f22: 
1:e260f22:         assertStatementError("42Y03", st, " values curtime()");
1:e260f22: 
1:e260f22:         assertStatementError("42X01", st, " values current_date()");
1:e260f22: 
1:e260f22:         assertStatementError("42X01", st, " values current_time()");
1:e260f22: 
1:e260f22:         assertStatementError("42X01", st, " values {fn current_date()}");
1:e260f22: 
1:e260f22:         assertStatementError("42X01", st, " values {fn current_time()}");
1:e260f22: 
1:e260f22:         
1:e260f22:         // DB2 UDB compatible test for escaped functions
1:e260f22:         rs = st.executeQuery("select 'pass' from source " +
1:e260f22:         		"where hour(current_time) = {fn hour(current_time)} " +
1:e260f22:         		"and minute(current_time) = {fn minute(current_time)}" +
1:e260f22:         		" and second(current_time) = {fn second(current_time)} " +
1:e260f22:         		"and year(current_date)   = {fn year(current_date)}");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "pass" } }, true);
1:e260f22: 
1:e260f22:         
1:e260f22:         // valid jdbc date and time escaped functions
1:e260f22:         rs = st.executeQuery("values {fn hour('23:38:10')}");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "23" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" values {fn minute('23:38:10')}");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "38" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" values {fn second('23:38:10')}");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "10" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" values {fn year('2004-03-22')}");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "2004" } }, true);
1:e260f22: 
1:e260f22:         
1:e260f22:         // currents do have types, these inserts fail:
1:e260f22:         assertStatementError("42821", st,
1:e260f22:                 "insert into source values (0, 0, '0', '0', 0, 0, "
1:e260f22:                         + "current_time, current_time, current_timestamp)");
1:e260f22: 
1:e260f22:         assertStatementError("42821", st, " insert into source values" +
1:e260f22:         		" (0, 0, '0', '0', 0, 0, current_date, " +
1:e260f22:         		"current_timestamp, current_timestamp)");
1:e260f22: 
1:e260f22:         assertStatementError("42821", st,
1:e260f22:                 " insert into source values (0, 0, '0', '0', 0, 0, "
1:e260f22:                         + "current_date, current_time, current_date)");
1:e260f22: 
1:e260f22:         // this insert works
1:e260f22:         st.executeUpdate("insert into source values (0, 0, '0', '0', 0, 0, "
1:e260f22:                 + "current_date, current_time, current_timestamp)");
1:e260f22: 
1:e260f22:         // test with DB2 syntax this insert works
1:e260f22:         st.executeUpdate("insert into source values (0, 0, '0', '0', 0, 0, "
1:e260f22:                 + "current date, current time, current timestamp)");
1:e260f22: 
1:e260f22:         // this test will diff if the select is run just after 
1:e260f22:         // midnight, and the insert above was run just before 
1:e260f22:         // midnight...
1:e260f22:         rs = st.executeQuery("select * from source " +
1:e260f22:         		"where e <> current_date and p <> current_timestamp");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "I", "S", "C", "V", "D", 
1:e260f22:                 "R", "E", "T", "P" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "1", "2", 
1:e260f22:             "3", "4", "5.0", "6.0", "1997-06-07", "08:08:08",
1:e260f22:             "9999-09-09 09:09:09.0" } }, true);
1:e260f22: 
1:e260f22:         
1:e260f22:         // test with DB2 syntax
1:e260f22:         rs = st.executeQuery("select * from source " +
1:e260f22:         		"where e <> current date and p <> current timestamp");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "I", "S", "C", "V", 
1:e260f22:                 "D", "R", "E", "T", "P" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "1", "2", "3",
1:e260f22:             "4", "5.0", "6.0", "1997-06-07", "08:08:08", 
1:e260f22:             "9999-09-09 09:09:09.0" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select 'pass' from source " +
1:e260f22:         		"where e <= current_date and p <= current_timestamp");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "pass" }, { "pass" } }, true);
1:e260f22: 
1:e260f22:         // reduce it back to one row
1:e260f22:         assertUpdateCount(st, 2, "delete from source where i=0");
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     public void testSyntax_Extract() throws SQLException{
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         ResultSet rs = st.executeQuery("select year( e), month( e), day( date( "
1:e260f22:                 + "'1997-01-15')), hour( t), minute( t), second( time( "
1:e260f22:                 + "'01:01:42')), year( p), month( p), day( p), hour( "
1:e260f22:                 + "timestamp( '1992-01-01 14:11:23')), minute( p), "
1:e260f22:                 + "second( p) from source");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1", "2", "3", "4", 
1:e260f22:                 "5", "6", "7", "8", "9", "10", "11", "12" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "1997", "6", "15", 
1:e260f22:             "8", "8", "42", "9999", "9", "9", "14", "9", "9.0" } }, true);
1:e260f22: 
1:e260f22:         // extract won't work on other types
1:e260f22:         assertStatementError("42X25", st, "select month( i) from source");
1:e260f22: 
1:e260f22:         assertStatementError("42X25", st, " select hour( d) from source");
1:e260f22: 
1:e260f22:         // extract won't work on certain field/type combos
1:e260f22:         assertStatementError("42X25", st, "select month( t) from source");
1:e260f22: 
1:e260f22:         assertStatementError("42X25", st, " select day( t) from source");
1:e260f22: 
1:e260f22:         assertStatementError("42X25", st, " select year( t) from source");
1:e260f22: 
1:e260f22:         assertStatementError("42X25", st, " select hour( e) from source");
1:e260f22: 
1:e260f22:         assertStatementError("42X25", st, " select minute( e) from source");
1:e260f22: 
1:e260f22:         assertStatementError("42X25", st, " select second( e) from source");
1:e260f22: 
1:e260f22:         assertUpdateCount(st, 1,
1:e260f22:                 " update source set i=month( e), s=minute( t), d=second( p)");
1:e260f22: 
1:e260f22:         // should be true and atomics should match field named as 
1:e260f22:         // label in date/times
1:e260f22:         rs = st.executeQuery("select i,e as \"month\",s,t " +
1:e260f22:                 "as \"minute\",d,p as \"second\" from source " +
1:e260f22:                 "where (i = month(e)) and (s = minute(t)) " +
1:e260f22:                 "and (d = second(p))");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "I", "month", 
1:e260f22:                 "S", "minute", "D", "second" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "6", "1997-06-07", 
1:e260f22:                 "8", "08:08:08", "9.0", "9999-09-09 09:09:09.0" } }, true);
1:e260f22: 
1:e260f22:         // fields should match the fields in the date (in order)
1:e260f22:         rs = st.executeQuery("select p, year( p) as \"year\", month( p) as "
1:e260f22:                 + "\"month\", day( p) as \"day\", hour( p) as "
1:e260f22:                 + "\"hour\", minute( p) as \"minute\", second( p) as "
1:e260f22:                 + "\"second\" from source");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "P", "year", "month", 
1:e260f22:                 "day", "hour", "minute", "second" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { 
1:e260f22:             "9999-09-09 09:09:09.0", "9999", "9", "9",
1:e260f22:             "9", "9", "9.0" } }, true);
1:e260f22: 
1:e260f22:         
1:e260f22:         // jdbc escape sequences
1:e260f22:         rs = st.executeQuery("values ({d '1999-01-12'}, {t '11:26:35'}, {ts "
1:e260f22:                 + "'1999-01-12 11:26:51'})");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1", "2", "3" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "1999-01-12", 
1:e260f22:                 "11:26:35", "1999-01-12 11:26:51.0" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" values year( {d '1999-01-12'})");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "1999" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" values hour( {t '11:28:10'})");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "11" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" values day( {ts '1999-01-12 11:28:23'})");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "12" } }, true);
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     /**
1:e260f22:      * Random tests for date.
1:e260f22:      */
1:e260f22:     public void testRandom() throws SQLException{        
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         st.executeUpdate("create table sertest(d date, s Date, o Date)");
1:e260f22:         st.executeUpdate(" insert into sertest values (date('1992-01-03'), " +
1:e260f22:         		"null, null)");
1:e260f22:         
1:e260f22:         ResultSet rs = st.executeQuery(" select * from sertest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "D", "S", "O" });
1:e260f22:         JDBC.assertFullResultSet(rs,
1:e260f22:                 new String[][] { { "1992-01-03", null, null } }, true);
1:e260f22:         
1:e260f22:         assertUpdateCount(st, 1, " update sertest set s=d");
1:e260f22:         assertUpdateCount(st, 1, " update sertest set o=d");
1:e260f22:         st.executeUpdate(" insert into sertest values (date( '3245-09-09'), "
1:e260f22:                 + "date( '1001-06-07'), date( '1999-01-05'))");
1:e260f22:         
1:e260f22:         rs = st.executeQuery(" select * from sertest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "D", "S", "O" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "1992-01-03", 
1:e260f22:                 "1992-01-03", "1992-01-03" }, { "3245-09-09", "1001-06-07", 
1:e260f22:                     "1999-01-05" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select * from sertest where d > s");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "D", "S", "O" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "3245-09-09", 
1:e260f22:                 "1001-06-07", "1999-01-05" } }, true);
1:e260f22: 
1:e260f22:         assertUpdateCount(st, 2, " update sertest set d=s");
1:e260f22: 
1:e260f22:         // should get type errors:
1:e260f22:         assertStatementError("42821", st,
1:e260f22:                 "insert into sertest values (date('3245-09-09'), "
1:e260f22:                         + "time('09:30:25'), null)");
1:e260f22: 
1:e260f22:         assertStatementError("42821", st,
1:e260f22:                 " insert into sertest values (null, null, time('09:30:25'))");
1:e260f22: 
1:e260f22:         assertStatementError("42821", st,
1:e260f22:                 " insert into sertest values (null, null, "
1:e260f22:                         + "timestamp('1745-01-01 09:30:25'))");
1:e260f22: 
1:e260f22:         assertUpdateCount(st, 2, "update sertest set d=o");
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select * from sertest where s is null " +
1:e260f22:         		"and o is not null");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "D", "S", "O" });
1:e260f22:         JDBC.assertDrainResults(rs, 0);
1:e260f22: 
1:e260f22:         rs = st.executeQuery("select month(s) from sertest " +
1:e260f22:         		"where s is not null");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "1" }, { "6" } },
1:e260f22:                 true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select day(o) from sertest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "3" }, { "5" } }, 
1:e260f22:                 true);
1:e260f22: 
1:e260f22:         dropTable("sertest");
1:e260f22:     }
1:e260f22:     
1:e260f22:     public void testConvertFromString() throws SQLException{        
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         st.executeUpdate("create table convstrtest(d varchar(30), t char(30), "
1:e260f22:                 + "ts long varchar)");
1:e260f22:         st.executeUpdate(" insert into convstrtest values('1932-03-21',  "
1:e260f22:                 + "'23:49:52', '1832-09-24 10:11:43.32')");
1:e260f22:         st.executeUpdate(" insert into convstrtest values(null, null, null)");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st,
1:e260f22:                 "select CAST (d AS time) from convstrtest");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st,
1:e260f22:                 " select CAST (t AS date) from convstrtest");
1:e260f22: 
1:e260f22:         assertStatementError("42846", st,
1:e260f22:                 " select CAST (ts AS time) from convstrtest");
1:e260f22: 
1:e260f22:         assertStatementError("42846", st,
1:e260f22:                 " select CAST (ts AS date) from convstrtest");
1:e260f22: 
1:e260f22: 
1:e260f22:         ResultSet rs = st.executeQuery("select CAST (t AS time) from convstrtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "23:49:52" }, 
1:e260f22:                 { null } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select CAST (d AS date) from convstrtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "1932-03-21" }, { null } }, true);
1:e260f22: 
1:e260f22:         // show time and date separately as timestamp will be 
1:e260f22:         // filtered out
1:e260f22:         assertStatementError("42846", st, "select " +
1:e260f22:                 "CAST(CAST (ts AS timestamp) AS date), " +
1:e260f22:                 "CAST(CAST (ts AS timestamp) AS time) from convstrtest");
1:e260f22: 
1:e260f22:         dropTable("convstrtest");
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22: 
1:e260f22:     /**
1:3d03e7d:      * Test that conversion from timestamp to string is correct when a
1:3d03e7d:      * calendar is specified. Specifically, verify that the full nanosecond
1:3d03e7d:      * resolution is used and that the converted timestamp is not rounded to
1:3d03e7d:      * microsecond resolution. Regression test case for DERBY-4626.
1:3d03e7d:      */
1:3d03e7d:     public void testConvertToStringWithCalendar() throws SQLException {
1:3d03e7d:         PreparedStatement ps =
1:3d03e7d:                 prepareStatement("values cast(? as varchar(29))");
1:3d03e7d: 
1:3d03e7d:         // Generate a timestamp representing 2010-09-01 20:31:40.123456789 GMT
1:3d03e7d:         Timestamp ts = new Timestamp(1283373100000L);
1:3d03e7d:         ts.setNanos(123456789);
1:3d03e7d: 
1:3d03e7d:         // Array of (timezone, timestamp string) pairs representing a timezone
1:3d03e7d:         // with which to test and the expected timestamp string produced.
1:3d03e7d:         String[][] testData = {
1:3d03e7d:             { "GMT", "2010-09-01 20:31:40.123456789" },
1:3d03e7d:             { "Europe/Oslo", "2010-09-01 22:31:40.123456789" },
1:3d03e7d:         };
1:3d03e7d: 
1:3d03e7d:         for (int i = 0; i < testData.length; i++) {
1:3d03e7d:             Calendar cal = Calendar.getInstance(
1:3d03e7d:                     TimeZone.getTimeZone(testData[i][0]));
1:3d03e7d:             ps.setTimestamp(1, ts, cal);
1:3d03e7d:             JDBC.assertSingleValueResultSet(ps.executeQuery(), testData[i][1]);
1:3d03e7d:         }
1:3d03e7d:     }
1:3d03e7d: 
1:3d03e7d:     /**
1:95ad00d:      * Regression test case for DERBY-4621, which caused the conversion of
1:95ad00d:      * timestamp and time values to varchar to generate wrong results when
1:95ad00d:      * a Calendar object was supplied.
1:95ad00d:      */
1:95ad00d:     public void testConversionToString() throws SQLException {
1:95ad00d:         String timestampString = "2010-04-20 15:17:36.0";
1:95ad00d:         String timeString = "15:17:36";
1:95ad00d:         String dateString = "2010-04-20";
1:95ad00d: 
1:95ad00d:         Timestamp ts = Timestamp.valueOf(timestampString);
1:95ad00d:         Time t = Time.valueOf(timeString);
1:95ad00d:         Date d = Date.valueOf(dateString);
1:95ad00d: 
1:95ad00d:         PreparedStatement ps =
1:95ad00d:                 prepareStatement("VALUES CAST(? AS VARCHAR(40))");
1:95ad00d: 
1:95ad00d:         ps.setTimestamp(1, ts);
1:95ad00d:         JDBC.assertSingleValueResultSet(ps.executeQuery(), timestampString);
1:95ad00d: 
1:95ad00d:         // Used to give wrong result - 2010-04-20 03:17:36
1:95ad00d:         ps.setTimestamp(1, ts, Calendar.getInstance());
1:95ad00d:         JDBC.assertSingleValueResultSet(ps.executeQuery(), timestampString);
1:95ad00d: 
1:95ad00d:         ps.setTime(1, t);
1:95ad00d:         JDBC.assertSingleValueResultSet(ps.executeQuery(), timeString);
1:95ad00d: 
1:95ad00d:         // Used to give wrong result - 03:17:36
1:95ad00d:         ps.setTime(1, t, Calendar.getInstance());
1:95ad00d:         JDBC.assertSingleValueResultSet(ps.executeQuery(), timeString);
1:95ad00d: 
1:95ad00d:         ps.setDate(1, d);
1:95ad00d:         JDBC.assertSingleValueResultSet(ps.executeQuery(), dateString);
1:95ad00d: 
1:95ad00d:         ps.setDate(1, d, Calendar.getInstance());
1:95ad00d:         JDBC.assertSingleValueResultSet(ps.executeQuery(), dateString);
1:95ad00d:     }
1:28e7078: 
1:28e7078:     /**
1:28e7078:      * Test that trailing zeros in the nanoseconds component of a timestamp
1:28e7078:      * are handled the same way by
1:28e7078:      * {@code PreparedStatement.setTimestamp(int,Timestamp)} and
1:28e7078:      * {@code PreparedStatement.setTimestamp(int,Timestamp, Calendar)}
1:28e7078:      * when converting the timestamp to a VARCHAR. (DERBY-4810)
1:28e7078:      */
1:28e7078:     public void testTrailingZeros() throws SQLException {
1:28e7078:         PreparedStatement ps =
1:28e7078:                 prepareStatement("values cast(? as varchar(29))");
1:28e7078: 
1:28e7078:         String[] tsStrings = {
1:28e7078:             "2010-09-22 14:40:33.000000000",
1:28e7078:             "2010-09-22 14:40:33.012000000",
1:28e7078:             "2010-09-22 14:40:33.123456000",
1:28e7078:             "2010-09-22 14:40:33.139990900",
1:28e7078:             "2010-09-22 14:40:33.139990983",
1:28e7078:         };
1:28e7078: 
1:28e7078:         for (int i = 0; i < tsStrings.length; i++) {
1:28e7078:             Timestamp ts = Timestamp.valueOf(tsStrings[i]);
1:28e7078: 
1:28e7078:             // We expect the converted value to have the same format as
1:28e7078:             // what Timestamp.toString() returns.
1:28e7078:             String expected = ts.toString();
1:28e7078: 
1:28e7078:             ps.setTimestamp(1, ts);
1:28e7078:             JDBC.assertSingleValueResultSet(ps.executeQuery(), expected);
1:28e7078: 
1:28e7078:             ps.setTimestamp(1, ts, Calendar.getInstance());
1:28e7078:             JDBC.assertSingleValueResultSet(ps.executeQuery(), expected);
1:28e7078:         }
1:28e7078:     }
1:28e7078: 
1:e260f22:     public void testConversion_Aggregates() throws SQLException{
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         //test aggregates sum should fail
1:e260f22:         assertStatementError("42Y22", st, "select sum(d) from convtest");
1:e260f22: 
1:e260f22:         assertStatementError("42Y22", st, " select sum(t) from convtest");
1:e260f22: 
1:e260f22:         assertStatementError("42Y22", st, " select sum(ts) from convtest");
1:e260f22: 
1:e260f22:         // these should work
1:e260f22:         ResultSet rs = st.executeQuery("select count(d) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "2" }, }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select count(t) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "2" }, }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select count(ts) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "2" }, }, true);
1:e260f22: 
1:e260f22:         st.executeUpdate(" insert into convtest values(date('0001-03-21'),  "
1:e260f22:                 + "time('5:22:59'), timestamp('9999-12-31 23:59:59.999999'))");
1:e260f22: 
1:e260f22:         // distinct count should be 2 not 3
1:e260f22:         rs = st.executeQuery("select count(distinct d) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "2" }, }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select count(distinct t) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "2" }, }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select count(distinct ts) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "2" }, }, true);
1:e260f22: 
1:e260f22:         // min should not be null!!!!!!!!
1:e260f22:         rs = st.executeQuery("select min(d) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "0001-03-21" }, }, 
1:e260f22:                 true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select min(t) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "05:22:59" }, }, true);
1:e260f22: 
1:e260f22:         // show time and date separately as timestamp will be 
1:e260f22:         // filtered out
1:e260f22:         rs = st.executeQuery("select " +
1:e260f22:                 "CAST(CAST (min(ts) AS timestamp) AS date), " +
1:e260f22:                 "CAST(CAST (min(ts) AS timestamp) AS time) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1", "2" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "1832-09-24", 
1:e260f22:             "10:11:43" }, }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select max(d) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "1932-03-21" }, }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select max(t) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs,
1:e260f22:                 new String[][] { { "23:49:52" }, }, true);
1:e260f22: 
1:e260f22:         // show time and date separately as timestamp will be 
1:e260f22:         // filtered out
1:e260f22:         rs = st.executeQuery("select " +
1:e260f22:                 "CAST(CAST (max(ts) AS timestamp) AS date), " +
1:e260f22:                 "CAST(CAST (max(ts) AS timestamp) AS time) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1", "2" });
1:e260f22:         JDBC.assertFullResultSet(rs,
1:e260f22:                 new String[][] { { "9999-12-31", "23:59:59" }, }, true);
1:e260f22:         
1:e260f22:         //just to recover the test environment
1:e260f22:         dropTable("convtest");
1:e260f22:         createTableForConversionTest(st);
1:e260f22: 
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     public void testConversion() throws SQLException{        
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         // these should fail
1:e260f22:         assertStatementError("42846", st, 
1:e260f22:                 "select CAST (d AS time) from convtest");
1:e260f22: 
1:e260f22:         assertStatementError("42846", st,
1:e260f22:                 " select CAST (t AS date) from convtest");
1:e260f22: 
1:e260f22:         // these should work
1:e260f22:         ResultSet rs = st.executeQuery(
1:e260f22:                 "select CAST (t AS time) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "23:49:52" }, 
1:e260f22:                 { "05:22:59" }, { null } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select CAST (d AS date) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "1932-03-21" },
1:e260f22:                 { "0001-03-21" }, { null } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select CAST (ts AS time) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "10:11:43" }, 
1:e260f22:                 { "23:59:59" }, { null } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select CAST (ts AS date) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "1832-09-24" }, 
1:e260f22:                 { "9999-12-31" }, { null } }, true);
1:e260f22: 
1:e260f22:         // show time and date separately as timestamp will be 
1:e260f22:         // filtered out
1:e260f22:         rs = st.executeQuery("select CAST(CAST (ts AS timestamp) AS date), " +
1:e260f22:         		"CAST(CAST (ts AS timestamp) AS time) from convtest");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1", "2" });
1:e260f22: 
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "1832-09-24", 
1:e260f22:                 "10:11:43" }, { "9999-12-31", "23:59:59" }, 
1:e260f22:                 { null, null } }, true);
1:e260f22: 
1:e260f22:         // casting from a time to a timestamp sets the date to 
1:e260f22:         // current date
1:e260f22:         assertStatementError("42846", st, "select 'pass', " +
1:e260f22:         		"CAST (CAST(t AS timestamp) AS time) from convtest " +
1:e260f22:         		"where CAST(CAST(t AS timestamp) AS date)=current_date");
1:e260f22: 
1:e260f22:         // time should be 0
1:e260f22:         assertStatementError("42846", st, "select " +
1:e260f22:         		"CAST (CAST (d AS timestamp) AS date), " +
1:e260f22:         		"CAST(CAST(d AS timestamp) AS time) from convtest");
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     /**
1:e260f22:      * leading zeros may be omitted from the month, 
1:e260f22:      * day and part of the timestamp.
1:e260f22:      */
1:e260f22:     public void testISOFormat_OmitLeadingZero() throws SQLException{
1:e260f22:         Statement st = createStatement();
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(
1:e260f22:                 "insert into ts values ('2003-03-05-17.05.43.111111', " +
1:e260f22:                 "'2003-03-05 17:05:43.111111')"));
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:e260f22:         		"('2003-3-03-17.05.43.111111', '2003-3-03 17:05:43.111111')"));
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:e260f22:         		"('2003-3-2-17.05.43.111111', '2003-3-2 17:05:43.111111')"));
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:e260f22:         		"('2003-03-2-17.05.43.111111', '2003-03-2 17:05:43.111111')"));
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:e260f22:         		"('2003-3-1-17.05.43.1', '2003-3-1 17:05:43.1')"));
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:e260f22:         		"('2003-3-1-17.05.43.12', '2003-3-1 17:05:43.12')"));
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:e260f22:         		"('2003-3-1-17.05.43.123', '2003-3-1 17:05:43.123')"));
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:e260f22:         		"('2003-3-1-17.05.43.1234', '2003-3-1 17:05:43.1234')"));
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:e260f22:         		"('2003-3-1-17.05.43.12345', '2003-3-1 17:05:43.12345')"));
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:e260f22:         		"('2003-3-1-17.05.43.123456', '2003-3-1 17:05:43.123456')"));
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:e260f22:         		"('2003-3-1-17.05.43', '2003-3-1 17:05:43')"));
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }    
1:e260f22:     
1:e260f22:     /**
1:e260f22:      *Trailing blanks are allowed.
1:e260f22:      */
1:e260f22:     public void testISOFormat_TrailingBlanks() throws SQLException{
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         assertEquals(1, st.executeUpdate("insert into ts values " +
1:e260f22:         		"('2002-03-05-17.05.43.111111  ', " +
1:e260f22:         		"'2002-03-05 17:05:43.111111   ')"));
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:e260f22:         		"('2002-03-05-17.05.43.1   ', '2002-03-05 17:05:43.1   ')"));
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:e260f22:         		"('2002-03-05-17.05.43    ', '2002-03-05 17:05:43    ')"));
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     /**
1:e260f22:      *  UDB allows this by "appending a zero"; so, cloudscape follows.
1:e260f22:      */
1:e260f22:     public void testISOFormat_TrailingZero() throws SQLException{
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         assertEquals(1, st.executeUpdate("insert into ts values " +
1:e260f22:         		"('2003-3-1-17.05.43.', '2003-3-1 17:05:43')"));
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:e260f22:         		"('2003-3-1-17.05.43.0', '2003-3-1 17:05:43.0')"));
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:e260f22:         		"('0003-03-05-17.05.43.111111'," +
1:e260f22:         		" '0003-03-05 17:05:43.111111')"));
1:e260f22:         
1:e260f22:         ResultSet rs = st.executeQuery(" select count(*) from ts " +
1:e260f22:         		"where ts1=ts2");
1:e260f22:         rs.next();
1:e260f22:         int rows = rs.getInt(1);
1:e260f22:         rs = st.executeQuery(" select count(*) from ts ");
1:e260f22:         rs.next();
1:e260f22:         assertEquals(rows, rs.getInt(1));
1:e260f22:         
1:e260f22:         st.executeUpdate(" delete from ts");
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     /**
1:e260f22:      * Should be rejected because leading zero in year is missing.
1:e260f22:      */
1:e260f22:     public void testISOFormat_LeadingZero() throws SQLException{
1:e260f22:         Statement st = createStatement();
1:e260f22:                 
1:e260f22:         assertStatementError("22007", st,
1:e260f22:                 "insert into ts (ts1) values ('03-03-05-17.05.43.111111')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st,
1:e260f22:                 " insert into ts (ts1) values ('103-03-05-17.05.43.111111')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st,
1:e260f22:                 " insert into ts (ts1) values ('3-03-05-17.05.43.111111')");
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     /**
1:e260f22:      * not valid Time format in the timestamp strings:  cloudscape rejects
1:e260f22:      */
1:e260f22:     public void testISOFormat_WrongTimestampFormat() throws SQLException{
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         assertStatementError("22007", st,
1:e260f22:                 "insert into ts (ts1) values ('2003-3-24-13.1.02.566999')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st,
1:e260f22:                 " insert into ts (ts1) values ('2003-3-24-13.1.1.569')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st,
1:e260f22:                 " insert into ts (ts1) values ('2003-3-24-1.1.1.56')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st,
1:e260f22:                 " insert into ts (ts1) values ('2003-3-24-1.1.1')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st,
1:e260f22:                 " insert into ts (ts1) values ('2003-3-1-17.05.4.')");
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(" insert into ts (ts1) values " +
1:e260f22:         		"('2003-03-05-7.05.43.111111')"));
1:e260f22: 
1:e260f22:         // invalid ISO format: cloudscape rejects
1:e260f22: 
1:e260f22:         assertStatementError("22007", st,
1:e260f22:                 "insert into ts (ts1) values ('2003-3-1 17.05.43.123456')");
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     /**
1:c13beb1:      * Don't allow more than nanoseconds in ISO format.
1:e260f22:      */
1:c13beb1:     public void testISOFormat_MoreThanNanoseconds() throws SQLException{
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         assertStatementError("22007", st, "insert into ts (ts1) values "
1:c13beb1:                 + "('2003-03-05-17.05.43.999999999999')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, " insert into ts (ts1) values "
1:c13beb1:                 + "('2003-03-05-17.05.43.999999999000')");
1:e260f22: 
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     /**
1:e260f22:      * Test the timestamp( d, t) function.
1:e260f22:      */
1:e260f22:     public void testTimeStampFunction() throws SQLException{
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         st .executeUpdate("create table tt " +
1:e260f22:         		"(datecol date, dateStr varchar(16), timecol time, " +
1:e260f22:         		"timeStr varchar(16), expected timestamp)");
1:e260f22: 
1:e260f22:         st.executeUpdate(" insert into tt ( dateStr, timeStr) " +
1:e260f22:         		"values( '2004-03-04', '12:01:02')");
1:e260f22: 
1:e260f22:         st.executeUpdate(" insert into tt ( dateStr, timeStr) " +
1:e260f22:         		"values( null, '12:01:03')");
1:e260f22: 
1:e260f22:         st.executeUpdate(" insert into tt ( dateStr, timeStr) " +
1:e260f22:         		"values( '2004-03-05', null)");
1:e260f22: 
1:e260f22:         assertUpdateCount(st, 3, " update tt  set datecol = date( dateStr), " +
1:e260f22:         		"timecol = time( timeStr)");
1:e260f22: 
1:e260f22:         assertUpdateCount(st, 1, " update tt  set expected = " +
1:e260f22:         		"timestamp( dateStr || ' ' || timeStr) " +
1:e260f22:         		"where dateStr is not null and timeStr is not null");
1:e260f22: 
1:e260f22:         ResultSet rs = st.executeQuery(" select dateStr, timeStr from tt " +
1:e260f22:         		"where (expected is not null and (expected <> " +
1:e260f22:         		"timestamp( dateCol, timeCol) or " +
1:e260f22:         		"timestamp( dateCol, timeCol) is null)) or " +
1:e260f22:         		"(expected is null and " +
1:e260f22:         		"timestamp( dateCol, timeCol) is not null)");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "DATESTR", "TIMESTR" });
1:e260f22:         JDBC.assertDrainResults(rs, 0);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select dateStr, timeStr from tt " +
1:e260f22:         		"where (expected is not null and (expected <> " +
1:e260f22:         		"timestamp( dateStr, timeStr) or " +
1:e260f22:         		"timestamp( dateStr, timeStr) is null)) " +
1:e260f22:         		"or (expected is null and " +
1:e260f22:         		"timestamp( dateStr, timeStr) is not null)");
1:e260f22: 
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "DATESTR", "TIMESTR" });
1:e260f22:         JDBC.assertDrainResults(rs, 0);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select dateStr, timeStr from tt " +
1:e260f22:         		"where (expected is not null and " +
1:e260f22:         		"timestamp( dateStr, timeStr) <> timestamp( dateCol, timeCol))" +
1:e260f22:         		" or (expected is null and " +
1:e260f22:         		"timestamp( dateStr, timeStr) is not null)");
1:e260f22: 
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "DATESTR", "TIMESTR" });
1:e260f22:         JDBC.assertDrainResults(rs, 0);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select dateStr, timeStr from tt " +
1:e260f22:         		"where expected is not null and " +
1:e260f22:         		"date( timestamp( dateCol, timeCol)) <> dateCol");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "DATESTR", "TIMESTR" });
1:e260f22:         JDBC.assertDrainResults(rs, 0);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select dateStr, timeStr from tt " +
1:e260f22:         		"where expected is not null and " +
1:e260f22:         		"time( timestamp( dateCol, timeCol)) <> timeCol");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "DATESTR", "TIMESTR" });
1:e260f22:         JDBC.assertDrainResults(rs, 0);
1:e260f22: 
1:e260f22:         // Error cases
1:e260f22:         assertStatementError("42Y95", st,
1:e260f22:                 "select timestamp( dateCol, dateCol) from tt where "
1:e260f22:                         + "dateCol is not null");
1:e260f22: 
1:e260f22:         assertStatementError("42Y95", st,
1:e260f22:                 " select timestamp( timeCol, timeCol) from tt where "
1:e260f22:                         + "timeCol is not null");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st,
1:e260f22:                 "values timestamp( 'xyz', '12:01:02')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st,
1:e260f22:                 " values timestamp( '2004-03-04', 'xyz')");
1:e260f22: 
1:e260f22:         dropTable("tt");
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     public void testFormat() throws SQLException{
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         st.executeUpdate(" create table t_format (t time)");
1:e260f22: 
1:e260f22:         // ISO format: UDB is okay.
1:e260f22:         assertEquals(1, 
1:e260f22:                 st.executeUpdate("insert into t_format values ('17.05.44')"));
1:e260f22: 
1:e260f22:         assertEquals(1, 
1:e260f22:                 st.executeUpdate(" insert into t_format values ('17.05.00')"));
1:e260f22: 
1:e260f22:         assertEquals(1, 
1:e260f22:                 st.executeUpdate(" insert into t_format values ('00.05.43')"));
1:e260f22: 
1:e260f22:         assertEquals(1, 
1:e260f22:                 st.executeUpdate(" insert into t_format values ('00.00.00')"));
1:e260f22: 
1:e260f22:         // DB2 keeps '24:00:00' but Cloudcape returns '00:00:00'
1:e260f22:         assertEquals(1, 
1:e260f22:                 st.executeUpdate("insert into t_format values ('24.00.00')"));
1:e260f22: 
1:e260f22:         // trailing blanks are allowed
1:e260f22:         assertEquals(1, 
1:e260f22:                 st.executeUpdate("insert into t_format values ('17.05.11  ')"));
1:e260f22: 
1:e260f22:         assertEquals(1, 
1:e260f22:                 st.executeUpdate(" insert into t_format values ('17:05:11  ')"));
1:e260f22: 
1:e260f22:         // seconds can be omitted
1:e260f22:         assertEquals(1, 
1:e260f22:                 st.executeUpdate("insert into t_format values ('1:01')"));
1:e260f22: 
1:e260f22:         assertEquals(1, 
1:e260f22:                 st.executeUpdate(" insert into t_format values ('1:02 ')"));
1:e260f22: 
1:e260f22:         assertEquals(1, 
1:e260f22:                 st.executeUpdate(" insert into t_format values ('2.01')"));
1:e260f22: 
1:e260f22:         assertEquals(1, 
1:e260f22:                 st.executeUpdate(" insert into t_format values ('2.02 ')"));
1:e260f22: 
1:e260f22:         // 11 rows
1:e260f22:         ResultSet rs = st.executeQuery("select * from t_format");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "T" });
1:e260f22: 
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "17:05:44" }, { "17:05:00" },
1:e260f22:                 { "00:05:43" }, { "00:00:00" }, { "00:00:00" }, { "17:05:11" },
1:e260f22:                 { "17:05:11" }, { "01:01:00" }, { "01:02:00" }, { "02:01:00" },
1:e260f22:                 { "02:02:00" } }, true);
1:e260f22:         assertUpdateCount(st, 11, " delete from t_format");
1:e260f22: 
1:e260f22:         // end value tests...
1:e260f22:         assertStatementError("22007", st, "insert into t_format values ('24.60.60')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, " insert into t_format values ('04.00.60')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, " insert into t_format values ('03.60.00')");
1:e260f22: 
1:e260f22:         // not valid Time string ISO format: HH.MM.SS
1:e260f22:         assertStatementError("22007", st, 
1:e260f22:                 "insert into t_format values ('07.5.44')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, 
1:e260f22:                 " insert into t_format values ('07.05.4')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, 
1:e260f22:                 " insert into t_format values ('7.5.44')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, 
1:e260f22:                 " insert into t_format values ('7.5.4')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, 
1:e260f22:                 " insert into t_format values ('7.5.0')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, 
1:e260f22:                 " insert into t_format values ('-4.00.00')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, 
1:e260f22:                 " insert into t_format values ('A4.00.00')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, 
1:e260f22:                 " insert into t_format values ('7.5.999')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, 
1:e260f22:                 " insert into t_format values ('07.05.111')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, 
1:e260f22:                 " insert into t_format values ('111.05.11')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st, 
1:e260f22:                 " insert into t_format values ('11.115.00')");
1:e260f22: 
1:e260f22:         // no row
1:e260f22:         rs = st.executeQuery("select * from t_format");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "T" });
1:e260f22:         JDBC.assertDrainResults(rs, 0);
1:e260f22: 
1:e260f22:         dropTable("t_format");
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22: 
1:e260f22:     public void testFormat_Additional() throws SQLException{
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         ResultSet rs = st .executeQuery(
1:e260f22:         		"values time('2004-04-15 16:15:32.387')");
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "16:15:32" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" values time('2004-04-15-16.15.32.387')");
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "16:15:32" } }, true);
1:e260f22: 
1:e260f22:         assertStatementError("22007", st,
1:e260f22:                 " values time('2004-04-15-16.15.32.387 zz')");
1:e260f22: 
1:e260f22:         assertStatementError("22007", st,
1:e260f22:                 " values time('x-04-15-16.15.32.387')");
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" values date('2004-04-15 16:15:32.387')");
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "2004-04-15" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" values date('2004-04-15-16.15.32.387')");
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "2004-04-15" } }, true);
1:e260f22: 
1:e260f22:         assertStatementError("22008", st,
1:e260f22:                 " values date('2004-04-15-16.15.32.387 zz')");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st,
1:e260f22:                 " values date('2004-04-15-16.15.32.y')");
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" values time('13:59')");
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "13:59:00" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" values time('1:00')");
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "01:00:00" } }, true);
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     /**
1:e260f22:      * Test unary date and datetime functions. 
1:e260f22:      * Test with both constant and variable arguments.
1:e260f22:      */
1:e260f22:     public void test_DateAndDatetimeFunctionsMore() throws Exception {
1:e260f22:         ResultSet rs = null;
1:e260f22:         ResultSetMetaData rsmd;
1:e260f22:         PreparedStatement pSt;
1:e260f22:         Statement st = createStatement();
1:e260f22: 
1:e260f22:         String[][] expRS;
1:e260f22:         String[] expColNames;      
1:e260f22: 
1:e260f22:         setAutoCommit(false);
1:e260f22:         // test date(integer)
1:e260f22:         st.executeUpdate("create table t_func( i int, d date)");
1:e260f22: 
1:e260f22:         commit();
1:e260f22:         st.executeUpdate(" insert into t_func values( 1, date(1)),(10, " + 
1:e260f22:                 "date(10.1)),(365,date(365.1e0)),(366,date(366)),(789" + 
1:e260f22:                 ",date(789)),(790,date(790)),(791,date(791))");
1:e260f22: 
1:e260f22:         // should fail
1:e260f22:         assertStatementError("22008", st, "insert into t_func values( 0, date(0))");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st,
1:e260f22:                 " insert into t_func values( -1, date(-1))");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st,
1:e260f22:                 " insert into t_func values( 3652060, date( 3652060))");
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select i,d,date(i),date(d) from t_func order by i");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "I", "D", "3", "4" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] {
1:e260f22:                 { "1", "1970-01-01", "1970-01-01", "1970-01-01" },
1:e260f22:                 { "10", "1970-01-10", "1970-01-10", "1970-01-10" },
1:e260f22:                 { "365", "1970-12-31", "1970-12-31", "1970-12-31" },
1:e260f22:                 { "366", "1971-01-01", "1971-01-01", "1971-01-01" },
1:e260f22:                 { "789", "1972-02-28", "1972-02-28", "1972-02-28" },
1:e260f22:                 { "790", "1972-02-29", "1972-02-29", "1972-02-29" },
1:e260f22:                 { "791", "1972-03-01", "1972-03-01", "1972-03-01" } }, true);
1:e260f22: 
1:e260f22:         rollback();
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(" insert into t_func(i) values( 0)"));
1:e260f22:         
1:e260f22:         assertStatementError("22008", st, " select date(i) from t_func");
1:e260f22: 
1:e260f22:         rollback();
1:e260f22: 
1:e260f22:         st.executeUpdate(" insert into t_func(i) values( -1)");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st, " select date(i) from t_func");
1:e260f22:         rollback();
1:e260f22: 
1:e260f22:         st.executeUpdate(" insert into t_func(i) values( 3652060)");
1:e260f22:         assertStatementError("22008", st, " select date(i) from t_func");
1:e260f22:         rollback();
1:e260f22: 
1:e260f22:         st.executeUpdate(" drop table t_func");
1:e260f22:         
1:e260f22:         st.executeUpdate(" create table t_func( s varchar(32), d date)");
1:e260f22: 
1:e260f22:         commit();
1:e260f22:         assertEquals(6, st.executeUpdate(" insert into t_func " +
1:e260f22:         		"values('1900060', date('1900060')), ('1904060', " +
1:e260f22:         		"date('1904060')), ('1904366', date('1904366')), " +
1:e260f22:         		"('2000060', date('2000060')), ('2001060'," +
1:e260f22:         		" date('2001060')), ('2001365', date('2001365'))"));
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select s,d,date(s) from t_func order by s");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "S", "D", "3" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "1900060", "1900-03-01", "1900-03-01" },
1:e260f22:                 { "1904060", "1904-02-29", "1904-02-29" },
1:e260f22:                 { "1904366", "1904-12-31", "1904-12-31" },
1:e260f22:                 { "2000060", "2000-02-29", "2000-02-29" },
1:e260f22:                 { "2001060", "2001-03-01", "2001-03-01" },
1:e260f22:                 { "2001365", "2001-12-31", "2001-12-31" } }, true);
1:e260f22: 
1:e260f22:         rollback();
1:e260f22: 
1:e260f22:         // failure cases
1:e260f22:         assertStatementError("22008", st, "values( date('2001000'))");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st, " values( date('2001366'))");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st, " values( date('2000367'))");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st, " values( date('xxxxxxx'))");
1:e260f22: 
1:e260f22:         st.executeUpdate(" insert into t_func(s) values( '2001000')");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st, "select date(s) from t_func");
1:e260f22:         rollback();
1:e260f22: 
1:e260f22:         st.executeUpdate(" insert into t_func(s) values( '2001366')");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st, "select date(s) from t_func");
1:e260f22:         rollback();
1:e260f22: 
1:e260f22:         st.executeUpdate(" insert into t_func(s) values( '2000367')");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st, "select date(s) from t_func");
1:e260f22:         rollback();
1:e260f22: 
1:e260f22:         st.executeUpdate(" insert into t_func(s) values( 'xxxxxxx')");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st, "select date(s) from t_func");
1:e260f22:         rollback();
1:e260f22: 
1:e260f22:         // test parameter
1:e260f22:         pSt = prepareStatement("values( date(cast(? as integer))," +
1:e260f22:         		"timestamp(cast(? as varchar(32))))");
1:e260f22:         rs = st.executeQuery("values(cast(1 as integer), " +
1:e260f22:         		"'2003-03-05-17.05.43.111111')");
1:e260f22: 
1:e260f22:         rs.next();
1:e260f22:         rsmd = rs.getMetaData();
1:e260f22:         for (int i = 1; i <= rsmd.getColumnCount(); i++)
1:e260f22:             pSt.setObject(i, rs.getObject(i));
1:e260f22:         
1:e260f22:         rs = pSt.executeQuery();
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1", "2" });
1:79fec78:         JDBC.assertFullResultSet(rs, new String[][] { { "1970-01-01",
1:e260f22:             "2003-03-05 17:05:43.111111" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery("values(2, '20030422190200')");
1:e260f22:         rs.next();
1:e260f22:         rsmd = rs.getMetaData();
1:e260f22:         for (int i = 1; i <= rsmd.getColumnCount(); i++)
1:e260f22:             pSt.setObject(i, rs.getObject(i));
1:e260f22: 
1:e260f22:         rs = pSt.executeQuery();
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1", "2" });
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { "1970-01-02", 
1:e260f22:                 "2003-04-22 19:02:00.0" } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" values( date(date(1)), "
1:e260f22:                 + "date(timestamp('2003-03-05-17.05.43.111111')))");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "1", "2" });
1:e260f22:         JDBC.assertFullResultSet(rs, 
1:e260f22:                 new String[][] { { "1970-01-01", "2003-03-05" } }, true);
1:e260f22: 
1:e260f22:         st.executeUpdate(" drop table t_func");
1:e260f22:         
1:e260f22:         
1:e260f22:         st.executeUpdate(" create table t_func( s varchar(32), ts timestamp, " + 
1:e260f22:                 "expected timestamp)");
1:e260f22: 
1:e260f22:         commit();
1:e260f22:         st.executeUpdate(" insert into t_func(ts) values( " +
1:e260f22:                 "timestamp('2003-03-05-17.05.43.111111'))");
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select date(ts) from t_func");
1:e260f22: 
1:e260f22:         expColNames = new String[] { "1" };
1:e260f22:         JDBC.assertColumnNames(rs, expColNames);
1:e260f22: 
1:e260f22:         expRS = new String[][] { { "2003-03-05" } };
1:e260f22: 
1:e260f22:         JDBC.assertFullResultSet(rs, expRS, true);
1:e260f22: 
1:e260f22:         rollback();
1:e260f22: 
1:e260f22:         // Test special unary timestamp function rules: yyyyxxddhhmmss
1:e260f22:         st.executeUpdate("insert into t_func values('20000228235959', " + 
1:e260f22:                 "timestamp('20000228235959'), '2000-02-28-23.59.59'), " +
1:e260f22:                 "('20000229000000', timestamp('20000229000000'), " +
1:e260f22:                 "'2000-02-29-00.00.00')");
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select s from t_func where ts <> expected or " + 
1:e260f22:                 "timestamp(s) <> expected or timestamp(ts) <> expected");
1:e260f22:         JDBC.assertColumnNames(rs, new String[] { "S" });
1:e260f22:         JDBC.assertDrainResults(rs, 0);
1:e260f22: 
1:e260f22:         rollback();
1:e260f22: 
1:e260f22:         // invalid
1:e260f22:         assertStatementError("22008", st,
1:e260f22:                 "values( timestamp('2000 1 1 0 0 0'))");
1:e260f22: 
1:e260f22:         assertStatementError("22008", st,
1:e260f22:                 " values( timestamp('aaaaaaaaaaaaaa'))");
1:e260f22: 
1:e260f22:         assertEquals(1, st.executeUpdate(
1:e260f22:                 " insert into t_func(s) values('2000 1 1 0 0 0')"));
1:e260f22:         
1:e260f22:         assertStatementError("22008", st, " select timestamp(s) from t_func");
1:e260f22: 
1:e260f22:         rollback();
1:e260f22:         assertEquals(1, st.executeUpdate(
1:e260f22:                 " insert into t_func(s) values('aaaaaaaaaaaaaa')"));
1:e260f22:         assertStatementError("22008", st, " select timestamp(s) from t_func");
1:e260f22:         rollback();
1:e260f22: 
1:e260f22:         commit();
1:e260f22: 
1:e260f22:         getConnection().rollback();
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22:     
1:e260f22:     /**
1:e260f22:      *  Null values in datetime scalar functions.
1:e260f22:      */
1:e260f22:     public void testNulls() throws SQLException{
1:e260f22:         Statement st = createStatement();
1:e260f22:         
1:e260f22:         st.executeUpdate("create table nulls (t time, d date, ts timestamp)");
1:e260f22: 
1:e260f22:         st.executeUpdate(" insert into nulls values (null,null,null)");
1:e260f22: 
1:e260f22:         commit();
1:e260f22:         assertStatementError("42X25", st, " select year(t) from nulls");
1:e260f22: 
1:e260f22:         assertStatementError("42X25", st, " select month(t) from nulls");
1:e260f22: 
1:e260f22:         assertStatementError("42X25", st, " select day(t) from nulls");
1:e260f22: 
1:e260f22:         ResultSet rs = st.executeQuery(" select hour(t) from nulls");
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select minute(t) from nulls");
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select second(t) from nulls");
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select year(d) from nulls");
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select month(d) from nulls");
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select day(d) from nulls");
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1:e260f22: 
1:e260f22:         assertStatementError("42X25", st, " select hour(d) from nulls");
1:e260f22: 
1:e260f22:         assertStatementError("42X25", st, " select minute(d) from nulls");
1:e260f22: 
1:e260f22:         assertStatementError("42X25", st, " select second(d) from nulls");
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select year(ts) from nulls");
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select month(ts) from nulls");
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select day(ts) from nulls");
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select hour(ts) from nulls");
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select minute(ts) from nulls");
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1:e260f22: 
1:e260f22:         rs = st.executeQuery(" select second(ts) from nulls");
1:e260f22:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1:e260f22: 
1:e260f22:         st.executeUpdate(" drop table nulls");
1:e260f22:         
1:e260f22:         st.close();
1:e260f22:     }
1:e260f22: 
1:e260f22:     /**
1:79fec78:      * Regression test case for DERBY-3856. The embedded driver sometimes
1:79fec78:      * returned an unnormalized datetime string when getString() was used
1:79fec78:      * to retrieve the result from an invocation of the unary TIMESTAMP or
1:79fec78:      * DATE function.
1:79fec78:      */
1:79fec78:     public void testDerby3856() throws SQLException {
1:79fec78:         // TIMESTAMP called on literal has always a returned normalized value.
1:79fec78:         assertSingleValue(
1:79fec78:                 "values timestamp('2003-03-05-17.05.43.111111')",
1:79fec78:                 "2003-03-05 17:05:43.111111");
1:79fec78: 
1:79fec78:         // This one used to return the original unnormalized input with the
1:79fec78:         // embedded driver.
1:79fec78:         assertSingleValue(
1:79fec78:                 "values timestamp(cast('2003-03-05-17.05.43.111111' " +
1:79fec78:                 "as varchar(32)))",
1:79fec78:                 "2003-03-05 17:05:43.111111");
1:79fec78: 
1:79fec78:         // DATE called on literal has always a returned normalized value.
1:79fec78:         assertSingleValue("values date('10/07/2008')", "2008-10-07");
1:79fec78: 
1:79fec78:         // This one used to return the original unnormalized input with the
1:79fec78:         // embedded driver.
1:79fec78:         assertSingleValue(
1:79fec78:                 "values date(cast('10/07/2008' as varchar(10)))",
1:79fec78:                 "2008-10-07");
1:79fec78: 
1:79fec78:         // TIME called on literal has always a returned normalized string.
1:79fec78:         assertSingleValue("values time('10.00.00')", "10:00:00");
1:79fec78: 
1:79fec78:         // TIME has also always returned a normalized value for the variant
1:79fec78:         // with a CAST.
1:79fec78:         assertSingleValue(
1:79fec78:                 "values time(cast('10.00.00' as varchar(10)))",
1:79fec78:                 "10:00:00");
1:79fec78:     }
1:79fec78: 
1:79fec78:     /**
1:c13beb1:      * Test case to show that timestamp function accepts nanoseconds
1:c13beb1:      * resolution (DERBY-4625).
1:c13beb1:      */
1:c13beb1:     public void testNanosecondResolution() throws SQLException{
1:c13beb1:     	assertSingleValue("values timestamp('2010-04-21 12:00:00.123456789')",
1:c13beb1:     			"2010-04-21 12:00:00.123456789");
1:c13beb1:     }
1:c13beb1: 
1:c13beb1:     /**
1:79fec78:      * Execute an SQL statement and check that it returns a single, specific
1:79fec78:      * value.
1:79fec78:      *
1:79fec78:      * @param sql the statement to execute
1:79fec78:      * @param expectedValue the expected value
1:79fec78:      */
1:79fec78:     private void assertSingleValue(String sql, String expectedValue)
1:79fec78:             throws SQLException {
1:79fec78:         JDBC.assertSingleValueResultSet(
1:79fec78:                 createStatement().executeQuery(sql), expectedValue);
1:79fec78:     }
1:e260f22: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("DateTimeTest");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite(name);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:28e7078
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that trailing zeros in the nanoseconds component of a timestamp
1:      * are handled the same way by
1:      * {@code PreparedStatement.setTimestamp(int,Timestamp)} and
1:      * {@code PreparedStatement.setTimestamp(int,Timestamp, Calendar)}
1:      * when converting the timestamp to a VARCHAR. (DERBY-4810)
1:      */
1:     public void testTrailingZeros() throws SQLException {
1:         PreparedStatement ps =
1:                 prepareStatement("values cast(? as varchar(29))");
1: 
1:         String[] tsStrings = {
1:             "2010-09-22 14:40:33.000000000",
1:             "2010-09-22 14:40:33.012000000",
1:             "2010-09-22 14:40:33.123456000",
1:             "2010-09-22 14:40:33.139990900",
1:             "2010-09-22 14:40:33.139990983",
1:         };
1: 
1:         for (int i = 0; i < tsStrings.length; i++) {
1:             Timestamp ts = Timestamp.valueOf(tsStrings[i]);
1: 
1:             // We expect the converted value to have the same format as
1:             // what Timestamp.toString() returns.
1:             String expected = ts.toString();
1: 
1:             ps.setTimestamp(1, ts);
1:             JDBC.assertSingleValueResultSet(ps.executeQuery(), expected);
1: 
1:             ps.setTimestamp(1, ts, Calendar.getInstance());
1:             JDBC.assertSingleValueResultSet(ps.executeQuery(), expected);
1:         }
1:     }
1: 
commit:3d03e7d
/////////////////////////////////////////////////////////////////////////
1: import java.util.TimeZone;
/////////////////////////////////////////////////////////////////////////
1:      * Test that conversion from timestamp to string is correct when a
1:      * calendar is specified. Specifically, verify that the full nanosecond
1:      * resolution is used and that the converted timestamp is not rounded to
1:      * microsecond resolution. Regression test case for DERBY-4626.
1:      */
1:     public void testConvertToStringWithCalendar() throws SQLException {
1:         PreparedStatement ps =
1:                 prepareStatement("values cast(? as varchar(29))");
1: 
1:         // Generate a timestamp representing 2010-09-01 20:31:40.123456789 GMT
1:         Timestamp ts = new Timestamp(1283373100000L);
1:         ts.setNanos(123456789);
1: 
1:         // Array of (timezone, timestamp string) pairs representing a timezone
1:         // with which to test and the expected timestamp string produced.
1:         String[][] testData = {
1:             { "GMT", "2010-09-01 20:31:40.123456789" },
1:             { "Europe/Oslo", "2010-09-01 22:31:40.123456789" },
1:         };
1: 
1:         for (int i = 0; i < testData.length; i++) {
1:             Calendar cal = Calendar.getInstance(
1:                     TimeZone.getTimeZone(testData[i][0]));
1:             ps.setTimestamp(1, ts, cal);
1:             JDBC.assertSingleValueResultSet(ps.executeQuery(), testData[i][1]);
1:         }
1:     }
1: 
1:     /**
commit:c13beb1
/////////////////////////////////////////////////////////////////////////
1:      * Don't allow more than nanoseconds in ISO format.
1:     public void testISOFormat_MoreThanNanoseconds() throws SQLException{
1:                 + "('2003-03-05-17.05.43.999999999999')");
1:                 + "('2003-03-05-17.05.43.999999999000')");
/////////////////////////////////////////////////////////////////////////
1:      * Test case to show that timestamp function accepts nanoseconds
1:      * resolution (DERBY-4625).
1:      */
1:     public void testNanosecondResolution() throws SQLException{
1:     	assertSingleValue("values timestamp('2010-04-21 12:00:00.123456789')",
1:     			"2010-04-21 12:00:00.123456789");
1:     }
1: 
1:     /**
commit:79fec78
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertFullResultSet(rs, new String[][] { { "1970-01-01",
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Regression test case for DERBY-3856. The embedded driver sometimes
1:      * returned an unnormalized datetime string when getString() was used
1:      * to retrieve the result from an invocation of the unary TIMESTAMP or
1:      * DATE function.
1:      */
1:     public void testDerby3856() throws SQLException {
1:         // TIMESTAMP called on literal has always a returned normalized value.
1:         assertSingleValue(
1:                 "values timestamp('2003-03-05-17.05.43.111111')",
1:                 "2003-03-05 17:05:43.111111");
1: 
1:         // This one used to return the original unnormalized input with the
1:         // embedded driver.
1:         assertSingleValue(
1:                 "values timestamp(cast('2003-03-05-17.05.43.111111' " +
1:                 "as varchar(32)))",
1:                 "2003-03-05 17:05:43.111111");
1: 
1:         // DATE called on literal has always a returned normalized value.
1:         assertSingleValue("values date('10/07/2008')", "2008-10-07");
1: 
1:         // This one used to return the original unnormalized input with the
1:         // embedded driver.
1:         assertSingleValue(
1:                 "values date(cast('10/07/2008' as varchar(10)))",
1:                 "2008-10-07");
1: 
1:         // TIME called on literal has always a returned normalized string.
1:         assertSingleValue("values time('10.00.00')", "10:00:00");
1: 
1:         // TIME has also always returned a normalized value for the variant
1:         // with a CAST.
1:         assertSingleValue(
1:                 "values time(cast('10.00.00' as varchar(10)))",
1:                 "10:00:00");
1:     }
1: 
1:     /**
1:      * Execute an SQL statement and check that it returns a single, specific
1:      * value.
1:      *
1:      * @param sql the statement to execute
1:      * @param expectedValue the expected value
1:      */
1:     private void assertSingleValue(String sql, String expectedValue)
1:             throws SQLException {
1:         JDBC.assertSingleValueResultSet(
1:                 createStatement().executeQuery(sql), expectedValue);
1:     }
commit:95ad00d
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.util.Calendar;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Regression test case for DERBY-4621, which caused the conversion of
1:      * timestamp and time values to varchar to generate wrong results when
1:      * a Calendar object was supplied.
1:      */
1:     public void testConversionToString() throws SQLException {
1:         String timestampString = "2010-04-20 15:17:36.0";
1:         String timeString = "15:17:36";
1:         String dateString = "2010-04-20";
1: 
1:         Timestamp ts = Timestamp.valueOf(timestampString);
1:         Time t = Time.valueOf(timeString);
1:         Date d = Date.valueOf(dateString);
1: 
1:         PreparedStatement ps =
1:                 prepareStatement("VALUES CAST(? AS VARCHAR(40))");
1: 
1:         ps.setTimestamp(1, ts);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), timestampString);
1: 
1:         // Used to give wrong result - 2010-04-20 03:17:36
1:         ps.setTimestamp(1, ts, Calendar.getInstance());
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), timestampString);
1: 
1:         ps.setTime(1, t);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), timeString);
1: 
1:         // Used to give wrong result - 03:17:36
1:         ps.setTime(1, t, Calendar.getInstance());
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), timeString);
1: 
1:         ps.setDate(1, d);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), dateString);
1: 
1:         ps.setDate(1, d, Calendar.getInstance());
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), dateString);
1:     }
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:e260f22
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.DateTimeTest
1: 
1:        Licensed to the Apache Software Foundation (ASF) under one
1:        or more contributor license agreements.  See the NOTICE file
1:        distributed with this work for additional information
1:        regarding copyright ownership.  The ASF licenses this file
1:        to you under the Apache License, Version 2.0 (the
1:        "License"); you may not use this file except in compliance
1:        with the License.  You may obtain a copy of the License at
1: 
1:          http://www.apache.org/licenses/LICENSE-2.0
1: 
1:        Unless required by applicable law or agreed to in writing,
1:        software distributed under the License is distributed on an
1:        "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:        KIND, either express or implied.  See the License for the
1:        specific language governing permissions and limitations
1:        under the License
1: */
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Test the builtin date/time types assumes these builtin types 
1:  * exist: int, smallint, char, varchar, real other things we might test: 
1:  * interaction with UUID and other user defined types 
1:  * compatibility with dynamic parameters and JDBC getDate etc. methods.
1:  */
1: public final class DateTimeTest extends BaseJDBCTestCase {
1: 
1:     /**
1:      * Public constructor required for running test as standalone JUnit.
1:      */
1:     public DateTimeTest(String name) {
1:         super(name);
1:     }
1: 
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("DateTimeTest");
1:         suite.addTest(baseSuite("DateTimeTest:Embedded"));
1:         suite.addTest(TestConfiguration
1:                 .clientServerDecorator(baseSuite("DateTimeTest:Client")));
1:         return suite;
1:     }
1: 
1:     protected static Test baseSuite(String name) {
0:         TestSuite suite = new TestSuite(name);
1:         suite.addTestSuite(DateTimeTest.class);
1:         return new CleanDatabaseTestSetup(suite) {
1:             /**
1:              * Creates the tables used in the test cases.
1:              * @exception SQLException if a database error occurs
1:              */
1:             protected void decorateSQL(Statement stmt) throws SQLException {
1:                 createTableForArithmeticTest(stmt);
1:                 createTableForSyntaxTest(stmt);
1:                 createTableForConversionTest(stmt);
1:                 createTableForISOFormatTest(stmt);
1:             }
1:         };
1:     }
1:     
1:     private static void createTableForISOFormatTest(Statement st)
1:     throws SQLException{
1:         st.executeUpdate(" create table ts (ts1 timestamp, ts2 timestamp)");   
1:     }
1:     
1:     
1:     private static void createTableForConversionTest(Statement st) throws SQLException{
1:         st.executeUpdate(
1:                 " create table convtest(d date, t time, ts timestamp)");
1:         st.executeUpdate(" insert into convtest values(date('1932-03-21'),  "
1:                 + "time('23:49:52'), timestamp('1832-09-24 10:11:43.32'))");
1:         st.executeUpdate(" insert into convtest values(date('0001-03-21'),  "
1:                 + "time('5:22:59'), timestamp('9999-12-31 23:59:59.999999'))");
1:         st.executeUpdate(" insert into convtest values(null, null, null)");
1:     }
1:     
1:     private static void createTableForSyntaxTest(Statement stmt) 
1:     throws SQLException{
1:         stmt.executeUpdate("create table source (i int, s smallint, c char(10), "
1:                 + "v varchar(50), d double precision, r real, e date, "
1:                 + "t time, p timestamp)");
1: 
1:         stmt.executeUpdate(" create table target (e date not null, t time not "
1:                 + "null, p timestamp not null)");
1:     }
1:         
1:     private static void createTableForArithmeticTest(Statement stmt)
1:     throws SQLException{
1:         stmt.executeUpdate("create table t (i int, s smallint, " +
1:                 "c char(10), v varchar(50), d double precision," +
1:                 " r real, e date, t time, p timestamp)");
1: 
1:         stmt.executeUpdate(" insert into t values (null, null, " +
1:                 "null, null, null, null, null, null, null)");
1: 
1:         stmt.executeUpdate(" insert into t values (0, 100, 'hello', " +
1:                 "'everyone is here', 200.0e0, 300.0e0, " +
1:                 "date('1992-01-01'), time('12:30:30'), " +
1:                 "timestamp('1992-01-01 12:30:30'))");
1: 
1:         stmt.executeUpdate(" insert into t values (-1, -100, " +
1:                 "'goodbye', 'everyone is there', -200.0e0, " +
1:                 "-300.0e0, date('1992-01-01'), time('12:30:30'), " +
1:                 "timestamp('1992-01-01 12:30:45'))");
1:     }
1:     
1:     /**
1:      * date/times don't support math, show each combination.
1:      */
1:     public void testArithOpers_math() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         assertStatementError("42Y95", st, "select e + e from t");
1: 
1:         assertStatementError("42Y95", st, " select i + e from t");
1: 
1:         assertStatementError("42Y95", st, " select p / p from t");
1: 
1:         assertStatementError("42Y95", st, " select p * s from t");
1: 
1:         assertStatementError("42Y95", st, " select t - t from t");
1: 
1:         assertStatementError("42X37", st, " select -t from t");
1: 
1:         assertStatementError("42X37", st, " select +e from t");
1:         
1:         st.close();
1:     }
1:     
1:     public void testArithOpers_Comarision() throws SQLException{
1:         ResultSet rs = null;
1:         Statement st = createStatement();
1: 
1:         rs = st.executeQuery("select e from t where e = date('1992-01-01')");
1:         JDBC.assertColumnNames(rs, new String[] { "E" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "1992-01-01" }, { "1992-01-01" } }, true);
1: 
1:         rs = st.executeQuery(" select e from t where date('1992-01-01') = e");
1:         JDBC.assertColumnNames(rs, new String[] { "E" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "1992-01-01" }, { "1992-01-01" } }, true);
1: 
1:         rs = st.executeQuery(" select t from t where t > time('09:30:15')");
1:         JDBC.assertColumnNames(rs, new String[] { "T" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "12:30:30" }, { "12:30:30" } }, true);
1: 
1:         rs = st.executeQuery(" select t from t where time('09:30:15') < t");
1:         JDBC.assertColumnNames(rs, new String[] { "T" });
1:         JDBC.assertFullResultSet(rs,
1:                 new String[][] { { "12:30:30" }, { "12:30:30" } }, true);
1: 
1:         rs = st.executeQuery(
1:                 "select p from t where p < timestamp('1997-06-30 01:01:01')");
1:         JDBC.assertColumnNames(rs, new String[] { "P" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "1992-01-01 12:30:30.0" },
1:                 { "1992-01-01 12:30:45.0" } }, true);
1: 
1:         rs = st.executeQuery(
1:                 "select p from t where timestamp('1997-06-30 01:01:01' )> p");
1:         JDBC.assertColumnNames(rs, new String[] { "P" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "1992-01-01 12:30:30.0" },
1:                 { "1992-01-01 12:30:45.0" } }, true);
1:         
1:         rs = st.executeQuery("select e from t where e >= date('1990-01-01')");
1:         JDBC.assertColumnNames(rs, new String[] { "E" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "1992-01-01" }, { "1992-01-01" } }, true);
1: 
1:         rs = st.executeQuery(" select e from t where date('1990-01-01')<= e");
1:         JDBC.assertColumnNames(rs, new String[] { "E" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "1992-01-01" }, { "1992-01-01" } }, true);
1: 
1:         rs = st.executeQuery(" select t from t where t <= time('09:30:15')");
1:         JDBC.assertColumnNames(rs, new String[] { "T" });
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         rs = st.executeQuery(" select t from t where time('09:30:15') >= t");
1:         JDBC.assertColumnNames(rs, new String[] { "T" });
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         rs = st.executeQuery(
1:                 "select p from t where p <> timestamp('1997-06-30 01:01:01')");
1:         JDBC.assertColumnNames(rs, new String[] { "P" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "1992-01-01 12:30:30.0" },
1:                 { "1992-01-01 12:30:45.0" } }, true);
1: 
1:         rs = st.executeQuery(
1:                 "select p from t where timestamp('1997-06-30 01:01:01' )<> p");
1:         JDBC.assertColumnNames(rs, new String[] { "P" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "1992-01-01 12:30:30.0" },
1:                 { "1992-01-01 12:30:45.0" } }, true);
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * Show comparisons with mixed types don't work.
1:      */
1:     public void testArithOpers_CompraionOnMixedTypes() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         assertStatementError("42818", st, "select e from t where e <= i");
1: 
1:         assertStatementError("42818", st, " select e from t where t < s");
1: 
1:         assertStatementError("42818", st, " select e from t where p > d");
1: 
1:         assertStatementError("42818", st, " select e from t where e >= t");
1: 
1:         assertStatementError("42818", st, " select e from t where t <> p");
1: 
1:         assertStatementError("42818", st, " select e from t where p = e");
1: 
1:         st.close();
1:     }
1:     
1:     /**
1:      * Look for a value that isn't in the table.
1:      */
1:     public void testArithOpers_CompraionOnNotExistingValue() 
1:     throws SQLException{
1:         ResultSet rs = null;
1:         Statement st = createStatement();
1:         
1:         rs = st.executeQuery("select e from t where e <> date('1992-01-01')");
1:         JDBC.assertColumnNames(rs, new String[] { "E" });
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         rs = st.executeQuery("select e from t where date('1992-01-01') <> e");
1:         JDBC.assertColumnNames(rs, new String[] { "E" });
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         st.close();
1:     }
1:     
1:     /**
1:      * Show garbage in == errors out
1:      */
1:     public void testArithOpers_ComparisonOnGarbage() throws SQLException {
1:         Statement st = createStatement();
1:         
1:         assertStatementError("22008", st, 
1:                 "select date( 'xxxx') from t where p is null");
1: 
1:         assertStatementError("22007", st, 
1:                 " select time( '') from t where p is null");
1: 
1:         assertStatementError("22008", st,
1:                 " select timestamp( 'is there anything here?' )from " +
1:                 "t where p is null");
1: 
1:         assertStatementError("22008", st,
1:                 " select timestamp( '1992-01- there anything here?')" +
1:                 "from t where p is null");
1: 
1:         assertStatementError("22008", st,
1:                 " select timestamp( '--::' )from t where p is null");
1: 
1:         assertStatementError("22007", st, 
1:                 " select time('::::') from t where p is null");
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * Check limit values.
1:      */
1:     public void testArithOpers_ComparisonOnLimits() throws SQLException {
1:         ResultSet rs = null;
1:         Statement st = createStatement();
1: 
1:         rs = st.executeQuery("values( date('0001-1-1'), date('9999-12-31'), "
1:                 + "date('2/29/2000'), date('29.2.2004'))");
1:         JDBC.assertColumnNames(rs, new String[] { "1", "2", "3", "4" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "0001-01-01", 
1:                 "9999-12-31", "2000-02-29", "2004-02-29" } }, true);
1: 
1:         rs = st.executeQuery(" values( time('00:00:00'), time('23:59:59'))");
1:         JDBC.assertColumnNames(rs, new String[] { "1", "2" });
1:         JDBC.assertFullResultSet(rs,
1:                 new String[][] { { "00:00:00", "23:59:59" } }, true);
1: 
1:         rs = st.executeQuery(" values( time('00 AM'), time( '12:59 AM')," +
1:         		" time('1 PM'), time('12:59 PM'))");
1:         JDBC.assertColumnNames(rs, new String[] { "1", "2", "3", "4" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "00:00:00", 
1:                 "00:59:00", "13:00:00", "12:59:00" } }, true);
1: 
1:         rs = st.executeQuery(" values( time('00.00.00'), time('23.59.59'), " +
1:                 "time('24.00.00'))");
1:         JDBC.assertColumnNames(rs, new String[] { "1", "2", "3" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "00:00:00", 
1:                 "23:59:59", "00:00:00" } }, true);
1: 
1:         rs = st.executeQuery(" values( timestamp('0001-1-1 00:00:00'), "
1:                 + "timestamp('9999-12-31 23:59:59.999999'))");
1:         JDBC.assertColumnNames(rs, new String[] { "1", "2" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { 
1:             "0001-01-01 00:00:00.0", "9999-12-31 23:59:59.999999" } }, true);
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * Show that overflow and underflow are not allowed
1:      *  (SQL92 would have these report errors).
1:      */
1:     public void testArithOpers_ComparisonOnBeyondLimits() throws SQLException {
1:         Statement st = createStatement();
1:         
1:         assertStatementError("22008", st , "values( date('0000-01-01'))");
1: 
1:         assertStatementError("22008", st, " values( date('2000-00-01'))");
1: 
1:         assertStatementError("22008", st, " values( date('2000-01-00'))");
1: 
1:         assertStatementError("22008", st, " values( date('10000-01-01'))");
1: 
1:         assertStatementError("22008", st, " values( date('2000-13-01'))");
1: 
1:         assertStatementError("22008", st, " values( date('2000-01-32'))");
1: 
1:         assertStatementError("22008", st, " values( date('1900-02-29'))");
1: 
1:         assertStatementError("22008", st, " values( date('2001-02-29'))");
1: 
1:         assertStatementError("22007", st, " values( time('25.00.00'))");
1: 
1:         assertStatementError("22007", st, " values( time('24.00.01'))");
1: 
1:         assertStatementError("22007", st, " values( time('0:60:00'))");
1: 
1:         assertStatementError("22007", st, " values( time('00:00:60'))");
1: 
1:         st.close();
1:     }
1:     
1:     public void testArithOpers_ComparisonOnNullAndNonNull() 
1:     throws SQLException {
1:         ResultSet rs = null;
1:         Statement st = createStatement();
1:         
1:         rs = st.executeQuery("select e, t, p from t " +
1:         		"where e = e or t = t or p = p");
1:         JDBC.assertColumnNames(rs, new String[] { "E", "T", "P" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "1992-01-01", 
1:                 "12:30:30", "1992-01-01 12:30:30.0" }, { "1992-01-01",
1:                 "12:30:30", "1992-01-01 12:30:45.0" } }, true);
1:         
1:         rs = st.executeQuery("select * from t where e is not null " +
1:         		"and t is not " + "null and p is not null");
1:         JDBC.assertColumnNames(rs, new String[] { "I", "S", "C", "V",
1:                 "D", "R", "E", "T", "P" });
1:         JDBC.assertFullResultSet(rs,  new String[][] {
1:                 { "0", "100", "hello", "everyone is here", "200.0", "300.0",
1:                     "1992-01-01", "12:30:30", "1992-01-01 12:30:30.0" },
1:                 { "-1", "-100", "goodbye", "everyone is there", "-200.0",
1:                     "-300.0", "1992-01-01", "12:30:30", 
1:                     "1992-01-01 12:30:45.0" } }, true);
1:         
1:         st.close();
1:     }
1: 
1:     /**
1:      * Test =SQ .
1:      */
1:     public void testArithOpers_ComparisonOnEqualSQ() throws SQLException{
1:         ResultSet rs = null;
1:         Statement st = createStatement();
1: 
1:         assertStatementError("21000", st,
1:                 "select 'fail' from t where e = (select e from t)");
1: 
1:         rs = st.executeQuery("select 'pass' from t " +
1:         		"where e = (select e from t where d=200)");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs,
1:                 new String[][] { { "pass" }, { "pass" } }, true);
1: 
1:         assertStatementError("21000", st,
1:                 "select 'fail' from t where t = (select t from t)");
1: 
1:         rs = st.executeQuery("select 'pass' from t " +
1:         		"where t = (select t from t where d=200)");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "pass" }, { "pass" } }, true);
1: 
1:         assertStatementError("21000", st,
1:                 "select 'fail' from t where p = (select p from t)");
1: 
1:         rs = st.executeQuery("select 'pass' from t " +
1:         		"where p = (select p from t where d=200)");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "pass" } }, true);
1: 
1:         st.close();
1:     }
1:     
1:     /**
1:      * Test syntax: precision cannot be specified.
1:      */
1:     public void testSyntax_SpecifiedPrecision() throws SQLException{        
1:         Statement st = createStatement();
1:         
1:         assertStatementError("42X01", st , 
1:                 "create table wrong (t time(-100))");
1: 
1:         assertStatementError("42X01", st, 
1:                 " create table wrong (t time(0))");
1: 
1:         assertStatementError("42X01", st, 
1:                 " create table wrong (t time(23))");
1: 
1:         assertStatementError("42X01", st,
1:                 " create table wrong (t timestamp(-100))");
1: 
1:         assertStatementError("42X01", st,
1:                 " create table wrong (t timestamp(0))");
1: 
1:         assertStatementError("42X01", st,
1:                 " create table wrong (t timestamp(6))");
1: 
1:         assertStatementError("42X01", st,
1:                 " create table wrong (t timestamp(9))");
1: 
1:         assertStatementError("42X01", st,
1:                 " create table wrong (t timestamp(23))");
1:         
1:         st.close();
1:     }
1:     
1: 
1:     /**
1:      * Test a variety of inserts.
1:      */
1:     public void testSyntax_Insert() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         st.executeUpdate("insert into source values (1, 2, '3', '4', 5, 6, "
1:                 + "date('1997-07-07'), "
1:                 + "time('08:08:08'),timestamp('1999-09-09 09:09:09'))");
1:         
1:         st.executeUpdate("insert into target select e,t,p from source");
1:         
1:         //wrong columns should fail
1:         assertStatementError("42821", st,
1:                 "insert into target select p,e,t from source");
1:         
1:         assertStatementError("42821", st,
1:         " insert into target select i,s,d from source");
1: 
1:         assertStatementError("42821", st,
1:             " insert into target (t,p) select c,r from source");
1: 
1:         assertUpdateCount(st, 1, " delete from source");
1:         
1:         
1:         st.executeUpdate(" insert into source values (null, null, null, null, "
1:                 + "null, null, null, null, null)");
1: 
1:         // these fail because the target won't take a null -- of any type
1:         assertStatementError("23502", st,
1:                 "insert into target values(null, null, null)");
1: 
1:         assertStatementError("23502", st,
1:                 " insert into target select e,t,p from source");
1:         
1:         //these still fail with type errors:
1:         assertStatementError("42821", st,
1:                 "insert into target select p,e,t from source");
1: 
1:         assertStatementError("42821", st,
1:                 " insert into target select i,s,d from source");
1: 
1:         assertStatementError("42821", st,
1:                 " insert into target (t,p)select c,r from source");
1: 
1:         //expect 1 row in target.
1:         ResultSet rs = st.executeQuery("select * from target");
1:         JDBC.assertColumnNames(rs, new String[] { "E", "T", "P" });
1:         JDBC.assertFullResultSet(rs, new String[][] { {
1:                 "1997-07-07", "08:08:08", "1999-09-09 09:09:09.0" } }, true);
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * Test a variety of updates.
1:      */
1:     public void testSyntax_Update() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         //expect 1 row in target.
1:         ResultSet rs = st.executeQuery("select * from target");
1:         JDBC.assertColumnNames(rs, new String[] { "E", "T", "P" });
1:         JDBC.assertFullResultSet(rs, new String[][] { {
1:                 "1997-07-07", "08:08:08", "1999-09-09 09:09:09.0" } }, true);
1:         
1:         // unchanged:
1:         assertUpdateCount(st, 1, "update target set e = e, t = t, p = p");
1:         rs = st.executeQuery(" select * from target");
1:         JDBC.assertColumnNames(rs, new String[] { "E", "T", "P" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { 
1:                 "1997-07-07", "08:08:08", "1999-09-09 09:09:09.0" } }, true);
1: 
1:         // alters the row:
1:         assertUpdateCount(st, 1, "update target set e = date('1990-01-01')");
1:         rs = st.executeQuery(" select * from target");
1:         JDBC.assertColumnNames(rs, new String[] { "E", "T", "P" });
1:         JDBC.assertFullResultSet(rs, new String[][] { {
1:                 "1990-01-01", "08:08:08", "1999-09-09 09:09:09.0" } }, true);
1:         
1:         //not settable to null
1:         assertStatementError("23502", st, "update target set e = null");
1:         rs = st.executeQuery(" select * from target");
1:         JDBC.assertColumnNames(rs, new String[] { "E", "T", "P" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { 
1:                 "1990-01-01", "08:08:08", "1999-09-09 09:09:09.0" } }, true);
1:         
1:         // nullable col can be set to null:
1:         assertUpdateCount(st, 1, "update source set e = date('1492-10-01')");
1:         rs = st.executeQuery(" select e from source");
1:         JDBC.assertColumnNames(rs, new String[] { "E" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "1492-10-01" } }, true);
1: 
1:         assertUpdateCount(st, 1, " update source set e = null");
1:         rs = st.executeQuery(" select e from source");
1:         JDBC.assertColumnNames(rs,  new String[] { "E" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1:         
1:         // these should get type errors
1:         assertStatementError("42821", st, "update target set e = 1");
1:         assertStatementError("42821", st, " update source set p = 1.4e10");
1:         assertStatementError("42821", st,
1:                 " update source set i = date('1001-01-01')");
1:         
1:         st.close();
1:     }
1:     
1:     public void testSyntax_CurrentFunctions() throws SQLException{
1:         ResultSet rs = null;
1:         Statement st = createStatement();
1:         
1:         // tests with current functions:
1:         assertUpdateCount(st, 1, "delete from source");
1:         assertUpdateCount(st, 1, " delete from target");
1: 
1:         st.executeUpdate(" insert into source values (1, 2, '3', " +
1:         		"'4', 5, 6, date('1997-06-07'), time('08:08:08'), " +
1:         		"timestamp('9999-09-09 09:09:09'))");
1: 
1:         // these tests are 'funny' so that the masters won't show 
1:         // a diff every time.
1:         rs = st.executeQuery("select 'pass' from source where current_date = "
1:                 + "current_date and current_time = current_time and "
1:                 + "current_timestamp = current_timestamp");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "pass" } }, true);
1: 
1:         rs = st.executeQuery(" select 'pass' from source where current_date > "
1:                 + "date('1996-12-31') and current_time <= "
1:                 + "time(        '23:59:59') -- may oopsie on leap second days "
1:                 + "and current_timestamp <> timestamp( -- this comment "
1:                 + "is just more whitespace '1996-12-31 00:00:00')");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });        
1:         JDBC.assertFullResultSet(rs, new String[][] { { "pass" } }, true);
1: 
1:         // test with DB2 compatible syntax
1:         rs = st.executeQuery("select 'pass' from source where current date = "
1:                 + "current date and current time = current time and "
1:                 + "current timestamp = current timestamp");
1:         JDBC.assertFullResultSet(rs, new String[][] { { "pass" } }, true);
1: 
1:         rs = st.executeQuery(" select 'pass' from source where current date > "
1:                 + "date('1996-12-31') and current time <= "
1:                 + "time(        '23:59:59') -- may oopsie on leap second days "
1:                 + "and current timestamp <> timestamp( -- this comment "
1:                 + "is just more whitespace '1996-12-31 00:00:00')");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "pass" } }, true);
1:     }
1:     
1:     public void testSyntax_EscapedFunctions() throws SQLException{
1:         ResultSet rs = null;
1:         Statement st = createStatement();
1:         
1:         //CURRENT_DATE escaped function not supported in DB2 UDB 
1:         //CURRENT_TIME escaped function not supported in DB2 UDB
1:         assertStatementError("42X01", st, "select 'pass' from source " +
1:         		"where current_date = {fn current_date()} " +
1:         		"and current_time = {fn current_time()} " +
1:         		"and current_timestamp = current_timestamp");
1: 
1:         rs = st.executeQuery(" select 'pass' from source " +
1:         		"where current_date = {fn curdate()} " +
1:         		"and current_time = {fn curtime()} " +
1:         		"and current_timestamp = current_timestamp");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "pass" } }, true);
1: 
1:         
1:         // current_date() and current_time() not valid in DB2. 
1:         // curdate() and curtime() are as escaped functions only.
1:         assertStatementError("42Y03", st, "values curdate()");
1: 
1:         assertStatementError("42Y03", st, " values curtime()");
1: 
1:         assertStatementError("42X01", st, " values current_date()");
1: 
1:         assertStatementError("42X01", st, " values current_time()");
1: 
1:         assertStatementError("42X01", st, " values {fn current_date()}");
1: 
1:         assertStatementError("42X01", st, " values {fn current_time()}");
1: 
1:         
1:         // DB2 UDB compatible test for escaped functions
1:         rs = st.executeQuery("select 'pass' from source " +
1:         		"where hour(current_time) = {fn hour(current_time)} " +
1:         		"and minute(current_time) = {fn minute(current_time)}" +
1:         		" and second(current_time) = {fn second(current_time)} " +
1:         		"and year(current_date)   = {fn year(current_date)}");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "pass" } }, true);
1: 
1:         
1:         // valid jdbc date and time escaped functions
1:         rs = st.executeQuery("values {fn hour('23:38:10')}");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "23" } }, true);
1: 
1:         rs = st.executeQuery(" values {fn minute('23:38:10')}");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "38" } }, true);
1: 
1:         rs = st.executeQuery(" values {fn second('23:38:10')}");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "10" } }, true);
1: 
1:         rs = st.executeQuery(" values {fn year('2004-03-22')}");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "2004" } }, true);
1: 
1:         
1:         // currents do have types, these inserts fail:
1:         assertStatementError("42821", st,
1:                 "insert into source values (0, 0, '0', '0', 0, 0, "
1:                         + "current_time, current_time, current_timestamp)");
1: 
1:         assertStatementError("42821", st, " insert into source values" +
1:         		" (0, 0, '0', '0', 0, 0, current_date, " +
1:         		"current_timestamp, current_timestamp)");
1: 
1:         assertStatementError("42821", st,
1:                 " insert into source values (0, 0, '0', '0', 0, 0, "
1:                         + "current_date, current_time, current_date)");
1: 
1:         // this insert works
1:         st.executeUpdate("insert into source values (0, 0, '0', '0', 0, 0, "
1:                 + "current_date, current_time, current_timestamp)");
1: 
1:         // test with DB2 syntax this insert works
1:         st.executeUpdate("insert into source values (0, 0, '0', '0', 0, 0, "
1:                 + "current date, current time, current timestamp)");
1: 
1:         // this test will diff if the select is run just after 
1:         // midnight, and the insert above was run just before 
1:         // midnight...
1:         rs = st.executeQuery("select * from source " +
1:         		"where e <> current_date and p <> current_timestamp");
1:         JDBC.assertColumnNames(rs, new String[] { "I", "S", "C", "V", "D", 
1:                 "R", "E", "T", "P" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "1", "2", 
1:             "3", "4", "5.0", "6.0", "1997-06-07", "08:08:08",
1:             "9999-09-09 09:09:09.0" } }, true);
1: 
1:         
1:         // test with DB2 syntax
1:         rs = st.executeQuery("select * from source " +
1:         		"where e <> current date and p <> current timestamp");
1:         JDBC.assertColumnNames(rs, new String[] { "I", "S", "C", "V", 
1:                 "D", "R", "E", "T", "P" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "1", "2", "3",
1:             "4", "5.0", "6.0", "1997-06-07", "08:08:08", 
1:             "9999-09-09 09:09:09.0" } }, true);
1: 
1:         rs = st.executeQuery(" select 'pass' from source " +
1:         		"where e <= current_date and p <= current_timestamp");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "pass" }, { "pass" } }, true);
1: 
1:         // reduce it back to one row
1:         assertUpdateCount(st, 2, "delete from source where i=0");
1:         
1:         st.close();
1:     }
1:     
1:     public void testSyntax_Extract() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         ResultSet rs = st.executeQuery("select year( e), month( e), day( date( "
1:                 + "'1997-01-15')), hour( t), minute( t), second( time( "
1:                 + "'01:01:42')), year( p), month( p), day( p), hour( "
1:                 + "timestamp( '1992-01-01 14:11:23')), minute( p), "
1:                 + "second( p) from source");
1:         JDBC.assertColumnNames(rs, new String[] { "1", "2", "3", "4", 
1:                 "5", "6", "7", "8", "9", "10", "11", "12" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "1997", "6", "15", 
1:             "8", "8", "42", "9999", "9", "9", "14", "9", "9.0" } }, true);
1: 
1:         // extract won't work on other types
1:         assertStatementError("42X25", st, "select month( i) from source");
1: 
1:         assertStatementError("42X25", st, " select hour( d) from source");
1: 
1:         // extract won't work on certain field/type combos
1:         assertStatementError("42X25", st, "select month( t) from source");
1: 
1:         assertStatementError("42X25", st, " select day( t) from source");
1: 
1:         assertStatementError("42X25", st, " select year( t) from source");
1: 
1:         assertStatementError("42X25", st, " select hour( e) from source");
1: 
1:         assertStatementError("42X25", st, " select minute( e) from source");
1: 
1:         assertStatementError("42X25", st, " select second( e) from source");
1: 
1:         assertUpdateCount(st, 1,
1:                 " update source set i=month( e), s=minute( t), d=second( p)");
1: 
1:         // should be true and atomics should match field named as 
1:         // label in date/times
1:         rs = st.executeQuery("select i,e as \"month\",s,t " +
1:                 "as \"minute\",d,p as \"second\" from source " +
1:                 "where (i = month(e)) and (s = minute(t)) " +
1:                 "and (d = second(p))");
1:         JDBC.assertColumnNames(rs, new String[] { "I", "month", 
1:                 "S", "minute", "D", "second" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "6", "1997-06-07", 
1:                 "8", "08:08:08", "9.0", "9999-09-09 09:09:09.0" } }, true);
1: 
1:         // fields should match the fields in the date (in order)
1:         rs = st.executeQuery("select p, year( p) as \"year\", month( p) as "
1:                 + "\"month\", day( p) as \"day\", hour( p) as "
1:                 + "\"hour\", minute( p) as \"minute\", second( p) as "
1:                 + "\"second\" from source");
1:         JDBC.assertColumnNames(rs, new String[] { "P", "year", "month", 
1:                 "day", "hour", "minute", "second" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { 
1:             "9999-09-09 09:09:09.0", "9999", "9", "9",
1:             "9", "9", "9.0" } }, true);
1: 
1:         
1:         // jdbc escape sequences
1:         rs = st.executeQuery("values ({d '1999-01-12'}, {t '11:26:35'}, {ts "
1:                 + "'1999-01-12 11:26:51'})");
1:         JDBC.assertColumnNames(rs, new String[] { "1", "2", "3" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "1999-01-12", 
1:                 "11:26:35", "1999-01-12 11:26:51.0" } }, true);
1: 
1:         rs = st.executeQuery(" values year( {d '1999-01-12'})");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "1999" } }, true);
1: 
1:         rs = st.executeQuery(" values hour( {t '11:28:10'})");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "11" } }, true);
1: 
1:         rs = st.executeQuery(" values day( {ts '1999-01-12 11:28:23'})");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "12" } }, true);
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * Random tests for date.
1:      */
1:     public void testRandom() throws SQLException{        
1:         Statement st = createStatement();
1:         
1:         st.executeUpdate("create table sertest(d date, s Date, o Date)");
1:         st.executeUpdate(" insert into sertest values (date('1992-01-03'), " +
1:         		"null, null)");
1:         
1:         ResultSet rs = st.executeQuery(" select * from sertest");
1:         JDBC.assertColumnNames(rs, new String[] { "D", "S", "O" });
1:         JDBC.assertFullResultSet(rs,
1:                 new String[][] { { "1992-01-03", null, null } }, true);
1:         
1:         assertUpdateCount(st, 1, " update sertest set s=d");
1:         assertUpdateCount(st, 1, " update sertest set o=d");
1:         st.executeUpdate(" insert into sertest values (date( '3245-09-09'), "
1:                 + "date( '1001-06-07'), date( '1999-01-05'))");
1:         
1:         rs = st.executeQuery(" select * from sertest");
1:         JDBC.assertColumnNames(rs, new String[] { "D", "S", "O" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "1992-01-03", 
1:                 "1992-01-03", "1992-01-03" }, { "3245-09-09", "1001-06-07", 
1:                     "1999-01-05" } }, true);
1: 
1:         rs = st.executeQuery(" select * from sertest where d > s");
1:         JDBC.assertColumnNames(rs, new String[] { "D", "S", "O" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "3245-09-09", 
1:                 "1001-06-07", "1999-01-05" } }, true);
1: 
1:         assertUpdateCount(st, 2, " update sertest set d=s");
1: 
1:         // should get type errors:
1:         assertStatementError("42821", st,
1:                 "insert into sertest values (date('3245-09-09'), "
1:                         + "time('09:30:25'), null)");
1: 
1:         assertStatementError("42821", st,
1:                 " insert into sertest values (null, null, time('09:30:25'))");
1: 
1:         assertStatementError("42821", st,
1:                 " insert into sertest values (null, null, "
1:                         + "timestamp('1745-01-01 09:30:25'))");
1: 
1:         assertUpdateCount(st, 2, "update sertest set d=o");
1: 
1:         rs = st.executeQuery(" select * from sertest where s is null " +
1:         		"and o is not null");
1:         JDBC.assertColumnNames(rs, new String[] { "D", "S", "O" });
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         rs = st.executeQuery("select month(s) from sertest " +
1:         		"where s is not null");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "1" }, { "6" } },
1:                 true);
1: 
1:         rs = st.executeQuery(" select day(o) from sertest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "3" }, { "5" } }, 
1:                 true);
1: 
1:         dropTable("sertest");
1:     }
1:     
1:     public void testConvertFromString() throws SQLException{        
1:         Statement st = createStatement();
1:         
1:         st.executeUpdate("create table convstrtest(d varchar(30), t char(30), "
1:                 + "ts long varchar)");
1:         st.executeUpdate(" insert into convstrtest values('1932-03-21',  "
1:                 + "'23:49:52', '1832-09-24 10:11:43.32')");
1:         st.executeUpdate(" insert into convstrtest values(null, null, null)");
1: 
1:         assertStatementError("22007", st,
1:                 "select CAST (d AS time) from convstrtest");
1: 
1:         assertStatementError("22007", st,
1:                 " select CAST (t AS date) from convstrtest");
1: 
1:         assertStatementError("42846", st,
1:                 " select CAST (ts AS time) from convstrtest");
1: 
1:         assertStatementError("42846", st,
1:                 " select CAST (ts AS date) from convstrtest");
1: 
1: 
1:         ResultSet rs = st.executeQuery("select CAST (t AS time) from convstrtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "23:49:52" }, 
1:                 { null } }, true);
1: 
1:         rs = st.executeQuery(" select CAST (d AS date) from convstrtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "1932-03-21" }, { null } }, true);
1: 
1:         // show time and date separately as timestamp will be 
1:         // filtered out
1:         assertStatementError("42846", st, "select " +
1:                 "CAST(CAST (ts AS timestamp) AS date), " +
1:                 "CAST(CAST (ts AS timestamp) AS time) from convstrtest");
1: 
1:         dropTable("convstrtest");
1:         
1:         st.close();
1:     }
1:     
1:     public void testConversion_Aggregates() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         //test aggregates sum should fail
1:         assertStatementError("42Y22", st, "select sum(d) from convtest");
1: 
1:         assertStatementError("42Y22", st, " select sum(t) from convtest");
1: 
1:         assertStatementError("42Y22", st, " select sum(ts) from convtest");
1: 
1:         // these should work
1:         ResultSet rs = st.executeQuery("select count(d) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "2" }, }, true);
1: 
1:         rs = st.executeQuery(" select count(t) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "2" }, }, true);
1: 
1:         rs = st.executeQuery(" select count(ts) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "2" }, }, true);
1: 
1:         st.executeUpdate(" insert into convtest values(date('0001-03-21'),  "
1:                 + "time('5:22:59'), timestamp('9999-12-31 23:59:59.999999'))");
1: 
1:         // distinct count should be 2 not 3
1:         rs = st.executeQuery("select count(distinct d) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "2" }, }, true);
1: 
1:         rs = st.executeQuery(" select count(distinct t) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "2" }, }, true);
1: 
1:         rs = st.executeQuery(" select count(distinct ts) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "2" }, }, true);
1: 
1:         // min should not be null!!!!!!!!
1:         rs = st.executeQuery("select min(d) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "0001-03-21" }, }, 
1:                 true);
1: 
1:         rs = st.executeQuery(" select min(t) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "05:22:59" }, }, true);
1: 
1:         // show time and date separately as timestamp will be 
1:         // filtered out
1:         rs = st.executeQuery("select " +
1:                 "CAST(CAST (min(ts) AS timestamp) AS date), " +
1:                 "CAST(CAST (min(ts) AS timestamp) AS time) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1", "2" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "1832-09-24", 
1:             "10:11:43" }, }, true);
1: 
1:         rs = st.executeQuery(" select max(d) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "1932-03-21" }, }, true);
1: 
1:         rs = st.executeQuery(" select max(t) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs,
1:                 new String[][] { { "23:49:52" }, }, true);
1: 
1:         // show time and date separately as timestamp will be 
1:         // filtered out
1:         rs = st.executeQuery("select " +
1:                 "CAST(CAST (max(ts) AS timestamp) AS date), " +
1:                 "CAST(CAST (max(ts) AS timestamp) AS time) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1", "2" });
1:         JDBC.assertFullResultSet(rs,
1:                 new String[][] { { "9999-12-31", "23:59:59" }, }, true);
1:         
1:         //just to recover the test environment
1:         dropTable("convtest");
1:         createTableForConversionTest(st);
1: 
1:         st.close();
1:     }
1:     
1:     public void testConversion() throws SQLException{        
1:         Statement st = createStatement();
1:         
1:         // these should fail
1:         assertStatementError("42846", st, 
1:                 "select CAST (d AS time) from convtest");
1: 
1:         assertStatementError("42846", st,
1:                 " select CAST (t AS date) from convtest");
1: 
1:         // these should work
1:         ResultSet rs = st.executeQuery(
1:                 "select CAST (t AS time) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "23:49:52" }, 
1:                 { "05:22:59" }, { null } }, true);
1: 
1:         rs = st.executeQuery(" select CAST (d AS date) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "1932-03-21" },
1:                 { "0001-03-21" }, { null } }, true);
1: 
1:         rs = st.executeQuery(" select CAST (ts AS time) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "10:11:43" }, 
1:                 { "23:59:59" }, { null } }, true);
1: 
1:         rs = st.executeQuery(" select CAST (ts AS date) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "1832-09-24" }, 
1:                 { "9999-12-31" }, { null } }, true);
1: 
1:         // show time and date separately as timestamp will be 
1:         // filtered out
1:         rs = st.executeQuery("select CAST(CAST (ts AS timestamp) AS date), " +
1:         		"CAST(CAST (ts AS timestamp) AS time) from convtest");
1:         JDBC.assertColumnNames(rs, new String[] { "1", "2" });
1: 
1:         JDBC.assertFullResultSet(rs, new String[][] { { "1832-09-24", 
1:                 "10:11:43" }, { "9999-12-31", "23:59:59" }, 
1:                 { null, null } }, true);
1: 
1:         // casting from a time to a timestamp sets the date to 
1:         // current date
1:         assertStatementError("42846", st, "select 'pass', " +
1:         		"CAST (CAST(t AS timestamp) AS time) from convtest " +
1:         		"where CAST(CAST(t AS timestamp) AS date)=current_date");
1: 
1:         // time should be 0
1:         assertStatementError("42846", st, "select " +
1:         		"CAST (CAST (d AS timestamp) AS date), " +
1:         		"CAST(CAST(d AS timestamp) AS time) from convtest");
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * leading zeros may be omitted from the month, 
1:      * day and part of the timestamp.
1:      */
1:     public void testISOFormat_OmitLeadingZero() throws SQLException{
1:         Statement st = createStatement();
1: 
1:         assertEquals(1, st.executeUpdate(
1:                 "insert into ts values ('2003-03-05-17.05.43.111111', " +
1:                 "'2003-03-05 17:05:43.111111')"));
1: 
1:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:         		"('2003-3-03-17.05.43.111111', '2003-3-03 17:05:43.111111')"));
1: 
1:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:         		"('2003-3-2-17.05.43.111111', '2003-3-2 17:05:43.111111')"));
1: 
1:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:         		"('2003-03-2-17.05.43.111111', '2003-03-2 17:05:43.111111')"));
1: 
1:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:         		"('2003-3-1-17.05.43.1', '2003-3-1 17:05:43.1')"));
1: 
1:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:         		"('2003-3-1-17.05.43.12', '2003-3-1 17:05:43.12')"));
1: 
1:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:         		"('2003-3-1-17.05.43.123', '2003-3-1 17:05:43.123')"));
1: 
1:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:         		"('2003-3-1-17.05.43.1234', '2003-3-1 17:05:43.1234')"));
1: 
1:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:         		"('2003-3-1-17.05.43.12345', '2003-3-1 17:05:43.12345')"));
1: 
1:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:         		"('2003-3-1-17.05.43.123456', '2003-3-1 17:05:43.123456')"));
1: 
1:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:         		"('2003-3-1-17.05.43', '2003-3-1 17:05:43')"));
1:         
1:         st.close();
1:     }    
1:     
1:     /**
1:      *Trailing blanks are allowed.
1:      */
1:     public void testISOFormat_TrailingBlanks() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         assertEquals(1, st.executeUpdate("insert into ts values " +
1:         		"('2002-03-05-17.05.43.111111  ', " +
1:         		"'2002-03-05 17:05:43.111111   ')"));
1: 
1:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:         		"('2002-03-05-17.05.43.1   ', '2002-03-05 17:05:43.1   ')"));
1: 
1:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:         		"('2002-03-05-17.05.43    ', '2002-03-05 17:05:43    ')"));
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      *  UDB allows this by "appending a zero"; so, cloudscape follows.
1:      */
1:     public void testISOFormat_TrailingZero() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         assertEquals(1, st.executeUpdate("insert into ts values " +
1:         		"('2003-3-1-17.05.43.', '2003-3-1 17:05:43')"));
1: 
1:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:         		"('2003-3-1-17.05.43.0', '2003-3-1 17:05:43.0')"));
1: 
1:         assertEquals(1, st.executeUpdate(" insert into ts values " +
1:         		"('0003-03-05-17.05.43.111111'," +
1:         		" '0003-03-05 17:05:43.111111')"));
1:         
1:         ResultSet rs = st.executeQuery(" select count(*) from ts " +
1:         		"where ts1=ts2");
1:         rs.next();
1:         int rows = rs.getInt(1);
1:         rs = st.executeQuery(" select count(*) from ts ");
1:         rs.next();
1:         assertEquals(rows, rs.getInt(1));
1:         
1:         st.executeUpdate(" delete from ts");
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * Should be rejected because leading zero in year is missing.
1:      */
1:     public void testISOFormat_LeadingZero() throws SQLException{
1:         Statement st = createStatement();
1:                 
1:         assertStatementError("22007", st,
1:                 "insert into ts (ts1) values ('03-03-05-17.05.43.111111')");
1: 
1:         assertStatementError("22007", st,
1:                 " insert into ts (ts1) values ('103-03-05-17.05.43.111111')");
1: 
1:         assertStatementError("22007", st,
1:                 " insert into ts (ts1) values ('3-03-05-17.05.43.111111')");
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * not valid Time format in the timestamp strings:  cloudscape rejects
1:      */
1:     public void testISOFormat_WrongTimestampFormat() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         assertStatementError("22007", st,
1:                 "insert into ts (ts1) values ('2003-3-24-13.1.02.566999')");
1: 
1:         assertStatementError("22007", st,
1:                 " insert into ts (ts1) values ('2003-3-24-13.1.1.569')");
1: 
1:         assertStatementError("22007", st,
1:                 " insert into ts (ts1) values ('2003-3-24-1.1.1.56')");
1: 
1:         assertStatementError("22007", st,
1:                 " insert into ts (ts1) values ('2003-3-24-1.1.1')");
1: 
1:         assertStatementError("22007", st,
1:                 " insert into ts (ts1) values ('2003-3-1-17.05.4.')");
1: 
1:         assertEquals(1, st.executeUpdate(" insert into ts (ts1) values " +
1:         		"('2003-03-05-7.05.43.111111')"));
1: 
1:         // invalid ISO format: cloudscape rejects
1: 
1:         assertStatementError("22007", st,
1:                 "insert into ts (ts1) values ('2003-3-1 17.05.43.123456')");
1:         
1:         st.close();
1:     }
1:     
1:     /**
0:      *  Don't allow more than microseconds in ISO format: cloudscape rejects.
1:      */
0:     public void testISOFormat_MoreThanMicroseconds() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         assertStatementError("22007", st, "insert into ts (ts1) values "
0:                 + "('2003-03-05-17.05.43.999999999')");
1: 
1:         assertStatementError("22007", st, " insert into ts (ts1) values "
0:                 + "('2003-03-05-17.05.43.999999000')");
1: 
1:         st.close();
1:     }
1:     
1:     /**
1:      * Test the timestamp( d, t) function.
1:      */
1:     public void testTimeStampFunction() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         st .executeUpdate("create table tt " +
1:         		"(datecol date, dateStr varchar(16), timecol time, " +
1:         		"timeStr varchar(16), expected timestamp)");
1: 
1:         st.executeUpdate(" insert into tt ( dateStr, timeStr) " +
1:         		"values( '2004-03-04', '12:01:02')");
1: 
1:         st.executeUpdate(" insert into tt ( dateStr, timeStr) " +
1:         		"values( null, '12:01:03')");
1: 
1:         st.executeUpdate(" insert into tt ( dateStr, timeStr) " +
1:         		"values( '2004-03-05', null)");
1: 
1:         assertUpdateCount(st, 3, " update tt  set datecol = date( dateStr), " +
1:         		"timecol = time( timeStr)");
1: 
1:         assertUpdateCount(st, 1, " update tt  set expected = " +
1:         		"timestamp( dateStr || ' ' || timeStr) " +
1:         		"where dateStr is not null and timeStr is not null");
1: 
1:         ResultSet rs = st.executeQuery(" select dateStr, timeStr from tt " +
1:         		"where (expected is not null and (expected <> " +
1:         		"timestamp( dateCol, timeCol) or " +
1:         		"timestamp( dateCol, timeCol) is null)) or " +
1:         		"(expected is null and " +
1:         		"timestamp( dateCol, timeCol) is not null)");
1:         JDBC.assertColumnNames(rs, new String[] { "DATESTR", "TIMESTR" });
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         rs = st.executeQuery(" select dateStr, timeStr from tt " +
1:         		"where (expected is not null and (expected <> " +
1:         		"timestamp( dateStr, timeStr) or " +
1:         		"timestamp( dateStr, timeStr) is null)) " +
1:         		"or (expected is null and " +
1:         		"timestamp( dateStr, timeStr) is not null)");
1: 
1:         JDBC.assertColumnNames(rs, new String[] { "DATESTR", "TIMESTR" });
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         rs = st.executeQuery(" select dateStr, timeStr from tt " +
1:         		"where (expected is not null and " +
1:         		"timestamp( dateStr, timeStr) <> timestamp( dateCol, timeCol))" +
1:         		" or (expected is null and " +
1:         		"timestamp( dateStr, timeStr) is not null)");
1: 
1:         JDBC.assertColumnNames(rs, new String[] { "DATESTR", "TIMESTR" });
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         rs = st.executeQuery(" select dateStr, timeStr from tt " +
1:         		"where expected is not null and " +
1:         		"date( timestamp( dateCol, timeCol)) <> dateCol");
1:         JDBC.assertColumnNames(rs, new String[] { "DATESTR", "TIMESTR" });
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         rs = st.executeQuery(" select dateStr, timeStr from tt " +
1:         		"where expected is not null and " +
1:         		"time( timestamp( dateCol, timeCol)) <> timeCol");
1:         JDBC.assertColumnNames(rs, new String[] { "DATESTR", "TIMESTR" });
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         // Error cases
1:         assertStatementError("42Y95", st,
1:                 "select timestamp( dateCol, dateCol) from tt where "
1:                         + "dateCol is not null");
1: 
1:         assertStatementError("42Y95", st,
1:                 " select timestamp( timeCol, timeCol) from tt where "
1:                         + "timeCol is not null");
1: 
1:         assertStatementError("22007", st,
1:                 "values timestamp( 'xyz', '12:01:02')");
1: 
1:         assertStatementError("22007", st,
1:                 " values timestamp( '2004-03-04', 'xyz')");
1: 
1:         dropTable("tt");
1:         
1:         st.close();
1:     }
1:     
1:     public void testFormat() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         st.executeUpdate(" create table t_format (t time)");
1: 
1:         // ISO format: UDB is okay.
1:         assertEquals(1, 
1:                 st.executeUpdate("insert into t_format values ('17.05.44')"));
1: 
1:         assertEquals(1, 
1:                 st.executeUpdate(" insert into t_format values ('17.05.00')"));
1: 
1:         assertEquals(1, 
1:                 st.executeUpdate(" insert into t_format values ('00.05.43')"));
1: 
1:         assertEquals(1, 
1:                 st.executeUpdate(" insert into t_format values ('00.00.00')"));
1: 
1:         // DB2 keeps '24:00:00' but Cloudcape returns '00:00:00'
1:         assertEquals(1, 
1:                 st.executeUpdate("insert into t_format values ('24.00.00')"));
1: 
1:         // trailing blanks are allowed
1:         assertEquals(1, 
1:                 st.executeUpdate("insert into t_format values ('17.05.11  ')"));
1: 
1:         assertEquals(1, 
1:                 st.executeUpdate(" insert into t_format values ('17:05:11  ')"));
1: 
1:         // seconds can be omitted
1:         assertEquals(1, 
1:                 st.executeUpdate("insert into t_format values ('1:01')"));
1: 
1:         assertEquals(1, 
1:                 st.executeUpdate(" insert into t_format values ('1:02 ')"));
1: 
1:         assertEquals(1, 
1:                 st.executeUpdate(" insert into t_format values ('2.01')"));
1: 
1:         assertEquals(1, 
1:                 st.executeUpdate(" insert into t_format values ('2.02 ')"));
1: 
1:         // 11 rows
1:         ResultSet rs = st.executeQuery("select * from t_format");
1:         JDBC.assertColumnNames(rs, new String[] { "T" });
1: 
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "17:05:44" }, { "17:05:00" },
1:                 { "00:05:43" }, { "00:00:00" }, { "00:00:00" }, { "17:05:11" },
1:                 { "17:05:11" }, { "01:01:00" }, { "01:02:00" }, { "02:01:00" },
1:                 { "02:02:00" } }, true);
1:         assertUpdateCount(st, 11, " delete from t_format");
1: 
1:         // end value tests...
1:         assertStatementError("22007", st, "insert into t_format values ('24.60.60')");
1: 
1:         assertStatementError("22007", st, " insert into t_format values ('04.00.60')");
1: 
1:         assertStatementError("22007", st, " insert into t_format values ('03.60.00')");
1: 
1:         // not valid Time string ISO format: HH.MM.SS
1:         assertStatementError("22007", st, 
1:                 "insert into t_format values ('07.5.44')");
1: 
1:         assertStatementError("22007", st, 
1:                 " insert into t_format values ('07.05.4')");
1: 
1:         assertStatementError("22007", st, 
1:                 " insert into t_format values ('7.5.44')");
1: 
1:         assertStatementError("22007", st, 
1:                 " insert into t_format values ('7.5.4')");
1: 
1:         assertStatementError("22007", st, 
1:                 " insert into t_format values ('7.5.0')");
1: 
1:         assertStatementError("22007", st, 
1:                 " insert into t_format values ('-4.00.00')");
1: 
1:         assertStatementError("22007", st, 
1:                 " insert into t_format values ('A4.00.00')");
1: 
1:         assertStatementError("22007", st, 
1:                 " insert into t_format values ('7.5.999')");
1: 
1:         assertStatementError("22007", st, 
1:                 " insert into t_format values ('07.05.111')");
1: 
1:         assertStatementError("22007", st, 
1:                 " insert into t_format values ('111.05.11')");
1: 
1:         assertStatementError("22007", st, 
1:                 " insert into t_format values ('11.115.00')");
1: 
1:         // no row
1:         rs = st.executeQuery("select * from t_format");
1:         JDBC.assertColumnNames(rs, new String[] { "T" });
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         dropTable("t_format");
1:         
1:         st.close();
1:     }
1: 
1:     public void testFormat_Additional() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         ResultSet rs = st .executeQuery(
1:         		"values time('2004-04-15 16:15:32.387')");
1:         JDBC.assertFullResultSet(rs, new String[][] { { "16:15:32" } }, true);
1: 
1:         rs = st.executeQuery(" values time('2004-04-15-16.15.32.387')");
1:         JDBC.assertFullResultSet(rs, new String[][] { { "16:15:32" } }, true);
1: 
1:         assertStatementError("22007", st,
1:                 " values time('2004-04-15-16.15.32.387 zz')");
1: 
1:         assertStatementError("22007", st,
1:                 " values time('x-04-15-16.15.32.387')");
1: 
1:         rs = st.executeQuery(" values date('2004-04-15 16:15:32.387')");
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "2004-04-15" } }, true);
1: 
1:         rs = st.executeQuery(" values date('2004-04-15-16.15.32.387')");
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "2004-04-15" } }, true);
1: 
1:         assertStatementError("22008", st,
1:                 " values date('2004-04-15-16.15.32.387 zz')");
1: 
1:         assertStatementError("22008", st,
1:                 " values date('2004-04-15-16.15.32.y')");
1: 
1:         rs = st.executeQuery(" values time('13:59')");
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "13:59:00" } }, true);
1: 
1:         rs = st.executeQuery(" values time('1:00')");
1:         JDBC.assertFullResultSet(rs, new String[][] { { "01:00:00" } }, true);
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * Test unary date and datetime functions. 
1:      * Test with both constant and variable arguments.
1:      */
1:     public void test_DateAndDatetimeFunctionsMore() throws Exception {
1:         ResultSet rs = null;
1:         ResultSetMetaData rsmd;
1:         PreparedStatement pSt;
1:         Statement st = createStatement();
1: 
1:         String[][] expRS;
1:         String[] expColNames;      
1: 
1:         setAutoCommit(false);
1:         // test date(integer)
1:         st.executeUpdate("create table t_func( i int, d date)");
1: 
1:         commit();
1:         st.executeUpdate(" insert into t_func values( 1, date(1)),(10, " + 
1:                 "date(10.1)),(365,date(365.1e0)),(366,date(366)),(789" + 
1:                 ",date(789)),(790,date(790)),(791,date(791))");
1: 
1:         // should fail
1:         assertStatementError("22008", st, "insert into t_func values( 0, date(0))");
1: 
1:         assertStatementError("22008", st,
1:                 " insert into t_func values( -1, date(-1))");
1: 
1:         assertStatementError("22008", st,
1:                 " insert into t_func values( 3652060, date( 3652060))");
1: 
1:         rs = st.executeQuery(" select i,d,date(i),date(d) from t_func order by i");
1:         JDBC.assertColumnNames(rs, new String[] { "I", "D", "3", "4" });
1:         JDBC.assertFullResultSet(rs, new String[][] {
1:                 { "1", "1970-01-01", "1970-01-01", "1970-01-01" },
1:                 { "10", "1970-01-10", "1970-01-10", "1970-01-10" },
1:                 { "365", "1970-12-31", "1970-12-31", "1970-12-31" },
1:                 { "366", "1971-01-01", "1971-01-01", "1971-01-01" },
1:                 { "789", "1972-02-28", "1972-02-28", "1972-02-28" },
1:                 { "790", "1972-02-29", "1972-02-29", "1972-02-29" },
1:                 { "791", "1972-03-01", "1972-03-01", "1972-03-01" } }, true);
1: 
1:         rollback();
1: 
1:         assertEquals(1, st.executeUpdate(" insert into t_func(i) values( 0)"));
1:         
1:         assertStatementError("22008", st, " select date(i) from t_func");
1: 
1:         rollback();
1: 
1:         st.executeUpdate(" insert into t_func(i) values( -1)");
1: 
1:         assertStatementError("22008", st, " select date(i) from t_func");
1:         rollback();
1: 
1:         st.executeUpdate(" insert into t_func(i) values( 3652060)");
1:         assertStatementError("22008", st, " select date(i) from t_func");
1:         rollback();
1: 
1:         st.executeUpdate(" drop table t_func");
1:         
1:         st.executeUpdate(" create table t_func( s varchar(32), d date)");
1: 
1:         commit();
1:         assertEquals(6, st.executeUpdate(" insert into t_func " +
1:         		"values('1900060', date('1900060')), ('1904060', " +
1:         		"date('1904060')), ('1904366', date('1904366')), " +
1:         		"('2000060', date('2000060')), ('2001060'," +
1:         		" date('2001060')), ('2001365', date('2001365'))"));
1: 
1:         rs = st.executeQuery(" select s,d,date(s) from t_func order by s");
1:         JDBC.assertColumnNames(rs, new String[] { "S", "D", "3" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "1900060", "1900-03-01", "1900-03-01" },
1:                 { "1904060", "1904-02-29", "1904-02-29" },
1:                 { "1904366", "1904-12-31", "1904-12-31" },
1:                 { "2000060", "2000-02-29", "2000-02-29" },
1:                 { "2001060", "2001-03-01", "2001-03-01" },
1:                 { "2001365", "2001-12-31", "2001-12-31" } }, true);
1: 
1:         rollback();
1: 
1:         // failure cases
1:         assertStatementError("22008", st, "values( date('2001000'))");
1: 
1:         assertStatementError("22008", st, " values( date('2001366'))");
1: 
1:         assertStatementError("22008", st, " values( date('2000367'))");
1: 
1:         assertStatementError("22008", st, " values( date('xxxxxxx'))");
1: 
1:         st.executeUpdate(" insert into t_func(s) values( '2001000')");
1: 
1:         assertStatementError("22008", st, "select date(s) from t_func");
1:         rollback();
1: 
1:         st.executeUpdate(" insert into t_func(s) values( '2001366')");
1: 
1:         assertStatementError("22008", st, "select date(s) from t_func");
1:         rollback();
1: 
1:         st.executeUpdate(" insert into t_func(s) values( '2000367')");
1: 
1:         assertStatementError("22008", st, "select date(s) from t_func");
1:         rollback();
1: 
1:         st.executeUpdate(" insert into t_func(s) values( 'xxxxxxx')");
1: 
1:         assertStatementError("22008", st, "select date(s) from t_func");
1:         rollback();
1: 
1:         // test parameter
1:         pSt = prepareStatement("values( date(cast(? as integer))," +
1:         		"timestamp(cast(? as varchar(32))))");
1:         rs = st.executeQuery("values(cast(1 as integer), " +
1:         		"'2003-03-05-17.05.43.111111')");
1: 
1:         rs.next();
1:         rsmd = rs.getMetaData();
1:         for (int i = 1; i <= rsmd.getColumnCount(); i++)
1:             pSt.setObject(i, rs.getObject(i));
1:         
1:         rs = pSt.executeQuery();
1:         JDBC.assertColumnNames(rs, new String[] { "1", "2" });
0:         // See DERBY-3856 - there's a diff between Embedded and DerbyNetClient
0:         // in how the cast returns the following...
0:         if (usingDerbyNetClient())
0:             JDBC.assertFullResultSet(rs, new String[][] { { "1970-01-01",
1:             "2003-03-05 17:05:43.111111" } }, true);
0:         else
0:             JDBC.assertFullResultSet(rs, new String[][] { { "1970-01-01",
0:                 "2003-03-05-17.05.43.111111" } }, true);
1: 
1:         rs = st.executeQuery("values(2, '20030422190200')");
1:         rs.next();
1:         rsmd = rs.getMetaData();
1:         for (int i = 1; i <= rsmd.getColumnCount(); i++)
1:             pSt.setObject(i, rs.getObject(i));
1: 
1:         rs = pSt.executeQuery();
1:         JDBC.assertColumnNames(rs, new String[] { "1", "2" });
1:         JDBC.assertFullResultSet(rs, new String[][] { { "1970-01-02", 
1:                 "2003-04-22 19:02:00.0" } }, true);
1: 
1:         rs = st.executeQuery(" values( date(date(1)), "
1:                 + "date(timestamp('2003-03-05-17.05.43.111111')))");
1:         JDBC.assertColumnNames(rs, new String[] { "1", "2" });
1:         JDBC.assertFullResultSet(rs, 
1:                 new String[][] { { "1970-01-01", "2003-03-05" } }, true);
1: 
1:         st.executeUpdate(" drop table t_func");
1:         
1:         
1:         st.executeUpdate(" create table t_func( s varchar(32), ts timestamp, " + 
1:                 "expected timestamp)");
1: 
1:         commit();
1:         st.executeUpdate(" insert into t_func(ts) values( " +
1:                 "timestamp('2003-03-05-17.05.43.111111'))");
1: 
1:         rs = st.executeQuery(" select date(ts) from t_func");
1: 
1:         expColNames = new String[] { "1" };
1:         JDBC.assertColumnNames(rs, expColNames);
1: 
1:         expRS = new String[][] { { "2003-03-05" } };
1: 
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         rollback();
1: 
1:         // Test special unary timestamp function rules: yyyyxxddhhmmss
1:         st.executeUpdate("insert into t_func values('20000228235959', " + 
1:                 "timestamp('20000228235959'), '2000-02-28-23.59.59'), " +
1:                 "('20000229000000', timestamp('20000229000000'), " +
1:                 "'2000-02-29-00.00.00')");
1: 
1:         rs = st.executeQuery(" select s from t_func where ts <> expected or " + 
1:                 "timestamp(s) <> expected or timestamp(ts) <> expected");
1:         JDBC.assertColumnNames(rs, new String[] { "S" });
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         rollback();
1: 
1:         // invalid
1:         assertStatementError("22008", st,
1:                 "values( timestamp('2000 1 1 0 0 0'))");
1: 
1:         assertStatementError("22008", st,
1:                 " values( timestamp('aaaaaaaaaaaaaa'))");
1: 
1:         assertEquals(1, st.executeUpdate(
1:                 " insert into t_func(s) values('2000 1 1 0 0 0')"));
1:         
1:         assertStatementError("22008", st, " select timestamp(s) from t_func");
1: 
1:         rollback();
1:         assertEquals(1, st.executeUpdate(
1:                 " insert into t_func(s) values('aaaaaaaaaaaaaa')"));
1:         assertStatementError("22008", st, " select timestamp(s) from t_func");
1:         rollback();
1: 
1:         commit();
1: 
1:         getConnection().rollback();
1:         st.close();
1:     }
1:     
1:     /**
1:      *  Null values in datetime scalar functions.
1:      */
1:     public void testNulls() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         st.executeUpdate("create table nulls (t time, d date, ts timestamp)");
1: 
1:         st.executeUpdate(" insert into nulls values (null,null,null)");
1: 
1:         commit();
1:         assertStatementError("42X25", st, " select year(t) from nulls");
1: 
1:         assertStatementError("42X25", st, " select month(t) from nulls");
1: 
1:         assertStatementError("42X25", st, " select day(t) from nulls");
1: 
1:         ResultSet rs = st.executeQuery(" select hour(t) from nulls");
1:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1: 
1:         rs = st.executeQuery(" select minute(t) from nulls");
1:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1: 
1:         rs = st.executeQuery(" select second(t) from nulls");
1:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1: 
1:         rs = st.executeQuery(" select year(d) from nulls");
1:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1: 
1:         rs = st.executeQuery(" select month(d) from nulls");
1:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1: 
1:         rs = st.executeQuery(" select day(d) from nulls");
1:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1: 
1:         assertStatementError("42X25", st, " select hour(d) from nulls");
1: 
1:         assertStatementError("42X25", st, " select minute(d) from nulls");
1: 
1:         assertStatementError("42X25", st, " select second(d) from nulls");
1: 
1:         rs = st.executeQuery(" select year(ts) from nulls");
1:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1: 
1:         rs = st.executeQuery(" select month(ts) from nulls");
1:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1: 
1:         rs = st.executeQuery(" select day(ts) from nulls");
1:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1: 
1:         rs = st.executeQuery(" select hour(ts) from nulls");
1:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1: 
1:         rs = st.executeQuery(" select minute(ts) from nulls");
1:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1: 
1:         rs = st.executeQuery(" select second(ts) from nulls");
1:         JDBC.assertFullResultSet(rs, new String[][] { { null } }, true);
1: 
1:         st.executeUpdate(" drop table nulls");
1:         
1:         st.close();
1:     }
1: }
============================================================================