1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.ValueNodeList
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
17:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:f33fbaf: import java.util.List;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:f33fbaf: import org.apache.derby.iapi.services.loader.ClassFactory;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1:3bb140c: import org.apache.derby.iapi.store.access.Qualifier;
1:eac0369: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:244952e: import org.apache.derby.iapi.types.StringDataValue;
1:eac0369: import org.apache.derby.iapi.types.TypeId;
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
3:eac0369: /**
1:eac0369:  * A ValueNodeList represents a list of ValueNodes within a specific predicate 
1:3bb140c:  * e.g. IN list, NOT IN list or BETWEEN in a DML statement.
1:eac0369:  */
1:eac0369: 
1:e1f49ca: class ValueNodeList extends QueryTreeNodeVector<ValueNode>
1:eac0369: {
1:3bb140c:     ValueNodeList(ContextManager cm) {
1:e1f49ca:         super(ValueNode.class, cm);
1:3bb140c:     }
1:3bb140c: 
1:5d7388d: 	/**
1:eac0369: 	 * Add a ValueNode to the list.
9:eac0369: 	 *
1:eac0369: 	 * @param valueNode	A ValueNode to add to the list
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void addValueNode(ValueNode valueNode) throws StandardException
1:eac0369: 	{
1:eac0369: 		addElement(valueNode);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this expression.  This means binding the sub-expressions,
1:eac0369: 	 * as well as figuring out what the return type is for this expression.
1:eac0369: 	 *
1:eac0369: 	 * @param fromList		The FROM list for the query this
1:eac0369: 	 *				expression is in, for binding columns.
1:eac0369: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
1:09c2697:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:71c8e86:     void bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 
2:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:e1f49ca:             ValueNode vn = elementAt(index);
1:09c2697:             vn = vn.bindExpression(fromList, subqueryList, aggregates);
1:eac0369: 
1:eac0369: 			setElementAt(vn, index);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * Generate a SQL-&gt;Java-&gt;SQL conversion tree any node in the list
1:eac0369: 	 * which is not a system built-in type.
1:eac0369: 	 * This is useful when doing comparisons, built-in functions, etc. on
1:eac0369: 	 * java types which have a direct mapping to system built-in types.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException	Thrown on error
1:eac0369: 	 */
1:3bb140c:     void genSQLJavaSQLTrees()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:e1f49ca:             ValueNode valueNode = elementAt(index);
1:eac0369: 			
1:08d6ce2: 			if (valueNode.getTypeId().userType())
1:eac0369: 			{
1:eac0369: 				setElementAt(valueNode.genSQLJavaSQLTree(), index);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:2364fd8: 	 * Get the dominant DataTypeServices from the elements in the list. This
1:2364fd8: 	 * method will also set the correct collation information on the dominant
1:cfdc68f: 	 * DataTypeService if we are dealing with character string datatypes.
1:eac0369: 	 *  
1:2364fd8: 	 * Algorithm for determining collation information
1:2364fd8: 	 * This method will check if it is dealing with character string datatypes.
1:244952e: 	 * If yes, then it will check if all the character string datatypes have
1:244952e: 	 * the same collation derivation and collation type associated with them.
1:244952e: 	 * If not, then the resultant DTD from this method will have collation
1:244952e: 	 * derivation of NONE. If yes, then the resultant DTD from this method will
1:244952e: 	 * have the same collation derivation and collation type as all the 
1:244952e: 	 * character string datatypes.
1:eac0369: 	 * 
1:2364fd8: 	 * Note that this method calls DTD.getDominantType and that method returns
1:cfdc68f: 	 * the dominant type of the 2 DTDs involved in this method. That method 
1:2364fd8: 	 * sets the collation info on the dominant type following the algorithm
1:2364fd8: 	 * mentioned in the comments of 
1:2364fd8: 	 * @see DataTypeDescriptor#getDominantType(DataTypeDescriptor, ClassFactory)
1:cfdc68f: 	 * With that algorithm, if one DTD has collation derivation of NONE and the
1:cfdc68f: 	 * other DTD has collation derivation of IMPLICIT, then the return DTD from
1:cfdc68f: 	 * DTD.getDominantType will have collation derivation of IMPLICIT. That is 
1:cfdc68f: 	 * not the correct algorithm for aggregate operators. SQL standards says
1:cfdc68f: 	 * that if EVERY type has implicit derivation AND is of the same type, then 
1:cfdc68f: 	 * the collation of the resultant will be of that type with derivation 
1:cfdc68f: 	 * IMPLICIT. To provide this behavior for aggregate operator, we basically 
1:cfdc68f: 	 * ignore the collation type and derivation picked by 
1:cfdc68f: 	 * DataTypeDescriptor.getDominantType. Instead we let 
1:2364fd8: 	 * getDominantTypeServices use the simple algorithm listed at the top of
1:cfdc68f: 	 * this method's comments to determine the collation type and derivation 
1:cfdc68f: 	 * for this ValueNodeList object.
1:eac0369: 	 * 
1:eac0369: 	 * @return DataTypeServices		The dominant DataTypeServices.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     DataTypeDescriptor getDominantTypeServices() throws StandardException
1:eac0369: 	{
1:eac0369: 		DataTypeDescriptor	dominantDTS = null;
1:244952e: 		//Following 2 will hold the collation derivation and type of the first 
1:244952e: 		//string operand. This collation information will be checked against
1:244952e: 		//the collation derivation and type of other string operands. If a 
1:244952e: 		//mismatch is found, foundCollationMisMatch will be set to true.
1:244952e: 		int firstCollationDerivation = -1;
1:244952e: 		int firstCollationType = -1;
1:244952e: 		//As soon as we find 2 strings with different collations, we set the 
1:244952e: 		//following flag to true. At the end of the method, if this flag is set 
1:244952e: 		//to true then it means that we have operands with different collation
1:244952e: 		//types and hence the resultant dominant type will have to have the
1:244952e: 		//collation derivation of NONE. 
1:244952e: 		boolean foundCollationMisMatch = false;
1:eac0369: 
2:eac0369: 		for (int index = 0; index < size(); index++)
1:eac0369: 		{
2:eac0369: 			ValueNode			valueNode;
1:eac0369: 
1:e1f49ca:             valueNode = elementAt(index);
1:2bd5cbd: 
1:2bd5cbd:             // Skip nodes that take their type from the context, if they
1:2bd5cbd:             // haven't already been bound to a type.
1:2bd5cbd:             if (valueNode.requiresTypeFromContext()
1:2bd5cbd:                     && valueNode.getTypeServices() == null) {
1:eac0369: 				continue;
1:2bd5cbd:             }
1:2bd5cbd: 
1:eac0369: 			DataTypeDescriptor valueNodeDTS = valueNode.getTypeServices();
1:eac0369: 
1:244952e: 			if (valueNodeDTS.getTypeId().isStringTypeId())
1:eac0369: 			{
1:244952e: 				if (firstCollationDerivation == -1)
1:eac0369: 				{
1:244952e: 					//found first string type. Initialize firstCollationDerivation
1:244952e: 					//and firstCollationType with collation information from 
1:244952e: 					//that first string type operand.
1:244952e: 					firstCollationDerivation = valueNodeDTS.getCollationDerivation(); 
1:244952e: 					firstCollationType = valueNodeDTS.getCollationType(); 
1:244952e: 				} else if (!foundCollationMisMatch)
1:eac0369: 				{
1:244952e: 					if (firstCollationDerivation != valueNodeDTS.getCollationDerivation())
1:244952e: 						foundCollationMisMatch = true;//collation derivations don't match
1:244952e: 					else if (firstCollationType != valueNodeDTS.getCollationType())
1:244952e: 						foundCollationMisMatch = true;//collation types don't match
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			if (dominantDTS == null)
1:eac0369: 			{
1:eac0369: 				dominantDTS = valueNodeDTS;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				dominantDTS = dominantDTS.getDominantType(valueNodeDTS, getClassFactory());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:244952e: 		//if following if returns true, then it means that we are dealing with 
1:244952e: 		//string operands.
1:244952e: 		if (firstCollationDerivation != -1)
1:eac0369: 		{
1:244952e: 			if (foundCollationMisMatch) {
1:244952e: 				//if we come here that it means that alll the string operands
1:244952e: 				//do not have matching collation information on them. Hence the
1:244952e: 				//resultant dominant DTD should have collation derivation of 
1:244952e: 				//NONE.
1:9ed7c4d: 				dominantDTS =
1:9ed7c4d:                     dominantDTS.getCollatedType(
1:9ed7c4d:                             dominantDTS.getCollationType(),
1:9ed7c4d:                             StringDataValue.COLLATION_DERIVATION_NONE);
1:eac0369: 			}			
1:2364fd8: 			//if we didn't find any collation mismatch, then resultant dominant
1:244952e: 			//DTD already has the correct collation information on it and hence
1:244952e: 			//we don't need to do anything.
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return dominantDTS;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the first non-null DataTypeServices from the elements in the list.
1:eac0369: 	 *
1:eac0369: 	 * @return DataTypeServices		The first non-null DataTypeServices.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     DataTypeDescriptor getTypeServices() throws StandardException
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:e1f49ca:             ValueNode valueNode = elementAt(index);
1:eac0369: 			DataTypeDescriptor valueNodeDTS = valueNode.getTypeServices();
1:eac0369: 
1:e2f08d2: 			if (valueNodeDTS != null)
1:eac0369: 			{
1:e2f08d2: 				return valueNodeDTS;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:e2f08d2: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not all of the entries in the list have the same
1:eac0369: 	 * type precendence as the specified value.
1:eac0369: 	 *
1:eac0369: 	 * @param precedence	The specified precedence.
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether or not all of the entries in the list have the same
1:eac0369: 	 *			type precendence as the specified value.
1:eac0369: 	 */
1:eac0369: 	boolean allSamePrecendence(int precedence)
1:eac0369: 	{
1:eac0369: 		boolean allSame = true;
1:eac0369: 		int size = size();
1:eac0369: 
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			ValueNode			valueNode;
1:eac0369: 
1:e1f49ca:             valueNode = elementAt(index);
1:eac0369: 			DataTypeDescriptor valueNodeDTS = valueNode.getTypeServices();
1:eac0369: 
1:eac0369: 			if (valueNodeDTS == null)
1:eac0369: 			{
1:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (precedence != valueNodeDTS.getTypeId().typePrecedence())
1:eac0369: 			{
1:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return allSame;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Make sure that passed ValueNode's type is compatible with the non-parameter elements in the ValueNodeList.
1:eac0369: 	 *
1:eac0369: 	 * @param leftOperand	Check for compatibility against this parameter's type
1:eac0369: 	 *
1:eac0369: 	 */
1:3bb140c:     void compatible(ValueNode leftOperand) throws StandardException
1:eac0369: 	{
1:e1f49ca:         TypeId leftType = leftOperand.getTypeId();
1:e1f49ca:         TypeCompiler leftTC = leftOperand.getTypeCompiler();
1:eac0369: 
1:e1f49ca:         for (ValueNode valueNode : this)
1:eac0369: 		{
1:e1f49ca:             if (valueNode.requiresTypeFromContext()) {
1:eac0369: 				continue;
1:e1f49ca:             }
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Are the types compatible to each other?  If not, throw an exception.
1:eac0369: 			*/
1:eac0369: 			if (! leftTC.compatible(valueNode.getTypeId()))
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_DB2_COALESCE_DATATYPE_MISMATCH,
2:eac0369: 						leftType.getSQLTypeName(),
2:eac0369: 						valueNode.getTypeId().getSQLTypeName()
1:eac0369: 						);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Determine whether or not the leftOperand is comparable() with all of
1:eac0369: 	 * the elements in the list. Throw an exception if any of them are not 
1:eac0369: 	 * comparable.
1:eac0369: 	 *
1:eac0369: 	 * @param leftOperand	The left side of the expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void comparable(ValueNode leftOperand) throws StandardException
1:eac0369: 	{
2:eac0369: 		int			 size = size();
4:eac0369: 		ValueNode		valueNode;
1:eac0369: 
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:e1f49ca:             valueNode = elementAt(index);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Can the types be compared to each other?  If not, throw an
1:eac0369: 			** exception.
1:eac0369: 			*/
1:2bb198a: 			if (! leftOperand.getTypeServices().comparable(valueNode.getTypeServices(),
1:eac0369: 									false,
1:eac0369: 									getClassFactory()))
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_NOT_COMPARABLE, 
1:3b598ee: 						leftOperand.getTypeServices().getSQLTypeNameWithCollation(),
1:3b598ee: 						valueNode.getTypeServices().getSQLTypeNameWithCollation()
1:eac0369: 						);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Determine whether or not any of the elements in the list are nullable.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not any of the elements in the list 
1:eac0369: 	 *					are nullable.
1:eac0369: 	 */
1:3bb140c:     boolean isNullable()
1:d5bc20f: 	throws StandardException
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:e1f49ca:             if (elementAt(index).getTypeServices().isNullable())
1:eac0369: 			{
1:eac0369: 				return true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 										 
1:eac0369: 	/**
1:eac0369: 	 * Does this list contain a ParameterNode?
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not the list contains a ParameterNode
1:eac0369: 	 */
1:3bb140c:     boolean containsParameterNode()
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:e1f49ca:             if (elementAt(index).requiresTypeFromContext())
1:eac0369: 			{
1:eac0369: 				return true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 										 
1:eac0369: 	/**
1:eac0369: 	 * Does this list contain all ParameterNodes?
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not the list contains all ParameterNodes
1:eac0369: 	 */
1:3bb140c:     boolean containsAllParameterNodes()
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:e1f49ca:             if (! (elementAt(index).requiresTypeFromContext()))
1:eac0369: 			{
1:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Does this list contain all ConstantNodes?
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not the list contains all ConstantNodes
1:eac0369: 	 */
1:3bb140c:     boolean containsAllConstantNodes()
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:e1f49ca:             if (! (elementAt(index) instanceof ConstantNode))
1:eac0369: 			{
1:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:7777c5d: 	 * Does this list *only* contain constant and/or parameter nodes?
1:eac0369: 	 *
1:7777c5d: 	 * @return boolean	True if every node in this list is either a constant
1:7777c5d: 	 *  node or parameter node.
1:eac0369: 	 */
1:3bb140c:     boolean containsOnlyConstantAndParamNodes()
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 
1:eac0369: 		for (int index = 0; index < size; index++)
2:244952e: 		{
1:e1f49ca:             ValueNode vNode = elementAt(index);
1:7777c5d: 			if (!vNode.requiresTypeFromContext() &&
1:7777c5d: 			    !(vNode instanceof ConstantNode))
1:244952e: 			{
1:7777c5d: 				return false;
1:eac0369: 			}
1:244952e: 		}
1:eac0369: 
1:7777c5d: 		return true;
1:244952e: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sort the entries in the list in ascending order.
1:eac0369: 	 * (All values are assumed to be constants.)
1:eac0369: 	 *
1:eac0369: 	 * @param judgeODV  In case of type not exactly matching, the judging type.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void sortInAscendingOrder(DataValueDescriptor judgeODV)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(size > 0,
1:eac0369: 				"size() expected to be non-zero");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* We use bubble sort to sort the list since we expect
1:eac0369: 		 * the list to be in sorted order > 90% of the time.
1:eac0369: 		 */
1:eac0369: 		boolean continueSort = true;
1:eac0369: 
1:eac0369: 		while (continueSort)
1:eac0369: 		{
1:eac0369: 			continueSort = false;
1:eac0369: 			
1:eac0369: 			for (int index = 1; index < size; index++)
1:eac0369: 			{
1:eac0369: 				ConstantNode currCN = (ConstantNode) elementAt(index);
1:eac0369: 				DataValueDescriptor currODV =
1:eac0369: 					 currCN.getValue();
1:eac0369: 				ConstantNode prevCN = (ConstantNode) elementAt(index - 1);
1:eac0369: 				DataValueDescriptor prevODV =
1:eac0369: 					 prevCN.getValue();
1:eac0369: 
1:eac0369: 				/* Swap curr and prev if prev > curr */
1:eac0369: 				if ((judgeODV == null && (prevODV.compare(currODV)) > 0) ||
1:eac0369: 					(judgeODV != null && judgeODV.greaterThan(prevODV, currODV).equals(true)))
1:eac0369: 				{
1:eac0369: 					setElementAt(currCN, index - 1);
1:eac0369: 					setElementAt(prevCN, index);
1:eac0369: 					continueSort = true;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:5d7388d:      * Eliminate NotNodes in all the nodes in this list.
1:5d7388d:      *
1:5d7388d:      * @param underNotNode whether or not we are under a NotNode
1:5d7388d:      * @see ValueNode#eliminateNots(boolean)
1:5d7388d:      */
1:5d7388d:     void eliminateNots(boolean underNotNode) throws StandardException {
1:5d7388d:         for (int i = 0; i < size(); i++) {
1:5d7388d:             setElementAt(elementAt(i).eliminateNots(underNotNode), i);
1:5d7388d:         }
1:5d7388d:     }
1:5d7388d: 
1:eac0369: 	/**
1:eac0369: 	 * Set the descriptor for every ParameterNode in the list.
1:eac0369: 	 *
1:eac0369: 	 * @param descriptor	The DataTypeServices to set for the parameters
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void setParameterDescriptor(DataTypeDescriptor descriptor)
1:eac0369: 						throws StandardException
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:e1f49ca:             ValueNode valueNode = elementAt(index);
1:d5bc20f: 			if (valueNode.requiresTypeFromContext())
1:eac0369: 			{
1:d5bc20f: 				valueNode.setType(descriptor);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Preprocess a ValueNodeList.  For now, we just preprocess each ValueNode
1:eac0369: 	 * in the list.
1:eac0369: 	 *
1:eac0369: 	 * @param	numTables			Number of tables in the DML Statement
1:eac0369: 	 * @param	outerFromList		FromList from outer query block
1:eac0369: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1:eac0369: 	 * @param	outerPredicateList	PredicateList from outer query block
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void preprocess(int numTables,
1:eac0369: 							FromList outerFromList,
1:eac0369: 							SubqueryList outerSubqueryList,
1:eac0369: 							PredicateList outerPredicateList) 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:39e20ff:             ValueNode vn = elementAt(index).preprocess(numTables,
1:eac0369: 								 outerFromList, outerSubqueryList,
1:eac0369: 								 outerPredicateList);
1:39e20ff:             setElementAt(vn, index);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remap all ColumnReferences in this tree to be clones of the
1:eac0369: 	 * underlying expression.
1:eac0369: 	 *
1:eac0369: 	 * @return ValueNodeList			The remapped expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     ValueNodeList remapColumnReferencesToExpressions()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:e1f49ca:             setElementAt(elementAt(index).remapColumnReferencesToExpressions(),
1:e1f49ca:                          index);
1:eac0369: 		}
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:fc5f3cc:     /**
1:fc5f3cc:      * Check if all the elements in this list are equivalent to the elements
1:fc5f3cc:      * in another list. The two lists must have the same size, and the
1:fc5f3cc:      * equivalent nodes must appear in the same order in both lists, for the
1:fc5f3cc:      * two lists to be equivalent.
1:fc5f3cc:      *
1:fc5f3cc:      * @param other the other list
1:fc5f3cc:      * @return {@code true} if the two lists contain equivalent elements, or
1:fc5f3cc:      * {@code false} otherwise
1:fc5f3cc:      * @throws StandardException thrown on error
1:fc5f3cc:      * @see ValueNode#isEquivalent(ValueNode)
1:fc5f3cc:      */
1:fc5f3cc:     boolean isEquivalent(ValueNodeList other) throws StandardException {
1:fc5f3cc:         if (size() != other.size()) {
1:fc5f3cc:             return false;
1:fc5f3cc:         }
1:fc5f3cc: 
1:fc5f3cc:         for (int i = 0; i < size(); i++) {
1:e1f49ca:             ValueNode vn1 = elementAt(i);
1:e1f49ca:             ValueNode vn2 = other.elementAt(i);
1:fc5f3cc:             if (!vn1.isEquivalent(vn2)) {
1:fc5f3cc:                 return false;
1:fc5f3cc:             }
1:fc5f3cc:         }
1:fc5f3cc: 
1:fc5f3cc:         return true;
1:fc5f3cc:     }
1:fc5f3cc: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not this expression tree represents a constant expression.
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether or not this expression tree represents a constant expression.
1:eac0369: 	 */
1:3bb140c:     boolean isConstantExpression()
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			boolean retcode;
1:eac0369: 
1:e1f49ca:             retcode = elementAt(index).isConstantExpression();
1:eac0369: 			if (! retcode)
1:eac0369: 			{
1:eac0369: 				return retcode;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see ValueNode#constantExpression */
1:3bb140c:     boolean constantExpression(PredicateList whereClause)
1:eac0369: 	{
1:eac0369: 		int size = size();
1:eac0369: 
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:eac0369: 			boolean retcode;
1:eac0369: 
1:e1f49ca:             retcode = elementAt(index).constantExpression(whereClause);
1:eac0369: 			if (! retcode)
1:eac0369: 			{
1:eac0369: 				return retcode;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Categorize this predicate.  Initially, this means
1:eac0369: 	 * building a bit map of the referenced tables for each predicate.
1:eac0369: 	 * If the source of this ColumnReference (at the next underlying level) 
1:eac0369: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1:eac0369: 	 * will not be pushed down.
1:eac0369: 	 *
1:eac0369: 	 * For example, in:
1:eac0369: 	 *		select * from (select 1 from s) a (x) where x = 1
1:eac0369: 	 * we will not push down x = 1.
1:eac0369: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1:eac0369: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1:eac0369: 	 * that tree into the pushed predicate, and that tree could contain
1:eac0369: 	 * subqueries and method calls.
1:eac0369: 	 * RESOLVE - revisit this issue once we have views.
1:eac0369: 	 *
1:eac0369: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1:eac0369: 	 * @param simplePredsOnly	Whether or not to consider method
1:eac0369: 	 *							calls, field references and conditional nodes
1:eac0369: 	 *							when building bit map
1:eac0369: 	 *
1:eac0369: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1:eac0369: 	 *						or a VirtualColumnNode.
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* We stop here when only considering simple predicates
1:eac0369: 		 *  as we don't consider in lists when looking
1:eac0369: 		 * for null invariant predicates.
1:eac0369: 		 */
1:eac0369: 		boolean pushable = true;
1:eac0369: 		int size = size();
1:eac0369: 
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:e1f49ca:             pushable = elementAt(index).categorize(referencedTabs, simplePredsOnly) &&
1:eac0369: 					   pushable;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return pushable;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the variant type for the underlying expression.
1:eac0369: 	 * The variant type can be:
1:eac0369: 	 *		VARIANT				- variant within a scan
1:eac0369: 	 *							  (method calls and non-static field access)
1:eac0369: 	 *		SCAN_INVARIANT		- invariant within a scan
1:eac0369: 	 *							  (column references from outer tables)
1:eac0369: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1:eac0369: 	 *		CONSTANT			- constant
1:eac0369: 	 *
1:eac0369: 	 * @return	The variant type for the underlying expression.
1:eac0369: 	 * @exception StandardException	thrown on error
1:eac0369: 	 */
1:eac0369: 	protected int getOrderableVariantType() throws StandardException
1:eac0369: 	{
1:eac0369: 		int listType = Qualifier.CONSTANT;
1:eac0369: 		int size = size();
1:eac0369: 
1:eac0369: 		/* If any element in the list is VARIANT then the 
1:eac0369: 		 * entire expression is variant
1:eac0369: 		 * else it is SCAN_INVARIANT if any element is SCAN_INVARIANT
1:eac0369: 		 * else it is QUERY_INVARIANT.
1:eac0369: 		 */
1:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:e1f49ca:             int curType = elementAt(index).getOrderableVariantType();
1:eac0369: 			listType = Math.min(listType, curType);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return listType;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 * Generate a SQL-&gt;Java-&gt;SQL conversion tree any node in the list
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:     void bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:2bd5cbd
/////////////////////////////////////////////////////////////////////////
1: 
1:             // Skip nodes that take their type from the context, if they
1:             // haven't already been bound to a type.
1:             if (valueNode.requiresTypeFromContext()
1:                     && valueNode.getTypeServices() == null) {
1:             }
1: 
commit:39e20ff
/////////////////////////////////////////////////////////////////////////
1:             ValueNode vn = elementAt(index).preprocess(numTables,
1:             setElementAt(vn, index);
commit:5d7388d
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Eliminate NotNodes in all the nodes in this list.
1:      *
1:      * @param underNotNode whether or not we are under a NotNode
1:      * @see ValueNode#eliminateNots(boolean)
1:      */
1:     void eliminateNots(boolean underNotNode) throws StandardException {
1:         for (int i = 0; i < size(); i++) {
1:             setElementAt(elementAt(i).eliminateNots(underNotNode), i);
1:         }
1:     }
1: 
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates        The aggregate list being built as we find AggregateNodes
0:     void bindExpression(FromList fromList, SubqueryList subqueryList, List aggregates)
/////////////////////////////////////////////////////////////////////////
1:             vn = vn.bindExpression(fromList, subqueryList, aggregates);
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.loader.ClassFactory;
/////////////////////////////////////////////////////////////////////////
0: 							   List aggregateVector)
commit:4d09732
/////////////////////////////////////////////////////////////////////////
commit:fc5f3cc
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check if all the elements in this list are equivalent to the elements
1:      * in another list. The two lists must have the same size, and the
1:      * equivalent nodes must appear in the same order in both lists, for the
1:      * two lists to be equivalent.
1:      *
1:      * @param other the other list
1:      * @return {@code true} if the two lists contain equivalent elements, or
1:      * {@code false} otherwise
1:      * @throws StandardException thrown on error
1:      * @see ValueNode#isEquivalent(ValueNode)
1:      */
1:     boolean isEquivalent(ValueNodeList other) throws StandardException {
1:         if (size() != other.size()) {
1:             return false;
1:         }
1: 
1:         for (int i = 0; i < size(); i++) {
0:             ValueNode vn1 = (ValueNode) elementAt(i);
0:             ValueNode vn2 = (ValueNode) other.elementAt(i);
1:             if (!vn1.isEquivalent(vn2)) {
1:                 return false;
1:             }
1:         }
1: 
1:         return true;
1:     }
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1: class ValueNodeList extends QueryTreeNodeVector<ValueNode>
1:         super(ValueNode.class, cm);
/////////////////////////////////////////////////////////////////////////
1:             ValueNode vn = elementAt(index);
/////////////////////////////////////////////////////////////////////////
1:             ValueNode valueNode = elementAt(index);
/////////////////////////////////////////////////////////////////////////
1:             valueNode = elementAt(index);
/////////////////////////////////////////////////////////////////////////
1:             ValueNode valueNode = elementAt(index);
/////////////////////////////////////////////////////////////////////////
1:             valueNode = elementAt(index);
/////////////////////////////////////////////////////////////////////////
1:         TypeId leftType = leftOperand.getTypeId();
1:         TypeCompiler leftTC = leftOperand.getTypeCompiler();
1:         for (ValueNode valueNode : this)
1:             if (valueNode.requiresTypeFromContext()) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             valueNode = elementAt(index);
/////////////////////////////////////////////////////////////////////////
1:             if (elementAt(index).getTypeServices().isNullable())
/////////////////////////////////////////////////////////////////////////
1:             if (elementAt(index).requiresTypeFromContext())
/////////////////////////////////////////////////////////////////////////
1:             if (! (elementAt(index).requiresTypeFromContext()))
/////////////////////////////////////////////////////////////////////////
1:             if (! (elementAt(index) instanceof ConstantNode))
/////////////////////////////////////////////////////////////////////////
1:             ValueNode vNode = elementAt(index);
/////////////////////////////////////////////////////////////////////////
1:             ValueNode valueNode = elementAt(index);
/////////////////////////////////////////////////////////////////////////
0:             valueNode = elementAt(index);
/////////////////////////////////////////////////////////////////////////
1:             setElementAt(elementAt(index).remapColumnReferencesToExpressions(),
1:                          index);
/////////////////////////////////////////////////////////////////////////
1:             ValueNode vn1 = elementAt(i);
1:             ValueNode vn2 = other.elementAt(i);
/////////////////////////////////////////////////////////////////////////
1:             retcode = elementAt(index).isConstantExpression();
/////////////////////////////////////////////////////////////////////////
1:             retcode = elementAt(index).constantExpression(whereClause);
/////////////////////////////////////////////////////////////////////////
1:             pushable = elementAt(index).categorize(referencedTabs, simplePredsOnly) &&
/////////////////////////////////////////////////////////////////////////
1:             int curType = elementAt(index).getOrderableVariantType();
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: import org.apache.derby.iapi.store.access.Qualifier;
1:  * e.g. IN list, NOT IN list or BETWEEN in a DML statement.
0: class ValueNodeList extends QueryTreeNodeVector
1:     ValueNodeList(ContextManager cm) {
0:         super(cm);
0:         setNodeType(C_NodeTypes.VALUE_NODE_LIST);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     void addValueNode(ValueNode valueNode) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     void genSQLJavaSQLTrees()
/////////////////////////////////////////////////////////////////////////
1:     DataTypeDescriptor getDominantTypeServices() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     DataTypeDescriptor getTypeServices() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     void compatible(ValueNode leftOperand) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     void comparable(ValueNode leftOperand) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     boolean isNullable()
/////////////////////////////////////////////////////////////////////////
1:     boolean containsParameterNode()
/////////////////////////////////////////////////////////////////////////
1:     boolean containsAllParameterNodes()
/////////////////////////////////////////////////////////////////////////
1:     boolean containsAllConstantNodes()
/////////////////////////////////////////////////////////////////////////
1:     boolean containsOnlyConstantAndParamNodes()
/////////////////////////////////////////////////////////////////////////
1:     void setParameterDescriptor(DataTypeDescriptor descriptor)
/////////////////////////////////////////////////////////////////////////
1:     void preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     ValueNodeList remapColumnReferencesToExpressions()
/////////////////////////////////////////////////////////////////////////
1:     boolean isConstantExpression()
/////////////////////////////////////////////////////////////////////////
1:     boolean constantExpression(PredicateList whereClause)
/////////////////////////////////////////////////////////////////////////
1:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9ed7c4d
/////////////////////////////////////////////////////////////////////////
1: 				dominantDTS =
1:                     dominantDTS.getCollatedType(
1:                             dominantDTS.getCollationType(),
1:                             StringDataValue.COLLATION_DERIVATION_NONE);
commit:e2f08d2
/////////////////////////////////////////////////////////////////////////
0: 			ValueNode valueNode = (ValueNode) elementAt(index);
1: 			if (valueNodeDTS != null)
1: 				return valueNodeDTS;
1: 		return null;
/////////////////////////////////////////////////////////////////////////
0: 			ValueNode valueNode = (ValueNode) elementAt(index);
commit:08d6ce2
/////////////////////////////////////////////////////////////////////////
1: 			if (valueNode.getTypeId().userType())
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.ValueNodeList
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: 
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.store.access.Qualifier;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
1: 
0: import java.util.Vector;
1: 
1: /**
1:  * A ValueNodeList represents a list of ValueNodes within a specific predicate 
0:  * (eg, IN list, NOT IN list or BETWEEN) in a DML statement.  
0:  * It extends QueryTreeNodeVector.
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
0: public class ValueNodeList extends QueryTreeNodeVector
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
1: 	 *
0: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			super.printSubNodes(depth);
1: 
1: 			for (int index = 0; index < size(); index++)
1: 			{
1: 				ValueNode		valueNode;
0: 				valueNode = (ValueNode) elementAt(index);
0: 				valueNode.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Set the clause that this node appears in.
1: 	 *
0: 	 * @param clause	The clause that this node appears in.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setClause(int clause)
1: 	{
1: 		int size = size();
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			ValueNode		valueNode;
0: 				valueNode = (ValueNode) elementAt(index);
0: 			valueNode.setClause(clause);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Add a ValueNode to the list.
1: 	 *
1: 	 * @param valueNode	A ValueNode to add to the list
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void addValueNode(ValueNode valueNode) throws StandardException
1: 	{
1: 		addElement(valueNode);
1: 	}
1: 
1: 	/**
1: 	 * Bind this expression.  This means binding the sub-expressions,
1: 	 * as well as figuring out what the return type is for this expression.
1: 	 *
1: 	 * @param fromList		The FROM list for the query this
1: 	 *				expression is in, for binding columns.
1: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void	bindExpression(FromList fromList, 
0: 							   SubqueryList subqueryList,
0: 							   Vector aggregateVector)
1: 			throws StandardException
1: 	{
1: 		int size = size();
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			ValueNode vn = (ValueNode) elementAt(index);
0: 			vn = vn.bindExpression(fromList, subqueryList,
0: 								   aggregateVector);
1: 
1: 			setElementAt(vn, index);
1: 		}
1: 	}
1: 
1: 
1: 	/**
0: 	 * Generate a SQL->Java->SQL conversion tree any node in the list
1: 	 * which is not a system built-in type.
1: 	 * This is useful when doing comparisons, built-in functions, etc. on
1: 	 * java types which have a direct mapping to system built-in types.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException	Thrown on error
1: 	 */
0: 	public void genSQLJavaSQLTrees()
1: 		throws StandardException
1: 	{
1: 		int size = size();
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			ValueNode valueNode = (ValueNode) elementAt(index);
1: 			
0: 			if (! valueNode.getTypeId().systemBuiltIn())
1: 			{
1: 				setElementAt(valueNode.genSQLJavaSQLTree(), index);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Get the dominant DataTypeServices from the elements in the list.
1: 	 *
1: 	 * @return DataTypeServices		The dominant DataTypeServices.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public DataTypeDescriptor getDominantTypeServices() throws StandardException
1: 	{
1: 		DataTypeDescriptor	dominantDTS = null;
1: 
1: 		for (int index = 0; index < size(); index++)
1: 		{
1: 			ValueNode			valueNode;
1: 
0: 			valueNode = (ValueNode) elementAt(index);
0: 			if (valueNode.isParameterNode())
1: 				continue;
1: 			DataTypeDescriptor valueNodeDTS = valueNode.getTypeServices();
1: 
1: 			if (dominantDTS == null)
1: 			{
1: 				dominantDTS = valueNodeDTS;
1: 			}
1: 			else
1: 			{
1: 				dominantDTS = dominantDTS.getDominantType(valueNodeDTS, getClassFactory());
1: 			}
1: 		}
1: 
1: 		return dominantDTS;
1: 	}
1: 
1: 	/**
1: 	 * Get the first non-null DataTypeServices from the elements in the list.
1: 	 *
1: 	 * @return DataTypeServices		The first non-null DataTypeServices.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public DataTypeDescriptor getTypeServices() throws StandardException
1: 	{
0: 		DataTypeDescriptor	firstDTS = null;
1: 		int size = size();
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			ValueNode			valueNode;
1: 
0: 			valueNode = (ValueNode) elementAt(index);
1: 			DataTypeDescriptor valueNodeDTS = valueNode.getTypeServices();
1: 
0: 			if ((firstDTS == null) && (valueNodeDTS != null))
1: 			{
0: 				firstDTS = valueNodeDTS;
0: 				break;
1: 			}
1: 		}
1: 
0: 		return firstDTS;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not all of the entries in the list have the same
1: 	 * type precendence as the specified value.
1: 	 *
1: 	 * @param precedence	The specified precedence.
1: 	 *
1: 	 * @return	Whether or not all of the entries in the list have the same
1: 	 *			type precendence as the specified value.
1: 	 */
1: 	boolean allSamePrecendence(int precedence)
1: 	{
1: 		boolean allSame = true;
1: 		int size = size();
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			ValueNode			valueNode;
1: 
0: 			valueNode = (ValueNode) elementAt(index);
1: 			DataTypeDescriptor valueNodeDTS = valueNode.getTypeServices();
1: 
1: 			if (valueNodeDTS == null)
1: 			{
1: 				return false;
1: 			}
1: 
1: 			if (precedence != valueNodeDTS.getTypeId().typePrecedence())
1: 			{
1: 				return false;
1: 			}
1: 		}
1: 
1: 		return allSame;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Make sure that passed ValueNode's type is compatible with the non-parameter elements in the ValueNodeList.
1: 	 *
1: 	 * @param leftOperand	Check for compatibility against this parameter's type
1: 	 *
1: 	 */
0: 	public void compatible(ValueNode leftOperand) throws StandardException
1: 	{
1: 		int			 size = size();
0: 		TypeId	leftType;
1: 		ValueNode		valueNode;
0: 		TypeCompiler leftTC;
1: 
0: 		leftType = leftOperand.getTypeId();
0: 		leftTC = leftOperand.getTypeCompiler();
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			valueNode = (ValueNode) elementAt(index);
0: 			if (valueNode.isParameterNode())
1: 				continue;
1: 
1: 
1: 			/*
1: 			** Are the types compatible to each other?  If not, throw an exception.
1: 			*/
1: 			if (! leftTC.compatible(valueNode.getTypeId()))
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_DB2_COALESCE_DATATYPE_MISMATCH,
1: 						leftType.getSQLTypeName(),
1: 						valueNode.getTypeId().getSQLTypeName()
1: 						);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Determine whether or not the leftOperand is comparable() with all of
1: 	 * the elements in the list. Throw an exception if any of them are not 
1: 	 * comparable.
1: 	 *
1: 	 * @param leftOperand	The left side of the expression
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void comparable(ValueNode leftOperand) throws StandardException
1: 	{
1: 		int			 size = size();
0: 		TypeId	leftType;
1: 		ValueNode		valueNode;
0: 		TypeCompiler leftTC;
1: 
0: 		leftType = leftOperand.getTypeId();
0: 		leftTC = leftOperand.getTypeCompiler();
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			valueNode = (ValueNode) elementAt(index);
1: 
1: 			/*
1: 			** Can the types be compared to each other?  If not, throw an
1: 			** exception.
1: 			*/
0: 			if (! leftTC.comparable(valueNode.getTypeId(),
1: 									false,
1: 									getClassFactory()))
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_NOT_COMPARABLE, 
1: 						leftType.getSQLTypeName(),
1: 						valueNode.getTypeId().getSQLTypeName()
1: 						);
1: 			}
1: 		}
1: 	}
1: 
1: 	/** 
1: 	 * Determine whether or not any of the elements in the list are nullable.
1: 	 *
1: 	 * @return boolean	Whether or not any of the elements in the list 
1: 	 *					are nullable.
1: 	 */
0: 	public boolean isNullable()
1: 	{
1: 		int size = size();
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			if (((ValueNode) elementAt(index)).getTypeServices().isNullable())
1: 			{
1: 				return true;
1: 			}
1: 		}
1: 		return false;
1: 	}
1: 										 
1: 	/**
1: 	 * Does this list contain a ParameterNode?
1: 	 *
1: 	 * @return boolean	Whether or not the list contains a ParameterNode
1: 	 */
0: 	public boolean containsParameterNode()
1: 	{
1: 		int size = size();
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			if (((ValueNode) elementAt(index)).isParameterNode())
1: 			{
1: 				return true;
1: 			}
1: 		}
1: 		return false;
1: 	}
1: 										 
1: 	/**
1: 	 * Does this list contain all ParameterNodes?
1: 	 *
1: 	 * @return boolean	Whether or not the list contains all ParameterNodes
1: 	 */
0: 	public boolean containsAllParameterNodes()
1: 	{
1: 		int size = size();
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			if (! (((ValueNode) elementAt(index)).isParameterNode()))
1: 			{
1: 				return false;
1: 			}
1: 		}
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Does this list contain all ConstantNodes?
1: 	 *
1: 	 * @return boolean	Whether or not the list contains all ConstantNodes
1: 	 */
0: 	public boolean containsAllConstantNodes()
1: 	{
1: 		int size = size();
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			if (! ((ValueNode) elementAt(index) instanceof ConstantNode))
1: 			{
1: 				return false;
1: 			}
1: 		}
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Sort the entries in the list in ascending order.
1: 	 * (All values are assumed to be constants.)
1: 	 *
1: 	 * @param judgeODV  In case of type not exactly matching, the judging type.
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void sortInAscendingOrder(DataValueDescriptor judgeODV)
1: 		throws StandardException
1: 	{
1: 		int size = size();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(size > 0,
1: 				"size() expected to be non-zero");
1: 		}
1: 
1: 		/* We use bubble sort to sort the list since we expect
1: 		 * the list to be in sorted order > 90% of the time.
1: 		 */
1: 		boolean continueSort = true;
1: 
1: 		while (continueSort)
1: 		{
1: 			continueSort = false;
1: 			
1: 			for (int index = 1; index < size; index++)
1: 			{
1: 				ConstantNode currCN = (ConstantNode) elementAt(index);
1: 				DataValueDescriptor currODV =
1: 					 currCN.getValue();
1: 				ConstantNode prevCN = (ConstantNode) elementAt(index - 1);
1: 				DataValueDescriptor prevODV =
1: 					 prevCN.getValue();
1: 
1: 				/* Swap curr and prev if prev > curr */
1: 				if ((judgeODV == null && (prevODV.compare(currODV)) > 0) ||
1: 					(judgeODV != null && judgeODV.greaterThan(prevODV, currODV).equals(true)))
1: 				{
1: 					setElementAt(currCN, index - 1);
1: 					setElementAt(prevCN, index);
1: 					continueSort = true;
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Set the descriptor for every ParameterNode in the list.
1: 	 *
1: 	 * @param descriptor	The DataTypeServices to set for the parameters
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void setParameterDescriptor(DataTypeDescriptor descriptor)
1: 						throws StandardException
1: 	{
1: 		int size = size();
0: 		ValueNode	valueNode;
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			valueNode = (ValueNode) elementAt(index);
0: 			if (valueNode.isParameterNode())
1: 			{
0: 				((ParameterNode) valueNode).setDescriptor(descriptor);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Preprocess a ValueNodeList.  For now, we just preprocess each ValueNode
1: 	 * in the list.
1: 	 *
1: 	 * @param	numTables			Number of tables in the DML Statement
1: 	 * @param	outerFromList		FromList from outer query block
1: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1: 	 * @param	outerPredicateList	PredicateList from outer query block
1: 	 *
0: 	 * @return	Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void preprocess(int numTables,
1: 							FromList outerFromList,
1: 							SubqueryList outerSubqueryList,
1: 							PredicateList outerPredicateList) 
1: 		throws StandardException
1: 	{
1: 		int size = size();
0: 		ValueNode	valueNode;
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			valueNode = (ValueNode) elementAt(index);
0: 			valueNode.preprocess(numTables,
1: 								 outerFromList, outerSubqueryList,
1: 								 outerPredicateList);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Remap all ColumnReferences in this tree to be clones of the
1: 	 * underlying expression.
1: 	 *
1: 	 * @return ValueNodeList			The remapped expression tree.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public ValueNodeList remapColumnReferencesToExpressions()
1: 		throws StandardException
1: 	{
1: 		int size = size();
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			setElementAt(
0: 				((ValueNode) elementAt(index)).remapColumnReferencesToExpressions(),
0: 				index);
1: 		}
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this expression tree represents a constant expression.
1: 	 *
1: 	 * @return	Whether or not this expression tree represents a constant expression.
1: 	 */
0: 	public boolean isConstantExpression()
1: 	{
1: 		int size = size();
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			boolean retcode;
1: 
0: 			retcode = ((ValueNode) elementAt(index)).isConstantExpression();
1: 			if (! retcode)
1: 			{
1: 				return retcode;
1: 			}
1: 		}
1: 
1: 		return true;
1: 	}
1: 
1: 	/** @see ValueNode#constantExpression */
0: 	public boolean constantExpression(PredicateList whereClause)
1: 	{
1: 		int size = size();
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
1: 			boolean retcode;
1: 
0: 			retcode =
0: 				((ValueNode) elementAt(index)).constantExpression(whereClause);
1: 			if (! retcode)
1: 			{
1: 				return retcode;
1: 			}
1: 		}
1: 
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Categorize this predicate.  Initially, this means
1: 	 * building a bit map of the referenced tables for each predicate.
1: 	 * If the source of this ColumnReference (at the next underlying level) 
1: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1: 	 * will not be pushed down.
1: 	 *
1: 	 * For example, in:
1: 	 *		select * from (select 1 from s) a (x) where x = 1
1: 	 * we will not push down x = 1.
1: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1: 	 * that tree into the pushed predicate, and that tree could contain
1: 	 * subqueries and method calls.
1: 	 * RESOLVE - revisit this issue once we have views.
1: 	 *
1: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1: 	 * @param simplePredsOnly	Whether or not to consider method
1: 	 *							calls, field references and conditional nodes
1: 	 *							when building bit map
1: 	 *
1: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1: 	 *						or a VirtualColumnNode.
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1: 		throws StandardException
1: 	{
1: 		/* We stop here when only considering simple predicates
1: 		 *  as we don't consider in lists when looking
1: 		 * for null invariant predicates.
1: 		 */
1: 		boolean pushable = true;
1: 		int size = size();
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			pushable = ((ValueNode) elementAt(index)).categorize(referencedTabs, simplePredsOnly) &&
1: 					   pushable;
1: 		}
1: 
1: 		return pushable;
1: 	}
1: 
1: 	/**
1: 	 * Return the variant type for the underlying expression.
1: 	 * The variant type can be:
1: 	 *		VARIANT				- variant within a scan
1: 	 *							  (method calls and non-static field access)
1: 	 *		SCAN_INVARIANT		- invariant within a scan
1: 	 *							  (column references from outer tables)
1: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1: 	 *		CONSTANT			- constant
1: 	 *
1: 	 * @return	The variant type for the underlying expression.
1: 	 * @exception StandardException	thrown on error
1: 	 */
1: 	protected int getOrderableVariantType() throws StandardException
1: 	{
1: 		int listType = Qualifier.CONSTANT;
1: 		int size = size();
1: 
1: 		/* If any element in the list is VARIANT then the 
1: 		 * entire expression is variant
1: 		 * else it is SCAN_INVARIANT if any element is SCAN_INVARIANT
1: 		 * else it is QUERY_INVARIANT.
1: 		 */
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			int curType = ((ValueNode) elementAt(index)).getOrderableVariantType();
1: 			listType = Math.min(listType, curType);
1: 		}
1: 
1: 		return listType;
1: 	}
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:cfdc68f
/////////////////////////////////////////////////////////////////////////
1: 	 * DataTypeService if we are dealing with character string datatypes.
/////////////////////////////////////////////////////////////////////////
1: 	 * the dominant type of the 2 DTDs involved in this method. That method 
1: 	 * With that algorithm, if one DTD has collation derivation of NONE and the
1: 	 * other DTD has collation derivation of IMPLICIT, then the return DTD from
1: 	 * DTD.getDominantType will have collation derivation of IMPLICIT. That is 
1: 	 * not the correct algorithm for aggregate operators. SQL standards says
1: 	 * that if EVERY type has implicit derivation AND is of the same type, then 
1: 	 * the collation of the resultant will be of that type with derivation 
1: 	 * IMPLICIT. To provide this behavior for aggregate operator, we basically 
1: 	 * ignore the collation type and derivation picked by 
1: 	 * DataTypeDescriptor.getDominantType. Instead we let 
1: 	 * this method's comments to determine the collation type and derivation 
1: 	 * for this ValueNodeList object.
commit:0f58b38
/////////////////////////////////////////////////////////////////////////
commit:2364fd8
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the dominant DataTypeServices from the elements in the list. This
1: 	 * method will also set the correct collation information on the dominant
0: 	 * DataTypeService.
0: 	 *  
1: 	 * Algorithm for determining collation information
1: 	 * This method will check if it is dealing with character string datatypes.
/////////////////////////////////////////////////////////////////////////
0: 	 * sysCharColumn1 || userCharColumn
/////////////////////////////////////////////////////////////////////////
1: 	 * Note that this method calls DTD.getDominantType and that method returns
0: 	 * the dominant type of the 2 DTDs involved in this method. The method also
1: 	 * sets the collation info on the dominant type following the algorithm
1: 	 * mentioned in the comments of 
1: 	 * @see DataTypeDescriptor#getDominantType(DataTypeDescriptor, ClassFactory)
0: 	 * But when there are more than 2 DTDs involved in this ValueNodeList, we
0: 	 * can't determine the collation info using only 2 DTDs at a time which is
0: 	 * what TD.getDominantType does. Consider following eg
0: 	 * sysCharColumn1 || userCharColumn || sysCharColumn2
0: 	 * If we let the DataTypeDescriptor.getDominantType determine the collation
0: 	 * of the eg above, then DataTypeDescriptor.getDominantType will first set 
0: 	 * collation derivation of NONE for the following. This intermediate DTD is 
0: 	 * tracked by dominantDTS 
0: 	 * sysCharColumn1 || userCharColumn
0: 	 * Next, DataTypeDescriptor.getDominantType gets called for the intermediate
0: 	 * DTD (dominantDTS) and sysCharColumn2
0: 	 * dominantDTS || sysCharColumn2
0: 	 * For these two DTDs, DataTypeDescriptor.getDominantType will set 
0: 	 * collation type of UCS_BASIC and collation derivation of IMPLICIT. So, the
0: 	 * result string of the sysCharColumn1 || userCharColumn || sysCharColumn2
0: 	 * will have collation type of UCS_BASIC and collation derivation of 
0: 	 * IMPLICIT, but that is not correct. The reason for this is 
0: 	 * DataTypeDescriptor.getDominantType deals with only 2 DTDs at a time. To
0: 	 * fix this problem, we basically ignore the collation type and derivation 
0: 	 * picked by DataTypeDescriptor.getDominantType. Instead we let 
1: 	 * getDominantTypeServices use the simple algorithm listed at the top of
0: 	 * this method's comments to determine the collation type and derivation for 
0: 	 * this ValueNodeList object.
0: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 			//if we didn't find any collation mismatch, then resultant dominant
commit:f63b7da
/////////////////////////////////////////////////////////////////////////
0: 				valueNode.setCollationUsingCompilationSchema(
commit:7c5fbc4
/////////////////////////////////////////////////////////////////////////
0: 				//? parameter should pick up the collation type of the schema in
0: 				//which this statement is getting compiled.
0: 				valueNode.getTypeServices().setCollationDerivation(
0: 						StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 				valueNode.getTypeServices().setCollationType(
0: 						getLanguageConnectionContext().getDefaultSchema().getCollationType());
commit:244952e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
0: 	 * Get the dominant DataTypeServices from the elements in the list. This 
0: 	 * method will also check if it is dealing with character string datatypes.
1: 	 * If yes, then it will check if all the character string datatypes have
1: 	 * the same collation derivation and collation type associated with them.
1: 	 * If not, then the resultant DTD from this method will have collation
1: 	 * derivation of NONE. If yes, then the resultant DTD from this method will
1: 	 * have the same collation derivation and collation type as all the 
1: 	 * character string datatypes.
0: 	 * 
0: 	 * eg consider we are dealing with a database with territory based 
0: 	 * collation. Now consider following example first
0: 	 * sysCharColumn || userCharColumn
0: 	 * The result of this concatenation will have collation derivation of NONE
0: 	 * because the first operand has collation derivation of IMPLICIT and 
0: 	 * collation type of UCS_BASIC whereas the 2nd opernad has collation 
0: 	 * derivation of IMPLICIT and collation type of territory based. Since the
0: 	 * 2 operands don't have matching collaiton information, the result of this
0: 	 * concatenation will have collation derivation of NONE.
0: 	 * 
0: 	 * Now consider following example
0: 	 * sysCharColumn1 || sysCharColumn2
0: 	 * Since in this example, both the operands have the same collation
0: 	 * derivation of IMPLICIT and same collation type of UCS_BASIC, the 
0: 	 * resultant type will have collation derivation of IMPLICIT and collation 
0: 	 * type of UCS_BASIC
0: 	 * 
/////////////////////////////////////////////////////////////////////////
1: 		//Following 2 will hold the collation derivation and type of the first 
1: 		//string operand. This collation information will be checked against
1: 		//the collation derivation and type of other string operands. If a 
1: 		//mismatch is found, foundCollationMisMatch will be set to true.
1: 		int firstCollationDerivation = -1;
1: 		int firstCollationType = -1;
1: 		//As soon as we find 2 strings with different collations, we set the 
1: 		//following flag to true. At the end of the method, if this flag is set 
1: 		//to true then it means that we have operands with different collation
1: 		//types and hence the resultant dominant type will have to have the
1: 		//collation derivation of NONE. 
1: 		boolean foundCollationMisMatch = false;
/////////////////////////////////////////////////////////////////////////
1: 			if (valueNodeDTS.getTypeId().isStringTypeId())
1: 			{
1: 				if (firstCollationDerivation == -1)
1: 				{
1: 					//found first string type. Initialize firstCollationDerivation
1: 					//and firstCollationType with collation information from 
1: 					//that first string type operand.
1: 					firstCollationDerivation = valueNodeDTS.getCollationDerivation(); 
1: 					firstCollationType = valueNodeDTS.getCollationType(); 
1: 				} else if (!foundCollationMisMatch)
1: 				{
1: 					if (firstCollationDerivation != valueNodeDTS.getCollationDerivation())
1: 						foundCollationMisMatch = true;//collation derivations don't match
1: 					else if (firstCollationType != valueNodeDTS.getCollationType())
1: 						foundCollationMisMatch = true;//collation types don't match
1: 				}
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 		//if following if returns true, then it means that we are dealing with 
1: 		//string operands.
1: 		if (firstCollationDerivation != -1)
0: 		{
1: 			if (foundCollationMisMatch) {
1: 				//if we come here that it means that alll the string operands
1: 				//do not have matching collation information on them. Hence the
1: 				//resultant dominant DTD should have collation derivation of 
1: 				//NONE.
0: 				dominantDTS.setCollationDerivation(StringDataValue.COLLATION_DERIVATION_NONE);
0: 			}			
0: 			//if we didn't fine any collation mismatch, then resultant dominant
1: 			//DTD already has the correct collation information on it and hence
1: 			//we don't need to do anything.
0: 		}
0: 
commit:2bb198a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			if (! leftOperand.getTypeServices().comparable(valueNode.getTypeServices(),
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:3b598ee
/////////////////////////////////////////////////////////////////////////
1: 						leftOperand.getTypeServices().getSQLTypeNameWithCollation(),
1: 						valueNode.getTypeServices().getSQLTypeNameWithCollation()
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b3bf9ca
/////////////////////////////////////////////////////////////////////////
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Army
-------------------------------------------------------------------------------
commit:7777c5d
/////////////////////////////////////////////////////////////////////////
1: 	 * Does this list *only* contain constant and/or parameter nodes?
0: 	 *
1: 	 * @return boolean	True if every node in this list is either a constant
1: 	 *  node or parameter node.
0: 	 */
0: 	public boolean containsOnlyConstantAndParamNodes()
0: 	{
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			ValueNode vNode = (ValueNode)elementAt(index);
1: 			if (!vNode.requiresTypeFromContext() &&
1: 			    !(vNode instanceof ConstantNode))
0: 			{
1: 				return false;
0: 			}
0: 		}
0: 
1: 		return true;
0: 	}
0: 
0: 	/**
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
1: 			if (valueNode.requiresTypeFromContext())
/////////////////////////////////////////////////////////////////////////
1: 	throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 			if (valueNode.requiresTypeFromContext())
/////////////////////////////////////////////////////////////////////////
0: 	throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 			if (((ValueNode) elementAt(index)).requiresTypeFromContext())
/////////////////////////////////////////////////////////////////////////
0: 			if (! (((ValueNode) elementAt(index)).requiresTypeFromContext()))
/////////////////////////////////////////////////////////////////////////
0: 			if (valueNode.requiresTypeFromContext())
1: 				valueNode.setType(descriptor);
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * A ValueNodeList represents a list of ValueNodes within a specific predicate 
0:  * (eg, IN list, NOT IN list or BETWEEN) in a DML statement.  
0:  * It extends QueryTreeNodeVector.
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public class ValueNodeList extends QueryTreeNodeVector
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			for (int index = 0; index < size(); index++)
0: 			{
0: 				ValueNode		valueNode;
0: 				valueNode = (ValueNode) elementAt(index);
0: 				valueNode.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Set the clause that this node appears in.
0: 	 *
0: 	 * @param clause	The clause that this node appears in.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setClause(int clause)
0: 	{
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			ValueNode		valueNode;
0: 				valueNode = (ValueNode) elementAt(index);
0: 			valueNode.setClause(clause);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Add a ValueNode to the list.
0: 	 *
0: 	 * @param valueNode	A ValueNode to add to the list
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void addValueNode(ValueNode valueNode) throws StandardException
0: 	{
0: 		addElement(valueNode);
0: 	}
0: 
0: 	/**
0: 	 * Bind this expression.  This means binding the sub-expressions,
0: 	 * as well as figuring out what the return type is for this expression.
0: 	 *
0: 	 * @param fromList		The FROM list for the query this
0: 	 *				expression is in, for binding columns.
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void	bindExpression(FromList fromList, 
0: 							   SubqueryList subqueryList,
0: 							   Vector aggregateVector)
0: 			throws StandardException
0: 	{
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			ValueNode vn = (ValueNode) elementAt(index);
0: 			vn = vn.bindExpression(fromList, subqueryList,
0: 								   aggregateVector);
0: 
0: 			setElementAt(vn, index);
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 	 * Generate a SQL->Java->SQL conversion tree any node in the list
0: 	 * which is not a system built-in type.
0: 	 * This is useful when doing comparisons, built-in functions, etc. on
0: 	 * java types which have a direct mapping to system built-in types.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException	Thrown on error
0: 	 */
0: 	public void genSQLJavaSQLTrees()
0: 		throws StandardException
0: 	{
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			ValueNode valueNode = (ValueNode) elementAt(index);
0: 			
0: 			if (! valueNode.getTypeId().systemBuiltIn())
0: 			{
0: 				setElementAt(valueNode.genSQLJavaSQLTree(), index);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the dominant DataTypeServices from the elements in the list.
0: 	 *
0: 	 * @return DataTypeServices		The dominant DataTypeServices.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public DataTypeDescriptor getDominantTypeServices() throws StandardException
0: 	{
0: 		DataTypeDescriptor	dominantDTS = null;
0: 
0: 		for (int index = 0; index < size(); index++)
0: 		{
0: 			ValueNode			valueNode;
0: 
0: 			valueNode = (ValueNode) elementAt(index);
0: 			if (valueNode.isParameterNode())
0: 				continue;
0: 			DataTypeDescriptor valueNodeDTS = valueNode.getTypeServices();
0: 
0: 			if (dominantDTS == null)
0: 			{
0: 				dominantDTS = valueNodeDTS;
0: 			}
0: 			else
0: 			{
0: 				dominantDTS = dominantDTS.getDominantType(valueNodeDTS, getClassFactory());
0: 			}
0: 		}
0: 
0: 		return dominantDTS;
0: 	}
0: 
0: 	/**
0: 	 * Get the first non-null DataTypeServices from the elements in the list.
0: 	 *
0: 	 * @return DataTypeServices		The first non-null DataTypeServices.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public DataTypeDescriptor getTypeServices() throws StandardException
0: 	{
0: 		DataTypeDescriptor	firstDTS = null;
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			ValueNode			valueNode;
0: 
0: 			valueNode = (ValueNode) elementAt(index);
0: 			DataTypeDescriptor valueNodeDTS = valueNode.getTypeServices();
0: 
0: 			if ((firstDTS == null) && (valueNodeDTS != null))
0: 			{
0: 				firstDTS = valueNodeDTS;
0: 				break;
0: 			}
0: 		}
0: 
0: 		return firstDTS;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not all of the entries in the list have the same
0: 	 * type precendence as the specified value.
0: 	 *
0: 	 * @param precedence	The specified precedence.
0: 	 *
0: 	 * @return	Whether or not all of the entries in the list have the same
0: 	 *			type precendence as the specified value.
0: 	 */
0: 	boolean allSamePrecendence(int precedence)
0: 	{
0: 		boolean allSame = true;
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			ValueNode			valueNode;
0: 
0: 			valueNode = (ValueNode) elementAt(index);
0: 			DataTypeDescriptor valueNodeDTS = valueNode.getTypeServices();
0: 
0: 			if (valueNodeDTS == null)
0: 			{
0: 				return false;
0: 			}
0: 
0: 			if (precedence != valueNodeDTS.getTypeId().typePrecedence())
0: 			{
0: 				return false;
0: 			}
0: 		}
0: 
0: 		return allSame;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Make sure that passed ValueNode's type is compatible with the non-parameter elements in the ValueNodeList.
0: 	 *
0: 	 * @param leftOperand	Check for compatibility against this parameter's type
0: 	 *
0: 	 */
0: 	public void compatible(ValueNode leftOperand) throws StandardException
0: 	{
0: 		int			 size = size();
0: 		TypeId	leftType;
0: 		ValueNode		valueNode;
0: 		TypeCompiler leftTC;
0: 
0: 		leftType = leftOperand.getTypeId();
0: 		leftTC = leftOperand.getTypeCompiler();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			valueNode = (ValueNode) elementAt(index);
0: 			if (valueNode.isParameterNode())
0: 				continue;
0: 
0: 
0: 			/*
0: 			** Are the types compatible to each other?  If not, throw an exception.
0: 			*/
0: 			if (! leftTC.compatible(valueNode.getTypeId()))
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_DB2_COALESCE_DATATYPE_MISMATCH,
0: 						leftType.getSQLTypeName(),
0: 						valueNode.getTypeId().getSQLTypeName()
0: 						);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Determine whether or not the leftOperand is comparable() with all of
0: 	 * the elements in the list. Throw an exception if any of them are not 
0: 	 * comparable.
0: 	 *
0: 	 * @param leftOperand	The left side of the expression
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void comparable(ValueNode leftOperand) throws StandardException
0: 	{
0: 		int			 size = size();
0: 		TypeId	leftType;
0: 		ValueNode		valueNode;
0: 		TypeCompiler leftTC;
0: 
0: 		leftType = leftOperand.getTypeId();
0: 		leftTC = leftOperand.getTypeCompiler();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			valueNode = (ValueNode) elementAt(index);
0: 
0: 			/*
0: 			** Can the types be compared to each other?  If not, throw an
0: 			** exception.
0: 			*/
0: 			if (! leftTC.comparable(valueNode.getTypeId(),
0: 									false,
0: 									getClassFactory()))
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_NOT_COMPARABLE, 
0: 						leftType.getSQLTypeName(),
0: 						valueNode.getTypeId().getSQLTypeName()
0: 						);
0: 			}
0: 		}
0: 	}
0: 
0: 	/** 
0: 	 * Determine whether or not any of the elements in the list are nullable.
0: 	 *
0: 	 * @return boolean	Whether or not any of the elements in the list 
0: 	 *					are nullable.
0: 	 */
0: 	public boolean isNullable()
0: 	{
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			if (((ValueNode) elementAt(index)).getTypeServices().isNullable())
0: 			{
0: 				return true;
0: 			}
0: 		}
0: 		return false;
0: 	}
0: 										 
0: 	/**
0: 	 * Does this list contain a ParameterNode?
0: 	 *
0: 	 * @return boolean	Whether or not the list contains a ParameterNode
0: 	 */
0: 	public boolean containsParameterNode()
0: 	{
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			if (((ValueNode) elementAt(index)).isParameterNode())
0: 			{
0: 				return true;
0: 			}
0: 		}
0: 		return false;
0: 	}
0: 										 
0: 	/**
0: 	 * Does this list contain all ParameterNodes?
0: 	 *
0: 	 * @return boolean	Whether or not the list contains all ParameterNodes
0: 	 */
0: 	public boolean containsAllParameterNodes()
0: 	{
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			if (! (((ValueNode) elementAt(index)).isParameterNode()))
0: 			{
0: 				return false;
0: 			}
0: 		}
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Does this list contain all ConstantNodes?
0: 	 *
0: 	 * @return boolean	Whether or not the list contains all ConstantNodes
0: 	 */
0: 	public boolean containsAllConstantNodes()
0: 	{
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			if (! ((ValueNode) elementAt(index) instanceof ConstantNode))
0: 			{
0: 				return false;
0: 			}
0: 		}
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Sort the entries in the list in ascending order.
0: 	 * (All values are assumed to be constants.)
0: 	 *
0: 	 * @param judgeODV  In case of type not exactly matching, the judging type.
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void sortInAscendingOrder(DataValueDescriptor judgeODV)
0: 		throws StandardException
0: 	{
0: 		int size = size();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(size > 0,
0: 				"size() expected to be non-zero");
0: 		}
0: 
0: 		/* We use bubble sort to sort the list since we expect
0: 		 * the list to be in sorted order > 90% of the time.
0: 		 */
0: 		boolean continueSort = true;
0: 
0: 		while (continueSort)
0: 		{
0: 			continueSort = false;
0: 			
0: 			for (int index = 1; index < size; index++)
0: 			{
0: 				ConstantNode currCN = (ConstantNode) elementAt(index);
0: 				DataValueDescriptor currODV =
0: 					 currCN.getValue();
0: 				ConstantNode prevCN = (ConstantNode) elementAt(index - 1);
0: 				DataValueDescriptor prevODV =
0: 					 prevCN.getValue();
0: 
0: 				/* Swap curr and prev if prev > curr */
0: 				if ((judgeODV == null && (prevODV.compare(currODV)) > 0) ||
0: 					(judgeODV != null && judgeODV.greaterThan(prevODV, currODV).equals(true)))
0: 				{
0: 					setElementAt(currCN, index - 1);
0: 					setElementAt(prevCN, index);
0: 					continueSort = true;
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Set the descriptor for every ParameterNode in the list.
0: 	 *
0: 	 * @param descriptor	The DataTypeServices to set for the parameters
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setParameterDescriptor(DataTypeDescriptor descriptor)
0: 						throws StandardException
0: 	{
0: 		int size = size();
0: 		ValueNode	valueNode;
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			valueNode = (ValueNode) elementAt(index);
0: 			if (valueNode.isParameterNode())
0: 			{
0: 				((ParameterNode) valueNode).setDescriptor(descriptor);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Preprocess a ValueNodeList.  For now, we just preprocess each ValueNode
0: 	 * in the list.
0: 	 *
0: 	 * @param	numTables			Number of tables in the DML Statement
0: 	 * @param	outerFromList		FromList from outer query block
0: 	 * @param	outerSubqueryList	SubqueryList from outer query block
0: 	 * @param	outerPredicateList	PredicateList from outer query block
0: 	 *
0: 	 * @return	Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void preprocess(int numTables,
0: 							FromList outerFromList,
0: 							SubqueryList outerSubqueryList,
0: 							PredicateList outerPredicateList) 
0: 		throws StandardException
0: 	{
0: 		int size = size();
0: 		ValueNode	valueNode;
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			valueNode = (ValueNode) elementAt(index);
0: 			valueNode.preprocess(numTables,
0: 								 outerFromList, outerSubqueryList,
0: 								 outerPredicateList);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Remap all ColumnReferences in this tree to be clones of the
0: 	 * underlying expression.
0: 	 *
0: 	 * @return ValueNodeList			The remapped expression tree.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public ValueNodeList remapColumnReferencesToExpressions()
0: 		throws StandardException
0: 	{
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			setElementAt(
0: 				((ValueNode) elementAt(index)).remapColumnReferencesToExpressions(),
0: 				index);
0: 		}
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not this expression tree represents a constant expression.
0: 	 *
0: 	 * @return	Whether or not this expression tree represents a constant expression.
0: 	 */
0: 	public boolean isConstantExpression()
0: 	{
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			boolean retcode;
0: 
0: 			retcode = ((ValueNode) elementAt(index)).isConstantExpression();
0: 			if (! retcode)
0: 			{
0: 				return retcode;
0: 			}
0: 		}
0: 
0: 		return true;
0: 	}
0: 
0: 	/** @see ValueNode#constantExpression */
0: 	public boolean constantExpression(PredicateList whereClause)
0: 	{
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			boolean retcode;
0: 
0: 			retcode =
0: 				((ValueNode) elementAt(index)).constantExpression(whereClause);
0: 			if (! retcode)
0: 			{
0: 				return retcode;
0: 			}
0: 		}
0: 
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Categorize this predicate.  Initially, this means
0: 	 * building a bit map of the referenced tables for each predicate.
0: 	 * If the source of this ColumnReference (at the next underlying level) 
0: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
0: 	 * will not be pushed down.
0: 	 *
0: 	 * For example, in:
0: 	 *		select * from (select 1 from s) a (x) where x = 1
0: 	 * we will not push down x = 1.
0: 	 * NOTE: It would be easy to handle the case of a constant, but if the
0: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
0: 	 * that tree into the pushed predicate, and that tree could contain
0: 	 * subqueries and method calls.
0: 	 * RESOLVE - revisit this issue once we have views.
0: 	 *
0: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
0: 	 * @param simplePredsOnly	Whether or not to consider method
0: 	 *							calls, field references and conditional nodes
0: 	 *							when building bit map
0: 	 *
0: 	 * @return boolean		Whether or not source.expression is a ColumnReference
0: 	 *						or a VirtualColumnNode.
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
0: 		throws StandardException
0: 	{
0: 		/* We stop here when only considering simple predicates
0: 		 *  as we don't consider in lists when looking
0: 		 * for null invariant predicates.
0: 		 */
0: 		boolean pushable = true;
0: 		int size = size();
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			pushable = ((ValueNode) elementAt(index)).categorize(referencedTabs, simplePredsOnly) &&
0: 					   pushable;
0: 		}
0: 
0: 		return pushable;
0: 	}
0: 
0: 	/**
0: 	 * Return the variant type for the underlying expression.
0: 	 * The variant type can be:
0: 	 *		VARIANT				- variant within a scan
0: 	 *							  (method calls and non-static field access)
0: 	 *		SCAN_INVARIANT		- invariant within a scan
0: 	 *							  (column references from outer tables)
0: 	 *		QUERY_INVARIANT		- invariant within the life of a query
0: 	 *		CONSTANT			- constant
0: 	 *
0: 	 * @return	The variant type for the underlying expression.
0: 	 * @exception StandardException	thrown on error
0: 	 */
0: 	protected int getOrderableVariantType() throws StandardException
0: 	{
0: 		int listType = Qualifier.CONSTANT;
0: 		int size = size();
0: 
0: 		/* If any element in the list is VARIANT then the 
0: 		 * entire expression is variant
0: 		 * else it is SCAN_INVARIANT if any element is SCAN_INVARIANT
0: 		 * else it is QUERY_INVARIANT.
0: 		 */
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			int curType = ((ValueNode) elementAt(index)).getOrderableVariantType();
0: 			listType = Math.min(listType, curType);
0: 		}
0: 
0: 		return listType;
0: 	}
0: }
============================================================================