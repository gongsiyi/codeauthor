1:661c2e6: /*
15:508a010: 
1:661c2e6:    Derby - Class org.apache.derby.impl.sql.compile.MatchingClauseNode
1:508a010: 
1:661c2e6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:661c2e6:    contributor license agreements.  See the NOTICE file distributed with
1:661c2e6:    this work for additional information regarding copyright ownership.
1:661c2e6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:661c2e6:    (the "License"); you may not use this file except in compliance with
1:661c2e6:    the License.  You may obtain a copy of the License at
1:508a010: 
1:661c2e6:       http://www.apache.org/licenses/LICENSE-2.0
1:508a010: 
1:661c2e6:    Unless required by applicable law or agreed to in writing, software
1:661c2e6:    distributed under the License is distributed on an "AS IS" BASIS,
1:661c2e6:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:661c2e6:    See the License for the specific language governing permissions and
1:661c2e6:    limitations under the License.
1:508a010: 
3:508a010:  */
1:508a010: 
1:661c2e6: package	org.apache.derby.impl.sql.compile;
1:508a010: 
1:508a010: import java.lang.reflect.Modifier;
1:661c2e6: import java.util.ArrayList;
1:508a010: import java.util.HashMap;
1:6ab1083: import java.util.HashSet;
1:01632c2: import java.util.List;
1:01632c2: import org.apache.derby.catalog.types.DefaultInfoImpl;
1:661c2e6: import org.apache.derby.iapi.error.StandardException;
1:508a010: import org.apache.derby.iapi.reference.ClassName;
1:661c2e6: import org.apache.derby.iapi.reference.SQLState;
1:01632c2: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:508a010: import org.apache.derby.iapi.services.compiler.LocalField;
1:508a010: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:661c2e6: import org.apache.derby.iapi.services.context.ContextManager;
1:508a010: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:661c2e6: import org.apache.derby.shared.common.sanity.SanityManager;
1:01632c2: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1:01632c2: import org.apache.derby.iapi.sql.ResultDescription;
1:508a010: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:daffaee: import org.apache.derby.iapi.sql.compile.IgnoreFilter;
1:508a010: import org.apache.derby.iapi.sql.compile.Visitor;
1:01632c2: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:69ab4bd: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1:508a010: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:01632c2: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:508a010: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:01632c2: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:6ab1083: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:6ab1083: import org.apache.derby.iapi.types.DataValueDescriptor;
1:508a010: 
1:6ab1083: /**
1:661c2e6:  * Node representing a WHEN MATCHED or WHEN NOT MATCHED clause
1:661c2e6:  * in a MERGE statement.
1:661c2e6:  *
1:01632c2:  */
1:508a010: 
1:661c2e6: public class MatchingClauseNode extends QueryTreeNode
1:508a010: {
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:6ab1083:     //
1:661c2e6:     // CONSTANTS
1:4cf6633:     //
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:18792e2: 
1:508a010:     private static  final   String  CURRENT_OF_NODE_NAME = "$MERGE_CURRENT";
1:508a010: 
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:6ab1083:     //
1:661c2e6:     // STATE
7:661c2e6:     //
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:508a010: 
1:661c2e6:     //
1:4cf6633:     // Filled in by the constructor.
1:4cf6633:     //
1:661c2e6:     private ValueNode           _matchingRefinement;
1:661c2e6:     private ResultColumnList    _updateColumns;
1:661c2e6:     private ResultColumnList    _insertColumns;
1:661c2e6:     private ResultColumnList    _insertValues;
1:508a010: 
1:508a010:     //
1:4cf6633:     // Filled in at bind() time.
1:508a010:     //
1:508a010: 
1:4cf6633:     // the INSERT/UPDATE/DELETE statement of this WHEN [ NOT ] MATCHED clause
1:661c2e6:     private DMLModStatementNode _dml;
1:508a010: 
1:4cf6633:     // the columns in the temporary conglomerate which drives the INSERT/UPDATE/DELETE
1:508a010:     private ResultColumnList        _thenColumns;
1:508a010: 
1:4cf6633:     //
1:4cf6633:     // Filled in at generate() time.
1:4cf6633:     //
1:508a010:     private int                             _clauseNumber;
1:508a010:     private String                          _actionMethodName;
1:508a010:     private String                          _resultSetFieldName;
1:01632c2:     private String                          _rowMakingMethodName;
1:508a010:     
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:661c2e6:     //
1:661c2e6:     // CONSTRUCTORS/FACTORY METHODS
1:661c2e6:     //
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:508a010: 
1:856f892:     /**
1:661c2e6:      * Constructor called by factory methods.
1:508a010:      */
1:661c2e6:     private MatchingClauseNode
1:3e77b5a:         (
1:661c2e6:          ValueNode  matchingRefinement,
1:661c2e6:          ResultColumnList   updateColumns,
1:661c2e6:          ResultColumnList   insertColumns,
1:661c2e6:          ResultColumnList   insertValues,
1:661c2e6:          ContextManager     cm
1:508a010:          )
1:01632c2:         throws StandardException
1:508a010:     {
1:661c2e6:         super( cm );
1:01632c2:         
1:661c2e6:         _matchingRefinement = matchingRefinement;
1:661c2e6:         _updateColumns = updateColumns;
1:661c2e6:         _insertColumns = insertColumns;
1:661c2e6:         _insertValues = insertValues;
1:01632c2:     }
1:2f8e6fb: 
1:661c2e6:     /** Make a WHEN MATCHED ... THEN UPDATE clause */
1:508a010:     static  MatchingClauseNode   makeUpdateClause
1:2f8e6fb:         (
1:661c2e6:          ValueNode  matchingRefinement,
1:661c2e6:          ResultColumnList   updateColumns,
1:661c2e6:          ContextManager     cm
1:508a010:          )
1:01632c2:         throws StandardException
1:2f8e6fb:     {
1:661c2e6:         return new MatchingClauseNode( matchingRefinement, updateColumns, null, null, cm );
1:508a010:     }
1:6ab1083: 
1:661c2e6:     /** Make a WHEN MATCHED ... THEN DELETE clause */
1:508a010:     static  MatchingClauseNode   makeDeleteClause
1:6ab1083:         (
1:661c2e6:          ValueNode  matchingRefinement,
1:661c2e6:          ContextManager     cm
1:508a010:          )
1:01632c2:         throws StandardException
1:2f8e6fb:     {
1:661c2e6:         return new MatchingClauseNode( matchingRefinement, null, null, null, cm );
1:508a010:     }
1:6ab1083: 
1:661c2e6:     /** Make a WHEN NOT MATCHED ... THEN INSERT clause */
1:508a010:     static  MatchingClauseNode   makeInsertClause
1:01632c2:         (
1:661c2e6:          ValueNode  matchingRefinement,
1:661c2e6:          ResultColumnList   insertColumns,
1:661c2e6:          ResultColumnList   insertValues,
1:661c2e6:          ContextManager     cm
1:508a010:          )
1:01632c2:         throws StandardException
1:508a010:     {
1:661c2e6:         return new MatchingClauseNode( matchingRefinement, null, insertColumns, insertValues, cm );
1:508a010:     }
1:01632c2: 
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:757bc0e:     //
1:661c2e6:     // ACCESSORS
1:757bc0e:     //
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:01632c2: 
1:661c2e6:     /** Return true if this is a WHEN MATCHED ... UPDATE clause */
1:508a010:     boolean isUpdateClause()    { return (_updateColumns != null); }
1:01632c2:     
1:661c2e6:     /** Return true if this is a WHEN NOT MATCHED ... INSERT clause */
1:508a010:     boolean isInsertClause()    { return (_insertValues != null); }
1:01632c2:     
1:661c2e6:     /** Return true if this is a WHEN MATCHED ... DELETE clause */
1:508a010:     boolean isDeleteClause()    { return !( isUpdateClause() || isInsertClause() ); }
1:01632c2: 
1:0ae3b6d:     /**
1:508a010:      * Return the list of columns which form the rows of the ResultSet which drive
1:508a010:      * the INSERT/UPDATE/DELETE actions.
1:6ab1083:      */
1:757bc0e:     ResultColumnList    getThenColumns() { return _thenColumns; }
1:01632c2: 
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:18792e2:     //
1:757bc0e:     // bind() BEHAVIOR CALLED BY MergeNode
1:daffaee:     //
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:01632c2: 
1:757bc0e:     /** Bind this WHEN [ NOT ] MATCHED clause against the parent MergeNode */
1:508a010:     void    bind
1:508a010:         (
1:508a010:          DataDictionary dd,
2:508a010:          MergeNode mergeNode,
1:508a010:          FromList fullFromList,
1:2f8e6fb:          FromBaseTable targetTable
1:6ab1083:          )
1:6ab1083:         throws StandardException
1:6ab1083:     {
1:1484b83:         //
1:1484b83:         // Although the SQL Standard allows subqueries in the WHEN [ NOT ] MATCHED clauses,
1:1484b83:         // we don't support them yet. That is because code-generation for those clauses breaks
1:1484b83:         // if they contain subqueries. That, in turn, is because we don't completely optimize those
1:1484b83:         // clauses. If we improve Derby so that we do completely optimize the WHEN [ NOT ] MATCHED clauses,
1:1484b83:         // then we can consider enabling subqueries in them.
1:1484b83:         //
1:1484b83:         forbidSubqueries();
1:2f8e6fb: 
1:01632c2:         _thenColumns = new ResultColumnList( getContextManager() );
1:1484b83: 
1:508a010:         if ( isDeleteClause() ) { bindDelete( dd, fullFromList, targetTable ); }
1:3e77b5a:         if ( isUpdateClause() ) { bindUpdate( dd, mergeNode, fullFromList, targetTable ); }
1:508a010:         if ( isInsertClause() ) { bindInsert( dd, mergeNode, fullFromList, targetTable ); }
1:508a010:     }
1:6ab1083: 
1:508a010:     /** Bind the optional refinement condition in the MATCHED clause */
1:508a010:     void    bindRefinement( MergeNode mergeNode, FromList fullFromList ) throws StandardException
1:6ab1083:     {
1:508a010:         if ( _matchingRefinement != null )
1:508a010:         {
1:1cd5dd1:             FromList    fromList = fullFromList;
1:1cd5dd1: 
1:1cd5dd1:             //
1:1cd5dd1:             // For an INSERT action, the WHEN NOT MATCHED refinement can only
1:1cd5dd1:             // mention columns in the source table.
1:1cd5dd1:             //
1:1cd5dd1:             if ( isInsertClause() )
1:1cd5dd1:             {
1:1cd5dd1:                 fromList = new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() );
1:1cd5dd1:                 fromList.addElement( fullFromList.elementAt( MergeNode.SOURCE_TABLE_INDEX ) );
1:1cd5dd1:             }
1:1cd5dd1: 
1:1cd5dd1:             mergeNode.bindExpression( _matchingRefinement, fromList );
1:508a010:         }
1:508a010:     }
1:01632c2: 
1:508a010:     /** Collect the columns mentioned by expressions in this MATCHED clause */
1:508a010:     void    getColumnsInExpressions
1:508a010:         (
1:508a010:          MergeNode  mergeNode,
1:508a010:          HashMap<String,ColumnReference> drivingColumnMap
1:508a010:          )
1:508a010:         throws StandardException
1:508a010:     {
1:508a010:         if ( _matchingRefinement != null )
1:508a010:         {
1:2f8e6fb:             mergeNode.getColumnsInExpression( drivingColumnMap, _matchingRefinement, ColumnReference.MERGE_UNKNOWN );
1:508a010:         }
1:01632c2: 
2:508a010:         if ( isUpdateClause() )
1:508a010:         {
1:6ab1083:             TableName   targetTableName = mergeNode.getTargetTable().getTableName();
1:6ab1083: 
1:6ab1083:             //
1:6ab1083:             // Get all columns mentioned on both sides of SET operators in WHEN MATCHED ... THEN UPDATE clauses.
1:6ab1083:             // We need the left side because UPDATE needs before and after images of columns.
1:6ab1083:             // We need the right side because there may be columns in the expressions there.
1:6ab1083:             //
1:508a010:             for ( ResultColumn rc : _updateColumns )
1:508a010:             {
1:2f8e6fb:                 mergeNode.getColumnsInExpression( drivingColumnMap, rc.getExpression(), ColumnReference.MERGE_UNKNOWN );
1:6ab1083: 
1:b0456a0:                 ColumnReference leftCR = new ColumnReference( rc.getName(), targetTableName, getContextManager() );
1:2f8e6fb:                 mergeNode.addColumn( drivingColumnMap, leftCR, ColumnReference.MERGE_TARGET );
1:508a010:             }
1:508a010:         }
2:508a010:         else if ( isInsertClause() )
1:508a010:         {
1:508a010:             // get all columns mentioned in the VALUES subclauses of WHEN NOT MATCHED ... THEN INSERT clauses
1:508a010:             for ( ResultColumn rc : _insertValues )
1:508a010:             {
1:2f8e6fb:                 mergeNode.getColumnsInExpression( drivingColumnMap, rc.getExpression(), ColumnReference.MERGE_UNKNOWN );
1:508a010:             }
1:508a010:         }
1:3e77b5a:         else if ( isDeleteClause() )
1:3e77b5a:         {
1:3e77b5a:             // add all of the THEN columns
1:3e77b5a:             mergeNode.getColumnsFromList( drivingColumnMap, _thenColumns, ColumnReference.MERGE_TARGET );
1:3e77b5a:         }
1:508a010:     }
1:01632c2:     
1:757bc0e:     ////////////////
1:757bc0e:     //
1:757bc0e:     // BIND UPDATE
1:757bc0e:     //
1:757bc0e:     ////////////////
1:508a010: 
1:661c2e6:     /** Bind a WHEN MATCHED ... THEN UPDATE clause */
1:508a010:     private void    bindUpdate
1:508a010:         (
1:508a010:          DataDictionary dd,
1:3e77b5a:          MergeNode  mergeNode,
1:508a010:          FromList fullFromList,
1:2f8e6fb:          FromBaseTable targetTable
1:508a010:          )
1:508a010:         throws StandardException
1:508a010:     {
1:2f8e6fb:         ResultColumnList    setClauses = realiasSetClauses( targetTable );
1:3e77b5a:         bindSetClauses( mergeNode, fullFromList, targetTable, setClauses );
1:b3f38f8: 
1:b3f38f8:         TableName   tableName = targetTable.getTableNameField();
1:b3f38f8:         FromList    selectFromList = fullFromList;
1:3e77b5a: 
2:661c2e6:         SelectNode  selectNode = new SelectNode
8:661c2e6:             (
1:2f8e6fb:              setClauses,
1:b3f38f8:              selectFromList,
2:661c2e6:              null,      // where clause
2:661c2e6:              null,      // group by list
2:661c2e6:              null,      // having clause
2:661c2e6:              null,      // window list
2:661c2e6:              null,      // optimizer plan override
1:661c2e6:              getContextManager()
1:3e77b5a:              );
1:b3f38f8:         _dml = new UpdateNode( tableName, selectNode, this, getContextManager() );
1:508a010: 
1:661c2e6:         _dml.bindStatement();
1:6ab1083: 
1:757bc0e:         //
1:ffbe813:         // Don't add USAGE privilege on user-defined types.
1:757bc0e:         //
1:ffbe813:         boolean wasSkippingTypePrivileges = getCompilerContext().skipTypePrivileges( true );
1:ffbe813:             
1:ffbe813:         //
1:6ab1083:         // Split the update row into its before and after images.
1:ffbe813:         //
1:6ab1083:         ResultColumnList    beforeColumns = new ResultColumnList( getContextManager() );
1:6ab1083:         ResultColumnList    afterColumns = new ResultColumnList( getContextManager() );
1:11f7ee3:         ResultColumnList    fullUpdateRow = getBoundSelectUnderUpdate().getResultColumns();
1:6ab1083:         
1:6ab1083:         // the full row is the before image, the after image, and a row location
1:6ab1083:         int     rowSize = fullUpdateRow.size() / 2;
1:6ab1083: 
1:b3f38f8:         // split the row into before and after images
1:6ab1083:         for ( int i = 0; i < rowSize; i++ )
1:6ab1083:         {
1:6ab1083:             ResultColumn    origBeforeRC = fullUpdateRow.elementAt( i );
1:6ab1083:             ResultColumn    origAfterRC = fullUpdateRow.elementAt( i + rowSize );
1:6ab1083:             ResultColumn    beforeRC = origBeforeRC.cloneMe();
1:6ab1083:             ResultColumn    afterRC = origAfterRC.cloneMe();
1:6ab1083: 
1:6ab1083:             beforeColumns.addResultColumn( beforeRC );
1:6ab1083:             afterColumns.addResultColumn( afterRC );
1:6ab1083:         }
1:6ab1083: 
1:6ab1083:         buildThenColumnsForUpdate( fullFromList, targetTable, fullUpdateRow, beforeColumns, afterColumns );
1:ffbe813: 
1:ffbe813:         getCompilerContext().skipTypePrivileges( wasSkippingTypePrivileges );
1:6ab1083:     }
1:6ab1083: 
1:bbd6aff:     /**
1:0ae3b6d:      * <p>
1:4cf6633:      * Due to discrepancies in how names are resolved by SELECT and UPDATE,
1:2f8e6fb:      * we have to force the left side of SET clauses to use the same table identifiers
1:2f8e6fb:      * as the right sides of the SET clauses.
1:2f8e6fb:      * </p>
1:2f8e6fb:      */
1:2f8e6fb:     private ResultColumnList    realiasSetClauses
1:2f8e6fb:         (
1:2f8e6fb:          FromBaseTable targetTable
1:2f8e6fb:          )
1:2f8e6fb:         throws StandardException
1:2f8e6fb:     {
1:2f8e6fb:         ResultColumnList    rcl = new ResultColumnList( getContextManager() );
1:2f8e6fb:         for ( int i = 0; i < _updateColumns.size(); i++ )
1:2f8e6fb:         {
1:2f8e6fb:             ResultColumn    setRC = _updateColumns.elementAt( i );
1:b3f38f8:             TableName   tableName = targetTable.getTableName();
1:2f8e6fb:             ColumnReference newTargetColumn = new ColumnReference
1:2f8e6fb:                 (
1:2f8e6fb:                  setRC.getReference().getColumnName(),
1:b3f38f8:                  tableName,
1:2f8e6fb:                  getContextManager()
1:2f8e6fb:                  );
1:2f8e6fb:             newTargetColumn.setMergeTableID( ColumnReference.MERGE_TARGET );
1:2f8e6fb:             ResultColumn    newRC = new ResultColumn
1:2f8e6fb:                 (
1:2f8e6fb:                  newTargetColumn,
1:2f8e6fb:                  setRC.getExpression(),
1:2f8e6fb:                  getContextManager()
1:2f8e6fb:                  );
1:2f8e6fb:             rcl.addResultColumn( newRC );
1:2f8e6fb:         }
1:2f8e6fb: 
1:2f8e6fb:         return rcl;
1:2f8e6fb:     }
1:2f8e6fb:     
1:2f8e6fb:     /**
1:bbd6aff:      * <p>
1:6ab1083:      * Get the bound SELECT node under the dummy UPDATE node.
1:4cf6633:      * This may not be the source result set of the UPDATE node. That is because a ProjectRestrictNode
1:6ab1083:      * may have been inserted on top of it by DEFAULT handling. This method
1:4cf6633:      * exists to make the UPDATE actions of MERGE statements behave like ordinary
1:6ab1083:      * UPDATE statements in this situation. The behavior is actually wrong. See
1:6ab1083:      * DERBY-6414. Depending on how that bug is addressed, we may be able
1:6ab1083:      * to remove this method eventually.
1:856f892:      * </p>
1:856f892:      */
1:6ab1083:     private ResultSetNode    getBoundSelectUnderUpdate()
1:856f892:         throws StandardException
1:856f892:     {
1:6ab1083:         ResultSetNode   candidate = _dml.resultSet;
1:856f892: 
1:6ab1083:         while ( candidate != null )
1:856f892:         {
1:6ab1083:             if ( candidate instanceof SelectNode ) { return candidate; }
1:6ab1083:             else if ( candidate instanceof SingleChildResultSetNode )
1:3511a12:             {
1:6ab1083:                 candidate = ((SingleChildResultSetNode) candidate).getChildResult();
1:3511a12:             }
1:6ab1083:             else    { break; }
1:6ab1083:         }
1:856f892:         
1:6ab1083:         // don't understand what's going on
1:6ab1083:         throw StandardException.newException( SQLState.NOT_IMPLEMENTED );
1:6ab1083:     }
1:3511a12:     
1:01632c2:     /** Bind the SET clauses of an UPDATE action */
1:01632c2:     private void    bindSetClauses
1:856f892:         (
1:3e77b5a:          MergeNode mergeNode,
1:01632c2:          FromList fullFromList,
1:2f8e6fb:          FromTable targetTable,
1:2f8e6fb:          ResultColumnList   setClauses
1:856f892:          )
1:3511a12:         throws StandardException
1:6ab1083:     {
1:01632c2:         // needed to make the UpdateNode bind
1:2f8e6fb:         setClauses.replaceOrForbidDefaults( targetTable.getTableDescriptor(), _updateColumns, true );
1:6ab1083: 
1:2f8e6fb:         bindExpressions( setClauses, fullFromList );
1:3e77b5a: 
1:3e77b5a:         //
1:3e77b5a:         // For column resolution later on, columns on the left side
1:3e77b5a:         // of SET operators are associated with the TARGET table.
1:3e77b5a:         //
1:3e77b5a:         for ( int i = 0; i < _updateColumns.size(); i++ )
1:3e77b5a:         {
1:3e77b5a:             ResultColumn    rc = _updateColumns.elementAt( i );
1:3e77b5a:             ColumnReference  cr = rc.getReference();
1:3e77b5a:             cr.setMergeTableID( ColumnReference.MERGE_TARGET );
1:3e77b5a:         }
1:3e77b5a: 
1:3e77b5a:         // Now associate the columns on the right side of SET operators.
1:daffaee:         List<ColumnReference> colRefs = getColumnReferences( _updateColumns );
1:3e77b5a:         for ( ColumnReference cr : colRefs )
1:3e77b5a:         {
1:3e77b5a:             mergeNode.associateColumn( fullFromList, cr, ColumnReference.MERGE_UNKNOWN );
1:3e77b5a:         }
1:856f892:     }
1:856f892: 
1:1484b83:     /**
1:2f8e6fb:      * <p>
1:6ab1083:      * Construct the row in the temporary table which drives an UPDATE action.
1:6ab1083:      * Unlike a DELETE, whose temporary row is just a list of copied columns, the
1:6ab1083:      * temporary row for UPDATE may contain complex expressions which must
1:6ab1083:      * be code-generated later on.
1:3511a12:      * </p>
1:3511a12:      */
1:6ab1083:     private void    buildThenColumnsForUpdate
1:3511a12:         (
1:6ab1083:          FromList fullFromList,
1:6ab1083:          FromTable targetTable,
1:6ab1083:          ResultColumnList   fullRow,
1:6ab1083:          ResultColumnList beforeRow,
1:6ab1083:          ResultColumnList afterValues
1:3511a12:          )
1:6ab1083:         throws StandardException
1:6ab1083:     {
1:69ab4bd:         TableDescriptor td = targetTable.getTableDescriptor();
1:6ab1083:         HashSet<String> changedColumns = getChangedColumnNames();
1:6ab1083:         HashSet<String> changedGeneratedColumns = getChangedGeneratedColumnNames( td, changedColumns );
1:b3f38f8:         
1:6ab1083:         _thenColumns = fullRow.copyListAndObjects();
1:856f892: 
1:6ab1083:         //
1:6ab1083:         // Here we set up for the evaluation of expressions in the temporary table
1:6ab1083:         // which drives the INSERT action. If we were actually generating the dummy SELECT
1:6ab1083:         // for the DML action, the work would normally be done there. But we don't generate
1:6ab1083:         // that SELECT. So we do the following here:
1:6ab1083:         //
1:6ab1083:         // 1) If a column has a value specified in the WHEN [ NOT ] MATCHED clause, then we use it.
1:6ab1083:         //     There is some special handling to make the DEFAULT value work for identity columns.
1:6ab1083:         //
1:6ab1083:         // 2) Otherwise, if the column has a default, then we plug it in.
1:6ab1083:         //
1:6ab1083:         for ( int i = 0; i < _thenColumns.size(); i++ )
1:6ab1083:         {
1:6ab1083:             ResultColumn    origRC = _thenColumns.elementAt( i );
1:69ab4bd: 
1:6ab1083:             boolean isAfterColumn = (i >= beforeRow.size());
1:6ab1083: 
1:6ab1083:             // skip the final RowLocation column of an UPDATE
1:6ab1083:             boolean isRowLocation = isRowLocation( origRC );
1:6ab1083:             ValueNode   origExpr = origRC.getExpression();
1:6ab1083: 
1:6ab1083:             if ( isRowLocation ) { continue; }
1:6ab1083: 
1:6ab1083:             String              columnName = origRC.getName();
1:6ab1083:             ColumnDescriptor    cd = td.getColumnDescriptor( columnName );
1:6ab1083:             boolean         changed = false;
1:6ab1083: 
1:6ab1083:             //
1:6ab1083:             // This handles the case that a GENERATED BY DEFAULT identity column is being
1:6ab1083:             // set to the keyword DEFAULT. This causes the UPDATE action of a MERGE statement
1:6ab1083:             // to have the same wrong behavior as a regular UPDATE statement. See derby-6414.
1:6ab1083:             //
1:6ab1083:             if ( cd.isAutoincrement() && (origRC.getExpression() instanceof NumericConstantNode) )
1:6ab1083:             {
1:6ab1083:                 DataValueDescriptor numericValue = ((NumericConstantNode) origRC.getExpression()).getValue();
1:6ab1083:                 
1:6ab1083:                 if ( numericValue == null )
1:6ab1083:                 {
1:6ab1083:                     ResultColumn    newRC = makeAutoGenRC( targetTable, origRC, i+1 );
1:6ab1083:                     newRC.setVirtualColumnId( origRC.getVirtualColumnId() );
1:6ab1083:                     _thenColumns.setElementAt( newRC, i  );
1:6ab1083: 
1:6ab1083:                     continue;
1:856f892:                 }
1:6ab1083:             }
1:6ab1083: 
1:6ab1083:             //
1:6ab1083:             // VirtualColumnNodes are skipped at code-generation time. This can result in
1:6ab1083:             // NPEs when evaluating generation expressions. Replace VirtualColumnNodes with
1:6ab1083:             // UntypedNullConstantNodes, except for identity columns, which require special
1:6ab1083:             // handling below.
1:6ab1083:             //
1:6ab1083:             if ( !origRC.isAutoincrement() && (origRC.getExpression() instanceof VirtualColumnNode) )
1:6ab1083:             {
1:6ab1083:                 origRC.setExpression( new UntypedNullConstantNode( getContextManager() ) );
1:6ab1083:             }
1:6ab1083: 
1:6ab1083:             //
1:6ab1083:             // Generated columns need special handling. The value needs to be recalculated
1:6ab1083:             // under the following circumstances:
1:6ab1083:             //
1:6ab1083:             // 1) It's the after image of the column
1:6ab1083:             //
1:6ab1083:             // 2) AND the statement causes the value to change.
1:6ab1083:             //
1:6ab1083:             // Otherwise, the value should be set to whatever is in the row coming out
1:6ab1083:             // of the driving left join.
1:6ab1083:             //
1:6ab1083:             if ( cd.hasGenerationClause() )
1:6ab1083:             {
1:6ab1083:                 if ( isAfterColumn && changedGeneratedColumns.contains( columnName ) )
1:6ab1083:                 {
1:6ab1083:                     // Set the expression to something that won't choke ResultColumnList.generateEvaluatedRow().
1:6ab1083:                     // The value will be a Java null at execution time, which will cause the value
1:6ab1083:                     // to be re-generated.
1:6ab1083:                     origRC.setExpression( new UntypedNullConstantNode( getContextManager() ) );
1:6ab1083:                 }
1:6ab1083:                 else
1:6ab1083:                 {
1:6ab1083:                     ColumnReference cr = new ColumnReference
1:6ab1083:                         ( columnName, targetTable.getTableName(), getContextManager() );
1:6ab1083:                     origRC.setExpression( cr );
1:6ab1083: 
1:6ab1083:                     // remove the column descriptor in order to turn off hasGenerationClause()
1:b0456a0:                     origRC.setColumnDescriptor( null, null );
1:6ab1083:                 }
1:6ab1083:                 
1:6ab1083:                 continue;
1:6ab1083:             }
1:6ab1083: 
1:6ab1083:             if ( isAfterColumn )
1:6ab1083:             {
1:6ab1083:                 for ( int ic = 0; ic < beforeRow.size(); ic++ )
1:6ab1083:                 {
1:6ab1083:                     ResultColumn    icRC = beforeRow.elementAt( ic );
1:6ab1083: 
1:6ab1083:                     if ( columnName.equals( icRC.getName() ) )
1:6ab1083:                     {
1:6ab1083:                         ResultColumn    newRC = null;
1:6ab1083:                     
1:6ab1083:                         // replace DEFAULT for a generated or identity column
1:6ab1083:                         ResultColumn    valueRC = afterValues.elementAt( ic );
1:6ab1083: 
1:6ab1083:                         if ( valueRC.wasDefaultColumn() || (valueRC.getExpression() instanceof UntypedNullConstantNode ) )
1:6ab1083:                         {
1:6ab1083:                             if ( !cd.isAutoincrement() )
1:6ab1083:                             {
1:6ab1083:                                 //
1:6ab1083:                                 // Eliminate column references under identity columns. They
1:6ab1083:                                 // will mess up the code generation.
1:6ab1083:                                 //
1:6ab1083:                                 ValueNode   expr = origRC.getExpression();
1:6ab1083:                                 if ( expr instanceof ColumnReference )
1:6ab1083:                                 {
1:6ab1083:                                     origRC.setExpression( new UntypedNullConstantNode( getContextManager() ) );
1:6ab1083:                                 }
1:6ab1083:                                 continue;
1:6ab1083:                             }
1:6ab1083: 
1:6ab1083:                             newRC = makeAutoGenRC( targetTable, origRC, i+1 );
1:6ab1083:                         }
1:6ab1083:                         else
1:6ab1083:                         {
1:6ab1083:                             newRC = valueRC.cloneMe();
1:6ab1083:                             newRC.setType( origRC.getTypeServices() );
1:6ab1083:                         }
1:6ab1083: 
1:6ab1083:                         newRC.setVirtualColumnId( origRC.getVirtualColumnId() );
1:6ab1083:                         _thenColumns.setElementAt( newRC, i  );
1:6ab1083:                         changed = true;
1:6ab1083:                         break;
1:6ab1083:                     }
1:6ab1083:                 }
1:6ab1083:             }
1:6ab1083: 
1:6ab1083:             // plug in defaults if we haven't done so already
1:6ab1083:             if ( !changed )
1:6ab1083:             {
1:6ab1083:                 DefaultInfoImpl     defaultInfo = (DefaultInfoImpl) cd.getDefaultInfo();
1:6ab1083: 
1:6ab1083: 				if ( (defaultInfo != null) && !defaultInfo.isGeneratedColumn() && !cd.isAutoincrement() )
1:6ab1083: 				{
1:6ab1083:                     _thenColumns.setDefault( origRC, cd, defaultInfo );
1:6ab1083:                     changed = true;
1:6ab1083: 				}
1:6ab1083:             }
1:6ab1083: 
1:6ab1083:             // set the result column name correctly for buildThenColumnSignature()
1:6ab1083:             ResultColumn    finalRC = _thenColumns.elementAt( i );
1:6ab1083:             finalRC.setName( cd.getColumnName() );
1:6ab1083:             
1:6ab1083:             //
1:6ab1083:             // Turn off the autogenerated bit for identity columns so that
1:6ab1083:             // ResultColumnList.generateEvaluatedRow() doesn't try to compile
1:6ab1083:             // code to generate values for the before images in UPDATE rows.
1:6ab1083:             // This logic will probably need to be revisited as part of fixing derby-6414.
1:6ab1083:             //
1:6ab1083:             finalRC.resetAutoincrementGenerated();
1:6ab1083:         }   // end loop through _thenColumns
1:6ab1083:     }
1:6ab1083: 
1:6ab1083:     /** Get the names of the columns explicitly changed by SET clauses */
1:6ab1083:     private HashSet<String> getChangedColumnNames()
1:6ab1083:         throws StandardException
1:6ab1083:     {
1:6ab1083:         HashSet<String> result = new HashSet<String>();
1:6ab1083: 
1:856f892:         for ( int i = 0; i < _updateColumns.size(); i++ )
1:6ab1083:         {
1:6ab1083:             String  columnName = _updateColumns.elementAt( i ).getName();
1:6ab1083:             result.add( columnName );
1:6ab1083:         }
1:6ab1083: 
1:6ab1083:         return result;
1:6ab1083:     }
1:6ab1083: 
1:3511a12:     /**
1:1484b83:      * <p>
1:6ab1083:      * Get the names of the generated columns which are changed
1:6ab1083:      * by the UPDATE statement. These are the generated columns which
1:6ab1083:      * match one of the following conditions:
1:6ab1083:      * </p>
1:6ab1083:      *
1:6ab1083:      * <ul>
1:6ab1083:      * <li>Are explicitly mentioned on the left side of a SET clause.</li>
1:6ab1083:      * <li>Are built from other columns which are explicitly mentioned on the left side of a SET clause.</li>
1:6ab1083:      * </ul>
1:6ab1083:      */
1:6ab1083:     private HashSet<String> getChangedGeneratedColumnNames
1:6ab1083:         (
1:6ab1083:          TableDescriptor    targetTableDescriptor,
1:6ab1083:          HashSet<String>    changedColumnNames  // columns which are explicitly mentioned on the left side of a SET clause
1:6ab1083:          )
1:6ab1083:         throws StandardException
1:6ab1083:     {
1:6ab1083:         HashSet<String> result = new HashSet<String>();
1:6ab1083: 
1:6ab1083:         for ( ColumnDescriptor cd : targetTableDescriptor.getColumnDescriptorList() )
1:6ab1083:         {
1:6ab1083:             if ( !cd.hasGenerationClause() ) { continue; }
1:6ab1083: 
1:6ab1083:             if ( changedColumnNames.contains( cd.getColumnName() ) )
1:6ab1083:             {
1:6ab1083:                 result.add( cd.getColumnName() );
1:6ab1083:                 continue;
1:6ab1083:             }
1:6ab1083: 
1:6ab1083:             String[]    referencedColumns = cd.getDefaultInfo().getReferencedColumnNames();
1:6ab1083: 
1:6ab1083:             for ( String referencedColumnName : referencedColumns )
1:6ab1083:             {
1:6ab1083:                 if ( changedColumnNames.contains( referencedColumnName ) )
1:6ab1083:                 {
1:6ab1083:                     result.add( referencedColumnName );
1:6ab1083:                     break;
1:6ab1083:                 }
1:6ab1083:             }
1:6ab1083:         }
1:6ab1083: 
1:6ab1083:         return result;
1:6ab1083:     }
1:6ab1083: 
1:6ab1083: 
1:757bc0e:     ////////////////
1:6ab1083:     //
1:757bc0e:     // BIND DELETE
1:757bc0e:     //
1:757bc0e:     ////////////////
1:6ab1083: 
1:661c2e6:     /** Bind a WHEN MATCHED ... THEN DELETE clause */
1:508a010:     private void    bindDelete
1:508a010:         (
1:508a010:          DataDictionary dd,
1:508a010:          FromList fullFromList,
1:508a010:          FromBaseTable targetTable
1:01632c2:          )
1:01632c2:         throws StandardException
1:01632c2:     {
1:508a010:         //
1:daffaee:         // Don't add any privileges until we bind the DELETE.
1:daffaee:         //
1:daffaee:         IgnoreFilter    ignorePermissions = new IgnoreFilter();
1:daffaee:         getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:daffaee:             
1:2f8e6fb:         FromBaseTable   deleteTarget = new FromBaseTable
1:2f8e6fb:             ( targetTable.getTableNameField(), null, null, null, getContextManager() );
1:2f8e6fb:         FromList    dummyFromList = new FromList( getContextManager() );
1:2f8e6fb:         dummyFromList.addFromTable( deleteTarget );
1:2f8e6fb:         dummyFromList.bindTables( dd, new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() ) );
1:2f8e6fb:  
1:508a010:         CurrentOfNode   currentOfNode = CurrentOfNode.makeForMerge
1:2f8e6fb:             ( CURRENT_OF_NODE_NAME, deleteTarget, getContextManager() );
1:508a010:         FromList        fromList = new FromList( getContextManager() );
1:508a010:         fromList.addFromTable( currentOfNode );
1:508a010:         SelectNode      selectNode = new SelectNode
1:508a010:             (
1:508a010:              null,
1:508a010:              fromList, /* FROM list */
1:508a010:              null, /* WHERE clause */
1:508a010:              null, /* GROUP BY list */
1:508a010:              null, /* having clause */
1:508a010:              null, /* window list */
1:508a010:              null, /* optimizer plan override */
1:661c2e6:              getContextManager()
1:2f8e6fb:              );
1:2f8e6fb:         _dml = new DeleteNode( targetTable.getTableNameField(), selectNode, this, getContextManager() );
1:6ab1083: 
1:daffaee:         // ready to add permissions
1:daffaee:         getCompilerContext().removePrivilegeFilter( ignorePermissions );
1:daffaee: 
1:661c2e6:         _dml.bindStatement();
1:6ab1083: 
1:01632c2:         buildThenColumnsForDelete();
1:6ab1083:     }
1:6ab1083: 
1:6ab1083:     /**
1:856f892:      * <p>
1:01632c2:      * Construct the signature of the temporary table which drives the
1:01632c2:      * INSERT/UPDATE/DELETE action.
1:6ab1083:      * </p>
1:6ab1083:      */
1:01632c2:     private void    buildThenColumnsForDelete()
1:01632c2:         throws StandardException
1:01632c2:     {
1:11f7ee3:         ResultColumnList    dmlSignature = _dml.resultSet.getResultColumns();
1:01632c2:         for ( int i = 0; i < dmlSignature.size(); i++ )
1:01632c2:         {
1:01632c2:             ResultColumn    origRC = dmlSignature.elementAt( i );
1:508a010:             ResultColumn    newRC;
1:508a010:             ValueNode       expression = origRC.getExpression();
1:6ab1083: 
1:508a010:             if ( expression instanceof ColumnReference )
1:01632c2:             {
1:508a010:                 ColumnReference cr = (ColumnReference) ((ColumnReference) expression).getClone();
1:508a010:                 newRC = new ResultColumn( cr, cr, getContextManager() );
1:6ab1083:             }
1:508a010:             else
1:01632c2:             {
1:508a010:                 newRC = origRC.cloneMe();
1:01632c2:             }
1:508a010:             _thenColumns.addResultColumn( newRC );
1:01632c2:         }
1:01632c2:     }
1:6ab1083: 
1:757bc0e:     ////////////////
1:508a010:     //
1:757bc0e:     // BIND INSERT
1:757bc0e:     //
1:757bc0e:     ////////////////
1:6ab1083: 
1:661c2e6:     /** Bind a WHEN NOT MATCHED ... THEN INSERT clause */
1:508a010:     private void    bindInsert
1:508a010:         (
1:508a010:          DataDictionary dd,
1:508a010:          MergeNode  mergeNode,
2:508a010:          FromList fullFromList,
1:508a010:          FromBaseTable targetTable
1:01632c2:          )
1:01632c2:         throws StandardException
1:01632c2:     {
1:5d1ab63:         ResultColumnList    selectList = new ResultColumnList( getContextManager() );
1:5d1ab63:         for ( int i = 0; i < _insertValues.size(); i++ )
1:5d1ab63:         {
1:5d1ab63:             ResultColumn    rc = _insertValues.elementAt( i );
1:5d1ab63:             selectList.addResultColumn( rc.cloneMe() );
1:5d1ab63:         }
1:5d1ab63:         selectList.replaceOrForbidDefaults( targetTable.getTableDescriptor(), _insertColumns, true );
1:18792e2: 
1:ffbe813:         bindExpressions( selectList, fullFromList );
1:01632c2:         
1:5d1ab63:         bindInsertValues( fullFromList, targetTable );
1:5d1ab63: 
1:661c2e6:         // the VALUES clause may not mention columns in the target table
1:1cd5dd1:         FromList    sourceTableFromList = new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() );
1:1cd5dd1:         sourceTableFromList.addElement( fullFromList.elementAt( MergeNode.SOURCE_TABLE_INDEX ) );
1:1cd5dd1:         bindExpressions( _insertValues, sourceTableFromList );
1:01632c2:         
1:661c2e6:         SelectNode  selectNode = new SelectNode
1:508a010:             (
1:5d1ab63:              selectList,      // select list
1:508a010:              fullFromList,
1:661c2e6:              null,      // where clause
1:661c2e6:              null,      // group by list
1:661c2e6:              null,      // having clause
1:661c2e6:              null,      // window list
1:661c2e6:              null,      // optimizer plan override
1:661c2e6:              getContextManager()
1:508a010:              );
1:661c2e6:         _dml = new InsertNode
1:661c2e6:             (
1:2f8e6fb:              targetTable.getTableNameField(),
1:661c2e6:              _insertColumns,
1:661c2e6:              selectNode,
1:508a010:              this,      // in NOT MATCHED clause
1:661c2e6:              null,      // targetProperties
1:661c2e6:              null,      // order by cols
1:661c2e6:              null,      // offset
1:661c2e6:              null,      // fetch first
1:661c2e6:              false,     // has JDBC limit clause
1:661c2e6:              getContextManager()
5:661c2e6:              );
1:01632c2: 
1:661c2e6:         _dml.bindStatement();
1:01632c2: 
1:11f7ee3:         buildThenColumnsForInsert( fullFromList, targetTable, _dml.resultSet.getResultColumns(), _insertColumns, _insertValues );
1:01632c2:     }
1:01632c2: 
1:01632c2:     /**  Bind the values in the INSERT list */
1:01632c2:     private void    bindInsertValues
1:01632c2:         (
1:01632c2:          FromList fullFromList,
1:01632c2:          FromTable targetTable
1:01632c2:          )
1:01632c2:         throws StandardException
1:01632c2:     {
1:6ab1083:         TableDescriptor td = targetTable.getTableDescriptor();
1:01632c2: 
1:69ab4bd:         // construct a full insert column list if insert columns weren't specified
1:69ab4bd:         if ( _insertColumns == null )  { _insertColumns = buildFullColumnList( td ); }
1:69ab4bd: 
1:01632c2:         if ( _insertColumns.size() != _insertValues.size() )
1:01632c2:         {
1:01632c2:             throw StandardException.newException( SQLState.LANG_DB2_INVALID_COLS_SPECIFIED ); 
1:01632c2:         }
1:01632c2:         
1:01632c2:         // forbid illegal values for identity columns
1:01632c2:         for ( int i = 0; i <_insertValues.size(); i++ )
1:01632c2:         {
1:01632c2:             ResultColumn    rc = _insertValues.elementAt( i );
1:b0456a0:             String          columnName = _insertColumns.elementAt( i ).getName();
1:01632c2:             ValueNode       expr = rc.getExpression();
1:6ab1083:             ColumnDescriptor    cd = td.getColumnDescriptor( columnName );
1:01632c2: 
1:01632c2:             // if the column isn't in the table, this will be sorted out when we bind
1:01632c2:             // the InsertNode
1:01632c2:             if ( cd == null ) { continue; }
1:01632c2: 
1:01632c2:             // DEFAULT is the only value allowed for a GENERATED ALWAYS AS IDENTITY column
1:01632c2:             if ( cd.isAutoincAlways() && !(expr instanceof DefaultNode) )
1:01632c2:             {
1:01632c2:                 throw StandardException.newException( SQLState.LANG_AI_CANNOT_MODIFY_AI, columnName );
1:01632c2:             }
1:01632c2: 
1:01632c2:             // NULL is illegal as the value for any identity column
1:01632c2:             if ( cd.isAutoincrement() && (expr instanceof UntypedNullConstantNode) )
1:01632c2:             {
1:01632c2:                 throw StandardException.newException( SQLState.LANG_NULL_INTO_NON_NULL, columnName );
1:01632c2:             }
1:01632c2:         }
1:01632c2:         
1:01632c2:         // needed to make the SelectNode bind
1:01632c2:         _insertValues.replaceOrForbidDefaults( targetTable.getTableDescriptor(), _insertColumns, true );
1:01632c2:         bindExpressions( _insertValues, fullFromList );
1:01632c2:     }
1:69ab4bd: 
1:69ab4bd:     /**
1:69ab4bd:      * <p>
1:69ab4bd:      * Build the full column list for a table.
1:69ab4bd:      * </p>
1:69ab4bd:      */
1:69ab4bd:     private ResultColumnList    buildFullColumnList( TableDescriptor td )
1:69ab4bd:         throws StandardException
1:69ab4bd:     {
1:69ab4bd:         ResultColumnList    result = new ResultColumnList( getContextManager() );
1:69ab4bd: 		ColumnDescriptorList cdl = td.getColumnDescriptorList();
1:69ab4bd: 		int					 cdlSize = cdl.size();
1:69ab4bd: 
1:69ab4bd: 		for ( int index = 0; index < cdlSize; index++ )
1:69ab4bd: 		{
1:69ab4bd:             ColumnDescriptor colDesc = cdl.elementAt( index );
1:69ab4bd:             ColumnReference columnRef = new ColumnReference( colDesc.getColumnName(), null, getContextManager() );
1:69ab4bd:             ResultColumn    resultColumn = new ResultColumn
1:69ab4bd:                 (
1:69ab4bd:                  columnRef,
1:69ab4bd:                  null,
1:69ab4bd:                  getContextManager()
1:69ab4bd:                  );
1:69ab4bd:             
1:69ab4bd:             result.addResultColumn( resultColumn );
1:69ab4bd:         }
1:69ab4bd: 
1:69ab4bd:         return result;
1:69ab4bd:     }
1:01632c2:     
1:6ab1083:     /**
1:3511a12:      * <p>
1:6ab1083:      * Construct the row in the temporary table which drives an INSERT action.
1:6ab1083:      * Unlike a DELETE, whose temporary row is just a list of copied columns, the
1:6ab1083:      * temporary row for INSERT may contain complex expressions which must
1:6ab1083:      * be code-generated later on.
1:6ab1083:      * </p>
1:6ab1083:      */
1:6ab1083:     private void    buildThenColumnsForInsert
1:6ab1083:         (
1:6ab1083:          FromList fullFromList,
1:6ab1083:          FromTable targetTable,
1:6ab1083:          ResultColumnList   fullRow,
1:6ab1083:          ResultColumnList insertColumns,
1:6ab1083:          ResultColumnList insertValues
1:6ab1083:          )
1:01632c2:         throws StandardException
1:01632c2:     {
1:01632c2:         //
1:18792e2:         // Don't add USAGE privilege on user-defined types just because we're
1:18792e2:         // building the THEN columns.
1:18792e2:         //
1:18792e2:         boolean wasSkippingTypePrivileges = getCompilerContext().skipTypePrivileges( true );
2:01632c2:         TableDescriptor td = targetTable.getTableDescriptor();
1:01632c2: 
1:6ab1083:         _thenColumns = fullRow.copyListAndObjects();
1:01632c2: 
1:01632c2:         //
1:01632c2:         // Here we set up for the evaluation of expressions in the temporary table
1:01632c2:         // which drives the INSERT action. If we were actually generating the dummy SELECT
1:01632c2:         // for the DML action, the work would normally be done there. But we don't generate
1:01632c2:         // that SELECT. So we do the following here:
1:01632c2:         //
1:01632c2:         // 1) If a column has a value specified in the WHEN [ NOT ] MATCHED clause, then we use it.
1:01632c2:         //     There is some special handling to make the DEFAULT value work for identity columns.
1:01632c2:         //
1:01632c2:         // 2) Otherwise, if the column has a default, then we plug it in.
1:01632c2:         //
1:01632c2:         for ( int i = 0; i < _thenColumns.size(); i++ )
1:01632c2:         {
1:01632c2:             ResultColumn    origRC = _thenColumns.elementAt( i );
1:01632c2: 
1:01632c2:             String              columnName = origRC.getName();
1:01632c2:             ColumnDescriptor    cd = td.getColumnDescriptor( columnName );
1:01632c2:             boolean         changed = false;
1:01632c2: 
1:01632c2:             //
1:01632c2:             // VirtualColumnNodes are skipped at code-generation time. This can result in
1:01632c2:             // NPEs when evaluating generation expressions. Replace VirtualColumnNodes with
1:01632c2:             // UntypedNullConstantNodes, except for identity columns, which require special
1:01632c2:             // handling below.
1:01632c2:             //
1:01632c2:             if ( !origRC.isAutoincrement() && (origRC.getExpression() instanceof VirtualColumnNode) )
1:01632c2:             {
1:6ab1083:                 origRC.setExpression( new UntypedNullConstantNode( getContextManager() ) );
1:01632c2:             }
1:01632c2: 
1:6ab1083:             if ( cd.hasGenerationClause() )
1:01632c2:             {
1:01632c2:                 origRC.setExpression( new UntypedNullConstantNode( getContextManager() ) );
1:6ab1083:                 continue;
1:01632c2:             }
1:01632c2: 
1:6ab1083:             for ( int ic = 0; ic < insertColumns.size(); ic++ )
1:6ab1083:             {
1:6ab1083:                 ResultColumn    icRC = insertColumns.elementAt( ic );
1:01632c2: 
1:01632c2:                 if ( columnName.equals( icRC.getName() ) )
1:01632c2:                 {
1:01632c2:                     ResultColumn    newRC = null;
1:01632c2:                     
1:01632c2:                     // replace DEFAULT for a generated or identity column
1:6ab1083:                     ResultColumn    valueRC = insertValues.elementAt( ic );
1:01632c2: 
1:6ab1083:                     if ( valueRC.wasDefaultColumn() || (valueRC.getExpression() instanceof UntypedNullConstantNode ) )
1:01632c2:                     {
1:6ab1083:                         if ( !cd.isAutoincrement() )
1:01632c2:                         {
1:01632c2:                             //
1:01632c2:                             // Eliminate column references under identity columns. They
1:01632c2:                             // will mess up the code generation.
1:508a010:                             //
1:01632c2:                             ValueNode   expr = origRC.getExpression();
1:01632c2:                             if ( expr instanceof ColumnReference )
1:01632c2:                             {
1:01632c2:                                 origRC.setExpression( new UntypedNullConstantNode( getContextManager() ) );
1:01632c2:                             }
1:01632c2:                             continue;
1:01632c2:                         }
1:01632c2: 
1:6ab1083:                         newRC = makeAutoGenRC( targetTable, origRC, i+1 );
1:01632c2:                     }
1:01632c2:                     else
1:01632c2:                     {
1:6ab1083:                         newRC = valueRC.cloneMe();
2:01632c2:                         newRC.setType( origRC.getTypeServices() );
1:01632c2:                     }
1:01632c2: 
1:01632c2:                     newRC.setVirtualColumnId( origRC.getVirtualColumnId() );
1:01632c2:                     _thenColumns.setElementAt( newRC, i  );
1:01632c2:                     changed = true;
1:01632c2:                     break;
1:01632c2:                 }
1:01632c2:             }
1:01632c2: 
1:01632c2:             // plug in defaults if we haven't done so already
1:01632c2:             if ( !changed )
1:01632c2:             {
1:01632c2:                 DefaultInfoImpl     defaultInfo = (DefaultInfoImpl) cd.getDefaultInfo();
1:01632c2: 
1:01632c2: 				if ( (defaultInfo != null) && !defaultInfo.isGeneratedColumn() && !cd.isAutoincrement() )
1:01632c2: 				{
1:01632c2:                     _thenColumns.setDefault( origRC, cd, defaultInfo );
1:01632c2:                     changed = true;
1:01632c2: 				}
1:01632c2:             }
1:01632c2: 
1:01632c2:             // set the result column name correctly for buildThenColumnSignature()
1:01632c2:             ResultColumn    finalRC = _thenColumns.elementAt( i );
1:01632c2:             finalRC.setName( cd.getColumnName() );
1:01632c2: 
1:01632c2:         }   // end loop through _thenColumns
1:01632c2: 
1:18792e2:         getCompilerContext().skipTypePrivileges( wasSkippingTypePrivileges );
1:01632c2:     }
1:01632c2: 
1:6ab1083:     /**
1:6ab1083:      * <p>
1:6ab1083:      * Make a ResultColumn for an identity column which is being set to the DEFAULT
1:6ab1083:      * value. This special ResultColumn will make it through code generation so that it
1:6ab1083:      * will be calculated when the INSERT/UPDATE action is run.
1:6ab1083:      * </p>
1:6ab1083:      */
1:6ab1083:     private ResultColumn    makeAutoGenRC
1:6ab1083:         (
1:6ab1083:          FromTable targetTable,
1:6ab1083:          ResultColumn   origRC,
1:6ab1083:          int    virtualColumnID
1:6ab1083:          )
1:6ab1083:         throws StandardException
1:6ab1083:     {
1:6ab1083:         String              columnName = origRC.getName();
1:6ab1083:         ColumnReference autoGenCR = new ColumnReference( columnName, targetTable.getTableName(), getContextManager() );
1:6ab1083:         ResultColumn    autoGenRC = new ResultColumn( autoGenCR, null, getContextManager() );
1:6ab1083:         VirtualColumnNode autoGenVCN = new VirtualColumnNode( targetTable, autoGenRC, virtualColumnID, getContextManager() );
1:6ab1083:         ResultColumn    newRC = new ResultColumn( autoGenCR, autoGenVCN, getContextManager() );
1:6ab1083: 
1:6ab1083:         // set the type so that buildThenColumnSignature() will function correctly
1:6ab1083:         newRC.setType( origRC.getTypeServices() );
1:6ab1083: 
1:6ab1083:         return newRC;
1:6ab1083:     }
1:6ab1083: 
1:6ab1083: 
1:757bc0e:     /////////////////
1:757bc0e:     //
1:757bc0e:     // BIND MINIONS
1:757bc0e:     //
1:757bc0e:     /////////////////
1:757bc0e: 
1:757bc0e:     /** Boilerplate for binding a list of ResultColumns against a FromList */
1:757bc0e:     private void bindExpressions( ResultColumnList rcl, FromList fromList )
1:757bc0e:         throws StandardException
1:757bc0e:     {
1:757bc0e:         CompilerContext cc = getCompilerContext();
1:757bc0e:         final int previousReliability = cc.getReliability();
1:757bc0e: 
1:757bc0e:         boolean wasSkippingTypePrivileges = cc.skipTypePrivileges( true );
1:757bc0e:         cc.setReliability( previousReliability | CompilerContext.SQL_IN_ROUTINES_ILLEGAL );
1:757bc0e:         
1:757bc0e:         try {
1:757bc0e:             rcl.bindExpressions
1:757bc0e:                 (
1:757bc0e:                  fromList,
1:757bc0e:                  new SubqueryList( getContextManager() ),
1:757bc0e:                  new ArrayList<AggregateNode>()
1:757bc0e:                  );
1:757bc0e:         }
1:757bc0e:         finally
1:757bc0e:         {
1:757bc0e:             // Restore previous compiler state
1:757bc0e:             cc.setReliability( previousReliability );
1:757bc0e:             cc.skipTypePrivileges( wasSkippingTypePrivileges );
1:757bc0e:         }
1:757bc0e:     }
1:757bc0e: 
1:6ab1083:     /**
1:6ab1083:      * <p>
1:1484b83:      * Forbid subqueries in WHEN [ NOT ] MATCHED clauses.
1:1484b83:      * </p>
1:1484b83:      */
1:1484b83:     private void    forbidSubqueries()
1:1484b83:         throws StandardException
1:1484b83:     {
1:1484b83:         forbidSubqueries( _matchingRefinement );
1:1484b83:         forbidSubqueries( _updateColumns );
1:1484b83:         forbidSubqueries( _insertColumns );
1:1484b83:         forbidSubqueries( _insertValues );
1:1484b83:     }
1:1484b83:     private void    forbidSubqueries( ResultColumnList rcl )
1:1484b83:         throws StandardException
1:1484b83:     {
1:1484b83:         if ( rcl != null )
1:1484b83:         {
1:1484b83:             for ( int i = 0; i < rcl.size(); i++ )
1:1484b83:             {
1:1484b83:                 forbidSubqueries( rcl.elementAt( i ) );
1:1484b83:             }
1:1484b83:         }
1:1484b83:     }
1:1484b83:     private void    forbidSubqueries( ValueNode expr )
1:1484b83:         throws StandardException
1:1484b83:     {
1:1484b83:         if ( expr != null )
1:1484b83:         {
1:1484b83:             CollectNodesVisitor<SubqueryNode> getSubqueries =
1:1484b83:                 new CollectNodesVisitor<SubqueryNode>(SubqueryNode.class);
1:1484b83:             expr.accept( getSubqueries );
1:1484b83:             if ( getSubqueries.getList().size() > 0 )
1:1484b83:             {
1:1484b83:                 throw StandardException.newException( SQLState.LANG_NO_SUBQUERIES_IN_MATCHED_CLAUSE );
1:1484b83:             }
1:1484b83:         }
1:1484b83:     }
1:1484b83: 
1:508a010:     ///////////////////////////////////////////////////////////////////////////////////
1:508a010:     //
1:508a010:     // optimize() BEHAVIOR
1:508a010:     //
1:508a010:     ///////////////////////////////////////////////////////////////////////////////////
1:01632c2: 
1:01632c2:     /**
1:6ab1083:      * <p>
1:508a010:      * Optimize the INSERT/UPDATE/DELETE action.
1:6ab1083:      * </p>
1:01632c2:      */
1:508a010:     void    optimize()  throws StandardException
1:01632c2:     {
1:508a010:         _dml.optimizeStatement();
1:01632c2:     }
1:01632c2: 
1:508a010:     ///////////////////////////////////////////////////////////////////////////////////
1:508a010:     //
1:508a010:     // generate() BEHAVIOR
1:508a010:     //
1:508a010:     ///////////////////////////////////////////////////////////////////////////////////
1:01632c2: 
1:508a010:     ConstantAction makeConstantAction( ActivationClassBuilder acb )
1:01632c2:         throws StandardException
1:508a010: 	{
1:508a010:         // generate the clause-specific refinement
1:508a010:         String  refinementName = null;
1:508a010:         if ( _matchingRefinement != null )
1:508a010:         {
1:508a010:             MethodBuilder userExprFun = acb.newUserExprFun();
1:508a010: 
1:508a010:             _matchingRefinement.generateExpression( acb, userExprFun );
1:508a010:             userExprFun.methodReturn();
1:508a010: 		
1:508a010:             // we are done modifying userExprFun, complete it.
1:508a010:             userExprFun.complete();
1:508a010: 
1:508a010:             refinementName = userExprFun.getName();
1:508a010:         }
1:508a010:         
1:508a010:         return	getGenericConstantActionFactory().getMatchingClauseConstantAction
1:508a010:             (
1:508a010:              getClauseType(),
1:508a010:              refinementName,
1:01632c2:              buildThenColumnSignature(),
1:01632c2:              _rowMakingMethodName,
1:508a010:              _resultSetFieldName,
1:508a010:              _actionMethodName,
1:508a010:              _dml.makeConstantAction()
1:508a010:              );
1:508a010: 	}
1:508a010:     private int getClauseType()
1:508a010:     {
1:508a010:         if ( isUpdateClause() ) { return ConstantAction.WHEN_MATCHED_THEN_UPDATE; }
1:508a010:         else if ( isInsertClause() ) { return ConstantAction.WHEN_NOT_MATCHED_THEN_INSERT; }
1:508a010:         else { return ConstantAction.WHEN_MATCHED_THEN_DELETE; }
1:508a010:     }
1:508a010: 
1:01632c2:     /**
1:6ab1083:      * <p>
1:01632c2:      * Build the signature of the row which will go into the temporary table.
1:01632c2:      * </p>
1:01632c2:      */
1:01632c2:     private ResultDescription    buildThenColumnSignature()
1:01632c2:         throws StandardException
1:01632c2:     {
1:01632c2:         ResultColumnDescriptor[]  cells = _thenColumns.makeResultDescriptors();
1:01632c2: 
1:01632c2:         return getLanguageConnectionContext().getLanguageFactory().getResultDescription( cells, "MERGE" );
1:01632c2:     }
1:01632c2: 
1:01632c2:     /**
1:6ab1083:      * <p>
1:508a010:      * Generate a method to invoke the INSERT/UPDATE/DELETE action. This method
1:508a010:      * will be called at runtime by MatchingClauseConstantAction.executeConstantAction().
1:01632c2:      * </p>
1:01632c2:      */
1:01632c2:     void    generate
1:01632c2:         (
1:01632c2:          ActivationClassBuilder acb,
1:01632c2:          ResultColumnList selectList,
1:6ab1083:          ResultSetNode  generatedScan,
1:01632c2:          HalfOuterJoinNode  hojn,
1:01632c2:          int    clauseNumber
1:01632c2:          )
4:508a010:         throws StandardException
1:01632c2:     {
1:508a010:         _clauseNumber = clauseNumber;
1:01632c2: 
1:bbd6aff:         adjustMatchingRefinement( selectList, generatedScan );
1:bbd6aff:         
1:0ae3b6d:         generateInsertUpdateRow( acb, selectList, generatedScan, hojn );
1:01632c2:         
1:508a010:         _actionMethodName = "mergeActionMethod_" + _clauseNumber;
1:508a010:         
1:508a010:         MethodBuilder mb = acb.getClassBuilder().newMethodBuilder
1:508a010:             (
1:508a010:              Modifier.PUBLIC,
1:508a010:              ClassName.ResultSet,
1:508a010:              _actionMethodName
1:508a010:              );
1:508a010:         mb.addThrownException(ClassName.StandardException);
1:508a010: 
1:01632c2:         remapConstraints();
1:01632c2: 
1:508a010:         // now generate the action into this method
1:508a010:         _dml.generate( acb, mb );
1:508a010:         
1:508a010:         mb.methodReturn();
1:508a010:         mb.complete();
1:01632c2:     }
1:508a010: 
1:01632c2:     /**
1:01632c2:      * <p>
1:01632c2:      * Re-map ColumnReferences in constraints to point into the row from the
1:01632c2:      * temporary table. This is where the row will be stored when constraints
1:01632c2:      * are being evaluated.
1:01632c2:      * </p>
1:01632c2:      */
1:01632c2:     private void    remapConstraints()
1:01632c2:         throws StandardException
1:01632c2:     {
1:6ab1083:         if( isDeleteClause()) { return; }
1:01632c2:         else
1:01632c2:         {
1:6ab1083:             ValueNode   checkConstraints = isInsertClause() ?
1:6ab1083:                 ((InsertNode) _dml).checkConstraints :
1:6ab1083:                 ((UpdateNode) _dml).checkConstraints;
1:01632c2: 
1:01632c2:             if ( checkConstraints != null )
1:01632c2:             {
1:daffaee:                 List<ColumnReference> colRefs = getColumnReferences( checkConstraints );
1:01632c2:                 for ( ColumnReference cr : colRefs )
1:01632c2:                 {
1:01632c2:                     cr.getSource().setResultSetNumber( NoPutResultSet.TEMPORARY_RESULT_SET_NUMBER );
1:01632c2:                 }
1:01632c2:             }            
1:01632c2:         }
1:01632c2:     }
1:01632c2: 
1:01632c2:     /**
1:01632c2:      * <p>
1:757bc0e:      * Adds a field to the generated class to hold the ResultSet of "then" rows
1:508a010:      * which drive the INSERT/UPDATE/DELETE action. Generates code to push
1:508a010:      * the contents of that field onto the stack.
1:01632c2:      * </p>
1:508a010:      */
1:508a010:     void    generateResultSetField( ActivationClassBuilder acb, MethodBuilder mb )
1:508a010:         throws StandardException
1:508a010:     {
1:508a010:         _resultSetFieldName = "mergeResultSetField_" + _clauseNumber;
1:508a010:         
1:508a010:         // make the field public so we can stuff it at execution time
1:508a010:         LocalField  resultSetField = acb.newFieldDeclaration( Modifier.PUBLIC, ClassName.NoPutResultSet, _resultSetFieldName );
1:508a010: 
1:508a010:         //
1:508a010:         // At runtime, MatchingClauseConstantAction.executeConstantAction()
1:508a010:         // will stuff the resultSetField with the temporary table which collects
1:508a010:         // the rows relevant to this action. We want to push the value of resultSetField
1:508a010:         // onto the stack, where it will be the ResultSet argument to the constructor
1:508a010:         // of the actual INSERT/UPDATE/DELETE action.
1:508a010:         //
1:508a010:         mb.getField( resultSetField );
1:01632c2:     }
1:508a010:     
1:01632c2:     /**
1:01632c2:      * <p>
1:6ab1083:      * Generate a method to build a row for the temporary table for INSERT/UPDATE actions.
1:01632c2:      * The method stuffs each column in the row with the result of the corresponding
1:01632c2:      * expression built out of columns in the current row of the driving left join.
1:01632c2:      * The method returns the stuffed row.
1:01632c2:      * </p>
1:01632c2:      */
1:bbd6aff:     private void    generateInsertUpdateRow
1:01632c2:         (
1:01632c2:          ActivationClassBuilder acb,
1:01632c2:          ResultColumnList selectList,
1:6ab1083:          ResultSetNode  generatedScan,
1:01632c2:          HalfOuterJoinNode  hojn
1:01632c2:          )
1:01632c2:         throws StandardException
1:01632c2:     {
1:01632c2:         // point expressions in the temporary row at the columns in the
1:01632c2:         // result column list of the driving left join.
1:6ab1083:         adjustThenColumns( selectList, generatedScan, hojn );
1:01632c2:         
1:01632c2:         _rowMakingMethodName = "mergeRowMakingMethod_" + _clauseNumber;
1:01632c2:         
1:01632c2:         MethodBuilder mb = acb.getClassBuilder().newMethodBuilder
1:01632c2:             (
1:01632c2:              Modifier.PUBLIC,
1:01632c2:              ClassName.ExecRow,
1:01632c2:              _rowMakingMethodName
1:01632c2:              );
1:01632c2:         mb.addThrownException(ClassName.StandardException);
1:01632c2: 
1:01632c2:         _thenColumns.generateEvaluatedRow( acb, mb, false, true );
1:01632c2:     }
1:01632c2: 
1:01632c2:     /**
1:01632c2:      * <p>
1:bbd6aff:      * Point the column references in the matching refinement at the corresponding
1:bbd6aff:      * columns returned by the driving left join.
1:bbd6aff:      * </p>
1:bbd6aff:      */
1:bbd6aff:     private void    adjustMatchingRefinement
1:bbd6aff:         (
1:bbd6aff:          ResultColumnList selectList,
1:bbd6aff:          ResultSetNode  generatedScan
1:bbd6aff:          )
1:bbd6aff:         throws StandardException
1:bbd6aff:     {
1:bbd6aff:         if ( _matchingRefinement != null )
1:bbd6aff:         {
1:bbd6aff:             useGeneratedScan( selectList, generatedScan, _matchingRefinement );
1:bbd6aff:         }
1:bbd6aff:     }
1:bbd6aff:     
1:bbd6aff:     /**
1:bbd6aff:      * <p>
1:6ab1083:      * Point the column references in the temporary row at the corresponding
1:01632c2:      * columns returned by the driving left join.
2:01632c2:      * </p>
1:01632c2:      */
1:bbd6aff:     private void    adjustThenColumns
1:01632c2:         (
1:01632c2:          ResultColumnList selectList,
1:6ab1083:          ResultSetNode  generatedScan,
1:01632c2:          HalfOuterJoinNode  hojn
1:01632c2:          )
1:01632c2:         throws StandardException
1:01632c2:     {
1:11f7ee3:         ResultColumnList    leftJoinResult = generatedScan.getResultColumns();
1:01632c2: 
1:bbd6aff:         useGeneratedScan( selectList, generatedScan, _thenColumns );
1:01632c2: 
1:508a010:         //
1:6ab1083:         // For an UPDATE action, the final column in the temporary row is the
1:6ab1083:         // RowLocation. Point it at the last column in the row returned by the left join.
1:6ab1083:         //
1:6ab1083:         int                 lastRCSlot = _thenColumns.size() - 1;
1:6ab1083:         ResultColumn    lastRC = _thenColumns.elementAt( lastRCSlot );
1:6ab1083: 
1:6ab1083:         if ( isRowLocation( lastRC ) )
1:6ab1083:         {
1:6ab1083:             ResultColumn    lastLeftJoinRC = leftJoinResult.elementAt( leftJoinResult.size() - 1 );
1:6ab1083:             ValueNode       value = lastLeftJoinRC.getExpression();
1:b0456a0:             String              columnName = lastLeftJoinRC.getName();
1:6ab1083:             ColumnReference rowLocationCR = new ColumnReference
1:6ab1083:                 ( columnName, hojn.getTableName(), getContextManager() );
1:6ab1083: 
1:6ab1083:             rowLocationCR.setSource( lastLeftJoinRC );
1:6ab1083:             
1:6ab1083:             ResultColumn    rowLocationRC = new ResultColumn( columnName, rowLocationCR, getContextManager() );
1:6ab1083: 
1:6ab1083:             _thenColumns.removeElementAt( lastRCSlot );
1:6ab1083:             _thenColumns.addResultColumn( rowLocationRC );
1:6ab1083:         }
1:6ab1083:     }
1:6ab1083: 
1:508a010:     /**
1:01632c2:      * <p>
1:bbd6aff:      * Point a node's ColumnReferences into the row returned by the driving left join.
1:bbd6aff:      * </p>
1:bbd6aff:      */
1:bbd6aff:     private void    useGeneratedScan
1:bbd6aff:         (
1:bbd6aff:          ResultColumnList selectList,
1:bbd6aff:          ResultSetNode  generatedScan,
1:bbd6aff:          QueryTreeNode  node
1:bbd6aff:          )
1:bbd6aff:         throws StandardException
1:bbd6aff:     {
1:bbd6aff:         ResultColumnList    leftJoinResult = generatedScan.getResultColumns();
1:bbd6aff: 
1:daffaee:         for ( ColumnReference cr : getColumnReferences( node ) )
1:bbd6aff:         {
1:bbd6aff:             ResultColumn    leftJoinRC = leftJoinResult.elementAt( getSelectListOffset( selectList, cr ) - 1 );
1:bbd6aff:             cr.setSource( leftJoinRC );
1:bbd6aff:         }
1:bbd6aff:     }
1:bbd6aff:     
4:508a010:     /**
2:01632c2:      * <p>
1:0ae3b6d:      * Find a column reference in the SELECT list of the driving left join
1:0ae3b6d:      * and return its 1-based offset into that list.  Returns -1 if the column
1:0ae3b6d:      * can't be found.
1:0ae3b6d:      * </p>
1:0ae3b6d:      */
1:0ae3b6d:     private int getSelectListOffset( ResultColumnList selectList, ValueNode thenExpression )
1:0ae3b6d:         throws StandardException
1:0ae3b6d:     {
1:0ae3b6d:         int                 selectCount = selectList.size();
1:0ae3b6d: 
1:0ae3b6d:         if ( thenExpression instanceof ColumnReference )
1:0ae3b6d:         {
1:0ae3b6d:             ColumnReference thenCR = (ColumnReference) thenExpression;
1:0ae3b6d:             String              thenCRName = thenCR.getColumnName();
1:0ae3b6d:             int                 thenCRMergeTableID = getMergeTableID( thenCR );
1:0ae3b6d: 
1:0ae3b6d:             // loop through the SELECT list to find this column reference
1:0ae3b6d:             for ( int sidx = 0; sidx < selectCount; sidx++ )
1:0ae3b6d:             {
1:0ae3b6d:                 ResultColumn    selectRC = selectList.elementAt( sidx );
1:0ae3b6d:                 ValueNode       selectExpression = selectRC.getExpression();
1:0ae3b6d:                 ColumnReference selectCR = selectExpression instanceof ColumnReference ?
1:0ae3b6d:                     (ColumnReference) selectExpression : null;
1:0ae3b6d: 
1:0ae3b6d:                 if ( selectCR != null )
1:0ae3b6d:                 {
1:0ae3b6d:                     if (
1:0ae3b6d:                         ( getMergeTableID( selectCR ) == thenCRMergeTableID) &&
1:0ae3b6d:                         thenCRName.equals( selectCR.getColumnName() )
1:0ae3b6d:                         )
1:0ae3b6d:                     {
1:0ae3b6d:                         return sidx + 1;
1:0ae3b6d:                     }
1:0ae3b6d:                 }
1:0ae3b6d:             }
1:0ae3b6d:             
1:0ae3b6d:             if (SanityManager.DEBUG)
1:0ae3b6d:             {
1:0ae3b6d:                 SanityManager.THROWASSERT
1:0ae3b6d:                     (
1:0ae3b6d:                      "Can't find select list column corresponding to " + thenCR.getSQLColumnName() +
1:0ae3b6d:                      " with merge table id = " + thenCRMergeTableID
1:0ae3b6d:                      );
1:0ae3b6d:             }
1:0ae3b6d:         }
1:0ae3b6d:         else if ( thenExpression instanceof CurrentRowLocationNode )
1:0ae3b6d:         {
1:0ae3b6d:             //
1:0ae3b6d:             // There is only one RowLocation in the SELECT list, the row location for the
1:0ae3b6d:             // tuple from the target table. The RowLocation is always the last column in
1:0ae3b6d:             // the SELECT list.
1:0ae3b6d:             //
1:0ae3b6d:             return selectCount;
1:0ae3b6d:         }
1:0ae3b6d: 
1:0ae3b6d:         return -1;
1:0ae3b6d:     }
1:0ae3b6d: 
1:0ae3b6d:     /** Find the MERGE table id of the indicated column */
1:0ae3b6d:     private int getMergeTableID( ColumnReference cr )
1:0ae3b6d:     {
1:0ae3b6d:         int                 mergeTableID = cr.getMergeTableID();
1:0ae3b6d: 
1:0ae3b6d:         if (SanityManager.DEBUG)
1:0ae3b6d:         {
1:0ae3b6d:             SanityManager.ASSERT
1:0ae3b6d:                 (
1:0ae3b6d:                  ( (mergeTableID == ColumnReference.MERGE_SOURCE) || (mergeTableID == ColumnReference.MERGE_TARGET) ),
1:0ae3b6d:                  "Column " + cr.getSQLColumnName() + " has illegal MERGE table id: " + mergeTableID
1:0ae3b6d:                  );
1:0ae3b6d:         }
1:0ae3b6d: 
1:0ae3b6d:         return mergeTableID;
1:0ae3b6d:     }
1:0ae3b6d: 
1:508a010:     ///////////////////////////////////////////////////////////////////////////////////
1:01632c2:     //
1:508a010:     // Visitable BEHAVIOR
1:01632c2:     //
1:508a010:     ///////////////////////////////////////////////////////////////////////////////////
1:2f8e6fb: 
1:508a010: 	/**
1:508a010: 	 * Accept the visitor for all visitable children of this node.
1:508a010: 	 * 
1:508a010: 	 * @param v the visitor
1:508a010: 	 *
1:508a010: 	 * @exception StandardException on error
1:508a010: 	 */
1:508a010:     @Override
1:508a010: 	void acceptChildren(Visitor v)
1:508a010: 		throws StandardException
1:2f8e6fb: 	{
1:508a010: 		super.acceptChildren( v );
1:2f8e6fb: 
1:508a010:         if ( _matchingRefinement != null ) { _matchingRefinement.accept( v ); }
1:508a010:         if ( _updateColumns != null ) { _updateColumns.accept( v ); }
1:508a010:         if ( _insertColumns != null ) { _insertColumns.accept( v ); }
1:508a010:         if ( _insertValues != null ) { _insertValues.accept( v ); }
1:2f8e6fb: 
1:508a010:         if ( _dml != null ) { _dml.accept( v ); }
1:2f8e6fb: 	}
1:6ab1083: 
1:508a010: 	/**
1:ddfefeb: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:ddfefeb: 	 * how tree printing is supposed to work.
1:ddfefeb: 	 *
1:ddfefeb: 	 * @param depth		The depth of this node in the tree
1:ddfefeb: 	 */
1:ddfefeb:     @Override
1:ddfefeb:     void printSubNodes( int depth )
1:ddfefeb: 	{
1:ddfefeb: 		if (SanityManager.DEBUG)
1:ddfefeb: 		{
1:ddfefeb: 			super.printSubNodes( depth );
1:ddfefeb: 
1:ddfefeb:             if ( _matchingRefinement != null )
1:ddfefeb:             {
1:ddfefeb:                 printLabel( depth, "matchingRefinement: " );
1:ddfefeb:                 _matchingRefinement.treePrint( depth + 1 );
1:ddfefeb:             }
1:ddfefeb: 
1:ddfefeb:             if ( _updateColumns != null )
1:ddfefeb:             {
1:ddfefeb:                 printLabel( depth, "updateColumns: " );
1:ddfefeb:                 _updateColumns.treePrint( depth + 1 );
1:ddfefeb:             }
1:ddfefeb: 
1:ddfefeb:             if ( _insertColumns != null )
1:ddfefeb:             {
1:ddfefeb:                 printLabel( depth, "insertColumns: " );
1:ddfefeb:                 _insertColumns.treePrint( depth + 1 );
1:ddfefeb:             }
1:ddfefeb: 
1:ddfefeb:             if ( _insertValues != null )
1:ddfefeb:             {
1:ddfefeb:                 printLabel( depth, "insertValues: " );
1:ddfefeb:                 _insertValues.treePrint( depth + 1 );
1:ddfefeb:             }
1:ddfefeb: 		}
1:ddfefeb: 	}
1:ddfefeb: 
1:ddfefeb: 	/**
1:508a010: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:508a010: 	 * for how this should be done for tree printing.
1:508a010: 	 *
1:508a010: 	 * @return	This object as a String
1:508a010: 	 */
1:508a010:     @Override
1:508a010: 	public String toString()
1:6ab1083: 	{
1:508a010:         if ( isUpdateClause() ) { return "UPDATE"; }
1:508a010:         else if ( isInsertClause() ) { return "INSERT"; }
1:508a010:         else { return "DELETE"; }
1:2f8e6fb: 	}
1:daffaee: 
1:daffaee:     ///////////////////////////////////////////////////////////////////////////////////
1:daffaee:     //
1:daffaee:     // MINIONS
1:daffaee:     //
1:daffaee:     ///////////////////////////////////////////////////////////////////////////////////
1:daffaee: 
1:daffaee:     /** Get a list of column references in an expression */
1:daffaee:     private List<ColumnReference>   getColumnReferences( QueryTreeNode expression )
1:daffaee:         throws StandardException
1:daffaee:     {
1:daffaee:         CollectNodesVisitor<ColumnReference> getCRs =
1:daffaee:             new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
1:daffaee: 
1:daffaee:         expression.accept(getCRs);
1:daffaee:         
1:daffaee:         return getCRs.getList();
1:daffaee:     }
1:757bc0e: 
1:757bc0e:     /** Return true if the ResultColumn represents a RowLocation */
1:757bc0e:     private boolean isRowLocation( ResultColumn rc ) throws StandardException
1:757bc0e:     {
1:757bc0e:         if ( rc.getExpression() instanceof CurrentRowLocationNode ) { return true; }
1:757bc0e: 
1:757bc0e:         DataTypeDescriptor  dtd = rc.getTypeServices();
1:757bc0e:         if ( (dtd != null) && (dtd.getTypeId().isRefTypeId()) ) { return true; }
1:757bc0e: 
1:757bc0e:         return false;
1:757bc0e:     }
1:d043e29: 
1:d043e29:     @Override
1:d043e29:     public boolean referencesSessionSchema() throws StandardException {
1:d043e29:         return referencesSessionSchema(_matchingRefinement)
1:d043e29:                 || referencesSessionSchema(_updateColumns)
1:d043e29:                 || referencesSessionSchema(_insertColumns)
1:d043e29:                 || referencesSessionSchema(_insertValues);
1:d043e29:     }
1:d043e29: 
1:d043e29:     private static boolean referencesSessionSchema(QueryTreeNode node)
1:d043e29:             throws StandardException {
1:d043e29:         return node != null && node.referencesSessionSchema();
1:d043e29:     }
1:2f8e6fb: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:d043e29
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public boolean referencesSessionSchema() throws StandardException {
1:         return referencesSessionSchema(_matchingRefinement)
1:                 || referencesSessionSchema(_updateColumns)
1:                 || referencesSessionSchema(_insertColumns)
1:                 || referencesSessionSchema(_insertValues);
1:     }
1: 
1:     private static boolean referencesSessionSchema(QueryTreeNode node)
1:             throws StandardException {
1:         return node != null && node.referencesSessionSchema();
1:     }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4cf6633
/////////////////////////////////////////////////////////////////////////
1:     //
1:     // Filled in by the constructor.
1:     //
1:     // Filled in at bind() time.
1:     // the INSERT/UPDATE/DELETE statement of this WHEN [ NOT ] MATCHED clause
1:     // the columns in the temporary conglomerate which drives the INSERT/UPDATE/DELETE
1:     //
1:     // Filled in at generate() time.
1:     //
/////////////////////////////////////////////////////////////////////////
1:      * Due to discrepancies in how names are resolved by SELECT and UPDATE,
/////////////////////////////////////////////////////////////////////////
1:      * This may not be the source result set of the UPDATE node. That is because a ProjectRestrictNode
1:      * exists to make the UPDATE actions of MERGE statements behave like ordinary
commit:0ae3b6d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         generateInsertUpdateRow( acb, selectList, generatedScan, hojn );
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Find a column reference in the SELECT list of the driving left join
1:      * and return its 1-based offset into that list.  Returns -1 if the column
1:      * can't be found.
1:      * </p>
1:      */
1:     private int getSelectListOffset( ResultColumnList selectList, ValueNode thenExpression )
1:         throws StandardException
1:     {
1:         int                 selectCount = selectList.size();
1: 
1:         if ( thenExpression instanceof ColumnReference )
1:         {
1:             ColumnReference thenCR = (ColumnReference) thenExpression;
1:             String              thenCRName = thenCR.getColumnName();
1:             int                 thenCRMergeTableID = getMergeTableID( thenCR );
1: 
1:             // loop through the SELECT list to find this column reference
1:             for ( int sidx = 0; sidx < selectCount; sidx++ )
1:             {
1:                 ResultColumn    selectRC = selectList.elementAt( sidx );
1:                 ValueNode       selectExpression = selectRC.getExpression();
1:                 ColumnReference selectCR = selectExpression instanceof ColumnReference ?
1:                     (ColumnReference) selectExpression : null;
1: 
1:                 if ( selectCR != null )
1:                 {
1:                     if (
1:                         ( getMergeTableID( selectCR ) == thenCRMergeTableID) &&
1:                         thenCRName.equals( selectCR.getColumnName() )
1:                         )
1:                     {
1:                         return sidx + 1;
1:                     }
1:                 }
1:             }
1:             
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.THROWASSERT
1:                     (
1:                      "Can't find select list column corresponding to " + thenCR.getSQLColumnName() +
1:                      " with merge table id = " + thenCRMergeTableID
1:                      );
1:             }
1:         }
1:         else if ( thenExpression instanceof CurrentRowLocationNode )
1:         {
1:             //
1:             // There is only one RowLocation in the SELECT list, the row location for the
1:             // tuple from the target table. The RowLocation is always the last column in
1:             // the SELECT list.
1:             //
1:             return selectCount;
1:         }
1: 
1:         return -1;
1:     }
1: 
1:     /** Find the MERGE table id of the indicated column */
1:     private int getMergeTableID( ColumnReference cr )
1:     {
1:         int                 mergeTableID = cr.getMergeTableID();
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT
1:                 (
1:                  ( (mergeTableID == ColumnReference.MERGE_SOURCE) || (mergeTableID == ColumnReference.MERGE_TARGET) ),
1:                  "Column " + cr.getSQLColumnName() + " has illegal MERGE table id: " + mergeTableID
1:                  );
1:         }
1: 
1:         return mergeTableID;
1:     }
1: 
commit:757bc0e
/////////////////////////////////////////////////////////////////////////
1:     ResultColumnList    getThenColumns() { return _thenColumns; }
1:     // bind() BEHAVIOR CALLED BY MergeNode
1:     /** Bind this WHEN [ NOT ] MATCHED clause against the parent MergeNode */
/////////////////////////////////////////////////////////////////////////
1:     ////////////////
1:     //
1:     // BIND UPDATE
1:     //
1:     ////////////////
/////////////////////////////////////////////////////////////////////////
1:     ////////////////
1:     //
1:     // BIND DELETE
1:     //
1:     ////////////////
/////////////////////////////////////////////////////////////////////////
0:      * Calculate the 1-based offsets which define the "then" rows which will be buffered up
/////////////////////////////////////////////////////////////////////////
0:         int     thenCount = _thenColumns.size();
0:         _deleteColumnOffsets = new int[ thenCount ];
0:         for ( int bidx = 0; bidx < thenCount; bidx++ )
0:             ResultColumn    thenRC = _thenColumns.elementAt( bidx );
0:             ValueNode       thenExpression = thenRC.getExpression();
0:             _deleteColumnOffsets[ bidx ] = getSelectListOffset( selectList, thenExpression );
1:     ////////////////
1:     //
1:     // BIND INSERT
1:     //
1:     ////////////////
/////////////////////////////////////////////////////////////////////////
0:     ////////////////////////
1:     //
0:     // BIND THE THEN ROW
1:     //
0:     ////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     private int getSelectListOffset( ResultColumnList selectList, ValueNode thenExpression )
0:         if ( thenExpression instanceof ColumnReference )
0:             ColumnReference thenCR = (ColumnReference) thenExpression;
0:             String              thenCRName = thenCR.getColumnName();
0:             int                 thenCRMergeTableID = getMergeTableID( thenCR );
/////////////////////////////////////////////////////////////////////////
0:                         ( getMergeTableID( selectCR ) == thenCRMergeTableID) &&
0:                         thenCRName.equals( selectCR.getColumnName() )
/////////////////////////////////////////////////////////////////////////
0:                      "Can't find select list column corresponding to " + thenCR.getSQLColumnName() +
0:                      " with merge table id = " + thenCRMergeTableID
0:         else if ( thenExpression instanceof CurrentRowLocationNode )
/////////////////////////////////////////////////////////////////////////
1:     /////////////////
1:     //
1:     // BIND MINIONS
1:     //
1:     /////////////////
1: 
1:     /** Boilerplate for binding a list of ResultColumns against a FromList */
1:     private void bindExpressions( ResultColumnList rcl, FromList fromList )
1:         throws StandardException
1:     {
1:         CompilerContext cc = getCompilerContext();
1:         final int previousReliability = cc.getReliability();
1: 
1:         boolean wasSkippingTypePrivileges = cc.skipTypePrivileges( true );
1:         cc.setReliability( previousReliability | CompilerContext.SQL_IN_ROUTINES_ILLEGAL );
1:         
1:         try {
1:             rcl.bindExpressions
1:                 (
1:                  fromList,
1:                  new SubqueryList( getContextManager() ),
1:                  new ArrayList<AggregateNode>()
1:                  );
1:         }
1:         finally
1:         {
1:             // Restore previous compiler state
1:             cc.setReliability( previousReliability );
1:             cc.skipTypePrivileges( wasSkippingTypePrivileges );
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Adds a field to the generated class to hold the ResultSet of "then" rows
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /** Return true if the ResultColumn represents a RowLocation */
1:     private boolean isRowLocation( ResultColumn rc ) throws StandardException
1:     {
1:         if ( rc.getExpression() instanceof CurrentRowLocationNode ) { return true; }
1: 
1:         DataTypeDescriptor  dtd = rc.getTypeServices();
1:         if ( (dtd != null) && (dtd.getTypeId().isRefTypeId()) ) { return true; }
1: 
1:         return false;
1:     }
1:     
commit:ddfefeb
/////////////////////////////////////////////////////////////////////////
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 */
1:     @Override
1:     void printSubNodes( int depth )
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes( depth );
1: 
1:             if ( _matchingRefinement != null )
1:             {
1:                 printLabel( depth, "matchingRefinement: " );
1:                 _matchingRefinement.treePrint( depth + 1 );
1:             }
1: 
1:             if ( _updateColumns != null )
1:             {
1:                 printLabel( depth, "updateColumns: " );
1:                 _updateColumns.treePrint( depth + 1 );
1:             }
1: 
1:             if ( _insertColumns != null )
1:             {
1:                 printLabel( depth, "insertColumns: " );
1:                 _insertColumns.treePrint( depth + 1 );
1:             }
1: 
1:             if ( _insertValues != null )
1:             {
1:                 printLabel( depth, "insertValues: " );
1:                 _insertValues.treePrint( depth + 1 );
1:             }
1: 		}
1: 	}
1: 
1: 	/**
commit:ffbe813
/////////////////////////////////////////////////////////////////////////
1:         // Don't add USAGE privilege on user-defined types.
1:         //
1:         boolean wasSkippingTypePrivileges = getCompilerContext().skipTypePrivileges( true );
1:             
1:         //
/////////////////////////////////////////////////////////////////////////
1: 
1:         getCompilerContext().skipTypePrivileges( wasSkippingTypePrivileges );
/////////////////////////////////////////////////////////////////////////
1:         bindExpressions( selectList, fullFromList );
commit:18792e2
/////////////////////////////////////////////////////////////////////////
1: 
0:        bindExpressions( selectList, fullFromList );
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // Don't add USAGE privilege on user-defined types just because we're
1:         // building the THEN columns.
1:         //
1:         boolean wasSkippingTypePrivileges = getCompilerContext().skipTypePrivileges( true );
/////////////////////////////////////////////////////////////////////////
1:         getCompilerContext().skipTypePrivileges( wasSkippingTypePrivileges );
/////////////////////////////////////////////////////////////////////////
1: 
0:         boolean wasSkippingTypePrivileges = cc.skipTypePrivileges( true );
0:         cc.setReliability( previousReliability | CompilerContext.SQL_IN_ROUTINES_ILLEGAL );
/////////////////////////////////////////////////////////////////////////
0:             cc.skipTypePrivileges( wasSkippingTypePrivileges );
commit:daffaee
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.IgnoreFilter;
/////////////////////////////////////////////////////////////////////////
1:         List<ColumnReference> colRefs = getColumnReferences( _updateColumns );
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // Don't add any privileges until we bind the DELETE.
1:         //
1:         IgnoreFilter    ignorePermissions = new IgnoreFilter();
1:         getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:             
/////////////////////////////////////////////////////////////////////////
1:         // ready to add permissions
1:         getCompilerContext().removePrivilegeFilter( ignorePermissions );
1: 
/////////////////////////////////////////////////////////////////////////
1:                 List<ColumnReference> colRefs = getColumnReferences( checkConstraints );
/////////////////////////////////////////////////////////////////////////
1:         for ( ColumnReference cr : getColumnReferences( node ) )
/////////////////////////////////////////////////////////////////////////
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /** Get a list of column references in an expression */
1:     private List<ColumnReference>   getColumnReferences( QueryTreeNode expression )
1:         throws StandardException
1:     {
1:         CollectNodesVisitor<ColumnReference> getCRs =
1:             new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
1: 
1:         expression.accept(getCRs);
1:         
1:         return getCRs.getList();
1:     }
1: 
commit:3e77b5a
/////////////////////////////////////////////////////////////////////////
1:         if ( isUpdateClause() ) { bindUpdate( dd, mergeNode, fullFromList, targetTable ); }
/////////////////////////////////////////////////////////////////////////
1:         else if ( isDeleteClause() )
1:         {
1:             // add all of the THEN columns
1:             mergeNode.getColumnsFromList( drivingColumnMap, _thenColumns, ColumnReference.MERGE_TARGET );
1:         }
/////////////////////////////////////////////////////////////////////////
1:          MergeNode  mergeNode,
1:         bindSetClauses( mergeNode, fullFromList, targetTable, setClauses );
1: 
/////////////////////////////////////////////////////////////////////////
1:          MergeNode mergeNode,
/////////////////////////////////////////////////////////////////////////
1: 
1:         //
1:         // For column resolution later on, columns on the left side
1:         // of SET operators are associated with the TARGET table.
1:         //
1:         for ( int i = 0; i < _updateColumns.size(); i++ )
1:         {
1:             ResultColumn    rc = _updateColumns.elementAt( i );
1:             ColumnReference  cr = rc.getReference();
1:             cr.setMergeTableID( ColumnReference.MERGE_TARGET );
1:         }
1: 
1:         // Now associate the columns on the right side of SET operators.
0:         CollectNodesVisitor<ColumnReference> getCRs =
0:             new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
0:         _updateColumns.accept(getCRs);
0:         List<ColumnReference> colRefs = getCRs.getList();
1:         for ( ColumnReference cr : colRefs )
1:         {
1:             mergeNode.associateColumn( fullFromList, cr, ColumnReference.MERGE_UNKNOWN );
1:         }
/////////////////////////////////////////////////////////////////////////
0:     private void    bindDeleteThenColumns( ResultColumnList selectList )
/////////////////////////////////////////////////////////////////////////
0:                 SanityManager.THROWASSERT
1:                     (
0:                      "Can't find select list column corresponding to " + bufferedCR.getSQLColumnName() +
0:                      " with merge table id = " + bufferedCRMergeTableID
1:                      );
commit:bbd6aff
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         adjustMatchingRefinement( selectList, generatedScan );
1:         
/////////////////////////////////////////////////////////////////////////
1:     private void    generateInsertUpdateRow
/////////////////////////////////////////////////////////////////////////
1:      * Point the column references in the matching refinement at the corresponding
1:      * columns returned by the driving left join.
1:      * </p>
1:      */
1:     private void    adjustMatchingRefinement
1:         (
1:          ResultColumnList selectList,
1:          ResultSetNode  generatedScan
1:          )
1:         throws StandardException
1:     {
1:         if ( _matchingRefinement != null )
1:         {
1:             useGeneratedScan( selectList, generatedScan, _matchingRefinement );
1:         }
1:     }
1:     
1:     /**
1:      * <p>
1:     private void    adjustThenColumns
/////////////////////////////////////////////////////////////////////////
1:         useGeneratedScan( selectList, generatedScan, _thenColumns );
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Point a node's ColumnReferences into the row returned by the driving left join.
1:      * </p>
1:      */
1:     private void    useGeneratedScan
1:         (
1:          ResultColumnList selectList,
1:          ResultSetNode  generatedScan,
1:          QueryTreeNode  node
1:          )
1:         throws StandardException
1:     {
1:         ResultColumnList    leftJoinResult = generatedScan.getResultColumns();
0:         CollectNodesVisitor<ColumnReference> getCRs =
0:             new CollectNodesVisitor<ColumnReference>( ColumnReference.class );
0:         node.accept( getCRs );
1: 
0:         for ( ColumnReference cr : getCRs.getList() )
1:         {
1:             ResultColumn    leftJoinRC = leftJoinResult.elementAt( getSelectListOffset( selectList, cr ) - 1 );
1:             cr.setSource( leftJoinRC );
1:         }
1:     }
1:     
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1:         ResultColumnList    fullUpdateRow = getBoundSelectUnderUpdate().getResultColumns();
/////////////////////////////////////////////////////////////////////////
1:         ResultColumnList    dmlSignature = _dml.resultSet.getResultColumns();
/////////////////////////////////////////////////////////////////////////
1:         buildThenColumnsForInsert( fullFromList, targetTable, _dml.resultSet.getResultColumns(), _insertColumns, _insertValues );
/////////////////////////////////////////////////////////////////////////
1:         ResultColumnList    leftJoinResult = generatedScan.getResultColumns();
commit:5d1ab63
/////////////////////////////////////////////////////////////////////////
1:         ResultColumnList    selectList = new ResultColumnList( getContextManager() );
1:         for ( int i = 0; i < _insertValues.size(); i++ )
1:         {
1:             ResultColumn    rc = _insertValues.elementAt( i );
1:             selectList.addResultColumn( rc.cloneMe() );
1:         }
1:         selectList.replaceOrForbidDefaults( targetTable.getTableDescriptor(), _insertColumns, true );
0:         bindExpressions( selectList, fullFromList );
1:         bindInsertValues( fullFromList, targetTable );
1: 
/////////////////////////////////////////////////////////////////////////
1:              selectList,      // select list
commit:b3f38f8
/////////////////////////////////////////////////////////////////////////
1:         TableName   tableName = targetTable.getTableNameField();
1:         FromList    selectFromList = fullFromList;
1:         
1:              selectFromList,
/////////////////////////////////////////////////////////////////////////
1:         _dml = new UpdateNode( tableName, selectNode, this, getContextManager() );
/////////////////////////////////////////////////////////////////////////
1:         // split the row into before and after images
/////////////////////////////////////////////////////////////////////////
1:             TableName   tableName = targetTable.getTableName();
1:                  tableName,
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
0:                 SanityManager.THROWASSERT( "Can't find select list column corresponding to " + bufferedCR.getSQLColumnName() );
/////////////////////////////////////////////////////////////////////////
0:                  "Column " + cr.getSQLColumnName() + " has illegal MERGE table id: " + mergeTableID
commit:2f8e6fb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             mergeNode.getColumnsInExpression( drivingColumnMap, _matchingRefinement, ColumnReference.MERGE_UNKNOWN );
/////////////////////////////////////////////////////////////////////////
1:                 mergeNode.getColumnsInExpression( drivingColumnMap, rc.getExpression(), ColumnReference.MERGE_UNKNOWN );
1:                 mergeNode.addColumn( drivingColumnMap, leftCR, ColumnReference.MERGE_TARGET );
/////////////////////////////////////////////////////////////////////////
1:                 mergeNode.getColumnsInExpression( drivingColumnMap, rc.getExpression(), ColumnReference.MERGE_UNKNOWN );
/////////////////////////////////////////////////////////////////////////
1:          FromBaseTable targetTable
1:         ResultColumnList    setClauses = realiasSetClauses( targetTable );
0:         bindSetClauses( fullFromList, targetTable, setClauses );
1: 
0:              //             _updateColumns,
1:              setClauses,
/////////////////////////////////////////////////////////////////////////
0:         _dml = new UpdateNode( targetTable.getTableNameField(), selectNode, this, getContextManager() );
/////////////////////////////////////////////////////////////////////////
0:      * Due to discrepancies on how names are resolved in SELECT and UPDATE,
1:      * we have to force the left side of SET clauses to use the same table identifiers
1:      * as the right sides of the SET clauses.
1:      * </p>
1:      */
1:     private ResultColumnList    realiasSetClauses
1:         (
1:          FromBaseTable targetTable
1:          )
1:         throws StandardException
1:     {
1:         ResultColumnList    rcl = new ResultColumnList( getContextManager() );
1:         for ( int i = 0; i < _updateColumns.size(); i++ )
1:         {
1:             ResultColumn    setRC = _updateColumns.elementAt( i );
1:             ColumnReference newTargetColumn = new ColumnReference
1:                 (
1:                  setRC.getReference().getColumnName(),
0:                  targetTable.getTableName(),
1:                  getContextManager()
1:                  );
1:             newTargetColumn.setMergeTableID( ColumnReference.MERGE_TARGET );
1:             ResultColumn    newRC = new ResultColumn
1:                 (
1:                  newTargetColumn,
1:                  setRC.getExpression(),
1:                  getContextManager()
1:                  );
1:             rcl.addResultColumn( newRC );
1:         }
1: 
1:         return rcl;
1:     }
1:     
1:     /**
1:      * <p>
/////////////////////////////////////////////////////////////////////////
1:          FromTable targetTable,
1:          ResultColumnList   setClauses
1:         setClauses.replaceOrForbidDefaults( targetTable.getTableDescriptor(), _updateColumns, true );
1:         bindExpressions( setClauses, fullFromList );
/////////////////////////////////////////////////////////////////////////
1:         FromBaseTable   deleteTarget = new FromBaseTable
1:             ( targetTable.getTableNameField(), null, null, null, getContextManager() );
1:         FromList    dummyFromList = new FromList( getContextManager() );
1:         dummyFromList.addFromTable( deleteTarget );
1:         dummyFromList.bindTables( dd, new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() ) );
1:  
1:             ( CURRENT_OF_NODE_NAME, deleteTarget, getContextManager() );
/////////////////////////////////////////////////////////////////////////
1:         _dml = new DeleteNode( targetTable.getTableNameField(), selectNode, this, getContextManager() );
/////////////////////////////////////////////////////////////////////////
1:          FromBaseTable targetTable
/////////////////////////////////////////////////////////////////////////
1:              targetTable.getTableNameField(),
/////////////////////////////////////////////////////////////////////////
0:             String              bufferedCRName = bufferedCR.getColumnName();
0:             int                 bufferedCRMergeTableID = getMergeTableID( bufferedCR );
/////////////////////////////////////////////////////////////////////////
0:                         ( getMergeTableID( selectCR ) == bufferedCRMergeTableID) &&
0:                         bufferedCRName.equals( selectCR.getColumnName() )
1:             
0:             if (SanityManager.DEBUG)
1:             {
0:                 SanityManager.THROWASSERT( "Can't find select list column corresponding to " + bufferedCR.debugName() );
1:             }
/////////////////////////////////////////////////////////////////////////
0:     /** Find the MERGE table id of the indicated column */
0:     private int getMergeTableID( ColumnReference cr )
1:     {
0:         int                 mergeTableID = cr.getMergeTableID();
1: 
0:         if (SanityManager.DEBUG)
1:         {
0:             SanityManager.ASSERT
1:                 (
0:                  ( (mergeTableID == ColumnReference.MERGE_SOURCE) || (mergeTableID == ColumnReference.MERGE_TARGET) ),
0:                  "Column " + cr.debugName() + " has illegal MERGE table id: " + mergeTableID
1:                  );
1:         }
1: 
0:         return mergeTableID;
1:     }
1: 
commit:b0456a0
/////////////////////////////////////////////////////////////////////////
1:                 ColumnReference leftCR = new ColumnReference( rc.getName(), targetTableName, getContextManager() );
/////////////////////////////////////////////////////////////////////////
1:                     origRC.setColumnDescriptor( null, null );
/////////////////////////////////////////////////////////////////////////
1:             String          columnName = _insertColumns.elementAt( i ).getName();
/////////////////////////////////////////////////////////////////////////
1:             String              columnName = lastLeftJoinRC.getName();
commit:1484b83
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // Although the SQL Standard allows subqueries in the WHEN [ NOT ] MATCHED clauses,
1:         // we don't support them yet. That is because code-generation for those clauses breaks
1:         // if they contain subqueries. That, in turn, is because we don't completely optimize those
1:         // clauses. If we improve Derby so that we do completely optimize the WHEN [ NOT ] MATCHED clauses,
1:         // then we can consider enabling subqueries in them.
1:         //
1:         forbidSubqueries();
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Forbid subqueries in WHEN [ NOT ] MATCHED clauses.
1:      * </p>
1:      */
1:     private void    forbidSubqueries()
1:         throws StandardException
1:     {
1:         forbidSubqueries( _matchingRefinement );
1:         forbidSubqueries( _updateColumns );
1:         forbidSubqueries( _insertColumns );
1:         forbidSubqueries( _insertValues );
1:     }
1:     private void    forbidSubqueries( ResultColumnList rcl )
1:         throws StandardException
1:     {
1:         if ( rcl != null )
1:         {
1:             for ( int i = 0; i < rcl.size(); i++ )
1:             {
1:                 forbidSubqueries( rcl.elementAt( i ) );
1:             }
1:         }
1:     }
1:     private void    forbidSubqueries( ValueNode expr )
1:         throws StandardException
1:     {
1:         if ( expr != null )
1:         {
1:             CollectNodesVisitor<SubqueryNode> getSubqueries =
1:                 new CollectNodesVisitor<SubqueryNode>(SubqueryNode.class);
1:             expr.accept( getSubqueries );
1:             if ( getSubqueries.getList().size() > 0 )
1:             {
1:                 throw StandardException.newException( SQLState.LANG_NO_SUBQUERIES_IN_MATCHED_CLAUSE );
1:             }
1:         }
1:     }
1: 
commit:856f892
/////////////////////////////////////////////////////////////////////////
0:         replaceCorrelationNameInSetClauses( parent, correlationName, newTableName );
1:     /**
1:      * <p>
0:      * Replace references to the correlation name with the underlying table name
0:      * in the SET clauses of WHEN MATCHED ... THEN UPDATE clauses. This replacement is
0:      * done before the ColumnReferences are bound.
1:      * </p>
1:      */
0:     public  void    replaceCorrelationNameInSetClauses
1:         (
0:          MergeNode  parent,
0:          String correlationName,
0:          TableName  newTableName
1:          )
1:         throws StandardException
1:     {
0:         if ( _updateColumns == null ) { return; }
1:         
0:         // this handles the right side of the SET clauses
0:         parent.replaceCorrelationName( correlationName, newTableName, _updateColumns );
1: 
0:         // we have to hand-process the left side because the Visitor
0:         // logic for ResultColumns does not process the ColumnReference
1:         for ( int i = 0; i < _updateColumns.size(); i++ )
1:         {
0:             ResultColumn    rc = _updateColumns.elementAt( i );
1: 
0:             parent.replaceCorrelationName( correlationName, newTableName, rc.getReference() );
1:         }
1:     }
1:     
commit:69ab4bd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
/////////////////////////////////////////////////////////////////////////
1:         TableDescriptor td = targetTable.getTableDescriptor();
1: 
1:         // construct a full insert column list if insert columns weren't specified
1:         if ( _insertColumns == null )  { _insertColumns = buildFullColumnList( td ); }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Build the full column list for a table.
1:      * </p>
1:      */
1:     private ResultColumnList    buildFullColumnList( TableDescriptor td )
1:         throws StandardException
1:     {
1:         ResultColumnList    result = new ResultColumnList( getContextManager() );
1: 		ColumnDescriptorList cdl = td.getColumnDescriptorList();
1: 		int					 cdlSize = cdl.size();
1: 
1: 		for ( int index = 0; index < cdlSize; index++ )
1: 		{
1:             ColumnDescriptor colDesc = cdl.elementAt( index );
1:             ColumnReference columnRef = new ColumnReference( colDesc.getColumnName(), null, getContextManager() );
1:             ResultColumn    resultColumn = new ResultColumn
1:                 (
1:                  columnRef,
1:                  null,
1:                  getContextManager()
1:                  );
1:             
1:             result.addResultColumn( resultColumn );
1:         }
1: 
1:         return result;
1:     }
commit:1cd5dd1
/////////////////////////////////////////////////////////////////////////
1:             FromList    fromList = fullFromList;
1: 
1:             //
1:             // For an INSERT action, the WHEN NOT MATCHED refinement can only
1:             // mention columns in the source table.
1:             //
1:             if ( isInsertClause() )
1:             {
1:                 fromList = new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() );
1:                 fromList.addElement( fullFromList.elementAt( MergeNode.SOURCE_TABLE_INDEX ) );
1:             }
1: 
1:             mergeNode.bindExpression( _matchingRefinement, fromList );
/////////////////////////////////////////////////////////////////////////
1:         FromList    sourceTableFromList = new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() );
1:         sourceTableFromList.addElement( fullFromList.elementAt( MergeNode.SOURCE_TABLE_INDEX ) );
1:         bindExpressions( _insertValues, sourceTableFromList );
commit:3511a12
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
0:      * Replace references to the correlation name with the underlying table name
0:      * in all ColumnReferences under all expressions. This replacement is
0:      * done before the ColumnReferences are bound.
1:      * </p>
1:      */
0:     public  void    replaceCorrelationName
1:         (
0:          MergeNode  parent,
0:          String correlationName,
0:          TableName  newTableName
1:          )
1:         throws StandardException
1:     {
0:         parent.replaceCorrelationName( correlationName, newTableName, _matchingRefinement );
0:         parent.replaceCorrelationName( correlationName, newTableName, _updateColumns );
0:         parent.replaceCorrelationName( correlationName, newTableName, _insertColumns );
0:         parent.replaceCorrelationName( correlationName, newTableName, _insertValues );
1:     }
1:     
commit:6ab1083
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
/////////////////////////////////////////////////////////////////////////
1:             TableName   targetTableName = mergeNode.getTargetTable().getTableName();
1: 
1:             //
1:             // Get all columns mentioned on both sides of SET operators in WHEN MATCHED ... THEN UPDATE clauses.
1:             // We need the left side because UPDATE needs before and after images of columns.
1:             // We need the right side because there may be columns in the expressions there.
1:             //
1: 
0:                 ColumnReference leftCR = new ColumnReference( rc.exposedName, targetTableName, getContextManager() );
0:                 mergeNode.addColumn( drivingColumnMap, leftCR );
/////////////////////////////////////////////////////////////////////////
1: 
1:         //
1:         // Split the update row into its before and after images.
1:         //
1:         ResultColumnList    beforeColumns = new ResultColumnList( getContextManager() );
1:         ResultColumnList    afterColumns = new ResultColumnList( getContextManager() );
0:         ResultColumnList    fullUpdateRow = getBoundSelectUnderUpdate().resultColumns;
1:         
1:         // the full row is the before image, the after image, and a row location
1:         int     rowSize = fullUpdateRow.size() / 2;
1: 
1:         for ( int i = 0; i < rowSize; i++ )
1:         {
1:             ResultColumn    origBeforeRC = fullUpdateRow.elementAt( i );
1:             ResultColumn    origAfterRC = fullUpdateRow.elementAt( i + rowSize );
1:             ResultColumn    beforeRC = origBeforeRC.cloneMe();
1:             ResultColumn    afterRC = origAfterRC.cloneMe();
1: 
1:             beforeColumns.addResultColumn( beforeRC );
1:             afterColumns.addResultColumn( afterRC );
1:         }
1: 
1:         buildThenColumnsForUpdate( fullFromList, targetTable, fullUpdateRow, beforeColumns, afterColumns );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Get the bound SELECT node under the dummy UPDATE node.
0:      * This may not be the source result set of the UPDATE node. That is because a ProjectRestrictResultSet
1:      * may have been inserted on top of it by DEFAULT handling. This method
0:      * exists to make the UPDATE actions of MERGE statement behave like ordinary
1:      * UPDATE statements in this situation. The behavior is actually wrong. See
1:      * DERBY-6414. Depending on how that bug is addressed, we may be able
1:      * to remove this method eventually.
1:      * </p>
1:      */
1:     private ResultSetNode    getBoundSelectUnderUpdate()
1:         throws StandardException
1:     {
1:         ResultSetNode   candidate = _dml.resultSet;
1: 
1:         while ( candidate != null )
1:         {
1:             if ( candidate instanceof SelectNode ) { return candidate; }
1:             else if ( candidate instanceof SingleChildResultSetNode )
1:             {
1:                 candidate = ((SingleChildResultSetNode) candidate).getChildResult();
1:             }
1:             else    { break; }
1:         }
1:         
1:         // don't understand what's going on
1:         throw StandardException.newException( SQLState.NOT_IMPLEMENTED );
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Construct the row in the temporary table which drives an UPDATE action.
1:      * Unlike a DELETE, whose temporary row is just a list of copied columns, the
1:      * temporary row for UPDATE may contain complex expressions which must
1:      * be code-generated later on.
1:      * </p>
1:      */
1:     private void    buildThenColumnsForUpdate
1:         (
1:          FromList fullFromList,
1:          FromTable targetTable,
1:          ResultColumnList   fullRow,
1:          ResultColumnList beforeRow,
1:          ResultColumnList afterValues
1:          )
1:         throws StandardException
1:     {
1:         TableDescriptor td = targetTable.getTableDescriptor();
1:         HashSet<String> changedColumns = getChangedColumnNames();
1:         HashSet<String> changedGeneratedColumns = getChangedGeneratedColumnNames( td, changedColumns );
1: 
1:         _thenColumns = fullRow.copyListAndObjects();
1: 
1:         //
1:         // Here we set up for the evaluation of expressions in the temporary table
1:         // which drives the INSERT action. If we were actually generating the dummy SELECT
1:         // for the DML action, the work would normally be done there. But we don't generate
1:         // that SELECT. So we do the following here:
1:         //
1:         // 1) If a column has a value specified in the WHEN [ NOT ] MATCHED clause, then we use it.
1:         //     There is some special handling to make the DEFAULT value work for identity columns.
1:         //
1:         // 2) Otherwise, if the column has a default, then we plug it in.
1:         //
1:         for ( int i = 0; i < _thenColumns.size(); i++ )
1:         {
1:             ResultColumn    origRC = _thenColumns.elementAt( i );
1: 
1:             boolean isAfterColumn = (i >= beforeRow.size());
1: 
1:             // skip the final RowLocation column of an UPDATE
1:             boolean isRowLocation = isRowLocation( origRC );
1:             ValueNode   origExpr = origRC.getExpression();
1: 
1:             if ( isRowLocation ) { continue; }
1: 
1:             String              columnName = origRC.getName();
1:             ColumnDescriptor    cd = td.getColumnDescriptor( columnName );
1:             boolean         changed = false;
1: 
1:             //
1:             // This handles the case that a GENERATED BY DEFAULT identity column is being
1:             // set to the keyword DEFAULT. This causes the UPDATE action of a MERGE statement
1:             // to have the same wrong behavior as a regular UPDATE statement. See derby-6414.
1:             //
1:             if ( cd.isAutoincrement() && (origRC.getExpression() instanceof NumericConstantNode) )
1:             {
1:                 DataValueDescriptor numericValue = ((NumericConstantNode) origRC.getExpression()).getValue();
1:                 
1:                 if ( numericValue == null )
1:                 {
1:                     ResultColumn    newRC = makeAutoGenRC( targetTable, origRC, i+1 );
1:                     newRC.setVirtualColumnId( origRC.getVirtualColumnId() );
1:                     _thenColumns.setElementAt( newRC, i  );
1: 
1:                     continue;
1:                 }
1:             }
1: 
1:             //
1:             // VirtualColumnNodes are skipped at code-generation time. This can result in
1:             // NPEs when evaluating generation expressions. Replace VirtualColumnNodes with
1:             // UntypedNullConstantNodes, except for identity columns, which require special
1:             // handling below.
1:             //
1:             if ( !origRC.isAutoincrement() && (origRC.getExpression() instanceof VirtualColumnNode) )
1:             {
1:                 origRC.setExpression( new UntypedNullConstantNode( getContextManager() ) );
1:             }
1: 
1:             //
1:             // Generated columns need special handling. The value needs to be recalculated
1:             // under the following circumstances:
1:             //
1:             // 1) It's the after image of the column
1:             //
1:             // 2) AND the statement causes the value to change.
1:             //
1:             // Otherwise, the value should be set to whatever is in the row coming out
1:             // of the driving left join.
1:             //
1:             if ( cd.hasGenerationClause() )
1:             {
1:                 if ( isAfterColumn && changedGeneratedColumns.contains( columnName ) )
1:                 {
1:                     // Set the expression to something that won't choke ResultColumnList.generateEvaluatedRow().
1:                     // The value will be a Java null at execution time, which will cause the value
1:                     // to be re-generated.
1:                     origRC.setExpression( new UntypedNullConstantNode( getContextManager() ) );
1:                 }
1:                 else
1:                 {
1:                     ColumnReference cr = new ColumnReference
1:                         ( columnName, targetTable.getTableName(), getContextManager() );
1:                     origRC.setExpression( cr );
1: 
1:                     // remove the column descriptor in order to turn off hasGenerationClause()
0:                     origRC.columnDescriptor = null;
1:                 }
1:                 
1:                 continue;
1:             }
1: 
1:             if ( isAfterColumn )
1:             {
1:                 for ( int ic = 0; ic < beforeRow.size(); ic++ )
1:                 {
1:                     ResultColumn    icRC = beforeRow.elementAt( ic );
1: 
1:                     if ( columnName.equals( icRC.getName() ) )
1:                     {
1:                         ResultColumn    newRC = null;
1:                     
1:                         // replace DEFAULT for a generated or identity column
1:                         ResultColumn    valueRC = afterValues.elementAt( ic );
1: 
1:                         if ( valueRC.wasDefaultColumn() || (valueRC.getExpression() instanceof UntypedNullConstantNode ) )
1:                         {
1:                             if ( !cd.isAutoincrement() )
1:                             {
1:                                 //
1:                                 // Eliminate column references under identity columns. They
1:                                 // will mess up the code generation.
1:                                 //
1:                                 ValueNode   expr = origRC.getExpression();
1:                                 if ( expr instanceof ColumnReference )
1:                                 {
1:                                     origRC.setExpression( new UntypedNullConstantNode( getContextManager() ) );
1:                                 }
1:                                 continue;
1:                             }
1: 
1:                             newRC = makeAutoGenRC( targetTable, origRC, i+1 );
1:                         }
1:                         else
1:                         {
1:                             newRC = valueRC.cloneMe();
1:                             newRC.setType( origRC.getTypeServices() );
1:                         }
1: 
1:                         newRC.setVirtualColumnId( origRC.getVirtualColumnId() );
1:                         _thenColumns.setElementAt( newRC, i  );
1:                         changed = true;
1:                         break;
1:                     }
1:                 }
1:             }
1: 
1:             // plug in defaults if we haven't done so already
1:             if ( !changed )
1:             {
1:                 DefaultInfoImpl     defaultInfo = (DefaultInfoImpl) cd.getDefaultInfo();
1: 
1: 				if ( (defaultInfo != null) && !defaultInfo.isGeneratedColumn() && !cd.isAutoincrement() )
1: 				{
1:                     _thenColumns.setDefault( origRC, cd, defaultInfo );
1:                     changed = true;
1: 				}
1:             }
1: 
1:             // set the result column name correctly for buildThenColumnSignature()
1:             ResultColumn    finalRC = _thenColumns.elementAt( i );
1:             finalRC.setName( cd.getColumnName() );
1:             
1:             //
1:             // Turn off the autogenerated bit for identity columns so that
1:             // ResultColumnList.generateEvaluatedRow() doesn't try to compile
1:             // code to generate values for the before images in UPDATE rows.
1:             // This logic will probably need to be revisited as part of fixing derby-6414.
1:             //
1:             finalRC.resetAutoincrementGenerated();
1:         }   // end loop through _thenColumns
1:     }
1: 
1:     /** Get the names of the columns explicitly changed by SET clauses */
1:     private HashSet<String> getChangedColumnNames()
1:         throws StandardException
1:     {
1:         HashSet<String> result = new HashSet<String>();
1: 
0:         for ( int i = 0; i < _updateColumns.size(); i++ )
1:         {
1:             String  columnName = _updateColumns.elementAt( i ).getName();
1:             result.add( columnName );
1:         }
1: 
1:         return result;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Get the names of the generated columns which are changed
1:      * by the UPDATE statement. These are the generated columns which
1:      * match one of the following conditions:
1:      * </p>
1:      *
1:      * <ul>
1:      * <li>Are explicitly mentioned on the left side of a SET clause.</li>
1:      * <li>Are built from other columns which are explicitly mentioned on the left side of a SET clause.</li>
1:      * </ul>
1:      */
1:     private HashSet<String> getChangedGeneratedColumnNames
1:         (
1:          TableDescriptor    targetTableDescriptor,
1:          HashSet<String>    changedColumnNames  // columns which are explicitly mentioned on the left side of a SET clause
1:          )
1:         throws StandardException
1:     {
1:         HashSet<String> result = new HashSet<String>();
1: 
1:         for ( ColumnDescriptor cd : targetTableDescriptor.getColumnDescriptorList() )
1:         {
1:             if ( !cd.hasGenerationClause() ) { continue; }
1: 
1:             if ( changedColumnNames.contains( cd.getColumnName() ) )
1:             {
1:                 result.add( cd.getColumnName() );
1:                 continue;
1:             }
1: 
1:             String[]    referencedColumns = cd.getDefaultInfo().getReferencedColumnNames();
1: 
1:             for ( String referencedColumnName : referencedColumns )
1:             {
1:                 if ( changedColumnNames.contains( referencedColumnName ) )
1:                 {
1:                     result.add( referencedColumnName );
1:                     break;
1:                 }
1:             }
1:         }
1: 
1:         return result;
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:         buildThenColumnsForInsert( fullFromList, targetTable, _dml.resultSet.resultColumns, _insertColumns, _insertValues );
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Construct the row in the temporary table which drives an INSERT action.
1:      * Unlike a DELETE, whose temporary row is just a list of copied columns, the
1:      * temporary row for INSERT may contain complex expressions which must
1:      * be code-generated later on.
1:      * </p>
1:      */
1:     private void    buildThenColumnsForInsert
1:         (
1:          FromList fullFromList,
1:          FromTable targetTable,
1:          ResultColumnList   fullRow,
1:          ResultColumnList insertColumns,
1:          ResultColumnList insertValues
1:          )
1:         _thenColumns = fullRow.copyListAndObjects();
/////////////////////////////////////////////////////////////////////////
1: 
1:             ColumnDescriptor    cd = td.getColumnDescriptor( columnName );
/////////////////////////////////////////////////////////////////////////
1:             if ( cd.hasGenerationClause() )
1:                 origRC.setExpression( new UntypedNullConstantNode( getContextManager() ) );
1:                 continue;
1:             }
1: 
1:             for ( int ic = 0; ic < insertColumns.size(); ic++ )
1:             {
1:                 ResultColumn    icRC = insertColumns.elementAt( ic );
1:                     ResultColumn    valueRC = insertValues.elementAt( ic );
1:                     if ( valueRC.wasDefaultColumn() || (valueRC.getExpression() instanceof UntypedNullConstantNode ) )
1:                         if ( !cd.isAutoincrement() )
/////////////////////////////////////////////////////////////////////////
1:                         newRC = makeAutoGenRC( targetTable, origRC, i+1 );
1:                         newRC = valueRC.cloneMe();
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * <p>
1:      * Make a ResultColumn for an identity column which is being set to the DEFAULT
1:      * value. This special ResultColumn will make it through code generation so that it
1:      * will be calculated when the INSERT/UPDATE action is run.
1:      * </p>
1:      */
1:     private ResultColumn    makeAutoGenRC
1:         (
1:          FromTable targetTable,
1:          ResultColumn   origRC,
1:          int    virtualColumnID
1:          )
1:         throws StandardException
1:     {
1:         String              columnName = origRC.getName();
1:         ColumnReference autoGenCR = new ColumnReference( columnName, targetTable.getTableName(), getContextManager() );
1:         ResultColumn    autoGenRC = new ResultColumn( autoGenCR, null, getContextManager() );
1:         VirtualColumnNode autoGenVCN = new VirtualColumnNode( targetTable, autoGenRC, virtualColumnID, getContextManager() );
1:         ResultColumn    newRC = new ResultColumn( autoGenCR, autoGenVCN, getContextManager() );
1: 
1:         // set the type so that buildThenColumnSignature() will function correctly
1:         newRC.setType( origRC.getTypeServices() );
1: 
1:         return newRC;
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:          ResultSetNode  generatedScan,
/////////////////////////////////////////////////////////////////////////
0:         if ( isInsertClause() || isUpdateClause() ) { generateInsertUpdateRow( acb, selectList, generatedScan, hojn ); }
/////////////////////////////////////////////////////////////////////////
1:         if( isDeleteClause()) { return; }
1:             ValueNode   checkConstraints = isInsertClause() ?
1:                 ((InsertNode) _dml).checkConstraints :
1:                 ((UpdateNode) _dml).checkConstraints;
/////////////////////////////////////////////////////////////////////////
1:      * Generate a method to build a row for the temporary table for INSERT/UPDATE actions.
0:     void    generateInsertUpdateRow
1:          ResultSetNode  generatedScan,
1:         adjustThenColumns( selectList, generatedScan, hojn );
/////////////////////////////////////////////////////////////////////////
1:      * Point the column references in the temporary row at the corresponding
1:          ResultSetNode  generatedScan,
0:         ResultColumnList    leftJoinResult = generatedScan.resultColumns;
/////////////////////////////////////////////////////////////////////////
1: 
1:         //
1:         // For an UPDATE action, the final column in the temporary row is the
1:         // RowLocation. Point it at the last column in the row returned by the left join.
1:         //
1:         int                 lastRCSlot = _thenColumns.size() - 1;
1:         ResultColumn    lastRC = _thenColumns.elementAt( lastRCSlot );
1: 
1:         if ( isRowLocation( lastRC ) )
1:         {
1:             ResultColumn    lastLeftJoinRC = leftJoinResult.elementAt( leftJoinResult.size() - 1 );
1:             ValueNode       value = lastLeftJoinRC.getExpression();
0:             String              columnName = lastLeftJoinRC.exposedName;
1:             ColumnReference rowLocationCR = new ColumnReference
1:                 ( columnName, hojn.getTableName(), getContextManager() );
1: 
1:             rowLocationCR.setSource( lastLeftJoinRC );
1:             
1:             ResultColumn    rowLocationRC = new ResultColumn( columnName, rowLocationCR, getContextManager() );
1: 
1:             _thenColumns.removeElementAt( lastRCSlot );
1:             _thenColumns.addResultColumn( rowLocationRC );
1:         }
1:     }
1: 
0:     /** Return true if the ResultColumn represents a RowLocation */
0:     private boolean isRowLocation( ResultColumn rc ) throws StandardException
1:     {
0:         if ( rc.getExpression() instanceof CurrentRowLocationNode ) { return true; }
1: 
0:         DataTypeDescriptor  dtd = rc.getTypeServices();
0:         if ( (dtd != null) && (dtd.getTypeId().isRefTypeId()) ) { return true; }
1: 
0:         return false;
commit:01632c2
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
1: import org.apache.derby.catalog.types.DefaultInfoImpl;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
/////////////////////////////////////////////////////////////////////////
0:     private int[]                           _deleteColumnOffsets;
1:     private String                          _rowMakingMethodName;
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:         _thenColumns = new ResultColumnList( getContextManager() );
1: 
/////////////////////////////////////////////////////////////////////////
0:     /** Re-bind various clauses and lists once we have ResultSet numbers for the driving left join */
0:     void    bindResultSetNumbers( MergeNode mergeNode, FromList fullFromList ) throws StandardException
0:         bindRefinement( mergeNode, fullFromList );
1: 
/////////////////////////////////////////////////////////////////////////
0:     ////////////////////// UPDATE ///////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         bindSetClauses( fullFromList, targetTable );
1:         
/////////////////////////////////////////////////////////////////////////
1:     /** Bind the SET clauses of an UPDATE action */
1:     private void    bindSetClauses
1:         (
1:          FromList fullFromList,
1:          FromTable targetTable
1:          )
1:         throws StandardException
1:     {
1:         // needed to make the UpdateNode bind
0:         _updateColumns.replaceOrForbidDefaults( targetTable.getTableDescriptor(), _updateColumns, true );
1: 
0:         bindExpressions( _updateColumns, fullFromList );
1:     }
1: 
0:     ////////////////////// DELETE ///////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         buildThenColumnsForDelete();
1:     }
1: 
1:     /**
1:      * <p>
1:      * Construct the signature of the temporary table which drives the
1:      * INSERT/UPDATE/DELETE action.
1:      * </p>
1:      */
1:     private void    buildThenColumnsForDelete()
1:         throws StandardException
1:     {
0:         ResultColumnList    dmlSignature = _dml.resultSet.resultColumns;
1:         for ( int i = 0; i < dmlSignature.size(); i++ )
1:             ResultColumn    origRC = dmlSignature.elementAt( i );
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
0:      * Calculate the 1-based offsets which define the rows which will be buffered up
0:      * for a DELETE action at run-time. The rows are constructed
0:      * from the columns in the SELECT list of the driving left joins. This method
0:      * calculates an array of offsets into the SELECT list. The columns at those
0:      * offsets will form the row which is buffered up for the DELETE
0:      * action.
1:      * </p>
1:      */
0:     void    bindDeleteThenColumns( ResultColumnList selectList )
1:         throws StandardException
1:     {
0:         int     bufferedCount = _thenColumns.size();
0:         int     selectCount = selectList.size();
1:         
0:         _deleteColumnOffsets = new int[ bufferedCount ];
1: 
0:         for ( int bidx = 0; bidx < bufferedCount; bidx++ )
1:         {
0:             ResultColumn    bufferedRC = _thenColumns.elementAt( bidx );
0:             ValueNode       bufferedExpression = bufferedRC.getExpression();
1: 
0:             _deleteColumnOffsets[ bidx ] = getSelectListOffset( selectList, bufferedExpression );
1:         }
1:     }
1: 
0:     ////////////////////// INSERT ///////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:         bindInsertValues( fullFromList, targetTable );
1:         
/////////////////////////////////////////////////////////////////////////
1: 
0:         buildInsertThenColumns( targetTable );
1:     /**  Bind the values in the INSERT list */
1:     private void    bindInsertValues
1:         (
1:          FromList fullFromList,
0:          FromTable targetTable
1:          )
1:         throws StandardException
1:     {
1:         if ( _insertColumns.size() != _insertValues.size() )
1:         {
1:             throw StandardException.newException( SQLState.LANG_DB2_INVALID_COLS_SPECIFIED ); 
1:         }
1:         
1:         TableDescriptor td = targetTable.getTableDescriptor();
1: 
1:         // forbid illegal values for identity columns
1:         for ( int i = 0; i <_insertValues.size(); i++ )
1:         {
1:             ResultColumn    rc = _insertValues.elementAt( i );
0:             String          columnName = _insertColumns.elementAt( i ).exposedName;
1:             ValueNode       expr = rc.getExpression();
1:             ColumnDescriptor    cd = td.getColumnDescriptor( columnName );
1: 
1:             // if the column isn't in the table, this will be sorted out when we bind
1:             // the InsertNode
1:             if ( cd == null ) { continue; }
1: 
1:             // DEFAULT is the only value allowed for a GENERATED ALWAYS AS IDENTITY column
1:             if ( cd.isAutoincAlways() && !(expr instanceof DefaultNode) )
1:             {
1:                 throw StandardException.newException( SQLState.LANG_AI_CANNOT_MODIFY_AI, columnName );
1:             }
1: 
1:             // NULL is illegal as the value for any identity column
1:             if ( cd.isAutoincrement() && (expr instanceof UntypedNullConstantNode) )
1:             {
1:                 throw StandardException.newException( SQLState.LANG_NULL_INTO_NON_NULL, columnName );
1:             }
1:         }
1:         
1:         // needed to make the SelectNode bind
1:         _insertValues.replaceOrForbidDefaults( targetTable.getTableDescriptor(), _insertColumns, true );
1:         bindExpressions( _insertValues, fullFromList );
1:     }
1:     
0:     /** Construct the row in the temporary table which drives an INSERT action */
0:     private void    buildInsertThenColumns( FromTable targetTable )
1:         throws StandardException
1:     {
1:         TableDescriptor td = targetTable.getTableDescriptor();
1: 
0:         _thenColumns = _dml.resultSet.resultColumns.copyListAndObjects();
1: 
1:         //
1:         // Here we set up for the evaluation of expressions in the temporary table
1:         // which drives the INSERT action. If we were actually generating the dummy SELECT
1:         // for the DML action, the work would normally be done there. But we don't generate
1:         // that SELECT. So we do the following here:
1:         //
1:         // 1) If a column has a value specified in the WHEN [ NOT ] MATCHED clause, then we use it.
1:         //     There is some special handling to make the DEFAULT value work for identity columns.
1:         //
1:         // 2) Otherwise, if the column has a default, then we plug it in.
1:         //
1:         for ( int i = 0; i < _thenColumns.size(); i++ )
1:         {
0:             ColumnDescriptor    cd = td.getColumnDescriptor( i + 1 );
1:             ResultColumn    origRC = _thenColumns.elementAt( i );
1:             String              columnName = origRC.getName();
1:             
1:             boolean         changed = false;
1: 
1:             //
1:             // VirtualColumnNodes are skipped at code-generation time. This can result in
1:             // NPEs when evaluating generation expressions. Replace VirtualColumnNodes with
1:             // UntypedNullConstantNodes, except for identity columns, which require special
1:             // handling below.
1:             //
1:             if ( !origRC.isAutoincrement() && (origRC.getExpression() instanceof VirtualColumnNode) )
1:             {
1:                 origRC.setExpression( new UntypedNullConstantNode( getContextManager() ) );
1:             }
1: 
0:             for ( int ic = 0; ic < _insertColumns.size(); ic++ )
1:             {
0:                 ResultColumn    icRC = _insertColumns.elementAt( ic );
1: 
1:                 if ( columnName.equals( icRC.getName() ) )
1:                 {
1:                     ResultColumn    newRC = null;
1:                     
1:                     // replace DEFAULT for a generated or identity column
0:                     ResultColumn    insertRC =_insertValues.elementAt( ic );
1: 
0:                     if ( insertRC.wasDefaultColumn() || (insertRC.getExpression() instanceof UntypedNullConstantNode ) )
1:                     {
0:                        if ( !cd.isAutoincrement() )
1:                         {
1:                             //
1:                             // Eliminate column references under identity columns. They
1:                             // will mess up the code generation.
1:                             //
1:                             ValueNode   expr = origRC.getExpression();
1:                             if ( expr instanceof ColumnReference )
1:                             {
1:                                 origRC.setExpression( new UntypedNullConstantNode( getContextManager() ) );
1:                             }
1:                             continue;
1:                         }
1: 
0:                         ColumnReference autoGenCR = new ColumnReference( columnName, targetTable.getTableName(), getContextManager() );
0:                         ResultColumn    autoGenRC = new ResultColumn( autoGenCR, null, getContextManager() );
0:                         VirtualColumnNode autoGenVCN = new VirtualColumnNode( targetTable, autoGenRC, i + 1, getContextManager() );
1: 
0:                         newRC = new ResultColumn( autoGenCR, autoGenVCN, getContextManager() );
1: 
0:                         // set the type so that buildThenColumnSignature() will function correctly
1:                         newRC.setType( origRC.getTypeServices() );
1:                     }
1:                     else
1:                     {
0:                         newRC = insertRC.cloneMe();
1:                         newRC.setType( origRC.getTypeServices() );
1:                     }
1: 
1:                     newRC.setVirtualColumnId( origRC.getVirtualColumnId() );
1:                     _thenColumns.setElementAt( newRC, i  );
1:                     changed = true;
1:                     break;
1:                 }
1:             }
1: 
1:             // plug in defaults if we haven't done so already
1:             if ( !changed )
1:             {
1:                 DefaultInfoImpl     defaultInfo = (DefaultInfoImpl) cd.getDefaultInfo();
1: 
1: 				if ( (defaultInfo != null) && !defaultInfo.isGeneratedColumn() && !cd.isAutoincrement() )
1: 				{
1:                     _thenColumns.setDefault( origRC, cd, defaultInfo );
1:                     changed = true;
1: 				}
1:             }
1: 
1:             // set the result column name correctly for buildThenColumnSignature()
1:             ResultColumn    finalRC = _thenColumns.elementAt( i );
1:             finalRC.setName( cd.getColumnName() );
1:         }   // end loop through _thenColumns
1:     }
1: 
0:     ////////////////////// bind() MINIONS ///////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:      * Bind the row which will go into the temporary table at run-time.
0:         if ( isDeleteClause() ) { bindDeleteThenColumns( selectList ); }
0:         else if ( isUpdateClause() )
0:             throw StandardException.newException( SQLState.NOT_IMPLEMENTED, "MERGE" );
1:         }
1:     }
1:     /**
1:      * <p>
0:      * Find a column reference in the SELECT list of the driving left join
0:      * and return its 1-based offset into that list.  Returns -1 if the column
0:      * can't be found.
1:      * </p>
1:      */
0:     private int getSelectListOffset( ResultColumnList selectList, ValueNode bufferedExpression )
1:         throws StandardException
1:     {
0:         int                 selectCount = selectList.size();
1: 
0:         if ( bufferedExpression instanceof ColumnReference )
1:         {
0:             ColumnReference bufferedCR = (ColumnReference) bufferedExpression;
0:             String              tableName = bufferedCR.getTableName();
0:             String              columnName = bufferedCR.getColumnName();
1: 
0:             // loop through the SELECT list to find this column reference
0:             for ( int sidx = 0; sidx < selectCount; sidx++ )
0:                 ResultColumn    selectRC = selectList.elementAt( sidx );
0:                 ValueNode       selectExpression = selectRC.getExpression();
0:                 ColumnReference selectCR = selectExpression instanceof ColumnReference ?
0:                     (ColumnReference) selectExpression : null;
0:                 if ( selectCR != null )
0:                     if (
0:                         tableName.equals( selectCR.getTableName() ) &&
0:                         columnName.equals( selectCR.getColumnName() )
1:                         )
0:                         return sidx + 1;
0:         else if ( bufferedExpression instanceof CurrentRowLocationNode )
1:         {
1:             //
0:             // There is only one RowLocation in the SELECT list, the row location for the
0:             // tuple from the target table. The RowLocation is always the last column in
0:             // the SELECT list.
1:             //
0:             return selectCount;
1:         }
1: 
0:         return -1;
/////////////////////////////////////////////////////////////////////////
1:              buildThenColumnSignature(),
1:              _rowMakingMethodName,
0:              _deleteColumnOffsets,
/////////////////////////////////////////////////////////////////////////
1:      * Build the signature of the row which will go into the temporary table.
1:      * </p>
1:      */
1:     private ResultDescription    buildThenColumnSignature()
1:         throws StandardException
1:     {
1:         ResultColumnDescriptor[]  cells = _thenColumns.makeResultDescriptors();
1: 
1:         return getLanguageConnectionContext().getLanguageFactory().getResultDescription( cells, "MERGE" );
1:     }
1: 
1:     /**
1:      * <p>
1:     void    generate
1:         (
1:          ActivationClassBuilder acb,
1:          ResultColumnList selectList,
1:          HalfOuterJoinNode  hojn,
1:          int    clauseNumber
1:          )
1: 
0:         if ( isInsertClause() ) { generateInsertRow( acb, selectList, hojn ); }
1:         
/////////////////////////////////////////////////////////////////////////
1:         remapConstraints();
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Re-map ColumnReferences in constraints to point into the row from the
1:      * temporary table. This is where the row will be stored when constraints
1:      * are being evaluated.
1:      * </p>
1:      */
1:     private void    remapConstraints()
1:         throws StandardException
1:     {
0:         if( !isInsertClause() ) { return; }
1:         else
1:         {
0:             CollectNodesVisitor<ColumnReference> getCRs =
0:                 new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
1: 
0:             ValueNode   checkConstraints = ((InsertNode) _dml).checkConstraints;
1: 
1:             if ( checkConstraints != null )
1:             {
0:                 checkConstraints.accept(getCRs);
0:                 List<ColumnReference> colRefs = getCRs.getList();
1:                 for ( ColumnReference cr : colRefs )
1:                 {
1:                     cr.getSource().setResultSetNumber( NoPutResultSet.TEMPORARY_RESULT_SET_NUMBER );
1:                 }
1:             }            
1:         }
1:     }
1: 
1:     /**
1:      * <p>
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
0:      * Generate a method to build a row for the temporary table for INSERT actions.
1:      * The method stuffs each column in the row with the result of the corresponding
1:      * expression built out of columns in the current row of the driving left join.
1:      * The method returns the stuffed row.
1:      * </p>
1:      */
0:     void    generateInsertRow
1:         (
1:          ActivationClassBuilder acb,
1:          ResultColumnList selectList,
1:          HalfOuterJoinNode  hojn
1:          )
1:         throws StandardException
1:     {
1:         // point expressions in the temporary row at the columns in the
1:         // result column list of the driving left join.
0:         adjustThenColumns( selectList, hojn );
1:         
1:         _rowMakingMethodName = "mergeRowMakingMethod_" + _clauseNumber;
1:         
1:         MethodBuilder mb = acb.getClassBuilder().newMethodBuilder
1:             (
1:              Modifier.PUBLIC,
1:              ClassName.ExecRow,
1:              _rowMakingMethodName
1:              );
1:         mb.addThrownException(ClassName.StandardException);
1: 
1:         _thenColumns.generateEvaluatedRow( acb, mb, false, true );
1:     }
1: 
1:     /**
1:      * <p>
0:      * Point the column references in the temporary row at corresponding
1:      * columns returned by the driving left join.
1:      * </p>
1:      */
0:     void    adjustThenColumns
1:         (
1:          ResultColumnList selectList,
1:          HalfOuterJoinNode  hojn
1:          )
1:         throws StandardException
1:     {
0:         ResultColumnList    leftJoinResult = hojn.resultColumns;
0:         CollectNodesVisitor<ColumnReference> getCRs =
0:             new CollectNodesVisitor<ColumnReference>( ColumnReference.class );
0:         _thenColumns.accept( getCRs );
1: 
0:         for ( ColumnReference cr : getCRs.getList() )
1:         {
0:             ResultColumn    leftJoinRC = leftJoinResult.elementAt( getSelectListOffset( selectList, cr ) - 1 );
0:             cr.setSource( leftJoinRC );
1:         }
1:     }
1:     
commit:508a010
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Modifier;
1: import java.util.HashMap;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  CURRENT_OF_NODE_NAME = "$MERGE_CURRENT";
1: 
/////////////////////////////////////////////////////////////////////////
1:     //
1:     //
1: 
0:     /** the INSERT/UPDATE/DELETE statement of this WHEN [ NOT ] MATCHED clause */
0:     /** the columns in the temporary conglomerate which drives the INSERT/UPDATE/DELETE */
1:     private ResultColumnList        _thenColumns;
0:     private int[]                           _thenColumnOffsets;
1: 
0:     // Filled in at generate() time
1:     private int                             _clauseNumber;
1:     private String                          _actionMethodName;
1:     private String                          _resultSetFieldName;
1:     
/////////////////////////////////////////////////////////////////////////
1:     static  MatchingClauseNode   makeUpdateClause
/////////////////////////////////////////////////////////////////////////
1:     static  MatchingClauseNode   makeDeleteClause
/////////////////////////////////////////////////////////////////////////
1:     static  MatchingClauseNode   makeInsertClause
/////////////////////////////////////////////////////////////////////////
1:     boolean isUpdateClause()    { return (_updateColumns != null); }
1:     boolean isInsertClause()    { return (_insertValues != null); }
1:     boolean isDeleteClause()    { return !( isUpdateClause() || isInsertClause() ); }
0:     DMLModStatementNode getDML()    { return _dml; }
1: 
1:     /**
1:      * Return the list of columns which form the rows of the ResultSet which drive
1:      * the INSERT/UPDATE/DELETE actions.
1:      */
0:     ResultColumnList    getBufferedColumns() { return _thenColumns; }
1: 
/////////////////////////////////////////////////////////////////////////
1:     void    bind
1:         (
1:          DataDictionary dd,
1:          MergeNode mergeNode,
1:          FromList fullFromList,
1:          FromBaseTable targetTable
1:          )
0:         bindExpressions( mergeNode, fullFromList, targetTable );
1:         
1:         if ( isDeleteClause() ) { bindDelete( dd, fullFromList, targetTable ); }
0:         if ( isUpdateClause() ) { bindUpdate( dd, fullFromList, targetTable ); }
1:         if ( isInsertClause() ) { bindInsert( dd, mergeNode, fullFromList, targetTable ); }
0:         bindExpressions( _thenColumns, fullFromList );
1:     /** Bind the optional refinement condition in the MATCHED clause */
1:     void    bindRefinement( MergeNode mergeNode, FromList fullFromList ) throws StandardException
1:     {
1:         if ( _matchingRefinement != null )
1:         {
0:             mergeNode.bindExpression( _matchingRefinement, fullFromList );
1:         }
1:     }
1: 
0:     /** Bind the expressions in this MATCHED clause */
0:     private void    bindExpressions
1:         (
1:          MergeNode mergeNode,
1:          FromList fullFromList,
0:          FromTable targetTable
1:          )
1:         throws StandardException
1:     {
0:         _thenColumns = new ResultColumnList( getContextManager() );
1: 
1:         if ( isUpdateClause() )
1:         {
0:             // needed to make the UpdateNode bind
0:             _updateColumns.replaceOrForbidDefaults( targetTable.getTableDescriptor(), _updateColumns, true );
1: 
0:             bindExpressions( _updateColumns, fullFromList );
1:         }
1:         else if ( isInsertClause() )
1:         {
0:             // needed to make the SelectNode bind
0:             _insertValues.replaceOrForbidDefaults( targetTable.getTableDescriptor(), _insertColumns, true );
0:             bindExpressions( _insertValues, fullFromList );
1:         }
1:     }
1:     
1:     /** Collect the columns mentioned by expressions in this MATCHED clause */
1:     void    getColumnsInExpressions
1:         (
1:          MergeNode  mergeNode,
1:          HashMap<String,ColumnReference> drivingColumnMap
1:          )
1:         throws StandardException
1:     {
1:         if ( _matchingRefinement != null )
1:         {
0:             mergeNode.getColumnsInExpression( drivingColumnMap, _matchingRefinement );
1:         }
1: 
1:         if ( isUpdateClause() )
1:         {
0:             // get all columns mentioned on the right side of SET operators in WHEN MATCHED ... THEN UPDATE clauses
1:             for ( ResultColumn rc : _updateColumns )
1:             {
0:                 mergeNode.getColumnsInExpression( drivingColumnMap, rc.getExpression() );
1:             }
1:         }
1:         else if ( isInsertClause() )
1:         {
1:             // get all columns mentioned in the VALUES subclauses of WHEN NOT MATCHED ... THEN INSERT clauses
1:             for ( ResultColumn rc : _insertValues )
1:             {
0:                 mergeNode.getColumnsInExpression( drivingColumnMap, rc.getExpression() );
1:             }
1:         }
1:     }
1:     
1:     private void    bindUpdate
1:         (
1:          DataDictionary dd,
1:          FromList fullFromList,
0:          FromTable targetTable
1:          )
1:              fullFromList,
/////////////////////////////////////////////////////////////////////////
0:         _dml = new UpdateNode( targetTable.getTableName(), selectNode, this, getContextManager() );
1:     private void    bindDelete
1:         (
1:          DataDictionary dd,
1:          FromList fullFromList,
1:          FromBaseTable targetTable
1:          )
1:         CurrentOfNode   currentOfNode = CurrentOfNode.makeForMerge
0:             ( CURRENT_OF_NODE_NAME, targetTable, getContextManager() );
1:         FromList        fromList = new FromList( getContextManager() );
1:         fromList.addFromTable( currentOfNode );
1:         SelectNode      selectNode = new SelectNode
1:              null,
1:              fromList, /* FROM list */
1:              null, /* WHERE clause */
1:              null, /* GROUP BY list */
1:              null, /* having clause */
1:              null, /* window list */
1:              null, /* optimizer plan override */
0:         _dml = new DeleteNode( targetTable.getTableName(), selectNode, this, getContextManager() );
1: 
0:         ResultColumnList    deleteSignature = _dml.resultSet.resultColumns;
0:         for ( int i = 0; i < deleteSignature.size(); i++ )
1:         {
0:             ResultColumn    origRC = deleteSignature.elementAt( i );
1:             ResultColumn    newRC;
1:             ValueNode       expression = origRC.getExpression();
1: 
1:             if ( expression instanceof ColumnReference )
1:             {
1:                 ColumnReference cr = (ColumnReference) ((ColumnReference) expression).getClone();
1:                 newRC = new ResultColumn( cr, cr, getContextManager() );
1:             }
1:             else
1:             {
1:                 newRC = origRC.cloneMe();
1:             }
1:             _thenColumns.addResultColumn( newRC );
1:         }
1:     private void    bindInsert
1:         (
1:          DataDictionary dd,
1:          MergeNode  mergeNode,
1:          FromList fullFromList,
0:          FromTable targetTable
1:          )
0:         FromList    targetTableFromList = new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() );
0:         targetTableFromList.addElement( fullFromList.elementAt( 0 ) );
0:         bindExpressions( _insertValues, targetTableFromList );
1:         if ( _matchingRefinement != null )
1:         {
0:             mergeNode.bindExpression( _matchingRefinement, targetTableFromList );
1:         }
0:              fullFromList,
/////////////////////////////////////////////////////////////////////////
1:              this,      // in NOT MATCHED clause
/////////////////////////////////////////////////////////////////////////
0:     /** Boilerplate for binding a list of ResultColumns against a FromList */
0:     private void bindExpressions( ResultColumnList rcl, FromList fromList )
1:         throws StandardException
0:     {
0:         CompilerContext cc = getCompilerContext();
0:         final int previousReliability = cc.getReliability();
1:         
0:         try {
0:             cc.setReliability( previousReliability | CompilerContext.SQL_IN_ROUTINES_ILLEGAL );
1:             
0:             rcl.bindExpressions
1:                 (
0:                  fromList,
0:                  new SubqueryList( getContextManager() ),
0:                  new ArrayList<AggregateNode>()
1:                  );
0:         }
0:         finally
0:         {
0:             // Restore previous compiler state
0:             cc.setReliability( previousReliability );
0:         }
0:     }
1: 
1:     /**
0:      * <p>
0:      * Calculate the 1-based offsets which define the rows which will be buffered up
0:      * for this INSERT/UPDATE/DELETE action at run-time. The rows are constructed
0:      * from the columns in the SELECT list of the driving left joins. This method
0:      * calculates an array of offsets into the SELECT list. The columns at those
0:      * offsets will form the row which is buffered up for the INSERT/UPDATE/DELETE
0:      * action.
0:      * </p>
1:      */
0:     void    bindThenColumns( ResultColumnList selectList )
1:         throws StandardException
0:     {
0:         int     bufferedCount = _thenColumns.size();
0:         int     selectCount = selectList.size();
1:         
0:         _thenColumnOffsets = new int[ bufferedCount ];
1: 
0:         for ( int bidx = 0; bidx < bufferedCount; bidx++ )
0:         {
0:             ResultColumn    bufferedRC = _thenColumns.elementAt( bidx );
0:             ValueNode       bufferedExpression = bufferedRC.getExpression();
0:             int                     offset = -1;    // start out undefined
1: 
0:             if ( bufferedExpression instanceof ColumnReference )
0:             {
0:                 ColumnReference bufferedCR = (ColumnReference) bufferedExpression;
0:                 String              tableName = bufferedCR.getTableName();
0:                 String              columnName = bufferedCR.getColumnName();
1: 
0:                 // loop through the SELECT list to find this column reference
0:                 for ( int sidx = 0; sidx < selectCount; sidx++ )
0:                 {
0:                     ResultColumn    selectRC = selectList.elementAt( sidx );
0:                     ValueNode       selectExpression = selectRC.getExpression();
0:                     ColumnReference selectCR = selectExpression instanceof ColumnReference ?
0:                         (ColumnReference) selectExpression : null;
1: 
0:                     if ( selectCR != null )
0:                     {
0:                         if (
0:                             tableName.equals( selectCR.getTableName() ) &&
0:                             columnName.equals( selectCR.getColumnName() )
0:                             )
0:                         {
0:                             offset = sidx + 1;
0:                             break;
0:                         }
0:                     }
0:                 }
0:             }
0:             else if ( bufferedExpression instanceof CurrentRowLocationNode )
0:             {
1:                 //
0:                 // There is only one RowLocation in the SELECT list, the row location for the
0:                 // tuple from the target table. The RowLocation is always the last column in
0:                 // the SELECT list.
1:                 //
0:                 offset = selectCount;
0:             }
1: 
0:             _thenColumnOffsets[ bidx ] = offset;
0:         }
0:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // optimize() BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * <p>
1:      * Optimize the INSERT/UPDATE/DELETE action.
0:      * </p>
1:      */
1:     void    optimize()  throws StandardException
0:     {
1:         _dml.optimizeStatement();
0:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // generate() BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ConstantAction makeConstantAction( ActivationClassBuilder acb )
1:         throws StandardException
0: 	{
1:         // generate the clause-specific refinement
1:         String  refinementName = null;
0:         if ( _matchingRefinement != null )
0:         {
1:             MethodBuilder userExprFun = acb.newUserExprFun();
1: 
1:             _matchingRefinement.generateExpression( acb, userExprFun );
1:             userExprFun.methodReturn();
1: 		
1:             // we are done modifying userExprFun, complete it.
1:             userExprFun.complete();
1: 
1:             refinementName = userExprFun.getName();
0:         }
1:         
1:         return	getGenericConstantActionFactory().getMatchingClauseConstantAction
1:             (
1:              getClauseType(),
1:              refinementName,
0:              _thenColumnOffsets,
1:              _resultSetFieldName,
1:              _actionMethodName,
1:              _dml.makeConstantAction()
1:              );
0: 	}
1:     private int getClauseType()
0:     {
1:         if ( isUpdateClause() ) { return ConstantAction.WHEN_MATCHED_THEN_UPDATE; }
1:         else if ( isInsertClause() ) { return ConstantAction.WHEN_NOT_MATCHED_THEN_INSERT; }
1:         else { return ConstantAction.WHEN_MATCHED_THEN_DELETE; }
0:     }
1: 
1:     /**
0:      * <p>
1:      * Generate a method to invoke the INSERT/UPDATE/DELETE action. This method
1:      * will be called at runtime by MatchingClauseConstantAction.executeConstantAction().
0:      * </p>
1:      */
0:     void    generate( ActivationClassBuilder acb, int clauseNumber )
1:         throws StandardException
0:     {
1:         _clauseNumber = clauseNumber;
1:         _actionMethodName = "mergeActionMethod_" + _clauseNumber;
1:         
1:         MethodBuilder mb = acb.getClassBuilder().newMethodBuilder
1:             (
1:              Modifier.PUBLIC,
1:              ClassName.ResultSet,
1:              _actionMethodName
1:              );
1:         mb.addThrownException(ClassName.StandardException);
1: 
1:         // now generate the action into this method
1:         _dml.generate( acb, mb );
1:         
1:         mb.methodReturn();
1:         mb.complete();
0:     }
1: 
1:     /**
0:      * <p>
0:      * Adds a field to the generated class to hold the ResultSet of buffered rows
1:      * which drive the INSERT/UPDATE/DELETE action. Generates code to push
1:      * the contents of that field onto the stack.
0:      * </p>
1:      */
1:     void    generateResultSetField( ActivationClassBuilder acb, MethodBuilder mb )
1:         throws StandardException
0:     {
1:         _resultSetFieldName = "mergeResultSetField_" + _clauseNumber;
1:         
1:         // make the field public so we can stuff it at execution time
1:         LocalField  resultSetField = acb.newFieldDeclaration( Modifier.PUBLIC, ClassName.NoPutResultSet, _resultSetFieldName );
1: 
1:         //
1:         // At runtime, MatchingClauseConstantAction.executeConstantAction()
1:         // will stuff the resultSetField with the temporary table which collects
1:         // the rows relevant to this action. We want to push the value of resultSetField
1:         // onto the stack, where it will be the ResultSet argument to the constructor
1:         // of the actual INSERT/UPDATE/DELETE action.
1:         //
1:         mb.getField( resultSetField );
0:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // Visitable BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Accept the visitor for all visitable children of this node.
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1:     @Override
1: 	void acceptChildren(Visitor v)
1: 		throws StandardException
0: 	{
1: 		super.acceptChildren( v );
1: 
1:         if ( _matchingRefinement != null ) { _matchingRefinement.accept( v ); }
1:         if ( _updateColumns != null ) { _updateColumns.accept( v ); }
1:         if ( _insertColumns != null ) { _insertColumns.accept( v ); }
1:         if ( _insertValues != null ) { _insertValues.accept( v ); }
1: 
1:         if ( _dml != null ) { _dml.accept( v ); }
0: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1:     @Override
1: 	public String toString()
0: 	{
1:         if ( isUpdateClause() ) { return "UPDATE"; }
1:         else if ( isInsertClause() ) { return "INSERT"; }
1:         else { return "DELETE"; }
0: 	}
1: 
commit:661c2e6
/////////////////////////////////////////////////////////////////////////
1: /*
0: 
1:    Derby - Class org.apache.derby.impl.sql.compile.MatchingClauseNode
0: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
0: 
1:       http://www.apache.org/licenses/LICENSE-2.0
0: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
0: 
0:  */
0: 
1: package	org.apache.derby.impl.sql.compile;
0: 
1: import java.util.ArrayList;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.shared.common.sanity.SanityManager;
0: 
0: /**
1:  * Node representing a WHEN MATCHED or WHEN NOT MATCHED clause
1:  * in a MERGE statement.
1:  *
0:  */
0: 
1: public class MatchingClauseNode extends QueryTreeNode
0: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
0: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
0: 
0:     // filled in by the constructor
1:     private ValueNode           _matchingRefinement;
1:     private ResultColumnList    _updateColumns;
1:     private ResultColumnList    _insertColumns;
1:     private ResultColumnList    _insertValues;
0: 
0:     // filled in at bind() time
1:     private DMLModStatementNode _dml;
0: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTORS/FACTORY METHODS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:      * Constructor called by factory methods.
0:      */
1:     private MatchingClauseNode
1:         (
1:          ValueNode  matchingRefinement,
1:          ResultColumnList   updateColumns,
1:          ResultColumnList   insertColumns,
1:          ResultColumnList   insertValues,
1:          ContextManager     cm
0:          )
0:     {
1:         super( cm );
0:         
1:         _matchingRefinement = matchingRefinement;
1:         _updateColumns = updateColumns;
1:         _insertColumns = insertColumns;
1:         _insertValues = insertValues;
0:     }
0: 
1:     /** Make a WHEN MATCHED ... THEN UPDATE clause */
0:     public  static  MatchingClauseNode   makeUpdateClause
1:         (
1:          ValueNode  matchingRefinement,
1:          ResultColumnList   updateColumns,
1:          ContextManager     cm
0:          )
0:     {
1:         return new MatchingClauseNode( matchingRefinement, updateColumns, null, null, cm );
0:     }
0: 
1:     /** Make a WHEN MATCHED ... THEN DELETE clause */
0:     public  static  MatchingClauseNode   makeDeleteClause
1:         (
1:          ValueNode  matchingRefinement,
1:          ContextManager     cm
0:          )
0:     {
1:         return new MatchingClauseNode( matchingRefinement, null, null, null, cm );
0:     }
0: 
1:     /** Make a WHEN NOT MATCHED ... THEN INSERT clause */
0:     public  static  MatchingClauseNode   makeInsertClause
1:         (
1:          ValueNode  matchingRefinement,
1:          ResultColumnList   insertColumns,
1:          ResultColumnList   insertValues,
1:          ContextManager     cm
0:          )
0:     {
1:         return new MatchingClauseNode( matchingRefinement, null, insertColumns, insertValues, cm );
0:     }
0: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // ACCESSORS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
0: 
1:     /** Return true if this is a WHEN MATCHED ... UPDATE clause */
0:     public  boolean isUpdateClause()    { return (_updateColumns != null); }
0:     
1:     /** Return true if this is a WHEN NOT MATCHED ... INSERT clause */
0:     public  boolean isInsertClause()    { return (_insertValues != null); }
0:     
1:     /** Return true if this is a WHEN MATCHED ... DELETE clause */
0:     public  boolean isDeleteClause()    { return !( isUpdateClause() || isInsertClause() ); }
0: 
0:     /** Return the bound DML statement--returns null if called before binding */
0:     public  DMLModStatementNode getDML()    { return _dml; }
0:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
0:     // bind() BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
0: 
0:     /** Bind this WHEN [ NOT ] MATCHED clause against the parent JoinNode */
0:     public void    bind( JoinNode joinNode, FromTable targetTable )
0:         throws StandardException
0:     {
0:         String  clauseType = isInsertClause() ? "WHEN NOT MATCHED" : "WHEN MATCHED";
0: 
0:         // For WHEN NOT MATCHED clauses, the target table is not in scope.
0:         boolean useTargetTable = !isInsertClause();
0: 
0:         if ( _matchingRefinement != null )
0:         {
0:             _matchingRefinement = joinNode.bindExpression
0:                 ( _matchingRefinement, true, useTargetTable, clauseType );
0:         }
0: 
0:         if ( isDeleteClause() ) { bindDelete( joinNode, targetTable ); }
0:         if ( isUpdateClause() ) { bindUpdate( joinNode, targetTable ); }
0:         if ( isInsertClause() ) { bindInsert( joinNode, targetTable ); }
0:     }
0: 
1:     /** Bind a WHEN MATCHED ... THEN UPDATE clause */
0:     private void    bindUpdate( JoinNode joinNode, FromTable targetTable )
0:         throws StandardException
0:     {
1:         SelectNode  selectNode = new SelectNode
1:             (
0:              _updateColumns,
0:              joinNode.makeFromList( true, true ),
1:              null,      // where clause
1:              null,      // group by list
1:              null,      // having clause
1:              null,      // window list
1:              null,      // optimizer plan override
1:              getContextManager()
1:              );
0:         _dml = new UpdateNode( targetTable.getTableName(), selectNode, true, getContextManager() );
0: 
1:         _dml.bindStatement();
0:     }
0:     
1:     /** Bind a WHEN MATCHED ... THEN DELETE clause */
0:     private void    bindDelete( JoinNode joinNode, FromTable targetTable )
0:         throws StandardException
0:     {
1:         SelectNode  selectNode = new SelectNode
1:             (
0:              null,      // select list
0:              joinNode.makeFromList( true, true ),
1:              null,      // where clause
1:              null,      // group by list
1:              null,      // having clause
1:              null,      // window list
1:              null,      // optimizer plan override
1:              getContextManager()
1:              );
0:         _dml = new DeleteNode( targetTable.getTableName(), selectNode, getContextManager() );
0: 
1:         _dml.bindStatement();
0:     }
0: 
1:     /** Bind a WHEN NOT MATCHED ... THEN INSERT clause */
0:     private void    bindInsert( JoinNode joinNode, FromTable targetTable )
0:         throws StandardException
0:     {
0:         // needed to make the SelectNode bind
0:         _insertValues.replaceOrForbidDefaults( targetTable.getTableDescriptor(), _insertColumns, true );
0: 
1:         // the VALUES clause may not mention columns in the target table
0:         _insertValues.bindExpressions
1:             (
0:              joinNode.makeFromList( true, false ),
0:              new SubqueryList( getContextManager() ),
0:              new ArrayList<AggregateNode>()
1:              );
0:         
1:         SelectNode  selectNode = new SelectNode
1:             (
0:              _insertValues,      // select list
0:              joinNode.makeFromList( true, true ),
1:              null,      // where clause
1:              null,      // group by list
1:              null,      // having clause
1:              null,      // window list
1:              null,      // optimizer plan override
1:              getContextManager()
1:              );
1:         _dml = new InsertNode
1:             (
0:              targetTable.getTableName(),
1:              _insertColumns,
1:              selectNode,
1:              null,      // targetProperties
1:              null,      // order by cols
1:              null,      // offset
1:              null,      // fetch first
1:              false,     // has JDBC limit clause
1:              getContextManager()
1:              );
0: 
1:         _dml.bindStatement();
0:     }
0: 
0: }
============================================================================