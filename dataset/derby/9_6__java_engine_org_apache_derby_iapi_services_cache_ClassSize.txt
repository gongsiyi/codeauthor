1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.services.cache.ClassSize
1:7ecc1f2: 
1:6baf18b:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6baf18b:    contributor license agreements.  See the NOTICE file distributed with
1:6baf18b:    this work for additional information regarding copyright ownership.
1:6baf18b:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6baf18b:    (the "License"); you may not use this file except in compliance with
1:6baf18b:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
4:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.services.cache;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import java.lang.reflect.Field;
1:eac0369: import java.lang.reflect.Modifier;
1:2365e78: import java.security.AccessController;
1:2365e78: import java.security.PrivilegedAction;
1:2365e78: import java.util.Arrays;
1:eac0369: 
1:eac0369: public class ClassSize
2:eac0369: {
1:eac0369:     public static final int refSize;
1:eac0369:     private static final int objectOverhead = 2; // references, not bytes!
1:eac0369:     private static final int booleanSize = 4;
1:eac0369:     private static final int charSize = 4; // Unicode
1:eac0369:     private static final int shortSize = 4;
1:eac0369:     private static final int intSize = 4;
1:eac0369:     private static final int longSize = 8;
1:eac0369:     private static final int floatSize = 4;
1:eac0369:     private static final int doubleSize = 8;
1:eac0369:     private static final int minObjectSize;
1:eac0369: 
1:eac0369:     private static boolean dummyCatalog = false; // Used when constructing the catalog to prevent recursion
1:eac0369: 
1:eac0369:     static boolean noGuess = false;
1:eac0369:     // noGuess is used in unit testing.
1:eac0369: 
1:eac0369:     static boolean unitTest = false;
1:eac0369:     // unitTest is used in unit testing
1:eac0369: 
1:eac0369:     private static final int[] wildGuess = {0,16};
1:eac0369:     /* The standard wild guess of the size of an unknown class, the size of 16 references.
1:eac0369:      * Used when the security manager will not let us look at the class fields.
1:eac0369:      */
1:eac0369: 
1:eac0369:     static
1:eac0369:     {
1:eac0369:         // Figure out whether this is a 32 or 64 bit machine.
1:2365e78:         int tmpRefSize = fetchRefSizeFromSystemProperties();
1:2365e78:         // If we didn't understand the properties, or were not allowed to read
1:2365e78:         // them, use a heuristic.
1:2365e78:         if (tmpRefSize < 4) {
1:2365e78:             Runtime runtime = Runtime.getRuntime();
1:2365e78:             runtime.gc();
1:2365e78:             runtime.runFinalization();
1:2365e78:             long memBase = runtime.totalMemory() - runtime.freeMemory();
1:2365e78:             Object[] junk = new Object[10000];
1:2365e78:             runtime.gc();
1:2365e78:             runtime.runFinalization();
1:2365e78:             long memUsed = runtime.totalMemory() - runtime.freeMemory() - memBase;
1:2365e78:             int sz = (int)((memUsed + junk.length/2)/junk.length);
1:2365e78:             tmpRefSize = ( 4 > sz) ? 4 : sz;
1:2365e78:         }
1:2365e78:         // Assign what we have found to the final variable.
1:2365e78:         refSize = tmpRefSize;
1:eac0369:         minObjectSize = 4*refSize;
2:eac0369:     }
1:eac0369: 
2:eac0369:     /**
1:eac0369:      * do not try to use the catalog.
1:eac0369:      */
1:eac0369:     public static void setDummyCatalog()
1:eac0369:     {
1:eac0369:         dummyCatalog = true;
1:eac0369:     }
1:eac0369:     /**
1:eac0369:      * Get the estimate of the size of an object reference.
1:eac0369:      *
1:eac0369:      * @return the estimate in bytes.
1:eac0369:      */
1:eac0369:     public static int getRefSize()
1:eac0369:     {
1:eac0369:         return refSize;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * @return the estimate of the size of a primitive int
1:eac0369:      */
1:eac0369:     public static int getIntSize()
1:eac0369:     {
1:eac0369:         return intSize;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The estimate of the size of a class instance depends on whether the JVM uses 32 or 64
1:eac0369:      * bit addresses, that is it depends on the size of an object reference. It is a linear
1:eac0369:      * function of the size of a reference, e.g.
1:eac0369:      *    24 + 5*r
1:eac0369:      * where r is the size of a reference (usually 4 or 8 bytes).
1:eac0369:      *
1:eac0369:      * This method returns the coefficients of the linear function, e.g. {24, 5} in the above
1:eac0369:      * example.
1:eac0369:      *
1:eac0369:      * @param cl A class whose instance size is to be estimated
1:eac0369:      * @return an array of 2 integers. The first integer is the constant part of the function,
1:eac0369:      *         the second is the reference size coefficient.
1:eac0369:      */
1:eac0369:     public static int[] getSizeCoefficients( Class cl)
1:eac0369:     {
1:eac0369:         int[] coeff = {0, objectOverhead};
1:eac0369: 
1:eac0369: 
1:eac0369:         
1:eac0369:         for( ; null != cl; cl = cl.getSuperclass())
1:eac0369:         {
1:eac0369:            Field[] field = cl.getDeclaredFields();
1:eac0369:             if( null != field)
1:eac0369:             {
1:eac0369:                 for( int i = 0; i < field.length; i++)
1:eac0369:                 {
1:eac0369:                     if( ! Modifier.isStatic( field[i].getModifiers()))
1:eac0369:                     {
1:eac0369:                         Class fieldClass = field[i].getType();
1:eac0369:                         if( fieldClass.isArray() || ! fieldClass.isPrimitive())
1:eac0369:                             coeff[1]++;
1:eac0369:                         else // Is simple primitive
1:eac0369:                         {
1:eac0369:                             String name = fieldClass.getName();
1:eac0369: 
1:eac0369:                             if( name.equals( "int") || name.equals( "I"))
1:eac0369:                                 coeff[0] += intSize;
1:eac0369:                             else if( name.equals( "long") || name.equals( "J"))
1:eac0369:                                 coeff[0] += longSize;
1:eac0369:                             else if( name.equals( "boolean") || name.equals( "Z"))
1:eac0369:                                 coeff[0] += booleanSize;
1:eac0369:                             else if( name.equals( "short") || name.equals( "S"))
1:eac0369:                                 coeff[0] += shortSize;
1:eac0369:                             else if( name.equals( "byte") || name.equals( "B"))
1:eac0369:                                 coeff[0] += 1;
1:eac0369:                             else if( name.equals( "char") || name.equals( "C"))
1:eac0369:                                 coeff[0] += charSize;
1:eac0369:                             else if( name.equals( "float") || name.equals( "F"))
1:eac0369:                                 coeff[0] += floatSize;
1:eac0369:                             else if( name.equals( "double") || name.equals( "D"))
1:eac0369:                                 coeff[0] += doubleSize;
1:eac0369:                             else // What is this??
1:eac0369:                                 coeff[1]++; // Make a guess: one reference (?)
1:eac0369:                         }
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369:         return coeff;
1:eac0369:     } // end of getSizeCoefficients
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Estimate the static space taken up by a class instance given the coefficients
1:eac0369:      * returned by getSizeCoefficients.
1:eac0369:      *
1:eac0369:      * @param coeff the coefficients
1:eac0369:      *
1:eac0369:      * @return the size estimate, in bytes
1:eac0369:      */
1:eac0369:     public static int estimateBaseFromCoefficients( int[] coeff)
1:eac0369:     {
1:eac0369:         int size = coeff[0] + coeff[1]*refSize;
1:eac0369:         // Round up to a multiple of 8
1:eac0369:         size = (size + 7)/8;
1:eac0369:         size *= 8;
1:eac0369:         return (size < minObjectSize) ? minObjectSize : size;
1:eac0369:     } // end of estimateBaseFromCoefficients
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Estimate the static space taken up by a class instance from cataloged coefficients.
1:eac0369:      *
1:eac0369:      * @param cls the class
1:eac0369:      *
1:eac0369:      * @return the size estimate, in bytes
1:eac0369:      *
1:eac0369:      * @see #estimateBaseFromCoefficients
1:eac0369:      * @see #getSizeCoefficients
1:d1d5ad1:      * see org.apache.derbyBuild.ClassSizeCrawler
1:eac0369:      */
1:eac0369:     public static int estimateBaseFromCatalog( Class cls)
1:eac0369:     {
1:eac0369:         return estimateBaseFromCatalog( cls, false);
1:eac0369:     }
1:eac0369:     
1:073b862:     private static int estimateBaseFromCatalog( Class<?> cls, boolean addToCatalog)
1:eac0369:     {
1:eac0369:         if( dummyCatalog)
1:eac0369:             return 0;
1:8b47bc7: 
1:8b47bc7:         ClassSizeCatalog catalog = ClassSizeCatalog.getInstance();
1:8b47bc7: 
1:eac0369:         if( SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT( catalog != null, "The class size catalog could not be initialized.");
1:eac0369:         
1:8b47bc7:         int[] coeff = catalog.get(cls.getName());
1:eac0369:         if( coeff == null)
1:eac0369:         {
2:eac0369:             try
1:eac0369:             {
1:eac0369:                 coeff = getSizeCoefficients( cls);
1:eac0369:             }
1:eac0369:             catch( Throwable t)
1:eac0369:             {
1:eac0369:                 if( noGuess)
1:eac0369:                     return -2;
1:eac0369:                 coeff = wildGuess;
1:eac0369:             }
1:eac0369:             if( addToCatalog)
1:eac0369:                 catalog.put( cls.getName(), coeff);
1:eac0369:         }
1:eac0369:         return estimateBaseFromCoefficients( coeff);
1:eac0369:     } // end of estimateBaseFromCatalog
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Estimate the static space taken up by a class instance. Save the coefficients
1:eac0369:      * in a catalog.
1:eac0369:      *
1:eac0369:      * @param cls the class
1:eac0369:      *
1:eac0369:      * @return the size estimate, in bytes
1:eac0369:      *
1:eac0369:      * @see #estimateBaseFromCoefficients
1:eac0369:      * @see #getSizeCoefficients
1:d1d5ad1:      * see org.apache.derbyBuild.ClassSizeCrawler
1:eac0369:      */
1:eac0369:     public static int estimateAndCatalogBase( Class cls)
1:eac0369:     {
1:eac0369:         return estimateBaseFromCatalog( cls, true);
1:eac0369:     } // end of estimateAndCatalogBase
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Estimate the static space taken up by the fields of a class. This includes the space taken
1:eac0369:      * up by by references (the pointer) but not by the referenced object. So the estimated
1:eac0369:      * size of an array field does not depend on the size of the array. Similarly the size of
1:eac0369:      * an object (reference) field does not depend on the object.
1:eac0369:      *
1:eac0369:      * @return the size estimate in bytes.
1:eac0369:      *
1:eac0369:      * Note that this method will throw a SecurityException if the SecurityManager does not
1:eac0369:      * let this class execute the method Class.getDeclaredFields(). If this is a concern try
1:eac0369:      * to compute the size coefficients at build time.
1:d1d5ad1:      * see org.apache.derbyBuild.ClassSizeCrawler
1:eac0369:      * @see #estimateBaseFromCatalog
1:eac0369:      */
1:eac0369:     public static int estimateBase( Class cl)
1:eac0369:     {
1:eac0369:         return estimateBaseFromCoefficients( getSizeCoefficients( cl));
1:eac0369:     } // End of estimateBase
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * @return the estimated overhead of an array. The estimated size of an x[n] array is
1:eac0369:      * estimateArrayOverhead() + n*sizeOf(x).
1:eac0369:      */
1:eac0369:     public static int estimateArrayOverhead()
1:eac0369:     {
1:eac0369:         return minObjectSize;
1:eac0369:     }
1:eac0369:     
1:eac0369:     /**
1:eac0369:      * Estimate the size of a Hashtable entry. In Java 1.2 we can use Map.entry, but this is not
1:eac0369:      * available in earlier versions of Java.
1:eac0369:      *
1:eac0369:      * @return the estimate, in bytes
1:eac0369:      */
1:eac0369:     public static int estimateHashEntrySize()
1:eac0369:     {
1:eac0369:         return objectOverhead + 3*refSize;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Estimate the size of a string.
1:eac0369:      *
1:eac0369:      * @return the estimated size, in bytes
1:eac0369:      */
1:eac0369:     public static int estimateMemoryUsage( String str)
1:eac0369:     {
1:eac0369:         if( null == str)
1:eac0369:             return 0;
1:eac0369:         // Since Java uses Unicode assume that each character takes 2 bytes
1:eac0369:         return 2*str.length();
1:eac0369:     }
1:2365e78: 
1:2365e78:     /**
1:2365e78:      * Tries to determine the reference size in bytes by checking whether the
1:2365e78:      * VM we're running in is 32 or 64 bit by looking at the system properties.
1:2365e78:      *
1:2365e78:      * @return The reference size in bytes as specified or implied by the VM,
1:2365e78:      *      or {@code -1} if the reference size couldn't be determined.
1:2365e78:      */
1:2365e78:     private static final int fetchRefSizeFromSystemProperties() {
1:2365e78:         // Try the direct way first, by looking for 'sun.arch.data.model'
1:2365e78:         String dataModel = getSystemProperty("sun.arch.data.model");
1:2365e78:         try {
1:ce40a31:             return Integer.parseInt(dataModel) / 8;
1:2365e78:         } catch (NumberFormatException ignoreNFE) {}
1:2365e78: 
1:2365e78:         // Try 'os.arch'
1:2365e78:         String arch = getSystemProperty("os.arch");
1:2365e78:         // See if we recognize the property value.
1:2365e78:         if (arch != null) {
1:2365e78:             // Is it a known 32 bit architecture?
1:2365e78:             String[] b32 = new String[] {"i386", "x86", "sparc"};
1:2365e78:             if (Arrays.asList(b32).contains(arch)) return 4; // 4 bytes per ref
1:2365e78:             // Is it a known 64 bit architecture?
1:2365e78:             String[] b64 = new String[] {"amd64", "x86_64", "sparcv9"};
1:2365e78:             if (Arrays.asList(b64).contains(arch)) return 8; // 8 bytes per ref
1:2365e78:         }
1:2365e78: 
1:2365e78:         // Didn't find out anything.
1:2365e78:         if (SanityManager.DEBUG) {
1:2365e78:             SanityManager.DEBUG_PRINT(
1:2365e78:                     "REFSIZE", "Bitness undetermined, sun.arch.data.model='" +
1:2365e78:                     dataModel + "', os.arch='" + arch + "'");
1:2365e78:         }
1:2365e78:         return -1;
1:2365e78:     }
1:2365e78: 
1:2365e78:     /**
1:2365e78:      * Attempts to read the specified system property.
1:2365e78:      *
1:2365e78:      * @param propName name of the system property to read
1:2365e78:      * @return The property value, or {@code null} if it doesn't exist or the
1:2365e78:      *      required permission to read the property is missing.
1:2365e78:      */
1:2365e78:     private static final String getSystemProperty(final String propName) {
1:2365e78:         try {
1:073b862:             return AccessController.doPrivileged(
1:073b862:                     new PrivilegedAction<String>() {
1:073b862:                         public String run() {
1:2365e78:                             return System.getProperty(propName, null);
1:2365e78:                         }
1:2365e78:                 });
1:2365e78:         } catch (SecurityException se) {
1:2365e78:             // Ignore exception and return null.
1:2365e78:             return null;
1:2365e78:         }
1:2365e78:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:             return Integer.parseInt(dataModel) / 8;
commit:073b862
/////////////////////////////////////////////////////////////////////////
0: @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
0:     private static java.util.Hashtable<String,int[]> catalog;
0:             catalog = (java.util.Hashtable<String,int[]>)
/////////////////////////////////////////////////////////////////////////
1:     private static int estimateBaseFromCatalog( Class<?> cls, boolean addToCatalog)
/////////////////////////////////////////////////////////////////////////
1:             return AccessController.doPrivileged(
1:                     new PrivilegedAction<String>() {
1:                         public String run() {
commit:6baf18b
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8b47bc7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         ClassSizeCatalog catalog = ClassSizeCatalog.getInstance();
1: 
1:         int[] coeff = catalog.get(cls.getName());
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:2365e78
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
0:         catch( Exception e){}
1:         int tmpRefSize = fetchRefSizeFromSystemProperties();
1:         // If we didn't understand the properties, or were not allowed to read
1:         // them, use a heuristic.
1:         if (tmpRefSize < 4) {
1:             Runtime runtime = Runtime.getRuntime();
1:             runtime.gc();
1:             runtime.runFinalization();
1:             long memBase = runtime.totalMemory() - runtime.freeMemory();
1:             Object[] junk = new Object[10000];
1:             runtime.gc();
1:             runtime.runFinalization();
1:             long memUsed = runtime.totalMemory() - runtime.freeMemory() - memBase;
1:             int sz = (int)((memUsed + junk.length/2)/junk.length);
1:             tmpRefSize = ( 4 > sz) ? 4 : sz;
1:         }
1:         // Assign what we have found to the final variable.
1:         refSize = tmpRefSize;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Tries to determine the reference size in bytes by checking whether the
1:      * VM we're running in is 32 or 64 bit by looking at the system properties.
1:      *
1:      * @return The reference size in bytes as specified or implied by the VM,
1:      *      or {@code -1} if the reference size couldn't be determined.
1:      */
1:     private static final int fetchRefSizeFromSystemProperties() {
1:         // Try the direct way first, by looking for 'sun.arch.data.model'
1:         String dataModel = getSystemProperty("sun.arch.data.model");
1:         try {
0:             return (new Integer(dataModel).intValue() / 8);
1:         } catch (NumberFormatException ignoreNFE) {}
1: 
1:         // Try 'os.arch'
1:         String arch = getSystemProperty("os.arch");
1:         // See if we recognize the property value.
1:         if (arch != null) {
1:             // Is it a known 32 bit architecture?
1:             String[] b32 = new String[] {"i386", "x86", "sparc"};
1:             if (Arrays.asList(b32).contains(arch)) return 4; // 4 bytes per ref
1:             // Is it a known 64 bit architecture?
1:             String[] b64 = new String[] {"amd64", "x86_64", "sparcv9"};
1:             if (Arrays.asList(b64).contains(arch)) return 8; // 8 bytes per ref
1:         }
1: 
1:         // Didn't find out anything.
1:         if (SanityManager.DEBUG) {
1:             SanityManager.DEBUG_PRINT(
1:                     "REFSIZE", "Bitness undetermined, sun.arch.data.model='" +
1:                     dataModel + "', os.arch='" + arch + "'");
1:         }
1:         return -1;
1:     }
1: 
1:     /**
1:      * Attempts to read the specified system property.
1:      *
1:      * @param propName name of the system property to read
1:      * @return The property value, or {@code null} if it doesn't exist or the
1:      *      required permission to read the property is missing.
1:      */
1:     private static final String getSystemProperty(final String propName) {
1:         try {
0:             return (String)AccessController.doPrivileged(
0:                     new PrivilegedAction() {
0:                         public Object run() {
1:                             return System.getProperty(propName, null);
1:                         }
1:                 });
1:         } catch (SecurityException se) {
1:             // Ignore exception and return null.
1:             return null;
1:         }
1:     }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:b437b6c
/////////////////////////////////////////////////////////////////////////
0:         runtime.gc();
0:         runtime.runFinalization();
0:         runtime.gc();
0:         runtime.runFinalization();
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:d1d5ad1
/////////////////////////////////////////////////////////////////////////
1:      * see org.apache.derbyBuild.ClassSizeCrawler
/////////////////////////////////////////////////////////////////////////
1:      * see org.apache.derbyBuild.ClassSizeCrawler
/////////////////////////////////////////////////////////////////////////
1:      * see org.apache.derbyBuild.ClassSizeCrawler
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.services.cache.ClassSize
1: 
0:    Copyright 2002, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.cache
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.services.cache;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import java.lang.Class;
1: import java.lang.reflect.Field;
0: import java.lang.Runtime;
0: import java.lang.InterruptedException;
1: import java.lang.reflect.Modifier;
1: 
1: public class ClassSize
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
1:     public static final int refSize;
1:     private static final int objectOverhead = 2; // references, not bytes!
1:     private static final int booleanSize = 4;
1:     private static final int charSize = 4; // Unicode
1:     private static final int shortSize = 4;
1:     private static final int intSize = 4;
1:     private static final int longSize = 8;
1:     private static final int floatSize = 4;
1:     private static final int doubleSize = 8;
1:     private static final int minObjectSize;
1: 
1:     private static boolean dummyCatalog = false; // Used when constructing the catalog to prevent recursion
1: 
1:     static boolean noGuess = false;
1:     // noGuess is used in unit testing.
1: 
1:     static boolean unitTest = false;
1:     // unitTest is used in unit testing
1: 
1:     private static final int[] wildGuess = {0,16};
1:     /* The standard wild guess of the size of an unknown class, the size of 16 references.
1:      * Used when the security manager will not let us look at the class fields.
1:      */
1: 
0:     /* Do not let the compiler see ClassSizeCatalog. Otherwise it will try to
0:      * compile it. This may fail because ClassSizeCatalog.java is not created
0:      * until everything else has been compiled. Bury ClassSizeCatalog in a string.
1:      */
0:     private static java.util.Hashtable catalog;
1:     static
1:     {
1:         try
1:         {
0:             catalog = (java.util.Hashtable)
0:               Class.forName( "org.apache.derby.iapi.services.cache.ClassSizeCatalog").newInstance();
1:         }
0:         catch( Exception e){};
1: 
1:         // Figure out whether this is a 32 or 64 bit machine.
0:         Runtime runtime = Runtime.getRuntime();
0:         long memBase = runtime.totalMemory() - runtime.freeMemory();
0:         Object[] junk = new Object[10000];
0:         long memUsed = runtime.totalMemory() - runtime.freeMemory() - memBase;
0:         int sz = (int)((memUsed + junk.length/2)/junk.length);
0:         refSize = ( 4 > sz) ? 4 : sz;
1:         minObjectSize = 4*refSize;
1:     }
1: 
1:     /**
1:      * do not try to use the catalog.
1:      */
1:     public static void setDummyCatalog()
1:     {
1:         dummyCatalog = true;
1:     }
1:     /**
1:      * Get the estimate of the size of an object reference.
1:      *
1:      * @return the estimate in bytes.
1:      */
1:     public static int getRefSize()
1:     {
1:         return refSize;
1:     }
1: 
1:     /**
1:      * @return the estimate of the size of a primitive int
1:      */
1:     public static int getIntSize()
1:     {
1:         return intSize;
1:     }
1: 
1:     /**
1:      * The estimate of the size of a class instance depends on whether the JVM uses 32 or 64
1:      * bit addresses, that is it depends on the size of an object reference. It is a linear
1:      * function of the size of a reference, e.g.
1:      *    24 + 5*r
1:      * where r is the size of a reference (usually 4 or 8 bytes).
1:      *
1:      * This method returns the coefficients of the linear function, e.g. {24, 5} in the above
1:      * example.
1:      *
1:      * @param cl A class whose instance size is to be estimated
1:      * @return an array of 2 integers. The first integer is the constant part of the function,
1:      *         the second is the reference size coefficient.
1:      */
1:     public static int[] getSizeCoefficients( Class cl)
1:     {
1:         int[] coeff = {0, objectOverhead};
1: 
1: 
1:         
1:         for( ; null != cl; cl = cl.getSuperclass())
1:         {
1:            Field[] field = cl.getDeclaredFields();
1:             if( null != field)
1:             {
1:                 for( int i = 0; i < field.length; i++)
1:                 {
1:                     if( ! Modifier.isStatic( field[i].getModifiers()))
1:                     {
1:                         Class fieldClass = field[i].getType();
1:                         if( fieldClass.isArray() || ! fieldClass.isPrimitive())
1:                             coeff[1]++;
1:                         else // Is simple primitive
1:                         {
1:                             String name = fieldClass.getName();
1: 
1:                             if( name.equals( "int") || name.equals( "I"))
1:                                 coeff[0] += intSize;
1:                             else if( name.equals( "long") || name.equals( "J"))
1:                                 coeff[0] += longSize;
1:                             else if( name.equals( "boolean") || name.equals( "Z"))
1:                                 coeff[0] += booleanSize;
1:                             else if( name.equals( "short") || name.equals( "S"))
1:                                 coeff[0] += shortSize;
1:                             else if( name.equals( "byte") || name.equals( "B"))
1:                                 coeff[0] += 1;
1:                             else if( name.equals( "char") || name.equals( "C"))
1:                                 coeff[0] += charSize;
1:                             else if( name.equals( "float") || name.equals( "F"))
1:                                 coeff[0] += floatSize;
1:                             else if( name.equals( "double") || name.equals( "D"))
1:                                 coeff[0] += doubleSize;
1:                             else // What is this??
1:                                 coeff[1]++; // Make a guess: one reference (?)
1:                         }
1:                     }
1:                 }
1:             }
1:         }
1:         return coeff;
1:     } // end of getSizeCoefficients
1: 
1:     /**
1:      * Estimate the static space taken up by a class instance given the coefficients
1:      * returned by getSizeCoefficients.
1:      *
1:      * @param coeff the coefficients
1:      *
1:      * @return the size estimate, in bytes
1:      */
1:     public static int estimateBaseFromCoefficients( int[] coeff)
1:     {
1:         int size = coeff[0] + coeff[1]*refSize;
1:         // Round up to a multiple of 8
1:         size = (size + 7)/8;
1:         size *= 8;
1:         return (size < minObjectSize) ? minObjectSize : size;
1:     } // end of estimateBaseFromCoefficients
1: 
1:     /**
1:      * Estimate the static space taken up by a class instance from cataloged coefficients.
1:      *
1:      * @param cls the class
1:      *
1:      * @return the size estimate, in bytes
1:      *
1:      * @see #estimateBaseFromCoefficients
1:      * @see #getSizeCoefficients
0:      * @see ClassSizeCrawler
1:      */
1:     public static int estimateBaseFromCatalog( Class cls)
1:     {
1:         return estimateBaseFromCatalog( cls, false);
1:     }
1:     
0:     private static int estimateBaseFromCatalog( Class cls, boolean addToCatalog)
1:     {
1:         if( dummyCatalog)
1:             return 0;
1:         
1:         if( SanityManager.DEBUG)
1: 			SanityManager.ASSERT( catalog != null, "The class size catalog could not be initialized.");
1:         
0:         int[] coeff = (int[]) catalog.get( cls.getName());
1:         if( coeff == null)
1:         {
1:             try
1:             {
1:                 coeff = getSizeCoefficients( cls);
1:             }
1:             catch( Throwable t)
1:             {
1:                 if( noGuess)
1:                     return -2;
1:                 coeff = wildGuess;
1:             }
1:             if( addToCatalog)
1:                 catalog.put( cls.getName(), coeff);
1:         }
1:         return estimateBaseFromCoefficients( coeff);
1:     } // end of estimateBaseFromCatalog
1: 
1: 
1:     /**
1:      * Estimate the static space taken up by a class instance. Save the coefficients
1:      * in a catalog.
1:      *
1:      * @param cls the class
1:      *
1:      * @return the size estimate, in bytes
1:      *
1:      * @see #estimateBaseFromCoefficients
1:      * @see #getSizeCoefficients
0:      * @see ClassSizeCrawler
1:      */
1:     public static int estimateAndCatalogBase( Class cls)
1:     {
1:         return estimateBaseFromCatalog( cls, true);
1:     } // end of estimateAndCatalogBase
1: 
1:     /**
1:      * Estimate the static space taken up by the fields of a class. This includes the space taken
1:      * up by by references (the pointer) but not by the referenced object. So the estimated
1:      * size of an array field does not depend on the size of the array. Similarly the size of
1:      * an object (reference) field does not depend on the object.
1:      *
1:      * @return the size estimate in bytes.
1:      *
1:      * Note that this method will throw a SecurityException if the SecurityManager does not
1:      * let this class execute the method Class.getDeclaredFields(). If this is a concern try
1:      * to compute the size coefficients at build time.
0:      * @see ClassSizeCrawler
1:      * @see #estimateBaseFromCatalog
1:      */
1:     public static int estimateBase( Class cl)
1:     {
1:         return estimateBaseFromCoefficients( getSizeCoefficients( cl));
1:     } // End of estimateBase
1: 
1:     /**
1:      * @return the estimated overhead of an array. The estimated size of an x[n] array is
1:      * estimateArrayOverhead() + n*sizeOf(x).
1:      */
1:     public static int estimateArrayOverhead()
1:     {
1:         return minObjectSize;
1:     }
1:     
1:     /**
1:      * Estimate the size of a Hashtable entry. In Java 1.2 we can use Map.entry, but this is not
1:      * available in earlier versions of Java.
1:      *
1:      * @return the estimate, in bytes
1:      */
1:     public static int estimateHashEntrySize()
1:     {
1:         return objectOverhead + 3*refSize;
1:     }
1: 
1:     /**
1:      * Estimate the size of a string.
1:      *
1:      * @return the estimated size, in bytes
1:      */
1:     public static int estimateMemoryUsage( String str)
1:     {
1:         if( null == str)
1:             return 0;
1:         // Since Java uses Unicode assume that each character takes 2 bytes
1:         return 2*str.length();
1:     }
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.cache
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.services.cache;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import java.lang.Class;
0: import java.lang.reflect.Field;
0: import java.lang.Runtime;
0: import java.lang.InterruptedException;
0: import java.lang.reflect.Modifier;
0: 
0: public class ClassSize
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
0:     public static final int refSize;
0:     private static final int objectOverhead = 2; // references, not bytes!
0:     private static final int booleanSize = 4;
0:     private static final int charSize = 4; // Unicode
0:     private static final int shortSize = 4;
0:     private static final int intSize = 4;
0:     private static final int longSize = 8;
0:     private static final int floatSize = 4;
0:     private static final int doubleSize = 8;
0:     private static final int minObjectSize;
0: 
0:     private static boolean dummyCatalog = false; // Used when constructing the catalog to prevent recursion
0: 
0:     static boolean noGuess = false;
0:     // noGuess is used in unit testing.
0: 
0:     static boolean unitTest = false;
0:     // unitTest is used in unit testing
0: 
0:     private static final int[] wildGuess = {0,16};
0:     /* The standard wild guess of the size of an unknown class, the size of 16 references.
0:      * Used when the security manager will not let us look at the class fields.
0:      */
0: 
0:     /* Do not let the compiler see ClassSizeCatalog. Otherwise it will try to
0:      * compile it. This may fail because ClassSizeCatalog.java is not created
0:      * until everything else has been compiled. Bury ClassSizeCatalog in a string.
0:      */
0:     private static java.util.Hashtable catalog;
0:     static
0:     {
0:         try
0:         {
0:             catalog = (java.util.Hashtable)
0:               Class.forName( "org.apache.derby.iapi.services.cache.ClassSizeCatalog").newInstance();
0:         }
0:         catch( Exception e){};
0: 
0:         // Figure out whether this is a 32 or 64 bit machine.
0:         Runtime runtime = Runtime.getRuntime();
0:         long memBase = runtime.totalMemory() - runtime.freeMemory();
0:         Object[] junk = new Object[10000];
0:         long memUsed = runtime.totalMemory() - runtime.freeMemory() - memBase;
0:         int sz = (int)((memUsed + junk.length/2)/junk.length);
0:         refSize = ( 4 > sz) ? 4 : sz;
0:         minObjectSize = 4*refSize;
0:     }
0: 
0:     /**
0:      * do not try to use the catalog.
0:      */
0:     public static void setDummyCatalog()
0:     {
0:         dummyCatalog = true;
0:     }
0:     /**
0:      * Get the estimate of the size of an object reference.
0:      *
0:      * @return the estimate in bytes.
0:      */
0:     public static int getRefSize()
0:     {
0:         return refSize;
0:     }
0: 
0:     /**
0:      * @return the estimate of the size of a primitive int
0:      */
0:     public static int getIntSize()
0:     {
0:         return intSize;
0:     }
0: 
0:     /**
0:      * The estimate of the size of a class instance depends on whether the JVM uses 32 or 64
0:      * bit addresses, that is it depends on the size of an object reference. It is a linear
0:      * function of the size of a reference, e.g.
0:      *    24 + 5*r
0:      * where r is the size of a reference (usually 4 or 8 bytes).
0:      *
0:      * This method returns the coefficients of the linear function, e.g. {24, 5} in the above
0:      * example.
0:      *
0:      * @param cl A class whose instance size is to be estimated
0:      * @return an array of 2 integers. The first integer is the constant part of the function,
0:      *         the second is the reference size coefficient.
0:      */
0:     public static int[] getSizeCoefficients( Class cl)
0:     {
0:         int[] coeff = {0, objectOverhead};
0: 
0: 
0:         
0:         for( ; null != cl; cl = cl.getSuperclass())
0:         {
0:            Field[] field = cl.getDeclaredFields();
0:             if( null != field)
0:             {
0:                 for( int i = 0; i < field.length; i++)
0:                 {
0:                     if( ! Modifier.isStatic( field[i].getModifiers()))
0:                     {
0:                         Class fieldClass = field[i].getType();
0:                         if( fieldClass.isArray() || ! fieldClass.isPrimitive())
0:                             coeff[1]++;
0:                         else // Is simple primitive
0:                         {
0:                             String name = fieldClass.getName();
0: 
0:                             if( name.equals( "int") || name.equals( "I"))
0:                                 coeff[0] += intSize;
0:                             else if( name.equals( "long") || name.equals( "J"))
0:                                 coeff[0] += longSize;
0:                             else if( name.equals( "boolean") || name.equals( "Z"))
0:                                 coeff[0] += booleanSize;
0:                             else if( name.equals( "short") || name.equals( "S"))
0:                                 coeff[0] += shortSize;
0:                             else if( name.equals( "byte") || name.equals( "B"))
0:                                 coeff[0] += 1;
0:                             else if( name.equals( "char") || name.equals( "C"))
0:                                 coeff[0] += charSize;
0:                             else if( name.equals( "float") || name.equals( "F"))
0:                                 coeff[0] += floatSize;
0:                             else if( name.equals( "double") || name.equals( "D"))
0:                                 coeff[0] += doubleSize;
0:                             else // What is this??
0:                                 coeff[1]++; // Make a guess: one reference (?)
0:                         }
0:                     }
0:                 }
0:             }
0:         }
0:         return coeff;
0:     } // end of getSizeCoefficients
0: 
0:     /**
0:      * Estimate the static space taken up by a class instance given the coefficients
0:      * returned by getSizeCoefficients.
0:      *
0:      * @param coeff the coefficients
0:      *
0:      * @return the size estimate, in bytes
0:      */
0:     public static int estimateBaseFromCoefficients( int[] coeff)
0:     {
0:         int size = coeff[0] + coeff[1]*refSize;
0:         // Round up to a multiple of 8
0:         size = (size + 7)/8;
0:         size *= 8;
0:         return (size < minObjectSize) ? minObjectSize : size;
0:     } // end of estimateBaseFromCoefficients
0: 
0:     /**
0:      * Estimate the static space taken up by a class instance from cataloged coefficients.
0:      *
0:      * @param cls the class
0:      *
0:      * @return the size estimate, in bytes
0:      *
0:      * @see #estimateBaseFromCoefficients
0:      * @see #getSizeCoefficients
0:      * @see ClassSizeCrawler
0:      */
0:     public static int estimateBaseFromCatalog( Class cls)
0:     {
0:         return estimateBaseFromCatalog( cls, false);
0:     }
0:     
0:     private static int estimateBaseFromCatalog( Class cls, boolean addToCatalog)
0:     {
0:         if( dummyCatalog)
0:             return 0;
0:         
0:         if( SanityManager.DEBUG)
0: 			SanityManager.ASSERT( catalog != null, "The class size catalog could not be initialized.");
0:         
0:         int[] coeff = (int[]) catalog.get( cls.getName());
0:         if( coeff == null)
0:         {
0:             try
0:             {
0:                 coeff = getSizeCoefficients( cls);
0:             }
0:             catch( Throwable t)
0:             {
0:                 if( noGuess)
0:                     return -2;
0:                 coeff = wildGuess;
0:             }
0:             if( addToCatalog)
0:                 catalog.put( cls.getName(), coeff);
0:         }
0:         return estimateBaseFromCoefficients( coeff);
0:     } // end of estimateBaseFromCatalog
0: 
0: 
0:     /**
0:      * Estimate the static space taken up by a class instance. Save the coefficients
0:      * in a catalog.
0:      *
0:      * @param cls the class
0:      *
0:      * @return the size estimate, in bytes
0:      *
0:      * @see #estimateBaseFromCoefficients
0:      * @see #getSizeCoefficients
0:      * @see ClassSizeCrawler
0:      */
0:     public static int estimateAndCatalogBase( Class cls)
0:     {
0:         return estimateBaseFromCatalog( cls, true);
0:     } // end of estimateAndCatalogBase
0: 
0:     /**
0:      * Estimate the static space taken up by the fields of a class. This includes the space taken
0:      * up by by references (the pointer) but not by the referenced object. So the estimated
0:      * size of an array field does not depend on the size of the array. Similarly the size of
0:      * an object (reference) field does not depend on the object.
0:      *
0:      * @return the size estimate in bytes.
0:      *
0:      * Note that this method will throw a SecurityException if the SecurityManager does not
0:      * let this class execute the method Class.getDeclaredFields(). If this is a concern try
0:      * to compute the size coefficients at build time.
0:      * @see ClassSizeCrawler
0:      * @see #estimateBaseFromCatalog
0:      */
0:     public static int estimateBase( Class cl)
0:     {
0:         return estimateBaseFromCoefficients( getSizeCoefficients( cl));
0:     } // End of estimateBase
0: 
0:     /**
0:      * @return the estimated overhead of an array. The estimated size of an x[n] array is
0:      * estimateArrayOverhead() + n*sizeOf(x).
0:      */
0:     public static int estimateArrayOverhead()
0:     {
0:         return minObjectSize;
0:     }
0:     
0:     /**
0:      * Estimate the size of a Hashtable entry. In Java 1.2 we can use Map.entry, but this is not
0:      * available in earlier versions of Java.
0:      *
0:      * @return the estimate, in bytes
0:      */
0:     public static int estimateHashEntrySize()
0:     {
0:         return objectOverhead + 3*refSize;
0:     }
0: 
0:     /**
0:      * Estimate the size of a string.
0:      *
0:      * @return the estimated size, in bytes
0:      */
0:     public static int estimateMemoryUsage( String str)
0:     {
0:         if( null == str)
0:             return 0;
0:         // Since Java uses Unicode assume that each character takes 2 bytes
0:         return 2*str.length();
0:     }
0: }
============================================================================