1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.ColumnDefinitionNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
12:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:f1c232e: import java.sql.Types;
1:47d4a4c: import java.util.List;
1:f1c232e: import org.apache.derby.catalog.DefaultInfo;
1:f1c232e: import org.apache.derby.catalog.UUID;
1:f1c232e: import org.apache.derby.catalog.types.DefaultInfoImpl;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:f1c232e: import org.apache.derby.iapi.reference.Limits;
1:f1c232e: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:f1c232e: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:f1c232e: import org.apache.derby.iapi.services.loader.ClassInspector;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:f1c232e: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:f1c232e: import org.apache.derby.iapi.sql.depend.ProviderList;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:9ed7c4d: import org.apache.derby.iapi.types.StringDataValue;
1:eac0369: import org.apache.derby.iapi.types.TypeId;
1:eac0369: import org.apache.derby.impl.sql.execute.ColumnInfo;
1:eac0369: 
1:eac0369: /**
1:eac0369:  * A ColumnDefinitionNode represents a column definition in a DDL statement.
1:eac0369:  * There will be a ColumnDefinitionNode for each column in a CREATE TABLE
1:eac0369:  * statement, and for the column in an ALTER TABLE ADD COLUMN statement.
5:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: public class ColumnDefinitionNode extends TableElementNode
1:03b7b8d: {
1:eac0369: 	boolean						isAutoincrement;
1:cb8f109: 	
1:cb8f109:     /**
1:cb8f109:      * The data type of this column.
1:cb8f109:      */
1:7dda5d5:     DataTypeDescriptor type;
1:cb8f109:     
1:eac0369: 	DataValueDescriptor			defaultValue;
1:eac0369: 	DefaultInfoImpl				defaultInfo;
1:eac0369: 	DefaultNode					defaultNode;
1:fe3c8d8: 	boolean						keepCurrentDefault;
1:95a483d:     GenerationClauseNode   generationClauseNode;
1:eac0369: 	long						autoincrementIncrement;
1:eac0369: 	long						autoincrementStart;
1:d055adb:         long                                            autoincrementCycle;
1:6a5edfc: 	//This variable tells if the autoincrement column is participating 
1:6a5edfc: 	//in create or alter table. And if it is participating in alter
1:6a5edfc: 	//table, then it further knows if it is represting a change in 
1:6a5edfc: 	//increment value or a change in start value.
1:6a5edfc: 	//This information is later used to make sure that the autoincrement
1:6a5edfc: 	//column's increment value is not 0 at the time of create, or is not
1:6a5edfc: 	//getting set to 0 at the time of increment value modification.
1:6a5edfc: 	long						autoinc_create_or_modify_Start_Increment;
1:eac0369: 	boolean						autoincrementVerify;
1:eac0369: 
1:6a5edfc: 	//autoinc_create_or_modify_Start_Increment will be set to one of the
1:6a5edfc: 	//following 3 values.
1:6a5edfc: 	//CREATE_AUTOINCREMENT - this autoincrement column definition is for create table
1:6a5edfc: 	public static final int CREATE_AUTOINCREMENT = 0;
1:6a5edfc: 	//MODIFY_AUTOINCREMENT_RESTART_VALUE - this column definition is for
1:6a5edfc: 	//alter table command to change the start value of the column
1:6a5edfc: 	public static final int MODIFY_AUTOINCREMENT_RESTART_VALUE = 1;
1:6a5edfc: 	//MODIFY_AUTOINCREMENT_INC_VALUE - this column definition is for
1:6a5edfc: 	//alter table command to change the increment value of the column
1:6a5edfc: 	public static final int MODIFY_AUTOINCREMENT_INC_VALUE = 2;
1:5b838fd: 	//alter table command to change the ALWAYS vs DEFAULT nature of an autoinc column
1:5b838fd: 	public static final int MODIFY_AUTOINCREMENT_ALWAYS_VS_DEFAULT = 3;
1:eac0369: 	
1:eac0369: 	/**
1:3bb140c:      * Constructor for a ColumnDefinitionNode
1:eac0369: 	 *
1:eac0369: 	 * @param name			The name of the column
1:eac0369: 	 * @param defaultNode	The default value of the column
1:eac0369: 	 * @param dataTypeServices	A DataTypeServices telling the type
1:eac0369: 	 *				of the column
1:3bb140c:      * @param autoIncrementInfo Info for auto-increment columns
1:3bb140c:      * @param cm            The context manager
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     ColumnDefinitionNode(
1:3bb140c:                     String name,
1:3bb140c:                     ValueNode defaultNode,
1:3bb140c:                     DataTypeDescriptor dataTypeServices,
1:3bb140c:                     long[] autoIncrementInfo,
1:3bb140c:                     ContextManager cm)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:3bb140c:         super(name, cm);
1:3bb140c:         this.type = dataTypeServices;
1:2706d1f: 
1:2706d1f:         if (defaultNode instanceof UntypedNullConstantNode)
1:eac0369: 		{
1:eac0369: 			/* No DTS yet for MODIFY DEFAULT */
2:eac0369: 			if (dataTypeServices != null)
1:eac0369: 			{
1:eac0369: 				defaultValue = 
1:eac0369: 					((UntypedNullConstantNode) defaultNode).
1:7dda5d5: 									convertDefaultNode(this.type);
1:eac0369: 			}
1:eac0369: 		}
1:95a483d: 		else if (defaultNode instanceof GenerationClauseNode)
1:95a483d: 		{
1:95a483d:             generationClauseNode = (GenerationClauseNode) defaultNode;
1:95a483d: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				if (defaultNode != null &&
1:eac0369: 					! (defaultNode instanceof DefaultNode))
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 						"defaultNode expected to be instanceof DefaultNode, not " +
1:eac0369: 						defaultNode.getClass().getName());
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			this.defaultNode = (DefaultNode) defaultNode;
1:eac0369: 			if (autoIncrementInfo != null)
1:eac0369: 			{
1:3bb140c:                 long[] aii = autoIncrementInfo;
1:eac0369: 				autoincrementStart = aii[QueryTreeNode.AUTOINCREMENT_START_INDEX];
1:eac0369: 				autoincrementIncrement = aii[QueryTreeNode.AUTOINCREMENT_INC_INDEX];
1:d055adb: 				autoincrementCycle = aii[QueryTreeNode.AUTOINCREMENT_CYCLE];
1:6a5edfc: 				//Parser has passed the info about autoincrement column's status in the
1:6a5edfc: 				//following array element. It will tell if the autoinc column is part of 
1:6a5edfc: 				//a create table or if is a part of alter table. And if it is part of 
1:6a5edfc: 				//alter table, is it for changing the increment value or for changing 
1:6a5edfc: 				//the start value?
1:6a5edfc: 				autoinc_create_or_modify_Start_Increment = aii[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY];
1:eac0369: 				
1:eac0369: 				/*
1:eac0369: 				 * If using DB2 syntax to set increment value, will need to check if column
1:eac0369: 				 * is already created for autoincrement.
1:eac0369: 				 */
1:eac0369: 				autoincrementVerify = (aii[QueryTreeNode.AUTOINCREMENT_IS_AUTOINCREMENT_INDEX] > 0) ? false : true;
1:eac0369: 				isAutoincrement = true;
1:eac0369: 				// an autoincrement column cannot be null-- setting
1:eac0369: 				// non-nullability for this column is needed because 
1:eac0369: 				// you could create a column with ai default, add data, drop 
1:eac0369: 				// the default, and try to add it back again you'll get an
1:eac0369: 				// error because the column is marked nullable.
1:ed82406:                 if (dataTypeServices != null)
1:7dda5d5:                     setNullability(false);
1:eac0369: 			}
1:eac0369: 		}
1:fe3c8d8: 		// ColumnDefinitionNode instances can be subclassed by
1:fe3c8d8: 		// ModifyColumnNode for use in ALTER TABLE .. ALTER COLUMN
1:fe3c8d8: 		// statements, in which case the node represents the intended
1:fe3c8d8: 		// changes to the column definition. For such a case, we
1:fe3c8d8: 		// record whether or not the statement specified that the
1:fe3c8d8: 		// column's default value should be changed. If we are to
1:fe3c8d8: 		// keep the current default, ModifyColumnNode will re-read
1:fe3c8d8: 		// the current default from the system catalogs prior to
1:fe3c8d8: 		// performing the column alteration. See DERBY-4006
1:fe3c8d8: 		// for more discussion of this behavior.
1:fe3c8d8: 		this.keepCurrentDefault = (defaultNode == null);
1:eac0369: 	}
1:eac0369: 
1:c9a1206: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:e126f58: 			return "type: " + getType() + "\n" +
1:eac0369: 				"defaultValue: " + defaultValue + "\n" +
1:eac0369: 				super.toString();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the unqualified name of the column being defined.
1:eac0369: 	 *
1:eac0369: 	 * @return	the name of the column
1:eac0369: 	 */
1:3bb140c:     String getColumnName()
1:eac0369: 	{
1:eac0369: 		return this.name;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:7dda5d5: 	 * Returns the data type of the column being defined.
1:eac0369: 	 *
1:7dda5d5: 	 * @return	the data type of the column
1:eac0369: 	 */
1:3bb140c:     final DataTypeDescriptor getType()
1:eac0369: 	{
1:7dda5d5: 		return type;
1:eac0369: 	}
1:95a483d: 
1:95a483d:     /** Set the type of this column */
1:95a483d:     public void setType( DataTypeDescriptor dts ) { type = dts; }
1:7dda5d5:     
1:7dda5d5:     /**
1:7dda5d5:      * Set the nullability of the column definition node.
1:7dda5d5:       */
1:3bb140c:     final void setNullability(boolean nullable)
1:7dda5d5:     {
1:7dda5d5:         type = getType().getNullabilityType(nullable);
1:7dda5d5:     }
1:9ed7c4d:     
1:9ed7c4d:     /**
1:9ed7c4d:      * Set the collation type, note derivation is always
1:9ed7c4d:      * implicit for any catalog item.
1:9ed7c4d:      */
1:9ed7c4d:     void setCollationType(int collationType)
1:9ed7c4d:     {
1:9ed7c4d:         type = getType().getCollatedType(collationType,
1:9ed7c4d:                 StringDataValue.COLLATION_DERIVATION_IMPLICIT);
1:9ed7c4d:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the DataValueDescriptor containing the default value for this
1:eac0369: 	 * column
1:eac0369: 	 *
1:eac0369: 	 * @return	The default value of the column
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     DataValueDescriptor getDefaultValue()
1:eac0369: 	{
1:eac0369: 		return this.defaultValue;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the DefaultInfo containing the default information for this
1:eac0369: 	 * column
1:eac0369: 	 *
1:eac0369: 	 * @return	The default info for the column
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     DefaultInfo getDefaultInfo()
1:eac0369: 	{
1:eac0369: 		return defaultInfo;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:95a483d: 	 * Set the generation clause (Default) bound to this column.
1:95a483d: 	 */
1:95a483d:     public  void    setDefaultInfo( DefaultInfoImpl dii ) { defaultInfo = dii; }
1:95a483d: 
1:95a483d: 	/**
1:eac0369: 	 * Return the DefaultNode, if any, associated with this node.
1:eac0369: 	 *
1:eac0369: 	 * @return The DefaultNode, if any, associated with this node.
1:eac0369: 	 */
1:3bb140c:     DefaultNode getDefaultNode()
1:eac0369: 	{
1:eac0369: 		return defaultNode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:95a483d: 	 * Return true if this column has a generation clause.
1:95a483d: 	 */
1:95a483d: 	public boolean hasGenerationClause() { return ( generationClauseNode != null ); }
1:95a483d: 
1:95a483d: 	/**
1:95a483d: 	 * Get the generation clause.
1:95a483d: 	 */
1:3bb140c:     GenerationClauseNode getGenerationClauseNode() {
1:3bb140c:         return generationClauseNode;
1:3bb140c:     }
1:95a483d: 
1:95a483d: 	/**
1:eac0369: 	 * Is this an autoincrement column?
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not this is an autoincrement column.
1:eac0369: 	 */
1:3bb140c:     boolean isAutoincrementColumn()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:6a5edfc: 			//increment value for autoincrement column can't be 0 if the autoinc column
1:6a5edfc: 			//is part of create table or it is part of alter table to change the 
1:6a5edfc: 			//increment value. 
1:6a5edfc: 			if (isAutoincrement && autoincrementIncrement == 0 && 
1:6a5edfc: 					(autoinc_create_or_modify_Start_Increment == ColumnDefinitionNode.CREATE_AUTOINCREMENT ||
1:6a5edfc: 							autoinc_create_or_modify_Start_Increment == ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE))
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"autoincrementIncrement expected to be non-zero");
1:eac0369: 			}
1:eac0369: 			if ((! isAutoincrement) && 
1:eac0369: 				(autoincrementStart != 0 || autoincrementIncrement != 0))
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"both autoincrementStart and autoincrementIncrement expected to be 0");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return isAutoincrement;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the autoincrement start value
1:eac0369: 	 *
1:eac0369: 	 * @return Autoincrement start value.
1:eac0369: 	 */
1:eac0369: 	long getAutoincrementStart()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(isAutoincrement,
1:eac0369: 				"isAutoincrement expected to be true");
1:eac0369: 		}
1:eac0369: 		return autoincrementStart;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the autoincrement increment value
1:eac0369: 	 *
1:eac0369: 	 * @return Autoincrement increment value.
1:eac0369: 	 */
1:eac0369: 	long getAutoincrementIncrement()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(isAutoincrement,
1:eac0369: 				"isAutoincrement expected to be true");
1:eac0369: 		}
1:eac0369: 		return autoincrementIncrement;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:d055adb: 	 * Get the autoincrement cycle value
1:d055adb: 	 *
1:d055adb: 	 * @return Autoincrement cycle value.
1:d055adb: 	 */
1:d055adb: 	long getAutoincrementCycle()
1:d055adb: 	{
1:d055adb: 		if (SanityManager.DEBUG)
1:d055adb: 		{			SanityManager.ASSERT(isAutoincrement,
1:d055adb: 					"isAutoincrement expected to be true");
1:d055adb: 		}
1:d055adb: 		return autoincrementCycle;
1:d055adb: 	}
1:d055adb: 
1:d055adb: 
1:d055adb: 	/**
1:6a5edfc: 	 * Get the status of this autoincrement column 
1:eac0369: 	 *
1:6a5edfc: 	 * @return ColumnDefinitionNode.CREATE_AUTOINCREMENT - 
1:6a5edfc: 	 * 		if this definition is for autoincrement column creatoin
1:6a5edfc: 	 *   ColumnDefinitionNode.MODIFY_AUTOINCREMENT_RESTART_VALUE -
1:6a5edfc: 	 * 		if this definition is for alter sutoincrement column to change the start value 
1:6a5edfc: 	 *   ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE 
1:6a5edfc: 	 * 		if this definition is for alter autoincrement column to change the increment value
1:eac0369: 	 */
1:6a5edfc: 	long getAutoinc_create_or_modify_Start_Increment()
1:eac0369: 	{
1:6a5edfc: 		if (SanityManager.DEBUG)
2:6a5edfc: 		{
1:6a5edfc: 			SanityManager.ASSERT(isAutoincrement,
1:6a5edfc: 				"isAutoincrement expected to be true");
1:6a5edfc: 		}
1:6a5edfc: 		return autoinc_create_or_modify_Start_Increment;
1:6a5edfc: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Check the validity of a user type.  Checks whether this column
1:eac0369: 	 * definition describes a user type that either doesn't exist or is
1:eac0369: 	 * inaccessible, or that doesn't implement Serializable.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void checkUserType(TableDescriptor td)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		String			columnTypeName;
1:eac0369: 
1:fce10ba:         // continue if this is a generated column and the datatype has been
1:fce10ba:         // omitted. we can't check generation clauses until later on
1:fce10ba:         if ( hasGenerationClause() && (getType() == null ) ) { return; }
1:fce10ba: 
1:eac0369: 		/* Built-in types need no checking */
1:7dda5d5: 		if (!getType().getTypeId().userType())
1:eac0369: 			return;
1:eac0369: 
1:d039ced:         // bind the UDT if necessary
1:d039ced:         setType( bindUserType( getType() ) );
1:d039ced: 
1:eac0369: 		ClassInspector classInspector = getClassFactory().getClassInspector();
1:eac0369: 
1:eac0369: 		columnTypeName =
1:7dda5d5: 			getType().getTypeId().getCorrespondingJavaTypeName();
1:eac0369: 
1:eac0369: 		/* User type - We first check for the columnTypeName as a java class.
1:eac0369: 		 * If that fails, then we treat it as a class alias.
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		boolean foundMatch = false;
1:eac0369: 		Throwable reason = null;
1:eac0369: 		try {
1:eac0369: 			foundMatch = classInspector.accessible(columnTypeName);
1:eac0369: 		} catch (ClassNotFoundException cnfe) {
1:eac0369: 			reason = cnfe;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (!foundMatch)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_TYPE_DOESNT_EXIST, reason, columnTypeName,
1:eac0369: 																name);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (! classInspector.assignableTo(columnTypeName,
1:eac0369: 											"java.io.Serializable")  &&
1:eac0369:             // Before Java2, SQLData is not defined, assignableTo call returns false
1:eac0369:             ! classInspector.assignableTo(columnTypeName,"java.sql.SQLData"))
1:eac0369:         {
1:eac0369: 			getCompilerContext().addWarning(
1:eac0369: 				StandardException.newWarning(SQLState.LANG_TYPE_NOT_SERIALIZABLE, columnTypeName,
1:eac0369: 																 name));
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the UUID of the old column default.
1:eac0369: 	 *
1:eac0369: 	 * @return The UUID of the old column default.
1:eac0369: 	 */
1:eac0369: 	UUID getOldDefaultUUID()
1:eac0369: 	{
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the action associated with this node.
1:eac0369: 	 *
1:eac0369: 	 * @return The action associated with this node.
1:eac0369: 	 */
1:eac0369: 	int getAction()
1:eac0369: 	{
1:eac0369: 		return ColumnInfo.CREATE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check the validity of the default, if any, for this node.
1:eac0369: 	 *
1:eac0369: 	 * @param dd		The DataDictionary.
1:eac0369: 	 * @param td		The TableDescriptor.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void bindAndValidateDefault(DataDictionary dd, TableDescriptor td)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* DB2 requires non-nullable columns to have a default in ALTER TABLE */
1:fce10ba: 		if (td != null && !hasGenerationClause() && !getType().isNullable() && defaultNode == null)
1:eac0369: 		{
1:fce10ba: 			if (!isAutoincrement )
1:eac0369: 				throw StandardException.newException(SQLState.LANG_DB2_NOT_NULL_COLUMN_INVALID_DEFAULT, getColumnName());
1:eac0369: 		}
1:eac0369: 			
1:eac0369: 		// No work to do if no user specified default
1:eac0369: 		if (defaultNode == null)
1:eac0369: 		{
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// No work to do if user specified NULL
1:eac0369: 		if (defaultValue != null)
1:eac0369: 		{
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Now validate the default
1:eac0369: 		validateDefault(dd, td);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check the validity of the autoincrement values for this node.
1:eac0369: 	 * The following errors are thrown by this routine.
1:eac0369: 	 * 1. 42z21 Invalid Increment; i.e 0.
1:eac0369: 	 * 2. 42z22 Invalid Type; autoincrement created on a non-exact-numeric type
1:eac0369: 	 * 3. 42995 The requested function does not apply to global temporary tables
1:eac0369: 	 *
1:eac0369: 	 * @param 		dd		DataDictionary.
1:eac0369: 	 * @param		td		table descriptor.
1:eac0369: 	 * @param		tableType	base table or declared global temporary table.
1:eac0369: 	 *
1:eac0369: 	 * @exception 	StandardException if autoincrement default is incorrect; i.e
1:eac0369: 	 * 				if increment is 0 or if initial or increment values are out
1:eac0369: 	 * 				of range for the datatype.
1:eac0369: 	 */
1:3bb140c:     void validateAutoincrement(DataDictionary dd,
1:3bb140c:                                TableDescriptor td,
1:3bb140c:                                int tableType) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (isAutoincrement == false)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
1:eac0369: 			throw StandardException.newException(SQLState.LANG_NOT_ALLOWED_FOR_DECLARED_GLOBAL_TEMP_TABLE);
1:eac0369: 
1:6a5edfc: 		//increment value for autoincrement column can't be 0 if the autoinc column
1:6a5edfc: 		//is part of create table or it is part of alter table to change the 
1:6a5edfc: 		//increment value. 
1:6a5edfc: 		if (autoincrementIncrement == 0 && 
1:6a5edfc: 				(autoinc_create_or_modify_Start_Increment == ColumnDefinitionNode.CREATE_AUTOINCREMENT ||
1:6a5edfc: 						autoinc_create_or_modify_Start_Increment == ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE))
1:eac0369: 			throw StandardException.newException(SQLState.LANG_AI_INVALID_INCREMENT, getColumnName());
1:7dda5d5: 		int jdbctype = getType().getTypeId().getJDBCTypeId();
1:eac0369: 		switch (jdbctype)
1:eac0369: 		{
1:eac0369: 		case Types.TINYINT:
1:eac0369: 			autoincrementCheckRange((long)Byte.MIN_VALUE, 
1:eac0369: 									(long)Byte.MAX_VALUE, 
1:eac0369: 									TypeId.TINYINT_NAME);
1:eac0369: 			break;
1:eac0369: 		case Types.SMALLINT:
1:eac0369: 			autoincrementCheckRange((long)Short.MIN_VALUE, 
1:eac0369: 									(long)Short.MAX_VALUE,
1:eac0369: 									TypeId.SMALLINT_NAME);
1:eac0369: 			break;
1:eac0369: 		case Types.INTEGER:
1:eac0369: 			autoincrementCheckRange((long)Integer.MIN_VALUE, 
1:eac0369: 									(long)Integer.MAX_VALUE,
1:eac0369: 									TypeId.INTEGER_NAME);
1:eac0369: 			break;
1:eac0369: 		case Types.BIGINT:
1:eac0369: 			autoincrementCheckRange(Long.MIN_VALUE, Long.MAX_VALUE,
1:3bb140c:                                     TypeId.BIGINT_NAME);
1:eac0369: 			break;
2:eac0369: 		default:
1:eac0369: 			throw StandardException.newException(SQLState.LANG_AI_INVALID_TYPE,
1:eac0369: 												 getColumnName());
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * checks to see if autoincrementIncrement and autoincrementInitial
1:eac0369: 	 * are within the bounds of the type whose min and max values are
1:eac0369: 	 * passed into this routine.
1:eac0369: 	 */
1:eac0369: 	private	void autoincrementCheckRange(long minValue, long maxValue,
1:eac0369: 									String typeName)
1:eac0369: 				throws StandardException					
1:eac0369: 	{
1:eac0369: 		if ((minValue > autoincrementIncrement) || 
1:eac0369: 			(maxValue < autoincrementIncrement))
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(
1:eac0369: 								 SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, typeName);
1:eac0369: 		}
1:eac0369: 		if ((minValue > autoincrementStart) || 
1:eac0369: 			(maxValue < autoincrementStart))
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(
1:eac0369: 								 SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, typeName);
1:eac0369: 		}			
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 * Check the validity of the default for this node.
1:eac0369: 	 *
1:eac0369: 	 * @param td		The TableDescriptor.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void validateDefault(DataDictionary dd, TableDescriptor td)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (defaultNode == null)
1:eac0369: 			return;
1:eac0369: 
1:b0ad765: 		//Examin whether default value is autoincrement.
1:b0ad765: 		if (isAutoincrement){
1:b0ad765: 			defaultInfo = createDefaultInfoOfAutoInc();
1:b0ad765: 			return;
1:b0ad765: 		}
1:eac0369: 		
1:eac0369: 		
1:b0ad765: 		//Judged as default value is constant value.
1:eac0369: 		
1:867a530: 		CompilerContext cc = getCompilerContext();
1:eac0369: 
1:eac0369: 		ValueNode defaultTree = defaultNode.getDefaultTree();
1:eac0369: 
1:eac0369: 		/* bind the default.
1:eac0369: 		 * Verify that it does not contain any ColumnReferences or subqueries
1:eac0369: 		 * and that it is type compatable with the column.
1:eac0369: 		 */
1:eac0369: 		final int previousReliability = cc.getReliability();
1:eac0369: 		try
1:eac0369: 		{
1:867a530: 			/*
1:867a530: 				Defaults cannot have dependencies as they
1:867a530: 				should just be constants. Code used to exist
1:867a530: 				to handle dependencies in defaults, now this
1:867a530: 				is under sanity to ensure no dependencies exist.
1:eac0369: 			 */
1:867a530: 			ProviderList apl = null;
1:867a530: 			ProviderList prevAPL = null;
1:eac0369: 
1:867a530: 			if (SanityManager.DEBUG) {
1:867a530: 				apl = new ProviderList();
1:867a530: 				prevAPL = cc.getCurrentAuxiliaryProviderList();
1:867a530: 				cc.setCurrentAuxiliaryProviderList(apl);
1:867a530: 			}
1:867a530: 			
1:eac0369: 			// Tell the compiler context to only allow deterministic nodes
1:eac0369: 			cc.setReliability( CompilerContext.DEFAULT_RESTRICTION );
1:eac0369: 			defaultTree = defaultTree.bindExpression(
1:3bb140c:                             new FromList(
1:3bb140c:                                 getOptimizerFactory().doJoinOrderOptimization(),
1:eac0369: 								getContextManager()), 
1:eac0369: 							(SubqueryList) null,
1:71c8e86: 							(List<AggregateNode>) null);
1:eac0369: 
1:7dda5d5: 			TypeId columnTypeId = getType().getTypeId();
1:eac0369: 			TypeId defaultTypeId = defaultTree.getTypeId();
1:eac0369: 
1:eac0369: 			// Check for 'invalid default' errors (42894)
1:eac0369: 			// before checking for 'not storable' errors (42821).
1:7dda5d5: 			if (!defaultTypeIsValid(columnTypeId, getType(),
1:eac0369: 					defaultTypeId, defaultTree, defaultNode.getDefaultText()))
1:eac0369: 			{
1:eac0369: 					throw StandardException.newException(
1:eac0369: 						SQLState.LANG_DB2_INVALID_DEFAULT_VALUE,
1:eac0369: 						this.name);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// Now check 'not storable' errors.
1:eac0369: 			if (! getTypeCompiler(columnTypeId).
1:eac0369: 								storable(defaultTypeId, getClassFactory()))
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_NOT_STORABLE, 
1:eac0369: 					columnTypeId.getSQLTypeName(),
1:eac0369: 					defaultTypeId.getSQLTypeName() );
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// Save off the default text
1:eac0369: 			// RESOLVEDEFAULT - Convert to constant if possible
1:b0ad765: 			defaultInfo = new DefaultInfoImpl(false,
1:b0ad765: 							  defaultNode.getDefaultText(), 
1:b0ad765: 							  defaultValue);
1:eac0369: 
1:867a530: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:867a530: 				/* Save the APL off in the constraint node */
1:867a530: 				if (apl.size() > 0)
1:867a530: 				{
1:eac0369: 
1:867a530: 					SanityManager.THROWASSERT("DEFAULT clause has unexpected dependencies");
1:867a530: 				}
1:867a530: 				// Restore the previous AuxiliaryProviderList
1:867a530: 				cc.setCurrentAuxiliaryProviderList(prevAPL);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			cc.setReliability(previousReliability);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:5b838fd: 	protected static DefaultInfoImpl createDefaultInfoOfAutoInc(){
1:b0ad765: 		return new DefaultInfoImpl(true,
1:b0ad765: 					   null, 
1:b0ad765: 					   null);
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check the validity of the default for this node
1:eac0369: 	 *
1:eac0369: 	 * @param columnType TypeId of the target column.
1:eac0369: 	 * @param columnDesc Description of the type of the
1:eac0369: 	 *		target column.
1:eac0369: 	 * @param defaultType TypeId of the default node.
1:eac0369: 	 * @param defaultNode Parsed ValueNode for the default value.
1:eac0369: 	 * @param defaultText Unparsed default value (as entered
1:eac0369: 	 * 		by user).
1:eac0369: 	 * @return True if the defaultNode abides by the restrictions
1:eac0369: 	 * 	imposed by DB2 on default constants; false otherwise.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     boolean defaultTypeIsValid(TypeId columnType,
1:eac0369: 		DataTypeDescriptor columnDesc, TypeId defaultType,
1:eac0369: 		ValueNode defaultNode, String defaultText)
1:eac0369: 	throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 
1:eac0369: 		/* We can use info about the way the parser works
1:eac0369: 		 * to guide this process a little (see the getNumericNode()
1:eac0369: 		 * method in sqlgrammar.jj):
1:eac0369: 		 *
1:eac0369: 		 * 1) Tinyint and Smallints are both parsed as "INT" types,
1:eac0369: 	 	 *	  while integers larger than a basic "INT" are parsed into
1:eac0369: 		 *	  "LONGINT" or, if needed, "DECIMAL".
1:eac0369: 		 * 2) Floats, doubles, and decimals with fractional parts
1:eac0369: 		 *	  are all parsed as "DECIMAL".
1:eac0369: 		 * 3) All strings are parsed as "CHAR" constants (no varchar
1:eac0369: 		 *	  or any others; see stringLiteral() method in
1:eac0369: 		 *	  sqlgrammar.jj).
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		int colType = columnType.getTypeFormatId();
1:eac0369: 		int defType = (defaultType == null ? -1 : defaultType.getTypeFormatId());
1:eac0369: 
1:eac0369: 		if (!defaultNode.isConstantExpression()) {
1:eac0369: 		// then we have a built-in function, such as "user"
1:eac0369: 		// or "current schema".  If the function is a datetime
1:eac0369: 		// value function, then we don't need any special
1:eac0369: 		// action; however, if it's a "user" or "current schema"
1:eac0369: 		// function, then the column must be a char type with
1:eac0369: 		// minimum lengths matching those of DB2 (note that
1:eac0369: 		// such limits are ONLY enforced on defaults, not at
1:eac0369: 		// normal insertion time).
1:eac0369: 
1:eac0369: 			boolean charCol = ((colType == StoredFormatIds.CHAR_TYPE_ID) ||
1:eac0369: 				(colType == StoredFormatIds.VARCHAR_TYPE_ID) ||
1:eac0369: 				(colType == StoredFormatIds.LONGVARCHAR_TYPE_ID));
1:eac0369: 
1:03b7b8d: 			if (defaultNode instanceof SpecialFunctionNode) {
1:2706d1f:                 switch (((SpecialFunctionNode)defaultNode).kind) {
1:2706d1f:                     case SpecialFunctionNode.K_USER:
1:2706d1f:                     case SpecialFunctionNode.K_CURRENT_USER:
1:2706d1f:                     case SpecialFunctionNode.K_CURRENT_ROLE:
1:2706d1f:                     case SpecialFunctionNode.K_SESSION_USER:
1:2706d1f:                     case SpecialFunctionNode.K_SYSTEM_USER:
1:2706d1f:                         // DB2 enforces min length of 8.
1:2706d1f:                         // Note also: any size under 30 gives a warning in DB2.
1:2706d1f:                         return (charCol && (columnDesc.getMaximumWidth() >=
1:2706d1f:                                 Limits.DB2_MIN_COL_LENGTH_FOR_CURRENT_USER));
1:eac0369: 
1:2706d1f:                     case SpecialFunctionNode.K_CURRENT_SCHEMA:
1:2706d1f:                         // DB2 enforces min length of 128.
1:2706d1f:                         return (charCol && (columnDesc.getMaximumWidth() >=
1:2706d1f:                                 Limits.DB2_MIN_COL_LENGTH_FOR_CURRENT_SCHEMA));
1:2706d1f:                     default:
1:2706d1f:                         // else, function not allowed.
1:2706d1f:                         return false;
1:2706d1f:                 }
1:03b7b8d: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		switch (colType) {
1:eac0369: 
1:6ee5782: 			case StoredFormatIds.BOOLEAN_TYPE_ID:
1:6ee5782:                 return ( defaultNode instanceof BooleanConstantNode );
1:6ee5782:                 
1:eac0369: 			case StoredFormatIds.INT_TYPE_ID:
1:eac0369: 			// DB2 doesn't allow floating point values to be used
1:eac0369: 			// as defaults for integer columns (they ARE allowed
1:eac0369: 			// as part of normal insertions, but not as defaults).
1:eac0369: 			// If the default is an integer that's too big, then
1:eac0369: 			// it won't have type INT_TYPE_ID (it'll be either
1:eac0369: 			// LONGINT or DECIMAL)--so we only allow the default
1:eac0369: 			// value if it's integer.
1:eac0369: 				return (defType == StoredFormatIds.INT_TYPE_ID);
1:eac0369: 
1:3bb140c:             case StoredFormatIds.BIGINT_TYPE_ID:
1:844190c: 			// This is a BIGINT column: we allow smallints, ints,
1:844190c: 			// and big int constants.  Smallint and int literals
1:844190c: 			// are both covered by INT_TYPE; big int literals are
1:844190c: 			// covered by LONG_INT type.
1:844190c: 				return ((defType == StoredFormatIds.INT_TYPE_ID)
1:3bb140c:                     || (defType == StoredFormatIds.BIGINT_TYPE_ID));
1:eac0369: 	
1:eac0369: 			case StoredFormatIds.DECIMAL_TYPE_ID:
1:eac0369: 				if (defType == StoredFormatIds.DECIMAL_TYPE_ID) {
1:eac0369: 				// only valid if scale and precision are within
1:eac0369: 				// those of the column.  Note that scale here should
1:cfa2a95: 				// exclude any trailing 0's after the decimal
1:eac0369: 					DataTypeDescriptor defDesc = defaultNode.getTypeServices();
1:eac0369: 					int len = defaultText.length();
1:eac0369: 					int precision = defDesc.getPrecision();
1:eac0369: 					int scale = defDesc.getScale();
1:eac0369: 					for (int i = 1; i <= scale; scale--, precision--) {
1:eac0369: 						if (defaultText.charAt(len - i) != '0')
1:eac0369: 							break;
1:eac0369: 					}
1:eac0369: 					return ((scale <= columnDesc.getScale()) &&
1:eac0369: 						((precision - scale) <=
1:eac0369: 						(columnDesc.getPrecision() - columnDesc.getScale())));
1:eac0369: 				}
1:3bb140c:                 else if ((defType == StoredFormatIds.BIGINT_TYPE_ID) ||
1:eac0369: 					(defType == StoredFormatIds.INT_TYPE_ID)) {
1:eac0369: 				// only valid if number of digits is within limits of
1:eac0369: 				// the decimal column.  We'll check this at insertion time;
1:eac0369: 				// see Beetle 5585 regarding the need to move that check to
1:eac0369: 				// here instead of waiting until insert time.  Until that's
1:eac0369: 				// done, just allow this and wait for insertion...
1:eac0369: 					return true;
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				// no other types allowed.
1:03b7b8d: 					return false;
1:eac0369: 
1:eac0369: 			case StoredFormatIds.CHAR_TYPE_ID:
1:eac0369: 			case StoredFormatIds.VARCHAR_TYPE_ID:
1:eac0369: 			case StoredFormatIds.LONGVARCHAR_TYPE_ID:
1:eac0369: 			// only valid if the default type is a character string.
1:eac0369: 			// That's not to say that all character defaults are
1:eac0369: 			// valid, but we only check for character string here;
1:eac0369: 			// further checking will be done at insertion time.  See
1:eac0369: 			// beetle 5585 regarding the need to move that check
1:eac0369: 			// to here instead of waiting until insert time.
1:eac0369: 				return (defType == StoredFormatIds.CHAR_TYPE_ID);
1:eac0369: 
1:cfa2a95: 			case StoredFormatIds.BIT_TYPE_ID:
1:cfa2a95: 			case StoredFormatIds.VARBIT_TYPE_ID:
1:cfa2a95: 			case StoredFormatIds.LONGVARBIT_TYPE_ID:
1:cfa2a95: 			// only valid if the default type is a BIT string.
1:cfa2a95: 				return (defType == StoredFormatIds.BIT_TYPE_ID);
1:eac0369: 
1:eac0369: 			case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
1:eac0369: 			// default is only valid if it's the same type as the column.
1:eac0369: 				return (defType == colType);
1:eac0369: 
1:cfa2a95: 			case StoredFormatIds.BLOB_TYPE_ID:
1:eac0369: 			case StoredFormatIds.CLOB_TYPE_ID:
1:eac0369: 			case StoredFormatIds.SMALLINT_TYPE_ID:
1:eac0369: 			case StoredFormatIds.REAL_TYPE_ID:
1:eac0369: 			case StoredFormatIds.DOUBLE_TYPE_ID:
1:eac0369: 			case StoredFormatIds.DATE_TYPE_ID:
1:eac0369: 			case StoredFormatIds.TIME_TYPE_ID:
1:eac0369: 			case StoredFormatIds.TIMESTAMP_TYPE_ID:
1:eac0369: 			// For these types, validity checks will be performed
1:94f158a: 			// by Derby at insertion time--see beetle 5585 regarding
1:eac0369: 			// the need to do such checks here instead of later.  For now,
1:eac0369: 			// just assume we're okay.
1:eac0369: 				return true;
1:eac0369: 
1:03b7b8d: 			default:
1:cfa2a95: 			// All other default type checks either 
1:111785f: 			// (TINYINT, etc), or 2) require a DB2 cast-
1:94f158a: 			// function (ex. blob(...), which Derby doesn't
1:eac0369: 			// support yet--see Beetle 5281), and so they are not
1:94f158a: 			// valid for Derby running in DB2 compatibility mode.
4:eac0369: 				return false;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:c9a1206: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:c9a1206: 	 * how tree printing is supposed to work.
1:c9a1206: 	 *
1:c9a1206: 	 * @param depth		The depth of this node in the tree
1:c9a1206: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:c9a1206: 	{
1:c9a1206: 		if (SanityManager.DEBUG)
1:c9a1206: 		{
1:c9a1206: 			super.printSubNodes(depth);
1:c9a1206: 
1:c9a1206: 			if (defaultNode != null) {
1:c9a1206: 				printLabel(depth, "default: ");
1:c9a1206: 				defaultNode.treePrint(depth + 1);
1:c9a1206: 			}
1:c9a1206: 
1:c9a1206: 
1:c9a1206: 			if (generationClauseNode != null) {
1:c9a1206: 				printLabel(depth, "generationClause: ");
1:c9a1206: 				generationClauseNode.treePrint(depth + 1);
1:c9a1206: 			}
1:c9a1206: 		}
1:c9a1206: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:d055adb
/////////////////////////////////////////////////////////////////////////
1:         long                                            autoincrementCycle;
/////////////////////////////////////////////////////////////////////////
1: 				autoincrementCycle = aii[QueryTreeNode.AUTOINCREMENT_CYCLE];
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the autoincrement cycle value
1: 	 *
1: 	 * @return Autoincrement cycle value.
1: 	 */
1: 	long getAutoincrementCycle()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{			SanityManager.ASSERT(isAutoincrement,
1: 					"isAutoincrement expected to be true");
1: 		}
1: 		return autoincrementCycle;
1: 	}
1: 
1: 
1: 	/**
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:fe3c8d8
/////////////////////////////////////////////////////////////////////////
1: 	boolean						keepCurrentDefault;
/////////////////////////////////////////////////////////////////////////
1: 		// ColumnDefinitionNode instances can be subclassed by
1: 		// ModifyColumnNode for use in ALTER TABLE .. ALTER COLUMN
1: 		// statements, in which case the node represents the intended
1: 		// changes to the column definition. For such a case, we
1: 		// record whether or not the statement specified that the
1: 		// column's default value should be changed. If we are to
1: 		// keep the current default, ModifyColumnNode will re-read
1: 		// the current default from the system catalogs prior to
1: 		// performing the column alteration. See DERBY-4006
1: 		// for more discussion of this behavior.
1: 		this.keepCurrentDefault = (defaultNode == null);
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:5b838fd
/////////////////////////////////////////////////////////////////////////
1: 	//alter table command to change the ALWAYS vs DEFAULT nature of an autoinc column
1: 	public static final int MODIFY_AUTOINCREMENT_ALWAYS_VS_DEFAULT = 3;
/////////////////////////////////////////////////////////////////////////
1: 	protected static DefaultInfoImpl createDefaultInfoOfAutoInc(){
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1: 							(List<AggregateNode>) null);
commit:6ee5782
/////////////////////////////////////////////////////////////////////////
1: 			case StoredFormatIds.BOOLEAN_TYPE_ID:
1:                 return ( defaultNode instanceof BooleanConstantNode );
1:                 
commit:e126f58
/////////////////////////////////////////////////////////////////////////
1: 			return "type: " + getType() + "\n" +
commit:d039ced
/////////////////////////////////////////////////////////////////////////
1:         // bind the UDT if necessary
1:         setType( bindUserType( getType() ) );
1: 
commit:fce10ba
/////////////////////////////////////////////////////////////////////////
1:         // continue if this is a generated column and the datatype has been
1:         // omitted. we can't check generation clauses until later on
1:         if ( hasGenerationClause() && (getType() == null ) ) { return; }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		if (td != null && !hasGenerationClause() && !getType().isNullable() && defaultNode == null)
1: 			if (!isAutoincrement )
commit:ec4aa98
/////////////////////////////////////////////////////////////////////////
0: 			if (!isAutoincrement && !hasGenerationClause())
commit:95a483d
/////////////////////////////////////////////////////////////////////////
1:     GenerationClauseNode   generationClauseNode;
/////////////////////////////////////////////////////////////////////////
1: 		else if (defaultNode instanceof GenerationClauseNode)
1: 		{
1:             generationClauseNode = (GenerationClauseNode) defaultNode;
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** Set the type of this column */
1:     public void setType( DataTypeDescriptor dts ) { type = dts; }
/////////////////////////////////////////////////////////////////////////
1: 	 * Set the generation clause (Default) bound to this column.
1: 	 */
1:     public  void    setDefaultInfo( DefaultInfoImpl dii ) { defaultInfo = dii; }
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	 * Return true if this column has a generation clause.
1: 	 */
1: 	public boolean hasGenerationClause() { return ( generationClauseNode != null ); }
1: 
1: 	/**
1: 	 * Get the generation clause.
1: 	 */
0: 	public GenerationClauseNode getGenerationClauseNode() { return generationClauseNode; }
1: 
1: 	/**
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (defaultNode instanceof UntypedNullConstantNode)
/////////////////////////////////////////////////////////////////////////
1:                 switch (((SpecialFunctionNode)defaultNode).kind) {
1:                     case SpecialFunctionNode.K_USER:
1:                     case SpecialFunctionNode.K_CURRENT_USER:
1:                     case SpecialFunctionNode.K_CURRENT_ROLE:
1:                     case SpecialFunctionNode.K_SESSION_USER:
1:                     case SpecialFunctionNode.K_SYSTEM_USER:
1:                         // DB2 enforces min length of 8.
1:                         // Note also: any size under 30 gives a warning in DB2.
1:                         return (charCol && (columnDesc.getMaximumWidth() >=
1:                                 Limits.DB2_MIN_COL_LENGTH_FOR_CURRENT_USER));
1:                     case SpecialFunctionNode.K_CURRENT_SCHEMA:
1:                         // DB2 enforces min length of 128.
1:                         return (charCol && (columnDesc.getMaximumWidth() >=
1:                                 Limits.DB2_MIN_COL_LENGTH_FOR_CURRENT_SCHEMA));
1:                     default:
1:                         // else, function not allowed.
1:                         return false;
1:                 }
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextManager;
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a ColumnDefinitionNode
1:      * @param autoIncrementInfo Info for auto-increment columns
1:      * @param cm            The context manager
1:     ColumnDefinitionNode(
1:                     String name,
1:                     ValueNode defaultNode,
1:                     DataTypeDescriptor dataTypeServices,
1:                     long[] autoIncrementInfo,
1:                     ContextManager cm)
1:         super(name, cm);
0:         setNodeType(C_NodeTypes.COLUMN_DEFINITION_NODE);
1:         this.type = dataTypeServices;
/////////////////////////////////////////////////////////////////////////
1:                 long[] aii = autoIncrementInfo;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     String getColumnName()
/////////////////////////////////////////////////////////////////////////
1:     final DataTypeDescriptor getType()
/////////////////////////////////////////////////////////////////////////
1:     final void setNullability(boolean nullable)
/////////////////////////////////////////////////////////////////////////
1:     DataValueDescriptor getDefaultValue()
/////////////////////////////////////////////////////////////////////////
1:     DefaultInfo getDefaultInfo()
/////////////////////////////////////////////////////////////////////////
1:     DefaultNode getDefaultNode()
/////////////////////////////////////////////////////////////////////////
1:     GenerationClauseNode getGenerationClauseNode() {
1:         return generationClauseNode;
1:     }
1:     boolean isAutoincrementColumn()
/////////////////////////////////////////////////////////////////////////
1:     void checkUserType(TableDescriptor td)
/////////////////////////////////////////////////////////////////////////
1:     void validateAutoincrement(DataDictionary dd,
1:                                TableDescriptor td,
1:                                int tableType) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:                                     TypeId.BIGINT_NAME);
/////////////////////////////////////////////////////////////////////////
1:                             new FromList(
1:                                 getOptimizerFactory().doJoinOrderOptimization(),
/////////////////////////////////////////////////////////////////////////
1:     boolean defaultTypeIsValid(TypeId columnType,
/////////////////////////////////////////////////////////////////////////
1:             case StoredFormatIds.BIGINT_TYPE_ID:
1:                     || (defType == StoredFormatIds.BIGINT_TYPE_ID));
/////////////////////////////////////////////////////////////////////////
1:                 else if ((defType == StoredFormatIds.BIGINT_TYPE_ID) ||
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
commit:f1c232e
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
0: import java.util.Vector;
1: import org.apache.derby.catalog.DefaultInfo;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.catalog.types.DefaultInfoImpl;
1: import org.apache.derby.iapi.reference.Limits;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: import org.apache.derby.iapi.services.loader.ClassInspector;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.depend.ProviderList;
/////////////////////////////////////////////////////////////////////////
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
1:     /**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 */
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (defaultNode != null) {
1: 				printLabel(depth, "default: ");
1: 				defaultNode.treePrint(depth + 1);
1: 			}
1: 
1: 
1: 			if (generationClauseNode != null) {
1: 				printLabel(depth, "generationClause: ");
1: 				generationClauseNode.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
commit:ee59de8
/////////////////////////////////////////////////////////////////////////
0: 				case C_NodeTypes.CURRENT_ROLE_NODE:
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:47d4a4c
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 							(List) null);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9ed7c4d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Set the collation type, note derivation is always
1:      * implicit for any catalog item.
1:      */
1:     void setCollationType(int collationType)
1:     {
1:         type = getType().getCollatedType(collationType,
1:                 StringDataValue.COLLATION_DERIVATION_IMPLICIT);
1:     }
commit:7dda5d5
/////////////////////////////////////////////////////////////////////////
1:     DataTypeDescriptor type;
/////////////////////////////////////////////////////////////////////////
0: 		this.type = (DataTypeDescriptor) dataTypeServices;
/////////////////////////////////////////////////////////////////////////
1: 									convertDefaultNode(this.type);
/////////////////////////////////////////////////////////////////////////
1:                     setNullability(false);
/////////////////////////////////////////////////////////////////////////
0: 			return "type: " + getType().toString() + "\n" +
/////////////////////////////////////////////////////////////////////////
1: 	 * Returns the data type of the column being defined.
1: 	 * @return	the data type of the column
0: 	public final DataTypeDescriptor getType()
1: 		return type;
1:     
1:     /**
1:      * Set the nullability of the column definition node.
1:       */
0:     void setNullability(boolean nullable)
1:     {
1:         type = getType().getNullabilityType(nullable);
1:     }
/////////////////////////////////////////////////////////////////////////
1: 		if (!getType().getTypeId().userType())
1: 			getType().getTypeId().getCorrespondingJavaTypeName();
/////////////////////////////////////////////////////////////////////////
0: 		if (td != null && !getType().isNullable() && defaultNode == null)
/////////////////////////////////////////////////////////////////////////
1: 		int jdbctype = getType().getTypeId().getJDBCTypeId();
/////////////////////////////////////////////////////////////////////////
1: 			TypeId columnTypeId = getType().getTypeId();
1: 			if (!defaultTypeIsValid(columnTypeId, getType(),
commit:ed82406
/////////////////////////////////////////////////////////////////////////
1:                 if (dataTypeServices != null)
0:                     this.dataTypeServices = getDataTypeServices().getNullabilityType(false);
/////////////////////////////////////////////////////////////////////////
0: 			TypeId columnTypeId = dataTypeServices.getTypeId();
commit:cb8f109
/////////////////////////////////////////////////////////////////////////
1: 	
1:     /**
1:      * The data type of this column.
1:      */
0:     DataTypeDescriptor			dataTypeServices;
1:     
/////////////////////////////////////////////////////////////////////////
0: 	public final DataTypeDescriptor getDataTypeServices()
commit:08d6ce2
/////////////////////////////////////////////////////////////////////////
0: 		if (!dataTypeServices.getTypeId().userType())
commit:2542f1d
/////////////////////////////////////////////////////////////////////////
commit:03b7b8d
/////////////////////////////////////////////////////////////////////////
1: 			if (defaultNode instanceof SpecialFunctionNode) {
0: 				switch (defaultNode.getNodeType())
1: 				{
0: 				case C_NodeTypes.USER_NODE:
0: 				case C_NodeTypes.CURRENT_USER_NODE:
0: 				case C_NodeTypes.SESSION_USER_NODE:
0: 				case C_NodeTypes.SYSTEM_USER_NODE:
0: 				case C_NodeTypes.CURRENT_SCHEMA_NODE:
1: 				default:
0: 					// else, function not allowed.
1: 					return false;
1: 				}
commit:867a530
/////////////////////////////////////////////////////////////////////////
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
/////////////////////////////////////////////////////////////////////////
1: 		CompilerContext cc = getCompilerContext();
/////////////////////////////////////////////////////////////////////////
1: 			/*
1: 				Defaults cannot have dependencies as they
1: 				should just be constants. Code used to exist
1: 				to handle dependencies in defaults, now this
1: 				is under sanity to ensure no dependencies exist.
1: 			ProviderList apl = null;
1: 			ProviderList prevAPL = null;
1: 			if (SanityManager.DEBUG) {
1: 				apl = new ProviderList();
1: 				prevAPL = cc.getCurrentAuxiliaryProviderList();
1: 				cc.setCurrentAuxiliaryProviderList(apl);
1: 			}
1: 			
/////////////////////////////////////////////////////////////////////////
1: 			if (SanityManager.DEBUG)
1: 				/* Save the APL off in the constraint node */
1: 				if (apl.size() > 0)
1: 				{
1: 					SanityManager.THROWASSERT("DEFAULT clause has unexpected dependencies");
1: 				}
1: 				// Restore the previous AuxiliaryProviderList
1: 				cc.setCurrentAuxiliaryProviderList(prevAPL);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.ColumnDefinitionNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.loader.ClassInspector;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.reference.DB2Limit;
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.depend.ProviderList;
0: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.impl.sql.execute.ColumnInfo;
1: 
0: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.catalog.DefaultInfo;
0: import org.apache.derby.catalog.UUID;
1: 
0: import org.apache.derby.catalog.types.DefaultInfoImpl;
1: 
0: import java.util.Vector;
0: import java.sql.Types;
1: 
1: /**
1:  * A ColumnDefinitionNode represents a column definition in a DDL statement.
1:  * There will be a ColumnDefinitionNode for each column in a CREATE TABLE
1:  * statement, and for the column in an ALTER TABLE ADD COLUMN statement.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
1: public class ColumnDefinitionNode extends TableElementNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	boolean						isAutoincrement;
0: 	DataTypeDescriptor			dataTypeServices;
1: 	DataValueDescriptor			defaultValue;
1: 	DefaultInfoImpl				defaultInfo;
1: 	DefaultNode					defaultNode;
1: 	long						autoincrementIncrement;
1: 	long						autoincrementStart;
1: 	boolean						autoincrementVerify;
1: 
1: 	/**
0: 	 * Initializer for a ColumnDefinitionNode
1: 	 *
1: 	 * @param name			The name of the column
1: 	 * @param defaultNode	The default value of the column
1: 	 * @param dataTypeServices	A DataTypeServices telling the type
1: 	 *				of the column
0: 	 * @param autoIncrementInfo	Info for autoincrement columns
1: 	 *
1: 	 */
1: 
0: 	public void init(
0: 					Object name,
0: 					Object defaultNode,
0: 					Object dataTypeServices,
0: 					Object autoIncrementInfo)
1: 		throws StandardException
1: 	{
0: 		super.init(name);
0: 		this.dataTypeServices = (DataTypeDescriptor) dataTypeServices;
0: 		if (defaultNode instanceof UntypedNullConstantNode)
1: 		{
1: 			/* No DTS yet for MODIFY DEFAULT */
1: 			if (dataTypeServices != null)
1: 			{
1: 				defaultValue = 
1: 					((UntypedNullConstantNode) defaultNode).
0: 									convertDefaultNode(this.dataTypeServices);
1: 			}
1: 		}
1: 		else
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				if (defaultNode != null &&
1: 					! (defaultNode instanceof DefaultNode))
1: 				{
1: 					SanityManager.THROWASSERT(
1: 						"defaultNode expected to be instanceof DefaultNode, not " +
1: 						defaultNode.getClass().getName());
1: 				}
1: 			}
1: 			this.defaultNode = (DefaultNode) defaultNode;
1: 			if (autoIncrementInfo != null)
1: 			{
0: 				long[] aii = (long[]) autoIncrementInfo;
1: 				autoincrementStart = aii[QueryTreeNode.AUTOINCREMENT_START_INDEX];
1: 				autoincrementIncrement = aii[QueryTreeNode.AUTOINCREMENT_INC_INDEX];
1: 
1: 				/*
1: 				 * If using DB2 syntax to set increment value, will need to check if column
1: 				 * is already created for autoincrement.
1: 				 */
1: 				autoincrementVerify = (aii[QueryTreeNode.AUTOINCREMENT_IS_AUTOINCREMENT_INDEX] > 0) ? false : true;
1: 				isAutoincrement = true;
1: 				// an autoincrement column cannot be null-- setting
1: 				// non-nullability for this column is needed because 
1: 				// you could create a column with ai default, add data, drop 
1: 				// the default, and try to add it back again you'll get an
1: 				// error because the column is marked nullable.
1: 				if (dataTypeServices != null)
0: 					(this.dataTypeServices).setNullability(false);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			return "dataTypeServices: " + dataTypeServices.toString() + "\n" +
1: 				"defaultValue: " + defaultValue + "\n" +
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Returns the unqualified name of the column being defined.
1: 	 *
1: 	 * @return	the name of the column
1: 	 */
0: 	public String getColumnName()
1: 	{
1: 		return this.name;
1: 	}
1: 
1: 	/**
0: 	 * Returns the data type services of the column being defined.
1: 	 *
0: 	 * @return	the data type services of the column
1: 	 */
0: 	public DataTypeDescriptor getDataTypeServices()
1: 	{
0: 		return this.dataTypeServices;
1: 	}
1: 
1: 	/**
1: 	 * Return the DataValueDescriptor containing the default value for this
1: 	 * column
1: 	 *
1: 	 * @return	The default value of the column
1: 	 */
1: 
0: 	public DataValueDescriptor getDefaultValue()
1: 	{
1: 		return this.defaultValue;
1: 	}
1: 
1: 	/**
1: 	 * Return the DefaultInfo containing the default information for this
1: 	 * column
1: 	 *
1: 	 * @return	The default info for the column
1: 	 */
1: 
0: 	public DefaultInfo getDefaultInfo()
1: 	{
1: 		return defaultInfo;
1: 	}
1: 
1: 	/**
1: 	 * Return the DefaultNode, if any, associated with this node.
1: 	 *
1: 	 * @return The DefaultNode, if any, associated with this node.
1: 	 */
0: 	public DefaultNode getDefaultNode()
1: 	{
1: 		return defaultNode;
1: 	}
1: 
1: 	/**
1: 	 * Is this an autoincrement column?
1: 	 *
1: 	 * @return Whether or not this is an autoincrement column.
1: 	 */
0: 	public boolean isAutoincrementColumn()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			if (isAutoincrement && autoincrementIncrement == 0)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"autoincrementIncrement expected to be non-zero");
1: 			}
1: 			if ((! isAutoincrement) && 
1: 				(autoincrementStart != 0 || autoincrementIncrement != 0))
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"both autoincrementStart and autoincrementIncrement expected to be 0");
1: 			}
1: 		}
1: 		return isAutoincrement;
1: 	}
1: 
1: 	/**
1: 	 * Get the autoincrement start value
1: 	 *
1: 	 * @return Autoincrement start value.
1: 	 */
1: 	long getAutoincrementStart()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(isAutoincrement,
1: 				"isAutoincrement expected to be true");
1: 		}
1: 		return autoincrementStart;
1: 	}
1: 
1: 	/**
1: 	 * Get the autoincrement increment value
1: 	 *
1: 	 * @return Autoincrement increment value.
1: 	 */
1: 	long getAutoincrementIncrement()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(isAutoincrement,
1: 				"isAutoincrement expected to be true");
1: 		}
1: 		return autoincrementIncrement;
1: 	}
1: 
1: 	/**
1: 	 * Check the validity of a user type.  Checks whether this column
1: 	 * definition describes a user type that either doesn't exist or is
1: 	 * inaccessible, or that doesn't implement Serializable.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void checkUserType(TableDescriptor td) 
1: 		throws StandardException
1: 	{
1: 		String			columnTypeName;
1: 
1: 		/* Built-in types need no checking */
0: 		if (dataTypeServices.getTypeId().builtIn())
1: 			return;
1: 
1: 		ClassInspector classInspector = getClassFactory().getClassInspector();
1: 
1: 		columnTypeName =
0: 			dataTypeServices.getTypeId().getCorrespondingJavaTypeName();
1: 
1: 
1: 
1: 
1: 		/* User type - We first check for the columnTypeName as a java class.
1: 		 * If that fails, then we treat it as a class alias.
1: 		 */
1: 
1: 		boolean foundMatch = false;
1: 		Throwable reason = null;
1: 		try {
1: 			foundMatch = classInspector.accessible(columnTypeName);
1: 		} catch (ClassNotFoundException cnfe) {
1: 			reason = cnfe;
0: 		} catch (LinkageError le) {
0: 			reason = le;
1: 		}
1: 
1: 		if (!foundMatch)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_TYPE_DOESNT_EXIST, reason, columnTypeName,
1: 																name);
1: 		}
1: 
1: 		if (! classInspector.assignableTo(columnTypeName,
1: 											"java.io.Serializable")  &&
1:             // Before Java2, SQLData is not defined, assignableTo call returns false
1:             ! classInspector.assignableTo(columnTypeName,"java.sql.SQLData"))
1:         {
1: 			getCompilerContext().addWarning(
1: 				StandardException.newWarning(SQLState.LANG_TYPE_NOT_SERIALIZABLE, columnTypeName,
1: 																 name));
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the UUID of the old column default.
1: 	 *
1: 	 * @return The UUID of the old column default.
1: 	 */
1: 	UUID getOldDefaultUUID()
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Get the action associated with this node.
1: 	 *
1: 	 * @return The action associated with this node.
1: 	 */
1: 	int getAction()
1: 	{
1: 		return ColumnInfo.CREATE;
1: 	}
1: 
1: 	/**
1: 	 * Check the validity of the default, if any, for this node.
1: 	 *
1: 	 * @param dd		The DataDictionary.
1: 	 * @param td		The TableDescriptor.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void bindAndValidateDefault(DataDictionary dd, TableDescriptor td)
1: 		throws StandardException
1: 	{
1: 		/* DB2 requires non-nullable columns to have a default in ALTER TABLE */
0: 		if (td != null && !dataTypeServices.isNullable() && defaultNode == null)
1: 		{
0: 			if (!isAutoincrement)
1: 				throw StandardException.newException(SQLState.LANG_DB2_NOT_NULL_COLUMN_INVALID_DEFAULT, getColumnName());
1: 		}
1: 			
1: 		// No work to do if no user specified default
1: 		if (defaultNode == null)
1: 		{
1: 			return;
1: 		}
1: 
1: 		// No work to do if user specified NULL
1: 		if (defaultValue != null)
1: 		{
1: 			return;
1: 		}
1: 
1: 		// Now validate the default
1: 		validateDefault(dd, td);
1: 	}
1: 
1: 
1: 	/**
1: 	 * Check the validity of the autoincrement values for this node.
1: 	 * The following errors are thrown by this routine.
1: 	 * 1. 42z21 Invalid Increment; i.e 0.
1: 	 * 2. 42z22 Invalid Type; autoincrement created on a non-exact-numeric type
1: 	 * 3. 42995 The requested function does not apply to global temporary tables
1: 	 *
1: 	 * @param 		dd		DataDictionary.
1: 	 * @param		td		table descriptor.
1: 	 * @param		tableType	base table or declared global temporary table.
1: 	 *
1: 	 * @exception 	StandardException if autoincrement default is incorrect; i.e
1: 	 * 				if increment is 0 or if initial or increment values are out
1: 	 * 				of range for the datatype.
1: 	 */
0: 	public void validateAutoincrement(DataDictionary dd, TableDescriptor td, int tableType)
1: 	     throws StandardException
1: 	{
1: 		if (isAutoincrement == false)
1: 			return;
1: 
1: 		if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
1: 			throw StandardException.newException(SQLState.LANG_NOT_ALLOWED_FOR_DECLARED_GLOBAL_TEMP_TABLE);
1: 
0: 		if (autoincrementIncrement == 0)
1: 			throw StandardException.newException(SQLState.LANG_AI_INVALID_INCREMENT, getColumnName());
0: 		int jdbctype = dataTypeServices.getTypeId().getJDBCTypeId();
1: 		switch (jdbctype)
1: 		{
1: 		case Types.TINYINT:
1: 			autoincrementCheckRange((long)Byte.MIN_VALUE, 
1: 									(long)Byte.MAX_VALUE, 
1: 									TypeId.TINYINT_NAME);
1: 			break;
1: 		case Types.SMALLINT:
1: 			autoincrementCheckRange((long)Short.MIN_VALUE, 
1: 									(long)Short.MAX_VALUE,
1: 									TypeId.SMALLINT_NAME);
1: 			break;
1: 		case Types.INTEGER:
1: 			autoincrementCheckRange((long)Integer.MIN_VALUE, 
1: 									(long)Integer.MAX_VALUE,
1: 									TypeId.INTEGER_NAME);
1: 			break;
1: 		case Types.BIGINT:
1: 			autoincrementCheckRange(Long.MIN_VALUE, Long.MAX_VALUE,
0: 									TypeId.LONGINT_NAME);
1: 			break;
1: 		default:
1: 			throw StandardException.newException(SQLState.LANG_AI_INVALID_TYPE,
1: 												 getColumnName());
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * checks to see if autoincrementIncrement and autoincrementInitial
1: 	 * are within the bounds of the type whose min and max values are
1: 	 * passed into this routine.
1: 	 */
1: 	private	void autoincrementCheckRange(long minValue, long maxValue,
1: 									String typeName)
1: 				throws StandardException					
1: 	{
1: 		if ((minValue > autoincrementIncrement) || 
1: 			(maxValue < autoincrementIncrement))
1: 		{
1: 			throw StandardException.newException(
1: 								 SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, typeName);
1: 		}
1: 		if ((minValue > autoincrementStart) || 
1: 			(maxValue < autoincrementStart))
1: 		{
1: 			throw StandardException.newException(
1: 								 SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, typeName);
1: 		}			
1: 	}
1: 	/**
1: 	 * Check the validity of the default for this node.
1: 	 *
1: 	 * @param td		The TableDescriptor.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void validateDefault(DataDictionary dd, TableDescriptor td)
1: 		throws StandardException
1: 	{
0: 		CompilerContext cc;
1: 
1: 		if (defaultNode == null)
1: 			return;
1: 
0: 		cc = getCompilerContext();
1: 
1: 		ValueNode defaultTree = defaultNode.getDefaultTree();
1: 
1: 		/* bind the default.
1: 		 * Verify that it does not contain any ColumnReferences or subqueries
1: 		 * and that it is type compatable with the column.
1: 		 */
1: 		final int previousReliability = cc.getReliability();
1: 		try
1: 		{
0: 			/* Each default can have its own set of dependencies.
0: 			 * These dependencies need to be shared with the prepared
0: 			 * statement as well.  We create a new auxiliary provider list
0: 			 * for the default, "push" it on the compiler context
0: 			 * by swapping it with the current auxiliary provider list
0: 			 * and the "pop" it when we're done by restoring the old 
0: 			 * auxiliary provider list.
1: 			 */
0: 			ProviderList apl = new ProviderList();
1: 
0: 			ProviderList prevAPL = cc.getCurrentAuxiliaryProviderList();
0: 			cc.setCurrentAuxiliaryProviderList(apl);
1: 
1: 			// Tell the compiler context to only allow deterministic nodes
1: 			cc.setReliability( CompilerContext.DEFAULT_RESTRICTION );
1: 			defaultTree = defaultTree.bindExpression(
0: 							(FromList) getNodeFactory().getNode(
0: 								C_NodeTypes.FROM_LIST,
0: 								getNodeFactory().doJoinOrderOptimization(),
1: 								getContextManager()), 
1: 							(SubqueryList) null,
0: 							(Vector) null);
1: 
0: 			TypeId columnTypeId = (TypeId) dataTypeServices.getTypeId();
1: 			TypeId defaultTypeId = defaultTree.getTypeId();
1: 
1: 			// Check for 'invalid default' errors (42894)
1: 			// before checking for 'not storable' errors (42821).
0: 			if (!defaultTypeIsDB2Valid(columnTypeId, dataTypeServices,
1: 					defaultTypeId, defaultTree, defaultNode.getDefaultText()))
1: 			{
1: 					throw StandardException.newException(
1: 						SQLState.LANG_DB2_INVALID_DEFAULT_VALUE,
1: 						this.name);
1: 			}
1: 
1: 			// Now check 'not storable' errors.
1: 			if (! getTypeCompiler(columnTypeId).
1: 								storable(defaultTypeId, getClassFactory()))
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_NOT_STORABLE, 
1: 					columnTypeId.getSQLTypeName(),
1: 					defaultTypeId.getSQLTypeName() );
1: 			}
1: 
1: 			// Save off the default text
1: 			// RESOLVEDEFAULT - Convert to constant if possible
0: 			defaultInfo = new DefaultInfoImpl(defaultNode.getDefaultText(), defaultValue);
1: 
0: 			/* Save the APL off in the constraint node */
0: 			if (apl.size() > 0)
1: 			{
0: 				defaultNode.setAuxiliaryProviderList(apl);
0: 				// Add info on any providers to DefaultInfo
0: 				ProviderInfo[]	providerInfos = null;
1: 
0: 				/* Get all the dependencies for the current statement and transfer
0: 				 * them to this view.
1: 				 */
0: 				DependencyManager dm;
0: 				dm = dd.getDependencyManager();
0: 				providerInfos = dm.getPersistentProviderInfos(apl);
0: 				defaultInfo.setProviderInfo(providerInfos);
1: 			}
1: 
0: 			// Restore the previous AuxiliaryProviderList
0: 			cc.setCurrentAuxiliaryProviderList(prevAPL);
1: 		}
1: 		finally
1: 		{
1: 			cc.setReliability(previousReliability);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Check the validity of the default for this node
0: 	 * with respect to restrictions imposed by DB2 that
0: 	 * Cloudscape doesn't normally disallow (Beetle 5203).
1: 	 *
0: 	 * NOTE: that the only checks currently here are those
0: 	 * which DB2 enforces on DEFAULTS but does NOT enforce
0: 	 * on normal insertion.  At some point, we may want
0: 	 * move other checks, currently performed at insertion,
0: 	 * to here to mimic DB2 behavior (beetle 5585), but
0: 	 * that is not yet how we do it.
1: 	 *
1: 	 * @param columnType TypeId of the target column.
1: 	 * @param columnDesc Description of the type of the
1: 	 *		target column.
1: 	 * @param defaultType TypeId of the default node.
1: 	 * @param defaultNode Parsed ValueNode for the default value.
1: 	 * @param defaultText Unparsed default value (as entered
1: 	 * 		by user).
1: 	 * @return True if the defaultNode abides by the restrictions
1: 	 * 	imposed by DB2 on default constants; false otherwise.
1: 	 *
1: 	 */
1: 
0: 	public boolean defaultTypeIsDB2Valid(TypeId columnType,
1: 		DataTypeDescriptor columnDesc, TypeId defaultType,
1: 		ValueNode defaultNode, String defaultText)
1: 	{
1: 
0: 		if (defaultText.length() > DB2Limit.DB2_CHAR_MAXWIDTH)
0: 		// DB2 spec says this isn't allowed.
1: 			return false;
1: 
1: 		/* We can use info about the way the parser works
1: 		 * to guide this process a little (see the getNumericNode()
1: 		 * method in sqlgrammar.jj):
1: 		 *
1: 		 * 1) Tinyint and Smallints are both parsed as "INT" types,
1: 	 	 *	  while integers larger than a basic "INT" are parsed into
1: 		 *	  "LONGINT" or, if needed, "DECIMAL".
1: 		 * 2) Floats, doubles, and decimals with fractional parts
1: 		 *	  are all parsed as "DECIMAL".
1: 		 * 3) All strings are parsed as "CHAR" constants (no varchar
1: 		 *	  or any others; see stringLiteral() method in
1: 		 *	  sqlgrammar.jj).
1: 		 */
1: 
1: 		int colType = columnType.getTypeFormatId();
1: 		int defType = (defaultType == null ? -1 : defaultType.getTypeFormatId());
1: 
1: 		if (!defaultNode.isConstantExpression()) {
1: 		// then we have a built-in function, such as "user"
1: 		// or "current schema".  If the function is a datetime
1: 		// value function, then we don't need any special
1: 		// action; however, if it's a "user" or "current schema"
1: 		// function, then the column must be a char type with
1: 		// minimum lengths matching those of DB2 (note that
1: 		// such limits are ONLY enforced on defaults, not at
1: 		// normal insertion time).
1: 
1: 			boolean charCol = ((colType == StoredFormatIds.CHAR_TYPE_ID) ||
1: 				(colType == StoredFormatIds.VARCHAR_TYPE_ID) ||
1: 				(colType == StoredFormatIds.LONGVARCHAR_TYPE_ID));
1: 
0: 			if (defaultNode instanceof CurrentUserNode) {
1: 
0: 				defaultText = defaultText.toLowerCase(java.util.Locale.ENGLISH);
0: 				if (defaultText.indexOf("user") != -1)
0: 				// DB2 enforces min length of 8.
0: 				// Note also: any size under 30 gives a warning in DB2.
0: 					return (charCol && (columnDesc.getMaximumWidth() >=
0: 						DB2Limit.MIN_COL_LENGTH_FOR_CURRENT_USER));
1: 
0: 				if ((defaultText.indexOf("schema") != -1) ||
0: 					(defaultText.indexOf("sqlid") != -1))
0: 				// DB2 enforces min length of 128.
0: 					return (charCol && (columnDesc.getMaximumWidth() >=
0: 						DB2Limit.MIN_COL_LENGTH_FOR_CURRENT_SCHEMA));
1: 
0: 				// else, function not allowed.
1: 				return false;
1: 
1: 			}
1: 
1: 		}
1: 
1: 		switch (colType) {
1: 
1: 			case StoredFormatIds.INT_TYPE_ID:
1: 			// DB2 doesn't allow floating point values to be used
1: 			// as defaults for integer columns (they ARE allowed
1: 			// as part of normal insertions, but not as defaults).
1: 			// If the default is an integer that's too big, then
1: 			// it won't have type INT_TYPE_ID (it'll be either
1: 			// LONGINT or DECIMAL)--so we only allow the default
1: 			// value if it's integer.
1: 				return (defType == StoredFormatIds.INT_TYPE_ID);
1: 
1: 			case StoredFormatIds.DECIMAL_TYPE_ID:
1: 				if (defType == StoredFormatIds.DECIMAL_TYPE_ID) {
1: 				// only valid if scale and precision are within
1: 				// those of the column.  Note that scale here should
0: 				// exclude any trailing 0's after the decimal, per
0: 				// the DB2 spec.
1: 					DataTypeDescriptor defDesc = defaultNode.getTypeServices();
1: 					int len = defaultText.length();
1: 					int precision = defDesc.getPrecision();
1: 					int scale = defDesc.getScale();
1: 					for (int i = 1; i <= scale; scale--, precision--) {
1: 						if (defaultText.charAt(len - i) != '0')
1: 							break;
1: 					}
1: 					return ((scale <= columnDesc.getScale()) &&
1: 						((precision - scale) <=
1: 						(columnDesc.getPrecision() - columnDesc.getScale())));
1: 				}
0: 				else if ((defType == StoredFormatIds.LONGINT_TYPE_ID) ||
1: 					(defType == StoredFormatIds.INT_TYPE_ID)) {
1: 				// only valid if number of digits is within limits of
1: 				// the decimal column.  We'll check this at insertion time;
1: 				// see Beetle 5585 regarding the need to move that check to
1: 				// here instead of waiting until insert time.  Until that's
1: 				// done, just allow this and wait for insertion...
1: 					return true;
1: 				}
1: 				else
1: 				// no other types allowed.
1: 					return false;
1: 
1: 			case StoredFormatIds.CHAR_TYPE_ID:
1: 			case StoredFormatIds.VARCHAR_TYPE_ID:
1: 			case StoredFormatIds.LONGVARCHAR_TYPE_ID:
1: 			// only valid if the default type is a character string.
1: 			// That's not to say that all character defaults are
1: 			// valid, but we only check for character string here;
1: 			// further checking will be done at insertion time.  See
1: 			// beetle 5585 regarding the need to move that check
1: 			// to here instead of waiting until insert time.
1: 				return (defType == StoredFormatIds.CHAR_TYPE_ID);
1: 
1: 			case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
1: 			// default is only valid if it's the same type as the column.
1: 				return (defType == colType);
1: 
1: 			case StoredFormatIds.CLOB_TYPE_ID:
1: 			case StoredFormatIds.SMALLINT_TYPE_ID:
1: 			case StoredFormatIds.REAL_TYPE_ID:
1: 			case StoredFormatIds.DOUBLE_TYPE_ID:
1: 			case StoredFormatIds.DATE_TYPE_ID:
1: 			case StoredFormatIds.TIME_TYPE_ID:
1: 			case StoredFormatIds.TIMESTAMP_TYPE_ID:
1: 			// For these types, validity checks will be performed
0: 			// by Cloudscape at insertion time--see beetle 5585 regarding
1: 			// the need to do such checks here instead of later.  For now,
1: 			// just assume we're okay.
1: 				return true;
1: 
1: 			default:
0: 			// All other default type checks either 1) involve
0: 			// types which are not supported in DB2 mode (such as BIT,
0: 			// TINYINT, NATIONAL_CHAR, etc), or 2) require a DB2 cast-
0: 			// function (ex. blob(...), which Cloudscape doesn't
1: 			// support yet--see Beetle 5281), and so they are not
0: 			// valid for Cloudscape running in DB2 compatibility mode.
1: 				return false;
1: 
1: 		}
1: 
1: 	}
1: 
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:111785f
/////////////////////////////////////////////////////////////////////////
1: 			// (TINYINT, etc), or 2) require a DB2 cast-
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 			// by Derby at insertion time--see beetle 5585 regarding
/////////////////////////////////////////////////////////////////////////
1: 			// function (ex. blob(...), which Derby doesn't
1: 			// valid for Derby running in DB2 compatibility mode.
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:6a5edfc
/////////////////////////////////////////////////////////////////////////
1: 	//This variable tells if the autoincrement column is participating 
1: 	//in create or alter table. And if it is participating in alter
1: 	//table, then it further knows if it is represting a change in 
1: 	//increment value or a change in start value.
1: 	//This information is later used to make sure that the autoincrement
1: 	//column's increment value is not 0 at the time of create, or is not
1: 	//getting set to 0 at the time of increment value modification.
1: 	long						autoinc_create_or_modify_Start_Increment;
1: 	//autoinc_create_or_modify_Start_Increment will be set to one of the
1: 	//following 3 values.
1: 	//CREATE_AUTOINCREMENT - this autoincrement column definition is for create table
1: 	public static final int CREATE_AUTOINCREMENT = 0;
1: 	//MODIFY_AUTOINCREMENT_RESTART_VALUE - this column definition is for
1: 	//alter table command to change the start value of the column
1: 	public static final int MODIFY_AUTOINCREMENT_RESTART_VALUE = 1;
1: 	//MODIFY_AUTOINCREMENT_INC_VALUE - this column definition is for
1: 	//alter table command to change the increment value of the column
1: 	public static final int MODIFY_AUTOINCREMENT_INC_VALUE = 2;
0: 	
/////////////////////////////////////////////////////////////////////////
1: 				//Parser has passed the info about autoincrement column's status in the
1: 				//following array element. It will tell if the autoinc column is part of 
1: 				//a create table or if is a part of alter table. And if it is part of 
1: 				//alter table, is it for changing the increment value or for changing 
1: 				//the start value?
1: 				autoinc_create_or_modify_Start_Increment = aii[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY];
0: 				
/////////////////////////////////////////////////////////////////////////
1: 			//increment value for autoincrement column can't be 0 if the autoinc column
1: 			//is part of create table or it is part of alter table to change the 
1: 			//increment value. 
1: 			if (isAutoincrement && autoincrementIncrement == 0 && 
1: 					(autoinc_create_or_modify_Start_Increment == ColumnDefinitionNode.CREATE_AUTOINCREMENT ||
1: 							autoinc_create_or_modify_Start_Increment == ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE))
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the status of this autoincrement column 
0: 	 *
1: 	 * @return ColumnDefinitionNode.CREATE_AUTOINCREMENT - 
1: 	 * 		if this definition is for autoincrement column creatoin
1: 	 *   ColumnDefinitionNode.MODIFY_AUTOINCREMENT_RESTART_VALUE -
1: 	 * 		if this definition is for alter sutoincrement column to change the start value 
1: 	 *   ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE 
1: 	 * 		if this definition is for alter autoincrement column to change the increment value
0: 	 */
1: 	long getAutoinc_create_or_modify_Start_Increment()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(isAutoincrement,
1: 				"isAutoincrement expected to be true");
1: 		}
1: 		return autoinc_create_or_modify_Start_Increment;
1: 	}
0: 	
0: 	/**
/////////////////////////////////////////////////////////////////////////
1: 		//increment value for autoincrement column can't be 0 if the autoinc column
1: 		//is part of create table or it is part of alter table to change the 
1: 		//increment value. 
1: 		if (autoincrementIncrement == 0 && 
1: 				(autoinc_create_or_modify_Start_Increment == ColumnDefinitionNode.CREATE_AUTOINCREMENT ||
1: 						autoinc_create_or_modify_Start_Increment == ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE))
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
0: 	throws StandardException
commit:b0ad765
/////////////////////////////////////////////////////////////////////////
1: 		//Examin whether default value is autoincrement.
1: 		if (isAutoincrement){
1: 			defaultInfo = createDefaultInfoOfAutoInc();
1: 			return;
1: 		}
0: 		
0: 		
1: 		//Judged as default value is constant value.
0: 		
/////////////////////////////////////////////////////////////////////////
1: 			defaultInfo = new DefaultInfoImpl(false,
1: 							  defaultNode.getDefaultText(), 
1: 							  defaultValue);
/////////////////////////////////////////////////////////////////////////
0: 
0: 	private static DefaultInfoImpl createDefaultInfoOfAutoInc(){
1: 		return new DefaultInfoImpl(true,
1: 					   null, 
1: 					   null);
0: 	}
0: 	
0: 
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
0: 		if (defaultText.length() > Limits.DB2_CHAR_MAXWIDTH)
/////////////////////////////////////////////////////////////////////////
0: 						Limits.DB2_MIN_COL_LENGTH_FOR_CURRENT_USER));
0: 						Limits.DB2_MIN_COL_LENGTH_FOR_CURRENT_SCHEMA));
commit:844190c
/////////////////////////////////////////////////////////////////////////
0: 			case StoredFormatIds.LONGINT_TYPE_ID:
1: 			// This is a BIGINT column: we allow smallints, ints,
1: 			// and big int constants.  Smallint and int literals
1: 			// are both covered by INT_TYPE; big int literals are
1: 			// covered by LONG_INT type.
1: 				return ((defType == StoredFormatIds.INT_TYPE_ID)
0: 					|| (defType == StoredFormatIds.LONGINT_TYPE_ID));
0: 	
commit:cfa2a95
/////////////////////////////////////////////////////////////////////////
0: 			if (!defaultTypeIsValid(columnTypeId, dataTypeServices,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	public boolean defaultTypeIsValid(TypeId columnType,
/////////////////////////////////////////////////////////////////////////
1: 				// exclude any trailing 0's after the decimal
/////////////////////////////////////////////////////////////////////////
1: 			case StoredFormatIds.BIT_TYPE_ID:
1: 			case StoredFormatIds.VARBIT_TYPE_ID:
1: 			case StoredFormatIds.LONGVARBIT_TYPE_ID:
1: 			// only valid if the default type is a BIT string.
1: 				return (defType == StoredFormatIds.BIT_TYPE_ID);
0: 
1: 			case StoredFormatIds.BLOB_TYPE_ID:
/////////////////////////////////////////////////////////////////////////
1: 			// All other default type checks either 
0: 			// (TINYINT, NATIONAL_CHAR, etc), or 2) require a DB2 cast-
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.reference.DB2Limit;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.depend.ProviderList;
0: import org.apache.derby.iapi.sql.depend.ProviderInfo;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.impl.sql.execute.ColumnInfo;
0: 
0: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.catalog.DefaultInfo;
0: import org.apache.derby.catalog.UUID;
0: 
0: import org.apache.derby.catalog.types.DefaultInfoImpl;
0: 
0: import java.util.Vector;
0: import java.sql.Types;
0: 
0: /**
0:  * A ColumnDefinitionNode represents a column definition in a DDL statement.
0:  * There will be a ColumnDefinitionNode for each column in a CREATE TABLE
0:  * statement, and for the column in an ALTER TABLE ADD COLUMN statement.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public class ColumnDefinitionNode extends TableElementNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	boolean						isAutoincrement;
0: 	DataTypeDescriptor			dataTypeServices;
0: 	DataValueDescriptor			defaultValue;
0: 	DefaultInfoImpl				defaultInfo;
0: 	DefaultNode					defaultNode;
0: 	long						autoincrementIncrement;
0: 	long						autoincrementStart;
0: 	boolean						autoincrementVerify;
0: 
0: 	/**
0: 	 * Initializer for a ColumnDefinitionNode
0: 	 *
0: 	 * @param name			The name of the column
0: 	 * @param defaultNode	The default value of the column
0: 	 * @param dataTypeServices	A DataTypeServices telling the type
0: 	 *				of the column
0: 	 * @param autoIncrementInfo	Info for autoincrement columns
0: 	 *
0: 	 */
0: 
0: 	public void init(
0: 					Object name,
0: 					Object defaultNode,
0: 					Object dataTypeServices,
0: 					Object autoIncrementInfo)
0: 		throws StandardException
0: 	{
0: 		super.init(name);
0: 		this.dataTypeServices = (DataTypeDescriptor) dataTypeServices;
0: 		if (defaultNode instanceof UntypedNullConstantNode)
0: 		{
0: 			/* No DTS yet for MODIFY DEFAULT */
0: 			if (dataTypeServices != null)
0: 			{
0: 				defaultValue = 
0: 					((UntypedNullConstantNode) defaultNode).
0: 									convertDefaultNode(this.dataTypeServices);
0: 			}
0: 		}
0: 		else
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (defaultNode != null &&
0: 					! (defaultNode instanceof DefaultNode))
0: 				{
0: 					SanityManager.THROWASSERT(
0: 						"defaultNode expected to be instanceof DefaultNode, not " +
0: 						defaultNode.getClass().getName());
0: 				}
0: 			}
0: 			this.defaultNode = (DefaultNode) defaultNode;
0: 			if (autoIncrementInfo != null)
0: 			{
0: 				long[] aii = (long[]) autoIncrementInfo;
0: 				autoincrementStart = aii[QueryTreeNode.AUTOINCREMENT_START_INDEX];
0: 				autoincrementIncrement = aii[QueryTreeNode.AUTOINCREMENT_INC_INDEX];
0: 
0: 				/*
0: 				 * If using DB2 syntax to set increment value, will need to check if column
0: 				 * is already created for autoincrement.
0: 				 */
0: 				autoincrementVerify = (aii[QueryTreeNode.AUTOINCREMENT_IS_AUTOINCREMENT_INDEX] > 0) ? false : true;
0: 				isAutoincrement = true;
0: 				// an autoincrement column cannot be null-- setting
0: 				// non-nullability for this column is needed because 
0: 				// you could create a column with ai default, add data, drop 
0: 				// the default, and try to add it back again you'll get an
0: 				// error because the column is marked nullable.
0: 				if (dataTypeServices != null)
0: 					(this.dataTypeServices).setNullability(false);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "dataTypeServices: " + dataTypeServices.toString() + "\n" +
0: 				"defaultValue: " + defaultValue + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Returns the unqualified name of the column being defined.
0: 	 *
0: 	 * @return	the name of the column
0: 	 */
0: 	public String getColumnName()
0: 	{
0: 		return this.name;
0: 	}
0: 
0: 	/**
0: 	 * Returns the data type services of the column being defined.
0: 	 *
0: 	 * @return	the data type services of the column
0: 	 */
0: 	public DataTypeDescriptor getDataTypeServices()
0: 	{
0: 		return this.dataTypeServices;
0: 	}
0: 
0: 	/**
0: 	 * Return the DataValueDescriptor containing the default value for this
0: 	 * column
0: 	 *
0: 	 * @return	The default value of the column
0: 	 */
0: 
0: 	public DataValueDescriptor getDefaultValue()
0: 	{
0: 		return this.defaultValue;
0: 	}
0: 
0: 	/**
0: 	 * Return the DefaultInfo containing the default information for this
0: 	 * column
0: 	 *
0: 	 * @return	The default info for the column
0: 	 */
0: 
0: 	public DefaultInfo getDefaultInfo()
0: 	{
0: 		return defaultInfo;
0: 	}
0: 
0: 	/**
0: 	 * Return the DefaultNode, if any, associated with this node.
0: 	 *
0: 	 * @return The DefaultNode, if any, associated with this node.
0: 	 */
0: 	public DefaultNode getDefaultNode()
0: 	{
0: 		return defaultNode;
0: 	}
0: 
0: 	/**
0: 	 * Is this an autoincrement column?
0: 	 *
0: 	 * @return Whether or not this is an autoincrement column.
0: 	 */
0: 	public boolean isAutoincrementColumn()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (isAutoincrement && autoincrementIncrement == 0)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"autoincrementIncrement expected to be non-zero");
0: 			}
0: 			if ((! isAutoincrement) && 
0: 				(autoincrementStart != 0 || autoincrementIncrement != 0))
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"both autoincrementStart and autoincrementIncrement expected to be 0");
0: 			}
0: 		}
0: 		return isAutoincrement;
0: 	}
0: 
0: 	/**
0: 	 * Get the autoincrement start value
0: 	 *
0: 	 * @return Autoincrement start value.
0: 	 */
0: 	long getAutoincrementStart()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(isAutoincrement,
0: 				"isAutoincrement expected to be true");
0: 		}
0: 		return autoincrementStart;
0: 	}
0: 
0: 	/**
0: 	 * Get the autoincrement increment value
0: 	 *
0: 	 * @return Autoincrement increment value.
0: 	 */
0: 	long getAutoincrementIncrement()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(isAutoincrement,
0: 				"isAutoincrement expected to be true");
0: 		}
0: 		return autoincrementIncrement;
0: 	}
0: 
0: 	/**
0: 	 * Check the validity of a user type.  Checks whether this column
0: 	 * definition describes a user type that either doesn't exist or is
0: 	 * inaccessible, or that doesn't implement Serializable.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void checkUserType(TableDescriptor td) 
0: 		throws StandardException
0: 	{
0: 		String			columnTypeName;
0: 
0: 		/* Built-in types need no checking */
0: 		if (dataTypeServices.getTypeId().builtIn())
0: 			return;
0: 
0: 		ClassInspector classInspector = getClassFactory().getClassInspector();
0: 
0: 		columnTypeName =
0: 			dataTypeServices.getTypeId().getCorrespondingJavaTypeName();
0: 
0: 
0: 
0: 
0: 		/* User type - We first check for the columnTypeName as a java class.
0: 		 * If that fails, then we treat it as a class alias.
0: 		 */
0: 
0: 		boolean foundMatch = false;
0: 		Throwable reason = null;
0: 		try {
0: 			foundMatch = classInspector.accessible(columnTypeName);
0: 		} catch (ClassNotFoundException cnfe) {
0: 			reason = cnfe;
0: 		} catch (LinkageError le) {
0: 			reason = le;
0: 		}
0: 
0: 		if (!foundMatch)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_TYPE_DOESNT_EXIST, reason, columnTypeName,
0: 																name);
0: 		}
0: 
0: 		if (! classInspector.assignableTo(columnTypeName,
0: 											"java.io.Serializable")  &&
0:             // Before Java2, SQLData is not defined, assignableTo call returns false
0:             ! classInspector.assignableTo(columnTypeName,"java.sql.SQLData"))
0:         {
0: 			getCompilerContext().addWarning(
0: 				StandardException.newWarning(SQLState.LANG_TYPE_NOT_SERIALIZABLE, columnTypeName,
0: 																 name));
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the UUID of the old column default.
0: 	 *
0: 	 * @return The UUID of the old column default.
0: 	 */
0: 	UUID getOldDefaultUUID()
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Get the action associated with this node.
0: 	 *
0: 	 * @return The action associated with this node.
0: 	 */
0: 	int getAction()
0: 	{
0: 		return ColumnInfo.CREATE;
0: 	}
0: 
0: 	/**
0: 	 * Check the validity of the default, if any, for this node.
0: 	 *
0: 	 * @param dd		The DataDictionary.
0: 	 * @param td		The TableDescriptor.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void bindAndValidateDefault(DataDictionary dd, TableDescriptor td)
0: 		throws StandardException
0: 	{
0: 		/* DB2 requires non-nullable columns to have a default in ALTER TABLE */
0: 		if (td != null && !dataTypeServices.isNullable() && defaultNode == null)
0: 		{
0: 			if (!isAutoincrement)
0: 				throw StandardException.newException(SQLState.LANG_DB2_NOT_NULL_COLUMN_INVALID_DEFAULT, getColumnName());
0: 		}
0: 			
0: 		// No work to do if no user specified default
0: 		if (defaultNode == null)
0: 		{
0: 			return;
0: 		}
0: 
0: 		// No work to do if user specified NULL
0: 		if (defaultValue != null)
0: 		{
0: 			return;
0: 		}
0: 
0: 		// Now validate the default
0: 		validateDefault(dd, td);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Check the validity of the autoincrement values for this node.
0: 	 * The following errors are thrown by this routine.
0: 	 * 1. 42z21 Invalid Increment; i.e 0.
0: 	 * 2. 42z22 Invalid Type; autoincrement created on a non-exact-numeric type
0: 	 * 3. 42995 The requested function does not apply to global temporary tables
0: 	 *
0: 	 * @param 		dd		DataDictionary.
0: 	 * @param		td		table descriptor.
0: 	 * @param		tableType	base table or declared global temporary table.
0: 	 *
0: 	 * @exception 	StandardException if autoincrement default is incorrect; i.e
0: 	 * 				if increment is 0 or if initial or increment values are out
0: 	 * 				of range for the datatype.
0: 	 */
0: 	public void validateAutoincrement(DataDictionary dd, TableDescriptor td, int tableType)
0: 	     throws StandardException
0: 	{
0: 		if (isAutoincrement == false)
0: 			return;
0: 
0: 		if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
0: 			throw StandardException.newException(SQLState.LANG_NOT_ALLOWED_FOR_DECLARED_GLOBAL_TEMP_TABLE);
0: 
0: 		if (autoincrementIncrement == 0)
0: 			throw StandardException.newException(SQLState.LANG_AI_INVALID_INCREMENT, getColumnName());
0: 		int jdbctype = dataTypeServices.getTypeId().getJDBCTypeId();
0: 		switch (jdbctype)
0: 		{
0: 		case Types.TINYINT:
0: 			autoincrementCheckRange((long)Byte.MIN_VALUE, 
0: 									(long)Byte.MAX_VALUE, 
0: 									TypeId.TINYINT_NAME);
0: 			break;
0: 		case Types.SMALLINT:
0: 			autoincrementCheckRange((long)Short.MIN_VALUE, 
0: 									(long)Short.MAX_VALUE,
0: 									TypeId.SMALLINT_NAME);
0: 			break;
0: 		case Types.INTEGER:
0: 			autoincrementCheckRange((long)Integer.MIN_VALUE, 
0: 									(long)Integer.MAX_VALUE,
0: 									TypeId.INTEGER_NAME);
0: 			break;
0: 		case Types.BIGINT:
0: 			autoincrementCheckRange(Long.MIN_VALUE, Long.MAX_VALUE,
0: 									TypeId.LONGINT_NAME);
0: 			break;
0: 		default:
0: 			throw StandardException.newException(SQLState.LANG_AI_INVALID_TYPE,
0: 												 getColumnName());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * checks to see if autoincrementIncrement and autoincrementInitial
0: 	 * are within the bounds of the type whose min and max values are
0: 	 * passed into this routine.
0: 	 */
0: 	private	void autoincrementCheckRange(long minValue, long maxValue,
0: 									String typeName)
0: 				throws StandardException					
0: 	{
0: 		if ((minValue > autoincrementIncrement) || 
0: 			(maxValue < autoincrementIncrement))
0: 		{
0: 			throw StandardException.newException(
0: 								 SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, typeName);
0: 		}
0: 		if ((minValue > autoincrementStart) || 
0: 			(maxValue < autoincrementStart))
0: 		{
0: 			throw StandardException.newException(
0: 								 SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, typeName);
0: 		}			
0: 	}
0: 	/**
0: 	 * Check the validity of the default for this node.
0: 	 *
0: 	 * @param td		The TableDescriptor.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void validateDefault(DataDictionary dd, TableDescriptor td)
0: 		throws StandardException
0: 	{
0: 		CompilerContext cc;
0: 
0: 		if (defaultNode == null)
0: 			return;
0: 
0: 		cc = getCompilerContext();
0: 
0: 		ValueNode defaultTree = defaultNode.getDefaultTree();
0: 
0: 		/* bind the default.
0: 		 * Verify that it does not contain any ColumnReferences or subqueries
0: 		 * and that it is type compatable with the column.
0: 		 */
0: 		final int previousReliability = cc.getReliability();
0: 		try
0: 		{
0: 			/* Each default can have its own set of dependencies.
0: 			 * These dependencies need to be shared with the prepared
0: 			 * statement as well.  We create a new auxiliary provider list
0: 			 * for the default, "push" it on the compiler context
0: 			 * by swapping it with the current auxiliary provider list
0: 			 * and the "pop" it when we're done by restoring the old 
0: 			 * auxiliary provider list.
0: 			 */
0: 			ProviderList apl = new ProviderList();
0: 
0: 			ProviderList prevAPL = cc.getCurrentAuxiliaryProviderList();
0: 			cc.setCurrentAuxiliaryProviderList(apl);
0: 
0: 			// Tell the compiler context to only allow deterministic nodes
0: 			cc.setReliability( CompilerContext.DEFAULT_RESTRICTION );
0: 			defaultTree = defaultTree.bindExpression(
0: 							(FromList) getNodeFactory().getNode(
0: 								C_NodeTypes.FROM_LIST,
0: 								getNodeFactory().doJoinOrderOptimization(),
0: 								getContextManager()), 
0: 							(SubqueryList) null,
0: 							(Vector) null);
0: 
0: 			TypeId columnTypeId = (TypeId) dataTypeServices.getTypeId();
0: 			TypeId defaultTypeId = defaultTree.getTypeId();
0: 
0: 			// Check for 'invalid default' errors (42894)
0: 			// before checking for 'not storable' errors (42821).
0: 			if (!defaultTypeIsDB2Valid(columnTypeId, dataTypeServices,
0: 					defaultTypeId, defaultTree, defaultNode.getDefaultText()))
0: 			{
0: 					throw StandardException.newException(
0: 						SQLState.LANG_DB2_INVALID_DEFAULT_VALUE,
0: 						this.name);
0: 			}
0: 
0: 			// Now check 'not storable' errors.
0: 			if (! getTypeCompiler(columnTypeId).
0: 								storable(defaultTypeId, getClassFactory()))
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_NOT_STORABLE, 
0: 					columnTypeId.getSQLTypeName(),
0: 					defaultTypeId.getSQLTypeName() );
0: 			}
0: 
0: 			// Save off the default text
0: 			// RESOLVEDEFAULT - Convert to constant if possible
0: 			defaultInfo = new DefaultInfoImpl(defaultNode.getDefaultText(), defaultValue);
0: 
0: 			/* Save the APL off in the constraint node */
0: 			if (apl.size() > 0)
0: 			{
0: 				defaultNode.setAuxiliaryProviderList(apl);
0: 				// Add info on any providers to DefaultInfo
0: 				ProviderInfo[]	providerInfos = null;
0: 
0: 				/* Get all the dependencies for the current statement and transfer
0: 				 * them to this view.
0: 				 */
0: 				DependencyManager dm;
0: 				dm = dd.getDependencyManager();
0: 				providerInfos = dm.getPersistentProviderInfos(apl);
0: 				defaultInfo.setProviderInfo(providerInfos);
0: 			}
0: 
0: 			// Restore the previous AuxiliaryProviderList
0: 			cc.setCurrentAuxiliaryProviderList(prevAPL);
0: 		}
0: 		finally
0: 		{
0: 			cc.setReliability(previousReliability);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Check the validity of the default for this node
0: 	 * with respect to restrictions imposed by DB2 that
0: 	 * Cloudscape doesn't normally disallow (Beetle 5203).
0: 	 *
0: 	 * NOTE: that the only checks currently here are those
0: 	 * which DB2 enforces on DEFAULTS but does NOT enforce
0: 	 * on normal insertion.  At some point, we may want
0: 	 * move other checks, currently performed at insertion,
0: 	 * to here to mimic DB2 behavior (beetle 5585), but
0: 	 * that is not yet how we do it.
0: 	 *
0: 	 * @param columnType TypeId of the target column.
0: 	 * @param columnDesc Description of the type of the
0: 	 *		target column.
0: 	 * @param defaultType TypeId of the default node.
0: 	 * @param defaultNode Parsed ValueNode for the default value.
0: 	 * @param defaultText Unparsed default value (as entered
0: 	 * 		by user).
0: 	 * @return True if the defaultNode abides by the restrictions
0: 	 * 	imposed by DB2 on default constants; false otherwise.
0: 	 *
0: 	 */
0: 
0: 	public boolean defaultTypeIsDB2Valid(TypeId columnType,
0: 		DataTypeDescriptor columnDesc, TypeId defaultType,
0: 		ValueNode defaultNode, String defaultText)
0: 	{
0: 
0: 		if (defaultText.length() > DB2Limit.DB2_CHAR_MAXWIDTH)
0: 		// DB2 spec says this isn't allowed.
0: 			return false;
0: 
0: 		/* We can use info about the way the parser works
0: 		 * to guide this process a little (see the getNumericNode()
0: 		 * method in sqlgrammar.jj):
0: 		 *
0: 		 * 1) Tinyint and Smallints are both parsed as "INT" types,
0: 	 	 *	  while integers larger than a basic "INT" are parsed into
0: 		 *	  "LONGINT" or, if needed, "DECIMAL".
0: 		 * 2) Floats, doubles, and decimals with fractional parts
0: 		 *	  are all parsed as "DECIMAL".
0: 		 * 3) All strings are parsed as "CHAR" constants (no varchar
0: 		 *	  or any others; see stringLiteral() method in
0: 		 *	  sqlgrammar.jj).
0: 		 */
0: 
0: 		int colType = columnType.getTypeFormatId();
0: 		int defType = (defaultType == null ? -1 : defaultType.getTypeFormatId());
0: 
0: 		if (!defaultNode.isConstantExpression()) {
0: 		// then we have a built-in function, such as "user"
0: 		// or "current schema".  If the function is a datetime
0: 		// value function, then we don't need any special
0: 		// action; however, if it's a "user" or "current schema"
0: 		// function, then the column must be a char type with
0: 		// minimum lengths matching those of DB2 (note that
0: 		// such limits are ONLY enforced on defaults, not at
0: 		// normal insertion time).
0: 
0: 			boolean charCol = ((colType == StoredFormatIds.CHAR_TYPE_ID) ||
0: 				(colType == StoredFormatIds.VARCHAR_TYPE_ID) ||
0: 				(colType == StoredFormatIds.LONGVARCHAR_TYPE_ID));
0: 
0: 			if (defaultNode instanceof CurrentUserNode) {
0: 
0: 				defaultText = defaultText.toLowerCase(java.util.Locale.ENGLISH);
0: 				if (defaultText.indexOf("user") != -1)
0: 				// DB2 enforces min length of 8.
0: 				// Note also: any size under 30 gives a warning in DB2.
0: 					return (charCol && (columnDesc.getMaximumWidth() >=
0: 						DB2Limit.MIN_COL_LENGTH_FOR_CURRENT_USER));
0: 
0: 				if ((defaultText.indexOf("schema") != -1) ||
0: 					(defaultText.indexOf("sqlid") != -1))
0: 				// DB2 enforces min length of 128.
0: 					return (charCol && (columnDesc.getMaximumWidth() >=
0: 						DB2Limit.MIN_COL_LENGTH_FOR_CURRENT_SCHEMA));
0: 
0: 				// else, function not allowed.
0: 				return false;
0: 
0: 			}
0: 
0: 		}
0: 
0: 		switch (colType) {
0: 
0: 			case StoredFormatIds.INT_TYPE_ID:
0: 			// DB2 doesn't allow floating point values to be used
0: 			// as defaults for integer columns (they ARE allowed
0: 			// as part of normal insertions, but not as defaults).
0: 			// If the default is an integer that's too big, then
0: 			// it won't have type INT_TYPE_ID (it'll be either
0: 			// LONGINT or DECIMAL)--so we only allow the default
0: 			// value if it's integer.
0: 				return (defType == StoredFormatIds.INT_TYPE_ID);
0: 
0: 			case StoredFormatIds.DECIMAL_TYPE_ID:
0: 				if (defType == StoredFormatIds.DECIMAL_TYPE_ID) {
0: 				// only valid if scale and precision are within
0: 				// those of the column.  Note that scale here should
0: 				// exclude any trailing 0's after the decimal, per
0: 				// the DB2 spec.
0: 					DataTypeDescriptor defDesc = defaultNode.getTypeServices();
0: 					int len = defaultText.length();
0: 					int precision = defDesc.getPrecision();
0: 					int scale = defDesc.getScale();
0: 					for (int i = 1; i <= scale; scale--, precision--) {
0: 						if (defaultText.charAt(len - i) != '0')
0: 							break;
0: 					}
0: 					return ((scale <= columnDesc.getScale()) &&
0: 						((precision - scale) <=
0: 						(columnDesc.getPrecision() - columnDesc.getScale())));
0: 				}
0: 				else if ((defType == StoredFormatIds.LONGINT_TYPE_ID) ||
0: 					(defType == StoredFormatIds.INT_TYPE_ID)) {
0: 				// only valid if number of digits is within limits of
0: 				// the decimal column.  We'll check this at insertion time;
0: 				// see Beetle 5585 regarding the need to move that check to
0: 				// here instead of waiting until insert time.  Until that's
0: 				// done, just allow this and wait for insertion...
0: 					return true;
0: 				}
0: 				else
0: 				// no other types allowed.
0: 					return false;
0: 
0: 			case StoredFormatIds.CHAR_TYPE_ID:
0: 			case StoredFormatIds.VARCHAR_TYPE_ID:
0: 			case StoredFormatIds.LONGVARCHAR_TYPE_ID:
0: 			// only valid if the default type is a character string.
0: 			// That's not to say that all character defaults are
0: 			// valid, but we only check for character string here;
0: 			// further checking will be done at insertion time.  See
0: 			// beetle 5585 regarding the need to move that check
0: 			// to here instead of waiting until insert time.
0: 				return (defType == StoredFormatIds.CHAR_TYPE_ID);
0: 
0: 			case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
0: 			// default is only valid if it's the same type as the column.
0: 				return (defType == colType);
0: 
0: 			case StoredFormatIds.CLOB_TYPE_ID:
0: 			case StoredFormatIds.SMALLINT_TYPE_ID:
0: 			case StoredFormatIds.REAL_TYPE_ID:
0: 			case StoredFormatIds.DOUBLE_TYPE_ID:
0: 			case StoredFormatIds.DATE_TYPE_ID:
0: 			case StoredFormatIds.TIME_TYPE_ID:
0: 			case StoredFormatIds.TIMESTAMP_TYPE_ID:
0: 			// For these types, validity checks will be performed
0: 			// by Cloudscape at insertion time--see beetle 5585 regarding
0: 			// the need to do such checks here instead of later.  For now,
0: 			// just assume we're okay.
0: 				return true;
0: 
0: 			default:
0: 			// All other default type checks either 1) involve
0: 			// types which are not supported in DB2 mode (such as BIT,
0: 			// TINYINT, NATIONAL_CHAR, etc), or 2) require a DB2 cast-
0: 			// function (ex. blob(...), which Cloudscape doesn't
0: 			// support yet--see Beetle 5281), and so they are not
0: 			// valid for Cloudscape running in DB2 compatibility mode.
0: 				return false;
0: 
0: 		}
0: 
0: 	}
0: 
0: }
============================================================================