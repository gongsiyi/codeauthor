1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.btree.BTreeMaxScan
1:86e051f: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
31:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.btree;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException; 
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.Page;
1:eac0369: import org.apache.derby.iapi.store.raw.RecordHandle;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1:eac0369: 
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369:   A b-tree scan controller corresponds to an instance of an open b-tree scan.
1:eac0369:   <P>
1:227eaef:   <B>Concurrency Notes</B>
1:eac0369:   <P>
1:eac0369:   The concurrency rules are derived from OpenBTree.
1:eac0369:   <P>
1:eac0369:   @see OpenBTree
1:eac0369: 
2:eac0369: **/
1:eac0369: 
1:eac0369: /**
1:eac0369: 
1:20cc8ad: A BTreeScan implementation that provides the 95% solution to the max on
1:eac0369: btree problem.  If the row is the last row in the btree it works very
1:eac0369: efficiently.  This implementation will be removed once backward scan is
1:eac0369: fully functional.
1:eac0369: 
1:f24ce88: The current implementation only exports to the user the ability to call
1:f24ce88: fetchMax() and get back one row, none of the generic scan ablities are
1:f24ce88: exported.  
1:f24ce88: 
1:f24ce88: To return the maximum row this implementation does the following:
1:f24ce88: 1) calls positionAtStartPosition() which returns with the a latch on the
1:f24ce88:    rightmost leaf page and a lock on the rightmost leaf row on that page.
1:f24ce88:    It will loop until it can get the lock without waiting while holding
1:f24ce88:    the latch.  At this point the slot position is just right of the
1:f24ce88:    locked row.
1:f24ce88: 2) in fetchMax() it loops backward on the last leaf page, locking rows
1:20cc8ad:    as it does so, until it finds the first non-deleted, non-NULL row.
1:20cc8ad: 3) If it is not successful in this last page search it attempts to latch
1:20cc8ad:    the left sibling page, without waiting to avoid deadlocks with forward
1:20cc8ad:    scans, and continue the search on that page.
1:20cc8ad: 4) If the sibling page couldn't be latched without waiting, save the
1:20cc8ad:    current position, release all latches, and restart the scan from the
1:20cc8ad:    saved position.
1:f24ce88: 
1:eac0369: **/
1:f24ce88: 
1:eac0369: public class BTreeMaxScan extends BTreeScan
15:eac0369: {
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Private methods of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:20cc8ad:      * Move the current position to the page to the left of the current page,
1:20cc8ad:      * right after the last slot on that page. If we have to wait for a latch,
1:20cc8ad:      * give up the latch on the current leaf and give up. The caller will have
1:20cc8ad:      * to reposition and retry.
3:eac0369:      *
1:20cc8ad:      * @return true if the position was successfully moved, false if we had
1:20cc8ad:      * to wait for a latch
1:20cc8ad:      */
1:20cc8ad:     private boolean moveToLeftSibling() throws StandardException {
1:20cc8ad:         try {
1:20cc8ad:             positionAtPreviousPage();
1:20cc8ad:             return true;
1:20cc8ad:         } catch (WaitError we) {
1:20cc8ad:             // We couldn't get the latch without waiting. Let's save the
1:e47817a:             // position and let the caller retry. But first, let's save the
1:e47817a:             // page number of the left sibling so that we can try again to
1:e47817a:             // get the latch after we've saved the position.
1:e47817a:             long left = scan_position.current_leaf.getleftSiblingPageNumber();
1:e47817a: 
1:20cc8ad:             // If the page is empty, there is no position to save. Since
1:20cc8ad:             // positionAtPreviousPage() skips empty pages mid-scan, we know
1:20cc8ad:             // that an empty page seen here must be the rightmost leaf. In
1:20cc8ad:             // that case, the caller can simply restart the scan, so there's
1:20cc8ad:             // no need to save the position.
1:20cc8ad:             if (isEmpty(scan_position.current_leaf.getPage())) {
1:20cc8ad:                 scan_position.current_leaf.release();
1:20cc8ad:                 scan_position.init();
1:20cc8ad:             } else {
1:20cc8ad:                 // Save the leftmost record on the page. That's the record in
1:20cc8ad:                 // slot 1, since slot 0 is the control row.
1:20cc8ad:                 scan_position.current_slot = 1;
1:20cc8ad:                 savePositionAndReleasePage();
1:20cc8ad:             }
1:eac0369: 
1:e47817a:             // There's no point in attempting to reposition too early, as we're
1:e47817a:             // likely to hit the same WaitError again (and again). So instead
1:e47817a:             // let's sleep here until the left sibling page has been released,
1:e47817a:             // and then return to let the caller reposition and retry.
1:e47817a:             Page leftPage = container.getPage(left);
1:e47817a:             if (leftPage != null) {
1:e47817a:                 // Got the latch. Anything may have happened while we didn't
1:e47817a:                 // hold any latches, so we don't know if we're still supposed
1:e47817a:                 // to go to that page. Just release the latch and let the
1:e47817a:                 // caller reposition to the right spot in the B-tree.
1:e47817a:                 leftPage.unlatch();
1:e47817a:                 leftPage = null;
1:e47817a:             }
1:e47817a: 
1:20cc8ad:             return false;
1:20cc8ad:         }
1:20cc8ad:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Protected implementation of abstract methods of BTreeScan class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:f24ce88:      * disallow fetchRows on this scan type, caller should only be able
1:f24ce88:      * to call fetchMax().
2:eac0369:      * <p>
2:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     protected int fetchRows(
2:eac0369:     BTreeRowPosition        pos,
1:eac0369:     DataValueDescriptor[][] row_array,
1:eac0369:     RowLocation[]           rowloc_array,
1:eac0369:     BackingStoreHashtable   hash_table,
1:eac0369:     long                    max_rowcnt,
1:eac0369:     int[]                   key_column_numbers)
2:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         throw StandardException.newException(
1:eac0369:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
15:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:f24ce88:      * Position scan at "start" position of the MAX scan.
1:eac0369:      * <p>
1:f24ce88:      * Positions the scan to the slot just after the last record on the
1:f24ce88:      * rightmost leaf of the index.  Returns the rightmost leaf page latched,  
1:f24ce88:      * the rightmost row on the page locked and 
1:f24ce88:      * sets "current_slot" to the slot number just right of the last row
1:f24ce88:      * on the page.
1:eac0369:      * <p>
1:f24ce88:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     protected void positionAtStartPosition(
1:eac0369:     BTreeRowPosition    pos)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean         exact;
1:eac0369: 
1:eac0369:         // This routine should only be called from first next() call //
4:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:f24ce88:             SanityManager.ASSERT(this.scan_state         == SCAN_INIT);
1:eac0369:             SanityManager.ASSERT(pos.current_rh          == null);
1:f24ce88:             SanityManager.ASSERT(pos.current_positionKey == null);
1:eac0369:         }
1:eac0369: 
1:f24ce88:         // Loop until you can lock the last row, on the rightmost leaf page
1:f24ce88:         // of the tree, while holding the page latched, without waiting.
1:20cc8ad:         //
1:f24ce88:         // If you have to wait, drop the latch, and wait for the lock.
1:f24ce88:         // This makes it likely that the next search you will loop just
1:eac0369:         // once, find the same lock satisfies the search and since you already
1:eac0369:         // have the lock it will be granted.
1:eac0369:         while (true)
1:eac0369:         {
1:eac0369:             // Find the starting page and row slot, must start at root and
1:f24ce88:             // search for rightmost leaf.
1:4a2b0d9:             ControlRow root = ControlRow.get(this, BTree.ROOTPAGEID); 
1:eac0369: 
1:eac0369:             // include search of tree in page visited stats.
1:eac0369:             stat_numpages_visited += root.getLevel() + 1;
1:eac0369: 
1:eac0369:             if (init_startKeyValue == null)
1:eac0369:             {
1:eac0369:                 // No start given, position at last slot + 1 of rightmost leaf 
1:eac0369:                 pos.current_leaf = (LeafControlRow) root.searchRight(this);
1:eac0369: 
1:eac0369:                 pos.current_slot = pos.current_leaf.page.recordCount();
1:eac0369:                 exact     = false;
1:eac0369:             }
2:eac0369:             else
1:eac0369:             {
1:eac0369:                 // only max needed, no start position supported.
1:eac0369:                 throw StandardException.newException(
1:eac0369:                         SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:eac0369:             }
1:eac0369: 
1:f24ce88:             // lock the last row on the rightmost leaf of the table, as this
1:f24ce88:             // is a max scan no previous key locking necessary.  Previous key
1:f24ce88:             // locking is used to protect a range of keys, but for max there
1:f24ce88:             // is only a single row returned.
1:eac0369: 
1:eac0369:             pos.current_slot--;
2:eac0369:             boolean latch_released = 
2:eac0369:                 !this.getLockingPolicy().lockScanRow(
1:f6fea40:                     this, pos,
2:eac0369:                     init_lock_fetch_desc,
2:eac0369:                     pos.current_lock_template,
2:eac0369:                     pos.current_lock_row_loc,
2:eac0369:                     false, init_forUpdate, lock_operation);
2:eac0369:             pos.current_slot++;
1:eac0369: 
2:eac0369:             // special test to see if latch release code works
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
2:eac0369:                 latch_released = 
2:eac0369:                     test_errors(
2:eac0369:                         this,
1:86e051f:                         "BTreeMaxScan_positionAtStartPosition", pos,
1:eac0369:                         this.getLockingPolicy(), pos.current_leaf, latch_released);
1:eac0369:             }
1:eac0369: 
2:eac0369:             if (latch_released)
1:eac0369:             {
1:eac0369:                 // lost latch on pos.current_leaf, search the tree again.
1:be4b84e:                 // Forget the current position since we'll reposition on the
1:be4b84e:                 // rightmost key, which is not necessarily the saved position.
1:be4b84e:                 pos.init();
1:eac0369:                 continue;
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 // success! got all the locks, while holding the latch.
4:eac0369:                 break;
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         this.scan_state          = SCAN_INPROGRESS;
1:eac0369: 
1:86e051f:         if (SanityManager.DEBUG)
1:eac0369:             SanityManager.ASSERT(pos.current_leaf != null);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Fetch the maximum row in the table.
1:f24ce88:      *
1:f24ce88:      * Call positionAtStartPosition() to quickly position on rightmost row
1:f24ce88:      * of rightmost leaf of tree.
1:f24ce88:      *
1:f24ce88:      * Search last page for last non deleted row, and if one is found return
1:f24ce88:      * it as max.
1:f24ce88:      *
1:20cc8ad:      * If no row found on last page, or could not find row without losing latch
1:f24ce88:      * then call fetchMaxRowFromBeginning() to search from left to right
1:f24ce88:      * for maximum value in index.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public boolean fetchMax(
2:eac0369:     DataValueDescriptor[]   fetch_row)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         BTreeRowPosition    pos           = scan_position;
1:eac0369:         int                 ret_row_count = 0;
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(this.container != null,
1:eac0369:                 "BTreeMaxScan.fetchMax() called on a closed scan.");
1:eac0369:         }
1:eac0369: 
1:eac0369: 
1:eac0369:         if (this.scan_state == BTreeScan.SCAN_INPROGRESS)
1:eac0369:         {
1:eac0369:             // Get current page of scan, with latch
1:f24ce88: 
1:f24ce88:             // RESOLVE (mikem) - I don't think this code can be called.
1:eac0369:             
1:eac0369:             // reposition the scan at the row just before the next one to 
1:eac0369:             // return.
1:eac0369:             // This routine handles the mess of repositioning if the row or 
1:eac0369:             // the page has disappeared. This can happen if a lock was not 
1:eac0369:             // held on the row while not holding the latch (can happen if
1:eac0369:             // this scan is read uncommitted).
1:eac0369:             if (!reposition(scan_position, true))
1:eac0369:             {
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:86e051f:                     SanityManager.THROWASSERT(
1:eac0369:                         "can not fail with 2nd param true.");
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369:         }
1:eac0369:         else if (this.scan_state == SCAN_INIT)
1:eac0369:         {
1:eac0369:             // 1st positioning of scan (delayed from openScan).
1:eac0369:             positionAtStartPosition(scan_position);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.ASSERT(this.scan_state == SCAN_DONE);
1:eac0369: 
1:eac0369:             return(false);
1:eac0369:         }
1:eac0369: 
1:eac0369: 
2:eac0369:         // At this point:
2:eac0369:         // current_page is latched.  current_slot is the slot on current_page
1:eac0369:         // just "right" of the "next" record this routine should process.
1:20cc8ad:         // In this case the "next" record is the last row on the rightmost
1:f24ce88:         // leaf page.
1:eac0369: 
1:eac0369: 
1:eac0369:         boolean max_found = false;
1:eac0369: 
1:f24ce88:         // Code is positioned on the rightmost leaf of the index, the rightmost
1:f24ce88:         // non-deleted row on this page is the maximum row to return.
1:eac0369: 
1:20cc8ad:         leaf_loop:
1:20cc8ad:         while (!max_found && pos.current_leaf != null)
1:eac0369:         {
1:20cc8ad:             if (pos.current_slot <= 1)
1:20cc8ad:             {
1:20cc8ad:                 // Reached beginning of this leaf page without finding a
1:20cc8ad:                 // value, so move position to the end of the left sibling and
1:20cc8ad:                 // resume the scan.
1:20cc8ad:                 boolean latch_released = !moveToLeftSibling();
1:20cc8ad: 
1:20cc8ad:                 if (latch_released)
1:20cc8ad:                 {
1:20cc8ad:                     // The previous page was latched by someone else, so we
1:20cc8ad:                     // gave up the latch on this page to avoid running into a
1:20cc8ad:                     // deadlock with someone scanning the leaves in the
1:20cc8ad:                     // opposite direction.
1:20cc8ad: 
1:20cc8ad:                     if (SanityManager.DEBUG)
1:20cc8ad:                     {
1:20cc8ad:                         SanityManager.DEBUG(
1:20cc8ad:                                 "BTreeMaxScan.latchConflict",
1:20cc8ad:                                 "Couldn't get latch nowait, will retry");
1:20cc8ad:                     }
1:20cc8ad: 
1:20cc8ad:                     if (pos.current_positionKey == null)
1:20cc8ad:                     {
1:20cc8ad:                         // We haven't seen any rows yet, so no position has
1:20cc8ad:                         // been saved. See comment in moveToLeftSibling().
1:20cc8ad:                         // Restart the scan from the rightmost leaf.
1:20cc8ad:                         if (SanityManager.DEBUG)
1:20cc8ad:                         {
1:20cc8ad:                             SanityManager.DEBUG(
1:20cc8ad:                                     "BTreeMaxScan.latchConflict",
1:20cc8ad:                                     "Restart scan from rightmost leaf");
1:20cc8ad:                         }
1:20cc8ad:                         scan_state = SCAN_INIT;
1:20cc8ad:                         positionAtStartPosition(pos);
1:20cc8ad:                     }
1:20cc8ad:                     else if (!reposition(pos, false))
1:20cc8ad:                     {
1:20cc8ad:                         if (SanityManager.DEBUG)
1:20cc8ad:                         {
1:20cc8ad:                             SanityManager.DEBUG(
1:20cc8ad:                                     "BTreeMaxScan.latchConflict",
1:20cc8ad:                                     "Saved position is gone");
1:20cc8ad:                         }
1:20cc8ad: 
1:20cc8ad:                         // The row on the saved position doesn't exist anymore,
1:20cc8ad:                         // so it must have been purged. Move to the position
1:20cc8ad:                         // immediately to the left of where the row should
1:20cc8ad:                         // have been.
1:20cc8ad:                         if (!reposition(pos, true))
1:20cc8ad:                         {
1:20cc8ad:                             if (SanityManager.DEBUG)
1:20cc8ad:                             {
1:20cc8ad:                                 SanityManager.THROWASSERT(
1:20cc8ad:                                         "Cannot fail with 2nd param true");
1:20cc8ad:                             }
1:20cc8ad:                         }
1:20cc8ad: 
1:20cc8ad:                         // reposition() will position to the left of the purged
1:20cc8ad:                         // row, whereas we want to be on the right side of it
1:20cc8ad:                         // since we're moving backwards.
1:20cc8ad:                         pos.current_slot++;
1:20cc8ad:                     }
1:20cc8ad:                 }
1:20cc8ad: 
1:20cc8ad:                 // We now have one of the following scenarios:
1:20cc8ad:                 //
1:20cc8ad:                 // 1) Current position is right after the last row on the left
1:20cc8ad:                 //    sibling page if we could move to the sibling page without
1:20cc8ad:                 //    waiting for a latch.
1:20cc8ad:                 // 2) Current position is on the same row as the last one we
1:20cc8ad:                 //    looked at if we had to wait for a latch on the sibling
1:20cc8ad:                 //    page and the row hadn't been purged before we
1:20cc8ad:                 //    repositioned.
1:20cc8ad:                 // 3) Current position is right after the position where we
1:20cc8ad:                 //    should have found the last row we looked at if we had
1:20cc8ad:                 //    to wait for a latch on the sibling page and the row was
1:20cc8ad:                 //    purged before we repositioned.
1:20cc8ad:                 // 4) There is no current position if we already were at the
1:20cc8ad:                 //    leftmost leaf page.
1:20cc8ad:                 //
1:20cc8ad:                 // For scenarios 1-3, we're positioned immediately to the right
1:20cc8ad:                 // of the next row we want to look at, so going to the top of
1:20cc8ad:                 // the loop will make us move to the next interesting row. For
1:20cc8ad:                 // scenario 4, we want to break out of the loop, which also
1:20cc8ad:                 // is handled by going to the top of the loop and reevaluating
1:20cc8ad:                 // the loop condition.
1:20cc8ad:                 continue;
1:20cc8ad:             }
1:20cc8ad: 
1:f24ce88:             // move scan backward in search of last non-deleted row on page.
1:eac0369:             pos.current_slot--;
1:eac0369: 
1:eac0369:             while (pos.current_slot > 0)
1:eac0369:             {
2:eac0369:                 this.stat_numrows_visited++;
1:eac0369: 
2:eac0369:                 // get current record handle for positioning but don't read
2:eac0369:                 // data until we verify it is not deleted.  rh is needed
2:eac0369:                 // for repositioning if we lose the latch.
2:eac0369:                 RecordHandle rh = 
3:eac0369:                     pos.current_leaf.page.fetchFromSlot(
2:eac0369:                         (RecordHandle) null,
2:eac0369:                         pos.current_slot, fetch_row, init_fetchDesc,
3:eac0369:                         true);
1:eac0369: 
1:f24ce88:                 // lock current row in max scan, no previous key lock necessary.
1:eac0369:                 boolean latch_released =
1:eac0369:                     !this.getLockingPolicy().lockScanRow(
1:f6fea40:                         this, pos,
1:eac0369:                         init_lock_fetch_desc,
1:eac0369:                         pos.current_lock_template,
1:eac0369:                         pos.current_lock_row_loc,
1:eac0369:                         false, init_forUpdate, lock_operation);
1:eac0369: 
2:eac0369:                 // At this point we have successfully locked this record, so
2:eac0369:                 // remember the record handle so that it can be unlocked if
2:eac0369:                 // necessary.  If the above lock deadlocks, we will not try
2:eac0369:                 // to unlock a lock we never got in close(), because current_rh
2:eac0369:                 // is null until after the lock is granted.
2:eac0369:                 pos.current_rh = rh;
1:eac0369: 
1:eac0369: 
1:eac0369:                 if (latch_released)
1:eac0369:                 {
1:20cc8ad:                     // Had to wait on lock while not holding the latch, so now
1:20cc8ad:                     // the current row may have been moved to another page and
1:20cc8ad:                     // we need to reposition.
1:20cc8ad:                     if (!reposition(pos, false))
1:20cc8ad:                     {
1:20cc8ad:                         // Could not position on the exact same row that was
1:20cc8ad:                         // saved, which means that it has been purged.
1:20cc8ad:                         // Reposition on the row immediately to the left of
1:20cc8ad:                         // where the purged row should have been.
1:20cc8ad:                         if (!reposition(pos, true))
1:20cc8ad:                         {
1:20cc8ad:                             if (SanityManager.DEBUG)
1:20cc8ad:                             {
1:20cc8ad:                                 SanityManager.THROWASSERT(
1:20cc8ad:                                         "Cannot fail with 2nd param true");
1:20cc8ad:                             }
1:20cc8ad:                         }
1:20cc8ad: 
1:20cc8ad:                         // Now we're positioned immediately to the left of our
1:20cc8ad:                         // previous position. We want to be positioned to the
1:20cc8ad:                         // right of that position so that we can restart the
1:20cc8ad:                         // scan from where we were before we came to the row
1:20cc8ad:                         // that disappeared for us. Adjust position one step
1:20cc8ad:                         // to the right and continue from the top of the loop.
1:20cc8ad:                         pos.current_slot++;
1:20cc8ad:                         continue leaf_loop;
1:20cc8ad:                     }
1:86e051f:                 }
1:86e051f: 
2:eac0369:                 if (pos.current_leaf.page.isDeletedAtSlot(pos.current_slot))
1:86e051f:                 {
2:eac0369:                     this.stat_numdeleted_rows_visited++;
1:eac0369:                     pos.current_rh_qualified = false;
1:eac0369:                 }
1:eac0369:                 else if (fetch_row[0].isNull())
1:eac0369:                 {
1:eac0369:                     pos.current_rh_qualified = false;
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     pos.current_rh_qualified = true;
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 if (pos.current_rh_qualified)
1:eac0369:                 {
1:eac0369:                     // return the qualifying max row.
1:eac0369:                     ret_row_count++;
2:eac0369:                     stat_numrows_qualified++;
1:eac0369: 
1:eac0369:                     // current_slot is invalid after releasing latch
1:eac0369:                     pos.current_slot = Page.INVALID_SLOT_NUMBER;
1:eac0369: 
1:eac0369:                     max_found = true;
1:eac0369:                     break;
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     pos.current_slot--;
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369:         if (pos.current_leaf != null)
1:eac0369:         {
1:eac0369:             // done with "last" page in table.
1:eac0369:             pos.current_leaf.release();
3:eac0369:             pos.current_leaf = null;
1:eac0369:         }
1:eac0369: 
1:f24ce88:         // Clean up the scan based on searching through rightmost leaf of btree
1:eac0369:         positionAtDoneScan(scan_position);
1:eac0369: 
1:eac0369:         return(max_found);
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f6fea40
/////////////////////////////////////////////////////////////////////////
1:                     this, pos,
/////////////////////////////////////////////////////////////////////////
1:                         this, pos,
commit:e47817a
/////////////////////////////////////////////////////////////////////////
1:             // position and let the caller retry. But first, let's save the
1:             // page number of the left sibling so that we can try again to
1:             // get the latch after we've saved the position.
1:             long left = scan_position.current_leaf.getleftSiblingPageNumber();
1: 
/////////////////////////////////////////////////////////////////////////
1:             // There's no point in attempting to reposition too early, as we're
1:             // likely to hit the same WaitError again (and again). So instead
1:             // let's sleep here until the left sibling page has been released,
1:             // and then return to let the caller reposition and retry.
1:             Page leftPage = container.getPage(left);
1:             if (leftPage != null) {
1:                 // Got the latch. Anything may have happened while we didn't
1:                 // hold any latches, so we don't know if we're still supposed
1:                 // to go to that page. Just release the latch and let the
1:                 // caller reposition to the right spot in the B-tree.
1:                 leftPage.unlatch();
1:                 leftPage = null;
1:             }
1: 
commit:20cc8ad
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: A BTreeScan implementation that provides the 95% solution to the max on
/////////////////////////////////////////////////////////////////////////
1:    as it does so, until it finds the first non-deleted, non-NULL row.
1: 3) If it is not successful in this last page search it attempts to latch
1:    the left sibling page, without waiting to avoid deadlocks with forward
1:    scans, and continue the search on that page.
1: 4) If the sibling page couldn't be latched without waiting, save the
1:    current position, release all latches, and restart the scan from the
1:    saved position.
/////////////////////////////////////////////////////////////////////////
1:      * Move the current position to the page to the left of the current page,
1:      * right after the last slot on that page. If we have to wait for a latch,
1:      * give up the latch on the current leaf and give up. The caller will have
1:      * to reposition and retry.
1:      * @return true if the position was successfully moved, false if we had
1:      * to wait for a latch
1:      */
1:     private boolean moveToLeftSibling() throws StandardException {
1:         try {
1:             positionAtPreviousPage();
1:             return true;
1:         } catch (WaitError we) {
1:             // We couldn't get the latch without waiting. Let's save the
0:             // position and let the caller retry.
1:             //
1:             // If the page is empty, there is no position to save. Since
1:             // positionAtPreviousPage() skips empty pages mid-scan, we know
1:             // that an empty page seen here must be the rightmost leaf. In
1:             // that case, the caller can simply restart the scan, so there's
1:             // no need to save the position.
1:             if (isEmpty(scan_position.current_leaf.getPage())) {
1:                 scan_position.current_leaf.release();
1:                 scan_position.init();
1:             } else {
1:                 // Save the leftmost record on the page. That's the record in
1:                 // slot 1, since slot 0 is the control row.
1:                 scan_position.current_slot = 1;
1:                 savePositionAndReleasePage();
1:             }
1:             return false;
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * If no row found on last page, or could not find row without losing latch
/////////////////////////////////////////////////////////////////////////
1:         // In this case the "next" record is the last row on the rightmost
/////////////////////////////////////////////////////////////////////////
1:         leaf_loop:
1:         while (!max_found && pos.current_leaf != null)
1:             if (pos.current_slot <= 1)
1:             {
1:                 // Reached beginning of this leaf page without finding a
1:                 // value, so move position to the end of the left sibling and
1:                 // resume the scan.
1:                 boolean latch_released = !moveToLeftSibling();
1: 
1:                 if (latch_released)
1:                 {
1:                     // The previous page was latched by someone else, so we
1:                     // gave up the latch on this page to avoid running into a
1:                     // deadlock with someone scanning the leaves in the
1:                     // opposite direction.
1: 
1:                     if (SanityManager.DEBUG)
1:                     {
1:                         SanityManager.DEBUG(
1:                                 "BTreeMaxScan.latchConflict",
1:                                 "Couldn't get latch nowait, will retry");
1:                     }
1: 
1:                     if (pos.current_positionKey == null)
1:                     {
1:                         // We haven't seen any rows yet, so no position has
1:                         // been saved. See comment in moveToLeftSibling().
1:                         // Restart the scan from the rightmost leaf.
1:                         if (SanityManager.DEBUG)
1:                         {
1:                             SanityManager.DEBUG(
1:                                     "BTreeMaxScan.latchConflict",
1:                                     "Restart scan from rightmost leaf");
1:                         }
1:                         scan_state = SCAN_INIT;
1:                         positionAtStartPosition(pos);
1:                     }
1:                     else if (!reposition(pos, false))
1:                     {
1:                         if (SanityManager.DEBUG)
1:                         {
1:                             SanityManager.DEBUG(
1:                                     "BTreeMaxScan.latchConflict",
1:                                     "Saved position is gone");
1:                         }
1: 
1:                         // The row on the saved position doesn't exist anymore,
1:                         // so it must have been purged. Move to the position
1:                         // immediately to the left of where the row should
1:                         // have been.
1:                         if (!reposition(pos, true))
1:                         {
1:                             if (SanityManager.DEBUG)
1:                             {
1:                                 SanityManager.THROWASSERT(
1:                                         "Cannot fail with 2nd param true");
1:                             }
1:                         }
1: 
1:                         // reposition() will position to the left of the purged
1:                         // row, whereas we want to be on the right side of it
1:                         // since we're moving backwards.
1:                         pos.current_slot++;
1:                     }
1:                 }
1: 
1:                 // We now have one of the following scenarios:
1:                 //
1:                 // 1) Current position is right after the last row on the left
1:                 //    sibling page if we could move to the sibling page without
1:                 //    waiting for a latch.
1:                 // 2) Current position is on the same row as the last one we
1:                 //    looked at if we had to wait for a latch on the sibling
1:                 //    page and the row hadn't been purged before we
1:                 //    repositioned.
1:                 // 3) Current position is right after the position where we
1:                 //    should have found the last row we looked at if we had
1:                 //    to wait for a latch on the sibling page and the row was
1:                 //    purged before we repositioned.
1:                 // 4) There is no current position if we already were at the
1:                 //    leftmost leaf page.
1:                 //
1:                 // For scenarios 1-3, we're positioned immediately to the right
1:                 // of the next row we want to look at, so going to the top of
1:                 // the loop will make us move to the next interesting row. For
1:                 // scenario 4, we want to break out of the loop, which also
1:                 // is handled by going to the top of the loop and reevaluating
1:                 // the loop condition.
1:                 continue;
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     // Had to wait on lock while not holding the latch, so now
1:                     // the current row may have been moved to another page and
1:                     // we need to reposition.
1:                     if (!reposition(pos, false))
1:                     {
1:                         // Could not position on the exact same row that was
1:                         // saved, which means that it has been purged.
1:                         // Reposition on the row immediately to the left of
1:                         // where the purged row should have been.
1:                         if (!reposition(pos, true))
1:                         {
1:                             if (SanityManager.DEBUG)
1:                             {
1:                                 SanityManager.THROWASSERT(
1:                                         "Cannot fail with 2nd param true");
1:                             }
1:                         }
1: 
1:                         // Now we're positioned immediately to the left of our
1:                         // previous position. We want to be positioned to the
1:                         // right of that position so that we can restart the
1:                         // scan from where we were before we came to the row
1:                         // that disappeared for us. Adjust position one step
1:                         // to the right and continue from the top of the loop.
1:                         pos.current_slot++;
1:                         continue leaf_loop;
1:                     }
/////////////////////////////////////////////////////////////////////////
commit:be4b84e
/////////////////////////////////////////////////////////////////////////
1:                 // Forget the current position since we'll reposition on the
1:                 // rightmost key, which is not necessarily the saved position.
1:                 pos.init();
commit:86e051f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         BTreeRowPosition pos = scan_position;
1: 
/////////////////////////////////////////////////////////////////////////
0:         leaf_loop:
0:             slot_loop:
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                             "BTreeMaxScan_fetchNextGroup", pos,
/////////////////////////////////////////////////////////////////////////
0:                     // Call reposition() which will use the saved record
0:                     // If the row is no longer on the page, reposition()
0:                     // will take care of searching the tree and position
0:                     // on the correct page.
0:                         // Could not position on the exact same row that was
0:                         // saved, which means that it has been purged.
0:                         // Reposition on the row immediately to the left of
0:                         // the purged row instead.
0:                         if (!reposition(pos, true))
1:                             if (SanityManager.DEBUG)
1:                             {
1:                                 SanityManager.THROWASSERT(
0:                                         "Cannot fail with 2nd param true");
1:                             }
0:                             // reposition will set pos.current_leaf to null if
0:                             // it returns false, so if this ever does fail in
0:                             // delivered code, expect a NullPointerException at
0:                             // the top of this loop when we call recordCount().
1: 
0:                         // Now we're positioned to the left of our saved
0:                         // position. Go to the top of the loop so that we move
0:                         // the scan to the next row and release the lock on
0:                         // the purged row.
0:                         continue slot_loop;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             // locking is the max row to return.
/////////////////////////////////////////////////////////////////////////
1:                         "BTreeMaxScan_positionAtStartPosition", pos,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             max_found = fetchMaxRowFromBeginning(fetch_row);
commit:bbcc923
/////////////////////////////////////////////////////////////////////////
0:             SanityManager.ASSERT(pos.current_scan_protectionHandle == null);
/////////////////////////////////////////////////////////////////////////
0:         pos.current_scan_protectionHandle =
0:             pos.current_leaf.page.getProtectionRecordHandle();
commit:227eaef
/////////////////////////////////////////////////////////////////////////
1:   <B>Concurrency Notes</B>
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:854dd10
/////////////////////////////////////////////////////////////////////////
0:         check_row_template[0] = fetch_row[0].cloneValue(false);
commit:4a2b0d9
/////////////////////////////////////////////////////////////////////////
1:             ControlRow root = ControlRow.get(this, BTree.ROOTPAGEID); 
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:f24ce88
/////////////////////////////////////////////////////////////////////////
1: The current implementation only exports to the user the ability to call
1: fetchMax() and get back one row, none of the generic scan ablities are
1: exported.  
1: 
1: To return the maximum row this implementation does the following:
1: 1) calls positionAtStartPosition() which returns with the a latch on the
1:    rightmost leaf page and a lock on the rightmost leaf row on that page.
1:    It will loop until it can get the lock without waiting while holding
1:    the latch.  At this point the slot position is just right of the
1:    locked row.
1: 2) in fetchMax() it loops backward on the last leaf page, locking rows
0:    as it does so, until it either finds the first non-deleted and locks
0:    that row without having to wait and thus did not give up the latch on the 
0:    page.  If successful it returns that row.
0: 3) If it is not successful in this last page search it faults over to 
0:    the original implementation of max scan, which is simply a search from 
0:    left to right at the leaf level for the last row in the table.
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:      * Scan from left to right at the leaf level searching for the 
0:      * rightmost non deleted row in the index.
1:      *
/////////////////////////////////////////////////////////////////////////
1:      * disallow fetchRows on this scan type, caller should only be able
1:      * to call fetchMax().
/////////////////////////////////////////////////////////////////////////
1:      * Position scan at "start" position of the MAX scan.
1:      * Positions the scan to the slot just after the last record on the
1:      * rightmost leaf of the index.  Returns the rightmost leaf page latched,  
1:      * the rightmost row on the page locked and 
1:      * sets "current_slot" to the slot number just right of the last row
1:      * on the page.
/////////////////////////////////////////////////////////////////////////
1:             SanityManager.ASSERT(this.scan_state         == SCAN_INIT);
1:             SanityManager.ASSERT(pos.current_positionKey == null);
1:         // Loop until you can lock the last row, on the rightmost leaf page
1:         // of the tree, while holding the page latched, without waiting.
0:         //
1:         // If you have to wait, drop the latch, and wait for the lock.
1:         // This makes it likely that the next search you will loop just
1:             // search for rightmost leaf.
/////////////////////////////////////////////////////////////////////////
1:             // lock the last row on the rightmost leaf of the table, as this
1:             // is a max scan no previous key locking necessary.  Previous key
1:             // locking is used to protect a range of keys, but for max there
1:             // is only a single row returned.
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * Call positionAtStartPosition() to quickly position on rightmost row
1:      * of rightmost leaf of tree.
1:      *
1:      * Search last page for last non deleted row, and if one is found return
1:      * it as max.
1:      *
0:      * If no row found on last page, or could not find row withou losing latch
1:      * then call fetchMaxRowFromBeginning() to search from left to right
1:      * for maximum value in index.
/////////////////////////////////////////////////////////////////////////
1: 
1:             // RESOLVE (mikem) - I don't think this code can be called.
/////////////////////////////////////////////////////////////////////////
0:         // In this case teh "next" record is the last row on the rightmost
1:         // leaf page.
1:         // Code is positioned on the rightmost leaf of the index, the rightmost
1:         // non-deleted row on this page is the maximum row to return.
1:             // move scan backward in search of last non-deleted row on page.
/////////////////////////////////////////////////////////////////////////
1:                 // lock current row in max scan, no previous key lock necessary.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // Clean up the scan based on searching through rightmost leaf of btree
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.btree.BTreeMaxScan
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.btree;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException; 
1: 
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.ScanController;
1: 
0: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.RecordHandle;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1: 
1: 
1: /**
1: 
1:   A b-tree scan controller corresponds to an instance of an open b-tree scan.
1:   <P>
0:   <B>Concurrency Notes<\B>
1:   <P>
1:   The concurrency rules are derived from OpenBTree.
1:   <P>
1:   @see OpenBTree
1: 
1: **/
1: 
1: /**
1: 
0: A BTreeScan implementation that provides the 90% solution to the max on
1: btree problem.  If the row is the last row in the btree it works very
1: efficiently.  This implementation will be removed once backward scan is
1: fully functional.
1: 
1: **/
1: 
1: public class BTreeMaxScan extends BTreeScan
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 
1:     /**************************************************************************
1:      * Private methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     /**
0:      * Fetch the maximum non-deleted row from the table.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0:     private boolean fetchMaxRowFromBeginning(
1:     BTreeRowPosition        pos,
1:     DataValueDescriptor[]   fetch_row)
1:         throws StandardException
1: 	{
0:         int                 ret_row_count     = 0;
0:         RecordHandle        max_rh            = null;
1: 
0:         // we need to scan until we hit the end of the table or until we
0:         // run into a null.  Use this template to probe the "next" row so
0:         // that if we need to finish, fetch_row will have the right value.
0:         DataValueDescriptor[] check_row_template = new DataValueDescriptor[1];
0:         check_row_template[0] = fetch_row[0].getClone();
0:         FetchDescriptor check_row_desc = RowUtil.getFetchDescriptorConstant(1);
1: 
0:         // reopen the scan for reading from the beginning of the table.
0:         reopenScan(
0:             (DataValueDescriptor[]) null,
0:             ScanController.NA,
0:             (Qualifier[][]) null,
0:             (DataValueDescriptor[]) null,
0:             ScanController.NA);
1: 
0:         positionAtStartForForwardScan(pos);
1: 
1:         // At this point:
1:         // current_page is latched.  current_slot is the slot on current_page
0:         // just before the "next" record this routine should process.
1: 
0:         // loop through successive leaf pages and successive slots on those
0:         // leaf pages.  Stop when either the last leaf is reached. At any
0:         // time in the scan fetch_row will contain "last" non-deleted row
0:         // seen.
1: 
0:         boolean nulls_not_reached = true;
0: 		while ((pos.current_leaf != null) && nulls_not_reached)
1: 		{
0: 			while ((pos.current_slot + 1) < pos.current_leaf.page.recordCount())
1: 			{
0:                 // unlock the previous row if doing read.
0:                 if (pos.current_rh != null)
1:                 {
0:                     this.getLockingPolicy().unlockScanRecordAfterRead(
0:                         pos, init_forUpdate);
1: 
0:                     // current_rh is used to track which row we need to unlock,
0:                     // at this point no row needs to be unlocked.
0:                     pos.current_rh = null;
1:                 }
1: 
0:                 // move scan current position forward.
1:                 pos.current_slot++;
1:                 this.stat_numrows_visited++;
1: 
1:                 // get current record handle for positioning but don't read
1:                 // data until we verify it is not deleted.  rh is needed
1:                 // for repositioning if we lose the latch.
1:                 RecordHandle rh = 
1:                     pos.current_leaf.page.fetchFromSlot(
1:                         (RecordHandle) null,
0:                         pos.current_slot, 
0:                         check_row_template,
0:                         null,
1:                         true);
1: 
0:                 // lock the row.
1:                 boolean latch_released =
1:                     !this.getLockingPolicy().lockScanRow(
0:                         this, this.getConglomerate(), pos,
0:                         false, 
1:                         init_lock_fetch_desc,
1:                         pos.current_lock_template,
1:                         pos.current_lock_row_loc,
1:                         false, init_forUpdate, lock_operation);
1: 
1:                 // special test to see if latch release code works
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     latch_released = 
1:                         test_errors(
1:                             this,
0:                             "BTreeMaxScan_fetchNextGroup", false, 
0:                             this.getLockingPolicy(),
0:                             pos.current_leaf, latch_released);
1:                 }
1: 
1:                 // At this point we have successfully locked this record, so
1:                 // remember the record handle so that it can be unlocked if
1:                 // necessary.  If the above lock deadlocks, we will not try
1:                 // to unlock a lock we never got in close(), because current_rh
1:                 // is null until after the lock is granted.
1:                 pos.current_rh = rh;
1: 
1:                 if (latch_released)
1:                 {
0:                     // lost latch on page in order to wait for row lock.
0:                     // Because we have scan lock on page, we need only
0:                     // call reposition() which will use the saved record
0:                     // handle to reposition to the same spot on the page.
0:                     // We don't have to search the
0:                     // tree again, as we have the a scan lock on the page
0:                     // which means the current_rh is valid to reposition on.
0:                     if (!reposition(pos, false))
1:                     {
1:                         if (SanityManager.DEBUG)
1:                         {
0:                             // can't fail while with scan lock
0:                             SanityManager.THROWASSERT(
0:                                 "can not fail holding scan lock.");
1:                         }
1:                     }
1:                 }
1: 
1: 
1:                 if (pos.current_leaf.page.isDeletedAtSlot(pos.current_slot))
1:                 {
1:                     this.stat_numdeleted_rows_visited++;
1: 
0:                     if (check_row_template[0].isNull())
1:                     {
0:                         // nulls sort at high end and are not to be returned
0:                         // by max scan, so search is over, return whatever is
0:                         // in fetch_row.
0:                         nulls_not_reached = false;
1:                         break;
1:                     }
1:                 }
0:                 else if (check_row_template[0].isNull())
1:                 {
0:                     nulls_not_reached = false;
1:                     break;
1:                 }
1:                 else 
1:                 {
1: 
1:                     pos.current_leaf.page.fetchFromSlot(
0:                         pos.current_rh,
1:                         pos.current_slot, fetch_row, init_fetchDesc,
1:                         true);
1: 
1:                     stat_numrows_qualified++;
0:                     max_rh = pos.current_rh;
1:                 }
1: 			}
1: 
0:             // Move position of the scan to slot 0 of the next page.  If there
0:             // is no next page current_page will be null.
0:             positionAtNextPage(pos);
1: 
0:             this.stat_numpages_visited++;
1: 		}
1: 
1: 
0:         // Reached last leaf of tree.
0:         positionAtDoneScan(pos);
1: 
0:         // we need to decrement when we stop scan at the end of the table.
0:         this.stat_numpages_visited--;
1: 
0:         return(max_rh != null);
1: 	}
1: 
1:     /**************************************************************************
1:      * Protected implementation of abstract methods of BTreeScan class:
1:      **************************************************************************
1:      */
1: 
1:     /**
0:      * disallow fetchRows on this scan type.
1:      * <p>
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected int fetchRows(
1:     BTreeRowPosition        pos,
1:     DataValueDescriptor[][] row_array,
1:     RowLocation[]           rowloc_array,
1:     BackingStoreHashtable   hash_table,
1:     long                    max_rowcnt,
1:     int[]                   key_column_numbers)
1:         throws StandardException
1:     {
1:         throw StandardException.newException(
1:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:     }
1: 
1: 
1:     /**
0:      * Position scan at "start" position of the scan.
1:      * <p>
0:      * Positions the scan to the slot just after the first record to be 
0:      * returned from the backward scan.  Returns the start page latched, and 
0:      * sets "current_slot" to the slot number just right of the first slot
0:      * to return.
1:      * <p>
1:      *
0: 	 * @return The leaf page containing the start position, or null if no
0:      *         start position is found.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected void positionAtStartPosition(
1:     BTreeRowPosition    pos)
1:         throws StandardException
1: 	{
1: 		boolean         exact;
1: 
1:         // This routine should only be called from first next() call //
1:         if (SanityManager.DEBUG)
1:         {
0:             SanityManager.ASSERT(this.scan_state          == SCAN_INIT);
1:             SanityManager.ASSERT(pos.current_rh          == null);
0:             SanityManager.ASSERT(pos.current_positionKey         == null);
0:             SanityManager.ASSERT(pos.current_scan_pageno == 0);
1:         }
1: 
0:         // Loop until you can lock the row previous to the first row to be
0:         // returned by the scan, while holding the page latched, without
0:         // waiting.  If you have to wait, drop the latch, wait for the lock -
0:         // which makes it likely if you wait for the lock you will loop just
1:         // once, find the same lock satisfies the search and since you already
1:         // have the lock it will be granted.
1:         while (true)
1:         {
1:             // Find the starting page and row slot, must start at root and
0:             // search either for leftmost leaf, or search for specific key.
0:             ControlRow root = ControlRow.Get(this, BTree.ROOTPAGEID); 
1: 
1:             // include search of tree in page visited stats.
1:             stat_numpages_visited += root.getLevel() + 1;
1: 
1:             if (init_startKeyValue == null)
1:             {
1:                 // No start given, position at last slot + 1 of rightmost leaf 
1:                 pos.current_leaf = (LeafControlRow) root.searchRight(this);
1: 
1:                 pos.current_slot = pos.current_leaf.page.recordCount();
1:                 exact     = false;
1:             }
1:             else
1:             {
1:                 // only max needed, no start position supported.
1:                 throw StandardException.newException(
1:                         SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:             }
1: 
0:             // backward scan initial positioning will request a previous
0:             // key lock for initial positioning.  The actual scan will have
0:             // to make 2 lock requests per row fetch, one for a previous key
0:             // and one for lock on row it is positioned on.  Optimizations
0:             // can be made depending on isolation level.
0:             // 
0:             // Note that this is not a "previous key" lock as the row we are
0:             // locking is the max row to return.  Get the scan lock at the
0:             // same time.
1: 
1:             pos.current_slot--;
1:             boolean latch_released = 
1:                 !this.getLockingPolicy().lockScanRow(
0:                     this, this.getConglomerate(), pos,
0:                     true, 
1:                     init_lock_fetch_desc,
1:                     pos.current_lock_template,
1:                     pos.current_lock_row_loc,
1:                     false, init_forUpdate, lock_operation);
1:             pos.current_slot++;
1: 
1:             // special test to see if latch release code works
1:             if (SanityManager.DEBUG)
1:             {
1:                 latch_released = 
1:                     test_errors(
1:                         this,
0:                         "BTreeMaxScan_positionAtStartPosition", true,
1:                         this.getLockingPolicy(), pos.current_leaf, latch_released);
1:             }
1: 
1:             if (latch_released)
1:             {
1:                 // lost latch on pos.current_leaf, search the tree again.
1:                 pos.current_leaf = null;
1:                 continue;
1:             }
1:             else
1:             {
1:                 // success! got all the locks, while holding the latch.
1:                 break;
1:             }
1:         }
1: 
1:         this.scan_state          = SCAN_INPROGRESS;
0:         pos.current_scan_pageno = pos.current_leaf.page.getPageNumber();
1: 
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT(pos.current_leaf != null);
1: 	}
1: 
1:     /**************************************************************************
1:      * Public Methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Fetch the maximum row in the table.
1:      * <p>
0:      * Utility routine used by both fetchSet() and fetchNextGroup().
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public boolean fetchMax(
1:     DataValueDescriptor[]   fetch_row)
1:         throws StandardException
1:     {
1:         BTreeRowPosition    pos           = scan_position;
1:         int                 ret_row_count = 0;
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(this.container != null,
1:                 "BTreeMaxScan.fetchMax() called on a closed scan.");
1:         }
1: 
1: 
1:         if (this.scan_state == BTreeScan.SCAN_INPROGRESS)
1:         {
1:             // Get current page of scan, with latch
1:             
1:             // reposition the scan at the row just before the next one to 
1:             // return.
1:             // This routine handles the mess of repositioning if the row or 
1:             // the page has disappeared. This can happen if a lock was not 
1:             // held on the row while not holding the latch (can happen if
1:             // this scan is read uncommitted).
1:             if (!reposition(scan_position, true))
1:             {
1:                 if (SanityManager.DEBUG)
1:                 {
0:                     SanityManager.THROWASSERT(
1:                         "can not fail with 2nd param true.");
1:                 }
1:             }
1: 
1:         }
1:         else if (this.scan_state == SCAN_INIT)
1:         {
1:             // 1st positioning of scan (delayed from openScan).
1:             positionAtStartPosition(scan_position);
1:         }
1:         else
1:         {
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(this.scan_state == SCAN_DONE);
1: 
1:             return(false);
1:         }
1: 
1: 
1:         // At this point:
1:         // current_page is latched.  current_slot is the slot on current_page
1:         // just "right" of the "next" record this routine should process.
1: 
1: 
1:         boolean max_found = false;
1: 
0:         // if we can find a non-deleted row on this page then it is easy.
1: 
0:         if ((pos.current_slot - 1) > 0)
1:         {
0:             // move scan current position forward.
1:             pos.current_slot--;
1: 
1:             while (pos.current_slot > 0)
1:             {
1:                 this.stat_numrows_visited++;
1: 
1:                 // get current record handle for positioning but don't read
1:                 // data until we verify it is not deleted.  rh is needed
1:                 // for repositioning if we lose the latch.
1:                 RecordHandle rh = 
1:                     pos.current_leaf.page.fetchFromSlot(
1:                         (RecordHandle) null,
1:                         pos.current_slot, fetch_row, init_fetchDesc,
1:                         true);
1: 
1:                 boolean latch_released =
1:                     !this.getLockingPolicy().lockScanRow(
0:                         this, this.getConglomerate(), pos, 
0:                         false, 
1:                         init_lock_fetch_desc,
1:                         pos.current_lock_template,
1:                         pos.current_lock_row_loc,
1:                         false, init_forUpdate, lock_operation);
1: 
1:                 // At this point we have successfully locked this record, so
1:                 // remember the record handle so that it can be unlocked if
1:                 // necessary.  If the above lock deadlocks, we will not try
1:                 // to unlock a lock we never got in close(), because current_rh
1:                 // is null until after the lock is granted.
1:                 pos.current_rh = rh;
1: 
1: 
1:                 if (latch_released)
1:                 {
0:                     // had to wait on lock while lost latch, now last page of
0:                     // index may have changed, give up on "easy/fast" max scan.
1:                     pos.current_leaf = null;
1:                     break;
1:                 }
1: 
1:                 if (pos.current_leaf.page.isDeletedAtSlot(pos.current_slot))
1:                 {
1:                     this.stat_numdeleted_rows_visited++;
1:                     pos.current_rh_qualified = false;
1:                 }
1:                 else if (fetch_row[0].isNull())
1:                 {
1:                     pos.current_rh_qualified = false;
1:                 }
1:                 else
1:                 {
1:                     pos.current_rh_qualified = true;
1:                 }
1: 
1:                 if (pos.current_rh_qualified)
1:                 {
1:                     // return the qualifying max row.
1: 
0:                     // Found qualifying row.  Are we done fetching rows for the
0:                     // group?
1:                     ret_row_count++;
1:                     stat_numrows_qualified++;
1: 
1:                     // current_slot is invalid after releasing latch
1:                     pos.current_slot = Page.INVALID_SLOT_NUMBER;
1: 
1:                     max_found = true;
1:                     break;
1:                 }
1:                 else
1:                 {
1:                     pos.current_slot--;
1:                 }
1:             }
1: 		}
1: 
1:         if (pos.current_leaf != null)
1:         {
1:             // done with "last" page in table.
1:             pos.current_leaf.release();
1:             pos.current_leaf = null;
1:         }
1: 
0:         // Reached last leaf of tree.
1:         positionAtDoneScan(scan_position);
1: 
0:         if (!max_found)
1:         {
0:             // max row in table was not last row in table
0:             max_found = fetchMaxRowFromBeginning(scan_position, fetch_row);
1:         }
1: 
1:         return(max_found);
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.btree;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException; 
0: 
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.ScanController;
0: 
0: import org.apache.derby.iapi.store.raw.FetchDescriptor;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
0: 
0: 
0: /**
0: 
0:   A b-tree scan controller corresponds to an instance of an open b-tree scan.
0:   <P>
0:   <B>Concurrency Notes<\B>
0:   <P>
0:   The concurrency rules are derived from OpenBTree.
0:   <P>
0:   @see OpenBTree
0: 
0: **/
0: 
0: /**
0: 
0: A BTreeScan implementation that provides the 90% solution to the max on
0: btree problem.  If the row is the last row in the btree it works very
0: efficiently.  This implementation will be removed once backward scan is
0: fully functional.
0: 
0: **/
0: 
0: public class BTreeMaxScan extends BTreeScan
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 
0:     /**************************************************************************
0:      * Private methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Fetch the maximum non-deleted row from the table.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     private boolean fetchMaxRowFromBeginning(
0:     BTreeRowPosition        pos,
0:     DataValueDescriptor[]   fetch_row)
0:         throws StandardException
0: 	{
0:         int                 ret_row_count     = 0;
0:         RecordHandle        max_rh            = null;
0: 
0:         // we need to scan until we hit the end of the table or until we
0:         // run into a null.  Use this template to probe the "next" row so
0:         // that if we need to finish, fetch_row will have the right value.
0:         DataValueDescriptor[] check_row_template = new DataValueDescriptor[1];
0:         check_row_template[0] = fetch_row[0].getClone();
0:         FetchDescriptor check_row_desc = RowUtil.getFetchDescriptorConstant(1);
0: 
0:         // reopen the scan for reading from the beginning of the table.
0:         reopenScan(
0:             (DataValueDescriptor[]) null,
0:             ScanController.NA,
0:             (Qualifier[][]) null,
0:             (DataValueDescriptor[]) null,
0:             ScanController.NA);
0: 
0:         positionAtStartForForwardScan(pos);
0: 
0:         // At this point:
0:         // current_page is latched.  current_slot is the slot on current_page
0:         // just before the "next" record this routine should process.
0: 
0:         // loop through successive leaf pages and successive slots on those
0:         // leaf pages.  Stop when either the last leaf is reached. At any
0:         // time in the scan fetch_row will contain "last" non-deleted row
0:         // seen.
0: 
0:         boolean nulls_not_reached = true;
0: 		while ((pos.current_leaf != null) && nulls_not_reached)
0: 		{
0: 			while ((pos.current_slot + 1) < pos.current_leaf.page.recordCount())
0: 			{
0:                 // unlock the previous row if doing read.
0:                 if (pos.current_rh != null)
0:                 {
0:                     this.getLockingPolicy().unlockScanRecordAfterRead(
0:                         pos, init_forUpdate);
0: 
0:                     // current_rh is used to track which row we need to unlock,
0:                     // at this point no row needs to be unlocked.
0:                     pos.current_rh = null;
0:                 }
0: 
0:                 // move scan current position forward.
0:                 pos.current_slot++;
0:                 this.stat_numrows_visited++;
0: 
0:                 // get current record handle for positioning but don't read
0:                 // data until we verify it is not deleted.  rh is needed
0:                 // for repositioning if we lose the latch.
0:                 RecordHandle rh = 
0:                     pos.current_leaf.page.fetchFromSlot(
0:                         (RecordHandle) null,
0:                         pos.current_slot, 
0:                         check_row_template,
0:                         null,
0:                         true);
0: 
0:                 // lock the row.
0:                 boolean latch_released =
0:                     !this.getLockingPolicy().lockScanRow(
0:                         this, this.getConglomerate(), pos,
0:                         false, 
0:                         init_lock_fetch_desc,
0:                         pos.current_lock_template,
0:                         pos.current_lock_row_loc,
0:                         false, init_forUpdate, lock_operation);
0: 
0:                 // special test to see if latch release code works
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     latch_released = 
0:                         test_errors(
0:                             this,
0:                             "BTreeMaxScan_fetchNextGroup", false, 
0:                             this.getLockingPolicy(),
0:                             pos.current_leaf, latch_released);
0:                 }
0: 
0:                 // At this point we have successfully locked this record, so
0:                 // remember the record handle so that it can be unlocked if
0:                 // necessary.  If the above lock deadlocks, we will not try
0:                 // to unlock a lock we never got in close(), because current_rh
0:                 // is null until after the lock is granted.
0:                 pos.current_rh = rh;
0: 
0:                 if (latch_released)
0:                 {
0:                     // lost latch on page in order to wait for row lock.
0:                     // Because we have scan lock on page, we need only
0:                     // call reposition() which will use the saved record
0:                     // handle to reposition to the same spot on the page.
0:                     // We don't have to search the
0:                     // tree again, as we have the a scan lock on the page
0:                     // which means the current_rh is valid to reposition on.
0:                     if (!reposition(pos, false))
0:                     {
0:                         if (SanityManager.DEBUG)
0:                         {
0:                             // can't fail while with scan lock
0:                             SanityManager.THROWASSERT(
0:                                 "can not fail holding scan lock.");
0:                         }
0:                     }
0:                 }
0: 
0: 
0:                 if (pos.current_leaf.page.isDeletedAtSlot(pos.current_slot))
0:                 {
0:                     this.stat_numdeleted_rows_visited++;
0: 
0:                     if (check_row_template[0].isNull())
0:                     {
0:                         // nulls sort at high end and are not to be returned
0:                         // by max scan, so search is over, return whatever is
0:                         // in fetch_row.
0:                         nulls_not_reached = false;
0:                         break;
0:                     }
0:                 }
0:                 else if (check_row_template[0].isNull())
0:                 {
0:                     nulls_not_reached = false;
0:                     break;
0:                 }
0:                 else 
0:                 {
0: 
0:                     pos.current_leaf.page.fetchFromSlot(
0:                         pos.current_rh,
0:                         pos.current_slot, fetch_row, init_fetchDesc,
0:                         true);
0: 
0:                     stat_numrows_qualified++;
0:                     max_rh = pos.current_rh;
0:                 }
0: 			}
0: 
0:             // Move position of the scan to slot 0 of the next page.  If there
0:             // is no next page current_page will be null.
0:             positionAtNextPage(pos);
0: 
0:             this.stat_numpages_visited++;
0: 		}
0: 
0: 
0:         // Reached last leaf of tree.
0:         positionAtDoneScan(pos);
0: 
0:         // we need to decrement when we stop scan at the end of the table.
0:         this.stat_numpages_visited--;
0: 
0:         return(max_rh != null);
0: 	}
0: 
0:     /**************************************************************************
0:      * Protected implementation of abstract methods of BTreeScan class:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * disallow fetchRows on this scan type.
0:      * <p>
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     protected int fetchRows(
0:     BTreeRowPosition        pos,
0:     DataValueDescriptor[][] row_array,
0:     RowLocation[]           rowloc_array,
0:     BackingStoreHashtable   hash_table,
0:     long                    max_rowcnt,
0:     int[]                   key_column_numbers)
0:         throws StandardException
0:     {
0:         throw StandardException.newException(
0:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
0:     }
0: 
0: 
0:     /**
0:      * Position scan at "start" position of the scan.
0:      * <p>
0:      * Positions the scan to the slot just after the first record to be 
0:      * returned from the backward scan.  Returns the start page latched, and 
0:      * sets "current_slot" to the slot number just right of the first slot
0:      * to return.
0:      * <p>
0:      *
0: 	 * @return The leaf page containing the start position, or null if no
0:      *         start position is found.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     protected void positionAtStartPosition(
0:     BTreeRowPosition    pos)
0:         throws StandardException
0: 	{
0: 		boolean         exact;
0: 
0:         // This routine should only be called from first next() call //
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(this.scan_state          == SCAN_INIT);
0:             SanityManager.ASSERT(pos.current_rh          == null);
0:             SanityManager.ASSERT(pos.current_positionKey         == null);
0:             SanityManager.ASSERT(pos.current_scan_pageno == 0);
0:         }
0: 
0:         // Loop until you can lock the row previous to the first row to be
0:         // returned by the scan, while holding the page latched, without
0:         // waiting.  If you have to wait, drop the latch, wait for the lock -
0:         // which makes it likely if you wait for the lock you will loop just
0:         // once, find the same lock satisfies the search and since you already
0:         // have the lock it will be granted.
0:         while (true)
0:         {
0:             // Find the starting page and row slot, must start at root and
0:             // search either for leftmost leaf, or search for specific key.
0:             ControlRow root = ControlRow.Get(this, BTree.ROOTPAGEID); 
0: 
0:             // include search of tree in page visited stats.
0:             stat_numpages_visited += root.getLevel() + 1;
0: 
0:             if (init_startKeyValue == null)
0:             {
0:                 // No start given, position at last slot + 1 of rightmost leaf 
0:                 pos.current_leaf = (LeafControlRow) root.searchRight(this);
0: 
0:                 pos.current_slot = pos.current_leaf.page.recordCount();
0:                 exact     = false;
0:             }
0:             else
0:             {
0:                 // only max needed, no start position supported.
0:                 throw StandardException.newException(
0:                         SQLState.BTREE_UNIMPLEMENTED_FEATURE);
0:             }
0: 
0:             // backward scan initial positioning will request a previous
0:             // key lock for initial positioning.  The actual scan will have
0:             // to make 2 lock requests per row fetch, one for a previous key
0:             // and one for lock on row it is positioned on.  Optimizations
0:             // can be made depending on isolation level.
0:             // 
0:             // Note that this is not a "previous key" lock as the row we are
0:             // locking is the max row to return.  Get the scan lock at the
0:             // same time.
0: 
0:             pos.current_slot--;
0:             boolean latch_released = 
0:                 !this.getLockingPolicy().lockScanRow(
0:                     this, this.getConglomerate(), pos,
0:                     true, 
0:                     init_lock_fetch_desc,
0:                     pos.current_lock_template,
0:                     pos.current_lock_row_loc,
0:                     false, init_forUpdate, lock_operation);
0:             pos.current_slot++;
0: 
0:             // special test to see if latch release code works
0:             if (SanityManager.DEBUG)
0:             {
0:                 latch_released = 
0:                     test_errors(
0:                         this,
0:                         "BTreeMaxScan_positionAtStartPosition", true,
0:                         this.getLockingPolicy(), pos.current_leaf, latch_released);
0:             }
0: 
0:             if (latch_released)
0:             {
0:                 // lost latch on pos.current_leaf, search the tree again.
0:                 pos.current_leaf = null;
0:                 continue;
0:             }
0:             else
0:             {
0:                 // success! got all the locks, while holding the latch.
0:                 break;
0:             }
0:         }
0: 
0:         this.scan_state          = SCAN_INPROGRESS;
0:         pos.current_scan_pageno = pos.current_leaf.page.getPageNumber();
0: 
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(pos.current_leaf != null);
0: 	}
0: 
0:     /**************************************************************************
0:      * Public Methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Fetch the maximum row in the table.
0:      * <p>
0:      * Utility routine used by both fetchSet() and fetchNextGroup().
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public boolean fetchMax(
0:     DataValueDescriptor[]   fetch_row)
0:         throws StandardException
0:     {
0:         BTreeRowPosition    pos           = scan_position;
0:         int                 ret_row_count = 0;
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(this.container != null,
0:                 "BTreeMaxScan.fetchMax() called on a closed scan.");
0:         }
0: 
0: 
0:         if (this.scan_state == BTreeScan.SCAN_INPROGRESS)
0:         {
0:             // Get current page of scan, with latch
0:             
0:             // reposition the scan at the row just before the next one to 
0:             // return.
0:             // This routine handles the mess of repositioning if the row or 
0:             // the page has disappeared. This can happen if a lock was not 
0:             // held on the row while not holding the latch (can happen if
0:             // this scan is read uncommitted).
0:             if (!reposition(scan_position, true))
0:             {
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     SanityManager.THROWASSERT(
0:                         "can not fail with 2nd param true.");
0:                 }
0:             }
0: 
0:         }
0:         else if (this.scan_state == SCAN_INIT)
0:         {
0:             // 1st positioning of scan (delayed from openScan).
0:             positionAtStartPosition(scan_position);
0:         }
0:         else
0:         {
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(this.scan_state == SCAN_DONE);
0: 
0:             return(false);
0:         }
0: 
0: 
0:         // At this point:
0:         // current_page is latched.  current_slot is the slot on current_page
0:         // just "right" of the "next" record this routine should process.
0: 
0: 
0:         boolean max_found = false;
0: 
0:         // if we can find a non-deleted row on this page then it is easy.
0: 
0:         if ((pos.current_slot - 1) > 0)
0:         {
0:             // move scan current position forward.
0:             pos.current_slot--;
0: 
0:             while (pos.current_slot > 0)
0:             {
0:                 this.stat_numrows_visited++;
0: 
0:                 // get current record handle for positioning but don't read
0:                 // data until we verify it is not deleted.  rh is needed
0:                 // for repositioning if we lose the latch.
0:                 RecordHandle rh = 
0:                     pos.current_leaf.page.fetchFromSlot(
0:                         (RecordHandle) null,
0:                         pos.current_slot, fetch_row, init_fetchDesc,
0:                         true);
0: 
0:                 boolean latch_released =
0:                     !this.getLockingPolicy().lockScanRow(
0:                         this, this.getConglomerate(), pos, 
0:                         false, 
0:                         init_lock_fetch_desc,
0:                         pos.current_lock_template,
0:                         pos.current_lock_row_loc,
0:                         false, init_forUpdate, lock_operation);
0: 
0:                 // At this point we have successfully locked this record, so
0:                 // remember the record handle so that it can be unlocked if
0:                 // necessary.  If the above lock deadlocks, we will not try
0:                 // to unlock a lock we never got in close(), because current_rh
0:                 // is null until after the lock is granted.
0:                 pos.current_rh = rh;
0: 
0: 
0:                 if (latch_released)
0:                 {
0:                     // had to wait on lock while lost latch, now last page of
0:                     // index may have changed, give up on "easy/fast" max scan.
0:                     pos.current_leaf = null;
0:                     break;
0:                 }
0: 
0:                 if (pos.current_leaf.page.isDeletedAtSlot(pos.current_slot))
0:                 {
0:                     this.stat_numdeleted_rows_visited++;
0:                     pos.current_rh_qualified = false;
0:                 }
0:                 else if (fetch_row[0].isNull())
0:                 {
0:                     pos.current_rh_qualified = false;
0:                 }
0:                 else
0:                 {
0:                     pos.current_rh_qualified = true;
0:                 }
0: 
0:                 if (pos.current_rh_qualified)
0:                 {
0:                     // return the qualifying max row.
0: 
0:                     // Found qualifying row.  Are we done fetching rows for the
0:                     // group?
0:                     ret_row_count++;
0:                     stat_numrows_qualified++;
0: 
0:                     // current_slot is invalid after releasing latch
0:                     pos.current_slot = Page.INVALID_SLOT_NUMBER;
0: 
0:                     max_found = true;
0:                     break;
0:                 }
0:                 else
0:                 {
0:                     pos.current_slot--;
0:                 }
0:             }
0: 		}
0: 
0:         if (pos.current_leaf != null)
0:         {
0:             // done with "last" page in table.
0:             pos.current_leaf.release();
0:             pos.current_leaf = null;
0:         }
0: 
0:         // Reached last leaf of tree.
0:         positionAtDoneScan(scan_position);
0: 
0:         if (!max_found)
0:         {
0:             // max row in table was not last row in table
0:             max_found = fetchMaxRowFromBeginning(scan_position, fetch_row);
0:         }
0: 
0:         return(max_found);
0: 	}
0: }
============================================================================