2:7fc54b9: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.GenericActivationHolder
1:e4caed2: 
1:67c1c96:    Licensed to the Apache Software Foundation (ASF) under one or more
1:67c1c96:    contributor license agreements.  See the NOTICE file distributed with
1:67c1c96:    this work for additional information regarding copyright ownership.
1:67c1c96:    The ASF licenses this file to you under the Apache License, Version 2.0
1:67c1c96:    (the "License"); you may not use this file except in compliance with
1:67c1c96:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
9:eac0369:  */
1:7fc54b9: 
1:eac0369: package org.apache.derby.impl.sql;
1:e4caed2: 
1:801cf0d: import java.sql.SQLWarning;
1:801cf0d: import java.util.Enumeration;
1:801cf0d: import java.util.Vector;
1:801cf0d: import org.apache.derby.catalog.Dependable;
1:801cf0d: import org.apache.derby.catalog.DependableFinder;
1:e4caed2: import org.apache.derby.catalog.UUID;
1:801cf0d: import org.apache.derby.iapi.error.StandardException;
1:801cf0d: import org.apache.derby.iapi.reference.SQLState;
1:801cf0d: import org.apache.derby.iapi.services.loader.GeneratedClass;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:801cf0d: import org.apache.derby.iapi.sql.Activation;
1:801cf0d: import org.apache.derby.iapi.sql.ParameterValueSet;
1:801cf0d: import org.apache.derby.iapi.sql.ResultDescription;
1:801cf0d: import org.apache.derby.iapi.sql.ResultSet;
1:c533cd2: import org.apache.derby.iapi.sql.Row;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:6950a39: import org.apache.derby.iapi.sql.conn.SQLSessionContext;
1:801cf0d: import org.apache.derby.iapi.sql.depend.Provider;
1:801cf0d: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:801cf0d: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:801cf0d: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1:eac0369: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:eac0369: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.ScanController;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:801cf0d: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:801cf0d: import org.apache.derby.iapi.types.DataValueFactory;
1:a180287: import org.apache.derby.iapi.types.NumberDataValue;
1:801cf0d: import org.apache.derby.iapi.types.RowLocation;
1:801cf0d: import org.apache.derby.impl.sql.execute.BaseActivation;
48:eac0369: 
3:eac0369: /**
1:eac0369:  * This class holds an Activation, and passes through most of the calls
1:eac0369:  * to the activation.  The purpose of this class is to allow a PreparedStatement
1:eac0369:  * to be recompiled without the caller having to detect this and get a new
1:eac0369:  * activation.
1:eac0369:  *
1:eac0369:  * In addition to the Activation, this class holds a reference to the
1:eac0369:  * PreparedStatement that created it, along with a reference to the
1:eac0369:  * GeneratedClass that was associated with the PreparedStatement at the time
1:eac0369:  * this holder was created.  These references are used to validate the
1:eac0369:  * Activation, to ensure that an activation is used only with the
1:eac0369:  * PreparedStatement that created it, and to detect when recompilation has
1:eac0369:  * happened.
1:eac0369:  *
1:eac0369:  * We detect recompilation by checking whether the GeneratedClass has changed.
1:eac0369:  * If it has, we try to let the caller continue to use this ActivationHolder.
1:eac0369:  * We create a new instance of the new GeneratedClass (that is, we create a
1:eac0369:  * new Activation), and we compare the number and type of parameters.  If these
1:eac0369:  * are compatible, we copy the parameters from the old to the new Activation.
1:eac0369:  * If they are not compatible, we throw an exception telling the user that
1:eac0369:  * the Activation is out of date, and they need to get a new one.
1:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:e3883f5: final public class GenericActivationHolder implements Activation
3:eac0369: {
1:e3883f5: 	public BaseActivation			ac;
1:eac0369: 	ExecPreparedStatement	ps;
1:eac0369: 	GeneratedClass			gc;
1:eac0369: 	DataTypeDescriptor[]	paramTypes;
1:eac0369: 	private final LanguageConnectionContext lcc;
1:eac0369: 	/**
1:eac0369: 	 * Constructor for an ActivationHolder
1:eac0369: 	 *
1:eac0369: 	 * @param gc	The GeneratedClass of the Activation
1:eac0369: 	 * @param ps	The PreparedStatement this ActivationHolder is associated
1:eac0369: 	 *				with
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	GenericActivationHolder(LanguageConnectionContext lcc, GeneratedClass gc, ExecPreparedStatement ps, boolean scrollable)
2:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		this.lcc = lcc;
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(gc != null, "generated class is null , ps is a " + ps.getClass());
1:85132a2: 		}
1:85132a2: 
1:eac0369: 		this.gc = gc;
1:eac0369: 		this.ps = ps;
1:7fc54b9: 
1:eac0369: 		ac = (BaseActivation) gc.newInstance(lcc);
1:eac0369: 		ac.setupActivation(ps, scrollable);
1:eac0369: 		paramTypes = ps.getParameterTypes();
1:85132a2: 	}
1:7fc54b9: 
1:eac0369: 	/* Activation interface */
1:7fc54b9: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#reset
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure
1:7fc54b9: 	 */
1:eac0369: 	public void	reset() throws StandardException
1:eac0369: 	{
1:eac0369: 		ac.reset();
1:7fc54b9: 	}
1:7fc54b9: 
1:eac0369: 	/**
1:eac0369: 	 * Temporary tables can be declared with ON COMMIT DELETE ROWS. But if the table has a held curosr open at
1:eac0369: 	 * commit time, data should not be deleted from the table. This method, (gets called at commit time) checks if this
1:eac0369: 	 * activation held cursor and if so, does that cursor reference the passed temp table name.
1:eac0369: 	 *
1:eac0369: 	 * @return	true if this activation has held cursor and if it references the passed temp table name
1:eac0369: 	 */
1:eac0369: 	public boolean checkIfThisActivationHasHoldCursor(String tableName)
1:eac0369: 	{
1:eac0369: 		return ac.checkIfThisActivationHasHoldCursor(tableName);
8:eac0369: 	}
1:7fc54b9: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#setCursorName
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void	setCursorName(String cursorName)
1:eac0369: 	{
1:eac0369: 		ac.setCursorName(cursorName);
1:eac0369: 	}
1:387d1fb: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getCursorName
1:eac0369: 	 */
1:eac0369: 	public String	getCursorName()
1:eac0369: 	{
1:eac0369: 		return ac.getCursorName();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#setResultSetHoldability
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void	setResultSetHoldability(boolean resultSetHoldability)
1:eac0369: 	{
1:eac0369: 		ac.setResultSetHoldability(resultSetHoldability);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getResultSetHoldability
1:eac0369: 	 */
1:eac0369: 	public boolean	getResultSetHoldability()
1:eac0369: 	{
1:eac0369: 		return ac.getResultSetHoldability();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Activation#setAutoGeneratedKeysResultsetInfo */
1:eac0369: 	public void setAutoGeneratedKeysResultsetInfo(int[] columnIndexes, String[] columnNames)
1:eac0369: 	{
1:eac0369: 		ac.setAutoGeneratedKeysResultsetInfo(columnIndexes, columnNames);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Activation#getAutoGeneratedKeysResultsetMode */
1:eac0369: 	public boolean getAutoGeneratedKeysResultsetMode()
1:eac0369: 	{
1:eac0369: 		return ac.getAutoGeneratedKeysResultsetMode();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Activation#getAutoGeneratedKeysColumnIndexes */
1:eac0369: 	public int[] getAutoGeneratedKeysColumnIndexes()
1:eac0369: 	{
1:eac0369: 		return ac.getAutoGeneratedKeysColumnIndexes();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Activation#getAutoGeneratedKeysColumnNames */
1:eac0369: 	public String[] getAutoGeneratedKeysColumnNames()
1:eac0369: 	{
1:eac0369: 		return ac.getAutoGeneratedKeysColumnNames();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see org.apache.derby.iapi.sql.Activation#getLanguageConnectionContext */
1:eac0369: 	public	LanguageConnectionContext	getLanguageConnectionContext()
1:eac0369: 	{
1:eac0369: 		return	lcc;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public TransactionController getTransactionController()
1:eac0369: 	{
1:eac0369: 		return ac.getTransactionController();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Activation#getExecutionFactory */
1:eac0369: 	public	ExecutionFactory	getExecutionFactory()
1:eac0369: 	{
1:eac0369: 		return	ac.getExecutionFactory();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getParameterValueSet
1:eac0369: 	 */
1:eac0369: 	public ParameterValueSet	getParameterValueSet()
1:eac0369: 	{
1:eac0369: 		return ac.getParameterValueSet();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#setParameters
1:eac0369: 	 */
1:eac0369: 	public void	setParameters(ParameterValueSet parameterValues, DataTypeDescriptor[] parameterTypes) throws StandardException
1:eac0369: 	{
1:eac0369: 		ac.setParameters(parameterValues, parameterTypes);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * @see Activation#execute
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:eac0369: 	public ResultSet execute() throws StandardException
1:eac0369: 	{
1:7fc54b9: 		/*
1:eac0369: 		** Synchronize to avoid problems if another thread is preparing
1:eac0369: 		** the statement at the same time we're trying to execute it.
1:7fc54b9: 		*/
1:eac0369: 		// synchronized (ps)
1:eac0369: 		{
1:e4caed2: 			/* Has the activation class changed or has the activation been
1:e4caed2: 			 * invalidated? */
1:6555d3c:             final boolean needNewClass =
1:6555d3c:                     gc == null || gc != ps.getActivationClass();
1:6555d3c: 			if (needNewClass || !ac.isValid())
1:7fc54b9: 			{
1:85132a2: 
1:85132a2:                 GeneratedClass newGC;
1:85132a2: 
1:6555d3c: 				if (needNewClass) {
1:6555d3c:                     // The statement has been re-prepared since the last time
1:6555d3c:                     // we executed it. Get the new activation class.
1:e4caed2:                     newGC = ps.getActivationClass();
1:6555d3c:                     if (newGC == null) {
1:6555d3c:                         // There is no class associated with the statement.
1:6555d3c:                         // Tell the caller that the statement needs to be
1:6555d3c:                         // recompiled.
1:6555d3c:                         throw StandardException.newException(
1:6555d3c:                                 SQLState.LANG_STATEMENT_NEEDS_RECOMPILE);
1:e4caed2:                     }
1:e4caed2: 				} else {
1:e4caed2: 					// Reuse the generated class, we just want a new activation
1:e4caed2: 					// since the old is no longer valid.
1:e4caed2: 					newGC = gc;
1:e4caed2: 				}
1:e4caed2: 
1:85132a2: 
1:85132a2: 				/*
1:e4caed2: 				** If we get here, it means the Activation has been invalidated
1:e4caed2: 				** or the PreparedStatement has been recompiled.  Get a new
1:e4caed2: 				** Activation and check whether the parameters are compatible.
1:e4caed2: 				** If so, transfer the parameters from the old Activation to
1:e4caed2: 				** the new one, and make that the current Activation.  If not,
1:e4caed2: 				** throw an exception.
1:85132a2: 				*/
1:85132a2: 				BaseActivation		newAC = (BaseActivation) newGC.newInstance(lcc);
1:85132a2: 
1:85132a2: 				DataTypeDescriptor[]	newParamTypes = ps.getParameterTypes();
1:85132a2: 
1:85132a2: 				/*
1:85132a2: 				** Link the new activation to the prepared statement.
1:85132a2: 				*/
1:85132a2: 				newAC.setupActivation(ps, ac.getScrollable());
1:85132a2: 
1:85132a2: 				newAC.setParameters(ac.getParameterValueSet(), paramTypes);
1:85132a2: 
1:85132a2: 
1:85132a2: 				/*
1:85132a2: 				** IMPORTANT
1:85132a2: 				**
1:85132a2: 				** Copy any essential state from the old activation
1:85132a2: 				** to the new activation. This must match the state
1:85132a2: 				** setup in EmbedStatement.
1:85132a2: 				** singleExecution, cursorName, holdability, maxRows.
1:85132a2: 				*/
1:85132a2: 
1:85132a2: 				if (ac.isSingleExecution())
1:85132a2: 					newAC.setSingleExecution();
1:85132a2: 
1:85132a2: 				newAC.setCursorName(ac.getCursorName());
1:85132a2: 
1:85132a2: 				newAC.setResultSetHoldability(ac.getResultSetHoldability());
1:85132a2: 				if (ac.getAutoGeneratedKeysResultsetMode()) //Need to do copy only if auto generated mode is on
1:706f2eb:                 {
1:85132a2: 					newAC.setAutoGeneratedKeysResultsetInfo(ac.getAutoGeneratedKeysColumnIndexes(),
1:85132a2: 					ac.getAutoGeneratedKeysColumnNames());
1:706f2eb:                 }
1:85132a2: 				newAC.setMaxRows(ac.getMaxRows());
1:85132a2: 
1:85132a2: 				// break the link with the prepared statement
1:85132a2: 				ac.setupActivation(null, false);
1:85132a2: 				ac.close();
1:85132a2: 
1:85132a2: 				/* Remember the new class information */
1:85132a2: 				ac = newAC;
1:85132a2: 				gc = newGC;
1:85132a2: 				paramTypes = newParamTypes;
1:6555d3c: 			}
1:387d1fb: 		}
1:7fc54b9: 
1:eac0369: 		String cursorName = ac.getCursorName();
1:eac0369: 		if (cursorName != null)
1:eac0369: 		{
1:eac0369: 			// have to see if another activation is open
1:eac0369: 			// with the same cursor name. If so we can't use this name
1:7fc54b9: 
1:eac0369: 			Activation activeCursor = lcc.lookupCursorActivation(cursorName);
1:7fc54b9: 
1:eac0369: 			if ((activeCursor != null) && (activeCursor != ac)) {
1:eac0369: 				throw StandardException.newException(SQLState.LANG_CURSOR_ALREADY_EXISTS, cursorName);
1:eac0369: 			}
1:eac0369: 		}
1:7fc54b9: 
1:eac0369: 		return ac.execute();
1:eac0369: 	}
1:7fc54b9: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the current ResultSet of this activation.
1:7fc54b9: 	 */
1:eac0369: 	public ResultSet getResultSet()
1:eac0369: 	{
1:eac0369: 		return ac.getResultSet();
1:eac0369: 	}
1:387d1fb: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#setCurrentRow
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setCurrentRow(ExecRow currentRow, int resultSetNumber) 
1:eac0369: 	{
1:eac0369: 		ac.setCurrentRow(currentRow, resultSetNumber);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:c533cd2: 	 * @see Activation#getCurrentRow
1:c533cd2: 	 *
1:c533cd2: 	 */
1:c533cd2: 	public Row getCurrentRow(int resultSetNumber)
1:c533cd2:     {
1:c533cd2:         return ac.getCurrentRow( resultSetNumber );
1:c533cd2:     }
1:c533cd2:     
1:c533cd2: 	/**
1:eac0369: 	 * @see Activation#clearCurrentRow
1:eac0369: 	 */
1:eac0369: 	public void clearCurrentRow(int resultSetNumber) 
1:eac0369: 	{
1:eac0369: 		ac.clearCurrentRow(resultSetNumber);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getPreparedStatement
1:eac0369: 	 */
1:eac0369: 	public ExecPreparedStatement getPreparedStatement()
1:eac0369: 	{
1:eac0369: 		return ps;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void checkStatementValidity() throws StandardException {
1:eac0369: 		ac.checkStatementValidity();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getResultDescription
1:eac0369: 	 */
1:eac0369: 	public ResultDescription getResultDescription()
1:eac0369: 	{
1:eac0369: 		return ac.getResultDescription();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getDataValueFactory
1:eac0369: 	 */
1:eac0369: 	public DataValueFactory getDataValueFactory()
1:eac0369: 	{
1:eac0369: 		return ac.getDataValueFactory();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getRowLocationTemplate
1:eac0369: 	 */
1:eac0369: 	public RowLocation getRowLocationTemplate(int itemNumber)
1:eac0369: 	{
1:eac0369: 		return ac.getRowLocationTemplate(itemNumber);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getHeapConglomerateController
1:eac0369: 	 */
1:eac0369: 	public ConglomerateController getHeapConglomerateController()
1:eac0369: 	{
1:eac0369: 		return ac.getHeapConglomerateController();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#setHeapConglomerateController
1:eac0369: 	 */
1:eac0369: 	public void setHeapConglomerateController(ConglomerateController updateHeapCC)
1:eac0369: 	{
1:eac0369: 		ac.setHeapConglomerateController(updateHeapCC);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#clearHeapConglomerateController
1:eac0369: 	 */
1:eac0369: 	public void clearHeapConglomerateController()
1:eac0369: 	{
1:eac0369: 		ac.clearHeapConglomerateController();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getIndexScanController
1:eac0369: 	 */
1:eac0369: 	public ScanController getIndexScanController()
1:eac0369: 	{
1:eac0369: 		return ac.getIndexScanController();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#setIndexScanController
1:eac0369: 	 */
1:eac0369: 	public void setIndexScanController(ScanController indexSC)
1:eac0369: 	{
1:eac0369: 		ac.setIndexScanController(indexSC);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getIndexConglomerateNumber
1:eac0369: 	 */
1:eac0369: 	public long getIndexConglomerateNumber()
1:eac0369: 	{
1:eac0369: 		return ac.getIndexConglomerateNumber();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#setIndexConglomerateNumber
1:eac0369: 	 */
1:eac0369: 	public void setIndexConglomerateNumber(long indexConglomerateNumber)
1:eac0369: 	{
1:eac0369: 		ac.setIndexConglomerateNumber(indexConglomerateNumber);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#clearIndexScanInfo
1:eac0369: 	 */
1:eac0369: 	public void clearIndexScanInfo()
1:eac0369: 	{
1:eac0369: 		ac.clearIndexScanInfo();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#close
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void close() throws StandardException
1:eac0369: 	{
1:7fc54b9: 		ac.close();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#isClosed
1:eac0369: 	 */
1:eac0369: 	public boolean isClosed()
1:eac0369: 	{
1:eac0369: 		return ac.isClosed();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set the activation for a single execution.
1:eac0369: 
1:eac0369: 		@see Activation#setSingleExecution
1:eac0369: 	*/
1:eac0369: 	public void setSingleExecution() {
1:eac0369: 		ac.setSingleExecution();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Is the activation set up for a single execution.
1:eac0369: 
1:eac0369: 		@see Activation#isSingleExecution
1:eac0369: 	*/
1:eac0369: 	public boolean isSingleExecution() {
1:eac0369: 		return ac.isSingleExecution();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the number of subqueries in the entire query.
1:eac0369: 		@return int	 The number of subqueries in the entire query.
1:eac0369: 	 */
1:eac0369: 	public int getNumSubqueries() {
1:eac0369: 		return ac.getNumSubqueries();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#setForCreateTable()
1:eac0369: 	 */
1:eac0369: 	public void setForCreateTable()
1:eac0369: 	{
1:eac0369: 		ac.setForCreateTable();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getForCreateTable()
1:eac0369: 	 */
1:eac0369: 	public boolean getForCreateTable()
1:eac0369: 	{
1:eac0369: 		return ac.getForCreateTable();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#setDDLTableDescriptor
1:eac0369: 	 */
1:eac0369: 	public void setDDLTableDescriptor(TableDescriptor td)
1:eac0369: 	{
1:eac0369: 		ac.setDDLTableDescriptor(td);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getDDLTableDescriptor
1:eac0369: 	 */
1:eac0369: 	public TableDescriptor getDDLTableDescriptor()
1:eac0369: 	{
1:eac0369: 		return ac.getDDLTableDescriptor();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#setMaxRows
1:eac0369: 	 */
1:47a8183: 	public void setMaxRows(long maxRows)
1:eac0369: 	{
1:eac0369: 		ac.setMaxRows(maxRows);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getMaxRows
1:eac0369: 	 */
1:47a8183: 	public long getMaxRows()
1:eac0369: 	{
1:eac0369: 		return ac.getMaxRows();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setTargetVTI(java.sql.ResultSet targetVTI)
1:eac0369: 	{
1:eac0369: 		ac.setTargetVTI(targetVTI);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public java.sql.ResultSet getTargetVTI()
1:eac0369: 	{
1:eac0369: 		return ac.getTargetVTI();
1:99d7d8b: 	}
1:99d7d8b: 
1:e3883f5: 	public SQLSessionContext getSQLSessionContextForChildren() {
1:e3883f5: 		return ac.getSQLSessionContextForChildren();
1:99d7d8b:     }
1:99d7d8b: 
1:e3883f5: 	public SQLSessionContext setupSQLSessionContextForChildren(boolean push) {
1:e3883f5: 		return ac.setupSQLSessionContextForChildren(push);
1:e3883f5:     }
1:e3883f5: 
1:e3883f5: 	public void setParentActivation(Activation a) {
1:e3883f5: 		ac.setParentActivation(a);
1:99d7d8b: 	}
1:99d7d8b: 
1:e3883f5: 	public Activation getParentActivation() {
1:e3883f5: 		return ac.getParentActivation();
1:99d7d8b: 	}
1:99d7d8b: 
1:99d7d8b: 
1:e4caed2: 	/* Dependable interface implementation */
1:eac0369: 
1:e4caed2: 	/**
1:e4caed2: 	 * @see Dependable#getDependableFinder
1:e4caed2: 	 */
1:e4caed2: 	public DependableFinder getDependableFinder()
1:e4caed2: 	{
1:e4caed2: 		// Vacuous implementation to make class concrete, only needed for
1:e4caed2: 		// BaseActivation
1:e4caed2: 		if (SanityManager.DEBUG) {
1:e4caed2: 			SanityManager.NOTREACHED();
1:e4caed2: 		}
1:e4caed2: 
1:e4caed2: 		return null;
1:e4caed2: 	}
1:e4caed2: 
1:e4caed2: 
1:e4caed2: 	/**
1:e4caed2: 	 * @see Dependable#getObjectName
1:e4caed2: 	 */
1:e4caed2: 	public String getObjectName()
1:e4caed2: 	{
1:e4caed2: 		// Vacuous implementation to make class concrete, only needed for
1:e4caed2: 		// BaseActivation
1:e4caed2: 		if (SanityManager.DEBUG) {
1:e4caed2: 			SanityManager.NOTREACHED();
1:e4caed2: 		}
1:e4caed2: 
1:e4caed2: 		return null;
1:e4caed2: 	}
1:e4caed2: 
1:e4caed2: 
1:e4caed2: 
1:e4caed2: 	/**
1:e4caed2: 	 * @see Dependable#getObjectID
1:e4caed2: 	 */
1:e4caed2: 	public UUID getObjectID()
1:e4caed2: 	{
1:e4caed2: 		// Vacuous implementation to make class concrete, only needed for
1:e4caed2: 		// BaseActivation
1:e4caed2: 		if (SanityManager.DEBUG) {
1:e4caed2: 			SanityManager.NOTREACHED();
1:e4caed2: 		}
1:e4caed2: 
1:e4caed2: 		return null;
1:e4caed2: 	}
1:e4caed2: 
1:e4caed2: 
1:e4caed2: 	/**
1:e4caed2: 	 * @see Dependable#getClassType
1:e4caed2: 	 */
1:e4caed2: 	public String getClassType()
1:e4caed2: 	{
1:e4caed2: 		// Vacuous implementation to make class concrete, only needed for
1:e4caed2: 		// BaseActivation
1:e4caed2: 		if (SanityManager.DEBUG) {
1:e4caed2: 			SanityManager.NOTREACHED();
1:e4caed2: 		}
1:e4caed2: 
1:e4caed2: 		return null;
1:e4caed2: 	}
1:e4caed2: 
1:e4caed2: 
1:e4caed2: 	/**
1:e4caed2: 	 * @see Dependable#isPersistent
1:e4caed2: 	 */
1:e4caed2: 	public boolean isPersistent()
1:e4caed2: 	{
1:e4caed2: 		// Vacuous implementation to make class concrete, only needed for
1:e4caed2: 		// BaseActivation
1:e4caed2: 		if (SanityManager.DEBUG) {
1:e4caed2: 			SanityManager.NOTREACHED();
1:e4caed2: 		}
1:e4caed2: 
1:e4caed2: 		return false;
1:e4caed2: 	}
1:e4caed2: 
1:e4caed2: 
1:e4caed2: 	/* Dependent interface implementation */
1:e4caed2: 
1:e4caed2: 	/**
1:88d10d4: 	 * @see org.apache.derby.iapi.sql.depend.Dependent#isValid
1:e4caed2: 	 */
1:e4caed2: 	public boolean isValid() {
1:e4caed2: 		// Vacuous implementation to make class concrete, only needed for
1:e4caed2: 		// BaseActivation
1:e4caed2: 		if (SanityManager.DEBUG) {
1:e4caed2: 			SanityManager.NOTREACHED();
1:e4caed2: 		}
1:e4caed2: 
1:e4caed2: 		return false;
1:e4caed2: 	}
1:e4caed2: 
1:e4caed2: 	/**
1:88d10d4: 	 * @see org.apache.derby.iapi.sql.depend.Dependent#makeInvalid
1:e4caed2: 	 */
1:e4caed2: 	public void makeInvalid(int action,
1:e4caed2: 							LanguageConnectionContext lcc)
1:e4caed2: 			throws StandardException {
1:e4caed2: 		// Vacuous implementation to make class concrete, only needed for
1:e4caed2: 		// BaseActivation
1:e4caed2: 		if (SanityManager.DEBUG) {
1:e4caed2: 			SanityManager.NOTREACHED();
1:e4caed2: 		}
1:e4caed2: 	}
1:e4caed2: 
1:e4caed2: 	/**
1:88d10d4: 	 * @see org.apache.derby.iapi.sql.depend.Dependent#prepareToInvalidate
1:e4caed2: 	 */
1:e4caed2: 	public void prepareToInvalidate(Provider p, int action,
1:e4caed2: 							 LanguageConnectionContext lcc)
1:e4caed2: 			throws StandardException {
1:e4caed2: 		// Vacuous implementation to make class concrete, only needed for
1:e4caed2: 		// BaseActivation
1:e4caed2: 		if (SanityManager.DEBUG) {
1:e4caed2: 			SanityManager.NOTREACHED();
1:e4caed2: 		}
1:e4caed2: 	}
1:e4caed2: 
1:e4caed2: 
1:e4caed2: 	/* Class implementation */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark the activation as unused.  
1:eac0369: 	 */
1:eac0369: 	public void markUnused()
1:eac0369: 	{
1:eac0369: 		ac.markUnused();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is the activation in use?
1:eac0369: 	 *
1:eac0369: 	 * @return true/false
1:eac0369: 	 */
1:eac0369: 	public boolean isInUse()
1:eac0369: 	{
1:eac0369: 		return ac.isInUse();
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	  @see org.apache.derby.iapi.sql.Activation#addWarning
1:eac0369: 	  */
1:eac0369: 	public void addWarning(SQLWarning w)
1:eac0369: 	{
1:eac0369: 		ac.addWarning(w);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see org.apache.derby.iapi.sql.Activation#getWarnings
1:eac0369: 	  */
1:eac0369: 	public SQLWarning getWarnings()
1:eac0369: 	{
1:eac0369: 		return ac.getWarnings();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see org.apache.derby.iapi.sql.Activation#clearWarnings
1:eac0369: 	  */
1:eac0369: 	public void clearWarnings()
1:eac0369: 	{
1:eac0369: 		ac.clearWarnings();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see Activation#informOfRowCount
1:eac0369: 		@exception StandardException	Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void informOfRowCount(NoPutResultSet resultSet, long rowCount)
1:92268ac: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		ac.informOfRowCount(resultSet, rowCount);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#isCursorActivation
1:eac0369: 	 */
1:eac0369: 	public boolean isCursorActivation()
1:eac0369: 	{
1:eac0369: 		return ac.isCursorActivation();
1:eac0369: 	}
1:eac0369: 
1:508a010:     public  ConstantAction    pushConstantAction( ConstantAction newConstantAction )
1:508a010:     {
1:508a010:         return ac.pushConstantAction( newConstantAction );
1:508a010:     }
1:508a010: 
1:508a010:     public  ConstantAction    popConstantAction()
1:508a010:     {
1:508a010:         return ac.popConstantAction();
1:508a010:     }
1:508a010: 
1:eac0369: 	public ConstantAction getConstantAction() {
1:eac0369: 		return ac.getConstantAction();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setParentResultSet(TemporaryRowHolder rs, String resultSetId)
1:eac0369: 	{
1:eac0369: 		ac.setParentResultSet(rs, resultSetId);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:801cf0d:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:801cf0d:     public Vector<TemporaryRowHolder> getParentResultSet(String resultSetId)
1:eac0369: 	{
1:eac0369: 		return ac.getParentResultSet(resultSetId);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void clearParentResultSets()
1:eac0369: 	{
1:eac0369: 		ac.clearParentResultSets();
1:eac0369: 	}
1:eac0369: 
1:801cf0d:     public Enumeration<String> getParentResultSetKeys()
1:eac0369: 	{
1:706f2eb: 		return ac.getParentResultSetKeys();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setForUpdateIndexScan(CursorResultSet forUpdateResultSet)
1:eac0369: 	{
1:eac0369: 		ac.setForUpdateIndexScan(forUpdateResultSet);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public CursorResultSet getForUpdateIndexScan()
1:eac0369: 	{
1:eac0369: 		return ac.getForUpdateIndexScan();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public java.sql.ResultSet[][] getDynamicResults() {
1:eac0369: 		return ac.getDynamicResults();
1:eac0369: 	}
1:eac0369: 	public int getMaxDynamicResults() {
1:eac0369: 		return ac.getMaxDynamicResults();
1:eac0369: 	}
1:a180287: 
1:a180287: 	public NumberDataValue getCurrentValueAndAdvance
1:a180287:         ( String sequenceUUIDstring, int typeFormatID )
1:a180287:         throws StandardException
1:a180287:     {
1:a180287:         return ac.getCurrentValueAndAdvance( sequenceUUIDstring, typeFormatID );
1:a180287:     }
1:a180287: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a180287
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.NumberDataValue;
/////////////////////////////////////////////////////////////////////////
1: 
1: 	public NumberDataValue getCurrentValueAndAdvance
1:         ( String sequenceUUIDstring, int typeFormatID )
1:         throws StandardException
1:     {
1:         return ac.getCurrentValueAndAdvance( sequenceUUIDstring, typeFormatID );
1:     }
1: 
commit:508a010
/////////////////////////////////////////////////////////////////////////
1:     public  ConstantAction    pushConstantAction( ConstantAction newConstantAction )
1:     {
1:         return ac.pushConstantAction( newConstantAction );
1:     }
1: 
1:     public  ConstantAction    popConstantAction()
1:     {
1:         return ac.popConstantAction();
1:     }
1: 
commit:706f2eb
/////////////////////////////////////////////////////////////////////////
1:                 {
1:                 }
/////////////////////////////////////////////////////////////////////////
0: 	public Enumeration getParentResultSetKeys()
1: 		return ac.getParentResultSetKeys();
commit:47a8183
/////////////////////////////////////////////////////////////////////////
1: 	public void setMaxRows(long maxRows)
/////////////////////////////////////////////////////////////////////////
1: 	public long getMaxRows()
commit:9495437
/////////////////////////////////////////////////////////////////////////
commit:92268ac
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
commit:c533cd2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.Row;
/////////////////////////////////////////////////////////////////////////
1: 	 * @see Activation#getCurrentRow
1: 	 *
1: 	 */
1: 	public Row getCurrentRow(int resultSetNumber)
1:     {
1:         return ac.getCurrentRow( resultSetNumber );
1:     }
1:     
1: 	/**
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLWarning;
1: import java.util.Enumeration;
1: import java.util.Vector;
1: import org.apache.derby.catalog.Dependable;
1: import org.apache.derby.catalog.DependableFinder;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.ParameterValueSet;
1: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Row;
1: import org.apache.derby.iapi.sql.depend.Provider;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataValueFactory;
1: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.impl.sql.execute.BaseActivation;
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:     public Vector<TemporaryRowHolder> getParentResultSet(String resultSetId)
/////////////////////////////////////////////////////////////////////////
1:     public Enumeration<String> getParentResultSetKeys()
commit:e3883f5
/////////////////////////////////////////////////////////////////////////
1: final public class GenericActivationHolder implements Activation
1: 	public BaseActivation			ac;
/////////////////////////////////////////////////////////////////////////
1: 	public SQLSessionContext getSQLSessionContextForChildren() {
1: 		return ac.getSQLSessionContextForChildren();
1: 	public SQLSessionContext setupSQLSessionContextForChildren(boolean push) {
1: 		return ac.setupSQLSessionContextForChildren(push);
1:     }
1: 
1: 	public void setParentActivation(Activation a) {
1: 		ac.setParentActivation(a);
1: 	public Activation getParentActivation() {
1: 		return ac.getParentActivation();
commit:88d10d4
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.sql.depend.Dependent#isValid
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.sql.depend.Dependent#makeInvalid
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.sql.depend.Dependent#prepareToInvalidate
commit:e4caed2
/////////////////////////////////////////////////////////////////////////
0: import	org.apache.derby.catalog.Dependable;
0: import	org.apache.derby.catalog.DependableFinder;
1: import org.apache.derby.catalog.UUID;
1: 
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.depend.Provider;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			/* Has the activation class changed or has the activation been
1: 			 * invalidated? */
0: 			if (gc != ps.getActivationClass() || !ac.isValid())
0: 				if (gc != ps.getActivationClass()) {
0: 					// ensure the statement is valid by rePreparing it.
0: 					// DERBY-3260: If someone else reprepares the statement at
0: 					// the same time as we do, there's a window between the
0: 					// calls to rePrepare() and getActivationClass() when the
0: 					// activation class can be set to null, leading to
0: 					// NullPointerException being thrown later. Therefore,
0: 					// synchronize on ps to close the window.
0: 					synchronized (ps) {
0: 						ps.rePrepare(getLanguageConnectionContext());
1: 						newGC = ps.getActivationClass();
1: 					}
1: 				} else {
1: 					// Reuse the generated class, we just want a new activation
1: 					// since the old is no longer valid.
1: 					newGC = gc;
1: 				}
1: 
1: 				** If we get here, it means the Activation has been invalidated
1: 				** or the PreparedStatement has been recompiled.  Get a new
1: 				** Activation and check whether the parameters are compatible.
1: 				** If so, transfer the parameters from the old Activation to
1: 				** the new one, and make that the current Activation.  If not,
1: 				** throw an exception.
/////////////////////////////////////////////////////////////////////////
1: 	/* Dependable interface implementation */
1: 	/**
1: 	 * @see Dependable#getDependableFinder
1: 	 */
1: 	public DependableFinder getDependableFinder()
1: 	{
1: 		// Vacuous implementation to make class concrete, only needed for
1: 		// BaseActivation
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.NOTREACHED();
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 
1: 	/**
1: 	 * @see Dependable#getObjectName
1: 	 */
1: 	public String getObjectName()
1: 	{
1: 		// Vacuous implementation to make class concrete, only needed for
1: 		// BaseActivation
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.NOTREACHED();
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 
1: 
1: 	/**
1: 	 * @see Dependable#getObjectID
1: 	 */
1: 	public UUID getObjectID()
1: 	{
1: 		// Vacuous implementation to make class concrete, only needed for
1: 		// BaseActivation
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.NOTREACHED();
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 
1: 	/**
1: 	 * @see Dependable#getClassType
1: 	 */
1: 	public String getClassType()
1: 	{
1: 		// Vacuous implementation to make class concrete, only needed for
1: 		// BaseActivation
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.NOTREACHED();
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 
1: 	/**
1: 	 * @see Dependable#isPersistent
1: 	 */
1: 	public boolean isPersistent()
1: 	{
1: 		// Vacuous implementation to make class concrete, only needed for
1: 		// BaseActivation
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.NOTREACHED();
1: 		}
1: 
1: 		return false;
1: 	}
1: 
1: 
1: 	/* Dependent interface implementation */
1: 
1: 	/**
0: 	 * @see Dependent#isValid
1: 	 */
1: 	public boolean isValid() {
1: 		// Vacuous implementation to make class concrete, only needed for
1: 		// BaseActivation
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.NOTREACHED();
1: 		}
1: 
1: 		return false;
1: 	}
1: 
1: 	/**
0: 	 * @see Dependent#makeInvalid
1: 	 */
1: 	public void makeInvalid(int action,
1: 							LanguageConnectionContext lcc)
1: 			throws StandardException {
1: 		// Vacuous implementation to make class concrete, only needed for
1: 		// BaseActivation
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.NOTREACHED();
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * @see Dependent#prepareToInvalidate
1: 	 */
1: 	public void prepareToInvalidate(Provider p, int action,
1: 							 LanguageConnectionContext lcc)
1: 			throws StandardException {
1: 		// Vacuous implementation to make class concrete, only needed for
1: 		// BaseActivation
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.NOTREACHED();
1: 		}
1: 	}
1: 
1: 
1: 	/* Class implementation */
commit:6950a39
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.SQLSessionContext;
/////////////////////////////////////////////////////////////////////////
0: 	public SQLSessionContext getNestedSQLSessionContext() {
0: 		return ac.getNestedSQLSessionContext();
commit:99d7d8b
/////////////////////////////////////////////////////////////////////////
0: 	public void setNestedCurrentRole(String role) {
0: 		ac.setNestedCurrentRole(role);
1:     }
1: 
0:     public String getNestedCurrentRole() {
0: 		return ac.getNestedCurrentRole();
1:     }
1: 
0: 	public void setCallActivation(Activation a) {
0: 		ac.setCallActivation(a);
1: 	}
1: 
0: 	public Activation getCallActivation() {
0: 		return ac.getCallActivation();
1: 	}
1: 
1: 
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:6555d3c
/////////////////////////////////////////////////////////////////////////
1:             final boolean needNewClass =
1:                     gc == null || gc != ps.getActivationClass();
1: 			if (needNewClass || !ac.isValid())
1: 				if (needNewClass) {
1:                     // The statement has been re-prepared since the last time
1:                     // we executed it. Get the new activation class.
0:                     newGC = ps.getActivationClass();
1:                     if (newGC == null) {
1:                         // There is no class associated with the statement.
1:                         // Tell the caller that the statement needs to be
1:                         // recompiled.
1:                         throw StandardException.newException(
1:                                 SQLState.LANG_STATEMENT_NEEDS_RECOMPILE);
1:                     }
commit:85132a2
/////////////////////////////////////////////////////////////////////////
0: 			/* Has the activation class changed or has the activation been
0: 			 * invalidated? */
0: 			if (gc != ps.getActivationClass() || !ac.isValid())
1: 
1:                 GeneratedClass newGC;
1: 
0: 				if (gc != ps.getActivationClass()) {
0: 					// ensure the statement is valid by rePreparing it.
0: 					// DERBY-3260: If someone else reprepares the statement at
0: 					// the same time as we do, there's a window between the
0: 					// calls to rePrepare() and getActivationClass() when the
0: 					// activation class can be set to null, leading to
0: 					// NullPointerException being thrown later. Therefore,
0: 					// synchronize on ps to close the window.
0: 					synchronized (ps) {
0: 						ps.rePrepare(getLanguageConnectionContext());
0: 						newGC = ps.getActivationClass();
1: 					}
0: 				} else {
0: 					// Reuse the generated class, we just want a new activation
0: 					// since the old is no longer valid.
0: 					newGC = gc;
1: 				}
1: 
1: 
1: 				/*
0: 				** If we get here, it means the Activation has been invalidated
0: 				** or the PreparedStatement has been recompiled.  Get a new
0: 				** Activation and check whether the parameters are compatible.
0: 				** If so, transfer the parameters from the old Activation to
0: 				** the new one, and make that the current Activation.  If not,
0: 				** throw an exception.
1: 				*/
1: 				BaseActivation		newAC = (BaseActivation) newGC.newInstance(lcc);
1: 
1: 				DataTypeDescriptor[]	newParamTypes = ps.getParameterTypes();
1: 
1: 				/*
1: 				** Link the new activation to the prepared statement.
1: 				*/
1: 				newAC.setupActivation(ps, ac.getScrollable());
1: 
1: 				newAC.setParameters(ac.getParameterValueSet(), paramTypes);
1: 
1: 
1: 				/*
1: 				** IMPORTANT
1: 				**
1: 				** Copy any essential state from the old activation
1: 				** to the new activation. This must match the state
1: 				** setup in EmbedStatement.
1: 				** singleExecution, cursorName, holdability, maxRows.
1: 				*/
1: 
1: 				if (ac.isSingleExecution())
1: 					newAC.setSingleExecution();
1: 
1: 				newAC.setCursorName(ac.getCursorName());
1: 
1: 				newAC.setResultSetHoldability(ac.getResultSetHoldability());
1: 				if (ac.getAutoGeneratedKeysResultsetMode()) //Need to do copy only if auto generated mode is on
1: 					newAC.setAutoGeneratedKeysResultsetInfo(ac.getAutoGeneratedKeysColumnIndexes(),
1: 					ac.getAutoGeneratedKeysColumnNames());
1: 				newAC.setMaxRows(ac.getMaxRows());
1: 
1: 				// break the link with the prepared statement
1: 				ac.setupActivation(null, false);
1: 				ac.close();
1: 
1: 				/* Remember the new class information */
1: 				ac = newAC;
1: 				gc = newGC;
1: 				paramTypes = newParamTypes;
commit:7fc54b9
/////////////////////////////////////////////////////////////////////////
1: 
0: 		/* Has the activation class changed or has the activation been
0: 		 * invalidated? */
0: 		if (gc != ps.getActivationClass() || !ac.isValid())
0: 	        GeneratedClass newGC;
0: 	        ExecPreparedStatement newPS;
0: 			if (gc != ps.getActivationClass()) {
0: 				// ensure the statement is valid by rePreparing it.
0: 				// DERBY-3260: If someone else reprepares the statement at
0: 				// the same time as we do, there's a window between the
0: 				// calls to rePrepare() and getActivationClass() when the
0: 				// activation class can be set to null, leading to
0: 				// NullPointerException being thrown later. Therefore,
0: 				// synchronize on ps to close the window.
0: 				synchronized (ps) {
0: 					newPS = (ExecPreparedStatement) ps.rePrepare(getLanguageConnectionContext());
0: 					newGC = newPS.getActivationClass();
0: 			else
1: 			{
0: 				newGC = gc;
0: 				newPS = ps;
1: 			}
1: 
1: 			/*
0: 			** If we get here, it means the Activation has been invalidated
0: 			** or the PreparedStatement has been recompiled.  Get a new
0: 			** Activation and check whether the parameters are compatible.
0: 			** If so, transfer the parameters from the old Activation to
0: 			** the new one, and make that the current Activation.  If not,
0: 			** throw an exception.
1: 			*/
0: 			BaseActivation newAC = (BaseActivation) newGC.newInstance(lcc);
1: 
0: 			DataTypeDescriptor[] newParamTypes = newPS.getParameterTypes();
1: 
1: 			/*
0: 			** Link the new activation to the prepared statement.
1: 			*/
0: 			newAC.setupActivation(newPS, ac.getScrollable());
1: 
0: 			newAC.setParameters(ac.getParameterValueSet(), paramTypes);
1: 
1: 			/*
0: 			** IMPORTANT
0: 			**
0: 			** Copy any essential state from the old activation
0: 			** to the new activation. This must match the state
0: 			** setup in EmbedStatement.
0: 			** singleExecution, cursorName, holdability, maxRows.
1: 			*/
1: 
0: 			if (ac.isSingleExecution())
0: 				newAC.setSingleExecution();
1: 
0: 			newAC.setCursorName(ac.getCursorName());
1: 
0: 			newAC.setResultSetHoldability(ac.getResultSetHoldability());
0: 			if (ac.getAutoGeneratedKeysResultsetMode()) //Need to do copy only if auto generated mode is on
0: 				newAC.setAutoGeneratedKeysResultsetInfo(ac.getAutoGeneratedKeysColumnIndexes(),
0: 						ac.getAutoGeneratedKeysColumnNames());
0: 			newAC.setMaxRows(ac.getMaxRows());
1: 
0: 			// break the link with the prepared statement
0: 			ac.setupActivation(null, false);
1: 			ac.close();
1: 
0: 			/* Remember the new class information */
0: 			ac = newAC;
0: 			gc = newGC;
0: 			ps = newPS;
0: 			paramTypes = newParamTypes;
commit:387d1fb
/////////////////////////////////////////////////////////////////////////
0:                 GeneratedClass newGC;
1: 
0:                 // DERBY-3260: If someone else reprepares the statement at the
0:                 // same time as we do, there's a window between the calls to
0:                 // rePrepare() and getActivationClass() when the activation
0:                 // class can be set to null, leading to NullPointerException
0:                 // being thrown later. Therefore, synchronize on ps to close
0:                 // the window.
0:                 synchronized (ps) {
0:                     ps.rePrepare(getLanguageConnectionContext());
0:                     newGC = ps.getActivationClass();
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
commit:fbf1381
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:67c1c96
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.GenericActivationHolder
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
0: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql;
1: 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.types.DataValueFactory;
1: 
1: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: 
0: import org.apache.derby.impl.sql.execute.BaseActivation;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
1: 
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: import org.apache.derby.iapi.services.context.Context;
1: 
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.ScanController;
1: 
0: import org.apache.derby.iapi.types.RowLocation;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import java.sql.SQLWarning;
0: import java.util.Enumeration;
0: import java.util.Vector;
0: import java.util.Hashtable;
1: 
1: /**
1:  * This class holds an Activation, and passes through most of the calls
1:  * to the activation.  The purpose of this class is to allow a PreparedStatement
1:  * to be recompiled without the caller having to detect this and get a new
1:  * activation.
1:  *
1:  * In addition to the Activation, this class holds a reference to the
1:  * PreparedStatement that created it, along with a reference to the
1:  * GeneratedClass that was associated with the PreparedStatement at the time
1:  * this holder was created.  These references are used to validate the
1:  * Activation, to ensure that an activation is used only with the
1:  * PreparedStatement that created it, and to detect when recompilation has
1:  * happened.
1:  *
1:  * We detect recompilation by checking whether the GeneratedClass has changed.
1:  * If it has, we try to let the caller continue to use this ActivationHolder.
1:  * We create a new instance of the new GeneratedClass (that is, we create a
1:  * new Activation), and we compare the number and type of parameters.  If these
1:  * are compatible, we copy the parameters from the old to the new Activation.
1:  * If they are not compatible, we throw an exception telling the user that
1:  * the Activation is out of date, and they need to get a new one.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: final class GenericActivationHolder implements Activation
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	BaseActivation			ac;
1: 	ExecPreparedStatement	ps;
1: 	GeneratedClass			gc;
1: 	DataTypeDescriptor[]	paramTypes;
1: 	private final LanguageConnectionContext lcc;
1: 
1: 	/**
1: 	 * Constructor for an ActivationHolder
1: 	 *
1: 	 * @param gc	The GeneratedClass of the Activation
1: 	 * @param ps	The PreparedStatement this ActivationHolder is associated
1: 	 *				with
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	GenericActivationHolder(LanguageConnectionContext lcc, GeneratedClass gc, ExecPreparedStatement ps, boolean scrollable)
1: 			throws StandardException
1: 	{
1: 		this.lcc = lcc;
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(gc != null, "generated class is null , ps is a " + ps.getClass());
1: 		}
1: 
1: 		this.gc = gc;
1: 		this.ps = ps;
1: 
1: 		ac = (BaseActivation) gc.newInstance(lcc);
1: 		ac.setupActivation(ps, scrollable);
1: 		paramTypes = ps.getParameterTypes();
1: 	}
1: 
1: 	/* Activation interface */
1: 
1: 	/**
1: 	 * @see Activation#reset
1: 	 *
1: 	 * @exception StandardException thrown on failure
1: 	 */
1: 	public void	reset() throws StandardException
1: 	{
1: 		ac.reset();
1: 	}
1: 
1: 	/**
1: 	 * Temporary tables can be declared with ON COMMIT DELETE ROWS. But if the table has a held curosr open at
1: 	 * commit time, data should not be deleted from the table. This method, (gets called at commit time) checks if this
1: 	 * activation held cursor and if so, does that cursor reference the passed temp table name.
1: 	 *
1: 	 * @return	true if this activation has held cursor and if it references the passed temp table name
1: 	 */
1: 	public boolean checkIfThisActivationHasHoldCursor(String tableName)
1: 	{
1: 		return ac.checkIfThisActivationHasHoldCursor(tableName);
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#setCursorName
1: 	 *
1: 	 */
1: 	public void	setCursorName(String cursorName)
1: 	{
1: 		ac.setCursorName(cursorName);
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getCursorName
1: 	 */
1: 	public String	getCursorName()
1: 	{
1: 		return ac.getCursorName();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#setResultSetHoldability
1: 	 *
1: 	 */
1: 	public void	setResultSetHoldability(boolean resultSetHoldability)
1: 	{
1: 		ac.setResultSetHoldability(resultSetHoldability);
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getResultSetHoldability
1: 	 */
1: 	public boolean	getResultSetHoldability()
1: 	{
1: 		return ac.getResultSetHoldability();
1: 	}
1: 
1: 	/** @see Activation#setAutoGeneratedKeysResultsetInfo */
1: 	public void setAutoGeneratedKeysResultsetInfo(int[] columnIndexes, String[] columnNames)
1: 	{
1: 		ac.setAutoGeneratedKeysResultsetInfo(columnIndexes, columnNames);
1: 	}
1: 
1: 	/** @see Activation#getAutoGeneratedKeysResultsetMode */
1: 	public boolean getAutoGeneratedKeysResultsetMode()
1: 	{
1: 		return ac.getAutoGeneratedKeysResultsetMode();
1: 	}
1: 
1: 	/** @see Activation#getAutoGeneratedKeysColumnIndexes */
1: 	public int[] getAutoGeneratedKeysColumnIndexes()
1: 	{
1: 		return ac.getAutoGeneratedKeysColumnIndexes();
1: 	}
1: 
1: 	/** @see Activation#getAutoGeneratedKeysColumnNames */
1: 	public String[] getAutoGeneratedKeysColumnNames()
1: 	{
1: 		return ac.getAutoGeneratedKeysColumnNames();
1: 	}
1: 
1: 	/** @see org.apache.derby.iapi.sql.Activation#getLanguageConnectionContext */
1: 	public	LanguageConnectionContext	getLanguageConnectionContext()
1: 	{
1: 		return	lcc;
1: 	}
1: 
1: 	public TransactionController getTransactionController()
1: 	{
1: 		return ac.getTransactionController();
1: 	}
1: 
1: 	/** @see Activation#getExecutionFactory */
1: 	public	ExecutionFactory	getExecutionFactory()
1: 	{
1: 		return	ac.getExecutionFactory();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getParameterValueSet
1: 	 */
1: 	public ParameterValueSet	getParameterValueSet()
1: 	{
1: 		return ac.getParameterValueSet();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#setParameters
1: 	 */
1: 	public void	setParameters(ParameterValueSet parameterValues, DataTypeDescriptor[] parameterTypes) throws StandardException
1: 	{
1: 		ac.setParameters(parameterValues, parameterTypes);
1: 	}
1: 
1: 	/** 
1: 	 * @see Activation#execute
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
1: 	public ResultSet execute() throws StandardException
1: 	{
0: 		/*
1: 		** Synchronize to avoid problems if another thread is preparing
1: 		** the statement at the same time we're trying to execute it.
1: 		*/
1: 		// synchronized (ps)
1: 		{
0: 			/* Has the activation class changed? */
0: 			if (gc != ps.getActivationClass())
1: 			{
1: 
0: 				// ensure the statement is valid by rePreparing it.
0: 				ps.rePrepare(getLanguageConnectionContext());
1: 				
0: 				/*
0: 				** If we get here, it means the PreparedStatement has been
0: 				** recompiled.  Get a new Activation and check whether the
0: 				** parameters are compatible.  If so, transfer the parameters
0: 				** from the old Activation to the new one, and make that the
0: 				** current Activation.  If not, throw an exception.
1: 				*/
0: 				GeneratedClass		newGC = ps.getActivationClass();
1: 
0: 				BaseActivation		newAC = (BaseActivation) newGC.newInstance(lcc);
1: 
0: 				DataTypeDescriptor[]	newParamTypes = ps.getParameterTypes();
1: 
0: 				/*
0: 				** Link the new activation to the prepared statement.
1: 				*/
0: 				newAC.setupActivation(ps, ac.getScrollable());
1: 
0: 				newAC.setParameters(ac.getParameterValueSet(), paramTypes);
1: 
1: 
0: 				/*
0: 				** IMPORTANT
0: 				**
0: 				** Copy any essential state from the old activation
0: 				** to the new activation. This must match the state
0: 				** setup in EmbedStatement.
0: 				** singleExecution, cursorName, holdability, maxRows.
1: 				*/
1: 
0: 				if (ac.isSingleExecution())
0: 					newAC.setSingleExecution();
1: 
0: 				newAC.setCursorName(ac.getCursorName());
1: 
0: 				newAC.setResultSetHoldability(ac.getResultSetHoldability());
0: 				if (ac.getAutoGeneratedKeysResultsetMode()) //Need to do copy only if auto generated mode is on
0: 					newAC.setAutoGeneratedKeysResultsetInfo(ac.getAutoGeneratedKeysColumnIndexes(),
0: 					ac.getAutoGeneratedKeysColumnNames());
0: 				newAC.setMaxRows(ac.getMaxRows());
1: 
0: 				// break the link with the prepared statement
0: 				ac.setupActivation(null, false);
0: 				ac.close();
1: 
0: 				/* Remember the new class information */
0: 				ac = newAC;
0: 				gc = newGC;
0: 				paramTypes = newParamTypes;
1: 			}
1: 		}
1: 
1: 		String cursorName = ac.getCursorName();
1: 		if (cursorName != null)
1: 		{
1: 			// have to see if another activation is open
1: 			// with the same cursor name. If so we can't use this name
1: 
1: 			Activation activeCursor = lcc.lookupCursorActivation(cursorName);
1: 
1: 			if ((activeCursor != null) && (activeCursor != ac)) {
1: 				throw StandardException.newException(SQLState.LANG_CURSOR_ALREADY_EXISTS, cursorName);
1: 			}
1: 		}
1: 
1: 		return ac.execute();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getResultSet
1: 	 *
1: 	 * @return the current ResultSet of this activation.
1: 	 */
1: 	public ResultSet getResultSet()
1: 	{
1: 		return ac.getResultSet();
1: 	}
1: 
1: 	/**
0: 	 * @see Activation#clearResultSet
1: 	 */
0: 	public void clearResultSet()
1: 	{
0: 		ac.clearResultSet();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#setCurrentRow
1: 	 *
1: 	 */
1: 	public void setCurrentRow(ExecRow currentRow, int resultSetNumber) 
1: 	{
1: 		ac.setCurrentRow(currentRow, resultSetNumber);
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#clearCurrentRow
1: 	 */
1: 	public void clearCurrentRow(int resultSetNumber) 
1: 	{
1: 		ac.clearCurrentRow(resultSetNumber);
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getPreparedStatement
1: 	 */
1: 	public ExecPreparedStatement getPreparedStatement()
1: 	{
1: 		return ps;
1: 	}
1: 
1: 	public void checkStatementValidity() throws StandardException {
1: 		ac.checkStatementValidity();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getResultDescription
1: 	 */
1: 	public ResultDescription getResultDescription()
1: 	{
1: 		return ac.getResultDescription();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getDataValueFactory
1: 	 */
1: 	public DataValueFactory getDataValueFactory()
1: 	{
1: 		return ac.getDataValueFactory();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getRowLocationTemplate
1: 	 */
1: 	public RowLocation getRowLocationTemplate(int itemNumber)
1: 	{
1: 		return ac.getRowLocationTemplate(itemNumber);
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getHeapConglomerateController
1: 	 */
1: 	public ConglomerateController getHeapConglomerateController()
1: 	{
1: 		return ac.getHeapConglomerateController();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#setHeapConglomerateController
1: 	 */
1: 	public void setHeapConglomerateController(ConglomerateController updateHeapCC)
1: 	{
1: 		ac.setHeapConglomerateController(updateHeapCC);
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#clearHeapConglomerateController
1: 	 */
1: 	public void clearHeapConglomerateController()
1: 	{
1: 		ac.clearHeapConglomerateController();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getIndexScanController
1: 	 */
1: 	public ScanController getIndexScanController()
1: 	{
1: 		return ac.getIndexScanController();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#setIndexScanController
1: 	 */
1: 	public void setIndexScanController(ScanController indexSC)
1: 	{
1: 		ac.setIndexScanController(indexSC);
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getIndexConglomerateNumber
1: 	 */
1: 	public long getIndexConglomerateNumber()
1: 	{
1: 		return ac.getIndexConglomerateNumber();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#setIndexConglomerateNumber
1: 	 */
1: 	public void setIndexConglomerateNumber(long indexConglomerateNumber)
1: 	{
1: 		ac.setIndexConglomerateNumber(indexConglomerateNumber);
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#clearIndexScanInfo
1: 	 */
1: 	public void clearIndexScanInfo()
1: 	{
1: 		ac.clearIndexScanInfo();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#close
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void close() throws StandardException
1: 	{
0: 		ac.close();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#isClosed
1: 	 */
1: 	public boolean isClosed()
1: 	{
1: 		return ac.isClosed();
1: 	}
1: 
1: 	/**
1: 		Set the activation for a single execution.
1: 
1: 		@see Activation#setSingleExecution
1: 	*/
1: 	public void setSingleExecution() {
1: 		ac.setSingleExecution();
1: 	}
1: 
1: 	/**
1: 		Is the activation set up for a single execution.
1: 
1: 		@see Activation#isSingleExecution
1: 	*/
1: 	public boolean isSingleExecution() {
1: 		return ac.isSingleExecution();
1: 	}
1: 
1: 	/**
1: 		Get the number of subqueries in the entire query.
1: 		@return int	 The number of subqueries in the entire query.
1: 	 */
1: 	public int getNumSubqueries() {
1: 		return ac.getNumSubqueries();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#setForCreateTable()
1: 	 */
1: 	public void setForCreateTable()
1: 	{
1: 		ac.setForCreateTable();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getForCreateTable()
1: 	 */
1: 	public boolean getForCreateTable()
1: 	{
1: 		return ac.getForCreateTable();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#setDDLTableDescriptor
1: 	 */
1: 	public void setDDLTableDescriptor(TableDescriptor td)
1: 	{
1: 		ac.setDDLTableDescriptor(td);
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getDDLTableDescriptor
1: 	 */
1: 	public TableDescriptor getDDLTableDescriptor()
1: 	{
1: 		return ac.getDDLTableDescriptor();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#setMaxRows
1: 	 */
0: 	public void setMaxRows(int maxRows)
1: 	{
1: 		ac.setMaxRows(maxRows);
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getMaxRows
1: 	 */
0: 	public int getMaxRows()
1: 	{
1: 		return ac.getMaxRows();
1: 	}
1: 
1: 	public void setTargetVTI(java.sql.ResultSet targetVTI)
1: 	{
1: 		ac.setTargetVTI(targetVTI);
1: 	}
1: 
1: 	public java.sql.ResultSet getTargetVTI()
1: 	{
1: 		return ac.getTargetVTI();
1: 	}
1: 
0: 	/* Class implementation */
1: 
1: 
1: 	/**
1: 	 * Mark the activation as unused.  
1: 	 */
1: 	public void markUnused()
1: 	{
1: 		ac.markUnused();
1: 	}
1: 
1: 	/**
1: 	 * Is the activation in use?
1: 	 *
1: 	 * @return true/false
1: 	 */
1: 	public boolean isInUse()
1: 	{
1: 		return ac.isInUse();
1: 	}
1: 	/**
1: 	  @see org.apache.derby.iapi.sql.Activation#addWarning
1: 	  */
1: 	public void addWarning(SQLWarning w)
1: 	{
1: 		ac.addWarning(w);
1: 	}
1: 
1: 	/**
1: 	  @see org.apache.derby.iapi.sql.Activation#getWarnings
1: 	  */
1: 	public SQLWarning getWarnings()
1: 	{
1: 		return ac.getWarnings();
1: 	}
1: 
1: 	/**
1: 	  @see org.apache.derby.iapi.sql.Activation#clearWarnings
1: 	  */
1: 	public void clearWarnings()
1: 	{
1: 		ac.clearWarnings();
1: 	}
1: 
1: 	/**
1: 		@see Activation#informOfRowCount
1: 		@exception StandardException	Thrown on error
1: 	 */
1: 	public void informOfRowCount(NoPutResultSet resultSet, long rowCount)
1: 					throws StandardException
1: 	{
1: 		ac.informOfRowCount(resultSet, rowCount);
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#isCursorActivation
1: 	 */
1: 	public boolean isCursorActivation()
1: 	{
1: 		return ac.isCursorActivation();
1: 	}
1: 
1: 	public ConstantAction getConstantAction() {
1: 		return ac.getConstantAction();
1: 	}
1: 
1: 	public void setParentResultSet(TemporaryRowHolder rs, String resultSetId)
1: 	{
1: 		ac.setParentResultSet(rs, resultSetId);
1: 	}
1: 
1: 
0: 	public Vector getParentResultSet(String resultSetId)
1: 	{
1: 		return ac.getParentResultSet(resultSetId);
1: 	}
1: 
1: 	public void clearParentResultSets()
1: 	{
1: 		ac.clearParentResultSets();
1: 	}
1: 
0: 	public Hashtable getParentResultSets()
1: 	{
0: 		return ac.getParentResultSets();
1: 	}
1: 
1: 	public void setForUpdateIndexScan(CursorResultSet forUpdateResultSet)
1: 	{
1: 		ac.setForUpdateIndexScan(forUpdateResultSet);
1: 	}
1: 
1: 	public CursorResultSet getForUpdateIndexScan()
1: 	{
1: 		return ac.getForUpdateIndexScan();
1: 	}
1: 
1: 	public java.sql.ResultSet[][] getDynamicResults() {
1: 		return ac.getDynamicResults();
1: 	}
1: 	public int getMaxDynamicResults() {
1: 		return ac.getMaxDynamicResults();
1: 	}
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: 
0: import org.apache.derby.impl.sql.execute.BaseActivation;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
0: 
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: import org.apache.derby.iapi.services.context.Context;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import java.sql.SQLWarning;
0: import java.util.Enumeration;
0: import java.util.Vector;
0: import java.util.Hashtable;
0: 
0: /**
0:  * This class holds an Activation, and passes through most of the calls
0:  * to the activation.  The purpose of this class is to allow a PreparedStatement
0:  * to be recompiled without the caller having to detect this and get a new
0:  * activation.
0:  *
0:  * In addition to the Activation, this class holds a reference to the
0:  * PreparedStatement that created it, along with a reference to the
0:  * GeneratedClass that was associated with the PreparedStatement at the time
0:  * this holder was created.  These references are used to validate the
0:  * Activation, to ensure that an activation is used only with the
0:  * PreparedStatement that created it, and to detect when recompilation has
0:  * happened.
0:  *
0:  * We detect recompilation by checking whether the GeneratedClass has changed.
0:  * If it has, we try to let the caller continue to use this ActivationHolder.
0:  * We create a new instance of the new GeneratedClass (that is, we create a
0:  * new Activation), and we compare the number and type of parameters.  If these
0:  * are compatible, we copy the parameters from the old to the new Activation.
0:  * If they are not compatible, we throw an exception telling the user that
0:  * the Activation is out of date, and they need to get a new one.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: final class GenericActivationHolder implements Activation
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	BaseActivation			ac;
0: 	ExecPreparedStatement	ps;
0: 	GeneratedClass			gc;
0: 	DataTypeDescriptor[]	paramTypes;
0: 	private final LanguageConnectionContext lcc;
0: 
0: 	/**
0: 	 * Constructor for an ActivationHolder
0: 	 *
0: 	 * @param gc	The GeneratedClass of the Activation
0: 	 * @param ps	The PreparedStatement this ActivationHolder is associated
0: 	 *				with
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	GenericActivationHolder(LanguageConnectionContext lcc, GeneratedClass gc, ExecPreparedStatement ps, boolean scrollable)
0: 			throws StandardException
0: 	{
0: 		this.lcc = lcc;
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(gc != null, "generated class is null , ps is a " + ps.getClass());
0: 		}
0: 
0: 		this.gc = gc;
0: 		this.ps = ps;
0: 
0: 		ac = (BaseActivation) gc.newInstance(lcc);
0: 		ac.setupActivation(ps, scrollable);
0: 		paramTypes = ps.getParameterTypes();
0: 	}
0: 
0: 	/* Activation interface */
0: 
0: 	/**
0: 	 * @see Activation#reset
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	public void	reset() throws StandardException
0: 	{
0: 		ac.reset();
0: 	}
0: 
0: 	/**
0: 	 * Temporary tables can be declared with ON COMMIT DELETE ROWS. But if the table has a held curosr open at
0: 	 * commit time, data should not be deleted from the table. This method, (gets called at commit time) checks if this
0: 	 * activation held cursor and if so, does that cursor reference the passed temp table name.
0: 	 *
0: 	 * @return	true if this activation has held cursor and if it references the passed temp table name
0: 	 */
0: 	public boolean checkIfThisActivationHasHoldCursor(String tableName)
0: 	{
0: 		return ac.checkIfThisActivationHasHoldCursor(tableName);
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#setCursorName
0: 	 *
0: 	 */
0: 	public void	setCursorName(String cursorName)
0: 	{
0: 		ac.setCursorName(cursorName);
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getCursorName
0: 	 */
0: 	public String	getCursorName()
0: 	{
0: 		return ac.getCursorName();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#setResultSetHoldability
0: 	 *
0: 	 */
0: 	public void	setResultSetHoldability(boolean resultSetHoldability)
0: 	{
0: 		ac.setResultSetHoldability(resultSetHoldability);
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getResultSetHoldability
0: 	 */
0: 	public boolean	getResultSetHoldability()
0: 	{
0: 		return ac.getResultSetHoldability();
0: 	}
0: 
0: 	/** @see Activation#setAutoGeneratedKeysResultsetInfo */
0: 	public void setAutoGeneratedKeysResultsetInfo(int[] columnIndexes, String[] columnNames)
0: 	{
0: 		ac.setAutoGeneratedKeysResultsetInfo(columnIndexes, columnNames);
0: 	}
0: 
0: 	/** @see Activation#getAutoGeneratedKeysResultsetMode */
0: 	public boolean getAutoGeneratedKeysResultsetMode()
0: 	{
0: 		return ac.getAutoGeneratedKeysResultsetMode();
0: 	}
0: 
0: 	/** @see Activation#getAutoGeneratedKeysColumnIndexes */
0: 	public int[] getAutoGeneratedKeysColumnIndexes()
0: 	{
0: 		return ac.getAutoGeneratedKeysColumnIndexes();
0: 	}
0: 
0: 	/** @see Activation#getAutoGeneratedKeysColumnNames */
0: 	public String[] getAutoGeneratedKeysColumnNames()
0: 	{
0: 		return ac.getAutoGeneratedKeysColumnNames();
0: 	}
0: 
0: 	/** @see org.apache.derby.iapi.sql.Activation#getLanguageConnectionContext */
0: 	public	LanguageConnectionContext	getLanguageConnectionContext()
0: 	{
0: 		return	lcc;
0: 	}
0: 
0: 	public TransactionController getTransactionController()
0: 	{
0: 		return ac.getTransactionController();
0: 	}
0: 
0: 	/** @see Activation#getExecutionFactory */
0: 	public	ExecutionFactory	getExecutionFactory()
0: 	{
0: 		return	ac.getExecutionFactory();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getParameterValueSet
0: 	 */
0: 	public ParameterValueSet	getParameterValueSet()
0: 	{
0: 		return ac.getParameterValueSet();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#setParameters
0: 	 */
0: 	public void	setParameters(ParameterValueSet parameterValues, DataTypeDescriptor[] parameterTypes) throws StandardException
0: 	{
0: 		ac.setParameters(parameterValues, parameterTypes);
0: 	}
0: 
0: 	/** 
0: 	 * @see Activation#execute
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public ResultSet execute() throws StandardException
0: 	{
0: 		/*
0: 		** Synchronize to avoid problems if another thread is preparing
0: 		** the statement at the same time we're trying to execute it.
0: 		*/
0: 		// synchronized (ps)
0: 		{
0: 			/* Has the activation class changed? */
0: 			if (gc != ps.getActivationClass())
0: 			{
0: 
0: 				// ensure the statement is valid by rePreparing it.
0: 				ps.rePrepare(getLanguageConnectionContext());
0: 				
0: 				/*
0: 				** If we get here, it means the PreparedStatement has been
0: 				** recompiled.  Get a new Activation and check whether the
0: 				** parameters are compatible.  If so, transfer the parameters
0: 				** from the old Activation to the new one, and make that the
0: 				** current Activation.  If not, throw an exception.
0: 				*/
0: 				GeneratedClass		newGC = ps.getActivationClass();
0: 
0: 				BaseActivation		newAC = (BaseActivation) newGC.newInstance(lcc);
0: 
0: 				DataTypeDescriptor[]	newParamTypes = ps.getParameterTypes();
0: 
0: 				/*
0: 				** Link the new activation to the prepared statement.
0: 				*/
0: 				newAC.setupActivation(ps, ac.getScrollable());
0: 
0: 				newAC.setParameters(ac.getParameterValueSet(), paramTypes);
0: 
0: 
0: 				/*
0: 				** IMPORTANT
0: 				**
0: 				** Copy any essential state from the old activation
0: 				** to the new activation. This must match the state
0: 				** setup in EmbedStatement.
0: 				** singleExecution, cursorName, holdability, maxRows.
0: 				*/
0: 
0: 				if (ac.isSingleExecution())
0: 					newAC.setSingleExecution();
0: 
0: 				newAC.setCursorName(ac.getCursorName());
0: 
0: 				newAC.setResultSetHoldability(ac.getResultSetHoldability());
0: 				if (ac.getAutoGeneratedKeysResultsetMode()) //Need to do copy only if auto generated mode is on
0: 					newAC.setAutoGeneratedKeysResultsetInfo(ac.getAutoGeneratedKeysColumnIndexes(),
0: 					ac.getAutoGeneratedKeysColumnNames());
0: 				newAC.setMaxRows(ac.getMaxRows());
0: 
0: 				// break the link with the prepared statement
0: 				ac.setupActivation(null, false);
0: 				ac.close();
0: 
0: 				/* Remember the new class information */
0: 				ac = newAC;
0: 				gc = newGC;
0: 				paramTypes = newParamTypes;
0: 			}
0: 		}
0: 
0: 		String cursorName = ac.getCursorName();
0: 		if (cursorName != null)
0: 		{
0: 			// have to see if another activation is open
0: 			// with the same cursor name. If so we can't use this name
0: 
0: 			Activation activeCursor = lcc.lookupCursorActivation(cursorName);
0: 
0: 			if ((activeCursor != null) && (activeCursor != ac)) {
0: 				throw StandardException.newException(SQLState.LANG_CURSOR_ALREADY_EXISTS, cursorName);
0: 			}
0: 		}
0: 
0: 		return ac.execute();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getResultSet
0: 	 *
0: 	 * @return the current ResultSet of this activation.
0: 	 */
0: 	public ResultSet getResultSet()
0: 	{
0: 		return ac.getResultSet();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#clearResultSet
0: 	 */
0: 	public void clearResultSet()
0: 	{
0: 		ac.clearResultSet();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#setCurrentRow
0: 	 *
0: 	 */
0: 	public void setCurrentRow(ExecRow currentRow, int resultSetNumber) 
0: 	{
0: 		ac.setCurrentRow(currentRow, resultSetNumber);
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#clearCurrentRow
0: 	 */
0: 	public void clearCurrentRow(int resultSetNumber) 
0: 	{
0: 		ac.clearCurrentRow(resultSetNumber);
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getPreparedStatement
0: 	 */
0: 	public ExecPreparedStatement getPreparedStatement()
0: 	{
0: 		return ps;
0: 	}
0: 
0: 	public void checkStatementValidity() throws StandardException {
0: 		ac.checkStatementValidity();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getResultDescription
0: 	 */
0: 	public ResultDescription getResultDescription()
0: 	{
0: 		return ac.getResultDescription();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getDataValueFactory
0: 	 */
0: 	public DataValueFactory getDataValueFactory()
0: 	{
0: 		return ac.getDataValueFactory();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getRowLocationTemplate
0: 	 */
0: 	public RowLocation getRowLocationTemplate(int itemNumber)
0: 	{
0: 		return ac.getRowLocationTemplate(itemNumber);
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getHeapConglomerateController
0: 	 */
0: 	public ConglomerateController getHeapConglomerateController()
0: 	{
0: 		return ac.getHeapConglomerateController();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#setHeapConglomerateController
0: 	 */
0: 	public void setHeapConglomerateController(ConglomerateController updateHeapCC)
0: 	{
0: 		ac.setHeapConglomerateController(updateHeapCC);
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#clearHeapConglomerateController
0: 	 */
0: 	public void clearHeapConglomerateController()
0: 	{
0: 		ac.clearHeapConglomerateController();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getIndexScanController
0: 	 */
0: 	public ScanController getIndexScanController()
0: 	{
0: 		return ac.getIndexScanController();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#setIndexScanController
0: 	 */
0: 	public void setIndexScanController(ScanController indexSC)
0: 	{
0: 		ac.setIndexScanController(indexSC);
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getIndexConglomerateNumber
0: 	 */
0: 	public long getIndexConglomerateNumber()
0: 	{
0: 		return ac.getIndexConglomerateNumber();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#setIndexConglomerateNumber
0: 	 */
0: 	public void setIndexConglomerateNumber(long indexConglomerateNumber)
0: 	{
0: 		ac.setIndexConglomerateNumber(indexConglomerateNumber);
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#clearIndexScanInfo
0: 	 */
0: 	public void clearIndexScanInfo()
0: 	{
0: 		ac.clearIndexScanInfo();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#close
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void close() throws StandardException
0: 	{
0: 		ac.close();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#isClosed
0: 	 */
0: 	public boolean isClosed()
0: 	{
0: 		return ac.isClosed();
0: 	}
0: 
0: 	/**
0: 		Set the activation for a single execution.
0: 
0: 		@see Activation#setSingleExecution
0: 	*/
0: 	public void setSingleExecution() {
0: 		ac.setSingleExecution();
0: 	}
0: 
0: 	/**
0: 		Is the activation set up for a single execution.
0: 
0: 		@see Activation#isSingleExecution
0: 	*/
0: 	public boolean isSingleExecution() {
0: 		return ac.isSingleExecution();
0: 	}
0: 
0: 	/**
0: 		Get the number of subqueries in the entire query.
0: 		@return int	 The number of subqueries in the entire query.
0: 	 */
0: 	public int getNumSubqueries() {
0: 		return ac.getNumSubqueries();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#setForCreateTable()
0: 	 */
0: 	public void setForCreateTable()
0: 	{
0: 		ac.setForCreateTable();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getForCreateTable()
0: 	 */
0: 	public boolean getForCreateTable()
0: 	{
0: 		return ac.getForCreateTable();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#setDDLTableDescriptor
0: 	 */
0: 	public void setDDLTableDescriptor(TableDescriptor td)
0: 	{
0: 		ac.setDDLTableDescriptor(td);
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getDDLTableDescriptor
0: 	 */
0: 	public TableDescriptor getDDLTableDescriptor()
0: 	{
0: 		return ac.getDDLTableDescriptor();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#setMaxRows
0: 	 */
0: 	public void setMaxRows(int maxRows)
0: 	{
0: 		ac.setMaxRows(maxRows);
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getMaxRows
0: 	 */
0: 	public int getMaxRows()
0: 	{
0: 		return ac.getMaxRows();
0: 	}
0: 
0: 	public void setTargetVTI(java.sql.ResultSet targetVTI)
0: 	{
0: 		ac.setTargetVTI(targetVTI);
0: 	}
0: 
0: 	public java.sql.ResultSet getTargetVTI()
0: 	{
0: 		return ac.getTargetVTI();
0: 	}
0: 
0: 	/* Class implementation */
0: 
0: 
0: 	/**
0: 	 * Mark the activation as unused.  
0: 	 */
0: 	public void markUnused()
0: 	{
0: 		ac.markUnused();
0: 	}
0: 
0: 	/**
0: 	 * Is the activation in use?
0: 	 *
0: 	 * @return true/false
0: 	 */
0: 	public boolean isInUse()
0: 	{
0: 		return ac.isInUse();
0: 	}
0: 	/**
0: 	  @see org.apache.derby.iapi.sql.Activation#addWarning
0: 	  */
0: 	public void addWarning(SQLWarning w)
0: 	{
0: 		ac.addWarning(w);
0: 	}
0: 
0: 	/**
0: 	  @see org.apache.derby.iapi.sql.Activation#getWarnings
0: 	  */
0: 	public SQLWarning getWarnings()
0: 	{
0: 		return ac.getWarnings();
0: 	}
0: 
0: 	/**
0: 	  @see org.apache.derby.iapi.sql.Activation#clearWarnings
0: 	  */
0: 	public void clearWarnings()
0: 	{
0: 		ac.clearWarnings();
0: 	}
0: 
0: 	/**
0: 		@see Activation#informOfRowCount
0: 		@exception StandardException	Thrown on error
0: 	 */
0: 	public void informOfRowCount(NoPutResultSet resultSet, long rowCount)
0: 					throws StandardException
0: 	{
0: 		ac.informOfRowCount(resultSet, rowCount);
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#isCursorActivation
0: 	 */
0: 	public boolean isCursorActivation()
0: 	{
0: 		return ac.isCursorActivation();
0: 	}
0: 
0: 	public ConstantAction getConstantAction() {
0: 		return ac.getConstantAction();
0: 	}
0: 
0: 	public void setParentResultSet(TemporaryRowHolder rs, String resultSetId)
0: 	{
0: 		ac.setParentResultSet(rs, resultSetId);
0: 	}
0: 
0: 
0: 	public Vector getParentResultSet(String resultSetId)
0: 	{
0: 		return ac.getParentResultSet(resultSetId);
0: 	}
0: 
0: 	public void clearParentResultSets()
0: 	{
0: 		ac.clearParentResultSets();
0: 	}
0: 
0: 	public Hashtable getParentResultSets()
0: 	{
0: 		return ac.getParentResultSets();
0: 	}
0: 
0: 	public void setForUpdateIndexScan(CursorResultSet forUpdateResultSet)
0: 	{
0: 		ac.setForUpdateIndexScan(forUpdateResultSet);
0: 	}
0: 
0: 	public CursorResultSet getForUpdateIndexScan()
0: 	{
0: 		return ac.getForUpdateIndexScan();
0: 	}
0: 
0: 	public java.sql.ResultSet[][] getDynamicResults() {
0: 		return ac.getDynamicResults();
0: 	}
0: 	public int getMaxDynamicResults() {
0: 		return ac.getMaxDynamicResults();
0: 	}
0: 
0: }
============================================================================