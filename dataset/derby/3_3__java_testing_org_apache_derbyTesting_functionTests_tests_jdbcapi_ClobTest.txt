1:cb2e1a4: /*
1:cb2e1a4: 
1:cb2e1a4:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.ClobTest
1:cb2e1a4: 
1:cb2e1a4:    Licensed to the Apache Software Foundation (ASF) under one
1:cb2e1a4:    or more contributor license agreements.  See the NOTICE file
1:cb2e1a4:    distributed with this work for additional information
1:cb2e1a4:    regarding copyright ownership.  The ASF licenses this file
1:cb2e1a4:    to you under the Apache License, Version 2.0 (the
1:cb2e1a4:    "License"); you may not use this file except in compliance
1:cb2e1a4:    with the License.  You may obtain a copy of the License at
1:cb2e1a4: 
1:cb2e1a4:      http://www.apache.org/licenses/LICENSE-2.0
1:cb2e1a4: 
1:cb2e1a4:    Unless required by applicable law or agreed to in writing,
1:cb2e1a4:    software distributed under the License is distributed on an
1:cb2e1a4:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:cb2e1a4:    KIND, either express or implied.  See the License for the
1:cb2e1a4:    specific language governing permissions and limitations
1:cb2e1a4:    under the License.
1:cb2e1a4: 
1:cb2e1a4:  */
1:cb2e1a4: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:cb2e1a4: 
1:cb2e1a4: import java.io.BufferedInputStream;
1:cb2e1a4: import java.io.BufferedOutputStream;
1:cb2e1a4: import java.io.BufferedReader;
1:cb2e1a4: import java.io.BufferedWriter;
1:cb2e1a4: import java.io.CharArrayWriter;
1:cb2e1a4: import java.io.IOException;
1:cb2e1a4: import java.io.InputStream;
1:cb2e1a4: import java.io.OutputStream;
1:cb2e1a4: import java.io.Reader;
1:9b9c25a: import java.io.StringReader;
1:cb2e1a4: import java.io.Writer;
1:cb2e1a4: 
1:cb2e1a4: import java.sql.Connection;
1:cb2e1a4: import java.sql.Clob;
1:e8fd686: import java.sql.PreparedStatement;
1:cb2e1a4: import java.sql.ResultSet;
1:cb2e1a4: import java.sql.SQLException;
1:cb2e1a4: import java.sql.Statement;
1:cb2e1a4: 
1:8f75194: import java.util.Arrays;
1:8f75194: 
1:cb2e1a4: import junit.framework.Test;
1:cb2e1a4: 
1:961ecca: import org.apache.derby.iapi.types.HarmonySerialClob;
1:961ecca: 
1:cb2e1a4: import org.apache.derbyTesting.functionTests.util.streams.CharAlphabet;
1:cb2e1a4: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:cb2e1a4: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1:cb2e1a4: 
1:cb2e1a4: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:cb2e1a4: import org.apache.derbyTesting.junit.BaseJDBCTestSetup;
1:cb2e1a4: import org.apache.derbyTesting.junit.TestConfiguration;
1:cb2e1a4: 
1:cb2e1a4: 
1:cb2e1a4: 
1:a63282c: /**
1:cb2e1a4:  * Test the methods defined by the {@link java.sql.Clob} interface.
1:cb2e1a4:  * <p>
1:cb2e1a4:  * Only methods defined by JDBC 3 or earlier are tested here, and the focus of
1:cb2e1a4:  * the test is the interface methods. Less attention is given to inserting
1:cb2e1a4:  * Clobs and fetching Clobs from the database.
1:cb2e1a4:  */
1:cb2e1a4: public class ClobTest
1:cb2e1a4:     extends BaseJDBCTestCase {
1:cb2e1a4: 
1:cb2e1a4:     /** Buffer size to use when transferring data between streams. */
1:cb2e1a4:     private static final int TRANSFER_BUFFER_SIZE = 4*1024; // 4 KB
1:cb2e1a4: 
1:cb2e1a4:     /** Constant for Clob.setString method. */
1:cb2e1a4:     private static final int SET_STRING = 1;
1:cb2e1a4:     /** Constant for Clob.setAsciiStream method. */
1:cb2e1a4:     private static final int SET_ASCII_STREAM = 2;
1:cb2e1a4:     /** Constant for Clob.setCharacterStream method. */
1:cb2e1a4:     private static final int SET_CHARACTER_STREAM = 4;
1:8f75194:     /**
1:8f75194:      * Next unique id for a Clob. Note that this isn't accessed in a thread-
1:8f75194:      * safe way.
1:8f75194:      */
1:8f75194:     private static int nextUniqueId = 150000;
1:cb2e1a4: 
1:cb2e1a4:     /** Test data, 18 characters long, containing only Norwegian letters. */
1:cb2e1a4:     private static final String NORWEGIAN_LETTERS =
1:cb2e1a4:             "\u00e6\u00f8\u00e5\u00e6\u00f8\u00e5\u00e6\u00f8\u00e5" +
1:cb2e1a4:             "\u00e6\u00f8\u00e5\u00e6\u00f8\u00e5\u00e6\u00f8\u00e5";
1:cb2e1a4: 
1:cb2e1a4:     /**
1:cb2e1a4:      * The Clob used for testing.
1:cb2e1a4:      * It is reinitialized to a Clob containing the empty string for each test.
1:cb2e1a4:      */
1:cb2e1a4:     private Clob clob = null;
1:cb2e1a4: 
1:cb2e1a4:     public ClobTest(String testName) {
1:cb2e1a4:         super(testName);
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testGetSubString_PosOneTooBig()
1:cb2e1a4:             throws SQLException {
1:cb2e1a4:         long length = this.clob.length();
1:cb2e1a4:         assertEquals("", this.clob.getSubString(length +1, 10));
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testGetSubString_PosTooBig() {
1:cb2e1a4:         try {
1:cb2e1a4:             this.clob.getSubString(999, 10);
1:cb2e1a4:             fail("getSubString with pos larger than clob length must fail");
1:cb2e1a4:         } catch (SQLException sqle) {
1:a63282c:             assertSQLState("XJ076", sqle);
1:cb2e1a4:         }
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testGetSubString_PosNegative()
1:cb2e1a4:             throws SQLException {
1:cb2e1a4:         try {
1:cb2e1a4:             this.clob.getSubString(-123, 10);
1:cb2e1a4:             fail("getSubString with negative position should fail");
1:cb2e1a4:         } catch (SQLException sqle) {
1:cb2e1a4:             assertSQLState("XJ070", sqle);
1:cb2e1a4:         }
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testGetSubString_RequestZeroLength_PosValid()
1:cb2e1a4:             throws SQLException {
1:cb2e1a4:         // Tests if an exception is thrown or not.
1:cb2e1a4:         // According to the JDBC spec, 0 is a valid length.
1:cb2e1a4:         assertEquals("", this.clob.getSubString(1L, 0));
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testGetSubString_RequestZeroLength_PosTooBig()
1:cb2e1a4:             throws SQLException {
1:cb2e1a4:         try {
1:cb2e1a4:             this.clob.getSubString(999L, 0);
1:cb2e1a4:         } catch (SQLException sqle) {
1:a63282c:             assertSQLState("XJ076", sqle);
1:cb2e1a4:         }
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     /**
1:cb2e1a4:      * Tests if big strings can be handled.
1:cb2e1a4:      * <p>
1:cb2e1a4:      * The motivation for the test is to make sure big buffers are filled with
1:cb2e1a4:      * the call to read inside a loop. Big in this sense means bigger than some
1:cb2e1a4:      * internal buffer. This is typically around 8 KB or so, but we try
1:cb2e1a4:      * something considerably bigger. If a char/byte array is attempted filled
1:cb2e1a4:      * with a single call to read, the resulting string wil typically contain
1:cb2e1a4:      * \u0000 at positions after the size of the internal buffer.
1:cb2e1a4:      */
1:cb2e1a4:     public void testGetSubString_BiggerThanInternalBuffer()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         int stringLength = 1*1024*1024; // 1 M characters
1:cb2e1a4:         transferData(new LoopingAlphabetReader(stringLength),
1:cb2e1a4:                      this.clob.setCharacterStream(1L),
1:cb2e1a4:                      TRANSFER_BUFFER_SIZE);
1:cb2e1a4:         String obtained = this.clob.getSubString(1, stringLength);
1:cb2e1a4:         assertEquals("Incorrect string length",
1:cb2e1a4:             stringLength, obtained.length());
1:cb2e1a4:         // Obtain the string we inserted for comparison.
1:cb2e1a4:         CharArrayWriter charWriter = new CharArrayWriter();
1:cb2e1a4:         transferData(new LoopingAlphabetReader(stringLength), charWriter,
1:cb2e1a4:                                                TRANSFER_BUFFER_SIZE);
1:cb2e1a4:         assertEquals("String do not match",
1:cb2e1a4:             charWriter.toString(), obtained);
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testLengthOnEmptyClob()
1:cb2e1a4:             throws SQLException {
1:cb2e1a4:         assertEquals(0, this.clob.length());
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testInsertStringOnEmptyClob_Singlebyte()
1:cb2e1a4:             throws SQLException {
1:cb2e1a4:         String content = "This is the new Clob content.";
1:cb2e1a4:         this.clob.setString(1, content);
1:cb2e1a4:         assertEquals("Incorrect length reported",
1:cb2e1a4:             content.length(), this.clob.length());
3:cb2e1a4:         assertEquals("Clob content is incorrect",
1:cb2e1a4:             content, this.clob.getSubString(1, content.length()));
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testInsertStringOnEmptyClob_Multibyte()
1:cb2e1a4:             throws SQLException {
1:cb2e1a4:         String content = "A few Norwegian letters: \u00e6, \u00e5, \u00f8.";
1:cb2e1a4:         this.clob.setString(1, content);
1:cb2e1a4:         assertEquals("Incorrect length reported",
1:cb2e1a4:             content.length(), this.clob.length());
1:cb2e1a4:         assertEquals("Clob content is incorrect",
1:cb2e1a4:             content, this.clob.getSubString(1, content.length()));
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testInsertStringInMiddle_Multibyte()
1:cb2e1a4:             throws SQLException {
1:cb2e1a4:         // Add some content to work on first.
1:cb2e1a4:         this.clob.setString(1, NORWEGIAN_LETTERS);
1:cb2e1a4:         assertEquals(NORWEGIAN_LETTERS,
1:cb2e1a4:             this.clob.getSubString(1, NORWEGIAN_LETTERS.length()));
1:cb2e1a4: 
1:cb2e1a4:         // Replace a portion with single byte characters.
1:cb2e1a4:         char[] modifiedContent = NORWEGIAN_LETTERS.toCharArray();
1:cb2e1a4:         // Replace chars at 0-based indexes 4,5 and 8
1:cb2e1a4:         modifiedContent[4] = 'a';
1:cb2e1a4:         modifiedContent[5] = 'b';
1:cb2e1a4:         modifiedContent[8] = 'c';
1:cb2e1a4:         String newContent = String.copyValueOf(modifiedContent);
1:cb2e1a4:         // Do this in a "funny" order, or else it currently fails when running
1:cb2e1a4:         // with the client driver.
1:cb2e1a4:         assertEquals(1, this.clob.setString(9, "c"));
1:cb2e1a4:         assertEquals(1, this.clob.setString(5, "a"));
1:cb2e1a4:         assertEquals(1, this.clob.setString(6, "b"));
1:a78e683: 	    assertEquals("Clob content is incorrect",
1:a78e683:             newContent, this.clob.getSubString(1, newContent.length()));
1:cb2e1a4:     }
1:cb2e1a4: 
1:71dca8c:     /**
1:71dca8c:      * Tests that the length is updated correctly when inserting data.
1:71dca8c:      */
1:71dca8c:     public void testLengthAfterInsertOnEmpty()
1:71dca8c:             throws IOException, SQLException {
1:71dca8c:         insertDataWithToken("", 0, 0, SET_STRING);
1:71dca8c:         assertEquals(0L, clob.length());
1:71dca8c:         clob.setString(1, "TEST");
1:71dca8c:         assertEquals(4L, clob.length());
1:71dca8c:         clob.setString(1, "TEST");
1:71dca8c:         assertEquals(4L, clob.length());
1:71dca8c:         clob.setString(5, "TEST");
1:71dca8c:         assertEquals(8L, clob.length());
1:71dca8c:         clob.setString(7, "TEST");
1:71dca8c:         assertEquals(10L, clob.length());
1:71dca8c:         clob.truncate(4L);
1:71dca8c:         assertEquals(4L, clob.length());
1:71dca8c:         clob.setString(4, "TEST");
1:71dca8c:         assertEquals(7L, clob.length());
1:71dca8c:     }
1:71dca8c: 
1:71dca8c:     /**
1:71dca8c:      * Tests that the length is updated correctly when inserting data.
1:71dca8c:      */
1:71dca8c:     public void testLengthAfterInsertOnLarge()
1:71dca8c:             throws IOException, SQLException {
1:71dca8c:         final String token = "SWEETSPOT";
1:71dca8c:         long curLength = (32+9) * 1024 + token.length();
1:71dca8c:         insertDataWithToken(token, 32*1024, 9*1024, SET_CHARACTER_STREAM);
1:71dca8c:         assertEquals(curLength, clob.length());
1:71dca8c:         clob.setString(1, "TEST");
1:71dca8c:         assertEquals(curLength, clob.length());
1:71dca8c:         clob.setString(curLength, "X");
1:71dca8c:         assertEquals(curLength, clob.length());
1:71dca8c:         assertEquals(32*1024+1, clob.position(token, 17*1024));
1:71dca8c:         clob.setString(32*1024+1, "FUNNYSPOT");
1:71dca8c:         assertEquals(curLength, clob.length());
1:71dca8c:         assertEquals(-1, clob.position(token, 17*1024));
1:71dca8c:         clob.setString(curLength +1, "TEST");
1:71dca8c:         curLength += 4;
1:71dca8c:         assertEquals(curLength, clob.length());
1:71dca8c:     }
1:71dca8c: 
1:9b9c25a:     public void testReplaceMultibyteWithSingleByteForwards()
1:9b9c25a:             throws IOException, SQLException {
1:9b9c25a:         // Add some content to work on first.
1:9b9c25a:         this.clob.setString(1, NORWEGIAN_LETTERS);
1:9b9c25a:         assertEquals(NORWEGIAN_LETTERS,
1:9b9c25a:             this.clob.getSubString(1, NORWEGIAN_LETTERS.length()));
1:9b9c25a: 
1:9b9c25a:         // Replace chars one by one from the start.
1:9b9c25a:         char[] modifiedContent = NORWEGIAN_LETTERS.toCharArray();
1:9b9c25a:         String toInsert = "abcdefghijklmnopqr";
1:9b9c25a:         for (int iz=0; iz < toInsert.length(); iz++) {
1:9b9c25a:             modifiedContent[iz] = toInsert.charAt(iz);
1:9b9c25a:             assertEquals(1, this.clob.setString(iz +1,
1:9b9c25a:                     toInsert.substring(iz, iz +1)));
1:9b9c25a:             assertEquals(String.copyValueOf(modifiedContent),
1:9b9c25a:                     this.clob.getSubString(1, 100));
1:9b9c25a:             assertEquals(new StringReader(String.copyValueOf(modifiedContent)),
1:9b9c25a:                     this.clob.getCharacterStream());
1:9b9c25a:         }
1:9b9c25a:     }
1:9b9c25a: 
1:9b9c25a:     public void testReplaceMultibyteWithSingleByteBackwards()
1:9b9c25a:             throws IOException, SQLException {
1:9b9c25a:         // Add some content to work on first.
1:9b9c25a:         this.clob.setString(1, NORWEGIAN_LETTERS);
1:9b9c25a:         assertEquals(NORWEGIAN_LETTERS,
1:9b9c25a:             this.clob.getSubString(1, NORWEGIAN_LETTERS.length()));
1:9b9c25a: 
1:9b9c25a:         // Replace chars one by one from the end.
1:9b9c25a:         char[] modifiedContent = NORWEGIAN_LETTERS.toCharArray();
1:9b9c25a:         String toInsert = "abcdefghijklmnopqr";
1:9b9c25a:         for (int iz=toInsert.length() -1; iz >= 0; iz--) {
1:9b9c25a:             modifiedContent[iz] = toInsert.charAt(iz);
1:9b9c25a:             assertEquals(1, this.clob.setString(iz +1,
1:9b9c25a:                     toInsert.substring(iz, iz +1)));
1:9b9c25a:             assertEquals(String.copyValueOf(modifiedContent),
1:9b9c25a:                     this.clob.getSubString(1, 100));
1:9b9c25a:             assertEquals(new StringReader(String.copyValueOf(modifiedContent)),
1:9b9c25a:                     this.clob.getCharacterStream());
1:9b9c25a:         }
1:9b9c25a:     }
1:9b9c25a: 
1:e8fd686:     /**
1:e8fd686:      * Tests that Derby specific end-of-stream markers aren't passed over to
1:e8fd686:      * the temporary Clob, which doesn't use such markers.
1:e8fd686:      * <p>
1:e8fd686:      * Passing the marker over will normally result in a UTF encoding exception.
1:e8fd686:      * <p>
1:e8fd686:      * ID USAGE: reads id 2, writes id 10002
1:e8fd686:      */
1:e8fd686:     public void testInsertCharacter_ReadOnlyToTemporary()
1:e8fd686:             throws IOException, SQLException {
1:e8fd686:         setAutoCommit(false);
1:e8fd686:         // Insert data, a medium sized Clob to store it as a stream.
1:e8fd686:         PreparedStatement ps = prepareStatement(
1:e8fd686:                 "insert into ClobTestData values (?,?)");
1:e8fd686:         int initalSize = 128*1024;
1:e8fd686:         ps.setInt(1, 2);
1:e8fd686:         ps.setCharacterStream(
1:e8fd686:                 2, new LoopingAlphabetReader(initalSize), initalSize);
1:e8fd686:         ps.executeUpdate();
1:e8fd686: 
1:e8fd686:         // Select the Clob, and change one character.
1:e8fd686:         PreparedStatement psSelect = prepareStatement(
1:e8fd686:                 "select dClob from ClobTestData where id = ?");
1:e8fd686:         psSelect.setInt(1, 2);
1:e8fd686:         ResultSet lRs = psSelect.executeQuery();
1:e8fd686:         lRs.next();
1:e8fd686:         Clob lClob = lRs.getClob(1);
1:e8fd686:         lClob.setString(1, "K");
1:e8fd686:         Reader r = lClob.getCharacterStream();
1:e8fd686:         assertEquals('K', r.read());
1:e8fd686:         long length = 1;
1:e8fd686:         while (true) {
1:e8fd686:             // Since we're skipping characters, the bytes have to be decoded
1:e8fd686:             // and we will detect any encoding errors.
1:e8fd686:             long skipped = r.skip(4096);
1:e8fd686:             if (skipped > 0) {
1:e8fd686:                 length += skipped;
2:a63282c:             } else {
1:e8fd686:                 break;
1:e8fd686:             }
1:e8fd686:         }
1:e8fd686:         lRs.close();
1:e8fd686:         assertEquals("Wrong length!", initalSize, length);
1:e8fd686:         // Reports the correct length, now try to insert it.
1:e8fd686:         ps.setInt(1, 10003);
1:e8fd686:         ps.setClob(2, lClob);
1:e8fd686:         ps.executeUpdate();
1:e8fd686:         // Fetch it back.
1:e8fd686:         psSelect.setInt(1, 10003);
1:e8fd686:         lRs = psSelect.executeQuery();
1:e8fd686:         lRs.next();
1:e8fd686:         Clob lClob2 = lRs.getClob(1);
1:e8fd686:         assertEquals(lClob.getCharacterStream(), lClob2.getCharacterStream());
1:e8fd686:         assertEquals(initalSize, lClob2.length());
1:e8fd686:     }
1:e8fd686: 
1:cb2e1a4:     public void testPositionWithString_ASCII_SimplePartialRecurringPattern()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         String token = "xxSPOTxx";
1:cb2e1a4:         String inserted ="abcdexxSPxabcdexabxxSPxxxSPOTxabcxxSPOTxxabc";
1:cb2e1a4:         this.clob.setString(1L, inserted);
1:cb2e1a4:         assertEquals("Invalid match position",
1:cb2e1a4:             inserted.indexOf(token, 0) +1, this.clob.position(token, 1L));
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testPositionWithString_USASCII()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         String token = "xxSPOTxx";
1:cb2e1a4:         final long prefix = 91*1024 +7;
1:cb2e1a4:         final long postfix = 12*1024;
1:cb2e1a4:         insertDataWithToken(token, prefix, postfix, SET_ASCII_STREAM);
1:cb2e1a4:         executeTestPositionWithStringToken(token, prefix);
1:a63282c:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testPositionWithString_IOS88591()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         String token = "xx\u00c6\u00c6\u00c6xx";
1:cb2e1a4:         final long prefix = 67*1024;
1:cb2e1a4:         final long postfix = 1*1024-2;
1:cb2e1a4:         insertDataWithToken(token, prefix, postfix, SET_ASCII_STREAM);
1:cb2e1a4:         executeTestPositionWithStringToken(token, prefix);
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testPositionWithString_CJK()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         final long prefix = 11L;
1:cb2e1a4:         final long postfix = 90L;
1:cb2e1a4:         char[] tmpChar = new char[1];
1:a78e683:         LoopingAlphabetReader tokenSrc =
1:cb2e1a4:             new LoopingAlphabetReader(1L, CharAlphabet.cjkSubset());
1:cb2e1a4:         tokenSrc.read(tmpChar);
1:cb2e1a4:         String token = String.copyValueOf(tmpChar);
1:cb2e1a4:         insertDataWithToken(token, prefix, postfix, SET_CHARACTER_STREAM);
1:cb2e1a4:         //insertDataWithToken(token, prefix, 2*1024-7, SET_CHARACTER_STREAM);
1:cb2e1a4:         executeTestPositionWithStringToken(token, prefix);
1:cb2e1a4:     }
1:cb2e1a4:     
1:cb2e1a4:     /**
1:1e5b2aa:      * Test setString() refuses wrong offset. 
1:1e5b2aa:      */
1:1e5b2aa:     public void testSetStringOnWrongOffset() throws SQLException {
1:1e5b2aa:         clob.setString(1, "TEST");
1:1e5b2aa:         long upperLimit = clob.length() + 1;
1:1e5b2aa:         String str = "AGAIN";
1:1e5b2aa:         
1:1e5b2aa:         try {
1:1e5b2aa:             clob.setString(upperLimit, str, -1, 2);
1:1e5b2aa:             fail("setString() refuses negative offset!");
1:1e5b2aa:         } catch (SQLException e) {
1:1e5b2aa:             assertSQLState("XJ078", e);
1:cb2e1a4:         }
1:1e5b2aa:         
1:1e5b2aa:         try {
1:1e5b2aa:             clob.setString(upperLimit, str, str.length() + 1, 1);
1:1e5b2aa:             fail("setString() refuses offset greater than str.length()!");
1:1e5b2aa:         } catch (SQLException e) {
1:1e5b2aa:             assertSQLState("XJ078", e);
1:cb2e1a4:         }
1:1e5b2aa:         
1:1e5b2aa:         //if (offset + len) == str.length(), it's accepted.
1:1e5b2aa:         clob.setString(upperLimit, str, str.length() - 1, 1);
1:1e5b2aa:         
1:1e5b2aa:         try {
1:1e5b2aa:             clob.setString(upperLimit, str, str.length(), 0);
1:1e5b2aa:             fail("offset should be smaller than the length of str");
1:1e5b2aa:         } catch (SQLException e) {
1:1e5b2aa:             assertSQLState("XJ078", e);
1:cb2e1a4:         }
1:1e5b2aa:         
1:1e5b2aa:         try {
1:1e5b2aa:             clob.setString(upperLimit, str, str.length() - 1, 2);
1:1e5b2aa:             fail("setString() refuses offset + len > str.length()!");
1:1e5b2aa:         } catch (SQLException e) {
1:1e5b2aa:             assertSQLState("22011", e);
4:1e5b2aa:         }
1:1e5b2aa:     }
1:1e5b2aa:     
1:cb2e1a4:     /**
1:1e5b2aa:      * Test setString() refuses wrong len. 
1:1e5b2aa:      */
1:1e5b2aa:     public void testSetStringWithWrongLen() throws SQLException {
1:1e5b2aa:         clob.setString(1, "TEST");
1:1e5b2aa:         long upperLimit = clob.length() + 1;
1:1e5b2aa:         String str = "AGAIN";
1:1e5b2aa:         
1:1e5b2aa:         try {
1:1e5b2aa:             clob.setString(upperLimit, str, 0, -1);
1:1e5b2aa:             fail("setString() refuses negative len!");
1:1e5b2aa:         } catch (SQLException e) {
1:1e5b2aa:             assertSQLState("XJ071", e);
1:1e5b2aa:         }
1:1e5b2aa:         
1:1e5b2aa:         try {
1:1e5b2aa:             clob.setString(upperLimit, str, 0, str.length() + 1);
1:1e5b2aa:             fail("setString() refuses wrong len out of range!");
1:1e5b2aa:         } catch (SQLException e) {
1:1e5b2aa:             assertSQLState("22011", e);
1:1e5b2aa:         }
1:1e5b2aa:     }
1:1e5b2aa:     
1:1e5b2aa:     /**
1:1e5b2aa:      * Test setString() refuses pos bigger than clob.length() + 1.
1:1e5b2aa:      */
1:1e5b2aa:     public void testSetStringWithBigPos() throws SQLException {
1:1e5b2aa:         clob.setString(1, "TEST");
1:1e5b2aa:         long upperLimit = clob.length() + 1;
1:1e5b2aa:         
1:1e5b2aa:         try {
1:1e5b2aa:             clob.setString(upperLimit + 1, "AGAIN", 0, 2);
1:1e5b2aa:             fail("pos is out of range!");
1:1e5b2aa:         } catch (SQLException e) {
1:1e5b2aa:             assertSQLState("XJ076", e);
1:1e5b2aa:         }
1:1e5b2aa:     }
1:1e5b2aa:     
1:1e5b2aa:     /**
1:1e5b2aa:      * Test setStrinng() refuses a Null String.
1:1e5b2aa:      */
1:1e5b2aa:     public void testSetStringWithNull() throws SQLException {
1:1e5b2aa:         clob.setString(1, "TEST");
1:1e5b2aa:         long upperLimit = clob.length() + 1;
1:1e5b2aa:         
1:1e5b2aa:         try {
1:1e5b2aa:             clob.setString(upperLimit, null, 0, 2);
1:1e5b2aa:             fail("can not accepted null String!");
1:1e5b2aa:         } catch (SQLException e) {
1:1e5b2aa:             assertSQLState("XJ072", e);
1:1e5b2aa:         }
1:1e5b2aa:     }
1:1e5b2aa:     
1:1e5b2aa:     /**
1:1e5b2aa:      * Test setString() accepts a empty String, and just return 0.
1:1e5b2aa:      */
1:1e5b2aa:     public void testSetStringWithEmptyString() throws SQLException {
1:1e5b2aa:         clob.setString(1, "TEST");
1:1e5b2aa:         long upperLimit = clob.length() + 1;              
1:1e5b2aa:         assertEquals(0, clob.setString(upperLimit, "", 0, 0));           
1:1e5b2aa:     }
1:1e5b2aa: 
1:1e5b2aa:     /**
1:979d9e8:      * Truncating a Clob to the empty string.
1:979d9e8:      */
1:979d9e8:     public void testTruncateZeroOnDisk()
1:979d9e8:             throws IOException, SQLException {
1:979d9e8:         long size = 33*1024+7;
1:979d9e8:         insertDataWithToken("", size, 0, SET_CHARACTER_STREAM);
1:979d9e8:         truncateToZero(size);
1:979d9e8:     }
1:979d9e8: 
1:979d9e8:     /**
1:979d9e8:      * Truncating a Clob to the empty string.
1:979d9e8:      */
1:979d9e8:     public void testTruncateZeroInMemory()
1:979d9e8:             throws IOException, SQLException {
1:979d9e8:         long size = 33;
1:979d9e8:         insertDataWithToken("", size, 0, SET_STRING);
1:979d9e8:         truncateToZero(size);
1:979d9e8:     }
1:979d9e8: 
1:979d9e8:     /**
1:979d9e8:      * Truncates the default Clob to zero length and checks some basic
1:979d9e8:      * operations on the empty Clob.
1:979d9e8:      *
1:979d9e8:      * @param initSize the expected size of the Clob to truncate
1:979d9e8:      */
1:979d9e8:     private void truncateToZero(long initSize)
1:979d9e8:             throws IOException, SQLException {
1:979d9e8:         assertEquals(initSize, this.clob.length());
1:979d9e8:         this.clob.truncate(0);
1:979d9e8:         assertEquals(0L, this.clob.length());
1:979d9e8:         assertEquals("", this.clob.getSubString(1, 0));
1:979d9e8:         assertEquals("", this.clob.getSubString(1, 1));
1:979d9e8:         assertEquals(-1, this.clob.getCharacterStream().read());
1:979d9e8:     }
1:979d9e8: 
1:979d9e8:     /**
1:a63282c:      * Truncating a Clob to the current length should work.
1:a63282c:      */
1:a63282c:     public void testTruncateExactOnDisk()
1:a63282c:             throws IOException, SQLException {
1:a63282c:         long size = 33*1024+7;
1:a63282c:         insertDataWithToken("", size, 0, SET_CHARACTER_STREAM);
1:a63282c:         assertEquals(size, this.clob.length());
1:a63282c:         this.clob.truncate(size);
1:a63282c:         assertEquals(size, this.clob.length());
1:a63282c:     }
1:a63282c: 
1:a63282c:     /**
1:a63282c:      * Truncating a Clob to the current length should work.
1:a63282c:      */
1:a63282c:     public void testTruncateExactInMemory()
1:a63282c:             throws IOException, SQLException {
1:a63282c:         long size = 33;
1:a63282c:         insertDataWithToken("", size, 0, SET_STRING);
1:a63282c:         assertEquals(size, this.clob.length());
1:a63282c:         this.clob.truncate(size);
1:a63282c:         assertEquals(size, this.clob.length());
1:a63282c:     }
1:a63282c: 
1:a63282c:     /**
1:a63282c:      * Specify a position that is larger then the Clob length.
1:a63282c:      * <p>
1:a63282c:      * This operation should fail and raise an exception.
1:a63282c:      */
1:a63282c:     public void testTruncateTooLongOnDisk()
1:a63282c:             throws IOException, SQLException {
1:a63282c:         long size = 44*1024+8;
1:a63282c:         insertDataWithToken("", size, 0, SET_CHARACTER_STREAM);
1:a63282c:         try {
1:a63282c:             this.clob.truncate(size * 2);
1:a63282c:             fail("Truncate should have failed, position too large");
1:a63282c:         } catch (SQLException sqle) {
1:4d20e64:             assertSQLState("XJ079", sqle);
1:a63282c:         }
1:a63282c:     }
1:a63282c: 
1:a63282c:     /**
1:a63282c:      * Specify a position that is larger then the Clob length.
1:a63282c:      * <p>
1:a63282c:      * This operation should fail and raise an exception.
1:a63282c:      */
1:a63282c:     public void testTruncateTooLongInMemory()
1:a63282c:             throws IOException, SQLException {
1:a63282c:         long size = 44;
1:a63282c:         insertDataWithToken("", size, 0, SET_STRING);
1:a63282c:         try {
1:a63282c:             this.clob.truncate(size * 2);
1:a63282c:             fail("Truncate should have failed, position too large");
1:a63282c:         } catch (SQLException sqle) {
1:4d20e64:             assertSQLState("XJ079", sqle);
1:a63282c:         }
1:a63282c:     }
1:a63282c: 
1:a63282c:     /**
1:a63282c:      * Tests that the length of a Clob isn't cached in such a way that the
1:a63282c:      * length isn't updated after truncation.
1:a63282c:      */
1:a63282c:     public void testGetLengthAfterTruncate()
1:a63282c:             throws IOException, SQLException {
1:a63282c:         final long initialSize =87*1024-2;
1:a63282c:         final long truncateOnceSize = 85*1024+9;
1:a63282c:         final long truncateTwiceSize = 2*1024+17;
1:a63282c:         insertDataWithToken("", initialSize, 0, SET_ASCII_STREAM);
1:a63282c:         // Check initial length.
1:a63282c:         assertEquals(initialSize, clob.length());
1:a63282c:         clob.truncate(truncateOnceSize);
1:a63282c:         assertEquals(truncateOnceSize, clob.length());
1:a63282c:         // This should bring the Clob over into memory again.
1:a63282c:         clob.truncate(truncateTwiceSize);
1:a63282c:         assertEquals(truncateTwiceSize, clob.length());
1:a63282c:         // Truncate again, same length.
1:a63282c:         clob.truncate(truncateTwiceSize);
1:a63282c:         assertEquals(truncateTwiceSize, clob.length());
1:a63282c:     }
1:a63282c: 
1:8f75194:     /**
1:8f75194:      * Tests that cloning an SQLClob object works when a stream has been set as
1:8f75194:      * the source of the Clob.
1:8f75194:      * <p>
1:8f75194:      * See DERBY-4278
1:8f75194:      *
1:8f75194:      * @throws SQLException if something goes wrong
1:8f75194:      */
1:8f75194:     public void testCloningThroughAddBatchWithStream()
1:8f75194:             throws SQLException {
1:8f75194:         testCloningThroughAddBatch(true, true);
1:8f75194:         testCloningThroughAddBatch(true, false);
1:8f75194:     }
1:8f75194: 
1:8f75194:     /**
1:8f75194:      * Tests that cloning an SQLClob object works when a string has been set as
1:8f75194:      * the source of the Clob.
1:8f75194:      *
1:8f75194:      * @throws SQLException if something goes wrong
1:8f75194:      */
1:8f75194:     public void testCloningThroughAddBatchWithString()
1:8f75194:             throws SQLException {
1:8f75194:         testCloningThroughAddBatch(false, true);
1:8f75194:         testCloningThroughAddBatch(false, false);
1:8f75194:     }
1:8f75194: 
1:8f75194:     /**
1:8f75194:      * Adds a series of Clobs into the test table using a batch, then deletes
1:8f75194:      * the Clobs inserted.
1:8f75194:      *
1:8f75194:      * @param sourceAsStream whether the source shall be specified as a stream
1:8f75194:      *      or a string
1:8f75194:      * @param autoCommit auto commit mode to run with
1:8f75194:      * @throws SQLException if something goes wrong
1:8f75194:      */
1:8f75194:     private void testCloningThroughAddBatch(final boolean sourceAsStream,
1:8f75194:                                             boolean autoCommit)
1:8f75194:             throws SQLException {
1:8f75194:         final int count = 100;
1:8f75194:         // Adjust auto commit as specified (and reset when done).
1:8f75194:         boolean savedAutoCommitValue = getConnection().getAutoCommit();
1:8f75194:         setAutoCommit(autoCommit);
1:8f75194:         // Expect execution to return an array with ones.
1:8f75194:         int[] expectedResult = new int[count];
1:8f75194:         Arrays.fill(expectedResult, 1);
1:8f75194:         // Insert a series of Clobs using a batch.
1:8f75194:         PreparedStatement insert = prepareStatement(
1:8f75194:                 "insert into ClobTestData values (?,?)");
1:8f75194:         int firstId = nextUniqueId;
1:8f75194:         for (int i=0; i < count; i++) {
1:8f75194:             insert.setInt(1, nextUniqueId++);
1:8f75194:             String str = "Clob-" + i;
1:8f75194:             if (sourceAsStream) {
1:8f75194:                 insert.setCharacterStream(
1:8f75194:                         2, new StringReader(str), str.length());
1:8f75194:             } else {
1:8f75194:                 insert.setString(2, "Clob-" +i);
1:8f75194:             }
1:8f75194:             insert.addBatch();
1:8f75194:         }
1:8f75194:         assertTrue(Arrays.equals(expectedResult, insert.executeBatch()));
1:8f75194:         commit();
1:8f75194: 
1:8f75194:         // To avoid keeping the data around, delete it as well.
1:8f75194:         PreparedStatement delete = prepareStatement
1:8f75194:                 ("delete from ClobTestData where id = ?");
1:8f75194:         for (int i=0; i < count; i++) {
1:8f75194:             delete.setInt(1, firstId + i);
1:8f75194:             delete.addBatch();
1:8f75194:         }
1:8f75194:         assertTrue(Arrays.equals(expectedResult, delete.executeBatch()));
1:8f75194:         commit();
1:8f75194:         setAutoCommit(savedAutoCommitValue);
1:8f75194:     }
1:8f75194: 
1:961ecca:     /**
1:961ecca:      * Verify that generated columns don't interfere with streaming Clobs.
1:961ecca:      * See DERBY-4544.
1:961ecca:      */
1:961ecca:     public  void    test_4544() throws Exception
1:961ecca:     {
1:961ecca:         int     streamLength = 100;
1:961ecca:         String  tableName;
1:961ecca: 
1:961ecca:         prepareStatement
1:961ecca:             ( "create table t_4544_0 ( myclob clob )" ).execute();
1:961ecca:         insertClob( streamLength, "t_4544_0" );
1:961ecca:         prepareStatement
1:961ecca:             (
1:961ecca:              "create function replace_4544( inclob clob, target varchar( 32672 ), replacement varchar( 32672 ) )\n" +
1:961ecca:              "returns clob\n" +
1:961ecca:              "language java parameter style java no sql deterministic\n" +
1:961ecca:              "external name '" + getClass().getName() + ".replace'"
1:961ecca:              ).execute();
1:961ecca: 
1:961ecca:         vetTable
1:961ecca:             (
1:961ecca:              streamLength,
1:961ecca:              "generated always as (length(myclob))",
1:961ecca:              Integer.toString( streamLength )
1:961ecca:              );
1:961ecca:         vetTable
1:961ecca:             (
1:961ecca:              streamLength,
1:961ecca:              "varchar( 3 ) generated always as ( substr(myclob, 1, 3) )",
1:961ecca:              " ab"
1:961ecca:              );
1:961ecca:         vetTable
1:961ecca:             (
1:961ecca:              streamLength,
1:961ecca:              "generated always as (locate( 'def', myclob ))",
1:961ecca:              "5"
1:961ecca:              );
1:961ecca:         vetTable
1:961ecca:             (
1:961ecca:              streamLength,
1:961ecca:              "clob generated always as (upper( myclob ))",
1:961ecca:              (new DummyReader( streamLength )).toString().toUpperCase()
1:961ecca:              );
1:961ecca:         vetTable
1:961ecca:             (
1:961ecca:              streamLength,
1:961ecca:              "clob generated always as (trim( myclob ))",
1:961ecca:              (new DummyReader( streamLength )).toString().trim()
1:961ecca:              );
1:961ecca:         vetTable
1:961ecca:             (
1:961ecca:              streamLength,
1:961ecca:              "clob generated always as (replace_4544( myclob, 'b', 'B' ))",
1:961ecca:              (new DummyReader( streamLength )).toString().replace( 'b', 'B' )
1:961ecca:              );
1:961ecca: 
1:961ecca:         dropTable( "t_4544_0" );
1:961ecca:         prepareStatement( "drop function replace_4544" ).execute();
1:961ecca:     }
1:961ecca:     private void    vetTable( int streamLength, String gencol, String expectedValue ) throws Exception
1:961ecca:     {
1:961ecca:         String tableName = "t_4544_1";
1:961ecca:         
1:961ecca:         prepareStatement
1:961ecca:             ( "create table " + tableName + "( myclob clob, gencol " + gencol + " )" ).execute();
1:961ecca: 
1:961ecca:         insertClob( streamLength, tableName );
1:961ecca:         vetTable( tableName, expectedValue );
1:961ecca:         vetClob( streamLength, tableName );
1:961ecca:         
1:961ecca:         prepareStatement( "delete from " + tableName ).executeUpdate();
1:961ecca: 
1:961ecca:         prepareStatement( "insert into " + tableName + "( myclob ) select myclob from t_4544_0" ).executeUpdate();
1:961ecca:         vetTable( tableName, expectedValue );
1:961ecca:         vetClob( streamLength, tableName );
1:961ecca:         
1:961ecca:         dropTable( tableName );
1:961ecca:     }
1:961ecca:     private void    vetTable( String tableName, String expectedValue ) throws Exception
1:961ecca:     {
1:961ecca:         ResultSet   rs = prepareStatement( "select gencol from " + tableName ).executeQuery();
1:961ecca:         rs.next();
1:961ecca:         assertEquals( expectedValue, rs.getString( 1 ) );
1:961ecca:         rs.close();
1:961ecca:     }
1:961ecca:     private void    insertClob( int streamLength, String tableName ) throws Exception
1:961ecca:     {
1:961ecca:         PreparedStatement   insert = prepareStatement( "insert into " + tableName + "( myclob ) values ( ? )" );
1:961ecca:         insert.setCharacterStream( 1, new DummyReader( streamLength ), streamLength );
1:961ecca:         insert.executeUpdate();
1:961ecca:     }
1:961ecca:     private void    vetClob( int streamLength, String tableName ) throws Exception
1:961ecca:     {
1:961ecca:         PreparedStatement   select = prepareStatement( "select myclob from " + tableName );
1:961ecca:         ResultSet               rs = select.executeQuery();
1:961ecca:         rs.next();
1:961ecca:         Reader      actualReader = rs.getCharacterStream( 1 );
1:961ecca:         Reader      expectedReader = new DummyReader( streamLength );
1:961ecca: 
1:961ecca:         for ( int i = 0; i < streamLength; i++ )
1:961ecca:         {
1:961ecca:             int actual = actualReader.read();
1:961ecca:             if ( actual < 0 )
1:961ecca:             {
1:961ecca:                 fail( "    Read stream was only " + i + " characters long." );
1:961ecca:             }
1:961ecca:             
1:961ecca:             int    expected = expectedReader.read();
1:961ecca:             
1:961ecca:             assertEquals( expected, actual );
1:961ecca:         }
1:961ecca:         assertTrue( actualReader.read() < 0 );
1:961ecca: 
1:961ecca:         rs.close();
1:961ecca:     }
1:961ecca:     public  static  Clob    replace( Clob clob, String target, String replacement )
1:961ecca:         throws Exception
1:961ecca:     {
1:961ecca:         char    targetChar = target.charAt( 0 );
1:961ecca:         char    replacementChar = replacement.charAt( 0 );
1:961ecca:         String  originalString = clob.getSubString( 1, (int) clob.length() );
1:961ecca:         String  resultString = originalString.replace( targetChar, replacementChar );
1:961ecca: 
1:961ecca:         return new HarmonySerialClob( resultString );
1:961ecca:     }
1:961ecca: 
1:a78e683:     /* Test ideas for more tests
1:cb2e1a4:      *
1:cb2e1a4:      * truncate:
1:cb2e1a4:      *      truncate both on in store and from createClob
1:cb2e1a4:      *      truncate multiple times, check length and compare content
1:cb2e1a4:      *      truncate with negative size
1:cb2e1a4:      *      truncate with too big size
1:cb2e1a4:      *      truncate to 0
1:cb2e1a4:      *      truncate to current length
1:a78e683:      *
1:a78e683:      * setString:
1:a78e683:      *      test with null string
1:a78e683:      *      test with offset out of range
1:a78e683:      *      test with length of string to insert out of range
1:cb2e1a4:      */
1:cb2e1a4: 
1:cb2e1a4:     /**
1:cb2e1a4:      * Insert text into a Clob using {@link java.sql.Clob#setAsciiStream} and
1:cb2e1a4:      * then search for the specified token.
1:cb2e1a4:      * <p>
1:cb2e1a4:      * Some data is inserted before and after the token, and the specified token
1:cb2e1a4:      * is converted to bytes by using the ISO-8859-1 encoding.
1:cb2e1a4:      * Note that ascii in JDBC is equivalent to ISO-8859-1, not US-ASCII.
1:cb2e1a4:      */
1:cb2e1a4:     private void executeTestPositionWithStringToken(String token, long prefixLength)
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4: 
1:cb2e1a4:         final long TOKEN_POS = prefixLength +1;
1:cb2e1a4:         // Start searching behind the token.
1:cb2e1a4:         assertEquals(-1, this.clob.position(token, TOKEN_POS+1));
1:cb2e1a4:         // Start searching exactly at the right position.
1:cb2e1a4:         assertEquals(TOKEN_POS, this.clob.position(token, TOKEN_POS));
1:cb2e1a4:         // Start searching at the start of the Clob.
1:cb2e1a4:         assertEquals(TOKEN_POS, this.clob.position(token, 1L));
1:a63282c:     }
1:cb2e1a4: 
1:cb2e1a4:     /**
1:cb2e1a4:      * Obtain a Clob containing the empty string.
1:cb2e1a4:      */
1:cb2e1a4:     protected void setUp()
1:cb2e1a4:             throws Exception {
1:cb2e1a4:         // Obtain a Clob containing the empty string ("").
1:e8fd686:         Statement stmt = createStatement();
1:cb2e1a4:         // Keep reference to the result set to be able to close it.
1:71dca8c:         ResultSet rs = stmt.executeQuery(
1:e8fd686:                 "select dClob from ClobTestData where id = 1");
1:71dca8c:         assertTrue(rs.next());
1:71dca8c:         this.clob = rs.getClob(1);
1:71dca8c:         // Leave the result set open to keep the Clob alive.
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     /**
1:71dca8c:      * Nullify reference to Clob.
1:cb2e1a4:      */
1:cb2e1a4:     protected void tearDown()
1:cb2e1a4:             throws Exception {
1:cb2e1a4:         this.clob = null;
1:cb2e1a4:         super.tearDown();
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public static Test suite() {
1:cb2e1a4:         return new ClobTestSetup(
1:cb2e1a4:             TestConfiguration.defaultSuite(ClobTest.class, false));
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     /**
1:cb2e1a4:      * Transfer data from an input stream to an output stream.
1:cb2e1a4:      *
1:cb2e1a4:      * @param source source data
1:cb2e1a4:      * @param dest destination to write to
1:cb2e1a4:      * @param tz buffer size in number of bytes. Must be 1 or greater.
1:cb2e1a4:      * @return Number of bytes read from the source data. This should equal the
1:cb2e1a4:      *      number of bytes written to the destination.
1:cb2e1a4:      */
1:cb2e1a4:     private int transferData(InputStream source, OutputStream dest, int tz)
1:cb2e1a4:             throws IOException {
1:cb2e1a4:         if (tz < 1) {
1:cb2e1a4:             throw new IllegalArgumentException(
1:cb2e1a4:                 "Buffer size must be 1 or greater: " + tz);
1:cb2e1a4:         }
1:cb2e1a4:         BufferedInputStream in = new BufferedInputStream(source);
1:cb2e1a4:         BufferedOutputStream out = new BufferedOutputStream(dest, tz);
1:cb2e1a4:         byte[] bridge = new byte[tz];
1:cb2e1a4:         int total = 0;
1:cb2e1a4:         int read;
1:cb2e1a4:         while ((read = in.read(bridge, 0, tz)) != -1) {
1:cb2e1a4:             out.write(bridge, 0, read);
1:cb2e1a4:             total += read;
1:cb2e1a4:         }
1:cb2e1a4:         in.close();
1:cb2e1a4:         // Don't close the stream, in case it will be written to again.
1:cb2e1a4:         out.flush();
1:cb2e1a4:         return total;
1:cb2e1a4:     }
1:cb2e1a4: 
1:a63282c:         /**
1:cb2e1a4:      * Transfer data from a source Reader to a destination Writer.
1:cb2e1a4:      *
1:cb2e1a4:      * @param source source data
1:cb2e1a4:      * @param dest destination to write to
1:cb2e1a4:      * @param tz buffer size in number of characters. Must be 1 or greater.
1:cb2e1a4:      * @return Number of characters read from the source data. This should equal the
1:cb2e1a4:      *      number of characters written to the destination.
1:cb2e1a4:      */
1:cb2e1a4:     private int transferData(Reader source, Writer dest, int tz)
1:cb2e1a4:             throws IOException {
1:cb2e1a4:         if (tz < 1) {
1:cb2e1a4:             throw new IllegalArgumentException(
1:cb2e1a4:                 "Buffer size must be 1 or greater: " + tz);
1:cb2e1a4:         }
1:cb2e1a4:         BufferedReader in = new BufferedReader(source);
1:cb2e1a4:         BufferedWriter out = new BufferedWriter(dest, tz);
1:cb2e1a4:         char[] bridge = new char[tz];
1:cb2e1a4:         int total = 0;
1:cb2e1a4:         int read;
1:cb2e1a4:         while ((read = in.read(bridge, 0, tz)) != -1) {
1:cb2e1a4:             out.write(bridge, 0, read);
1:cb2e1a4:             total += read;
1:cb2e1a4:         }
1:cb2e1a4:         in.close();
1:cb2e1a4:         // Don't close the stream, in case it will be written to again.
1:cb2e1a4:         out.flush();
1:cb2e1a4:         return total;
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     private int transferData(Reader source, int tz)
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         if (tz < 1) {
1:cb2e1a4:             throw new IllegalArgumentException(
1:cb2e1a4:                 "Buffer size must be 1 or greater: " + tz);
1:cb2e1a4:         }
1:cb2e1a4:         BufferedReader in = new BufferedReader(source);
1:cb2e1a4:         char[] bridge = new char[tz];
1:cb2e1a4:         int total = 0;
1:cb2e1a4:         int read;
1:cb2e1a4:         while ((read = in.read(bridge, 0, tz)) != -1) {
1:cb2e1a4:             this.clob.setString(total +1L, String.copyValueOf(bridge, 0, read));
1:cb2e1a4:             total += read;
1:cb2e1a4:         }
1:cb2e1a4:         in.close();
1:cb2e1a4:         return total;
1:cb2e1a4:     }
1:cb2e1a4: 
1:1e5b2aa:     /**
1:a63282c:      * Inserts data into the test Clob, referenced by {@code this.clob}.
1:a63282c:      *
1:a63282c:      * @param token a token to insert into the Clob, cannot be {@code null} but
1:a63282c:      *      the empty string is accepted
1:a63282c:      * @param pre number of characters to insert before the token, using the
1:a63282c:      *      repeating alphabet stream (latin lower-case)
1:a63282c:      * @param post number of characters to insert after the token, using the
1:a63282c:      *      repeating alphabet stream (latin lower-case)
1:a63282c:      * @param mode insertion mode; SET_STRING, SET_ASCII_STREAM or
1:a63282c:      *      SET_CHARACTER_STREAM
1:a63282c:      * @throws IOException if inserting data fails for some reason
1:a63282c:      * @throws SQLException if inserting data fails for some reason
1:a63282c:      */
1:cb2e1a4:     private void insertDataWithToken(String token, 
1:cb2e1a4:                                      long pre, long post, int mode)
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         long total = 0;
1:cb2e1a4:         switch (mode) {
1:cb2e1a4:             case SET_STRING: {
1:cb2e1a4:                 Reader charIn = new LoopingAlphabetReader(pre);
1:cb2e1a4:                 total += transferData(charIn, TRANSFER_BUFFER_SIZE);
1:cb2e1a4:                 this.clob.setString(pre +1, token);
1:cb2e1a4:                 total += token.length();
1:cb2e1a4:                 charIn = new LoopingAlphabetReader(post);
1:cb2e1a4:                 total += transferData(charIn, TRANSFER_BUFFER_SIZE);
1:cb2e1a4:                 break;
1:cb2e1a4:             } case SET_ASCII_STREAM: {
1:cb2e1a4:                 OutputStream asciiOut = this.clob.setAsciiStream(1L);
1:cb2e1a4:                 InputStream asciiIn = new LoopingAlphabetStream(pre);
1:cb2e1a4:                 total += transferData(asciiIn, asciiOut, TRANSFER_BUFFER_SIZE);
1:cb2e1a4:                 byte[] tokenBytes = token.getBytes("ISO-8859-1");
1:cb2e1a4:                 asciiOut.write(tokenBytes, 0, tokenBytes.length);
1:cb2e1a4:                 total += tokenBytes.length;
1:cb2e1a4:                 asciiIn = new LoopingAlphabetStream(post);
1:cb2e1a4:                 total += transferData(asciiIn, asciiOut, TRANSFER_BUFFER_SIZE);
1:cb2e1a4:                 break;
1:cb2e1a4:             } case SET_CHARACTER_STREAM: {
1:cb2e1a4:                 Writer charOut = this.clob.setCharacterStream(1L);
1:cb2e1a4:                 Reader charIn = new LoopingAlphabetReader(pre);
1:cb2e1a4:                 total += transferData(charIn, charOut, TRANSFER_BUFFER_SIZE);
1:cb2e1a4:                 charOut.write(token);
1:cb2e1a4:                 total += token.length();
1:cb2e1a4:                 charIn = new LoopingAlphabetReader(post);
1:cb2e1a4:                 total += transferData(charIn, charOut, TRANSFER_BUFFER_SIZE);
1:cb2e1a4:                 break;
1:cb2e1a4:             } default:
1:cb2e1a4:                 throw new IllegalArgumentException(
1:cb2e1a4:                     "Unknown insertion mode: " + mode);
1:cb2e1a4:         }
1:cb2e1a4:         assertEquals("Invalid length after insertion",
1:cb2e1a4:             pre + post + token.length(), this.clob.length());
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     /**
1:cb2e1a4:      * Decorator creating the neccessary test data.
1:cb2e1a4:      */
1:cb2e1a4:     private static class ClobTestSetup extends BaseJDBCTestSetup {
1:cb2e1a4: 
1:cb2e1a4:         ClobTestSetup(Test test) {
1:cb2e1a4:             super(test);
1:cb2e1a4:         }
1:cb2e1a4: 
1:cb2e1a4:         protected void setUp() throws SQLException {
1:cb2e1a4:             Connection con = getConnection();
1:cb2e1a4:             Statement stmt = con.createStatement();
1:cb2e1a4:             stmt.execute("create table ClobTestData (" +
1:e8fd686:                     "id int unique, dClob CLOB)");
1:e8fd686:             stmt.executeUpdate("insert into ClobTestData values (1, '')");
1:cb2e1a4:             stmt.close();
1:cb2e1a4:        }
1:cb2e1a4: 
1:cb2e1a4:         protected void tearDown()
1:cb2e1a4:                 throws Exception {
1:cb2e1a4:             Connection con = getConnection();
1:cb2e1a4:             Statement stmt = con.createStatement();
1:cb2e1a4:             stmt.execute("drop table ClobTestData");
1:cb2e1a4:             stmt.close();
1:cb2e1a4:             super.tearDown();
1:cb2e1a4:         }
1:cb2e1a4:     } // End inner class ClobTestSetup
1:cb2e1a4: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:961ecca
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.HarmonySerialClob;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verify that generated columns don't interfere with streaming Clobs.
1:      * See DERBY-4544.
1:      */
1:     public  void    test_4544() throws Exception
1:     {
1:         int     streamLength = 100;
1:         String  tableName;
1: 
1:         prepareStatement
1:             ( "create table t_4544_0 ( myclob clob )" ).execute();
1:         insertClob( streamLength, "t_4544_0" );
1:         prepareStatement
1:             (
1:              "create function replace_4544( inclob clob, target varchar( 32672 ), replacement varchar( 32672 ) )\n" +
1:              "returns clob\n" +
1:              "language java parameter style java no sql deterministic\n" +
1:              "external name '" + getClass().getName() + ".replace'"
1:              ).execute();
1: 
1:         vetTable
1:             (
1:              streamLength,
1:              "generated always as (length(myclob))",
1:              Integer.toString( streamLength )
1:              );
1:         vetTable
1:             (
1:              streamLength,
1:              "varchar( 3 ) generated always as ( substr(myclob, 1, 3) )",
1:              " ab"
1:              );
1:         vetTable
1:             (
1:              streamLength,
1:              "generated always as (locate( 'def', myclob ))",
1:              "5"
1:              );
1:         vetTable
1:             (
1:              streamLength,
1:              "clob generated always as (upper( myclob ))",
1:              (new DummyReader( streamLength )).toString().toUpperCase()
1:              );
1:         vetTable
1:             (
1:              streamLength,
1:              "clob generated always as (trim( myclob ))",
1:              (new DummyReader( streamLength )).toString().trim()
1:              );
1:         vetTable
1:             (
1:              streamLength,
1:              "clob generated always as (replace_4544( myclob, 'b', 'B' ))",
1:              (new DummyReader( streamLength )).toString().replace( 'b', 'B' )
1:              );
1: 
1:         dropTable( "t_4544_0" );
1:         prepareStatement( "drop function replace_4544" ).execute();
1:     }
1:     private void    vetTable( int streamLength, String gencol, String expectedValue ) throws Exception
1:     {
1:         String tableName = "t_4544_1";
1:         
1:         prepareStatement
1:             ( "create table " + tableName + "( myclob clob, gencol " + gencol + " )" ).execute();
1: 
1:         insertClob( streamLength, tableName );
1:         vetTable( tableName, expectedValue );
1:         vetClob( streamLength, tableName );
1:         
1:         prepareStatement( "delete from " + tableName ).executeUpdate();
1: 
1:         prepareStatement( "insert into " + tableName + "( myclob ) select myclob from t_4544_0" ).executeUpdate();
1:         vetTable( tableName, expectedValue );
1:         vetClob( streamLength, tableName );
1:         
1:         dropTable( tableName );
1:     }
1:     private void    vetTable( String tableName, String expectedValue ) throws Exception
1:     {
1:         ResultSet   rs = prepareStatement( "select gencol from " + tableName ).executeQuery();
1:         rs.next();
1:         assertEquals( expectedValue, rs.getString( 1 ) );
1:         rs.close();
1:     }
1:     private void    insertClob( int streamLength, String tableName ) throws Exception
1:     {
1:         PreparedStatement   insert = prepareStatement( "insert into " + tableName + "( myclob ) values ( ? )" );
1:         insert.setCharacterStream( 1, new DummyReader( streamLength ), streamLength );
1:         insert.executeUpdate();
1:     }
1:     private void    vetClob( int streamLength, String tableName ) throws Exception
1:     {
1:         PreparedStatement   select = prepareStatement( "select myclob from " + tableName );
1:         ResultSet               rs = select.executeQuery();
1:         rs.next();
1:         Reader      actualReader = rs.getCharacterStream( 1 );
1:         Reader      expectedReader = new DummyReader( streamLength );
1: 
1:         for ( int i = 0; i < streamLength; i++ )
1:         {
1:             int actual = actualReader.read();
1:             if ( actual < 0 )
1:             {
1:                 fail( "    Read stream was only " + i + " characters long." );
1:             }
1:             
1:             int    expected = expectedReader.read();
1:             
1:             assertEquals( expected, actual );
1:         }
1:         assertTrue( actualReader.read() < 0 );
1: 
1:         rs.close();
1:     }
1:     public  static  Clob    replace( Clob clob, String target, String replacement )
1:         throws Exception
1:     {
1:         char    targetChar = target.charAt( 0 );
1:         char    replacementChar = replacement.charAt( 0 );
1:         String  originalString = clob.getSubString( 1, (int) clob.length() );
1:         String  resultString = originalString.replace( targetChar, replacementChar );
1: 
1:         return new HarmonySerialClob( resultString );
1:     }
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:8f75194
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Next unique id for a Clob. Note that this isn't accessed in a thread-
1:      * safe way.
1:      */
1:     private static int nextUniqueId = 150000;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tests that cloning an SQLClob object works when a stream has been set as
1:      * the source of the Clob.
1:      * <p>
1:      * See DERBY-4278
1:      *
1:      * @throws SQLException if something goes wrong
1:      */
1:     public void testCloningThroughAddBatchWithStream()
1:             throws SQLException {
1:         testCloningThroughAddBatch(true, true);
1:         testCloningThroughAddBatch(true, false);
1:     }
1: 
1:     /**
1:      * Tests that cloning an SQLClob object works when a string has been set as
1:      * the source of the Clob.
1:      *
1:      * @throws SQLException if something goes wrong
1:      */
1:     public void testCloningThroughAddBatchWithString()
1:             throws SQLException {
1:         testCloningThroughAddBatch(false, true);
1:         testCloningThroughAddBatch(false, false);
1:     }
1: 
1:     /**
1:      * Adds a series of Clobs into the test table using a batch, then deletes
1:      * the Clobs inserted.
1:      *
1:      * @param sourceAsStream whether the source shall be specified as a stream
1:      *      or a string
1:      * @param autoCommit auto commit mode to run with
1:      * @throws SQLException if something goes wrong
1:      */
1:     private void testCloningThroughAddBatch(final boolean sourceAsStream,
1:                                             boolean autoCommit)
1:             throws SQLException {
1:         final int count = 100;
1:         // Adjust auto commit as specified (and reset when done).
1:         boolean savedAutoCommitValue = getConnection().getAutoCommit();
1:         setAutoCommit(autoCommit);
1:         // Expect execution to return an array with ones.
1:         int[] expectedResult = new int[count];
1:         Arrays.fill(expectedResult, 1);
1:         // Insert a series of Clobs using a batch.
1:         PreparedStatement insert = prepareStatement(
1:                 "insert into ClobTestData values (?,?)");
1:         int firstId = nextUniqueId;
1:         for (int i=0; i < count; i++) {
1:             insert.setInt(1, nextUniqueId++);
1:             String str = "Clob-" + i;
1:             if (sourceAsStream) {
1:                 insert.setCharacterStream(
1:                         2, new StringReader(str), str.length());
1:             } else {
1:                 insert.setString(2, "Clob-" +i);
1:             }
1:             insert.addBatch();
1:         }
1:         assertTrue(Arrays.equals(expectedResult, insert.executeBatch()));
1:         commit();
1: 
1:         // To avoid keeping the data around, delete it as well.
1:         PreparedStatement delete = prepareStatement
1:                 ("delete from ClobTestData where id = ?");
1:         for (int i=0; i < count; i++) {
1:             delete.setInt(1, firstId + i);
1:             delete.addBatch();
1:         }
1:         assertTrue(Arrays.equals(expectedResult, delete.executeBatch()));
1:         commit();
1:         setAutoCommit(savedAutoCommitValue);
1:     }
1: 
commit:979d9e8
/////////////////////////////////////////////////////////////////////////
1:      * Truncating a Clob to the empty string.
1:      */
1:     public void testTruncateZeroOnDisk()
1:             throws IOException, SQLException {
1:         long size = 33*1024+7;
1:         insertDataWithToken("", size, 0, SET_CHARACTER_STREAM);
1:         truncateToZero(size);
1:     }
1: 
1:     /**
1:      * Truncating a Clob to the empty string.
1:      */
1:     public void testTruncateZeroInMemory()
1:             throws IOException, SQLException {
1:         long size = 33;
1:         insertDataWithToken("", size, 0, SET_STRING);
1:         truncateToZero(size);
1:     }
1: 
1:     /**
1:      * Truncates the default Clob to zero length and checks some basic
1:      * operations on the empty Clob.
1:      *
1:      * @param initSize the expected size of the Clob to truncate
1:      */
1:     private void truncateToZero(long initSize)
1:             throws IOException, SQLException {
1:         assertEquals(initSize, this.clob.length());
1:         this.clob.truncate(0);
1:         assertEquals(0L, this.clob.length());
1:         assertEquals("", this.clob.getSubString(1, 0));
1:         assertEquals("", this.clob.getSubString(1, 1));
1:         assertEquals(-1, this.clob.getCharacterStream().read());
1:     }
1: 
1:     /**
commit:b1c6145
/////////////////////////////////////////////////////////////////////////
commit:4d20e64
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("XJ079", sqle);
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("XJ079", sqle);
commit:71dca8c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tests that the length is updated correctly when inserting data.
1:      */
1:     public void testLengthAfterInsertOnEmpty()
1:             throws IOException, SQLException {
1:         insertDataWithToken("", 0, 0, SET_STRING);
1:         assertEquals(0L, clob.length());
1:         clob.setString(1, "TEST");
1:         assertEquals(4L, clob.length());
1:         clob.setString(1, "TEST");
1:         assertEquals(4L, clob.length());
1:         clob.setString(5, "TEST");
1:         assertEquals(8L, clob.length());
1:         clob.setString(7, "TEST");
1:         assertEquals(10L, clob.length());
1:         clob.truncate(4L);
1:         assertEquals(4L, clob.length());
1:         clob.setString(4, "TEST");
1:         assertEquals(7L, clob.length());
1:     }
1: 
1:     /**
1:      * Tests that the length is updated correctly when inserting data.
1:      */
1:     public void testLengthAfterInsertOnLarge()
1:             throws IOException, SQLException {
1:         final String token = "SWEETSPOT";
1:         long curLength = (32+9) * 1024 + token.length();
1:         insertDataWithToken(token, 32*1024, 9*1024, SET_CHARACTER_STREAM);
1:         assertEquals(curLength, clob.length());
1:         clob.setString(1, "TEST");
1:         assertEquals(curLength, clob.length());
1:         clob.setString(curLength, "X");
1:         assertEquals(curLength, clob.length());
1:         assertEquals(32*1024+1, clob.position(token, 17*1024));
1:         clob.setString(32*1024+1, "FUNNYSPOT");
1:         assertEquals(curLength, clob.length());
1:         assertEquals(-1, clob.position(token, 17*1024));
1:         clob.setString(curLength +1, "TEST");
1:         curLength += 4;
1:         assertEquals(curLength, clob.length());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs = stmt.executeQuery(
1:         assertTrue(rs.next());
1:         this.clob = rs.getClob(1);
1:         // Leave the result set open to keep the Clob alive.
1:      * Nullify reference to Clob.
commit:a63282c
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Truncating a Clob to the current length should work.
1:      */
1:     public void testTruncateExactOnDisk()
1:             throws IOException, SQLException {
1:         long size = 33*1024+7;
1:         insertDataWithToken("", size, 0, SET_CHARACTER_STREAM);
1:         assertEquals(size, this.clob.length());
1:         this.clob.truncate(size);
1:         assertEquals(size, this.clob.length());
1:     }
1: 
1:     /**
1:      * Truncating a Clob to the current length should work.
1:      */
1:     public void testTruncateExactInMemory()
1:             throws IOException, SQLException {
1:         long size = 33;
1:         insertDataWithToken("", size, 0, SET_STRING);
1:         assertEquals(size, this.clob.length());
1:         this.clob.truncate(size);
1:         assertEquals(size, this.clob.length());
1:     }
1: 
1:     /**
1:      * Specify a position that is larger then the Clob length.
1:      * <p>
1:      * This operation should fail and raise an exception.
1:      */
1:     public void testTruncateTooLongOnDisk()
1:             throws IOException, SQLException {
1:         long size = 44*1024+8;
1:         insertDataWithToken("", size, 0, SET_CHARACTER_STREAM);
1:         try {
1:             this.clob.truncate(size * 2);
1:             fail("Truncate should have failed, position too large");
1:         } catch (SQLException sqle) {
0:             // See DERBY-3977
0:             if (usingEmbedded()) {
1:                 assertSQLState("XJ076", sqle);
1:             } else {
0:                 assertSQLState("XJ079", sqle);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Specify a position that is larger then the Clob length.
1:      * <p>
1:      * This operation should fail and raise an exception.
1:      */
1:     public void testTruncateTooLongInMemory()
1:             throws IOException, SQLException {
1:         long size = 44;
1:         insertDataWithToken("", size, 0, SET_STRING);
1:         try {
1:             this.clob.truncate(size * 2);
1:             fail("Truncate should have failed, position too large");
1:         } catch (SQLException sqle) {
0:             // See DERBY-3977
0:             if (usingEmbedded()) {
1:                 assertSQLState("XJ076", sqle);
1:             } else {
0:                 assertSQLState("XJ079", sqle);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Tests that the length of a Clob isn't cached in such a way that the
1:      * length isn't updated after truncation.
1:      */
1:     public void testGetLengthAfterTruncate()
1:             throws IOException, SQLException {
1:         final long initialSize =87*1024-2;
1:         final long truncateOnceSize = 85*1024+9;
1:         final long truncateTwiceSize = 2*1024+17;
1:         insertDataWithToken("", initialSize, 0, SET_ASCII_STREAM);
1:         // Check initial length.
1:         assertEquals(initialSize, clob.length());
1:         clob.truncate(truncateOnceSize);
1:         assertEquals(truncateOnceSize, clob.length());
1:         // This should bring the Clob over into memory again.
1:         clob.truncate(truncateTwiceSize);
1:         assertEquals(truncateTwiceSize, clob.length());
1:         // Truncate again, same length.
1:         clob.truncate(truncateTwiceSize);
1:         assertEquals(truncateTwiceSize, clob.length());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Inserts data into the test Clob, referenced by {@code this.clob}.
1:      *
1:      * @param token a token to insert into the Clob, cannot be {@code null} but
1:      *      the empty string is accepted
1:      * @param pre number of characters to insert before the token, using the
1:      *      repeating alphabet stream (latin lower-case)
1:      * @param post number of characters to insert after the token, using the
1:      *      repeating alphabet stream (latin lower-case)
1:      * @param mode insertion mode; SET_STRING, SET_ASCII_STREAM or
1:      *      SET_CHARACTER_STREAM
1:      * @throws IOException if inserting data fails for some reason
1:      * @throws SQLException if inserting data fails for some reason
1:      */
commit:9b9c25a
/////////////////////////////////////////////////////////////////////////
1: import java.io.StringReader;
/////////////////////////////////////////////////////////////////////////
1:     public void testReplaceMultibyteWithSingleByteForwards()
1:             throws IOException, SQLException {
1:         // Add some content to work on first.
1:         this.clob.setString(1, NORWEGIAN_LETTERS);
1:         assertEquals(NORWEGIAN_LETTERS,
1:             this.clob.getSubString(1, NORWEGIAN_LETTERS.length()));
1: 
1:         // Replace chars one by one from the start.
1:         char[] modifiedContent = NORWEGIAN_LETTERS.toCharArray();
1:         String toInsert = "abcdefghijklmnopqr";
1:         for (int iz=0; iz < toInsert.length(); iz++) {
1:             modifiedContent[iz] = toInsert.charAt(iz);
1:             assertEquals(1, this.clob.setString(iz +1,
1:                     toInsert.substring(iz, iz +1)));
1:             assertEquals(String.copyValueOf(modifiedContent),
1:                     this.clob.getSubString(1, 100));
1:             assertEquals(new StringReader(String.copyValueOf(modifiedContent)),
1:                     this.clob.getCharacterStream());
1:         }
1:     }
1: 
1:     public void testReplaceMultibyteWithSingleByteBackwards()
1:             throws IOException, SQLException {
1:         // Add some content to work on first.
1:         this.clob.setString(1, NORWEGIAN_LETTERS);
1:         assertEquals(NORWEGIAN_LETTERS,
1:             this.clob.getSubString(1, NORWEGIAN_LETTERS.length()));
1: 
1:         // Replace chars one by one from the end.
1:         char[] modifiedContent = NORWEGIAN_LETTERS.toCharArray();
1:         String toInsert = "abcdefghijklmnopqr";
1:         for (int iz=toInsert.length() -1; iz >= 0; iz--) {
1:             modifiedContent[iz] = toInsert.charAt(iz);
1:             assertEquals(1, this.clob.setString(iz +1,
1:                     toInsert.substring(iz, iz +1)));
1:             assertEquals(String.copyValueOf(modifiedContent),
1:                     this.clob.getSubString(1, 100));
1:             assertEquals(new StringReader(String.copyValueOf(modifiedContent)),
1:                     this.clob.getCharacterStream());
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
commit:e8fd686
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tests that Derby specific end-of-stream markers aren't passed over to
1:      * the temporary Clob, which doesn't use such markers.
1:      * <p>
1:      * Passing the marker over will normally result in a UTF encoding exception.
1:      * <p>
1:      * ID USAGE: reads id 2, writes id 10002
1:      */
1:     public void testInsertCharacter_ReadOnlyToTemporary()
1:             throws IOException, SQLException {
1:         setAutoCommit(false);
1:         // Insert data, a medium sized Clob to store it as a stream.
1:         Statement stmt = createStatement();
1:         PreparedStatement ps = prepareStatement(
1:                 "insert into ClobTestData values (?,?)");
1:         int initalSize = 128*1024;
1:         ps.setInt(1, 2);
1:         ps.setCharacterStream(
1:                 2, new LoopingAlphabetReader(initalSize), initalSize);
1:         ps.executeUpdate();
1: 
1:         // Select the Clob, and change one character.
1:         PreparedStatement psSelect = prepareStatement(
1:                 "select dClob from ClobTestData where id = ?");
1:         psSelect.setInt(1, 2);
1:         ResultSet lRs = psSelect.executeQuery();
1:         lRs.next();
1:         Clob lClob = lRs.getClob(1);
1:         lClob.setString(1, "K");
1:         Reader r = lClob.getCharacterStream();
1:         assertEquals('K', r.read());
1:         long length = 1;
1:         while (true) {
1:             // Since we're skipping characters, the bytes have to be decoded
1:             // and we will detect any encoding errors.
1:             long skipped = r.skip(4096);
1:             if (skipped > 0) {
1:                 length += skipped;
0:             } else {
1:                 break;
1:             }
1:         }
1:         lRs.close();
1:         assertEquals("Wrong length!", initalSize, length);
1:         // Reports the correct length, now try to insert it.
1:         ps.setInt(1, 10003);
1:         ps.setClob(2, lClob);
1:         ps.executeUpdate();
1:         // Fetch it back.
1:         psSelect.setInt(1, 10003);
1:         lRs = psSelect.executeQuery();
1:         lRs.next();
1:         Clob lClob2 = lRs.getClob(1);
1:         assertEquals(lClob.getCharacterStream(), lClob2.getCharacterStream());
1:         assertEquals(initalSize, lClob2.length());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         this.rs = stmt.executeQuery(
1:                 "select dClob from ClobTestData where id = 1");
/////////////////////////////////////////////////////////////////////////
1:                     "id int unique, dClob CLOB)");
1:             stmt.executeUpdate("insert into ClobTestData values (1, '')");
commit:a78e683
/////////////////////////////////////////////////////////////////////////
1: 	    assertEquals("Clob content is incorrect",
1:             newContent, this.clob.getSubString(1, newContent.length()));
/////////////////////////////////////////////////////////////////////////
1:         LoopingAlphabetReader tokenSrc =
/////////////////////////////////////////////////////////////////////////
1:     /* Test ideas for more tests
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * setString:
1:      *      test with null string
1:      *      test with offset out of range
1:      *      test with length of string to insert out of range
commit:cb2e1a4
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.ClobTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one
1:    or more contributor license agreements.  See the NOTICE file
1:    distributed with this work for additional information
1:    regarding copyright ownership.  The ASF licenses this file
1:    to you under the Apache License, Version 2.0 (the
1:    "License"); you may not use this file except in compliance
1:    with the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing,
1:    software distributed under the License is distributed on an
1:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:    KIND, either express or implied.  See the License for the
1:    specific language governing permissions and limitations
1:    under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.io.BufferedInputStream;
1: import java.io.BufferedOutputStream;
1: import java.io.BufferedReader;
1: import java.io.BufferedWriter;
1: import java.io.CharArrayWriter;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: import java.io.Reader;
1: import java.io.Writer;
1: 
1: import java.sql.Connection;
1: import java.sql.Clob;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.derbyTesting.functionTests.util.streams.CharAlphabet;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseJDBCTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: 
1: 
1: /**
1:  * Test the methods defined by the {@link java.sql.Clob} interface.
1:  * <p>
1:  * Only methods defined by JDBC 3 or earlier are tested here, and the focus of
1:  * the test is the interface methods. Less attention is given to inserting
1:  * Clobs and fetching Clobs from the database.
1:  */
1: public class ClobTest
1:     extends BaseJDBCTestCase {
1: 
1:     /** Buffer size to use when transferring data between streams. */
1:     private static final int TRANSFER_BUFFER_SIZE = 4*1024; // 4 KB
1: 
1:     /** Constant for Clob.setString method. */
1:     private static final int SET_STRING = 1;
1:     /** Constant for Clob.setAsciiStream method. */
1:     private static final int SET_ASCII_STREAM = 2;
1:     /** Constant for Clob.setCharacterStream method. */
1:     private static final int SET_CHARACTER_STREAM = 4;
1: 
1:     /** Test data, 18 characters long, containing only Norwegian letters. */
1:     private static final String NORWEGIAN_LETTERS =
1:             "\u00e6\u00f8\u00e5\u00e6\u00f8\u00e5\u00e6\u00f8\u00e5" +
1:             "\u00e6\u00f8\u00e5\u00e6\u00f8\u00e5\u00e6\u00f8\u00e5";
1: 
0:     /** Result set used to obtain Clob. */
0:     private ResultSet rs = null;
1:     /**
1:      * The Clob used for testing.
1:      * It is reinitialized to a Clob containing the empty string for each test.
1:      */
1:     private Clob clob = null;
1: 
1:     public ClobTest(String testName) {
1:         super(testName);
1:     }
1: 
1:     public void testGetSubString_PosOneTooBig()
1:             throws SQLException {
1:         long length = this.clob.length();
1:         assertEquals("", this.clob.getSubString(length +1, 10));
1:     }
1: 
1:     public void testGetSubString_PosTooBig() {
1:         try {
1:             this.clob.getSubString(999, 10);
1:             fail("getSubString with pos larger than clob length must fail");
1:         } catch (SQLException sqle) {
0:             assertSQLState("XJ076", sqle);
1:         }
1:     }
1: 
1:     public void testGetSubString_PosNegative()
1:             throws SQLException {
1:         try {
1:             this.clob.getSubString(-123, 10);
1:             fail("getSubString with negative position should fail");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ070", sqle);
1:         }
1:     }
1: 
1:     public void testGetSubString_RequestZeroLength_PosValid()
1:             throws SQLException {
1:         // Tests if an exception is thrown or not.
1:         // According to the JDBC spec, 0 is a valid length.
1:         assertEquals("", this.clob.getSubString(1L, 0));
1:     }
1: 
1:     public void testGetSubString_RequestZeroLength_PosTooBig()
1:             throws SQLException {
1:         try {
1:             this.clob.getSubString(999L, 0);
1:         } catch (SQLException sqle) {
0:             assertSQLState("XJ076", sqle);
1:         }
1:     }
1: 
1:     /**
1:      * Tests if big strings can be handled.
1:      * <p>
1:      * The motivation for the test is to make sure big buffers are filled with
1:      * the call to read inside a loop. Big in this sense means bigger than some
1:      * internal buffer. This is typically around 8 KB or so, but we try
1:      * something considerably bigger. If a char/byte array is attempted filled
1:      * with a single call to read, the resulting string wil typically contain
1:      * \u0000 at positions after the size of the internal buffer.
1:      */
1:     public void testGetSubString_BiggerThanInternalBuffer()
1:             throws IOException, SQLException {
1:         int stringLength = 1*1024*1024; // 1 M characters
1:         transferData(new LoopingAlphabetReader(stringLength),
1:                      this.clob.setCharacterStream(1L),
1:                      TRANSFER_BUFFER_SIZE);
1:         String obtained = this.clob.getSubString(1, stringLength);
1:         assertEquals("Incorrect string length",
1:             stringLength, obtained.length());
1:         // Obtain the string we inserted for comparison.
1:         CharArrayWriter charWriter = new CharArrayWriter();
1:         transferData(new LoopingAlphabetReader(stringLength), charWriter,
1:                                                TRANSFER_BUFFER_SIZE);
1:         assertEquals("String do not match",
1:             charWriter.toString(), obtained);
1:     }
1: 
1:     public void testLengthOnEmptyClob()
1:             throws SQLException {
1:         assertEquals(0, this.clob.length());
1:     }
1: 
1:     public void testInsertStringOnEmptyClob_Singlebyte()
1:             throws SQLException {
1:         String content = "This is the new Clob content.";
1:         this.clob.setString(1, content);
1:         assertEquals("Incorrect length reported",
1:             content.length(), this.clob.length());
1:         assertEquals("Clob content is incorrect",
1:             content, this.clob.getSubString(1, content.length()));
1:     }
1: 
1:     public void testInsertStringOnEmptyClob_Multibyte()
1:             throws SQLException {
1:         String content = "A few Norwegian letters: \u00e6, \u00e5, \u00f8.";
1:         this.clob.setString(1, content);
1:         assertEquals("Incorrect length reported",
1:             content.length(), this.clob.length());
1:         assertEquals("Clob content is incorrect",
1:             content, this.clob.getSubString(1, content.length()));
1:     }
1: 
1:     public void testInsertStringInMiddle_Multibyte()
1:             throws SQLException {
1:         // Add some content to work on first.
1:         this.clob.setString(1, NORWEGIAN_LETTERS);
1:         assertEquals(NORWEGIAN_LETTERS,
1:             this.clob.getSubString(1, NORWEGIAN_LETTERS.length()));
1: 
1:         // Replace a portion with single byte characters.
1:         char[] modifiedContent = NORWEGIAN_LETTERS.toCharArray();
1:         // Replace chars at 0-based indexes 4,5 and 8
1:         modifiedContent[4] = 'a';
1:         modifiedContent[5] = 'b';
1:         modifiedContent[8] = 'c';
1:         String newContent = String.copyValueOf(modifiedContent);
1:         // Do this in a "funny" order, or else it currently fails when running
1:         // with the client driver.
1:         assertEquals(1, this.clob.setString(9, "c"));
1:         assertEquals(1, this.clob.setString(5, "a"));
1:         assertEquals(1, this.clob.setString(6, "b"));
0:         if (BaseJDBCTestCase.usingEmbedded()) {
1:             assertEquals("Clob content is incorrect",
0:                 newContent, this.clob.getSubString(1, newContent.length()));
0:         } else {
0:             // Client currently truncates the Clob when inserting strings.
0:             // See DERBY-1286 and DERBY-2652.
1:             assertEquals("Clob content is incorrect",
0:                 newContent.substring(0, 6),
0:                 this.clob.getSubString(1, newContent.length()));
1:         }
1:     }
1: 
1:     public void testPositionWithString_ASCII_SimplePartialRecurringPattern()
1:             throws IOException, SQLException {
1:         String token = "xxSPOTxx";
1:         String inserted ="abcdexxSPxabcdexabxxSPxxxSPOTxabcxxSPOTxxabc";
1:         this.clob.setString(1L, inserted);
1:         assertEquals("Invalid match position",
1:             inserted.indexOf(token, 0) +1, this.clob.position(token, 1L));
1:     }
1: 
1:     public void testPositionWithString_USASCII()
1:             throws IOException, SQLException {
1:         String token = "xxSPOTxx";
1:         final long prefix = 91*1024 +7;
1:         final long postfix = 12*1024;
1:         insertDataWithToken(token, prefix, postfix, SET_ASCII_STREAM);
1:         executeTestPositionWithStringToken(token, prefix);
1:     }
1: 
1:     public void testPositionWithString_IOS88591()
1:             throws IOException, SQLException {
1:         String token = "xx\u00c6\u00c6\u00c6xx";
1:         final long prefix = 67*1024;
1:         final long postfix = 1*1024-2;
1:         insertDataWithToken(token, prefix, postfix, SET_ASCII_STREAM);
1:         executeTestPositionWithStringToken(token, prefix);
1:     }
1: 
1:     public void testPositionWithString_CJK()
1:             throws IOException, SQLException {
1:         final long prefix = 11L;
1:         final long postfix = 90L;
1:         char[] tmpChar = new char[1];
0:         LoopingAlphabetReader tokenSrc = 
1:             new LoopingAlphabetReader(1L, CharAlphabet.cjkSubset());
1:         tokenSrc.read(tmpChar);
1:         String token = String.copyValueOf(tmpChar);
1:         insertDataWithToken(token, prefix, postfix, SET_CHARACTER_STREAM);
1:         //insertDataWithToken(token, prefix, 2*1024-7, SET_CHARACTER_STREAM);
1:         executeTestPositionWithStringToken(token, prefix);
1:     }
1: 
0:     /* Test ideas
1:      *
1:      * truncate:
1:      *      truncate both on in store and from createClob
1:      *      truncate multiple times, check length and compare content
1:      *      truncate with negative size
1:      *      truncate with too big size
1:      *      truncate to 0
1:      *      truncate to current length
1:      */
1: 
1:     /**
1:      * Insert text into a Clob using {@link java.sql.Clob#setAsciiStream} and
1:      * then search for the specified token.
1:      * <p>
1:      * Some data is inserted before and after the token, and the specified token
1:      * is converted to bytes by using the ISO-8859-1 encoding.
1:      * Note that ascii in JDBC is equivalent to ISO-8859-1, not US-ASCII.
1:      */
1:     private void executeTestPositionWithStringToken(String token, long prefixLength)
1:             throws IOException, SQLException {
1: 
1:         final long TOKEN_POS = prefixLength +1;
1:         // Start searching behind the token.
1:         assertEquals(-1, this.clob.position(token, TOKEN_POS+1));
1:         // Start searching exactly at the right position.
1:         assertEquals(TOKEN_POS, this.clob.position(token, TOKEN_POS));
1:         // Start searching at the start of the Clob.
1:         assertEquals(TOKEN_POS, this.clob.position(token, 1L));
1:     }
1: 
1:     /**
1:      * Obtain a Clob containing the empty string.
1:      */
1:     protected void setUp()
1:             throws Exception {
1:         // Obtain a Clob containing the empty string ("").
0:         Statement stmt = createStatement();
1:         // Keep reference to the result set to be able to close it.
0:         this.rs = stmt.executeQuery("select * from ClobTestData");
0:         assertTrue(this.rs.next());
0:         this.clob = this.rs.getClob(1);
1:     }
1: 
1:     /**
0:      * Nullify reference to Clob, close the parent result set.
1:      */
1:     protected void tearDown()
1:             throws Exception {
1:         this.clob = null;
0:         this.rs.close();
1:         super.tearDown();
1:     }
1: 
1:     public static Test suite() {
1:         return new ClobTestSetup(
1:             TestConfiguration.defaultSuite(ClobTest.class, false));
1:     }
1: 
1:     /**
1:      * Transfer data from an input stream to an output stream.
1:      *
1:      * @param source source data
1:      * @param dest destination to write to
1:      * @param tz buffer size in number of bytes. Must be 1 or greater.
1:      * @return Number of bytes read from the source data. This should equal the
1:      *      number of bytes written to the destination.
1:      */
1:     private int transferData(InputStream source, OutputStream dest, int tz)
1:             throws IOException {
1:         if (tz < 1) {
1:             throw new IllegalArgumentException(
1:                 "Buffer size must be 1 or greater: " + tz);
1:         }
1:         BufferedInputStream in = new BufferedInputStream(source);
1:         BufferedOutputStream out = new BufferedOutputStream(dest, tz);
1:         byte[] bridge = new byte[tz];
1:         int total = 0;
1:         int read;
1:         while ((read = in.read(bridge, 0, tz)) != -1) {
1:             out.write(bridge, 0, read);
1:             total += read;
1:         }
1:         in.close();
1:         // Don't close the stream, in case it will be written to again.
1:         out.flush();
1:         return total;
1:     }
1: 
1:         /**
1:      * Transfer data from a source Reader to a destination Writer.
1:      *
1:      * @param source source data
1:      * @param dest destination to write to
1:      * @param tz buffer size in number of characters. Must be 1 or greater.
1:      * @return Number of characters read from the source data. This should equal the
1:      *      number of characters written to the destination.
1:      */
1:     private int transferData(Reader source, Writer dest, int tz)
1:             throws IOException {
1:         if (tz < 1) {
1:             throw new IllegalArgumentException(
1:                 "Buffer size must be 1 or greater: " + tz);
1:         }
1:         BufferedReader in = new BufferedReader(source);
1:         BufferedWriter out = new BufferedWriter(dest, tz);
1:         char[] bridge = new char[tz];
1:         int total = 0;
1:         int read;
1:         while ((read = in.read(bridge, 0, tz)) != -1) {
1:             out.write(bridge, 0, read);
1:             total += read;
1:         }
1:         in.close();
1:         // Don't close the stream, in case it will be written to again.
1:         out.flush();
1:         return total;
1:     }
1: 
1:     private int transferData(Reader source, int tz)
1:             throws IOException, SQLException {
1:         if (tz < 1) {
1:             throw new IllegalArgumentException(
1:                 "Buffer size must be 1 or greater: " + tz);
1:         }
1:         BufferedReader in = new BufferedReader(source);
1:         char[] bridge = new char[tz];
1:         int total = 0;
1:         int read;
1:         while ((read = in.read(bridge, 0, tz)) != -1) {
1:             this.clob.setString(total +1L, String.copyValueOf(bridge, 0, read));
1:             total += read;
1:         }
1:         in.close();
1:         return total;
1:     }
1: 
1:     private void insertDataWithToken(String token, 
1:                                      long pre, long post, int mode)
1:             throws IOException, SQLException {
0:         int TRANSFER_BUFFER_SIZE = 4*1024; // Byte and char array size.
1:         long total = 0;
1:         switch (mode) {
1:             case SET_STRING: {
1:                 Reader charIn = new LoopingAlphabetReader(pre);
1:                 total += transferData(charIn, TRANSFER_BUFFER_SIZE);
1:                 this.clob.setString(pre +1, token);
1:                 total += token.length();
1:                 charIn = new LoopingAlphabetReader(post);
1:                 total += transferData(charIn, TRANSFER_BUFFER_SIZE);
1:                 break;
1:             } case SET_ASCII_STREAM: {
1:                 OutputStream asciiOut = this.clob.setAsciiStream(1L);
1:                 InputStream asciiIn = new LoopingAlphabetStream(pre);
1:                 total += transferData(asciiIn, asciiOut, TRANSFER_BUFFER_SIZE);
1:                 byte[] tokenBytes = token.getBytes("ISO-8859-1");
1:                 asciiOut.write(tokenBytes, 0, tokenBytes.length);
1:                 total += tokenBytes.length;
1:                 asciiIn = new LoopingAlphabetStream(post);
1:                 total += transferData(asciiIn, asciiOut, TRANSFER_BUFFER_SIZE);
1:                 break;
1:             } case SET_CHARACTER_STREAM: {
1:                 Writer charOut = this.clob.setCharacterStream(1L);
1:                 Reader charIn = new LoopingAlphabetReader(pre);
1:                 total += transferData(charIn, charOut, TRANSFER_BUFFER_SIZE);
1:                 charOut.write(token);
1:                 total += token.length();
1:                 charIn = new LoopingAlphabetReader(post);
1:                 total += transferData(charIn, charOut, TRANSFER_BUFFER_SIZE);
1:                 break;
1:             } default:
1:                 throw new IllegalArgumentException(
1:                     "Unknown insertion mode: " + mode);
1:         }
1:         assertEquals("Invalid length after insertion",
1:             pre + post + token.length(), this.clob.length());
1:     }
1: 
1:     /**
1:      * Decorator creating the neccessary test data.
1:      */
1:     private static class ClobTestSetup extends BaseJDBCTestSetup {
1: 
1:         ClobTestSetup(Test test) {
1:             super(test);
1:         }
1: 
1:         protected void setUp() throws SQLException {
1:             Connection con = getConnection();
1:             Statement stmt = con.createStatement();
1:             stmt.execute("create table ClobTestData (" +
0:                     "dClob CLOB)");
0:             stmt.executeUpdate("insert into ClobTestData values ('')");
1:             stmt.close();
1:        }
1: 
1:         protected void tearDown()
1:                 throws Exception {
1:             Connection con = getConnection();
1:             Statement stmt = con.createStatement();
1:             stmt.execute("drop table ClobTestData");
1:             stmt.close();
1:             super.tearDown();
1:         }
1:     } // End inner class ClobTestSetup
1: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:1e5b2aa
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Test setString() refuses wrong offset. 
1:      */
1:     public void testSetStringOnWrongOffset() throws SQLException {
1:         clob.setString(1, "TEST");
1:         long upperLimit = clob.length() + 1;
1:         String str = "AGAIN";
1:         
1:         try {
1:             clob.setString(upperLimit, str, -1, 2);
1:             fail("setString() refuses negative offset!");
1:         } catch (SQLException e) {
1:             assertSQLState("XJ078", e);
1:         }
1:         
1:         try {
1:             clob.setString(upperLimit, str, str.length() + 1, 1);
1:             fail("setString() refuses offset greater than str.length()!");
1:         } catch (SQLException e) {
1:             assertSQLState("XJ078", e);
1:         }
1:         
1:         //if (offset + len) == str.length(), it's accepted.
1:         clob.setString(upperLimit, str, str.length() - 1, 1);
1:         
1:         try {
1:             clob.setString(upperLimit, str, str.length(), 0);
1:             fail("offset should be smaller than the length of str");
1:         } catch (SQLException e) {
1:             assertSQLState("XJ078", e);
1:         }
1:         
1:         try {
1:             clob.setString(upperLimit, str, str.length() - 1, 2);
1:             fail("setString() refuses offset + len > str.length()!");
1:         } catch (SQLException e) {
1:             assertSQLState("22011", e);
1:         }
1:     }
1:     
1:     /**
1:      * Test setString() refuses wrong len. 
1:      */
1:     public void testSetStringWithWrongLen() throws SQLException {
1:         clob.setString(1, "TEST");
1:         long upperLimit = clob.length() + 1;
1:         String str = "AGAIN";
1:         
1:         try {
1:             clob.setString(upperLimit, str, 0, -1);
1:             fail("setString() refuses negative len!");
1:         } catch (SQLException e) {
1:             assertSQLState("XJ071", e);
1:         }
1:         
1:         try {
1:             clob.setString(upperLimit, str, 0, str.length() + 1);
1:             fail("setString() refuses wrong len out of range!");
1:         } catch (SQLException e) {
1:             assertSQLState("22011", e);
1:         }
1:     }
1:     
1:     /**
1:      * Test setString() refuses pos bigger than clob.length() + 1.
1:      */
1:     public void testSetStringWithBigPos() throws SQLException {
1:         clob.setString(1, "TEST");
1:         long upperLimit = clob.length() + 1;
1:         
1:         try {
1:             clob.setString(upperLimit + 1, "AGAIN", 0, 2);
1:             fail("pos is out of range!");
1:         } catch (SQLException e) {
1:             assertSQLState("XJ076", e);
1:         }
1:     }
1:     
1:     /**
1:      * Test setStrinng() refuses a Null String.
1:      */
1:     public void testSetStringWithNull() throws SQLException {
1:         clob.setString(1, "TEST");
1:         long upperLimit = clob.length() + 1;
1:         
1:         try {
1:             clob.setString(upperLimit, null, 0, 2);
1:             fail("can not accepted null String!");
1:         } catch (SQLException e) {
1:             assertSQLState("XJ072", e);
1:         }
1:     }
1:     
1:     /**
1:      * Test setString() accepts a empty String, and just return 0.
1:      */
1:     public void testSetStringWithEmptyString() throws SQLException {
1:         clob.setString(1, "TEST");
1:         long upperLimit = clob.length() + 1;              
1:         assertEquals(0, clob.setString(upperLimit, "", 0, 0));           
1:     }
============================================================================