1:3bfb5f0: /*
1:3bfb5f0:  
1:3bfb5f0:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.DataSourceTest
1:3bfb5f0: 
1:6e3dbab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6e3dbab:    contributor license agreements.  See the NOTICE file distributed with
1:6e3dbab:    this work for additional information regarding copyright ownership.
1:6e3dbab:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6e3dbab:    (the "License"); you may not use this file except in compliance with
1:6e3dbab:    the License.  You may obtain a copy of the License at
1:3bfb5f0:  
1:3bfb5f0:       http://www.apache.org/licenses/LICENSE-2.0
1:3bfb5f0:  
1:3bfb5f0:    Unless required by applicable law or agreed to in writing, software
1:3bfb5f0:    distributed under the License is distributed on an "AS IS" BASIS,
1:3bfb5f0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:3bfb5f0:    See the License for the specific language governing permissions and
1:3bfb5f0:    limitations under the License.
1:3bfb5f0:  
2:3bfb5f0:  */
1:3bfb5f0: 
1:3bfb5f0: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:3bfb5f0: 
1:1ae02c9: import java.sql.Connection;
1:1ae02c9: import java.sql.ResultSet;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.SQLFeatureNotSupportedException;
1:1ae02c9: import javax.sql.CommonDataSource;
1:1ae02c9: import javax.sql.ConnectionPoolDataSource;
1:1ae02c9: import javax.sql.DataSource;
1:1ae02c9: import javax.sql.PooledConnection;
1:1ae02c9: import javax.sql.XADataSource;
1:1ae02c9: import junit.framework.Test;
1:836fc7b: import org.apache.derbyTesting.functionTests.tests.jdbcapi.AssertEventCatcher;
1:3bd1dd8: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1bd559b: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:e5ddb68: import org.apache.derbyTesting.junit.J2EEDataSource;
1:8ed08b2: import org.apache.derbyTesting.junit.JDBCDataSource;
1:ec5ae26: import org.apache.derbyTesting.junit.TestConfiguration;
1:3bfb5f0: 
2:3bfb5f0: /**
1:3bfb5f0:  * Tests of the <code>javax.sql.DataSource</code> JDBC40 API.
1:3bfb5f0:  */
1:3bfb5f0: 
1:3bfb5f0: public class DataSourceTest extends BaseJDBCTestCase {
1:3bfb5f0:     
1:3bfb5f0:     //Default DataSource that will be used by the tests
1:3bfb5f0:     private DataSource ds = null;
1:3bfb5f0:     
1:3bfb5f0:     /**
5:3bfb5f0:      *
1:3bfb5f0:      * Create a test with the given name.
1:3bfb5f0:      *
1:3bfb5f0:      * @param name name of the test.
1:3bfb5f0:      *
1:3bfb5f0:      */
1:3bfb5f0:     public DataSourceTest(String name) {
1:3bfb5f0:         super(name);
1:3bfb5f0:     }
1:3bfb5f0:     
1:3bfb5f0:     /**
1:3bfb5f0:      * Create a default DataSource
1:3bfb5f0:      */
1:3bfb5f0:     public void setUp() {
1:8ed08b2:         ds = JDBCDataSource.getDataSource();
1:3bfb5f0:     }
1:3bfb5f0:     
1:3bfb5f0:     /**
1:3bfb5f0:      * 
1:3bfb5f0:      * Initialize the ds to null once the tests that need to be run have been 
1:3bfb5f0:      * run
1:3bfb5f0:      */
1:9b52936:     public void tearDown() throws Exception {
1:3bfb5f0:         ds = null;
1:9b52936:         super.tearDown();
1:3bfb5f0:     }
1:3bfb5f0: 
1:f631317:     public void testIsWrapperForDataSource() throws SQLException {
1:f631317:         assertTrue(ds.isWrapperFor(DataSource.class));
1:836fc7b:     }
1:3bfb5f0: 
1:f631317:     public void testIsNotWrapperForPoolDataSource() throws SQLException {
1:f631317:         assertFalse(ds.isWrapperFor(ConnectionPoolDataSource.class));
1:836fc7b:     }
1:3bfb5f0: 
1:f631317:     public void testIsNotWrapperForXADataSource() throws SQLException {
1:f631317:         assertFalse(ds.isWrapperFor(XADataSource.class));
1:836fc7b:     }
1:3bfb5f0: 
1:f631317:     public void testIsNotWrapperForResultSet() throws SQLException {
1:f631317:         assertFalse(ds.isWrapperFor(ResultSet.class));
1:836fc7b:     }
1:3bfb5f0: 
1:f631317:     public void testUnwrapDataSource() throws SQLException {
1:f631317:         DataSource ds2 = ds.unwrap(DataSource.class);
1:f631317:         assertSame("Unwrap returned wrong object.", ds, ds2);
7:f631317:     }
1:836fc7b: 
1:f631317:     public void testUnwrapConnectionPoolDataSource() {
1:3bfb5f0:         try {
1:f631317:             ConnectionPoolDataSource cpds =
1:f631317:                 ds.unwrap(ConnectionPoolDataSource.class);
1:f631317:             fail("Unwrap didn't fail.");
1:f631317:         } catch (SQLException e) {
1:f631317:             assertSQLState("XJ128", e);
1:3bfb5f0:         }
1:3bfb5f0:     }
1:3bfb5f0: 
1:f631317:     public void testUnwrapXADataSource() {
1:3bfb5f0:         try {
1:f631317:             XADataSource xads = ds.unwrap(XADataSource.class);
1:f631317:             fail("Unwrap didn't fail.");
1:f631317:         } catch (SQLException e) {
1:f631317:             assertSQLState("XJ128", e);
1:3bfb5f0:         }
1:3bfb5f0:     }
1:3bfb5f0: 
1:f631317:     public void testUnwrapResultSet() {
1:836fc7b:         try {
1:f631317:             ResultSet rs = ds.unwrap(ResultSet.class);
1:f631317:             fail("Unwrap didn't fail.");
1:f631317:         } catch (SQLException e) {
1:f631317:             assertSQLState("XJ128", e);
1:3bfb5f0:         }
1:3bfb5f0:     }
1:3bfb5f0:     
1:3bfb5f0:     /**
1:836fc7b:      * Test case for DERBY-3172
1:836fc7b:      * When the Derby engine is shutdown or Network Server is brought down, any
1:836fc7b:      * api on JDBC Connection object should generate a Connection error event.
1:3bfb5f0:      */
1:836fc7b:     public void testConnectionErrorEvent() throws SQLException, Exception
3:836fc7b:     {
1:836fc7b:         AssertEventCatcher aes12 = new AssertEventCatcher(12);
1:836fc7b:         //Get the correct ConnectionPoolDataSource object
1:e5ddb68:         ConnectionPoolDataSource ds = J2EEDataSource.getConnectionPoolDataSource();
1:e5ddb68: 
1:e5ddb68:         PooledConnection pc = ds.getPooledConnection();
1:836fc7b:         //Add a connection event listener to ConnectionPoolDataSource
1:836fc7b:         pc.addConnectionEventListener(aes12);
1:e5ddb68:         Connection conn = pc.getConnection();
1:e5ddb68:         
1:e5ddb68:         dropTable(conn, "TAB1");
1:e5ddb68: 
1:836fc7b:         //No event should have been generated at this point
1:836fc7b:         assertFalse(aes12.didConnectionClosedEventHappen());
1:836fc7b:         assertFalse(aes12.didConnectionErrorEventHappen());
2:836fc7b:         aes12.resetState();
1:836fc7b:         //Shutdown the Derby engine or Network Server depending on what 
1:836fc7b:         //mode we are running in.
2:836fc7b:         if (usingEmbedded())
1:836fc7b:         {
1:836fc7b:         	getTestConfiguration().shutdownDatabase();
2:836fc7b:         } else
1:836fc7b:         {
1:836fc7b:         	getTestConfiguration().stopNetworkServer();
1:3bfb5f0:         }
1:836fc7b:         //Now try to use various apis on the JDBC Connection object created 
1:836fc7b:         //before shutdown and they all should generate connection error event.
1:836fc7b:         try {
1:836fc7b:             conn.createArrayOf("junk", null);
1:836fc7b:         } catch (SQLException e) {
1:836fc7b:             assertSQLState("0A000", e);
1:3bfb5f0:         }
1:836fc7b:         try {
1:836fc7b:             conn.createNClob();
1:836fc7b:         } catch (SQLException e) {
1:836fc7b:             assertSQLState("0A000", e);
1:836fc7b:         }
1:836fc7b:         try {
1:836fc7b:             conn.createSQLXML();
1:836fc7b:         } catch (SQLException e) {
1:836fc7b:             assertSQLState("0A000", e);
1:836fc7b:         }
1:836fc7b:         try {
1:836fc7b:             conn.createStruct("junk", null);
1:836fc7b:         } catch (SQLException e) {
1:836fc7b:             assertSQLState("0A000", e);
1:836fc7b:         }
1:836fc7b:         try {
1:836fc7b:             conn.createBlob();
1:836fc7b:         } catch (SQLException e) {
1:836fc7b:             //The first call on JDBC Connection object after Network Server
1:836fc7b:             //shutdown will generate a communication error and that's why we
1:836fc7b:             //are checking for SQL State 08006 rather than No current connection
1:836fc7b:             //SQL State 08003. In embedded mode, we will get SQL State 08003
1:836fc7b:         	//meaning No current connection
1:836fc7b:             if (usingEmbedded())
1:836fc7b:                 assertSQLState("08003", e);
1:836fc7b:             else
1:836fc7b:                 assertSQLState("08006", e);
1:836fc7b:         }
1:836fc7b:         assertFalse(aes12.didConnectionClosedEventHappen());
1:836fc7b:         assertTrue(aes12.didConnectionErrorEventHappen());
1:836fc7b:         aes12.resetState();        	
1:836fc7b:         try {
1:836fc7b:             conn.createClob();
1:836fc7b:         } catch (SQLException e) {
1:836fc7b:                 assertSQLState("08003", e);
1:836fc7b:         }
1:836fc7b:         assertFalse(aes12.didConnectionClosedEventHappen());
1:836fc7b:         assertTrue(aes12.didConnectionErrorEventHappen());
1:836fc7b:         aes12.resetState();        	
1:836fc7b:         try {
1:836fc7b:             conn.getClientInfo();
1:836fc7b:         } catch (SQLException e) {
1:836fc7b:                 assertSQLState("08003", e);
1:836fc7b:         }
1:836fc7b:         assertFalse(aes12.didConnectionClosedEventHappen());
1:836fc7b:         assertTrue(aes12.didConnectionErrorEventHappen());
1:836fc7b:         aes12.resetState();        	
1:836fc7b:         try {
1:836fc7b:             conn.getClientInfo("junk");
1:836fc7b:         } catch (SQLException e) {
1:836fc7b:                 assertSQLState("08003", e);
1:836fc7b:         }
1:836fc7b:         assertFalse(aes12.didConnectionClosedEventHappen());
1:836fc7b:         assertTrue(aes12.didConnectionErrorEventHappen());
1:836fc7b:         aes12.resetState();        	
1:836fc7b:         try {
1:836fc7b:             conn.setClientInfo(null);
1:836fc7b:         } catch (SQLException e) {
1:836fc7b:                 assertSQLState("08003", e);
1:836fc7b:         }
1:836fc7b:         assertFalse(aes12.didConnectionClosedEventHappen());
1:836fc7b:         assertTrue(aes12.didConnectionErrorEventHappen());
1:836fc7b:         aes12.resetState();        	
1:836fc7b:         try {
1:836fc7b:             conn.setClientInfo("junk1", "junk2");
1:836fc7b:         } catch (SQLException e) {
1:836fc7b:                 assertSQLState("08003", e);
1:836fc7b:         }
1:836fc7b:         assertFalse(aes12.didConnectionClosedEventHappen());
1:836fc7b:         assertTrue(aes12.didConnectionErrorEventHappen());
1:836fc7b:         aes12.resetState();        	
1:836fc7b:         try {
1:836fc7b:             conn.isWrapperFor(this.getClass());
1:836fc7b:         } catch (SQLException e) {
1:836fc7b:                 assertSQLState("08003", e);
1:836fc7b:         }
1:836fc7b:         assertFalse(aes12.didConnectionClosedEventHappen());
1:836fc7b:         if (usingEmbedded())
1:836fc7b:         	assertTrue(aes12.didConnectionErrorEventHappen());
1:836fc7b:         else
1:836fc7b:         	//We do not make any call on underneath JDBC Connection
1:836fc7b:         	//object for isWrapperFor and hence never get Connection
1:836fc7b:         	//Error event
1:836fc7b:         	assertFalse(aes12.didConnectionErrorEventHappen());
1:836fc7b:         aes12.resetState();        	
1:836fc7b:         try {
1:836fc7b:             conn.unwrap(this.getClass());
1:836fc7b:         } catch (SQLException e) {
1:836fc7b:             if (usingEmbedded())
1:836fc7b:                 assertSQLState("08003", e);
1:836fc7b:             else
1:836fc7b:             	//We do not make any call on underneath JDBC Connection
1:836fc7b:             	//object for unwrap and hence never get Connection
1:836fc7b:             	//closed exception. Instead we got exception because
1:836fc7b:             	//client driver code is trying to unwrap this.getClass
1:836fc7b:             	//and it can't do that
1:836fc7b:                 assertSQLState("XJ128", e);
1:836fc7b:         }
1:836fc7b:     	assertFalse(aes12.didConnectionClosedEventHappen());
1:836fc7b:         if (usingEmbedded())
1:836fc7b:         	assertTrue(aes12.didConnectionErrorEventHappen());
1:836fc7b:         else
1:836fc7b:         	//We do not make any call on underneath JDBC Connection
1:836fc7b:         	//object for isWrapperFor and hence never get Connection
1:836fc7b:         	//Error event
1:836fc7b:         	assertFalse(aes12.didConnectionErrorEventHappen());
1:836fc7b:         aes12.resetState();        	
1:836fc7b:         try {
1:836fc7b:             conn.isValid(5);
1:836fc7b:         } catch (SQLException e) {
1:836fc7b:             assertSQLState("08003", e);
1:836fc7b:         }
1:836fc7b:         if (usingEmbedded())
1:836fc7b:         	assertTrue(aes12.didConnectionClosedEventHappen());
1:836fc7b:         else
1:836fc7b:         	assertFalse(aes12.didConnectionClosedEventHappen());
1:836fc7b:     	//As per the JDBC definition, an exception and hence an event is raised
1:836fc7b:     	//for isValid only if the param value is illegal
1:836fc7b:     	assertFalse(aes12.didConnectionErrorEventHappen());
1:4469400:         aes12.resetState();
1:4469400:         Class<?> clazz;
1:836fc7b:         if (usingEmbedded())
1:836fc7b:         {
1:4469400:             clazz = Class.forName("org.apache.derby.jdbc.EmbeddedDriver");
1:4469400:             clazz.getConstructor().newInstance();
1:836fc7b:         }else
1:836fc7b:         {
1:836fc7b:         	getTestConfiguration().startNetworkServer();
1:836fc7b:         }
1:836fc7b: 
1:836fc7b:         // Get a new connection to the database
1:836fc7b:         conn = getConnection();
1:836fc7b:         conn.close();
1:836fc7b:     }
1:836fc7b: 
1:3bfb5f0:     /**
1:09869c6:      * <p>
1:09869c6:      * Test the new method added by JDBC 4.1.
1:09869c6:      * </p>
1:09869c6:      */
1:09869c6:     public void test_jdbc4_1() throws Exception
1:09869c6:     {
1:09869c6:         DataSource  ds = JDBCDataSource.getDataSource();
1:09869c6:         ConnectionPoolDataSource cpds = J2EEDataSource.getConnectionPoolDataSource();
1:09869c6:         XADataSource xads = J2EEDataSource.getXADataSource();
1:09869c6: 
1:09869c6:         vetDSjdbc4_1( ds );
1:09869c6:         vetDSjdbc4_1( cpds );
1:09869c6:         vetDSjdbc4_1( xads );
1:09869c6:     }
1:09869c6:     private void    vetDSjdbc4_1( CommonDataSource cds ) throws Exception
1:09869c6:     {
1:09869c6:         println( "Vetting a " + cds.getClass().getName() );
1:09869c6: 
1:09869c6:         Wrapper41DataSource wrapper = new Wrapper41DataSource( cds );
1:09869c6:         
1:09869c6:         try {
1:09869c6:             wrapper.getParentLogger();
1:09869c6:             fail( "Should raise an Unimplemented Feature exception." );
1:09869c6:         }
1:09869c6:         catch (SQLException se)
1:09869c6:         {
1:09869c6:             assertEquals( SQLFeatureNotSupportedException.class.getName(), se.getClass().getName() );
1:09869c6:         }
1:09869c6:     }
1:09869c6: 
1:09869c6: 
1:09869c6:     /**
1:3bfb5f0:      * Return suite with all tests of the class.
1:3bfb5f0:      */
1:3bfb5f0:     public static Test suite() {
1:1bd559b:         // Use explicit ordering of fixtures until fix of DERBY-5988
1:1ae02c9:         BaseTestSuite s = new BaseTestSuite("datasourcetestsuite-embedded");
1:1bd559b:         s.addTest(new DataSourceTest("testIsNotWrapperForPoolDataSource"));
1:1bd559b:         s.addTest(new DataSourceTest("testIsNotWrapperForXADataSource"));
1:1bd559b:         s.addTest(new DataSourceTest("testUnwrapConnectionPoolDataSource"));
1:1bd559b:         s.addTest(new DataSourceTest("testIsWrapperForDataSource"));
1:1bd559b:         s.addTest(new DataSourceTest("testIsNotWrapperForResultSet"));
1:1bd559b:         s.addTest(new DataSourceTest("testUnwrapXADataSource"));
1:1bd559b:         s.addTest(new DataSourceTest("testConnectionErrorEvent"));
1:1bd559b:         s.addTest(new DataSourceTest("testUnwrapResultSet"));
1:1bd559b:         s.addTest(new DataSourceTest("testUnwrapDataSource"));
1:1bd559b:         s.addTest(new DataSourceTest("test_jdbc4_1"));
1:1ae02c9:         BaseTestSuite ns = new BaseTestSuite("datasourcetestsuite-net");
1:1bd559b:         ns.addTest(new DataSourceTest("testIsNotWrapperForPoolDataSource"));
1:1bd559b:         ns.addTest(new DataSourceTest("testIsNotWrapperForXADataSource"));
1:1bd559b:         ns.addTest(new DataSourceTest("testUnwrapConnectionPoolDataSource"));
1:1bd559b:         ns.addTest(new DataSourceTest("testIsWrapperForDataSource"));
1:1bd559b:         ns.addTest(new DataSourceTest("testIsNotWrapperForResultSet"));
1:1bd559b:         ns.addTest(new DataSourceTest("testUnwrapXADataSource"));
1:1bd559b:         ns.addTest(new DataSourceTest("testConnectionErrorEvent"));
1:1bd559b:         ns.addTest(new DataSourceTest("testUnwrapResultSet"));
1:1bd559b:         ns.addTest(new DataSourceTest("testUnwrapDataSource"));
1:1bd559b:         ns.addTest(new DataSourceTest("test_jdbc4_1"));
1:1bd559b: 
1:1ae02c9:         BaseTestSuite totalsuite = new BaseTestSuite("datasourcetest");
1:1bd559b:         totalsuite.addTest(new CleanDatabaseTestSetup(s));
1:1bd559b:         totalsuite.addTest(TestConfiguration.clientServerDecorator(
1:1bd559b:                                new CleanDatabaseTestSetup(ns)));
1:1bd559b:         return totalsuite;
1:3bfb5f0:     }
1:3bfb5f0: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:         aes12.resetState();
1:         Class<?> clazz;
1:             clazz = Class.forName("org.apache.derby.jdbc.EmbeddedDriver");
1:             clazz.getConstructor().newInstance();
commit:09869c6
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * Test the new method added by JDBC 4.1.
1:      * </p>
1:      */
1:     public void test_jdbc4_1() throws Exception
1:     {
1:         DataSource  ds = JDBCDataSource.getDataSource();
1:         ConnectionPoolDataSource cpds = J2EEDataSource.getConnectionPoolDataSource();
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1: 
1:         vetDSjdbc4_1( ds );
1:         vetDSjdbc4_1( cpds );
1:         vetDSjdbc4_1( xads );
1:     }
1:     private void    vetDSjdbc4_1( CommonDataSource cds ) throws Exception
1:     {
1:         println( "Vetting a " + cds.getClass().getName() );
1: 
1:         Wrapper41DataSource wrapper = new Wrapper41DataSource( cds );
1:         
1:         try {
1:             wrapper.getParentLogger();
1:             fail( "Should raise an Unimplemented Feature exception." );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertEquals( SQLFeatureNotSupportedException.class.getName(), se.getClass().getName() );
1:         }
1:     }
1: 
1: 
1:     /**
commit:6e3dbab
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:3bfb5f0
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.DataSourceTest
1: 
0:    Copyright 2006 The Apache Software Foundation or its licensors, as applicable.
1:  
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1:  
1:       http://www.apache.org/licenses/LICENSE-2.0
1:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1:  
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1: 
0: import junit.framework.*;
1: 
0: import org.apache.derbyTesting.functionTests.util.BaseJDBCTestCase;
0: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
1: 
0: import java.sql.*;
0: import javax.sql.*;
1: 
1: /**
1:  * Tests of the <code>javax.sql.DataSource</code> JDBC40 API.
1:  */
1: 
1: public class DataSourceTest extends BaseJDBCTestCase {
1:     
1:     //Default DataSource that will be used by the tests
1:     private DataSource ds = null;
1:     
1:     /**
1:      *
1:      * Create a test with the given name.
1:      *
1:      * @param name name of the test.
1:      *
1:      */
1:     public DataSourceTest(String name) {
1:         super(name);
1:     }
1:     
1:     /**
1:      * Create a default DataSource
1:      */
1:     public void setUp() {
0:         ds = getDataSource();
1:     }
1:     
1:     /**
1:      * 
1:      * Initialize the ds to null once the tests that need to be run have been 
1:      * run
1:      */
0:     public void tearDown() {
1:         ds = null;
1:     }
1:     
1:     /**
1:      *
0:      * Tests the wrapper methods isWrapperFor and unwrap. Test
0:      * for the case when isWrapperFor returns true and we call unwrap
0:      * The test is right now being run in the embedded case only
1:      *
1:      */
0:     public void testisWrapperReturnsTrue() throws SQLException {
0:         Class<DataSource> wrap_class = DataSource.class;
1:         
0:         //The if should return true enabling us  to call the unwrap method
0:         //without throwing  an exception
0:         if(ds.isWrapperFor(wrap_class)) {
1:             try {
0:                 DataSource stmt1 =
0:                         (DataSource)ds.unwrap(wrap_class);
1:             }
0:             catch(SQLException sqle) {
0:                 fail("Unwrap wrongly throws a SQLException");
1:             }
0:         } else {
0:             fail("isWrapperFor wrongly returns false");
1:         }
1:     }
1:     
1:     /**
1:      *
0:      * Tests the wrapper methods isWrapperFor and unwrap. Test
0:      * for the case when isWrapperFor returns false and we call unwrap
0:      * The test is right now being run in the embedded case only
1:      *
1:      */
0:     public void testisWrapperReturnsFalse() throws SQLException {
0:         Class<ResultSet> wrap_class = ResultSet.class;
1:         
0:         //returning false is the correct behaviour in this case
0:         //Generate a message if it returns true
0:         if(ds.isWrapperFor(wrap_class)) {
0:             fail("isWrapperFor wrongly returns true");
0:         } else {
1:             try {
0:                 ResultSet rs1 = (ResultSet)
0:                 ds.unwrap(wrap_class);
0:                 fail("unwrap does not throw the expected " +
0:                         "exception");
0:             } catch (SQLException sqle) {
0:                 //calling unwrap in this case throws an SQLException
0:                 //check that this SQLException has the correct SQLState
0:                 if(!SQLStateConstants.UNABLE_TO_UNWRAP.equals(sqle.getSQLState())) {
0:                     throw sqle;
1:                 }
1:             }
1:         }
1:     }
1:     
1:     /**
1:      * Return suite with all tests of the class.
1:      */
1:     public static Test suite() {
0:         return (new TestSuite(DataSourceTest.class,
0:                               "DataSourceTest suite"));
1:     }
1: }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.SQLFeatureNotSupportedException;
1: import javax.sql.CommonDataSource;
1: import javax.sql.ConnectionPoolDataSource;
1: import javax.sql.DataSource;
1: import javax.sql.PooledConnection;
1: import javax.sql.XADataSource;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite s = new BaseTestSuite("datasourcetestsuite-embedded");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite ns = new BaseTestSuite("datasourcetestsuite-net");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite totalsuite = new BaseTestSuite("datasourcetest");
commit:1bd559b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
/////////////////////////////////////////////////////////////////////////
1:         // Use explicit ordering of fixtures until fix of DERBY-5988
0:         TestSuite s = new TestSuite("datasourcetestsuite-embedded");
1:         s.addTest(new DataSourceTest("testIsNotWrapperForPoolDataSource"));
1:         s.addTest(new DataSourceTest("testIsNotWrapperForXADataSource"));
1:         s.addTest(new DataSourceTest("testUnwrapConnectionPoolDataSource"));
1:         s.addTest(new DataSourceTest("testIsWrapperForDataSource"));
1:         s.addTest(new DataSourceTest("testIsNotWrapperForResultSet"));
1:         s.addTest(new DataSourceTest("testUnwrapXADataSource"));
1:         s.addTest(new DataSourceTest("testConnectionErrorEvent"));
1:         s.addTest(new DataSourceTest("testUnwrapResultSet"));
1:         s.addTest(new DataSourceTest("testUnwrapDataSource"));
1:         s.addTest(new DataSourceTest("test_jdbc4_1"));
0:         TestSuite ns = new TestSuite("datasourcetestsuite-net");
1:         ns.addTest(new DataSourceTest("testIsNotWrapperForPoolDataSource"));
1:         ns.addTest(new DataSourceTest("testIsNotWrapperForXADataSource"));
1:         ns.addTest(new DataSourceTest("testUnwrapConnectionPoolDataSource"));
1:         ns.addTest(new DataSourceTest("testIsWrapperForDataSource"));
1:         ns.addTest(new DataSourceTest("testIsNotWrapperForResultSet"));
1:         ns.addTest(new DataSourceTest("testUnwrapXADataSource"));
1:         ns.addTest(new DataSourceTest("testConnectionErrorEvent"));
1:         ns.addTest(new DataSourceTest("testUnwrapResultSet"));
1:         ns.addTest(new DataSourceTest("testUnwrapDataSource"));
1:         ns.addTest(new DataSourceTest("test_jdbc4_1"));
1: 
0:         TestSuite totalsuite = new TestSuite("datasourcetest");
1:         totalsuite.addTest(new CleanDatabaseTestSetup(s));
1:         totalsuite.addTest(TestConfiguration.clientServerDecorator(
1:                                new CleanDatabaseTestSetup(ns)));
1:         return totalsuite;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:e5ddb68
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.J2EEDataSource;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         ConnectionPoolDataSource ds = J2EEDataSource.getConnectionPoolDataSource();
1: 
1:         PooledConnection pc = ds.getPooledConnection();
1:         Connection conn = pc.getConnection();
1:         
1:         dropTable(conn, "TAB1");
1: 
commit:8ed08b2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBCDataSource;
/////////////////////////////////////////////////////////////////////////
1:         ds = JDBCDataSource.getDataSource();
/////////////////////////////////////////////////////////////////////////
0:         return TestConfiguration.defaultSuite(DataSourceTest.class);
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:836fc7b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.jdbc.ClientConnectionPoolDataSource;
0: import org.apache.derby.jdbc.EmbeddedConnectionPoolDataSource;
1: import org.apache.derbyTesting.functionTests.tests.jdbcapi.AssertEventCatcher;
0: import org.apache.derbyTesting.junit.JDBC;
1: 
/////////////////////////////////////////////////////////////////////////
0:     protected static String dbName = 
0:         TestConfiguration.getCurrent().getDefaultDatabaseName();
/////////////////////////////////////////////////////////////////////////
1:     
0:     /**
1:      * Test case for DERBY-3172
1:      * When the Derby engine is shutdown or Network Server is brought down, any
1:      * api on JDBC Connection object should generate a Connection error event.
0:      */
1:     public void testConnectionErrorEvent() throws SQLException, Exception
1:     {
0:     	Connection conn;
0:     	ConnectionPoolDataSource ds;
0:     	PooledConnection pc;
0:     	Statement st;
1:         AssertEventCatcher aes12 = new AssertEventCatcher(12);
1:         //Get the correct ConnectionPoolDataSource object
1:         if (usingEmbedded())
1:         {
0:         	ds = new EmbeddedConnectionPoolDataSource();
0:             ((EmbeddedConnectionPoolDataSource)ds).setDatabaseName(dbName);
1:         } else
1:         {
0:             ds = new ClientConnectionPoolDataSource();
0:             ((ClientConnectionPoolDataSource)ds).setDatabaseName(dbName);
1:         }
0:         pc = ds.getPooledConnection();
1:         //Add a connection event listener to ConnectionPoolDataSource
1:         pc.addConnectionEventListener(aes12);
0:         conn = pc.getConnection();
0:         st = conn.createStatement();
0:         //TAB1 does not exist and hence catch the expected exception
1:         try {
0:             st.executeUpdate("drop table TAB1");
0:         } catch (SQLException sqle) {
0:             assertSQLState("42Y55", sqle);
1:         }
1:         //No event should have been generated at this point
1:         assertFalse(aes12.didConnectionClosedEventHappen());
1:         assertFalse(aes12.didConnectionErrorEventHappen());
1:         aes12.resetState();
1:         //Shutdown the Derby engine or Network Server depending on what 
1:         //mode we are running in.
1:         if (usingEmbedded())
1:         {
1:         	getTestConfiguration().shutdownDatabase();
1:         } else
1:         {
1:         	getTestConfiguration().stopNetworkServer();
1:         }
1:         //Now try to use various apis on the JDBC Connection object created 
1:         //before shutdown and they all should generate connection error event.
1:         try {
1:             conn.createArrayOf("junk", null);
1:         } catch (SQLException e) {
1:             assertSQLState("0A000", e);
1:         }
1:         try {
1:             conn.createNClob();
1:         } catch (SQLException e) {
1:             assertSQLState("0A000", e);
1:         }
1:         try {
1:             conn.createSQLXML();
1:         } catch (SQLException e) {
1:             assertSQLState("0A000", e);
1:         }
1:         try {
1:             conn.createStruct("junk", null);
1:         } catch (SQLException e) {
1:             assertSQLState("0A000", e);
1:         }
1:         try {
1:             conn.createBlob();
1:         } catch (SQLException e) {
1:             //The first call on JDBC Connection object after Network Server
1:             //shutdown will generate a communication error and that's why we
1:             //are checking for SQL State 08006 rather than No current connection
1:             //SQL State 08003. In embedded mode, we will get SQL State 08003
1:         	//meaning No current connection
1:             if (usingEmbedded())
1:                 assertSQLState("08003", e);
1:             else
1:                 assertSQLState("08006", e);
1:         }
1:         assertFalse(aes12.didConnectionClosedEventHappen());
1:         assertTrue(aes12.didConnectionErrorEventHappen());
1:         aes12.resetState();        	
1:         try {
1:             conn.createClob();
1:         } catch (SQLException e) {
1:                 assertSQLState("08003", e);
1:         }
1:         assertFalse(aes12.didConnectionClosedEventHappen());
1:         assertTrue(aes12.didConnectionErrorEventHappen());
1:         aes12.resetState();        	
1:         try {
1:             conn.getClientInfo();
1:         } catch (SQLException e) {
1:                 assertSQLState("08003", e);
1:         }
1:         assertFalse(aes12.didConnectionClosedEventHappen());
1:         assertTrue(aes12.didConnectionErrorEventHappen());
1:         aes12.resetState();        	
1:         try {
1:             conn.getClientInfo("junk");
1:         } catch (SQLException e) {
1:                 assertSQLState("08003", e);
1:         }
1:         assertFalse(aes12.didConnectionClosedEventHappen());
1:         assertTrue(aes12.didConnectionErrorEventHappen());
1:         aes12.resetState();        	
1:         try {
1:             conn.setClientInfo(null);
1:         } catch (SQLException e) {
1:                 assertSQLState("08003", e);
1:         }
1:         assertFalse(aes12.didConnectionClosedEventHappen());
1:         assertTrue(aes12.didConnectionErrorEventHappen());
1:         aes12.resetState();        	
1:         try {
1:             conn.setClientInfo("junk1", "junk2");
1:         } catch (SQLException e) {
1:                 assertSQLState("08003", e);
1:         }
1:         assertFalse(aes12.didConnectionClosedEventHappen());
1:         assertTrue(aes12.didConnectionErrorEventHappen());
1:         aes12.resetState();        	
1:         try {
1:             conn.isWrapperFor(this.getClass());
1:         } catch (SQLException e) {
1:                 assertSQLState("08003", e);
1:         }
1:         assertFalse(aes12.didConnectionClosedEventHappen());
1:         if (usingEmbedded())
1:         	assertTrue(aes12.didConnectionErrorEventHappen());
1:         else
1:         	//We do not make any call on underneath JDBC Connection
1:         	//object for isWrapperFor and hence never get Connection
1:         	//Error event
1:         	assertFalse(aes12.didConnectionErrorEventHappen());
1:         aes12.resetState();        	
1:         try {
1:             conn.unwrap(this.getClass());
1:         } catch (SQLException e) {
1:             if (usingEmbedded())
1:                 assertSQLState("08003", e);
1:             else
1:             	//We do not make any call on underneath JDBC Connection
1:             	//object for unwrap and hence never get Connection
1:             	//closed exception. Instead we got exception because
1:             	//client driver code is trying to unwrap this.getClass
1:             	//and it can't do that
1:                 assertSQLState("XJ128", e);
1:         }
1:     	assertFalse(aes12.didConnectionClosedEventHappen());
1:         if (usingEmbedded())
1:         	assertTrue(aes12.didConnectionErrorEventHappen());
1:         else
1:         	//We do not make any call on underneath JDBC Connection
1:         	//object for isWrapperFor and hence never get Connection
1:         	//Error event
1:         	assertFalse(aes12.didConnectionErrorEventHappen());
1:         aes12.resetState();        	
1:         try {
1:             conn.isValid(5);
1:         } catch (SQLException e) {
1:             assertSQLState("08003", e);
1:         }
1:         if (usingEmbedded())
1:         	assertTrue(aes12.didConnectionClosedEventHappen());
1:         else
1:         	assertFalse(aes12.didConnectionClosedEventHappen());
1:     	//As per the JDBC definition, an exception and hence an event is raised
1:     	//for isValid only if the param value is illegal
1:     	assertFalse(aes12.didConnectionErrorEventHappen());
1:         aes12.resetState();        	
1:         if (usingEmbedded())
1:         {
0:             Class.forName("org.apache.derby.jdbc.EmbeddedDriver").newInstance();
1:         }else
1:         {
1:         	getTestConfiguration().startNetworkServer();
1:         }
1: 
1:         // Get a new connection to the database
1:         conn = getConnection();
1:         conn.close();
1:     }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9b52936
/////////////////////////////////////////////////////////////////////////
1:     public void tearDown() throws Exception {
1:         super.tearDown();
commit:ec5ae26
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
0:         // This test will fail in client/server mode until DERBY-2047 is fixed.
0:         //return TestConfiguration.defaultSuite(DataSourceTest.class);
commit:f631317
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
1:     public void testIsWrapperForDataSource() throws SQLException {
1:         assertTrue(ds.isWrapperFor(DataSource.class));
1:     }
0: 
1:     public void testIsNotWrapperForPoolDataSource() throws SQLException {
1:         assertFalse(ds.isWrapperFor(ConnectionPoolDataSource.class));
1:     }
0: 
1:     public void testIsNotWrapperForXADataSource() throws SQLException {
1:         assertFalse(ds.isWrapperFor(XADataSource.class));
1:     }
0: 
1:     public void testIsNotWrapperForResultSet() throws SQLException {
1:         assertFalse(ds.isWrapperFor(ResultSet.class));
1:     }
0: 
1:     public void testUnwrapDataSource() throws SQLException {
1:         DataSource ds2 = ds.unwrap(DataSource.class);
1:         assertSame("Unwrap returned wrong object.", ds, ds2);
1:     }
0: 
1:     public void testUnwrapConnectionPoolDataSource() {
0:         try {
1:             ConnectionPoolDataSource cpds =
1:                 ds.unwrap(ConnectionPoolDataSource.class);
1:             fail("Unwrap didn't fail.");
1:         } catch (SQLException e) {
1:             assertSQLState("XJ128", e);
0: 
1:     public void testUnwrapXADataSource() {
0:         try {
1:             XADataSource xads = ds.unwrap(XADataSource.class);
1:             fail("Unwrap didn't fail.");
1:         } catch (SQLException e) {
1:             assertSQLState("XJ128", e);
0: 
1:     public void testUnwrapResultSet() {
0:         try {
1:             ResultSet rs = ds.unwrap(ResultSet.class);
1:             fail("Unwrap didn't fail.");
1:         } catch (SQLException e) {
1:             assertSQLState("XJ128", e);
1:         }
1:     }
0: 
commit:57efc3c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.TestDataSourceFactory;
/////////////////////////////////////////////////////////////////////////
0:         ds = TestDataSourceFactory.getDataSource();
============================================================================