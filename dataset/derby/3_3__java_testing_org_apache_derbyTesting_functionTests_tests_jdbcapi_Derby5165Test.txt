1:dc57c1f: /*
1:dc57c1f:  *
1:dc57c1f:  * Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.Derby5165Test
1:dc57c1f:  *
1:dc57c1f:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:dc57c1f:  * contributor license agreements.  See the NOTICE file distributed with
1:dc57c1f:  * this work for additional information regarding copyright ownership.
1:dc57c1f:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:dc57c1f:  * (the "License"); you may not use this file except in compliance with
1:dc57c1f:  * the License.  You may obtain a copy of the License at
1:dc57c1f:  *
1:dc57c1f:  *    http://www.apache.org/licenses/LICENSE-2.0
1:dc57c1f:  *
1:dc57c1f:  * Unless required by applicable law or agreed to in writing, 
1:dc57c1f:  * software distributed under the License is distributed on an 
1:dc57c1f:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:dc57c1f:  * either express or implied. See the License for the specific 
1:dc57c1f:  * language governing permissions and limitations under the License.
1:dc57c1f:  */
1:dc57c1f: 
1:dc57c1f: 
1:7af32f6: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:7af32f6: 
1:7af32f6: import java.sql.Connection;
1:7af32f6: import java.sql.ResultSet;
1:7af32f6: import java.sql.SQLException;
1:7af32f6: import java.sql.Statement;
1:7af32f6: 
1:7af32f6: import javax.sql.DataSource;
1:7af32f6: import javax.sql.XAConnection;
1:7af32f6: import javax.sql.XADataSource;
1:7af32f6: import javax.transaction.xa.XAException;
1:7af32f6: import javax.transaction.xa.XAResource;
1:7af32f6: import javax.transaction.xa.Xid;
1:7af32f6: 
1:7af32f6: import junit.framework.Test;
1:7af32f6: 
1:7af32f6: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:7af32f6: import org.apache.derbyTesting.junit.BaseTestSuite;
1:7af32f6: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:7af32f6: import org.apache.derbyTesting.junit.J2EEDataSource;
1:7af32f6: import org.apache.derbyTesting.junit.JDBC;
1:7af32f6: import org.apache.derbyTesting.junit.JDBCDataSource;
1:7af32f6: import org.apache.derbyTesting.junit.TestConfiguration;
1:7af32f6: 
1:7af32f6: public class Derby5165Test extends BaseJDBCTestCase {
1:7af32f6:     
1:7af32f6:     public Derby5165Test(String name) {
1:7af32f6:         super(name);
1:7af32f6:     }
1:7af32f6: 
1:7af32f6:     public static Test suite() {
1:7af32f6:         // the test requires XADataSource to run
1:7af32f6:         if (JDBC.vmSupportsJDBC3()) {
1:7af32f6:             //Test test = TestConfiguration.defaultSuite(Derby5165Test.class);
1:7af32f6:             Test test = TestConfiguration.embeddedSuite(Derby5165Test.class);
1:7af32f6:             
1:7af32f6:             // Set the lock timeout back to the default, because when
1:7af32f6:             // running in a bigger suite the value may have been
1:7af32f6:             // altered by an earlier test
1:7af32f6:             test = DatabasePropertyTestSetup.setLockTimeouts(test, 2, 4);
1:7af32f6:             
1:7af32f6:             test = TestConfiguration.singleUseDatabaseDecorator( test, "d5165db" );
1:7af32f6:             test = TestConfiguration.singleUseDatabaseDecorator( test, "d5165db2");
1:947a723:             test = TestConfiguration.singleUseDatabaseDecorator( test, "d5165db3" );
1:947a723:             test = TestConfiguration.singleUseDatabaseDecorator( test, "d5165db4");
1:7af32f6:             
1:7af32f6:             return test;
1:7af32f6:         }
1:7af32f6: 
1:7af32f6:         return new BaseTestSuite(
1:7af32f6:             "Derby5165Test cannot run without XA support");
1:7af32f6:     }
1:7af32f6:     
1:af5936c:     public void testXAUpdateLockKeptPastDBRestart()
1:7af32f6:             throws InterruptedException, SQLException, XAException {
1:7af32f6:         if (usingDerbyNetClient())
1:7af32f6:             return;
1:7af32f6:         // step 0 - initialize db and xa constructs
1:7af32f6:         XADataSource xads = J2EEDataSource.getXADataSource();
1:7af32f6:         J2EEDataSource.setBeanProperty(xads, "databaseName", "d5165db");
1:7af32f6:         XAConnection xac = xads.getXAConnection();
1:7af32f6:         XAResource xar = xac.getXAResource();
1:7af32f6:         Connection conn = xac.getConnection();
2:7af32f6:         // step 1 - perform update with XA, using Xid xid1 
1:7af32f6:         Statement s = conn.createStatement();
1:947a723:         String tableName = "d5165t";
1:947a723:         createAndLoadTable(conn, tableName, true);
1:7af32f6:         conn.commit();
1:7af32f6:         
1:7af32f6:         JDBC.assertSingleValueResultSet(
1:947a723:                 s.executeQuery("select * from " + tableName),
1:7af32f6:                 "1");
1:7af32f6:         
1:7af32f6:         conn.close();
1:7af32f6:         s.close();
1:7af32f6:         
1:7af32f6:         Xid xid1 = new MyXid(1, 2, 3);
1:7af32f6:         xar.start(xid1, XAResource.TMNOFLAGS);
1:7af32f6:         Connection c1 = xac.getConnection();
1:7af32f6:         Statement s1 = c1.createStatement();
1:947a723:         s1.execute("update " + tableName + " set x = 2 where x = 1");
1:7af32f6:         xar.end(xid1, XAResource.TMSUCCESS);
1:7af32f6: 
1:7af32f6:         // step 2-prepare xid1 with XA but do NOT commit
1:7af32f6:         xar.prepare(xid1);
1:7af32f6: 
1:7af32f6:         // step 3 - 'restart' the database
1:7af32f6:         try {
1:7af32f6:             // so first shutdown the database
1:7af32f6:             DataSource ds = JDBCDataSource.getDataSource("d5165db");
1:7af32f6:             JDBCDataSource.shutdownDatabase(ds);
1:7af32f6:         } catch (Exception e) {
1:7af32f6:             // Ignore shutdown successful exception
1:7af32f6:         }
1:7af32f6:         // the next Connection call automatically starts up the database again 
1:7af32f6:         Connection c2 = openConnection("d5165db");
1:7af32f6: 
1:7af32f6:         // step 4 - if the bug occurs, the updates of step 1 will be visible
1:7af32f6:         // however, the XA transaction was not committed, so this should
1:7af32f6:         // time out.
1:7af32f6:         Statement s2 = c2.createStatement();
1:7af32f6:         try { 
1:947a723:             ResultSet rs = s2.executeQuery("select * from " + tableName);
1:7af32f6:             //System.out.println("Contents of T:");
1:7af32f6:             while (rs.next()) {
1:7af32f6:                 //    System.out.println(rs.getInt(1));
1:7af32f6:                 rs.getInt(1);
1:7af32f6:             }
1:7af32f6:             rs.close();
1:7af32f6:             fail("expected a timeout");
1:7af32f6:         } catch (SQLException sqle ) {
1:7af32f6:             // for debugging uncomment following lines:
1:7af32f6:             //System.out.println("expected exception: ");
1:7af32f6:             //e.printStackTrace();
1:7af32f6:             assertSQLState("40XL1", sqle);
1:7af32f6:         }
1:7af32f6: 
1:7af32f6:         s.close();
1:7af32f6:         c2.close();
1:7af32f6:         s2.close();
1:7af32f6:         
1:7af32f6:         xac.close();
1:7af32f6:     }
1:947a723:     
1:7af32f6:     public void testXAInsertLockKeptPastDBRestart()
1:7af32f6:             throws InterruptedException, SQLException, XAException {
1:7af32f6:         if (usingDerbyNetClient())
1:7af32f6:             return;
1:7af32f6:         // open a connection to force creation of the second database
1:7af32f6:         Connection ctmp = openConnection("d5165db2");
1:7af32f6:         ctmp.close();
1:947a723:         
1:7af32f6:         // step 0 - initialize db and xa constructs
1:7af32f6:         XADataSource xads = J2EEDataSource.getXADataSource();
1:7af32f6:         J2EEDataSource.setBeanProperty(xads, "databaseName", "d5165db2");
1:7af32f6:         XAConnection xac = xads.getXAConnection();
1:7af32f6:         XAResource xar = xac.getXAResource();
1:7af32f6:         Connection conn = xac.getConnection();
1:947a723:         // step 1 - perform insert with XA, using Xid xid1 
1:7af32f6:         Statement s = conn.createStatement();
1:947a723:         String tableName = "d5165t";
1:947a723:         createAndLoadTable(conn, tableName, true);
1:7af32f6:         conn.commit();
1:7af32f6:         
1:7af32f6:         JDBC.assertSingleValueResultSet(
1:947a723:                 s.executeQuery("select * from " + tableName),
1:7af32f6:                 "1");
1:7af32f6:         
1:7af32f6:         conn.close();
1:7af32f6:         s.close();
1:7af32f6:         
1:7af32f6:         Xid xid1 = new MyXid(1, 2, 3);
1:7af32f6:         xar.start(xid1, XAResource.TMNOFLAGS);
1:7af32f6:         Connection c1 = xac.getConnection();
1:7af32f6:         Statement s1 = c1.createStatement();
1:947a723:         s1.execute("insert into " + tableName + " values 2");
1:7af32f6:         xar.end(xid1, XAResource.TMSUCCESS);
1:7af32f6: 
1:7af32f6:         // step 2-prepare xid1 with XA but do NOT commit
1:7af32f6:         xar.prepare(xid1);
1:7af32f6: 
1:7af32f6:         // step 3 - 'restart' the database
1:7af32f6:         try {
1:7af32f6:             // so first shutdown the database
1:7af32f6:             DataSource ds = JDBCDataSource.getDataSource("d5165db2");
1:7af32f6:             JDBCDataSource.shutdownDatabase(ds);
1:7af32f6:         } catch (Exception e) {
1:7af32f6:             // Ignore shutdown successful exception
1:7af32f6:         }
1:7af32f6:         // the next Connection call automatically starts up the database again 
1:7af32f6:         Connection c2 = openConnection("d5165db2");
1:7af32f6: 
1:7af32f6:         // step 4 - if the bug occurs, the updates of step 1 will be visible
1:7af32f6:         // however, the XA transaction was not committed, so this should have
1:7af32f6:         // timed out.
1:7af32f6:         Statement s2 = c2.createStatement();
1:7af32f6:         try { 
1:947a723:             ResultSet rs = s2.executeQuery("select * from " + tableName);
1:7af32f6:             while (rs.next()) {
1:7af32f6:                 //    System.out.println(rs.getInt(1));
1:7af32f6:                 rs.getInt(1);
1:7af32f6:             }
1:7af32f6:             rs.close();
1:7af32f6:             fail("expected a timeout");
1:7af32f6:         } catch (SQLException sqle ) {
1:7af32f6:             assertSQLState("40XL1", sqle);
1:7af32f6:         }
1:7af32f6: 
1:7af32f6:         s.close();
1:7af32f6:         c2.close();
1:7af32f6:         s2.close();
1:7af32f6:         
1:7af32f6:         xac.close();
1:7af32f6:     }
1:7af32f6:     
1:af5936c:     public void testXAUpdateLockKeptPastCrashedDBRestart() throws Exception
1:947a723:     {
1:947a723:         // call a forked process - this one will do something,
1:947a723:         // then *not* shutdown, but not doing anything else either,
1:947a723:         // implying a crash when the jvm is done
1:947a723:         // This will force the connect to recover the database.
1:947a723:         // Pass in the name of the database to be used.
1:947a723:         assertLaunchedJUnitTestMethod("org.apache.derbyTesting." +
1:947a723:                 "functionTests.tests.jdbcapi.Derby5165Test.launchUpdate",
1:947a723:                 "d5165db3");
1:947a723:         // Call the second forked process. This will connect and check,
1:947a723:         // forcing recovery.
1:947a723:         assertLaunchedJUnitTestMethod("org.apache.derbyTesting." +
1:947a723:                 "functionTests.tests.jdbcapi.Derby5165Test.checkUpdate",
1:947a723:                 "d5165db3");
1:947a723:     }
1:947a723: 
1:947a723:     public void testXAInsertLockKeptPastCrashedDBRestart() throws Exception
1:947a723:     {
1:947a723:         // call a forked process - this one will do something,
1:947a723:         // then *not* shutdown, but not doing anything else either,
1:947a723:         // implying a crash when the jvm is done
1:947a723:         // This will force the connect to recover the database.
1:947a723:         // Pass in the name of the database to be used.
1:947a723:         assertLaunchedJUnitTestMethod("org.apache.derbyTesting." +
1:947a723:                 "functionTests.tests.jdbcapi.Derby5165Test.launchInsert",
1:947a723:                 "d5165db4");
1:947a723:         // Call the second forked process. This will connect and check,
1:947a723:         // forcing recovery.
1:947a723:         assertLaunchedJUnitTestMethod("org.apache.derbyTesting." +
1:947a723:                 "functionTests.tests.jdbcapi.Derby5165Test.checkInsert",
1:947a723:                 "d5165db4");
1:947a723:     }
1:947a723: 
1:947a723:     public void launchUpdate() throws Exception
1:947a723:     {
1:947a723:         // setup to setup for update
1:947a723:         // open a connection to the database
1:947a723:         Connection simpleconn = getConnection();
1:947a723:         setAutoCommit(false);
1:947a723:         String tableName = "d5165t2";
1:947a723:         createAndLoadTable(simpleconn, tableName, true);
1:947a723:         
1:947a723:         // step 0 - initialize db and xa constructs
1:947a723:         XADataSource xads = J2EEDataSource.getXADataSource();
1:947a723:         J2EEDataSource.setBeanProperty(xads, "databaseName", "d5165db3");
1:947a723:         XAConnection xac = xads.getXAConnection();
1:947a723:         XAResource xar = xac.getXAResource();
1:947a723:         Connection conn = xac.getConnection();
1:947a723:         // step 1 - perform update with XA, using Xid xid1 
1:947a723:         Statement s = conn.createStatement();
1:947a723:         JDBC.assertSingleValueResultSet(
1:947a723:                 s.executeQuery("select * from " + tableName),
1:947a723:                 "1");
1:947a723:         
1:947a723:         conn.close();
1:947a723:         s.close();
1:947a723:         
1:947a723:         Xid xid1 = new MyXid(1, 2, 3);
1:947a723:         xar.start(xid1, XAResource.TMNOFLAGS);
1:947a723:         Connection c1 = xac.getConnection();
1:947a723:         Statement s1 = c1.createStatement();
1:947a723:         s1.execute("update " + tableName + " set x = 2 where x = 1");
1:947a723:         xar.end(xid1, XAResource.TMSUCCESS);
1:947a723: 
1:947a723:         // step 2-prepare xid1 with XA but do NOT commit
1:947a723:         xar.prepare(xid1);
1:947a723:         
1:947a723:         // doing nothing further should stop this jvm process.
1:947a723:     }
1:947a723: 
1:947a723:     public void checkUpdate() throws Exception
1:947a723:     {
1:947a723:         String tableName = "d5165t2";
1:947a723:         // getting the connection will start and thus recover the db
1:947a723:         Connection c2 = getConnection();
1:947a723:         setAutoCommit(false);
1:947a723: 
1:947a723:         // step 4 - if the bug occurs, the updates of step 1 will be visible
1:947a723:         // however, the XA transaction was not committed, so this should
1:947a723:         // time out.
1:947a723:         Statement s2 = c2.createStatement();
1:947a723:         try { 
1:947a723:             ResultSet rs = s2.executeQuery(
1:947a723:                     "select * from " + tableName);
1:947a723:             while (rs.next()) {
1:947a723:                 rs.getInt(1);
1:947a723:             }
1:947a723:             rs.close();
1:947a723:             fail("expected a timeout");
1:947a723:         } catch (SQLException sqle ) {
1:947a723:             assertSQLState("40XL1", sqle);
1:947a723:         }
1:947a723:     }
1:947a723: 
1:947a723:     public void launchInsert() throws Exception
1:947a723:     {
1:947a723:         String tableName = "d5165t3";
1:947a723:         // setup to setup for update
1:947a723:         // open a connection to the database
1:947a723:         Connection simpleconn = getConnection();
1:947a723:         setAutoCommit(false);        
1:947a723:         createAndLoadTable(simpleconn, tableName, true);
1:947a723:         
1:947a723:         // step 0 - initialize db and xa constructs
1:947a723:         XADataSource xads = J2EEDataSource.getXADataSource();
1:947a723:         J2EEDataSource.setBeanProperty(xads, "databaseName", "d5165db4");
1:947a723:         XAConnection xac = xads.getXAConnection();
1:947a723:         XAResource xar = xac.getXAResource();
1:947a723:         Connection conn = xac.getConnection();
1:947a723:         // step 1 - perform insert with XA, using Xid xid1 
1:947a723:         Statement s = conn.createStatement();
1:947a723:         JDBC.assertSingleValueResultSet(
1:947a723:                 s.executeQuery("select * from " + tableName),
1:947a723:                 "1");
1:947a723:         
1:947a723:         conn.close();
1:947a723:         s.close();
1:947a723:         
1:947a723:         Xid xid1 = new MyXid(1, 2, 3);
1:947a723:         xar.start(xid1, XAResource.TMNOFLAGS);
1:947a723:         Connection c1 = xac.getConnection();
1:947a723:         Statement s1 = c1.createStatement();
1:947a723:         // insert
1:947a723:         s1.execute("insert into " + tableName + " values 2");
1:947a723:         xar.end(xid1, XAResource.TMSUCCESS);
1:947a723: 
1:947a723:         // step 2-prepare xid1 with XA but do NOT commit
1:947a723:         xar.prepare(xid1);
1:947a723:         
1:947a723:         // doing nothing further should stop this jvm process.
1:947a723:     }
1:947a723: 
1:947a723:     public void checkInsert() throws Exception
1:947a723:     {
1:947a723:         String tableName = "d5165t3";
1:947a723:         // getting the connection will start and thus recover the db
1:947a723:         Connection c2 = getConnection();
1:947a723:         setAutoCommit(false);
1:947a723: 
1:947a723:         // step 4 - if the bug occurs, the updates of step 1 will be visible
1:947a723:         // however, the XA transaction was not committed, so this should
1:947a723:         // time out.
1:947a723:         Statement s2 = c2.createStatement();
1:947a723:         try { 
1:947a723:             ResultSet rs = s2.executeQuery(
1:947a723:                     "select * from " + tableName);
1:947a723:             while (rs.next()) {
1:947a723:                 rs.getInt(1);
1:947a723:             }
1:947a723:             rs.close();
1:947a723:             fail("expected a timeout");
1:947a723:         } catch (SQLException sqle ) {
1:947a723:             assertSQLState("40XL1", sqle);
1:947a723:         }
1:947a723:     }
1:7af32f6:     
1:947a723:     /**
1:947a723:      * Create and load a table.
1:947a723:      *
1:947a723:      * @param create_table  If true, create new table - otherwise load into
1:947a723:      *                      existing table.
1:947a723:      * @param tblname       table to use.
1:947a723:      *
1:947a723:      * @exception  SQLException  Standard exception policy.
1:947a723:      **/
1:947a723:     private void createAndLoadTable(
1:947a723:             Connection conn, 
1:947a723:             String     tblname,
1:947a723:             boolean    create_table)
1:947a723:                     throws SQLException
1:947a723:                     {
1:947a723:         if (create_table)
1:947a723:         {
1:947a723:             Statement s = conn.createStatement();
1:947a723: 
1:947a723:             s.executeUpdate("create table " + tblname + "(x int)");
1:947a723:             s.executeUpdate("insert into " + tblname + " values 1");
1:947a723:             conn.commit();
1:947a723:             
1:947a723:             JDBC.assertSingleValueResultSet(
1:947a723:                     s.executeQuery("select * from " + tblname),
1:947a723:                     "1");
1:947a723:             s.close();
1:947a723:             println("table created: " + tblname);
1:947a723:         }
1:947a723:     }
1:7af32f6: 
1:7af32f6:     private static class MyXid implements Xid {
1:7af32f6:         int formatId;
1:7af32f6:         byte txid, bq;
1:7af32f6: 
1:7af32f6:         MyXid(int formatId, int txid, int bq) {
1:7af32f6:             this.formatId = formatId;
1:7af32f6:             this.txid = (byte) txid;
1:7af32f6:             this.bq = (byte) bq;
1:7af32f6:         }
1:7af32f6: 
1:7af32f6:         @Override
1:7af32f6:         public int getFormatId() {
1:7af32f6:             return formatId;
1:7af32f6:         }
1:7af32f6: 
1:7af32f6:         @Override
1:7af32f6:         public byte[] getGlobalTransactionId() {
1:7af32f6:             return new byte[] { txid };
1:7af32f6:         }
1:7af32f6: 
1:7af32f6:         @Override
1:7af32f6:         public byte[] getBranchQualifier() {
1:7af32f6:             return new byte[] { bq };
1:7af32f6:         }
1:7af32f6:     }
1:7af32f6: 
1:7af32f6: }
============================================================================
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:af5936c
/////////////////////////////////////////////////////////////////////////
1:     public void testXAUpdateLockKeptPastDBRestart()
/////////////////////////////////////////////////////////////////////////
1:     public void testXAUpdateLockKeptPastCrashedDBRestart() throws Exception
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:947a723
/////////////////////////////////////////////////////////////////////////
1:             test = TestConfiguration.singleUseDatabaseDecorator( test, "d5165db3" );
1:             test = TestConfiguration.singleUseDatabaseDecorator( test, "d5165db4");
/////////////////////////////////////////////////////////////////////////
1:         String tableName = "d5165t";
1:         createAndLoadTable(conn, tableName, true);
1:                 s.executeQuery("select * from " + tableName),
/////////////////////////////////////////////////////////////////////////
1:         s1.execute("update " + tableName + " set x = 2 where x = 1");
/////////////////////////////////////////////////////////////////////////
1:             ResultSet rs = s2.executeQuery("select * from " + tableName);
/////////////////////////////////////////////////////////////////////////
1:         // step 1 - perform insert with XA, using Xid xid1 
1:         String tableName = "d5165t";
1:         createAndLoadTable(conn, tableName, true);
1:                 s.executeQuery("select * from " + tableName),
/////////////////////////////////////////////////////////////////////////
1:         s1.execute("insert into " + tableName + " values 2");
/////////////////////////////////////////////////////////////////////////
1:             ResultSet rs = s2.executeQuery("select * from " + tableName);
/////////////////////////////////////////////////////////////////////////
1:     
0:     public void xtestXAUpdateLockKeptPastCrashedDBRestart() throws Exception
1:     {
1:         // call a forked process - this one will do something,
1:         // then *not* shutdown, but not doing anything else either,
1:         // implying a crash when the jvm is done
1:         // This will force the connect to recover the database.
1:         // Pass in the name of the database to be used.
1:         assertLaunchedJUnitTestMethod("org.apache.derbyTesting." +
1:                 "functionTests.tests.jdbcapi.Derby5165Test.launchUpdate",
1:                 "d5165db3");
1:         // Call the second forked process. This will connect and check,
1:         // forcing recovery.
1:         assertLaunchedJUnitTestMethod("org.apache.derbyTesting." +
1:                 "functionTests.tests.jdbcapi.Derby5165Test.checkUpdate",
1:                 "d5165db3");
1:     }
1: 
1:     public void testXAInsertLockKeptPastCrashedDBRestart() throws Exception
1:     {
1:         // call a forked process - this one will do something,
1:         // then *not* shutdown, but not doing anything else either,
1:         // implying a crash when the jvm is done
1:         // This will force the connect to recover the database.
1:         // Pass in the name of the database to be used.
1:         assertLaunchedJUnitTestMethod("org.apache.derbyTesting." +
1:                 "functionTests.tests.jdbcapi.Derby5165Test.launchInsert",
1:                 "d5165db4");
1:         // Call the second forked process. This will connect and check,
1:         // forcing recovery.
1:         assertLaunchedJUnitTestMethod("org.apache.derbyTesting." +
1:                 "functionTests.tests.jdbcapi.Derby5165Test.checkInsert",
1:                 "d5165db4");
1:     }
1: 
1:     public void launchUpdate() throws Exception
1:     {
1:         // setup to setup for update
1:         // open a connection to the database
1:         Connection simpleconn = getConnection();
1:         setAutoCommit(false);
1:         String tableName = "d5165t2";
1:         createAndLoadTable(simpleconn, tableName, true);
1:         
1:         // step 0 - initialize db and xa constructs
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         J2EEDataSource.setBeanProperty(xads, "databaseName", "d5165db3");
1:         XAConnection xac = xads.getXAConnection();
1:         XAResource xar = xac.getXAResource();
1:         Connection conn = xac.getConnection();
1:         // step 1 - perform update with XA, using Xid xid1 
1:         Statement s = conn.createStatement();
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select * from " + tableName),
1:                 "1");
1:         
1:         conn.close();
1:         s.close();
1:         
1:         Xid xid1 = new MyXid(1, 2, 3);
1:         xar.start(xid1, XAResource.TMNOFLAGS);
1:         Connection c1 = xac.getConnection();
1:         Statement s1 = c1.createStatement();
1:         s1.execute("update " + tableName + " set x = 2 where x = 1");
1:         xar.end(xid1, XAResource.TMSUCCESS);
1: 
1:         // step 2-prepare xid1 with XA but do NOT commit
1:         xar.prepare(xid1);
1:         
1:         // doing nothing further should stop this jvm process.
1:     }
1: 
1:     public void checkUpdate() throws Exception
1:     {
1:         String tableName = "d5165t2";
1:         // getting the connection will start and thus recover the db
1:         Connection c2 = getConnection();
1:         setAutoCommit(false);
1: 
1:         // step 4 - if the bug occurs, the updates of step 1 will be visible
1:         // however, the XA transaction was not committed, so this should
1:         // time out.
1:         Statement s2 = c2.createStatement();
1:         try { 
1:             ResultSet rs = s2.executeQuery(
1:                     "select * from " + tableName);
1:             while (rs.next()) {
1:                 rs.getInt(1);
1:             }
1:             rs.close();
1:             fail("expected a timeout");
1:         } catch (SQLException sqle ) {
1:             assertSQLState("40XL1", sqle);
1:         }
1:     }
1: 
1:     public void launchInsert() throws Exception
1:     {
1:         String tableName = "d5165t3";
1:         // setup to setup for update
1:         // open a connection to the database
1:         Connection simpleconn = getConnection();
1:         setAutoCommit(false);        
1:         createAndLoadTable(simpleconn, tableName, true);
1:         
1:         // step 0 - initialize db and xa constructs
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         J2EEDataSource.setBeanProperty(xads, "databaseName", "d5165db4");
1:         XAConnection xac = xads.getXAConnection();
1:         XAResource xar = xac.getXAResource();
1:         Connection conn = xac.getConnection();
1:         // step 1 - perform insert with XA, using Xid xid1 
1:         Statement s = conn.createStatement();
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select * from " + tableName),
1:                 "1");
1:         
1:         conn.close();
1:         s.close();
1:         
1:         Xid xid1 = new MyXid(1, 2, 3);
1:         xar.start(xid1, XAResource.TMNOFLAGS);
1:         Connection c1 = xac.getConnection();
1:         Statement s1 = c1.createStatement();
1:         // insert
1:         s1.execute("insert into " + tableName + " values 2");
1:         xar.end(xid1, XAResource.TMSUCCESS);
1: 
1:         // step 2-prepare xid1 with XA but do NOT commit
1:         xar.prepare(xid1);
1:         
1:         // doing nothing further should stop this jvm process.
1:     }
1: 
1:     public void checkInsert() throws Exception
1:     {
1:         String tableName = "d5165t3";
1:         // getting the connection will start and thus recover the db
1:         Connection c2 = getConnection();
1:         setAutoCommit(false);
1: 
1:         // step 4 - if the bug occurs, the updates of step 1 will be visible
1:         // however, the XA transaction was not committed, so this should
1:         // time out.
1:         Statement s2 = c2.createStatement();
1:         try { 
1:             ResultSet rs = s2.executeQuery(
1:                     "select * from " + tableName);
1:             while (rs.next()) {
1:                 rs.getInt(1);
1:             }
1:             rs.close();
1:             fail("expected a timeout");
1:         } catch (SQLException sqle ) {
1:             assertSQLState("40XL1", sqle);
1:         }
1:     }
1:     
1:     /**
1:      * Create and load a table.
1:      *
1:      * @param create_table  If true, create new table - otherwise load into
1:      *                      existing table.
1:      * @param tblname       table to use.
1:      *
1:      * @exception  SQLException  Standard exception policy.
1:      **/
1:     private void createAndLoadTable(
1:             Connection conn, 
1:             String     tblname,
1:             boolean    create_table)
1:                     throws SQLException
1:                     {
1:         if (create_table)
1:         {
1:             Statement s = conn.createStatement();
1: 
1:             s.executeUpdate("create table " + tblname + "(x int)");
1:             s.executeUpdate("insert into " + tblname + " values 1");
1:             conn.commit();
1:             
1:             JDBC.assertSingleValueResultSet(
1:                     s.executeQuery("select * from " + tblname),
1:                     "1");
1:             s.close();
1:             println("table created: " + tblname);
1:         }
1:     }
commit:dc57c1f
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.Derby5165Test
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
1:  */
1: 
1: 
author:asf-sync-process
-------------------------------------------------------------------------------
commit:7af32f6
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.sql.Connection;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import javax.sql.DataSource;
1: import javax.sql.XAConnection;
1: import javax.sql.XADataSource;
1: import javax.transaction.xa.XAException;
1: import javax.transaction.xa.XAResource;
1: import javax.transaction.xa.Xid;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.J2EEDataSource;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: public class Derby5165Test extends BaseJDBCTestCase {
1:     
1:     public Derby5165Test(String name) {
1:         super(name);
1:     }
1: 
1:     public static Test suite() {
1:         // the test requires XADataSource to run
1:         if (JDBC.vmSupportsJDBC3()) {
1:             //Test test = TestConfiguration.defaultSuite(Derby5165Test.class);
1:             Test test = TestConfiguration.embeddedSuite(Derby5165Test.class);
1:             
1:             // Set the lock timeout back to the default, because when
1:             // running in a bigger suite the value may have been
1:             // altered by an earlier test
1:             test = DatabasePropertyTestSetup.setLockTimeouts(test, 2, 4);
1:             
1:             test = TestConfiguration.singleUseDatabaseDecorator( test, "d5165db" );
1:             test = TestConfiguration.singleUseDatabaseDecorator( test, "d5165db2");
1:             
1:             return test;
1:         }
1: 
1:         return new BaseTestSuite(
1:             "Derby5165Test cannot run without XA support");
1:     }
1:     
0:     public void xtestXAUpdateLockKeptPastDBRestart()
1:             throws InterruptedException, SQLException, XAException {
1:         if (usingDerbyNetClient())
1:             return;
1:         // step 0 - initialize db and xa constructs
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         J2EEDataSource.setBeanProperty(xads, "databaseName", "d5165db");
1:         XAConnection xac = xads.getXAConnection();
1:         XAResource xar = xac.getXAResource();
1:         Connection conn = xac.getConnection();
1:         // step 1 - perform update with XA, using Xid xid1 
1:         Statement s = conn.createStatement();
0:         s.executeUpdate("create table d5165t(x int)");
0:         s.executeUpdate("insert into d5165t values 1");
1:         conn.commit();
1:         
1:         JDBC.assertSingleValueResultSet(
0:                 s.executeQuery("select * from d5165t"),
1:                 "1");
1:         
1:         conn.close();
1:         s.close();
1:         
1:         Xid xid1 = new MyXid(1, 2, 3);
1:         xar.start(xid1, XAResource.TMNOFLAGS);
1:         Connection c1 = xac.getConnection();
1:         Statement s1 = c1.createStatement();
0:         s1.execute("update d5165t set x = 2 where x = 1");
1:         xar.end(xid1, XAResource.TMSUCCESS);
1: 
1:         // step 2-prepare xid1 with XA but do NOT commit
1:         xar.prepare(xid1);
1: 
1:         // step 3 - 'restart' the database
1:         try {
1:             // so first shutdown the database
1:             DataSource ds = JDBCDataSource.getDataSource("d5165db");
1:             JDBCDataSource.shutdownDatabase(ds);
1:         } catch (Exception e) {
1:             // Ignore shutdown successful exception
1:         }
1:         // the next Connection call automatically starts up the database again 
1:         Connection c2 = openConnection("d5165db");
1: 
1:         // step 4 - if the bug occurs, the updates of step 1 will be visible
1:         // however, the XA transaction was not committed, so this should
1:         // time out.
1:         Statement s2 = c2.createStatement();
1:         try { 
0:             ResultSet rs = s2.executeQuery("select * from d5165t");
1:             //System.out.println("Contents of T:");
1:             while (rs.next()) {
1:                 //    System.out.println(rs.getInt(1));
1:                 rs.getInt(1);
1:             }
1:             rs.close();
1:             fail("expected a timeout");
1:         } catch (SQLException sqle ) {
1:             // for debugging uncomment following lines:
1:             //System.out.println("expected exception: ");
1:             //e.printStackTrace();
1:             assertSQLState("40XL1", sqle);
1:         }
1: 
1:         s.close();
1:         c2.close();
1:         s2.close();
1:         
1:         xac.close();
1:     }
1:     
1:     public void testXAInsertLockKeptPastDBRestart()
1:             throws InterruptedException, SQLException, XAException {
1:         if (usingDerbyNetClient())
1:             return;
1:         // open a connection to force creation of the second database
1:         Connection ctmp = openConnection("d5165db2");
1:         ctmp.close();
1:         
1:         // step 0 - initialize db and xa constructs
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         J2EEDataSource.setBeanProperty(xads, "databaseName", "d5165db2");
1:         XAConnection xac = xads.getXAConnection();
1:         XAResource xar = xac.getXAResource();
1:         Connection conn = xac.getConnection();
1:         // step 1 - perform update with XA, using Xid xid1 
1:         Statement s = conn.createStatement();
0:         s.executeUpdate("create table d5165t(x int)");
0:         s.executeUpdate("insert into d5165t values 1");
1:         conn.commit();
1:         
1:         JDBC.assertSingleValueResultSet(
0:                 s.executeQuery("select * from d5165t"),
1:                 "1");
1:         
1:         conn.close();
1:         s.close();
1:         
1:         Xid xid1 = new MyXid(1, 2, 3);
1:         xar.start(xid1, XAResource.TMNOFLAGS);
1:         Connection c1 = xac.getConnection();
1:         Statement s1 = c1.createStatement();
0:         s1.execute("insert into d5165t values 2");
1:         xar.end(xid1, XAResource.TMSUCCESS);
1: 
1:         // step 2-prepare xid1 with XA but do NOT commit
1:         xar.prepare(xid1);
1: 
1:         // step 3 - 'restart' the database
1:         try {
1:             // so first shutdown the database
1:             DataSource ds = JDBCDataSource.getDataSource("d5165db2");
1:             JDBCDataSource.shutdownDatabase(ds);
1:         } catch (Exception e) {
1:             // Ignore shutdown successful exception
1:         }
1:         // the next Connection call automatically starts up the database again 
1:         Connection c2 = openConnection("d5165db2");
1: 
1:         // step 4 - if the bug occurs, the updates of step 1 will be visible
1:         // however, the XA transaction was not committed, so this should have
1:         // timed out.
1:         Statement s2 = c2.createStatement();
1:         try { 
0:             ResultSet rs = s2.executeQuery("select * from d5165t");
1:             while (rs.next()) {
1:                 //    System.out.println(rs.getInt(1));
1:                 rs.getInt(1);
1:             }
1:             rs.close();
1:             fail("expected a timeout");
1:         } catch (SQLException sqle ) {
1:             assertSQLState("40XL1", sqle);
1:         }
1: 
1:         s.close();
1:         c2.close();
1:         s2.close();
1:         
1:         xac.close();
1:     }
1: 
1:     private static class MyXid implements Xid {
1:         int formatId;
1:         byte txid, bq;
1: 
1:         MyXid(int formatId, int txid, int bq) {
1:             this.formatId = formatId;
1:             this.txid = (byte) txid;
1:             this.bq = (byte) bq;
1:         }
1: 
1:         @Override
1:         public int getFormatId() {
1:             return formatId;
1:         }
1: 
1:         @Override
1:         public byte[] getGlobalTransactionId() {
1:             return new byte[] { txid };
1:         }
1: 
1:         @Override
1:         public byte[] getBranchQualifier() {
1:             return new byte[] { bq };
1:         }
1:     }
1: 
1: }
============================================================================