1:28e234d: /**
1:28e234d:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.NullableUniqueConstraintTest
1:28e234d:  *
1:28e234d:  * Licensed to the Apache Software Foundation (ASF) under one
1:28e234d:  * or more contributor license agreements.  See the NOTICE file
1:28e234d:  * distributed with this work for additional information
1:28e234d:  * regarding copyright ownership.  The ASF licenses this file
1:28e234d:  * to you under the Apache License, Version 2.0 (the
1:28e234d:  * "License"); you may not use this file except in compliance
1:28e234d:  * with the License.  You may obtain a copy of the License at
1:28e234d:  *
1:28e234d:  *   http://www.apache.org/licenses/LICENSE-2.0
1:28e234d:  *
1:28e234d:  * Unless required by applicable law or agreed to in writing,
1:28e234d:  * software distributed under the License is distributed on an
1:28e234d:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:28e234d:  * KIND, either express or implied.  See the License for the
1:28e234d:  * specific language governing permissions and limitations
1:28e234d:  * under the License.
1:28e234d:  */
3:28e234d: 
1:28e234d: package org.apache.derbyTesting.functionTests.tests.lang;
1:28e234d: 
1:28e234d: import java.sql.Connection;
1:28e234d: import java.sql.PreparedStatement;
1:28e234d: import java.sql.ResultSet;
1:28e234d: import java.sql.SQLException;
1:28e234d: import java.sql.Savepoint;
1:28e234d: import java.sql.Statement;
1:28e234d: import java.sql.Types;
1:28e234d: import java.util.Enumeration;
1:28e234d: import junit.framework.Test;
1:28e234d: import junit.framework.TestFailure;
1:28e234d: import junit.framework.TestResult;
1:28e234d: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:28e234d: import org.apache.derbyTesting.junit.TestConfiguration;
1:28e234d: 
1:28e234d: /**
1:28e234d:  * Test unique constraint
1:28e234d:  */
1:28e234d: public class NullableUniqueConstraintTest extends BaseJDBCTestCase {
1:28e234d:     
1:28e234d:     /**
1:28e234d:      * Basic constructor.
1:28e234d:      */
1:28e234d:     public NullableUniqueConstraintTest(String name) {
1:28e234d:         super(name);
1:28e234d:     }
1:28e234d:     
1:4d5163b:     /**
1:28e234d:      * Returns the implemented tests.
1:28e234d:      *
1:28e234d:      * @return An instance of <code>Test</code> with the implemented tests to
1:28e234d:      *         run.
1:28e234d:      */
1:28e234d:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite("NullableUniqueConstraintTest");
1:1ae02c9: 
1:28e234d:         suite.addTest(TestConfiguration.defaultSuite(
1:28e234d:                             NullableUniqueConstraintTest.class));
1:28e234d:         return suite;
1:28e234d:     }
1:28e234d:     
1:28e234d:     /**
1:28e234d:      * Create table for test cases to use.
1:28e234d:      */
1:28e234d:     protected void setUp() throws Exception {
1:28e234d:         Connection con = getConnection();
1:28e234d:         Statement stmt = con.createStatement();
1:28e234d:         stmt.executeUpdate("create table constraintest (val1 varchar (20), " +
1:28e234d:                 "val2 varchar (20), val3 varchar (20), val4 varchar (20))");
1:28e234d:     }
1:28e234d:     
1:28e234d:     protected void tearDown() throws Exception {
1:28e234d:         Connection con = getConnection();
1:28e234d:         con.commit ();
1:28e234d:         Statement stmt = con.createStatement();
1:28e234d:         stmt.executeUpdate("drop table constraintest");
1:28e234d:         stmt.close ();
1:28e234d:         con.commit ();
1:28e234d:         super.tearDown();
1:28e234d:     }
1:28e234d:     /**
1:28e234d:      * Basic test of Unique Constraint using single part key.
1:28e234d:      * @throws SQLException
1:28e234d:      */
1:28e234d:     public void testSingleKeyPartUniqueConstraint() throws SQLException {
1:28e234d:         Connection con = getConnection();
1:28e234d:         Statement stmt = con.createStatement();
1:28e234d:         //create unique constraint without not null
1:28e234d:         stmt.executeUpdate("alter table constraintest add constraint " +
1:28e234d:                 "u_con unique (val1)");
1:28e234d:         PreparedStatement ps  = con.prepareStatement("insert into " +
1:28e234d:                 "constraintest (val1, val2) values (?, ?)");
1:28e234d:         ps.setString(1, "test");
1:28e234d:         ps.setString(2, "should pass");
1:28e234d:         ps.execute();
1:28e234d:         try {
1:28e234d:             ps.setString(1, "test");
1:28e234d:             ps.setString(2, "should fail");
1:28e234d:             ps.execute();
1:28e234d:             fail("duplicate key inserted expected '23505'");
1:28e234d:         }
1:28e234d:         catch (SQLException e) {
1:28e234d:             assertSQLState("inserting duplicate", "23505", e);
1:28e234d:         }
1:28e234d:         ps.setNull(1, Types.VARCHAR);
1:28e234d:         ps.setString(2, "should pass");
1:28e234d:         ps.execute();
1:28e234d:         ps.setNull(1, Types.VARCHAR);
1:28e234d:         ps.setString(2, "should pass");
1:28e234d:         ps.execute();
1:28e234d:         //check if there are two record with val1=null
1:28e234d:         ResultSet rs = stmt.executeQuery("select count (*) from " +
1:28e234d:                 "constraintest where val1 is null");
1:28e234d:         rs.next();
1:28e234d:         assertEquals("expected 2 rows", 2, rs.getInt(1));
1:28e234d:         //try creating constraint with existing value
1:28e234d:         stmt.execute("alter table constraintest drop constraint u_con");
1:28e234d:         stmt.execute("delete from constraintest where val1 is null");
1:28e234d:         con.commit ();
1:28e234d:         ps.setString(1, "test");
1:28e234d:         ps.setString(2, "removeit");
1:28e234d:         ps.execute();
1:28e234d:         //constraint dropped successfully
1:28e234d:         //create constraint - must fail
1:28e234d:         try {
1:28e234d:             stmt.executeUpdate("alter table constraintest add constraint " +
1:28e234d:                 "u_con unique (val1)");
1:28e234d:             fail ("create unique constraint with duplicate key in " +
1:28e234d:                     "table should fail");
1:28e234d:         }
1:28e234d:         catch (SQLException e) {
1:28e234d:             assertSQLState("creating unique constraint when duplicate" +
1:28e234d:                     " keys are present  duplicate", "23505", e);
1:28e234d:         }
1:28e234d:         //remove duplicate record
1:28e234d:         stmt.execute ("delete from constraintest where val2 = 'removeit'");
1:28e234d:         //should be fine now
1:28e234d:         stmt.executeUpdate("alter table constraintest add constraint " +
1:28e234d:                 "u_con unique (val1)");
1:28e234d:         con.commit();
1:28e234d:         stmt.close ();
1:28e234d:         ps.close();
1:28e234d:     }
1:012a72b: 
1:012a72b:     /**
1:012a72b:      * Compress table should recreate the indexes correctly rather
1:012a72b:      * than ignoring the unique nullable property of the index
1:012a72b:      * @throws SQLException
1:012a72b:      */
1:012a72b:     public void testDerby4677CompressTable() throws SQLException {
1:012a72b:         Connection con = getConnection();
1:012a72b:         Statement stmt = con.createStatement();
1:012a72b:         stmt.executeUpdate("CREATE TABLE TABLE1(NAME1 INT UNIQUE, "+
1:012a72b:         		"name2 int unique not null, name3 int primary key)");
1:012a72b:         stmt.execute("call syscs_util.syscs_compress_table('APP','TABLE1',1)");
1:012a72b:         stmt.executeUpdate("INSERT INTO TABLE1 VALUES(1,11,111)");
1:012a72b:         //following should run into problem because of constraint on name1
1:012a72b:         assertStatementError("23505", stmt,
1:012a72b:         		"INSERT INTO TABLE1 VALUES(1,22,222)");
1:012a72b:         //following should run into problem because of constraint on name2
1:012a72b:         assertStatementError("23505", stmt,
1:012a72b:         		"INSERT INTO TABLE1 VALUES(3,11,333)");
1:012a72b:         //following should run into problem because of constraint on name3
1:012a72b:         assertStatementError("23505", stmt,
1:012a72b:         		"INSERT INTO TABLE1 VALUES(4,44,111)");
1:012a72b:         stmt.executeUpdate("DROP TABLE TABLE1");    
1:012a72b:     }
1:28e234d:     
1:28e234d:     /**
1:28e234d:      * Basic test of Unique Constraint using multipart part key.
1:28e234d:      * @throws SQLException
1:28e234d:      */
1:28e234d:     public void testMultipartKeyUniqueConstraint() throws SQLException {
1:28e234d:         Connection con = getConnection();
1:28e234d:         Statement stmt = con.createStatement();
1:28e234d:         //create unique constraint without not null
1:28e234d:         stmt.executeUpdate("alter table constraintest add constraint " +
1:28e234d:                 "u_con unique (val1, val2, val3)");
1:28e234d:         PreparedStatement ps  = con.prepareStatement("insert into " +
1:28e234d:                 "constraintest (val1, val2, val3, val4) values (?, ?, ?, ?)");
1:28e234d:         ps.setString(1, "part1");
1:28e234d:         ps.setString(2, "part2");
1:28e234d:         ps.setString(3, "part3");
1:28e234d:         ps.setString(4, "should pass");
1:28e234d:         ps.execute();
1:28e234d:         try {
1:28e234d:             ps.setString(1, "part1");
1:28e234d:             ps.setString(2, "part2");
1:28e234d:             ps.setString(3, "part3");
1:28e234d:             ps.setString(4, "should fail");
1:28e234d:             ps.execute();
1:28e234d:             fail("duplicate key inserted expected '23505'");
1:28e234d:         }
1:28e234d:         catch (SQLException e) {
1:28e234d:             assertSQLState("inserting duplicate", "23505", e);
1:28e234d:         }
1:28e234d:         ps.setNull(1, Types.VARCHAR);
1:28e234d:         ps.setString(2, "part2");
1:28e234d:         ps.setString(3, "part3");
1:28e234d:         ps.setString(4, "should pass");
1:28e234d:         ps.execute();
1:28e234d:         ps.setNull(1, Types.VARCHAR);
1:28e234d:         ps.setString(2, "part2");
1:28e234d:         ps.setString(3, "part3");
1:28e234d:         ps.setString(4, "should pass");
1:28e234d:         ps.execute();
1:28e234d:         ps.setString(1, "part1");
1:28e234d:         ps.setNull(2, Types.VARCHAR);
1:28e234d:         ps.setString(3, "part3");
1:28e234d:         ps.setString(4, "should pass");
1:28e234d:         ps.execute();
1:28e234d:         //check if there are two record with val1=null
1:28e234d:         ResultSet rs = stmt.executeQuery("select count (*) from " +
1:28e234d:                 "constraintest where val1 is null");
1:28e234d:         rs.next();
1:28e234d:         assertEquals("expected 2 rows", 2, rs.getInt(1));
1:28e234d:         //try creating constraint with existing value
1:28e234d:         stmt.execute("alter table constraintest drop constraint u_con");
1:28e234d:         con.commit ();
1:28e234d:         ps.setString(1, "part1");
1:28e234d:         ps.setString(2, "part2");
1:28e234d:         ps.setString(3, "part3");
1:28e234d:         ps.setString(4, "removeit");
1:28e234d:         ps.execute();
1:28e234d:         //constraint dropped successfully
1:28e234d:         //create constraint - must fail
1:28e234d:         try {
1:28e234d:             stmt.executeUpdate("alter table constraintest add constraint " +
1:28e234d:                 "u_con unique (val1, val2, val3)");
1:28e234d:             fail ("create unique constraint with duplicate key in " +
1:28e234d:                     "table should fail");
1:28e234d:         }
1:28e234d:         catch (SQLException e) {
1:28e234d:             assertSQLState("creating unique constraint when duplicate" +
1:28e234d:                     " keys are present  duplicate", "23505", e);
1:28e234d:         }
1:28e234d:         //remove duplicate record
1:28e234d:         stmt.execute ("delete from constraintest where val4 = 'removeit'");
1:28e234d:         //should be fine now
1:28e234d:         stmt.executeUpdate("alter table constraintest add constraint " +
1:28e234d:                 "u_con unique (val1, val2, val3)");
1:28e234d:         con.commit();
1:28e234d:         stmt.close ();
1:28e234d:         ps.close();
1:28e234d:     }
1:28e234d:     
1:28e234d:     /**
1:28e234d:      * Inserts a duplicate key of a deleted key within same transaction.
1:28e234d:      * @throws java.sql.SQLException
1:28e234d:      */
1:28e234d:     public void testWithDeletedKey() throws SQLException {
1:28e234d:         Connection con = getConnection();
1:28e234d:         Statement stmt = con.createStatement();
1:28e234d:         //create unique constraint without not null
1:28e234d:         stmt.executeUpdate("alter table constraintest add constraint " +
1:28e234d:                 "u_con unique (val1, val2, val3)");
1:28e234d:         PreparedStatement ps  = con.prepareStatement("insert into " +
1:28e234d:                 "constraintest (val1, val2, val3, val4) values (?, ?, ?, ?)");
1:28e234d:         ps.setString(1, "part1");
1:28e234d:         ps.setString(2, "part2");
1:28e234d:         ps.setString(3, "part3");
1:28e234d:         ps.setString(4, "should pass");
1:28e234d:         ps.execute();
1:28e234d:         //delete a record within transaction and try inserting same record
1:28e234d:         con.setAutoCommit(false);
1:28e234d:         stmt.executeUpdate("delete from constraintest where " +
1:28e234d:                 "val1 = 'part1' and val2 = 'part2' and val3 = 'part3'");
1:28e234d:         //insert same record
1:28e234d:         ps.setString(1, "part1");
1:28e234d:         ps.setString(2, "part2");
1:28e234d:         ps.setString(3, "part3");
1:28e234d:         ps.setString(4, "should pass");
1:28e234d:         ps.execute();
1:28e234d:         stmt.close();
1:28e234d:         ps.close();
1:28e234d:         con.commit();
1:28e234d:     }
1:28e234d:     
1:28e234d:     public void testDistinctQuery() throws SQLException {
1:28e234d:         Connection con = getConnection();
1:28e234d:         Statement stmt = con.createStatement();
1:28e234d:         stmt.executeUpdate("alter table constraintest add constraint " +
1:28e234d:                 "u_con unique (val1)");
1:28e234d:         PreparedStatement ps  = con.prepareStatement("insert into " +
1:28e234d:                 "constraintest (val1) values (?)");
1:28e234d:         //insert 5 null keys
1:28e234d:         for (int i = 0; i < 5; i++) {
1:28e234d:             ps.setNull(1, Types.VARCHAR);
1:28e234d:             ps.executeUpdate();
1:28e234d:         }
1:28e234d:         
1:28e234d:         //insert 5 null keys
1:28e234d:         for (int i = 0; i < 5; i++) {
1:28e234d:             ps.setString(1, String.valueOf(i));
1:28e234d:             ps.executeUpdate();
1:28e234d:         }
1:28e234d:         ResultSet rs = stmt.executeQuery("select count (*) from constraintest");
1:28e234d:         rs.next();
1:28e234d:         assertEquals(10, rs.getInt(1));
1:28e234d:         rs.close ();
1:28e234d: 
1:28e234d:         rs = stmt.executeQuery("select count (distinct (val1)) from " +
1:28e234d:                 "constraintest");
1:28e234d:         rs.next();
1:28e234d:         assertEquals(5, rs.getInt(1));
1:28e234d:         rs.close ();
1:28e234d:     }
1:28e234d:     /**
1:28e234d:      * Test null ordering of the key in order by query.
1:28e234d:      * @throws java.sql.SQLException
1:28e234d:      */
1:28e234d:     public void testNullOrdering() throws SQLException {
1:28e234d:         Connection con = getConnection();
1:28e234d:         Statement stmt = con.createStatement();
1:28e234d:         stmt.executeUpdate("alter table constraintest add constraint " +
1:28e234d:                 "u_con unique (val1)");
1:28e234d:         PreparedStatement ps  = con.prepareStatement("insert into " +
1:28e234d:                 "constraintest (val1) values (?)");
1:28e234d:         //insert 5 null keys
1:28e234d:         for (int i = 0; i < 5; i++) {
1:28e234d:             ps.setNull(1, Types.VARCHAR);
1:28e234d:             ps.executeUpdate();
1:28e234d:         }
1:28e234d:         
1:28e234d:         //insert 5 non null keys
1:28e234d:         for (int i = 0; i < 5; i++) {
1:28e234d:             ps.setString(1, String.valueOf(i));
1:28e234d:             ps.executeUpdate();
1:28e234d:         }
1:28e234d:         
1:28e234d:         ResultSet rs = stmt.executeQuery("select val1 from constraintest " +
1:28e234d:                             "order by val1 nulls last");
1:28e234d:         //first 5 should be non null
1:28e234d:         for (int i = 0; i < 5; i++) {
1:28e234d:             rs.next();
1:28e234d:             assertEquals (String.valueOf(i), rs.getString(1));
1:28e234d:         }
1:28e234d:         
1:28e234d:         //next 5 should be null
1:28e234d:         for (int i = 0; i < 5; i++) {
1:28e234d:             rs.next();
1:28e234d:             assertEquals (null, rs.getString(1));
1:28e234d:         }
1:28e234d:         rs.close ();
1:28e234d:         rs = stmt.executeQuery("select val1 from constraintest " +
1:28e234d:                             "order by val1 nulls first");
1:28e234d:         //first 5 should be null
1:28e234d:         for (int i = 0; i < 5; i++) {
1:28e234d:             rs.next();
1:28e234d:             assertEquals (null, rs.getString(1));
1:28e234d:         }
1:28e234d:         
1:28e234d:         //next 5 should be null
1:28e234d:         for (int i = 0; i < 5; i++) {
1:28e234d:             rs.next();
1:28e234d:             assertEquals (String.valueOf(i), rs.getString(1));
1:28e234d:         }
1:28e234d:         rs.close ();
1:28e234d:     }
1:28e234d:     
1:28e234d:     /**
1:28e234d:      * Tries to forces internal routibe to travel across
1:28e234d:      * pages to check for duplicates. It first inserts large 
1:28e234d:      * number of records assuming they occupy multiple pages 
1:28e234d:      * in index and then tries to insert duplicates of each 
1:28e234d:      * of them. Rrecords at the page boundry will require 
1:28e234d:      * duplucate checking routine to check more than one page 
1:28e234d:      * to look for locate. If that routine is not working properly 
1:28e234d:      * duplucate will be inserted in tree.
1:28e234d:      * @throws java.sql.SQLException
1:28e234d:      */
1:28e234d:     public void testComparisonAcrossPages() throws SQLException {
1:28e234d:         Connection con = getConnection();
1:28e234d:         Statement stmt = con.createStatement();
1:28e234d:         //create unique constraint without not null
1:28e234d:         stmt.executeUpdate("alter table constraintest add constraint " +
1:28e234d:                 "u_con unique (val1)");
1:28e234d:         PreparedStatement ps  = con.prepareStatement("insert into " +
1:28e234d:                 "constraintest (val1, val2) values (?, ?)");
1:28e234d:         for (int i = 0; i < 500; i++) {
1:28e234d:             ps.setString(1, "" + i);
1:28e234d:             ps.setString (2, "" + i);
1:28e234d:             ps.execute();
1:28e234d:         }
1:28e234d:         
1:28e234d:         for (int i = 0; i < 500; i++) {
1:28e234d:             ps.setString(1, "" + i);
1:28e234d:             ps.setString (2, "" + i);
1:28e234d:             try {
1:28e234d:                 ps.execute();
1:28e234d:                 fail("duplicate key inserted expected '23505'");
1:28e234d:             }
1:28e234d:             catch (SQLException e) {
1:28e234d:                 assertSQLState("inserting duplicate", "23505", e);  
1:28e234d:             }
1:28e234d:         }
1:28e234d:         //mark all records except for first, as deleted and try 
1:28e234d:         //inserting duplicate. This will force comparison 
1:28e234d:         //logic to scan all the records to find another rcord for 
1:28e234d:         //comparison.
1:28e234d:         con.setAutoCommit(false);
1:28e234d:         assertEquals (499, stmt.executeUpdate (
1:28e234d:                 "delete from constraintest where val1 != '0'"));
1:28e234d:         Savepoint deleted = con.setSavepoint("deleted");
1:28e234d:         ps.setString(1, "0");
1:28e234d:         ps.setString (2, "test");
1:28e234d:         try {
1:28e234d:             ps.execute();
1:28e234d:             fail ("managed to insert a duplicate");
1:28e234d:         }
1:28e234d:         catch (SQLException e) {
1:28e234d:             assertSQLState("inserting duplicate", "23505",  e);
1:28e234d:         }
1:28e234d:         //rollback to check point and try to insert a record 
1:28e234d:         //at the middle
1:28e234d:         con.rollback(deleted);
1:28e234d:         ps.setString(1, "250");
1:28e234d:         ps.setString(2, "test");
1:28e234d:         ps.execute ();
1:28e234d:         //rollback to check point and try 
1:28e234d:         //inserting at end
1:28e234d:         con.rollback(deleted);
1:28e234d:         ps.setString(1, "499");
1:28e234d:         ps.setString (2, "test");
1:28e234d:         ps.execute ();
1:28e234d: 
1:28e234d:         ResultSet rs = stmt.executeQuery("select count (*) from constraintest");
1:28e234d:         rs.next ();
1:28e234d:         assertEquals(2, rs.getInt(1));
1:28e234d:         
1:28e234d:         con.rollback ();
1:28e234d:         ps.close();
1:28e234d:         stmt.close();
1:28e234d:         ps.close();
1:28e234d:     }
1:28e234d:     
1:28e234d:     /**
1:28e234d:      * Checks is insert for updates uses deffered inserts or not. 
1:28e234d:      * It inserts two part keys in the form of
1:28e234d:      * part1 part2
1:28e234d:      * 1        1
1:28e234d:      * 1        2
1:28e234d:      * 1        3
1:28e234d:      * 2        1
1:28e234d:      * 2        2
1:28e234d:      * 2        3
1:28e234d:      * 3        1
1:28e234d:      * 3        2
1:28e234d:      * 3        3
1:28e234d:      * 
1:28e234d:      * and then tries to update all the records so that the values 
1:28e234d:      * part1 and part2 are interchanged. Internally updates are 
1:28e234d:      * treated as delete and insert and unless inserts are deffered 
1:28e234d:      * till all deletes are over, there will be unique constraint 
1:28e234d:      * violation.
1:28e234d:      * @throws java.sql.SQLException
1:28e234d:      */
1:28e234d:     public void testDefferedInsert() throws SQLException {
1:28e234d:         Connection con = getConnection();
1:28e234d:         Statement stmt = con.createStatement();
1:28e234d:         //create unique constraint without not null
1:28e234d:         stmt.executeUpdate("alter table constraintest add constraint " +
1:28e234d:                 "u_con unique (val1, val2)");
1:28e234d:         PreparedStatement ps  = con.prepareStatement("insert into " +
1:28e234d:                 "constraintest (val1, val2) values (?, ?)");
1:28e234d:         for (int i = 0; i < 5; i++) {
1:28e234d:             for (int j = 0; j < 5; j++) {
1:28e234d:                 ps.setString(1, String.valueOf(i));
1:28e234d:                 ps.setString(2, String.valueOf(j));
1:28e234d:                 ps.executeUpdate();
1:28e234d:             }
1:28e234d:         }
1:28e234d:         //interchange the values of val1 and val2
1:28e234d:         //this will fail unless its handled by deffered inserts
1:28e234d:         assertEquals("updating 25 records", 25, 
1:28e234d:                 stmt.executeUpdate("update constraintest set " +
1:28e234d:                 "val1 = val2, val2 = val1"));
1:28e234d:     }
1:8072a56: 
1:8072a56:     /**
1:8072a56:      * Test that repeatedly performing multi-row inserts and deletes spanning
1:8072a56:      * multiple pages works correctly with nullable unique constraint. This
1:8072a56:      * used to cause <tt>ERROR XSDA1: An attempt was made to access an out of
1:8072a56:      * range slot on a page</tt> (DERBY-4027).
1:8072a56:      */
1:8072a56:     public void testMixedInsertDelete() throws SQLException {
1:8072a56:         createStatement().execute(
1:8072a56:                 "alter table constraintest add constraint uc unique (val1)");
1:8072a56:         PreparedStatement insert = prepareStatement(
1:8072a56:                 "insert into constraintest(val1) values ?");
1:8072a56:         PreparedStatement delete = prepareStatement(
1:8072a56:                 "delete from constraintest");
1:8072a56:         // The error happened most frequently in the second iteration, but
1:8072a56:         // it didn't always, so we repeat it ten times to increase the
1:8072a56:         // likelihood of triggering the bug.
1:24d3856:         // DERBY-4097: Increase the number of iterations to increase the
1:24d3856:         // likelihood of exposing another timing-dependent problem with a
1:24d3856:         // WaitError caused by a conflict between the post-commit thread
1:24d3856:         // and the user thread.
1:24d3856:         for (int i = 0; i < 100; i++) {
1:8072a56:             for (int j = 0; j < 1000; j++) {
1:8072a56:                 insert.setInt(1, j);
1:8072a56:                 insert.addBatch();
1:8072a56:             }
1:8072a56:             insert.executeBatch();
1:8072a56:             assertEquals(1000, delete.executeUpdate());
1:8072a56:         }
1:8072a56:     }
1:8072a56: 
1:28e234d:     /**
1:4d5163b:      * Test that a deleted duplicate value on the right side of the slot
1:4d5163b:      * into which a new value is inserted does not hide a non-deleted
1:4d5163b:      * duplicate two slots to the right. DERBY-4028
1:4d5163b:      */
1:4d5163b:     public void testDeletedDuplicateHidesDuplicateOnRightSide()
1:4d5163b:             throws SQLException {
1:4d5163b:         Statement s = createStatement();
1:4d5163b:         s.execute("alter table constraintest add constraint c unique(val1)");
1:4d5163b:         s.execute("insert into constraintest(val1) values '1','2','3'");
1:4d5163b:         // Make sure there's a deleted index entry for val1 = 2
1:4d5163b:         s.execute("delete from constraintest where val1 = '2'");
1:4d5163b:         // Make sure there's an index entry for val1 = 2 after the deleted one
1:4d5163b:         // (the third row will be located after the deleted one because it
1:4d5163b:         // was inserted later and its record id is greater)
1:4d5163b:         s.execute("update constraintest set val1 = '2' where val1 = '3'");
1:4d5163b:         // Insert an index entry in front of the deleted one. It should fail,
1:4d5163b:         // but before DERBY-4028 it was successfully inserted.
1:4d5163b:         assertStatementError("23505", s,
1:4d5163b:                 "update constraintest set val1 = '2' where val1 = '1'");
1:4d5163b:     }
1:4d5163b: 
1:4d5163b:     /**
1:4d5163b:      * Test that a deleted duplicate value on the left side of the slot
1:4d5163b:      * into which a new value is inserted does not hide a non-deleted
1:4d5163b:      * duplicate two slots to the left. DERBY-4028
1:4d5163b:      */
1:4d5163b:     public void testDeletedDuplicateHidesDuplicateOnLeftSide()
1:4d5163b:             throws SQLException {
1:4d5163b:         Statement s = createStatement();
1:4d5163b:         s.execute("alter table constraintest add constraint c unique(val1)");
1:4d5163b:         s.execute("insert into constraintest(val1) values '1','2','3'");
1:4d5163b:         // Make sure there's a deleted index entry for val1 = 2
1:4d5163b:         s.execute("delete from constraintest where val1 = '2'");
1:4d5163b:         // Make sure there's an index entry for val1 = 2 in front of the
1:4d5163b:         // deleted one (the first row will be located in front of the deleted
1:4d5163b:         // one because it was inserted before and its record id is smaller)
1:4d5163b:         s.execute("update constraintest set val1 = '2' where val1 = '1'");
1:4d5163b:         // Insert an index entry after the deleted one. It should fail,
1:4d5163b:         // but before DERBY-4028 it was successfully inserted.
1:4d5163b:         assertStatementError("23505", s,
1:4d5163b:                 "update constraintest set val1 = '2' where val1 = '3'");
1:4d5163b:     }
1:4d5163b: 
1:4f37664:     /**
1:4f37664:      * Test that we can insert and delete the same value multiple times in a
1:4f37664:      * nullable unique index. This used to cause a livelock before DERBY-4081
1:4f37664:      * because the duplicate check on insert sometimes didn't release all
1:4f37664:      * latches.
1:4f37664:      */
1:4f37664:     public void testInsertDeleteContinuouslySameValue() throws SQLException {
1:4f37664:         // Must disable auto-commit for reliable reproduction, otherwise the
1:4f37664:         // post-commit worker thread will remove deleted index rows.
1:4f37664:         setAutoCommit(false);
1:4f37664: 
1:4f37664:         Statement s = createStatement();
1:4f37664:         s.execute("create table d4081(x int unique)");
1:4f37664: 
1:4f37664:         // The loop below did not get past the 372nd iteration before
1:4f37664:         // DERBY-4081 was fixed. Try 500 iterations now.
1:4f37664:         PreparedStatement ins = prepareStatement("insert into d4081 values 0");
1:4f37664:         PreparedStatement del = prepareStatement("delete from d4081");
1:4f37664:         for (int i = 0; i < 500; i++) {
1:4f37664:             ins.execute();
1:4f37664:             del.execute();
1:4f37664:         }
1:4f37664: 
1:4f37664:         // Verify that the table is empty after the last delete operation.
1:4f37664:         assertTableRowCount("D4081", 0);
1:4f37664:     }
1:4f37664: 
1:28e234d:     public static void main(String [] args) {
1:28e234d:         TestResult tr = new TestResult();
1:28e234d:         Test t = suite();
1:28e234d:         t.run(tr);
1:28e234d:         System.out.println(tr.errorCount());
1:28e234d:         Enumeration e = tr.failures();
1:28e234d:         while (e.hasMoreElements()) {
1:28e234d:             ((TestFailure)e.nextElement ()).thrownException().printStackTrace();
1:28e234d:         }
1:28e234d:         System.out.println(tr.failureCount());
1:28e234d:     }
1:28e234d: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite("NullableUniqueConstraintTest");
1: 
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:012a72b
/////////////////////////////////////////////////////////////////////////
0: import java.sql.CallableStatement;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.SupportFilesSetup;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Compress table should recreate the indexes correctly rather
1:      * than ignoring the unique nullable property of the index
1:      * @throws SQLException
1:      */
1:     public void testDerby4677CompressTable() throws SQLException {
1:         Connection con = getConnection();
1:         Statement stmt = con.createStatement();
1:         stmt.executeUpdate("CREATE TABLE TABLE1(NAME1 INT UNIQUE, "+
1:         		"name2 int unique not null, name3 int primary key)");
1:         stmt.execute("call syscs_util.syscs_compress_table('APP','TABLE1',1)");
1:         stmt.executeUpdate("INSERT INTO TABLE1 VALUES(1,11,111)");
1:         //following should run into problem because of constraint on name1
1:         assertStatementError("23505", stmt,
1:         		"INSERT INTO TABLE1 VALUES(1,22,222)");
1:         //following should run into problem because of constraint on name2
1:         assertStatementError("23505", stmt,
1:         		"INSERT INTO TABLE1 VALUES(3,11,333)");
1:         //following should run into problem because of constraint on name3
1:         assertStatementError("23505", stmt,
1:         		"INSERT INTO TABLE1 VALUES(4,44,111)");
1:         stmt.executeUpdate("DROP TABLE TABLE1");    
1:     }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4f37664
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that we can insert and delete the same value multiple times in a
1:      * nullable unique index. This used to cause a livelock before DERBY-4081
1:      * because the duplicate check on insert sometimes didn't release all
1:      * latches.
1:      */
1:     public void testInsertDeleteContinuouslySameValue() throws SQLException {
1:         // Must disable auto-commit for reliable reproduction, otherwise the
1:         // post-commit worker thread will remove deleted index rows.
1:         setAutoCommit(false);
1: 
1:         Statement s = createStatement();
1:         s.execute("create table d4081(x int unique)");
1: 
1:         // The loop below did not get past the 372nd iteration before
1:         // DERBY-4081 was fixed. Try 500 iterations now.
1:         PreparedStatement ins = prepareStatement("insert into d4081 values 0");
1:         PreparedStatement del = prepareStatement("delete from d4081");
1:         for (int i = 0; i < 500; i++) {
1:             ins.execute();
1:             del.execute();
1:         }
1: 
1:         // Verify that the table is empty after the last delete operation.
1:         assertTableRowCount("D4081", 0);
1:     }
1: 
commit:24d3856
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-4097: Increase the number of iterations to increase the
1:         // likelihood of exposing another timing-dependent problem with a
1:         // WaitError caused by a conflict between the post-commit thread
1:         // and the user thread.
1:         for (int i = 0; i < 100; i++) {
commit:4d5163b
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that a deleted duplicate value on the right side of the slot
1:      * into which a new value is inserted does not hide a non-deleted
1:      * duplicate two slots to the right. DERBY-4028
1:      */
1:     public void testDeletedDuplicateHidesDuplicateOnRightSide()
1:             throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("alter table constraintest add constraint c unique(val1)");
1:         s.execute("insert into constraintest(val1) values '1','2','3'");
1:         // Make sure there's a deleted index entry for val1 = 2
1:         s.execute("delete from constraintest where val1 = '2'");
1:         // Make sure there's an index entry for val1 = 2 after the deleted one
1:         // (the third row will be located after the deleted one because it
1:         // was inserted later and its record id is greater)
1:         s.execute("update constraintest set val1 = '2' where val1 = '3'");
1:         // Insert an index entry in front of the deleted one. It should fail,
1:         // but before DERBY-4028 it was successfully inserted.
1:         assertStatementError("23505", s,
1:                 "update constraintest set val1 = '2' where val1 = '1'");
1:     }
1: 
1:     /**
1:      * Test that a deleted duplicate value on the left side of the slot
1:      * into which a new value is inserted does not hide a non-deleted
1:      * duplicate two slots to the left. DERBY-4028
1:      */
1:     public void testDeletedDuplicateHidesDuplicateOnLeftSide()
1:             throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("alter table constraintest add constraint c unique(val1)");
1:         s.execute("insert into constraintest(val1) values '1','2','3'");
1:         // Make sure there's a deleted index entry for val1 = 2
1:         s.execute("delete from constraintest where val1 = '2'");
1:         // Make sure there's an index entry for val1 = 2 in front of the
1:         // deleted one (the first row will be located in front of the deleted
1:         // one because it was inserted before and its record id is smaller)
1:         s.execute("update constraintest set val1 = '2' where val1 = '1'");
1:         // Insert an index entry after the deleted one. It should fail,
1:         // but before DERBY-4028 it was successfully inserted.
1:         assertStatementError("23505", s,
1:                 "update constraintest set val1 = '2' where val1 = '3'");
1:     }
1: 
commit:8072a56
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that repeatedly performing multi-row inserts and deletes spanning
1:      * multiple pages works correctly with nullable unique constraint. This
1:      * used to cause <tt>ERROR XSDA1: An attempt was made to access an out of
1:      * range slot on a page</tt> (DERBY-4027).
1:      */
1:     public void testMixedInsertDelete() throws SQLException {
1:         createStatement().execute(
1:                 "alter table constraintest add constraint uc unique (val1)");
1:         PreparedStatement insert = prepareStatement(
1:                 "insert into constraintest(val1) values ?");
1:         PreparedStatement delete = prepareStatement(
1:                 "delete from constraintest");
1:         // The error happened most frequently in the second iteration, but
1:         // it didn't always, so we repeat it ten times to increase the
1:         // likelihood of triggering the bug.
0:         for (int i = 0; i < 10; i++) {
1:             for (int j = 0; j < 1000; j++) {
1:                 insert.setInt(1, j);
1:                 insert.addBatch();
1:             }
1:             insert.executeBatch();
1:             assertEquals(1000, delete.executeUpdate());
1:         }
1:     }
1: 
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:28e234d
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.NullableUniqueConstraintTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Savepoint;
1: import java.sql.Statement;
1: import java.sql.Types;
1: import java.util.Enumeration;
1: 
1: import junit.framework.Test;
1: import junit.framework.TestFailure;
1: import junit.framework.TestResult;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Test unique constraint
1:  */
1: public class NullableUniqueConstraintTest extends BaseJDBCTestCase {
1:     
1:     /**
1:      * Basic constructor.
1:      */
1:     public NullableUniqueConstraintTest(String name) {
1:         super(name);
1:     }
1:     
1:     /**
1:      * Returns the implemented tests.
1:      *
1:      * @return An instance of <code>Test</code> with the implemented tests to
1:      *         run.
1:      */
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("NullableUniqueConstraintTest");
1:         suite.addTest(TestConfiguration.defaultSuite(
1:                             NullableUniqueConstraintTest.class));
1:         return suite;
1:     }
1:     
1:     /**
1:      * Create table for test cases to use.
1:      */
1:     protected void setUp() throws Exception {
1:         Connection con = getConnection();
1:         Statement stmt = con.createStatement();
1:         stmt.executeUpdate("create table constraintest (val1 varchar (20), " +
1:                 "val2 varchar (20), val3 varchar (20), val4 varchar (20))");
1:     }
1:     
1:     protected void tearDown() throws Exception {
1:         Connection con = getConnection();
1:         con.commit ();
1:         Statement stmt = con.createStatement();
1:         stmt.executeUpdate("drop table constraintest");
1:         stmt.close ();
1:         con.commit ();
1:         super.tearDown();
1:     }
1:     /**
1:      * Basic test of Unique Constraint using single part key.
1:      * @throws SQLException
1:      */
1:     public void testSingleKeyPartUniqueConstraint() throws SQLException {
1:         Connection con = getConnection();
1:         Statement stmt = con.createStatement();
1:         //create unique constraint without not null
1:         stmt.executeUpdate("alter table constraintest add constraint " +
1:                 "u_con unique (val1)");
1:         PreparedStatement ps  = con.prepareStatement("insert into " +
1:                 "constraintest (val1, val2) values (?, ?)");
1:         ps.setString(1, "test");
1:         ps.setString(2, "should pass");
1:         ps.execute();
1:         try {
1:             ps.setString(1, "test");
1:             ps.setString(2, "should fail");
1:             ps.execute();
1:             fail("duplicate key inserted expected '23505'");
1:         }
1:         catch (SQLException e) {
1:             assertSQLState("inserting duplicate", "23505", e);
1:         }
1:         ps.setNull(1, Types.VARCHAR);
1:         ps.setString(2, "should pass");
1:         ps.execute();
1:         ps.setNull(1, Types.VARCHAR);
1:         ps.setString(2, "should pass");
1:         ps.execute();
1:         //check if there are two record with val1=null
1:         ResultSet rs = stmt.executeQuery("select count (*) from " +
1:                 "constraintest where val1 is null");
1:         rs.next();
1:         assertEquals("expected 2 rows", 2, rs.getInt(1));
1:         //try creating constraint with existing value
1:         stmt.execute("alter table constraintest drop constraint u_con");
1:         stmt.execute("delete from constraintest where val1 is null");
1:         con.commit ();
1:         ps.setString(1, "test");
1:         ps.setString(2, "removeit");
1:         ps.execute();
1:         //constraint dropped successfully
1:         //create constraint - must fail
1:         try {
1:             stmt.executeUpdate("alter table constraintest add constraint " +
1:                 "u_con unique (val1)");
1:             fail ("create unique constraint with duplicate key in " +
1:                     "table should fail");
1:         }
1:         catch (SQLException e) {
1:             assertSQLState("creating unique constraint when duplicate" +
1:                     " keys are present  duplicate", "23505", e);
1:         }
1:         //remove duplicate record
1:         stmt.execute ("delete from constraintest where val2 = 'removeit'");
1:         //should be fine now
1:         stmt.executeUpdate("alter table constraintest add constraint " +
1:                 "u_con unique (val1)");
1:         con.commit();
1:         stmt.close ();
1:         ps.close();
1:     }
1:     
1:     /**
1:      * Basic test of Unique Constraint using multipart part key.
1:      * @throws SQLException
1:      */
1:     public void testMultipartKeyUniqueConstraint() throws SQLException {
1:         Connection con = getConnection();
1:         Statement stmt = con.createStatement();
1:         //create unique constraint without not null
1:         stmt.executeUpdate("alter table constraintest add constraint " +
1:                 "u_con unique (val1, val2, val3)");
1:         PreparedStatement ps  = con.prepareStatement("insert into " +
1:                 "constraintest (val1, val2, val3, val4) values (?, ?, ?, ?)");
1:         ps.setString(1, "part1");
1:         ps.setString(2, "part2");
1:         ps.setString(3, "part3");
1:         ps.setString(4, "should pass");
1:         ps.execute();
1:         try {
1:             ps.setString(1, "part1");
1:             ps.setString(2, "part2");
1:             ps.setString(3, "part3");
1:             ps.setString(4, "should fail");
1:             ps.execute();
1:             fail("duplicate key inserted expected '23505'");
1:         }
1:         catch (SQLException e) {
1:             assertSQLState("inserting duplicate", "23505", e);
1:         }
1:         ps.setNull(1, Types.VARCHAR);
1:         ps.setString(2, "part2");
1:         ps.setString(3, "part3");
1:         ps.setString(4, "should pass");
1:         ps.execute();
1:         ps.setNull(1, Types.VARCHAR);
1:         ps.setString(2, "part2");
1:         ps.setString(3, "part3");
1:         ps.setString(4, "should pass");
1:         ps.execute();
1:         ps.setString(1, "part1");
1:         ps.setNull(2, Types.VARCHAR);
1:         ps.setString(3, "part3");
1:         ps.setString(4, "should pass");
1:         ps.execute();
1:         //check if there are two record with val1=null
1:         ResultSet rs = stmt.executeQuery("select count (*) from " +
1:                 "constraintest where val1 is null");
1:         rs.next();
1:         assertEquals("expected 2 rows", 2, rs.getInt(1));
1:         //try creating constraint with existing value
1:         stmt.execute("alter table constraintest drop constraint u_con");
1:         con.commit ();
1:         ps.setString(1, "part1");
1:         ps.setString(2, "part2");
1:         ps.setString(3, "part3");
1:         ps.setString(4, "removeit");
1:         ps.execute();
1:         //constraint dropped successfully
1:         //create constraint - must fail
1:         try {
1:             stmt.executeUpdate("alter table constraintest add constraint " +
1:                 "u_con unique (val1, val2, val3)");
1:             fail ("create unique constraint with duplicate key in " +
1:                     "table should fail");
1:         }
1:         catch (SQLException e) {
1:             assertSQLState("creating unique constraint when duplicate" +
1:                     " keys are present  duplicate", "23505", e);
1:         }
1:         //remove duplicate record
1:         stmt.execute ("delete from constraintest where val4 = 'removeit'");
1:         //should be fine now
1:         stmt.executeUpdate("alter table constraintest add constraint " +
1:                 "u_con unique (val1, val2, val3)");
1:         con.commit();
1:         stmt.close ();
1:         ps.close();
1:     }
1:     
1:     /**
1:      * Inserts a duplicate key of a deleted key within same transaction.
1:      * @throws java.sql.SQLException
1:      */
1:     public void testWithDeletedKey() throws SQLException {
1:         Connection con = getConnection();
1:         Statement stmt = con.createStatement();
1:         //create unique constraint without not null
1:         stmt.executeUpdate("alter table constraintest add constraint " +
1:                 "u_con unique (val1, val2, val3)");
1:         PreparedStatement ps  = con.prepareStatement("insert into " +
1:                 "constraintest (val1, val2, val3, val4) values (?, ?, ?, ?)");
1:         ps.setString(1, "part1");
1:         ps.setString(2, "part2");
1:         ps.setString(3, "part3");
1:         ps.setString(4, "should pass");
1:         ps.execute();
1:         //delete a record within transaction and try inserting same record
1:         con.setAutoCommit(false);
1:         stmt.executeUpdate("delete from constraintest where " +
1:                 "val1 = 'part1' and val2 = 'part2' and val3 = 'part3'");
1:         //insert same record
1:         ps.setString(1, "part1");
1:         ps.setString(2, "part2");
1:         ps.setString(3, "part3");
1:         ps.setString(4, "should pass");
1:         ps.execute();
1:         stmt.close();
1:         ps.close();
1:         con.commit();
1:     }
1:     
1:     public void testDistinctQuery() throws SQLException {
1:         Connection con = getConnection();
1:         Statement stmt = con.createStatement();
1:         stmt.executeUpdate("alter table constraintest add constraint " +
1:                 "u_con unique (val1)");
1:         PreparedStatement ps  = con.prepareStatement("insert into " +
1:                 "constraintest (val1) values (?)");
1:         //insert 5 null keys
1:         for (int i = 0; i < 5; i++) {
1:             ps.setNull(1, Types.VARCHAR);
1:             ps.executeUpdate();
1:         }
1:         
1:         //insert 5 null keys
1:         for (int i = 0; i < 5; i++) {
1:             ps.setString(1, String.valueOf(i));
1:             ps.executeUpdate();
1:         }
1:         ResultSet rs = stmt.executeQuery("select count (*) from constraintest");
1:         rs.next();
1:         assertEquals(10, rs.getInt(1));
1:         rs.close ();
1: 
1:         rs = stmt.executeQuery("select count (distinct (val1)) from " +
1:                 "constraintest");
1:         rs.next();
1:         assertEquals(5, rs.getInt(1));
1:         rs.close ();
1:     }
1:     /**
1:      * Test null ordering of the key in order by query.
1:      * @throws java.sql.SQLException
1:      */
1:     public void testNullOrdering() throws SQLException {
1:         Connection con = getConnection();
1:         Statement stmt = con.createStatement();
1:         stmt.executeUpdate("alter table constraintest add constraint " +
1:                 "u_con unique (val1)");
1:         PreparedStatement ps  = con.prepareStatement("insert into " +
1:                 "constraintest (val1) values (?)");
1:         //insert 5 null keys
1:         for (int i = 0; i < 5; i++) {
1:             ps.setNull(1, Types.VARCHAR);
1:             ps.executeUpdate();
1:         }
1:         
1:         //insert 5 non null keys
1:         for (int i = 0; i < 5; i++) {
1:             ps.setString(1, String.valueOf(i));
1:             ps.executeUpdate();
1:         }
1:         
1:         ResultSet rs = stmt.executeQuery("select val1 from constraintest " +
1:                             "order by val1 nulls last");
1:         //first 5 should be non null
1:         for (int i = 0; i < 5; i++) {
1:             rs.next();
1:             assertEquals (String.valueOf(i), rs.getString(1));
1:         }
1:         
1:         //next 5 should be null
1:         for (int i = 0; i < 5; i++) {
1:             rs.next();
1:             assertEquals (null, rs.getString(1));
1:         }
1:         rs.close ();
1:         rs = stmt.executeQuery("select val1 from constraintest " +
1:                             "order by val1 nulls first");
1:         //first 5 should be null
1:         for (int i = 0; i < 5; i++) {
1:             rs.next();
1:             assertEquals (null, rs.getString(1));
1:         }
1:         
1:         //next 5 should be null
1:         for (int i = 0; i < 5; i++) {
1:             rs.next();
1:             assertEquals (String.valueOf(i), rs.getString(1));
1:         }
1:         rs.close ();
1:     }
1:     
1:     /**
1:      * Tries to forces internal routibe to travel across
1:      * pages to check for duplicates. It first inserts large 
1:      * number of records assuming they occupy multiple pages 
1:      * in index and then tries to insert duplicates of each 
1:      * of them. Rrecords at the page boundry will require 
1:      * duplucate checking routine to check more than one page 
1:      * to look for locate. If that routine is not working properly 
1:      * duplucate will be inserted in tree.
1:      * @throws java.sql.SQLException
1:      */
1:     public void testComparisonAcrossPages() throws SQLException {
1:         Connection con = getConnection();
1:         Statement stmt = con.createStatement();
1:         //create unique constraint without not null
1:         stmt.executeUpdate("alter table constraintest add constraint " +
1:                 "u_con unique (val1)");
1:         PreparedStatement ps  = con.prepareStatement("insert into " +
1:                 "constraintest (val1, val2) values (?, ?)");
1:         for (int i = 0; i < 500; i++) {
1:             ps.setString(1, "" + i);
1:             ps.setString (2, "" + i);
1:             ps.execute();
1:         }
1:         
1:         for (int i = 0; i < 500; i++) {
1:             ps.setString(1, "" + i);
1:             ps.setString (2, "" + i);
1:             try {
1:                 ps.execute();
1:                 fail("duplicate key inserted expected '23505'");
1:             }
1:             catch (SQLException e) {
1:                 assertSQLState("inserting duplicate", "23505", e);  
1:             }
1:         }
1:         //mark all records except for first, as deleted and try 
1:         //inserting duplicate. This will force comparison 
1:         //logic to scan all the records to find another rcord for 
1:         //comparison.
1:         con.setAutoCommit(false);
1:         assertEquals (499, stmt.executeUpdate (
1:                 "delete from constraintest where val1 != '0'"));
1:         Savepoint deleted = con.setSavepoint("deleted");
1:         ps.setString(1, "0");
1:         ps.setString (2, "test");
1:         try {
1:             ps.execute();
1:             fail ("managed to insert a duplicate");
1:         }
1:         catch (SQLException e) {
1:             assertSQLState("inserting duplicate", "23505",  e);
1:         }
1:         //rollback to check point and try to insert a record 
1:         //at the middle
1:         con.rollback(deleted);
1:         ps.setString(1, "250");
1:         ps.setString(2, "test");
1:         ps.execute ();
1:         //rollback to check point and try 
1:         //inserting at end
1:         con.rollback(deleted);
1:         ps.setString(1, "499");
1:         ps.setString (2, "test");
1:         ps.execute ();
1: 
1:         ResultSet rs = stmt.executeQuery("select count (*) from constraintest");
1:         rs.next ();
1:         assertEquals(2, rs.getInt(1));
1:         
1:         con.rollback ();
1:         ps.close();
1:         stmt.close();
1:         ps.close();
1:     }
1:     
1:     /**
1:      * Checks is insert for updates uses deffered inserts or not. 
1:      * It inserts two part keys in the form of
1:      * part1 part2
1:      * 1        1
1:      * 1        2
1:      * 1        3
1:      * 2        1
1:      * 2        2
1:      * 2        3
1:      * 3        1
1:      * 3        2
1:      * 3        3
1:      * 
1:      * and then tries to update all the records so that the values 
1:      * part1 and part2 are interchanged. Internally updates are 
1:      * treated as delete and insert and unless inserts are deffered 
1:      * till all deletes are over, there will be unique constraint 
1:      * violation.
1:      * @throws java.sql.SQLException
1:      */
1:     public void testDefferedInsert() throws SQLException {
1:         Connection con = getConnection();
1:         Statement stmt = con.createStatement();
1:         //create unique constraint without not null
1:         stmt.executeUpdate("alter table constraintest add constraint " +
1:                 "u_con unique (val1, val2)");
1:         PreparedStatement ps  = con.prepareStatement("insert into " +
1:                 "constraintest (val1, val2) values (?, ?)");
1:         for (int i = 0; i < 5; i++) {
1:             for (int j = 0; j < 5; j++) {
1:                 ps.setString(1, String.valueOf(i));
1:                 ps.setString(2, String.valueOf(j));
1:                 ps.executeUpdate();
1:             }
1:         }
1:         //interchange the values of val1 and val2
1:         //this will fail unless its handled by deffered inserts
1:         assertEquals("updating 25 records", 25, 
1:                 stmt.executeUpdate("update constraintest set " +
1:                 "val1 = val2, val2 = val1"));
1:     }
1:     public static void main(String [] args) {
1:         TestResult tr = new TestResult();
1:         Test t = suite();
1:         t.run(tr);
1:         System.out.println(tr.errorCount());
1:         Enumeration e = tr.failures();
1:         while (e.hasMoreElements()) {
1:             ((TestFailure)e.nextElement ()).thrownException().printStackTrace();
1:         }
1:         System.out.println(tr.failureCount());
1:     }
1: }
============================================================================