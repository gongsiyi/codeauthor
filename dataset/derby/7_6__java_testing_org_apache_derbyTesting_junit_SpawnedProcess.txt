1:a63ab5e: /*
1:17227cf:  *
1:a63ab5e:  * Derby - Class org.apache.derbyTesting.junit.SpawnedProcess
1:17227cf:  *
1:a63ab5e:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:a63ab5e:  * contributor license agreements.  See the NOTICE file distributed with
1:a63ab5e:  * this work for additional information regarding copyright ownership.
1:a63ab5e:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:a63ab5e:  * (the "License"); you may not use this file except in compliance with
1:a63ab5e:  * the License.  You may obtain a copy of the License at
3:a63ab5e:  *
1:a63ab5e:  *    http://www.apache.org/licenses/LICENSE-2.0
1:a63ab5e:  *
1:a63ab5e:  * Unless required by applicable law or agreed to in writing, 
1:a63ab5e:  * software distributed under the License is distributed on an 
1:a63ab5e:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:a63ab5e:  * either express or implied. See the License for the specific 
1:a63ab5e:  * language governing permissions and limitations under the License.
1:a63ab5e:  */
1:a63ab5e: package org.apache.derbyTesting.junit;
9:a63ab5e: 
1:a63ab5e: import java.io.ByteArrayOutputStream;
1:8ad67d3: import java.io.File;
1:a63ab5e: import java.io.IOException;
1:a63ab5e: import java.io.InputStream;
1:04846d1: import java.io.OutputStream;
1:a63ab5e: import java.io.PrintStream;
1:8ad67d3: import java.lang.reflect.Field;
1:8ad67d3: import java.security.AccessController;
1:8ad67d3: import java.security.PrivilegedActionException;
1:8ad67d3: import java.security.PrivilegedExceptionAction;
1:df02986: 
1:04846d1: import java.util.Timer;
1:04846d1: import java.util.TimerTask;
1:8ad67d3: import static junit.framework.Assert.assertTrue;
1:8ad67d3: import static org.apache.derbyTesting.junit.BaseTestCase.execJavaCmd;
1:8ad67d3: import static org.apache.derbyTesting.junit.BaseTestCase.getJavaExecutableName;
1:8ad67d3: import static org.apache.derbyTesting.junit.BaseTestCase.isIBMJVM;
1:8ad67d3: import static org.apache.derbyTesting.junit.BaseTestCase.isWindowsPlatform;
1:04846d1: 
1:04846d1: /**
1:a63ab5e:  * Utility code that wraps a spawned process (Java Process object).
1:04846d1:  * <p>
1:04846d1:  * There are three main aspects handled by this class:
1:04846d1:  * <ul> <li>Draining the output streams of the process.<br/>
1:04846d1:  *          Happens automatically, the output gathered can be accessed with
1:04846d1:  *          {@linkplain #getFailMessage}, {@linkplain #getFullServerError},
1:04846d1:  *          {@linkplain #getFullServerOutput}, and
1:04846d1:  *          {@linkplain #getNextServerOutput}</li>
1:04846d1:  *      <li>Waiting for process completion, followed by cleanup (see
1:04846d1:  *          {@linkplain #complete()} and {@linkplain #complete(long)})</li>
1:04846d1:  *      <li>Forcibly destroying a process that live too long, for instance
1:04846d1:  *          if inter-process communication hangs. This happens automatically
1:04846d1:  *          if a threshold value is exceeded.</li>
1:04846d1:  * </ul>
1:04846d1:  * <p>
1:04846d1:  * <em>Implementation notes</em>: Active waiting is employed when waiting for
1:04846d1:  * the process to complete. This is considered acceptable since the expected
1:04846d1:  * usage pattern is to spawn the process, execute a set of tests, and then
1:04846d1:  * finally asking the process to shut down. Waiting for the process to
1:04846d1:  * complete is the last step, and a process typically lives only for a short
1:04846d1:  * period of time anyway (often only for seconds, seldom more than a few
1:04846d1:  * minutes).
1:04846d1:  * <br/>
1:04846d1:  * Forcibly destroying processes that live too long makes the test run
1:04846d1:  * continue even when facing inter-process communication hangs. The prime
1:04846d1:  * example is when both the client and the server are waiting for the other
1:04846d1:  * party to send data. Since the timeout is very high this feature is intended
1:04846d1:  * to avoid automated test runs from hanging indefinitely, for instance due to
1:04846d1:  * environmental issues affecting the process.
1:a63ab5e:  */
1:04846d1: //@NotThreadSafe
1:a63ab5e: public final class SpawnedProcess {
1:a63ab5e: 
1:04846d1:     private static final String TAG = "DEBUG: {SpawnedProcess} ";
1:04846d1:     private static Timer KILL_TIMER;
1:04846d1: 
1:04846d1:     /**
1:04846d1:      * Property allowing the kill threshold to be overridden.
1:04846d1:      * <p>
1:04846d1:      * Interprets the numeric value as milliseconds, ignored if non-numeric.
1:04846d1:      * Overriding this value may be required if the test machine is extremely
1:04846d1:      * slow, or you want to kill hung processes earlier for some reason.
1:04846d1:      */
1:04846d1:     private static final String KILL_THRESHOLD_PROPERTY =
1:04846d1:             "derby.tests.process.killThreshold";
1:04846d1:     private static final long KILL_THRESHOLD_DEFAULT = 45*60*1000; // 45 minutes
1:04846d1:     /** The maximum allowed time for a process to live. */
1:04846d1:     private static final long KILL_THRESHOLD;
1:04846d1:     static {
1:04846d1:         long tmpThreshold = KILL_THRESHOLD_DEFAULT;
1:04846d1:         String tmp = BaseTestCase.getSystemProperty(KILL_THRESHOLD_PROPERTY);
1:04846d1:         if (tmp != null) {
1:04846d1:             try {
1:04846d1:                 tmpThreshold = Long.parseLong(tmp);
1:04846d1:             } catch (NumberFormatException nfe) {
1:04846d1:                 // Ignore, use the default set previously.
1:04846d1:                 System.err.println(TAG + "Invalid kill threshold: " + tmp);
1:04846d1:             }
1:04846d1:         }
1:04846d1:         KILL_THRESHOLD = tmpThreshold;
1:04846d1:     }
1:04846d1: 
1:04846d1:     private static void sleep(long ms) {
1:04846d1:         try {
1:04846d1:             Thread.sleep(ms);
1:04846d1:         } catch (InterruptedException ie) {
1:04846d1:             // Ignore the interrupt. We want to make sure the process
1:04846d1:             // terminates before returning, and we don't want to preserve
1:04846d1:             // the interrupt flag because it causes Derby to shut down. These
1:04846d1:             // are test requirements and don't apply for production code.
1:f09789b:             // Print a notice to stdout.
1:04846d1:             System.out.println(TAG + "Interrupted while sleeping (ignored)");
1:04846d1:         }
1:04846d1:     }
1:04846d1: 
1:a63ab5e:     private final String name;
1:17227cf: 
1:a63ab5e:     private final Process javaProcess;
1:a63ab5e: 
1:df02986:     private final StreamSaver errSaver;
1:a63ab5e: 
1:df02986:     private final StreamSaver outSaver;
1:a63ab5e: 
1:d96e3aa:     private boolean suppressOutput;
1:d96e3aa: 
1:04846d1:     private final TimerTask killTask;
1:04846d1: 
1:df02986:     /**
1:04846d1:      * Creates a new wrapper to handle the given process.
1:04846d1:      *
1:04846d1:      * @param javaProcess a (running) process
1:04846d1:      * @param name name to associate with the process
1:04846d1:      */
1:df02986:     public SpawnedProcess(Process javaProcess, String name) {
1:a63ab5e:         this.javaProcess = javaProcess;
1:a63ab5e:         this.name = name;
1:04846d1: 
1:04846d1:         errSaver = startStreamSaver(javaProcess.getErrorStream(), name
1:a63ab5e:                 .concat(":System.err"));
1:04846d1:         outSaver = startStreamSaver(javaProcess.getInputStream(), name
1:a63ab5e:                 .concat(":System.out"));
1:04846d1:         killTask = scheduleKill(javaProcess, name);
1:17227cf:     }
1:a63ab5e: 
1:04846d1:     /**
1:04846d1:      * Schedules a task to kill/terminate the task after a predefined timeout.
1:04846d1:      *
1:04846d1:      * @param name name of the process
1:04846d1:      * @param process the process
1:04846d1:      * @return The task object.
1:04846d1:      */
1:04846d1:     private TimerTask scheduleKill(Process process, String name) {
1:04846d1:         synchronized (KILL_THRESHOLD_PROPERTY) {
1:04846d1:             if (KILL_TIMER == null) {
1:85fa204:                 // Can't use 1.5 methods yet due to J2ME. Add name later.
1:85fa204:                 KILL_TIMER = new Timer(true);
1:04846d1:             }        
1:04846d1:         }
1:04846d1:         TimerTask killer = new ProcessKillerTask(process, name);
1:04846d1:         KILL_TIMER.schedule(killer, KILL_THRESHOLD);
1:04846d1:         return killer;
1:04846d1:     }
1:04846d1: 
1:04846d1:     /**
1:04846d1:      * Causes output obtained from the process to be suppressed when
1:d96e3aa:      * executing the {@code complete}-methods.
1:d96e3aa:      *
1:d96e3aa:      * @see #getFullServerOutput() to obtain suppressed output from stdout
1:d96e3aa:      * @see #getFullServerError() to obtain suppressed output from stderr
1:d96e3aa:      */
1:d96e3aa:     public void suppressOutputOnComplete() {
1:d96e3aa:         suppressOutput = true;
1:d96e3aa:     }
1:d96e3aa: 
1:d96e3aa:     /**
1:a63ab5e:      * Get the Java Process object
1:17227cf:      */
1:a63ab5e:     public Process getProcess() {
1:a63ab5e:         return javaProcess;
1:17227cf:     }
1:a63ab5e:     
1:17227cf:     /**
1:df02986:      * <p>
1:a63ab5e:      * Get the full server output (stdout) as a string using the default
1:df02986:      * encoding which is assumed is how it was originally written.
1:df02986:      * </p>
1:df02986:      *
1:df02986:      * <p>
1:df02986:      * This method should only be called after the process has completed.
1:04846d1:      * That is, {@link #complete()} or {@link #complete(long)}
1:df02986:      * should be called first.
1:df02986:      * </p>
1:a63ab5e:      */
1:d96e3aa:     public String getFullServerOutput() throws InterruptedException {
1:df02986:         // First wait until we've read all the output.
1:df02986:         outSaver.thread.join();
1:df02986: 
2:a63ab5e:         synchronized (this) {
1:df02986:             return outSaver.stream.toString();
1:17227cf:         }
1:17227cf:     }
1:a63ab5e:     
2:a63ab5e:     /**
1:d96e3aa:      * Get the full server error output (stderr) as a string using the default
1:d96e3aa:      * encoding which is assumed is how it was originally written.
1:d96e3aa:      * <p>
1:d96e3aa:      * This method should only be called after the process has completed.
1:04846d1:      * That is, {@link #complete()} or {@link #complete(long)}
1:d96e3aa:      * should be called first.
1:d96e3aa:      */
1:d96e3aa:     public String getFullServerError() throws InterruptedException {
1:d96e3aa:         // First wait until we've read all the output on stderr.
1:df02986:         errSaver.thread.join();
1:df02986: 
1:d96e3aa:         synchronized (this) {
1:d96e3aa:             return errSaver.stream.toString();
1:d96e3aa:         }
1:d96e3aa:     }
1:d96e3aa: 
1:d96e3aa:     /**
1:a63ab5e:      * Position offset for getNextServerOutput().
1:a63ab5e:      */
1:a63ab5e:     int stdOutReadOffset;
1:a63ab5e:     /**
1:a63ab5e:      * Get the next set of server output (stdout) as a string using the default
1:04846d1:      * encoding which is assumed is how it was originally
1:a63ab5e:      * written. Assumes a single caller is executing the calls
1:a63ab5e:      * to this method.
1:a63ab5e:      */
1:04846d1:     public String getNextServerOutput() {
1:a63ab5e:         byte[] fullData;
1:a63ab5e:         synchronized (this) {
1:df02986:             fullData = outSaver.stream.toByteArray();
6:a63ab5e:         }
1:d96e3aa:         
1:a63ab5e:         String output = new String(fullData, stdOutReadOffset,
1:a63ab5e:                 fullData.length - stdOutReadOffset);
1:a63ab5e:         stdOutReadOffset = fullData.length;
1:a63ab5e:         return output;
1:a63ab5e:     }
1:a63ab5e:     /**
1:a63ab5e:      * Get a fail message that is the passed in reason plus
1:a63ab5e:      * the stderr and stdout for any output written. Allows
1:a63ab5e:      * easier debugging if the reason the process failed is there!
1:a63ab5e:      */
1:04846d1:     public String getFailMessage(String reason) {
1:04846d1:         sleep(500);
1:a63ab5e:         StringBuffer sb = new StringBuffer();
1:a63ab5e:         sb.append(reason);
1:a63ab5e:         sb.append(":Spawned ");
1:a63ab5e:         sb.append(name);
1:a63ab5e:         sb.append(" exitCode=");
1:a63ab5e:         try {
1:a63ab5e:             sb.append(javaProcess.exitValue());
1:a63ab5e:         } catch (IllegalThreadStateException e) {
1:a63ab5e:             sb.append("running");
1:a63ab5e:         }
1:df02986: 
1:df02986:         ByteArrayOutputStream err = errSaver.stream;
1:df02986:         ByteArrayOutputStream out = outSaver.stream;
1:df02986: 
1:a63ab5e:         synchronized (this) {
1:a63ab5e:             if (err.size() != 0)
3:a63ab5e:             {
1:a63ab5e:                 sb.append("\nSTDERR:\n");
1:a63ab5e:                 sb.append(err.toString());          
1:a63ab5e:             }
1:a63ab5e:             if (out.size() != 0)
1:a63ab5e:             {
1:a63ab5e:                 sb.append("\nSTDOUT:\n");
1:a63ab5e:                 sb.append(out.toString());          
1:a63ab5e:             }
1:a63ab5e:        }
1:a63ab5e:        return sb.toString();
1:a63ab5e:     }
1:a63ab5e: 
1:df02986:     /**
1:04846d1:      * Waits for the process to terminate.
1:04846d1:      * <p>
1:04846d1:      * This call will block until one of the following conditions are met:
1:04846d1:      * <ul> <li>the process terminates on its own</li>
1:04846d1:      *      <li>the hung-process watchdog mechanism forcibly terminates the
1:04846d1:      *          process (see {@linkplain #scheduleKill})</li>
1:04846d1:      * @return The process exit code.
1:04846d1:      * @throws IOException if printing diagnostics fails
1:a63ab5e:      */
1:04846d1:     public int complete()
1:04846d1:             throws IOException {
1:04846d1:         return complete(Long.MAX_VALUE);         
1:04846d1:     }
1:04846d1: 
1:04846d1:     /**
1:04846d1:      * Waits for the process to terminate, forcibly terminating it if it
1:04846d1:      * takes longer than the specified timeout.
1:04846d1:      * <p>
1:04846d1:      * This call will block until one of the following conditions are met:
1:04846d1:      * <ul> <li>the process terminates on its own</li>
1:04846d1:      *      <li>the timeout is exceeded, at which point the process is
1:04846d1:      *          forcibly destroyed</li>
1:04846d1:      *      <li>the hung-process watchdog mechanism forcibly terminates the
1:04846d1:      *          process (see {@linkplain #scheduleKill})</li>
1:f6df184:      * @param timeout the number of milliseconds to wait for the process
1:f6df184:      *                to terminate normally before destroying it
1:04846d1:      * @return The process exit code.
1:04846d1:      * @throws IOException if printing diagnostics fails
1:04846d1:      */
1:04846d1:     public int complete(long timeout)
1:04846d1:             throws IOException {
1:04846d1:         long start = System.currentTimeMillis();
1:04846d1:         Integer exitCode = null;
1:04846d1:         while (exitCode == null) {
1:04846d1:             try {
1:39b3237:                 exitCode = javaProcess.exitValue();
1:04846d1:             } catch (IllegalThreadStateException itse) {
1:04846d1:                 // This exception means the process is running.
1:04846d1:                 if (System.currentTimeMillis() - start > timeout) {
1:04846d1:                     javaProcess.destroy();
1:04846d1:                 }
1:04846d1:                 sleep(500);
1:04846d1:             }
1:04846d1:         }
1:04846d1: 
1:04846d1:         // Clean up
1:04846d1:         killTask.cancel();
1:04846d1:         joinWith(errSaver.thread);
1:04846d1:         joinWith(outSaver.thread);
1:f09789b:         cleanupProcess();
1:04846d1:         printDiagnostics(exitCode.intValue());
1:04846d1:         return exitCode.intValue();
1:859720d:     }
1:a63ab5e:     
1:a63ab5e:     /**
1:04846d1:      * Cleans up the process, explicitly closing the streams associated with it.
1:a63ab5e:      */
1:04846d1:     private void cleanupProcess() {
1:04846d1:         // Doing this is considered best practice.
1:04846d1:         closeStream(javaProcess.getOutputStream());
1:04846d1:         closeStream(javaProcess.getErrorStream());
1:04846d1:         closeStream(javaProcess.getInputStream());
1:04846d1:         javaProcess.destroy();
1:04846d1:     }
1:04846d1: 
1:04846d1:     /**
1:04846d1:      * Prints diagnostics to stdout/stderr if the process failed.
1:04846d1:      *
1:04846d1:      * @param exitCode the exit code of the spawned process
1:04846d1:      * @throws IOException if writing to an output stream fails
1:04846d1:      * @see #suppressOutput
1:04846d1:      */
1:04846d1:     private synchronized void printDiagnostics(int exitCode)
1:04846d1:             throws IOException {
1:04846d1:         // Always write the error, except when suppressed.
1:df02986:         ByteArrayOutputStream err = errSaver.stream;
1:04846d1:         if (!suppressOutput && err.size() != 0) {
1:04846d1:             System.err.println("START-SPAWNED:" + name + " ERROR OUTPUT:");
1:04846d1:             err.writeTo(System.err);
1:04846d1:             System.err.println("END-SPAWNED  :" + name + " ERROR OUTPUT:");
1:04846d1:         }
1:04846d1: 
1:04846d1:         // Only write contents of stdout if it appears the server
1:04846d1:         // failed in some way, or output is suppressed.
1:df02986:         ByteArrayOutputStream out = outSaver.stream;
1:04846d1:         if (!suppressOutput && exitCode != 0 && out.size() != 0) {
1:04846d1:             System.out.println("START-SPAWNED:" + name
1:04846d1:                     + " STANDARD OUTPUT: exit code=" + exitCode);
1:04846d1:             out.writeTo(System.out);
1:04846d1:             System.out.println("END-SPAWNED  :" + name
1:04846d1:                     + " STANDARD OUTPUT:");
1:04846d1:         }
1:04846d1:     }
1:04846d1: 
1:04846d1:     /** Joins up with the specified thread. */
1:04846d1:     private void joinWith(Thread t) {
1:04846d1:         try {
1:04846d1:             t.join();
1:04846d1:         } catch (InterruptedException ie) {
1:04846d1:             // Ignore the interrupt. We want to make sure the process
1:04846d1:             // terminates before returning, and we don't want to preserve
1:04846d1:             // the interrupt flag because it causes Derby to shut down. These
1:04846d1:             // are test requirements and don't apply for production code.
1:f09789b:             // Print a notice to stdout.
1:04846d1:             System.out.println(TAG + "Interrupted while joining " +
1:04846d1:                     "with thread '" + t.toString() + "'");
1:04846d1:         }
1:04846d1:     }
1:04846d1: 
1:04846d1:     /**
1:04846d1:      * Closes the specified stream, ignoring any exceptions.
1:04846d1:      *
1:04846d1:      * @param stream stream to close (may be {@code null})
1:04846d1:      */
1:04846d1:     private void closeStream(Object stream) {
1:04846d1:         if (stream instanceof InputStream) {
1:04846d1:             try {
1:04846d1:                 ((InputStream)stream).close();
1:04846d1:             } catch (IOException ioe) {
1:04846d1:                 // Ignore exception on close
1:a63ab5e:             }
1:04846d1:         } else if (stream instanceof OutputStream) {
1:04846d1:             try {
1:04846d1:                 ((OutputStream)stream).close();
1:04846d1:             } catch (IOException ioe) {
1:04846d1:                 // Ignore exception on close
1:a63ab5e:             }
1:a63ab5e:         }
1:a63ab5e:     }
1:a63ab5e: 
1:a63ab5e:     /**
1:df02986:      * Class holding references to a stream that receives the output from a
1:df02986:      * process and a thread that reads the process output and passes it on
1:df02986:      * to the stream.
1:df02986:      */
1:df02986:     private static class StreamSaver {
1:df02986:         final ByteArrayOutputStream stream;
1:df02986:         final Thread thread;
1:df02986:         StreamSaver(ByteArrayOutputStream stream, Thread thread) {
1:df02986:             this.stream = stream;
1:df02986:             this.thread = thread;
1:df02986:         }
1:df02986:     }
1:df02986: 
1:a63ab5e:     /**
1:04846d1:      * Creates and starts a stream saver that reads the specified input stream
1:04846d1:      * in a separate stream.
1:04846d1:      *
1:04846d1:      * @param in input stream to read from
1:04846d1:      * @param name name of the thread
1:04846d1:      * @return A {@code StreamSaver} object.
1:04846d1:      */
1:04846d1:     private StreamSaver startStreamSaver(final InputStream in,
1:df02986:             final String name) {
1:a63ab5e: 
1:a63ab5e:         final ByteArrayOutputStream out = new ByteArrayOutputStream() {
1:a63ab5e:             public void reset() {
1:a63ab5e:                 super.reset();
1:a63ab5e:                 new Throwable("WWW").printStackTrace(System.out);
1:a63ab5e:             }
1:a63ab5e: 
1:a63ab5e:         };
1:a63ab5e: 
1:a63ab5e:         Thread streamReader = new Thread(new Runnable() {
1:a63ab5e: 
1:a63ab5e:             public void run() {
1:a63ab5e:                 try {
1:a63ab5e:                     byte[] buffer = new byte[1024];
1:a63ab5e:                     int read;
1:a63ab5e:                     while ((read = in.read(buffer)) != -1) {
1:a63ab5e:                         synchronized (SpawnedProcess.this) {
1:a63ab5e:                             out.write(buffer, 0, read);
1:a63ab5e:                         }
1:a63ab5e:                     }
1:a63ab5e: 
1:a63ab5e:                 } catch (IOException ioe) {
1:a63ab5e:                     ioe.printStackTrace(new PrintStream(out, true));
1:a63ab5e:                 }
1:a63ab5e:             }
1:a63ab5e: 
1:a63ab5e:         }, name);
1:a63ab5e:         streamReader.setDaemon(true);
1:a63ab5e:         streamReader.start();
1:a63ab5e: 
1:df02986:         return new StreamSaver(out, streamReader);
1:a63ab5e:     }
1:04846d1: 
1:04846d1:     /**
1:04846d1:      * A task that will kill the specified process.
1:04846d1:      *
1:04846d1:      * @see #scheduleKill(java.lang.Process, java.lang.String) 
1:04846d1:      */
1:04846d1:     private static class ProcessKillerTask
1:04846d1:         extends TimerTask {
1:04846d1: 
1:04846d1:         private final String name;
1:04846d1:         private Process process;
1:04846d1: 
1:04846d1:         public ProcessKillerTask(Process process, String name) {
1:04846d1:             this.process = process;
1:04846d1:             this.name = name;
1:04846d1:         }
1:04846d1: 
1:04846d1:         public synchronized boolean cancel() {
1:04846d1:             // Since this task will usually be in the timer queue for a long
1:04846d1:             // time, nullify the process reference on cancel to free resources.
1:04846d1:             process = null;
1:04846d1:             return super.cancel();
1:04846d1:         }
1:8ad67d3: 
1:04846d1:         public synchronized void run() {
1:04846d1:             // We may have just been cancelled 
1:04846d1:             if (process == null) {
1:04846d1:                 return;
1:04846d1:             }
1:04846d1: 
1:04846d1:             System.err.println("DEBUG: Destroying process '" + name + "'");
1:04846d1:             process.destroy();
1:04846d1:             int retriesAllowed = 10;
1:04846d1:             while (retriesAllowed > 0) {
1:04846d1:                 try {
1:04846d1:                     int exitCode = process.exitValue();
1:04846d1:                     System.err.println("DEBUG: Destroyed process '" + name +
1:04846d1:                             "', exit code is " + exitCode);
1:04846d1:                     break;
1:04846d1:                 } catch (IllegalThreadStateException itse) {
1:04846d1:                     // Sleep for a second and retry.
1:04846d1:                     sleep(1000);
1:04846d1:                     retriesAllowed--;
1:04846d1:                 }
1:04846d1:             }
1:04846d1:             if (retriesAllowed == 0) {
1:04846d1:                 System.err.println(
1:f09789b:                         "DEBUG: Failed to destroy process '" + name + "'");
1:04846d1:             } 
1:04846d1:             process = null;
1:04846d1:         }
1:04846d1:     }
1:a63ab5e: 
1:8ad67d3:     /**
1:8ad67d3:      * Return {@code true} if the subprocess {@code p} has exited within {@code
1:8ad67d3:      * patience} milliseconds. Sleep {@code sleepInterval} between each check}.
1:8ad67d3:      * Note: you still need to call one of the {@link #complete} overloads even
1:8ad67d3:      * if using this method (which is optional). It can be used before trying
1:8ad67d3:      * a {@link #jstack} call.
1:8ad67d3:      *
1:8ad67d3:      * @param patience the maximum milliseconds we want to wait for
1:8ad67d3:      * @param sleepInterval sleep for this amount of milliseconds before trying
1:8ad67d3:      *                      testing again if not already exited the first time
1:8ad67d3:      *                      we check. If patience &lt;= sleepInterval we only
1:8ad67d3:      *                      check once.
1:8ad67d3:      * @return true if the process exited before our patience is up.
1:8ad67d3:      * @throws java.lang.InterruptedException
1:8ad67d3:      */
1:8ad67d3:     @SuppressWarnings("SleepWhileInLoop")
1:8ad67d3:     public boolean waitForExit(long patience, long sleepInterval)
1:8ad67d3:             throws InterruptedException {
1:8ad67d3:         boolean completed = false;
1:8ad67d3:         while (!completed && patience > 0) {
1:8ad67d3:             try {
1:8ad67d3:                 try {
1:8ad67d3:                     javaProcess.exitValue();
1:8ad67d3:                     completed = true;
1:8ad67d3:                 } catch (IllegalThreadStateException e) {
1:8ad67d3:                     // try again after sleeping
1:8ad67d3:                     Thread.sleep(sleepInterval);
1:8ad67d3:                     patience = patience - sleepInterval;
1:8ad67d3:                 }
1:8ad67d3:             } catch (InterruptedException e) {
1:8ad67d3:                 throw e;
1:8ad67d3:             }
1:8ad67d3:         }
1:8ad67d3:         return completed;
1:8ad67d3:     }
1:8ad67d3: 
1:8ad67d3: 
1:8ad67d3:     /**
1:8ad67d3:      * Return the jstack(1) dump of the process if possible.
1:8ad67d3:      * It will only work if we are running with a full JDK, not a simple JRE.
1:8ad67d3:      * It will not work on Windows, and just return an empty string.
1:8ad67d3:      * @return jstack dump if possible
1:8ad67d3:      * @throws PrivilegedActionException
1:8ad67d3:      * @throws InterruptedException
1:8ad67d3:      */
1:8ad67d3:     public String jstack()
1:8ad67d3:             throws PrivilegedActionException, InterruptedException{
1:8ad67d3: 
1:8ad67d3:         String output = "";
1:8ad67d3: 
1:8ad67d3:         if (!isWindowsPlatform() && !isIBMJVM()) {
1:8ad67d3:             // Get the pid of the subprocess using reflection. Dirty,
1:8ad67d3:             // for Unix there is a private field pid in the implementing
1:8ad67d3:             // class.
1:8ad67d3:             final int pid = getPid();
1:8ad67d3:             final String execName = getJavaExecutableName().replace(
1:8ad67d3:                     "jre" + File.separator + "bin" + File.separator + "java",
1:8ad67d3:                     "bin" + File.separator + "jstack");
1:8ad67d3:             final String[] arguments =
1:8ad67d3:                     new String[]{Integer.toString(pid)};
1:8ad67d3:             try {
1:8ad67d3:                 final Process p2 =
1:8ad67d3:                         execJavaCmd(execName, null, arguments, null, false);
1:8ad67d3:                 final SpawnedProcess spawn2 = new SpawnedProcess(p2, "jstack");
1:8ad67d3:                 spawn2.suppressOutputOnComplete();
1:8ad67d3:                 // Close stdin of the process so that it stops
1:8ad67d3:                 // any waiting for it and exits (shouldn't matter for this test)
1:8ad67d3:                 p2.getOutputStream().close();
1:8ad67d3:                 final int exitCode2 = spawn2.complete(30000); // 30 seconds
1:8ad67d3:                 assertTrue(spawn2.getFailMessage("jstack failed: "),
1:8ad67d3:                         exitCode2 == 0);
1:8ad67d3:                 output = spawn2.getFullServerOutput();
1:8ad67d3:             } catch (IOException e) {
1:8ad67d3:                 output = "Tried to catch jstack of hanging subprocess but it "
1:8ad67d3:                         + "failed (using JDK or JRE?): " + e;
1:8ad67d3:             }
1:8ad67d3:         }
1:8ad67d3: 
1:8ad67d3:         return output;
1:8ad67d3:     }
1:8ad67d3: 
1:8ad67d3:     /**
1:8ad67d3:      * Return the pid if on Unixen, or -1 on Windows (can't be obtained).
1:8ad67d3:      * @return pid
1:8ad67d3:      * @throws PrivilegedActionException
1:8ad67d3:      */
1:8ad67d3:     public int getPid() throws PrivilegedActionException {
1:8ad67d3:         if (!isWindowsPlatform() && !isIBMJVM()) {
1:8ad67d3:             return AccessController.doPrivileged(
1:8ad67d3:                 new PrivilegedExceptionAction<Integer>() {
1:8ad67d3:                     @Override
1:8ad67d3:                     public Integer run() throws IllegalAccessException,
1:8ad67d3:                             NoSuchFieldException {
1:8ad67d3:                         final Field f = javaProcess.getClass().
1:8ad67d3:                                 getDeclaredField("pid");
1:8ad67d3:                         f.setAccessible(true);
1:8ad67d3: 
1:8ad67d3:                         return f.getInt(javaProcess);
1:8ad67d3:                     }
1:8ad67d3:                 });
1:8ad67d3:         } else {
1:8ad67d3:             return -1;
1:8ad67d3:         }
1:8ad67d3:     }
1:8ad67d3: 
1:17227cf: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:                 exitCode = javaProcess.exitValue();
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:8ad67d3
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import java.lang.reflect.Field;
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
1: import static junit.framework.Assert.assertTrue;
1: import static org.apache.derbyTesting.junit.BaseTestCase.execJavaCmd;
1: import static org.apache.derbyTesting.junit.BaseTestCase.getJavaExecutableName;
1: import static org.apache.derbyTesting.junit.BaseTestCase.isIBMJVM;
1: import static org.apache.derbyTesting.junit.BaseTestCase.isWindowsPlatform;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Return {@code true} if the subprocess {@code p} has exited within {@code
1:      * patience} milliseconds. Sleep {@code sleepInterval} between each check}.
1:      * Note: you still need to call one of the {@link #complete} overloads even
1:      * if using this method (which is optional). It can be used before trying
1:      * a {@link #jstack} call.
1:      *
1:      * @param patience the maximum milliseconds we want to wait for
1:      * @param sleepInterval sleep for this amount of milliseconds before trying
1:      *                      testing again if not already exited the first time
1:      *                      we check. If patience &lt;= sleepInterval we only
1:      *                      check once.
1:      * @return true if the process exited before our patience is up.
1:      * @throws java.lang.InterruptedException
1:      */
1:     @SuppressWarnings("SleepWhileInLoop")
1:     public boolean waitForExit(long patience, long sleepInterval)
1:             throws InterruptedException {
1:         boolean completed = false;
1:         while (!completed && patience > 0) {
1:             try {
1:                 try {
1:                     javaProcess.exitValue();
1:                     completed = true;
1:                 } catch (IllegalThreadStateException e) {
1:                     // try again after sleeping
1:                     Thread.sleep(sleepInterval);
1:                     patience = patience - sleepInterval;
1:                 }
1:             } catch (InterruptedException e) {
1:                 throw e;
1:             }
1:         }
1:         return completed;
1:     }
1: 
1: 
1:     /**
1:      * Return the jstack(1) dump of the process if possible.
1:      * It will only work if we are running with a full JDK, not a simple JRE.
1:      * It will not work on Windows, and just return an empty string.
1:      * @return jstack dump if possible
1:      * @throws PrivilegedActionException
1:      * @throws InterruptedException
1:      */
1:     public String jstack()
1:             throws PrivilegedActionException, InterruptedException{
1: 
1:         String output = "";
1: 
1:         if (!isWindowsPlatform() && !isIBMJVM()) {
1:             // Get the pid of the subprocess using reflection. Dirty,
1:             // for Unix there is a private field pid in the implementing
1:             // class.
1:             final int pid = getPid();
1:             final String execName = getJavaExecutableName().replace(
1:                     "jre" + File.separator + "bin" + File.separator + "java",
1:                     "bin" + File.separator + "jstack");
1:             final String[] arguments =
1:                     new String[]{Integer.toString(pid)};
1:             try {
1:                 final Process p2 =
1:                         execJavaCmd(execName, null, arguments, null, false);
1:                 final SpawnedProcess spawn2 = new SpawnedProcess(p2, "jstack");
1:                 spawn2.suppressOutputOnComplete();
1:                 // Close stdin of the process so that it stops
1:                 // any waiting for it and exits (shouldn't matter for this test)
1:                 p2.getOutputStream().close();
1:                 final int exitCode2 = spawn2.complete(30000); // 30 seconds
1:                 assertTrue(spawn2.getFailMessage("jstack failed: "),
1:                         exitCode2 == 0);
1:                 output = spawn2.getFullServerOutput();
1:             } catch (IOException e) {
1:                 output = "Tried to catch jstack of hanging subprocess but it "
1:                         + "failed (using JDK or JRE?): " + e;
1:             }
1:         }
1: 
1:         return output;
1:     }
1: 
1:     /**
1:      * Return the pid if on Unixen, or -1 on Windows (can't be obtained).
1:      * @return pid
1:      * @throws PrivilegedActionException
1:      */
1:     public int getPid() throws PrivilegedActionException {
1:         if (!isWindowsPlatform() && !isIBMJVM()) {
1:             return AccessController.doPrivileged(
1:                 new PrivilegedExceptionAction<Integer>() {
1:                     @Override
1:                     public Integer run() throws IllegalAccessException,
1:                             NoSuchFieldException {
1:                         final Field f = javaProcess.getClass().
1:                                 getDeclaredField("pid");
1:                         f.setAccessible(true);
1: 
1:                         return f.getInt(javaProcess);
1:                     }
1:                 });
1:         } else {
1:             return -1;
1:         }
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f6df184
/////////////////////////////////////////////////////////////////////////
1:      * @param timeout the number of milliseconds to wait for the process
1:      *                to terminate normally before destroying it
commit:df02986
/////////////////////////////////////////////////////////////////////////
1:     private final StreamSaver errSaver;
1:     private final StreamSaver outSaver;
1:     public SpawnedProcess(Process javaProcess, String name) {
0:         errSaver = streamSaver(javaProcess.getErrorStream(), name
0:         outSaver = streamSaver(javaProcess.getInputStream(), name
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * encoding which is assumed is how it was originally written.
1:      * </p>
1:      *
1:      * <p>
1:      * This method should only be called after the process has completed.
0:      * That is, {@link #complete(boolean)} or {@link #complete(boolean, long)}
1:      * should be called first.
1:      * </p>
1:         // First wait until we've read all the output.
1:         outSaver.thread.join();
1: 
1:             return outSaver.stream.toString();
/////////////////////////////////////////////////////////////////////////
1:             fullData = outSaver.stream.toByteArray();
/////////////////////////////////////////////////////////////////////////
1: 
1:         ByteArrayOutputStream err = errSaver.stream;
1:         ByteArrayOutputStream out = outSaver.stream;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Complete the process.
/////////////////////////////////////////////////////////////////////////
0:      * Complete the process.
/////////////////////////////////////////////////////////////////////////
1: 
0:         // The process has completed. Wait until we've read all output.
0:         outSaver.thread.join();
1:         errSaver.thread.join();
1: 
1:             ByteArrayOutputStream err = errSaver.stream;
/////////////////////////////////////////////////////////////////////////
1:             ByteArrayOutputStream out = outSaver.stream;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Class holding references to a stream that receives the output from a
1:      * process and a thread that reads the process output and passes it on
1:      * to the stream.
1:      */
1:     private static class StreamSaver {
1:         final ByteArrayOutputStream stream;
1:         final Thread thread;
1:         StreamSaver(ByteArrayOutputStream stream, Thread thread) {
1:             this.stream = stream;
1:             this.thread = thread;
1:         }
1:     }
1: 
0:     private StreamSaver streamSaver(final InputStream in,
1:             final String name) {
/////////////////////////////////////////////////////////////////////////
1:         return new StreamSaver(out, streamReader);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:85fa204
/////////////////////////////////////////////////////////////////////////
1:                 // Can't use 1.5 methods yet due to J2ME. Add name later.
1:                 KILL_TIMER = new Timer(true);
commit:f09789b
/////////////////////////////////////////////////////////////////////////
1:             // Print a notice to stdout.
/////////////////////////////////////////////////////////////////////////
1:         cleanupProcess();
/////////////////////////////////////////////////////////////////////////
1:             // Print a notice to stdout.
/////////////////////////////////////////////////////////////////////////
1:                         "DEBUG: Failed to destroy process '" + name + "'");
commit:04846d1
/////////////////////////////////////////////////////////////////////////
1: import java.io.OutputStream;
1: import java.util.Timer;
1: import java.util.TimerTask;
1: 
1:  * <p>
1:  * There are three main aspects handled by this class:
1:  * <ul> <li>Draining the output streams of the process.<br/>
1:  *          Happens automatically, the output gathered can be accessed with
1:  *          {@linkplain #getFailMessage}, {@linkplain #getFullServerError},
1:  *          {@linkplain #getFullServerOutput}, and
1:  *          {@linkplain #getNextServerOutput}</li>
1:  *      <li>Waiting for process completion, followed by cleanup (see
1:  *          {@linkplain #complete()} and {@linkplain #complete(long)})</li>
1:  *      <li>Forcibly destroying a process that live too long, for instance
1:  *          if inter-process communication hangs. This happens automatically
1:  *          if a threshold value is exceeded.</li>
1:  * </ul>
1:  * <p>
1:  * <em>Implementation notes</em>: Active waiting is employed when waiting for
1:  * the process to complete. This is considered acceptable since the expected
1:  * usage pattern is to spawn the process, execute a set of tests, and then
1:  * finally asking the process to shut down. Waiting for the process to
1:  * complete is the last step, and a process typically lives only for a short
1:  * period of time anyway (often only for seconds, seldom more than a few
1:  * minutes).
1:  * <br/>
1:  * Forcibly destroying processes that live too long makes the test run
1:  * continue even when facing inter-process communication hangs. The prime
1:  * example is when both the client and the server are waiting for the other
1:  * party to send data. Since the timeout is very high this feature is intended
1:  * to avoid automated test runs from hanging indefinitely, for instance due to
1:  * environmental issues affecting the process.
1: //@NotThreadSafe
1:     private static final String TAG = "DEBUG: {SpawnedProcess} ";
1:     private static Timer KILL_TIMER;
1: 
1:     /**
1:      * Property allowing the kill threshold to be overridden.
1:      * <p>
1:      * Interprets the numeric value as milliseconds, ignored if non-numeric.
1:      * Overriding this value may be required if the test machine is extremely
1:      * slow, or you want to kill hung processes earlier for some reason.
1:      */
1:     private static final String KILL_THRESHOLD_PROPERTY =
1:             "derby.tests.process.killThreshold";
1:     private static final long KILL_THRESHOLD_DEFAULT = 45*60*1000; // 45 minutes
1:     /** The maximum allowed time for a process to live. */
1:     private static final long KILL_THRESHOLD;
1:     static {
1:         long tmpThreshold = KILL_THRESHOLD_DEFAULT;
1:         String tmp = BaseTestCase.getSystemProperty(KILL_THRESHOLD_PROPERTY);
1:         if (tmp != null) {
1:             try {
1:                 tmpThreshold = Long.parseLong(tmp);
1:             } catch (NumberFormatException nfe) {
1:                 // Ignore, use the default set previously.
1:                 System.err.println(TAG + "Invalid kill threshold: " + tmp);
1:             }
1:         }
1:         KILL_THRESHOLD = tmpThreshold;
1:     }
1: 
1:     private static void sleep(long ms) {
1:         try {
1:             Thread.sleep(ms);
1:         } catch (InterruptedException ie) {
1:             // Ignore the interrupt. We want to make sure the process
1:             // terminates before returning, and we don't want to preserve
1:             // the interrupt flag because it causes Derby to shut down. These
1:             // are test requirements and don't apply for production code.
0:             // Print a notice to stderr.
1:             System.out.println(TAG + "Interrupted while sleeping (ignored)");
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private final TimerTask killTask;
1: 
1:     /**
1:      * Creates a new wrapper to handle the given process.
1:      *
1:      * @param javaProcess a (running) process
1:      * @param name name to associate with the process
1:      */
1:         errSaver = startStreamSaver(javaProcess.getErrorStream(), name
1:         outSaver = startStreamSaver(javaProcess.getInputStream(), name
1:         killTask = scheduleKill(javaProcess, name);
1:      * Schedules a task to kill/terminate the task after a predefined timeout.
1:      *
1:      * @param name name of the process
1:      * @param process the process
1:      * @return The task object.
1:      */
1:     private TimerTask scheduleKill(Process process, String name) {
1:         synchronized (KILL_THRESHOLD_PROPERTY) {
1:             if (KILL_TIMER == null) {
0:                 // Can't use 1.5 methods yet due to J2ME.
0:                 KILL_TIMER = new Timer();
1:             }        
1:         }
1:         TimerTask killer = new ProcessKillerTask(process, name);
1:         KILL_TIMER.schedule(killer, KILL_THRESHOLD);
1:         return killer;
1:     }
1: 
1:     /**
1:      * Causes output obtained from the process to be suppressed when
/////////////////////////////////////////////////////////////////////////
1:      * That is, {@link #complete()} or {@link #complete(long)}
/////////////////////////////////////////////////////////////////////////
1:      * That is, {@link #complete()} or {@link #complete(long)}
/////////////////////////////////////////////////////////////////////////
1:      * encoding which is assumed is how it was originally
1:     public String getNextServerOutput() {
/////////////////////////////////////////////////////////////////////////
1:     public String getFailMessage(String reason) {
1:         sleep(500);
/////////////////////////////////////////////////////////////////////////
1:      * Waits for the process to terminate.
1:      * <p>
1:      * This call will block until one of the following conditions are met:
1:      * <ul> <li>the process terminates on its own</li>
1:      *      <li>the hung-process watchdog mechanism forcibly terminates the
1:      *          process (see {@linkplain #scheduleKill})</li>
1:      * @return The process exit code.
1:      * @throws IOException if printing diagnostics fails
1:     public int complete()
1:             throws IOException {
1:         return complete(Long.MAX_VALUE);         
1:     }
1: 
1:     /**
1:      * Waits for the process to terminate, forcibly terminating it if it
1:      * takes longer than the specified timeout.
1:      * <p>
1:      * This call will block until one of the following conditions are met:
1:      * <ul> <li>the process terminates on its own</li>
1:      *      <li>the timeout is exceeded, at which point the process is
1:      *          forcibly destroyed</li>
1:      *      <li>the hung-process watchdog mechanism forcibly terminates the
1:      *          process (see {@linkplain #scheduleKill})</li>
1:      * @return The process exit code.
1:      * @throws IOException if printing diagnostics fails
1:      */
1:     public int complete(long timeout)
1:             throws IOException {
1:         long start = System.currentTimeMillis();
1:         Integer exitCode = null;
1:         while (exitCode == null) {
1:             try {
0:                 exitCode = new Integer(javaProcess.exitValue());
1:             } catch (IllegalThreadStateException itse) {
1:                 // This exception means the process is running.
1:                 if (System.currentTimeMillis() - start > timeout) {
1:                     javaProcess.destroy();
1:                 }
1:                 sleep(500);
1:             }
1:         }
1: 
1:         // Clean up
1:         killTask.cancel();
0:         cleanupProcess();
1:         joinWith(errSaver.thread);
1:         joinWith(outSaver.thread);
1:         printDiagnostics(exitCode.intValue());
1:         return exitCode.intValue();
1:      * Cleans up the process, explicitly closing the streams associated with it.
1:     private void cleanupProcess() {
1:         // Doing this is considered best practice.
1:         closeStream(javaProcess.getOutputStream());
1:         closeStream(javaProcess.getErrorStream());
1:         closeStream(javaProcess.getInputStream());
1:         javaProcess.destroy();
1:     }
1: 
1:     /**
1:      * Prints diagnostics to stdout/stderr if the process failed.
1:      *
1:      * @param exitCode the exit code of the spawned process
1:      * @throws IOException if writing to an output stream fails
1:      * @see #suppressOutput
1:      */
1:     private synchronized void printDiagnostics(int exitCode)
1:             throws IOException {
1:         // Always write the error, except when suppressed.
0:         ByteArrayOutputStream err = errSaver.stream;
1:         if (!suppressOutput && err.size() != 0) {
1:             System.err.println("START-SPAWNED:" + name + " ERROR OUTPUT:");
1:             err.writeTo(System.err);
1:             System.err.println("END-SPAWNED  :" + name + " ERROR OUTPUT:");
1:         }
1: 
1:         // Only write contents of stdout if it appears the server
1:         // failed in some way, or output is suppressed.
0:         ByteArrayOutputStream out = outSaver.stream;
1:         if (!suppressOutput && exitCode != 0 && out.size() != 0) {
1:             System.out.println("START-SPAWNED:" + name
1:                     + " STANDARD OUTPUT: exit code=" + exitCode);
1:             out.writeTo(System.out);
1:             System.out.println("END-SPAWNED  :" + name
1:                     + " STANDARD OUTPUT:");
1:         }
1:     }
1: 
1:     /** Joins up with the specified thread. */
1:     private void joinWith(Thread t) {
1:         try {
1:             t.join();
1:         } catch (InterruptedException ie) {
1:             // Ignore the interrupt. We want to make sure the process
1:             // terminates before returning, and we don't want to preserve
1:             // the interrupt flag because it causes Derby to shut down. These
1:             // are test requirements and don't apply for production code.
0:             // Print a notice to stderr.
1:             System.out.println(TAG + "Interrupted while joining " +
1:                     "with thread '" + t.toString() + "'");
1:         }
1:     }
1: 
1:     /**
1:      * Closes the specified stream, ignoring any exceptions.
1:      *
1:      * @param stream stream to close (may be {@code null})
1:      */
1:     private void closeStream(Object stream) {
1:         if (stream instanceof InputStream) {
1:             try {
1:                 ((InputStream)stream).close();
1:             } catch (IOException ioe) {
1:                 // Ignore exception on close
1:         } else if (stream instanceof OutputStream) {
1:             try {
1:                 ((OutputStream)stream).close();
1:             } catch (IOException ioe) {
1:                 // Ignore exception on close
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Creates and starts a stream saver that reads the specified input stream
1:      * in a separate stream.
1:      *
1:      * @param in input stream to read from
1:      * @param name name of the thread
1:      * @return A {@code StreamSaver} object.
1:      */
1:     private StreamSaver startStreamSaver(final InputStream in,
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * A task that will kill the specified process.
1:      *
1:      * @see #scheduleKill(java.lang.Process, java.lang.String) 
1:      */
1:     private static class ProcessKillerTask
1:         extends TimerTask {
1: 
1:         private final String name;
1:         private Process process;
1: 
1:         public ProcessKillerTask(Process process, String name) {
1:             this.process = process;
1:             this.name = name;
1:         }
1: 
1:         public synchronized boolean cancel() {
1:             // Since this task will usually be in the timer queue for a long
1:             // time, nullify the process reference on cancel to free resources.
1:             process = null;
1:             return super.cancel();
1:         }
1: 
1:         public synchronized void run() {
1:             // We may have just been cancelled 
1:             if (process == null) {
1:                 return;
1:             }
1: 
1:             System.err.println("DEBUG: Destroying process '" + name + "'");
1:             process.destroy();
1:             int retriesAllowed = 10;
1:             while (retriesAllowed > 0) {
1:                 try {
1:                     int exitCode = process.exitValue();
1:                     System.err.println("DEBUG: Destroyed process '" + name +
1:                             "', exit code is " + exitCode);
1:                     break;
1:                 } catch (IllegalThreadStateException itse) {
1:                     // Sleep for a second and retry.
1:                     sleep(1000);
1:                     retriesAllowed--;
1:                 }
1:             }
1:             if (retriesAllowed == 0) {
1:                 System.err.println(
0:                         "DEBUG: Faild to destroy process '" + name + "'");
1:             } 
1:             process = null;
1:         }
1:     }
commit:d96e3aa
/////////////////////////////////////////////////////////////////////////
1:     private boolean suppressOutput;
1: 
/////////////////////////////////////////////////////////////////////////
0:      * Causes output obtained from the subprocess to be suppressed when
1:      * executing the {@code complete}-methods.
1:      *
1:      * @see #getFullServerOutput() to obtain suppressed output from stdout
1:      * @see #getFullServerError() to obtain suppressed output from stderr
1:      */
1:     public void suppressOutputOnComplete() {
1:         suppressOutput = true;
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     public String getFullServerOutput() throws InterruptedException {
/////////////////////////////////////////////////////////////////////////
1:      * Get the full server error output (stderr) as a string using the default
1:      * encoding which is assumed is how it was originally written.
1:      * <p>
1:      * This method should only be called after the process has completed.
0:      * That is, {@link #complete(boolean)} or {@link #complete(boolean, long)}
1:      * should be called first.
1:      */
1:     public String getFullServerError() throws InterruptedException {
1:         // First wait until we've read all the output on stderr.
0:         errSaver.thread.join();
1: 
1:         synchronized (this) {
1:             return errSaver.stream.toString();
1:         }
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
0:             if (!suppressOutput && err.size() != 0) {
/////////////////////////////////////////////////////////////////////////
0:             if (!suppressOutput && (destroy || exitCode != 0) &&
0:                     out.size() != 0) {
commit:859720d
/////////////////////////////////////////////////////////////////////////
0:             final long start = System.currentTimeMillis();
0:             boolean timedOut = true;
0:                    exitCode = javaProcess.exitValue();
0:                    //if no exception thrown, exited normally
0:                    destroy = timedOut = false;
0:                    break;
0:                    // Ignore exception, it means that the process is running.
0:                    Thread.sleep(1000);
0:                    totalwait = System.currentTimeMillis() - start;
0:             // If we timed out, make sure we try to destroy the process.
0:             if (timedOut) {
0:                 destroy = true;
1:             }
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:51beb81
/////////////////////////////////////////////////////////////////////////
0:     public SpawnedProcess(Process javaProcess, String name) 
0:                     throws InterruptedException {
/////////////////////////////////////////////////////////////////////////
0:             final String name) throws InterruptedException {
/////////////////////////////////////////////////////////////////////////
0:         streamReader.join(500);
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:17227cf
/////////////////////////////////////////////////////////////////////////
0:     /*Complete the method
0:      * @param destroy true to destroy it, false to wait indefinitely to complete 
0:         return complete(destroy, -1L);
1:     }
1:     
1:     /**
0:      * Complete the method.
0:      * @param destroy True to destroy it, false to wait for it to complete 
0:      * based on timeout.
1:      *  
0:      * @param timeout milliseconds to wait until finished or else destroy.
0:      * -1 don't timeout
1:      *  
1:      */
0:     public int complete(boolean destroy, long timeout) throws InterruptedException, IOException {
0:         int exitCode;
0:         if (timeout >= 0 ) {
0:             long totalwait = -1;
0:             while (totalwait < timeout) {
0:                try  { 
0:                exitCode = javaProcess.exitValue();
0:                //if no exception thrown, exited normally
0:                destroy = false;
0:                break;
0:                }catch (IllegalThreadStateException ite) {
0:                    if (totalwait >= timeout) {
0:                        destroy = true;
0:                        break;
0:                    } else {
0:                        totalwait += 1000;
0:                        Thread.sleep(1000);
1:                    }
1:                }
1:             }
1:     	}
0:         exitCode = javaProcess.waitFor();
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:a63ab5e
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class org.apache.derbyTesting.junit.SpawnedProcess
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.junit;
1: 
1: import java.io.ByteArrayOutputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.PrintStream;
1: 
1: /**
1:  * Utility code that wraps a spawned process (Java Process object).
0:  * Handles the output streams (stderr and stdout) written
0:  * by the process by spawning off background threads to read
0:  * them into byte arrays. The class provides access to the
0:  * output, typically called once the process is complete.
1:  */
1: public final class SpawnedProcess {
1: 
1:     private final String name;
1: 
1:     private final Process javaProcess;
1: 
0:     private final ByteArrayOutputStream err;
1: 
0:     private final ByteArrayOutputStream out;
1: 
0:     public SpawnedProcess(Process javaProcess, String name) {
1:         this.javaProcess = javaProcess;
1:         this.name = name;
1: 
0:         err = streamSaver(javaProcess.getErrorStream(), name
1:                 .concat(":System.err"));
0:         out = streamSaver(javaProcess.getInputStream(), name
1:                 .concat(":System.out"));
1:     }
1: 
1:     /**
1:      * Get the Java Process object
1:      */
1:     public Process getProcess() {
1:         return javaProcess;
1:     }
1:     
1:     /**
1:      * Get the full server output (stdout) as a string using the default
0:      * encoding which is assumed is how it was orginally
0:      * written.
1:      */
0:     public String getFullServerOutput() throws Exception {
0:         Thread.sleep(500);
1:         synchronized (this) {
0:             return out.toString(); 
1:         }
1:     }
1:     
1:     /**
1:      * Position offset for getNextServerOutput().
1:      */
1:     int stdOutReadOffset;
1:     /**
1:      * Get the next set of server output (stdout) as a string using the default
0:      * encoding which is assumed is how it was orginally
1:      * written. Assumes a single caller is executing the calls
1:      * to this method.
1:      */
0:     public String getNextServerOutput() throws Exception
1:     {
1:         byte[] fullData;
1:         synchronized (this) {
0:             fullData = out.toByteArray();
1:         }
1:         
1:         String output = new String(fullData, stdOutReadOffset,
1:                 fullData.length - stdOutReadOffset);
1:         stdOutReadOffset = fullData.length;
1:         return output;
1:     }
1:     /**
1:      * Get a fail message that is the passed in reason plus
1:      * the stderr and stdout for any output written. Allows
1:      * easier debugging if the reason the process failed is there!
1:      */
0:     public String getFailMessage(String reason) throws InterruptedException
1:     {
0:         Thread.sleep(500);
1:         StringBuffer sb = new StringBuffer();
1:         sb.append(reason);
1:         sb.append(":Spawned ");
1:         sb.append(name);
1:         sb.append(" exitCode=");
1:         try {
1:             sb.append(javaProcess.exitValue());
1:         } catch (IllegalThreadStateException e) {
1:             sb.append("running");
1:         }
1:         
1:         synchronized (this) {
1:             if (err.size() != 0)
1:             {
1:                 sb.append("\nSTDERR:\n");
1:                 sb.append(err.toString());          
1:             }
1:             if (out.size() != 0)
1:             {
1:                 sb.append("\nSTDOUT:\n");
1:                 sb.append(out.toString());          
1:             }
1:        }
1:        return sb.toString();
1:     }
1: 
1:     /**
0:      * Complete the method.
0:      * @param destroy True to destroy it, false to wait for it to complete.
1:      */
0:     public int complete(boolean destroy) throws InterruptedException, IOException {
0:         if (destroy)
0:             javaProcess.destroy();
1: 
0:         int exitCode = javaProcess.waitFor();
0:         Thread.sleep(500);
1:         synchronized (this) {
1: 
0:             // Always write the error
0:             if (err.size() != 0) {
0:                 System.err.println("START-SPAWNED:" + name + " ERROR OUTPUT:");
0:                 err.writeTo(System.err);
0:                 System.err.println("END-SPAWNED  :" + name + " ERROR OUTPUT:");
1:             }
1: 
0:             // Only write the error if it appeared the server
0:             // failed in some way.
0:             if ((destroy || exitCode != 0) && out.size() != 0) {
0:                 System.out.println("START-SPAWNED:" + name
0:                         + " STANDARD OUTPUT: exit code=" + exitCode);
0:                 out.writeTo(System.out);
0:                 System.out.println("END-SPAWNED  :" + name
0:                         + " STANDARD OUTPUT:");
1:             }
1:         }
1:         
0:         return exitCode;
1:     }
1: 
0:     private ByteArrayOutputStream streamSaver(final InputStream in,
0:             final String name) {
1: 
1:         final ByteArrayOutputStream out = new ByteArrayOutputStream() {
1:             public void reset() {
1:                 super.reset();
1:                 new Throwable("WWW").printStackTrace(System.out);
1:             }
1: 
1:         };
1: 
1:         Thread streamReader = new Thread(new Runnable() {
1: 
1:             public void run() {
1:                 try {
1:                     byte[] buffer = new byte[1024];
1:                     int read;
1:                     while ((read = in.read(buffer)) != -1) {
1:                         synchronized (SpawnedProcess.this) {
1:                             out.write(buffer, 0, read);
1:                         }
1:                     }
1: 
1:                 } catch (IOException ioe) {
1:                     ioe.printStackTrace(new PrintStream(out, true));
1:                 }
1:             }
1: 
1:         }, name);
1:         streamReader.setDaemon(true);
0:         streamReader.setPriority(Thread.MIN_PRIORITY);
1:         streamReader.start();
1: 
0:         return out;
1: 
1:     }
1: }
============================================================================