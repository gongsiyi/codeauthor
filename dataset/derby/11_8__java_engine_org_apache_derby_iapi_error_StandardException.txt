3:eac0369: /*
31:eac0369: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.error.StandardException
1:7ecc1f2: 
1:1d8e53f:    Licensed to the Apache Software Foundation (ASF) under one or more
1:1d8e53f:    contributor license agreements.  See the NOTICE file distributed with
1:1d8e53f:    this work for additional information regarding copyright ownership.
1:1d8e53f:    The ASF licenses this file to you under the Apache License, Version 2.0
1:1d8e53f:    (the "License"); you may not use this file except in compliance with
1:1d8e53f:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
5:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.error;
1:eac0369: 
1:cb184fe: import java.lang.reflect.InvocationTargetException;
1:cb184fe: import java.security.PrivilegedActionException;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.SQLWarning;
1:eac0369: 
1:342793b: import org.apache.derby.iapi.reference.SQLState;
1:9c18af1: import org.apache.derby.iapi.services.io.ArrayUtil;
1:342793b: import org.apache.derby.iapi.services.i18n.MessageService;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:342793b: 
2:eac0369: /**
1:eac0369: 	StandardException is the root of all exceptions that are handled
1:eac0369: 	in a standard fashion by the database code, mainly in the language code.
1:eac0369: 	<P>
1:eac0369:     This class is abstract to ensure that an implementation only throws
1:eac0369: 	a specific exception (e.g. TransactionException) which is a sub-class
1:eac0369: 	<P>
1:eac0369: 	A method in an iterface in a protocol under com.ibm.db2j.protocol.Database must
1:eac0369: 	only throw a StandardException (if it needs to throw an exception).
1:eac0369: 	This indicates that the method can throw an exception and therefore its
1:eac0369: 	caller must ensure that any resources it allocates will be cleaned up
1:eac0369: 	in the event of an exception in the StandardException hierarchy.
1:eac0369: 	<P>
1:eac0369: 	Implementations of methods that throw StandardException can have throws
1:eac0369: 	clause that are more specific than StandardException.
1:eac0369: */
1:eac0369: 
1:eac0369: public class StandardException extends Exception 
7:eac0369: {
1:eac0369: 	public static final int REPORT_DEFAULT = 0;
1:eac0369: 	public static final int REPORT_NEVER = 1;
1:eac0369: 	public static final int REPORT_ALWAYS = 2;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Exception State
1:eac0369: 	 */
1:36f8c01: 	private transient Object[] arguments;
1:eac0369: 	private int severity;
1:eac0369: 	private String textMessage;
1:eac0369: 	private String sqlState;
1:36f8c01: 	private transient int report;
1:28dc366:     private transient boolean isForPublicAPI;
1:28dc366:     private transient SQLException next;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** End of constructors
1:eac0369: 	*/
1:eac0369: 	
1:eac0369: 	protected StandardException(String messageID)
1:eac0369: 	{
1:eac0369: 		this(messageID, (Throwable) null, (Object[]) null);
1:eac0369: 
32:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected StandardException(String messageID, Throwable t, Object[] args)
1:eac0369: 	{
1:eac0369: 		super(messageID);
1:eac0369: 
1:eac0369: 		this.severity = getSeverityFromIdentifier(messageID);
1:eac0369: 		this.sqlState = getSQLStateFromIdentifier(messageID);
1:eac0369: 		this.arguments = args;
1:e70c716: 		if (t != null) {
1:e70c716: 			initCause(t);
1:e70c716: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369:                     SanityManager.ASSERT(messageID != null,
1:eac0369:                                          "StandardException with no messageID");
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This constructor is used when we already have the
1:eac0369: 	 * message text.
1:eac0369: 	 * 
1:eac0369: 	 * @param sqlState the sql state of the message
1:eac0369: 	 * @param text the text of the message
1:eac0369: 	 */
1:eac0369: 	private StandardException(String sqlState, String text)
1:eac0369: 	{
1:eac0369: 		this(sqlState);
1:eac0369: 		textMessage = text;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** End of constructors
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the arguments for this exception,
1:eac0369: 	 * if there are any.
1:eac0369: 	 */
1:9c18af1: 	public final Object[] getArguments()    { return ArrayUtil.copy( arguments ); }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Yes, report me. Errors that need this method to return
1:eac0369: 		false are in the minority.
1:eac0369: 	*/
1:eac0369: 	public final int report() {
1:eac0369: 		return report;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set my report type.
1:eac0369: 	*/
1:eac0369: 	public final void setReport(int report) {
1:eac0369: 		this.report = report;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final void setSeverity(int severity) {
1:eac0369: 		this.severity = severity;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public final int getSeverity() {
1:eac0369: 		return severity;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final int getErrorCode() {
1:eac0369: 		return severity;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the 5 character SQL State.
1:eac0369: 		If you need teh identifier that was used to create the
1:eac0369: 		message, then use getMessageId(). getMessageId() will return the
1:eac0369: 		string that corresponds to the field in org.apache.derby.iapi.reference.SQLState.
1:eac0369: 	*/
1:eac0369: 	public final String getSQLState()
1:eac0369: 	{
1:eac0369: 		return sqlState;
1:eac0369: 	}
1:eac0369: 
1:28dc366:     /**
1:28dc366:      * Get the next {@code SQLException} that should be put into the parent
1:28dc366:      * exception when this instance is converted to an {@code SQLException}.
1:28dc366:      * @return the next exception
1:28dc366:      */
1:28dc366:     public final SQLException getNextException() {
1:28dc366:         return next;
1:28dc366:     }
1:28dc366: 
1:28dc366:     /**
1:28dc366:      * Mark this exception as one that is thrown by a public API method.
1:28dc366:      * The purpose is to signal that this should be a top-level exception,
1:28dc366:      * so that it doesn't get wrapped inside multiple layers of other
1:28dc366:      * SQLExceptions or StandardExceptions as it travels up through the
1:28dc366:      * code layers.
1:28dc366:      * @see PublicAPI
1:28dc366:      */
1:28dc366:     final void markAsPublicAPI() {
1:28dc366:         isForPublicAPI = true;
1:28dc366:     }
1:28dc366: 
1:eac0369: 	/**
1:eac0369: 		Convert a message identifer from org.apache.derby.iapi.reference.SQLState to
1:eac0369: 		a SQLState five character string.
1:3fd26f3: 	 *	@param messageID - the sql state id of the message from Derby
1:eac0369: 	 *	@return String 	 - the 5 character code of the SQLState ID to returned to the user 
1:eac0369: 	*/
1:eac0369: 	public static String getSQLStateFromIdentifier(String messageID) {
1:eac0369: 
1:eac0369: 		if (messageID.length() == 5)
1:eac0369: 			return messageID;
1:eac0369: 		return messageID.substring(0, 5);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the severity given a message identifier from org.apache.derby.iapi.reference.SQLState.
1:eac0369: 	*/
1:eac0369: 	public static int getSeverityFromIdentifier(String messageID) {
1:eac0369: 
1:eac0369: 		int lseverity = ExceptionSeverity.NO_APPLICABLE_SEVERITY;
1:eac0369: 
1:eac0369: 		switch (messageID.length()) {
1:eac0369: 		case 5:
1:eac0369: 			switch (messageID.charAt(0)) {
1:eac0369: 			case '0':
1:eac0369: 				switch (messageID.charAt(1)) {
1:eac0369: 				case '1':
1:eac0369: 					lseverity = ExceptionSeverity.WARNING_SEVERITY;
1:eac0369: 					break;
1:eac0369: 				case 'A':
1:eac0369: 				case '7':
1:eac0369: 					lseverity = ExceptionSeverity.STATEMENT_SEVERITY;
1:eac0369: 					break;
1:eac0369: 				case '8':
1:eac0369: 					lseverity = ExceptionSeverity.SESSION_SEVERITY;
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 				break;	
1:eac0369: 			case '2':
1:eac0369: 			case '3':
1:eac0369: 				lseverity = ExceptionSeverity.STATEMENT_SEVERITY;
1:eac0369: 				break;
1:eac0369: 			case '4':
1:eac0369: 				switch (messageID.charAt(1)) {
1:eac0369: 				case '0':
1:eac0369: 					lseverity = ExceptionSeverity.TRANSACTION_SEVERITY;
1:eac0369: 					break;
1:eac0369: 				case '2':
1:eac0369: 					lseverity = ExceptionSeverity.STATEMENT_SEVERITY;
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 				break;	
1:eac0369: 			}
1:eac0369: 			break;
1:eac0369: 
1:eac0369: 		default:
1:eac0369: 			switch (messageID.charAt(6)) {
1:eac0369: 			case 'M':
1:eac0369: 				lseverity = ExceptionSeverity.SYSTEM_SEVERITY;
1:eac0369: 				break;
1:eac0369: 			case 'D':
1:eac0369: 				lseverity = ExceptionSeverity.DATABASE_SEVERITY;
1:eac0369: 				break;
1:eac0369: 			case 'C':
1:eac0369: 				lseverity = ExceptionSeverity.SESSION_SEVERITY;
1:eac0369: 				break;
1:eac0369: 			case 'T':
1:eac0369: 				lseverity = ExceptionSeverity.TRANSACTION_SEVERITY;
1:eac0369: 				break;
1:eac0369: 			case 'S':
1:eac0369: 				lseverity = ExceptionSeverity.STATEMENT_SEVERITY;
1:eac0369: 				break;
1:eac0369: 			case 'U':
1:eac0369: 				lseverity = ExceptionSeverity.NO_APPLICABLE_SEVERITY;
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 			break;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return lseverity;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Set of static methods to obtain exceptions.
1:eac0369: 	**
1:eac0369: 	** Possible parameters:
1:eac0369: 	** String sqlState - SQL State
1:eac0369: 	** int severity - Severity of message
1:eac0369: 	** Throwable t - exception to wrap
1:eac0369: 	** Object aN - argument to error message
1:eac0369: 	**
1:eac0369: 	** Calls that can be made after the exception has been created.
1:eac0369: 	**
1:eac0369: 	** setExceptionCategory()
1:eac0369: 	** setReport()
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/* specific exceptions */
1:eac0369: 
1:eac0369: 	public	static	StandardException	normalClose()
1:eac0369: 	{
1:eac0369: 		StandardException	se = newException( SQLState.NORMAL_CLOSE );
2:eac0369: 		se.report = REPORT_NEVER;
4:eac0369: 		return se;
1:eac0369: 	}
1:eac0369: 
1:97f7c7a:     public static StandardException
1:97f7c7a:             newException(String messageId, Object... args) {
1:97f7c7a:         return newException(messageId, (Throwable) null, args);
1:97f7c7a:     }
1:eac0369: 
1:97f7c7a:     public static StandardException
1:97f7c7a:             newException(String messageId, Throwable t, Object... args) {
1:97f7c7a:         return new StandardException(messageId, t, args);
1:97f7c7a:     }
1:eac0369: 
1:eac0369: 	/* 2 arguments */
1:eac0369: 
1:eac0369:     /**
1:75fb1cf:      * Dummy exception to catch incorrect use of
1:75fb1cf:      * StandardException.newException(), at compile-time. If you get a
1:75fb1cf:      * compilation error because this exception isn't caught, it means
1:75fb1cf:      * that you are using StandardException.newException(...)
1:75fb1cf:      * incorrectly. The nested exception should always be the second
1:75fb1cf:      * argument.
1:75fb1cf:      * @see StandardException#newException(String, Object, Throwable)
1:75fb1cf:      * @see StandardException#newException(String, Object, Object, Throwable)
1:eac0369:      */
1:75fb1cf:     public static class BadMessageArgumentException extends Throwable {}
1:eac0369: 
1:eac0369:     /**
1:75fb1cf:      * Dummy overload which should never be called. Only used to
1:75fb1cf:      * detect incorrect usage, at compile time.
1:75fb1cf:      * @param messageID - the sql state id of the message
1:75fb1cf:      * @param a1 - Message arg
1:75fb1cf:      * @param t - Incorrectly placed exception to be nested
1:75fb1cf:      * @return nothing - always throws
1:75fb1cf:      * @throws BadMessageArgumentException - always (dummy)
1:eac0369:      */
1:29fd25c:     public static StandardException newException(String messageID, 
1:75fb1cf:                                                  Object a1, 
1:75fb1cf:                                                  Throwable t) 
1:75fb1cf:         throws BadMessageArgumentException {
1:75fb1cf:         throw new BadMessageArgumentException();
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/* 3 arguments */
1:eac0369: 
1:eac0369:     /**
1:75fb1cf:      * Dummy overload which should never be called. Only used to
1:75fb1cf:      * detect incorrect usage, at compile time.
1:75fb1cf:      * @param messageID - the sql state id of the message
1:75fb1cf:      * @param a1 - First message arg
1:75fb1cf:      * @param a2 - Second message arg
1:75fb1cf:      * @param t - Incorrectly placed exception to be nested
1:75fb1cf:      * @return nothing - always throws
1:75fb1cf:      * @throws BadMessageArgumentException - always (dummy)
1:eac0369:      */
1:75fb1cf:     public static StandardException newException(String messageID, 
1:75fb1cf:                                                  Object a1, 
1:75fb1cf:                                                  Object a2,
1:75fb1cf:                                                  Throwable t) 
1:75fb1cf:         throws BadMessageArgumentException {
1:75fb1cf:         throw new BadMessageArgumentException(); 
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Creates a new StandardException using message text that has already been localized.
1:eac0369:      *
1:eac0369:      * @param MessageID The SQLState and severity are derived from the ID. However the text message is not.
1:eac0369:      * @param t The Throwable that caused this exception, null if this exception was not caused by another Throwable.
1:eac0369:      * @param localizedMessage The message associated with this exception.
1:eac0369:      *        <b>It is the caller's responsibility to ensure that this message is properly localized.</b>
1:eac0369:      *
1:6b50965:      * See org.apache.derby.iapi.tools.i18n.LocalizedResource
1:eac0369:      */
1:eac0369:     public static StandardException newPreLocalizedException( String MessageID,
1:eac0369:                                                               Throwable t,
1:eac0369:                                                               String localizedMessage)
1:eac0369:     {
1:eac0369:         StandardException se = new StandardException( MessageID, localizedMessage);
1:eac0369:         if( t != null)
1:e70c716:             se.initCause(t);
1:342793b:         return se;
1:342793b:     }
1:342793b:     
1:342793b:     
1:342793b: 	/**
1:28dc366:      * Unpack the exception, looking for a StandardException, which carries
1:342793b: 	 * the Derby messageID and arguments. 
1:342793b: 	 * @see org.apache.derby.impl.jdbc.SQLExceptionFactory
1:342793b: 	 * @see org.apache.derby.impl.jdbc.Util
1:342793b: 	 */
1:28dc366:     public static StandardException getArgumentFerry(SQLException se)
1:342793b: 	{
1:28dc366:         Throwable cause = se.getCause();
1:28dc366:         return (cause instanceof StandardException)
1:28dc366:                 ? (StandardException) cause : null;
1:342793b: 	}
1:342793b: 
1:cb184fe:     /**
1:cb184fe:      * Check if the top-level throwable is just a vacuous wrapper that does
1:cb184fe:      * not carry any useful information except what's returned by the
1:cb184fe:      * {@link Throwable#getCause()} method.
1:cb184fe:      *
1:cb184fe:      * @param t the throwable to check
1:cb184fe:      * @return {@code true} if the throwable is a vacuous wrapper and the
1:cb184fe:      *   only useful piece of information is the cause, or {@code false}
1:cb184fe:      *   otherwise
1:cb184fe:      */
1:cb184fe:     private static boolean isVacuousWrapper(Throwable t) {
1:cb184fe:         // The only interesting information in an InvocationTargetException
1:cb184fe:         // or a PrivilegedActionException is the cause, so consider them
1:cb184fe:         // vacuous if they have a cause.
1:cb184fe:         if (t instanceof InvocationTargetException
1:cb184fe:                 || t instanceof PrivilegedActionException) {
1:cb184fe:             return (t.getCause() != null);
1:cb184fe:         }
1:cb184fe: 
1:cb184fe:         // All other exceptions are non-vacuous.
1:cb184fe:         return false;
1:cb184fe:     }
1:342793b: 
1:eac0369: 	public static StandardException unexpectedUserException(Throwable t)
1:eac0369: 	{
1:cb184fe: 
1:cb184fe:         // If there is no useful information in the top-level throwable,
1:cb184fe:         // peel it off and only report the cause.
1:cb184fe:         if (isVacuousWrapper(t)) {
1:cb184fe:             return unexpectedUserException(t.getCause());
1:cb184fe:         }
1:cb184fe: 
1:de3b108:         // If the exception is an SQLException generated by Derby, it has an
1:28dc366:         // argument ferry which is a StandardException. Use this to check
1:de3b108:         // whether the exception was generated by Derby.
1:28dc366:         StandardException ferry = null;
1:de3b108:         if (t instanceof SQLException) {
1:28dc366:             SQLException sqle = (SQLException) t;
1:28dc366:             ferry = getArgumentFerry(sqle);
1:28dc366: 
1:28dc366:             // If the ferry is marked for public API, it means we shouldn't
1:28dc366:             // wrap it inside an "unexpected user exception", so just peel
1:28dc366:             // off the parent SQLException and return the ferry.
1:28dc366:             if (ferry != null && ferry.isForPublicAPI) {
1:28dc366:                 // If the parent SQLException has any next exceptions, we
1:28dc366:                 // need to store a reference to them before the parent is
1:28dc366:                 // discarded.
1:28dc366:                 ferry.next = sqle.getNextException();
1:28dc366:                 return ferry;
1:de3b108:             }
1:de3b108:         }
1:28dc366: 
1:342793b: 		/*
1:28dc366:         ** If we have a SQLException that didn't come from Derby, then we check
1:eac0369: 		** to see if it is a valid user defined exception range 
1:eac0369: 		** (38001-38XXX).  If so, then we convert it into a 
1:eac0369: 		** StandardException without further ado.
1:342793b: 		*/ 
1:de3b108: 		if ((t instanceof SQLException) && (ferry == null))
1:eac0369: 		{
1:eac0369: 			SQLException sqlex  = (SQLException)t;
1:eac0369: 			String state = sqlex.getSQLState();
1:eac0369: 			if ((state != null) && 
1:eac0369: 				(state.length() == 5) &&
1:eac0369: 				state.startsWith("38") &&
1:eac0369: 				!state.equals("38000"))
1:eac0369: 			{
1:eac0369: 				StandardException se = new StandardException(state, sqlex.getMessage());
1:eac0369: 				if (sqlex.getNextException() != null)		
1:eac0369: 				{	
1:e70c716: 					se.initCause(sqlex.getNextException());
1:eac0369: 				}
1:eac0369: 				return se;
1:eac0369: 			}
1:eac0369: 		}
1:de3b108: 
1:eac0369: 		// no need to wrap a StandardException
1:eac0369: 		if (t instanceof StandardException) 
1:eac0369: 		{
1:eac0369: 			return (StandardException) t;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:342793b: 			/*
1:eac0369: 			** 
1:eac0369: 			** The exception at this point could be a:
1:eac0369: 			**
1:eac0369: 			**    standard java exception, e.g. NullPointerException
1:eac0369: 			**    SQL Exception - from some server-side JDBC
1:eac0369: 			**    3rd party exception - from some application
1:3fd26f3: 			**    some Derby exception that is not a standard exception.
1:eac0369: 			**    
1:eac0369: 			**    
1:eac0369: 			** We don't want to call t.toString() here, because the JVM is
1:eac0369: 			** inconsistent about whether it includes a detail message
1:eac0369: 			** with some exceptions (esp. NullPointerException).  In those
1:eac0369: 			** cases where there is a detail message, t.toString() puts in
1:eac0369: 			** a colon character, even when the detail message is blank.
1:eac0369: 			** So, we do our own string formatting here, including the colon
1:eac0369: 			** only when there is a non-blank message.
1:eac0369: 			**
1:eac0369: 			** The above is because our test canons contain the text of
1:eac0369: 			** error messages.
1:eac0369: 			** 
1:3fd26f3: 			** In the past we didn't want to place the class name in
1:3fd26f3: 			** an exception because Cloudscape builds were
1:3fd26f3: 			** obfuscated, so the class name would change from build
1:28dc366:             ** to build. This is no longer true for Derby.
1:28dc366:             ** If the exception has no detail message
1:3fd26f3: 			** then we use the class name to make tracking the 
1:28dc366:             ** problem down easier, though the lack of a message
1:3fd26f3: 			** should be seen as a bug.
1:342793b: 			*/
1:28dc366:             String detailMessage = t.getMessage();
1:342793b: 
1:eac0369: 			if (detailMessage == null)
1:eac0369: 			{
1:eac0369: 				detailMessage = "";
1:eac0369: 			} else {
1:eac0369: 				detailMessage = detailMessage.trim();
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// if no message, use the class name
1:eac0369: 			if (detailMessage.length() == 0) {
1:eac0369: 				detailMessage = t.getClass().getName();
1:eac0369: 			}
1:28dc366:             else
1:28dc366:             {
1:28dc366:                 detailMessage = t.getClass().getName() + ": " + detailMessage;
1:eac0369: 			}
1:eac0369: 
1:28dc366:             return
1:eac0369: 				newException(SQLState.LANG_UNEXPECTED_USER_EXCEPTION, t, detailMessage);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Similar to unexpectedUserException but makes no assumtion about
1:eac0369: 		when the execption is being called. The error is wrapped as simply
1:eac0369: 		as possible.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public static StandardException plainWrapException(Throwable t) {
1:eac0369: 
1:cb184fe:         // If there is no useful information in the top-level throwable,
1:cb184fe:         // peel it off and only report the cause.
1:cb184fe:         if (isVacuousWrapper(t)) {
1:cb184fe:             return plainWrapException(t.getCause());
1:cb184fe:         }
1:cb184fe: 
1:eac0369: 		if (t instanceof StandardException)
1:eac0369: 			return (StandardException) t;
1:eac0369: 
1:eac0369: 		if (t instanceof SQLException) {
1:eac0369: 
1:eac0369: 			SQLException sqle = (SQLException) t;
1:eac0369: 
1:eac0369: 			String sqlState = sqle.getSQLState();
1:eac0369: 			if (sqlState != null) {
1:eac0369: 
1:eac0369: 				StandardException se = new StandardException(sqlState, "(" + sqle.getErrorCode()  + ") " + sqle.getMessage());
1:eac0369: 				sqle = sqle.getNextException();
1:eac0369: 				if (sqle != null)
1:e70c716: 					se.initCause(plainWrapException(sqle));
1:eac0369: 				return se;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		String	detailMessage = t.getMessage();
1:eac0369: 
1:eac0369: 		if (detailMessage == null)
1:eac0369: 		{
1:eac0369: 			detailMessage = "";
1:eac0369: 		} else {
1:eac0369: 			detailMessage = detailMessage.trim();
1:eac0369: 		}
1:eac0369: 		
2:eac0369: 		StandardException se =
1:eac0369: 				newException(SQLState.JAVA_EXCEPTION, t, detailMessage, t.getClass().getName());
1:eac0369: 		return se;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	** A special exception to close a session.
1:eac0369: 	*/
1:eac0369: 	public static StandardException closeException() {
1:eac0369: 		StandardException se = newException(SQLState.CLOSE_REQUEST);
1:eac0369: 		se.setReport(REPORT_NEVER);
1:eac0369: 		return se;
1:eac0369: 	}
1:eac0369: 	/*
1:eac0369: 	** Message handling
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		The message stored in the super class Throwable must be set
1:eac0369: 		up object creation. At this time we cannot get any information
1:eac0369: 		about the object itself (ie. this) in order to determine the
1:eac0369: 		natural language message. Ie. we need to class of the objec in
1:eac0369: 		order to look up its message, but we can't get the class of the
1:eac0369: 		exception before calling the super class message.
1:eac0369: 		<P>
1:eac0369: 		Thus the message stored by Throwable and obtained by the
1:eac0369: 		getMessage() of Throwable (ie. super.getMessage() in this
1:eac0369: 		class) is the message identifier. The actual text message
1:eac0369: 		is stored in this class at the first request.
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public String getMessage() {
1:1f18dc3:         if (textMessage == null) {
1:1f18dc3:             textMessage = MessageService.getTextMessage(
1:1f18dc3:                                 getMessageId(), getArguments());
1:1f18dc3:         }
1:eac0369: 
1:eac0369: 		return textMessage;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the message identifier that is used to look up the
1:eac0369: 		error message text in the messages.properties file.
1:eac0369: 	*/
1:eac0369: 	public final String getMessageId() {
1:eac0369: 		return super.getMessage();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the error code for an error given a type. The value of
1:eac0369: 		the property messageId.type will be returned, e.g.
1:eac0369: 		deadlock.sqlstate.
1:eac0369: 	*/
1:eac0369: 	public String getErrorProperty(String type) {
1:eac0369: 		return getErrorProperty(getMessageId(), type);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Don't print the class name in the toString() method.
1:eac0369: 	*/
1:eac0369: 	public String toString() {
1:d6401b1:         // Add the SQLState to the message. This should be kept consistent
1:d6401b1:         // with SqlException.toString() in the client driver.
1:eac0369: 		String msg = getMessage();
1:eac0369: 		return "ERROR " + getSQLState() + ": " + msg;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Static methods
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	private static String getErrorProperty(String messageId, String type) {
1:eac0369: 		return MessageService.getProperty(messageId, type);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static StandardException interrupt(InterruptedException ie) {
1:eac0369: 		StandardException se = StandardException.newException(SQLState.CONN_INTERRUPT, ie);
1:eac0369: 		return se;
1:eac0369: 	}
1:eac0369: 	/*
1:eac0369: 	** SQL warnings
1:eac0369: 	*/
1:eac0369: 
1:97f7c7a:     public static SQLWarning newWarning(String messageId, Object... oa)
1:eac0369: 	{
1:1f18dc3:         String      message = MessageService.getTextMessage(messageId, oa);
1:eac0369: 		String		state = StandardException.getSQLStateFromIdentifier(messageId);
1:eac0369: 		SQLWarning	sqlw = new SQLWarning(message, state, ExceptionSeverity.WARNING_SEVERITY);
1:eac0369: 
1:eac0369: 		return sqlw;
1:eac0369: 	}
1:c9ef166: 
1:c9ef166:     /**
1:c9ef166:      * Is this a lock timeout exception.
1:c9ef166:      * <p>
1:c9ef166:      *
1:c9ef166:      * @return true if this exception is a lock timeout.
1:c9ef166:      *
1:c9ef166:      **/
1:c9ef166:     public final boolean isLockTimeout() {
1:c9ef166: 
1:c9ef166:         return(SQLState.LOCK_TIMEOUT.equals(getSQLState()));
1:c9ef166:     }
1:c9ef166: 
1:c9ef166:     /**
1:9819cf8:      * Is this a self-deadlock exception caused by a nested transaction
1:9819cf8:      * being blocked by its parent's locks.
1:9819cf8:      * <p>
1:9819cf8:      *
1:9819cf8:      * @return true if this exception is a self-deadlock.
1:9819cf8:      *
1:9819cf8:      **/
1:9819cf8:     public final boolean isSelfDeadlock() {
1:9819cf8: 
1:9819cf8:         return(SQLState.SELF_DEADLOCK.equals(getSQLState()));
1:9819cf8:     }
1:9819cf8: 
1:9819cf8:     /**
1:c9ef166:      * Is this a lock timeout or lock deadlock exception.
1:c9ef166:      * <p>
1:c9ef166:      *
1:c9ef166:      * @return true if this exception is a lock timeout or lock deadlock.
1:c9ef166:      *
1:c9ef166:      **/
1:c9ef166:     public final boolean isLockTimeoutOrDeadlock() {
1:c9ef166: 
1:c9ef166:         return(SQLState.LOCK_TIMEOUT.equals(getSQLState()) ||
1:c9ef166:                SQLState.DEADLOCK.equals(getSQLState()));
1:c9ef166:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:9819cf8
/////////////////////////////////////////////////////////////////////////
1:      * Is this a self-deadlock exception caused by a nested transaction
1:      * being blocked by its parent's locks.
1:      * <p>
1:      *
1:      * @return true if this exception is a self-deadlock.
1:      *
1:      **/
1:     public final boolean isSelfDeadlock() {
1: 
1:         return(SQLState.SELF_DEADLOCK.equals(getSQLState()));
1:     }
1: 
1:     /**
commit:9c18af1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.ArrayUtil;
/////////////////////////////////////////////////////////////////////////
1: 	public final Object[] getArguments()    { return ArrayUtil.copy( arguments ); }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:cb184fe
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.InvocationTargetException;
1: import java.security.PrivilegedActionException;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check if the top-level throwable is just a vacuous wrapper that does
1:      * not carry any useful information except what's returned by the
1:      * {@link Throwable#getCause()} method.
1:      *
1:      * @param t the throwable to check
1:      * @return {@code true} if the throwable is a vacuous wrapper and the
1:      *   only useful piece of information is the cause, or {@code false}
1:      *   otherwise
1:      */
1:     private static boolean isVacuousWrapper(Throwable t) {
1:         // The only interesting information in an InvocationTargetException
1:         // or a PrivilegedActionException is the cause, so consider them
1:         // vacuous if they have a cause.
1:         if (t instanceof InvocationTargetException
1:                 || t instanceof PrivilegedActionException) {
1:             return (t.getCause() != null);
1:         }
1: 
1:         // All other exceptions are non-vacuous.
1:         return false;
1:     }
1: 
1:         // If there is no useful information in the top-level throwable,
1:         // peel it off and only report the cause.
1:         if (isVacuousWrapper(t)) {
1:             return unexpectedUserException(t.getCause());
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         // If there is no useful information in the top-level throwable,
1:         // peel it off and only report the cause.
1:         if (isVacuousWrapper(t)) {
1:             return plainWrapException(t.getCause());
1:         }
1: 
commit:28dc366
/////////////////////////////////////////////////////////////////////////
1:     private transient boolean isForPublicAPI;
1:     private transient SQLException next;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the next {@code SQLException} that should be put into the parent
1:      * exception when this instance is converted to an {@code SQLException}.
1:      * @return the next exception
1:      */
1:     public final SQLException getNextException() {
1:         return next;
1:     }
1: 
1:     /**
1:      * Mark this exception as one that is thrown by a public API method.
1:      * The purpose is to signal that this should be a top-level exception,
1:      * so that it doesn't get wrapped inside multiple layers of other
1:      * SQLExceptions or StandardExceptions as it travels up through the
1:      * code layers.
1:      * @see PublicAPI
1:      */
1:     final void markAsPublicAPI() {
1:         isForPublicAPI = true;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Unpack the exception, looking for a StandardException, which carries
1:     public static StandardException getArgumentFerry(SQLException se)
1:         Throwable cause = se.getCause();
1:         return (cause instanceof StandardException)
1:                 ? (StandardException) cause : null;
1:         // argument ferry which is a StandardException. Use this to check
1:         StandardException ferry = null;
1:             SQLException sqle = (SQLException) t;
1:             ferry = getArgumentFerry(sqle);
1: 
1:             // If the ferry is marked for public API, it means we shouldn't
1:             // wrap it inside an "unexpected user exception", so just peel
1:             // off the parent SQLException and return the ferry.
1:             if (ferry != null && ferry.isForPublicAPI) {
1:                 // If the parent SQLException has any next exceptions, we
1:                 // need to store a reference to them before the parent is
1:                 // discarded.
1:                 ferry.next = sqle.getNextException();
1:                 return ferry;
1: 
1:         ** If we have a SQLException that didn't come from Derby, then we check
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             ** to build. This is no longer true for Derby.
1:             ** If the exception has no detail message
1:             ** problem down easier, though the lack of a message
1:             String detailMessage = t.getMessage();
/////////////////////////////////////////////////////////////////////////
1:             else
1:             {
1:                 detailMessage = t.getClass().getName() + ": " + detailMessage;
1:             return
commit:d6401b1
/////////////////////////////////////////////////////////////////////////
1:         // Add the SQLState to the message. This should be kept consistent
1:         // with SqlException.toString() in the client driver.
commit:1f18dc3
/////////////////////////////////////////////////////////////////////////
1:         if (textMessage == null) {
1:             textMessage = MessageService.getTextMessage(
1:                                 getMessageId(), getArguments());
1:         }
/////////////////////////////////////////////////////////////////////////
1:         String      message = MessageService.getTextMessage(messageId, oa);
commit:7043754
/////////////////////////////////////////////////////////////////////////
commit:97f7c7a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public static StandardException
1:             newException(String messageId, Object... args) {
1:         return newException(messageId, (Throwable) null, args);
1:     }
1:     public static StandardException
1:             newException(String messageId, Throwable t, Object... args) {
1:         return new StandardException(messageId, t, args);
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public static SQLWarning newWarning(String messageId, Object... oa)
commit:de3b108
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.jdbc.Util;
/////////////////////////////////////////////////////////////////////////
1:         // If the exception is an SQLException generated by Derby, it has an
0:         // argument ferry which is an EmbedSQLException. Use this to check
1:         // whether the exception was generated by Derby.
0:         EmbedSQLException ferry = null;
1:         if (t instanceof SQLException) {
0:             SQLException sqle =
0:                 Util.getExceptionFactory().getArgumentFerry((SQLException) t);
0:             if (sqle instanceof EmbedSQLException) {
0:                 ferry = (EmbedSQLException) sqle;
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		if ((t instanceof SQLException) && (ferry == null))
/////////////////////////////////////////////////////////////////////////
0: 		if (ferry != null) {
0: 			if (ferry.isSimpleWrapper()) {
0: 				Throwable wrapped = ferry.getCause();
/////////////////////////////////////////////////////////////////////////
0: 			if (ferry != null) {
0: 				detailMessage = ferry.toString();
commit:1095183
/////////////////////////////////////////////////////////////////////////
0: 				Throwable wrapped = csqle.getCause();
commit:e70c716
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		if (t != null) {
1: 			initCause(t);
1: 		}
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             se.initCause(t);
/////////////////////////////////////////////////////////////////////////
1: 					se.initCause(sqlex.getNextException());
/////////////////////////////////////////////////////////////////////////
1: 					se.initCause(plainWrapException(sqle));
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:c9ef166
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Is this a lock timeout exception.
1:      * <p>
1:      *
1:      * @return true if this exception is a lock timeout.
1:      *
1:      **/
1:     public final boolean isLockTimeout() {
1: 
1:         return(SQLState.LOCK_TIMEOUT.equals(getSQLState()));
1:     }
1: 
1:     /**
1:      * Is this a lock timeout or lock deadlock exception.
1:      * <p>
1:      *
1:      * @return true if this exception is a lock timeout or lock deadlock.
1:      *
1:      **/
1:     public final boolean isLockTimeoutOrDeadlock() {
1: 
1:         return(SQLState.LOCK_TIMEOUT.equals(getSQLState()) ||
1:                SQLState.DEADLOCK.equals(getSQLState()));
1:     }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4cded85
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:342793b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
/////////////////////////////////////////////////////////////////////////
1:     
1:     
1: 	/**
0: 	 * Unpack the exception, looking for an DerbySQLException, which carries
1: 	 * the Derby messageID and arguments. 
1: 	 * @see org.apache.derby.impl.jdbc.SQLExceptionFactory
0: 	 * @see org.apache.derby.impl.jdbc.SQLExceptionFactory40
1: 	 * @see org.apache.derby.impl.jdbc.Util
1: 	 */
0: 	public static SQLException	getArgumentFerry(SQLException se)
1: 	{
0: 		if (se instanceof DerbySQLException) {
1: 			/*
0: 			 * Cater for pre-JDBC4 scenario.
1: 			 */
1: 			return se;
1: 		}
1: 		/*
0: 		 * See DERBY-1178 for background information.
0: 		 * In JDBC4, the DerbySQLException may be wrapped by a SQLException.
1: 		 */
0: 		Throwable	cause = se.getCause();
1: 
0: 		if ( (cause == null) || !(cause instanceof DerbySQLException ))	{ return se; }
0: 		else	{ return (SQLException) cause; }
1: 	}
1: 
0:         // argument ferry which is an DerbySQLException. Use this to check
0:         DerbySQLException ferry = null;
0:                 getArgumentFerry((SQLException) t);
0:             if (sqle instanceof DerbySQLException) {
0:                 ferry = (DerbySQLException) sqle;
1:         
/////////////////////////////////////////////////////////////////////////
0: 				Throwable wrapped = ((SQLException)ferry).getCause();
commit:36f8c01
/////////////////////////////////////////////////////////////////////////
1: 	private transient Object[] arguments;
1: 	private transient int report;
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.error.StandardException
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.error
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.error;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.impl.jdbc.EmbedSQLException;
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import java.sql.SQLException;
1: import java.sql.SQLWarning;
1: 
1: /**
1: 	StandardException is the root of all exceptions that are handled
1: 	in a standard fashion by the database code, mainly in the language code.
1: 	<P>
1:     This class is abstract to ensure that an implementation only throws
1: 	a specific exception (e.g. TransactionException) which is a sub-class
1: 	<P>
1: 	A method in an iterface in a protocol under com.ibm.db2j.protocol.Database must
1: 	only throw a StandardException (if it needs to throw an exception).
1: 	This indicates that the method can throw an exception and therefore its
1: 	caller must ensure that any resources it allocates will be cleaned up
1: 	in the event of an exception in the StandardException hierarchy.
1: 	<P>
1: 	Implementations of methods that throw StandardException can have throws
1: 	clause that are more specific than StandardException.
1: */
1: 
1: public class StandardException extends Exception 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	public static final int REPORT_DEFAULT = 0;
1: 	public static final int REPORT_NEVER = 1;
1: 	public static final int REPORT_ALWAYS = 2;
1: 
1: 	/*
1: 	 * Exception State
1: 	 */
0: 	private Throwable nestedException;
0: 	private Object[] arguments;
1: 	private int severity;
1: 	private String textMessage;
1: 	private String sqlState;
0: 	private int report;
1: 
1: 	/*
1: 	** End of constructors
1: 	*/
1: 	
1: 	protected StandardException(String messageID)
1: 	{
1: 		this(messageID, (Throwable) null, (Object[]) null);
1: 
1: 	}
1: 
0: 	protected StandardException(String messageID, Object[] args)
1: 	{
0: 		this(messageID, (Throwable) null, args);
1: 	}
1: 
1: 	protected StandardException(String messageID, Throwable t, Object[] args)
1: 	{
1: 		super(messageID);
1: 
1: 		this.severity = getSeverityFromIdentifier(messageID);
1: 		this.sqlState = getSQLStateFromIdentifier(messageID);
0: 		this.nestedException = t;
1: 		this.arguments = args;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(messageID != null,
1: 					"StandardException with no messageID");
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * This constructor is used when we already have the
1: 	 * message text.
1: 	 * 
1: 	 * @param sqlState the sql state of the message
1: 	 * @param text the text of the message
1: 	 */
1: 	private StandardException(String sqlState, String text)
1: 	{
1: 		this(sqlState);
1: 		textMessage = text;
1: 	}
1: 
1: 	/*
1: 	** End of constructors
1: 	*/
1: 	/**
0: 	 * Sets the arguments for this exception.
1: 	 */
0: 	private final void setArguments(Object[] arguments)
1: 	{
0: 		this.arguments = arguments;
1: 	}
1: 
1: 	/**
1: 	 * Returns the arguments for this exception,
1: 	 * if there are any.
1: 	 */
0: 	public final Object[] getArguments()
1: 	{
0: 		return arguments;
1: 	}
1: 
1: 	/**
0: 	 * Sets the nested exception for this exception.
1: 	 */
0: 	public final void setNestedException(Throwable nestedException)
1: 	{
0: 		this.nestedException = nestedException;
1: 	}
1: 
1: 	/**
0: 	 * Returns the nested exception for this exception,
0: 	 * if there is one.
1: 	 */
0: 	public final Throwable getNestedException()
1: 	{
0: 		return nestedException;
1: 	}
1: 
1: 	/**
1: 		Yes, report me. Errors that need this method to return
1: 		false are in the minority.
1: 	*/
1: 	public final int report() {
1: 		return report;
1: 	}
1: 
1: 	/**
1: 		Set my report type.
1: 	*/
1: 	public final void setReport(int report) {
1: 		this.report = report;
1: 	}
1: 
1: 	public final void setSeverity(int severity) {
1: 		this.severity = severity;
1: 	}
1: 
1: 
1: 	public final int getSeverity() {
1: 		return severity;
1: 	}
1: 
1: 	public final int getErrorCode() {
1: 		return severity;
1: 	}
1: 
1: 	/**
1: 		Return the 5 character SQL State.
1: 		If you need teh identifier that was used to create the
1: 		message, then use getMessageId(). getMessageId() will return the
1: 		string that corresponds to the field in org.apache.derby.iapi.reference.SQLState.
1: 	*/
1: 	public final String getSQLState()
1: 	{
1: 		return sqlState;
1: 	}
1: 
1: 	/**
1: 		Convert a message identifer from org.apache.derby.iapi.reference.SQLState to
1: 		a SQLState five character string.
0: 	 *	@param messageID - the sql state id of the message from cloudscape
1: 	 *	@return String 	 - the 5 character code of the SQLState ID to returned to the user 
1: 	*/
1: 	public static String getSQLStateFromIdentifier(String messageID) {
1: 
1: 		if (messageID.length() == 5)
1: 			return messageID;
1: 		return messageID.substring(0, 5);
1: 	}
1: 
1: 	/**
1: 		Get the severity given a message identifier from org.apache.derby.iapi.reference.SQLState.
1: 	*/
1: 	public static int getSeverityFromIdentifier(String messageID) {
1: 
1: 		int lseverity = ExceptionSeverity.NO_APPLICABLE_SEVERITY;
1: 
1: 		switch (messageID.length()) {
1: 		case 5:
1: 			switch (messageID.charAt(0)) {
1: 			case '0':
1: 				switch (messageID.charAt(1)) {
1: 				case '1':
1: 					lseverity = ExceptionSeverity.WARNING_SEVERITY;
1: 					break;
1: 				case 'A':
1: 				case '7':
1: 					lseverity = ExceptionSeverity.STATEMENT_SEVERITY;
1: 					break;
1: 				case '8':
1: 					lseverity = ExceptionSeverity.SESSION_SEVERITY;
1: 					break;
1: 				}
1: 				break;	
1: 			case '2':
1: 			case '3':
1: 				lseverity = ExceptionSeverity.STATEMENT_SEVERITY;
1: 				break;
1: 			case '4':
1: 				switch (messageID.charAt(1)) {
1: 				case '0':
1: 					lseverity = ExceptionSeverity.TRANSACTION_SEVERITY;
1: 					break;
1: 				case '2':
1: 					lseverity = ExceptionSeverity.STATEMENT_SEVERITY;
1: 					break;
1: 				}
1: 				break;	
1: 			}
1: 			break;
1: 
1: 		default:
1: 			switch (messageID.charAt(6)) {
1: 			case 'M':
1: 				lseverity = ExceptionSeverity.SYSTEM_SEVERITY;
1: 				break;
1: 			case 'D':
1: 				lseverity = ExceptionSeverity.DATABASE_SEVERITY;
1: 				break;
1: 			case 'C':
1: 				lseverity = ExceptionSeverity.SESSION_SEVERITY;
1: 				break;
1: 			case 'T':
1: 				lseverity = ExceptionSeverity.TRANSACTION_SEVERITY;
1: 				break;
1: 			case 'S':
1: 				lseverity = ExceptionSeverity.STATEMENT_SEVERITY;
1: 				break;
1: 			case 'U':
1: 				lseverity = ExceptionSeverity.NO_APPLICABLE_SEVERITY;
1: 				break;
1: 			}
1: 			break;
1: 		}
1: 
1: 		return lseverity;
1: 	}
1: 
1: 	/*
1: 	** Set of static methods to obtain exceptions.
1: 	**
1: 	** Possible parameters:
1: 	** String sqlState - SQL State
1: 	** int severity - Severity of message
1: 	** Throwable t - exception to wrap
1: 	** Object aN - argument to error message
1: 	**
1: 	** Calls that can be made after the exception has been created.
1: 	**
1: 	** setExceptionCategory()
1: 	** setReport()
1: 	*/
1: 
1: 	/* specific exceptions */
1: 
1: 	public	static	StandardException	normalClose()
1: 	{
1: 		StandardException	se = newException( SQLState.NORMAL_CLOSE );
1: 		se.report = REPORT_NEVER;
1: 		return se;
1: 	}
1: 
0: 	public	static	StandardException	errorClose( Throwable t )
1: 	{
0: 		StandardException	se = newException( SQLState.ERROR_CLOSE, t );
1: 		se.report = REPORT_NEVER;
1: 		return se;
1: 	}
1: 
0: 	/* 0 arguments */
1: 
0: 	public static StandardException newException(String messageID) {
0: 		return new StandardException(messageID);
1: 	}
0: 	public static StandardException newException(String messageID, Throwable t) {
0: 		return new StandardException(messageID, t, (Object[]) null);
1: 	}
1: 
0: 	/* 1 argument */
1: 
0: 	public static StandardException newException(String messageID, Object a1) {
0: 		Object[] oa = new Object[] {a1};
0: 		return new StandardException(messageID, oa);
1: 	}
0: 	public static StandardException newException(String messageID, Throwable t, Object a1) {
0: 		Object[] oa = new Object[] {a1};
0: 		return new StandardException(messageID, t, oa);
1: 	}
1: 
1: 	/* 2 arguments */
1: 
0: 	public static StandardException newException(String messageID, Object a1, Object a2) {
0: 		Object[] oa = new Object[] {a1, a2};
0: 		return new StandardException(messageID, oa);
1: 	}
0: 	public static StandardException newException(String messageID, Throwable t, Object a1, Object a2) {
0: 		Object[] oa = new Object[] {a1, a2};
0: 		return new StandardException(messageID, t, oa);
1: 	}
1: 
1: 	/* 3 arguments */
1: 
0: 	public static StandardException newException(String messageID, Object a1, Object a2, Object a3) {
0: 		Object[] oa = new Object[] {a1, a2, a3};
0: 		return new StandardException(messageID, oa);
1: 	}
0: 	public static StandardException newException(String messageID, Throwable t, Object a1, Object a2, Object a3) {
0: 		Object[] oa = new Object[] {a1, a2, a3};
0: 		return new StandardException(messageID, t, oa);
1: 	}
1: 
0: 	/* 4 arguments */
1: 
0: 	public static StandardException newException(String messageID, Object a1, Object a2, Object a3, Object a4) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4};
0: 		return new StandardException(messageID, oa);
1: 	}
0: 	public static StandardException newException(String messageID, Throwable t, Object a1, Object a2, Object a3, Object a4) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4};
0: 		return new StandardException(messageID, t, oa);
1: 	}
1:  
0: 	/* 5 arguments */
0: 	public static StandardException newException(String messageID, Object a1, Object a2, Object a3, Object a4, Object a5) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4, a5};
0: 		return new StandardException(messageID, oa);
1: 	}
0: 	public static StandardException newException(String messageID, Throwable t, Object a1, Object a2, Object a3, Object a4, Object a5) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4, a5};
0: 		return new StandardException(messageID, t, oa);
1: 	}
1: 
0: 	/* 6 arguments */
0: 	public static StandardException newException(String messageID, Object a1, Object a2, Object a3, Object a4, Object a5, Object a6) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4, a5, a6};
0: 		return new StandardException(messageID, oa);
1: 	}
0: 	public static StandardException newException(String messageID, Throwable t, Object a1, Object a2, Object a3, Object a4, Object a5, Object a6) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4, a5, a6};
0: 		return new StandardException(messageID, t, oa);
1: 	}
1: 
0: 	/* 7 arguments */
0: 	public static StandardException newException(String messageID, Object a1, Object a2, Object a3, Object a4, Object a5, Object a6, Object a7) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4, a5, a6, a7};
0: 		return new StandardException(messageID, oa);
1: 	}
0: 	public static StandardException newException(String messageID, Throwable t, Object a1, Object a2, Object a3, Object a4, Object a5, Object a6, Object a7) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4, a5, a6, a7};
0: 		return new StandardException(messageID, t, oa);
1: 	}
1: 
0: 	/* 8 arguments */
0: 	public static StandardException newException(String messageID, Object a1, Object a2, Object a3, Object a4, Object a5, Object a6, Object a7, Object a8) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4, a5, a6, a7, a8};
0: 		return new StandardException(messageID, oa);
1: 	}
0: 	public static StandardException newException(String messageID, Throwable t, Object a1, Object a2, Object a3, Object a4, Object a5, Object a6, Object a7, Object a8) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4, a5, a6, a7, a8};
0: 		return new StandardException(messageID, t, oa);
1: 	}
1: 
1:     /**
1:      * Creates a new StandardException using message text that has already been localized.
1:      *
1:      * @param MessageID The SQLState and severity are derived from the ID. However the text message is not.
1:      * @param t The Throwable that caused this exception, null if this exception was not caused by another Throwable.
1:      * @param localizedMessage The message associated with this exception.
1:      *        <b>It is the caller's responsibility to ensure that this message is properly localized.</b>
1:      *
0:      * @see org.apache.derby.iapi.tools.i18n.LocalizedResource
1:      */
1:     public static StandardException newPreLocalizedException( String MessageID,
1:                                                               Throwable t,
1:                                                               String localizedMessage)
1:     {
1:         StandardException se = new StandardException( MessageID, localizedMessage);
1:         if( t != null)
0:             se.nestedException = t;
1:         return se;
1:     }
1: 
1: 	public static StandardException unexpectedUserException(Throwable t)
1: 	{
1: 		/*
0: 		** If we have a SQLException that isn't a Util
0: 		** (i.e. it didn't come from cloudscape), then we check
1: 		** to see if it is a valid user defined exception range 
1: 		** (38001-38XXX).  If so, then we convert it into a 
1: 		** StandardException without further ado.
1: 		*/ 
0: 		if ((t instanceof SQLException) &&
0: 		    !(t instanceof EmbedSQLException)) 
1: 		{
1: 			SQLException sqlex  = (SQLException)t;
1: 			String state = sqlex.getSQLState();
1: 			if ((state != null) && 
1: 				(state.length() == 5) &&
1: 				state.startsWith("38") &&
1: 				!state.equals("38000"))
1: 			{
1: 				StandardException se = new StandardException(state, sqlex.getMessage());
1: 				if (sqlex.getNextException() != null)		
1: 				{	
0: 					se.setNestedException(sqlex.getNextException());
1: 				}
1: 				return se;
1: 			}
1: 		}
1: 
0: 		// Look for simple wrappers for 3.0.1 - will be cleaned up in main
0: 		if (t instanceof EmbedSQLException) {
0: 			EmbedSQLException csqle = (EmbedSQLException) t;
0: 			if (csqle.isSimpleWrapper()) {
0: 				Throwable wrapped = csqle.getJavaException();
0: 				if (wrapped instanceof StandardException)
0: 					return (StandardException) wrapped;
1: 			}
1: 		}
1: 
1: 
1: 		// no need to wrap a StandardException
1: 		if (t instanceof StandardException) 
1: 		{
1: 			return (StandardException) t;
1: 		}
1: 		else
1: 		{
1: 			/*
1: 			** 
1: 			** The exception at this point could be a:
1: 			**
1: 			**    standard java exception, e.g. NullPointerException
1: 			**    SQL Exception - from some server-side JDBC
1: 			**    3rd party exception - from some application
0: 			**    some cloudscape exception that is not a standard exception.
1: 			**    
1: 			**    
1: 			** We don't want to call t.toString() here, because the JVM is
1: 			** inconsistent about whether it includes a detail message
1: 			** with some exceptions (esp. NullPointerException).  In those
1: 			** cases where there is a detail message, t.toString() puts in
1: 			** a colon character, even when the detail message is blank.
1: 			** So, we do our own string formatting here, including the colon
1: 			** only when there is a non-blank message.
1: 			**
1: 			** The above is because our test canons contain the text of
1: 			** error messages.
1: 			**
0: 			** In addition we don't want to place the class name in an
0: 			** exception when the class is from cloudscape because
0: 			** the class name changes in obfuscated builds. Thus for
0: 			** exceptions that are in a package below com.ibm.db2j
0: 			** we use toString(). If this returns an empty or null
0: 			** then we use the class name to make tracking the problem
0: 			** down easier, though the lack of a message should be seen
0: 			** as a bug.
1: 			*/
0: 			String	detailMessage;
0: 			boolean cloudscapeException = false;
1: 
0: 			if (t instanceof EmbedSQLException) {
0: 				detailMessage = ((EmbedSQLException) t).toString();
0: 				cloudscapeException = true;
1: 			}
0: 			else {
0: 				detailMessage = t.getMessage();
1: 			}
1: 
1: 			if (detailMessage == null)
1: 			{
1: 				detailMessage = "";
1: 			} else {
1: 				detailMessage = detailMessage.trim();
1: 			}
1: 
1: 			// if no message, use the class name
1: 			if (detailMessage.length() == 0) {
1: 				detailMessage = t.getClass().getName();
1: 			}
0: 			else {
1: 
0: 				if (!cloudscapeException) {
0: 					detailMessage = t.getClass().getName() + ": " + detailMessage;
1: 				}
1: 			}
1: 
1: 			StandardException se =
1: 				newException(SQLState.LANG_UNEXPECTED_USER_EXCEPTION, t, detailMessage);
1: 			return se;
1: 		}
1: 	}
1: 
1: 	/**
1: 		Similar to unexpectedUserException but makes no assumtion about
1: 		when the execption is being called. The error is wrapped as simply
1: 		as possible.
1: 	*/
1: 
1: 	public static StandardException plainWrapException(Throwable t) {
1: 
1: 		if (t instanceof StandardException)
1: 			return (StandardException) t;
1: 
1: 		if (t instanceof SQLException) {
1: 
1: 			SQLException sqle = (SQLException) t;
1: 
1: 			String sqlState = sqle.getSQLState();
1: 			if (sqlState != null) {
1: 
1: 				StandardException se = new StandardException(sqlState, "(" + sqle.getErrorCode()  + ") " + sqle.getMessage());
1: 				sqle = sqle.getNextException();
1: 				if (sqle != null)
0: 					se.setNestedException(plainWrapException(sqle));
1: 				return se;
1: 			}
1: 		}
1: 
1: 		String	detailMessage = t.getMessage();
1: 
1: 		if (detailMessage == null)
1: 		{
1: 			detailMessage = "";
1: 		} else {
1: 			detailMessage = detailMessage.trim();
1: 		}
1: 		
1: 		StandardException se =
1: 				newException(SQLState.JAVA_EXCEPTION, t, detailMessage, t.getClass().getName());
1: 		return se;
1: 	}
1: 
1: 	/**
1: 	** A special exception to close a session.
1: 	*/
1: 	public static StandardException closeException() {
1: 		StandardException se = newException(SQLState.CLOSE_REQUEST);
1: 		se.setReport(REPORT_NEVER);
1: 		return se;
1: 	}
1: 	/*
1: 	** Message handling
1: 	*/
1: 
1: 	/**
1: 		The message stored in the super class Throwable must be set
1: 		up object creation. At this time we cannot get any information
1: 		about the object itself (ie. this) in order to determine the
1: 		natural language message. Ie. we need to class of the objec in
1: 		order to look up its message, but we can't get the class of the
1: 		exception before calling the super class message.
1: 		<P>
1: 		Thus the message stored by Throwable and obtained by the
1: 		getMessage() of Throwable (ie. super.getMessage() in this
1: 		class) is the message identifier. The actual text message
1: 		is stored in this class at the first request.
1: 
1: 	*/
1: 
1: 	public String getMessage() {
0: 		if (textMessage == null)
0: 			textMessage = MessageService.getCompleteMessage(getMessageId(), getArguments());
1: 		return textMessage;
1: 	}
1: 
1: 	/**
1: 		Return the message identifier that is used to look up the
1: 		error message text in the messages.properties file.
1: 	*/
1: 	public final String getMessageId() {
1: 		return super.getMessage();
1: 	}
1: 
1: 
1: 	/**
1: 		Get the error code for an error given a type. The value of
1: 		the property messageId.type will be returned, e.g.
1: 		deadlock.sqlstate.
1: 	*/
1: 	public String getErrorProperty(String type) {
1: 		return getErrorProperty(getMessageId(), type);
1: 	}
1: 
1: 	/**
1: 		Don't print the class name in the toString() method.
1: 	*/
1: 	public String toString() {
1: 		String msg = getMessage();
1: 
1: 		return "ERROR " + getSQLState() + ": " + msg;
1: 	}
1: 
1: 	/*
1: 	** Static methods
1: 	*/
1: 
1: 	private static String getErrorProperty(String messageId, String type) {
1: 		return MessageService.getProperty(messageId, type);
1: 	}
1: 
1: 	public static StandardException interrupt(InterruptedException ie) {
1: 		StandardException se = StandardException.newException(SQLState.CONN_INTERRUPT, ie);
1: 		return se;
1: 	}
1: 	/*
1: 	** SQL warnings
1: 	*/
1: 
0: 	public static SQLWarning newWarning(String messageId) {
1: 
0: 		return newWarningCommon( messageId, (Object[]) null );
1: 
1: 	}
1: 
0: 	public static SQLWarning newWarning(String messageId, Object a1) {
1: 
0: 		Object[] oa = new Object[] {a1};
1: 
0: 		return newWarningCommon( messageId, oa );
1: 	}
1: 
0: 	public static SQLWarning newWarning(String messageId, Object a1, Object a2) {
1: 
0: 		Object[] oa = new Object[] {a1, a2};
1: 
0: 		return newWarningCommon( messageId, oa );
1: 	}
1: 
0: 	private	static	SQLWarning	newWarningCommon( String messageId, Object[] oa )
1: 	{
0: 		String		message = MessageService.getCompleteMessage(messageId, oa);
1: 		String		state = StandardException.getSQLStateFromIdentifier(messageId);
1: 		SQLWarning	sqlw = new SQLWarning(message, state, ExceptionSeverity.WARNING_SEVERITY);
1: 
1: 		return sqlw;
1: 	}
1: }
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:29fd25c
/////////////////////////////////////////////////////////////////////////
0: 
1: 	public static StandardException newException(String messageID,
0: 												 Object[] a1) {
0: 		return new StandardException(messageID, a1);
0: 	}
0: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1: 	 *	@param messageID - the sql state id of the message from Derby
/////////////////////////////////////////////////////////////////////////
0: 		** If we have a SQLException that isn't an EmbedSQLException
0: 		** (i.e. it didn't come from Derby), then we check
/////////////////////////////////////////////////////////////////////////
1: 			**    some Derby exception that is not a standard exception.
/////////////////////////////////////////////////////////////////////////
0: 			** 
1: 			** In the past we didn't want to place the class name in
1: 			** an exception because Cloudscape builds were
1: 			** obfuscated, so the class name would change from build
0:                         ** to build. This is no longer true for Derby, but for
0: 			** exceptions that are Derby's, i.e. EmbedSQLException,
1: 			** then we use the class name to make tracking the 
0:                         ** problem down easier, though the lack of a message 
1: 			** should be seen as a bug.
0: 			boolean derbyException = false;
0: 				derbyException = true;
/////////////////////////////////////////////////////////////////////////
0: 				if (!derbyException) {
author:David Van Couvering
-------------------------------------------------------------------------------
commit:1d8e53f
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:2e35afd
/////////////////////////////////////////////////////////////////////////
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1:      * See org.apache.derby.iapi.tools.i18n.LocalizedResource
commit:75fb1cf
/////////////////////////////////////////////////////////////////////////
0:                     SanityManager.ASSERT(messageID != null,
0:                                          "StandardException with no messageID");
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:      * Dummy exception to catch incorrect use of
1:      * StandardException.newException(), at compile-time. If you get a
1:      * compilation error because this exception isn't caught, it means
1:      * that you are using StandardException.newException(...)
1:      * incorrectly. The nested exception should always be the second
1:      * argument.
1:      * @see StandardException#newException(String, Object, Throwable)
1:      * @see StandardException#newException(String, Object, Object, Throwable)
0:      */
1:     public static class BadMessageArgumentException extends Throwable {}
0: 
0:     /**
1:      * Dummy overload which should never be called. Only used to
1:      * detect incorrect usage, at compile time.
1:      * @param messageID - the sql state id of the message
1:      * @param a1 - Message arg
1:      * @param t - Incorrectly placed exception to be nested
1:      * @return nothing - always throws
1:      * @throws BadMessageArgumentException - always (dummy)
0:      */
1:     public static StandardException newException(String messageID, 
1:                                                  Object a1, 
1:                                                  Throwable t) 
1:         throws BadMessageArgumentException {
1:         throw new BadMessageArgumentException();
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:     
0:     /**
1:      * Dummy overload which should never be called. Only used to
1:      * detect incorrect usage, at compile time.
1:      * @param messageID - the sql state id of the message
1:      * @param a1 - First message arg
1:      * @param a2 - Second message arg
1:      * @param t - Incorrectly placed exception to be nested
1:      * @return nothing - always throws
1:      * @throws BadMessageArgumentException - always (dummy)
0:      */
0:     public static StandardException newException(String messageID, 
1:                                                  Object a1, 
1:                                                  Object a2,
1:                                                  Throwable t) 
1:         throws BadMessageArgumentException {
1:         throw new BadMessageArgumentException(); 
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.error
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.error;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.impl.jdbc.EmbedSQLException;
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import java.sql.SQLException;
0: import java.sql.SQLWarning;
0: 
0: /**
0: 	StandardException is the root of all exceptions that are handled
0: 	in a standard fashion by the database code, mainly in the language code.
0: 	<P>
0:     This class is abstract to ensure that an implementation only throws
0: 	a specific exception (e.g. TransactionException) which is a sub-class
0: 	<P>
0: 	A method in an iterface in a protocol under com.ibm.db2j.protocol.Database must
0: 	only throw a StandardException (if it needs to throw an exception).
0: 	This indicates that the method can throw an exception and therefore its
0: 	caller must ensure that any resources it allocates will be cleaned up
0: 	in the event of an exception in the StandardException hierarchy.
0: 	<P>
0: 	Implementations of methods that throw StandardException can have throws
0: 	clause that are more specific than StandardException.
0: */
0: 
0: public class StandardException extends Exception 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public static final int REPORT_DEFAULT = 0;
0: 	public static final int REPORT_NEVER = 1;
0: 	public static final int REPORT_ALWAYS = 2;
0: 
0: 	/*
0: 	 * Exception State
0: 	 */
0: 	private Throwable nestedException;
0: 	private Object[] arguments;
0: 	private int severity;
0: 	private String textMessage;
0: 	private String sqlState;
0: 	private int report;
0: 
0: 	/*
0: 	** End of constructors
0: 	*/
0: 	
0: 	protected StandardException(String messageID)
0: 	{
0: 		this(messageID, (Throwable) null, (Object[]) null);
0: 
0: 	}
0: 
0: 	protected StandardException(String messageID, Object[] args)
0: 	{
0: 		this(messageID, (Throwable) null, args);
0: 	}
0: 
0: 	protected StandardException(String messageID, Throwable t, Object[] args)
0: 	{
0: 		super(messageID);
0: 
0: 		this.severity = getSeverityFromIdentifier(messageID);
0: 		this.sqlState = getSQLStateFromIdentifier(messageID);
0: 		this.nestedException = t;
0: 		this.arguments = args;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(messageID != null,
0: 					"StandardException with no messageID");
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * This constructor is used when we already have the
0: 	 * message text.
0: 	 * 
0: 	 * @param sqlState the sql state of the message
0: 	 * @param text the text of the message
0: 	 */
0: 	private StandardException(String sqlState, String text)
0: 	{
0: 		this(sqlState);
0: 		textMessage = text;
0: 	}
0: 
0: 	/*
0: 	** End of constructors
0: 	*/
0: 	/**
0: 	 * Sets the arguments for this exception.
0: 	 */
0: 	private final void setArguments(Object[] arguments)
0: 	{
0: 		this.arguments = arguments;
0: 	}
0: 
0: 	/**
0: 	 * Returns the arguments for this exception,
0: 	 * if there are any.
0: 	 */
0: 	public final Object[] getArguments()
0: 	{
0: 		return arguments;
0: 	}
0: 
0: 	/**
0: 	 * Sets the nested exception for this exception.
0: 	 */
0: 	public final void setNestedException(Throwable nestedException)
0: 	{
0: 		this.nestedException = nestedException;
0: 	}
0: 
0: 	/**
0: 	 * Returns the nested exception for this exception,
0: 	 * if there is one.
0: 	 */
0: 	public final Throwable getNestedException()
0: 	{
0: 		return nestedException;
0: 	}
0: 
0: 	/**
0: 		Yes, report me. Errors that need this method to return
0: 		false are in the minority.
0: 	*/
0: 	public final int report() {
0: 		return report;
0: 	}
0: 
0: 	/**
0: 		Set my report type.
0: 	*/
0: 	public final void setReport(int report) {
0: 		this.report = report;
0: 	}
0: 
0: 	public final void setSeverity(int severity) {
0: 		this.severity = severity;
0: 	}
0: 
0: 
0: 	public final int getSeverity() {
0: 		return severity;
0: 	}
0: 
0: 	public final int getErrorCode() {
0: 		return severity;
0: 	}
0: 
0: 	/**
0: 		Return the 5 character SQL State.
0: 		If you need teh identifier that was used to create the
0: 		message, then use getMessageId(). getMessageId() will return the
0: 		string that corresponds to the field in org.apache.derby.iapi.reference.SQLState.
0: 	*/
0: 	public final String getSQLState()
0: 	{
0: 		return sqlState;
0: 	}
0: 
0: 	/**
0: 		Convert a message identifer from org.apache.derby.iapi.reference.SQLState to
0: 		a SQLState five character string.
0: 	 *	@param messageID - the sql state id of the message from cloudscape
0: 	 *	@return String 	 - the 5 character code of the SQLState ID to returned to the user 
0: 	*/
0: 	public static String getSQLStateFromIdentifier(String messageID) {
0: 
0: 		if (messageID.length() == 5)
0: 			return messageID;
0: 		return messageID.substring(0, 5);
0: 	}
0: 
0: 	/**
0: 		Get the severity given a message identifier from org.apache.derby.iapi.reference.SQLState.
0: 	*/
0: 	public static int getSeverityFromIdentifier(String messageID) {
0: 
0: 		int lseverity = ExceptionSeverity.NO_APPLICABLE_SEVERITY;
0: 
0: 		switch (messageID.length()) {
0: 		case 5:
0: 			switch (messageID.charAt(0)) {
0: 			case '0':
0: 				switch (messageID.charAt(1)) {
0: 				case '1':
0: 					lseverity = ExceptionSeverity.WARNING_SEVERITY;
0: 					break;
0: 				case 'A':
0: 				case '7':
0: 					lseverity = ExceptionSeverity.STATEMENT_SEVERITY;
0: 					break;
0: 				case '8':
0: 					lseverity = ExceptionSeverity.SESSION_SEVERITY;
0: 					break;
0: 				}
0: 				break;	
0: 			case '2':
0: 			case '3':
0: 				lseverity = ExceptionSeverity.STATEMENT_SEVERITY;
0: 				break;
0: 			case '4':
0: 				switch (messageID.charAt(1)) {
0: 				case '0':
0: 					lseverity = ExceptionSeverity.TRANSACTION_SEVERITY;
0: 					break;
0: 				case '2':
0: 					lseverity = ExceptionSeverity.STATEMENT_SEVERITY;
0: 					break;
0: 				}
0: 				break;	
0: 			}
0: 			break;
0: 
0: 		default:
0: 			switch (messageID.charAt(6)) {
0: 			case 'M':
0: 				lseverity = ExceptionSeverity.SYSTEM_SEVERITY;
0: 				break;
0: 			case 'D':
0: 				lseverity = ExceptionSeverity.DATABASE_SEVERITY;
0: 				break;
0: 			case 'C':
0: 				lseverity = ExceptionSeverity.SESSION_SEVERITY;
0: 				break;
0: 			case 'T':
0: 				lseverity = ExceptionSeverity.TRANSACTION_SEVERITY;
0: 				break;
0: 			case 'S':
0: 				lseverity = ExceptionSeverity.STATEMENT_SEVERITY;
0: 				break;
0: 			case 'U':
0: 				lseverity = ExceptionSeverity.NO_APPLICABLE_SEVERITY;
0: 				break;
0: 			}
0: 			break;
0: 		}
0: 
0: 		return lseverity;
0: 	}
0: 
0: 	/*
0: 	** Set of static methods to obtain exceptions.
0: 	**
0: 	** Possible parameters:
0: 	** String sqlState - SQL State
0: 	** int severity - Severity of message
0: 	** Throwable t - exception to wrap
0: 	** Object aN - argument to error message
0: 	**
0: 	** Calls that can be made after the exception has been created.
0: 	**
0: 	** setExceptionCategory()
0: 	** setReport()
0: 	*/
0: 
0: 	/* specific exceptions */
0: 
0: 	public	static	StandardException	normalClose()
0: 	{
0: 		StandardException	se = newException( SQLState.NORMAL_CLOSE );
0: 		se.report = REPORT_NEVER;
0: 		return se;
0: 	}
0: 
0: 	public	static	StandardException	errorClose( Throwable t )
0: 	{
0: 		StandardException	se = newException( SQLState.ERROR_CLOSE, t );
0: 		se.report = REPORT_NEVER;
0: 		return se;
0: 	}
0: 
0: 	/* 0 arguments */
0: 
0: 	public static StandardException newException(String messageID) {
0: 		return new StandardException(messageID);
0: 	}
0: 	public static StandardException newException(String messageID, Throwable t) {
0: 		return new StandardException(messageID, t, (Object[]) null);
0: 	}
0: 
0: 	/* 1 argument */
0: 
0: 	public static StandardException newException(String messageID, Object a1) {
0: 		Object[] oa = new Object[] {a1};
0: 		return new StandardException(messageID, oa);
0: 	}
0: 	public static StandardException newException(String messageID, Throwable t, Object a1) {
0: 		Object[] oa = new Object[] {a1};
0: 		return new StandardException(messageID, t, oa);
0: 	}
0: 
0: 	/* 2 arguments */
0: 
0: 	public static StandardException newException(String messageID, Object a1, Object a2) {
0: 		Object[] oa = new Object[] {a1, a2};
0: 		return new StandardException(messageID, oa);
0: 	}
0: 	public static StandardException newException(String messageID, Throwable t, Object a1, Object a2) {
0: 		Object[] oa = new Object[] {a1, a2};
0: 		return new StandardException(messageID, t, oa);
0: 	}
0: 
0: 	/* 3 arguments */
0: 
0: 	public static StandardException newException(String messageID, Object a1, Object a2, Object a3) {
0: 		Object[] oa = new Object[] {a1, a2, a3};
0: 		return new StandardException(messageID, oa);
0: 	}
0: 	public static StandardException newException(String messageID, Throwable t, Object a1, Object a2, Object a3) {
0: 		Object[] oa = new Object[] {a1, a2, a3};
0: 		return new StandardException(messageID, t, oa);
0: 	}
0: 
0: 	/* 4 arguments */
0: 
0: 	public static StandardException newException(String messageID, Object a1, Object a2, Object a3, Object a4) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4};
0: 		return new StandardException(messageID, oa);
0: 	}
0: 	public static StandardException newException(String messageID, Throwable t, Object a1, Object a2, Object a3, Object a4) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4};
0: 		return new StandardException(messageID, t, oa);
0: 	}
0:  
0: 	/* 5 arguments */
0: 	public static StandardException newException(String messageID, Object a1, Object a2, Object a3, Object a4, Object a5) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4, a5};
0: 		return new StandardException(messageID, oa);
0: 	}
0: 	public static StandardException newException(String messageID, Throwable t, Object a1, Object a2, Object a3, Object a4, Object a5) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4, a5};
0: 		return new StandardException(messageID, t, oa);
0: 	}
0: 
0: 	/* 6 arguments */
0: 	public static StandardException newException(String messageID, Object a1, Object a2, Object a3, Object a4, Object a5, Object a6) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4, a5, a6};
0: 		return new StandardException(messageID, oa);
0: 	}
0: 	public static StandardException newException(String messageID, Throwable t, Object a1, Object a2, Object a3, Object a4, Object a5, Object a6) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4, a5, a6};
0: 		return new StandardException(messageID, t, oa);
0: 	}
0: 
0: 	/* 7 arguments */
0: 	public static StandardException newException(String messageID, Object a1, Object a2, Object a3, Object a4, Object a5, Object a6, Object a7) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4, a5, a6, a7};
0: 		return new StandardException(messageID, oa);
0: 	}
0: 	public static StandardException newException(String messageID, Throwable t, Object a1, Object a2, Object a3, Object a4, Object a5, Object a6, Object a7) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4, a5, a6, a7};
0: 		return new StandardException(messageID, t, oa);
0: 	}
0: 
0: 	/* 8 arguments */
0: 	public static StandardException newException(String messageID, Object a1, Object a2, Object a3, Object a4, Object a5, Object a6, Object a7, Object a8) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4, a5, a6, a7, a8};
0: 		return new StandardException(messageID, oa);
0: 	}
0: 	public static StandardException newException(String messageID, Throwable t, Object a1, Object a2, Object a3, Object a4, Object a5, Object a6, Object a7, Object a8) {
0: 		Object[] oa = new Object[] {a1, a2, a3, a4, a5, a6, a7, a8};
0: 		return new StandardException(messageID, t, oa);
0: 	}
0: 
0:     /**
0:      * Creates a new StandardException using message text that has already been localized.
0:      *
0:      * @param MessageID The SQLState and severity are derived from the ID. However the text message is not.
0:      * @param t The Throwable that caused this exception, null if this exception was not caused by another Throwable.
0:      * @param localizedMessage The message associated with this exception.
0:      *        <b>It is the caller's responsibility to ensure that this message is properly localized.</b>
0:      *
0:      * @see org.apache.derby.iapi.tools.i18n.LocalizedResource
0:      */
0:     public static StandardException newPreLocalizedException( String MessageID,
0:                                                               Throwable t,
0:                                                               String localizedMessage)
0:     {
0:         StandardException se = new StandardException( MessageID, localizedMessage);
0:         if( t != null)
0:             se.nestedException = t;
0:         return se;
0:     }
0: 
0: 	public static StandardException unexpectedUserException(Throwable t)
0: 	{
0: 		/*
0: 		** If we have a SQLException that isn't a Util
0: 		** (i.e. it didn't come from cloudscape), then we check
0: 		** to see if it is a valid user defined exception range 
0: 		** (38001-38XXX).  If so, then we convert it into a 
0: 		** StandardException without further ado.
0: 		*/ 
0: 		if ((t instanceof SQLException) &&
0: 		    !(t instanceof EmbedSQLException)) 
0: 		{
0: 			SQLException sqlex  = (SQLException)t;
0: 			String state = sqlex.getSQLState();
0: 			if ((state != null) && 
0: 				(state.length() == 5) &&
0: 				state.startsWith("38") &&
0: 				!state.equals("38000"))
0: 			{
0: 				StandardException se = new StandardException(state, sqlex.getMessage());
0: 				if (sqlex.getNextException() != null)		
0: 				{	
0: 					se.setNestedException(sqlex.getNextException());
0: 				}
0: 				return se;
0: 			}
0: 		}
0: 
0: 		// Look for simple wrappers for 3.0.1 - will be cleaned up in main
0: 		if (t instanceof EmbedSQLException) {
0: 			EmbedSQLException csqle = (EmbedSQLException) t;
0: 			if (csqle.isSimpleWrapper()) {
0: 				Throwable wrapped = csqle.getJavaException();
0: 				if (wrapped instanceof StandardException)
0: 					return (StandardException) wrapped;
0: 			}
0: 		}
0: 
0: 
0: 		// no need to wrap a StandardException
0: 		if (t instanceof StandardException) 
0: 		{
0: 			return (StandardException) t;
0: 		}
0: 		else
0: 		{
0: 			/*
0: 			** 
0: 			** The exception at this point could be a:
0: 			**
0: 			**    standard java exception, e.g. NullPointerException
0: 			**    SQL Exception - from some server-side JDBC
0: 			**    3rd party exception - from some application
0: 			**    some cloudscape exception that is not a standard exception.
0: 			**    
0: 			**    
0: 			** We don't want to call t.toString() here, because the JVM is
0: 			** inconsistent about whether it includes a detail message
0: 			** with some exceptions (esp. NullPointerException).  In those
0: 			** cases where there is a detail message, t.toString() puts in
0: 			** a colon character, even when the detail message is blank.
0: 			** So, we do our own string formatting here, including the colon
0: 			** only when there is a non-blank message.
0: 			**
0: 			** The above is because our test canons contain the text of
0: 			** error messages.
0: 			**
0: 			** In addition we don't want to place the class name in an
0: 			** exception when the class is from cloudscape because
0: 			** the class name changes in obfuscated builds. Thus for
0: 			** exceptions that are in a package below com.ibm.db2j
0: 			** we use toString(). If this returns an empty or null
0: 			** then we use the class name to make tracking the problem
0: 			** down easier, though the lack of a message should be seen
0: 			** as a bug.
0: 			*/
0: 			String	detailMessage;
0: 			boolean cloudscapeException = false;
0: 
0: 			if (t instanceof EmbedSQLException) {
0: 				detailMessage = ((EmbedSQLException) t).toString();
0: 				cloudscapeException = true;
0: 			}
0: 			else {
0: 				detailMessage = t.getMessage();
0: 			}
0: 
0: 			if (detailMessage == null)
0: 			{
0: 				detailMessage = "";
0: 			} else {
0: 				detailMessage = detailMessage.trim();
0: 			}
0: 
0: 			// if no message, use the class name
0: 			if (detailMessage.length() == 0) {
0: 				detailMessage = t.getClass().getName();
0: 			}
0: 			else {
0: 
0: 				if (!cloudscapeException) {
0: 					detailMessage = t.getClass().getName() + ": " + detailMessage;
0: 				}
0: 			}
0: 
0: 			StandardException se =
0: 				newException(SQLState.LANG_UNEXPECTED_USER_EXCEPTION, t, detailMessage);
0: 			return se;
0: 		}
0: 	}
0: 
0: 	/**
0: 		Similar to unexpectedUserException but makes no assumtion about
0: 		when the execption is being called. The error is wrapped as simply
0: 		as possible.
0: 	*/
0: 
0: 	public static StandardException plainWrapException(Throwable t) {
0: 
0: 		if (t instanceof StandardException)
0: 			return (StandardException) t;
0: 
0: 		if (t instanceof SQLException) {
0: 
0: 			SQLException sqle = (SQLException) t;
0: 
0: 			String sqlState = sqle.getSQLState();
0: 			if (sqlState != null) {
0: 
0: 				StandardException se = new StandardException(sqlState, "(" + sqle.getErrorCode()  + ") " + sqle.getMessage());
0: 				sqle = sqle.getNextException();
0: 				if (sqle != null)
0: 					se.setNestedException(plainWrapException(sqle));
0: 				return se;
0: 			}
0: 		}
0: 
0: 		String	detailMessage = t.getMessage();
0: 
0: 		if (detailMessage == null)
0: 		{
0: 			detailMessage = "";
0: 		} else {
0: 			detailMessage = detailMessage.trim();
0: 		}
0: 		
0: 		StandardException se =
0: 				newException(SQLState.JAVA_EXCEPTION, t, detailMessage, t.getClass().getName());
0: 		return se;
0: 	}
0: 
0: 	/**
0: 	** A special exception to close a session.
0: 	*/
0: 	public static StandardException closeException() {
0: 		StandardException se = newException(SQLState.CLOSE_REQUEST);
0: 		se.setReport(REPORT_NEVER);
0: 		return se;
0: 	}
0: 	/*
0: 	** Message handling
0: 	*/
0: 
0: 	/**
0: 		The message stored in the super class Throwable must be set
0: 		up object creation. At this time we cannot get any information
0: 		about the object itself (ie. this) in order to determine the
0: 		natural language message. Ie. we need to class of the objec in
0: 		order to look up its message, but we can't get the class of the
0: 		exception before calling the super class message.
0: 		<P>
0: 		Thus the message stored by Throwable and obtained by the
0: 		getMessage() of Throwable (ie. super.getMessage() in this
0: 		class) is the message identifier. The actual text message
0: 		is stored in this class at the first request.
0: 
0: 	*/
0: 
0: 	public String getMessage() {
0: 		if (textMessage == null)
0: 			textMessage = MessageService.getCompleteMessage(getMessageId(), getArguments());
0: 		return textMessage;
0: 	}
0: 
0: 	/**
0: 		Return the message identifier that is used to look up the
0: 		error message text in the messages.properties file.
0: 	*/
0: 	public final String getMessageId() {
0: 		return super.getMessage();
0: 	}
0: 
0: 
0: 	/**
0: 		Get the error code for an error given a type. The value of
0: 		the property messageId.type will be returned, e.g.
0: 		deadlock.sqlstate.
0: 	*/
0: 	public String getErrorProperty(String type) {
0: 		return getErrorProperty(getMessageId(), type);
0: 	}
0: 
0: 	/**
0: 		Don't print the class name in the toString() method.
0: 	*/
0: 	public String toString() {
0: 		String msg = getMessage();
0: 
0: 		return "ERROR " + getSQLState() + ": " + msg;
0: 	}
0: 
0: 	/*
0: 	** Static methods
0: 	*/
0: 
0: 	private static String getErrorProperty(String messageId, String type) {
0: 		return MessageService.getProperty(messageId, type);
0: 	}
0: 
0: 	public static StandardException interrupt(InterruptedException ie) {
0: 		StandardException se = StandardException.newException(SQLState.CONN_INTERRUPT, ie);
0: 		return se;
0: 	}
0: 	/*
0: 	** SQL warnings
0: 	*/
0: 
0: 	public static SQLWarning newWarning(String messageId) {
0: 
0: 		return newWarningCommon( messageId, (Object[]) null );
0: 
0: 	}
0: 
0: 	public static SQLWarning newWarning(String messageId, Object a1) {
0: 
0: 		Object[] oa = new Object[] {a1};
0: 
0: 		return newWarningCommon( messageId, oa );
0: 	}
0: 
0: 	public static SQLWarning newWarning(String messageId, Object a1, Object a2) {
0: 
0: 		Object[] oa = new Object[] {a1, a2};
0: 
0: 		return newWarningCommon( messageId, oa );
0: 	}
0: 
0: 	private	static	SQLWarning	newWarningCommon( String messageId, Object[] oa )
0: 	{
0: 		String		message = MessageService.getCompleteMessage(messageId, oa);
0: 		String		state = StandardException.getSQLStateFromIdentifier(messageId);
0: 		SQLWarning	sqlw = new SQLWarning(message, state, ExceptionSeverity.WARNING_SEVERITY);
0: 
0: 		return sqlw;
0: 	}
0: }
============================================================================