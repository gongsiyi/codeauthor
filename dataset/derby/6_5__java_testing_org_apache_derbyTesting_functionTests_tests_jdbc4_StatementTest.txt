1:64e1768: /*
6:64e1768:  *
1:4eb3fed:  * Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.StatementTest
1:3bfb5f0:  *
1:6e3dbab:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:6e3dbab:  * contributor license agreements.  See the NOTICE file distributed with
1:6e3dbab:  * this work for additional information regarding copyright ownership.
1:6e3dbab:  * The ASF licenses this file to you under the Apache License, Version 2.0
1:6e3dbab:  * (the "License"); you may not use this file except in compliance with
1:6e3dbab:  * the License.  You may obtain a copy of the License at
1:64e1768:  *
1:64e1768:  *    http://www.apache.org/licenses/LICENSE-2.0
1:64e1768:  *
1:64e1768:  * Unless required by applicable law or agreed to in writing, 
1:64e1768:  * software distributed under the License is distributed on an 
1:64e1768:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:64e1768:  * either express or implied. See the License for the specific 
1:64e1768:  * language governing permissions and limitations under the License.
3:64e1768:  */
1:13e9e78: 
1:64e1768: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:f26c60c: 
1:f26c60c: import java.lang.reflect.InvocationTargetException;
1:f26c60c: import java.lang.reflect.Method;
1:1ae02c9: import java.sql.CallableStatement;
1:1ae02c9: import java.sql.Connection;
1:1ae02c9: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.ResultSet;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.SQLTimeoutException;
1:1ae02c9: import java.sql.Statement;
1:1ae02c9: import junit.framework.Test;
1:1ae02c9: import org.apache.derby.client.am.ClientStatement;
1:47a8183: import org.apache.derby.impl.jdbc.EmbedResultSet;
1:f26c60c: import org.apache.derby.impl.sql.execute.RowUtil;
1:1ae02c9: import org.apache.derby.shared.common.sanity.SanityManager;
1:b54918e: import org.apache.derbyTesting.functionTests.tests.jdbcapi.BatchUpdateTest;
1:4eb3fed: import org.apache.derbyTesting.functionTests.tests.jdbcapi.SetQueryTimeoutTest;
1:b54918e: import org.apache.derbyTesting.functionTests.tests.jdbcapi.Wrapper41Statement;
1:e4ba4e1: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
1:3bd1dd8: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:ec5ae26: import org.apache.derbyTesting.junit.TestConfiguration;
2:e4ba4e1: 
3:64e1768: /**
1:64e1768:  * Tests for new methods added for Statement in JDBC4.
1:64e1768:  */
1:64e1768: public class StatementTest
1:64e1768:     extends BaseJDBCTestCase {
1:3bfb5f0: 
1:13e9e78:    /** Default statement used by the tests. */
1:64e1768:     private Statement stmt = null;
1:3bfb5f0:     
1:64e1768:     /**
1:64e1768:      * Create a new test with the given name.
1:3bfb5f0:      *
1:64e1768:      * @param name name of the test.
1:64e1768:      */
1:64e1768:     public StatementTest(String name) {
1:64e1768:         super(name);
1:3bfb5f0:     }
1:4eb3fed: 
1:3bfb5f0:     /**
1:64e1768:      * Create default connection and statement.
1:3bfb5f0:      *
1:64e1768:      * @throws SQLException if setAutoCommit, createStatement or 
1:64e1768:      *                      BaseJDBCTestCase.getConnection fails.
1:3bfb5f0:      */
1:13e9e78:     protected void setUp() 
2:64e1768:         throws SQLException {
1:03a99e2:         getConnection().setAutoCommit(false);
1:64e1768:         // Create a default statement.
1:13e9e78:         stmt = createStatement();
1:64e1768:         assertFalse("First statement must be open initially", 
1:64e1768:                 stmt.isClosed());
1:b451cab:     }
1:4eb3fed: 
1:7eed914:     /**
1:64e1768:      * Close default connection and statement if necessary.
1:3bfb5f0:      *
1:64e1768:      * @throws SQLException if a database access exception occurs.
1:64e1768:      */
1:13e9e78:     protected void tearDown() 
1:13e9e78:         throws Exception {
1:64e1768:         // Close default statement
1:64e1768:         if (stmt != null) {
1:64e1768:             stmt.close();
1:ec5ae26:             stmt = null;
1:4eb3fed:         }
1:4eb3fed: 
1:13e9e78:         super.tearDown();
1:3bfb5f0:     }
1:4eb3fed: 
1:64e1768:     /**
1:64e1768:      * Check that <code>isClosed</code> returns <code>true</code> after
1:64e1768:      * the statement has been explicitly closed.
1:64e1768:      */
1:64e1768:     public void testIsClosedBasic()
1:64e1768:         throws SQLException {
1:64e1768:         ResultSet rs = stmt.executeQuery("select count(*) from stmtTable");
1:64e1768:         assertFalse("Statement should still be open", stmt.isClosed());
1:64e1768:         rs.close();
1:64e1768:         assertFalse("Statement should be open after ResultSet has been " +
1:64e1768:                 "closed", stmt.isClosed());
1:64e1768:         stmt.close();
1:64e1768:         assertTrue("Statement should be closed, close() has been called", 
1:64e1768:                 stmt.isClosed());
1:3bfb5f0:     }
1:3bfb5f0:     
1:64e1768:     /**
1:64e1768:      * Test that creating two statements on the same connection does not
1:64e1768:      * cause side effects on the statements.
1:64e1768:      */
1:64e1768:     public void testIsClosedWithTwoStatementsOnSameConnection()
1:64e1768:         throws SQLException {
1:64e1768:         // Create a second statement on the default connection.
1:13e9e78:         Statement stmt2 = createStatement();
1:64e1768:         assertFalse("Second statement must be open initially", 
1:64e1768:                 stmt2.isClosed());
1:64e1768:         assertFalse("First statement should not be closed when " +
1:64e1768:                 "creating a second statement", stmt.isClosed());
1:64e1768:         ResultSet rs = stmt2.executeQuery("select count(*) from stmtTable");
1:64e1768:         assertFalse("Second statement should be open after call to " +
1:64e1768:                 "execute()", stmt2.isClosed());
1:64e1768:         assertFalse("First statement should be open after call to " +
1:64e1768:                 "second statment's execute()", stmt.isClosed());
1:64e1768:         stmt2.close();
1:64e1768:         assertTrue("Second statement should be closed, close() has " +
1:64e1768:                 "been called!", stmt2.isClosed());
1:64e1768:         assertFalse("First statement should be open after call to " +
1:64e1768:                 "second statment's close()", stmt.isClosed());
11:64e1768:     }
1:3bfb5f0: 
1:64e1768:     /**
1:64e1768:      * Test that the two statements created on the connection are closed
1:64e1768:      * when the connection itself is closed.
1:64e1768:      */
1:64e1768:     public void testIsClosedWhenClosingConnection()
1:64e1768:         throws SQLException {
1:64e1768:         // Create an extra statement for good measure.
1:13e9e78:         Statement stmt2 = createStatement();
1:64e1768:         assertFalse("Second statement must be open initially",
1:64e1768:                 stmt2.isClosed());
1:64e1768:         // Exeute something on it, as opposed to the default statement.
1:64e1768:         stmt2.execute("select count(*) from stmtTable");
1:64e1768:         assertFalse("Second statement should be open after call to " +
1:64e1768:                 "execute()", stmt2.isClosed());
1:64e1768:         // Close the connection. We must commit/rollback first, or else a
1:64e1768:         // "Invalid transaction state" exception is raised.
1:13e9e78:         rollback();
1:03a99e2:         Connection con = getConnection();
2:64e1768:         con.close();
1:64e1768:         assertTrue("Connection should be closed after close()", 
1:64e1768:                 con.isClosed());
1:64e1768:         assertTrue("First statement should be closed, as parent " +
1:64e1768:                 "connection has been closed", stmt.isClosed());
1:64e1768:         assertTrue("Second statement should be closed, as parent " +
1:64e1768:                 "connection has been closed", stmt2.isClosed());
1:64e1768:     }
1:f631317:     
1:64e1768:     /**
1:64e1768:      * Check the state of the statement when the connection is first attempted
1:64e1768:      * closed when in an invalid transaction state, then closed after a
1:64e1768:      * commit. According to the JDBC 4 API documentation: </i>"It is strongly 
1:64e1768:      * recommended that an application explictly commits or rolls back an 
1:64e1768:      * active transaction prior to calling the close method. If the close 
1:64e1768:      * method is called and there is an active transaction, 
1:64e1768:      * the results are implementation-defined."</i>
1:64e1768:      * Derby throws an exception and keeps the connection open.
1:64e1768:      */
1:64e1768:     public void testIsClosedWhenClosingConnectionInInvalidState()
1:64e1768:         throws SQLException {
1:64e1768:         stmt.executeQuery("select count(*) from stmtTable");
1:64e1768:         // Connection should now be in an invalid transaction state.
1:13e9e78:         Connection con = stmt.getConnection();
1:3bfb5f0:         try {
1:64e1768:             con.close();
1:64e1768:             fail("Invalid transaction state exception was not thrown");
1:3bfb5f0:         } catch (SQLException sqle) {
1:554be49:             String expectedState =
1:554be49:                 SQLStateConstants.INVALID_TRANSACTION_STATE_ACTIVE_SQL_TRANSACTION;
1:59dedd1:             assertSQLState(expectedState, sqle);
1:3bfb5f0:         }
1:64e1768:         assertFalse("Statement should still be open, because " +
1:64e1768:                 "Connection.close() failed", stmt.isClosed());
1:64e1768:         assertFalse("Connection should still be open", con.isClosed());
1:64e1768:         // Do a commit here, since we do a rollback in another test.
1:64e1768:         con.commit();
1:64e1768:         con.close();
1:64e1768:         assertTrue("Connection should be closed after close()", 
1:64e1768:                 con.isClosed());
1:64e1768:         assertTrue("Statement should be closed, because " +
1:64e1768:                 "the connection has been closed", stmt.isClosed()); 
1:64e1768:         stmt.close();
1:64e1768:         assertTrue("Statement should still be closed", stmt.isClosed()); 
1:3bfb5f0:     }
1:3bfb5f0:         
1:3bfb5f0:     /**
1:64e1768:      * Execute a query on a statement after the parent connection has been
1:64e1768:      * closed.
1:3bfb5f0:      */
1:64e1768:     public void testStatementExecuteAfterConnectionClose() 
1:64e1768:         throws SQLException {
1:13e9e78:         Connection con = stmt.getConnection();
1:64e1768:         con.close();
1:64e1768:         assertTrue("Connection should be closed after close()", 
1:64e1768:                 con.isClosed());
1:3bfb5f0:         try {
1:64e1768:             stmt.executeQuery("select count(*) from stmtTable");
2:64e1768:         } catch (SQLException sqle) {
1:5d2e2bd:             assertEquals("Unexpected SQL state for performing " +
1:5d2e2bd:                     "operations on a closed statement.",
1:5d2e2bd:                     SQLStateConstants.CONNECTION_EXCEPTION_CONNECTION_DOES_NOT_EXIST,
1:5d2e2bd:                     sqle.getSQLState());
1:3bfb5f0:         }
1:64e1768:         assertTrue("Statement should be closed, because " +
1:64e1768:                 "the connection has been closed", stmt.isClosed()); 
1:3bfb5f0:     }
1:3bfb5f0: 
1:f631317:     public void testIsWrapperForStatement() throws SQLException {
1:f631317:         assertTrue(stmt.isWrapperFor(Statement.class));
1:3bfb5f0:     }
1:f631317: 
1:f631317:     public void testIsNotWrapperForPreparedStatement() throws SQLException {
1:f631317:         assertFalse(stmt.isWrapperFor(PreparedStatement.class));
1:f631317:     }
1:f631317: 
1:f631317:     public void testIsNotWrapperForCallableStatement() throws SQLException {
1:f631317:         assertFalse(stmt.isWrapperFor(CallableStatement.class));
1:f631317:     }
1:f631317: 
1:f631317:     public void testIsNotWrapperForResultSet() throws SQLException {
1:f631317:         assertFalse(stmt.isWrapperFor(ResultSet.class));
1:f631317:     }
1:f631317: 
1:f631317:     public void testUnwrapStatement() throws SQLException {
1:f631317:         Statement stmt2 = stmt.unwrap(Statement.class);
1:f631317:         assertSame("Unwrap returned wrong object.", stmt, stmt2);
1:f631317:     }
1:f631317: 
1:f631317:     public void testUnwrapPreparedStatement() {
1:f631317:         try {
1:f631317:             PreparedStatement ps = stmt.unwrap(PreparedStatement.class);
1:f631317:             fail("Unwrap didn't fail.");
1:f631317:         } catch (SQLException e) {
1:f631317:             assertSQLState("XJ128", e);
1:f631317:         }
1:64e1768:     }
1:f631317: 
1:f631317:     public void testUnwrapCallableStatement() {
1:f631317:         try {
1:f631317:             CallableStatement cs = stmt.unwrap(CallableStatement.class);
1:f631317:             fail("Unwrap didn't fail.");
1:f631317:         } catch (SQLException e) {
1:f631317:             assertSQLState("XJ128", e);
1:f631317:         }
1:f631317:     }
1:f631317: 
1:f631317:     public void testUnwrapResultSet() throws SQLException {
1:f631317:         try {
1:f631317:             ResultSet rs = stmt.unwrap(ResultSet.class);
1:f631317:             fail("Unwrap didn't fail.");
1:f631317:         } catch (SQLException e) {
1:f631317:             assertSQLState("XJ128", e);
1:64e1768:         }
1:64e1768:     }
1:7eed914: 
1:64e1768:     /**
1:7eed914:      * Tests isPoolable, setPoolable, and the default poolability.
1:7eed914:      */
1:7eed914:     public void testPoolable() throws SQLException {
1:7eed914:         assertFalse("Statement cannot be poolable by default", 
1:7eed914:                     stmt.isPoolable()); 
1:7eed914:         stmt.setPoolable(true);
1:7eed914:         assertTrue("Statement must be poolable", stmt.isPoolable());
1:7eed914: 
1:7eed914:         stmt.setPoolable(false);
1:7eed914:         assertFalse("Statement cannot be poolable", stmt.isPoolable());
1:7eed914:     }
1:7eed914: 
1:64e1768:     /**
1:4eb3fed:      * Test that Statement.setQueryTimeout() causes statements to
1:4eb3fed:      * raise SQLTimeoutException per the JDBC 4.1 spec clarification.
1:4eb3fed:      */
1:4eb3fed:     public  void    test_jdbc4_1_queryTimeoutException() throws Exception
1:b451cab:     {
1:226afe3:         SQLException    se = null;
1:4eb3fed: 
1:48aecee:         PreparedStatement ps = prepareStatement
1:48aecee:             (
1:48aecee:              "select columnnumber from sys.syscolumns c, sys.systables t\n" +
1:48aecee:              "where t.tablename = 'SYSTABLES'\n" +
1:48aecee:              "and t.tableid = c.referenceid\n" +
1:48aecee:              "and mod( delay_st( 5, c.columnnumber ), 3 ) = 0"
1:48aecee:              );
1:48aecee:         println( "Testing timeout exception for a " + ps.getClass().getName() );
1:226afe3:         
1:48aecee:         SetQueryTimeoutTest.StatementExecutor   executor =
1:48aecee:             new SetQueryTimeoutTest.StatementExecutor( ps, true, 1 );
1:48aecee:         
1:48aecee:         executor.start();
1:48aecee:         executor.join();
1:48aecee:         
1:48aecee:         ps.close();
1:48aecee:         
1:48aecee:         se = executor.getSQLException();
1:48aecee: 
1:48aecee:         assertNotNull( se );
1:48aecee:         assertEquals( SQLTimeoutException.class.getName(), se.getClass().getName() );
1:226afe3:     }
1:226afe3: 
1:4eb3fed:     /**
1:5cb4c04:      * Test the closeOnCompletion() and isCloseOnCompletion() methods
1:5cb4c04:      * when using ResultSets which close implicitly.
1:5cb4c04:      */
1:5cb4c04:     public void testCompletionClosure_jdbc4_1_implicitRSClosure() throws Exception
1:b451cab:     {
1:5cb4c04:         Connection  conn = getConnection();
1:5cb4c04:         conn.setHoldability( ResultSet.CLOSE_CURSORS_AT_COMMIT );
1:5cb4c04:         conn.setAutoCommit( true );
1:5cb4c04: 
1:5cb4c04:         PreparedStatement   ps;
1:5cb4c04:         ResultSet   rs;
1:5cb4c04:         Wrapper41Statement  wrapper;
1:5cb4c04: 
1:5cb4c04:         ps = conn.prepareStatement( "values ( 1 )" );
1:5cb4c04:         println( "Testing implicit closure WITH autocommit on a " + ps.getClass().getName() );
1:5cb4c04:         
1:5cb4c04:         wrapper = new Wrapper41Statement( ps );
1:5cb4c04:         wrapper.closeOnCompletion();
1:5cb4c04: 
1:5cb4c04:         rs = ps.executeQuery();
1:5cb4c04:         rs.next();
1:5cb4c04:         rs.next();
1:5cb4c04: 
1:5cb4c04:         assertTrue( rs.isClosed() );
1:5cb4c04:         assertTrue( ps.isClosed() );
1:5cb4c04: 
1:5cb4c04:         conn.setAutoCommit( false );
1:5cb4c04: 
1:5cb4c04:         // now retry the experiment with an explicit commit
1:5cb4c04: 
1:5cb4c04:         ps = conn.prepareStatement( "values ( 1 )" );
1:5cb4c04:         println( "Testing implicit closure WITHOUT autocommit on a " + ps.getClass().getName() );
1:5cb4c04:         
1:5cb4c04:         wrapper = new Wrapper41Statement( ps );
1:5cb4c04:         wrapper.closeOnCompletion();
1:5cb4c04: 
1:5cb4c04:         rs = ps.executeQuery();
1:5cb4c04:         rs.next();
1:5cb4c04:         rs.next();
1:5cb4c04: 
1:5cb4c04:         assertFalse( rs.isClosed() );
1:5cb4c04:         assertFalse( ps.isClosed() );
1:5cb4c04: 
1:5cb4c04:         conn.commit();
1:5cb4c04:         
1:5cb4c04:         assertTrue( rs.isClosed() );
1:5cb4c04:         assertTrue( ps.isClosed() );
1:5cb4c04:     }
1:5cb4c04: 
1:5cb4c04:     /**
1:f26c60c:      * Test the large update methods added by JDBC 4.2.
1:f26c60c:      */
1:f26c60c:     public void testLargeUpdate_jdbc4_2() throws Exception
1:f26c60c:     {
1:f26c60c:         Connection  conn = getConnection();
1:f26c60c: 
1:f26c60c:         largeUpdate_jdbc4_2( conn );
1:f26c60c:     }
1:f26c60c: 
1:f26c60c:     public  static  void    largeUpdate_jdbc4_2( Connection conn )
1:f26c60c:         throws Exception
1:f26c60c:     {
1:2e87a4c:         //
1:2e87a4c:         // This test makes use of a debug entry point which is a NOP
1:2e87a4c:         // in an insane production build.
1:2e87a4c:         //
1:2e87a4c:         if (!SanityManager.DEBUG)    { return; }
1:2e87a4c:         else { println( "Running largeUpdate_jdbc4_2() on debug code." ); }
1:2e87a4c: 
1:f26c60c:         conn.prepareStatement
1:f26c60c:             (
1:f26c60c:              "create procedure setRowCountBase( newBase bigint )\n" +
1:f26c60c:              "language java parameter style java no sql\n" +
1:f26c60c:              "external name 'org.apache.derbyTesting.functionTests.tests.jdbc4.StatementTest.setRowCountBase'\n"
1:f26c60c:              ).execute();
1:f26c60c:         conn.prepareStatement
1:f26c60c:             (
1:f26c60c:              "create table bigintTable( col1 int generated always as identity, col2 bigint )"
1:f26c60c:              ).execute();
1:f26c60c: 
1:f26c60c:         StatementWrapper  sw = new StatementWrapper( conn.createStatement() );
1:f26c60c: 
1:f26c60c:         largeUpdateTest( sw, (long) Integer.MAX_VALUE );
1:f26c60c:         largeUpdateTest( sw, 0L);
1:0b0a105: 
1:0b0a105:         largeBatchTest( sw, (long) Integer.MAX_VALUE );
1:0b0a105:         largeBatchTest( sw, 0L);
1:47a8183: 
1:47a8183:         largeMaxRowsTest( sw,  ((long) Integer.MAX_VALUE) + 1L );
1:b54918e: 
1:b54918e:         largeBatchUpdateExceptionTest( sw, ((long) Integer.MAX_VALUE) + 1L );
1:f26c60c:     }
1:f26c60c:     private static  void    largeUpdateTest( StatementWrapper sw, long rowCountBase )
1:f26c60c:         throws Exception
1:f26c60c:     {
1:2e87a4c:         //
1:2e87a4c:         // This test makes use of a debug entry point which is a NOP
1:2e87a4c:         // in an insane production build.
1:2e87a4c:         //
1:2e87a4c:         if (!SanityManager.DEBUG)    { return; }
1:2e87a4c:         else { println( "Running largeUpdateTest() on debug code." ); }
1:2e87a4c: 
1:f26c60c:         // poke the rowCountBase into the engine. all returned row counts will be
1:f26c60c:         // increased by this amount
1:20b2fd9:         setRowCountBase( sw.getWrappedStatement(), false, rowCountBase );
1:f26c60c: 
1:f26c60c:         largeUpdateTest( sw, rowCountBase, 1L );
1:f26c60c:         largeUpdateTest( sw, rowCountBase, 3L );
1:f26c60c:     }
1:f26c60c:     private static  void    largeUpdateTest( StatementWrapper sw, long rowCountBase, long rowCount )
1:f26c60c:         throws Exception
1:f26c60c:     {
1:f26c60c:         StringBuffer    buffer = new StringBuffer();
1:f26c60c:         buffer.append( "insert into bigintTable( col2 ) values " );
1:f26c60c:         for ( long i = 0L; i < rowCount; i++ )
1:f26c60c:         {
1:f26c60c:             if ( i > 0L ) { buffer.append( ", " ); }
1:f26c60c:             buffer.append( "( " + i + " )" );
1:f26c60c:         }
1:f26c60c:         String  text = buffer.toString();
1:f26c60c: 
1:f26c60c:         long    expectedResult = rowCountBase + rowCount;
1:f26c60c: 
1:f26c60c:         vetUpdateSize( sw, (int) expectedResult,
1:f26c60c:                        sw.getWrappedStatement().executeUpdate( text ), expectedResult );
1:f26c60c:         vetUpdateSize( sw, (int) expectedResult,
1:f26c60c:                        sw.getWrappedStatement().executeUpdate( text, Statement.RETURN_GENERATED_KEYS ), expectedResult );
1:f26c60c:         vetUpdateSize( sw, (int) expectedResult,
1:f26c60c:                        sw.getWrappedStatement().executeUpdate( text, new int[] { 1 } ), expectedResult );
1:f26c60c:         vetUpdateSize( sw, (int) expectedResult,
1:f26c60c:                        sw.getWrappedStatement().executeUpdate( text, new String[] { "COL1" } ), expectedResult );
1:f26c60c: 
1:f26c60c:         vetUpdateSize( sw, expectedResult, sw.executeLargeUpdate( text ), expectedResult );
1:f26c60c:         vetUpdateSize( sw, expectedResult, sw.executeLargeUpdate( text, Statement.RETURN_GENERATED_KEYS ), expectedResult );
1:f26c60c:         vetUpdateSize( sw, expectedResult, sw.executeLargeUpdate( text, new int[] { 1 } ), expectedResult );
1:f26c60c:         vetUpdateSize( sw, expectedResult, sw.executeLargeUpdate( text, new String[] { "COL1" } ), expectedResult );
1:f26c60c:     }
1:f26c60c:     private static  void    vetUpdateSize( StatementWrapper sw, int expected, int actual, long longAnswer )
1:f26c60c:         throws Exception
1:f26c60c:     {
1:f26c60c:         assertEquals( expected, actual );
1:f26c60c:         assertEquals( expected, sw.getWrappedStatement().getUpdateCount() );
1:f26c60c:         assertEquals( longAnswer, sw.getLargeUpdateCount() );
1:f26c60c:     }
1:f26c60c:     private static  void    vetUpdateSize( StatementWrapper sw, long expected, long actual, long longAnswer )
1:f26c60c:         throws Exception
1:f26c60c:     {
1:f26c60c:         assertEquals( expected, actual );
1:f26c60c:         assertEquals( (int) expected, sw.getWrappedStatement().getUpdateCount() );
1:f26c60c:         assertEquals( longAnswer, sw.getLargeUpdateCount() );
1:f26c60c:     }
1:0b0a105:     private static  void    largeBatchTest( StatementWrapper sw, long rowCountBase )
1:0b0a105:         throws Exception
1:0b0a105:     {
1:2e87a4c:         //
1:2e87a4c:         // This test makes use of a debug entry point which is a NOP
1:2e87a4c:         // in an insane production build.
1:2e87a4c:         //
1:2e87a4c:         if (!SanityManager.DEBUG)    { return; }
1:2e87a4c: 
1:0b0a105:         println( "Large batch test with rowCountBase = " + rowCountBase );
1:0b0a105:         
1:0b0a105:         // poke the rowCountBase into the engine. all returned row counts will be
1:0b0a105:         // increased by this amount
1:0b0a105:         sw.getWrappedStatement().clearBatch();
1:20b2fd9:         setRowCountBase( sw.getWrappedStatement(), false, rowCountBase );
1:0b0a105: 
1:0b0a105:         long[]  expectedResult = new long[] { rowCountBase + 1L, rowCountBase + 1L, rowCountBase + 2L };
1:0b0a105: 
1:0b0a105:         createBatch( sw );
1:0b0a105:         assertEquals( sw.getWrappedStatement().executeBatch(), squashLongs( expectedResult ) );
1:0b0a105: 
1:0b0a105:         createBatch( sw );
1:0b0a105:         assertEquals( sw.executeLargeBatch(), expectedResult );
1:0b0a105:     }
1:0b0a105:     private static  void    createBatch( StatementTest.StatementWrapper sw )
1:0b0a105:         throws Exception
1:0b0a105:     {
1:0b0a105:         sw.getWrappedStatement().clearBatch();
1:0b0a105:         truncate( sw );
1:0b0a105:         sw.getWrappedStatement().addBatch( "insert into bigintTable( col2 ) values ( 1 )" );
1:0b0a105:         sw.getWrappedStatement().addBatch( "update bigintTable set col2 = 2" );
1:0b0a105:         sw.getWrappedStatement().addBatch( "insert into bigintTable( col2 ) values ( 3 ), ( 4 )" );
1:0b0a105:     }
1:47a8183:     private static  void    largeMaxRowsTest( StatementWrapper sw, long maxRows )
1:47a8183:         throws Exception
1:47a8183:     {
1:2e87a4c:         //
1:2e87a4c:         // This test makes use of a debug entry point which is a NOP
1:2e87a4c:         // in an insane production build.
1:2e87a4c:         //
1:2e87a4c:         if (!SanityManager.DEBUG)    { return; }
1:2e87a4c: 
1:47a8183:         println( "Large max rows test with maxRows = " + maxRows );
1:47a8183: 
1:47a8183:         long    expectedRowCount = 3L;
1:47a8183: 
1:47a8183:         truncate( sw );
1:47a8183:         sw.getWrappedStatement().execute( "insert into bigintTable( col2 ) values ( 1 ), ( 2 ), ( 3 ), ( 4 ), ( 5 )" );
1:47a8183:         
1:20b2fd9:         setRowCountBase( sw.getWrappedStatement(), usingDerbyNetClient(), maxRows - expectedRowCount );
1:47a8183: 
1:47a8183:         sw.setLargeMaxRows( maxRows );
1:47a8183:         
1:47a8183:         ResultSet   rs = sw.getWrappedStatement().executeQuery( "select * from bigintTable" );
1:47a8183:         int     rowCount = 0;
1:47a8183:         while( rs.next() ) { rowCount++; }
1:47a8183:         rs.close();
1:47a8183: 
1:20b2fd9:         setRowCountBase( sw.getWrappedStatement(), usingDerbyNetClient(), 0L );
1:47a8183:         
1:47a8183:         assertEquals( expectedRowCount, rowCount );
1:47a8183:         assertEquals( maxRows, sw.getLargeMaxRows() );
1:47a8183:     }
1:b54918e:     private static  void    largeBatchUpdateExceptionTest( StatementWrapper sw, long rowCountBase )
1:b54918e:         throws Exception
1:b54918e:     {
1:2e87a4c:         //
1:2e87a4c:         // This test makes use of a debug entry point which is a NOP
1:2e87a4c:         // in an insane production build.
1:2e87a4c:         //
1:2e87a4c:         if (!SanityManager.DEBUG)    { return; }
1:2e87a4c: 
1:b54918e:         println( "Large batch update exception test with rowCountBase = " + rowCountBase );
1:b54918e:         
1:b54918e:         sw.getWrappedStatement().clearBatch();
1:b54918e:         sw.getWrappedStatement().execute( "create table intTable( col1 int generated always as identity, col2 int )" );
1:b54918e: 
1:b54918e:         // poke the rowCountBase into the engine. all returned row counts will be
1:b54918e:         // increased by this amount
1:b54918e:         setRowCountBase( sw.getWrappedStatement(), false, rowCountBase );
1:b54918e: 
1:b54918e:         //
1:b54918e:         // Create a batch of statements. The last one will die on an overflow condition.
1:b54918e:         //
1:b54918e:         sw.getWrappedStatement().addBatch( "insert into intTable( col2 ) values ( 1 )" );
1:b54918e:         sw.getWrappedStatement().addBatch( "insert into intTable( col2 ) values ( 1 )" );
1:b54918e:         sw.getWrappedStatement().addBatch( "update intTable set col2 = 2147483647 + 1" );
1:b54918e: 
1:b54918e:         if ( usingEmbedded() )
1:b54918e:         {
1:b54918e:             BatchUpdateTest.assertBatchExecuteError
1:b54918e:                 (
1:b54918e:                  "22003", sw.getWrappedStatement(),
1:b54918e:                  new long[] { rowCountBase + 1L, rowCountBase + 1L }
1:b54918e:                  );
1:b54918e:         }
1:b54918e:         else if ( usingDerbyNetClient() )
1:b54918e:         {
1:b54918e:             BatchUpdateTest.assertBatchExecuteError
1:b54918e:                 (
1:b54918e:                  "XJ208", sw.getWrappedStatement(),
1:b54918e:                  new long[] { rowCountBase + 1L, rowCountBase + 1L, -3 }
1:b54918e:                  );
1:b54918e:         }
1:b54918e:         
1:b54918e:         sw.getWrappedStatement().clearBatch();
1:b54918e:         setRowCountBase( sw.getWrappedStatement(), false, 0L );
1:b54918e:     }
1:47a8183:         
1:20b2fd9:     public static  void    setRowCountBase
1:20b2fd9:         ( Statement stmt, boolean onClient, long rowCountBase )
1:47a8183:         throws Exception
1:47a8183:     {
1:47a8183:         if ( onClient )
1:47a8183:         {
1:2e87a4c:             ClientStatement.setFetchedRowBase( rowCountBase );
1:47a8183:         }
1:47a8183:         else
1:47a8183:         {
1:20b2fd9:             stmt.execute( "call setRowCountBase( " + rowCountBase + " )" );
1:47a8183:         }
1:47a8183:     }
1:0b0a105:     private static  void    truncate( StatementTest.StatementWrapper sw )
1:0b0a105:         throws Exception
1:0b0a105:     {
1:0b0a105:         sw.getWrappedStatement().execute( "truncate table bigintTable" );
1:0b0a105:     }
1:0b0a105:     private static  int[]   squashLongs( long[] longs )
1:0b0a105:     {
1:0b0a105:         int count = (longs == null) ? 0 : longs.length;
1:0b0a105:         int[]   ints = new int[ count ];
1:0b0a105:         for ( int i = 0; i < count; i++ ) { ints[ i ] = (int) longs[ i ]; }
1:0b0a105: 
1:0b0a105:         return ints;
1:0b0a105:     }
1:f26c60c:     
1:f26c60c:     /**
1:64e1768:      * Create test suite for StatementTest.
1:64e1768:      */
1:64e1768:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("StatementTest suite");
1:64e1768:         // Decorate test suite with a TestSetup class.
1:64e1768:         suite.addTest(new StatementTestSetup(
1:1ae02c9:                         new BaseTestSuite(StatementTest.class)));
1:ec5ae26:         suite.addTest(TestConfiguration.clientServerDecorator(
1:1ae02c9:             new StatementTestSetup(new BaseTestSuite(StatementTest.class))));
1:64e1768:         return suite;
1:b451cab:     }
1:f26c60c: 
1:f26c60c:     ////////////////////////////////////////////////////////////////////////
1:f26c60c:     //
1:f26c60c:     // NESTED JDBC 4.2 WRAPPER AROUND A Statement
1:f26c60c:     //
1:f26c60c:     ////////////////////////////////////////////////////////////////////////
1:f26c60c: 
1:f26c60c:     /**
1:f26c60c:      * <p>
1:f26c60c:      * This wrapper is used to expose JDBC 4.2 methods which can run on
1:f26c60c:      * VM rev levels lower than Java 8.
1:f26c60c:      * </p>
1:f26c60c:      */
1:20b2fd9:     public  static  class   StatementWrapper
1:f26c60c:     {
1:f26c60c:         private Statement   _wrappedStatement;
1:f26c60c: 
1:f26c60c:         public  StatementWrapper( Statement wrappedStatement )
1:f26c60c:         {
1:f26c60c:             _wrappedStatement = wrappedStatement;
1:f26c60c:         }
1:f26c60c: 
1:f26c60c:         public  Statement   getWrappedStatement() { return _wrappedStatement; }
1:f26c60c: 
1:f26c60c:         // New methods added by JDBC 4.2
1:0b0a105:         public  long[] executeLargeBatch() throws SQLException
1:0b0a105:         {
1:0b0a105:             return ((long[]) invoke
1:0b0a105:                 (
1:0b0a105:                  "executeLargeBatch",
1:0b0a105:                  new Class[] {},
1:0b0a105:                  new Object[] {}
1:0b0a105:                  ));
1:0b0a105:         }
1:f26c60c:         public  long executeLargeUpdate( String sql ) throws SQLException
1:f26c60c:         {
1:f26c60c:             return ((Long) invoke
1:f26c60c:                 (
1:f26c60c:                  "executeLargeUpdate",
1:f26c60c:                  new Class[] { String.class },
1:f26c60c:                  new Object[] { sql }
1:f26c60c:                  )).longValue();
1:f26c60c:         }
1:f26c60c:         public  long executeLargeUpdate( String sql, int autoGeneratedKeys) throws SQLException
1:f26c60c:         {
1:f26c60c:             return ((Long) invoke
1:f26c60c:                 (
1:f26c60c:                  "executeLargeUpdate",
1:f26c60c:                  new Class[] { String.class, Integer.TYPE },
1:39b3237:                  new Object[] { sql, autoGeneratedKeys }
1:f26c60c:                  )).longValue();
1:f26c60c:         }
1:f26c60c:         public  long executeLargeUpdate( String sql, int[] columnIndexes ) throws SQLException
1:f26c60c:         {
1:f26c60c:             return ((Long) invoke
1:f26c60c:                 (
1:f26c60c:                  "executeLargeUpdate",
1:f26c60c:                  new Class[] { String.class, columnIndexes.getClass() },
1:f26c60c:                  new Object[] { sql, columnIndexes }
1:f26c60c:                  )).longValue();
1:f26c60c:         }
1:f26c60c:         public  long executeLargeUpdate( String sql, String[] columnNames ) throws SQLException
1:f26c60c:         {
1:f26c60c:             return ((Long) invoke
1:f26c60c:                 (
1:f26c60c:                  "executeLargeUpdate",
1:f26c60c:                  new Class[] { String.class, columnNames.getClass() },
1:f26c60c:                  new Object[] { sql, columnNames }
1:f26c60c:                  )).longValue();
1:f26c60c:         }
1:47a8183:         public  long getLargeMaxRows() throws SQLException
1:47a8183:         {
1:47a8183:             return ((Long) invoke
1:47a8183:                 (
1:47a8183:                  "getLargeMaxRows",
1:47a8183:                  new Class[] {},
1:47a8183:                  new Object[] {}
1:47a8183:                  )).longValue();
1:47a8183:         }
1:f26c60c:         public  long getLargeUpdateCount() throws SQLException
1:f26c60c:         {
1:f26c60c:             return ((Long) invoke
1:f26c60c:                 (
1:f26c60c:                  "getLargeUpdateCount",
1:f26c60c:                  new Class[] {},
1:f26c60c:                  new Object[] {}
1:f26c60c:                  )).longValue();
1:f26c60c:         }
1:47a8183:         public  void setLargeMaxRows( long max ) throws SQLException
1:47a8183:         {
1:47a8183:             invoke
1:47a8183:                 (
1:47a8183:                  "setLargeMaxRows",
1:47a8183:                  new Class[] { Long.TYPE },
1:39b3237:                  new Object[] { max }
1:47a8183:                  );
1:47a8183:         }
1:f26c60c: 
1:f26c60c: 
1:f26c60c:         // Reflection minion
1:20b2fd9:         protected Object  invoke( String methodName, Class[] argTypes, Object[] argValues )
1:f26c60c:             throws SQLException
1:f26c60c:         {
1:f26c60c:             try {
1:f26c60c:                 Method  method = _wrappedStatement.getClass().getMethod( methodName, argTypes );
1:f26c60c: 
1:f26c60c:                 return method.invoke( _wrappedStatement, argValues );
1:f26c60c:             }
1:f26c60c:             catch (NoSuchMethodException nsme) { throw wrap( nsme ); }
1:f26c60c:             catch (SecurityException se) { throw wrap( se ); }
1:f26c60c:             catch (IllegalAccessException iae) { throw wrap( iae ); }
1:f26c60c:             catch (IllegalArgumentException iare) { throw wrap( iare ); }
1:f26c60c:             catch (InvocationTargetException ite) { throw wrap( ite ); }
1:f26c60c:         }
1:f26c60c:         private SQLException    wrap( Throwable t ) { return new SQLException( t.getMessage(), t ); }
1:f26c60c:     }
1:226afe3:     
1:f26c60c:     ////////////////////////////////////////////////////////////////////////
1:f26c60c:     //
1:f26c60c:     // PROCEDURE FOR BUMPING THE RETURNED ROW COUNT, FOR TESTING JDBC 4.2.
1:f26c60c:     //
1:f26c60c:     ////////////////////////////////////////////////////////////////////////
1:f26c60c: 
1:47a8183:     /** Set the base which is used for returned row counts and fetched row counters */
1:f26c60c:     public  static  void    setRowCountBase( long newBase )
1:f26c60c:     {
1:2e87a4c:         EmbedResultSet.setFetchedRowBase( newBase );
1:2e87a4c:         RowUtil.setRowCountBase( newBase );
1:f26c60c:     }
1:f26c60c: 
1:64e1768: } // End class StatementTest
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:                  new Object[] { sql, autoGeneratedKeys }
/////////////////////////////////////////////////////////////////////////
1:                  new Object[] { max }
commit:2e87a4c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // This test makes use of a debug entry point which is a NOP
1:         // in an insane production build.
1:         //
1:         if (!SanityManager.DEBUG)    { return; }
1:         else { println( "Running largeUpdate_jdbc4_2() on debug code." ); }
1: 
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // This test makes use of a debug entry point which is a NOP
1:         // in an insane production build.
1:         //
1:         if (!SanityManager.DEBUG)    { return; }
1:         else { println( "Running largeUpdateTest() on debug code." ); }
1: 
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // This test makes use of a debug entry point which is a NOP
1:         // in an insane production build.
1:         //
1:         if (!SanityManager.DEBUG)    { return; }
1: 
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // This test makes use of a debug entry point which is a NOP
1:         // in an insane production build.
1:         //
1:         if (!SanityManager.DEBUG)    { return; }
1: 
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // This test makes use of a debug entry point which is a NOP
1:         // in an insane production build.
1:         //
1:         if (!SanityManager.DEBUG)    { return; }
1: 
/////////////////////////////////////////////////////////////////////////
1:             ClientStatement.setFetchedRowBase( rowCountBase );
/////////////////////////////////////////////////////////////////////////
1:         EmbedResultSet.setFetchedRowBase( newBase );
1:         RowUtil.setRowCountBase( newBase );
commit:b54918e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.tests.jdbcapi.BatchUpdateTest;
1: import org.apache.derbyTesting.functionTests.tests.jdbcapi.Wrapper41Statement;
/////////////////////////////////////////////////////////////////////////
1: 
1:         largeBatchUpdateExceptionTest( sw, ((long) Integer.MAX_VALUE) + 1L );
/////////////////////////////////////////////////////////////////////////
1:     private static  void    largeBatchUpdateExceptionTest( StatementWrapper sw, long rowCountBase )
1:         throws Exception
1:     {
1:         println( "Large batch update exception test with rowCountBase = " + rowCountBase );
1:         
1:         sw.getWrappedStatement().clearBatch();
1:         sw.getWrappedStatement().execute( "create table intTable( col1 int generated always as identity, col2 int )" );
1: 
1:         // poke the rowCountBase into the engine. all returned row counts will be
1:         // increased by this amount
1:         setRowCountBase( sw.getWrappedStatement(), false, rowCountBase );
1: 
1:         //
1:         // Create a batch of statements. The last one will die on an overflow condition.
1:         //
1:         sw.getWrappedStatement().addBatch( "insert into intTable( col2 ) values ( 1 )" );
1:         sw.getWrappedStatement().addBatch( "insert into intTable( col2 ) values ( 1 )" );
1:         sw.getWrappedStatement().addBatch( "update intTable set col2 = 2147483647 + 1" );
1: 
1:         if ( usingEmbedded() )
1:         {
1:             BatchUpdateTest.assertBatchExecuteError
1:                 (
1:                  "22003", sw.getWrappedStatement(),
1:                  new long[] { rowCountBase + 1L, rowCountBase + 1L }
1:                  );
1:         }
1:         else if ( usingDerbyNetClient() )
1:         {
1:             BatchUpdateTest.assertBatchExecuteError
1:                 (
1:                  "XJ208", sw.getWrappedStatement(),
1:                  new long[] { rowCountBase + 1L, rowCountBase + 1L, -3 }
1:                  );
1:         }
1:         
1:         sw.getWrappedStatement().clearBatch();
1:         setRowCountBase( sw.getWrappedStatement(), false, 0L );
1:     }
commit:20b2fd9
/////////////////////////////////////////////////////////////////////////
1:         setRowCountBase( sw.getWrappedStatement(), false, rowCountBase );
/////////////////////////////////////////////////////////////////////////
1:         setRowCountBase( sw.getWrappedStatement(), false, rowCountBase );
/////////////////////////////////////////////////////////////////////////
1:         setRowCountBase( sw.getWrappedStatement(), usingDerbyNetClient(), maxRows - expectedRowCount );
/////////////////////////////////////////////////////////////////////////
1:         setRowCountBase( sw.getWrappedStatement(), usingDerbyNetClient(), 0L );
1:     public static  void    setRowCountBase
1:         ( Statement stmt, boolean onClient, long rowCountBase )
/////////////////////////////////////////////////////////////////////////
1:             stmt.execute( "call setRowCountBase( " + rowCountBase + " )" );
/////////////////////////////////////////////////////////////////////////
1:     public  static  class   StatementWrapper
/////////////////////////////////////////////////////////////////////////
1:         protected Object  invoke( String methodName, Class[] argTypes, Object[] argValues )
commit:47a8183
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.jdbc.EmbedResultSet;
/////////////////////////////////////////////////////////////////////////
1: 
1:         largeMaxRowsTest( sw,  ((long) Integer.MAX_VALUE) + 1L );
0:         setRowCountBase( sw, false, rowCountBase );
/////////////////////////////////////////////////////////////////////////
0:         setRowCountBase( sw, false, rowCountBase );
/////////////////////////////////////////////////////////////////////////
1:     private static  void    largeMaxRowsTest( StatementWrapper sw, long maxRows )
1:         throws Exception
1:     {
1:         println( "Large max rows test with maxRows = " + maxRows );
1: 
1:         long    expectedRowCount = 3L;
1: 
1:         truncate( sw );
1:         sw.getWrappedStatement().execute( "insert into bigintTable( col2 ) values ( 1 ), ( 2 ), ( 3 ), ( 4 ), ( 5 )" );
1:         
0:         setRowCountBase( sw, usingDerbyNetClient(), maxRows - expectedRowCount );
1: 
1:         sw.setLargeMaxRows( maxRows );
1:         
1:         ResultSet   rs = sw.getWrappedStatement().executeQuery( "select * from bigintTable" );
1:         int     rowCount = 0;
1:         while( rs.next() ) { rowCount++; }
1:         rs.close();
1: 
0:         setRowCountBase( sw, usingDerbyNetClient(), 0L );
1:         
1:         assertEquals( expectedRowCount, rowCount );
1:         assertEquals( maxRows, sw.getLargeMaxRows() );
1:     }
1:         
0:     private static  void    setRowCountBase
0:         ( StatementTest.StatementWrapper sw, boolean onClient, long rowCountBase )
1:         throws Exception
1:     {
1:         if ( onClient )
1:         {
0:             org.apache.derby.client.am.Statement.fetchedRowBase = rowCountBase;
1:         }
1:         else
1:         {
0:             sw.getWrappedStatement().execute( "call setRowCountBase( " + rowCountBase + " )" );
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:         public  long getLargeMaxRows() throws SQLException
1:         {
1:             return ((Long) invoke
1:                 (
1:                  "getLargeMaxRows",
1:                  new Class[] {},
1:                  new Object[] {}
1:                  )).longValue();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         public  void setLargeMaxRows( long max ) throws SQLException
1:         {
1:             invoke
1:                 (
1:                  "setLargeMaxRows",
1:                  new Class[] { Long.TYPE },
0:                  new Object[] { new Long( max ) }
1:                  );
1:         }
/////////////////////////////////////////////////////////////////////////
1:     /** Set the base which is used for returned row counts and fetched row counters */
0:         EmbedResultSet.fetchedRowBase = newBase;
commit:0b0a105
/////////////////////////////////////////////////////////////////////////
1: 
1:         largeBatchTest( sw, (long) Integer.MAX_VALUE );
1:         largeBatchTest( sw, 0L);
/////////////////////////////////////////////////////////////////////////
1:     private static  void    largeBatchTest( StatementWrapper sw, long rowCountBase )
1:         throws Exception
1:     {
1:         println( "Large batch test with rowCountBase = " + rowCountBase );
1:         
1:         // poke the rowCountBase into the engine. all returned row counts will be
1:         // increased by this amount
1:         sw.getWrappedStatement().clearBatch();
0:         sw.getWrappedStatement().execute( "call setRowCountBase( " + rowCountBase + " )" );
1: 
1:         long[]  expectedResult = new long[] { rowCountBase + 1L, rowCountBase + 1L, rowCountBase + 2L };
1: 
1:         createBatch( sw );
1:         assertEquals( sw.getWrappedStatement().executeBatch(), squashLongs( expectedResult ) );
1: 
1:         createBatch( sw );
1:         assertEquals( sw.executeLargeBatch(), expectedResult );
1:     }
1:     private static  void    createBatch( StatementTest.StatementWrapper sw )
1:         throws Exception
1:     {
1:         sw.getWrappedStatement().clearBatch();
1:         truncate( sw );
1:         sw.getWrappedStatement().addBatch( "insert into bigintTable( col2 ) values ( 1 )" );
1:         sw.getWrappedStatement().addBatch( "update bigintTable set col2 = 2" );
1:         sw.getWrappedStatement().addBatch( "insert into bigintTable( col2 ) values ( 3 ), ( 4 )" );
1:     }
1:     private static  void    truncate( StatementTest.StatementWrapper sw )
1:         throws Exception
1:     {
1:         sw.getWrappedStatement().execute( "truncate table bigintTable" );
1:     }
1:     private static  int[]   squashLongs( long[] longs )
1:     {
1:         int count = (longs == null) ? 0 : longs.length;
1:         int[]   ints = new int[ count ];
1:         for ( int i = 0; i < count; i++ ) { ints[ i ] = (int) longs[ i ]; }
1: 
1:         return ints;
1:     }
/////////////////////////////////////////////////////////////////////////
1:         public  long[] executeLargeBatch() throws SQLException
1:         {
1:             return ((long[]) invoke
1:                 (
1:                  "executeLargeBatch",
1:                  new Class[] {},
1:                  new Object[] {}
1:                  ));
1:         }
commit:f26c60c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.vti.VTITemplate;
1: import org.apache.derby.impl.sql.execute.RowUtil;
1: 
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.InvocationTargetException;
1: import java.lang.reflect.Method;
/////////////////////////////////////////////////////////////////////////
1:      * Test the large update methods added by JDBC 4.2.
1:      */
1:     public void testLargeUpdate_jdbc4_2() throws Exception
1:     {
1:         Connection  conn = getConnection();
1: 
1:         largeUpdate_jdbc4_2( conn );
1:     }
1: 
1:     public  static  void    largeUpdate_jdbc4_2( Connection conn )
1:         throws Exception
1:     {
1:         conn.prepareStatement
1:             (
1:              "create procedure setRowCountBase( newBase bigint )\n" +
1:              "language java parameter style java no sql\n" +
1:              "external name 'org.apache.derbyTesting.functionTests.tests.jdbc4.StatementTest.setRowCountBase'\n"
1:              ).execute();
1:         conn.prepareStatement
1:             (
1:              "create table bigintTable( col1 int generated always as identity, col2 bigint )"
1:              ).execute();
1: 
1:         StatementWrapper  sw = new StatementWrapper( conn.createStatement() );
1: 
1:         largeUpdateTest( sw, (long) Integer.MAX_VALUE );
1:         largeUpdateTest( sw, 0L);
1:     }
1:     private static  void    largeUpdateTest( StatementWrapper sw, long rowCountBase )
1:         throws Exception
1:     {
1:         // poke the rowCountBase into the engine. all returned row counts will be
1:         // increased by this amount
0:         sw.getWrappedStatement().execute( "call setRowCountBase( " + rowCountBase + " )" );
1: 
1:         largeUpdateTest( sw, rowCountBase, 1L );
1:         largeUpdateTest( sw, rowCountBase, 3L );
1:     }
1:     private static  void    largeUpdateTest( StatementWrapper sw, long rowCountBase, long rowCount )
1:         throws Exception
1:     {
1:         StringBuffer    buffer = new StringBuffer();
1:         buffer.append( "insert into bigintTable( col2 ) values " );
1:         for ( long i = 0L; i < rowCount; i++ )
1:         {
1:             if ( i > 0L ) { buffer.append( ", " ); }
1:             buffer.append( "( " + i + " )" );
1:         }
1:         String  text = buffer.toString();
1: 
1:         long    expectedResult = rowCountBase + rowCount;
1: 
1:         vetUpdateSize( sw, (int) expectedResult,
1:                        sw.getWrappedStatement().executeUpdate( text ), expectedResult );
1:         vetUpdateSize( sw, (int) expectedResult,
1:                        sw.getWrappedStatement().executeUpdate( text, Statement.RETURN_GENERATED_KEYS ), expectedResult );
1:         vetUpdateSize( sw, (int) expectedResult,
1:                        sw.getWrappedStatement().executeUpdate( text, new int[] { 1 } ), expectedResult );
1:         vetUpdateSize( sw, (int) expectedResult,
1:                        sw.getWrappedStatement().executeUpdate( text, new String[] { "COL1" } ), expectedResult );
1: 
1:         vetUpdateSize( sw, expectedResult, sw.executeLargeUpdate( text ), expectedResult );
1:         vetUpdateSize( sw, expectedResult, sw.executeLargeUpdate( text, Statement.RETURN_GENERATED_KEYS ), expectedResult );
1:         vetUpdateSize( sw, expectedResult, sw.executeLargeUpdate( text, new int[] { 1 } ), expectedResult );
1:         vetUpdateSize( sw, expectedResult, sw.executeLargeUpdate( text, new String[] { "COL1" } ), expectedResult );
1:     }
1:     private static  void    vetUpdateSize( StatementWrapper sw, int expected, int actual, long longAnswer )
1:         throws Exception
1:     {
1:         assertEquals( expected, actual );
1:         assertEquals( expected, sw.getWrappedStatement().getUpdateCount() );
1:         assertEquals( longAnswer, sw.getLargeUpdateCount() );
1:     }
1:     private static  void    vetUpdateSize( StatementWrapper sw, long expected, long actual, long longAnswer )
1:         throws Exception
1:     {
1:         assertEquals( expected, actual );
1:         assertEquals( (int) expected, sw.getWrappedStatement().getUpdateCount() );
1:         assertEquals( longAnswer, sw.getLargeUpdateCount() );
1:     }
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     // NESTED JDBC 4.2 WRAPPER AROUND A Statement
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * This wrapper is used to expose JDBC 4.2 methods which can run on
1:      * VM rev levels lower than Java 8.
1:      * </p>
1:      */
0:     public  static  final   class   StatementWrapper
1:     {
1:         private Statement   _wrappedStatement;
1: 
1:         public  StatementWrapper( Statement wrappedStatement )
1:         {
1:             _wrappedStatement = wrappedStatement;
1:         }
1: 
1:         public  Statement   getWrappedStatement() { return _wrappedStatement; }
1: 
1:         // New methods added by JDBC 4.2
1:         public  long executeLargeUpdate( String sql ) throws SQLException
1:         {
1:             return ((Long) invoke
1:                 (
1:                  "executeLargeUpdate",
1:                  new Class[] { String.class },
1:                  new Object[] { sql }
1:                  )).longValue();
1:         }
1:         public  long executeLargeUpdate( String sql, int autoGeneratedKeys) throws SQLException
1:         {
1:             return ((Long) invoke
1:                 (
1:                  "executeLargeUpdate",
1:                  new Class[] { String.class, Integer.TYPE },
0:                  new Object[] { sql, new Integer( autoGeneratedKeys ) }
1:                  )).longValue();
1:         }
1:         public  long executeLargeUpdate( String sql, int[] columnIndexes ) throws SQLException
1:         {
1:             return ((Long) invoke
1:                 (
1:                  "executeLargeUpdate",
1:                  new Class[] { String.class, columnIndexes.getClass() },
1:                  new Object[] { sql, columnIndexes }
1:                  )).longValue();
1:         }
1:         public  long executeLargeUpdate( String sql, String[] columnNames ) throws SQLException
1:         {
1:             return ((Long) invoke
1:                 (
1:                  "executeLargeUpdate",
1:                  new Class[] { String.class, columnNames.getClass() },
1:                  new Object[] { sql, columnNames }
1:                  )).longValue();
1:         }
1:         public  long getLargeUpdateCount() throws SQLException
1:         {
1:             return ((Long) invoke
1:                 (
1:                  "getLargeUpdateCount",
1:                  new Class[] {},
1:                  new Object[] {}
1:                  )).longValue();
1:         }
1: 
1: 
1:         // Reflection minion
0:         private Object  invoke( String methodName, Class[] argTypes, Object[] argValues )
1:             throws SQLException
1:         {
1:             try {
1:                 Method  method = _wrappedStatement.getClass().getMethod( methodName, argTypes );
1: 
1:                 return method.invoke( _wrappedStatement, argValues );
1:             }
1:             catch (NoSuchMethodException nsme) { throw wrap( nsme ); }
1:             catch (SecurityException se) { throw wrap( se ); }
1:             catch (IllegalAccessException iae) { throw wrap( iae ); }
1:             catch (IllegalArgumentException iare) { throw wrap( iare ); }
1:             catch (InvocationTargetException ite) { throw wrap( ite ); }
1:         }
1:         private SQLException    wrap( Throwable t ) { return new SQLException( t.getMessage(), t ); }
1:     }
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     // PROCEDURE FOR BUMPING THE RETURNED ROW COUNT, FOR TESTING JDBC 4.2.
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
0:     /** Set the base which is used for returned row counts */
1:     public  static  void    setRowCountBase( long newBase )
1:     {
0:         RowUtil.rowCountBase = newBase;
1:     }
1: 
commit:48aecee
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = prepareStatement
1:             (
1:              "select columnnumber from sys.syscolumns c, sys.systables t\n" +
1:              "where t.tablename = 'SYSTABLES'\n" +
1:              "and t.tableid = c.referenceid\n" +
1:              "and mod( delay_st( 5, c.columnnumber ), 3 ) = 0"
1:              );
1:         println( "Testing timeout exception for a " + ps.getClass().getName() );
1:         SetQueryTimeoutTest.StatementExecutor   executor =
1:             new SetQueryTimeoutTest.StatementExecutor( ps, true, 1 );
1:         
1:         executor.start();
1:         executor.join();
1:         
1:         ps.close();
1:         
1:         se = executor.getSQLException();
1: 
1:         assertNotNull( se );
1:         assertEquals( SQLTimeoutException.class.getName(), se.getClass().getName() );
commit:b451cab
/////////////////////////////////////////////////////////////////////////
0:         for ( int i = 0; i < 20; i++ )
/////////////////////////////////////////////////////////////////////////
0:         if ( se == null )
1:         {
0:             println( "Dang! Still can't force a timeout on this platform!" );
1:         }
0:         else
1:         {
0:             assertEquals( SQLTimeoutException.class.getName(), se.getClass().getName() );
1:         }
commit:5cb4c04
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.tests.jdbcapi.Wrapper41Statement;
/////////////////////////////////////////////////////////////////////////
1:      * Test the closeOnCompletion() and isCloseOnCompletion() methods
1:      * when using ResultSets which close implicitly.
1:      */
1:     public void testCompletionClosure_jdbc4_1_implicitRSClosure() throws Exception
0:     {
1:         Connection  conn = getConnection();
1:         conn.setHoldability( ResultSet.CLOSE_CURSORS_AT_COMMIT );
1:         conn.setAutoCommit( true );
1: 
1:         PreparedStatement   ps;
1:         ResultSet   rs;
1:         Wrapper41Statement  wrapper;
1: 
1:         ps = conn.prepareStatement( "values ( 1 )" );
1:         println( "Testing implicit closure WITH autocommit on a " + ps.getClass().getName() );
1:         
1:         wrapper = new Wrapper41Statement( ps );
1:         wrapper.closeOnCompletion();
1: 
1:         rs = ps.executeQuery();
1:         rs.next();
1:         rs.next();
1: 
1:         assertTrue( rs.isClosed() );
1:         assertTrue( ps.isClosed() );
1: 
1:         conn.setAutoCommit( false );
1: 
1:         // now retry the experiment with an explicit commit
1: 
1:         ps = conn.prepareStatement( "values ( 1 )" );
1:         println( "Testing implicit closure WITHOUT autocommit on a " + ps.getClass().getName() );
1:         
1:         wrapper = new Wrapper41Statement( ps );
1:         wrapper.closeOnCompletion();
1: 
1:         rs = ps.executeQuery();
1:         rs.next();
1:         rs.next();
1: 
1:         assertFalse( rs.isClosed() );
1:         assertFalse( ps.isClosed() );
1: 
1:         conn.commit();
1:         
1:         assertTrue( rs.isClosed() );
1:         assertTrue( ps.isClosed() );
1:     }
1: 
1:     /**
commit:226afe3
/////////////////////////////////////////////////////////////////////////
1:         SQLException    se = null;
0:         // try to force a timeout. try a couple times to reduce the risk
0:         // of instability in this test.
0:         for ( int i = 0; i < 10; i++ )
0:         {
0:             PreparedStatement ps = prepareStatement
0:                 (
0:                  "select columnnumber from sys.syscolumns c, sys.systables t\n" +
0:                  "where t.tablename = 'SYSTABLES'\n" +
0:                  "and t.tableid = c.referenceid\n" +
0:                  "and c.columnnumber = delay_st( 5, 1 )"
0:                  );
0:             println( "Testing timeout exception for a " + ps.getClass().getName() );
0:             SetQueryTimeoutTest.StatementExecutor   executor =
0:                 new SetQueryTimeoutTest.StatementExecutor( ps, true, 1 );
0:             executor.start();
0:             executor.join();
0:             ps.close();
1: 
0:             se = executor.getSQLException();
1: 
0:             if ( se != null ) { break; }
1:         }
1:         
commit:4eb3fed
/////////////////////////////////////////////////////////////////////////
1:  * Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.StatementTest
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.tests.jdbcapi.SetQueryTimeoutTest;
/////////////////////////////////////////////////////////////////////////
1:      * Test that Statement.setQueryTimeout() causes statements to
1:      * raise SQLTimeoutException per the JDBC 4.1 spec clarification.
1:      */
1:     public  void    test_jdbc4_1_queryTimeoutException() throws Exception
0:     {
0:         PreparedStatement ps = prepareStatement
0:             (
0:              "select columnnumber from sys.syscolumns c, sys.systables t\n" +
0:              "where t.tablename = 'SYSTABLES'\n" +
0:              "and t.tableid = c.referenceid\n" +
0:              "and c.columnnumber = delay_st( 5, 1 )"
0:              );
0:         println( "Testing timeout exception for a " + ps.getClass().getName() );
1: 
0:         SetQueryTimeoutTest.StatementExecutor   executor =
0:             new SetQueryTimeoutTest.StatementExecutor( ps, true, 1 );
1: 
0:         executor.start();
0:         executor.join();
1: 
0:         ps.close();
1: 
0:         SQLException    se = executor.getSQLException();
0:         assertNotNull( se );
0:         assertEquals( SQLTimeoutException.class.getName(), se.getClass().getName() );
1:     }
1: 
1:     /**
commit:6e3dbab
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to you under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:2e7a2af
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bfb5f0
/////////////////////////////////////////////////////////////////////////
1:      *
0:      * Tests the wrapper methods isWrapperFor and unwrap. Test
0:      * for the case when isWrapperFor returns true and we call unwrap
0:      * The test is right now being run in the embedded case only
1:      *
1:      */
0:     public void testisWrapperReturnsTrue() throws SQLException {
0:         //wrapper support is currently provided 
0:         //only for embedded side so return if 
0:         //running in DerbyNetClient framework
0:         if(usingDerbyNetClient())
0:             return;
1:         
0:         Class<Statement> wrap_class = Statement.class;
1:         
0:         //The if should return true enabling us  to call the unwrap method
0:         //without throwing  an exception
0:         if(stmt.isWrapperFor(wrap_class)) {
1:             try {
0:                 Statement stmt1 =
0:                         (Statement)stmt.unwrap(wrap_class);
1:             }
0:             catch(SQLException sqle) {
0:                 fail("Unwrap wrongly throws a SQLException");
1:             }
0:         } else {
0:             fail("isWrapperFor wrongly returns false");
1:         }
1:     }
1:     
1:     /**
1:      *
0:      * Tests the wrapper methods isWrapperFor and unwrap. Test
0:      * for the case when isWrapperFor returns false and we call unwrap
0:      * The test is right now being run in the embedded case only.
1:      *
1:      */
0:     public void testisWrapperReturnsFalse() throws SQLException {
0:         //wrapper support is currently provided 
0:         //only for embedded side so return if 
0:         //running in DerbyNetClient framework
0:          if(usingDerbyNetClient())
0:             return;
1:          
0:         //test for the case when isWrapper returns false
0:         //using some class that will return false when
0:         //passed to isWrapperFor
0:         Class<ResultSet> wrap_class = ResultSet.class;
1:         
0:         //returning false is the correct behaviour in this case
0:         //Generate a message if it returns true
0:         if(stmt.isWrapperFor(wrap_class)) {
0:             fail("isWrapperFor wrongly returns true");
0:         } else {
1:             try {
0:                 ResultSet rs1 = (ResultSet)
0:                 stmt.unwrap(wrap_class);
0:                 fail("unwrap does not throw the expected " +
0:                         "exception");
1:             } catch (SQLException sqle) {
0:                 //calling unwrap in this case throws an SQLException
0:                 //check that this SQLException has the correct SQLState
0:                 if(!SQLStateConstants.UNABLE_TO_UNWRAP.equals(sqle.getSQLState())) {
0:                     throw sqle;
1:                 }
1:             }
1:         }
1:     }
1:     
1:     /**
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.InvocationTargetException;
0: import java.lang.reflect.Method;
1: import java.sql.CallableStatement;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.SQLTimeoutException;
1: import java.sql.Statement;
1: import junit.framework.Test;
1: import org.apache.derby.client.am.ClientStatement;
1: import org.apache.derby.shared.common.sanity.SanityManager;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("StatementTest suite");
1:                         new BaseTestSuite(StatementTest.class)));
1:             new StatementTestSetup(new BaseTestSuite(StatementTest.class))));
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.client.am.ClientStatement;
/////////////////////////////////////////////////////////////////////////
0:             ClientStatement.fetchedRowBase = rowCountBase;
commit:554be49
/////////////////////////////////////////////////////////////////////////
1:             String expectedState =
1:                 SQLStateConstants.INVALID_TRANSACTION_STATE_ACTIVE_SQL_TRANSACTION;
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:59dedd1
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState(expectedState, sqle);
commit:ec5ae26
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:             stmt = null;
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(TestConfiguration.clientServerDecorator(
0:             new StatementTestSetup(new TestSuite(StatementTest.class))));
commit:f631317
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testIsWrapperForStatement() throws SQLException {
1:         assertTrue(stmt.isWrapperFor(Statement.class));
1:     }
1: 
1:     public void testIsNotWrapperForPreparedStatement() throws SQLException {
1:         assertFalse(stmt.isWrapperFor(PreparedStatement.class));
1:     }
1: 
1:     public void testIsNotWrapperForCallableStatement() throws SQLException {
1:         assertFalse(stmt.isWrapperFor(CallableStatement.class));
1:     }
1: 
1:     public void testIsNotWrapperForResultSet() throws SQLException {
1:         assertFalse(stmt.isWrapperFor(ResultSet.class));
1:     }
1: 
1:     public void testUnwrapStatement() throws SQLException {
1:         Statement stmt2 = stmt.unwrap(Statement.class);
1:         assertSame("Unwrap returned wrong object.", stmt, stmt2);
1:     }
1: 
1:     public void testUnwrapPreparedStatement() {
1:         try {
1:             PreparedStatement ps = stmt.unwrap(PreparedStatement.class);
1:             fail("Unwrap didn't fail.");
1:         } catch (SQLException e) {
1:             assertSQLState("XJ128", e);
1: 
1:     public void testUnwrapCallableStatement() {
1:         try {
1:             CallableStatement cs = stmt.unwrap(CallableStatement.class);
1:             fail("Unwrap didn't fail.");
1:         } catch (SQLException e) {
1:             assertSQLState("XJ128", e);
1:         }
1:     }
1: 
1:     public void testUnwrapResultSet() throws SQLException {
1:         try {
1:             ResultSet rs = stmt.unwrap(ResultSet.class);
1:             fail("Unwrap didn't fail.");
1:         } catch (SQLException e) {
1:             assertSQLState("XJ128", e);
commit:7eed914
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Tests isPoolable, setPoolable, and the default poolability.
1:      */
1:     public void testPoolable() throws SQLException {
1:         assertFalse("Statement cannot be poolable by default", 
1:                     stmt.isPoolable()); 
1:         stmt.setPoolable(true);
1:         assertTrue("Statement must be poolable", stmt.isPoolable());
1: 
1:         stmt.setPoolable(false);
1:         assertFalse("Statement cannot be poolable", stmt.isPoolable());
1:     }
1: 
commit:eed8ac6
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:03a99e2
/////////////////////////////////////////////////////////////////////////
1:         getConnection().setAutoCommit(false);
/////////////////////////////////////////////////////////////////////////
1:         Connection con = getConnection();
commit:13e9e78
/////////////////////////////////////////////////////////////////////////
1:    /** Default statement used by the tests. */
/////////////////////////////////////////////////////////////////////////
1:     protected void setUp() 
0:         getXConnection().setAutoCommit(false);
1:         stmt = createStatement();
/////////////////////////////////////////////////////////////////////////
1:     protected void tearDown() 
1:         throws Exception {
1: 
1:         super.tearDown();
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt2 = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt2 = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         rollback();
0:         Connection con = getXConnection();
/////////////////////////////////////////////////////////////////////////
1:         Connection con = stmt.getConnection();
/////////////////////////////////////////////////////////////////////////
1:         Connection con = stmt.getConnection();
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
author:David Van Couvering
-------------------------------------------------------------------------------
commit:5d2e2bd
/////////////////////////////////////////////////////////////////////////
1:             assertEquals("Unexpected SQL state for performing " +
1:                     "operations on a closed statement.",
1:                     SQLStateConstants.CONNECTION_EXCEPTION_CONNECTION_DOES_NOT_EXIST,
1:                     sqle.getSQLState());
commit:e4ba4e1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
/////////////////////////////////////////////////////////////////////////
0:             // The SQL State is incorrect in the embedded client, see
0:             // JIRA id DERBY-1168
0:             String expectedState;
0:             if ( this.usingDerbyNetClient() )
0:                 expectedState = SQLStateConstants.INVALID_TRANSACTION_STATE_ACTIVE_SQL_TRANSACTION;
0:             else
0:                 expectedState = SQLStateConstants.INVALID_TRANSACTION_STATE_NO_SUBCLASS;
1:             
0:             if ( ! expectedState.equals(sqle.getSQLState()) )
0:             {
0:                 System.err.println("ERROR: Unexpected SQL State encountered; "
0:                     + "got " + sqle.getSQLState() + ", expected " 
0:                     + expectedState +
0:                     ". Unexpected exception message is " + sqle.getMessage());
1:                 
0:                 throw sqle;
commit:64e1768
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
0:  * Derby - Class StatementTest
1:  *
0:  * Copyright 2006 The Apache Software Foundation or its 
0:  * licensors, as applicable.
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
1:  */
0: 
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
0: 
0: import org.apache.derby.shared.common.reference.SQLState;
0: import org.apache.derbyTesting.functionTests.util.BaseJDBCTestCase;
0: 
0: import junit.framework.*;
0: 
0: import java.sql.*;
0: 
1: /**
1:  * Tests for new methods added for Statement in JDBC4.
1:  */
1: public class StatementTest
1:     extends BaseJDBCTestCase {
0: 
0:     /** Default connection used by the tests. */
0:     private Connection con = null;
0:     /** Default statement used by the tests. */
1:     private Statement stmt = null;
0:     
1:     /**
1:      * Create a new test with the given name.
1:      *
1:      * @param name name of the test.
1:      */
1:     public StatementTest(String name) {
1:         super(name);
1:     }
0: 
1:     /**
1:      * Create default connection and statement.
1:      *
1:      * @throws SQLException if setAutoCommit, createStatement or 
1:      *                      BaseJDBCTestCase.getConnection fails.
1:      */
0:     public void setUp() 
1:         throws SQLException {
0:         con = getConnection();
0:         assertFalse("Connection must be open initially", con.isClosed());
0:         con.setAutoCommit(false);
1:         // Create a default statement.
0:         stmt = con.createStatement();
1:         assertFalse("First statement must be open initially", 
1:                 stmt.isClosed());
1:     }
0: 
1:     /**
1:      * Close default connection and statement if necessary.
1:      *
1:      * @throws SQLException if a database access exception occurs.
1:      */
0:     public void tearDown() 
1:         throws SQLException {
1:         // Close default statement
1:         if (stmt != null) {
1:             stmt.close();
1:         }
0:         // Close default connection
0:         // Check if connection is open to avoid exception on rollback.
0:         if (con != null && !con.isClosed()) {
0:             // Abort changes that may have been done in the test.
0:             // The test-method may however commit these itself.
0:             con.rollback();
1:             con.close();
1:         }
1:     }
0: 
1:     /**
1:      * Check that <code>isClosed</code> returns <code>true</code> after
1:      * the statement has been explicitly closed.
1:      */
1:     public void testIsClosedBasic()
1:         throws SQLException {
1:         ResultSet rs = stmt.executeQuery("select count(*) from stmtTable");
1:         assertFalse("Statement should still be open", stmt.isClosed());
1:         rs.close();
1:         assertFalse("Statement should be open after ResultSet has been " +
1:                 "closed", stmt.isClosed());
1:         stmt.close();
1:         assertTrue("Statement should be closed, close() has been called", 
1:                 stmt.isClosed());
1:     }
0:     
1:     /**
1:      * Test that creating two statements on the same connection does not
1:      * cause side effects on the statements.
1:      */
1:     public void testIsClosedWithTwoStatementsOnSameConnection()
1:         throws SQLException {
1:         // Create a second statement on the default connection.
0:         Statement stmt2 = con.createStatement();
1:         assertFalse("Second statement must be open initially", 
1:                 stmt2.isClosed());
1:         assertFalse("First statement should not be closed when " +
1:                 "creating a second statement", stmt.isClosed());
1:         ResultSet rs = stmt2.executeQuery("select count(*) from stmtTable");
1:         assertFalse("Second statement should be open after call to " +
1:                 "execute()", stmt2.isClosed());
1:         assertFalse("First statement should be open after call to " +
1:                 "second statment's execute()", stmt.isClosed());
1:         stmt2.close();
1:         assertTrue("Second statement should be closed, close() has " +
1:                 "been called!", stmt2.isClosed());
1:         assertFalse("First statement should be open after call to " +
1:                 "second statment's close()", stmt.isClosed());
1:     }
0: 
1:     /**
1:      * Test that the two statements created on the connection are closed
1:      * when the connection itself is closed.
1:      */
1:     public void testIsClosedWhenClosingConnection()
1:         throws SQLException {
1:         // Create an extra statement for good measure.
0:         Statement stmt2 = con.createStatement();
1:         assertFalse("Second statement must be open initially",
1:                 stmt2.isClosed());
1:         // Exeute something on it, as opposed to the default statement.
1:         stmt2.execute("select count(*) from stmtTable");
1:         assertFalse("Second statement should be open after call to " +
1:                 "execute()", stmt2.isClosed());
1:         // Close the connection. We must commit/rollback first, or else a
1:         // "Invalid transaction state" exception is raised.
0:         con.rollback();
1:         con.close();
1:         assertTrue("Connection should be closed after close()", 
1:                 con.isClosed());
1:         assertTrue("First statement should be closed, as parent " +
1:                 "connection has been closed", stmt.isClosed());
1:         assertTrue("Second statement should be closed, as parent " +
1:                 "connection has been closed", stmt2.isClosed());
1:     }
0:     
1:     /**
1:      * Check the state of the statement when the connection is first attempted
1:      * closed when in an invalid transaction state, then closed after a
1:      * commit. According to the JDBC 4 API documentation: </i>"It is strongly 
1:      * recommended that an application explictly commits or rolls back an 
1:      * active transaction prior to calling the close method. If the close 
1:      * method is called and there is an active transaction, 
1:      * the results are implementation-defined."</i>
1:      * Derby throws an exception and keeps the connection open.
1:      */
1:     public void testIsClosedWhenClosingConnectionInInvalidState()
1:         throws SQLException {
1:         stmt.executeQuery("select count(*) from stmtTable");
1:         // Connection should now be in an invalid transaction state.
0:         try {
1:             con.close();
1:             fail("Invalid transaction state exception was not thrown");
1:         } catch (SQLException sqle) {
0:             if (usingEmbedded()) {
0:                 assertEquals("Unexpected exception thrown: " + sqle.getMessage(),
0:                         SQLState.LANG_INVALID_TRANSACTION_STATE,
0:                         sqle.getSQLState());
0:             } else {
0:                 // TODO: Compare with SQLState when implemented on the client side.
0:                 assertEquals("Unexpected exception thrown: " + sqle.getMessage(),
0:                         "java.sql.Connection.close() requested while a " +
0:                         "transaction is in progress on the connection.The " +
0:                         "transaction remains active, and the connection " +
0:                         "cannot be closed.",
0:                         sqle.getMessage());
1:             }
1:         }
1:         assertFalse("Statement should still be open, because " +
1:                 "Connection.close() failed", stmt.isClosed());
1:         assertFalse("Connection should still be open", con.isClosed());
1:         // Do a commit here, since we do a rollback in another test.
1:         con.commit();
1:         con.close();
1:         assertTrue("Connection should be closed after close()", 
1:                 con.isClosed());
1:         assertTrue("Statement should be closed, because " +
1:                 "the connection has been closed", stmt.isClosed()); 
1:         stmt.close();
1:         assertTrue("Statement should still be closed", stmt.isClosed()); 
1:     }
0:         
1:     /**
1:      * Execute a query on a statement after the parent connection has been
1:      * closed.
1:      */
1:     public void testStatementExecuteAfterConnectionClose() 
1:         throws SQLException {
1:         con.close();
1:         assertTrue("Connection should be closed after close()", 
1:                 con.isClosed());
0:         try {
1:             stmt.executeQuery("select count(*) from stmtTable");
1:         } catch (SQLException sqle) {
0:             // Different error messages are returned for embedded and client.
0:             if (usingEmbedded()) {
0:                 assertEquals("Unexpected SQL state for performing " +
0:                         "operations on a closed statement.",
0:                         SQLState.NO_CURRENT_CONNECTION,
0:                         sqle.getSQLState());
0:             } else {
0:                 // TODO: Compare with SQLState when implemented on client side.
0:                 assertEquals("Unexpected SQL state for performing " +
0:                         "operations on a closed statement.",
0:                         "Invalid operation: statement closed",
0:                         sqle.getMessage());
1:             }
1:         }
1:         assertTrue("Statement should be closed, because " +
1:                 "the connection has been closed", stmt.isClosed()); 
1:     }
0:     
1:     /**
1:      * Create test suite for StatementTest.
1:      */
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("StatementTest suite");
1:         // Decorate test suite with a TestSetup class.
1:         suite.addTest(new StatementTestSetup(
0:                         new TestSuite(StatementTest.class)));
0: 
1:         return suite;
1:     }
0:     
1: } // End class StatementTest
============================================================================