1:eac0369: /*
4:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.GenericExecutionFactory
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:dcd3fec: import org.apache.derby.iapi.reference.EngineType;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.sql.GenericColumnDescriptor;
1:eac0369: import org.apache.derby.impl.sql.GenericResultDescription;
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleControl;
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1:eac0369: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
1:eac0369: import org.apache.derby.iapi.sql.execute.ResultSetStatisticsFactory;
1:48a9884: import org.apache.derby.iapi.sql.execute.xplain.XPLAINFactoryIF;
1:eac0369: import org.apache.derby.iapi.sql.execute.ScanQualifier;
2:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.ResultDescription;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:eac0369: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
1:eac0369: import org.apache.derby.iapi.sql.execute.RowChanger;
1:eac0369: import org.apache.derby.iapi.jdbc.ConnectionContext;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.context.ContextManager;
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:56c1dc2: import java.security.AccessController;
1:56c1dc2: import java.security.PrivilegedActionException;
1:56c1dc2: import java.security.PrivilegedExceptionAction;
1:eac0369: import java.util.Properties;
1:eac0369: import java.util.Vector;
1:eac0369: 
4:eac0369: /**
1:eac0369: 	This Factory is for creating the execution items needed
1:eac0369: 	by a connection for a given database.  Once created for
1:eac0369: 	the connection, they should be pushed onto the execution context
1:eac0369: 	so that they can be found again by subsequent actions during the session.
1:eac0369: 
1:eac0369:  */
1:eac0369: public class GenericExecutionFactory
1:eac0369: 	implements ModuleControl, ModuleSupportable, ExecutionFactory {
1:53ce71e:     
1:53ce71e:     /**
1:53ce71e:      * Statistics factory for this factory.
1:53ce71e:      */
1:53ce71e:     private ResultSetStatisticsFactory rssFactory;
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// ModuleControl interface
1:eac0369: 	//
1:eac0369: 	public boolean canSupport(Properties startParams)
1:eac0369: 	{
1:dcd3fec:         return Monitor.isDesiredType(startParams,
1:dcd3fec:                 EngineType.STANDALONE_DB | EngineType.STORELESS_ENGINE);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		This Factory is expected to be booted relative to a
1:eac0369: 		LanguageConnectionFactory.
1:eac0369: 
1:eac0369: 		@see org.apache.derby.iapi.sql.conn.LanguageConnectionFactory
1:eac0369: 	 * @exception StandardException Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void boot(boolean create, Properties startParams)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		// do we need to/ is there some way to check that
1:eac0369: 		// we are configured per database?
1:eac0369: 
1:eac0369: 		/* Creation of the connection execution factories 
1:eac0369: 		 * for this database deferred until needed to reduce
1:eac0369: 		 * boot time.
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		// REMIND: removed boot of LanguageFactory because
1:eac0369: 		// that is done in BasicDatabase.
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void stop() {
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// ExecutionFactory interface
1:eac0369: 	//
1:eac0369: 	/**
1:eac0369: 	 * Factories are generic and can be used by all connections.
1:eac0369: 	 * We defer instantiation until needed to reduce boot time.
1:eac0369: 	 * We may instantiate too many instances in rare multi-user
1:eac0369: 	 * situation, but consistency will be maintained and at some
1:eac0369: 	 * point, usually always, we will have 1 and only 1 instance
1:eac0369: 	 * of each factory because assignment is atomic.
1:eac0369: 	 */
1:eac0369: 	public ResultSetFactory getResultSetFactory() 
1:eac0369: 	{
1:eac0369: 		if (rsFactory == null)
1:eac0369: 		{
1:eac0369: 			rsFactory = new GenericResultSetFactory();
1:eac0369: 		}
1:eac0369: 		return rsFactory;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Get the factory for constant actions.
1:eac0369: 	  *
1:eac0369: 	  *	@return	the factory for constant actions.
1:eac0369: 	  */
1:eac0369: 	public	GenericConstantActionFactory	getConstantActionFactory() 
1:eac0369: 	{ 
1:eac0369: 		if (genericConstantActionFactory == null)
1:eac0369: 		{
1:eac0369: 			genericConstantActionFactory = new GenericConstantActionFactory();
1:eac0369: 		}
1:eac0369: 		return genericConstantActionFactory; 
1:eac0369: 	}
1:53ce71e:     
1:53ce71e:     /**
1:53ce71e:      * Get the ResultSetStatisticsFactory from this ExecutionFactory.
1:53ce71e:      *
1:53ce71e:      * @return  The result set statistics factory associated with this
1:53ce71e:      *      ExecutionFactory
1:53ce71e:      *
1:53ce71e:      * @exception StandardException     Thrown on error
1:53ce71e:      */
1:53ce71e:     public ResultSetStatisticsFactory getResultSetStatisticsFactory()
1:53ce71e:                     throws StandardException {
1:53ce71e:         if (rssFactory == null) {
1:53ce71e:             rssFactory = (ResultSetStatisticsFactory)
1:56c1dc2:                 bootServiceModule(
1:53ce71e:                                     false,
1:53ce71e:                                     this,
1:53ce71e:                                     ResultSetStatisticsFactory.MODULE,
1:53ce71e:                                     (Properties) null);
1:53ce71e:         }
1:53ce71e: 
1:53ce71e:         return rssFactory;
1:53ce71e:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		We want a dependency context so that we can push it onto
1:eac0369: 		the stack.  We could instead require the implementation
1:eac0369: 		push it onto the stack for us, but this way we know
1:eac0369: 		which context object exactly was pushed onto the stack.
1:eac0369: 	 */
1:eac0369: 	public ExecutionContext newExecutionContext(ContextManager cm)
1:eac0369: 	{
1:eac0369: 		/* Pass in nulls for execution factories.  GEC
1:eac0369: 		 * will call back to get factories when needed.
1:eac0369: 		 * This allows us to reduce boot time class loading.
1:eac0369: 		 * (Replication currently instantiates factories
1:eac0369: 		 * at boot time.)
1:eac0369: 		 */
1:eac0369: 		return new GenericExecutionContext(
1:eac0369: 							cm, this);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * @see ExecutionFactory#getScanQualifier
1:eac0369: 	 */
1:eac0369: 	public ScanQualifier[][] getScanQualifier(int numQualifiers)
1:eac0369: 	{
1:eac0369: 		ScanQualifier[] sqArray = new GenericScanQualifier[numQualifiers];
1:eac0369: 
1:eac0369: 		for (int ictr = 0; ictr < numQualifiers; ictr++)
1:eac0369: 		{
1:eac0369: 			sqArray[ictr] = new GenericScanQualifier();
1:eac0369: 		}
1:eac0369: 
1:eac0369:         ScanQualifier[][] ret_sqArray = { sqArray };
1:eac0369: 
1:eac0369: 		return(ret_sqArray);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Make a result description
1:eac0369: 	 */
1:eac0369: 	public ResultDescription getResultDescription(
1:eac0369: 		ResultColumnDescriptor[] columns, String statementType) {
1:eac0369: 		return new GenericResultDescription(columns, statementType);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Create an execution time ResultColumnDescriptor from a 
1:eac0369: 	 * compile time RCD.
1:eac0369: 	 *
1:eac0369: 	 * @param compileRCD	The compile time RCD.
1:eac0369: 	 *
1:eac0369: 	 * @return The execution time ResultColumnDescriptor
1:eac0369: 	 */
1:eac0369: 	public ResultColumnDescriptor getResultColumnDescriptor(ResultColumnDescriptor compileRCD)
1:eac0369: 	{
1:eac0369: 		return new GenericColumnDescriptor(compileRCD);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ExecutionFactory#releaseScanQualifier
1:eac0369: 	 */
1:eac0369: 	public void releaseScanQualifier(ScanQualifier[][] qualifiers)
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ExecutionFactory#getQualifier
1:eac0369: 	 */
1:eac0369: 	public Qualifier getQualifier(
1:eac0369: 							int columnId,
1:eac0369: 							int operator,
1:eac0369: 							GeneratedMethod orderableGetter,
1:eac0369: 							Activation activation,
1:eac0369: 							boolean orderedNulls,
1:eac0369: 							boolean unknownRV,
1:eac0369: 							boolean negateCompareResult,
1:eac0369: 							int variantType)
1:eac0369: 	{
1:eac0369: 		return new GenericQualifier(columnId, operator, orderableGetter,
1:eac0369: 									activation, orderedNulls, unknownRV,
1:eac0369: 									negateCompareResult, variantType);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  @see ExecutionFactory#getRowChanger
1:eac0369: 	  */
1:eac0369: 	public RowChanger
1:eac0369: 	getRowChanger(long heapConglom,
1:eac0369: 				  StaticCompiledOpenConglomInfo heapSCOCI,
1:eac0369: 				  DynamicCompiledOpenConglomInfo heapDCOCI,
1:eac0369: 				  IndexRowGenerator[] irgs,
1:eac0369: 				  long[] indexCIDS,
1:eac0369: 				  StaticCompiledOpenConglomInfo[] indexSCOCIs,
1:eac0369: 				  DynamicCompiledOpenConglomInfo[] indexDCOCIs,
1:eac0369: 				  int numberOfColumns,
1:eac0369: 				  TransactionController tc,
1:eac0369: 				  int[] changedColumnIds,
1:eac0369: 				  int[] streamStorableHeapColIds,
1:eac0369: 				  Activation activation) throws StandardException
1:eac0369: 	{
1:eac0369: 		return new RowChangerImpl( heapConglom, 
1:eac0369: 								   heapSCOCI, heapDCOCI, 
1:eac0369: 								   irgs, indexCIDS, indexSCOCIs, indexDCOCIs,
1:eac0369: 								   numberOfColumns, 
1:eac0369: 								   changedColumnIds, tc, null,
1:eac0369: 								   streamStorableHeapColIds, activation );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @exception StandardException		Thrown on error
1:eac0369: 	  @see ExecutionFactory#getRowChanger
1:eac0369: 	  */
1:eac0369: 	public RowChanger getRowChanger(
1:eac0369: 			   long heapConglom,
1:eac0369: 			   StaticCompiledOpenConglomInfo heapSCOCI,
1:eac0369: 			   DynamicCompiledOpenConglomInfo heapDCOCI,
1:eac0369: 			   IndexRowGenerator[] irgs,
1:eac0369: 			   long[] indexCIDS,
1:eac0369: 			   StaticCompiledOpenConglomInfo[] indexSCOCIs,
1:eac0369: 			   DynamicCompiledOpenConglomInfo[] indexDCOCIs,
1:eac0369: 			   int numberOfColumns,
1:eac0369: 			   TransactionController tc,
1:eac0369: 			   int[] changedColumnIds,
1:eac0369: 			   FormatableBitSet	baseRowReadList,
1:eac0369: 			   int[] baseRowReadMap,
1:eac0369: 			   int[] streamStorableColIds,
1:eac0369: 			   Activation activation
3:eac0369: 			   )
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		return new RowChangerImpl( heapConglom,
1:eac0369: 								   heapSCOCI, heapDCOCI, 
1:eac0369: 								   irgs, indexCIDS, indexSCOCIs, indexDCOCIs,
1:eac0369: 								   numberOfColumns, 
1:eac0369: 								   changedColumnIds, tc, baseRowReadList,
1:eac0369: 								   baseRowReadMap, activation );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get a trigger execution context
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:05623b6:     InternalTriggerExecutionContext getTriggerExecutionContext
3:eac0369: 	(
1:eac0369: 		LanguageConnectionContext	lcc,
1:eac0369: 		ConnectionContext			cc,
1:eac0369: 		String 						statementText,
1:eac0369: 		int 						dmlType,
1:eac0369: 		UUID						targetTableId,
1:eac0369: 		String						targetTableName,
1:801cf0d:         Vector<AutoincrementCounter> aiCounters
1:eac0369: 	) throws StandardException
1:eac0369: 	{
1:eac0369: 		return new InternalTriggerExecutionContext(lcc, cc,
1:eac0369: 												   statementText, dmlType,
1:eac0369: 												   targetTableId,
1:eac0369: 												   targetTableName, 
1:eac0369: 												   aiCounters);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 		Old RowFactory interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public ExecRow getValueRow(int numColumns) {
1:eac0369: 		return new ValueRow(numColumns);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public ExecIndexRow getIndexableRow(int numColumns) {
1:eac0369: 		return new IndexRow(numColumns);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public ExecIndexRow getIndexableRow(ExecRow valueRow) {
1:eac0369: 		if (valueRow instanceof ExecIndexRow)
1:eac0369: 			return (ExecIndexRow)valueRow;
1:eac0369: 		return new IndexValueRow(valueRow);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// class interface
1:eac0369: 	//
1:eac0369: 	public GenericExecutionFactory() {
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// fields
1:eac0369: 	//
1:624d867: 	private ResultSetFactory rsFactory;
1:624d867:     private GenericConstantActionFactory	genericConstantActionFactory;
1:48a9884: 
1:48a9884: private XPLAINFactoryIF xplainFactory; 
1:48a9884:  
1:48a9884:  
1:48a9884:    /**
1:48a9884:     * Get the XPLAINFactory from this ExecutionContext.
1:48a9884:     *
1:48a9884:     * @return  The XPLAINFactory associated with this
1:48a9884:     *      ExecutionContext
1:48a9884:     *
1:48a9884:     * @exception StandardException     Thrown on error
1:48a9884:     */
1:48a9884:    public XPLAINFactoryIF getXPLAINFactory()
1:48a9884:                    throws StandardException {
1:48a9884:        if (xplainFactory == null) {
1:48a9884:            xplainFactory = (XPLAINFactoryIF)
1:56c1dc2:                bootServiceModule(
1:48a9884:                                    false,
1:48a9884:                                    this,
1:48a9884:                                    XPLAINFactoryIF.MODULE,
1:48a9884:                                    (Properties) null);
1:48a9884:        }
1:48a9884:        return xplainFactory;
1:48a9884:    }
1:56c1dc2: 
1:48a9884:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object bootServiceModule
1:56c1dc2:         (
1:56c1dc2:          final boolean create, final Object serviceModule,
1:56c1dc2:          final String factoryInterface, final Properties properties
1:56c1dc2:          )
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.bootServiceModule( create, serviceModule, factoryInterface, properties );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1:                 bootServiceModule(
/////////////////////////////////////////////////////////////////////////
1:                bootServiceModule(
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object bootServiceModule
1:         (
1:          final boolean create, final Object serviceModule,
1:          final String factoryInterface, final Properties properties
1:          )
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.bootServiceModule( create, serviceModule, factoryInterface, properties );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
1:         Vector<AutoincrementCounter> aiCounters
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:05623b6
/////////////////////////////////////////////////////////////////////////
1:     InternalTriggerExecutionContext getTriggerExecutionContext
commit:c67f5dd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:48a9884
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.xplain.XPLAINFactoryIF;
/////////////////////////////////////////////////////////////////////////
1: 
1: private XPLAINFactoryIF xplainFactory; 
1:  
1:  
1:    /**
1:     * Get the XPLAINFactory from this ExecutionContext.
1:     *
1:     * @return  The XPLAINFactory associated with this
1:     *      ExecutionContext
1:     *
1:     * @exception StandardException     Thrown on error
1:     */
1:    public XPLAINFactoryIF getXPLAINFactory()
1:                    throws StandardException {
1:        if (xplainFactory == null) {
1:            xplainFactory = (XPLAINFactoryIF)
0:                Monitor.bootServiceModule(
1:                                    false,
1:                                    this,
1:                                    XPLAINFactoryIF.MODULE,
1:                                    (Properties) null);
1:        }
1:        return xplainFactory;
1:    }
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:53ce71e
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Statistics factory for this factory.
1:      */
1:     private ResultSetStatisticsFactory rssFactory;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Get the ResultSetStatisticsFactory from this ExecutionFactory.
1:      *
1:      * @return  The result set statistics factory associated with this
1:      *      ExecutionFactory
1:      *
1:      * @exception StandardException     Thrown on error
1:      */
1:     public ResultSetStatisticsFactory getResultSetStatisticsFactory()
1:                     throws StandardException {
1:         if (rssFactory == null) {
1:             rssFactory = (ResultSetStatisticsFactory)
0:                 Monitor.bootServiceModule(
1:                                     false,
1:                                     this,
1:                                     ResultSetStatisticsFactory.MODULE,
1:                                     (Properties) null);
1:         }
1: 
1:         return rssFactory;
1:     }
commit:6c000e8
/////////////////////////////////////////////////////////////////////////
commit:624d867
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	private ResultSetFactory rsFactory;
1:     private GenericConstantActionFactory	genericConstantActionFactory;
commit:dcd3fec
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.EngineType;
/////////////////////////////////////////////////////////////////////////
1:         return Monitor.isDesiredType(startParams,
1:                 EngineType.STANDALONE_DB | EngineType.STORELESS_ENGINE);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.GenericExecutionFactory
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
1: import org.apache.derby.iapi.sql.Activation;
1: 
1: import org.apache.derby.impl.sql.GenericColumnDescriptor;
1: import org.apache.derby.impl.sql.GenericResultDescription;
1: import org.apache.derby.iapi.services.monitor.ModuleControl;
1: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.types.DataValueFactory;
1: 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
1: import org.apache.derby.iapi.sql.execute.ResultSetStatisticsFactory;
1: import org.apache.derby.iapi.sql.execute.ScanQualifier;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1: import org.apache.derby.iapi.sql.ResultDescription;
1: 
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
1: import org.apache.derby.iapi.sql.execute.RowChanger;
1: import org.apache.derby.iapi.jdbc.ConnectionContext;
1: 
1: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
0: import org.apache.derby.iapi.services.io.FormatableHashtable;
0: import org.apache.derby.iapi.services.io.FormatableIntHolder;
0: import org.apache.derby.iapi.services.io.FormatableProperties;
0: import org.apache.derby.catalog.TypeDescriptor;
1: import java.util.Properties;
1: import java.util.Vector;
1: 
1: /**
1: 	This Factory is for creating the execution items needed
1: 	by a connection for a given database.  Once created for
1: 	the connection, they should be pushed onto the execution context
1: 	so that they can be found again by subsequent actions during the session.
1: 
0: 	@author ames
1:  */
1: public class GenericExecutionFactory
1: 	implements ModuleControl, ModuleSupportable, ExecutionFactory {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	//
1: 	// ModuleControl interface
1: 	//
1: 	public boolean canSupport(Properties startParams)
1: 	{
0: 		return	Monitor.isDesiredType( startParams, org.apache.derby.iapi.reference.EngineType.NONE);
1: 	}
1: 
1: 	/**
1: 		This Factory is expected to be booted relative to a
1: 		LanguageConnectionFactory.
1: 
1: 		@see org.apache.derby.iapi.sql.conn.LanguageConnectionFactory
1: 	 * @exception StandardException Thrown on error
1: 	 */
1: 	public void boot(boolean create, Properties startParams)
1: 		throws StandardException
1: 	{
1: 		// do we need to/ is there some way to check that
1: 		// we are configured per database?
1: 
1: 		/* Creation of the connection execution factories 
1: 		 * for this database deferred until needed to reduce
1: 		 * boot time.
1: 		 */
1: 
1: 		// REMIND: removed boot of LanguageFactory because
1: 		// that is done in BasicDatabase.
1: 	}
1: 
1: 	public void stop() {
1: 	}
1: 
1: 	//
1: 	// ExecutionFactory interface
1: 	//
1: 	/**
1: 	 * Factories are generic and can be used by all connections.
1: 	 * We defer instantiation until needed to reduce boot time.
1: 	 * We may instantiate too many instances in rare multi-user
1: 	 * situation, but consistency will be maintained and at some
1: 	 * point, usually always, we will have 1 and only 1 instance
1: 	 * of each factory because assignment is atomic.
1: 	 */
1: 	public ResultSetFactory getResultSetFactory() 
1: 	{
1: 		if (rsFactory == null)
1: 		{
1: 			rsFactory = new GenericResultSetFactory();
1: 		}
1: 		return rsFactory;
1: 	}
1: 
1: 	/**
1: 	  *	Get the factory for constant actions.
1: 	  *
1: 	  *	@return	the factory for constant actions.
1: 	  */
1: 	public	GenericConstantActionFactory	getConstantActionFactory() 
1: 	{ 
1: 		if (genericConstantActionFactory == null)
1: 		{
1: 			genericConstantActionFactory = new GenericConstantActionFactory();
1: 		}
1: 		return genericConstantActionFactory; 
1: 	}
1: 
1: 	/**
1: 		We want a dependency context so that we can push it onto
1: 		the stack.  We could instead require the implementation
1: 		push it onto the stack for us, but this way we know
1: 		which context object exactly was pushed onto the stack.
1: 	 */
1: 	public ExecutionContext newExecutionContext(ContextManager cm)
1: 	{
1: 		/* Pass in nulls for execution factories.  GEC
1: 		 * will call back to get factories when needed.
1: 		 * This allows us to reduce boot time class loading.
1: 		 * (Replication currently instantiates factories
1: 		 * at boot time.)
1: 		 */
1: 		return new GenericExecutionContext(
0: 							(ResultSetFactory) null,
1: 							cm, this);
1: 	}
1: 
1: 	/*
1: 	 * @see ExecutionFactory#getScanQualifier
1: 	 */
1: 	public ScanQualifier[][] getScanQualifier(int numQualifiers)
1: 	{
1: 		ScanQualifier[] sqArray = new GenericScanQualifier[numQualifiers];
1: 
1: 		for (int ictr = 0; ictr < numQualifiers; ictr++)
1: 		{
1: 			sqArray[ictr] = new GenericScanQualifier();
1: 		}
1: 
1:         ScanQualifier[][] ret_sqArray = { sqArray };
1: 
1: 		return(ret_sqArray);
1: 	}
1: 
1: 	/**
1: 		Make a result description
1: 	 */
1: 	public ResultDescription getResultDescription(
1: 		ResultColumnDescriptor[] columns, String statementType) {
1: 		return new GenericResultDescription(columns, statementType);
1: 	}
1: 
1: 	/**
1: 	 * Create an execution time ResultColumnDescriptor from a 
1: 	 * compile time RCD.
1: 	 *
1: 	 * @param compileRCD	The compile time RCD.
1: 	 *
1: 	 * @return The execution time ResultColumnDescriptor
1: 	 */
1: 	public ResultColumnDescriptor getResultColumnDescriptor(ResultColumnDescriptor compileRCD)
1: 	{
1: 		return new GenericColumnDescriptor(compileRCD);
1: 	}
1: 
1: 	/**
1: 	 * @see ExecutionFactory#releaseScanQualifier
1: 	 */
1: 	public void releaseScanQualifier(ScanQualifier[][] qualifiers)
1: 	{
1: 	}
1: 
1: 	/**
1: 	 * @see ExecutionFactory#getQualifier
1: 	 */
1: 	public Qualifier getQualifier(
1: 							int columnId,
1: 							int operator,
1: 							GeneratedMethod orderableGetter,
1: 							Activation activation,
1: 							boolean orderedNulls,
1: 							boolean unknownRV,
1: 							boolean negateCompareResult,
1: 							int variantType)
1: 	{
1: 		return new GenericQualifier(columnId, operator, orderableGetter,
1: 									activation, orderedNulls, unknownRV,
1: 									negateCompareResult, variantType);
1: 	}
1: 
1: 	/**
1: 	  @exception StandardException		Thrown on error
1: 	  @see ExecutionFactory#getRowChanger
1: 	  */
1: 	public RowChanger
1: 	getRowChanger(long heapConglom,
1: 				  StaticCompiledOpenConglomInfo heapSCOCI,
1: 				  DynamicCompiledOpenConglomInfo heapDCOCI,
1: 				  IndexRowGenerator[] irgs,
1: 				  long[] indexCIDS,
1: 				  StaticCompiledOpenConglomInfo[] indexSCOCIs,
1: 				  DynamicCompiledOpenConglomInfo[] indexDCOCIs,
1: 				  int numberOfColumns,
1: 				  TransactionController tc,
1: 				  int[] changedColumnIds,
1: 				  int[] streamStorableHeapColIds,
1: 				  Activation activation) throws StandardException
1: 	{
1: 		return new RowChangerImpl( heapConglom, 
1: 								   heapSCOCI, heapDCOCI, 
1: 								   irgs, indexCIDS, indexSCOCIs, indexDCOCIs,
1: 								   numberOfColumns, 
1: 								   changedColumnIds, tc, null,
1: 								   streamStorableHeapColIds, activation );
1: 	}
1: 
1: 	/**
1: 	  @exception StandardException		Thrown on error
1: 	  @see ExecutionFactory#getRowChanger
1: 	  */
1: 	public RowChanger getRowChanger(
1: 			   long heapConglom,
1: 			   StaticCompiledOpenConglomInfo heapSCOCI,
1: 			   DynamicCompiledOpenConglomInfo heapDCOCI,
1: 			   IndexRowGenerator[] irgs,
1: 			   long[] indexCIDS,
1: 			   StaticCompiledOpenConglomInfo[] indexSCOCIs,
1: 			   DynamicCompiledOpenConglomInfo[] indexDCOCIs,
1: 			   int numberOfColumns,
1: 			   TransactionController tc,
1: 			   int[] changedColumnIds,
1: 			   FormatableBitSet	baseRowReadList,
1: 			   int[] baseRowReadMap,
1: 			   int[] streamStorableColIds,
1: 			   Activation activation
1: 			   )
1: 		 throws StandardException
1: 	{
1: 		return new RowChangerImpl( heapConglom,
1: 								   heapSCOCI, heapDCOCI, 
1: 								   irgs, indexCIDS, indexSCOCIs, indexDCOCIs,
1: 								   numberOfColumns, 
1: 								   changedColumnIds, tc, baseRowReadList,
1: 								   baseRowReadMap, activation );
1: 	}
1: 
1: 
1: 	/**
1: 	 * Get a trigger execution context
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public InternalTriggerExecutionContext getTriggerExecutionContext
1: 	(
1: 		LanguageConnectionContext	lcc,
1: 		ConnectionContext			cc,
1: 		String 						statementText,
1: 		int 						dmlType,
0: 		int[]						changedColIds,
0: 		String[]					changedColNames,
1: 		UUID						targetTableId,
1: 		String						targetTableName,
0: 		Vector						aiCounters
1: 	) throws StandardException
1: 	{
1: 		return new InternalTriggerExecutionContext(lcc, cc,
1: 												   statementText, dmlType,
0: 												   changedColIds,
0: 												   changedColNames,
1: 												   targetTableId,
1: 												   targetTableName, 
1: 												   aiCounters);
1: 	}
1: 
1: 	/*
1: 		Old RowFactory interface
1: 	 */
1: 
1: 	public ExecRow getValueRow(int numColumns) {
1: 		return new ValueRow(numColumns);
1: 	}
1: 
1: 	public ExecIndexRow getIndexableRow(int numColumns) {
1: 		return new IndexRow(numColumns);
1: 	}
1: 
1: 	public ExecIndexRow getIndexableRow(ExecRow valueRow) {
1: 		if (valueRow instanceof ExecIndexRow)
1: 			return (ExecIndexRow)valueRow;
1: 		return new IndexValueRow(valueRow);
1: 	}
1: 
1:    /**
0: 	 Packages up a clump of constants which the Plugin uses at execute()
0: 	 time for COPY PUBLICATION.
1:     */
0:     public	Object	getJdbcCopyConstants
1: 	(
0: 		int[][]				paramReferences,
0: 		TypeDescriptor[][]	columnTypes,
0: 		int[][]				publishedTableSchemaCounts
1:     )
0: 	{ return null; }
1: 
1:    /**
0: 	 Packages up a clump of constants which the Plugin uses at execute()
0: 	 time for CREATE PUBLICATION.
1:     */
0:     public	Object	getJdbcCreateConstants
1: 	(
0: 		UUID[]				publishedJarFileIDs,
0: 		Object				publishedItems,
0: 		int[][]				tableSchemaCounts
1:     )
0: 	{ return null; }
1: 
1: 	//
1: 	// class interface
1: 	//
1: 	public GenericExecutionFactory() {
1: 	}
1: 
1: 	//
1: 	// fields
1: 	//
0: 	public	  ResultSetFactory rsFactory;
0:     protected GenericConstantActionFactory	genericConstantActionFactory;
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.impl.sql.GenericColumnDescriptor;
0: import org.apache.derby.impl.sql.GenericResultDescription;
0: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
0: import org.apache.derby.iapi.sql.execute.ResultSetStatisticsFactory;
0: import org.apache.derby.iapi.sql.execute.ScanQualifier;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: 
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.execute.RowChanger;
0: import org.apache.derby.iapi.jdbc.ConnectionContext;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
0: import org.apache.derby.iapi.services.io.FormatableHashtable;
0: import org.apache.derby.iapi.services.io.FormatableIntHolder;
0: import org.apache.derby.iapi.services.io.FormatableProperties;
0: import org.apache.derby.catalog.TypeDescriptor;
0: import java.util.Properties;
0: import java.util.Vector;
0: 
0: /**
0: 	This Factory is for creating the execution items needed
0: 	by a connection for a given database.  Once created for
0: 	the connection, they should be pushed onto the execution context
0: 	so that they can be found again by subsequent actions during the session.
0: 
0: 	@author ames
0:  */
0: public class GenericExecutionFactory
0: 	implements ModuleControl, ModuleSupportable, ExecutionFactory {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	//
0: 	// ModuleControl interface
0: 	//
0: 	public boolean canSupport(Properties startParams)
0: 	{
0: 		return	Monitor.isDesiredType( startParams, org.apache.derby.iapi.reference.EngineType.NONE);
0: 	}
0: 
0: 	/**
0: 		This Factory is expected to be booted relative to a
0: 		LanguageConnectionFactory.
0: 
0: 		@see org.apache.derby.iapi.sql.conn.LanguageConnectionFactory
0: 	 * @exception StandardException Thrown on error
0: 	 */
0: 	public void boot(boolean create, Properties startParams)
0: 		throws StandardException
0: 	{
0: 		// do we need to/ is there some way to check that
0: 		// we are configured per database?
0: 
0: 		/* Creation of the connection execution factories 
0: 		 * for this database deferred until needed to reduce
0: 		 * boot time.
0: 		 */
0: 
0: 		// REMIND: removed boot of LanguageFactory because
0: 		// that is done in BasicDatabase.
0: 	}
0: 
0: 	public void stop() {
0: 	}
0: 
0: 	//
0: 	// ExecutionFactory interface
0: 	//
0: 	/**
0: 	 * Factories are generic and can be used by all connections.
0: 	 * We defer instantiation until needed to reduce boot time.
0: 	 * We may instantiate too many instances in rare multi-user
0: 	 * situation, but consistency will be maintained and at some
0: 	 * point, usually always, we will have 1 and only 1 instance
0: 	 * of each factory because assignment is atomic.
0: 	 */
0: 	public ResultSetFactory getResultSetFactory() 
0: 	{
0: 		if (rsFactory == null)
0: 		{
0: 			rsFactory = new GenericResultSetFactory();
0: 		}
0: 		return rsFactory;
0: 	}
0: 
0: 	/**
0: 	  *	Get the factory for constant actions.
0: 	  *
0: 	  *	@return	the factory for constant actions.
0: 	  */
0: 	public	GenericConstantActionFactory	getConstantActionFactory() 
0: 	{ 
0: 		if (genericConstantActionFactory == null)
0: 		{
0: 			genericConstantActionFactory = new GenericConstantActionFactory();
0: 		}
0: 		return genericConstantActionFactory; 
0: 	}
0: 
0: 	/**
0: 		We want a dependency context so that we can push it onto
0: 		the stack.  We could instead require the implementation
0: 		push it onto the stack for us, but this way we know
0: 		which context object exactly was pushed onto the stack.
0: 	 */
0: 	public ExecutionContext newExecutionContext(ContextManager cm)
0: 	{
0: 		/* Pass in nulls for execution factories.  GEC
0: 		 * will call back to get factories when needed.
0: 		 * This allows us to reduce boot time class loading.
0: 		 * (Replication currently instantiates factories
0: 		 * at boot time.)
0: 		 */
0: 		return new GenericExecutionContext(
0: 							(ResultSetFactory) null,
0: 							cm, this);
0: 	}
0: 
0: 	/*
0: 	 * @see ExecutionFactory#getScanQualifier
0: 	 */
0: 	public ScanQualifier[][] getScanQualifier(int numQualifiers)
0: 	{
0: 		ScanQualifier[] sqArray = new GenericScanQualifier[numQualifiers];
0: 
0: 		for (int ictr = 0; ictr < numQualifiers; ictr++)
0: 		{
0: 			sqArray[ictr] = new GenericScanQualifier();
0: 		}
0: 
0:         ScanQualifier[][] ret_sqArray = { sqArray };
0: 
0: 		return(ret_sqArray);
0: 	}
0: 
0: 	/**
0: 		Make a result description
0: 	 */
0: 	public ResultDescription getResultDescription(
0: 		ResultColumnDescriptor[] columns, String statementType) {
0: 		return new GenericResultDescription(columns, statementType);
0: 	}
0: 
0: 	/**
0: 	 * Create an execution time ResultColumnDescriptor from a 
0: 	 * compile time RCD.
0: 	 *
0: 	 * @param compileRCD	The compile time RCD.
0: 	 *
0: 	 * @return The execution time ResultColumnDescriptor
0: 	 */
0: 	public ResultColumnDescriptor getResultColumnDescriptor(ResultColumnDescriptor compileRCD)
0: 	{
0: 		return new GenericColumnDescriptor(compileRCD);
0: 	}
0: 
0: 	/**
0: 	 * @see ExecutionFactory#releaseScanQualifier
0: 	 */
0: 	public void releaseScanQualifier(ScanQualifier[][] qualifiers)
0: 	{
0: 	}
0: 
0: 	/**
0: 	 * @see ExecutionFactory#getQualifier
0: 	 */
0: 	public Qualifier getQualifier(
0: 							int columnId,
0: 							int operator,
0: 							GeneratedMethod orderableGetter,
0: 							Activation activation,
0: 							boolean orderedNulls,
0: 							boolean unknownRV,
0: 							boolean negateCompareResult,
0: 							int variantType)
0: 	{
0: 		return new GenericQualifier(columnId, operator, orderableGetter,
0: 									activation, orderedNulls, unknownRV,
0: 									negateCompareResult, variantType);
0: 	}
0: 
0: 	/**
0: 	  @exception StandardException		Thrown on error
0: 	  @see ExecutionFactory#getRowChanger
0: 	  */
0: 	public RowChanger
0: 	getRowChanger(long heapConglom,
0: 				  StaticCompiledOpenConglomInfo heapSCOCI,
0: 				  DynamicCompiledOpenConglomInfo heapDCOCI,
0: 				  IndexRowGenerator[] irgs,
0: 				  long[] indexCIDS,
0: 				  StaticCompiledOpenConglomInfo[] indexSCOCIs,
0: 				  DynamicCompiledOpenConglomInfo[] indexDCOCIs,
0: 				  int numberOfColumns,
0: 				  TransactionController tc,
0: 				  int[] changedColumnIds,
0: 				  int[] streamStorableHeapColIds,
0: 				  Activation activation) throws StandardException
0: 	{
0: 		return new RowChangerImpl( heapConglom, 
0: 								   heapSCOCI, heapDCOCI, 
0: 								   irgs, indexCIDS, indexSCOCIs, indexDCOCIs,
0: 								   numberOfColumns, 
0: 								   changedColumnIds, tc, null,
0: 								   streamStorableHeapColIds, activation );
0: 	}
0: 
0: 	/**
0: 	  @exception StandardException		Thrown on error
0: 	  @see ExecutionFactory#getRowChanger
0: 	  */
0: 	public RowChanger getRowChanger(
0: 			   long heapConglom,
0: 			   StaticCompiledOpenConglomInfo heapSCOCI,
0: 			   DynamicCompiledOpenConglomInfo heapDCOCI,
0: 			   IndexRowGenerator[] irgs,
0: 			   long[] indexCIDS,
0: 			   StaticCompiledOpenConglomInfo[] indexSCOCIs,
0: 			   DynamicCompiledOpenConglomInfo[] indexDCOCIs,
0: 			   int numberOfColumns,
0: 			   TransactionController tc,
0: 			   int[] changedColumnIds,
0: 			   FormatableBitSet	baseRowReadList,
0: 			   int[] baseRowReadMap,
0: 			   int[] streamStorableColIds,
0: 			   Activation activation
0: 			   )
0: 		 throws StandardException
0: 	{
0: 		return new RowChangerImpl( heapConglom,
0: 								   heapSCOCI, heapDCOCI, 
0: 								   irgs, indexCIDS, indexSCOCIs, indexDCOCIs,
0: 								   numberOfColumns, 
0: 								   changedColumnIds, tc, baseRowReadList,
0: 								   baseRowReadMap, activation );
0: 	}
0: 
0: 
0: 	/**
0: 	 * Get a trigger execution context
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public InternalTriggerExecutionContext getTriggerExecutionContext
0: 	(
0: 		LanguageConnectionContext	lcc,
0: 		ConnectionContext			cc,
0: 		String 						statementText,
0: 		int 						dmlType,
0: 		int[]						changedColIds,
0: 		String[]					changedColNames,
0: 		UUID						targetTableId,
0: 		String						targetTableName,
0: 		Vector						aiCounters
0: 	) throws StandardException
0: 	{
0: 		return new InternalTriggerExecutionContext(lcc, cc,
0: 												   statementText, dmlType,
0: 												   changedColIds,
0: 												   changedColNames,
0: 												   targetTableId,
0: 												   targetTableName, 
0: 												   aiCounters);
0: 	}
0: 
0: 	/*
0: 		Old RowFactory interface
0: 	 */
0: 
0: 	public ExecRow getValueRow(int numColumns) {
0: 		return new ValueRow(numColumns);
0: 	}
0: 
0: 	public ExecIndexRow getIndexableRow(int numColumns) {
0: 		return new IndexRow(numColumns);
0: 	}
0: 
0: 	public ExecIndexRow getIndexableRow(ExecRow valueRow) {
0: 		if (valueRow instanceof ExecIndexRow)
0: 			return (ExecIndexRow)valueRow;
0: 		return new IndexValueRow(valueRow);
0: 	}
0: 
0:    /**
0: 	 Packages up a clump of constants which the Plugin uses at execute()
0: 	 time for COPY PUBLICATION.
0:     */
0:     public	Object	getJdbcCopyConstants
0: 	(
0: 		int[][]				paramReferences,
0: 		TypeDescriptor[][]	columnTypes,
0: 		int[][]				publishedTableSchemaCounts
0:     )
0: 	{ return null; }
0: 
0:    /**
0: 	 Packages up a clump of constants which the Plugin uses at execute()
0: 	 time for CREATE PUBLICATION.
0:     */
0:     public	Object	getJdbcCreateConstants
0: 	(
0: 		UUID[]				publishedJarFileIDs,
0: 		Object				publishedItems,
0: 		int[][]				tableSchemaCounts
0:     )
0: 	{ return null; }
0: 
0: 	//
0: 	// class interface
0: 	//
0: 	public GenericExecutionFactory() {
0: 	}
0: 
0: 	//
0: 	// fields
0: 	//
0: 	public	  ResultSetFactory rsFactory;
0:     protected GenericConstantActionFactory	genericConstantActionFactory;
0: }
============================================================================