3:eac0369: /*
1:d7258ed: 
1:d7258ed:    Derby - Class org.apache.derby.impl.drda.DRDAResultSet
1:d7258ed: 
1:59e5225:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59e5225:    contributor license agreements.  See the NOTICE file distributed with
1:59e5225:    this work for additional information regarding copyright ownership.
1:59e5225:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59e5225:    (the "License"); you may not use this file except in compliance with
1:59e5225:    the License.  You may obtain a copy of the License at
1:d7258ed: 
1:d7258ed:       http://www.apache.org/licenses/LICENSE-2.0
1:d7258ed: 
1:d7258ed:    Unless required by applicable law or agreed to in writing, software
1:d7258ed:    distributed under the License is distributed on an "AS IS" BASIS,
1:d7258ed:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d7258ed:    See the License for the specific language governing permissions and
1:d7258ed:    limitations under the License.
40:eac0369: 
2:9ce79e7:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.drda;
1:eac0369: 
1:eac0369: import java.sql.ResultSet;
1:eac0369: import java.sql.ResultSetMetaData;
1:eac0369: import java.sql.SQLException;
1:9ce79e7: import java.sql.Types;
1:eac0369: import java.util.ArrayList;
1:886b5f8: import org.apache.derby.iapi.jdbc.EngineResultSet;
1:eac0369: 
1:4f996a4: /**
1:4f996a4:     DRDAResultSet holds result set information
1:f0dcf0b: */
1:eac0369: class DRDAResultSet
2:41f1df9: {
1:4f996a4:     //NOTE!
1:4f996a4:     //
1:4f996a4:     // Since DRDAResultSets are reused, ALL variables should be set 
1:4f996a4:     // to their default values in reset().
1:eac0369: 
1:4f996a4:     // resultSet states are NOT_OPENED and SUSPENDED
1:4f996a4:     protected static final int NOT_OPENED = 1;
1:4f996a4:     protected static final int SUSPENDED = 2;
1:4f996a4:     public static final int QRYCLSIMP_DEFAULT = CodePoint.QRYCLSIMP_NO;  
1:4f996a4:     
1:4f996a4:     boolean explicitlyClosed = false;
1:9ce79e7: 
1:4f996a4:     int state;
1:4f996a4:     protected boolean hasdata = true;
1:db9a013:     protected int[] rsLens;             // result length for each column
1:db9a013:     private int[] rsDRDATypes;          // DRDA Types of the result set columns
1:4f996a4:     private int[] rsPrecision;         // result precision for Decimal types
1:4f996a4:     private int[] rsScale;              // result sale for Decimal types
1:eac0369: 
1:db9a013:     protected int [] outovr_drdaType;   // Output override DRDA type and length
1:eac0369: 
1:db9a013:     protected int withHoldCursor;           // hold cursor after commit attribute
1:db9a013:     protected int scrollType = ResultSet.TYPE_FORWARD_ONLY;         // Sensitive or Insensitive scroll attribute
1:db9a013:     protected int concurType;           // Concurency type
1:4f996a4:     protected long rowCount;            // Number of rows we have processed
1:4f996a4:     private ResultSet rs;              // Current ResultSet
1:eac0369: 
1:db9a013:     protected int blksize;              // Query block size
1:4f996a4:     protected int maxblkext;            // Maximum number of extra blocks
1:4f996a4:     protected int outovropt;            // Output Override option
1:4f996a4:     protected int qryclsimp;            // Implicit Query Close Setting
1:4f996a4:     protected boolean qryrelscr;        // Query relative scrolling
1:db9a013:     protected long qryrownbr;           // Query row number
1:4f996a4:     protected boolean qryrfrtbl;        // Query refresh answer set table
1:4f996a4:     protected int qryscrorn;            // Query scroll orientation
1:4f996a4:     protected boolean qryrowsns;        // Query row sensitivity
1:4f996a4:     protected boolean qryblkrst;        // Query block reset
1:4f996a4:     protected boolean qryrtndta;        // Query returns data
1:4f996a4:     protected int qryrowset;            // Query row set
1:4f996a4:     private   int qryprctyp;            // Protocol type
1:4f996a4:     private   boolean gotPrctyp;        // save the result, for performance
1:4f996a4:     protected int rtnextdta;            // Return of EXTDTA option
1:db9a013:     protected int nbrrow;              // number of fetch or insert rows
1:4f996a4:     protected byte [] rslsetflg;        // Result Set Flags
1:eac0369: 
1:27fbf33:     /** List of Blobs and Clobs. Return values to send with extdta objects. */
1:27fbf33:     private ArrayList<Object> extDtaObjects;
1:4f996a4:     
1:27fbf33:     private ArrayList<Integer> rsExtPositions;
1:eac0369: 
1:4f996a4:     protected ConsistencyToken pkgcnstkn; // Unique consistency token for ResultSet 0
1:eac0369: 
1:4f996a4:     // splitQRYDTA is normally null. If it is non-null, it means that
1:4f996a4:     // the last QRYDTA response which was sent for this statement was
1:4f996a4:     // split according to the LMTBLKPRC protocol, and this array contains
1:4f996a4:     // the bytes that didn't fit. These bytes should be the first bytes
1:4f996a4:     // emitted in the next QRYDTA response to a CNTQRY request.
1:4f996a4:     private byte []splitQRYDTA;
1:41f1df9: 
1:4f996a4:     DRDAResultSet()
1:4f996a4:     {
1:4f996a4:         state = NOT_OPENED;
1:4f996a4:         // Initialize qryclsimp to NO. Only result sets requested by
1:4f996a4:         // an OPNQRY command should be implicitly closed. OPNQRY will
1:4f996a4:         // set qryclsimp later in setOPNQRYOptions().
2:4f996a4:         qryclsimp = CodePoint.QRYCLSIMP_NO;
1:4f996a4:     }
1:f0dcf0b: 
1:7ff69a3:     /**
1:db9a013:      * Set result set and initialize type array.
1:4f996a4:      *
1:4f996a4:      * @param value
1:4f996a4:      * 
1:4f996a4:      */
1:eac0369: 
1:4f996a4:     void setResultSet(ResultSet value) throws SQLException
1:4f996a4:     {
1:4f996a4:         rs = value;
2:4f996a4:         gotPrctyp = false;
1:4f996a4:         int numCols= rs.getMetaData().getColumnCount();
1:4f996a4:         rsDRDATypes = new int[numCols];
1:4f996a4:         explicitlyClosed = false;
1:4f996a4:     }
1:f0dcf0b: 
1:f0dcf0b: 
1:4f996a4:     /**
1:4f996a4:      * set consistency token for this resultSet
1:4f996a4:      *
1:4f996a4:      */
1:4f996a4:     protected void setPkgcnstkn(ConsistencyToken pkgcnstkn)
1:4f996a4:     {
1:4f996a4:         this.pkgcnstkn = pkgcnstkn;
1:4f996a4:     }
1:f0dcf0b: 
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * 
1:4f996a4:      *  @return the underlying java.sql.ResultSet
1:4f996a4:      */
1:4f996a4:     protected ResultSet getResultSet()
1:4f996a4:     {
1:4f996a4:         return rs;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     public void setSplitQRYDTA(byte []data)
1:4f996a4:     {
1:4f996a4:         splitQRYDTA = data;
1:4f996a4:     }
1:4f996a4:     public byte[]getSplitQRYDTA()
1:4f996a4:     {
1:4f996a4:         return splitQRYDTA;
1:4f996a4:     }
1:41f1df9: 
1:4f996a4:     /**
1:4f996a4:      *@return ResultSet DRDA DataTypes
1:4f996a4:      **/
1:eac0369: 
1:4f996a4:     protected int[] getRsDRDATypes()
1:4f996a4:     {
1:4f996a4:         // use the given override if it is present
1:4f996a4:         if (outovr_drdaType != null)
1:4f996a4:             return outovr_drdaType;
1:4f996a4:         return rsDRDATypes;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * set resultset/out parameter precision
1:4f996a4:      *
1:4f996a4:      * @param index - starting with 1
1:4f996a4:      * @param precision
1:4f996a4:      */
1:4f996a4:     protected void setRsPrecision(int index, int precision)
1:4f996a4:     {
1:4f996a4:         if (rsPrecision == null)
1:4f996a4:             rsPrecision = new int[rsDRDATypes.length];
1:4f996a4:         rsPrecision[index -1] = precision;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:c6892a1:      * get resultset /out parameter precision
1:4f996a4:      * @param index -starting with 1
1:4f996a4:      * @return precision of column
1:4f996a4:      */
1:4f996a4:     protected int getRsPrecision(int index)
1:4f996a4:     {
1:4f996a4:         if (rsPrecision == null)
1:4f996a4:             return 0;
1:4f996a4:         return rsPrecision[index-1];
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * set resultset/out parameter scale
1:4f996a4:      *
1:4f996a4:      * @param index - starting with 1
1:4f996a4:      * @param scale
1:4f996a4:      */
1:4f996a4:     protected void setRsScale(int index, int scale)
1:4f996a4:     {
1:4f996a4:         if (rsScale == null)
1:4f996a4:             rsScale = new int[rsDRDATypes.length];
1:4f996a4:         rsScale[index-1] = scale;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:c6892a1:      * get resultset /out parameter scale
1:4f996a4:      * @param index -starting with 1
1:4f996a4:      * @return scale of column
1:4f996a4:      */
1:4f996a4:     protected int  getRsScale(int index)
1:4f996a4:     {
1:4f996a4:         if (rsScale == null)
1:4f996a4:             return 0;
1:4f996a4:         
1:4f996a4:         return rsScale[index -1];
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     
1:4f996a4:     /**
1:4f996a4:      * set resultset/out parameter DRDAType
1:4f996a4:      *
1:4f996a4:      * @param index - starting with 1
1:4f996a4:      * @param type
1:4f996a4:      */
1:4f996a4:     protected  void setRsDRDAType(int index, int type)
1:4f996a4:     {
1:4f996a4:         rsDRDATypes[index -1] =  type;
1:4f996a4:         
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     /**
1:4f996a4:      * get  resultset/out parameter DRDAType
1:4f996a4:      *
1:4f996a4:      * @param index - starting with 1
1:4f996a4:      * @return  DRDA Type of column
1:4f996a4:      */
1:4f996a4:     protected int getRsDRDAType(int index)
1:4f996a4:     {
1:ad7199e:         if ((outovr_drdaType != null) && (outovr_drdaType[index-1] != 0)) {
1:ad7199e:             // Override with requested type.  0 means use default
1:ad7199e:             return outovr_drdaType[index-1];
1:f0dcf0b:         }
1:eac0369:         return rsDRDATypes[index -1];
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     
1:4f996a4:     /**
1:4f996a4:      * get  resultset  DRDALen
1:4f996a4:      * @param index - starting with 1
1:4f996a4:      * @return  length of column value
1:4f996a4:      */
1:4f996a4:     protected int getRsLen(int index)
1:4f996a4:     {
1:4f996a4:         return rsLens[index -1];
1:4f996a4:     }
1:4f996a4:     
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Add extDtaObject
1:4f996a4:      * @param o - object to  add
1:4f996a4:      */
1:4f996a4:     protected void  addExtDtaObject (Object o, int jdbcIndex )
1:4f996a4:     {
1:4f996a4:         if (extDtaObjects == null)
1:27fbf33:             extDtaObjects = new java.util.ArrayList<Object>();
1:4f996a4:         extDtaObjects.add (o);
1:eac0369: 
1:4f996a4:         if (rsExtPositions == null)
1:27fbf33:             rsExtPositions = new java.util.ArrayList<Integer>();
1:4f996a4:         
1:4f996a4:         // need to record the 0 based position so subtract 1
1:66527ec:         rsExtPositions.add(jdbcIndex - 1);
1:eac0369: 
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Clear externalized lob objects in current result set
1:4f996a4:      */
1:4f996a4:     protected void  clearExtDtaObjects ()
1:4f996a4:     {
1:4f996a4:         if (extDtaObjects != null)
1:4f996a4:             extDtaObjects.clear();
1:4f996a4:         if (rsExtPositions != null)
1:4f996a4:             rsExtPositions.clear();
1:4f996a4:         
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     /**
1:4f996a4:      * Is lob object nullable
1:4f996a4:      * @param index - offset starting with 0
1:4f996a4:      * @return true if object is nullable
1:4f996a4:      */
1:4f996a4:     protected boolean isExtDtaValueNullable(int index)
1:4f996a4:     {
1:4f996a4:         if ((rsExtPositions == null) || 
1:4f996a4:             rsExtPositions.get(index) == null)
1:4f996a4:             return false;
1:4f996a4:         
1:eac0369: 
1:6022edd:         // Column number is starting on 1
1:6022edd:         int colnum = ((Integer) rsExtPositions.get(index)).intValue() + 1;
1:94df7fb: 
1:94df7fb:         // if there is no type information, then we represent a CallableStatement
1:94df7fb:         // and all parameters are nullable
1:94df7fb:         if ( rsDRDATypes == null ) { return true; }
1:4f996a4:         else if (FdocaConstants.isNullable(getRsDRDAType(colnum)))
1:4f996a4:             return true;
1:4f996a4:         else 
1:4f996a4:             return false;
1:4f996a4:     }
1:4f996a4:     
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Get the extData Objects
1:4f996a4:      *
1:4f996a4:      *  @return ArrayList with extdta
1:4f996a4:      */
1:27fbf33:     protected ArrayList<Object> getExtDtaObjects()
1:4f996a4:     {
1:4f996a4:         return extDtaObjects;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * This method closes the JDBC objects and frees up all references held by
1:4f996a4:      * this object.
1:4f996a4:      * 
1:4f996a4:      * @throws SQLException
1:4f996a4:      */
1:4f996a4:     protected void close()  throws SQLException
1:4f996a4:     {
1:4f996a4:         if (rs != null)
1:4f996a4:             rs.close();
1:4f996a4:         rs = null;
1:4f996a4:         outovr_drdaType = null;
1:4f996a4:         rsLens = null;
1:4f996a4:         rsDRDATypes = null;
1:4f996a4:         rsPrecision = null;
1:4f996a4:         rsScale = null;
1:4f996a4:         extDtaObjects = null;
2:4f996a4:         splitQRYDTA = null;
1:4f996a4:         rsExtPositions = null;
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     /**
1:4f996a4:      * This method resets the state of this DRDAResultset object so that it can
1:4f996a4:      * be re-used. This method should reset all variables of this class.
1:4f996a4:      * 
1:4f996a4:      */
1:4f996a4:     protected void reset() {
1:4f996a4:         explicitlyClosed = false;
1:4f996a4:         state = NOT_OPENED;
1:4f996a4:         hasdata = true;
1:4f996a4:         rsLens = null;
1:4f996a4:         rsDRDATypes = null;
1:4f996a4:         rsPrecision = null;
1:4f996a4:         rsScale = null;
1:4f996a4:         
1:4f996a4:         outovr_drdaType = null;
1:4f996a4:         
1:db9a013:         withHoldCursor = 0;
1:4f996a4:         scrollType = ResultSet.TYPE_FORWARD_ONLY;
1:4f996a4:         concurType = 0;
1:4f996a4:         rowCount = 0;
1:4f996a4:         rs = null;
1:4f996a4:         
1:4f996a4:         blksize = 0;
1:db9a013:         maxblkext = 0;
1:4f996a4:         outovropt = 0;
1:db9a013:         qryclsimp = CodePoint.QRYCLSIMP_NO;
1:4f996a4:         qryrelscr = false;
1:4f996a4:         qryrownbr = 0;
1:db9a013:         qryrfrtbl = false;
1:4f996a4:         qryscrorn = 0;
1:4f996a4:         qryrowsns = false; 
1:4f996a4:         qryblkrst = false;
1:db9a013:         qryrtndta = false;
1:4f996a4:         qryrowset = 0;
1:4f996a4:         qryprctyp = 0;
1:db9a013:         gotPrctyp = false;
1:db9a013:         rtnextdta = 0;
1:4f996a4:         nbrrow = 0;
1:db9a013:         rslsetflg = null;
1:f0dcf0b: 
1:4f996a4:         extDtaObjects = null;
1:4f996a4:         rsExtPositions = null;
1:4f996a4:         pkgcnstkn = null;
1:db9a013:         splitQRYDTA = null;
1:4f996a4:     }
1:9ce79e7: 
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Explicitly close the result set by CLSQRY
1:4f996a4:      * needed to check for double close.
1:4f996a4:      */
1:4f996a4:     protected void CLSQRY()
1:4f996a4:     {
1:4f996a4:         explicitlyClosed = true;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /* 
1:4f996a4:      * @return whether CLSQRY has been called on the
1:4f996a4:      *         current result set.
1:4f996a4:      */
1:4f996a4:     protected boolean wasExplicitlyClosed()
1:4f996a4:     {
1:4f996a4:         return explicitlyClosed;
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     /****
1:4f996a4:      * Check to see if the result set for this statement
1:4f996a4:      * has at least one column that is BLOB/CLOB.
1:4f996a4:      * @return True if the result has at least one blob/clob
1:4f996a4:      *  column; false otherwise.
1:4f996a4:      ****/
1:eac0369:  
1:a10e456:     protected boolean hasLobColumns() throws SQLException
1:4f996a4:     {
1:4f996a4:         ResultSetMetaData rsmd = rs.getMetaData();
1:4f996a4:         int ncols = rsmd.getColumnCount();
1:4f996a4:         for (int i = 1; i <= ncols; i++)
1:4f996a4:         {
1:4f996a4:             int type = rsmd.getColumnType(i);
1:4f996a4:             if (type == Types.BLOB || type == Types.CLOB)
1:4f996a4:                 return true;
1:4f996a4:         }
1:4f996a4:         return false;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Get the cursor name for the ResultSet
1:4f996a4:      */
1:4f996a4:     public String getResultSetCursorName() throws SQLException
1:4f996a4:     {
1:eac0369: 
1:4f996a4:         if (rs != null)
1:4f996a4:             return rs.getCursorName();
1:4f996a4:         else 
1:4f996a4:             return null;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected int getQryprctyp()
1:4f996a4:         throws SQLException
1:4f996a4:     {
1:4f996a4:         if (!gotPrctyp && qryprctyp == CodePoint.LMTBLKPRC)
1:4f996a4:         {
1:4f996a4:             gotPrctyp = true;
1:4f996a4:             if (rs == null || ((EngineResultSet)rs).isForUpdate() ||
1:4f996a4:                 /* for now we are not supporting LOB under LMTBLKPRC.  drda spec only
1:4f996a4:                  * disallows LOB under LMTBLKPRC if OUTOVR is also for ANY CNTQRY reply.
1:4f996a4:                  * To support LOB, QRYDTA protocols for LOB will need to be changed.
1:4f996a4:                  */
1:4f996a4:                 hasLobColumns())
1:4f996a4:             {
1:4f996a4:                 qryprctyp = CodePoint.FIXROWPRC;
1:4f996a4:             }
1:4f996a4:         }
1:4f996a4:         return qryprctyp;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected void setQryprctyp(int qryprctyp)
1:4f996a4:     {
1:4f996a4:         this.qryprctyp = qryprctyp;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * is ResultSet closed
1:4f996a4:      * @return whether the resultSet  is closed
1:4f996a4:      */
1:4f996a4:     protected boolean isClosed()
1:4f996a4:     {
1:4f996a4:         return (state == NOT_OPENED);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Set state to SUSPENDED (result set is opened)
1:4f996a4:      */
1:4f996a4:     protected void suspend()
1:4f996a4:     {
1:4f996a4:         state = SUSPENDED;
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     protected String toDebugString(String indent)
1:4f996a4:     {
1:4f996a4:         String s = indent + "***** DRDASResultSet toDebugString ******\n";
1:4f996a4:         s += indent + "State:" + getStateString(state)+ "\n";
1:4f996a4:         s += indent + "pkgcnstkn: {" + pkgcnstkn + "}\n"; 
1:4f996a4:         s += indent + "cursor Name: ";
1:4f996a4:         String cursorName = null;
1:4f996a4:         try {
1:4f996a4:             if (rs != null)
1:4f996a4:                 cursorName = rs.getCursorName();
1:4f996a4:         }
1:4f996a4:         catch (SQLException se )
1:4f996a4:         {
1:4f996a4:             cursorName = "invalid rs";
1:4f996a4:         }
1:4f996a4:         s += indent + cursorName + "\n";
1:4f996a4:            
1:4f996a4:         return s;
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     private String getStateString( int i )
1:4f996a4:     {
1:4f996a4:         switch (i)
1:4f996a4:         {
1:4f996a4:             case NOT_OPENED:
1:4f996a4:                 return "NOT_OPENED";
1:4f996a4:             case SUSPENDED:
1:4f996a4:                 return "SUSPENDED";
1:4f996a4:             default:
1:4f996a4:                 return "UNKNOWN_STATE";
1:4f996a4:         }
1:4f996a4: 
1:4f996a4:     }
1:eac0369:     
1:4f996a4:     /**
1:4f996a4:      * Sets the OPNQRYOptions. For more information on the meaning of these
1:4f996a4:      * values consult the DRDA Technical Standard document. 
1:4f996a4:      * 
1:4f996a4:      * @param blksize Query block Size
1:4f996a4:      * @param qryblkctl Use to set the query protocol type
1:4f996a4:      * @param maxblkext Maximum number of extra blocks
1:4f996a4:      * @param outovropt Output override option
1:4f996a4:      * @param qryrowset Query row set
1:4f996a4:      * @param qryclsimpl Implicit query close setting
1:4f996a4:      */
1:4f996a4:     protected void setOPNQRYOptions(int blksize, int qryblkctl,
1:4f996a4:             int maxblkext, int outovropt,int qryrowset,int qryclsimpl)
1:4f996a4:     {
1:4f996a4:         this.blksize = blksize;
1:4f996a4:         setQryprctyp(qryblkctl);
1:4f996a4:         this.maxblkext = maxblkext;
1:4f996a4:         this.outovropt = outovropt;
1:4f996a4:         this.qryrowset = qryrowset;
1:4f996a4:         this.qryclsimp = (qryclsimpl == CodePoint.QRYCLSIMP_SERVER_CHOICE)
1:4f996a4:             ? DRDAResultSet.QRYCLSIMP_DEFAULT : qryclsimpl;
1:a10e456: 
1:a10e456:         // Assume that we are returning data until a CNTQRY command
1:a10e456:         // tells us otherwise. (DERBY-822)
1:a10e456:         qryrtndta = true;
1:a10e456: 
1:a10e456:         // For scrollable result sets, we don't know the fetch
1:a10e456:         // orientation until we get a CNTQRY command. Set orientation
1:a10e456:         // and row number to make pre-fetching possible. (DERBY-822)
1:a10e456:         qryscrorn = CodePoint.QRYSCRREL;
1:a10e456:         qryrownbr = 1;
1:4f996a4:     }
2:41f1df9: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c6892a1
/////////////////////////////////////////////////////////////////////////
1:      * get resultset /out parameter precision
/////////////////////////////////////////////////////////////////////////
1:      * get resultset /out parameter scale
commit:db9a013
/////////////////////////////////////////////////////////////////////////
1:     protected int[] rsLens;             // result length for each column
1:     private int[] rsDRDATypes;          // DRDA Types of the result set columns
1:     protected int [] outovr_drdaType;   // Output override DRDA type and length
1:     protected int withHoldCursor;           // hold cursor after commit attribute
1:     protected int scrollType = ResultSet.TYPE_FORWARD_ONLY;         // Sensitive or Insensitive scroll attribute
1:     protected int concurType;           // Concurency type
1:     protected int blksize;              // Query block size
1:     protected long qryrownbr;           // Query row number
/////////////////////////////////////////////////////////////////////////
1:     protected int nbrrow;              // number of fetch or insert rows
/////////////////////////////////////////////////////////////////////////
1:      * Set result set and initialize type array.
/////////////////////////////////////////////////////////////////////////
1:         withHoldCursor = 0;
1:         maxblkext = 0;
1:         qryclsimp = CodePoint.QRYCLSIMP_NO;
1:         qryrfrtbl = false;
1:         qryrtndta = false;
1:         gotPrctyp = false;
1:         rtnextdta = 0;
1:         rslsetflg = null;
1:         splitQRYDTA = null;
commit:66527ec
/////////////////////////////////////////////////////////////////////////
1:         rsExtPositions.add(jdbcIndex - 1);
commit:db4c995
/////////////////////////////////////////////////////////////////////////
commit:27fbf33
/////////////////////////////////////////////////////////////////////////
1:     /** List of Blobs and Clobs. Return values to send with extdta objects. */
1:     private ArrayList<Object> extDtaObjects;
1:     private ArrayList<Integer> rsExtPositions;
/////////////////////////////////////////////////////////////////////////
1: 			extDtaObjects = new java.util.ArrayList<Object>();
1: 			rsExtPositions = new java.util.ArrayList<Integer>();
/////////////////////////////////////////////////////////////////////////
1: 	protected ArrayList<Object> getExtDtaObjects()
commit:6022edd
/////////////////////////////////////////////////////////////////////////
1: 		// Column number is starting on 1
1: 		int colnum = ((Integer) rsExtPositions.get(index)).intValue() + 1;
0: 		if (FdocaConstants.isNullable(getRsDRDAType(colnum)))
commit:7ff69a3
/////////////////////////////////////////////////////////////////////////
1: 	/**
commit:a10e456
/////////////////////////////////////////////////////////////////////////
1: 	protected boolean hasLobColumns() throws SQLException
/////////////////////////////////////////////////////////////////////////
1: 
1: 		// Assume that we are returning data until a CNTQRY command
1: 		// tells us otherwise. (DERBY-822)
1: 		qryrtndta = true;
1: 
1: 		// For scrollable result sets, we don't know the fetch
1: 		// orientation until we get a CNTQRY command. Set orientation
1: 		// and row number to make pre-fetching possible. (DERBY-822)
1: 		qryscrorn = CodePoint.QRYSCRREL;
1: 		qryrownbr = 1;
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:4f996a4
/////////////////////////////////////////////////////////////////////////
1:     DRDAResultSet holds result set information
1:     //NOTE!
1:     //
1:     // Since DRDAResultSets are reused, ALL variables should be set 
1:     // to their default values in reset().
1:     // resultSet states are NOT_OPENED and SUSPENDED
1:     protected static final int NOT_OPENED = 1;
1:     protected static final int SUSPENDED = 2;
1:     public static final int QRYCLSIMP_DEFAULT = CodePoint.QRYCLSIMP_NO;  
1:     
1:     boolean explicitlyClosed = false;
1:     int state;
1:     protected boolean hasdata = true;
0:     protected int[] rsLens;                // result length for each column
0:     private int[] rsDRDATypes;            // DRDA Types of the result set columns
1:     private int[] rsPrecision;         // result precision for Decimal types
1:     private int[] rsScale;              // result sale for Decimal types
0:     protected int [] outovr_drdaType;    // Output override DRDA type and length
0:     protected int withHoldCursor;            // hold cursor after commit attribute
0:     protected int scrollType = ResultSet.TYPE_FORWARD_ONLY;            // Sensitive or Insensitive scroll attribute
0:     protected int concurType;            // Concurency type
1:     protected long rowCount;            // Number of rows we have processed
1:     private ResultSet rs;              // Current ResultSet
0:     protected int blksize;                // Query block size
1:     protected int maxblkext;            // Maximum number of extra blocks
1:     protected int outovropt;            // Output Override option
1:     protected int qryclsimp;            // Implicit Query Close Setting
1:     protected boolean qryrelscr;        // Query relative scrolling
0:     protected long qryrownbr;            // Query row number
1:     protected boolean qryrfrtbl;        // Query refresh answer set table
1:     protected int qryscrorn;            // Query scroll orientation
1:     protected boolean qryrowsns;        // Query row sensitivity
1:     protected boolean qryblkrst;        // Query block reset
1:     protected boolean qryrtndta;        // Query returns data
1:     protected int qryrowset;            // Query row set
1:     private   int qryprctyp;            // Protocol type
1:     private   boolean gotPrctyp;        // save the result, for performance
1:     protected int rtnextdta;            // Return of EXTDTA option
0:     protected int nbrrow;               // number of fetch or insert rows
1:     protected byte [] rslsetflg;        // Result Set Flags
1:     
1:     protected ConsistencyToken pkgcnstkn; // Unique consistency token for ResultSet 0
1:     // splitQRYDTA is normally null. If it is non-null, it means that
1:     // the last QRYDTA response which was sent for this statement was
1:     // split according to the LMTBLKPRC protocol, and this array contains
1:     // the bytes that didn't fit. These bytes should be the first bytes
1:     // emitted in the next QRYDTA response to a CNTQRY request.
1:     private byte []splitQRYDTA;
1:     DRDAResultSet()
1:     {
1:         state = NOT_OPENED;
1:         // Initialize qryclsimp to NO. Only result sets requested by
1:         // an OPNQRY command should be implicitly closed. OPNQRY will
1:         // set qryclsimp later in setOPNQRYOptions().
1:         qryclsimp = CodePoint.QRYCLSIMP_NO;
1:     }
1:     /**
0:       * Set result set and initialize type array.
1:      *
1:      * @param value
1:      * 
1:      */
1:     void setResultSet(ResultSet value) throws SQLException
1:     {
1:         rs = value;
1:         gotPrctyp = false;
1:         int numCols= rs.getMetaData().getColumnCount();
1:         rsDRDATypes = new int[numCols];
1:         explicitlyClosed = false;
1:     }
1:     /**
1:      * set consistency token for this resultSet
1:      *
1:      */
1:     protected void setPkgcnstkn(ConsistencyToken pkgcnstkn)
1:     {
1:         this.pkgcnstkn = pkgcnstkn;
1:     }
1:     /**
1:      * 
1:      *  @return the underlying java.sql.ResultSet
1:      */
1:     protected ResultSet getResultSet()
1:     {
1:         return rs;
1:     }
1:     public void setSplitQRYDTA(byte []data)
1:     {
1:         splitQRYDTA = data;
1:     }
1:     public byte[]getSplitQRYDTA()
1:     {
1:         return splitQRYDTA;
1:     }
1:     /**
1:      *@return ResultSet DRDA DataTypes
1:      **/
1:     protected int[] getRsDRDATypes()
1:     {
1:         // use the given override if it is present
1:         if (outovr_drdaType != null)
1:             return outovr_drdaType;
1:         return rsDRDATypes;
1:     }
1:     /**
1:      * set resultset/out parameter precision
1:      *
1:      * @param index - starting with 1
1:      * @param precision
1:      */
1:     protected void setRsPrecision(int index, int precision)
1:     {
1:         if (rsPrecision == null)
1:             rsPrecision = new int[rsDRDATypes.length];
1:         rsPrecision[index -1] = precision;
1:     }
1:     /**
0:      * get resultset /out paramter precision
1:      * @param index -starting with 1
1:      * @return precision of column
1:      */
1:     protected int getRsPrecision(int index)
1:     {
1:         if (rsPrecision == null)
1:             return 0;
1:         return rsPrecision[index-1];
1:     }
1:     /**
1:      * set resultset/out parameter scale
1:      *
1:      * @param index - starting with 1
1:      * @param scale
1:      */
1:     protected void setRsScale(int index, int scale)
1:     {
1:         if (rsScale == null)
1:             rsScale = new int[rsDRDATypes.length];
1:         rsScale[index-1] = scale;
1:     }
1:     /**
0:      * get resultset /out paramter scale
1:      * @param index -starting with 1
1:      * @return scale of column
1:      */
1:     protected int  getRsScale(int index)
1:     {
1:         if (rsScale == null)
1:             return 0;
1:         
1:         return rsScale[index -1];
1:     }
1:     
1:     
1:     /**
1:      * set resultset/out parameter DRDAType
1:      *
1:      * @param index - starting with 1
1:      * @param type
1:      */
1:     protected  void setRsDRDAType(int index, int type)
1:     {
1:         rsDRDATypes[index -1] =  type;
1:         
1:     }
1:     
1:     /**
1:      * get  resultset/out parameter DRDAType
1:      *
1:      * @param index - starting with 1
1:      * @return  DRDA Type of column
1:      */
1:     protected int getRsDRDAType(int index)
1:     {
1:     }
1:     
1:     
1:     /**
1:      * get  resultset  DRDALen
1:      * @param index - starting with 1
1:      * @return  length of column value
1:      */
1:     protected int getRsLen(int index)
1:     {
1:         return rsLens[index -1];
1:     }
1:     
1:     /**
1:      * Add extDtaObject
1:      * @param o - object to  add
1:      */
1:     protected void  addExtDtaObject (Object o, int jdbcIndex )
1:     {
1:         if (extDtaObjects == null)
0:             extDtaObjects = new java.util.ArrayList<Object>();
1:         extDtaObjects.add (o);
1:         if (rsExtPositions == null)
0:             rsExtPositions = new java.util.ArrayList<Integer>();
1:         
1:         // need to record the 0 based position so subtract 1
1:     }
1:     /**
1:      * Clear externalized lob objects in current result set
1:      */
1:     protected void  clearExtDtaObjects ()
1:     {
1:         if (extDtaObjects != null)
1:             extDtaObjects.clear();
1:         if (rsExtPositions != null)
1:             rsExtPositions.clear();
1:         
1:     }
1:     
1:     /**
1:      * Is lob object nullable
1:      * @param index - offset starting with 0
1:      * @return true if object is nullable
1:      */
1:     protected boolean isExtDtaValueNullable(int index)
1:     {
1:         if ((rsExtPositions == null) || 
1:             rsExtPositions.get(index) == null)
1:             return false;
1:         
0:         // Column number is starting on 1
0:         int colnum = ((Integer) rsExtPositions.get(index)).intValue() + 1;
1:         else if (FdocaConstants.isNullable(getRsDRDAType(colnum)))
1:             return true;
1:         else 
1:             return false;
1:     }
1:     
1:     /**
1:      * Get the extData Objects
1:      *
1:      *  @return ArrayList with extdta
1:      */
0:     protected ArrayList<Object> getExtDtaObjects()
1:     {
1:         return extDtaObjects;
1:     }
1:     /**
1:      * This method closes the JDBC objects and frees up all references held by
1:      * this object.
1:      * 
1:      * @throws SQLException
1:      */
1:     protected void close()  throws SQLException
1:     {
1:         if (rs != null)
1:             rs.close();
1:         rs = null;
1:         outovr_drdaType = null;
1:         rsLens = null;
1:         rsDRDATypes = null;
1:         rsPrecision = null;
1:         rsScale = null;
1:         extDtaObjects = null;
1:         splitQRYDTA = null;
1:         rsExtPositions = null;
1:     }
1:     
1:     /**
1:      * This method resets the state of this DRDAResultset object so that it can
1:      * be re-used. This method should reset all variables of this class.
1:      * 
1:      */
1:     protected void reset() {
1:         explicitlyClosed = false;
1:         state = NOT_OPENED;
1:         hasdata = true;
1:         rsLens = null;
1:         rsDRDATypes = null;
1:         rsPrecision = null;
1:         rsScale = null;
1:         
1:         outovr_drdaType = null;
1:         
0:         withHoldCursor = 0;    
1:         scrollType = ResultSet.TYPE_FORWARD_ONLY;
1:         concurType = 0;
1:         rowCount = 0;
1:         rs = null;
1:         
1:         blksize = 0;
0:         maxblkext = 0;    
1:         outovropt = 0;
1:         qryclsimp = CodePoint.QRYCLSIMP_NO;    
1:         qryrelscr = false;
1:         qryrownbr = 0;
0:         qryrfrtbl = false;    
1:         qryscrorn = 0;
1:         qryrowsns = false; 
1:         qryblkrst = false;
0:         qryrtndta = false;    
1:         qryrowset = 0;
1:         qryprctyp = 0;
1:         gotPrctyp = false;     
0:         rtnextdta = 0;    
1:         nbrrow = 0;
0:         rslsetflg = null;    
1:         extDtaObjects = null;
1:         rsExtPositions = null;
1:         pkgcnstkn = null;
1:         splitQRYDTA = null;    
1:     }
1:     /**
1:      * Explicitly close the result set by CLSQRY
1:      * needed to check for double close.
1:      */
1:     protected void CLSQRY()
1:     {
1:         explicitlyClosed = true;
1:     }
1:     /* 
1:      * @return whether CLSQRY has been called on the
1:      *         current result set.
1:      */
1:     protected boolean wasExplicitlyClosed()
1:     {
1:         return explicitlyClosed;
1:     }
1:     /****
1:      * Check to see if the result set for this statement
1:      * has at least one column that is BLOB/CLOB.
1:      * @return True if the result has at least one blob/clob
1:      *  column; false otherwise.
1:      ****/
0:     protected boolean hasLobColumns() throws SQLException
1:     {
1:         ResultSetMetaData rsmd = rs.getMetaData();
1:         int ncols = rsmd.getColumnCount();
1:         for (int i = 1; i <= ncols; i++)
1:         {
1:             int type = rsmd.getColumnType(i);
1:             if (type == Types.BLOB || type == Types.CLOB)
1:                 return true;
1:         }
1:         return false;
1:     }
1:     /**
1:      * Get the cursor name for the ResultSet
1:      */
1:     public String getResultSetCursorName() throws SQLException
1:     {
1:         if (rs != null)
1:             return rs.getCursorName();
1:         else 
1:             return null;
1:     }
1:     protected int getQryprctyp()
1:         throws SQLException
1:     {
1:         if (!gotPrctyp && qryprctyp == CodePoint.LMTBLKPRC)
1:         {
1:             gotPrctyp = true;
1:             if (rs == null || ((EngineResultSet)rs).isForUpdate() ||
1:                 /* for now we are not supporting LOB under LMTBLKPRC.  drda spec only
1:                  * disallows LOB under LMTBLKPRC if OUTOVR is also for ANY CNTQRY reply.
1:                  * To support LOB, QRYDTA protocols for LOB will need to be changed.
1:                  */
1:                 hasLobColumns())
1:             {
1:                 qryprctyp = CodePoint.FIXROWPRC;
1:             }
1:         }
1:         return qryprctyp;
1:     }
1:     protected void setQryprctyp(int qryprctyp)
1:     {
1:         this.qryprctyp = qryprctyp;
1:     }
1:     /**
1:      * is ResultSet closed
1:      * @return whether the resultSet  is closed
1:      */
1:     protected boolean isClosed()
1:     {
1:         return (state == NOT_OPENED);
1:     }
1:     /**
1:      * Set state to SUSPENDED (result set is opened)
1:      */
1:     protected void suspend()
1:     {
1:         state = SUSPENDED;
1:     }
1:     protected String toDebugString(String indent)
1:     {
1:         String s = indent + "***** DRDASResultSet toDebugString ******\n";
1:         s += indent + "State:" + getStateString(state)+ "\n";
1:         s += indent + "pkgcnstkn: {" + pkgcnstkn + "}\n"; 
1:         s += indent + "cursor Name: ";
1:         String cursorName = null;
1:         try {
1:             if (rs != null)
1:                 cursorName = rs.getCursorName();
1:         }
1:         catch (SQLException se )
1:         {
1:             cursorName = "invalid rs";
1:         }
1:         s += indent + cursorName + "\n";
1:            
1:         return s;
1:     }
1:     private String getStateString( int i )
1:     {
1:         switch (i)
1:         {
1:             case NOT_OPENED:
1:                 return "NOT_OPENED";
1:             case SUSPENDED:
1:                 return "SUSPENDED";
1:             default:
1:                 return "UNKNOWN_STATE";
1:         }
1:     }
1:     
1:     /**
1:      * Sets the OPNQRYOptions. For more information on the meaning of these
1:      * values consult the DRDA Technical Standard document. 
1:      * 
1:      * @param blksize Query block Size
1:      * @param qryblkctl Use to set the query protocol type
1:      * @param maxblkext Maximum number of extra blocks
1:      * @param outovropt Output override option
1:      * @param qryrowset Query row set
1:      * @param qryclsimpl Implicit query close setting
1:      */
1:     protected void setOPNQRYOptions(int blksize, int qryblkctl,
1:             int maxblkext, int outovropt,int qryrowset,int qryclsimpl)
1:     {
1:         this.blksize = blksize;
1:         setQryprctyp(qryblkctl);
1:         this.maxblkext = maxblkext;
1:         this.outovropt = outovropt;
1:         this.qryrowset = qryrowset;
1:         this.qryclsimp = (qryclsimpl == CodePoint.QRYCLSIMP_SERVER_CHOICE)
1:             ? DRDAResultSet.QRYCLSIMP_DEFAULT : qryclsimpl;
0:         // Assume that we are returning data until a CNTQRY command
0:         // tells us otherwise. (DERBY-822)
0:         qryrtndta = true;
0:         // For scrollable result sets, we don't know the fetch
0:         // orientation until we get a CNTQRY command. Set orientation
0:         // and row number to make pre-fetching possible. (DERBY-822)
0:         qryscrorn = CodePoint.QRYSCRREL;
0:         qryrownbr = 1;
1:     }
commit:f0dcf0b
/////////////////////////////////////////////////////////////////////////
0: 	//NOTE!
0: 	//
0: 	// Since DRDAResultSets are reused, ALL variables should be set 
0: 	// to their default values in reset().
/////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * This method closes the JDBC objects and frees up all references held by
0: 	 * this object.
0: 	 * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1: 	}
1: 	
0: 	/**
0: 	 * This method resets the state of this DRDAResultset object so that it can
0: 	 * be re-used. This method should reset all variables of this class.
0: 	 * 
1: 	 */
0: 	protected void reset() {
0: 		explicitlyClosed = false;
0: 		state = NOT_OPENED;
0: 		rsLens = null;
0: 		rsDRDATypes = null;
0: 		rsPrecision = null;
0: 		rsScale = null;
1: 		
0: 		outovr_drdaType = null;
1: 		
0: 		withHoldCursor = 0;	
0: 		scrollType = ResultSet.TYPE_FORWARD_ONLY;
0: 		concurType = 0;
0: 		rowCount = 0;
0: 		rs = null;
1: 		
0: 		blksize = 0;
0: 		maxblkext = 0;	
0: 		outovropt = 0;
0: 		qryclsimp = CodePoint.QRYCLSIMP_NO;	
0: 		qryrelscr = false;
0: 		qryrownbr = 0;
0: 		qryrfrtbl = false;	
0: 		qryscrorn = 0;
0: 		qryrowsns = false; 
0: 		qryblkrst = false;
0: 		qryrtndta = false;	
0: 		qryrowset = 0;
0: 		qryprctyp = 0;
0: 		gotPrctyp = false; 	
0: 		rtnextdta = 0;	
0: 		nbrrow = 0;
0: 		rslsetflg = null;	
1: 
0: 		extDtaObjects = null;
0: 		rsExtPositions = null;
0: 		pkgcnstkn = null;
0: 		splitQRYDTA = null;	
commit:6bfbcd6
/////////////////////////////////////////////////////////////////////////
0: 		splitQRYDTA = null;
commit:41f1df9
/////////////////////////////////////////////////////////////////////////
0: 	// splitQRYDTA is normally null. If it is non-null, it means that
0: 	// the last QRYDTA response which was sent for this statement was
0: 	// split according to the LMTBLKPRC protocol, and this array contains
0: 	// the bytes that didn't fit. These bytes should be the first bytes
0: 	// emitted in the next QRYDTA response to a CNTQRY request.
0: 	private byte []splitQRYDTA;
1: 
/////////////////////////////////////////////////////////////////////////
0: 	public void setSplitQRYDTA(byte []data)
1: 	{
0: 		splitQRYDTA = data;
1: 	}
0: 	public byte[]getSplitQRYDTA()
1: 	{
0: 		return splitQRYDTA;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
0: }
commit:82c7dde
/////////////////////////////////////////////////////////////////////////
commit:9ce79e7
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
0: 	public static final int QRYCLSIMP_DEFAULT = CodePoint.QRYCLSIMP_NO;  
1: 	
/////////////////////////////////////////////////////////////////////////
0: 	private int qryclsimp; // Implicit Query Close Setting
/////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Method to decide weather the ResultSet should be closed implicitly.
0: 	 * When the protocol type is Limited Block Query Protocol we should not
0: 	 * close implicitly even if qryclsimp is set to YES.
0: 	 * 
0: 	 * @return close implicit boolean
0: 	 * @throws SQLException
1: 	 */
0: 	boolean isRSCloseImplicit() throws SQLException {
0: 		return qryclsimp == CodePoint.QRYCLSIMP_YES && 
0: 			getQryprctyp() != CodePoint.LMTBLKPRC;
0: 	}
1: 	
0: 	/**
0: 	 * Sets the OPNQRYOptions. For more information on the meaning of these
0: 	 * values consult the DRDA Technical Standard document. 
0: 	 * 
0: 	 * @param blksize Query block Size
0: 	 * @param qryblkctl Use to set the query protocol type
0: 	 * @param maxblkext Maximum number of extra blocks
0: 	 * @param outovropt Output override option
0: 	 * @param qryrowset Query row set
0: 	 * @param qryclsimpl Implicit query close setting
1: 	 */
0: 	protected void setOPNQRYOptions(int blksize, int qryblkctl,
0: 			int maxblkext, int outovropt,int qryrowset,int qryclsimpl)
0: 	{
0: 		this.blksize = blksize;
0: 		setQryprctyp(qryblkctl);
0: 		this.maxblkext = maxblkext;
0: 		this.outovropt = outovropt;
0: 		this.qryrowset = qryrowset;
0: 		this.qryclsimp = (qryclsimpl == CodePoint.QRYCLSIMP_SERVER_CHOICE)
0: 			? DRDAResultSet.QRYCLSIMP_DEFAULT : qryclsimpl;
0: 	}
0: }
commit:4383496
/////////////////////////////////////////////////////////////////////////
0: 	protected int scrollType = ResultSet.TYPE_FORWARD_ONLY;			// Sensitive or Insensitive scroll attribute
/////////////////////////////////////////////////////////////////////////
0: 		scrollType = ResultSet.TYPE_FORWARD_ONLY;	
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:94df7fb
/////////////////////////////////////////////////////////////////////////
1: 
1:         // if there is no type information, then we represent a CallableStatement
1:         // and all parameters are nullable
1:         if ( rsDRDATypes == null ) { return true; }
0: 		else if (FdocaConstants.isNullable(getRsDRDAType(colnum)))
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:efb1bd2
/////////////////////////////////////////////////////////////////////////
0: 	void setResultSet(ResultSet value) throws SQLException
0: 		int numCols= rs.getMetaData().getColumnCount();
0: 		rsDRDATypes = new int[numCols];
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:7df5ffe
/////////////////////////////////////////////////////////////////////////
0: 	DRDAResultSet()
commit:d7258ed
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.drda.DRDAResultSet
1: 
0:    Copyright 2003, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:141cd31
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
0:  */
1: 
1: package org.apache.derby.impl.drda;
1: 
0: import java.lang.reflect.*;
1: 
0: import java.sql.Connection;
0: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
0: import java.sql.Statement;
1: import java.sql.ResultSetMetaData;
0: import java.sql.Types;
1: import java.sql.SQLException;
1: 
1: import java.util.ArrayList;
0: import java.util.StringTokenizer;
0: import java.util.Vector;
1: 
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.impl.jdbc.Util;
0: import org.apache.derby.impl.jdbc.EmbedResultSet;
0: import org.apache.derby.impl.jdbc.EmbedPreparedStatement;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.impl.jdbc.EmbedSQLException;
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: /**
0: 	DRDAResultSet holds result set information
0: */
1: class DRDAResultSet
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
1: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
1: 
0: 	// resultSet states are NOT_OPENED and SUSPENDED
0: 	protected static final int NOT_OPENED = 1;
0: 	protected static final int SUSPENDED = 2;
1: 
0: 	boolean explicitlyClosed = false;
1: 
0: 	int state;
0: 	protected boolean hasdata = true;
0: 	protected int[] rsLens;				// result length for each column
0: 	private int[] rsDRDATypes;			// DRDA Types of the result set columns
0: 	private int[] rsPrecision;         // result precision for Decimal types
0: 	private int[] rsScale;              // result sale for Decimal types
1: 
0: 	protected int [] outovr_drdaType;	// Output override DRDA type and length
1: 
0: 	protected int withHoldCursor;			// hold cursor after commit attribute
0: 	protected int scrollType;			// Sensitive or Insensitive scroll attribute
0: 	protected int concurType;			// Concurency type
0: 	protected long rowCount;			// Number of rows we have processed
0: 	private ResultSet rs;              // Current ResultSet
1: 
0: 	protected int blksize;				// Query block size
0: 	protected int maxblkext;			// Maximum number of extra blocks
0: 	protected int outovropt;			// Output Override option
0: 	protected int qryclsimp;            // Implicit Query Close Setting
0: 	protected boolean qryrelscr;		// Query relative scrolling
0: 	protected long qryrownbr;			// Query row number
0: 	protected boolean qryrfrtbl;		// Query refresh answer set table
0: 	protected int qryscrorn;			// Query scroll orientation
0: 	protected boolean qryrowsns;		// Query row sensitivity
0: 	protected boolean qryblkrst;		// Query block reset
0: 	protected boolean qryrtndta;		// Query returns data
0: 	protected int qryrowset;			// Query row set
0: 	private   int qryprctyp;			// Protocol type
0: 	private   boolean gotPrctyp;		// save the result, for performance
0: 	protected int rtnextdta;			// Return of EXTDTA option
0: 	protected int nbrrow;			   // number of fetch or insert rows
0: 	protected byte [] rslsetflg;		// Result Set Flags
1: 
0: 	private ArrayList  extDtaObjects;  // Arraylist of Blobs and Clobs 
0: 	                                   // Return Values to 
0: 		                               // send with extdta objects.
1: 	
0: 	private ArrayList rsExtPositions;
1: 
0: 	protected String pkgcnstknStr;               // Unique consistency token for ResultSet 0
1: 
1: 
1: 
0: 	protected DRDAResultSet(ResultSet rs) throws SQLException
0: 	{
0: 		setResultSet(rs);
0: 		state = NOT_OPENED;
0: 	}
1: 
0: 	protected DRDAResultSet()
0: 	{
0: 		state = NOT_OPENED;
0: 	}
1: 
0: 	/**
0:  	 * Set result set and initialize type array.
0: 	 *
0: 	 * @param value
0: 	 * 
0: 	 */
1: 
0: 	protected void setResultSet(ResultSet value) throws SQLException
0: 	{
0: 		int numCols;
0: 		rs = value;
0: 		gotPrctyp = false;
0: 		if (value != null)
0: 		{
0: 		    numCols= rs.getMetaData().getColumnCount();
0: 			rsDRDATypes = new int[numCols];
0: 		}
0: 		explicitlyClosed = false;
0: 	}
1: 
1: 
0: 	/**
0: 	 * set consistency token for this resultSet
0: 	 *
0: 	 */
0: 	protected void setPkgcnstknStr(String pkgcnstknStr)
0: 	{
0: 		this.pkgcnstknStr = pkgcnstknStr;
0: 	}
1: 
1: 
0: 	/**
0: 	 * 
0: 	 *  @return the underlying java.sql.ResultSet
0: 	 */
0: 	protected ResultSet getResultSet()
0: 	{
0: 		return rs;
0: 	}
1: 
0: 	/** 
0: 	 * Set ResultSet DRDA DataTypes
0: 	 * @param drddaTypes for columns.
0: 	 **/
0: 	protected void setRsDRDATypes(int [] value)
0: 	{
0: 		rsDRDATypes = value;
1: 
0: 	}
1: 
0: 	/**
0: 	 *@return ResultSet DRDA DataTypes
0: 	 **/
1: 
0: 	protected int[] getRsDRDATypes()
0: 	{
0: 		// use the given override if it is present
0: 		if (outovr_drdaType != null)
0: 			return outovr_drdaType;
0: 		return rsDRDATypes;
0: 	}
1: 
0: 	/**
0: 	 * set resultset/out parameter precision
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @param precision
0: 	 */
0: 	protected void setRsPrecision(int index, int precision)
0: 	{
0: 		if (rsPrecision == null)
0: 			rsPrecision = new int[rsDRDATypes.length];
0: 		rsPrecision[index -1] = precision;
0: 	}
1: 
0: 	/**
0: 	 * get resultset /out paramter precision
0: 	 * @param index -starting with 1
0: 	 * @return precision of column
0: 	 */
0: 	protected int getRsPrecision(int index)
0: 	{
0: 		if (rsPrecision == null)
0: 			return 0;
0: 		return rsPrecision[index-1];
0: 	}
1: 
0: 	/**
0: 	 * set resultset/out parameter scale
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @param scale
0: 	 */
0: 	protected void setRsScale(int index, int scale)
0: 	{
0: 		if (rsScale == null)
0: 			rsScale = new int[rsDRDATypes.length];
0: 		rsScale[index-1] = scale;
0: 	}
1: 
0: 	/**
0: 	 * get resultset /out paramter scale
0: 	 * @param index -starting with 1
0: 	 * @return scale of column
0: 	 */
0: 	protected int  getRsScale(int index)
0: 	{
0: 		if (rsScale == null)
0: 			return 0;
1: 		
0: 		return rsScale[index -1];
0: 	}
1: 	
1: 	
0: 	/**
0: 	 * set resultset/out parameter DRDAType
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @param type
0: 	 */
0: 	protected  void setRsDRDAType(int index, int type)
0: 	{
0: 		rsDRDATypes[index -1] =  type;
1: 		
0: 	}
1: 	
0: 	/**
0: 	 * get  resultset/out parameter DRDAType
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @return  DRDA Type of column
0: 	 */
0: 	protected int getRsDRDAType(int index)
0: 	{
1: 		return rsDRDATypes[index -1];
0: 	}
1: 	
1: 
0: 	/**
0: 	 * set resultset DRDA Len
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @param value
0: 	 */
0: 	protected  void setRsLen(int index, int value)
0: 	{
0: 		if (rsLens == null)
0: 			rsLens = new int[rsDRDATypes.length];
0: 		rsLens[index -1] = value;
1: 		
0: 	}
1: 	
0: 	/**
0: 	 * get  resultset  DRDALen
0: 	 * @param index - starting with 1
0: 	 * @return  length of column value
0: 	 */
0: 	protected int getRsLen(int index)
0: 	{
0: 		return rsLens[index -1];
0: 	}
1: 	
1: 
0: 	/**
0: 	 * Add extDtaObject
0: 	 * @param o - object to  add
0: 	 */
0: 	protected void  addExtDtaObject (Object o, int jdbcIndex )
0: 	{
0: 		if (extDtaObjects == null)
0: 			extDtaObjects = new java.util.ArrayList();
0: 		extDtaObjects.add (o);
1: 
0: 		if (rsExtPositions == null)
0: 			rsExtPositions = new java.util.ArrayList();
1: 		
0: 		// need to record the 0 based position so subtract 1
0: 		rsExtPositions.add (new Integer(jdbcIndex -1 ));
1: 
0: 	}
1: 
1: 
0: 	/**
0: 	 * Clear externalized lob objects in current result set
0: 	 */
0: 	protected void  clearExtDtaObjects ()
0: 	{
0: 		if (extDtaObjects != null)
0: 			extDtaObjects.clear();
0: 		if (rsExtPositions != null)
0: 			rsExtPositions.clear();
1: 		
0: 	}
1: 	
1: 	/*
0: 	 * Is lob object nullable
0: 	 * @param index - offset starting with 0
0: 	 * @return true if object is nullable
0: 	 */
0: 	protected boolean isExtDtaValueNullable(int index)
0: 	{
0: 		if ((rsExtPositions == null) || 
0: 			rsExtPositions.get(index) == null)
0: 			return false;
1: 		
1: 
0: 		int colnum = ((Integer) rsExtPositions.get(index)).intValue();
1: 		
0: 		if (FdocaConstants.isNullable((getRsDRDATypes())[colnum]))
0: 			return true;
0: 		else 
0: 			return false;
0: 	}
1: 	
1: 
0: 	/**
0: 	 * Get the extData Objects
0: 	 *
0: 	 *  @return ArrayList with extdta
0: 	 */
0: 	protected ArrayList getExtDtaObjects()
0: 	{
0: 		return extDtaObjects;
0: 	}
1: 
0: 	/**
0: 	 * Set the extData Objects
0: 	 *
0: 	 *  @return ArrayList with extdta
0: 	 */
0: 	protected void  setExtDtaObjects(ArrayList a)
0: 	{
0: 		extDtaObjects =a;
0: 	}
1: 	
1: 	
0: 	/** Clean up statements and resultSet
0: 	 * 
0: 	 */
0: 	protected void close()  throws SQLException
0: 	{
0: 		if (rs != null)
0: 			rs.close();
0: 		rs = null;
0: 		gotPrctyp = false;
0: 		outovr_drdaType = null;
0: 		scrollType = 0;
0: 		concurType = 0;
0: 		rowCount = 0;
0: 		rsLens = null;
0: 		rsDRDATypes = null;
0: 		rsPrecision = null;
0: 		rsScale = null;
0: 		extDtaObjects = null;
0: 		rsExtPositions = null;
0: 		state=NOT_OPENED;
0: 		hasdata = true;
0: 	}
1: 
1: 
0: 	/**
0: 	 * Explicitly close the result set by CLSQRY
0: 	 * needed to check for double close.
0: 	 */
0: 	protected void CLSQRY()
0: 	{
0: 		explicitlyClosed = true;
0: 	}
1: 
1: 	/* 
0: 	 * @return whether CLSQRY has been called on the
0: 	 *         current result set.
0: 	 */
0: 	protected boolean wasExplicitlyClosed()
0: 	{
0: 		return explicitlyClosed;
0: 	}
1: 
1: 
0: 	/****
0: 	 * Check to see if the result set for this statement
0: 	 * has at least one column that is BLOB/CLOB.
0: 	 * @return True if the result has at least one blob/clob
0: 	 *  column; false otherwise.
0: 	 ****/
1:  
0: 	private boolean hasLobColumns()	throws SQLException
0: 	{
0: 		ResultSetMetaData rsmd = rs.getMetaData();
0: 		int ncols = rsmd.getColumnCount();
0: 		for (int i = 1; i <= ncols; i++)
0: 		{
0: 			int type = rsmd.getColumnType(i);
0: 			if (type == Types.BLOB || type == Types.CLOB)
0: 				return true;
0: 		}
0: 		return false;
0: 	}
1: 
0: 	/**
0: 	 * Get the cursor name for the ResultSet
0: 	 */
0: 	public String getResultSetCursorName() throws SQLException
0: 	{
1: 
0: 		if (rs != null)
0: 			return rs.getCursorName();
0: 		else 
0: 			return null;
0: 	}
1: 
0: 	protected int getQryprctyp()
0: 		throws SQLException
0: 	{
0: 		if (!gotPrctyp && qryprctyp == CodePoint.LMTBLKPRC)
0: 		{
0: 			gotPrctyp = true;
0: 			if (rs == null || ((EmbedResultSet) rs).isForUpdate() ||
0: 				/* for now we are not supporting LOB under LMTBLKPRC.  drda spec only
0: 				 * disallows LOB under LMTBLKPRC if OUTOVR is also for ANY CNTQRY reply.
0: 				 * To support LOB, QRYDTA protocols for LOB will need to be changed.
0: 				 */
0: 				hasLobColumns())
0: 			{
0: 				qryprctyp = CodePoint.FIXROWPRC;
0: 			}
0: 		}
0: 		return qryprctyp;
0: 	}
1: 
0: 	protected void setQryprctyp(int qryprctyp)
0: 	{
0: 		this.qryprctyp = qryprctyp;
0: 	}
1: 
0: 	/**
0: 	 * is ResultSet closed
0: 	 * @return whether the resultSet  is closed
0: 	 */
0: 	protected boolean isClosed()
0: 	{
0: 		return (state == NOT_OPENED);
0: 	}
1: 
0: 	/**
0: 	 * Set state to SUSPENDED (result set is opened)
0: 	 */
0: 	protected void suspend()
0: 	{
0: 		state = SUSPENDED;
0: 	}
1: 
1: 
0: 	protected String toDebugString(String indent)
0: 	{
0: 		String s = indent + "***** DRDASResultSet toDebugString ******\n";
0: 		s += indent + "State:" + getStateString(state)+ "\n";
0: 		s += indent + "pkgcnstknStr: {" +pkgcnstknStr  + "}\n"; 
0: 		s += indent + "cursor Name: ";
0: 		String cursorName = null;
0: 		try {
0: 			if (rs != null)
0: 				cursorName = rs.getCursorName();
0: 		}
0: 		catch (SQLException se )
0: 		{
0: 			cursorName = "invalid rs";
0: 		}
0: 		s += indent + cursorName + "\n";
1: 		   
0: 		return s;
0: 	}
1: 
1: 
0: 	private String getStateString( int i )
0: 	{
0: 		switch (i)
0: 		{
0: 			case NOT_OPENED:
0: 				return "NOT_OPENED";
0: 			case SUSPENDED:
0: 				return "SUSPENDED";
0: 			default:
0: 				return "UNKNOWN_STATE";
0: 		}
1: 
0: 	}
0: }
1: 	
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:ad7199e
/////////////////////////////////////////////////////////////////////////
1:         if ((outovr_drdaType != null) && (outovr_drdaType[index-1] != 0)) {
1:             // Override with requested type.  0 means use default
1:             return outovr_drdaType[index-1];
0:         }
0:         return rsDRDATypes[index -1];
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59e5225
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:f0b0870
/////////////////////////////////////////////////////////////////////////
0: 	 * @param value drdaTypes for columns.
author:David Van Couvering
-------------------------------------------------------------------------------
commit:886b5f8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.EngineResultSet;
/////////////////////////////////////////////////////////////////////////
0: 			if (rs == null || ((EngineResultSet)rs).isForUpdate() ||
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:5e88312
/////////////////////////////////////////////////////////////////////////
0: 	protected int qryclsimp;			// Implicit Query Close Setting
/////////////////////////////////////////////////////////////////////////
0: 		// Initialize qryclsimp to NO. Only result sets requested by
0: 		// an OPNQRY command should be implicitly closed. OPNQRY will
0: 		// set qryclsimp later in setOPNQRYOptions().
0: 		qryclsimp = CodePoint.QRYCLSIMP_NO;
/////////////////////////////////////////////////////////////////////////
commit:ee2a860
/////////////////////////////////////////////////////////////////////////
0: 	protected ConsistencyToken pkgcnstkn; // Unique consistency token for ResultSet 0
/////////////////////////////////////////////////////////////////////////
0: 	protected void setPkgcnstkn(ConsistencyToken pkgcnstkn)
0: 		this.pkgcnstkn = pkgcnstkn;
/////////////////////////////////////////////////////////////////////////
0: 		s += indent + "pkgcnstkn: {" + pkgcnstkn + "}\n"; 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.drda;
0: 
0: import java.lang.reflect.*;
0: 
0: import java.sql.Connection;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.Statement;
0: import java.sql.ResultSetMetaData;
0: import java.sql.Types;
0: import java.sql.SQLException;
0: 
0: import java.util.ArrayList;
0: import java.util.StringTokenizer;
0: import java.util.Vector;
0: 
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.impl.jdbc.Util;
0: import org.apache.derby.impl.jdbc.EmbedResultSet;
0: import org.apache.derby.impl.jdbc.EmbedPreparedStatement;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.impl.jdbc.EmbedSQLException;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: /**
0: 	DRDAResultSet holds result set information
0: */
0: class DRDAResultSet
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
0: 
0: 	// resultSet states are NOT_OPENED and SUSPENDED
0: 	protected static final int NOT_OPENED = 1;
0: 	protected static final int SUSPENDED = 2;
0: 
0: 	boolean explicitlyClosed = false;
0: 
0: 	int state;
0: 	protected boolean hasdata = true;
0: 	protected int[] rsLens;				// result length for each column
0: 	private int[] rsDRDATypes;			// DRDA Types of the result set columns
0: 	private int[] rsPrecision;         // result precision for Decimal types
0: 	private int[] rsScale;              // result sale for Decimal types
0: 
0: 	protected int [] outovr_drdaType;	// Output override DRDA type and length
0: 
0: 	protected int withHoldCursor;			// hold cursor after commit attribute
0: 	protected int scrollType;			// Sensitive or Insensitive scroll attribute
0: 	protected int concurType;			// Concurency type
0: 	protected long rowCount;			// Number of rows we have processed
0: 	private ResultSet rs;              // Current ResultSet
0: 
0: 	protected int blksize;				// Query block size
0: 	protected int maxblkext;			// Maximum number of extra blocks
0: 	protected int outovropt;			// Output Override option
0: 	protected int qryclsimp;            // Implicit Query Close Setting
0: 	protected boolean qryrelscr;		// Query relative scrolling
0: 	protected long qryrownbr;			// Query row number
0: 	protected boolean qryrfrtbl;		// Query refresh answer set table
0: 	protected int qryscrorn;			// Query scroll orientation
0: 	protected boolean qryrowsns;		// Query row sensitivity
0: 	protected boolean qryblkrst;		// Query block reset
0: 	protected boolean qryrtndta;		// Query returns data
0: 	protected int qryrowset;			// Query row set
0: 	private   int qryprctyp;			// Protocol type
0: 	private   boolean gotPrctyp;		// save the result, for performance
0: 	protected int rtnextdta;			// Return of EXTDTA option
0: 	protected int nbrrow;			   // number of fetch or insert rows
0: 	protected byte [] rslsetflg;		// Result Set Flags
0: 
0: 	private ArrayList  extDtaObjects;  // Arraylist of Blobs and Clobs 
0: 	                                   // Return Values to 
0: 		                               // send with extdta objects.
0: 	
0: 	private ArrayList rsExtPositions;
0: 
0: 	protected String pkgcnstknStr;               // Unique consistency token for ResultSet 0
0: 
0: 
0: 
0: 	protected DRDAResultSet(ResultSet rs) throws SQLException
0: 	{
0: 		setResultSet(rs);
0: 		state = NOT_OPENED;
0: 	}
0: 
0: 	protected DRDAResultSet()
0: 	{
0: 		state = NOT_OPENED;
0: 	}
0: 
0: 	/**
0:  	 * Set result set and initialize type array.
0: 	 *
0: 	 * @param value
0: 	 * 
0: 	 */
0: 
0: 	protected void setResultSet(ResultSet value) throws SQLException
0: 	{
0: 		int numCols;
0: 		rs = value;
0: 		gotPrctyp = false;
0: 		if (value != null)
0: 		{
0: 		    numCols= rs.getMetaData().getColumnCount();
0: 			rsDRDATypes = new int[numCols];
0: 		}
0: 		explicitlyClosed = false;
0: 	}
0: 
0: 
0: 	/**
0: 	 * set consistency token for this resultSet
0: 	 *
0: 	 */
0: 	protected void setPkgcnstknStr(String pkgcnstknStr)
0: 	{
0: 		this.pkgcnstknStr = pkgcnstknStr;
0: 	}
0: 
0: 
0: 	/**
0: 	 * 
0: 	 *  @return the underlying java.sql.ResultSet
0: 	 */
0: 	protected ResultSet getResultSet()
0: 	{
0: 		return rs;
0: 	}
0: 
0: 	/** 
0: 	 * Set ResultSet DRDA DataTypes
0: 	 * @param drddaTypes for columns.
0: 	 **/
0: 	protected void setRsDRDATypes(int [] value)
0: 	{
0: 		rsDRDATypes = value;
0: 
0: 	}
0: 
0: 	/**
0: 	 *@return ResultSet DRDA DataTypes
0: 	 **/
0: 
0: 	protected int[] getRsDRDATypes()
0: 	{
0: 		// use the given override if it is present
0: 		if (outovr_drdaType != null)
0: 			return outovr_drdaType;
0: 		return rsDRDATypes;
0: 	}
0: 
0: 	/**
0: 	 * set resultset/out parameter precision
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @param precision
0: 	 */
0: 	protected void setRsPrecision(int index, int precision)
0: 	{
0: 		if (rsPrecision == null)
0: 			rsPrecision = new int[rsDRDATypes.length];
0: 		rsPrecision[index -1] = precision;
0: 	}
0: 
0: 	/**
0: 	 * get resultset /out paramter precision
0: 	 * @param index -starting with 1
0: 	 * @return precision of column
0: 	 */
0: 	protected int getRsPrecision(int index)
0: 	{
0: 		if (rsPrecision == null)
0: 			return 0;
0: 		return rsPrecision[index-1];
0: 	}
0: 
0: 	/**
0: 	 * set resultset/out parameter scale
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @param scale
0: 	 */
0: 	protected void setRsScale(int index, int scale)
0: 	{
0: 		if (rsScale == null)
0: 			rsScale = new int[rsDRDATypes.length];
0: 		rsScale[index-1] = scale;
0: 	}
0: 
0: 	/**
0: 	 * get resultset /out paramter scale
0: 	 * @param index -starting with 1
0: 	 * @return scale of column
0: 	 */
0: 	protected int  getRsScale(int index)
0: 	{
0: 		if (rsScale == null)
0: 			return 0;
0: 		
0: 		return rsScale[index -1];
0: 	}
0: 	
0: 	
0: 	/**
0: 	 * set resultset/out parameter DRDAType
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @param type
0: 	 */
0: 	protected  void setRsDRDAType(int index, int type)
0: 	{
0: 		rsDRDATypes[index -1] =  type;
0: 		
0: 	}
0: 	
0: 	/**
0: 	 * get  resultset/out parameter DRDAType
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @return  DRDA Type of column
0: 	 */
0: 	protected int getRsDRDAType(int index)
0: 	{
0: 		return rsDRDATypes[index -1];
0: 	}
0: 	
0: 
0: 	/**
0: 	 * set resultset DRDA Len
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @param value
0: 	 */
0: 	protected  void setRsLen(int index, int value)
0: 	{
0: 		if (rsLens == null)
0: 			rsLens = new int[rsDRDATypes.length];
0: 		rsLens[index -1] = value;
0: 		
0: 	}
0: 	
0: 	/**
0: 	 * get  resultset  DRDALen
0: 	 * @param index - starting with 1
0: 	 * @return  length of column value
0: 	 */
0: 	protected int getRsLen(int index)
0: 	{
0: 		return rsLens[index -1];
0: 	}
0: 	
0: 
0: 	/**
0: 	 * Add extDtaObject
0: 	 * @param o - object to  add
0: 	 */
0: 	protected void  addExtDtaObject (Object o, int jdbcIndex )
0: 	{
0: 		if (extDtaObjects == null)
0: 			extDtaObjects = new java.util.ArrayList();
0: 		extDtaObjects.add (o);
0: 
0: 		if (rsExtPositions == null)
0: 			rsExtPositions = new java.util.ArrayList();
0: 		
0: 		// need to record the 0 based position so subtract 1
0: 		rsExtPositions.add (new Integer(jdbcIndex -1 ));
0: 
0: 	}
0: 
0: 
0: 	/**
0: 	 * Clear externalized lob objects in current result set
0: 	 */
0: 	protected void  clearExtDtaObjects ()
0: 	{
0: 		if (extDtaObjects != null)
0: 			extDtaObjects.clear();
0: 		if (rsExtPositions != null)
0: 			rsExtPositions.clear();
0: 		
0: 	}
0: 	
0: 	/*
0: 	 * Is lob object nullable
0: 	 * @param index - offset starting with 0
0: 	 * @return true if object is nullable
0: 	 */
0: 	protected boolean isExtDtaValueNullable(int index)
0: 	{
0: 		if ((rsExtPositions == null) || 
0: 			rsExtPositions.get(index) == null)
0: 			return false;
0: 		
0: 
0: 		int colnum = ((Integer) rsExtPositions.get(index)).intValue();
0: 		
0: 		if (FdocaConstants.isNullable((getRsDRDATypes())[colnum]))
0: 			return true;
0: 		else 
0: 			return false;
0: 	}
0: 	
0: 
0: 	/**
0: 	 * Get the extData Objects
0: 	 *
0: 	 *  @return ArrayList with extdta
0: 	 */
0: 	protected ArrayList getExtDtaObjects()
0: 	{
0: 		return extDtaObjects;
0: 	}
0: 
0: 	/**
0: 	 * Set the extData Objects
0: 	 *
0: 	 *  @return ArrayList with extdta
0: 	 */
0: 	protected void  setExtDtaObjects(ArrayList a)
0: 	{
0: 		extDtaObjects =a;
0: 	}
0: 	
0: 	
0: 	/** Clean up statements and resultSet
0: 	 * 
0: 	 */
0: 	protected void close()  throws SQLException
0: 	{
0: 		if (rs != null)
0: 			rs.close();
0: 		rs = null;
0: 		gotPrctyp = false;
0: 		outovr_drdaType = null;
0: 		scrollType = 0;
0: 		concurType = 0;
0: 		rowCount = 0;
0: 		rsLens = null;
0: 		rsDRDATypes = null;
0: 		rsPrecision = null;
0: 		rsScale = null;
0: 		extDtaObjects = null;
0: 		rsExtPositions = null;
0: 		state=NOT_OPENED;
0: 		hasdata = true;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Explicitly close the result set by CLSQRY
0: 	 * needed to check for double close.
0: 	 */
0: 	protected void CLSQRY()
0: 	{
0: 		explicitlyClosed = true;
0: 	}
0: 
0: 	/* 
0: 	 * @return whether CLSQRY has been called on the
0: 	 *         current result set.
0: 	 */
0: 	protected boolean wasExplicitlyClosed()
0: 	{
0: 		return explicitlyClosed;
0: 	}
0: 
0: 
0: 	/****
0: 	 * Check to see if the result set for this statement
0: 	 * has at least one column that is BLOB/CLOB.
0: 	 * @return True if the result has at least one blob/clob
0: 	 *  column; false otherwise.
0: 	 ****/
0:  
0: 	private boolean hasLobColumns()	throws SQLException
0: 	{
0: 		ResultSetMetaData rsmd = rs.getMetaData();
0: 		int ncols = rsmd.getColumnCount();
0: 		for (int i = 1; i <= ncols; i++)
0: 		{
0: 			int type = rsmd.getColumnType(i);
0: 			if (type == Types.BLOB || type == Types.CLOB)
0: 				return true;
0: 		}
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Get the cursor name for the ResultSet
0: 	 */
0: 	public String getResultSetCursorName() throws SQLException
0: 	{
0: 
0: 		if (rs != null)
0: 			return rs.getCursorName();
0: 		else 
0: 			return null;
0: 	}
0: 
0: 	protected int getQryprctyp()
0: 		throws SQLException
0: 	{
0: 		if (!gotPrctyp && qryprctyp == CodePoint.LMTBLKPRC)
0: 		{
0: 			gotPrctyp = true;
0: 			if (rs == null || ((EmbedResultSet) rs).isForUpdate() ||
0: 				/* for now we are not supporting LOB under LMTBLKPRC.  drda spec only
0: 				 * disallows LOB under LMTBLKPRC if OUTOVR is also for ANY CNTQRY reply.
0: 				 * To support LOB, QRYDTA protocols for LOB will need to be changed.
0: 				 */
0: 				hasLobColumns())
0: 			{
0: 				qryprctyp = CodePoint.FIXROWPRC;
0: 			}
0: 		}
0: 		return qryprctyp;
0: 	}
0: 
0: 	protected void setQryprctyp(int qryprctyp)
0: 	{
0: 		this.qryprctyp = qryprctyp;
0: 	}
0: 
0: 	/**
0: 	 * is ResultSet closed
0: 	 * @return whether the resultSet  is closed
0: 	 */
0: 	protected boolean isClosed()
0: 	{
0: 		return (state == NOT_OPENED);
0: 	}
0: 
0: 	/**
0: 	 * Set state to SUSPENDED (result set is opened)
0: 	 */
0: 	protected void suspend()
0: 	{
0: 		state = SUSPENDED;
0: 	}
0: 
0: 
0: 	protected String toDebugString(String indent)
0: 	{
0: 		String s = indent + "***** DRDASResultSet toDebugString ******\n";
0: 		s += indent + "State:" + getStateString(state)+ "\n";
0: 		s += indent + "pkgcnstknStr: {" +pkgcnstknStr  + "}\n"; 
0: 		s += indent + "cursor Name: ";
0: 		String cursorName = null;
0: 		try {
0: 			if (rs != null)
0: 				cursorName = rs.getCursorName();
0: 		}
0: 		catch (SQLException se )
0: 		{
0: 			cursorName = "invalid rs";
0: 		}
0: 		s += indent + cursorName + "\n";
0: 		   
0: 		return s;
0: 	}
0: 
0: 
0: 	private String getStateString( int i )
0: 	{
0: 		switch (i)
0: 		{
0: 			case NOT_OPENED:
0: 				return "NOT_OPENED";
0: 			case SUSPENDED:
0: 				return "SUSPENDED";
0: 			default:
0: 				return "UNKNOWN_STATE";
0: 		}
0: 
0: 	}
0: }
0: 	
0: 
============================================================================