1:2bfe0a6: /*
1:2bfe0a6: 
1:626de50:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.OptimizerOverridesTest
1:2bfe0a6: 
1:2bfe0a6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2bfe0a6:    contributor license agreements.  See the NOTICE file distributed with
1:2bfe0a6:    this work for additional information regarding copyright ownership.
1:2bfe0a6:    The ASF licenses this file to You under the Apache License, Version 2.0
1:2bfe0a6:    (the "License"); you may not use this file except in compliance with
1:2bfe0a6:    the License.  You may obtain a copy of the License at
1:2bfe0a6: 
1:2bfe0a6:       http://www.apache.org/licenses/LICENSE-2.0
1:2bfe0a6: 
1:2bfe0a6:    Unless required by applicable law or agreed to in writing, software
1:2bfe0a6:    distributed under the License is distributed on an "AS IS" BASIS,
1:2bfe0a6:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:2bfe0a6:    See the License for the specific language governing permissions and
1:2bfe0a6:    limitations under the License.
1:2bfe0a6: 
1:2bfe0a6:  */
1:2bfe0a6: package org.apache.derbyTesting.functionTests.tests.lang;
1:2bfe0a6: 
1:2bfe0a6: import java.sql.PreparedStatement;
1:2bfe0a6: import java.sql.ResultSet;
1:2bfe0a6: import java.sql.SQLException;
1:2bfe0a6: import java.sql.Statement;
1:2bfe0a6: 
1:2bfe0a6: import junit.framework.Test;
1:2bfe0a6: 
1:2bfe0a6: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:2bfe0a6: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:2bfe0a6: import org.apache.derbyTesting.junit.JDBC;
1:2bfe0a6: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1:2bfe0a6: import org.apache.derbyTesting.junit.SQLUtilities;
1:2bfe0a6: import org.apache.derbyTesting.junit.TestConfiguration;
1:2bfe0a6: 
1:2bfe0a6: /**
1:2bfe0a6:  * Test the optimizer overrides.
1:2bfe0a6:  */
1:2bfe0a6: public class OptimizerOverridesTest extends BaseJDBCTestCase {
1:2bfe0a6:     private static final String[][] FULL_TABLE = 
1:2bfe0a6:         new String[][]{
1:2bfe0a6:         {"1", "1", "1"}, 
1:2bfe0a6:         {"2", "2", "2"},
1:2bfe0a6:         {"3", "3", "3"},
1:2bfe0a6:         {"4", "4", "4"},
1:2bfe0a6:     };
1:2bfe0a6:     
1:2bfe0a6:     public OptimizerOverridesTest(String name) {
1:2bfe0a6:         super(name);
1:2bfe0a6:     }
1:2bfe0a6:     
1:2bfe0a6:     public static Test suite(){
1:2bfe0a6:         Test suite = TestConfiguration.defaultSuite(
1:2bfe0a6:                 OptimizerOverridesTest.class, false);
1:2bfe0a6:         suite = new CleanDatabaseTestSetup(suite){
1:2bfe0a6:             
1:2bfe0a6:             /* Create tables, indices and views.
1:2bfe0a6:              * @see org.apache.derbyTesting.junit.CleanDatabaseTestSetup#decorateSQL(java.sql.Statement)
1:2bfe0a6:              */
1:2bfe0a6:             protected void decorateSQL(Statement st) throws SQLException {
1:2bfe0a6:                 st.getConnection().setAutoCommit(false);
1:2bfe0a6:                 
1:2bfe0a6:                 st.addBatch("create table t1 (c1 int, " +
1:2bfe0a6:                         "c2 int, c3 int," +
1:2bfe0a6:                         " constraint cons1 primary key(c1, c2))");
1:2bfe0a6:                 st.addBatch("create table t2 (c1 int not null, " +
1:2bfe0a6:                         "c2 int not null, c3 int, " +
1:2bfe0a6:                         "constraint cons2 unique(c1, c2))");
1:2bfe0a6:                 
1:2bfe0a6:                 st.addBatch("insert into t1 values (1, 1, 1), " +
1:2bfe0a6:                         "(2, 2, 2), (3, 3, 3), (4, 4, 4)");;
1:2bfe0a6:                 st.addBatch("insert into t2 values (1, 1, 1), " +
1:2bfe0a6:                         "(2, 2, 2), (3, 3, 3), (4, 4, 4)");
1:2bfe0a6:                 
1:2bfe0a6:                 st.addBatch("create index t1_c1c2c3 on t1(c1, c2, c3)");
1:2bfe0a6:                 st.addBatch("create index t1_c3c2c1 on t1(c3, c2, c1)");
1:2bfe0a6:                 st.addBatch("create index t1_c1 on t1(c1)");
1:2bfe0a6:                 st.addBatch("create index t1_c2 on t1(c2)");
1:2bfe0a6:                 st.addBatch("create index t1_c3 on t1(c3)");
1:2bfe0a6:                 st.addBatch("create index \"t1_c2c1\" on t1(c2, c1)");
1:2bfe0a6:                 st.addBatch("create index t2_c1c2c3 on t2(c1, c2, c3)");
1:2bfe0a6:                 st.addBatch("create index t2_c3c2c1 on t2(c3, c2, c1)");
1:2bfe0a6:                 st.addBatch("create index t2_c1 on t2(c1)");
1:2bfe0a6:                 st.addBatch("create index t2_c2 on t2(c2)");
1:2bfe0a6:                 st.addBatch("create index t2_c3 on t2(c3)");
1:2bfe0a6:                         
1:2bfe0a6:                 st.addBatch("create view v1 as select * from t1 " +
1:2bfe0a6:                         "--derby-properties index = t1_c1");
1:2bfe0a6:                 st.addBatch("create view v2 as select t1.* from t1, t2");
1:2bfe0a6:                 st.addBatch("create view v3 as select * from v1");
1:2bfe0a6:                 st.addBatch("create view neg_v1 as select * from t1" +
1:2bfe0a6:                         " --derby-properties asdf = fdsa");
1:2bfe0a6:                 
1:2bfe0a6:                 st.executeBatch();
1:2bfe0a6:             }            
1:2bfe0a6:         };
1:2bfe0a6:         
1:2bfe0a6:         return suite;
1:2bfe0a6:     }
1:2bfe0a6:         
1:2bfe0a6:     /**
1:2bfe0a6:      * Negative tests for bad formats.
1:2bfe0a6:      */
1:2bfe0a6:     public void testBadFormats() throws SQLException{
1:2bfe0a6:         Statement st = createStatement();
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42X01", st, 
1:2bfe0a6:             "select \n" +
1:2bfe0a6:             "-- derby-properties index = t1_c1 \n" +
1:2bfe0a6:             "* from t1");
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42X01", st, 
1:2bfe0a6:             "select * -- derby-properties index = t1_c1 \n" +
1:2bfe0a6:             "from t1");
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42X01", st, 
1:2bfe0a6:             "select * -- derby-properties\n" +
1:2bfe0a6:             " index = t1_c1 from t1");
1:2bfe0a6:         
1:2bfe0a6:         st.close();
1:2bfe0a6:     }
1:2bfe0a6:     
1:2bfe0a6:     /**
1:2bfe0a6:      * Test bad properties.
1:2bfe0a6:      */
1:2bfe0a6:     public void testBadProperties() throws SQLException{
1:2bfe0a6:         Statement st = createStatement();
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42Y44", st, "select * from t1" +
1:2bfe0a6:             " --derby-properties asdf = i1");
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42Y44", st, "select * from t1" +
1:2bfe0a6:             " exposedname --derby-properties asdf = i1");
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42Y44", st, 
1:2bfe0a6:             "select * from neg_v1");
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42Y44", st, 
1:2bfe0a6:             "select * from t1 --derby-properties i = a\n" + 
1:2bfe0a6:             "left outer join t2 on 1=1");
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42Y44", st, 
1:2bfe0a6:             "select * from t1 left outer join t2 " +
1:2bfe0a6:             "--derby-properties i = t1_c1\n on 1=1");
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42Y46", st, 
1:2bfe0a6:             "select * from t1 left outer join t2 " + 
1:2bfe0a6:             "--derby-properties index = t1_c1\n on 1=1");
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42Y46", st, 
1:2bfe0a6:             "select * from t1 right outer join t2 " + 
1:2bfe0a6:             "--derby-properties index = t1_c1\n on 1=1");
1:2bfe0a6:         
1:2bfe0a6:         st.close();
1:2bfe0a6:     }
1:2bfe0a6:     
1:2bfe0a6:     /**
1:2bfe0a6:      * Test not existing values of property.
1:2bfe0a6:      */
1:2bfe0a6:     public void testNonExistingPropertyValues() 
1:2bfe0a6:     throws SQLException{
1:2bfe0a6:         Statement st = createStatement();
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42Y46", st, "select * from t1 " +
1:2bfe0a6:             "--derby-properties index = t1_notexists");
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42Y46", st, 
1:2bfe0a6:             "select * from t1 exposedname " +
1:2bfe0a6:             "--derby-properties index = t1_notexists");
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42Y48", st, "select * from t1 " +
1:2bfe0a6:             "--derby-properties constraint = t1_notexists");
1:2bfe0a6: 
1:2bfe0a6:         assertStatementError("42Y48", st, 
1:2bfe0a6:             "select * from t1 exposedname " +
1:2bfe0a6:             "--derby-properties constraint = t1_notexists");
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42Y56", st, 
1:2bfe0a6:             "select * from t1 a, t1 b " +
1:2bfe0a6:             "--derby-properties joinStrategy = asdf");
1:2bfe0a6:                                     
1:2bfe0a6:         st.close();
1:2bfe0a6:     }
1:2bfe0a6:     
1:2bfe0a6:     /**
1:2bfe0a6:      *  Make sure following fragments get treated as comments.
1:2bfe0a6:      */
1:2bfe0a6:     public void testFragmentsAsComments() throws SQLException{
1:2bfe0a6:         String[] frags = {"--d", "-- de", "-- der",
1:2bfe0a6:             "--derb", "--derby comment",
1:2bfe0a6:             "-- derby another comment", "--derby-",
1:2bfe0a6:             "--derby-p", "--derby-pr", "--derby-pro",
1:2bfe0a6:             "--derby-prop", "--derby-prope", "--derby-proper",
1:2bfe0a6:             "-- derby-propert", "-- derby-properti", 
1:2bfe0a6:             "-- derby-propertie", "-- derby-propertiex"
1:2bfe0a6:         };
1:2bfe0a6:         
1:2bfe0a6:         Statement st = createStatement();
1:2bfe0a6:         
1:2bfe0a6:         for(int i = 0; i < frags.length; i++)
1:2bfe0a6:             JDBC.assertFullResultSet(
1:2bfe0a6:                 st.executeQuery(
1:2bfe0a6:                     frags[i] + "\n VALUES 1 "),
1:2bfe0a6:                     new String [][] {{"1"}});
1:2bfe0a6:         
1:2bfe0a6:         st.close();
1:2bfe0a6:     }
1:2bfe0a6:     
1:2bfe0a6:     /**
1:2bfe0a6:      * Test both index and constraint.
1:2bfe0a6:      */
1:2bfe0a6:     public void testMixedIndexAndConstraint() 
1:2bfe0a6:     throws SQLException{
1:2bfe0a6:         Statement st = createStatement();
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42Y50", st, "select * from t1" +
1:2bfe0a6:             " --derby-properties index = t1_c1, " +
1:2bfe0a6:             "constraint = cons1");
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42Y50", st, "select * from t1" +
1:2bfe0a6:                     " exposedname --derby-properties " +
1:2bfe0a6:                     "index = t1_c1, constraint = cons1");
1:2bfe0a6:         
1:2bfe0a6:         st.close();
1:2bfe0a6:     }
1:2bfe0a6:     
1:2bfe0a6:     /**
1:2bfe0a6:      * Index which includes columns in for update of list.
1:2bfe0a6:      */
1:2bfe0a6:     public void testPropertyForUpdate() throws SQLException{
1:2bfe0a6:         Statement st = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:2bfe0a6:                 ResultSet.CONCUR_UPDATABLE);
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(st.executeQuery(
1:2bfe0a6:                 "select * from t1 " + 
1:2bfe0a6:                 "--derby-properties index = t1_c1\n" + 
1:2bfe0a6:                 "for update"), FULL_TABLE);
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(st.executeQuery(
1:2bfe0a6:                 "select * from t1 exposedname " + 
1:2bfe0a6:                 "--derby-properties index = t1_c1\n" + 
1:2bfe0a6:                 "for update"), FULL_TABLE);
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(st.executeQuery(
1:2bfe0a6:                 "select * from t1 " + 
1:2bfe0a6:                 "--derby-properties index = t1_c1\n" + 
1:2bfe0a6:                 "for update of c2, c1"), FULL_TABLE);
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(st.executeQuery(
1:2bfe0a6:                 "select * from t1 exposedname " + 
1:2bfe0a6:                 "--derby-properties index = t1_c1\n" + 
1:2bfe0a6:                 "for update of c2, c1"), FULL_TABLE);
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(st.executeQuery(
1:2bfe0a6:                 "select * from t1 " +
1:2bfe0a6:                 "--derby-properties constraint = cons1\n" +  
1:2bfe0a6:                 "for update"), FULL_TABLE);
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(st.executeQuery(
1:2bfe0a6:                 "select * from t1 exposedname " +
1:2bfe0a6:                 "--derby-properties constraint = cons1\n" +  
1:2bfe0a6:                 "for update"), FULL_TABLE);
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(st.executeQuery(
1:2bfe0a6:                 "select * from t1 " +
1:2bfe0a6:                 "--derby-properties constraint = cons1\n" +  
1:2bfe0a6:                 "for update of c2, c1"), FULL_TABLE);
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(st.executeQuery(
1:2bfe0a6:                 "select * from t1 exposedname " +
1:2bfe0a6:                 "--derby-properties constraint = cons1\n" +  
1:2bfe0a6:                 "for update of c2, c1"), FULL_TABLE);
1:2bfe0a6:         
1:2bfe0a6:         st.close();        
1:2bfe0a6:     }
1:2bfe0a6:     
1:2bfe0a6:     public void testInvalidJoinStrategy() throws SQLException{
1:2bfe0a6:         Statement st = createStatement();
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42Y50", st, "select * from t1" +
1:2bfe0a6:             " --derby-properties index = t1_c1, " +
1:2bfe0a6:             "constraint = cons1");
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42Y50", st, "select * from t1" +
1:2bfe0a6:             " exposedname --derby-properties " +
1:2bfe0a6:             "index = t1_c1, constraint = cons1");
1:2bfe0a6:         
1:2bfe0a6:         st.close();
1:2bfe0a6:     }
1:2bfe0a6:     
1:2bfe0a6:     /**
1:2bfe0a6:      * Verify that statements are dependent 
1:2bfe0a6:      * on specified index.
1:2bfe0a6:      */
1:2bfe0a6:     public void testDependenceOnIndex() throws SQLException{
1:2bfe0a6:         PreparedStatement ps = 
1:2bfe0a6:             prepareStatement("select * from t1 " +
1:2bfe0a6:                     "--derby-properties index = t1_c1");
1:2bfe0a6:                 
1:2bfe0a6:         JDBC.assertFullResultSet(ps.executeQuery(),
1:2bfe0a6:                 new String[][]{
1:2bfe0a6:             {"1", "1", "1"}, 
1:2bfe0a6:             {"2", "2", "2"},
1:2bfe0a6:             {"3", "3", "3"},
1:2bfe0a6:             {"4", "4", "4"},
1:2bfe0a6:         });
1:2bfe0a6:         
1:2bfe0a6:         Statement st = createStatement();
1:2bfe0a6:         st.executeUpdate("drop index t1_c1");
1:2bfe0a6:                 
1:2bfe0a6:         assertStatementError("42Y46", ps);
1:2bfe0a6:         
1:2bfe0a6:         ps.close();
1:2bfe0a6:         
1:2bfe0a6:         //add index to avoid exception when deleted in tearDown().
1:2bfe0a6:         st.executeUpdate("create index t1_c1 on t1(c1)");
1:2bfe0a6:         
1:2bfe0a6:         st.close();        
1:2bfe0a6:     }
1:2bfe0a6:     
1:2bfe0a6:     /**
1:2bfe0a6:      * Verify that statements are dependent 
1:2bfe0a6:      * on specified constraint.
1:2bfe0a6:      */
1:2bfe0a6:     public void testDependenceOnConstraint()
1:2bfe0a6:     throws SQLException{
1:2bfe0a6:         PreparedStatement ps = 
1:2bfe0a6:             prepareStatement("select * from t1 " +
1:2bfe0a6:                     "--derby-properties constraint = cons1");
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(ps.executeQuery(), FULL_TABLE);
1:2bfe0a6:         
1:2bfe0a6:         Statement st = createStatement();
1:2bfe0a6:         st.executeUpdate("alter table t1 drop constraint cons1");
1:2bfe0a6:                 
1:2bfe0a6:         assertStatementError("42Y48", ps);
1:2bfe0a6:         
1:2bfe0a6:         //add cons1 to restore the test environment.
1:2bfe0a6:         st.executeUpdate("alter table t1 " +
1:2bfe0a6:                         "add constraint cons1 primary key(c1, c2)");
1:2bfe0a6:         
1:2bfe0a6:         ps.close();
1:2bfe0a6:         
1:2bfe0a6:         st.close();        
1:2bfe0a6:     }
1:2bfe0a6:     
1:2bfe0a6:     /**
1:2bfe0a6:      * Test case insensitivity, spelling sensitivity 
1:2bfe0a6:      * and delimited index.
1:2bfe0a6:      */
1:2bfe0a6:     public void testSpell() throws SQLException{
1:2bfe0a6:         Statement st = createStatement();
1:2bfe0a6:                 
1:2bfe0a6:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:2bfe0a6:         
1:2bfe0a6:         //the token derby-properties is case insensitive.
1:2bfe0a6:         JDBC.assertFullResultSet(
1:2bfe0a6:             st.executeQuery("select * from t1" +
1:2bfe0a6:             " --DeRbY-pRoPeRtIeS index = t1_c1"),
1:2bfe0a6:             FULL_TABLE);        
1:2bfe0a6:         RuntimeStatisticsParser rtsp = 
1:2bfe0a6:             SQLUtilities.getRuntimeStatisticsParser(st);
1:2bfe0a6:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_C1"));
1:2bfe0a6:         
1:2bfe0a6:         //-- misspell derby-properties and make sure that 
1:2bfe0a6:         //it gets treated as a regular comment 
1:2bfe0a6:         //rather than optimizer override
1:2bfe0a6:         JDBC.assertFullResultSet(
1:2bfe0a6:                 st.executeQuery("select * from t1 " +
1:2bfe0a6:                         " --DeRbY-pRoPeRtIeAAAA index = t1_c1"),
1:2bfe0a6:                         FULL_TABLE);
1:2bfe0a6:         rtsp = SQLUtilities.getRuntimeStatisticsParser(st);
1:2bfe0a6:         assertTrue("not using t1_c1, but what derby thinks is best index.",
1:2bfe0a6:                 rtsp.usedSpecificIndexForIndexScan("T1", "T1_C1C2C3"));
1:2bfe0a6:         
1:2bfe0a6:         
1:2bfe0a6:         //"--DeRbY-pRoPeRtIeSAAAA index = t1_c1" is 
1:2bfe0a6:         //treated as "--DeRbY-pRoPeRtIeS AAAA index = t1_c1"
1:2bfe0a6:         assertStatementError("42Y44", st, "select * from t1 " +
1:2bfe0a6:                 " --DeRbY-pRoPeRtIeSAAAA index = t1_c1");
1:2bfe0a6:         
1:2bfe0a6:         //-- force index, delimited identifier
1:2bfe0a6:         JDBC.assertFullResultSet(
1:2bfe0a6:             st.executeQuery("select * from t1 " +
1:2bfe0a6:                     "--derby-properties index = \"t1_c2c1\""),
1:2bfe0a6:                 FULL_TABLE);
1:2bfe0a6:         rtsp = SQLUtilities.getRuntimeStatisticsParser(st);
1:2bfe0a6:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "t1_c2c1"));
1:2bfe0a6:         
1:2bfe0a6:         //If the property spelled wrong gets treated 
1:2bfe0a6:         //as an optimizer override, the following test will fail.
1:2bfe0a6:         assertStatementError("42Y46", st, "select * from t1 " +
1:2bfe0a6:                        " --DeRbY-pRoPeRtIeS index = t1_notexisting");
1:2bfe0a6:         
1:2bfe0a6:         st.close();
1:2bfe0a6:     }
1:2bfe0a6:     
1:2bfe0a6:     public void testNullValue() throws SQLException{
1:2bfe0a6:         Statement st = createStatement();
1:2bfe0a6:         
1:2bfe0a6:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(
1:2bfe0a6:             st.executeQuery("select * from t1 " +
1:2bfe0a6:             "--derby-properties index = null"), FULL_TABLE);
1:2bfe0a6:         RuntimeStatisticsParser rtsp = 
1:2bfe0a6:             SQLUtilities.getRuntimeStatisticsParser(st);
1:2bfe0a6:         assertTrue("force table scan", rtsp.usedTableScan());
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(
1:2bfe0a6:             st.executeQuery("select * from t1 " +
1:2bfe0a6:             "--derby-properties constraint = null"), FULL_TABLE);
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42Y56", st, "select * from t1 " +
1:2bfe0a6:             "--derby-properties joinStrategy = null");
1:2bfe0a6:         
1:2bfe0a6:         st.close();
1:2bfe0a6:     }
1:2bfe0a6:     
1:2bfe0a6:     public void testJoin() throws SQLException{
1:2bfe0a6:         Statement st = createStatement();
1:2bfe0a6:         
1:2bfe0a6:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:2bfe0a6:         JDBC.assertFullResultSet(
1:2bfe0a6:             st.executeQuery("select 1 from t1 a" +
1:2bfe0a6:                 " --derby-properties index = t1_c1\n" +
1:2bfe0a6:                 ",t2 b --derby-properties index = t2_c2"),
1:2bfe0a6:             new String[][]{
1:2bfe0a6:                 {"1"}, {"1"}, {"1"}, {"1"},
1:2bfe0a6:                 {"1"}, {"1"}, {"1"}, {"1"},
1:2bfe0a6:                 {"1"}, {"1"}, {"1"}, {"1"},
1:2bfe0a6:                 {"1"}, {"1"}, {"1"}, {"1"},
1:2bfe0a6:             });
1:2bfe0a6:         RuntimeStatisticsParser rtsp = 
1:2bfe0a6:             SQLUtilities.getRuntimeStatisticsParser(st);
1:2bfe0a6:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_C1"));
1:2bfe0a6:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T2", "T2_C2"));
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(
1:2bfe0a6:             st.executeQuery("select 1 from " +
1:2bfe0a6:                 " --derby-properties joinOrder=fixed\n" +
1:2bfe0a6:                 "t1, t2 where t1.c1 = t2.c1"),
1:2bfe0a6:             new String[][]{{"1"}, {"1"}, {"1"}, {"1"}, }
1:2bfe0a6:         );
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(
1:2bfe0a6:             st.executeQuery("select * from t1" +
1:2bfe0a6:                 " --derby-properties index = t1_c1\n" +  
1:2bfe0a6:                 "left outer join t2 " +
1:2bfe0a6:                 "--derby-properties index = t2_c2\n" +  
1:2bfe0a6:                 "on t1.c1 = t2.c1"),
1:2bfe0a6:             new String[][]{
1:2bfe0a6:                     {"1", "1", "1", "1", "1", "1"}, 
1:2bfe0a6:                     {"2", "2", "2", "2", "2", "2"},
1:2bfe0a6:                     {"3", "3", "3", "3", "3", "3"},
1:2bfe0a6:                     {"4", "4", "4", "4", "4", "4"},
1:2bfe0a6:             });
1:2bfe0a6:         rtsp = 
1:2bfe0a6:             SQLUtilities.getRuntimeStatisticsParser(st);
1:2bfe0a6:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_C1"));
1:2bfe0a6:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T2", "T2_C2"));
1:2bfe0a6:         
1:2bfe0a6:         st.close();
1:2bfe0a6:     }
1:2bfe0a6:     
1:2bfe0a6:     /**
1:2bfe0a6:      * Comparisons that can't get pushed down.
1:2bfe0a6:      */
1:2bfe0a6:     public void testComparision() throws SQLException{
1:2bfe0a6:         Statement st = createStatement();
1:2bfe0a6:         
1:2bfe0a6:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(
1:2bfe0a6:             st.executeQuery("select * from t1" +
1:2bfe0a6:                 " --derby-properties index = t1_c1\n" +  
1:2bfe0a6:                 "where c1 = c1"), FULL_TABLE);
1:2bfe0a6:         RuntimeStatisticsParser rtsp = 
1:2bfe0a6:             SQLUtilities.getRuntimeStatisticsParser(st);
1:2bfe0a6:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_C1"));
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(
1:2bfe0a6:             st.executeQuery("select * from t1" +
1:2bfe0a6:                 " --derby-properties index = t1_c1\n" +  
1:2bfe0a6:                 "where c1 = c2"), FULL_TABLE);
1:2bfe0a6:         rtsp = SQLUtilities.getRuntimeStatisticsParser(st);
1:2bfe0a6:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_C1"));
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(
1:2bfe0a6:             st.executeQuery("select * from t1" +
1:2bfe0a6:                 " --derby-properties index = t1_c1\n" +  
1:2bfe0a6:                 "where c1 + 1 = 1 + c1"), FULL_TABLE);
1:2bfe0a6:         rtsp = SQLUtilities.getRuntimeStatisticsParser(st);
1:2bfe0a6:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_C1"));
1:2bfe0a6:         
1:2bfe0a6:         st.close();
1:2bfe0a6:     }
1:2bfe0a6:     
1:2bfe0a6:     public void testNestedLoopJoinStrategy()
1:2bfe0a6:     throws SQLException{
1:2bfe0a6:         Statement st = createStatement();
1:2bfe0a6:         
1:2bfe0a6:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:2bfe0a6:         
1:2bfe0a6:         JDBC.assertFullResultSet(
1:2bfe0a6:             st.executeQuery("select * from t1 a, t1 b " +
1:2bfe0a6:                 "--derby-properties joinStrategy = nestedloop\n" +
1:2bfe0a6:                 "where a.c1 = b.c1"),
1:2bfe0a6:             new String[][]{
1:2bfe0a6:                 {"1", "1", "1", "1", "1", "1"}, 
1:2bfe0a6:                 {"2", "2", "2", "2", "2", "2"},
1:2bfe0a6:                 {"3", "3", "3", "3", "3", "3"},
1:2bfe0a6:                 {"4", "4", "4", "4", "4", "4"},
1:2bfe0a6:             });
1:2bfe0a6: //        RuntimeStatisticsParser rtsp = 
1:2bfe0a6: //            SQLUtilities.getRuntimeStatisticsParser(st);
1:2bfe0a6: //        assertTrue(rtsp.usedHashJoin());
1:2bfe0a6: //        assertTrue("not using t1_c1, but what derby thinks is best index.",
1:2bfe0a6: //                rtsp.usedSpecificIndexForIndexScan("T1", "T1_C1C2C3"));
1:2bfe0a6:                 
1:2bfe0a6:         st.close();
1:2bfe0a6:     }
1:2bfe0a6:     
1:2bfe0a6:     /**
1:2bfe0a6:      *Negative test. insertModeValue is not available to a user 
1:2bfe0a6:      *and hence will give a syntax error. There are some 
1:2bfe0a6:      *undocumented properties which are allowed within Derby 
1:2bfe0a6:      *engine only and insertModeValue is one of them.
1:2bfe0a6:      */
1:2bfe0a6:     public void testInsertModeValue() throws SQLException{
1:2bfe0a6:         Statement st = createStatement();
1:2bfe0a6:         
1:2bfe0a6:         st.executeUpdate("create table temp1 (c1 int, c2 int, " +
1:2bfe0a6:             "c3 int, constraint temp1cons1 primary key(c1, c2))");
1:2bfe0a6:         
1:2bfe0a6:         assertStatementError("42X01", st,
1:2bfe0a6:             "insert into temp1 (c1,c2,c3)" +
1:2bfe0a6:             " -- derby-properties insertModeValue=replace\n" +
1:2bfe0a6:             "select * from t1");
1:2bfe0a6:         
1:2bfe0a6:         dropTable("temp1");
1:2bfe0a6:         
1:2bfe0a6:         st.close();
1:2bfe0a6:     }
1:2bfe0a6: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:626de50
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.OptimizerOverridesTest
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:2bfe0a6
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.OptimizerOverridingTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1: import org.apache.derbyTesting.junit.SQLUtilities;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Test the optimizer overrides.
1:  */
1: public class OptimizerOverridesTest extends BaseJDBCTestCase {
1:     private static final String[][] FULL_TABLE = 
1:         new String[][]{
1:         {"1", "1", "1"}, 
1:         {"2", "2", "2"},
1:         {"3", "3", "3"},
1:         {"4", "4", "4"},
1:     };
1:     
1:     public OptimizerOverridesTest(String name) {
1:         super(name);
1:     }
1:     
1:     public static Test suite(){
1:         Test suite = TestConfiguration.defaultSuite(
1:                 OptimizerOverridesTest.class, false);
1:         suite = new CleanDatabaseTestSetup(suite){
1:             
1:             /* Create tables, indices and views.
1:              * @see org.apache.derbyTesting.junit.CleanDatabaseTestSetup#decorateSQL(java.sql.Statement)
1:              */
1:             protected void decorateSQL(Statement st) throws SQLException {
1:                 st.getConnection().setAutoCommit(false);
1:                 
1:                 st.addBatch("create table t1 (c1 int, " +
1:                         "c2 int, c3 int," +
1:                         " constraint cons1 primary key(c1, c2))");
1:                 st.addBatch("create table t2 (c1 int not null, " +
1:                         "c2 int not null, c3 int, " +
1:                         "constraint cons2 unique(c1, c2))");
1:                 
1:                 st.addBatch("insert into t1 values (1, 1, 1), " +
1:                         "(2, 2, 2), (3, 3, 3), (4, 4, 4)");;
1:                 st.addBatch("insert into t2 values (1, 1, 1), " +
1:                         "(2, 2, 2), (3, 3, 3), (4, 4, 4)");
1:                 
1:                 st.addBatch("create index t1_c1c2c3 on t1(c1, c2, c3)");
1:                 st.addBatch("create index t1_c3c2c1 on t1(c3, c2, c1)");
1:                 st.addBatch("create index t1_c1 on t1(c1)");
1:                 st.addBatch("create index t1_c2 on t1(c2)");
1:                 st.addBatch("create index t1_c3 on t1(c3)");
1:                 st.addBatch("create index \"t1_c2c1\" on t1(c2, c1)");
1:                 st.addBatch("create index t2_c1c2c3 on t2(c1, c2, c3)");
1:                 st.addBatch("create index t2_c3c2c1 on t2(c3, c2, c1)");
1:                 st.addBatch("create index t2_c1 on t2(c1)");
1:                 st.addBatch("create index t2_c2 on t2(c2)");
1:                 st.addBatch("create index t2_c3 on t2(c3)");
1:                         
1:                 st.addBatch("create view v1 as select * from t1 " +
1:                         "--derby-properties index = t1_c1");
1:                 st.addBatch("create view v2 as select t1.* from t1, t2");
1:                 st.addBatch("create view v3 as select * from v1");
1:                 st.addBatch("create view neg_v1 as select * from t1" +
1:                         " --derby-properties asdf = fdsa");
1:                 
1:                 st.executeBatch();
1:             }            
1:         };
1:         
1:         return suite;
1:     }
1:         
1:     /**
1:      * Negative tests for bad formats.
1:      */
1:     public void testBadFormats() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         assertStatementError("42X01", st, 
1:             "select \n" +
1:             "-- derby-properties index = t1_c1 \n" +
1:             "* from t1");
1:         
1:         assertStatementError("42X01", st, 
1:             "select * -- derby-properties index = t1_c1 \n" +
1:             "from t1");
1:         
1:         assertStatementError("42X01", st, 
1:             "select * -- derby-properties\n" +
1:             " index = t1_c1 from t1");
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * Test bad properties.
1:      */
1:     public void testBadProperties() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         assertStatementError("42Y44", st, "select * from t1" +
1:             " --derby-properties asdf = i1");
1:         
1:         assertStatementError("42Y44", st, "select * from t1" +
1:             " exposedname --derby-properties asdf = i1");
1:         
1:         assertStatementError("42Y44", st, 
1:             "select * from neg_v1");
1:         
1:         assertStatementError("42Y44", st, 
1:             "select * from t1 --derby-properties i = a\n" + 
1:             "left outer join t2 on 1=1");
1:         
1:         assertStatementError("42Y44", st, 
1:             "select * from t1 left outer join t2 " +
1:             "--derby-properties i = t1_c1\n on 1=1");
1:         
1:         assertStatementError("42Y46", st, 
1:             "select * from t1 left outer join t2 " + 
1:             "--derby-properties index = t1_c1\n on 1=1");
1:         
1:         assertStatementError("42Y46", st, 
1:             "select * from t1 right outer join t2 " + 
1:             "--derby-properties index = t1_c1\n on 1=1");
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * Test not existing values of property.
1:      */
1:     public void testNonExistingPropertyValues() 
1:     throws SQLException{
1:         Statement st = createStatement();
1:         
1:         assertStatementError("42Y46", st, "select * from t1 " +
1:             "--derby-properties index = t1_notexists");
1:         
1:         assertStatementError("42Y46", st, 
1:             "select * from t1 exposedname " +
1:             "--derby-properties index = t1_notexists");
1:         
1:         assertStatementError("42Y48", st, "select * from t1 " +
1:             "--derby-properties constraint = t1_notexists");
1: 
1:         assertStatementError("42Y48", st, 
1:             "select * from t1 exposedname " +
1:             "--derby-properties constraint = t1_notexists");
1:         
1:         assertStatementError("42Y56", st, 
1:             "select * from t1 a, t1 b " +
1:             "--derby-properties joinStrategy = asdf");
1:                                     
1:         st.close();
1:     }
1:     
1:     /**
1:      *  Make sure following fragments get treated as comments.
1:      */
1:     public void testFragmentsAsComments() throws SQLException{
1:         String[] frags = {"--d", "-- de", "-- der",
1:             "--derb", "--derby comment",
1:             "-- derby another comment", "--derby-",
1:             "--derby-p", "--derby-pr", "--derby-pro",
1:             "--derby-prop", "--derby-prope", "--derby-proper",
1:             "-- derby-propert", "-- derby-properti", 
1:             "-- derby-propertie", "-- derby-propertiex"
1:         };
1:         
1:         Statement st = createStatement();
1:         
1:         for(int i = 0; i < frags.length; i++)
1:             JDBC.assertFullResultSet(
1:                 st.executeQuery(
1:                     frags[i] + "\n VALUES 1 "),
1:                     new String [][] {{"1"}});
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * Test both index and constraint.
1:      */
1:     public void testMixedIndexAndConstraint() 
1:     throws SQLException{
1:         Statement st = createStatement();
1:         
1:         assertStatementError("42Y50", st, "select * from t1" +
1:             " --derby-properties index = t1_c1, " +
1:             "constraint = cons1");
1:         
1:         assertStatementError("42Y50", st, "select * from t1" +
1:                     " exposedname --derby-properties " +
1:                     "index = t1_c1, constraint = cons1");
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * Index which includes columns in for update of list.
1:      */
1:     public void testPropertyForUpdate() throws SQLException{
1:         Statement st = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_UPDATABLE);
1:         
1:         JDBC.assertFullResultSet(st.executeQuery(
1:                 "select * from t1 " + 
1:                 "--derby-properties index = t1_c1\n" + 
1:                 "for update"), FULL_TABLE);
1:         
1:         JDBC.assertFullResultSet(st.executeQuery(
1:                 "select * from t1 exposedname " + 
1:                 "--derby-properties index = t1_c1\n" + 
1:                 "for update"), FULL_TABLE);
1:         
1:         JDBC.assertFullResultSet(st.executeQuery(
1:                 "select * from t1 " + 
1:                 "--derby-properties index = t1_c1\n" + 
1:                 "for update of c2, c1"), FULL_TABLE);
1:         
1:         JDBC.assertFullResultSet(st.executeQuery(
1:                 "select * from t1 exposedname " + 
1:                 "--derby-properties index = t1_c1\n" + 
1:                 "for update of c2, c1"), FULL_TABLE);
1:         
1:         JDBC.assertFullResultSet(st.executeQuery(
1:                 "select * from t1 " +
1:                 "--derby-properties constraint = cons1\n" +  
1:                 "for update"), FULL_TABLE);
1:         
1:         JDBC.assertFullResultSet(st.executeQuery(
1:                 "select * from t1 exposedname " +
1:                 "--derby-properties constraint = cons1\n" +  
1:                 "for update"), FULL_TABLE);
1:         
1:         JDBC.assertFullResultSet(st.executeQuery(
1:                 "select * from t1 " +
1:                 "--derby-properties constraint = cons1\n" +  
1:                 "for update of c2, c1"), FULL_TABLE);
1:         
1:         JDBC.assertFullResultSet(st.executeQuery(
1:                 "select * from t1 exposedname " +
1:                 "--derby-properties constraint = cons1\n" +  
1:                 "for update of c2, c1"), FULL_TABLE);
1:         
1:         st.close();        
1:     }
1:     
1:     public void testInvalidJoinStrategy() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         assertStatementError("42Y50", st, "select * from t1" +
1:             " --derby-properties index = t1_c1, " +
1:             "constraint = cons1");
1:         
1:         assertStatementError("42Y50", st, "select * from t1" +
1:             " exposedname --derby-properties " +
1:             "index = t1_c1, constraint = cons1");
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * Verify that statements are dependent 
1:      * on specified index.
1:      */
1:     public void testDependenceOnIndex() throws SQLException{
1:         PreparedStatement ps = 
1:             prepareStatement("select * from t1 " +
1:                     "--derby-properties index = t1_c1");
1:                 
1:         JDBC.assertFullResultSet(ps.executeQuery(),
1:                 new String[][]{
1:             {"1", "1", "1"}, 
1:             {"2", "2", "2"},
1:             {"3", "3", "3"},
1:             {"4", "4", "4"},
1:         });
1:         
1:         Statement st = createStatement();
1:         st.executeUpdate("drop index t1_c1");
1:                 
1:         assertStatementError("42Y46", ps);
1:         
1:         ps.close();
1:         
1:         //add index to avoid exception when deleted in tearDown().
1:         st.executeUpdate("create index t1_c1 on t1(c1)");
1:         
1:         st.close();        
1:     }
1:     
1:     /**
1:      * Verify that statements are dependent 
1:      * on specified constraint.
1:      */
1:     public void testDependenceOnConstraint()
1:     throws SQLException{
1:         PreparedStatement ps = 
1:             prepareStatement("select * from t1 " +
1:                     "--derby-properties constraint = cons1");
1:         
1:         JDBC.assertFullResultSet(ps.executeQuery(), FULL_TABLE);
1:         
1:         Statement st = createStatement();
1:         st.executeUpdate("alter table t1 drop constraint cons1");
1:                 
1:         assertStatementError("42Y48", ps);
1:         
1:         //add cons1 to restore the test environment.
1:         st.executeUpdate("alter table t1 " +
1:                         "add constraint cons1 primary key(c1, c2)");
1:         
1:         ps.close();
1:         
1:         st.close();        
1:     }
1:     
1:     /**
1:      * Test case insensitivity, spelling sensitivity 
1:      * and delimited index.
1:      */
1:     public void testSpell() throws SQLException{
1:         Statement st = createStatement();
1:                 
1:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         
1:         //the token derby-properties is case insensitive.
1:         JDBC.assertFullResultSet(
1:             st.executeQuery("select * from t1" +
1:             " --DeRbY-pRoPeRtIeS index = t1_c1"),
1:             FULL_TABLE);        
1:         RuntimeStatisticsParser rtsp = 
1:             SQLUtilities.getRuntimeStatisticsParser(st);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_C1"));
1:         
1:         //-- misspell derby-properties and make sure that 
1:         //it gets treated as a regular comment 
1:         //rather than optimizer override
1:         JDBC.assertFullResultSet(
1:                 st.executeQuery("select * from t1 " +
1:                         " --DeRbY-pRoPeRtIeAAAA index = t1_c1"),
1:                         FULL_TABLE);
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(st);
1:         assertTrue("not using t1_c1, but what derby thinks is best index.",
1:                 rtsp.usedSpecificIndexForIndexScan("T1", "T1_C1C2C3"));
1:         
1:         
1:         //"--DeRbY-pRoPeRtIeSAAAA index = t1_c1" is 
1:         //treated as "--DeRbY-pRoPeRtIeS AAAA index = t1_c1"
1:         assertStatementError("42Y44", st, "select * from t1 " +
1:                 " --DeRbY-pRoPeRtIeSAAAA index = t1_c1");
1:         
1:         //-- force index, delimited identifier
1:         JDBC.assertFullResultSet(
1:             st.executeQuery("select * from t1 " +
1:                     "--derby-properties index = \"t1_c2c1\""),
1:                 FULL_TABLE);
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(st);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "t1_c2c1"));
1:         
1:         //If the property spelled wrong gets treated 
1:         //as an optimizer override, the following test will fail.
1:         assertStatementError("42Y46", st, "select * from t1 " +
1:                        " --DeRbY-pRoPeRtIeS index = t1_notexisting");
1:         
1:         st.close();
1:     }
1:     
1:     public void testNullValue() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         
1:         JDBC.assertFullResultSet(
1:             st.executeQuery("select * from t1 " +
1:             "--derby-properties index = null"), FULL_TABLE);
1:         RuntimeStatisticsParser rtsp = 
1:             SQLUtilities.getRuntimeStatisticsParser(st);
1:         assertTrue("force table scan", rtsp.usedTableScan());
1:         
1:         JDBC.assertFullResultSet(
1:             st.executeQuery("select * from t1 " +
1:             "--derby-properties constraint = null"), FULL_TABLE);
1:         
1:         assertStatementError("42Y56", st, "select * from t1 " +
1:             "--derby-properties joinStrategy = null");
1:         
1:         st.close();
1:     }
1:     
1:     public void testJoin() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         JDBC.assertFullResultSet(
1:             st.executeQuery("select 1 from t1 a" +
1:                 " --derby-properties index = t1_c1\n" +
1:                 ",t2 b --derby-properties index = t2_c2"),
1:             new String[][]{
1:                 {"1"}, {"1"}, {"1"}, {"1"},
1:                 {"1"}, {"1"}, {"1"}, {"1"},
1:                 {"1"}, {"1"}, {"1"}, {"1"},
1:                 {"1"}, {"1"}, {"1"}, {"1"},
1:             });
1:         RuntimeStatisticsParser rtsp = 
1:             SQLUtilities.getRuntimeStatisticsParser(st);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_C1"));
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T2", "T2_C2"));
1:         
1:         JDBC.assertFullResultSet(
1:             st.executeQuery("select 1 from " +
1:                 " --derby-properties joinOrder=fixed\n" +
1:                 "t1, t2 where t1.c1 = t2.c1"),
1:             new String[][]{{"1"}, {"1"}, {"1"}, {"1"}, }
1:         );
1:         
1:         JDBC.assertFullResultSet(
1:             st.executeQuery("select * from t1" +
1:                 " --derby-properties index = t1_c1\n" +  
1:                 "left outer join t2 " +
1:                 "--derby-properties index = t2_c2\n" +  
1:                 "on t1.c1 = t2.c1"),
1:             new String[][]{
1:                     {"1", "1", "1", "1", "1", "1"}, 
1:                     {"2", "2", "2", "2", "2", "2"},
1:                     {"3", "3", "3", "3", "3", "3"},
1:                     {"4", "4", "4", "4", "4", "4"},
1:             });
1:         rtsp = 
1:             SQLUtilities.getRuntimeStatisticsParser(st);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_C1"));
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T2", "T2_C2"));
1:         
1:         st.close();
1:     }
1:     
1:     /**
1:      * Comparisons that can't get pushed down.
1:      */
1:     public void testComparision() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         
1:         JDBC.assertFullResultSet(
1:             st.executeQuery("select * from t1" +
1:                 " --derby-properties index = t1_c1\n" +  
1:                 "where c1 = c1"), FULL_TABLE);
1:         RuntimeStatisticsParser rtsp = 
1:             SQLUtilities.getRuntimeStatisticsParser(st);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_C1"));
1:         
1:         JDBC.assertFullResultSet(
1:             st.executeQuery("select * from t1" +
1:                 " --derby-properties index = t1_c1\n" +  
1:                 "where c1 = c2"), FULL_TABLE);
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(st);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_C1"));
1:         
1:         JDBC.assertFullResultSet(
1:             st.executeQuery("select * from t1" +
1:                 " --derby-properties index = t1_c1\n" +  
1:                 "where c1 + 1 = 1 + c1"), FULL_TABLE);
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(st);
1:         assertTrue(rtsp.usedSpecificIndexForIndexScan("T1", "T1_C1"));
1:         
1:         st.close();
1:     }
1:     
1:     public void testNestedLoopJoinStrategy()
1:     throws SQLException{
1:         Statement st = createStatement();
1:         
1:         st.execute("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         
1:         JDBC.assertFullResultSet(
1:             st.executeQuery("select * from t1 a, t1 b " +
1:                 "--derby-properties joinStrategy = nestedloop\n" +
1:                 "where a.c1 = b.c1"),
1:             new String[][]{
1:                 {"1", "1", "1", "1", "1", "1"}, 
1:                 {"2", "2", "2", "2", "2", "2"},
1:                 {"3", "3", "3", "3", "3", "3"},
1:                 {"4", "4", "4", "4", "4", "4"},
1:             });
1: //        RuntimeStatisticsParser rtsp = 
1: //            SQLUtilities.getRuntimeStatisticsParser(st);
1: //        assertTrue(rtsp.usedHashJoin());
1: //        assertTrue("not using t1_c1, but what derby thinks is best index.",
1: //                rtsp.usedSpecificIndexForIndexScan("T1", "T1_C1C2C3"));
1:                 
1:         st.close();
1:     }
1:     
1:     /**
1:      *Negative test. insertModeValue is not available to a user 
1:      *and hence will give a syntax error. There are some 
1:      *undocumented properties which are allowed within Derby 
1:      *engine only and insertModeValue is one of them.
1:      */
1:     public void testInsertModeValue() throws SQLException{
1:         Statement st = createStatement();
1:         
1:         st.executeUpdate("create table temp1 (c1 int, c2 int, " +
1:             "c3 int, constraint temp1cons1 primary key(c1, c2))");
1:         
1:         assertStatementError("42X01", st,
1:             "insert into temp1 (c1,c2,c3)" +
1:             " -- derby-properties insertModeValue=replace\n" +
1:             "select * from t1");
1:         
1:         dropTable("temp1");
1:         
1:         st.close();
1:     }
1: }
============================================================================