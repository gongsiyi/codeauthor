1:6e7bbc8: /*
1:0c5a8eb: 
1:6e7bbc8:    Derby - Class org.apache.derby.iapi.types.SqlXmlUtil
1:f67c2ee: 
1:4ecc65a:    Licensed to the Apache Software Foundation (ASF) under one or more
1:4ecc65a:    contributor license agreements.  See the NOTICE file distributed with
1:4ecc65a:    this work for additional information regarding copyright ownership.
1:4ecc65a:    The ASF licenses this file to you under the Apache License, Version 2.0
1:4ecc65a:    (the "License"); you may not use this file except in compliance with
1:4ecc65a:    the License.  You may obtain a copy of the License at
1:6e7bbc8: 
1:6e7bbc8:       http://www.apache.org/licenses/LICENSE-2.0
1:6e7bbc8: 
1:6e7bbc8:    Unless required by applicable law or agreed to in writing, software
1:6e7bbc8:    distributed under the License is distributed on an "AS IS" BASIS,
1:6e7bbc8:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6e7bbc8:    See the License for the specific language governing permissions and
1:6e7bbc8:    limitations under the License.
1:6e7bbc8: 
1:0c5a8eb:  */
1:0c5a8eb: 
1:6e7bbc8: package org.apache.derby.iapi.types;
1:6e7bbc8: 
1:6e7bbc8: import org.apache.derby.iapi.error.StandardException;
1:6e7bbc8: import org.apache.derby.iapi.reference.SQLState;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:6e7bbc8: 
1:6e7bbc8: import java.util.Properties;
1:6e7bbc8: import java.util.ArrayList;
1:5283796: import java.util.Collections;
1:1ffa77b: import java.util.Iterator;
1:5283796: import java.util.List;
1:6e7bbc8: 
1:a465628: import java.io.IOException;
1:6e7bbc8: import java.io.StringReader;
1:7139f7c: import java.io.StringWriter;
1:6e7bbc8: 
1:6e7bbc8: // -- JDBC 3.0 JAXP API classes.
1:6e7bbc8: 
1:0c5a8eb: import org.w3c.dom.Attr;
1:6e7bbc8: import org.w3c.dom.Document;
1:6e7bbc8: import org.w3c.dom.Node;
1:9f654e5: import org.w3c.dom.NodeList;
1:6e7bbc8: import org.w3c.dom.Text;
1:6e7bbc8: 
1:6e7bbc8: import org.xml.sax.ErrorHandler;
1:6e7bbc8: import org.xml.sax.InputSource;
1:6e7bbc8: import org.xml.sax.SAXException;
1:6e7bbc8: import org.xml.sax.SAXParseException;
1:6e7bbc8: 
1:1ffa77b: import javax.xml.XMLConstants;
1:6e7bbc8: 
1:1ffa77b: import javax.xml.namespace.NamespaceContext;
1:1ffa77b: import javax.xml.namespace.QName;
1:6e7bbc8: 
1:6e7bbc8: import javax.xml.parsers.DocumentBuilder;
1:6e7bbc8: import javax.xml.parsers.DocumentBuilderFactory;
1:6e7bbc8: 
1:6e7bbc8: import javax.xml.transform.OutputKeys;
1:5283796: import javax.xml.transform.Transformer;
1:5283796: import javax.xml.transform.TransformerConfigurationException;
1:6e7bbc8: import javax.xml.transform.TransformerException;
1:5283796: import javax.xml.transform.TransformerFactory;
1:5283796: import javax.xml.transform.dom.DOMSource;
1:5283796: import javax.xml.transform.stream.StreamResult;
1:6e7bbc8: 
1:1ffa77b: import javax.xml.xpath.XPath;
1:1ffa77b: import javax.xml.xpath.XPathConstants;
1:1ffa77b: import javax.xml.xpath.XPathExpression;
1:1ffa77b: import javax.xml.xpath.XPathExpressionException;
1:1ffa77b: import javax.xml.xpath.XPathFactory;
1:6e7bbc8: 
1:6e7bbc8: /**
1:6e7bbc8:  * This class contains "utility" methods that work with XML-specific
1:6e7bbc8:  * objects that are only available if JAXP and/or Xalan are in
1:6e7bbc8:  * the classpath.
1:6e7bbc8:  *
1:6e7bbc8:  * NOTE: This class is only compiled with JDK 1.4 and higher since
1:6e7bbc8:  * the XML-related classes that it uses (JAXP and Xalan) are not
1:6e7bbc8:  * part of earlier JDKs.
1:6e7bbc8:  *
1:6e7bbc8:  * Having a separate class for this functionality is beneficial
1:6e7bbc8:  * for two reasons:
1:6e7bbc8:  *
1:6e7bbc8:  *    1. Allows us to allocate XML objects and compile an XML
1:6e7bbc8:  *       query expression a single time per statement, instead of
1:6e7bbc8:  *       having to do it for every row against which the query
1:6e7bbc8:  *       is evaluated.  An instance of this class is created at
1:d09782a:  *       compile time and then passed to the appropriate operator
1:d09782a:  *       implementation method in XML.java.
1:6e7bbc8:  *
1:6e7bbc8:  *    2. By keeping all XML-specific references in this one class, 
1:6e7bbc8:  *       we have a single "point of entry" to the XML objects--namely,
1:6e7bbc8:  *       the constructor for this class.  Thus, if we always make
1:6e7bbc8:  *       sure to check for the required XML classes _before_ calling
1:6e7bbc8:  *       this class's constructor, we can detect early on whether
1:6e7bbc8:  *       some classes (ex. Xalan) are missing, and can throw a friendly
1:6e7bbc8:  *       error up front, instead of a ClassNotFoundException somewhere
1:3bcc92e:  *       deeper in the execution codepath.  The initial check for the
1:3bcc92e:  *       required XML classes can be found in XML.checkXMLRequirements().
1:6e7bbc8:  *
1:6e7bbc8:  *       Note that we don't want to put references to XML-specific
1:6e7bbc8:  *       objects directly into XML.java because that class (XML.java) is
1:6e7bbc8:  *       instantiated anytime a table with an XML column is referenced.
1:6e7bbc8:  *       That would mean that if a user tried to select a non-XML column
1:6e7bbc8:  *       (ex. integer) from a table that had at least one XML column in
1:6e7bbc8:  *       it, the user would have to have JAXP and Xalan classes in
1:6e7bbc8:  *       his/her classpath--which we don't want.  Instead, by keeping
1:6e7bbc8:  *       all XML-specific objects in this one class, and then only
1:6e7bbc8:  *       instantiating this class when an XML operator is used (either
1:6e7bbc8:  *       implicitly or explicitly), we make it so that the user is only
1:6e7bbc8:  *       required to have XML-specific classes in his/her classpath
1:6e7bbc8:  *       _if_ s/he is trying to access or operate on XML values.
2:6e7bbc8:  */
1:6e7bbc8: 
1:6e7bbc8: public class SqlXmlUtil
3:6e7bbc8: {
1:6e7bbc8:     // Used to parse a string into an XML value (DOM); checks
1:6e7bbc8:     // the well-formedness of the string while parsing.
1:6e7bbc8:     private DocumentBuilder dBuilder;
1:0c5a8eb: 
1:6e7bbc8:     // Used to serialize an XML value according the standard
1:6e7bbc8:     // XML serialization rules.
1:5283796:     private Transformer serializer;
1:6e7bbc8: 
1:1ffa77b:     /** The compiled XPath query. */
1:5283796:     private XPathExpression query;
1:6e7bbc8: 
1:1ffa77b:     /** The return type of the XPath query. {@code null} if it is unknown. */
1:1ffa77b:     private QName returnType;
1:6e7bbc8: 
1:6e7bbc8:     /**
1:6e7bbc8:      * Constructor: Initializes objects required for parsing
1:6e7bbc8:      * and serializing XML values.  Since most XML operations
1:6e7bbc8:      * that require XML-specific classes perform both parsing
1:6e7bbc8:      * and serialization at some point, we just initialize the
1:6e7bbc8:      * objects up front.
1:0c5a8eb:      */
1:6e7bbc8:     public SqlXmlUtil() throws StandardException
1:6e7bbc8:     {
1:6e7bbc8:         try {
1:6e7bbc8: 
1:6e7bbc8:             /* Note: Use of DocumentBuilderFactory means that we get
1:6e7bbc8:              * whatever XML parser is the "default" for the JVM in
1:6e7bbc8:              * use--and thus, we don't have to hard-code the parser
1:6e7bbc8:              * name, nor do we have to require that the user have a
1:6e7bbc8:              * specific parser in his/her classpath.
1:6e7bbc8:              *
1:6e7bbc8:              * This DocumentBuilder is currently used for parsing
1:6e7bbc8:              * (esp. XMLPARSE), and the SQL/XML spec says that XMLPARSE
1:6e7bbc8:              * should NOT perform validation (SQL/XML[2006], 6.15:
1:6e7bbc8:              * "Perform a non-validating parse of a string to produce
1:6e7bbc8:              * an XML value.").   So we disable validation here, and
1:6e7bbc8:              * we also make the parser namespace aware.
1:6e7bbc8:              *
1:6e7bbc8:              * At some point in the future we will probably want to add
1:6e7bbc8:              * support for the XMLVALIDATE function--but until then, user
1:6e7bbc8:              * is unable to validate the XML values s/he inserts.
1:6e7bbc8:              *
1:6e7bbc8:              * Note that, even with validation turned off, XMLPARSE
1:6e7bbc8:              * _will_ still check the well-formedness of the values,
1:6e7bbc8:              * and it _will_ still process DTDs to get default values,
1:6e7bbc8:              * etc--but that's it; no validation errors will be thrown.
1:0c5a8eb:              */
1:6e7bbc8: 
1:3bcc92e:             DocumentBuilderFactory dBF = null;
1:3bcc92e:             try {
1:3bcc92e: 
1:3bcc92e:                 dBF = DocumentBuilderFactory.newInstance();
1:3bcc92e: 
1:3bcc92e:             } catch (Throwable e) {
1:3bcc92e: 
1:3bcc92e:                 /* We assume that if we get an error creating the
1:3bcc92e:                  * DocumentBuilderFactory, it's because there's no
1:3bcc92e:                  * JAXP implementation.  This can happen in the
1:3bcc92e:                  * (admittedly unlikely) case where the classpath
1:6a210c5:                  * contains the JAXP _interfaces_
1:3bcc92e:                  * and the Xalan classes but does not actually
1:3bcc92e:                  * contain a JAXP _implementation_.  In that case the
1:3bcc92e:                  * check in XML.checkXMLRequirements() will pass
1:3bcc92e:                  * and this class (SqlXmlUtil) will be instantiated
1:3bcc92e:                  * successfully--which is how we get to this constructor.
1:3bcc92e:                  * But then attempts to create a DocumentBuilderFactory
1:3bcc92e:                  * will fail, bringing us here.  Note that we can't
1:3bcc92e:                  * check for a valid JAXP implementation in the
1:3bcc92e:                  * XML.checkXMLRequirements() method because we
1:3bcc92e:                  * always want to allow the XML.java class to be
1:3bcc92e:                  * instantiated, even if the required XML classes
1:3bcc92e:                  * are not present--and that means that it (the
1:3bcc92e:                  * XML class) cannot reference DocumentBuilder nor
1:3bcc92e:                  * any of the JAXP classes directly.
1:3bcc92e:                  */
1:3bcc92e:                  throw StandardException.newException(
1:3bcc92e:                      SQLState.LANG_MISSING_XML_CLASSES, "JAXP");
1:3bcc92e: 
1:0c5a8eb:             }
1:0c5a8eb: 
1:6e7bbc8:             dBF.setValidating(false);
1:6e7bbc8:             dBF.setNamespaceAware(true);
1:3bcc92e: 
1:a72ebf9:             if ( System.getSecurityManager() == null )
1:a72ebf9:             {
1:a72ebf9:                 dBF.setFeature( XMLConstants.FEATURE_SECURE_PROCESSING, true );
1:a72ebf9:                 dBF.setFeature(
1:a72ebf9:                  "http://xml.org/sax/features/external-general-entities", false );
1:a72ebf9:             }
1:a72ebf9: 
1:6e7bbc8:             // Load document builder that can be used for parsing XML.
1:6e7bbc8:             dBuilder = dBF.newDocumentBuilder();
1:6e7bbc8:             dBuilder.setErrorHandler(new XMLErrorHandler());
1:6e7bbc8: 
1:6e7bbc8:             // Load serializer for serializing XML into string according
1:6e7bbc8:             // XML serialization rules.
1:6e7bbc8:             loadSerializer();
1:6e7bbc8: 
1:3bcc92e:         } catch (StandardException se) {
1:3bcc92e: 
1:3bcc92e:             // Just rethrow it.
1:3bcc92e:             throw se;
1:3bcc92e: 
1:f67c2ee:         } catch (Throwable t) {
1:6e7bbc8: 
1:f67c2ee:             /* Must be something caused by JAXP or Xalan; wrap it in a
1:f67c2ee:              * StandardException and rethrow it. Note: we catch "Throwable"
1:f67c2ee:              * here to catch as many external errors as possible in order
1:f67c2ee:              * to minimize the chance of an uncaught JAXP/Xalan error (such
1:f67c2ee:              * as a NullPointerException) causing Derby to fail in a more
1:f67c2ee:              * serious way.  In particular, an uncaught Java exception
1:f67c2ee:              * like NPE can result in Derby throwing "ERROR 40XT0: An
1:f67c2ee:              * internal error was identified by RawStore module" for all
1:f67c2ee:              * statements on the connection after the failure--which we
1:f67c2ee:              * clearly don't want.  If we catch the error and wrap it,
1:f67c2ee:              * though, the statement will fail but Derby will continue to
1:f67c2ee:              * run as normal.
1:0c5a8eb:              */ 
1:6e7bbc8:             throw StandardException.newException(
1:8cefbbc:                 SQLState.LANG_UNEXPECTED_XML_EXCEPTION, t, t.getMessage());
1:6e7bbc8: 
1:0c5a8eb:         }
1:6e7bbc8: 
1:6e7bbc8:         // At construction time we don't have an XML query expression
1:6e7bbc8:         // to compile.  If one is required, we'll load/compile it later.
1:6e7bbc8:         query = null;
1:3bcc92e:     }
1:6e7bbc8: 
1:6e7bbc8:     /**
1:6e7bbc8:      * Take the received string, which is an XML query expression,
1:6e7bbc8:      * compile it, and store the compiled query locally.  Note
1:6e7bbc8:      * that for now, we only support XPath because that's what
1:6e7bbc8:      * Xalan supports.
1:6e7bbc8:      *
1:6e7bbc8:      * @param queryExpr The XPath expression to compile
1:f67c2ee:      */
1:f67c2ee:     public void compileXQExpr(String queryExpr, String opName)
1:6e7bbc8:         throws StandardException
1:0c5a8eb:     {
1:6e7bbc8:         try {
1:6e7bbc8: 
1:f67c2ee:             /* The following XPath constructor compiles the expression
1:5283796:              * as part of the construction process.  We pass a null
1:1ffa77b:              * namespace context object so that prefixes will not be resolved
1:f67c2ee:              * in the query (Xalan will just throw an error if a prefix
1:f67c2ee:              * is used).  In the future we may want to revisit this
1:f67c2ee:              * to make it easier for users to query based on namespaces.
1:f67c2ee:              */
1:1ffa77b:             XPath xpath = XPathFactory.newInstance().newXPath();
1:1ffa77b:             xpath.setNamespaceContext(NullNamespaceContext.SINGLETON);
1:6e7bbc8: 
1:1ffa77b:             query = xpath.compile(queryExpr);
1:6e7bbc8: 
1:f67c2ee:         } catch (Throwable te) {
1:6e7bbc8: 
1:f67c2ee:             /* Something went wrong during compilation of the
1:f67c2ee:              * expression; wrap the error and re-throw it.
1:f67c2ee:              * Note: we catch "Throwable" here to catch as many
1:f67c2ee:              * Xalan-produced errors as possible in order to
1:f67c2ee:              * minimize the chance of an uncaught Xalan error
1:f67c2ee:              * (such as a NullPointerException) causing Derby
1:f67c2ee:              * to fail in a more serious way.  In particular, an
1:f67c2ee:              * uncaught Java exception like NPE can result in
1:f67c2ee:              * Derby throwing "ERROR 40XT0: An internal error was
1:f67c2ee:              * identified by RawStore module" for all statements on
1:f67c2ee:              * the connection after the failure--which we clearly
1:f67c2ee:              * don't want.  If we catch the error and wrap it,
1:f67c2ee:              * though, the statement will fail but Derby will
1:f67c2ee:              * continue to run as normal. 
1:f67c2ee:              */
1:6e7bbc8:             throw StandardException.newException(
1:b23250c:                 SQLState.LANG_XML_QUERY_ERROR, te, opName, te.getMessage());
1:6e7bbc8: 
1:9f654e5:         }
1:6e7bbc8:     }
1:6e7bbc8: 
1:6e7bbc8:     /**
1:6e7bbc8:      * Take a string representing an XML value and serialize it
1:6e7bbc8:      * according SQL/XML serialization rules.  Right now, we perform
1:6e7bbc8:      * this serialization by first parsing the string into a JAXP
1:6e7bbc8:      * Document object, and then applying the serialization semantics
1:6e7bbc8:      * to that Document.  That seems a bit inefficient, but neither
1:6e7bbc8:      * Xalan nor JAXP provides a more direct way to do this.
1:6e7bbc8:      *
1:6e7bbc8:      * @param xmlAsText String version of XML on which to perform
1:6e7bbc8:      *   serialization.
1:6e7bbc8:      * @return A properly serialized version of xmlAsText.
1:6e7bbc8:      */
1:6e7bbc8:     protected String serializeToString(String xmlAsText)
2:6e7bbc8:         throws Exception
1:6e7bbc8:     {
1:7139f7c:         Document doc;
1:6e7bbc8: 
1:378aa34:         /* The call to dBuilder.parse() is a call to an external
1:378aa34:          * (w.r.t. to Derby) JAXP parser.  If the received XML
1:378aa34:          * text references an external DTD, then the JAXP parser
1:378aa34:          * will try to read that external DTD.  Thus we wrap the
1:378aa34:          * call to parse inside a privileged action to make sure
1:378aa34:          * that the JAXP parser has the required permissions for
1:378aa34:          * reading the DTD file.
1:6e7bbc8:          */
1:5283796:         try {
1:6e7bbc8: 
1:95685b1:             final InputSource is = new InputSource(new StringReader(xmlAsText));
1:7139f7c:             doc = java.security.AccessController.doPrivileged(
1:a8b9c70:                 new java.security.PrivilegedExceptionAction<Document>()
1:6e7bbc8:                 {
1:a8b9c70:                     public Document run() throws IOException, SAXException
1:6e7bbc8:                     {
1:95685b1:                         return dBuilder.parse(is);
1:6e7bbc8:                     }
1:7139f7c:                 });
1:6e7bbc8: 
1:95685b1:         } catch (java.security.PrivilegedActionException pae) {
1:6e7bbc8: 
1:95685b1:             /* Unwrap the privileged exception so that the user can
1:95685b1:              * see what the underlying error is. For example, it could
1:95685b1:              * be an i/o error from parsing the XML value, which can
1:95685b1:              * happen if the XML value references an external DTD file
1:95685b1:              * but the JAXP parser hits an i/o error when trying to read
1:95685b1:              * the DTD.  In that case we want to throw the i/o error
1:95685b1:              * itself so that it does not appear as a security exception
1:95685b1:              * to the user.
1:6e7bbc8:              */
1:95685b1:             throw pae.getException();
1:6e7bbc8: 
1:6e7bbc8:         }
1:6e7bbc8: 
1:0c5a8eb:         /* The second argument in the following call is for
1:0c5a8eb:          * catching cases where we have a top-level (parentless)
1:0c5a8eb:          * attribute node--but since we just created the list
1:0c5a8eb:          * with a single Document node, we already we know we
1:0c5a8eb:          * don't have a top-level attribute node in the list,
1:0c5a8eb:          * so we don't have to worry.  Hence the "null" here.
1:0c5a8eb:          */
1:7139f7c:         return serializeToString(Collections.singletonList(doc), null);
1:6e7bbc8:     }
1:6e7bbc8: 
1:6e7bbc8:     /**
1:6e7bbc8:      * Take an array list (sequence) of XML nodes and/or string values
1:6e7bbc8:      * and serialize that entire list according to SQL/XML serialization
1:0c5a8eb:      * rules, which ultimately point to XML serialization rules as
1:0c5a8eb:      * defined by w3c.  As part of that serialization process we have
1:0c5a8eb:      * to first "normalize" the sequence.  We do that by iterating through
1:0c5a8eb:      * the list and performing the steps for "sequence normalization" as
1:0c5a8eb:      * defined here:
1:0c5a8eb:      *
1:0c5a8eb:      * http://www.w3.org/TR/xslt-xquery-serialization/#serdm
1:0c5a8eb:      *
1:0c5a8eb:      * This method primarily focuses on taking the steps for normalization;
1:0c5a8eb:      * for the rest of the serialization work, we just make calls on the
1:0c5a8eb:      * DOMSerializer class provided by Xalan.
1:6e7bbc8:      *
1:7139f7c:      * @param items List of items to serialize. It should either be
1:7139f7c:      *  a list of a single string value (in case it's the result of
1:7139f7c:      *  an XMLQUERY operation that returns an atomic value), or a list
1:7139f7c:      *  of zero or more Node objects.
1:0c5a8eb:      * @param xmlVal XMLDataValue into which the serialized string
1:0c5a8eb:      *  returned by this method is ultimately going to be stored.
1:0c5a8eb:      *  This is used for keeping track of XML values that represent
1:0c5a8eb:      *  sequences having top-level (parentless) attribute nodes.
1:0c5a8eb:      * @return Single string holding the serialized version of the
1:0c5a8eb:      *  normalized sequence created from the items in the received
1:0c5a8eb:      *  list.
1:6e7bbc8:      */
1:5283796:     protected String serializeToString(List items,
1:5283796:         XMLDataValue xmlVal) throws TransformerException
1:6e7bbc8:     {
1:7139f7c:         // If we have an empty sequence, return an empty value immediately.
1:7139f7c:         if (items.isEmpty()) {
1:6e7bbc8:             return "";
1:6e7bbc8:         }
1:6e7bbc8: 
1:7139f7c:         // If it contains a single string, just return that string.
1:7139f7c:         if (items.size() == 1 && items.get(0) instanceof String) {
1:7139f7c:             return (String) items.get(0);
1:7139f7c:         }
1:6e7bbc8: 
1:7139f7c:         // Otherwise, it's a non-empty list of Node objects.
1:6e7bbc8: 
1:7139f7c:         StringWriter sWriter = new StringWriter();
1:6e7bbc8: 
1:6e7bbc8:         // Serializer should have been set by now.
1:6e7bbc8:         if (SanityManager.DEBUG)
1:6e7bbc8:         {
1:6e7bbc8:             SanityManager.ASSERT(serializer != null,
1:6e7bbc8:                 "Tried to serialize with uninitialized XML serializer.");
1:6e7bbc8:         }
1:6e7bbc8: 
1:6e7bbc8:         // Iterate through the list and serialize each item.
1:a8b9c70:         for (Object obj : items)
1:0c5a8eb:         {
1:7139f7c:             if (obj instanceof Attr)
1:0c5a8eb:             {
1:0c5a8eb:                 /* Step 7a: Attribute nodes.  If there is an Attribute node
1:0c5a8eb:                  * node in the sequence then we have to throw a serialization
1:0c5a8eb:                  * error.  NOTE: The rules say we also have to throw an error
1:0c5a8eb:                  * for Namespace nodes, but JAXP doesn't define a "Namespace"
1:0c5a8eb:                  * object per se; it just defines namespace prefixes and URIs
1:0c5a8eb:                  * on other Nodes.  So we just check for attributes.  If we
1:0c5a8eb:                  * find one then we take note of the fact that the result has
1:0c5a8eb:                  * a parentless attribute node and later, if the user calls
1:0c5a8eb:                  * XMLSERIALIZE on the received XMLDataValue we'll throw the
1:0c5a8eb:                  * error as required.  Note that we currently only get here
1:0c5a8eb:                  * for the XMLQUERY operator, which means we're serializing
1:0c5a8eb:                  * a result sequence returned from Xalan and we're going to
1:0c5a8eb:                  * store the serialized version into a Derby XML value.  In
1:0c5a8eb:                  * that case the serialization is an internal operation--and
1:0c5a8eb:                  * since the user didn't ask for it, we don't want to throw
1:0c5a8eb:                  * the serialization error here.  If we did, then whenever an
1:0c5a8eb:                  * XMLQUERY operation returned a result sequence with a top-
1:0c5a8eb:                  * level attribute in it, the user would see a serialization
1:0c5a8eb:                  * error. That's not correct since it is technically okay for
1:0c5a8eb:                  * the XMLQUERY operation to return a sequence with an attribute
1:0c5a8eb:                  * node; it's just not okay for a user to explicitly try to
1:0c5a8eb:                  * serialize that sequence. So instead of throwing the error
1:0c5a8eb:                  * here, we just take note of the fact that the sequence has
1:0c5a8eb:                  * a top-level attribute.  Then later, IF the user makes an
1:0c5a8eb:                  * explicit call to serialize the sequence, we'll throw the
1:0c5a8eb:                  * appropriate error (see XML.XMLSerialize()).
1:0c5a8eb:                  */
1:0c5a8eb:                 xmlVal.markAsHavingTopLevelAttr();
1:5283796:                 serializer.transform(
1:5283796:                         new DOMSource((Node) obj), new StreamResult(sWriter));
1:0c5a8eb:             }
1:6e7bbc8:             else
1:6e7bbc8:             { // We have a Node, so try to serialize it.
1:6e7bbc8:                 Node n = (Node)obj;
1:6e7bbc8:                 if (n instanceof Text)
1:0c5a8eb:                 {
1:0c5a8eb:                     /* Step 6: Combine adjacent text nodes into a single
1:0c5a8eb:                      * text node.  Since we're just going to serialize the
1:0c5a8eb:                      * Text node back into a string, we short-cut this step
1:0c5a8eb:                      * by skipping the creation of a new Text node and just
1:0c5a8eb:                      * writing the text value out directly to our serialized
1:0c5a8eb:                      * stream.  Step 6 also says that empty text nodes should
1:0c5a8eb:                      * be dropped--but if the text node is empty, the call
1:0c5a8eb:                      * to getNodeValue() will return an empty string and
1:0c5a8eb:                      * thus we've effectively "dropped" the text node from
1:0c5a8eb:                      * the serialized result.  Note: it'd be cleaner to just
1:0c5a8eb:                      * call "serialize()" on the Text node like we do for
1:0c5a8eb:                      * all other Nodes, but Xalan doesn't allow that.  So
1:0c5a8eb:                      * use the getNodeValue() method instead.
1:0c5a8eb:                      */
1:6e7bbc8:                     sWriter.write(n.getNodeValue());
1:0c5a8eb:                 }
1:6e7bbc8:                 else
1:0c5a8eb:                 {
1:0c5a8eb:                     /* Steps 5 and 7b: Copy all non-attribute, non-text
1:0c5a8eb:                      * nodes to the "normalized sequence" and then serialize
1:0c5a8eb:                      * that normalized sequence.  We short-cut this by
1:0c5a8eb:                      * just letting Xalan do the serialization for every
1:0c5a8eb:                      * Node in the current list of items that wasn't
1:0c5a8eb:                      * "serialized" as an atomic value, attribute, or
1:0c5a8eb:                      * text node.
1:0c5a8eb:                      */
1:5283796:                     serializer.transform(
1:5283796:                             new DOMSource(n), new StreamResult(sWriter));
1:0c5a8eb:                 }
1:6e7bbc8:             }
1:6e7bbc8:         }
1:0c5a8eb: 
1:0c5a8eb:         /* At this point sWriter holds the serialized version of the
1:0c5a8eb:          * normalized sequence that corresponds to the received list
1:0c5a8eb:          * of items.  So that's what we return.
1:0c5a8eb:          */
1:6e7bbc8:         sWriter.flush();
1:6e7bbc8:         return sWriter.toString();
1:6e7bbc8:     }
1:6e7bbc8: 
1:6e7bbc8:     /**
1:6e7bbc8:      * Evaluate this object's compiled XML query expression against
1:9f654e5:      * the received xmlContext.  Then if returnResults is false,
1:9f654e5:      * return an empty sequence (ArrayList) if evaluation yields
1:9f654e5:      * at least one item and return null if evaluation yields zero
1:9f654e5:      * items (the caller can then just check for null to see if the
1:9f654e5:      * query returned any items).  If returnResults is true, then return
1:9f654e5:      * return a sequence (ArrayList) containing all items returned
1:9f654e5:      * from evaluation of the expression.  This array list can contain
1:9f654e5:      * any combination of atomic values and XML nodes; it may also
1:9f654e5:      * be empty.
1:6e7bbc8:      *
1:6e7bbc8:      * Assumption here is that the query expression has already been
1:6e7bbc8:      * compiled and is stored in this.query.
1:6e7bbc8:      *
1:6e7bbc8:      * @param xmlContext The XML value against which to evaluate
1:9f654e5:      *  the stored (compiled) query expression
1:9f654e5:      * @param returnResults Whether or not to return the actual
1:9f654e5:      *  results of the query
1:9f654e5:      * @param resultXType The qualified XML type of the result
1:9f654e5:      *  of evaluating the expression, if returnResults is true.
1:f67c2ee:      *  If the result is a sequence of exactly one Document node
1:9f654e5:      *  then this will be XML(DOCUMENT(ANY)); else it will be
1:9f654e5:      *  XML(SEQUENCE).  If returnResults is false, this value
1:9f654e5:      *  is ignored.
1:9f654e5:      * @return If returnResults is false then return an empty
1:9f654e5:      *  ArrayList if evaluation returned at least one item and return
1:9f654e5:      *  null otherwise.  If returnResults is true then return an
1:9f654e5:      *  array list containing all of the result items and return
1:9f654e5:      *  the qualified XML type via the resultXType parameter.
1:6e7bbc8:      * @exception Exception thrown on error (and turned into a
1:6e7bbc8:      *  StandardException by the caller).
1:6e7bbc8:      */
1:5283796:     protected List evalXQExpression(XMLDataValue xmlContext,
1:9f654e5:         boolean returnResults, int [] resultXType) throws Exception
1:6e7bbc8:     {
1:6e7bbc8:         // Make sure we have a compiled query.
1:6e7bbc8:         if (SanityManager.DEBUG) {
1:6e7bbc8:             SanityManager.ASSERT(
1:5283796:                 (query != null),
1:6e7bbc8:                 "Failed to locate compiled XML query expression.");
1:6e7bbc8:         }
1:6e7bbc8: 
1:9f654e5:         /* Create a DOM node from the xmlContext, since that's how
1:9f654e5:          * we feed the context to Xalan.  We do this by creating
1:9f654e5:          * a Document node using DocumentBuilder, which means that
1:9f654e5:          * the serialized form of the context node must be a string
1:9f654e5:          * value that is parse-able by DocumentBuilder--i.e. it must
1:9f654e5:          * constitute a valid XML document.  If that's true then
1:9f654e5:          * the context item's qualified type will be DOC_ANY.
1:9f654e5:          */
1:9f654e5:         if (xmlContext.getXType() != XML.XML_DOC_ANY)
1:9f654e5:         {
1:9f654e5:             throw StandardException.newException(
1:9f654e5:                 SQLState.LANG_INVALID_XML_CONTEXT_ITEM,
1:9f654e5:                 (returnResults ? "XMLQUERY" : "XMLEXISTS"));
1:9f654e5:         } 
1:9f654e5: 
1:1ffa77b:         Document docNode = dBuilder.parse(
1:6e7bbc8:             new InputSource(
1:6e7bbc8:                 new StringReader(xmlContext.getString())));
1:6e7bbc8: 
1:1ffa77b:         Object result = evaluate(docNode);
1:6e7bbc8: 
1:9f654e5:         if (!returnResults)
1:9f654e5:         {
1:1ffa77b:             // This is for XMLEXISTS.
1:1ffa77b:             //
1:9f654e5:             // We don't want to return the actual results, we just
1:9f654e5:             // want to know if there was at least one item in the
1:9f654e5:             // result sequence.
1:1ffa77b:             if (result instanceof NodeList
1:1ffa77b:                     && ((NodeList) result).getLength() == 0) {
1:1ffa77b:                 // We have an empty sequence, so return null to indicate
1:1ffa77b:                 // there were no results from the query.
1:9f654e5:                 return null;
1:1ffa77b:             } else {
1:1ffa77b:                 // We have either a non-empty sequence or a scalar, so
1:1ffa77b:                 // return a non-null value to indicate that we found at
1:1ffa77b:                 // least one item.
1:1ffa77b:                 return Collections.emptyList();
1:9f654e5:             }
1:9f654e5:         }
1:9f654e5: 
1:9f654e5:         // Else process the results.
1:5283796:         List itemRefs;
1:1ffa77b:         if (result instanceof NodeList) {
1:1ffa77b:             NodeList list = (NodeList) result;
1:1ffa77b:             ArrayList<Node> nodes = new ArrayList<Node>();
1:1ffa77b:             for (int i = 0; i < list.getLength(); i++) {
1:1ffa77b:                 nodes.add(list.item(i));
1:9f654e5:             }
1:1ffa77b:             itemRefs = nodes;
1:1ffa77b:         } else {
1:1ffa77b:             itemRefs = Collections.singletonList(result);
1:9f654e5:         }
1:9f654e5: 
1:f67c2ee:         /* Indicate what kind of XML result value we have.  If
1:f67c2ee:          * we have a sequence of exactly one Document then it
1:f67c2ee:          * is XMLPARSE-able and so we consider it to be of type
1:f67c2ee:          * XML_DOC_ANY (which means we can store it in a Derby
1:f67c2ee:          * XML column).
1:f67c2ee:          */
1:5283796:         if ((itemRefs.size() == 1) && (itemRefs.get(0) instanceof Document))
1:9f654e5:             resultXType[0] = XML.XML_DOC_ANY;
1:9f654e5:         else
1:9f654e5:             resultXType[0] = XML.XML_SEQUENCE;
1:9f654e5: 
1:9f654e5:         return itemRefs;
1:6e7bbc8:     }
1:9f654e5: 
1:6e7bbc8:     /* ****
1:6e7bbc8:      * Helper classes and methods.
1:6e7bbc8:      * */
1:6e7bbc8: 
1:6e7bbc8:     /**
1:1ffa77b:      * Evaluate the XPath query on the specified document.
1:6e7bbc8:      */
1:1ffa77b:     private Object evaluate(Document doc) throws XPathExpressionException {
1:6e7bbc8: 
1:1ffa77b:         // If we know the return type, just evaluate the expression with
1:1ffa77b:         // that type.
1:1ffa77b:         if (returnType != null) {
1:1ffa77b:             return query.evaluate(doc, returnType);
1:6e7bbc8:         }
1:6e7bbc8: 
1:1ffa77b:         // Otherwise, first try to evaluate the expression as if it returned
1:1ffa77b:         // a set of nodes. If that fails, evaluate it as if it returned a
1:1ffa77b:         // string. Remember which type was successful so that we can use that
1:1ffa77b:         // type directly the next time we evaluate the expression.
1:1ffa77b:         try {
1:1ffa77b:             Object result = query.evaluate(doc, XPathConstants.NODESET);
1:1ffa77b:             returnType = XPathConstants.NODESET;
1:1ffa77b:             return result;
1:b23250c:         } catch (Exception xpee) {
1:b23250c:             // Retry with the string type if an XPathExpressionException is
1:b23250c:             // thrown. The catch block is broader and retries on all kinds of
1:b23250c:             // exceptions. The reason is that IBM fails with a runtime
1:b23250c:             // exception that shadows the XPathExpressionException, if a
1:b23250c:             // security manager is installed. See DERBY-6637 for details.
1:1ffa77b:             Object result = query.evaluate(doc, XPathConstants.STRING);
1:1ffa77b:             returnType = XPathConstants.STRING;
1:1ffa77b:             return result;
1:6e7bbc8:         }
1:1ffa77b:     }
1:6e7bbc8: 
1:6e7bbc8:     /**
1:6e7bbc8:      * Create an instance of Xalan serializer for the sake of
1:6e7bbc8:      * serializing an XML value according the SQL/XML specification
1:6e7bbc8:      * for serialization.
1:6e7bbc8:      */
1:5283796:     private void loadSerializer() throws TransformerConfigurationException
1:9f654e5:     {
1:6e7bbc8:         // Set serialization properties.
1:5283796:         Properties props = new Properties();
1:6e7bbc8: 
1:6e7bbc8:         // SQL/XML[2006] 10.15:General Rules:6 says method is "xml".
1:6e7bbc8:         props.setProperty(OutputKeys.METHOD, "xml");
1:6e7bbc8: 
1:6e7bbc8:         /* Since the XMLSERIALIZE operator doesn't currently support
1:6e7bbc8:          * the DOCUMENT nor CONTENT keywords, SQL/XML spec says that
1:6e7bbc8:          * the default is CONTENT (6.7:Syntax Rules:2.a).  Further,
1:6e7bbc8:          * since the XMLSERIALIZE operator doesn't currently support the
1:6e7bbc8:          * <XML declaration option> syntax, the SQL/XML spec says
1:6e7bbc8:          * that the default for that option is "Unknown" (6.7:General
1:6e7bbc8:          * Rules:2.f).  Put those together and that in turn means that
1:6e7bbc8:          * the value of "OMIT XML DECLARATION" must be "Yes", as
1:6e7bbc8:          * stated in section 10.15:General Rules:8.c.  SO, that's what
1:6e7bbc8:          * we set here.
1:6e7bbc8:          *
1:6e7bbc8:          * NOTE: currently the only way to view the contents of an
1:6e7bbc8:          * XML column is by using an explicit XMLSERIALIZE operator.
1:6e7bbc8:          * This means that if an XML document is stored and it
1:6e7bbc8:          * begins with an XML declaration, the user will never be
1:6e7bbc8:          * able to _see_ that declaration after inserting the doc
1:6e7bbc8:          * because, as explained above, our current support for
1:6e7bbc8:          * XMLSERIALIZE dictates that the declaration must be
1:6e7bbc8:          * omitted.  Similarly, other transformations that may
1:6e7bbc8:          * occur from serialization (ex. entity replacement,
1:6e7bbc8:          * attribute order, single-to-double quotes, etc)) will
1:6e7bbc8:          * always be in effect for the string returned to the user;
1:6e7bbc8:          * the original form of the XML document, if different
1:6e7bbc8:          * from the serialized version, is not currently retrievable.
1:6e7bbc8:          */
1:6e7bbc8:         props.setProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
1:6e7bbc8: 
1:6e7bbc8:         // We serialize everything as UTF-8 to match what we
1:6e7bbc8:         // store on disk.
1:6e7bbc8:         props.setProperty(OutputKeys.ENCODING, "UTF-8");
1:6e7bbc8: 
1:6e7bbc8:         // Load the serializer with the correct properties.
1:5283796:         serializer = TransformerFactory.newInstance().newTransformer();
1:5283796:         serializer.setOutputProperties(props);
1:6e7bbc8:     }
1:6e7bbc8: 
1:6e7bbc8:     /*
1:6e7bbc8:      ** The XMLErrorHandler class is just a generic implementation
1:6e7bbc8:      ** of the ErrorHandler interface.  It allows us to catch
1:6e7bbc8:      ** and process XML parsing errors in a graceful manner.
1:6e7bbc8:      */
1:6e7bbc8:     private class XMLErrorHandler implements ErrorHandler
1:6e7bbc8:     {
1:6e7bbc8:         public void error (SAXParseException exception)
1:6e7bbc8:             throws SAXException
1:6e7bbc8:         {
1:6e7bbc8:             throw new SAXException (exception);
1:6e7bbc8:         }
1:6e7bbc8: 
1:6e7bbc8:         public void fatalError (SAXParseException exception)
1:6e7bbc8:             throws SAXException
1:6e7bbc8:         {
1:6e7bbc8:             throw new SAXException (exception);
1:6e7bbc8:         }
1:6e7bbc8: 
1:6e7bbc8:         public void warning (SAXParseException exception)
1:6e7bbc8:             throws SAXException
1:6e7bbc8:         {
1:6e7bbc8:             throw new SAXException (exception);
1:6e7bbc8:         }
1:6e7bbc8:     }
1:6e7bbc8: 
1:1ffa77b:     /**
1:1ffa77b:      * A NamespaceContext that reports all namespaces as unbound.
1:6e7bbc8:      */
1:1ffa77b:     private static class NullNamespaceContext implements NamespaceContext {
1:7139f7c: 
1:1ffa77b:         private final static NullNamespaceContext
1:1ffa77b:                 SINGLETON = new NullNamespaceContext();
1:7139f7c: 
1:1ffa77b:         @Override
1:1ffa77b:         public String getNamespaceURI(String prefix) {
1:1ffa77b:             return XMLConstants.NULL_NS_URI;
1:6e7bbc8:         }
1:1ffa77b: 
1:1ffa77b:         @Override
1:1ffa77b:         public String getPrefix(String namespaceURI) {
1:1ffa77b:             return null;
1:1ffa77b:         }
1:1ffa77b: 
1:1ffa77b:         @Override
1:1ffa77b:         public Iterator getPrefixes(String namespaceURI) {
1:1ffa77b:             return Collections.emptyList().iterator();
1:1ffa77b:         }
1:1ffa77b:     }
4:1ffa77b: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:a72ebf9
/////////////////////////////////////////////////////////////////////////
1:             if ( System.getSecurityManager() == null )
1:             {
1:                 dBF.setFeature( XMLConstants.FEATURE_SECURE_PROCESSING, true );
1:                 dBF.setFeature(
1:                  "http://xml.org/sax/features/external-general-entities", false );
1:             }
1: 
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:0c5a8eb
/////////////////////////////////////////////////////////////////////////
1: import org.w3c.dom.Attr;
/////////////////////////////////////////////////////////////////////////
1: 
1:         /* The second argument in the following call is for
1:          * catching cases where we have a top-level (parentless)
1:          * attribute node--but since we just created the list
1:          * with a single Document node, we already we know we
1:          * don't have a top-level attribute node in the list,
1:          * so we don't have to worry.  Hence the "null" here.
1:          */
0:         return serializeToString(aList, null);
1:      * rules, which ultimately point to XML serialization rules as
1:      * defined by w3c.  As part of that serialization process we have
1:      * to first "normalize" the sequence.  We do that by iterating through
1:      * the list and performing the steps for "sequence normalization" as
1:      * defined here:
1:      *
1:      * http://www.w3.org/TR/xslt-xquery-serialization/#serdm
1:      *
1:      * This method primarily focuses on taking the steps for normalization;
1:      * for the rest of the serialization work, we just make calls on the
1:      * DOMSerializer class provided by Xalan.
1:      * @param xmlVal XMLDataValue into which the serialized string
1:      *  returned by this method is ultimately going to be stored.
1:      *  This is used for keeping track of XML values that represent
1:      *  sequences having top-level (parentless) attribute nodes.
1:      * @return Single string holding the serialized version of the
1:      *  normalized sequence created from the items in the received
1:      *  list.
0:     protected String serializeToString(ArrayList items,
0:         XMLDataValue xmlVal) throws java.io.IOException
/////////////////////////////////////////////////////////////////////////
0:         /* Step 1: Empty sequence.  If we have an empty sequence then we
0:          * won't ever enter the for loop and the call to sWriter.toString()
0:          * at the end of this method will return an empty string, as
0:          * required.  Otherwise, for a non-empty sequence our "items"
0:          * list already corresponds to "S1".
1:          */
1: 
0:         boolean lastItemWasString = false;
0:             if (obj instanceof String)
1:             {
0:                 /* Step 2: Atomic values.  If "obj" is a string then it
0:                  * corresponds to some atomic value whose "lexical
0:                  * representation" is obj.  So we just take that.
1:                  */
1: 
0:                 if (lastItemWasString)
1:                 {
0:                     /* Step 3: Adjacent strings.  If we have multiple adjacent
0:                      * strings then concatenate them with a single space
0:                      * between them.
1:                      */
0:                     sWriter.write(" ");
1:                 }
1: 
0:                 /* Step 4: Create a Text node from the adjacent strings.
0:                  * Since we're just going to serialize the Text node back
0:                  * into a string, we short-cut this step by skipping the
0:                  * creation of the Text node and just writing the string
0:                  * out directly to our serialized stream.
1:                  */
0:                 lastItemWasString = true;
1:             }
0:             else if (obj instanceof Attr)
1:             {
1:                 /* Step 7a: Attribute nodes.  If there is an Attribute node
1:                  * node in the sequence then we have to throw a serialization
1:                  * error.  NOTE: The rules say we also have to throw an error
1:                  * for Namespace nodes, but JAXP doesn't define a "Namespace"
1:                  * object per se; it just defines namespace prefixes and URIs
1:                  * on other Nodes.  So we just check for attributes.  If we
1:                  * find one then we take note of the fact that the result has
1:                  * a parentless attribute node and later, if the user calls
1:                  * XMLSERIALIZE on the received XMLDataValue we'll throw the
1:                  * error as required.  Note that we currently only get here
1:                  * for the XMLQUERY operator, which means we're serializing
1:                  * a result sequence returned from Xalan and we're going to
1:                  * store the serialized version into a Derby XML value.  In
1:                  * that case the serialization is an internal operation--and
1:                  * since the user didn't ask for it, we don't want to throw
1:                  * the serialization error here.  If we did, then whenever an
1:                  * XMLQUERY operation returned a result sequence with a top-
1:                  * level attribute in it, the user would see a serialization
1:                  * error. That's not correct since it is technically okay for
1:                  * the XMLQUERY operation to return a sequence with an attribute
1:                  * node; it's just not okay for a user to explicitly try to
1:                  * serialize that sequence. So instead of throwing the error
1:                  * here, we just take note of the fact that the sequence has
1:                  * a top-level attribute.  Then later, IF the user makes an
1:                  * explicit call to serialize the sequence, we'll throw the
1:                  * appropriate error (see XML.XMLSerialize()).
1:                  */
0:                 if (xmlVal != null)
1:                     xmlVal.markAsHavingTopLevelAttr();
0:                 dSer.serialize((Node)obj);
0:                 lastItemWasString = false;
1:             }
1:                 {
1:                     /* Step 6: Combine adjacent text nodes into a single
1:                      * text node.  Since we're just going to serialize the
1:                      * Text node back into a string, we short-cut this step
1:                      * by skipping the creation of a new Text node and just
1:                      * writing the text value out directly to our serialized
1:                      * stream.  Step 6 also says that empty text nodes should
1:                      * be dropped--but if the text node is empty, the call
1:                      * to getNodeValue() will return an empty string and
1:                      * thus we've effectively "dropped" the text node from
1:                      * the serialized result.  Note: it'd be cleaner to just
1:                      * call "serialize()" on the Text node like we do for
1:                      * all other Nodes, but Xalan doesn't allow that.  So
1:                      * use the getNodeValue() method instead.
1:                      */
1:                 }
1:                 {
1:                     /* Steps 5 and 7b: Copy all non-attribute, non-text
1:                      * nodes to the "normalized sequence" and then serialize
1:                      * that normalized sequence.  We short-cut this by
1:                      * just letting Xalan do the serialization for every
1:                      * Node in the current list of items that wasn't
1:                      * "serialized" as an atomic value, attribute, or
1:                      * text node.
1:                      */
1:                 }
1: 
0:                 lastItemWasString = false;
1:         /* At this point sWriter holds the serialized version of the
1:          * normalized sequence that corresponds to the received list
1:          * of items.  So that's what we return.
1:          */
commit:f67c2ee
/////////////////////////////////////////////////////////////////////////
0: import org.apache.xml.utils.PrefixResolverDefault;
1: 
/////////////////////////////////////////////////////////////////////////
1:         } catch (Throwable t) {
1:             /* Must be something caused by JAXP or Xalan; wrap it in a
1:              * StandardException and rethrow it. Note: we catch "Throwable"
1:              * here to catch as many external errors as possible in order
1:              * to minimize the chance of an uncaught JAXP/Xalan error (such
1:              * as a NullPointerException) causing Derby to fail in a more
1:              * serious way.  In particular, an uncaught Java exception
1:              * like NPE can result in Derby throwing "ERROR 40XT0: An
1:              * internal error was identified by RawStore module" for all
1:              * statements on the connection after the failure--which we
1:              * clearly don't want.  If we catch the error and wrap it,
1:              * though, the statement will fail but Derby will continue to
1:              * run as normal.
1:              */ 
0:                 SQLState.LANG_UNEXPECTED_XML_EXCEPTION, t);
/////////////////////////////////////////////////////////////////////////
1:     public void compileXQExpr(String queryExpr, String opName)
1:             /* The following XPath constructor compiles the expression
0:              * as part of the construction process.  We have to pass
0:              * in a PrefixResolver object in order to avoid NPEs when
0:              * invalid/unknown functions are used, so we just create
0:              * a dummy one, which means prefixes will not be resolved
1:              * in the query (Xalan will just throw an error if a prefix
1:              * is used).  In the future we may want to revisit this
1:              * to make it easier for users to query based on namespaces.
1:              */
0:             query = new XPath(queryExpr, null,
0:                 new PrefixResolverDefault(dBuilder.newDocument()),
0:                 XPath.SELECT);
1:         } catch (Throwable te) {
1:             /* Something went wrong during compilation of the
1:              * expression; wrap the error and re-throw it.
1:              * Note: we catch "Throwable" here to catch as many
1:              * Xalan-produced errors as possible in order to
1:              * minimize the chance of an uncaught Xalan error
1:              * (such as a NullPointerException) causing Derby
1:              * to fail in a more serious way.  In particular, an
1:              * uncaught Java exception like NPE can result in
1:              * Derby throwing "ERROR 40XT0: An internal error was
1:              * identified by RawStore module" for all statements on
1:              * the connection after the failure--which we clearly
1:              * don't want.  If we catch the error and wrap it,
1:              * though, the statement will fail but Derby will
1:              * continue to run as normal. 
1:              */
0:                 SQLState.LANG_XML_QUERY_ERROR, te, opName);
/////////////////////////////////////////////////////////////////////////
1:      *  If the result is a sequence of exactly one Document node
/////////////////////////////////////////////////////////////////////////
1:         /* Indicate what kind of XML result value we have.  If
1:          * we have a sequence of exactly one Document then it
1:          * is XMLPARSE-able and so we consider it to be of type
1:          * XML_DOC_ANY (which means we can store it in a Derby
1:          * XML column).
1:          */
0:         if ((numItems == 1) && (itemRefs.get(0) instanceof Document))
commit:e185894
/////////////////////////////////////////////////////////////////////////
0:                 SQLState.LANG_XML_QUERY_ERROR, te);
commit:3bcc92e
/////////////////////////////////////////////////////////////////////////
1:  *       deeper in the execution codepath.  The initial check for the
1:  *       required XML classes can be found in XML.checkXMLRequirements().
/////////////////////////////////////////////////////////////////////////
1:             DocumentBuilderFactory dBF = null;
1:             try {
1: 
1:                 dBF = DocumentBuilderFactory.newInstance();
1: 
1:             } catch (Throwable e) {
1: 
1:                 /* We assume that if we get an error creating the
1:                  * DocumentBuilderFactory, it's because there's no
1:                  * JAXP implementation.  This can happen in the
1:                  * (admittedly unlikely) case where the classpath
0:                  * contains the JAXP _interfaces_ (ex. via xml-apis.jar)
1:                  * and the Xalan classes but does not actually
1:                  * contain a JAXP _implementation_.  In that case the
1:                  * check in XML.checkXMLRequirements() will pass
1:                  * and this class (SqlXmlUtil) will be instantiated
1:                  * successfully--which is how we get to this constructor.
1:                  * But then attempts to create a DocumentBuilderFactory
1:                  * will fail, bringing us here.  Note that we can't
1:                  * check for a valid JAXP implementation in the
1:                  * XML.checkXMLRequirements() method because we
1:                  * always want to allow the XML.java class to be
1:                  * instantiated, even if the required XML classes
1:                  * are not present--and that means that it (the
1:                  * XML class) cannot reference DocumentBuilder nor
1:                  * any of the JAXP classes directly.
1:                  */
1:                  throw StandardException.newException(
1:                      SQLState.LANG_MISSING_XML_CLASSES, "JAXP");
1: 
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:         } catch (StandardException se) {
1: 
1:             // Just rethrow it.
1:             throw se;
1: 
commit:9f654e5
/////////////////////////////////////////////////////////////////////////
0: import org.w3c.dom.Element;
1: import org.w3c.dom.NodeList;
/////////////////////////////////////////////////////////////////////////
1:      * the received xmlContext.  Then if returnResults is false,
1:      * return an empty sequence (ArrayList) if evaluation yields
1:      * at least one item and return null if evaluation yields zero
1:      * items (the caller can then just check for null to see if the
1:      * query returned any items).  If returnResults is true, then return
1:      * return a sequence (ArrayList) containing all items returned
1:      * from evaluation of the expression.  This array list can contain
1:      * any combination of atomic values and XML nodes; it may also
1:      * be empty.
1:      *  the stored (compiled) query expression
1:      * @param returnResults Whether or not to return the actual
1:      *  results of the query
1:      * @param resultXType The qualified XML type of the result
1:      *  of evaluating the expression, if returnResults is true.
0:      *  If the result is a sequence of one Document or Element node
1:      *  then this will be XML(DOCUMENT(ANY)); else it will be
1:      *  XML(SEQUENCE).  If returnResults is false, this value
1:      *  is ignored.
1:      * @return If returnResults is false then return an empty
1:      *  ArrayList if evaluation returned at least one item and return
1:      *  null otherwise.  If returnResults is true then return an
1:      *  array list containing all of the result items and return
1:      *  the qualified XML type via the resultXType parameter.
0:     protected ArrayList evalXQExpression(XMLDataValue xmlContext,
1:         boolean returnResults, int [] resultXType) throws Exception
/////////////////////////////////////////////////////////////////////////
1:         /* Create a DOM node from the xmlContext, since that's how
1:          * we feed the context to Xalan.  We do this by creating
1:          * a Document node using DocumentBuilder, which means that
1:          * the serialized form of the context node must be a string
1:          * value that is parse-able by DocumentBuilder--i.e. it must
1:          * constitute a valid XML document.  If that's true then
1:          * the context item's qualified type will be DOC_ANY.
1:          */
1:         if (xmlContext.getXType() != XML.XML_DOC_ANY)
1:         {
1:             throw StandardException.newException(
1:                 SQLState.LANG_INVALID_XML_CONTEXT_ITEM,
1:                 (returnResults ? "XMLQUERY" : "XMLEXISTS"));
1:         } 
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (!returnResults)
1:         {
1:             // We don't want to return the actual results, we just
1:             // want to know if there was at least one item in the
1:             // result sequence.
0:             if ((xOb instanceof XNodeSet) &&
0:                 (((XNodeSet)xOb).nodelist().getLength() > 0))
0:             { // If we have a sequence (XNodeSet) of length greater
0:               // than zero, then we know that at least one item
0:               // "exists" in the result so return a non-null list.
0:                 return new ArrayList(0);
1:             }
0:             else if (!(xOb instanceof XNodeSet))
0:             // we have a single atomic value, which means the result is
0:             // non-empty.  So return a non-null list.
0:                 return new ArrayList(0);
0:             else {
0:             // return null; caller will take this to mean we have an
0:             // an empty sequence.
1:                 return null;
1:             }
1:         // Else process the results.
0:         NodeList nodeList = null;
0:         int numItems = 0;
0:         if (!(xOb instanceof XNodeSet))
0:         // then we only have a single (probably atomic) item.
0:             numItems = 1;
0:         else {
0:             nodeList = xOb.nodelist();
0:             numItems = nodeList.getLength();
1:         }
1: 
0:         // Return a list of the items contained in the query results.
0:         ArrayList itemRefs = new ArrayList();
0:         if (nodeList == null)
0:         // result is a single, non-node value (ex. it's an atomic number);
0:         // in this case, just take the string value.
0:             itemRefs.add(xOb.str());
0:         else {
0:             for (int i = 0; i < numItems; i++)
0:                 itemRefs.add(nodeList.item(i));
1:         }
1: 
0:         nodeList = null;
1: 
0:         // Indicate what kind of XML result value we have.  If
0:         // we have a sequence of exactly one Element or Document
0:         // then it is XMLPARSE-able and so we consider it to be
0:         // of type XML_DOC_ANY (which means we can store it in
0:         // a Derby XML column).
0:         if ((numItems == 1) && ((itemRefs.get(0) instanceof Document)
0:             || (itemRefs.get(0) instanceof Element)))
1:         {
1:             resultXType[0] = XML.XML_DOC_ANY;
1:         }
1:         else
1:             resultXType[0] = XML.XML_SEQUENCE;
1: 
1:         return itemRefs;
commit:6e7bbc8
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.iapi.types.SqlXmlUtil
1: 
0:    Copyright 2006 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import java.util.Properties;
1: import java.util.ArrayList;
1: 
1: import java.io.StringReader;
1: 
1: // -- JDBC 3.0 JAXP API classes.
1: 
1: import org.w3c.dom.Document;
1: import org.w3c.dom.Node;
1: import org.w3c.dom.Text;
1: 
1: import org.xml.sax.ErrorHandler;
1: import org.xml.sax.InputSource;
1: import org.xml.sax.SAXException;
1: import org.xml.sax.SAXParseException;
1: 
1: import javax.xml.parsers.DocumentBuilder;
1: import javax.xml.parsers.DocumentBuilderFactory;
1: 
1: import javax.xml.transform.OutputKeys;
1: import javax.xml.transform.TransformerException;
1: 
0: // -- Xalan-specific classes.
1: 
0: import org.apache.xpath.XPath;
0: import org.apache.xpath.XPathContext;
0: import org.apache.xpath.objects.XObject;
0: import org.apache.xpath.objects.XNodeSet;
1: 
0: import org.apache.xalan.serialize.DOMSerializer;
0: import org.apache.xalan.serialize.Serializer;
0: import org.apache.xalan.serialize.SerializerFactory;
0: import org.apache.xalan.templates.OutputProperties;
1: 
1: /**
1:  * This class contains "utility" methods that work with XML-specific
1:  * objects that are only available if JAXP and/or Xalan are in
1:  * the classpath.
1:  *
1:  * NOTE: This class is only compiled with JDK 1.4 and higher since
1:  * the XML-related classes that it uses (JAXP and Xalan) are not
1:  * part of earlier JDKs.
1:  *
1:  * Having a separate class for this functionality is beneficial
1:  * for two reasons:
1:  *
1:  *    1. Allows us to allocate XML objects and compile an XML
1:  *       query expression a single time per statement, instead of
1:  *       having to do it for every row against which the query
1:  *       is evaluated.  An instance of this class is created at
0:  *       compile time and then passed (using "saved objects")
0:  *       to the appropriate operator implementation method in
0:  *       XML.java; see SqlXmlExecutor.java for more about the
0:  *       role this class plays in "saved object" processing.
1:  *
1:  *    2. By keeping all XML-specific references in this one class, 
1:  *       we have a single "point of entry" to the XML objects--namely,
1:  *       the constructor for this class.  Thus, if we always make
1:  *       sure to check for the required XML classes _before_ calling
1:  *       this class's constructor, we can detect early on whether
1:  *       some classes (ex. Xalan) are missing, and can throw a friendly
1:  *       error up front, instead of a ClassNotFoundException somewhere
0:  *       deeper in the execution codepath.
1:  *
1:  *       Note that we don't want to put references to XML-specific
1:  *       objects directly into XML.java because that class (XML.java) is
1:  *       instantiated anytime a table with an XML column is referenced.
1:  *       That would mean that if a user tried to select a non-XML column
1:  *       (ex. integer) from a table that had at least one XML column in
1:  *       it, the user would have to have JAXP and Xalan classes in
1:  *       his/her classpath--which we don't want.  Instead, by keeping
1:  *       all XML-specific objects in this one class, and then only
1:  *       instantiating this class when an XML operator is used (either
1:  *       implicitly or explicitly), we make it so that the user is only
1:  *       required to have XML-specific classes in his/her classpath
1:  *       _if_ s/he is trying to access or operate on XML values.
1:  */
1: 
1: public class SqlXmlUtil 
1: {
1:     // Used to parse a string into an XML value (DOM); checks
1:     // the well-formedness of the string while parsing.
1:     private DocumentBuilder dBuilder;
1: 
1:     // Used to serialize an XML value according the standard
1:     // XML serialization rules.
0:     private Serializer serializer;
1: 
0:     // Classes used to compile and execute an XPath expression
0:     // against Xalan.
0:     private XPath query;
0:     private XPathContext xpContext;
1: 
1:     /**
1:      * Constructor: Initializes objects required for parsing
1:      * and serializing XML values.  Since most XML operations
1:      * that require XML-specific classes perform both parsing
1:      * and serialization at some point, we just initialize the
1:      * objects up front.
1:      */
1:     public SqlXmlUtil() throws StandardException
1:     {
1:         try {
1: 
1:             /* Note: Use of DocumentBuilderFactory means that we get
1:              * whatever XML parser is the "default" for the JVM in
1:              * use--and thus, we don't have to hard-code the parser
1:              * name, nor do we have to require that the user have a
1:              * specific parser in his/her classpath.
1:              *
1:              * This DocumentBuilder is currently used for parsing
1:              * (esp. XMLPARSE), and the SQL/XML spec says that XMLPARSE
1:              * should NOT perform validation (SQL/XML[2006], 6.15:
1:              * "Perform a non-validating parse of a string to produce
1:              * an XML value.").   So we disable validation here, and
1:              * we also make the parser namespace aware.
1:              *
1:              * At some point in the future we will probably want to add
1:              * support for the XMLVALIDATE function--but until then, user
1:              * is unable to validate the XML values s/he inserts.
1:              *
1:              * Note that, even with validation turned off, XMLPARSE
1:              * _will_ still check the well-formedness of the values,
1:              * and it _will_ still process DTDs to get default values,
1:              * etc--but that's it; no validation errors will be thrown.
1:              */
1: 
0:             DocumentBuilderFactory dBF = DocumentBuilderFactory.newInstance();
1:             dBF.setValidating(false);
1:             dBF.setNamespaceAware(true);
1: 
1:             // Load document builder that can be used for parsing XML.
1:             dBuilder = dBF.newDocumentBuilder();
1:             dBuilder.setErrorHandler(new XMLErrorHandler());
1: 
1:             // Load serializer for serializing XML into string according
1:             // XML serialization rules.
1:             loadSerializer();
1: 
0:         } catch (Exception e) {
1: 
0:             // Must be something caused by JAXP or Xalan; wrap it in a
0:             // StandardException and rethrow it.
1:             throw StandardException.newException(
0:                 SQLState.LANG_UNEXPECTED_XML_EXCEPTION, e);
1: 
1:         }
1: 
1:         // At construction time we don't have an XML query expression
1:         // to compile.  If one is required, we'll load/compile it later.
1:         query = null;
1:     }
1: 
1:     /**
1:      * Take the received string, which is an XML query expression,
1:      * compile it, and store the compiled query locally.  Note
1:      * that for now, we only support XPath because that's what
1:      * Xalan supports.
1:      *
1:      * @param queryExpr The XPath expression to compile
1:      */
0:     public void compileXQExpr(String queryExpr)
1:         throws StandardException
1:     {
1:         try {
1: 
0:             // The following XPath constructor compiles the expression
0:             // as part of the construction process.
0:             query = new XPath(queryExpr, null, null, XPath.SELECT);
1: 
0:         } catch (TransformerException te) {
1: 
0:             // Something went wrong during compilation of the
0:             // expression; wrap the error and re-throw it.
1:             throw StandardException.newException(
0:                 SQLState.LANG_UNEXPECTED_XML_EXCEPTION, te);
1: 
1:         }
1:     }
1: 
1:     /**
1:      * Take a string representing an XML value and serialize it
1:      * according SQL/XML serialization rules.  Right now, we perform
1:      * this serialization by first parsing the string into a JAXP
1:      * Document object, and then applying the serialization semantics
1:      * to that Document.  That seems a bit inefficient, but neither
1:      * Xalan nor JAXP provides a more direct way to do this.
1:      *
1:      * @param xmlAsText String version of XML on which to perform
1:      *   serialization.
1:      * @return A properly serialized version of xmlAsText.
1:      */
1:     protected String serializeToString(String xmlAsText)
1:         throws Exception
1:     {
0:         ArrayList aList = new ArrayList();
0:         aList.add(dBuilder.parse(
0:             new InputSource(new StringReader(xmlAsText))));
0:         return serializeToString(aList);
1:     }
1: 
1:     /**
1:      * Take an array list (sequence) of XML nodes and/or string values
1:      * and serialize that entire list according to SQL/XML serialization
0:      * rules.  We do that by going through each item in the array
0:      * list and either serializing it (if it's a Node) or else
0:      * just echoing the value to the serializer (if it's a Text
0:      * node or an atomic value).
1:      *
0:      * @param items List of items to serialize
0:      * @return Single string holding the concatenation of the serialized
0:      *  form of all items in the list
1:      */
0:     protected String serializeToString(ArrayList items)
0:         throws java.io.IOException
1:     {
0:         if ((items == null) || (items.size() == 0))
0:         // nothing to do; return empty sequence.
1:             return "";
1: 
0:         java.io.StringWriter sWriter = new java.io.StringWriter();
1: 
1:         // Serializer should have been set by now.
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(serializer != null,
1:                 "Tried to serialize with uninitialized XML serializer.");
1:         }
1: 
0:         serializer.setWriter(sWriter);
0:         DOMSerializer dSer = serializer.asDOMSerializer();
1: 
0:         int sz = items.size();
0:         Object obj = null;
1: 
1:         // Iterate through the list and serialize each item.
0:         for (int i = 0; i < sz; i++)
1:         {
0:             obj = items.get(i);
0:             if (obj instanceof String)
0:             // if it's a string, then this corresponds to some atomic
0:             // value, so just echo the string as it is.
0:                 sWriter.write((String)obj);
1:             else
1:             { // We have a Node, so try to serialize it.
1:                 Node n = (Node)obj;
1:                 if (n instanceof Text)
0:                 // Xalan doesn't allow a "serialize" call on Text nodes,
0:                 // so we just go ahead and echo the value of the text.
1:                     sWriter.write(n.getNodeValue());
1:                 else
0:                     dSer.serialize(n);
1:             }
1:         }
1: 
1:         sWriter.flush();
1:         return sWriter.toString();
1:     }
1: 
1:     /**
1:      * Evaluate this object's compiled XML query expression against
0:      * the received xmlContext and return whether or not at least
0:      * one item in the xmlContext is returned.
1:      *
1:      * Assumption here is that the query expression has already been
1:      * compiled and is stored in this.query.
1:      *
1:      * @param xmlContext The XML value against which to evaluate
0:      *  the stored (compiled) query expression.
0:      * @return True if evaluation returned at least one item,
0:      *  false otherwise.
1:      * @exception Exception thrown on error (and turned into a
1:      *  StandardException by the caller).
1:      */
0:     protected boolean evalXQExpression(XMLDataValue xmlContext)
1:         throws Exception
1:     {
1:         // Make sure we have a compiled query.
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(
0:                 (query != null) && (query.getExpression() != null),
1:                 "Failed to locate compiled XML query expression.");
1:         }
1: 
0:         // Create a DOM node from the xmlContext, since that's how
0:         // we feed the context to Xalan.
0:         Document docNode = null;
0:         docNode = dBuilder.parse(
1:             new InputSource(
1:                 new StringReader(xmlContext.getString())));
1: 
0:         // Evaluate the expresion using Xalan.
0:         getXPathContext();
0:         xpContext.reset();
0:         XObject xOb = query.execute(xpContext, docNode, null);
1: 
0:         // We don't want to return the actual results, we just
0:         // want to know if there was at least one item in the
0:         // result sequence.
0:         if ((xOb instanceof XNodeSet) &&
0:             (((XNodeSet)xOb).nodelist().getLength() > 0))
0:         { // If we have a sequence (XNodeSet) of length greater
0:           // than zero, then we know that at least one item
0:           // "exists" in the result.
0:             return true;
1:         }
0:         else if (!(xOb instanceof XNodeSet))
0:         // we have a single atomic value, which means the result is
0:         // non-empty.
0:             return true;
1: 
0:         // Else the result was an empty sequence.
0:         return false;
1:     }
1: 
1:     /* ****
1:      * Helper classes and methods.
1:      * */
1: 
1:     /**
0:      * Create and return an instance of Xalan's XPathContext
0:      * that can be used to compile an XPath expression.
1:      */
0:     private XPathContext getXPathContext()
1:     {
0:         if (xpContext == null)
0:             xpContext = new XPathContext();
1: 
0:         return xpContext;
1:     }
1: 
1:     /**
1:      * Create an instance of Xalan serializer for the sake of
1:      * serializing an XML value according the SQL/XML specification
1:      * for serialization.
1:      */
0:     private void loadSerializer() throws java.io.IOException
1:     {
0:         java.io.StringWriter sWriter = new java.io.StringWriter();
1: 
1:         // Set serialization properties.
0:         Properties props = OutputProperties.getDefaultMethodProperties("xml");
1: 
1:         // SQL/XML[2006] 10.15:General Rules:6 says method is "xml".
1:         props.setProperty(OutputKeys.METHOD, "xml");
1: 
1:         /* Since the XMLSERIALIZE operator doesn't currently support
1:          * the DOCUMENT nor CONTENT keywords, SQL/XML spec says that
1:          * the default is CONTENT (6.7:Syntax Rules:2.a).  Further,
1:          * since the XMLSERIALIZE operator doesn't currently support the
1:          * <XML declaration option> syntax, the SQL/XML spec says
1:          * that the default for that option is "Unknown" (6.7:General
1:          * Rules:2.f).  Put those together and that in turn means that
1:          * the value of "OMIT XML DECLARATION" must be "Yes", as
1:          * stated in section 10.15:General Rules:8.c.  SO, that's what
1:          * we set here.
1:          *
1:          * NOTE: currently the only way to view the contents of an
1:          * XML column is by using an explicit XMLSERIALIZE operator.
1:          * This means that if an XML document is stored and it
1:          * begins with an XML declaration, the user will never be
1:          * able to _see_ that declaration after inserting the doc
1:          * because, as explained above, our current support for
1:          * XMLSERIALIZE dictates that the declaration must be
1:          * omitted.  Similarly, other transformations that may
1:          * occur from serialization (ex. entity replacement,
1:          * attribute order, single-to-double quotes, etc)) will
1:          * always be in effect for the string returned to the user;
1:          * the original form of the XML document, if different
1:          * from the serialized version, is not currently retrievable.
1:          */
1:         props.setProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
1: 
1:         // We serialize everything as UTF-8 to match what we
1:         // store on disk.
1:         props.setProperty(OutputKeys.ENCODING, "UTF-8");
1: 
1:         // Load the serializer with the correct properties.
0:         serializer = SerializerFactory.getSerializer(props);
0:         return;
1:     }
1: 
1:     /*
1:      ** The XMLErrorHandler class is just a generic implementation
1:      ** of the ErrorHandler interface.  It allows us to catch
1:      ** and process XML parsing errors in a graceful manner.
1:      */
1:     private class XMLErrorHandler implements ErrorHandler
1:     {
1:         public void error (SAXParseException exception)
1:             throws SAXException
1:         {
1:             throw new SAXException (exception);
1:         }
1: 
1:         public void fatalError (SAXParseException exception)
1:             throws SAXException
1:         {
1:             throw new SAXException (exception);
1:         }
1: 
1:         public void warning (SAXParseException exception)
1:             throws SAXException
1:         {
1:             throw new SAXException (exception);
1:         }
1:     }
1: }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:7139f7c
/////////////////////////////////////////////////////////////////////////
1: import java.io.StringWriter;
/////////////////////////////////////////////////////////////////////////
1:         Document doc;
/////////////////////////////////////////////////////////////////////////
1:             doc = java.security.AccessController.doPrivileged(
1:                 });
/////////////////////////////////////////////////////////////////////////
1:         return serializeToString(Collections.singletonList(doc), null);
/////////////////////////////////////////////////////////////////////////
1:      * @param items List of items to serialize. It should either be
1:      *  a list of a single string value (in case it's the result of
1:      *  an XMLQUERY operation that returns an atomic value), or a list
1:      *  of zero or more Node objects.
/////////////////////////////////////////////////////////////////////////
1:         // If we have an empty sequence, return an empty value immediately.
1:         if (items.isEmpty()) {
1:         // If it contains a single string, just return that string.
1:         if (items.size() == 1 && items.get(0) instanceof String) {
1:             return (String) items.get(0);
1:         }
1: 
1:         // Otherwise, it's a non-empty list of Node objects.
1: 
1:         StringWriter sWriter = new StringWriter();
/////////////////////////////////////////////////////////////////////////
1:             if (obj instanceof Attr)
/////////////////////////////////////////////////////////////////////////
0:                 xmlVal.markAsHavingTopLevelAttr();
/////////////////////////////////////////////////////////////////////////
commit:b23250c
/////////////////////////////////////////////////////////////////////////
1:                 SQLState.LANG_XML_QUERY_ERROR, te, opName, te.getMessage());
/////////////////////////////////////////////////////////////////////////
1:         } catch (Exception xpee) {
1:             // Retry with the string type if an XPathExpressionException is
1:             // thrown. The catch block is broader and retries on all kinds of
1:             // exceptions. The reason is that IBM fails with a runtime
1:             // exception that shadows the XPathExpressionException, if a
1:             // security manager is installed. See DERBY-6637 for details.
commit:ed7f8b9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:1ffa77b
/////////////////////////////////////////////////////////////////////////
1: import java.util.Iterator;
0: import org.w3c.dom.NodeList;
1: import javax.xml.XMLConstants;
1: 
1: import javax.xml.namespace.NamespaceContext;
1: import javax.xml.namespace.QName;
1: 
/////////////////////////////////////////////////////////////////////////
1: import javax.xml.xpath.XPath;
1: import javax.xml.xpath.XPathConstants;
1: import javax.xml.xpath.XPathExpression;
1: import javax.xml.xpath.XPathExpressionException;
1: import javax.xml.xpath.XPathFactory;
0: 
/////////////////////////////////////////////////////////////////////////
1:     /** The compiled XPath query. */
1:     /** The return type of the XPath query. {@code null} if it is unknown. */
1:     private QName returnType;
0: 
/////////////////////////////////////////////////////////////////////////
1:              * namespace context object so that prefixes will not be resolved
1:             XPath xpath = XPathFactory.newInstance().newXPath();
1:             xpath.setNamespaceContext(NullNamespaceContext.SINGLETON);
0: 
1:             query = xpath.compile(queryExpr);
/////////////////////////////////////////////////////////////////////////
1:         Document docNode = dBuilder.parse(
1:         Object result = evaluate(docNode);
1:             // This is for XMLEXISTS.
1:             //
1:             if (result instanceof NodeList
1:                     && ((NodeList) result).getLength() == 0) {
1:                 // We have an empty sequence, so return null to indicate
1:                 // there were no results from the query.
1:                 return null;
1:             } else {
1:                 // We have either a non-empty sequence or a scalar, so
1:                 // return a non-null value to indicate that we found at
1:                 // least one item.
1:                 return Collections.emptyList();
1:         if (result instanceof NodeList) {
1:             NodeList list = (NodeList) result;
1:             ArrayList<Node> nodes = new ArrayList<Node>();
1:             for (int i = 0; i < list.getLength(); i++) {
1:                 nodes.add(list.item(i));
1:             }
1:             itemRefs = nodes;
1:         } else {
1:             itemRefs = Collections.singletonList(result);
/////////////////////////////////////////////////////////////////////////
1:      * Evaluate the XPath query on the specified document.
0:      */
1:     private Object evaluate(Document doc) throws XPathExpressionException {
0: 
1:         // If we know the return type, just evaluate the expression with
1:         // that type.
1:         if (returnType != null) {
1:             return query.evaluate(doc, returnType);
1:         }
0: 
1:         // Otherwise, first try to evaluate the expression as if it returned
1:         // a set of nodes. If that fails, evaluate it as if it returned a
1:         // string. Remember which type was successful so that we can use that
1:         // type directly the next time we evaluate the expression.
1:         try {
1:             Object result = query.evaluate(doc, XPathConstants.NODESET);
1:             returnType = XPathConstants.NODESET;
1:             return result;
0:         } catch (XPathExpressionException xpee) {
1:             Object result = query.evaluate(doc, XPathConstants.STRING);
1:             returnType = XPathConstants.STRING;
1:             return result;
1:         }
1:     }
0: 
1:     /**
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:      * A NamespaceContext that reports all namespaces as unbound.
0:      */
1:     private static class NullNamespaceContext implements NamespaceContext {
0: 
1:         private final static NullNamespaceContext
1:                 SINGLETON = new NullNamespaceContext();
0: 
1:         @Override
1:         public String getNamespaceURI(String prefix) {
1:             return XMLConstants.NULL_NS_URI;
1:         }
0: 
1:         @Override
1:         public String getPrefix(String namespaceURI) {
0:             return null;
1:         }
0: 
1:         @Override
1:         public Iterator getPrefixes(String namespaceURI) {
1:             return Collections.emptyList().iterator();
1:         }
1:     }
commit:be94230
/////////////////////////////////////////////////////////////////////////
0:         } else if (d == 0.0d) {
0:             // If the result is zero, return plain "0". This special case is
0:             // needed because BigDecimal.stripTrailingZeros() does not remove
0:             // trailing zeros from zero, and will end up producing "0.0", see
0:             // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6480539
0:             return "0";
0:             // We could have used Double to format it, but then the resulting
0:             // string would have been in scientific format (like 1.0e-3), and
0:             // we want it to be in plain format (like 0.001).
0:             return BigDecimal.valueOf(d).stripTrailingZeros().toPlainString();
commit:a8b9c70
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ArrayList<Document> aList = new ArrayList<Document>();
/////////////////////////////////////////////////////////////////////////
1:                 new java.security.PrivilegedExceptionAction<Document>()
1:                     public Document run() throws IOException, SAXException
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         for (Object obj : items)
/////////////////////////////////////////////////////////////////////////
0:                 ArrayList<Node> nodes = new ArrayList<Node>();
0:                     nodes.add(node);
0:                 itemRefs = nodes;
/////////////////////////////////////////////////////////////////////////
0:     private static String numberToString(double d) {
/////////////////////////////////////////////////////////////////////////
0:             // BigDecimal.toPlainString() formats the number the way we want.
0:             return dec.toPlainString();
commit:d09782a
/////////////////////////////////////////////////////////////////////////
1:  *       compile time and then passed to the appropriate operator
1:  *       implementation method in XML.java.
commit:044afae
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: public class SqlXmlUtil
/////////////////////////////////////////////////////////////////////////
commit:5283796
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
1: import java.util.List;
0: import java.lang.reflect.InvocationTargetException;
0: import java.lang.reflect.Method;
0: import java.math.BigDecimal;
0: 
0: import org.w3c.dom.xpath.XPathEvaluator;
0: import org.w3c.dom.xpath.XPathExpression;
0: import org.w3c.dom.xpath.XPathResult;
0: 
/////////////////////////////////////////////////////////////////////////
1: import javax.xml.transform.Transformer;
1: import javax.xml.transform.TransformerConfigurationException;
1: import javax.xml.transform.TransformerFactory;
1: import javax.xml.transform.dom.DOMSource;
1: import javax.xml.transform.stream.StreamResult;
/////////////////////////////////////////////////////////////////////////
1:     private Transformer serializer;
1:     private XPathExpression query;
0: 
0:     /**
0:      * <p>
0:      * An object representing the {@code BigDecimal.toPlainString()} method
0:      * if it's available on the platform. If it's not available, this field
0:      * will be initialized to {@code null}, and in that case the
0:      * {@code BigDecimal.toString()} method should be used instead without
0:      * reflection.
0:      * </p>
0:      *
0:      * <p>
0:      * The behaviour of the {@code toString()} method changed when
0:      * {@code toPlainString()} was introduced in Java SE 5. On older
0:      * platforms, it behaves just like {@code toPlainString()} does on
0:      * newer platforms. So when {@code toPlainString()} is not
0:      * available, it is safe to fall back to {@code toString()}. It
0:      * behaves differently on newer platforms, so we need to use
0:      * {@code toPlainString()} when it is available in order to get
0:      * consistent behaviour across all platforms.
0:      * </p>
0:      *
0:      * @see #numberToString(double)
0:      */
0:     private static final Method TO_PLAIN_STRING;
0:     static {
0:         Method m = null;
1:         try {
0:             m = BigDecimal.class.getMethod("toPlainString", new Class[0]);
0:         } catch (NoSuchMethodException nsme) {
0:             // Couldn't find the method, so we'll just fall back to toString()
0:             // on this platform.
0:         }
0:         TO_PLAIN_STRING = m;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:              * as part of the construction process.  We pass a null
0:              * namespace resolver object so that the implementation will
0:              * provide one for us, which means prefixes will not be resolved
0:             XPathEvaluator eval = (XPathEvaluator)
0:                 dBuilder.getDOMImplementation().getFeature("+XPath", "3.0");
0:             query = eval.createExpression(queryExpr, null);
0: 
/////////////////////////////////////////////////////////////////////////
1:     protected String serializeToString(List items,
1:         XMLDataValue xmlVal) throws TransformerException
0:         if ((items == null) || items.isEmpty()) {
0:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 serializer.transform(
1:                         new DOMSource((Node) obj), new StreamResult(sWriter));
/////////////////////////////////////////////////////////////////////////
1:                     serializer.transform(
1:                             new DOMSource(n), new StreamResult(sWriter));
/////////////////////////////////////////////////////////////////////////
1:     protected List evalXQExpression(XMLDataValue xmlContext,
/////////////////////////////////////////////////////////////////////////
1:                 (query != null),
/////////////////////////////////////////////////////////////////////////
0:         XPathResult result = (XPathResult)
0:                 query.evaluate(docNode, XPathResult.ANY_TYPE, null);
0:             switch (result.getResultType()) {
0:                 case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
0:                 case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
0:                     if (result.iterateNext() == null) {
0:                         // We have an empty sequence, so return null.
0:                         return null;
0:                     } else {
0:                         // We have a non-empty sequence, so return a non-null
0:                         // list to indicate that we found at least one item.
0:                         return Collections.EMPTY_LIST;
0:                     }
0:                 default:
0:                     // We have a single atomic value, which means the result is
0:                     // non-empty. So return a non-null list.
0:                     return Collections.EMPTY_LIST;
1:         List itemRefs;
0:         switch (result.getResultType()) {
0:             case XPathResult.NUMBER_TYPE:
0:                 // Single atomic number. Get its string value.
0:                 String val = numberToString(result.getNumberValue());
0:                 itemRefs = Collections.singletonList(val);
0:                 break;
0:             case XPathResult.STRING_TYPE:
0:                 // Single atomic string value.
0:                 itemRefs = Collections.singletonList(result.getStringValue());
0:                 break;
0:             case XPathResult.BOOLEAN_TYPE:
0:                 // Single atomic boolean. Get its string value.
0:                 itemRefs = Collections.singletonList(
0:                         String.valueOf(result.getBooleanValue()));
0:                 break;
0:             case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
0:             case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
0:                 // We have a sequence. Get all nodes.
0:                 itemRefs = new ArrayList();
0:                 Node node;
0:                 while ((node = result.iterateNext()) != null) {
0:                     itemRefs.add(node);
0:                 }
0:                 break;
0:             default:
0:                 if (SanityManager.DEBUG) {
0:                     SanityManager.THROWASSERT(
0:                             "Don't know how to handle XPath result type " +
0:                             result.getResultType());
0:                 }
0:                 itemRefs = null;
1:         if ((itemRefs.size() == 1) && (itemRefs.get(0) instanceof Document))
/////////////////////////////////////////////////////////////////////////
1:     private void loadSerializer() throws TransformerConfigurationException
1:         Properties props = new Properties();
/////////////////////////////////////////////////////////////////////////
1:         serializer = TransformerFactory.newInstance().newTransformer();
1:         serializer.setOutputProperties(props);
0:     /**
0:      * Convert a number returned by an XPath query to a string, following the
0:      * rules for the <a href="http://www.w3.org/TR/xpath/#function-string">
0:      * XPath string function</a>.
0:      *
0:      * @param d {@code double} representation of the number
0:      * @return {@code String} representation of the number
0:      */
0:     private static String numberToString(double d)
0:             throws IllegalAccessException, InvocationTargetException {
0:         if (Double.isNaN(d) || Double.isInfinite(d)) {
0:             // BigDecimal doesn't know how to handle NaN or +/- infinity, so
0:             // use Double to handle those cases.
0:             return Double.toString(d);
0:         } else {
0:             // Otherwise, use BigDecimal to format the number the way we want.
0:             // Ideally, we'd just return
0:             // BigDecimal.valueOf(d).stripTrailingZeros().toPlainString(),
0:             // but valueOf(double), stripTrailingZeros() and toPlainString()
0:             // were all introduced in Java 5, and we still need to support
0:             // older platforms.
0:             BigDecimal dec = new BigDecimal(Double.toString(d));
0: 
0:             // See how many trailing zeros we have after the decimal point.
0:             long unscaledValue = dec.unscaledValue().longValue();
0:             int scale = dec.scale();
0:             while (scale > 0 && unscaledValue % 10 == 0) {
0:                 scale--;
0:                 unscaledValue /= 10;
0:             }
0: 
0:             // If we have trailing zeros after the decimal point, remove them.
0:             if (scale != dec.scale()) {
0:                 dec = BigDecimal.valueOf(unscaledValue, scale);
0:             }
0: 
0:             // Finally, convert the value to a string. The method
0:             // BigDecimal.toPlainString() formats the number the way we want
0:             // it, but it's only available on Java 5 and later. Luckily, on
0:             // older platforms, BigDecimal.toString() is defined the same way
0:             // as toPlainString(), so we can fall back to that method if
0:             // toPlainString() isn't available. toString() was redefined in
0:             // Java 5, so we cannot use toString() unconditionally, however.
0:             if (TO_PLAIN_STRING == null) {
0:                 return dec.toString();
0:             } else {
0:                 return (String) TO_PLAIN_STRING.invoke(dec, (Object[]) null);
0:             }
0:         }
0:     }
0: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:870f7cd
/////////////////////////////////////////////////////////////////////////
0:                 SQLState.LANG_XML_QUERY_ERROR, opName, te.getMessage());
commit:6a210c5
/////////////////////////////////////////////////////////////////////////
1:                  * contains the JAXP _interfaces_
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:78befe8
/////////////////////////////////////////////////////////////////////////
author:Army
-------------------------------------------------------------------------------
commit:95685b1
/////////////////////////////////////////////////////////////////////////
0:     protected String serializeToString(String xmlAsText)
0:         ArrayList aList = new ArrayList();
/////////////////////////////////////////////////////////////////////////
0:         try {
0: 
1:             final InputSource is = new InputSource(new StringReader(xmlAsText));
0:             aList.add(java.security.AccessController.doPrivileged(
0:                 new java.security.PrivilegedExceptionAction()
0:                     public Object run() throws IOException, SAXException
0:                     {
1:                         return dBuilder.parse(is);
0:                     }
0:                 }));
0: 
1:         } catch (java.security.PrivilegedActionException pae) {
0: 
1:             /* Unwrap the privileged exception so that the user can
1:              * see what the underlying error is. For example, it could
1:              * be an i/o error from parsing the XML value, which can
1:              * happen if the XML value references an external DTD file
1:              * but the JAXP parser hits an i/o error when trying to read
1:              * the DTD.  In that case we want to throw the i/o error
1:              * itself so that it does not appear as a security exception
1:              * to the user.
0:              */
1:             throw pae.getException();
0: 
0:         }
commit:378aa34
/////////////////////////////////////////////////////////////////////////
0:     protected String serializeToString(final String xmlAsText)
0:         final ArrayList aList = new ArrayList();
0: 
1:         /* The call to dBuilder.parse() is a call to an external
1:          * (w.r.t. to Derby) JAXP parser.  If the received XML
1:          * text references an external DTD, then the JAXP parser
1:          * will try to read that external DTD.  Thus we wrap the
1:          * call to parse inside a privileged action to make sure
1:          * that the JAXP parser has the required permissions for
1:          * reading the DTD file.
0:          */
0:         java.security.AccessController.doPrivileged(
0:             new java.security.PrivilegedExceptionAction()
0:             {
0:                 public Object run() throws Exception
0:                 {
0:                     aList.add(dBuilder.parse(
0:                         new InputSource(new StringReader(xmlAsText))));
0:                     return null;
0:                 }
0:             });
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:8cefbbc
/////////////////////////////////////////////////////////////////////////
1:                 SQLState.LANG_UNEXPECTED_XML_EXCEPTION, t, t.getMessage());
/////////////////////////////////////////////////////////////////////////
0:                 SQLState.LANG_XML_QUERY_ERROR, te, opName, te.getMessage());
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:a465628
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: import java.io.IOException;
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
/////////////////////////////////////////////////////////////////////////
0: public class SqlXmlUtil implements Formatable
/////////////////////////////////////////////////////////////////////////
0:     // Used to recompile the XPath expression when this formatable
0:     // object is reconstructed.  e.g.:  SPS 
0:     private String queryExpr;
0:     private String opName;
0:     private boolean recompileQuery;
0:     
/////////////////////////////////////////////////////////////////////////
0:             
0:             this.queryExpr = queryExpr;
0:             this.opName = opName;
0:             this.recompileQuery = false;
/////////////////////////////////////////////////////////////////////////
0:         // if this object is in an SPS, we need to recompile the query
0:         if (recompileQuery)
0:         {
0:         	compileXQExpr(queryExpr, opName);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
0:     /* ****
0:      * Formatable interface implementation
0:      * */
0: 
0:     /** 
0:      * @see java.io.Externalizable#writeExternal 
0:      * 
0:      * @exception IOException on error
0:      */
0:     public void writeExternal(ObjectOutput out) 
0:         throws IOException
0:     {
0:         // query may be null
0:         if (query == null)
0:         {
0:             out.writeBoolean(false);
0:         }
0:         else
0:         {
0:             out.writeBoolean(true);
0:             out.writeObject(queryExpr);
0:             out.writeObject(opName);
0:         }
0:     }
0: 
0:     /** 
0:      * @see java.io.Externalizable#readExternal 
0:      *
0:      * @exception IOException on error
0:      * @exception ClassNotFoundException on error
0:      */
0:     public void readExternal(ObjectInput in) 
0:         throws IOException, ClassNotFoundException
0:     {
0:         if (in.readBoolean())
0:         {
0:             queryExpr = (String)in.readObject();
0:             opName = (String)in.readObject();
0:             recompileQuery = true;
0: 	    }
0:     }
0: 
0:     /**
0:      * Get the formatID which corresponds to this class.
0:      *
0:      * @return	the formatID of this class
0:      */
0:     public int getTypeFormatId()
0:     { 
0:         return StoredFormatIds.SQL_XML_UTIL_V01_ID;
0:     }
0: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:4ecc65a
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
============================================================================