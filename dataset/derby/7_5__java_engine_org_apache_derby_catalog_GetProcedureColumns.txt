1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.catalog.GetProcedureColumns
1:345de35: 
1:2f36947:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2f36947:    contributor license agreements.  See the NOTICE file distributed with
1:2f36947:    this work for additional information regarding copyright ownership.
1:2f36947:    The ASF licenses this file to You under the Apache License, Version 2.0
1:2f36947:    (the "License"); you may not use this file except in compliance with
1:2f36947:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
7:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.catalog;
1:eac0369: 
1:eac0369: import java.sql.Types;
1:eac0369: import java.sql.ResultSetMetaData;
1:eac0369: import java.sql.SQLException;
1:e423333: import java.sql.DatabaseMetaData;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: import org.apache.derby.iapi.types.DataTypeUtilities;
1:eac0369: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1:eac0369: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData;
1:eac0369: import org.apache.derby.catalog.types.RoutineAliasInfo;
1:eac0369: 
2:eac0369: /**
1:eac0369:     <P>Use of VirtualTableInterface to provide support for
1:eac0369:     DatabaseMetaData.getProcedureColumns().
1:eac0369: 	
1:eac0369: 
1:eac0369:     <P>This class is called from a Query constructed in 
1:eac0369:     java/org.apache.derby.impl.jdbc/metadata.properties:
1:eac0369: <PRE>
1:eac0369: 
1:eac0369: 
1:eac0369:     <P>The VTI will return columns 3-14, an extra column to the specification
1:eac0369:     METHOD_ID is returned to distinguish between overloaded methods.
1:eac0369: 
1:eac0369:   <OL>
1:dbed020:         <LI><B>PROCEDURE_CAT</B> String =&gt; procedure catalog (may be null)
1:dbed020:         <LI><B>PROCEDURE_SCHEM</B> String =&gt; procedure schema (may be null)
1:dbed020:         <LI><B>PROCEDURE_NAME</B> String =&gt; procedure name
1:dbed020:         <LI><B>COLUMN_NAME</B> String =&gt; column/parameter name 
1:dbed020:         <LI><B>COLUMN_TYPE</B> Short =&gt; kind of column/parameter:
1:eac0369:       <UL>
1:eac0369:       <LI> procedureColumnUnknown - nobody knows
1:eac0369:       <LI> procedureColumnIn - IN parameter
1:eac0369:       <LI> procedureColumnInOut - INOUT parameter
1:eac0369:       <LI> procedureColumnOut - OUT parameter
1:eac0369:       <LI> procedureColumnReturn - procedure return value
1:eac0369:       <LI> procedureColumnResult - result column in ResultSet
1:eac0369:       </UL>
1:dbed020:   <LI><B>DATA_TYPE</B> int =&gt; SQL type from java.sql.Types
1:dbed020:         <LI><B>TYPE_NAME</B> String =&gt; SQL type name, for a UDT type the
1:eac0369:   type name is fully qualified
1:dbed020:         <LI><B>PRECISION</B> int =&gt; precision
1:dbed020:         <LI><B>LENGTH</B> int =&gt; length in bytes of data
1:dbed020:         <LI><B>SCALE</B> short =&gt; scale
1:dbed020:         <LI><B>RADIX</B> short =&gt; radix
1:dbed020:         <LI><B>NULLABLE</B> short =&gt; can it contain NULL?
1:eac0369:       <UL>
1:eac0369:       <LI> procedureNoNulls - does not allow NULL values
1:eac0369:       <LI> procedureNullable - allows NULL values
1:eac0369:       <LI> procedureNullableUnknown - nullability unknown
1:eac0369:       </UL>
1:dbed020:         <LI><B>REMARKS</B> String =&gt; comment describing parameter/column
1:dbed020:         <LI><B>METHOD_ID</B> Short =&gt; Derby extra column (overloading)
1:dbed020:         <LI><B>PARAMETER_ID</B> Short =&gt; Derby extra column (output order)
1:eac0369:   </OL>
1:eac0369: 
1:eac0369: */
1:eac0369: 
1:eac0369: public class GetProcedureColumns extends org.apache.derby.vti.VTITemplate 
1:eac0369: {
1:e423333: 	private int translate(int val) {
1:e423333: 		if (!isFunction) { return val; }
1:e423333: 		switch (val) {
1:e423333: 		case DatabaseMetaData.procedureColumnUnknown:
1:e33b8d8:             return DatabaseMetaData.functionColumnUnknown;
1:e423333: 		case DatabaseMetaData.procedureColumnIn:
1:e33b8d8:             return DatabaseMetaData.functionColumnIn;
1:e423333: 		case DatabaseMetaData.procedureColumnInOut:
1:e33b8d8:             return DatabaseMetaData.functionColumnInOut;
1:e423333: 		case DatabaseMetaData.procedureColumnOut:
1:e33b8d8:             return DatabaseMetaData.functionColumnOut;
1:e423333: 		case DatabaseMetaData.procedureColumnReturn:
1:e33b8d8:             return DatabaseMetaData.functionReturn;
1:e423333: 		default:
1:e33b8d8:             return DatabaseMetaData.functionColumnUnknown;
1:e423333: 		}
1:e423333:     }
1:eac0369: 
1:eac0369: 	private boolean isProcedure;
1:d753aef: 	private boolean isFunction;
1:d753aef: 	private int          rowCount;
1:d753aef: 	private int          returnedTableColumnCount;
1:d66ce7b: 	private TypeDescriptor tableFunctionReturnType;
1:d753aef:     
1:eac0369: 	// state for procedures.
1:eac0369: 	private RoutineAliasInfo procedure;
1:e423333: 	private int paramCursor;
1:eac0369:     private short method_count;
1:eac0369:     private short param_number;
1:eac0369: 
1:eac0369:     private TypeDescriptor sqlType;
1:e423333:     private String columnName;
1:e423333:     private short columnType;
1:e423333:     private final short nullable;
1:eac0369: 
1:eac0369:     public ResultSetMetaData getMetaData()
1:eac0369:     {        
1:eac0369:         return metadata;
1:eac0369:     }
1:eac0369: 
1:eac0369:     //
1:eac0369:     // Instantiates the vti given a class name and methodname.
1:eac0369:     // 
1:eac0369:     // @exception SQLException  Thrown if there is a SQL error.
1:eac0369:     //
1:eac0369:     //
1:eac0369:     public GetProcedureColumns(AliasInfo aliasInfo, String aliasType) throws SQLException
1:eac0369:     {
1:c6c266b: 		int     functionParamCursor = -2;
1:c6c266b: 
1:eac0369: 		// compile time aliasInfo will be null.
1:eac0369: 		if (aliasInfo != null) {
1:eac0369: 			isProcedure = aliasType.equals("P");
1:e423333: 			isFunction = aliasType.equals("F");
1:eac0369: 			procedure = (RoutineAliasInfo) aliasInfo;
1:eac0369: 			method_count = (short) procedure.getParameterCount();
1:d753aef:             
1:d753aef: 			rowCount = procedure.getParameterCount();
1:d753aef: 			if ( procedure.isTableFunction() ) {
1:d66ce7b: 			    tableFunctionReturnType = procedure.getReturnType();
1:d66ce7b: 			    returnedTableColumnCount = tableFunctionReturnType.getRowColumnNames().length;
1:d753aef: 			    rowCount += returnedTableColumnCount;
1:c6c266b: 			    functionParamCursor = -1;
1:d753aef: 		        }
1:eac0369: 		}
1:e423333: 		if (aliasType == null) { 
1:e423333: 			nullable = 0;
1:e423333: 			return;
1:e423333: 		}
1:e423333: 
1:e423333: 		if (isFunction) {
1:e33b8d8:             nullable = (short) DatabaseMetaData.functionNullable;
1:e423333: 			sqlType = procedure.getReturnType();
1:e423333: 			columnName = "";  // COLUMN_NAME is VARCHAR NOT NULL
1:e33b8d8:             columnType = (short) DatabaseMetaData.functionReturn;
1:c6c266b: 			paramCursor = functionParamCursor;
1:e423333: 			return;
1:e423333: 		}
1:e423333: 		nullable = (short) DatabaseMetaData.procedureNullable;
1:e423333: 
1:e423333: 		paramCursor = -1;
1:eac0369:     }
1:eac0369: 
1:eac0369:     public boolean next() throws SQLException {
1:d753aef: 		if (++paramCursor >= rowCount)
1:eac0369: 			return false;
1:eac0369: 
1:d753aef: 		if ( procedure.isTableFunction() && (  paramCursor >= procedure.getParameterCount() ) ) {
1:d753aef: 			int     idx = paramCursor - procedure.getParameterCount();
1:d753aef:             
1:d66ce7b: 			sqlType      = tableFunctionReturnType.getRowTypes()[ idx ];
1:d66ce7b: 			columnName   = tableFunctionReturnType.getRowColumnNames()[ idx ];
1:e33b8d8:             columnType   = (short) DatabaseMetaData.functionColumnResult;
1:d753aef: 		}
1:d753aef: 		else if (paramCursor > -1) {
1:e423333: 			sqlType      = procedure.getParameterTypes()[paramCursor];
1:e423333: 			columnName   = procedure.getParameterNames()[paramCursor];
1:e423333: 			columnType   = 
1:e423333: 				(short)translate(procedure.getParameterModes()[paramCursor]);
1:e423333: 		}
1:d753aef:         
1:eac0369: 		param_number = (short) paramCursor;
1:d753aef: 
1:eac0369: 		return true;
1:eac0369: 	}   
1:eac0369: 
1:eac0369:     //
1:eac0369:     // Get the value of the specified data type from a column.
1:eac0369:     // 
1:eac0369:     // @exception SQLException  Thrown if there is a SQL error.
1:eac0369:     //
1:eac0369:     //
1:eac0369:     public String getString(int column) throws SQLException 
1:eac0369:     {
1:eac0369:         switch (column) 
1:eac0369:         {
1:eac0369: 		case 1: // COLUMN_NAME:
1:e423333: 			return columnName;
1:eac0369: 
1:eac0369: 		case 4: //_TYPE_NAME: 
1:eac0369:                return sqlType.getTypeName();
1:eac0369:                
1:eac0369: 		case 10: // REMARKS:
1:eac0369:                 return null;
1:eac0369: 
1:eac0369:             default: 
1:eac0369:                 return super.getString(column);  // throw exception
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     //
1:eac0369:     // Get the value of the specified data type from a column.
1:eac0369:     // 
1:eac0369:     // @exception SQLException  Thrown if there is a SQL error.
1:eac0369:     //
1:eac0369:     //
1:eac0369:     public int getInt(int column) throws SQLException 
1:eac0369:     {
1:eac0369:         switch (column) 
1:eac0369:         {
1:9f5e1d4:         case 3: // DATA_TYPE:
1:9f5e1d4:             if (sqlType != null) {
1:9f5e1d4:                 return sqlType.getJDBCTypeId();
1:9f5e1d4:             }
1:9f5e1d4:             return java.sql.Types.JAVA_OBJECT;
1:9f5e1d4: 
1:eac0369: 		case 5: // PRECISION:
2:eac0369:                 if (sqlType != null)
1:eac0369:                 {
1:eac0369:                     int type = sqlType.getJDBCTypeId();
1:eac0369:                     if (DataTypeDescriptor.isNumericType(type))
1:eac0369:                         return sqlType.getPrecision();
1:eac0369:                     else if (type == Types.DATE || type == Types.TIME
1:eac0369:                              || type == Types.TIMESTAMP)
1:eac0369:                         return DataTypeUtilities.getColumnDisplaySize(type, -1);
2:eac0369:                     else
2:eac0369:                         return sqlType.getMaximumWidth();
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // No corresponding SQL type
1:eac0369:                 return 0;
1:eac0369: 
1:09c8a0d: 		case 6: // LENGTH (in bytes):
1:eac0369:                 if (sqlType != null)
1:09c8a0d:                     return sqlType.getMaximumWidthInBytes();
1:eac0369: 
1:eac0369:                 // No corresponding SQL type
1:eac0369:                 return 0;
1:eac0369:           
1:eac0369:             default:
1:eac0369:                 return super.getInt(column);  // throw exception
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     //
1:eac0369:     // Get the value of the specified data type from a column.
1:eac0369:     // 
1:eac0369:     // @exception SQLException  Thrown if there is a SQL error.
1:eac0369:     //
1:eac0369:     //
1:eac0369:     public short getShort(int column) throws SQLException 
1:eac0369:     {
1:eac0369:         switch (column) 
1:eac0369:         {
1:eac0369: 		case 2: // COLUMN_TYPE:
1:e423333: 			return columnType;
1:eac0369: 
1:eac0369: 		case 7: // SCALE:
1:eac0369:                 if (sqlType != null)
1:eac0369:                     return (short)sqlType.getScale();
1:eac0369: 
1:eac0369:                 // No corresponding SQL type
1:eac0369:                 return 0;
1:eac0369: 
1:eac0369: 		case 8: // RADIX:
1:eac0369:                 if (sqlType != null)
1:eac0369:                 {
1:eac0369:                     int sqlTypeID = sqlType.getJDBCTypeId();
1:eac0369:                     if (sqlTypeID == java.sql.Types.REAL ||
1:eac0369:                         sqlTypeID == java.sql.Types.FLOAT ||
1:eac0369:                         sqlTypeID == java.sql.Types.DOUBLE)
1:eac0369:                     {
1:eac0369:                         return 2;
1:eac0369:                     }
1:eac0369:                     return 10;
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // No corresponding SQL type
1:eac0369:                 return 0;
1:eac0369: 
1:e423333: 		//FIXME
1:eac0369: 		case 9: // NULLABLE:
1:e423333: 			return nullable;
1:eac0369: 
1:eac0369: 		case 11: // METHOD_ID: 
1:eac0369:                 return method_count;
1:eac0369: 
1:eac0369: 		case 12: // PARAMETER_ID: 
1:eac0369:                 return param_number;
1:eac0369: 
1:eac0369:             default:
1:eac0369:                 return super.getShort(column);  // throw exception
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     public void close()
1:eac0369:     {
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Metadata
1:eac0369: 	*/
1:eac0369: 	private static final ResultColumnDescriptor[] columnInfo = {
1:eac0369: 
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("COLUMN_NAME",				 Types.VARCHAR, false, 128),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("COLUMN_TYPE",				 Types.SMALLINT, false),
1:9f5e1d4: 		EmbedResultSetMetaData.getResultColumnDescriptor("DATA_TYPE",				 Types.INTEGER, false),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("TYPE_NAME",				 Types.VARCHAR, false, 22),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("PRECISION",				 Types.INTEGER, false),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("LENGTH",					 Types.INTEGER, false),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("SCALE",					 Types.SMALLINT, false),
1:eac0369: 
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("RADIX",					 Types.SMALLINT, false),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("NULLABLE",				 Types.SMALLINT, false),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("REMARKS",					 Types.VARCHAR, true, 22),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("METHOD_ID",				 Types.SMALLINT, false),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("PARAMETER_ID",			 Types.SMALLINT, false),
1:eac0369: 	};
1:8514aa2: 
1:8514aa2:     private static final ResultSetMetaData metadata =
1:8514aa2:         new EmbedResultSetMetaData(columnInfo);
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:         <LI><B>PROCEDURE_CAT</B> String =&gt; procedure catalog (may be null)
1:         <LI><B>PROCEDURE_SCHEM</B> String =&gt; procedure schema (may be null)
1:         <LI><B>PROCEDURE_NAME</B> String =&gt; procedure name
1:         <LI><B>COLUMN_NAME</B> String =&gt; column/parameter name 
1:         <LI><B>COLUMN_TYPE</B> Short =&gt; kind of column/parameter:
/////////////////////////////////////////////////////////////////////////
1:   <LI><B>DATA_TYPE</B> int =&gt; SQL type from java.sql.Types
1:         <LI><B>TYPE_NAME</B> String =&gt; SQL type name, for a UDT type the
1:         <LI><B>PRECISION</B> int =&gt; precision
1:         <LI><B>LENGTH</B> int =&gt; length in bytes of data
1:         <LI><B>SCALE</B> short =&gt; scale
1:         <LI><B>RADIX</B> short =&gt; radix
1:         <LI><B>NULLABLE</B> short =&gt; can it contain NULL?
1:         <LI><B>REMARKS</B> String =&gt; comment describing parameter/column
1:         <LI><B>METHOD_ID</B> Short =&gt; Derby extra column (overloading)
1:         <LI><B>PARAMETER_ID</B> Short =&gt; Derby extra column (output order)
commit:dfc9ab0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData40;
/////////////////////////////////////////////////////////////////////////
0: 	private static final ResultSetMetaData metadata = new EmbedResultSetMetaData40(columnInfo);
commit:c6c266b
/////////////////////////////////////////////////////////////////////////
1: 		int     functionParamCursor = -2;
1: 
/////////////////////////////////////////////////////////////////////////
1: 			    functionParamCursor = -1;
/////////////////////////////////////////////////////////////////////////
1: 			paramCursor = functionParamCursor;
commit:d753aef
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.catalog.types.RowMultiSetImpl;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	private boolean isFunction;
1: 	private int          rowCount;
1: 	private int          returnedTableColumnCount;
0: 	private RowMultiSetImpl tableFunctionReturnType;
1:     
/////////////////////////////////////////////////////////////////////////
1:             
1: 			rowCount = procedure.getParameterCount();
1: 			if ( procedure.isTableFunction() ) {
0: 			    tableFunctionReturnType = (RowMultiSetImpl) ((DataTypeDescriptor) procedure.getReturnType()).getTypeId().getBaseTypeId();
0: 			    returnedTableColumnCount = tableFunctionReturnType.getColumnNames().length;
1: 			    rowCount += returnedTableColumnCount;
1: 		        }
/////////////////////////////////////////////////////////////////////////
1: 		if (++paramCursor >= rowCount)
1: 		if ( procedure.isTableFunction() && (  paramCursor >= procedure.getParameterCount() ) ) {
1: 			int     idx = paramCursor - procedure.getParameterCount();
1:             
0: 			sqlType      = tableFunctionReturnType.getTypes()[ idx ];
0: 			columnName   = tableFunctionReturnType.getColumnNames()[ idx ];
0: 			columnType   = (short) JDBC40Translation.FUNCTION_COLUMN_RESULT;
1: 		}
1: 		else if (paramCursor > -1) {
1:         
1: 
commit:e423333
/////////////////////////////////////////////////////////////////////////
1: import java.sql.DatabaseMetaData;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.reference.JDBC40Translation;
/////////////////////////////////////////////////////////////////////////
0: 	private boolean isFunction;
1: 	private int translate(int val) {
1: 		if (!isFunction) { return val; }
1: 		switch (val) {
1: 		case DatabaseMetaData.procedureColumnUnknown:
0: 			return JDBC40Translation.FUNCTION_PARAMETER_UNKNOWN;	
1: 		case DatabaseMetaData.procedureColumnIn:
0: 			return JDBC40Translation.FUNCTION_PARAMETER_IN;
1: 		case DatabaseMetaData.procedureColumnInOut:
0: 			return JDBC40Translation.FUNCTION_PARAMETER_INOUT;	
1: 		case DatabaseMetaData.procedureColumnOut:
0: 			return JDBC40Translation.FUNCTION_PARAMETER_OUT;
1: 		case DatabaseMetaData.procedureColumnReturn:
0: 			return JDBC40Translation.FUNCTION_RETURN;
1: 		default:
0: 			return JDBC40Translation.FUNCTION_PARAMETER_UNKNOWN;	
1: 		}
1:     }
1: 	private int paramCursor;
1:     private String columnName;
1:     private short columnType;
1:     private final short nullable;
/////////////////////////////////////////////////////////////////////////
1: 			isFunction = aliasType.equals("F");
1: 		if (aliasType == null) { 
1: 			nullable = 0;
1: 			return;
1: 		}
1: 
1: 		if (isFunction) {
0: 			nullable = (short) JDBC40Translation.FUNCTION_NULLABLE;
1: 			sqlType = procedure.getReturnType();
1: 			columnName = "";  // COLUMN_NAME is VARCHAR NOT NULL
0: 			columnType = (short) JDBC40Translation.FUNCTION_RETURN;
0: 			paramCursor = -2;
1: 			return;
1: 		}
1: 		nullable = (short) DatabaseMetaData.procedureNullable;
1: 
1: 		paramCursor = -1;
0: 		if (paramCursor > -1) {
1: 			sqlType      = procedure.getParameterTypes()[paramCursor];
1: 			columnName   = procedure.getParameterNames()[paramCursor];
1: 			columnType   = 
1: 				(short)translate(procedure.getParameterModes()[paramCursor]);
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 			return columnName;
/////////////////////////////////////////////////////////////////////////
1: 			return columnType;
/////////////////////////////////////////////////////////////////////////
1: 		//FIXME
1: 			return nullable;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8514aa2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static final ResultSetMetaData metadata =
1:         new EmbedResultSetMetaData(columnInfo);
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             return DatabaseMetaData.functionColumnUnknown;
1:             return DatabaseMetaData.functionColumnIn;
1:             return DatabaseMetaData.functionColumnInOut;
1:             return DatabaseMetaData.functionColumnOut;
1:             return DatabaseMetaData.functionReturn;
1:             return DatabaseMetaData.functionColumnUnknown;
/////////////////////////////////////////////////////////////////////////
1:             nullable = (short) DatabaseMetaData.functionNullable;
1:             columnType = (short) DatabaseMetaData.functionReturn;
/////////////////////////////////////////////////////////////////////////
1:             columnType   = (short) DatabaseMetaData.functionColumnResult;
commit:9f5e1d4
/////////////////////////////////////////////////////////////////////////
0:   <LI><B>DATA_TYPE</B> int => SQL type from java.sql.Types
/////////////////////////////////////////////////////////////////////////
1:         case 3: // DATA_TYPE:
1:             if (sqlType != null) {
1:                 return sqlType.getJDBCTypeId();
1:             }
1:             return java.sql.Types.JAVA_OBJECT;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("DATA_TYPE",				 Types.INTEGER, false),
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:d66ce7b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	private TypeDescriptor tableFunctionReturnType;
/////////////////////////////////////////////////////////////////////////
1: 			    tableFunctionReturnType = procedure.getReturnType();
1: 			    returnedTableColumnCount = tableFunctionReturnType.getRowColumnNames().length;
/////////////////////////////////////////////////////////////////////////
1: 			sqlType      = tableFunctionReturnType.getRowTypes()[ idx ];
1: 			columnName   = tableFunctionReturnType.getRowColumnNames()[ idx ];
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.catalog.GetProcedureColumns
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:4dede3b
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.catalog
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.catalog;
1: 
1: import java.sql.Types;
0: import java.lang.reflect.*;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
0: import org.apache.derby.catalog.TypeDescriptor;
1: 
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataTypeUtilities;
1: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData;
1: import org.apache.derby.catalog.types.RoutineAliasInfo;
1: 
1: /**
1:     <P>Use of VirtualTableInterface to provide support for
1:     DatabaseMetaData.getProcedureColumns().
1: 	
1: 
1:     <P>This class is called from a Query constructed in 
1:     java/org.apache.derby.impl.jdbc/metadata.properties:
1: <PRE>
1: 
1: 
1:     <P>The VTI will return columns 3-14, an extra column to the specification
1:     METHOD_ID is returned to distinguish between overloaded methods.
1: 
1:   <OL>
0:         <LI><B>PROCEDURE_CAT</B> String => procedure catalog (may be null)
0:         <LI><B>PROCEDURE_SCHEM</B> String => procedure schema (may be null)
0:         <LI><B>PROCEDURE_NAME</B> String => procedure name
0:         <LI><B>COLUMN_NAME</B> String => column/parameter name 
0:         <LI><B>COLUMN_TYPE</B> Short => kind of column/parameter:
1:       <UL>
1:       <LI> procedureColumnUnknown - nobody knows
1:       <LI> procedureColumnIn - IN parameter
1:       <LI> procedureColumnInOut - INOUT parameter
1:       <LI> procedureColumnOut - OUT parameter
1:       <LI> procedureColumnReturn - procedure return value
1:       <LI> procedureColumnResult - result column in ResultSet
1:       </UL>
0:   <LI><B>DATA_TYPE</B> short => SQL type from java.sql.Types
0:         <LI><B>TYPE_NAME</B> String => SQL type name, for a UDT type the
1:   type name is fully qualified
0:         <LI><B>PRECISION</B> int => precision
0:         <LI><B>LENGTH</B> int => length in bytes of data
0:         <LI><B>SCALE</B> short => scale
0:         <LI><B>RADIX</B> short => radix
0:         <LI><B>NULLABLE</B> short => can it contain NULL?
1:       <UL>
1:       <LI> procedureNoNulls - does not allow NULL values
1:       <LI> procedureNullable - allows NULL values
1:       <LI> procedureNullableUnknown - nullability unknown
1:       </UL>
0:         <LI><B>REMARKS</B> String => comment describing parameter/column
0:         <LI><B>METHOD_ID</B> Short => cloudscape extra column (overloading)
0:         <LI><B>PARAMETER_ID</B> Short => cloudscape extra column (output order)
1:   </OL>
1: 
1: */
1: 
1: public class GetProcedureColumns extends org.apache.derby.vti.VTITemplate 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
1: 
1: 	private boolean isProcedure;
1: 	// state for procedures.
1: 	private RoutineAliasInfo procedure;
0: 	private int paramCursor = -1;
1:     private short method_count;
1:     private short param_number;
1: 
1:     private TypeDescriptor sqlType;
1: 
1:     public ResultSetMetaData getMetaData()
1:     {        
1:         return metadata;
1:     }
1: 
1:     //
1:     // Instantiates the vti given a class name and methodname.
1:     // 
1:     // @exception SQLException  Thrown if there is a SQL error.
1:     //
1:     //
1:     public GetProcedureColumns(AliasInfo aliasInfo, String aliasType) throws SQLException 
1:     {
1: 		// compile time aliasInfo will be null.
1: 		if (aliasInfo != null) {
1: 
1: 			isProcedure = aliasType.equals("P");
1: 			procedure = (RoutineAliasInfo) aliasInfo;
1: 			method_count = (short) procedure.getParameterCount();
1: 		}
1:     }
1: 
1:     public boolean next() throws SQLException {
0: 		if (++paramCursor >= procedure.getParameterCount())
1: 			return false;
1: 
0: 		sqlType = procedure.getParameterTypes()[paramCursor];
1: 
1: 		param_number = (short) paramCursor;
1: 
1: 		return true;
1: 
1: 	}   
1: 
1:     //
1:     // Get the value of the specified data type from a column.
1:     // 
1:     // @exception SQLException  Thrown if there is a SQL error.
1:     //
1:     //
1:     public String getString(int column) throws SQLException 
1:     {
1:         switch (column) 
1:         {
1: 		case 1: // COLUMN_NAME:
0: 				return procedure.getParameterNames()[paramCursor];
1: 
1: 		case 4: //_TYPE_NAME: 
1:                return sqlType.getTypeName();
1:                
1: 		case 10: // REMARKS:
1:                 return null;
1: 
1:             default: 
1:                 return super.getString(column);  // throw exception
1:         }
1:     }
1: 
1:     //
1:     // Get the value of the specified data type from a column.
1:     // 
1:     // @exception SQLException  Thrown if there is a SQL error.
1:     //
1:     //
1:     public int getInt(int column) throws SQLException 
1:     {
1:         switch (column) 
1:         {
1: 		case 5: // PRECISION:
1:                 if (sqlType != null)
1:                 {
1:                     int type = sqlType.getJDBCTypeId();
1:                     if (DataTypeDescriptor.isNumericType(type))
1:                         return sqlType.getPrecision();
1:                     else if (type == Types.DATE || type == Types.TIME
1:                              || type == Types.TIMESTAMP)
1:                         return DataTypeUtilities.getColumnDisplaySize(type, -1);
1:                     else
1:                         return sqlType.getMaximumWidth();
1:                 }
1: 
1:                 // No corresponding SQL type
1:                 return 0;
1: 
0: 		case 6: // LENGTH:
1:                 if (sqlType != null)
1:                     return sqlType.getMaximumWidth();
1: 
1:                 // No corresponding SQL type
1:                 return 0;
1:           
1:             default:
1:                 return super.getInt(column);  // throw exception
1:         }
1:     }
1: 
1:     //
1:     // Get the value of the specified data type from a column.
1:     // 
1:     // @exception SQLException  Thrown if there is a SQL error.
1:     //
1:     //
1:     public short getShort(int column) throws SQLException 
1:     {
1:         switch (column) 
1:         {
1: 		case 2: // COLUMN_TYPE:
0: 			return (short) (procedure.getParameterModes()[paramCursor]);
1: 
0: 		case 3: // DATA_TYPE:
1:                 if (sqlType != null)
0:                     return (short)sqlType.getJDBCTypeId();
1:                 else
0:                     return (short) java.sql.Types.JAVA_OBJECT;
1: 
1: 		case 7: // SCALE:
1:                 if (sqlType != null)
1:                     return (short)sqlType.getScale();
1: 
1:                 // No corresponding SQL type
1:                 return 0;
1: 
1: 		case 8: // RADIX:
1:                 if (sqlType != null)
1:                 {
1:                     int sqlTypeID = sqlType.getJDBCTypeId();
1:                     if (sqlTypeID == java.sql.Types.REAL ||
1:                         sqlTypeID == java.sql.Types.FLOAT ||
1:                         sqlTypeID == java.sql.Types.DOUBLE)
1:                     {
1:                         return 2;
1:                     }
1:                     return 10;
1:                 }
1: 
1:                 // No corresponding SQL type
1:                 return 0;
1: 
1: 		case 9: // NULLABLE:
0:                 return (short)java.sql.DatabaseMetaData.procedureNullable;
1: 
1: 		case 11: // METHOD_ID: 
1:                 return method_count;
1: 
1: 		case 12: // PARAMETER_ID: 
1:                 return param_number;
1: 
1:             default:
1:                 return super.getShort(column);  // throw exception
1:         }
1:     }
1: 
1:     public void close()
1:     {
1:     }
1: 
1: 	/*
1: 	** Metadata
1: 	*/
1: 	private static final ResultColumnDescriptor[] columnInfo = {
1: 
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("COLUMN_NAME",				 Types.VARCHAR, false, 128),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("COLUMN_TYPE",				 Types.SMALLINT, false),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("DATA_TYPE",				 Types.SMALLINT, false),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("TYPE_NAME",				 Types.VARCHAR, false, 22),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("PRECISION",				 Types.INTEGER, false),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("LENGTH",					 Types.INTEGER, false),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("SCALE",					 Types.SMALLINT, false),
1: 
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("RADIX",					 Types.SMALLINT, false),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("NULLABLE",				 Types.SMALLINT, false),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("REMARKS",					 Types.VARCHAR, true, 22),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("METHOD_ID",				 Types.SMALLINT, false),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("PARAMETER_ID",			 Types.SMALLINT, false),
1: 	};
0: 	private static final ResultSetMetaData metadata = new EmbedResultSetMetaData(columnInfo);
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:2c21843
/////////////////////////////////////////////////////////////////////////
0:         <LI><B>METHOD_ID</B> Short => Derby extra column (overloading)
0:         <LI><B>PARAMETER_ID</B> Short => Derby extra column (output order)
commit:2f36947
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:09c8a0d
/////////////////////////////////////////////////////////////////////////
0:     public GetProcedureColumns(AliasInfo aliasInfo, String aliasType) throws SQLException
/////////////////////////////////////////////////////////////////////////
1: 		case 6: // LENGTH (in bytes):
1:                     return sqlType.getMaximumWidthInBytes();
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.catalog
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.catalog;
0: 
0: import java.sql.Types;
0: import java.lang.reflect.*;
0: import java.sql.ResultSetMetaData;
0: import java.sql.SQLException;
0: import org.apache.derby.catalog.TypeDescriptor;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataTypeUtilities;
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData;
0: import org.apache.derby.catalog.types.RoutineAliasInfo;
0: 
0: /**
0:     <P>Use of VirtualTableInterface to provide support for
0:     DatabaseMetaData.getProcedureColumns().
0: 	
0: 
0:     <P>This class is called from a Query constructed in 
0:     java/org.apache.derby.impl.jdbc/metadata.properties:
0: <PRE>
0: 
0: 
0:     <P>The VTI will return columns 3-14, an extra column to the specification
0:     METHOD_ID is returned to distinguish between overloaded methods.
0: 
0:   <OL>
0:         <LI><B>PROCEDURE_CAT</B> String => procedure catalog (may be null)
0:         <LI><B>PROCEDURE_SCHEM</B> String => procedure schema (may be null)
0:         <LI><B>PROCEDURE_NAME</B> String => procedure name
0:         <LI><B>COLUMN_NAME</B> String => column/parameter name 
0:         <LI><B>COLUMN_TYPE</B> Short => kind of column/parameter:
0:       <UL>
0:       <LI> procedureColumnUnknown - nobody knows
0:       <LI> procedureColumnIn - IN parameter
0:       <LI> procedureColumnInOut - INOUT parameter
0:       <LI> procedureColumnOut - OUT parameter
0:       <LI> procedureColumnReturn - procedure return value
0:       <LI> procedureColumnResult - result column in ResultSet
0:       </UL>
0:   <LI><B>DATA_TYPE</B> short => SQL type from java.sql.Types
0:         <LI><B>TYPE_NAME</B> String => SQL type name, for a UDT type the
0:   type name is fully qualified
0:         <LI><B>PRECISION</B> int => precision
0:         <LI><B>LENGTH</B> int => length in bytes of data
0:         <LI><B>SCALE</B> short => scale
0:         <LI><B>RADIX</B> short => radix
0:         <LI><B>NULLABLE</B> short => can it contain NULL?
0:       <UL>
0:       <LI> procedureNoNulls - does not allow NULL values
0:       <LI> procedureNullable - allows NULL values
0:       <LI> procedureNullableUnknown - nullability unknown
0:       </UL>
0:         <LI><B>REMARKS</B> String => comment describing parameter/column
0:         <LI><B>METHOD_ID</B> Short => cloudscape extra column (overloading)
0:         <LI><B>PARAMETER_ID</B> Short => cloudscape extra column (output order)
0:   </OL>
0: 
0: */
0: 
0: public class GetProcedureColumns extends org.apache.derby.vti.VTITemplate 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0: 
0: 	private boolean isProcedure;
0: 	// state for procedures.
0: 	private RoutineAliasInfo procedure;
0: 	private int paramCursor = -1;
0:     private short method_count;
0:     private short param_number;
0: 
0:     private TypeDescriptor sqlType;
0: 
0:     public ResultSetMetaData getMetaData()
0:     {        
0:         return metadata;
0:     }
0: 
0:     //
0:     // Instantiates the vti given a class name and methodname.
0:     // 
0:     // @exception SQLException  Thrown if there is a SQL error.
0:     //
0:     //
0:     public GetProcedureColumns(AliasInfo aliasInfo, String aliasType) throws SQLException 
0:     {
0: 		// compile time aliasInfo will be null.
0: 		if (aliasInfo != null) {
0: 
0: 			isProcedure = aliasType.equals("P");
0: 			procedure = (RoutineAliasInfo) aliasInfo;
0: 			method_count = (short) procedure.getParameterCount();
0: 		}
0:     }
0: 
0:     public boolean next() throws SQLException {
0: 		if (++paramCursor >= procedure.getParameterCount())
0: 			return false;
0: 
0: 		sqlType = procedure.getParameterTypes()[paramCursor];
0: 
0: 		param_number = (short) paramCursor;
0: 
0: 		return true;
0: 
0: 	}   
0: 
0:     //
0:     // Get the value of the specified data type from a column.
0:     // 
0:     // @exception SQLException  Thrown if there is a SQL error.
0:     //
0:     //
0:     public String getString(int column) throws SQLException 
0:     {
0:         switch (column) 
0:         {
0: 		case 1: // COLUMN_NAME:
0: 				return procedure.getParameterNames()[paramCursor];
0: 
0: 		case 4: //_TYPE_NAME: 
0:                return sqlType.getTypeName();
0:                
0: 		case 10: // REMARKS:
0:                 return null;
0: 
0:             default: 
0:                 return super.getString(column);  // throw exception
0:         }
0:     }
0: 
0:     //
0:     // Get the value of the specified data type from a column.
0:     // 
0:     // @exception SQLException  Thrown if there is a SQL error.
0:     //
0:     //
0:     public int getInt(int column) throws SQLException 
0:     {
0:         switch (column) 
0:         {
0: 		case 5: // PRECISION:
0:                 if (sqlType != null)
0:                 {
0:                     int type = sqlType.getJDBCTypeId();
0:                     if (DataTypeDescriptor.isNumericType(type))
0:                         return sqlType.getPrecision();
0:                     else if (type == Types.DATE || type == Types.TIME
0:                              || type == Types.TIMESTAMP)
0:                         return DataTypeUtilities.getColumnDisplaySize(type, -1);
0:                     else
0:                         return sqlType.getMaximumWidth();
0:                 }
0: 
0:                 // No corresponding SQL type
0:                 return 0;
0: 
0: 		case 6: // LENGTH:
0:                 if (sqlType != null)
0:                     return sqlType.getMaximumWidth();
0: 
0:                 // No corresponding SQL type
0:                 return 0;
0:           
0:             default:
0:                 return super.getInt(column);  // throw exception
0:         }
0:     }
0: 
0:     //
0:     // Get the value of the specified data type from a column.
0:     // 
0:     // @exception SQLException  Thrown if there is a SQL error.
0:     //
0:     //
0:     public short getShort(int column) throws SQLException 
0:     {
0:         switch (column) 
0:         {
0: 		case 2: // COLUMN_TYPE:
0: 			return (short) (procedure.getParameterModes()[paramCursor]);
0: 
0: 		case 3: // DATA_TYPE:
0:                 if (sqlType != null)
0:                     return (short)sqlType.getJDBCTypeId();
0:                 else
0:                     return (short) java.sql.Types.JAVA_OBJECT;
0: 
0: 		case 7: // SCALE:
0:                 if (sqlType != null)
0:                     return (short)sqlType.getScale();
0: 
0:                 // No corresponding SQL type
0:                 return 0;
0: 
0: 		case 8: // RADIX:
0:                 if (sqlType != null)
0:                 {
0:                     int sqlTypeID = sqlType.getJDBCTypeId();
0:                     if (sqlTypeID == java.sql.Types.REAL ||
0:                         sqlTypeID == java.sql.Types.FLOAT ||
0:                         sqlTypeID == java.sql.Types.DOUBLE)
0:                     {
0:                         return 2;
0:                     }
0:                     return 10;
0:                 }
0: 
0:                 // No corresponding SQL type
0:                 return 0;
0: 
0: 		case 9: // NULLABLE:
0:                 return (short)java.sql.DatabaseMetaData.procedureNullable;
0: 
0: 		case 11: // METHOD_ID: 
0:                 return method_count;
0: 
0: 		case 12: // PARAMETER_ID: 
0:                 return param_number;
0: 
0:             default:
0:                 return super.getShort(column);  // throw exception
0:         }
0:     }
0: 
0:     public void close()
0:     {
0:     }
0: 
0: 	/*
0: 	** Metadata
0: 	*/
0: 	private static final ResultColumnDescriptor[] columnInfo = {
0: 
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("COLUMN_NAME",				 Types.VARCHAR, false, 128),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("COLUMN_TYPE",				 Types.SMALLINT, false),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("DATA_TYPE",				 Types.SMALLINT, false),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("TYPE_NAME",				 Types.VARCHAR, false, 22),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("PRECISION",				 Types.INTEGER, false),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("LENGTH",					 Types.INTEGER, false),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("SCALE",					 Types.SMALLINT, false),
0: 
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("RADIX",					 Types.SMALLINT, false),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("NULLABLE",				 Types.SMALLINT, false),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("REMARKS",					 Types.VARCHAR, true, 22),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("METHOD_ID",				 Types.SMALLINT, false),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("PARAMETER_ID",			 Types.SMALLINT, false),
0: 	};
0: 	private static final ResultSetMetaData metadata = new EmbedResultSetMetaData(columnInfo);
0: }
============================================================================