1:eac0369: /*
10:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.BinaryComparisonOperatorNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:f33fbaf: import java.util.List;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * This node is the superclass  for all binary comparison operators, such as =,
1:dbed020:  * &lt;&gt;, &lt;, etc.
4:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: public abstract class BinaryComparisonOperatorNode extends BinaryOperatorNode
4:eac0369: {
1:eac0369: 	// Use between selectivity?
1:eac0369: 	private boolean forQueryRewrite;
1:eac0369: 	private boolean betweenSelectivity;
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for a BinaryComparisonOperatorNode
1:eac0369: 	 *
1:eac0369: 	 * @param leftOperand	The left operand of the comparison
1:eac0369: 	 * @param rightOperand	The right operand of the comparison
1:eac0369: 	 * @param operator		The name of the operator
1:eac0369: 	 * @param methodName	The name of the method to call in the generated
1:eac0369: 	 *						class
1:8c15184: 	 * @param forQueryRewrite Can be true only if if this node has been 
1:8c15184: 	 *                      added by an internal rewrite of the query. This
1:8c15184: 	 *                      allows binding to be more liberal when checking 
1:8c15184: 	 *                      it against allowed syntax.
1:8c15184: 	 *                      This parameter will be passed FALSE when a new 
1:8c15184: 	 *                      instance of the node is being created(which is 
1:8c15184: 	 *                      the majority of the cases). But when an  
1:8c15184: 	 *                      existing node is getting cloned, the value of
1:8c15184: 	 *                      this parameter should be passed as the 
1:8c15184: 	 *                      originalNode.getForQueryRewrite(). Examples of
1:8c15184: 	 *                      this can be found in Predicate.Java and 
1:8c15184: 	 *                      PredicateList.java
1:3bb140c:      * @param cm            The context manager
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     BinaryComparisonOperatorNode(
1:3bb140c:                 ValueNode   leftOperand,
1:3bb140c:                 ValueNode   rightOperand,
1:3bb140c:                 String      operator,
1:3bb140c:                 String      methodName,
1:3bb140c:                 boolean     forQueryRewrite,
1:3bb140c:                 ContextManager cm) throws StandardException
1:eac0369: 	{
1:3bb140c:         super(leftOperand,
1:3bb140c:               rightOperand,
1:3bb140c:               operator,
1:3bb140c:               methodName,
1:3bb140c:               ClassName.DataValueDescriptor,
1:3bb140c:               ClassName.DataValueDescriptor,
1:3bb140c:               cm);
1:3bb140c:         this.forQueryRewrite = forQueryRewrite;
4:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This node was generated as part of a query rewrite. Bypass the
1:eac0369: 	 * normal comparability checks.
1:eac0369: 	 * @param val  true if this was for a query rewrite
1:eac0369: 	 */
1:3bb140c:     void setForQueryRewrite(boolean val)
1:eac0369: 	{
1:eac0369: 		forQueryRewrite=val;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Was this node generated in a query rewrite?
1:eac0369: 	 *
1:eac0369: 	 * @return  true if it was generated in a query rewrite.
1:eac0369: 	 */
1:3bb140c:     boolean getForQueryRewrite()
1:eac0369: 	{
1:eac0369: 		return forQueryRewrite;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Use between selectivity when calculating the selectivity.
1:eac0369: 	 */
1:eac0369: 	void setBetweenSelectivity()
1:eac0369: 	{
1:eac0369: 		betweenSelectivity = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not to use the between selectivity for this node.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not to use the between selectivity for this node.
1:eac0369: 	 */
1:eac0369: 	boolean getBetweenSelectivity()
1:eac0369: 	{
1:eac0369: 		return betweenSelectivity;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this comparison operator.  All that has to be done for binding
1:eac0369: 	 * a comparison operator is to bind the operands, check the compatibility
1:eac0369: 	 * of the types, and set the result type to SQLBoolean.
1:eac0369: 	 *
1:eac0369: 	 * @param fromList			The query's FROM list
1:eac0369: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
1:09c2697:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:eac0369: 	 *
1:eac0369: 	 * @return	The new top of the expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:09c2697:     ValueNode bindExpression(
1:71c8e86:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
2:eac0369: 			throws StandardException
1:eac0369: 	{
1:09c2697:         super.bindExpression(fromList, subqueryList, aggregates);
1:eac0369: 
1:eac0369: 		TypeId leftTypeId = leftOperand.getTypeId();
1:eac0369: 		TypeId rightTypeId = rightOperand.getTypeId();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		 * If we are comparing a non-string with a string type, then we
1:eac0369: 		 * must prevent the non-string value from being used to probe into
1:eac0369: 		 * an index on a string column. This is because the string types
1:eac0369: 		 * are all of low precedence, so the comparison rules of the non-string
1:eac0369: 		 * value are used, so it may not find values in a string index because
1:eac0369: 		 * it will be in the wrong order. So, cast the string value to its
1:eac0369: 		 * own type. This is easier than casting it to the non-string type,
1:eac0369: 		 * because we would have to figure out the right length to cast it to.
1:eac0369: 		 */
1:eac0369: 		if (! leftTypeId.isStringTypeId() && rightTypeId.isStringTypeId())
1:eac0369: 		{
1:eac0369: 			DataTypeDescriptor rightTypeServices = rightOperand.getTypeServices();
1:eac0369: 
1:3bb140c:             rightOperand = new CastNode(
2:eac0369: 					rightOperand, 
1:eac0369: 					new DataTypeDescriptor(
1:eac0369: 							rightTypeId,
1:eac0369: 							true, 
1:eac0369: 							rightTypeServices.getMaximumWidth()),
3:eac0369: 					getContextManager());
2:eac0369: 			((CastNode) rightOperand).bindCastNodeOnly();
1:eac0369: 		}
1:eac0369: 		else if (! rightTypeId.isStringTypeId() && leftTypeId.isStringTypeId())
1:eac0369: 		{
1:eac0369: 			DataTypeDescriptor leftTypeServices = leftOperand.getTypeServices();
1:eac0369: 
1:3bb140c:             leftOperand = new CastNode(
2:eac0369: 					leftOperand, 
1:eac0369: 					new DataTypeDescriptor(
1:eac0369: 							leftTypeId,
1:eac0369: 							true, 
1:eac0369: 							leftTypeServices.getMaximumWidth()),
1:eac0369: 					getContextManager());
2:eac0369: 			((CastNode) leftOperand).bindCastNodeOnly();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Test type compatability and set type info for this node */
1:eac0369: 		bindComparisonOperator();
1:eac0369: 
2:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Test the type compatability of the operands and set the type info
1:eac0369: 	 * for this node.  This method is useful both during binding and
1:eac0369: 	 * when we generate nodes within the language module outside of the parser.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void bindComparisonOperator()
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean				nullableResult;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Can the types be compared to each other?  If not, throw an
1:eac0369: 		** exception.
1:eac0369: 		*/
1:eac0369: 		boolean forEquals = operator.equals("=") || operator.equals("<>");
1:eac0369: 
1:2bb198a:         boolean cmp = leftOperand.getTypeServices().comparable(
1:2bb198a:         		rightOperand.getTypeServices(),
1:2bb198a: 				forEquals,
1:2bb198a: 				getClassFactory());
1:eac0369: 		// Bypass the comparable check if this is a rewrite from the 
1:eac0369: 		// optimizer.  We will assume Mr. Optimizer knows what he is doing.
1:eac0369:           if (!cmp && !forQueryRewrite) {
1:eac0369: 			throw StandardException.newException(SQLState.LANG_NOT_COMPARABLE, 
1:3b598ee: 					leftOperand.getTypeServices().getSQLTypeNameWithCollation() ,
1:3b598ee: 					rightOperand.getTypeServices().getSQLTypeNameWithCollation());
1:3b598ee: 				
1:eac0369: 		  }
1:eac0369: 
1:eac0369: 		
1:eac0369: 		/*
1:eac0369: 		** Set the result type of this comparison operator based on the
1:eac0369: 		** operands.  The result type is always SQLBoolean - the only question
1:eac0369: 		** is whether it is nullable or not.  If either of the operands is
1:eac0369: 		** nullable, the result of the comparison must be nullable, too, so
1:eac0369: 		** we can represent the unknown truth value.
1:eac0369: 		*/
1:eac0369: 		nullableResult = leftOperand.getTypeServices().isNullable() ||
1:eac0369: 							rightOperand.getTypeServices().isNullable();
1:eac0369: 		setType(new DataTypeDescriptor(TypeId.BOOLEAN_ID, nullableResult));
1:eac0369: 
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Preprocess an expression tree.  We do a number of transformations
1:eac0369: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1:eac0369: 	 * subquery flattening.
1:eac0369: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1:eac0369: 	 *
1:eac0369: 	 * @param	numTables			Number of tables in the DML Statement
1:eac0369: 	 * @param	outerFromList		FromList from outer query block
1:eac0369: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1:eac0369: 	 * @param	outerPredicateList	PredicateList from outer query block
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode preprocess(int numTables,
1:eac0369: 								FromList outerFromList,
1:eac0369: 								SubqueryList outerSubqueryList,
1:eac0369: 								PredicateList outerPredicateList) 
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		leftOperand = leftOperand.preprocess(numTables,
1:eac0369: 											 outerFromList, outerSubqueryList,
1:eac0369: 											 outerPredicateList);
1:eac0369: 
1:eac0369: 		/* This is where we start to consider flattening expression subqueries based
1:eac0369: 		 * on a uniqueness condition.  If the right child is a SubqueryNode then
1:eac0369: 		 * it is a potentially flattenable expression subquery.  If we flatten the
1:eac0369: 		 * subquery then we at least need to change the right operand of this 
1:eac0369: 		 * comparison.  However, we may want to push the comparison into the subquery
1:eac0369: 		 * itself and replace this outer comparison with TRUE in the tree.  Thus we
1:eac0369: 		 * return rightOperand.preprocess() if the rightOperand is a SubqueryNode.
1:eac0369: 		 * NOTE: SubqueryNode.preprocess() is smart enough to return this node
1:eac0369: 		 * if it is not flattenable.
1:eac0369: 		 * NOTE: We only do this if the subquery has not yet been preprocessed.
1:eac0369: 		 * (A subquery can get preprocessed multiple times if it is a child node
1:eac0369: 		 * in an expression that gets transformed, like BETWEEN.  The subquery
1:eac0369: 		 * remembers whether or not it has been preprocessed and simply returns if
1:eac0369: 		 * it has already been preprocessed.  The return returns the SubqueryNode,
1:eac0369: 		 * so an invalid tree is returned if we set the parent comparison operator
1:eac0369: 		 * when the subquery has already been preprocessed.)
1:eac0369: 		 */
1:eac0369: 		if ((rightOperand instanceof SubqueryNode) &&
1:eac0369: 			!((SubqueryNode) rightOperand).getPreprocessed())
1:eac0369: 		{
1:eac0369: 			((SubqueryNode) rightOperand).setParentComparisonOperator(this);
1:eac0369: 			return rightOperand.preprocess(numTables,
1:eac0369: 										   outerFromList, outerSubqueryList,
1:eac0369: 										   outerPredicateList);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			rightOperand = rightOperand.preprocess(numTables,
1:eac0369: 												   outerFromList, outerSubqueryList,
1:eac0369: 												   outerPredicateList);
1:eac0369: 			return this;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Eliminate NotNodes in the current query block.  We traverse the tree, 
1:eac0369: 	 * inverting ANDs and ORs and eliminating NOTs as we go.  We stop at 
1:eac0369: 	 * ComparisonOperators and boolean expressions.  We invert 
1:eac0369: 	 * ComparisonOperators and replace boolean expressions with 
1:eac0369: 	 * boolean expression = false.
1:eac0369: 	 * NOTE: Since we do not recurse under ComparisonOperators, there
1:eac0369: 	 * still could be NotNodes left in the tree.
1:eac0369: 	 *
1:eac0369: 	 * @param	underNotNode		Whether or not we are under a NotNode.
1:eac0369: 	 *							
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	ValueNode eliminateNots(boolean underNotNode) 
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! underNotNode)
1:eac0369: 		{
1:eac0369: 			return this;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Convert the BinaryComparison operator to its negation */
1:eac0369: 		return getNegation(leftOperand, rightOperand);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Negate the comparison.
1:eac0369: 	 *
1:eac0369: 	 * @param leftOperand	The left operand of the comparison operator
1:eac0369: 	 * @param rightOperand	The right operand of the comparison operator
1:eac0369: 	 *
1:eac0369: 	 * @return BinaryOperatorNode	The negated expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:e7e328d: 	abstract BinaryOperatorNode getNegation(ValueNode leftOperand,
1:eac0369: 										  ValueNode rightOperand)
1:e7e328d: 				throws StandardException;
1:eac0369: 
1:0af1665:     /**
1:0af1665:      * <p>
1:0af1665:      * Return a node equivalent to this node, but with the left and right
1:0af1665:      * operands swapped. The node type may also be changed if the operator
1:0af1665:      * is not symmetric.
1:0af1665:      * </p>
1:0af1665:      *
1:0af1665:      * <p>
1:0af1665:      * This method may for instance be used to normalize a predicate by
1:0af1665:      * moving constants to the right-hand side of the comparison. Example:
1:0af1665:      * {@code 1 = A} will be transformed to {@code A = 1}, and {@code 10 < B}
1:0af1665:      * will be transformed to {@code B > 10}.
1:0af1665:      * </p>
1:0af1665:      *
1:0af1665:      * @return an equivalent expression with the operands swapped
1:0af1665:      * @throws StandardException if an error occurs
1:0af1665:      */
1:0af1665:     abstract BinaryOperatorNode getSwappedEquivalent() throws StandardException;
1:0af1665: 
1:eac0369: 	/**
1:eac0369: 	 * Finish putting an expression into conjunctive normal
1:eac0369: 	 * form.  An expression tree in conjunctive normal form meets
1:eac0369: 	 * the following criteria:
1:eac0369: 	 *		o  If the expression tree is not null,
1:eac0369: 	 *		   the top level will be a chain of AndNodes terminating
1:eac0369: 	 *		   in a true BooleanConstantNode.
1:eac0369: 	 *		o  The left child of an AndNode will never be an AndNode.
1:eac0369: 	 *		o  Any right-linked chain that includes an AndNode will
1:eac0369: 	 *		   be entirely composed of AndNodes terminated by a true BooleanConstantNode.
1:eac0369: 	 *		o  The left child of an OrNode will never be an OrNode.
1:eac0369: 	 *		o  Any right-linked chain that includes an OrNode will
1:eac0369: 	 *		   be entirely composed of OrNodes terminated by a false BooleanConstantNode.
1:eac0369: 	 *		o  ValueNodes other than AndNodes and OrNodes are considered
1:eac0369: 	 *		   leaf nodes for purposes of expression normalization.
1:eac0369: 	 *		   In other words, we won't do any normalization under
1:eac0369: 	 *		   those nodes.
1:eac0369: 	 *
1:eac0369: 	 * In addition, we track whether or not we are under a top level AndNode.  
1:eac0369: 	 * SubqueryNodes need to know this for subquery flattening.
1:eac0369: 	 *
1:eac0369: 	 * @param	underTopAndNode		Whether or not we are under a top level AndNode.
1:eac0369: 	 *							
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode changeToCNF(boolean underTopAndNode)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		/* If our right child is a subquery and we are under a top and node
1:eac0369: 		 * then we want to mark the subquery as under a top and node.
1:eac0369: 		 * That will allow us to consider flattening it.
1:eac0369: 		 */
1:eac0369: 		if (underTopAndNode && (rightOperand instanceof SubqueryNode))
1:eac0369: 		{
1:eac0369: 			rightOperand = rightOperand.changeToCNF(underTopAndNode);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/** @see BinaryOperatorNode#genSQLJavaSQLTree */
1:3bb140c:     @Override
1:3bb140c:     ValueNode genSQLJavaSQLTree() throws StandardException
1:eac0369: 	{
1:eac0369: 		TypeId leftTypeId = leftOperand.getTypeId();
1:eac0369: 
1:eac0369: 		/* If I have Java types, I need only add java->sql->java if the types
1:eac0369: 		 * are not comparable 
1:eac0369: 		 */
1:08d6ce2: 		if (leftTypeId.userType())
1:eac0369: 		{
1:2bb198a: 			if (leftOperand.getTypeServices().comparable(leftOperand.getTypeServices(),
1:2bb198a: 					false, getClassFactory()))
1:eac0369: 				return this;
1:eac0369: 
1:eac0369: 			leftOperand = leftOperand.genSQLJavaSQLTree();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		TypeId rightTypeId = rightOperand.getTypeId();
1:eac0369: 
1:08d6ce2: 		if (rightTypeId.userType())
1:eac0369: 		{
1:2bb198a: 			if (rightOperand.getTypeServices().comparable(rightOperand.getTypeServices(),
1:2bb198a: 					false, getClassFactory()))
1:eac0369: 				return this;
1:eac0369: 
1:eac0369: 			rightOperand = rightOperand.genSQLJavaSQLTree();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:  * &lt;&gt;, &lt;, etc.
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a BinaryComparisonOperatorNode
/////////////////////////////////////////////////////////////////////////
1:      * @param cm            The context manager
1:     BinaryComparisonOperatorNode(
1:                 ValueNode   leftOperand,
1:                 ValueNode   rightOperand,
1:                 String      operator,
1:                 String      methodName,
1:                 boolean     forQueryRewrite,
1:                 ContextManager cm) throws StandardException
1:         super(leftOperand,
1:               rightOperand,
1:               operator,
1:               methodName,
1:               ClassName.DataValueDescriptor,
1:               ClassName.DataValueDescriptor,
1:               cm);
1:         this.forQueryRewrite = forQueryRewrite;
/////////////////////////////////////////////////////////////////////////
1:     void setForQueryRewrite(boolean val)
/////////////////////////////////////////////////////////////////////////
1:     boolean getForQueryRewrite()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             rightOperand = new CastNode(
/////////////////////////////////////////////////////////////////////////
1:             leftOperand = new CastNode(
/////////////////////////////////////////////////////////////////////////
1:     void bindComparisonOperator()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode changeToCNF(boolean underTopAndNode)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode genSQLJavaSQLTree() throws StandardException
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:8c15184
/////////////////////////////////////////////////////////////////////////
1: 	 * @param forQueryRewrite Can be true only if if this node has been 
1: 	 *                      added by an internal rewrite of the query. This
1: 	 *                      allows binding to be more liberal when checking 
1: 	 *                      it against allowed syntax.
1: 	 *                      This parameter will be passed FALSE when a new 
1: 	 *                      instance of the node is being created(which is 
1: 	 *                      the majority of the cases). But when an  
1: 	 *                      existing node is getting cloned, the value of
1: 	 *                      this parameter should be passed as the 
1: 	 *                      originalNode.getForQueryRewrite(). Examples of
1: 	 *                      this can be found in Predicate.Java and 
1: 	 *                      PredicateList.java
0: 				Object		methodName,
0:                 Object      forQueryRewrite)
0:         this.forQueryRewrite = ((Boolean)forQueryRewrite).booleanValue();
commit:111785f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:2bb198a
/////////////////////////////////////////////////////////////////////////
1:         boolean cmp = leftOperand.getTypeServices().comparable(
1:         		rightOperand.getTypeServices(),
1: 				forEquals,
1: 				getClassFactory());
/////////////////////////////////////////////////////////////////////////
1: 			if (leftOperand.getTypeServices().comparable(leftOperand.getTypeServices(),
1: 					false, getClassFactory()))
/////////////////////////////////////////////////////////////////////////
1: 			if (rightOperand.getTypeServices().comparable(rightOperand.getTypeServices(),
1: 					false, getClassFactory()))
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:     ValueNode bindExpression(
0:         FromList fromList, SubqueryList subqueryList, List aggregates)
1:         super.bindExpression(fromList, subqueryList, aggregates);
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         FromList fromList, SubqueryList subqueryList, List aggregateVector)
commit:0af1665
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Return a node equivalent to this node, but with the left and right
1:      * operands swapped. The node type may also be changed if the operator
1:      * is not symmetric.
1:      * </p>
1:      *
1:      * <p>
1:      * This method may for instance be used to normalize a predicate by
1:      * moving constants to the right-hand side of the comparison. Example:
1:      * {@code 1 = A} will be transformed to {@code A = 1}, and {@code 10 < B}
1:      * will be transformed to {@code B > 10}.
1:      * </p>
1:      *
1:      * @return an equivalent expression with the operands swapped
1:      * @throws StandardException if an error occurs
1:      */
1:     abstract BinaryOperatorNode getSwappedEquivalent() throws StandardException;
1: 
commit:e7e328d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	abstract BinaryOperatorNode getNegation(ValueNode leftOperand,
1: 				throws StandardException;
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:3b598ee
/////////////////////////////////////////////////////////////////////////
1: 					leftOperand.getTypeServices().getSQLTypeNameWithCollation() ,
1: 					rightOperand.getTypeServices().getSQLTypeNameWithCollation());
1: 				
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:08d6ce2
/////////////////////////////////////////////////////////////////////////
1: 		if (leftTypeId.userType())
/////////////////////////////////////////////////////////////////////////
1: 		if (rightTypeId.userType())
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.BinaryComparisonOperatorNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
0: import java.util.Vector;
0: import java.sql.Types;
1: 
1: /**
1:  * This node is the superclass  for all binary comparison operators, such as =,
0:  * <>, <, etc.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
1: public abstract class BinaryComparisonOperatorNode extends BinaryOperatorNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	// Use between selectivity?
1: 	private boolean forQueryRewrite;
1: 	private boolean betweenSelectivity;
1: 
1: 	/**
0: 	 * Initializer for a BinaryComparisonOperatorNode
1: 	 *
1: 	 * @param leftOperand	The left operand of the comparison
1: 	 * @param rightOperand	The right operand of the comparison
1: 	 * @param operator		The name of the operator
1: 	 * @param methodName	The name of the method to call in the generated
1: 	 *						class
1: 	 */
1: 
0: 	public void init(
0: 				Object	leftOperand,
0: 				Object	rightOperand,
0: 				Object		operator,
0: 				Object		methodName)
1: 	{
0: 		super.init(leftOperand, rightOperand, operator, methodName,
0: 				ClassName.DataValueDescriptor, ClassName.DataValueDescriptor);
1: 	}
1: 
1: 	/**
1: 	 * This node was generated as part of a query rewrite. Bypass the
1: 	 * normal comparability checks.
1: 	 * @param val  true if this was for a query rewrite
1: 	 *
0: 	 * @return Nothing
1: 	 */
0: 	public void setForQueryRewrite(boolean val)
1: 	{
1: 		forQueryRewrite=val;
1: 	}
1: 
1: 	/**
1: 	 * Was this node generated in a query rewrite?
1: 	 *
1: 	 * @return  true if it was generated in a query rewrite.
1: 	 */
0: 	public boolean getForQueryRewrite()
1: 	{
1: 		return forQueryRewrite;
1: 	}
1: 
1: 	/**
1: 	 * Use between selectivity when calculating the selectivity.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void setBetweenSelectivity()
1: 	{
1: 		betweenSelectivity = true;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not to use the between selectivity for this node.
1: 	 *
1: 	 * @return Whether or not to use the between selectivity for this node.
1: 	 */
1: 	boolean getBetweenSelectivity()
1: 	{
1: 		return betweenSelectivity;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Bind this comparison operator.  All that has to be done for binding
1: 	 * a comparison operator is to bind the operands, check the compatibility
1: 	 * of the types, and set the result type to SQLBoolean.
1: 	 *
1: 	 * @param fromList			The query's FROM list
1: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ValueNode bindExpression(
0: 		FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector)
1: 			throws StandardException
1: 	{
0: 		super.bindExpression(fromList, subqueryList, aggregateVector);
1: 
0: //RESOLVELOCALIZE - convert constants to national constants
0: 		TypeCompiler leftTC = leftOperand.getTypeCompiler();
0: 		TypeCompiler rightTC = rightOperand.getTypeCompiler();
1: 		TypeId leftTypeId = leftOperand.getTypeId();
1: 		TypeId rightTypeId = rightOperand.getTypeId();
1: 
1: 		/*
1: 		 * If we are comparing a non-string with a string type, then we
1: 		 * must prevent the non-string value from being used to probe into
1: 		 * an index on a string column. This is because the string types
1: 		 * are all of low precedence, so the comparison rules of the non-string
1: 		 * value are used, so it may not find values in a string index because
1: 		 * it will be in the wrong order. So, cast the string value to its
1: 		 * own type. This is easier than casting it to the non-string type,
1: 		 * because we would have to figure out the right length to cast it to.
1: 		 */
1: 		if (! leftTypeId.isStringTypeId() && rightTypeId.isStringTypeId())
1: 		{
1: 			DataTypeDescriptor rightTypeServices = rightOperand.getTypeServices();
1: 
0: 			rightOperand =  (ValueNode)
0: 				getNodeFactory().getNode(
0: 					C_NodeTypes.CAST_NODE,
1: 					rightOperand, 
1: 					new DataTypeDescriptor(
1: 							rightTypeId,
1: 							true, 
1: 							rightTypeServices.getMaximumWidth()),
1: 					getContextManager());
1: 			((CastNode) rightOperand).bindCastNodeOnly();
1: 		}
1: 		else if (! rightTypeId.isStringTypeId() && leftTypeId.isStringTypeId())
1: 		{
1: 			DataTypeDescriptor leftTypeServices = leftOperand.getTypeServices();
1: 
0: 			leftOperand =  (ValueNode)
0: 				getNodeFactory().getNode(
0: 					C_NodeTypes.CAST_NODE,
1: 					leftOperand, 
1: 					new DataTypeDescriptor(
1: 							leftTypeId,
1: 							true, 
1: 							leftTypeServices.getMaximumWidth()),
1: 					getContextManager());
1: 			((CastNode) leftOperand).bindCastNodeOnly();
1: 		}
0: 		/* If we are comparing a char with a national char then
0: 		 * we need to generate a cast to the appropriate national
0: 		 * char above the char operand.
1: 		 */
0: 		else if (! leftTypeId.isNationalStringTypeId() &&
0: 			rightTypeId.isNationalStringTypeId())
1: 		{
0: 			leftOperand =  (ValueNode)
0: 				getNodeFactory().getNode(
0: 					C_NodeTypes.CAST_NODE,
1: 					leftOperand, 
0: 					DataTypeDescriptor.getBuiltInDataTypeDescriptor(leftTC.getMatchingNationalCharTypeName(),
0: 										leftTC.getCastToCharWidth(
0: 											leftOperand.getTypeServices())),
1: 					getContextManager());
1: 			((CastNode) leftOperand).bindCastNodeOnly();
1: 		}
0: 		else if (! rightTypeId.isNationalStringTypeId() &&
0: 				leftTypeId.isNationalStringTypeId())
1: 		{
0: 			rightOperand =  (ValueNode)
0: 				getNodeFactory().getNode(
0: 					C_NodeTypes.CAST_NODE,
1: 					rightOperand, 
0: 					DataTypeDescriptor.getBuiltInDataTypeDescriptor(rightTC.getMatchingNationalCharTypeName(), 
0: 										rightTC.getCastToCharWidth(
0: 											rightOperand.getTypeServices())),
1: 					getContextManager());
1: 			((CastNode) rightOperand).bindCastNodeOnly();
1: 		}
1: 
1: 		/* Test type compatability and set type info for this node */
1: 		bindComparisonOperator();
1: 
1: 		return this;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Test the type compatability of the operands and set the type info
1: 	 * for this node.  This method is useful both during binding and
1: 	 * when we generate nodes within the language module outside of the parser.
1: 	 *
0: 	 * @param fromQueryRewrite  If true this call came from a query that was
0: 	 * rewritten by the optimizer.  The normal isComparable check will be 
0: 	 * bypassed to allow > < and the like with longvarchar.  
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void bindComparisonOperator()
1: 			throws StandardException
1: 	{
0: 		TypeId	leftType;
0: 		TypeId	rightType;
1: 		boolean				nullableResult;
1: 
0: 		leftType = leftOperand.getTypeId();
0: 		rightType = rightOperand.getTypeId();
1: 
1: 
1: 		/*
1: 		** Can the types be compared to each other?  If not, throw an
1: 		** exception.
1: 		*/
1: 		boolean forEquals = operator.equals("=") || operator.equals("<>");
1: 
0:         boolean cmp = leftOperand.getTypeCompiler().comparable(rightType,
0:                                                                forEquals,
0:                                                                getClassFactory());
1: 		// Bypass the comparable check if this is a rewrite from the 
1: 		// optimizer.  We will assume Mr. Optimizer knows what he is doing.
1:           if (!cmp && !forQueryRewrite) {
1: 			throw StandardException.newException(SQLState.LANG_NOT_COMPARABLE, 
0: 					leftType.getSQLTypeName(),
0: 					rightType.getSQLTypeName()
0: 				);
1: 		  }
1: 
1: 		
1: 		/*
1: 		** Set the result type of this comparison operator based on the
1: 		** operands.  The result type is always SQLBoolean - the only question
1: 		** is whether it is nullable or not.  If either of the operands is
1: 		** nullable, the result of the comparison must be nullable, too, so
1: 		** we can represent the unknown truth value.
1: 		*/
1: 		nullableResult = leftOperand.getTypeServices().isNullable() ||
1: 							rightOperand.getTypeServices().isNullable();
1: 		setType(new DataTypeDescriptor(TypeId.BOOLEAN_ID, nullableResult));
1: 
1: 
1: 	}
1: 
1: 	/**
1: 	 * Preprocess an expression tree.  We do a number of transformations
1: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1: 	 * subquery flattening.
1: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1: 	 *
1: 	 * @param	numTables			Number of tables in the DML Statement
1: 	 * @param	outerFromList		FromList from outer query block
1: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1: 	 * @param	outerPredicateList	PredicateList from outer query block
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode preprocess(int numTables,
1: 								FromList outerFromList,
1: 								SubqueryList outerSubqueryList,
1: 								PredicateList outerPredicateList) 
1: 					throws StandardException
1: 	{
1: 		leftOperand = leftOperand.preprocess(numTables,
1: 											 outerFromList, outerSubqueryList,
1: 											 outerPredicateList);
1: 
1: 		/* This is where we start to consider flattening expression subqueries based
1: 		 * on a uniqueness condition.  If the right child is a SubqueryNode then
1: 		 * it is a potentially flattenable expression subquery.  If we flatten the
1: 		 * subquery then we at least need to change the right operand of this 
1: 		 * comparison.  However, we may want to push the comparison into the subquery
1: 		 * itself and replace this outer comparison with TRUE in the tree.  Thus we
1: 		 * return rightOperand.preprocess() if the rightOperand is a SubqueryNode.
1: 		 * NOTE: SubqueryNode.preprocess() is smart enough to return this node
1: 		 * if it is not flattenable.
1: 		 * NOTE: We only do this if the subquery has not yet been preprocessed.
1: 		 * (A subquery can get preprocessed multiple times if it is a child node
1: 		 * in an expression that gets transformed, like BETWEEN.  The subquery
1: 		 * remembers whether or not it has been preprocessed and simply returns if
1: 		 * it has already been preprocessed.  The return returns the SubqueryNode,
1: 		 * so an invalid tree is returned if we set the parent comparison operator
1: 		 * when the subquery has already been preprocessed.)
1: 		 */
1: 		if ((rightOperand instanceof SubqueryNode) &&
1: 			!((SubqueryNode) rightOperand).getPreprocessed())
1: 		{
1: 			((SubqueryNode) rightOperand).setParentComparisonOperator(this);
1: 			return rightOperand.preprocess(numTables,
1: 										   outerFromList, outerSubqueryList,
1: 										   outerPredicateList);
1: 		}
1: 		else
1: 		{
1: 			rightOperand = rightOperand.preprocess(numTables,
1: 												   outerFromList, outerSubqueryList,
1: 												   outerPredicateList);
1: 			return this;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Eliminate NotNodes in the current query block.  We traverse the tree, 
1: 	 * inverting ANDs and ORs and eliminating NOTs as we go.  We stop at 
1: 	 * ComparisonOperators and boolean expressions.  We invert 
1: 	 * ComparisonOperators and replace boolean expressions with 
1: 	 * boolean expression = false.
1: 	 * NOTE: Since we do not recurse under ComparisonOperators, there
1: 	 * still could be NotNodes left in the tree.
1: 	 *
1: 	 * @param	underNotNode		Whether or not we are under a NotNode.
1: 	 *							
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	ValueNode eliminateNots(boolean underNotNode) 
1: 					throws StandardException
1: 	{
1: 		if (! underNotNode)
1: 		{
1: 			return this;
1: 		}
1: 
1: 		/* Convert the BinaryComparison operator to its negation */
1: 		return getNegation(leftOperand, rightOperand);
1: 	}
1: 
1: 	/**
1: 	 * Negate the comparison.
1: 	 *
1: 	 * @param leftOperand	The left operand of the comparison operator
1: 	 * @param rightOperand	The right operand of the comparison operator
1: 	 *
1: 	 * @return BinaryOperatorNode	The negated expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	BinaryOperatorNode getNegation(ValueNode leftOperand,
1: 										  ValueNode rightOperand)
1: 				throws StandardException
1: 	{
0: 		/* Keep the compiler happy - this method should never be called.
0: 		 * We should always be calling the method in a sub-class.
1: 		 */
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(false,
0: 					"expected to call getNegation() for subclass " +
0: 					getClass().toString());
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Finish putting an expression into conjunctive normal
1: 	 * form.  An expression tree in conjunctive normal form meets
1: 	 * the following criteria:
1: 	 *		o  If the expression tree is not null,
1: 	 *		   the top level will be a chain of AndNodes terminating
1: 	 *		   in a true BooleanConstantNode.
1: 	 *		o  The left child of an AndNode will never be an AndNode.
1: 	 *		o  Any right-linked chain that includes an AndNode will
1: 	 *		   be entirely composed of AndNodes terminated by a true BooleanConstantNode.
1: 	 *		o  The left child of an OrNode will never be an OrNode.
1: 	 *		o  Any right-linked chain that includes an OrNode will
1: 	 *		   be entirely composed of OrNodes terminated by a false BooleanConstantNode.
1: 	 *		o  ValueNodes other than AndNodes and OrNodes are considered
1: 	 *		   leaf nodes for purposes of expression normalization.
1: 	 *		   In other words, we won't do any normalization under
1: 	 *		   those nodes.
1: 	 *
1: 	 * In addition, we track whether or not we are under a top level AndNode.  
1: 	 * SubqueryNodes need to know this for subquery flattening.
1: 	 *
1: 	 * @param	underTopAndNode		Whether or not we are under a top level AndNode.
1: 	 *							
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode changeToCNF(boolean underTopAndNode) 
1: 					throws StandardException
1: 	{
1: 		/* If our right child is a subquery and we are under a top and node
1: 		 * then we want to mark the subquery as under a top and node.
1: 		 * That will allow us to consider flattening it.
1: 		 */
1: 		if (underTopAndNode && (rightOperand instanceof SubqueryNode))
1: 		{
1: 			rightOperand = rightOperand.changeToCNF(underTopAndNode);
1: 		}
1: 
1: 		return this;
1: 	}
1: 	
1: 	/** @see BinaryOperatorNode#genSQLJavaSQLTree */
0: 	public ValueNode genSQLJavaSQLTree() throws StandardException
1: 	{
1: 		TypeId leftTypeId = leftOperand.getTypeId();
1: 
1: 		/* If I have Java types, I need only add java->sql->java if the types
1: 		 * are not comparable 
1: 		 */
0: 		if (!leftTypeId.systemBuiltIn())
1: 		{
0: 			if (leftOperand.getTypeCompiler().comparable(leftTypeId, false,
0: 														   getClassFactory()))
1: 				return this;
1: 
1: 			leftOperand = leftOperand.genSQLJavaSQLTree();
1: 		}
1: 
1: 		TypeId rightTypeId = rightOperand.getTypeId();
1: 
0: 		if (!rightTypeId.systemBuiltIn())
1: 		{
0: 			if (rightOperand.getTypeCompiler().comparable(rightTypeId, false,
0: 															getClassFactory()))
1: 				return this;
1: 
1: 			rightOperand = rightOperand.genSQLJavaSQLTree();
1: 		}
1: 
1: 		return this;
1: 	}
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import java.util.Vector;
0: import java.sql.Types;
0: 
0: /**
0:  * This node is the superclass  for all binary comparison operators, such as =,
0:  * <>, <, etc.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public abstract class BinaryComparisonOperatorNode extends BinaryOperatorNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	// Use between selectivity?
0: 	private boolean forQueryRewrite;
0: 	private boolean betweenSelectivity;
0: 
0: 	/**
0: 	 * Initializer for a BinaryComparisonOperatorNode
0: 	 *
0: 	 * @param leftOperand	The left operand of the comparison
0: 	 * @param rightOperand	The right operand of the comparison
0: 	 * @param operator		The name of the operator
0: 	 * @param methodName	The name of the method to call in the generated
0: 	 *						class
0: 	 */
0: 
0: 	public void init(
0: 				Object	leftOperand,
0: 				Object	rightOperand,
0: 				Object		operator,
0: 				Object		methodName)
0: 	{
0: 		super.init(leftOperand, rightOperand, operator, methodName,
0: 				ClassName.DataValueDescriptor, ClassName.DataValueDescriptor);
0: 	}
0: 
0: 	/**
0: 	 * This node was generated as part of a query rewrite. Bypass the
0: 	 * normal comparability checks.
0: 	 * @param val  true if this was for a query rewrite
0: 	 *
0: 	 * @return Nothing
0: 	 */
0: 	public void setForQueryRewrite(boolean val)
0: 	{
0: 		forQueryRewrite=val;
0: 	}
0: 
0: 	/**
0: 	 * Was this node generated in a query rewrite?
0: 	 *
0: 	 * @return  true if it was generated in a query rewrite.
0: 	 */
0: 	public boolean getForQueryRewrite()
0: 	{
0: 		return forQueryRewrite;
0: 	}
0: 
0: 	/**
0: 	 * Use between selectivity when calculating the selectivity.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void setBetweenSelectivity()
0: 	{
0: 		betweenSelectivity = true;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not to use the between selectivity for this node.
0: 	 *
0: 	 * @return Whether or not to use the between selectivity for this node.
0: 	 */
0: 	boolean getBetweenSelectivity()
0: 	{
0: 		return betweenSelectivity;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Bind this comparison operator.  All that has to be done for binding
0: 	 * a comparison operator is to bind the operands, check the compatibility
0: 	 * of the types, and set the result type to SQLBoolean.
0: 	 *
0: 	 * @param fromList			The query's FROM list
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ValueNode bindExpression(
0: 		FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector)
0: 			throws StandardException
0: 	{
0: 		super.bindExpression(fromList, subqueryList, aggregateVector);
0: 
0: //RESOLVELOCALIZE - convert constants to national constants
0: 		TypeCompiler leftTC = leftOperand.getTypeCompiler();
0: 		TypeCompiler rightTC = rightOperand.getTypeCompiler();
0: 		TypeId leftTypeId = leftOperand.getTypeId();
0: 		TypeId rightTypeId = rightOperand.getTypeId();
0: 
0: 		/*
0: 		 * If we are comparing a non-string with a string type, then we
0: 		 * must prevent the non-string value from being used to probe into
0: 		 * an index on a string column. This is because the string types
0: 		 * are all of low precedence, so the comparison rules of the non-string
0: 		 * value are used, so it may not find values in a string index because
0: 		 * it will be in the wrong order. So, cast the string value to its
0: 		 * own type. This is easier than casting it to the non-string type,
0: 		 * because we would have to figure out the right length to cast it to.
0: 		 */
0: 		if (! leftTypeId.isStringTypeId() && rightTypeId.isStringTypeId())
0: 		{
0: 			DataTypeDescriptor rightTypeServices = rightOperand.getTypeServices();
0: 
0: 			rightOperand =  (ValueNode)
0: 				getNodeFactory().getNode(
0: 					C_NodeTypes.CAST_NODE,
0: 					rightOperand, 
0: 					new DataTypeDescriptor(
0: 							rightTypeId,
0: 							true, 
0: 							rightTypeServices.getMaximumWidth()),
0: 					getContextManager());
0: 			((CastNode) rightOperand).bindCastNodeOnly();
0: 		}
0: 		else if (! rightTypeId.isStringTypeId() && leftTypeId.isStringTypeId())
0: 		{
0: 			DataTypeDescriptor leftTypeServices = leftOperand.getTypeServices();
0: 
0: 			leftOperand =  (ValueNode)
0: 				getNodeFactory().getNode(
0: 					C_NodeTypes.CAST_NODE,
0: 					leftOperand, 
0: 					new DataTypeDescriptor(
0: 							leftTypeId,
0: 							true, 
0: 							leftTypeServices.getMaximumWidth()),
0: 					getContextManager());
0: 			((CastNode) leftOperand).bindCastNodeOnly();
0: 		}
0: 		/* If we are comparing a char with a national char then
0: 		 * we need to generate a cast to the appropriate national
0: 		 * char above the char operand.
0: 		 */
0: 		else if (! leftTypeId.isNationalStringTypeId() &&
0: 			rightTypeId.isNationalStringTypeId())
0: 		{
0: 			leftOperand =  (ValueNode)
0: 				getNodeFactory().getNode(
0: 					C_NodeTypes.CAST_NODE,
0: 					leftOperand, 
0: 					DataTypeDescriptor.getBuiltInDataTypeDescriptor(leftTC.getMatchingNationalCharTypeName(),
0: 										leftTC.getCastToCharWidth(
0: 											leftOperand.getTypeServices())),
0: 					getContextManager());
0: 			((CastNode) leftOperand).bindCastNodeOnly();
0: 		}
0: 		else if (! rightTypeId.isNationalStringTypeId() &&
0: 				leftTypeId.isNationalStringTypeId())
0: 		{
0: 			rightOperand =  (ValueNode)
0: 				getNodeFactory().getNode(
0: 					C_NodeTypes.CAST_NODE,
0: 					rightOperand, 
0: 					DataTypeDescriptor.getBuiltInDataTypeDescriptor(rightTC.getMatchingNationalCharTypeName(), 
0: 										rightTC.getCastToCharWidth(
0: 											rightOperand.getTypeServices())),
0: 					getContextManager());
0: 			((CastNode) rightOperand).bindCastNodeOnly();
0: 		}
0: 
0: 		/* Test type compatability and set type info for this node */
0: 		bindComparisonOperator();
0: 
0: 		return this;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Test the type compatability of the operands and set the type info
0: 	 * for this node.  This method is useful both during binding and
0: 	 * when we generate nodes within the language module outside of the parser.
0: 	 *
0: 	 * @param fromQueryRewrite  If true this call came from a query that was
0: 	 * rewritten by the optimizer.  The normal isComparable check will be 
0: 	 * bypassed to allow > < and the like with longvarchar.  
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void bindComparisonOperator()
0: 			throws StandardException
0: 	{
0: 		TypeId	leftType;
0: 		TypeId	rightType;
0: 		boolean				nullableResult;
0: 
0: 		leftType = leftOperand.getTypeId();
0: 		rightType = rightOperand.getTypeId();
0: 
0: 
0: 		/*
0: 		** Can the types be compared to each other?  If not, throw an
0: 		** exception.
0: 		*/
0: 		boolean forEquals = operator.equals("=") || operator.equals("<>");
0: 
0:         boolean cmp = leftOperand.getTypeCompiler().comparable(rightType,
0:                                                                forEquals,
0:                                                                getClassFactory());
0: 		// Bypass the comparable check if this is a rewrite from the 
0: 		// optimizer.  We will assume Mr. Optimizer knows what he is doing.
0:           if (!cmp && !forQueryRewrite) {
0: 			throw StandardException.newException(SQLState.LANG_NOT_COMPARABLE, 
0: 					leftType.getSQLTypeName(),
0: 					rightType.getSQLTypeName()
0: 				);
0: 		  }
0: 
0: 		
0: 		/*
0: 		** Set the result type of this comparison operator based on the
0: 		** operands.  The result type is always SQLBoolean - the only question
0: 		** is whether it is nullable or not.  If either of the operands is
0: 		** nullable, the result of the comparison must be nullable, too, so
0: 		** we can represent the unknown truth value.
0: 		*/
0: 		nullableResult = leftOperand.getTypeServices().isNullable() ||
0: 							rightOperand.getTypeServices().isNullable();
0: 		setType(new DataTypeDescriptor(TypeId.BOOLEAN_ID, nullableResult));
0: 
0: 
0: 	}
0: 
0: 	/**
0: 	 * Preprocess an expression tree.  We do a number of transformations
0: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
0: 	 * subquery flattening.
0: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
0: 	 *
0: 	 * @param	numTables			Number of tables in the DML Statement
0: 	 * @param	outerFromList		FromList from outer query block
0: 	 * @param	outerSubqueryList	SubqueryList from outer query block
0: 	 * @param	outerPredicateList	PredicateList from outer query block
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode preprocess(int numTables,
0: 								FromList outerFromList,
0: 								SubqueryList outerSubqueryList,
0: 								PredicateList outerPredicateList) 
0: 					throws StandardException
0: 	{
0: 		leftOperand = leftOperand.preprocess(numTables,
0: 											 outerFromList, outerSubqueryList,
0: 											 outerPredicateList);
0: 
0: 		/* This is where we start to consider flattening expression subqueries based
0: 		 * on a uniqueness condition.  If the right child is a SubqueryNode then
0: 		 * it is a potentially flattenable expression subquery.  If we flatten the
0: 		 * subquery then we at least need to change the right operand of this 
0: 		 * comparison.  However, we may want to push the comparison into the subquery
0: 		 * itself and replace this outer comparison with TRUE in the tree.  Thus we
0: 		 * return rightOperand.preprocess() if the rightOperand is a SubqueryNode.
0: 		 * NOTE: SubqueryNode.preprocess() is smart enough to return this node
0: 		 * if it is not flattenable.
0: 		 * NOTE: We only do this if the subquery has not yet been preprocessed.
0: 		 * (A subquery can get preprocessed multiple times if it is a child node
0: 		 * in an expression that gets transformed, like BETWEEN.  The subquery
0: 		 * remembers whether or not it has been preprocessed and simply returns if
0: 		 * it has already been preprocessed.  The return returns the SubqueryNode,
0: 		 * so an invalid tree is returned if we set the parent comparison operator
0: 		 * when the subquery has already been preprocessed.)
0: 		 */
0: 		if ((rightOperand instanceof SubqueryNode) &&
0: 			!((SubqueryNode) rightOperand).getPreprocessed())
0: 		{
0: 			((SubqueryNode) rightOperand).setParentComparisonOperator(this);
0: 			return rightOperand.preprocess(numTables,
0: 										   outerFromList, outerSubqueryList,
0: 										   outerPredicateList);
0: 		}
0: 		else
0: 		{
0: 			rightOperand = rightOperand.preprocess(numTables,
0: 												   outerFromList, outerSubqueryList,
0: 												   outerPredicateList);
0: 			return this;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Eliminate NotNodes in the current query block.  We traverse the tree, 
0: 	 * inverting ANDs and ORs and eliminating NOTs as we go.  We stop at 
0: 	 * ComparisonOperators and boolean expressions.  We invert 
0: 	 * ComparisonOperators and replace boolean expressions with 
0: 	 * boolean expression = false.
0: 	 * NOTE: Since we do not recurse under ComparisonOperators, there
0: 	 * still could be NotNodes left in the tree.
0: 	 *
0: 	 * @param	underNotNode		Whether or not we are under a NotNode.
0: 	 *							
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	ValueNode eliminateNots(boolean underNotNode) 
0: 					throws StandardException
0: 	{
0: 		if (! underNotNode)
0: 		{
0: 			return this;
0: 		}
0: 
0: 		/* Convert the BinaryComparison operator to its negation */
0: 		return getNegation(leftOperand, rightOperand);
0: 	}
0: 
0: 	/**
0: 	 * Negate the comparison.
0: 	 *
0: 	 * @param leftOperand	The left operand of the comparison operator
0: 	 * @param rightOperand	The right operand of the comparison operator
0: 	 *
0: 	 * @return BinaryOperatorNode	The negated expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	BinaryOperatorNode getNegation(ValueNode leftOperand,
0: 										  ValueNode rightOperand)
0: 				throws StandardException
0: 	{
0: 		/* Keep the compiler happy - this method should never be called.
0: 		 * We should always be calling the method in a sub-class.
0: 		 */
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(false,
0: 					"expected to call getNegation() for subclass " +
0: 					getClass().toString());
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Finish putting an expression into conjunctive normal
0: 	 * form.  An expression tree in conjunctive normal form meets
0: 	 * the following criteria:
0: 	 *		o  If the expression tree is not null,
0: 	 *		   the top level will be a chain of AndNodes terminating
0: 	 *		   in a true BooleanConstantNode.
0: 	 *		o  The left child of an AndNode will never be an AndNode.
0: 	 *		o  Any right-linked chain that includes an AndNode will
0: 	 *		   be entirely composed of AndNodes terminated by a true BooleanConstantNode.
0: 	 *		o  The left child of an OrNode will never be an OrNode.
0: 	 *		o  Any right-linked chain that includes an OrNode will
0: 	 *		   be entirely composed of OrNodes terminated by a false BooleanConstantNode.
0: 	 *		o  ValueNodes other than AndNodes and OrNodes are considered
0: 	 *		   leaf nodes for purposes of expression normalization.
0: 	 *		   In other words, we won't do any normalization under
0: 	 *		   those nodes.
0: 	 *
0: 	 * In addition, we track whether or not we are under a top level AndNode.  
0: 	 * SubqueryNodes need to know this for subquery flattening.
0: 	 *
0: 	 * @param	underTopAndNode		Whether or not we are under a top level AndNode.
0: 	 *							
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode changeToCNF(boolean underTopAndNode) 
0: 					throws StandardException
0: 	{
0: 		/* If our right child is a subquery and we are under a top and node
0: 		 * then we want to mark the subquery as under a top and node.
0: 		 * That will allow us to consider flattening it.
0: 		 */
0: 		if (underTopAndNode && (rightOperand instanceof SubqueryNode))
0: 		{
0: 			rightOperand = rightOperand.changeToCNF(underTopAndNode);
0: 		}
0: 
0: 		return this;
0: 	}
0: 	
0: 	/** @see BinaryOperatorNode#genSQLJavaSQLTree */
0: 	public ValueNode genSQLJavaSQLTree() throws StandardException
0: 	{
0: 		TypeId leftTypeId = leftOperand.getTypeId();
0: 
0: 		/* If I have Java types, I need only add java->sql->java if the types
0: 		 * are not comparable 
0: 		 */
0: 		if (!leftTypeId.systemBuiltIn())
0: 		{
0: 			if (leftOperand.getTypeCompiler().comparable(leftTypeId, false,
0: 														   getClassFactory()))
0: 				return this;
0: 
0: 			leftOperand = leftOperand.genSQLJavaSQLTree();
0: 		}
0: 
0: 		TypeId rightTypeId = rightOperand.getTypeId();
0: 
0: 		if (!rightTypeId.systemBuiltIn())
0: 		{
0: 			if (rightOperand.getTypeCompiler().comparable(rightTypeId, false,
0: 															getClassFactory()))
0: 				return this;
0: 
0: 			rightOperand = rightOperand.genSQLJavaSQLTree();
0: 		}
0: 
0: 		return this;
0: 	}
0: }
============================================================================