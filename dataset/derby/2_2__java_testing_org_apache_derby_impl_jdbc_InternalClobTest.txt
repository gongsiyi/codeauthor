1:6b79c2b: /*
1:6b79c2b: 
1:6b79c2b:    Derby - Class org.apache.derby.impl.jdbc.InternalClobTest
1:6b79c2b: 
1:6b79c2b:    Licensed to the Apache Software Foundation (ASF) under one
1:6b79c2b:    or more contributor license agreements.  See the NOTICE file
1:6b79c2b:    distributed with this work for additional information
1:6b79c2b:    regarding copyright ownership.  The ASF licenses this file
1:6b79c2b:    to you under the Apache License, Version 2.0 (the
1:6b79c2b:    "License"); you may not use this file except in compliance
1:6b79c2b:    with the License.  You may obtain a copy of the License at
1:6b79c2b: 
1:6b79c2b:      http://www.apache.org/licenses/LICENSE-2.0
1:6b79c2b: 
1:6b79c2b:    Unless required by applicable law or agreed to in writing,
1:6b79c2b:    software distributed under the License is distributed on an
1:6b79c2b:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:6b79c2b:    KIND, either express or implied.  See the License for the
1:6b79c2b:    specific language governing permissions and limitations
1:6b79c2b:    under the License.
1:6b79c2b: 
1:6b79c2b:  */
1:cb2e1a4: package org.apache.derby.impl.jdbc;
12:cb2e1a4: 
1:1ae02c9: import java.io.BufferedReader;
1:1ae02c9: import java.io.BufferedWriter;
1:cb2e1a4: import java.io.EOFException;
1:1ae02c9: import java.io.IOException;
1:1ae02c9: import java.io.InputStream;
1:1ae02c9: import java.io.Reader;
1:1ae02c9: import java.io.Writer;
1:cb2e1a4: import java.lang.reflect.Constructor;
1:cb2e1a4: import java.lang.reflect.Method;
1:1ae02c9: import java.sql.SQLException;
1:cb2e1a4: import java.util.ArrayList;
1:cb2e1a4: import java.util.List;
1:1ae02c9: import junit.framework.Test;
1:1ae02c9: import junit.framework.TestCase;
1:cb2e1a4: import org.apache.derby.iapi.error.StandardException;
1:cb2e1a4: import org.apache.derby.iapi.types.Resetable;
1:cb2e1a4: import org.apache.derbyTesting.functionTests.util.streams.ByteAlphabet;
1:cb2e1a4: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1:cb2e1a4: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:cb2e1a4: 
1:cb2e1a4: /**
1:cb2e1a4:  * A set of tests for the {@link org.apache.derby.impl.jdbc.InternalClob}
1:cb2e1a4:  * interface.
1:cb2e1a4:  * <p>
1:cb2e1a4:  * The tests are split into two categories; read-only and modifying tests. The
1:cb2e1a4:  * latter should only be run if @{link InternalClob#isWritable} is true.
1:cb2e1a4:  * <p>
1:cb2e1a4:  * <em>Implementation notes</em>: To implement a test by subclassing, a few
1:cb2e1a4:  * things must be done. First of all, many of the tests require that the number
1:cb2e1a4:  * of bytes per character is fixed. The following variables must be initialized
1:cb2e1a4:  * by the subclass:
1:cb2e1a4:  * <ul> <li>initialByteLength : The number of bytes in the Clob.
1:cb2e1a4:  *      <li>initialCharLength : The number of chars in the Clob.
1:cb2e1a4:  *      <li>bytesPerChar : The number of bytes used to represent each char.
1:cb2e1a4:  * </ul>
1:cb2e1a4:  */
1:cb2e1a4: public abstract class InternalClobTest
1:cb2e1a4:     extends BaseJDBCTestCase {
1:cb2e1a4: 
1:cb2e1a4:     /** Buffer used for reading/skipping from streams. */
1:cb2e1a4:     final static int BUFFER_SIZE = 4096;
1:cb2e1a4: 
1:cb2e1a4:     /**
1:cb2e1a4:      * The InternalClob used by the tests, the concrete implementation is
1:cb2e1a4:      * chosen by the subclasses.
1:cb2e1a4:      */
1:cb2e1a4:     protected InternalClob iClob = null;
1:cb2e1a4:     protected long initialByteLength = Long.MIN_VALUE;
1:cb2e1a4:     protected long initialCharLength = Long.MIN_VALUE;
1:cb2e1a4:     protected long bytesPerChar = Long.MIN_VALUE;
1:7672693:     protected long headerLength = Long.MIN_VALUE;
1:cb2e1a4: 
1:cb2e1a4:     InternalClobTest(String name) {
1:cb2e1a4:         super(name);
14:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void tearDown()
1:cb2e1a4:             throws Exception {
1:cb2e1a4:         super.tearDown();
1:cb2e1a4:     }
1:cb2e1a4: 
1:f695643:     protected static Test addModifyingTests(Class<? extends TestCase> theClass)
1:cb2e1a4:             throws Exception {
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite("Modifying InternalClob test suite");
1:cb2e1a4:         Method[] methods = theClass.getMethods();
1:f695643:         List<String> testMethods = new ArrayList<String>();
1:cb2e1a4:         for (int i=0; i < methods.length; i++) {
1:cb2e1a4:             Method m = methods[i];
1:cb2e1a4:             if (m.getReturnType().equals(Void.TYPE) &&
1:cb2e1a4:                 m.getName().startsWith("modTest") &&
1:cb2e1a4:                 m.getParameterTypes().length == 0) {
1:cb2e1a4:                 testMethods.add(m.getName());
1:cb2e1a4:             }
1:cb2e1a4:         }
1:f695643:         Constructor<? extends Test> ctor = theClass.getConstructor(new Class[] {String.class});
1:cb2e1a4:         for (int i=0; i < testMethods.size(); i++) {
1:f695643:             suite.addTest(ctor.newInstance(
1:f695643:                 new Object[] {testMethods.get(i)}));
1:cb2e1a4:         }
1:cb2e1a4:         return suite;
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     /**
1:cb2e1a4:      * This test just ensures the initial variables are set in a sane way.
1:cb2e1a4:      * As can be seen, these tests require the number of bytes per character to
1:cb2e1a4:      * be fixed, thus only certain parts of Unicode can be used with these tests
1:cb2e1a4:      * when using UTF-8 as encoding.
1:cb2e1a4:      */
1:cb2e1a4:     public void testSanity() {
1:7672693:         assertEquals(initialByteLength,
1:7672693:                 initialCharLength * bytesPerChar + headerLength);
1:cb2e1a4:         assertTrue(initialCharLength > 25);
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     /* All the XXXAfterRelease tests just checks that an exception is thrown if
1:cb2e1a4:      * the method is invoked after the Clob has been released. Note that an
1:cb2e1a4:      * UnsupportedOperationException is allowed for read-only Clobs.
1:cb2e1a4:      */
1:cb2e1a4: 
1:cb2e1a4:     public void testGetCharLengthAfterRelease()
10:cb2e1a4:             throws IOException, SQLException {
3:cb2e1a4:         iClob.release();
5:cb2e1a4:         try {
1:cb2e1a4:             iClob.getCharLength();
3:cb2e1a4:             fail("Exception should have been raised, but was not");
3:cb2e1a4:         } catch (IllegalStateException ise) {
3:cb2e1a4:             // This is as expected.
1:cb2e1a4:         }
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testGetRawByteStreamAfterRelease()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         iClob.release();
1:cb2e1a4:         try {
1:cb2e1a4:             iClob.getRawByteStream();
1:cb2e1a4:             fail("Exception should have been raised, but was not");
1:cb2e1a4:         } catch (IllegalStateException ise) {
1:cb2e1a4:             // This is as expected.
1:cb2e1a4:         }
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testGetReaderAfterRelease()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         iClob.release();
1:cb2e1a4:         try {
1:cb2e1a4:             iClob.getReader(1L);
1:cb2e1a4:             fail("Exception should have been raised, but was not");
1:cb2e1a4:         } catch (IllegalStateException ise) {
1:cb2e1a4:             // This is as expected.
1:cb2e1a4:         }
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testReleaseAfterRelase()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         iClob.release();
1:cb2e1a4:         // This one should be a no-op and not fail.
1:cb2e1a4:         iClob.release();
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testGetWriterAfterRelease()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         iClob.release();
1:cb2e1a4:         try {
1:cb2e1a4:             iClob.getWriter(1L);
1:cb2e1a4:             fail("Exception should have been raised, but was not");
1:cb2e1a4:         } catch (IllegalStateException ise) {
1:cb2e1a4:             // This is as expected.
1:cb2e1a4:         } catch (UnsupportedOperationException uoe) {
1:cb2e1a4:             assertFalse("Must support getWriter if the Clob is writable",
1:cb2e1a4:                 iClob.isWritable());
1:cb2e1a4:         }
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testInsertStringAfterRelease()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         iClob.release();
1:cb2e1a4:         try {
1:cb2e1a4:             iClob.insertString("What a nice sunny day :)", 1L);
1:cb2e1a4:             fail("Exception should have been raised, but was not");
1:cb2e1a4:         } catch (IllegalStateException ise) {
1:cb2e1a4:             // This is as expected.
1:cb2e1a4:         } catch (UnsupportedOperationException uoe) {
1:cb2e1a4:             assertFalse("Must support insertString if the Clob is writable",
1:cb2e1a4:                 iClob.isWritable());
1:cb2e1a4:         }
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testTruncateAfterRelease()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         iClob.release();
1:cb2e1a4:         try {
1:cb2e1a4:             iClob.truncate(1L);
1:cb2e1a4:             fail("Exception should have been raised, but was not");
1:cb2e1a4:         } catch (IllegalStateException ise) {
1:cb2e1a4:             // This is as expected.
1:cb2e1a4:         } catch (UnsupportedOperationException uoe) {
1:cb2e1a4:             assertFalse("Must support trucate if the Clob is writable",
1:cb2e1a4:                 iClob.isWritable());
1:cb2e1a4:         }
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     /* End of XXXAfterRelease tests. */
1:cb2e1a4: 
1:cb2e1a4:     public void testGetCharLength()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         assertEquals(this.initialCharLength, iClob.getCharLength());
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testGetReaderAtStartPos()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         Reader reader = iClob.getReader(1L);
1:cb2e1a4:         assertEquals(initialCharLength,
1:cb2e1a4:                      readFromStream(reader, initialCharLength));
1:cb2e1a4:         assertEquals(-1, reader.read());
1:cb2e1a4:         reader.close();
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testGetReaderAtSecondPos()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         Reader reader = iClob.getReader(2L);
1:cb2e1a4:         assertEquals(initialCharLength -1,
1:cb2e1a4:                      readFromStream(reader, initialCharLength -1));
1:cb2e1a4:         assertEquals(-1, reader.read());
1:cb2e1a4:         reader.close();
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testGetReaderAtEndPos()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         Reader reader = iClob.getReader(initialCharLength);
1:cb2e1a4:         assertTrue(reader.read() != -1);
1:cb2e1a4:         assertEquals(-1, reader.read());
1:cb2e1a4:         reader.close();
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void testGetReaderAfterEndPos()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         Reader reader = iClob.getReader(initialCharLength +1);
1:cb2e1a4:         assertEquals(-1, reader.read());
1:cb2e1a4:         reader.close();
1:cb2e1a4:         try {
1:cb2e1a4:             reader = iClob.getReader(initialCharLength +767);
1:cb2e1a4:             fail("Got a reader at a position greater than the Clob");
1:cb2e1a4:         } catch (EOFException eofe) {
1:cb2e1a4:             // As expected
1:cb2e1a4:         }
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     public void modTestInsertString_append_small()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         long cLength = iClob.getCharLength();
1:cb2e1a4:         iClob.insertString("END", cLength +1);
1:cb2e1a4:         assertEquals(cLength + 3, iClob.getCharLength());
1:cb2e1a4:         assertEquals("END", subString(iClob, cLength +1, 3));
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     /**
1:cb2e1a4:      * Replaces a piece of the Clob.
1:cb2e1a4:      */
1:cb2e1a4:     public void modTestInsertString_replace_small()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         String replacement = "MIDDLE";
1:cb2e1a4:         iClob.insertString(replacement, 15L);
1:cb2e1a4:         assertEquals(initialCharLength, iClob.getCharLength());
1:cb2e1a4:         assertEquals(replacement,
1:cb2e1a4:                      this.subString(iClob, 15L, replacement.length()));
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     /**
1:cb2e1a4:      * Replaces the last part of the Clob and then adds a little more, all in
1:cb2e1a4:      * one operation.
1:cb2e1a4:      */
1:cb2e1a4:     public void modTestInsertString_replace_and_append_small()
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         String replacement = "REPLACING_AND_APPENDING!";
1:cb2e1a4:         assertTrue("Length of replacement text must be even",
1:cb2e1a4:             replacement.length() % 2 == 0);
1:cb2e1a4:         int halfLength = replacement.length() / 2;
1:cb2e1a4:         iClob.insertString(replacement,
1:cb2e1a4:             initialCharLength - halfLength +1);
1:cb2e1a4:         assertEquals("Wrong length after replace and append",
1:cb2e1a4:             initialCharLength + halfLength, iClob.getCharLength());
1:cb2e1a4:         assertEquals("Corresponding substring does not match replacement",
1:cb2e1a4:             replacement,
1:cb2e1a4:             this.subString(iClob, initialCharLength - halfLength +1,
1:cb2e1a4:                            replacement.length()));
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     /**
1:cb2e1a4:      * Extracts a substring from the Clob.
1:cb2e1a4:      *
1:cb2e1a4:      * @param clob the clob to extract from
1:cb2e1a4:      * @param pos the starting position in the Clob
1:cb2e1a4:      * @param count the number of characters to extract. Note that the actual
1:cb2e1a4:      *      number of characters extracted might be smaller if there are not
1:cb2e1a4:      *      enough characters in the Clob.
1:cb2e1a4:      * @return A substring up to <code>count</code> characters long.
1:cb2e1a4:      */
1:cb2e1a4:     protected static String subString(InternalClob clob, long pos, int count)
1:cb2e1a4:             throws IOException, SQLException {
1:cb2e1a4:         Reader reader = clob.getReader(pos);
1:cb2e1a4:         char[] sub = new char[count];
1:cb2e1a4:         int offset = 0;
1:cb2e1a4:         while (offset < count) {
1:cb2e1a4:             long read = reader.read(sub, offset, count - offset);
1:cb2e1a4:             if (read == -1) {
1:cb2e1a4:                 break;
1:cb2e1a4:             }
1:cb2e1a4:             offset += read;
1:cb2e1a4:         }
1:cb2e1a4:         return String.copyValueOf(sub);
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     /**
1:cb2e1a4:      * Transfers data from the source to the destination.
1:cb2e1a4:      */
1:cb2e1a4:     public static long transferData(Reader src, Writer dest, long charsToCopy)
1:cb2e1a4:             throws IOException {
1:cb2e1a4:         BufferedReader in = new BufferedReader(src);
1:cb2e1a4:         BufferedWriter out = new BufferedWriter(dest, BUFFER_SIZE);
1:cb2e1a4:         char[] bridge = new char[BUFFER_SIZE];
1:cb2e1a4:         long charsLeft = charsToCopy;
1:cb2e1a4:         int read;
1:cb2e1a4:         while ((read = in.read(bridge, 0, (int)Math.min(charsLeft, BUFFER_SIZE))) > 0) {
1:cb2e1a4:             out.write(bridge, 0, read);
1:cb2e1a4:             charsLeft -= read;
1:cb2e1a4:         }
1:cb2e1a4:         in.close();
1:cb2e1a4:         // Don't close the stream, in case it will be written to again.
1:cb2e1a4:         out.flush();
1:cb2e1a4:         return charsToCopy - charsLeft;
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     /**
1:cb2e1a4:      * Attemps to read the specified number of characters from the stream.
1:cb2e1a4:      */
1:cb2e1a4:     public static final long readFromStream(Reader in, long characterCount)
1:cb2e1a4:             throws IOException {
1:cb2e1a4:         char[] buf = new char[BUFFER_SIZE];
1:cb2e1a4:         long leftToRead = characterCount;
1:cb2e1a4:         while (leftToRead > 0) {
1:cb2e1a4:             long read =
1:cb2e1a4:                 in.read(buf, 0,(int)Math.min(leftToRead, (long)BUFFER_SIZE));
1:cb2e1a4:             if (read == 0) {
1:cb2e1a4:                 break;
1:cb2e1a4:             }
1:cb2e1a4:             leftToRead -= read;
1:cb2e1a4:         }
1:cb2e1a4:         return characterCount - leftToRead;
1:cb2e1a4:     }
1:cb2e1a4: 
1:cb2e1a4:     /**
1:cb2e1a4:      * A fake store stream passed in to StoreStreamClob.
1:cb2e1a4:      * <p>
1:cb2e1a4:      * Note that it is made such that init must be called before using the
1:cb2e1a4:      * stream, or after close, or else a NPE will be thrown.
1:cb2e1a4:      */
1:cb2e1a4:     static class FakeStoreStream
1:cb2e1a4:         extends InputStream
1:cb2e1a4:         implements Resetable {
1:cb2e1a4: 
1:cb2e1a4:         private static final ByteAlphabet ALPHABET =
1:cb2e1a4:             ByteAlphabet.modernLatinLowercase();
1:cb2e1a4:         private LoopingAlphabetStream stream = null;
1:cb2e1a4:         private final long length;
1:cb2e1a4:         private int encodedLengthRemaining = 2;
1:cb2e1a4:         private int eofMarkerRemaining = 3;
1:cb2e1a4: 
1:cb2e1a4:         public FakeStoreStream(long length) {
1:cb2e1a4:             super();
1:cb2e1a4:             this.length = length;
1:cb2e1a4:         }
1:cb2e1a4: 
1:cb2e1a4:         public int read(byte[] b, int off, int len)
1:cb2e1a4:                 throws IOException {
1:cb2e1a4:             int count = 0;
1:cb2e1a4:             while (count < len) {
1:cb2e1a4:                 int ret = read();
1:cb2e1a4:                 if (ret == -1) {
1:cb2e1a4:                     if (count == 0) {
1:cb2e1a4:                         // Inform about EOF.
1:cb2e1a4:                         return -1;
1:cb2e1a4:                     } else {
1:cb2e1a4:                         // Return what we got.
1:cb2e1a4:                         break;
1:cb2e1a4:                     }
1:cb2e1a4:                 }
1:cb2e1a4:                 b[off+count++] = (byte)ret;
1:cb2e1a4:             }
1:cb2e1a4:             return count;
1:cb2e1a4:         }
1:cb2e1a4: 
1:cb2e1a4:         public int read() throws IOException {
1:cb2e1a4:             if (this.encodedLengthRemaining > 0) {
1:cb2e1a4:                 this.encodedLengthRemaining--;
1:cb2e1a4:                 return 0;
1:cb2e1a4:             }
1:cb2e1a4:             int b = this.stream.read();
1:cb2e1a4:             if (b == -1 && this.eofMarkerRemaining > 0) {
1:cb2e1a4:                 if (this.eofMarkerRemaining == 3) {
1:cb2e1a4:                     b = 0xe0;
1:cb2e1a4:                 } else {
1:cb2e1a4:                     b = 0x00;
1:cb2e1a4:                 }
1:cb2e1a4:                 this.eofMarkerRemaining--;
1:cb2e1a4:             }
1:cb2e1a4:             return b;
1:cb2e1a4:         }
1:cb2e1a4: 
1:cb2e1a4:         public void resetStream() throws IOException, StandardException {
1:cb2e1a4:             this.stream = new LoopingAlphabetStream(length, ALPHABET);
1:cb2e1a4:             this.encodedLengthRemaining = 2;
1:cb2e1a4:             this.eofMarkerRemaining = 3;
1:cb2e1a4:         }
1:cb2e1a4: 
1:cb2e1a4:         public void initStream() throws StandardException {
1:cb2e1a4:             this.stream = new LoopingAlphabetStream(length, ALPHABET);
1:cb2e1a4:             this.encodedLengthRemaining = 2;
1:cb2e1a4:             this.eofMarkerRemaining = 3;
1:cb2e1a4:         }
1:cb2e1a4: 
1:cb2e1a4:         public void closeStream() {
1:cb2e1a4:             this.stream = null;
1:cb2e1a4:         }
1:cb2e1a4: 
1:cb2e1a4:     } // End private static class FakeStoreStream
1:cb2e1a4: } // End abstract class InternalClobTest
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedReader;
1: import java.io.BufferedWriter;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.Reader;
1: import java.io.Writer;
1: import java.sql.SQLException;
1: import junit.framework.Test;
1: import junit.framework.TestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite("Modifying InternalClob test suite");
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:7672693
/////////////////////////////////////////////////////////////////////////
1:     protected long headerLength = Long.MIN_VALUE;
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(initialByteLength,
1:                 initialCharLength * bytesPerChar + headerLength);
commit:e8fd686
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:65e0386
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:f695643
/////////////////////////////////////////////////////////////////////////
0: import junit.framework.TestCase;
/////////////////////////////////////////////////////////////////////////
1:     protected static Test addModifyingTests(Class<? extends TestCase> theClass)
1:         List<String> testMethods = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1:         Constructor<? extends Test> ctor = theClass.getConstructor(new Class[] {String.class});
1:             suite.addTest(ctor.newInstance(
1:                 new Object[] {testMethods.get(i)}));
commit:6b79c2b
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.jdbc.InternalClobTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one
1:    or more contributor license agreements.  See the NOTICE file
1:    distributed with this work for additional information
1:    regarding copyright ownership.  The ASF licenses this file
1:    to you under the Apache License, Version 2.0 (the
1:    "License"); you may not use this file except in compliance
1:    with the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing,
1:    software distributed under the License is distributed on an
1:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:    KIND, either express or implied.  See the License for the
1:    specific language governing permissions and limitations
1:    under the License.
1: 
1:  */
commit:cb2e1a4
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derby.impl.jdbc;
1: 
1: import java.io.EOFException;
1: import java.lang.reflect.Constructor;
1: import java.lang.reflect.Method;
0: import java.lang.reflect.Type;
0: import java.sql.Blob;
1: import java.util.ArrayList;
1: import java.util.List;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.types.Resetable;
1: import org.apache.derbyTesting.functionTests.util.streams.ByteAlphabet;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: 
0: import java.io.IOException;
0: import java.io.BufferedReader;
0: import java.io.BufferedWriter;
0: import java.io.InputStream;
0: import java.io.Reader;
0: import java.io.Writer;
1: 
0: import java.sql.SQLException;
1: 
0: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: /**
1:  * A set of tests for the {@link org.apache.derby.impl.jdbc.InternalClob}
1:  * interface.
1:  * <p>
1:  * The tests are split into two categories; read-only and modifying tests. The
1:  * latter should only be run if @{link InternalClob#isWritable} is true.
1:  * <p>
1:  * <em>Implementation notes</em>: To implement a test by subclassing, a few
1:  * things must be done. First of all, many of the tests require that the number
1:  * of bytes per character is fixed. The following variables must be initialized
1:  * by the subclass:
1:  * <ul> <li>initialByteLength : The number of bytes in the Clob.
1:  *      <li>initialCharLength : The number of chars in the Clob.
1:  *      <li>bytesPerChar : The number of bytes used to represent each char.
1:  * </ul>
1:  */
1: public abstract class InternalClobTest
1:     extends BaseJDBCTestCase {
1: 
1:     /** Buffer used for reading/skipping from streams. */
1:     final static int BUFFER_SIZE = 4096;
1: 
1:     /**
1:      * The InternalClob used by the tests, the concrete implementation is
1:      * chosen by the subclasses.
1:      */
1:     protected InternalClob iClob = null;
1:     protected long initialByteLength = Long.MIN_VALUE;
1:     protected long initialCharLength = Long.MIN_VALUE;
1:     protected long bytesPerChar = Long.MIN_VALUE;
1: 
1:     InternalClobTest(String name) {
1:         super(name);
1:     }
1: 
1:     public void tearDown()
1:             throws Exception {
1:         super.tearDown();
1:     }
1: 
0:     protected static Test addModifyingTests(Class theClass)
1:             throws Exception {
0:         TestSuite suite = new TestSuite("Modifying InternalClob test suite");
1:         Method[] methods = theClass.getMethods();
0:         List testMethods = new ArrayList();
1:         for (int i=0; i < methods.length; i++) {
1:             Method m = methods[i];
1:             if (m.getReturnType().equals(Void.TYPE) &&
1:                 m.getName().startsWith("modTest") &&
1:                 m.getParameterTypes().length == 0) {
1:                 testMethods.add(m.getName());
1:             }
1:         }
0:         Constructor ctor = theClass.getConstructor(new Class[] {String.class});
1:         for (int i=0; i < testMethods.size(); i++) {
0:             suite.addTest((Test)ctor.newInstance(
0:                 new Object[] {(String)testMethods.get(i)}));
1:         }
1:         return suite;
1:     }
1: 
1:     /**
1:      * This test just ensures the initial variables are set in a sane way.
1:      * As can be seen, these tests require the number of bytes per character to
1:      * be fixed, thus only certain parts of Unicode can be used with these tests
1:      * when using UTF-8 as encoding.
1:      */
1:     public void testSanity() {
0:         assertEquals(initialByteLength, initialCharLength * bytesPerChar);
1:         assertTrue(initialCharLength > 25);
1:     }
1: 
1:     /* All the XXXAfterRelease tests just checks that an exception is thrown if
1:      * the method is invoked after the Clob has been released. Note that an
1:      * UnsupportedOperationException is allowed for read-only Clobs.
1:      */
1: 
0:     public void testGetByteLengthAfterRelease()
1:             throws IOException, SQLException {
1:         iClob.release();
1:         try {
0:             iClob.getByteLength();
1:             fail("Exception should have been raised, but was not");
1:         } catch (IllegalStateException ise) {
1:             // This is as expected.
1:         }
1:     }
1: 
0:     public void testGetBytePositionAfterRelease()
1:             throws IOException, SQLException {
1:         iClob.release();
1:         try {
0:             iClob.getBytePosition(1L);
1:             fail("Exception should have been raised, but was not");
1:         } catch (IllegalStateException ise) {
1:             // This is as expected.
1:         }
1:     }
1:     public void testGetCharLengthAfterRelease()
1:             throws IOException, SQLException {
1:         iClob.release();
1:         try {
1:             iClob.getCharLength();
1:             fail("Exception should have been raised, but was not");
1:         } catch (IllegalStateException ise) {
1:             // This is as expected.
1:         }
1:     }
1: 
1:     public void testGetRawByteStreamAfterRelease()
1:             throws IOException, SQLException {
1:         iClob.release();
1:         try {
1:             iClob.getRawByteStream();
1:             fail("Exception should have been raised, but was not");
1:         } catch (IllegalStateException ise) {
1:             // This is as expected.
1:         }
1:     }
1: 
1:     public void testGetReaderAfterRelease()
1:             throws IOException, SQLException {
1:         iClob.release();
1:         try {
1:             iClob.getReader(1L);
1:             fail("Exception should have been raised, but was not");
1:         } catch (IllegalStateException ise) {
1:             // This is as expected.
1:         }
1:     }
1: 
1:     public void testReleaseAfterRelase()
1:             throws IOException, SQLException {
1:         iClob.release();
1:         // This one should be a no-op and not fail.
1:         iClob.release();
1:     }
1: 
1:     public void testGetWriterAfterRelease()
1:             throws IOException, SQLException {
1:         iClob.release();
1:         try {
1:             iClob.getWriter(1L);
1:             fail("Exception should have been raised, but was not");
1:         } catch (IllegalStateException ise) {
1:             // This is as expected.
1:         } catch (UnsupportedOperationException uoe) {
1:             assertFalse("Must support getWriter if the Clob is writable",
1:                 iClob.isWritable());
1:         }
1:     }
1: 
1:     public void testInsertStringAfterRelease()
1:             throws IOException, SQLException {
1:         iClob.release();
1:         try {
1:             iClob.insertString("What a nice sunny day :)", 1L);
1:             fail("Exception should have been raised, but was not");
1:         } catch (IllegalStateException ise) {
1:             // This is as expected.
1:         } catch (UnsupportedOperationException uoe) {
1:             assertFalse("Must support insertString if the Clob is writable",
1:                 iClob.isWritable());
1:         }
1:     }
1: 
1:     public void testTruncateAfterRelease()
1:             throws IOException, SQLException {
1:         iClob.release();
1:         try {
1:             iClob.truncate(1L);
1:             fail("Exception should have been raised, but was not");
1:         } catch (IllegalStateException ise) {
1:             // This is as expected.
1:         } catch (UnsupportedOperationException uoe) {
1:             assertFalse("Must support trucate if the Clob is writable",
1:                 iClob.isWritable());
1:         }
1:     }
1: 
1:     /* End of XXXAfterRelease tests. */
1: 
0:     public void testGetByteLength()
1:             throws IOException, SQLException {
0:         assertEquals(this.initialByteLength, iClob.getByteLength());
1:     }
1: 
0:     public void testGetBytePosition_first()
1:             throws IOException, SQLException {
0:         assertEquals(0L, iClob.getBytePosition(1L));
1:     }
1: 
0:     public void testGetBytePosition_second()
1:             throws IOException, SQLException {
0:         assertEquals(bytesPerChar, iClob.getBytePosition(2L));
1:     }
1: 
0:     public void testGetBytePosition_last()
1:             throws IOException, SQLException {
0:         assertEquals(initialByteLength - bytesPerChar,
0:                      iClob.getBytePosition(this.initialCharLength));
1:     }
1: 
0:     public void testGetBytePosition_lastPlussOne()
1:             throws IOException, SQLException {
0:         assertEquals(initialByteLength,
0:                      iClob.getBytePosition(this.initialCharLength +1));
1:     }
1: 
0:     public void testGetBytePosition_lastPlussTwo()
1:             throws IOException, SQLException {
1:         try {
0:             long pos = iClob.getBytePosition(this.initialCharLength +2);
0:             fail("Length +2 should have no valid byte position, got " + pos);
0:         } catch (EOFException ioe) {
0:             // As expected for Derby.
1:         }
1:     }
1: 
0:     public void testGetBytePosition_lastPlussThousand()
1:             throws IOException, SQLException {
1:         try {
0:             long pos = iClob.getBytePosition(this.initialCharLength +1000);
0:             fail("Length +1000 should have no valid byte position, got " + pos);
0:         } catch (EOFException ioe) {
0:             // As expected for Derby.
1:         }
1:     }
1: 
1:     public void testGetCharLength()
1:             throws IOException, SQLException {
1:         assertEquals(this.initialCharLength, iClob.getCharLength());
1:     }
1: 
1:     public void testGetReaderAtStartPos()
1:             throws IOException, SQLException {
1:         Reader reader = iClob.getReader(1L);
1:         assertEquals(initialCharLength,
1:                      readFromStream(reader, initialCharLength));
1:         assertEquals(-1, reader.read());
1:         reader.close();
1:     }
1: 
1:     public void testGetReaderAtSecondPos()
1:             throws IOException, SQLException {
1:         Reader reader = iClob.getReader(2L);
1:         assertEquals(initialCharLength -1,
1:                      readFromStream(reader, initialCharLength -1));
1:         assertEquals(-1, reader.read());
1:         reader.close();
1:     }
1: 
1:     public void testGetReaderAtEndPos()
1:             throws IOException, SQLException {
1:         Reader reader = iClob.getReader(initialCharLength);
1:         assertTrue(reader.read() != -1);
1:         assertEquals(-1, reader.read());
1:         reader.close();
1:     }
1: 
1:     public void testGetReaderAfterEndPos()
1:             throws IOException, SQLException {
1:         Reader reader = iClob.getReader(initialCharLength +1);
1:         assertEquals(-1, reader.read());
1:         reader.close();
1:         try {
1:             reader = iClob.getReader(initialCharLength +767);
1:             fail("Got a reader at a position greater than the Clob");
1:         } catch (EOFException eofe) {
1:             // As expected
1:         }
1:     }
1: 
1:     public void modTestInsertString_append_small()
1:             throws IOException, SQLException {
1:         long cLength = iClob.getCharLength();
1:         iClob.insertString("END", cLength +1);
1:         assertEquals(cLength + 3, iClob.getCharLength());
1:         assertEquals("END", subString(iClob, cLength +1, 3));
1:     }
1: 
1:     /**
1:      * Replaces a piece of the Clob.
1:      */
1:     public void modTestInsertString_replace_small()
1:             throws IOException, SQLException {
1:         String replacement = "MIDDLE";
1:         iClob.insertString(replacement, 15L);
1:         assertEquals(initialCharLength, iClob.getCharLength());
1:         assertEquals(replacement,
1:                      this.subString(iClob, 15L, replacement.length()));
1:     }
1: 
1:     /**
1:      * Replaces the last part of the Clob and then adds a little more, all in
1:      * one operation.
1:      */
1:     public void modTestInsertString_replace_and_append_small()
1:             throws IOException, SQLException {
1:         String replacement = "REPLACING_AND_APPENDING!";
1:         assertTrue("Length of replacement text must be even",
1:             replacement.length() % 2 == 0);
1:         int halfLength = replacement.length() / 2;
1:         iClob.insertString(replacement,
1:             initialCharLength - halfLength +1);
1:         assertEquals("Wrong length after replace and append",
1:             initialCharLength + halfLength, iClob.getCharLength());
1:         assertEquals("Corresponding substring does not match replacement",
1:             replacement,
1:             this.subString(iClob, initialCharLength - halfLength +1,
1:                            replacement.length()));
1:     }
1: 
1:     /**
1:      * Extracts a substring from the Clob.
1:      *
1:      * @param clob the clob to extract from
1:      * @param pos the starting position in the Clob
1:      * @param count the number of characters to extract. Note that the actual
1:      *      number of characters extracted might be smaller if there are not
1:      *      enough characters in the Clob.
1:      * @return A substring up to <code>count</code> characters long.
1:      */
1:     protected static String subString(InternalClob clob, long pos, int count)
1:             throws IOException, SQLException {
1:         Reader reader = clob.getReader(pos);
1:         char[] sub = new char[count];
1:         int offset = 0;
1:         while (offset < count) {
1:             long read = reader.read(sub, offset, count - offset);
1:             if (read == -1) {
1:                 break;
1:             }
1:             offset += read;
1:         }
1:         return String.copyValueOf(sub);
1:     }
1: 
1:     /**
1:      * Transfers data from the source to the destination.
1:      */
1:     public static long transferData(Reader src, Writer dest, long charsToCopy)
1:             throws IOException {
1:         BufferedReader in = new BufferedReader(src);
1:         BufferedWriter out = new BufferedWriter(dest, BUFFER_SIZE);
1:         char[] bridge = new char[BUFFER_SIZE];
1:         long charsLeft = charsToCopy;
1:         int read;
1:         while ((read = in.read(bridge, 0, (int)Math.min(charsLeft, BUFFER_SIZE))) > 0) {
1:             out.write(bridge, 0, read);
1:             charsLeft -= read;
1:         }
1:         in.close();
1:         // Don't close the stream, in case it will be written to again.
1:         out.flush();
1:         return charsToCopy - charsLeft;
1:     }
1: 
1:     /**
1:      * Attemps to read the specified number of characters from the stream.
1:      */
1:     public static final long readFromStream(Reader in, long characterCount)
1:             throws IOException {
1:         char[] buf = new char[BUFFER_SIZE];
1:         long leftToRead = characterCount;
1:         while (leftToRead > 0) {
1:             long read =
1:                 in.read(buf, 0,(int)Math.min(leftToRead, (long)BUFFER_SIZE));
1:             if (read == 0) {
1:                 break;
1:             }
1:             leftToRead -= read;
1:         }
1:         return characterCount - leftToRead;
1:     }
1: 
1:     /**
1:      * A fake store stream passed in to StoreStreamClob.
1:      * <p>
1:      * Note that it is made such that init must be called before using the
1:      * stream, or after close, or else a NPE will be thrown.
1:      */
1:     static class FakeStoreStream
1:         extends InputStream
1:         implements Resetable {
1: 
1:         private static final ByteAlphabet ALPHABET =
1:             ByteAlphabet.modernLatinLowercase();
1:         private LoopingAlphabetStream stream = null;
1:         private final long length;
1:         private int encodedLengthRemaining = 2;
1:         private int eofMarkerRemaining = 3;
1: 
1:         public FakeStoreStream(long length) {
1:             super();
1:             this.length = length;
1:         }
1: 
1:         public int read(byte[] b, int off, int len)
1:                 throws IOException {
1:             int count = 0;
1:             while (count < len) {
1:                 int ret = read();
1:                 if (ret == -1) {
1:                     if (count == 0) {
1:                         // Inform about EOF.
1:                         return -1;
1:                     } else {
1:                         // Return what we got.
1:                         break;
1:                     }
1:                 }
1:                 b[off+count++] = (byte)ret;
1:             }
1:             return count;
1:         }
1: 
1:         public int read() throws IOException {
1:             if (this.encodedLengthRemaining > 0) {
1:                 this.encodedLengthRemaining--;
1:                 return 0;
1:             }
1:             int b = this.stream.read();
1:             if (b == -1 && this.eofMarkerRemaining > 0) {
1:                 if (this.eofMarkerRemaining == 3) {
1:                     b = 0xe0;
1:                 } else {
1:                     b = 0x00;
1:                 }
1:                 this.eofMarkerRemaining--;
1:             }
1:             return b;
1:         }
1: 
1:         public void resetStream() throws IOException, StandardException {
1:             this.stream = new LoopingAlphabetStream(length, ALPHABET);
1:             this.encodedLengthRemaining = 2;
1:             this.eofMarkerRemaining = 3;
1:         }
1: 
1:         public void initStream() throws StandardException {
1:             this.stream = new LoopingAlphabetStream(length, ALPHABET);
1:             this.encodedLengthRemaining = 2;
1:             this.eofMarkerRemaining = 3;
1:         }
1: 
1:         public void closeStream() {
1:             this.stream = null;
1:         }
1: 
1:     } // End private static class FakeStoreStream
1: } // End abstract class InternalClobTest
============================================================================