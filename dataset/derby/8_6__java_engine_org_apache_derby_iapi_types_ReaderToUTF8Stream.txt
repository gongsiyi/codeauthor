1:eac0369: /*
1:345de35: 
1:19f33c6:    Derby - Class org.apache.derby.iapi.types.ReaderToUTF8Stream
1:345de35: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:eac0369: 
1:4dbb0ff:  */
1:eac0369: 
1:19f33c6: package org.apache.derby.iapi.types;
1:eac0369: 
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.IOException;
1:eac0369: import java.io.EOFException;
1:eac0369: import java.io.Reader;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.services.i18n.MessageService;
1:10cc70b: import org.apache.derby.iapi.services.io.DerbyIOException;
1:eac0369: import org.apache.derby.iapi.services.io.LimitReader;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:5b9a6d9: import org.apache.derby.shared.common.reference.MessageId;
1:eac0369: 
1:4dbb0ff: /**
1:51c45b8:  * Converts the characters served by a {@code java.io.Reader} to a stream
1:51c45b8:  * returning the data in the on-disk modified UTF-8 encoded representation used
1:51c45b8:  * by Derby.
1:51c45b8:  * <p>
1:51c45b8:  * Length validation is performed. If required and allowed by the target column
1:51c45b8:  * type, truncation of blanks will also be performed.
1:51c45b8:  */
1:5b9a6d9: //@NotThreadSafe
1:19f33c6: public final class ReaderToUTF8Stream
1:eac0369: 	extends InputStream
1:eac0369: {
1:4dbb0ff:     /**
1:4dbb0ff:      * Application's reader wrapped in a LimitReader.
1:4dbb0ff:      */
1:eac0369: 	private LimitReader reader;
1:242c9bd: 
1:6f4c92a:     /** Constant indicating the first iteration of {@code fillBuffer}. */
1:6f4c92a:     private final static int FIRST_READ = Integer.MIN_VALUE;
1:85de1e4:     /** Buffer space reserved for one 3 byte encoded char and the EOF marker. */
1:85de1e4:     private final static int READ_BUFFER_RESERVATION = 6;
1:51c45b8:     /**
1:5b9a6d9:      * Constant indicating that no mark is set in the stream, or that the read
1:5b9a6d9:      * ahead limit of the mark has been exceeded.
1:51c45b8:      */
1:5b9a6d9:     private final static int MARK_UNSET_OR_EXCEEDED = -1;
1:5b9a6d9:     /**
1:5b9a6d9:      * Buffer to hold the data read from stream and converted to the modified
1:85de1e4:      * UTF-8 format. The initial size is dependent on whether the data value
1:85de1e4:      * length is known (limited upwards to 32 KB), but it may grow if
1:5b9a6d9:      * {@linkplain #mark(int)} is invoked.
1:5b9a6d9:      */
1:85de1e4:     private byte[] buffer;
1:51c45b8: 	private int boff;
1:51c45b8:     private int blen = -1;
1:5b9a6d9:     /** Stream mark, set through {@linkplain #mark(int)}. */
1:5b9a6d9:     private int mark = MARK_UNSET_OR_EXCEEDED;
1:5b9a6d9:     /** Read ahead limit for mark, set through {@linkplain #mark(int)}. */
1:5b9a6d9:     private int readAheadLimit;
1:51c45b8: 	private boolean eof;
1:51c45b8:     /** Tells if the stream content is/was larger than the buffer size. */
1:51c45b8: 	private boolean multipleBuffer;
1:7af6726:     /**
1:6f4c92a:      * The generator for the stream header to use for this stream.
1:7af6726:      * @see #checkSufficientData()
1:7af6726:      */
1:6f4c92a:     private final StreamHeaderGenerator hdrGen;
1:6f4c92a:     /** The length of the header. */
1:6f4c92a:     private int headerLength;
1:6f4c92a: 
1:51c45b8:     /**
1:51c45b8:      * Number of characters to truncate from this stream.
1:51c45b8:      * The SQL standard allows for truncation of trailing spaces for CLOB,
1:51c45b8:      * VARCHAR and CHAR. If zero, no characters are truncated, unless the
1:85de1e4:      * stream length exceeds the maximum length of the column we are inserting
1:51c45b8:      * into.
1:4dbb0ff:      */
1:10cc70b:     private final int charsToTruncate;
1:10cc70b:     private static final char SPACE = ' ';
1:eac0369:     
1:eac0369:     /**
1:51c45b8:      * If positive, length of the expected final value, after truncation if any,
1:51c45b8:      * in characters. If negative, the maximum length allowed in the column we
1:51c45b8:      * are inserting into. A negative value means we are working with a stream
1:51c45b8:      * of unknown length, inserted through one of the JDBC 4.0 "lengthless
1:51c45b8:      * override" methods.
1:51c45b8:      */
1:4dbb0ff:     private final int valueLength; 
1:10cc70b:     /** The type name for the column data is inserted into. */
1:10cc70b:     private final String typeName;
1:6f4c92a:     /** The number of chars encoded. */
1:6f4c92a:     private int charCount;
1:eac0369:     
1:4dbb0ff:     /**
1:10cc70b:      * Create a stream that will truncate trailing blanks if required/allowed.
1:10cc70b:      *
1:10cc70b:      * If the stream must be truncated, the number of blanks to truncate
1:10cc70b:      * is specified to allow the stream to be checked for exact length, as
1:10cc70b:      * required by JDBC 3.0. If the stream is shorter or longer than specified,
1:10cc70b:      * an exception is thrown during read.
1:10cc70b:      *
1:10cc70b:      * @param appReader application reader
1:51c45b8:      * @param valueLength the expected length of the reader in characters
1:51c45b8:      *      (positive), or the inverse (maxColWidth * -1) of the maximum column
1:51c45b8:      *      width if the expected stream length is unknown
1:10cc70b:      * @param numCharsToTruncate the number of trailing blanks to truncate
1:10cc70b:      * @param typeName type name of the column data is inserted into
1:6f4c92a:      * @param headerGenerator the stream header generator
1:4dbb0ff:      */
1:10cc70b:     public ReaderToUTF8Stream(Reader appReader,
1:10cc70b:                               int valueLength,
1:10cc70b:                               int numCharsToTruncate,
1:7af6726:                               String typeName,
1:6f4c92a:                               StreamHeaderGenerator headerGenerator) {
1:10cc70b:         this.reader = new LimitReader(appReader);
1:28030d7:         this.charsToTruncate = numCharsToTruncate;
1:4dbb0ff:         this.valueLength = valueLength;
2:10cc70b:         this.typeName = typeName;
1:6f4c92a:         this.hdrGen = headerGenerator;
1:85de1e4: 
1:85de1e4:         int absValueLength = Math.abs(valueLength);
1:85de1e4:         reader.setLimit(absValueLength);
2:7af6726:         if (SanityManager.DEBUG) {
1:51c45b8:             // Check the type name
1:51c45b8:             // The national types (i.e. NVARCHAR) are not used/supported.
1:51c45b8:             SanityManager.ASSERT(typeName != null && (
1:51c45b8:                     typeName.equals(TypeId.CHAR_NAME) ||
1:51c45b8:                     typeName.equals(TypeId.VARCHAR_NAME) ||
1:51c45b8:                     typeName.equals(TypeId.CLOB_NAME)) ||
1:51c45b8:                     typeName.equals(TypeId.LONGVARCHAR_NAME));
1:51c45b8:         }
1:85de1e4:         // Optimization for small values, where we reduce the memory
1:85de1e4:         // requirement during encoding/insertion.
1:85de1e4:         // Be conservative, assume three bytes per char.
1:85de1e4:         int bz = 32*1024; // 32 KB default
1:85de1e4:         if (absValueLength < bz / 3) {
1:85de1e4:             // Enforce a minimum size of the buffer, otherwise read may loop
1:85de1e4:             // indefinitely (must enter for loop in fillBuffer to detect EOF).
1:85de1e4:             bz = hdrGen.getMaxHeaderLength() +
1:85de1e4:                     Math.max(READ_BUFFER_RESERVATION, absValueLength * 3 +3);
1:85de1e4:         }
1:85de1e4:         buffer = new byte[bz];
1:7af6726:     }
1:10cc70b: 
1:51c45b8:     /**
1:51c45b8:      * Creates a UTF-8 stream for an application reader whose length isn't
1:51c45b8:      * known at insertion time.
1:7af6726:      * <p>
1:51c45b8:      * The application reader is coming in through one of the "lengthless
1:51c45b8:      * overrides" added in JDBC 4.0, for instance
1:53190c0:      * java.sql.PreparedStatement.setCharacterStream(int,Reader).
1:51c45b8:      * A limit is placed on the length of the application reader. If the reader
1:51c45b8:      * exceeds the maximum length, truncation of trailing blanks is attempted.
1:51c45b8:      * If truncation fails, an exception is thrown.
1:10cc70b:      *
1:10cc70b:      * @param appReader application reader
1:10cc70b:      * @param maximumLength maximum allowed length in number of characters for
1:51c45b8:      *      the reader, typically the maximum field size
1:10cc70b:      * @param typeName type name of the column data is inserted into
1:6f4c92a:      * @param headerGenerator the stream header generator
1:51c45b8:      * @throws IllegalArgumentException if maximum length is negative
1:10cc70b:      */
1:10cc70b:     public ReaderToUTF8Stream(Reader appReader,
1:10cc70b:                               int maximumLength,
1:7af6726:                               String typeName,
1:6f4c92a:                               StreamHeaderGenerator headerGenerator) {
1:6f4c92a:         this(appReader, -1 * maximumLength, 0, typeName, headerGenerator);
1:10cc70b:         if (maximumLength < 0) {
1:10cc70b:             throw new IllegalArgumentException("Maximum length for a capped " +
1:10cc70b:                     "stream cannot be negative: " + maximumLength);
1:10cc70b:         }
1:10cc70b:     }
1:eac0369: 
1:10cc70b:     /**
1:51c45b8:      * Reads a byte from the stream.
1:51c45b8:      * <p>
1:51c45b8:      * Characters read from the source stream are converted to the UTF-8 Derby
1:51c45b8:      * specific encoding.
1:51c45b8:      *
1:51c45b8:      * @return The byte read, or {@code -1} if the end-of-stream is reached.
1:51c45b8:      * @throws EOFException if the end-of-stream has already been reached or
1:51c45b8:      *      the stream has been closed
1:51c45b8:      * @throws IOException if reading from the source stream fails
1:bb1be44:      * @see java.io.InputStream#read()
2:eac0369:      */
1:eac0369: 	public int read() throws IOException {
1:eac0369: 
1:bb1be44:         // when stream has been read and eof reached, stream is closed
1:bb1be44:         // and buffer is set to null ( see close() method)
1:bb1be44:         // since stream cannot be re-used, check if stream is closed and 
1:bb1be44:         // if so throw an EOFException
1:bb1be44:         if ( buffer == null)
1:bb1be44:             throw new EOFException(MessageService.getTextMessage(SQLState.STREAM_EOF));
1:eac0369: 
1:eac0369:         
1:eac0369: 		// first read
1:eac0369: 		if (blen < 0)
1:6f4c92a:             fillBuffer(FIRST_READ);
1:eac0369: 
1:eac0369: 		while (boff == blen)
1:eac0369: 		{
1:eac0369: 			// reached end of buffer, read more?
1:eac0369: 			if (eof)
1:eac0369:             {
1:bb1be44:                // we have reached the end of this stream
1:bb1be44:                // cleanup here and return -1 indicating 
1:bb1be44:                // eof of stream
1:bb1be44:                close();
1:eac0369:                return -1;
1:10cc70b:             }
1:eac0369:                 
1:eac0369: 
1:eac0369: 			fillBuffer(0);
1:10cc70b: 		}
1:eac0369: 
1:eac0369: 		return buffer[boff++] & 0xff;
1:eac0369: 
1:242c9bd: 	}
1:eac0369: 
1:eac0369:     /**
1:51c45b8:      * Reads up to {@code len} bytes from the stream.
1:51c45b8:      * <p>
1:51c45b8:      * Characters read from the source stream are converted to the UTF-8 Derby
1:51c45b8:      * specific encoding.
1:51c45b8:      *
1:51c45b8:      * @return The number of bytes read, or {@code -1} if the end-of-stream is
1:51c45b8:      *      reached.
1:51c45b8:      * @throws EOFException if the end-of-stream has already been reached or
1:51c45b8:      *      the stream has been closed
1:51c45b8:      * @throws IOException if reading from the source stream fails
1:51c45b8:      * @see java.io.InputStream#read(byte[],int,int)
1:51c45b8:      */
1:eac0369: 	public int read(byte b[], int off, int len) throws IOException {
1:eac0369:         
1:bb1be44:         // when stream has been read and eof reached, stream is closed
1:bb1be44:         // and buffer is set to null ( see close() method)
1:bb1be44:         // since stream cannot be re-used, check if stream is closed and 
1:bb1be44:         // if so throw an EOFException
1:bb1be44:         if ( buffer == null )
1:bb1be44:             throw new EOFException(MessageService.getTextMessage
1:bb1be44:                     (SQLState.STREAM_EOF));
1:eac0369: 
1:eac0369:         // first read
1:eac0369: 		if (blen < 0)
1:6f4c92a:             fillBuffer(FIRST_READ);
1:eac0369: 
1:eac0369: 		int readCount = 0;
1:eac0369: 
1:eac0369: 		while (len > 0)
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			int copyBytes = blen - boff;
1:eac0369: 
1:eac0369: 			// buffer empty?
1:eac0369: 			if (copyBytes == 0)
1:eac0369: 			{
1:eac0369: 				if (eof)
1:eac0369: 				{
1:bb1be44:                     if (readCount > 0)
1:eac0369:                     {
1:bb1be44:                         return readCount;
1:242c9bd:                     }
1:eac0369:                     else
1:eac0369:                     {
1:bb1be44:                         // we have reached the eof, so close the stream
1:bb1be44:                         close();
1:bb1be44:                         return -1;  
7:eac0369:                     }
1:eac0369:                     
1:eac0369: 				}
1:eac0369: 				fillBuffer(0);
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (len < copyBytes)
1:eac0369: 				copyBytes = len;
1:eac0369: 
1:eac0369: 			System.arraycopy(buffer, boff, b, off, copyBytes);
1:eac0369: 			boff += copyBytes;
1:eac0369: 			len -= copyBytes;
1:eac0369: 			readCount += copyBytes;
1:28030d7:             off += copyBytes;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 		return readCount;
1:eac0369: 	}
1:eac0369: 
1:51c45b8:     /**
1:51c45b8:      * Fills the internal buffer with data read from the source stream.
1:51c45b8:      * <p>
1:51c45b8:      * The characters read from the source are converted to the modified UTF-8
1:51c45b8:      * encoding, used as the on-disk format by Derby.
1:51c45b8:      *
1:51c45b8:      * @param startingOffset offset at which to start filling the buffer, used
1:51c45b8:      *      to avoid overwriting the stream header data on the first iteration
1:51c45b8:      * @throws DerbyIOException if the source stream has an invalid length
1:51c45b8:      *      (different than specified), or if truncation of blanks fails
1:51c45b8:      * @throws IOException if reading from the source stream fails
1:51c45b8:      */
1:eac0369: 	private void fillBuffer(int startingOffset) throws IOException
1:eac0369: 	{
1:6f4c92a:         if (startingOffset == FIRST_READ) {
1:6f4c92a:             // Generate the header. Provide the char length only if the header
1:6f4c92a:             // encodes a char count and we actually know the char count.
1:6f4c92a:             if (hdrGen.expectsCharCount() && valueLength >= 0) {
1:6f4c92a:                 headerLength = hdrGen.generateInto(buffer, 0, valueLength);
1:6f4c92a:             } else {
1:6f4c92a:                 headerLength = hdrGen.generateInto(buffer, 0, -1);
1:6f4c92a:             }
1:6f4c92a:             // Make startingOffset point at the first byte after the header.
1:6f4c92a:             startingOffset = headerLength;
1:6f4c92a:         }
1:5b9a6d9: 		int off = startingOffset;
1:5b9a6d9:         // In the case of a mark, the offset may be adjusted.
1:5b9a6d9:         // Do not change boff in the encoding loop. Before the encoding loop
1:5b9a6d9:         // starts, it shall point at the next byte the stream will deliver on
1:5b9a6d9:         // the next iteration of read or skip.
1:5b9a6d9:         boff = 0;
1:eac0369: 
1:eac0369: 		if (off == 0)
1:eac0369: 			multipleBuffer = true;
1:eac0369: 
1:5b9a6d9:         // If we have a mark set, see if we have to expand the buffer, or if we
1:5b9a6d9:         // are going to read past the read ahead limit and can invalidate the
1:5b9a6d9:         // mark and discard the data currently in the buffer.
1:5b9a6d9:         if (mark >= 0) {
1:5b9a6d9:             // Add 6 bytes reserved for one 3 byte character encoding and the
1:5b9a6d9:             // 3 byte Derby EOF marker (see encoding loop further down).
1:85de1e4:             int spaceRequired = readAheadLimit + READ_BUFFER_RESERVATION;
1:5b9a6d9:             if (mark + spaceRequired > buffer.length) {
1:5b9a6d9:                 if (blen != -1) {
1:5b9a6d9:                     // Calculate the new offset, as we may have to shift bytes
1:5b9a6d9:                     // we have already delivered to the left.
1:5b9a6d9:                     boff = off = blen - mark;
1:5b9a6d9:                 }
1:5b9a6d9:                 byte[] oldBuf = buffer;
1:5b9a6d9:                 if (spaceRequired > buffer.length) {
1:5b9a6d9:                     // We have to allocate a bigger buffer to save the bytes.
1:5b9a6d9:                     buffer = new byte[spaceRequired];
1:5b9a6d9:                 }
1:5b9a6d9:                 System.arraycopy(oldBuf, mark, buffer, 0, off);
1:5b9a6d9:                 mark = 0;
1:5b9a6d9:             } else if (blen != -1) {
1:5b9a6d9:                 // Invalidate the mark.
1:5b9a6d9:                 mark = MARK_UNSET_OR_EXCEEDED;
1:5b9a6d9:             }
1:5b9a6d9:         }
1:5b9a6d9: 
1:eac0369: 		// 6! need to leave room for a three byte UTF8 encoding
1:eac0369: 		// and 3 bytes for our special end of file marker.
1:85de1e4:         for (; off <= buffer.length - READ_BUFFER_RESERVATION; )
1:eac0369: 		{
1:eac0369: 			int c = reader.read();
1:eac0369: 			if (c < 0) {
1:eac0369: 				eof = true;
1:eac0369: 				break;
1:eac0369: 			}
1:6f4c92a:             charCount++; // Increment the character count.
1:eac0369: 
1:eac0369: 			if ((c >= 0x0001) && (c <= 0x007F))
1:eac0369:             {
1:eac0369: 				buffer[off++] = (byte) c;
1:eac0369: 			}
1:eac0369:             else if (c > 0x07FF)
1:eac0369:             {
1:eac0369: 				buffer[off++] = (byte) (0xE0 | ((c >> 12) & 0x0F));
1:eac0369: 				buffer[off++] = (byte) (0x80 | ((c >>  6) & 0x3F));
1:eac0369: 				buffer[off++] = (byte) (0x80 | ((c >>  0) & 0x3F));
1:eac0369: 			}
1:eac0369:             else
1:eac0369:             {
1:eac0369: 				buffer[off++] = (byte) (0xC0 | ((c >>  6) & 0x1F));
1:eac0369: 				buffer[off++] = (byte) (0x80 | ((c >>  0) & 0x3F));
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		blen = off;
1:eac0369: 		if (eof)
1:eac0369: 			checkSufficientData();
1:eac0369: 	}
1:eac0369: 
1:10cc70b:     /**
1:10cc70b:      * Validate the length of the stream, take corrective action if allowed.
1:10cc70b:      *
1:10cc70b:      * JDBC 3.0 (from tutorial book) requires that an input stream has the
1:10cc70b:      * correct number of bytes in the stream.
1:10cc70b:      * If the stream is too long, trailing blank truncation is attempted if
1:10cc70b:      * allowed. If truncation fails, or is disallowed, an exception is thrown.
2:10cc70b:      *
1:10cc70b:      * @throws IOException if an errors occurs in the application stream
1:10cc70b:      * @throws DerbyIOException if Derby finds a problem with the stream;
1:10cc70b:      *      stream is too long and cannot be truncated, or the stream length
1:10cc70b:      *      does not match the specified length
1:10cc70b:      */
1:eac0369: 	private void checkSufficientData() throws IOException
1:eac0369: 	{
1:28030d7: 		// now that we finished reading from the stream; the amount
1:28030d7:         // of data that we can insert,start check for trailing spaces
1:28030d7:         if (charsToTruncate > 0)
1:eac0369:         {
1:28030d7:             reader.setLimit(charsToTruncate);
1:10cc70b:             truncate();
1:eac0369:         }
1:eac0369:         
1:10cc70b:         // A length less stream that is capped, will return 0 even if there
1:10cc70b:         // are more bytes in the application stream.
1:eac0369:         int remainingBytes = reader.clearLimit();
1:10cc70b:         if (remainingBytes > 0 && valueLength > 0) {
1:10cc70b:             // If we had a specified length, throw exception.
1:10cc70b:             throw new DerbyIOException(
1:10cc70b:                     MessageService.getTextMessage(
1:10cc70b:                         SQLState.SET_STREAM_INEXACT_LENGTH_DATA),
1:10cc70b:                     SQLState.SET_STREAM_INEXACT_LENGTH_DATA);
1:10cc70b:         }
1:eac0369: 
1:eac0369: 		// if we had a limit try reading one more character.
1:10cc70b: 		// JDBC 3.0 states the stream must have the correct number of
1:28030d7:         // characters in it.
1:10cc70b:         if (remainingBytes == 0 && reader.read() >= 0) {
1:10cc70b:             if (valueLength > -1) {
1:10cc70b:                 throw new DerbyIOException(
1:10cc70b:                         MessageService.getTextMessage(
1:10cc70b:                             SQLState.SET_STREAM_INEXACT_LENGTH_DATA),
1:10cc70b:                         SQLState.SET_STREAM_INEXACT_LENGTH_DATA);
1:10cc70b:             } else {
1:10cc70b:                 // Stream was capped (length less) and too long.
1:10cc70b:                 // Try to truncate if allowed, or else throw exception.
1:10cc70b:                 if (canTruncate()) {
1:10cc70b:                     truncate();
1:10cc70b:                 } else {
1:10cc70b:                     throw new DerbyIOException(
1:10cc70b:                             MessageService.getTextMessage(
1:51c45b8:                                 SQLState.LANG_STRING_TRUNCATION,
1:51c45b8:                                 typeName,
1:51c45b8:                                 "<stream-value>", // Don't show the whole value.
1:51c45b8:                                 String.valueOf(Math.abs(valueLength))),
1:10cc70b:                             SQLState.LANG_STRING_TRUNCATION);
1:10cc70b:                 }
1:10cc70b:             }
1:eac0369:         }
1:eac0369: 
1:7af6726:         // can put the correct length into the stream.
1:7af6726:         if (!multipleBuffer) {
1:6f4c92a:             int newValueLen = -1;
1:6f4c92a:             if (hdrGen.expectsCharCount()) {
1:6f4c92a:                 if (SanityManager.DEBUG && charCount == 0) {
1:6f4c92a:                     SanityManager.ASSERT(eof);
1:7af6726:                 }
1:6f4c92a:                 newValueLen = charCount;
1:7af6726:             } else {
1:6f4c92a:                 // Store the byte length of the user data (exclude the header).
1:6f4c92a:                 newValueLen = blen - headerLength;
1:7af6726:             }
1:6f4c92a:             int newHeaderLength = hdrGen.generateInto(buffer, 0, newValueLen);
1:6f4c92a:             // Check that we didn't overwrite any of the user data.
1:6f4c92a:             if (newHeaderLength != headerLength) {
1:6f4c92a:                 throw new IOException("Data corruption detected; user data " +
1:6f4c92a:                         "overwritten by header bytes");
1:7af6726:             }
1:6f4c92a:             // Write the end-of-stream marker (if required).
1:6f4c92a:             blen += hdrGen.writeEOF(buffer, blen, newValueLen);
1:6f4c92a:         } else {
1:6f4c92a:             // Write the end-of-stream marker (if required).
1:6f4c92a:             blen += hdrGen.writeEOF(buffer, blen, Math.max(valueLength, -1));
1:7af6726:         }
1:7af6726:     }
1:eac0369: 
1:eac0369:     /**
1:10cc70b:      * Determine if trailing blank truncation is allowed.
1:10cc70b:      */
1:10cc70b:     private boolean canTruncate() {
1:10cc70b:         // Only a few types can be truncated, default is to not allow.
1:10cc70b:         if (typeName.equals(TypeId.CLOB_NAME)) {
1:10cc70b:             return true;
1:10cc70b:         } else if (typeName.equals(TypeId.VARCHAR_NAME)) {
1:10cc70b:             return true;
1:51c45b8:         } else if (typeName.equals(TypeId.CHAR_NAME)) {
1:51c45b8:             return true;
1:10cc70b:         }
1:10cc70b:         return false;
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     /**
1:10cc70b:      * Attempt to truncate the stream by removing trailing blanks.
1:10cc70b:      */
1:10cc70b:     private void truncate()
1:10cc70b:             throws IOException {
1:10cc70b:         int c = 0;
1:10cc70b:         for (;;) {
1:10cc70b:             c = reader.read();
1:10cc70b: 
1:10cc70b:             if (c < 0) {
1:10cc70b:                 break;
1:10cc70b:             } else if (c != SPACE) {
1:10cc70b:                 throw new DerbyIOException(
1:10cc70b:                     MessageService.getTextMessage(
1:10cc70b:                         SQLState.LANG_STRING_TRUNCATION,
1:10cc70b:                         typeName, 
1:51c45b8:                         "<stream-value>", // Don't show the whole value.
1:51c45b8:                         String.valueOf(Math.abs(valueLength))),
1:10cc70b:                     SQLState.LANG_STRING_TRUNCATION);
1:10cc70b:             }
1:10cc70b:         }
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     /**
1:bb1be44:      * return resources 
1:eac0369:      */
1:51c45b8:     public void close() {
1:bb1be44:         // since stream has been read and eof reached, return buffer back to 
1:bb1be44:         // the vm.
1:bb1be44:         // Instead of using another variable to indicate stream is closed
1:bb1be44:         // a check on (buffer==null) is used instead. 
1:eac0369:         buffer = null;
1:eac0369: 	}
1:eac0369: 
1:bb1be44:     /**
1:a4e8535:      * Return an optimized version of bytes available to read from 
1:51c45b8:      * the stream.
1:51c45b8:      * <p>
1:51c45b8:      * Note, it is not exactly per {@code java.io.InputStream#available()}.
1:eac0369:      */
1:a4e8535:     public final int available()
1:eac0369:     {
1:a4e8535:        int remainingBytes = reader.getLimit();
1:a4e8535:        // this object buffers BUFSIZE bytes that can be read 
1:a4e8535:        // and when that is finished it reads the next available bytes
1:a4e8535:        // from the reader object 
1:a4e8535:        // reader.getLimit() returns the remaining bytes available
1:a4e8535:        // on this stream
1:5b9a6d9:        return (buffer.length > remainingBytes ? remainingBytes : buffer.length);
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Marks the current position in the stream.
1:5b9a6d9:      * <p>
1:5b9a6d9:      * Note that this stream is not marked at position zero by default (i.e.
1:5b9a6d9:      * in the constructor).
1:5b9a6d9:      *
1:5b9a6d9:      * @param readAheadLimit the maximum limit of bytes that can be read before
1:5b9a6d9:      *      the mark position becomes invalid
1:5b9a6d9:      */
1:5b9a6d9:     public void mark(int readAheadLimit) {
1:5b9a6d9:         if (readAheadLimit > 0) {
1:5b9a6d9:             this.readAheadLimit = readAheadLimit;
1:5b9a6d9:             mark = boff;
1:5b9a6d9:         } else {
1:5b9a6d9:             this.readAheadLimit = mark = MARK_UNSET_OR_EXCEEDED;
1:5b9a6d9:         }
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Repositions this stream to the position at the time the mark method was
1:5b9a6d9:      * last called on this input stream.
1:5b9a6d9:      *
1:5b9a6d9:      * @throws EOFException if the stream has been closed
1:5b9a6d9:      * @throws IOException if no mark has been set, or the read ahead limit of
1:5b9a6d9:      *      the mark has been exceeded
1:5b9a6d9:      */
1:5b9a6d9:     public void reset()
1:5b9a6d9:             throws IOException {
1:85de1e4:         // Throw exception if the stream has been closed implicitly or
1:5b9a6d9:         // explicitly.
1:5b9a6d9:         if (buffer == null) {
1:5b9a6d9:             throw new EOFException(MessageService.getTextMessage
1:5b9a6d9:                     (SQLState.STREAM_EOF));
1:5b9a6d9:         }
1:5b9a6d9:         // Throw exception if the mark hasn't been set, or if we had to refill
1:5b9a6d9:         // the internal buffer after we had read past the read ahead limit.
1:5b9a6d9:         if (mark == MARK_UNSET_OR_EXCEEDED) {
1:5b9a6d9:             throw new IOException(MessageService.getTextMessage(
1:5b9a6d9:                     MessageId.STREAM_MARK_UNSET_OR_EXCEEDED));
1:5b9a6d9:         }
1:5b9a6d9:         // Reset successful, adjust state.
1:5b9a6d9:         boff = mark;
1:5b9a6d9:         readAheadLimit = mark = MARK_UNSET_OR_EXCEEDED;
1:5b9a6d9:     }
1:5b9a6d9: 
1:5b9a6d9:     /**
1:5b9a6d9:      * Tests if this stream supports mark/reset.
1:5b9a6d9:      * <p>
1:5b9a6d9:      * The {@code markSupported} method of {@code ByteArrayInputStream} always
1:5b9a6d9:      * returns {@code true}.
1:5b9a6d9:      *
1:5b9a6d9:      * @return {@code true}, mark/reset is always supported.
1:5b9a6d9:      */
1:5b9a6d9:     public boolean markSupported() {
1:5b9a6d9:         return true;
1:7af6726:     }
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:9495437
/////////////////////////////////////////////////////////////////////////
commit:92268ac
/////////////////////////////////////////////////////////////////////////
0:                     typeName.equals(TypeId.PASSWORD_NAME) ||
commit:53190c0
/////////////////////////////////////////////////////////////////////////
1:      * java.sql.PreparedStatement.setCharacterStream(int,Reader).
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:85de1e4
/////////////////////////////////////////////////////////////////////////
1:     /** Buffer space reserved for one 3 byte encoded char and the EOF marker. */
1:     private final static int READ_BUFFER_RESERVATION = 6;
/////////////////////////////////////////////////////////////////////////
1:      * UTF-8 format. The initial size is dependent on whether the data value
1:      * length is known (limited upwards to 32 KB), but it may grow if
1:     private byte[] buffer;
/////////////////////////////////////////////////////////////////////////
1:      * stream length exceeds the maximum length of the column we are inserting
/////////////////////////////////////////////////////////////////////////
1: 
1:         int absValueLength = Math.abs(valueLength);
1:         reader.setLimit(absValueLength);
/////////////////////////////////////////////////////////////////////////
1:         // Optimization for small values, where we reduce the memory
1:         // requirement during encoding/insertion.
1:         // Be conservative, assume three bytes per char.
1:         int bz = 32*1024; // 32 KB default
1:         if (absValueLength < bz / 3) {
1:             // Enforce a minimum size of the buffer, otherwise read may loop
1:             // indefinitely (must enter for loop in fillBuffer to detect EOF).
1:             bz = hdrGen.getMaxHeaderLength() +
1:                     Math.max(READ_BUFFER_RESERVATION, absValueLength * 3 +3);
1:         }
1:         buffer = new byte[bz];
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             int spaceRequired = readAheadLimit + READ_BUFFER_RESERVATION;
/////////////////////////////////////////////////////////////////////////
1:         for (; off <= buffer.length - READ_BUFFER_RESERVATION; )
/////////////////////////////////////////////////////////////////////////
1:         // Throw exception if the stream has been closed implicitly or
commit:5b9a6d9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.MessageId;
/////////////////////////////////////////////////////////////////////////
1: //@NotThreadSafe
/////////////////////////////////////////////////////////////////////////
1:      * Constant indicating that no mark is set in the stream, or that the read
1:      * ahead limit of the mark has been exceeded.
1:     private final static int MARK_UNSET_OR_EXCEEDED = -1;
1:     /**
1:      * Buffer to hold the data read from stream and converted to the modified
0:      * UTF-8 format. The initial size is 32 KB, but it may grow if the
1:      * {@linkplain #mark(int)} is invoked.
1:      */
0:     private byte[] buffer = new byte[32*1024];
1:     /** Stream mark, set through {@linkplain #mark(int)}. */
1:     private int mark = MARK_UNSET_OR_EXCEEDED;
1:     /** Read ahead limit for mark, set through {@linkplain #mark(int)}. */
1:     private int readAheadLimit;
/////////////////////////////////////////////////////////////////////////
1: 		int off = startingOffset;
1:         // In the case of a mark, the offset may be adjusted.
1:         // Do not change boff in the encoding loop. Before the encoding loop
1:         // starts, it shall point at the next byte the stream will deliver on
1:         // the next iteration of read or skip.
1:         boff = 0;
1:         // If we have a mark set, see if we have to expand the buffer, or if we
1:         // are going to read past the read ahead limit and can invalidate the
1:         // mark and discard the data currently in the buffer.
1:         if (mark >= 0) {
1:             // Add 6 bytes reserved for one 3 byte character encoding and the
1:             // 3 byte Derby EOF marker (see encoding loop further down).
0:             int spaceRequired = readAheadLimit + 6;
1:             if (mark + spaceRequired > buffer.length) {
1:                 if (blen != -1) {
1:                     // Calculate the new offset, as we may have to shift bytes
1:                     // we have already delivered to the left.
1:                     boff = off = blen - mark;
1:                 }
1:                 byte[] oldBuf = buffer;
1:                 if (spaceRequired > buffer.length) {
1:                     // We have to allocate a bigger buffer to save the bytes.
1:                     buffer = new byte[spaceRequired];
1:                 }
1:                 System.arraycopy(oldBuf, mark, buffer, 0, off);
1:                 mark = 0;
1:             } else if (blen != -1) {
1:                 // Invalidate the mark.
1:                 mark = MARK_UNSET_OR_EXCEEDED;
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:        return (buffer.length > remainingBytes ? remainingBytes : buffer.length);
1:     }
1: 
1:     /**
1:      * Marks the current position in the stream.
1:      * <p>
1:      * Note that this stream is not marked at position zero by default (i.e.
1:      * in the constructor).
1:      *
1:      * @param readAheadLimit the maximum limit of bytes that can be read before
1:      *      the mark position becomes invalid
1:      */
1:     public void mark(int readAheadLimit) {
1:         if (readAheadLimit > 0) {
1:             this.readAheadLimit = readAheadLimit;
1:             mark = boff;
1:         } else {
1:             this.readAheadLimit = mark = MARK_UNSET_OR_EXCEEDED;
1:         }
1:     }
1: 
1:     /**
1:      * Repositions this stream to the position at the time the mark method was
1:      * last called on this input stream.
1:      *
1:      * @throws EOFException if the stream has been closed
1:      * @throws IOException if no mark has been set, or the read ahead limit of
1:      *      the mark has been exceeded
1:      */
1:     public void reset()
1:             throws IOException {
0:         // Throw execption if the stream has been closed implicitly or
1:         // explicitly.
1:         if (buffer == null) {
1:             throw new EOFException(MessageService.getTextMessage
1:                     (SQLState.STREAM_EOF));
1:         }
1:         // Throw exception if the mark hasn't been set, or if we had to refill
1:         // the internal buffer after we had read past the read ahead limit.
1:         if (mark == MARK_UNSET_OR_EXCEEDED) {
1:             throw new IOException(MessageService.getTextMessage(
1:                     MessageId.STREAM_MARK_UNSET_OR_EXCEEDED));
1:         }
1:         // Reset successful, adjust state.
1:         boff = mark;
1:         readAheadLimit = mark = MARK_UNSET_OR_EXCEEDED;
1:     }
1: 
1:     /**
1:      * Tests if this stream supports mark/reset.
1:      * <p>
1:      * The {@code markSupported} method of {@code ByteArrayInputStream} always
1:      * returns {@code true}.
1:      *
1:      * @return {@code true}, mark/reset is always supported.
1:      */
1:     public boolean markSupported() {
1:         return true;
commit:6f4c92a
/////////////////////////////////////////////////////////////////////////
1:     /** Constant indicating the first iteration of {@code fillBuffer}. */
1:     private final static int FIRST_READ = Integer.MIN_VALUE;
/////////////////////////////////////////////////////////////////////////
1:      * The generator for the stream header to use for this stream.
1:     private final StreamHeaderGenerator hdrGen;
1:     /** The length of the header. */
1:     private int headerLength;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /** The number of chars encoded. */
1:     private int charCount;
/////////////////////////////////////////////////////////////////////////
1:      * @param headerGenerator the stream header generator
1:                               StreamHeaderGenerator headerGenerator) {
1:         this.hdrGen = headerGenerator;
/////////////////////////////////////////////////////////////////////////
1:      * @param headerGenerator the stream header generator
1:                               StreamHeaderGenerator headerGenerator) {
1:         this(appReader, -1 * maximumLength, 0, typeName, headerGenerator);
/////////////////////////////////////////////////////////////////////////
1:             fillBuffer(FIRST_READ);
/////////////////////////////////////////////////////////////////////////
1:             fillBuffer(FIRST_READ);
/////////////////////////////////////////////////////////////////////////
1:         if (startingOffset == FIRST_READ) {
1:             // Generate the header. Provide the char length only if the header
1:             // encodes a char count and we actually know the char count.
1:             if (hdrGen.expectsCharCount() && valueLength >= 0) {
1:                 headerLength = hdrGen.generateInto(buffer, 0, valueLength);
1:             } else {
1:                 headerLength = hdrGen.generateInto(buffer, 0, -1);
1:             }
1:             // Make startingOffset point at the first byte after the header.
1:             startingOffset = headerLength;
1:         }
/////////////////////////////////////////////////////////////////////////
1:             charCount++; // Increment the character count.
/////////////////////////////////////////////////////////////////////////
1:             int newValueLen = -1;
1:             if (hdrGen.expectsCharCount()) {
1:                 if (SanityManager.DEBUG && charCount == 0) {
1:                     SanityManager.ASSERT(eof);
1:                 newValueLen = charCount;
1:                 // Store the byte length of the user data (exclude the header).
1:                 newValueLen = blen - headerLength;
1:             int newHeaderLength = hdrGen.generateInto(buffer, 0, newValueLen);
1:             // Check that we didn't overwrite any of the user data.
1:             if (newHeaderLength != headerLength) {
1:                 throw new IOException("Data corruption detected; user data " +
1:                         "overwritten by header bytes");
1:             // Write the end-of-stream marker (if required).
1:             blen += hdrGen.writeEOF(buffer, blen, newValueLen);
1:         } else {
1:             // Write the end-of-stream marker (if required).
1:             blen += hdrGen.writeEOF(buffer, blen, Math.max(valueLength, -1));
commit:7af6726
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * The stream header to use for this stream.
1:      * <p>
0:      * The holder object is immutable, and the header should not have to be
0:      * changed, but we may replace it as an optimizataion. If the length of
0:      * the stream is unknown at the start of the insertion and the whole stream
0:      * content fits into the buffer, the header is updated with the length
0:      * after the source stream has been drained. This means that even though
0:      * the object is immutable and the reference final, another header may be
0:      * written to the stream.
1:      * @see #checkSufficientData()
1:      */
0:     private final StreamHeaderHolder header;
/////////////////////////////////////////////////////////////////////////
1:                               String typeName,
0:                               StreamHeaderHolder headerHolder) {
0:         this.header = headerHolder;
/////////////////////////////////////////////////////////////////////////
1:                               String typeName,
0:                               StreamHeaderHolder headerHolder) {
0:         this(appReader, -1 * maximumLength, 0, typeName, headerHolder);
/////////////////////////////////////////////////////////////////////////
0:             fillBuffer(header.copyInto(buffer, 0));
/////////////////////////////////////////////////////////////////////////
0:             fillBuffer(header.copyInto(buffer, 0));
/////////////////////////////////////////////////////////////////////////
1:         // can put the correct length into the stream.
1:         if (!multipleBuffer) {
0:             StreamHeaderHolder tmpHeader = header;
0:             if (header.expectsCharLength()) {
1:                 if (SanityManager.DEBUG) {
0:                     SanityManager.THROWASSERT("Header update with character " +
0:                             "length is not yet supported");
1:                 }
1:             } else {
0:                 int utflen = blen - header.headerLength(); // Length in bytes
0:                 tmpHeader = header.updateLength(utflen, false);
0:                 // Update the header we have already written to our buffer,
0:                 // still at postition zero.
0:                 tmpHeader.copyInto(buffer, 0);
1:                 if (SanityManager.DEBUG) {
0:                     // Check that we didn't overwrite any of the user data.
0:                     SanityManager.ASSERT(
0:                             header.headerLength() == tmpHeader.headerLength());
1:                 }
1:             }
0:             // The if below is temporary, it won't be necessary when support
0:             // for writing the new header has been added.
0:             if (tmpHeader.writeEOF()) {
0:                 // Write the end-of-stream marker.
0:                 buffer[blen++] = (byte) 0xE0;
0:                 buffer[blen++] = (byte) 0x00;
0:                 buffer[blen++] = (byte) 0x00;
1:             }
0:         } else if (header.writeEOF()) {
0:             // Write the end-of-stream marker.
0:             buffer[blen++] = (byte) 0xE0;
0:             buffer[blen++] = (byte) 0x00;
0:             buffer[blen++] = (byte) 0x00;
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1: }
commit:51c45b8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1:  * Converts the characters served by a {@code java.io.Reader} to a stream
1:  * returning the data in the on-disk modified UTF-8 encoded representation used
1:  * by Derby.
1:  * <p>
1:  * Length validation is performed. If required and allowed by the target column
1:  * type, truncation of blanks will also be performed.
1:  */
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Size of buffer to hold the data read from stream and converted to the
0:      * modified UTF-8 format.
1:      */
0:     private byte[] buffer = new byte[BUFSIZE];
1: 	private int boff;
1:     private int blen = -1;
1: 	private boolean eof;
1:     /** Tells if the stream content is/was larger than the buffer size. */
1: 	private boolean multipleBuffer;
1:     /**
1:      * Number of characters to truncate from this stream.
1:      * The SQL standard allows for truncation of trailing spaces for CLOB,
1:      * VARCHAR and CHAR. If zero, no characters are truncated, unless the
0:      * stream length execeeds the maximum length of the column we are inserting
1:      * into.
1:      * If positive, length of the expected final value, after truncation if any,
1:      * in characters. If negative, the maximum length allowed in the column we
1:      * are inserting into. A negative value means we are working with a stream
1:      * of unknown length, inserted through one of the JDBC 4.0 "lengthless
1:      * override" methods.
1:      */
/////////////////////////////////////////////////////////////////////////
1:      * @param valueLength the expected length of the reader in characters
1:      *      (positive), or the inverse (maxColWidth * -1) of the maximum column
1:      *      width if the expected stream length is unknown
/////////////////////////////////////////////////////////////////////////
0:         if (SanityManager.DEBUG) {
1:             // Check the type name
1:             // The national types (i.e. NVARCHAR) are not used/supported.
1:             SanityManager.ASSERT(typeName != null && (
1:                     typeName.equals(TypeId.CHAR_NAME) ||
1:                     typeName.equals(TypeId.VARCHAR_NAME) ||
1:                     typeName.equals(TypeId.CLOB_NAME)) ||
1:                     typeName.equals(TypeId.LONGVARCHAR_NAME));
1:         }
1:      * Creates a UTF-8 stream for an application reader whose length isn't
1:      * known at insertion time.
1:      * <p>
1:      * The application reader is coming in through one of the "lengthless
1:      * overrides" added in JDBC 4.0, for instance
0:      * {@link java.sql.PreparedStatement#setCharacterStream(int,Reader)}.
1:      * A limit is placed on the length of the application reader. If the reader
1:      * exceeds the maximum length, truncation of trailing blanks is attempted.
1:      * If truncation fails, an exception is thrown.
1:      *      the reader, typically the maximum field size
1:      * @throws IllegalArgumentException if maximum length is negative
0:         this(appReader, -1 * maximumLength, 0, typeName);
1:      * Reads a byte from the stream.
1:      * <p>
1:      * Characters read from the source stream are converted to the UTF-8 Derby
1:      * specific encoding.
1:      *
1:      * @return The byte read, or {@code -1} if the end-of-stream is reached.
1:      * @throws EOFException if the end-of-stream has already been reached or
1:      *      the stream has been closed
1:      * @throws IOException if reading from the source stream fails
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Reads up to {@code len} bytes from the stream.
1:      * <p>
1:      * Characters read from the source stream are converted to the UTF-8 Derby
1:      * specific encoding.
1:      *
1:      * @return The number of bytes read, or {@code -1} if the end-of-stream is
1:      *      reached.
1:      * @throws EOFException if the end-of-stream has already been reached or
1:      *      the stream has been closed
1:      * @throws IOException if reading from the source stream fails
1:      * @see java.io.InputStream#read(byte[],int,int)
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Fills the internal buffer with data read from the source stream.
1:      * <p>
1:      * The characters read from the source are converted to the modified UTF-8
1:      * encoding, used as the on-disk format by Derby.
1:      *
1:      * @param startingOffset offset at which to start filling the buffer, used
1:      *      to avoid overwriting the stream header data on the first iteration
1:      * @throws DerbyIOException if the source stream has an invalid length
1:      *      (different than specified), or if truncation of blanks fails
1:      * @throws IOException if reading from the source stream fails
1:      */
/////////////////////////////////////////////////////////////////////////
1:                                 SQLState.LANG_STRING_TRUNCATION,
1:                                 typeName,
1:                                 "<stream-value>", // Don't show the whole value.
1:                                 String.valueOf(Math.abs(valueLength))),
/////////////////////////////////////////////////////////////////////////
1:         } else if (typeName.equals(TypeId.CHAR_NAME)) {
1:             return true;
/////////////////////////////////////////////////////////////////////////
1:                         "<stream-value>", // Don't show the whole value.
1:                         String.valueOf(Math.abs(valueLength))),
/////////////////////////////////////////////////////////////////////////
1:     public void close() {
/////////////////////////////////////////////////////////////////////////
1:      * the stream.
0:      * <p>
1:      * Note, it is not exactly per {@code java.io.InputStream#available()}.
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:10cc70b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.DerbyIOException;
0: import org.apache.derby.iapi.types.TypeId;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final int charsToTruncate;
1:     private static final char SPACE = ' ';
/////////////////////////////////////////////////////////////////////////
0:     /** The maximum allowed length of the stream. */
0:     private final int maximumLength;
1:     /** The type name for the column data is inserted into. */
1:     private final String typeName;
1:      * Create a stream that will truncate trailing blanks if required/allowed.
1:      *
1:      * If the stream must be truncated, the number of blanks to truncate
1:      * is specified to allow the stream to be checked for exact length, as
1:      * required by JDBC 3.0. If the stream is shorter or longer than specified,
1:      * an exception is thrown during read.
1:      *
1:      * @param appReader application reader
0:      * @param valueLength the length of the reader in characters
1:      * @param numCharsToTruncate the number of trailing blanks to truncate
1:      * @param typeName type name of the column data is inserted into
1:     public ReaderToUTF8Stream(Reader appReader,
1:                               int valueLength,
1:                               int numCharsToTruncate,
0:                               String typeName) {
0:         reader.setLimit(valueLength);
0:         this.maximumLength = -1;
1:         this.typeName = typeName;
1:     }
1: 
1:     /**
0:      * Create a UTF-8 stream for a length less application reader.
1:      *
0:      * A limit is placed on the length of the reader. If the reader exceeds
0:      * the maximum length, truncation of trailing blanks is attempted. If
0:      * truncation fails, an exception is thrown.
1:      *
1:      * @param appReader application reader
1:      * @param maximumLength maximum allowed length in number of characters for
0:      *      the reader
1:      * @param typeName type name of the column data is inserted into
0:      * @throws IllegalArgumentException if maximum length is negative, or type
0:      *      name is <code>null<code>
1:      */
1:     public ReaderToUTF8Stream(Reader appReader,
1:                               int maximumLength,
0:                               String typeName) {
1:         if (maximumLength < 0) {
1:             throw new IllegalArgumentException("Maximum length for a capped " +
1:                     "stream cannot be negative: " + maximumLength);
1:         }
0:         if (typeName == null) {
0:             throw new IllegalArgumentException("Type name cannot be null");
1:         }
1:         this.reader = new LimitReader(appReader);
0:         reader.setLimit(maximumLength);
0:         buffer = new byte[BUFSIZE];
0:         blen = -1;
0:         this.maximumLength = maximumLength;
1:         this.typeName = typeName;
0:         this.charsToTruncate = -1;
0:         this.valueLength = -1;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Validate the length of the stream, take corrective action if allowed.
1:      *
1:      * JDBC 3.0 (from tutorial book) requires that an input stream has the
1:      * correct number of bytes in the stream.
1:      * If the stream is too long, trailing blank truncation is attempted if
1:      * allowed. If truncation fails, or is disallowed, an exception is thrown.
1:      *
1:      * @throws IOException if an errors occurs in the application stream
1:      * @throws DerbyIOException if Derby finds a problem with the stream;
1:      *      stream is too long and cannot be truncated, or the stream length
1:      *      does not match the specified length
1:      */
/////////////////////////////////////////////////////////////////////////
1:             truncate();
1:         // A length less stream that is capped, will return 0 even if there
1:         // are more bytes in the application stream.
1:         if (remainingBytes > 0 && valueLength > 0) {
1:             // If we had a specified length, throw exception.
1:             throw new DerbyIOException(
1:                     MessageService.getTextMessage(
1:                         SQLState.SET_STREAM_INEXACT_LENGTH_DATA),
1:                     SQLState.SET_STREAM_INEXACT_LENGTH_DATA);
1:         }
1: 		// JDBC 3.0 states the stream must have the correct number of
1:         if (remainingBytes == 0 && reader.read() >= 0) {
1:             if (valueLength > -1) {
1:                 throw new DerbyIOException(
1:                         MessageService.getTextMessage(
1:                             SQLState.SET_STREAM_INEXACT_LENGTH_DATA),
1:                         SQLState.SET_STREAM_INEXACT_LENGTH_DATA);
1:             } else {
1:                 // Stream was capped (length less) and too long.
1:                 // Try to truncate if allowed, or else throw exception.
1:                 if (canTruncate()) {
1:                     truncate();
1:                 } else {
1:                     throw new DerbyIOException(
1:                             MessageService.getTextMessage(
0:                                 SQLState.LANG_STRING_TRUNCATION),
1:                             SQLState.LANG_STRING_TRUNCATION);
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:      * Determine if trailing blank truncation is allowed.
1:      */
1:     private boolean canTruncate() {
1:         // Only a few types can be truncated, default is to not allow.
1:         if (typeName.equals(TypeId.CLOB_NAME)) {
1:             return true;
1:         } else if (typeName.equals(TypeId.VARCHAR_NAME)) {
1:             return true;
1:         }
1:         return false;
1:     }
1: 
1:     /**
1:      * Attempt to truncate the stream by removing trailing blanks.
1:      */
1:     private void truncate()
1:             throws IOException {
1:         int c = 0;
1:         for (;;) {
1:             c = reader.read();
1: 
1:             if (c < 0) {
1:                 break;
1:             } else if (c != SPACE) {
1:                 throw new DerbyIOException(
1:                     MessageService.getTextMessage(
1:                         SQLState.LANG_STRING_TRUNCATION,
1:                         typeName, 
0:                         "XXXX", 
0:                         String.valueOf(valueLength)),
1:                     SQLState.LANG_STRING_TRUNCATION);
1:             }
1:         }
1:     }
1: 
1:     /**
commit:242c9bd
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
0:     public static final int UNKNOWN_LENGTH = Integer.MIN_VALUE;
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (valueLength != UNKNOWN_LENGTH) {
0:             reader.setLimit(valueLength);
1:         } 
0:         if (SanityManager.DEBUG && valueLength == UNKNOWN_LENGTH) {
0:             // Number of chars to truncate must be 0 if length is unknown.
0:             // This count is used to check if the stream matches the
0:             // specified length.
0:             SanityManager.ASSERT(numCharsToTruncate == 0);
1:         }
/////////////////////////////////////////////////////////////////////////
0:                     // [NOTE] The assumption that this is always a Clob is not
0:                     //        enforced anywhere (i.e. that 'charsToTruncate'
0:                     //        is 0 for all other types)
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4dbb0ff
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Application's reader wrapped in a LimitReader.
1:      */
/////////////////////////////////////////////////////////////////////////
0:     /** Number of characters to truncate from this stream
0:      The SQL standard allows for truncation of trailing spaces 
0:      for clobs,varchar,char.
0:      If zero, no characters are truncated.
1:      */
0:     private static final char SPACE =' ';
1:     /**
0:      * Length of the final value, after truncation if any,
0:      * in characters.
0:      this stream needs to fit into a column of colWidth
0:      if truncation error happens ,then the error message includes 
0:      information about the column width.
1:     */
1:     private final int valueLength; 
1:     /**
0:      * Create a stream with truncation.
1:      */
0:  	public ReaderToUTF8Stream(Reader appReader, int valueLength,int numCharsToTruncate)
0:         this.reader = new LimitReader(appReader);
0:         reader.setLimit(valueLength);
0:         buffer = new byte[BUFSIZE];
0:         blen = -1;        
1:         this.valueLength = valueLength;
/////////////////////////////////////////////////////////////////////////
0:             for (;;)
/////////////////////////////////////////////////////////////////////////
0:                             String.valueOf(valueLength)));
commit:19f33c6
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.ReaderToUTF8Stream
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derby.iapi.types;
/////////////////////////////////////////////////////////////////////////
0: 	Converts a java.io.Reader to the on-disk UTF8 format used by Derby
0:     for character types.
1: public final class ReaderToUTF8Stream
/////////////////////////////////////////////////////////////////////////
0: 	public ReaderToUTF8Stream(LimitReader reader,int length,int numCharsToTruncate)
commit:345de35
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class org.apache.derby.impl.jdbc.ReaderToUTF8Stream
1: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
0: package org.apache.derby.impl.jdbc;
1: 
1: import java.io.InputStream;
1: import java.io.IOException;
1: import java.io.EOFException;
1: import java.io.Reader;
0: import java.io.UTFDataFormatException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: import org.apache.derby.iapi.services.io.LimitReader;
1: 
1: /**
0: 	Converts a java.io.Reader to the on-disk UTF8 format used by Cloudscape.
1: */
0: final class ReaderToUTF8Stream
1: 	extends InputStream
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
1: 
1: 	private LimitReader reader;
1: 
0: 	private byte[] buffer;
0: 	private int boff;
0: 	private int blen;
0: 	private boolean eof;
0: 	private boolean multipleBuffer;
1: 
0: 	ReaderToUTF8Stream(LimitReader reader)
1: 	{
0: 		this.reader = reader;
0: 		buffer = new byte[4096];
0: 		blen = -1;
1: 	}
1: 
1: 	public int read() throws IOException {
1: 
1: 		// first read
1: 		if (blen < 0)
0: 			fillBuffer(2);
1: 
1: 		while (boff == blen)
1: 		{
1: 			// reached end of buffer, read more?
1: 			if (eof)
1: 				return -1;
1: 
1: 			fillBuffer(0);
1: 		}
1: 
1: 		return buffer[boff++] & 0xff;
1: 
1: 	}
1: 
1: 	public int read(byte b[], int off, int len) throws IOException {
1: 		// first read
1: 		if (blen < 0)
0: 			fillBuffer(2);
1: 
1: 		int readCount = 0;
1: 
1: 		while (len > 0)
1: 		{
1: 
1: 			int copyBytes = blen - boff;
1: 
1: 			// buffer empty?
1: 			if (copyBytes == 0)
1: 			{
1: 				if (eof)
1: 				{
0: 					return readCount == 0 ? readCount : -1;
1: 				}
1: 				fillBuffer(0);
1: 				continue;
1: 			}
1: 
1: 			if (len < copyBytes)
1: 				copyBytes = len;
1: 
1: 			System.arraycopy(buffer, boff, b, off, copyBytes);
1: 			boff += copyBytes;
1: 			len -= copyBytes;
1: 			readCount += copyBytes;
1: 
1: 		}
1: 
1: 		return readCount;
1: 	}
1: 
1: 	private void fillBuffer(int startingOffset) throws IOException
1: 	{
0: 		int off = boff = startingOffset;
1: 
1: 		if (off == 0)
1: 			multipleBuffer = true;
1: 
1: 		// 6! need to leave room for a three byte UTF8 encoding
1: 		// and 3 bytes for our special end of file marker.
0: 		for (; off <= buffer.length - 6; )
1: 		{
1: 			int c = reader.read();
1: 			if (c < 0) {
1: 				eof = true;
1: 				break;
1: 			}
1: 
1: 			if ((c >= 0x0001) && (c <= 0x007F))
1:             {
1: 				buffer[off++] = (byte) c;
1: 			}
1:             else if (c > 0x07FF)
1:             {
1: 				buffer[off++] = (byte) (0xE0 | ((c >> 12) & 0x0F));
1: 				buffer[off++] = (byte) (0x80 | ((c >>  6) & 0x3F));
1: 				buffer[off++] = (byte) (0x80 | ((c >>  0) & 0x3F));
1: 			}
1:             else
1:             {
1: 				buffer[off++] = (byte) (0xC0 | ((c >>  6) & 0x1F));
1: 				buffer[off++] = (byte) (0x80 | ((c >>  0) & 0x3F));
1: 			}
1: 		}
1: 
1: 		blen = off;
0: 		boff = 0;
1: 
1: 		if (eof)
1: 			checkSufficientData();
1: 	}
1: 
1: 	/**
0: 		JDBC 3.0 (from tutorial book) requires that an
0: 		input stream has the correct number of bytes in
0: 		the stream.
1: 	*/
1: 	private void checkSufficientData() throws IOException
1: 	{
1: 		int remainingBytes = reader.clearLimit();
1: 
0: 		if (remainingBytes > 0)
0: 			throw new IOException(MessageService.getTextMessage(SQLState.SET_STREAM_INSUFFICIENT_DATA));
1: 
1: 		// if we had a limit try reading one more character.
0: 		// JDBC 3.0 states the stream muct have the correct number of characters in it.
0: 		if (remainingBytes == 0) {
0: 			int c;
0: 			try
1: 			{
0: 				c = reader.read();
1: 			}
0: 			catch (IOException ioe) {
0: 				c = -1;
1: 			}
0: 			if (c >= 0)
0: 				throw new IOException(MessageService.getTextMessage(SQLState.SET_STREAM_INSUFFICIENT_DATA));
1: 		}
1: 
0: 		// can put the correct length into the stream.
0: 		if (!multipleBuffer)
1: 		{
0: 			int utflen = blen - 2;
1: 
0: 			buffer[0] = (byte) ((utflen >>> 8) & 0xFF);
0: 			buffer[1] = (byte) ((utflen >>> 0) & 0xFF);
1: 		}
1: 		else
1: 		{
0: 			buffer[blen++] = (byte) 0xE0;
0: 			buffer[blen++] = (byte) 0x00;
0: 			buffer[blen++] = (byte) 0x00;
1: 		}
1: 	}
1: 
0: 	public void close() throws IOException
1: 	{
1: 		buffer = null;
0: 		reader.close();
1: 	}
1: 
1: }
1: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:bb1be44
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * read from stream; characters converted to utf-8 derby specific encoding.
0:      * If stream has been read, and eof reached, in that case any subsequent
0:      * read will throw an EOFException
1:      * @see java.io.InputStream#read()
0:      */
1:         // when stream has been read and eof reached, stream is closed
1:         // and buffer is set to null ( see close() method)
1:         // since stream cannot be re-used, check if stream is closed and 
1:         // if so throw an EOFException
1:         if ( buffer == null)
1:             throw new EOFException(MessageService.getTextMessage(SQLState.STREAM_EOF));
0: 
0:         
/////////////////////////////////////////////////////////////////////////
0:             {
1:                // we have reached the end of this stream
1:                // cleanup here and return -1 indicating 
1:                // eof of stream
1:                close();
1:                return -1;
0:             }
0:                 
/////////////////////////////////////////////////////////////////////////
0:         
1:         // when stream has been read and eof reached, stream is closed
1:         // and buffer is set to null ( see close() method)
1:         // since stream cannot be re-used, check if stream is closed and 
1:         // if so throw an EOFException
1:         if ( buffer == null )
1:             throw new EOFException(MessageService.getTextMessage
1:                     (SQLState.STREAM_EOF));
0: 
0:         // first read
/////////////////////////////////////////////////////////////////////////
1:                     if (readCount > 0)
0:                     {
1:                         return readCount;
0:                     }
0:                     else
0:                     {
1:                         // we have reached the eof, so close the stream
1:                         close();
0:                         return -1;  
0:                     }
0:                     
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * return resources 
0:      */
1:         // since stream has been read and eof reached, return buffer back to 
1:         // the vm.
1:         // Instead of using another variable to indicate stream is closed
1:         // a check on (buffer==null) is used instead. 
0:         buffer = null;
commit:28030d7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.TypeId;
/////////////////////////////////////////////////////////////////////////
0:     
0:     // Number of characters to truncate from this stream
0:     // The SQL standard allows for truncation of trailing spaces 
0:     // for clobs,varchar,char.
0:     private int charsToTruncate;
0:     private final char SPACE =' ';
0:     
0:     // this stream needs to fit into a column of colWidth
0:     // if truncation error happens ,then the error message includes 
0:     // information about the column width which is why this variable
0:     // is needed.
0:     private int colWidth;  
0:     
0: 	ReaderToUTF8Stream(LimitReader reader,int length,int numCharsToTruncate)
1:         this.charsToTruncate = numCharsToTruncate;
0:         this.colWidth = length;
/////////////////////////////////////////////////////////////////////////
0:                     // return actual number of bytes read into b[]
0: 					return readCount > 0 ? readCount : -1;
/////////////////////////////////////////////////////////////////////////
1:             off += copyBytes;
/////////////////////////////////////////////////////////////////////////
1: 		// now that we finished reading from the stream; the amount
1:         // of data that we can insert,start check for trailing spaces
1:         if (charsToTruncate > 0)
0:         {
1:             reader.setLimit(charsToTruncate);
0:             int c = 0;
0:             do
0:             {
0:                 c = reader.read();
0:                 
0:                 if (c < 0)
0:                 {
0:                     break;
0:                 }
0:                 else if (c != SPACE)
0:                 {
0:                     // throw truncation error, wont happen here for any other 
0:                     // type except for clob
0:                     // hence using TypeId.CLOB_NAME to avoid having to store
0:                     // the type information along with this stream.
0:                     throw new IOException(
0:                         MessageService.getTextMessage(
0:                             SQLState.LANG_STRING_TRUNCATION,
0:                             TypeId.CLOB_NAME, 
0:                             "XXXX", 
0:                             String.valueOf(colWidth)));
0:                 }
0:             }
0:             while (c == SPACE);
0:         }
0:         
0:         int remainingBytes = reader.clearLimit();
0: 		// JDBC 3.0 states the stream muct have the correct number of 
1:         // characters in it.
0: 
0:                
0:         }
0: 		
/////////////////////////////////////////////////////////////////////////
0:   }
commit:ff049ad
/////////////////////////////////////////////////////////////////////////
0: 			throw new IOException(MessageService.getTextMessage(SQLState.SET_STREAM_INEXACT_LENGTH_DATA));
/////////////////////////////////////////////////////////////////////////
0: 				throw new IOException(MessageService.getTextMessage(SQLState.SET_STREAM_INEXACT_LENGTH_DATA));
commit:a4e8535
/////////////////////////////////////////////////////////////////////////
0:     // buffer to hold the data read from stream 
0:     // and converted to UTF8 format
0:     private final static int BUFSIZE = 32768;
0: 		buffer = new byte[BUFSIZE];
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * Return an optimized version of bytes available to read from 
0:      * the stream 
0:      * Note, it is not exactly per java.io.InputStream#available()
0:      */
1:     public final int available()
0:     {
1:        int remainingBytes = reader.getLimit();
1:        // this object buffers BUFSIZE bytes that can be read 
1:        // and when that is finished it reads the next available bytes
1:        // from the reader object 
1:        // reader.getLimit() returns the remaining bytes available
1:        // on this stream
0:        return (BUFSIZE > remainingBytes ? remainingBytes : BUFSIZE);
0:     }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.jdbc;
0: 
0: import java.io.InputStream;
0: import java.io.IOException;
0: import java.io.EOFException;
0: import java.io.Reader;
0: import java.io.UTFDataFormatException;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.services.io.LimitReader;
0: 
0: /**
0: 	Converts a java.io.Reader to the on-disk UTF8 format used by Cloudscape.
0: */
0: final class ReaderToUTF8Stream
0: 	extends InputStream
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
0: 
0: 	private LimitReader reader;
0: 
0: 	private byte[] buffer;
0: 	private int boff;
0: 	private int blen;
0: 	private boolean eof;
0: 	private boolean multipleBuffer;
0: 
0: 	ReaderToUTF8Stream(LimitReader reader)
0: 	{
0: 		this.reader = reader;
0: 		buffer = new byte[4096];
0: 		blen = -1;
0: 	}
0: 
0: 	public int read() throws IOException {
0: 
0: 		// first read
0: 		if (blen < 0)
0: 			fillBuffer(2);
0: 
0: 		while (boff == blen)
0: 		{
0: 			// reached end of buffer, read more?
0: 			if (eof)
0: 				return -1;
0: 
0: 			fillBuffer(0);
0: 		}
0: 
0: 		return buffer[boff++] & 0xff;
0: 
0: 	}
0: 
0: 	public int read(byte b[], int off, int len) throws IOException {
0: 		// first read
0: 		if (blen < 0)
0: 			fillBuffer(2);
0: 
0: 		int readCount = 0;
0: 
0: 		while (len > 0)
0: 		{
0: 
0: 			int copyBytes = blen - boff;
0: 
0: 			// buffer empty?
0: 			if (copyBytes == 0)
0: 			{
0: 				if (eof)
0: 				{
0: 					return readCount == 0 ? readCount : -1;
0: 				}
0: 				fillBuffer(0);
0: 				continue;
0: 			}
0: 
0: 			if (len < copyBytes)
0: 				copyBytes = len;
0: 
0: 			System.arraycopy(buffer, boff, b, off, copyBytes);
0: 			boff += copyBytes;
0: 			len -= copyBytes;
0: 			readCount += copyBytes;
0: 
0: 		}
0: 
0: 		return readCount;
0: 	}
0: 
0: 	private void fillBuffer(int startingOffset) throws IOException
0: 	{
0: 		int off = boff = startingOffset;
0: 
0: 		if (off == 0)
0: 			multipleBuffer = true;
0: 
0: 		// 6! need to leave room for a three byte UTF8 encoding
0: 		// and 3 bytes for our special end of file marker.
0: 		for (; off <= buffer.length - 6; )
0: 		{
0: 			int c = reader.read();
0: 			if (c < 0) {
0: 				eof = true;
0: 				break;
0: 			}
0: 
0: 			if ((c >= 0x0001) && (c <= 0x007F))
0:             {
0: 				buffer[off++] = (byte) c;
0: 			}
0:             else if (c > 0x07FF)
0:             {
0: 				buffer[off++] = (byte) (0xE0 | ((c >> 12) & 0x0F));
0: 				buffer[off++] = (byte) (0x80 | ((c >>  6) & 0x3F));
0: 				buffer[off++] = (byte) (0x80 | ((c >>  0) & 0x3F));
0: 			}
0:             else
0:             {
0: 				buffer[off++] = (byte) (0xC0 | ((c >>  6) & 0x1F));
0: 				buffer[off++] = (byte) (0x80 | ((c >>  0) & 0x3F));
0: 			}
0: 		}
0: 
0: 		blen = off;
0: 		boff = 0;
0: 
0: 		if (eof)
0: 			checkSufficientData();
0: 	}
0: 
0: 	/**
0: 		JDBC 3.0 (from tutorial book) requires that an
0: 		input stream has the correct number of bytes in
0: 		the stream.
0: 	*/
0: 	private void checkSufficientData() throws IOException
0: 	{
0: 		int remainingBytes = reader.clearLimit();
0: 
0: 		if (remainingBytes > 0)
0: 			throw new IOException(MessageService.getTextMessage(SQLState.SET_STREAM_INSUFFICIENT_DATA));
0: 
0: 		// if we had a limit try reading one more character.
0: 		// JDBC 3.0 states the stream muct have the correct number of characters in it.
0: 		if (remainingBytes == 0) {
0: 			int c;
0: 			try
0: 			{
0: 				c = reader.read();
0: 			}
0: 			catch (IOException ioe) {
0: 				c = -1;
0: 			}
0: 			if (c >= 0)
0: 				throw new IOException(MessageService.getTextMessage(SQLState.SET_STREAM_INSUFFICIENT_DATA));
0: 		}
0: 
0: 		// can put the correct length into the stream.
0: 		if (!multipleBuffer)
0: 		{
0: 			int utflen = blen - 2;
0: 
0: 			buffer[0] = (byte) ((utflen >>> 8) & 0xFF);
0: 			buffer[1] = (byte) ((utflen >>> 0) & 0xFF);
0: 		}
0: 		else
0: 		{
0: 			buffer[blen++] = (byte) 0xE0;
0: 			buffer[blen++] = (byte) 0x00;
0: 			buffer[blen++] = (byte) 0x00;
0: 		}
0: 	}
0: 
0: 	public void close() throws IOException
0: 	{
0: 		buffer = null;
0: 		reader.close();
0: 	}
0: 
0: }
0: 
============================================================================