1:da847a2: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.jdbc.BrokeredConnection
1:f578f07: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:f578f07: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
6:eac0369:  */
1:7ecc1f2: 
1:eac0369: package org.apache.derby.iapi.jdbc;
15:eac0369: 
1:863daa0: import java.sql.Array;
1:863daa0: import java.sql.Blob;
1:eac0369: import java.sql.CallableStatement;
1:863daa0: import java.sql.Clob;
1:f44e479: import java.sql.Connection;
1:eac0369: import java.sql.DatabaseMetaData;
1:863daa0: import java.sql.NClob;
1:f44e479: import java.sql.PreparedStatement;
1:f44e479: import java.sql.ResultSet;
1:863daa0: import java.sql.SQLClientInfoException;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.SQLWarning;
1:863daa0: import java.sql.SQLXML;
1:f44e479: import java.sql.Savepoint;
1:f44e479: import java.sql.Statement;
1:863daa0: import java.sql.Struct;
1:863daa0: import java.util.Properties;
1:863daa0: import java.util.concurrent.Executor;
1:e8aba82: import org.apache.derby.iapi.error.SQLWarningFactory;
1:ce9d214: import org.apache.derby.shared.common.reference.SQLState;
1:eac0369: 
1:4383496: /**
1:eac0369:  * This is a rudimentary connection that delegates
1:92ee7b2:  * EVERYTHING to Connection.
1:4383496:  */
1:863daa0: public class BrokeredConnection implements EngineConnection
3:eac0369: {
1:f578f07: 	
1:f578f07: 	// default for Derby
1:1e8a20f: 	int stateHoldability = ResultSet.HOLD_CURSORS_OVER_COMMIT;
1:eac0369: 
1:5b2f5de: 	final BrokeredConnectionControl control;
1:f8cb3d7: 	protected boolean isClosed;
1:e214c07:         private String connString;
1:ec60014: 
1:1128268: 	/**
1:eac0369: 		Maintain state as seen by this Connection handle, not the state
1:eac0369: 		of the underlying Connection it is attached to.
1:08cd3aa: 	*/
1:eac0369: 	private int stateIsolationLevel;
1:eac0369: 	private boolean stateReadOnly;
1:eac0369: 	private boolean stateAutoCommit;
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	CONSTRUCTORS
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	public	BrokeredConnection(BrokeredConnectionControl control)
1:ec60014:             throws SQLException
1:eac0369: 	{
1:eac0369: 		this.control = control;
1:5fe468c: 	}
1:1d2a569: 
1:f44e479:     // JDBC 2.0 methods
1:f44e479: 
1:eac0369: 	public final void setAutoCommit(boolean autoCommit) throws SQLException 
1:eac0369: 	{
1:da847a2: 		try {
1:eac0369: 			control.checkAutoCommit(autoCommit);
1:1128268: 
1:eac0369: 			getRealConnection().setAutoCommit(autoCommit);
1:da847a2: 
1:eac0369: 			stateAutoCommit = autoCommit;
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:f44e479: 		}
1:5fe468c: 	}
1:eac0369: 	public final boolean getAutoCommit() throws SQLException 
1:eac0369: 	{
1:da847a2: 		try {
1:eac0369: 			return getRealConnection().getAutoCommit();
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
10:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	public final Statement createStatement() throws SQLException 
1:eac0369: 	{
2:eac0369: 		try {
1:eac0369: 			return control.wrapStatement(getRealConnection().createStatement());
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:da847a2: 
1:eac0369: 	public final PreparedStatement prepareStatement(String sql)
1:eac0369: 	    throws SQLException 
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			return control.wrapStatement(getRealConnection().prepareStatement(sql), sql, null);
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final CallableStatement prepareCall(String sql) throws SQLException 
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			return control.wrapStatement(getRealConnection().prepareCall(sql), sql);
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final String nativeSQL(String sql) throws SQLException
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			return getRealConnection().nativeSQL(sql);
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final void commit() throws SQLException 
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			control.checkCommit();
1:eac0369: 			getRealConnection().commit();
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final void rollback() throws SQLException 
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			control.checkRollback();
1:eac0369: 			getRealConnection().rollback();
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final void close() throws SQLException 
1:eac0369: 	{ 
1:eac0369: 		if (isClosed)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		try {
1:902041a:             control.checkClose();
1:902041a: 
1:eac0369: 			if (!control.closingConnection()) {
1:eac0369: 				isClosed = true;
1:eac0369: 				return;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			isClosed = true;
1:eac0369: 
1:eac0369: 
1:eac0369: 			getRealConnection().close();
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final boolean isClosed() throws SQLException 
1:eac0369: 	{
1:eac0369: 		if (isClosed)
1:eac0369: 			return true;
1:eac0369: 		try {
1:eac0369: 			boolean realIsClosed = getRealConnection().isClosed();
1:eac0369: 			if (realIsClosed) {
1:eac0369: 				control.closingConnection();
1:eac0369: 				isClosed = true;
1:eac0369: 			}
1:eac0369: 			return realIsClosed;
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final SQLWarning getWarnings() throws SQLException 
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			return getRealConnection().getWarnings();
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final void clearWarnings() throws SQLException 
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			getRealConnection().clearWarnings();
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final DatabaseMetaData getMetaData() throws SQLException 
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			return getRealConnection().getMetaData();
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final void setReadOnly(boolean readOnly) throws SQLException 
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			getRealConnection().setReadOnly(readOnly);
1:eac0369: 			stateReadOnly = readOnly;
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final boolean isReadOnly() throws SQLException 
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			return getRealConnection().isReadOnly();
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final void setCatalog(String catalog) throws SQLException 
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			getRealConnection().setCatalog(catalog);
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final String getCatalog() throws SQLException 
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			return getRealConnection().getCatalog();
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final void setTransactionIsolation(int level) throws SQLException 
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			getRealConnection().setTransactionIsolation(level);
1:eac0369: 			stateIsolationLevel = level;
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final int getTransactionIsolation() throws SQLException
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			return getRealConnection().getTransactionIsolation();
1:eac0369: 		} catch (SQLException sqle) {
1:eac0369: 			notifyException(sqle);
1:eac0369: 			throw sqle;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     public final Statement createStatement(int resultSetType, int resultSetConcurrency) 
1:eac0369:       throws SQLException
1:eac0369: 	{
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			return control.wrapStatement(getRealConnection().
1:eac0369: 				createStatement(resultSetType, resultSetConcurrency));
1:eac0369: 		}
1:eac0369: 		catch (SQLException se)
1:da847a2: 		{
1:eac0369: 			notifyException(se);
1:eac0369: 			throw se;
1:eac0369: 		}
1:eac0369: 	}
1:863daa0: 
1:f44e479: 
1:eac0369: 	public final PreparedStatement prepareStatement(String sql, int resultSetType, 
1:eac0369: 					int resultSetConcurrency)
1:eac0369:        throws SQLException
1:eac0369: 	{
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			return control.wrapStatement(getRealConnection().
1:eac0369: 				prepareStatement(sql, resultSetType, resultSetConcurrency), sql, null);
1:eac0369: 		}
1:eac0369: 		catch (SQLException se)
1:eac0369: 		{
1:eac0369: 			notifyException(se);
1:eac0369: 			throw se;
1:eac0369: 		}
1:eac0369: 	}
1:98ead91: 
1:eac0369:     public final CallableStatement prepareCall(String sql, int resultSetType, 
1:eac0369: 				 int resultSetConcurrency) throws SQLException
1:eac0369: 	{
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			return control.wrapStatement(getRealConnection().
1:eac0369: 				prepareCall(sql, resultSetType, resultSetConcurrency), sql);
1:eac0369: 		}
1:eac0369: 		catch (SQLException se)
1:eac0369: 		{
1:eac0369: 			notifyException(se);
1:eac0369: 			throw se;
1:eac0369: 		}
1:eac0369: 	}
1:ce9d214: 
1:850aba4:     public java.util.Map<String, Class<?>> getTypeMap() throws SQLException
1:eac0369: 	{
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			return getRealConnection().getTypeMap();
1:eac0369: 		}
1:eac0369: 		catch (SQLException se)
1:eac0369: 		{
1:eac0369: 			notifyException(se);
1:eac0369: 			throw se;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:850aba4:     public final void setTypeMap(java.util.Map<String, Class<?>> map) throws SQLException
1:eac0369: 	{
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			getRealConnection().setTypeMap(map);
1:eac0369: 		}
1:eac0369: 		catch (SQLException se)
1:eac0369: 		{
1:eac0369: 			notifyException(se);
1:eac0369: 			throw se;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:f44e479:     // JDBC 3.0 methods
1:f44e479: 
1:f44e479:     public final Statement createStatement(int resultSetType,
1:f44e479:             int resultSetConcurrency,
1:f44e479:             int resultSetHoldability)
1:f44e479:             throws SQLException {
1:f44e479:         try {
1:f44e479:             resultSetHoldability =
1:f44e479:                     statementHoldabilityCheck(resultSetHoldability);
1:f44e479:             return control.wrapStatement(
1:f44e479:                     getRealConnection().createStatement(resultSetType,
1:f44e479:                     resultSetConcurrency, resultSetHoldability));
1:f44e479:         } catch (SQLException se) {
1:f44e479:             notifyException(se);
1:f44e479:             throw se;
1:f44e479:         }
1:f44e479:     }
1:f44e479: 
1:f44e479:     public final CallableStatement prepareCall(String sql,
1:f44e479:             int resultSetType,
1:f44e479:             int resultSetConcurrency,
1:f44e479:             int resultSetHoldability)
1:f44e479:             throws SQLException {
1:f44e479:         try {
1:f44e479:             resultSetHoldability =
1:f44e479:                     statementHoldabilityCheck(resultSetHoldability);
1:f44e479:             return control.wrapStatement(
1:f44e479:                     getRealConnection().prepareCall(sql, resultSetType,
1:f44e479:                     resultSetConcurrency, resultSetHoldability), sql);
1:f44e479:         } catch (SQLException se) {
1:f44e479:             notifyException(se);
1:f44e479:             throw se;
1:f44e479:         }
1:f44e479:     }
1:f44e479: 
1:f44e479:     public final Savepoint setSavepoint()
1:f44e479:             throws SQLException {
1:f44e479:         try {
1:f44e479:             control.checkSavepoint();
1:f44e479:             return getRealConnection().setSavepoint();
1:f44e479:         } catch (SQLException se) {
1:f44e479:             notifyException(se);
1:f44e479:             throw se;
1:f44e479:         }
1:f44e479:     }
1:f44e479: 
1:f44e479:     public final Savepoint setSavepoint(String name)
1:f44e479:             throws SQLException {
1:f44e479:         try {
1:f44e479:             control.checkSavepoint();
1:f44e479:             return getRealConnection().setSavepoint(name);
1:f44e479:         } catch (SQLException se) {
1:f44e479:             notifyException(se);
1:f44e479:             throw se;
1:f44e479:         }
1:f44e479:     }
1:f44e479: 
1:f44e479:     public final void rollback(Savepoint savepoint)
1:f44e479:             throws SQLException {
1:f44e479:         try {
1:f44e479:             control.checkRollback();
1:f44e479:             getRealConnection().rollback(savepoint);
1:f44e479:         } catch (SQLException se) {
1:f44e479:             notifyException(se);
1:f44e479:             throw se;
1:f44e479:         }
1:f44e479:     }
1:f44e479: 
1:f44e479:     public final void releaseSavepoint(Savepoint savepoint)
1:f44e479:             throws SQLException {
1:f44e479:         try {
1:f44e479:             getRealConnection().releaseSavepoint(savepoint);
1:f44e479:         } catch (SQLException se) {
1:f44e479:             notifyException(se);
1:f44e479:             throw se;
1:f44e479:         }
1:f44e479:     }
1:f44e479: 
1:f44e479:     public final void setHoldability(int holdability)
1:f44e479:             throws SQLException {
1:f44e479:         try {
1:f44e479:             holdability = control.checkHoldCursors(holdability, false);
1:f44e479:             getRealConnection().setHoldability(holdability);
1:f44e479:             stateHoldability = holdability;
1:f44e479:         } catch (SQLException se) {
1:f44e479:             notifyException(se);
1:f44e479:             throw se;
1:f44e479:         }
1:f44e479:     }
1:f44e479: 
1:f44e479:     public final PreparedStatement prepareStatement(
1:f44e479:             String sql,
1:f44e479:             int autoGeneratedKeys)
1:f44e479:             throws SQLException {
1:f44e479:         try {
1:f44e479:             return control.wrapStatement(getRealConnection().prepareStatement(
1:f44e479:                 sql, autoGeneratedKeys), sql, autoGeneratedKeys);
1:f44e479:         } catch (SQLException se) {
1:f44e479:             notifyException(se);
1:f44e479:             throw se;
1:f44e479:         }
1:f44e479:     }
1:f44e479: 
1:f44e479:     public final PreparedStatement prepareStatement(
1:f44e479:             String sql,
1:f44e479:             int[] columnIndexes)
1:f44e479:             throws SQLException {
1:f44e479:         try {
1:f44e479:             return control.wrapStatement(getRealConnection().prepareStatement(
1:f44e479:                     sql, columnIndexes), sql, columnIndexes);
1:f44e479:         } catch (SQLException se) {
1:f44e479:             notifyException(se);
1:f44e479:             throw se;
1:f44e479:         }
1:f44e479:     }
1:f44e479: 
1:f44e479:     public final PreparedStatement prepareStatement(
1:f44e479:             String sql,
1:f44e479:             String[] columnNames)
1:f44e479:             throws SQLException {
1:f44e479:         try {
1:f44e479:             return control.wrapStatement(getRealConnection().prepareStatement(
1:f44e479:                     sql, columnNames), sql, columnNames);
1:f44e479:         } catch (SQLException se) {
1:f44e479:             notifyException(se);
1:f44e479:             throw se;
1:f44e479:         }
1:f44e479:     }
1:f44e479: 
1:f44e479: 
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	MINIONS
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:1837822: 
1:ec60014:     /**
1:ec60014:      * Generate an exception reporting that there is no current connection.
1:ec60014:      * @return a no-current-connection exception
1:ec60014:      */
1:ec60014:     final SQLException noCurrentConnection() {
1:aa5c5de:         return ExceptionFactory.getInstance().getSQLException(
1:ec60014:                 SQLState.NO_CURRENT_CONNECTION, null, null, null);
1:ec60014:     }
1:ec60014: 
1:ec60014: 	/**
1:eac0369: 	  *	A little indirection for getting the real connection. 
1:6aa0b12: 	  *
1:eac0369: 	  *	@return	the current connection
1:ec60014: 	  */
1:da847a2: 	final EngineConnection getRealConnection() throws SQLException {
1:eac0369: 		if (isClosed)
1:ec60014: 			throw noCurrentConnection();
1:2658306: 
1:eac0369: 		return control.getRealConnection();
1:2658306: 	}
1:eac0369: 
1:5b2f5de: 	final void notifyException(SQLException sqle) {
1:92ee7b2: 		if (!isClosed)
1:92ee7b2: 			control.notifyException(sqle);
1:2658306: 	}
1:eac0369: 
1:6aa0b12: 	/**
1:eac0369: 		Sync up the state of the underlying connection
1:eac0369: 		with the state of this new handle.
1:6aa0b12: 	*/
1:eac0369: 	public void syncState() throws SQLException {
1:da847a2: 		EngineConnection conn = getRealConnection();
1:eac0369: 
1:eac0369: 		stateIsolationLevel = conn.getTransactionIsolation();
1:eac0369: 		stateReadOnly = conn.isReadOnly();
1:eac0369: 		stateAutoCommit = conn.getAutoCommit();
1:da847a2:         stateHoldability = conn.getHoldability(); 
1:1837822: 	}
1:eac0369: 
1:6aa0b12: 	/**
1:08cd3aa: 		Isolation level state in BrokeredConnection can get out of sync
1:08cd3aa: 		if the isolation is set using SQL rather than JDBC. In order to
1:08cd3aa: 		ensure correct state level information, this method is called
1:08cd3aa: 		at the start and end of a global transaction.
1:6aa0b12: 	*/
1:08cd3aa: 	public void getIsolationUptoDate() throws SQLException {
1:da847a2: 		if (control.isIsolationLevelSetUsingSQLorJDBC()) {
1:08cd3aa: 			stateIsolationLevel = getRealConnection().getTransactionIsolation();
1:08cd3aa: 			control.resetIsolationLevelFlag();
1:f578f07: 		}
1:08cd3aa: 	}
1:2658306: 	/**
1:eac0369: 		Set the state of the underlying connection according to the
1:eac0369: 		state of this connection's view of state.
1:eac0369: 
1:eac0369: 		@param complete If true set the complete state of the underlying
1:eac0369: 		Connection, otherwise set only the Connection related state (ie.
1:eac0369: 		the non-transaction specific state).
1:08cd3aa: 
1:eac0369: 
1:2658306: 	*/
1:eac0369: 	public void setState(boolean complete) throws SQLException {
1:eac0369: 
1:eac0369: 		if (complete) {
1:c7a1d17: 		    Connection conn = getRealConnection();
1:eac0369: 			conn.setTransactionIsolation(stateIsolationLevel);
1:eac0369: 			conn.setReadOnly(stateReadOnly);
1:eac0369: 			conn.setAutoCommit(stateAutoCommit);
1:f578f07: 			// make the underlying connection pick my holdability state
1:f578f07: 			// since holdability is a state of the connection handle
1:f578f07: 			// not the underlying transaction.
1:b16f770:             conn.setHoldability(stateHoldability);
1:f578f07: 		}
1:08cd3aa: 	}
1:eac0369: 
1:863daa0:     public final BrokeredStatement newBrokeredStatement(
1:863daa0:             BrokeredStatementControl statementControl) throws SQLException {
1:863daa0:         try {
1:863daa0:             return new BrokeredStatement(statementControl);
1:863daa0:         } catch (SQLException sqle) {
1:863daa0:             notifyException(sqle);
1:863daa0:             throw sqle;
1:863daa0:         }
1:863daa0:     }
1:f44e479: 
1:863daa0:     public BrokeredPreparedStatement newBrokeredStatement(
1:863daa0:             BrokeredStatementControl statementControl,
1:863daa0:             String sql, Object generatedKeys) throws SQLException {
1:863daa0:         try {
1:863daa0:             return new BrokeredPreparedStatement(statementControl, sql, generatedKeys);
1:863daa0:         } catch (SQLException sqle) {
1:863daa0:             notifyException(sqle);
1:863daa0:             throw sqle;
1:863daa0:         }
1:863daa0:     }
1:f44e479: 
1:863daa0:     public BrokeredCallableStatement newBrokeredStatement(
1:f44e479:             BrokeredStatementControl statementControl, String sql)
1:863daa0:             throws SQLException {
1:863daa0:         try {
1:863daa0:             return new BrokeredCallableStatement(statementControl, sql);
1:863daa0:         } catch (SQLException sqle) {
1:863daa0:             notifyException(sqle);
1:863daa0:             throw sqle;
1:863daa0:         }
1:863daa0:     }
1:eac0369: 
1:98ead91: 	/**
1:4383496: 	 *  set the DrdaId for this connection. The drdaID prints with the 
1:4383496: 	 *  statement text to the errror log
1:4383496: 	 *  @param drdaID  drdaID to be used for this connection
1:2658306: 	 *
1:1d2a569: 	 */
1:da847a2: 	public final void setDrdaID(String drdaID)
1:f578f07: 	{
1:f578f07:         try {
1:da847a2: 		    getRealConnection().setDrdaID(drdaID);
1:da847a2:         } catch (SQLException sqle)
1:f578f07:         {
1:da847a2:             // connection is closed, just ignore drdaId
1:da847a2:             // since connection cannot be used.
1:f44e479:         }
1:4383496: 	}
1:4383496: 
1:ad40eda:     /** @see EngineConnection#isInGlobalTransaction() */
1:ad40eda:     public boolean isInGlobalTransaction() {
1:ad40eda:     	return control.isInGlobalTransaction();
1:ad40eda:     }
1:ad40eda: 
1:1d2a569: 	/**
1:4383496: 	 *  Set the internal isolation level to use for preparing statements.
1:4383496: 	 *  Subsequent prepares will use this isoalation level
1:4383496: 	 * @param level - internal isolation level 
1:4383496: 	 * @throws SQLException
1:6b50965: 	 * See EmbedConnection#setPrepareIsolation
1:d8a1a68: 	 * 
1:4383496: 	 */
1:da847a2: 	public final void setPrepareIsolation(int level) throws SQLException
1:4383496: 	{
1:da847a2:         getRealConnection().setPrepareIsolation(level);
1:4383496: 	}
1:4383496: 
1:4383496: 	/**
1:4383496: 	 * get the isolation level that is currently being used to prepare 
1:4383496: 	 * statements (used for network server)
1:1d2a569: 	 * 
1:4383496: 	 * @throws SQLException
1:4383496: 	 * @return current prepare isolation level 
1:6b50965: 	 * See EmbedConnection#getPrepareIsolation
1:4383496: 	 */
1:da847a2: 	public final int getPrepareIsolation() throws SQLException
1:4383496: 	{
1:da847a2: 		return getRealConnection().getPrepareIsolation();
1:4383496: 	}
1:4383496:     
1:4383496:     /**
1:1128268:      * Add a SQLWarning to this Connection object.
1:1128268:      * @throws SQLException 
1:1128268:      */
1:1128268:     public final void addWarning(SQLWarning w) throws SQLException
1:4383496:     {
1:1128268:         getRealConnection().addWarning(w);
1:1128268:     }
1:eac0369: 
1:da847a2:     /**
1:e214c07:      * Get the string representation for this connection.  Return
1:e214c07:      * the class name/hash code and various debug information.
1:1d2a569:      * 
1:e214c07:      * @return unique string representation for this connection
1:da847a2:      */
1:1d2a569:     public String toString() 
1:1d2a569:     {
1:e214c07:         if ( connString == null )
1:1d2a569:         {
1:e214c07:             String wrappedString;
1:1d2a569:             try
1:1128268:             {
1:e214c07:                 wrappedString = getRealConnection().toString();
1:1d2a569:             }
1:1d2a569:             catch ( SQLException e )
1:1d2a569:             {
1:e214c07:                 wrappedString = "<none>";
1:1d2a569:             }
1:eac0369:             
1:e214c07:             connString = this.getClass().getName() + "@" + this.hashCode() +
1:e214c07:                 ", Wrapped Connection = " + wrappedString;
1:1d2a569:         }
1:eac0369:         
1:e214c07:         return connString;
1:da847a2:     }
1:eac0369: 
1:ce9d214:     /*
1:863daa0:      * JDBC 3.0 methods.
1:eac0369:      */
1:eac0369:     
1:08cd3aa:     /**
1:da847a2:      * Prepare statement with explicit holdability.
1:da847a2:      */
1:da847a2:     public final PreparedStatement prepareStatement(String sql,
1:da847a2:             int resultSetType, int resultSetConcurrency,
1:da847a2:             int resultSetHoldability) throws SQLException {
1:f578f07:     	try {
1:ce9d214:             resultSetHoldability = statementHoldabilityCheck(resultSetHoldability);
1:ce9d214:     		
1:da847a2:     		return control.wrapStatement(
1:ce9d214:     			getRealConnection().prepareStatement(sql, resultSetType,
1:ce9d214:                         resultSetConcurrency, resultSetHoldability), sql, null);
1:da847a2:     	}
1:da847a2:     	catch (SQLException se)
1:da847a2:     	{
1:da847a2:     		notifyException(se);
1:da847a2:     		throw se;
1:da847a2:     	}
1:da847a2:     }
1:da847a2: 
1:da847a2:     /**
1:da847a2:      * Get the holdability for statements created by this connection
1:da847a2:      * when holdability is not passed in.
1:da847a2:      */
1:da847a2:     public final int getHoldability() throws SQLException {
1:da847a2:     	try {
1:da847a2:     		return getRealConnection().getHoldability();
1:da847a2:     	}
1:da847a2:     	catch (SQLException se)
1:da847a2:     	{
1:da847a2:     		notifyException(se);
1:da847a2:     		throw se;
1:da847a2:     	}
1:da847a2:     }
1:eac0369: 
1:863daa0:     // JDBC 4.0 methods
1:863daa0: 
1:863daa0:     public final Array createArrayOf(String typeName, Object[] elements)
1:863daa0:             throws SQLException {
1:863daa0:         try {
1:863daa0:             return getRealConnection().createArrayOf(typeName, elements);
1:863daa0:         } catch (SQLException sqle) {
1:863daa0:             notifyException(sqle);
1:863daa0:             throw sqle;
1:863daa0:         }
1:863daa0:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      *
1:863daa0:      * Constructs an object that implements the {@code Blob} interface. The
1:863daa0:      * object returned initially contains no data. The {@code setBinaryStream}
1:863daa0:      * and {@code setBytes} methods of the {@code Blob} interface may be used to
1:863daa0:      * add data to the {@code Blob}.
1:863daa0:      *
1:863daa0:      * @return An object that implements the {@code Blob} interface
1:863daa0:      * @throws SQLException if an object that implements the {@code Blob}
1:863daa0:      * interface can not be constructed, this method is called on a closed
1:863daa0:      * connection or a database access error occurs.
1:863daa0:      *
1:863daa0:      */
1:863daa0:     public final Blob createBlob() throws SQLException {
1:863daa0:         // Forward the createBlob call to the physical connection
1:863daa0:         try {
1:863daa0:             return getRealConnection().createBlob();
1:863daa0:         } catch (SQLException sqle) {
1:863daa0:             notifyException(sqle);
1:863daa0:             throw sqle;
1:863daa0:         }
1:863daa0:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      *
1:863daa0:      * Constructs an object that implements the {@code Clob} interface. The
1:863daa0:      * object returned initially contains no data. The {@code setAsciiStream},
1:863daa0:      * {@code setCharacterStream} and {@code setString} methods of the
1:863daa0:      * {@code Clob} interface may be used to add data to the {@code Clob}.
1:863daa0:      *
1:863daa0:      * @return An object that implements the {@code Clob} interface
1:863daa0:      * @throws SQLException if an object that implements the {@code Clob}
1:863daa0:      * interface can not be constructed, this method is called on a closed
1:863daa0:      * connection or a database access error occurs.
1:863daa0:      *
1:863daa0:      */
1:863daa0:     public final Clob createClob() throws SQLException {
1:863daa0:         // Forward the createClob call to the physical connection
1:863daa0:         try {
1:863daa0:             return getRealConnection().createClob();
1:863daa0:         } catch (SQLException sqle) {
1:863daa0:             notifyException(sqle);
1:863daa0:             throw sqle;
1:863daa0:         }
1:863daa0:     }
1:863daa0: 
1:863daa0:     public final NClob createNClob() throws SQLException {
1:863daa0:         try {
1:863daa0:             return getRealConnection().createNClob();
1:863daa0:         } catch (SQLException sqle) {
1:863daa0:             notifyException(sqle);
1:863daa0:             throw sqle;
1:863daa0:         }
1:863daa0:     }
1:863daa0: 
1:863daa0:     public final SQLXML createSQLXML() throws SQLException {
1:863daa0:         try {
1:863daa0:             return getRealConnection().createSQLXML();
1:863daa0:         } catch (SQLException sqle) {
1:863daa0:             notifyException(sqle);
1:863daa0:             throw sqle;
1:863daa0:         }
1:863daa0:     }
1:863daa0: 
1:863daa0:     public final Struct createStruct(String typeName, Object[] attributes)
1:863daa0:             throws SQLException {
1:863daa0:         try {
1:863daa0:             return getRealConnection().createStruct(typeName, attributes);
1:863daa0:         } catch (SQLException sqle) {
1:863daa0:             notifyException(sqle);
1:863daa0:             throw sqle;
1:863daa0:         }
1:863daa0:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      * Checks if the connection has not been closed and is still valid. The
1:863daa0:      * validity is checked by running a simple query against the database.
1:863daa0:      *
1:863daa0:      * @param timeout The time in seconds to wait for the database operation
1:863daa0:      * used to validate the connection to complete. If the timeout period
1:863daa0:      * expires before the operation completes, this method returns false. A
1:863daa0:      * value of 0 indicates a timeout is not applied to the database operation.
1:863daa0:      * @return true if the connection is valid, false otherwise
1:863daa0:      * @throws SQLException if the call on the physical connection throws an
1:863daa0:      * exception.
1:863daa0:      */
1:863daa0:     public final boolean isValid(int timeout) throws SQLException {
1:863daa0:         // Check first if the Brokered connection is closed
1:863daa0:         if (isClosed()) {
1:863daa0:             return false;
1:863daa0:         }
1:863daa0: 
1:863daa0:         // Forward the isValid call to the physical connection
1:863daa0:         try {
1:863daa0:             return getRealConnection().isValid(timeout);
1:863daa0:         } catch (SQLException sqle) {
1:863daa0:             notifyException(sqle);
1:863daa0:             throw sqle;
1:863daa0:         }
1:863daa0:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      * {@code setClientInfo} forwards to the real connection.
1:863daa0:      *
1:863daa0:      * @param name the property key {@code String}
1:863daa0:      * @param value the property value {@code String}
1:863daa0:      * @exception SQLClientInfoException if the property is not supported or the
1:863daa0:      * real connection could not be obtained.
1:863daa0:      */
1:863daa0:     public final void setClientInfo(String name, String value)
1:863daa0:             throws SQLClientInfoException {
1:863daa0:         try {
1:863daa0:             getRealConnection().setClientInfo(name, value);
1:863daa0:         } catch (SQLClientInfoException se) {
1:863daa0:             notifyException(se);
1:863daa0:             throw se;
1:863daa0:         } catch (SQLException se) {
1:863daa0:             notifyException(se);
1:863daa0:             throw new SQLClientInfoException(se.getMessage(), se.getSQLState(),
1:863daa0:                     se.getErrorCode(),
1:863daa0:                     new FailedProperties40(
1:863daa0:                         FailedProperties40.makeProperties(name, value))
1:863daa0:                             .getProperties());
1:863daa0:         }
1:863daa0:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      * {@code setClientInfo} forwards to the real connection. If the call to
1:863daa0:      * {@code getRealConnection} fails the resulting {@code SQLException} is
1:863daa0:      * wrapped in a {@code SQLClientInfoException} to satisfy the specified
1:863daa0:      * signature.
1:863daa0:      *
1:863daa0:      * @param properties a {@code Properties} object with the properties to set.
1:863daa0:      * @exception SQLClientInfoException if the properties are not supported or
1:863daa0:      * the real connection could not be obtained.
1:863daa0:      */
1:863daa0:     public final void setClientInfo(Properties properties)
1:863daa0:             throws SQLClientInfoException {
1:863daa0:         try {
1:863daa0:             getRealConnection().setClientInfo(properties);
1:863daa0:         } catch (SQLClientInfoException cie) {
1:863daa0:             notifyException(cie);
1:863daa0:             throw cie;
1:863daa0:         } catch (SQLException se) {
1:863daa0:             notifyException(se);
1:863daa0:             throw new SQLClientInfoException(se.getMessage(), se.getSQLState(),
1:863daa0:                     se.getErrorCode(),
1:863daa0:                     (new FailedProperties40(properties)).getProperties());
1:863daa0:         }
1:863daa0:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      * {@code getClientInfo} forwards to the real connection.
1:863daa0:      *
1:863daa0:      * @param name a {@code String} that is the property key to get.
1:863daa0:      * @return a {@code String} that is returned from the real connection.
1:863daa0:      * @exception SQLException if a database access error occurs.
1:863daa0:      */
1:863daa0:     public final String getClientInfo(String name)
1:863daa0:             throws SQLException {
1:863daa0:         try {
1:863daa0:             return getRealConnection().getClientInfo(name);
1:863daa0:         } catch (SQLException se) {
1:863daa0:             notifyException(se);
1:863daa0:             throw se;
1:863daa0:         }
1:863daa0:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      * {@code getClientInfo} forwards to the real connection.
1:863daa0:      *
1:863daa0:      * @return a {@code Properties} object from the real connection.
1:863daa0:      * @exception SQLException if a database access error occurs.
1:863daa0:      */
1:863daa0:     public final Properties getClientInfo()
1:863daa0:             throws SQLException {
1:863daa0:         try {
1:863daa0:             return getRealConnection().getClientInfo();
1:863daa0:         } catch (SQLException se) {
1:863daa0:             notifyException(se);
1:863daa0:             throw se;
1:863daa0:         }
1:863daa0:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      * Returns false unless {@code iface} is implemented.
1:863daa0:      *
1:863daa0:      * @param iface a Class defining an interface.
1:863daa0:      * @return true if this implements the interface or directly or indirectly
1:863daa0:      * wraps an object that does.
1:863daa0:      * @throws SQLException if an error occurs while determining
1:863daa0:      * whether this is a wrapper for an object with the given interface.
1:863daa0:      */
1:863daa0:     public final boolean isWrapperFor(Class<?> iface) throws SQLException {
1:863daa0:         try {
1:863daa0:             if (getRealConnection().isClosed()) {
1:863daa0:                 throw noCurrentConnection();
1:863daa0:             }
1:863daa0:             return iface.isInstance(this);
1:863daa0:         } catch (SQLException sqle) {
1:863daa0:             notifyException(sqle);
1:863daa0:             throw sqle;
1:863daa0:         }
1:863daa0:     }
1:863daa0: 
1:863daa0:     /**
1:863daa0:      * Returns {@code this} if this class implements the interface.
1:863daa0:      *
1:863daa0:      * @param iface a Class defining an interface
1:863daa0:      * @return an object that implements the interface
1:863daa0:      * @throws SQLException if no object if found that implements the
1:863daa0:      * interface
1:863daa0:      */
1:863daa0:     public final <T> T unwrap(Class<T> iface)
1:863daa0:             throws SQLException {
1:863daa0:         try {
1:863daa0:             if (getRealConnection().isClosed()) {
1:863daa0:                 throw noCurrentConnection();
1:863daa0:             }
1:863daa0:             // Derby does not implement non-standard methods on
1:863daa0:             // JDBC objects.
1:863daa0:             try {
1:863daa0:                 return iface.cast(this);
1:863daa0:             } catch (ClassCastException cce) {
1:863daa0:                 throw ExceptionFactory.getInstance().getSQLException(
1:863daa0:                         SQLState.UNABLE_TO_UNWRAP,
1:863daa0:                         (SQLException) null, (Throwable) null, iface);
1:863daa0:             }
1:863daa0:         } catch (SQLException sqle) {
1:863daa0:             notifyException(sqle);
1:863daa0:             throw sqle;
1:863daa0:         }
1:863daa0:     }
1:863daa0: 
1:eac0369:     /*
1:ce9d214:     ** Methods private to the class.
1:ce9d214:     */
1:ce9d214:     
1:ce9d214:     /**
1:ce9d214:      * Check the result set holdability when creating a statement
1:ce9d214:      * object. Section 16.1.3.1 of JDBC 4.0 (proposed final draft)
1:ce9d214:      * says the driver may change the holdabilty and add a SQLWarning
1:ce9d214:      * to the Connection object.
1:1d2a569:      * 
1:ce9d214:      * This work-in-progress implementation throws an exception
1:ce9d214:      * to match the old behaviour just as part of incremental development.
1:ce9d214:      */
1:ce9d214:     final int statementHoldabilityCheck(int resultSetHoldability)
1:ce9d214:         throws SQLException
1:ce9d214:     {
1:ce9d214:         int holdability = control.checkHoldCursors(resultSetHoldability, true);
1:1128268:         if (holdability != resultSetHoldability) {
1:1128268:             SQLWarning w =
1:e8aba82:                  SQLWarningFactory.newSQLWarning(SQLState.HOLDABLE_RESULT_SET_NOT_AVAILABLE);
1:1128268:             
1:1128268:             addWarning(w);
1:1128268:         }
1:ce9d214:         
1:ce9d214:         return holdability;
1:6aa0b12:         
1:ce9d214:     }
1:6aa0b12: 
1:6aa0b12: 	/**
1:d8a1a68: 	* Get the LOB reference corresponding to the locator.
1:6aa0b12: 	* @param key the integer that represents the LOB locator value.
1:6aa0b12: 	* @return the LOB Object corresponding to this locator.
1:6aa0b12: 	*/
1:d8a1a68: 	public Object getLOBMapping(int key) throws SQLException {
3:d8a1a68:             //Forward the methods implementation to the implementation in the
3:d8a1a68:             //underlying EmbedConnection object. 
1:d8a1a68:             return getRealConnection().getLOBMapping(key);
1:5fe468c: 	}
1:456b8a1: 
6:eac0369:     /**
1:c6c4d4d:      * Obtain the name of the current schema. Not part of the
1:c6c4d4d:      * java.sql.Connection interface, but is accessible through the
1:c6c4d4d:      * EngineConnection interface, so that the NetworkServer can get at the
1:c6c4d4d:      * current schema for piggy-backing
1:c6c4d4d:      * @return the current schema name
1:c6c4d4d:      * @throws java.sql.SQLException
1:eac0369:      */
1:c6c4d4d:     public String getCurrentSchemaName() throws SQLException {
1:eac0369:         try {
1:c6c4d4d:             return getRealConnection().getCurrentSchemaName();
1:eac0369:         }
1:c6c4d4d:         catch (SQLException se) {
1:c6c4d4d:             notifyException(se);
1:c6c4d4d:             throw se;
1:eac0369:         }
1:eac0369:     }
1:ce9d214: 
1:eac0369:     /**
1:98ead91:      * @see org.apache.derby.iapi.jdbc.EngineConnection
1:98ead91:      */
1:98ead91:     public void resetFromPool()
1:f44e479:             throws SQLException {
1:98ead91:         getRealConnection().resetFromPool();
1:ec60014:     }
1:ec60014: 
1:1837822:     ////////////////////////////////////////////////////////////////////
1:1837822:     //
1:1837822:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:1837822:     //
1:1837822:     ////////////////////////////////////////////////////////////////////
1:1837822: 
1:1837822:     /**
1:1837822:      * Get the name of the current schema.
1:1837822:      */
1:1837822:     public String   getSchema() throws SQLException
1:1837822:     {
1:1837822:     	try {
1:1837822:             return getRealConnection().getSchema();
1:1837822:     	}
1:1837822:     	catch (SQLException se)
1:1837822:     	{
1:1837822:     		notifyException(se);
1:1837822:     		throw se;
1:1837822:     	}
1:1837822:     }
1:1837822: 
1:1837822:     /**
1:1837822:      * Set the default schema for the Connection.
1:1837822:      */
1:1837822:     public void   setSchema(  String schemaName ) throws SQLException
1:1837822: 	{
1:1837822:     	try {
1:1837822:             getRealConnection().setSchema( schemaName );
1:1837822:     	}
1:1837822:     	catch (SQLException se)
1:1837822:     	{
1:1837822:     		notifyException(se);
1:1837822:     		throw se;
1:1837822:     	}
1:98ead91:     }
1:1837822: 
1:863daa0:     public void abort(Executor executor) throws SQLException {
1:863daa0:         if (!isClosed) {
1:863daa0:             ((EngineConnection) getRealConnection()).abort(executor);
1:863daa0:         }
1:863daa0:     }
1:863daa0: 
1:863daa0:     public int getNetworkTimeout() throws SQLException {
1:863daa0:         try {
1:863daa0:             return ((EngineConnection) getRealConnection()).getNetworkTimeout();
1:863daa0:         } catch (SQLException sqle) {
1:863daa0:             notifyException(sqle);
1:863daa0:             throw sqle;
1:863daa0:         }
1:863daa0:     }
1:863daa0: 
1:863daa0:     public void setNetworkTimeout(Executor executor, int milliseconds)
1:863daa0:             throws SQLException {
1:863daa0:         try {
1:863daa0:             ((EngineConnection) getRealConnection())
1:863daa0:                     .setNetworkTimeout(executor, milliseconds);
1:863daa0:         } catch (SQLException sqle) {
1:863daa0:             notifyException(sqle);
1:863daa0:             throw sqle;
1:863daa0:         }
1:863daa0:     }
1:863daa0: 
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:863daa0
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Array;
1: import java.sql.Blob;
1: import java.sql.Clob;
1: import java.sql.NClob;
1: import java.sql.SQLClientInfoException;
1: import java.sql.SQLXML;
1: import java.sql.Struct;
1: import java.util.Properties;
1: import java.util.concurrent.Executor;
/////////////////////////////////////////////////////////////////////////
1: public class BrokeredConnection implements EngineConnection
/////////////////////////////////////////////////////////////////////////
1:     public final BrokeredStatement newBrokeredStatement(
1:             BrokeredStatementControl statementControl) throws SQLException {
1:         try {
1:             return new BrokeredStatement(statementControl);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1:     public BrokeredPreparedStatement newBrokeredStatement(
1:             BrokeredStatementControl statementControl,
1:             String sql, Object generatedKeys) throws SQLException {
1:         try {
1:             return new BrokeredPreparedStatement(statementControl, sql, generatedKeys);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1:     public BrokeredCallableStatement newBrokeredStatement(
1:             throws SQLException {
1:         try {
1:             return new BrokeredCallableStatement(statementControl, sql);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * JDBC 3.0 methods.
/////////////////////////////////////////////////////////////////////////
1: 
1:     // JDBC 4.0 methods
1: 
1:     public final Array createArrayOf(String typeName, Object[] elements)
1:             throws SQLException {
1:         try {
1:             return getRealConnection().createArrayOf(typeName, elements);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     /**
1:      *
1:      * Constructs an object that implements the {@code Blob} interface. The
1:      * object returned initially contains no data. The {@code setBinaryStream}
1:      * and {@code setBytes} methods of the {@code Blob} interface may be used to
1:      * add data to the {@code Blob}.
1:      *
1:      * @return An object that implements the {@code Blob} interface
1:      * @throws SQLException if an object that implements the {@code Blob}
1:      * interface can not be constructed, this method is called on a closed
1:      * connection or a database access error occurs.
1:      *
1:      */
1:     public final Blob createBlob() throws SQLException {
1:         // Forward the createBlob call to the physical connection
1:         try {
1:             return getRealConnection().createBlob();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     /**
1:      *
1:      * Constructs an object that implements the {@code Clob} interface. The
1:      * object returned initially contains no data. The {@code setAsciiStream},
1:      * {@code setCharacterStream} and {@code setString} methods of the
1:      * {@code Clob} interface may be used to add data to the {@code Clob}.
1:      *
1:      * @return An object that implements the {@code Clob} interface
1:      * @throws SQLException if an object that implements the {@code Clob}
1:      * interface can not be constructed, this method is called on a closed
1:      * connection or a database access error occurs.
1:      *
1:      */
1:     public final Clob createClob() throws SQLException {
1:         // Forward the createClob call to the physical connection
1:         try {
1:             return getRealConnection().createClob();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     public final NClob createNClob() throws SQLException {
1:         try {
1:             return getRealConnection().createNClob();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     public final SQLXML createSQLXML() throws SQLException {
1:         try {
1:             return getRealConnection().createSQLXML();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     public final Struct createStruct(String typeName, Object[] attributes)
1:             throws SQLException {
1:         try {
1:             return getRealConnection().createStruct(typeName, attributes);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     /**
1:      * Checks if the connection has not been closed and is still valid. The
1:      * validity is checked by running a simple query against the database.
1:      *
1:      * @param timeout The time in seconds to wait for the database operation
1:      * used to validate the connection to complete. If the timeout period
1:      * expires before the operation completes, this method returns false. A
1:      * value of 0 indicates a timeout is not applied to the database operation.
1:      * @return true if the connection is valid, false otherwise
1:      * @throws SQLException if the call on the physical connection throws an
1:      * exception.
1:      */
1:     public final boolean isValid(int timeout) throws SQLException {
1:         // Check first if the Brokered connection is closed
1:         if (isClosed()) {
1:             return false;
1:         }
1: 
1:         // Forward the isValid call to the physical connection
1:         try {
1:             return getRealConnection().isValid(timeout);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     /**
1:      * {@code setClientInfo} forwards to the real connection.
1:      *
1:      * @param name the property key {@code String}
1:      * @param value the property value {@code String}
1:      * @exception SQLClientInfoException if the property is not supported or the
1:      * real connection could not be obtained.
1:      */
1:     public final void setClientInfo(String name, String value)
1:             throws SQLClientInfoException {
1:         try {
1:             getRealConnection().setClientInfo(name, value);
1:         } catch (SQLClientInfoException se) {
1:             notifyException(se);
1:             throw se;
1:         } catch (SQLException se) {
1:             notifyException(se);
1:             throw new SQLClientInfoException(se.getMessage(), se.getSQLState(),
1:                     se.getErrorCode(),
1:                     new FailedProperties40(
1:                         FailedProperties40.makeProperties(name, value))
1:                             .getProperties());
1:         }
1:     }
1: 
1:     /**
1:      * {@code setClientInfo} forwards to the real connection. If the call to
1:      * {@code getRealConnection} fails the resulting {@code SQLException} is
1:      * wrapped in a {@code SQLClientInfoException} to satisfy the specified
1:      * signature.
1:      *
1:      * @param properties a {@code Properties} object with the properties to set.
1:      * @exception SQLClientInfoException if the properties are not supported or
1:      * the real connection could not be obtained.
1:      */
1:     public final void setClientInfo(Properties properties)
1:             throws SQLClientInfoException {
1:         try {
1:             getRealConnection().setClientInfo(properties);
1:         } catch (SQLClientInfoException cie) {
1:             notifyException(cie);
1:             throw cie;
1:         } catch (SQLException se) {
1:             notifyException(se);
1:             throw new SQLClientInfoException(se.getMessage(), se.getSQLState(),
1:                     se.getErrorCode(),
1:                     (new FailedProperties40(properties)).getProperties());
1:         }
1:     }
1: 
1:     /**
1:      * {@code getClientInfo} forwards to the real connection.
1:      *
1:      * @param name a {@code String} that is the property key to get.
1:      * @return a {@code String} that is returned from the real connection.
1:      * @exception SQLException if a database access error occurs.
1:      */
1:     public final String getClientInfo(String name)
1:             throws SQLException {
1:         try {
1:             return getRealConnection().getClientInfo(name);
1:         } catch (SQLException se) {
1:             notifyException(se);
1:             throw se;
1:         }
1:     }
1: 
1:     /**
1:      * {@code getClientInfo} forwards to the real connection.
1:      *
1:      * @return a {@code Properties} object from the real connection.
1:      * @exception SQLException if a database access error occurs.
1:      */
1:     public final Properties getClientInfo()
1:             throws SQLException {
1:         try {
1:             return getRealConnection().getClientInfo();
1:         } catch (SQLException se) {
1:             notifyException(se);
1:             throw se;
1:         }
1:     }
1: 
1:     /**
1:      * Returns false unless {@code iface} is implemented.
1:      *
1:      * @param iface a Class defining an interface.
1:      * @return true if this implements the interface or directly or indirectly
1:      * wraps an object that does.
1:      * @throws SQLException if an error occurs while determining
1:      * whether this is a wrapper for an object with the given interface.
1:      */
1:     public final boolean isWrapperFor(Class<?> iface) throws SQLException {
1:         try {
1:             if (getRealConnection().isClosed()) {
1:                 throw noCurrentConnection();
1:             }
1:             return iface.isInstance(this);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     /**
1:      * Returns {@code this} if this class implements the interface.
1:      *
1:      * @param iface a Class defining an interface
1:      * @return an object that implements the interface
1:      * @throws SQLException if no object if found that implements the
1:      * interface
1:      */
1:     public final <T> T unwrap(Class<T> iface)
1:             throws SQLException {
1:         try {
1:             if (getRealConnection().isClosed()) {
1:                 throw noCurrentConnection();
1:             }
1:             // Derby does not implement non-standard methods on
1:             // JDBC objects.
1:             try {
1:                 return iface.cast(this);
1:             } catch (ClassCastException cce) {
1:                 throw ExceptionFactory.getInstance().getSQLException(
1:                         SQLState.UNABLE_TO_UNWRAP,
1:                         (SQLException) null, (Throwable) null, iface);
1:             }
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void abort(Executor executor) throws SQLException {
1:         if (!isClosed) {
1:             ((EngineConnection) getRealConnection()).abort(executor);
1:         }
1:     }
1: 
1:     public int getNetworkTimeout() throws SQLException {
1:         try {
1:             return ((EngineConnection) getRealConnection()).getNetworkTimeout();
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
1:     public void setNetworkTimeout(Executor executor, int milliseconds)
1:             throws SQLException {
1:         try {
1:             ((EngineConnection) getRealConnection())
1:                     .setNetworkTimeout(executor, milliseconds);
1:         } catch (SQLException sqle) {
1:             notifyException(sqle);
1:             throw sqle;
1:         }
1:     }
1: 
commit:aa5c5de
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return ExceptionFactory.getInstance().getSQLException(
/////////////////////////////////////////////////////////////////////////
commit:6395944
/////////////////////////////////////////////////////////////////////////
commit:f44e479
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.Savepoint;
1: import java.sql.Statement;
/////////////////////////////////////////////////////////////////////////
0: public class BrokeredConnection implements EngineConnection
/////////////////////////////////////////////////////////////////////////
1:     // JDBC 2.0 methods
1: 
/////////////////////////////////////////////////////////////////////////
1:     // JDBC 3.0 methods
1: 
1:     public final Statement createStatement(int resultSetType,
1:             int resultSetConcurrency,
1:             int resultSetHoldability)
1:             throws SQLException {
1:         try {
1:             resultSetHoldability =
1:                     statementHoldabilityCheck(resultSetHoldability);
1:             return control.wrapStatement(
1:                     getRealConnection().createStatement(resultSetType,
1:                     resultSetConcurrency, resultSetHoldability));
1:         } catch (SQLException se) {
1:             notifyException(se);
1:             throw se;
1:         }
1:     }
1: 
1:     public final CallableStatement prepareCall(String sql,
1:             int resultSetType,
1:             int resultSetConcurrency,
1:             int resultSetHoldability)
1:             throws SQLException {
1:         try {
1:             resultSetHoldability =
1:                     statementHoldabilityCheck(resultSetHoldability);
1:             return control.wrapStatement(
1:                     getRealConnection().prepareCall(sql, resultSetType,
1:                     resultSetConcurrency, resultSetHoldability), sql);
1:         } catch (SQLException se) {
1:             notifyException(se);
1:             throw se;
1:         }
1:     }
1: 
1:     public final Savepoint setSavepoint()
1:             throws SQLException {
1:         try {
1:             control.checkSavepoint();
1:             return getRealConnection().setSavepoint();
1:         } catch (SQLException se) {
1:             notifyException(se);
1:             throw se;
1:         }
1:     }
1: 
1:     public final Savepoint setSavepoint(String name)
1:             throws SQLException {
1:         try {
1:             control.checkSavepoint();
1:             return getRealConnection().setSavepoint(name);
1:         } catch (SQLException se) {
1:             notifyException(se);
1:             throw se;
1:         }
1:     }
1: 
1:     public final void rollback(Savepoint savepoint)
1:             throws SQLException {
1:         try {
1:             control.checkRollback();
1:             getRealConnection().rollback(savepoint);
1:         } catch (SQLException se) {
1:             notifyException(se);
1:             throw se;
1:         }
1:     }
1: 
1:     public final void releaseSavepoint(Savepoint savepoint)
1:             throws SQLException {
1:         try {
1:             getRealConnection().releaseSavepoint(savepoint);
1:         } catch (SQLException se) {
1:             notifyException(se);
1:             throw se;
1:         }
1:     }
1: 
1:     public final void setHoldability(int holdability)
1:             throws SQLException {
1:         try {
1:             holdability = control.checkHoldCursors(holdability, false);
1:             getRealConnection().setHoldability(holdability);
1:             stateHoldability = holdability;
1:         } catch (SQLException se) {
1:             notifyException(se);
1:             throw se;
1:         }
1:     }
1: 
1:     public final PreparedStatement prepareStatement(
1:             String sql,
1:             int autoGeneratedKeys)
1:             throws SQLException {
1:         try {
1:             return control.wrapStatement(getRealConnection().prepareStatement(
1:                 sql, autoGeneratedKeys), sql, autoGeneratedKeys);
1:         } catch (SQLException se) {
1:             notifyException(se);
1:             throw se;
1:         }
1:     }
1: 
1:     public final PreparedStatement prepareStatement(
1:             String sql,
1:             int[] columnIndexes)
1:             throws SQLException {
1:         try {
1:             return control.wrapStatement(getRealConnection().prepareStatement(
1:                     sql, columnIndexes), sql, columnIndexes);
1:         } catch (SQLException se) {
1:             notifyException(se);
1:             throw se;
1:         }
1:     }
1: 
1:     public final PreparedStatement prepareStatement(
1:             String sql,
1:             String[] columnNames)
1:             throws SQLException {
1:         try {
1:             return control.wrapStatement(getRealConnection().prepareStatement(
1:                     sql, columnNames), sql, columnNames);
1:         } catch (SQLException se) {
1:             notifyException(se);
1:             throw se;
1:         }
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     public BrokeredPreparedStatement newBrokeredStatement(
0:             BrokeredStatementControl statementControl, String sql,
0:             Object generatedKeys) throws SQLException {
0:         return new BrokeredPreparedStatement(
0:                 statementControl, sql, generatedKeys);
1:     }
1: 
0:     public BrokeredCallableStatement newBrokeredStatement(
1:             BrokeredStatementControl statementControl, String sql)
1:             throws SQLException {
0:         return new BrokeredCallableStatement(statementControl, sql);
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
commit:850aba4
/////////////////////////////////////////////////////////////////////////
1:     public java.util.Map<String, Class<?>> getTypeMap() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:     public final void setTypeMap(java.util.Map<String, Class<?>> map) throws SQLException
commit:ec60014
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     /** Exception factory for the underlying connection. */
0:     private final ExceptionFactory exceptionFactory;
1: 
/////////////////////////////////////////////////////////////////////////
1:             throws SQLException
0:         this.exceptionFactory =
0:                 control.getRealConnection().getExceptionFactory();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Generate an exception reporting that there is no current connection.
1:      * @return a no-current-connection exception
1:      */
1:     final SQLException noCurrentConnection() {
0:         return exceptionFactory.getSQLException(
1:                 SQLState.NO_CURRENT_CONNECTION, null, null, null);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 			throw noCurrentConnection();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Return the exception factory for the underlying connection.
1:      */
0:     public final ExceptionFactory getExceptionFactory() {
0:         return exceptionFactory;
1:     }
commit:b16f770
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             conn.setHoldability(stateHoldability);
commit:c7a1d17
/////////////////////////////////////////////////////////////////////////
1: 		    Connection conn = getRealConnection();
/////////////////////////////////////////////////////////////////////////
0: 		        Class[] CONN_PARAM = { Integer.TYPE };
0: 		        Object[] CONN_ARG = { new Integer(stateHoldability)};
commit:902041a
/////////////////////////////////////////////////////////////////////////
1:             control.checkClose();
1: 
commit:5fe468c
/////////////////////////////////////////////////////////////////////////
0: 	public int addLOBMapping(Object LOBReference) {
0: 		//This call is forwarded to the implementation in the EmbedConnection
0: 		//class and hence the actual implementation here is not necessary.
0: 		return -1;
1: 	}
0: 	public void clearLOBMapping() {
0: 		//This call is forwarded to the implementation in the EmbedConnection
0: 		//class and hence the actual implementation here is not necessary.
1: 	}
0: 	public Object getLOBMapping(int key) {
0: 		//This call is forwarded to the implementation in the EmbedConnection
0: 		//class and hence the actual implementation here is not necessary.
0: 		return null;
1: 	}
commit:6aa0b12
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	* Dummy implementation for method in EngineConnection.
1:         *
0: 	* @param LOBReference The object which contains the LOB object that
0: 	*                     that is added to the HashMap.
0: 	* @return an integer that represents the locator that has been
0: 	*         allocated to this LOB.
1: 	*/
0: 	public int addLOBMapping(Object LOBReference) { return -1;}
1: 
1: 	/**
0: 	* Dummy implementation for method in EngineConnection.
1: 	*/
0: 	public void clearLOBMapping() {}
1: 
1: 	/**
0: 	* Dummy implementation for method in EngineConnection.
1: 	* @param key the integer that represents the LOB locator value.
1: 	* @return the LOB Object corresponding to this locator.
1: 	*/
0: 	public Object getLOBMapping(int key) { return null;}
commit:2658306
/////////////////////////////////////////////////////////////////////////
0:      * Checks if the connection is closed and throws an exception if
0:      * it is.
1:      *
0:      * @exception SQLException if the connection is closed
1:      */
0:     protected final void checkIfClosed() throws SQLException {
0:         if (isClosed()) {
0:             throw Util.noCurrentConnection();
1:         }
1:     }
1: 
1:     /**
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:eec86ed
/////////////////////////////////////////////////////////////////////////
0: public abstract class BrokeredConnection implements EngineConnection
/////////////////////////////////////////////////////////////////////////
0: 	public abstract BrokeredStatement newBrokeredStatement(BrokeredStatementControl statementControl) throws SQLException;
0:     public abstract BrokeredPreparedStatement newBrokeredStatement(
0:             Object generatedKeys) throws SQLException;
0:     public abstract BrokeredCallableStatement newBrokeredStatement(
0:         throws SQLException;
commit:1837822
/////////////////////////////////////////////////////////////////////////
1:     
1:     ////////////////////////////////////////////////////////////////////
1:     //
1:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:     //
1:     ////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Get the name of the current schema.
1:      */
1:     public String   getSchema() throws SQLException
1:     {
1:     	try {
1:             return getRealConnection().getSchema();
1:     	}
1:     	catch (SQLException se)
1:     	{
1:     		notifyException(se);
1:     		throw se;
1:     	}
1:     }
1: 
1:     /**
1:      * Set the default schema for the Connection.
1:      */
1:     public void   setSchema(  String schemaName ) throws SQLException
1: 	{
1:     	try {
1:             getRealConnection().setSchema( schemaName );
1:     	}
1:     	catch (SQLException se)
1:     	{
1:     		notifyException(se);
1:     		throw se;
1:     	}
1:     }
1:     
commit:f8cb3d7
/////////////////////////////////////////////////////////////////////////
1: 	protected boolean isClosed;
commit:d8a1a68
/////////////////////////////////////////////////////////////////////////
0: 	* Add the locator and the corresponding LOB object into the
0: 	* HashMap
1: 	*
0: 	public int addLOBMapping(Object LOBReference) throws SQLException {
1:             //Forward the methods implementation to the implementation in the
1:             //underlying EmbedConnection object. 
0:             return getRealConnection().addLOBMapping(LOBReference);
0: 	* Clear the HashMap of all entries.
0: 	* Called when a commit or rollback of the transaction
0: 	* happens.
0: 	public void clearLOBMapping() throws SQLException {
1:             //Forward the methods implementation to the implementation in the
1:             //underlying EmbedConnection object. 
0:             getRealConnection().clearLOBMapping();
1: 	* Get the LOB reference corresponding to the locator.
1: 	public Object getLOBMapping(int key) throws SQLException {
1:             //Forward the methods implementation to the implementation in the
1:             //underlying EmbedConnection object. 
1:             return getRealConnection().getLOBMapping(key);
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:ad40eda
/////////////////////////////////////////////////////////////////////////
1:     /** @see EngineConnection#isInGlobalTransaction() */
1:     public boolean isInGlobalTransaction() {
1:     	return control.isInGlobalTransaction();
1:     }
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:98ead91
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @see org.apache.derby.iapi.jdbc.EngineConnection
1:      */
1:     public void resetFromPool()
0:             throws SQLException {
1:         getRealConnection().resetFromPool();
1:     }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:3be5c9d
/////////////////////////////////////////////////////////////////////////
0: 		return new BrokeredStatement(statementControl);
/////////////////////////////////////////////////////////////////////////
commit:456b8a1
/////////////////////////////////////////////////////////////////////////
1:     
commit:f578f07
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.*;
1: 
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.iapi.error.PublicAPI;
0: import org.apache.derby.iapi.error.StandardException;
1: 
1: 	
1: 	// default for Derby
0: 	protected int stateHoldability = JDBC30Translation.HOLD_CURSORS_OVER_COMMIT;
/////////////////////////////////////////////////////////////////////////
0: 		// jdk13 does not have Connection.getHoldability method and hence using
0: 		// reflection to cover both jdk13 and higher jdks
1: 		try {
0: 			Method sh = conn.getClass().getMethod("getHoldability", null);
0: 			stateHoldability = ((Integer)sh.invoke(conn, null)).intValue();
0: 		} catch( Exception e)
1: 		{
0: 			throw PublicAPI.wrapStandardException( StandardException.plainWrapException( e));
1: 		}       
/////////////////////////////////////////////////////////////////////////
0: 		Class[] CONN_PARAM = { Integer.TYPE };
0: 		Object[] CONN_ARG = { new Integer(stateHoldability)};
/////////////////////////////////////////////////////////////////////////
1: 			// make the underlying connection pick my holdability state
1: 			// since holdability is a state of the connection handle
1: 			// not the underlying transaction.
0: 			// jdk13 does not have Connection.setHoldability method and hence using
0: 			// reflection to cover both jdk13 and higher jdks
1: 			try {
0: 				Method sh = conn.getClass().getMethod("setHoldability", CONN_PARAM);
0: 				sh.invoke(conn, CONN_ARG);
0: 			} catch( Exception e)
1: 			{
0: 				throw PublicAPI.wrapStandardException( StandardException.plainWrapException( e));
1: 			}
commit:1d2a569
/////////////////////////////////////////////////////////////////////////
1:             
1:     /**
0:      * Get the string representation for the underlying physical
0:      * connection.
1:      *
0:      *  When a physical connection is created, it is assigned a unique id 
0:      *  that is unchanged for the lifetime of the connection. When an 
0:      *  application calls Connection.toString(), it gets the string 
0:      *  representation of the underlying physical connection, regardless 
0:      *  of whether the application has a reference to the physical connection 
0:      *  itself or a reference to a proxy connection (aka brokered connection) 
0:      *  that wraps the physical connection.
1:      *
0:      *  Since this BrokeredConnection is a proxy connection, we return the
0:      *  string value of its underlying physical connection
1:      * 
0:      * @return unique string representation of the underlying
0:      *   physical connection
1:      */
1:     public String toString() 
1:     {
1:         try
1:         {
0:             return getRealConnection().toString();
1:         }
1:         catch ( SQLException e )
1:         {
0:             return "<no connection>";
1:         }
1:     }
commit:4383496
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 *  set the DrdaId for this connection. The drdaID prints with the 
1: 	 *  statement text to the errror log
1: 	 *  @param drdaID  drdaID to be used for this connection
0: 	 *
1: 	 */
0: 	public void setDrdaID(String drdaID)
1: 	{
0: 		control.setDrdaID(drdaID);
1: 	}
1: 
1: 	/**
1: 	 *  Set the internal isolation level to use for preparing statements.
1: 	 *  Subsequent prepares will use this isoalation level
1: 	 * @param level - internal isolation level 
1: 	 * @throws SQLException
0: 	 * @see EmbedConnection#setPrepareIsolation
0: 	 * 
1: 	 */
0: 	public void setPrepareIsolation(int level) throws SQLException
1: 	{
0: 		control.setPrepareIsolation(level);
1: 	}
1: 
1: 	/**
1: 	 * get the isolation level that is currently being used to prepare 
1: 	 * statements (used for network server)
0: 	 * 
1: 	 * @throws SQLException
1: 	 * @return current prepare isolation level 
0: 	 * @see EmbedConnection#getPrepareIsolation
1: 	 */
0: 	public int getPrepareIsolation() throws SQLException
1: 	{
0: 		return control.getPrepareIsolation();
1: 	}
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:e8aba82
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.SQLWarningFactory;
/////////////////////////////////////////////////////////////////////////
1:                  SQLWarningFactory.newSQLWarning(SQLState.HOLDABLE_RESULT_SET_NOT_AVAILABLE);
commit:1e8a20f
/////////////////////////////////////////////////////////////////////////
0: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	int stateHoldability = ResultSet.HOLD_CURSORS_OVER_COMMIT;
commit:df380db
/////////////////////////////////////////////////////////////////////////
0: public abstract class BrokeredConnection implements EngineConnection
/////////////////////////////////////////////////////////////////////////
0: 	public abstract BrokeredPreparedStatement
0:         newBrokeredStatement(BrokeredStatementControl statementControl,
0:                 String sql, Object generatedKeys) throws SQLException;
0: 	public abstract BrokeredCallableStatement
0:         newBrokeredStatement(BrokeredStatementControl statementControl,
0:                 String sql) throws SQLException;
commit:1128268
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.jdbc.EmbedSQLWarning;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Add a SQLWarning to this Connection object.
1:      * @throws SQLException 
1:      */
1:     public final void addWarning(SQLWarning w) throws SQLException
1:     {
1:         getRealConnection().addWarning(w);
1:     }
/////////////////////////////////////////////////////////////////////////
1:         if (holdability != resultSetHoldability) {
1:             SQLWarning w =
0:                  EmbedSQLWarning.newEmbedSQLWarning(SQLState.HOLDABLE_RESULT_SET_NOT_AVAILABLE);
1:             
1:             addWarning(w);
1:         }
commit:ce9d214
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:             resultSetHoldability = statementHoldabilityCheck(resultSetHoldability);
1:     		
1:     			getRealConnection().prepareStatement(sql, resultSetType,
1:                         resultSetConcurrency, resultSetHoldability), sql, null);
/////////////////////////////////////////////////////////////////////////
1:     
1:     /*
1:     ** Methods private to the class.
1:     */
1:     
1:     /**
1:      * Check the result set holdability when creating a statement
1:      * object. Section 16.1.3.1 of JDBC 4.0 (proposed final draft)
1:      * says the driver may change the holdabilty and add a SQLWarning
1:      * to the Connection object.
0:      * 
1:      * This work-in-progress implementation throws an exception
1:      * to match the old behaviour just as part of incremental development.
1:      */
1:     final int statementHoldabilityCheck(int resultSetHoldability)
1:         throws SQLException
1:     {
1:         int holdability = control.checkHoldCursors(resultSetHoldability, true);
0:         if (holdability != resultSetHoldability)
0:             throw Util.generateCsSQLException(SQLState.CANNOT_HOLD_CURSOR_XA);
1:         
1:         return holdability;
1:         
1:     }
commit:da847a2
/////////////////////////////////////////////////////////////////////////
0: public class BrokeredConnection implements EngineConnection
/////////////////////////////////////////////////////////////////////////
1: 	final EngineConnection getRealConnection() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 		EngineConnection conn = getRealConnection();
1:         stateHoldability = conn.getHoldability(); 
/////////////////////////////////////////////////////////////////////////
1: 		if (control.isIsolationLevelSetUsingSQLorJDBC()) {
/////////////////////////////////////////////////////////////////////////
1: 	public final void setDrdaID(String drdaID)
1:         try {
1: 		    getRealConnection().setDrdaID(drdaID);
1:         } catch (SQLException sqle)
1:         {
1:             // connection is closed, just ignore drdaId
1:             // since connection cannot be used.
1:         }
/////////////////////////////////////////////////////////////////////////
1: 	public final void setPrepareIsolation(int level) throws SQLException
1:         getRealConnection().setPrepareIsolation(level);
/////////////////////////////////////////////////////////////////////////
1: 	public final int getPrepareIsolation() throws SQLException
1: 		return getRealConnection().getPrepareIsolation();
/////////////////////////////////////////////////////////////////////////
1: 
1:     /*
0:      * JDBC 3.0 methods that are exposed through EngineConnection.
1:      */
1:     
1:     /**
1:      * Prepare statement with explicit holdability.
1:      */
1:     public final PreparedStatement prepareStatement(String sql,
1:             int resultSetType, int resultSetConcurrency,
1:             int resultSetHoldability) throws SQLException {
1:     	try {
0:     		control.checkHoldCursors(resultSetHoldability);
1:     		return control.wrapStatement(
0:     			getRealConnection().prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability), sql, null);
1:     	}
1:     	catch (SQLException se)
1:     	{
1:     		notifyException(se);
1:     		throw se;
1:     	}
1:     }
1: 
1:     /**
1:      * Get the holdability for statements created by this connection
1:      * when holdability is not passed in.
1:      */
1:     public final int getHoldability() throws SQLException {
1:     	try {
1:     		return getRealConnection().getHoldability();
1:     	}
1:     	catch (SQLException se)
1:     	{
1:     		notifyException(se);
1:     		throw se;
1:     	}
1:     }
commit:5b2f5de
/////////////////////////////////////////////////////////////////////////
0: 	int stateHoldability = JDBC30Translation.HOLD_CURSORS_OVER_COMMIT;
1: 	final BrokeredConnectionControl control;
/////////////////////////////////////////////////////////////////////////
0: 	final Connection getRealConnection() throws SQLException {
1: 	final void notifyException(SQLException sqle) {
/////////////////////////////////////////////////////////////////////////
0: 	int getJDBCLevel() { return 2;}
commit:08cd3aa
/////////////////////////////////////////////////////////////////////////
1: 		Isolation level state in BrokeredConnection can get out of sync
1: 		if the isolation is set using SQL rather than JDBC. In order to
1: 		ensure correct state level information, this method is called
1: 		at the start and end of a global transaction.
1: 	*/
1: 	public void getIsolationUptoDate() throws SQLException {
0: 		if (control!=null && control.isIsolationLevelSetUsingSQLorJDBC()) {
1: 			stateIsolationLevel = getRealConnection().getTransactionIsolation();
1: 			control.resetIsolationLevelFlag();
1: 		}
1: 	}
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.jdbc.BrokeredConnection
1: 
0:    Copyright 2002, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:bff3c2e
/////////////////////////////////////////////////////////////////////////
commit:92ee7b2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  * EVERYTHING to Connection.
/////////////////////////////////////////////////////////////////////////
0: 	protected final BrokeredConnectionControl control;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		if (!isClosed)
1: 			control.notifyException(sqle);
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.jdbc
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.jdbc;
1: 
0: import java.sql.Connection;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
1: import java.sql.CallableStatement;
1: import java.sql.DatabaseMetaData;
0: import java.sql.DriverManager;
1: import java.sql.SQLException;
1: import java.sql.SQLWarning;
1: 
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.impl.jdbc.Util;
1: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
1: 
1: /**
1:  * This is a rudimentary connection that delegates
0:  * EVERYTHING to Connection.  Its sole purpose is to
0:  * provide a way to replicate connections.  It has special
0:  * logic to reconstitute a connection on a server other
0:  * than where it was first run.
0:  *
0:  * @author jamie
1:  */
0: public class BrokeredConnection implements Connection
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
1: 
0: 	protected BrokeredConnectionControl control;
0: 	private boolean isClosed;
1: 
1: 	/**
1: 		Maintain state as seen by this Connection handle, not the state
1: 		of the underlying Connection it is attached to.
1: 	*/
1: 	private int stateIsolationLevel;
1: 	private boolean stateReadOnly;
1: 	private boolean stateAutoCommit;
1: 
1: 	/////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	CONSTRUCTORS
1: 	//
1: 	/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	 *	Public niladic constructor to satisfy Formatable interface.
1: 	 */
0: 	public	BrokeredConnection()
1: 	{
1: 	}
1: 
1: 	public	BrokeredConnection(BrokeredConnectionControl control)
1: 	{
1: 		this.control = control;
1: 	}
1: 
1: 	public final void setAutoCommit(boolean autoCommit) throws SQLException 
1: 	{
1: 		try {
1: 			control.checkAutoCommit(autoCommit);
1: 
1: 			getRealConnection().setAutoCommit(autoCommit);
1: 
1: 			stateAutoCommit = autoCommit;
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 	public final boolean getAutoCommit() throws SQLException 
1: 	{
1: 		try {
1: 			return getRealConnection().getAutoCommit();
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 	public final Statement createStatement() throws SQLException 
1: 	{
1: 		try {
1: 			return control.wrapStatement(getRealConnection().createStatement());
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1: 	public final PreparedStatement prepareStatement(String sql)
1: 	    throws SQLException 
1: 	{
1: 		try {
1: 			return control.wrapStatement(getRealConnection().prepareStatement(sql), sql, null);
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1: 	public final CallableStatement prepareCall(String sql) throws SQLException 
1: 	{
1: 		try {
1: 			return control.wrapStatement(getRealConnection().prepareCall(sql), sql);
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1: 	public final String nativeSQL(String sql) throws SQLException
1: 	{
1: 		try {
1: 			return getRealConnection().nativeSQL(sql);
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1: 	public final void commit() throws SQLException 
1: 	{
1: 		try {
1: 			control.checkCommit();
1: 			getRealConnection().commit();
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1: 	public final void rollback() throws SQLException 
1: 	{
1: 		try {
1: 			control.checkRollback();
1: 			getRealConnection().rollback();
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1: 	public final void close() throws SQLException 
1: 	{ 
1: 		if (isClosed)
1: 			return;
1: 
1: 		try {
1: 			if (!control.closingConnection()) {
1: 				isClosed = true;
1: 				return;
1: 			}
1: 
1: 			isClosed = true;
1: 
1: 
1: 			getRealConnection().close();
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1: 	public final boolean isClosed() throws SQLException 
1: 	{
1: 		if (isClosed)
1: 			return true;
1: 		try {
1: 			boolean realIsClosed = getRealConnection().isClosed();
1: 			if (realIsClosed) {
1: 				control.closingConnection();
1: 				isClosed = true;
1: 			}
1: 			return realIsClosed;
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1: 	public final SQLWarning getWarnings() throws SQLException 
1: 	{
1: 		try {
1: 			return getRealConnection().getWarnings();
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1: 	public final void clearWarnings() throws SQLException 
1: 	{
1: 		try {
1: 			getRealConnection().clearWarnings();
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1: 	public final DatabaseMetaData getMetaData() throws SQLException 
1: 	{
1: 		try {
1: 			return getRealConnection().getMetaData();
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1: 	public final void setReadOnly(boolean readOnly) throws SQLException 
1: 	{
1: 		try {
1: 			getRealConnection().setReadOnly(readOnly);
1: 			stateReadOnly = readOnly;
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1: 	public final boolean isReadOnly() throws SQLException 
1: 	{
1: 		try {
1: 			return getRealConnection().isReadOnly();
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1: 	public final void setCatalog(String catalog) throws SQLException 
1: 	{
1: 		try {
1: 			getRealConnection().setCatalog(catalog);
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1: 	public final String getCatalog() throws SQLException 
1: 	{
1: 		try {
1: 			return getRealConnection().getCatalog();
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1: 	public final void setTransactionIsolation(int level) throws SQLException 
1: 	{
1: 		try {
1: 			getRealConnection().setTransactionIsolation(level);
1: 			stateIsolationLevel = level;
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1: 	public final int getTransactionIsolation() throws SQLException
1: 	{
1: 		try {
1: 			return getRealConnection().getTransactionIsolation();
1: 		} catch (SQLException sqle) {
1: 			notifyException(sqle);
1: 			throw sqle;
1: 		}
1: 	}
1: 
1:     public final Statement createStatement(int resultSetType, int resultSetConcurrency) 
1:       throws SQLException
1: 	{
1: 		try
1: 		{
1: 			return control.wrapStatement(getRealConnection().
1: 				createStatement(resultSetType, resultSetConcurrency));
1: 		}
1: 		catch (SQLException se)
1: 		{
1: 			notifyException(se);
1: 			throw se;
1: 		}
1: 	}
1: 
1: 
1: 	public final PreparedStatement prepareStatement(String sql, int resultSetType, 
1: 					int resultSetConcurrency)
1:        throws SQLException
1: 	{
1: 		try
1: 		{
1: 			return control.wrapStatement(getRealConnection().
1: 				prepareStatement(sql, resultSetType, resultSetConcurrency), sql, null);
1: 		}
1: 		catch (SQLException se)
1: 		{
1: 			notifyException(se);
1: 			throw se;
1: 		}
1: 	}
1: 
1:     public final CallableStatement prepareCall(String sql, int resultSetType, 
1: 				 int resultSetConcurrency) throws SQLException
1: 	{
1: 		try
1: 		{
1: 			return control.wrapStatement(getRealConnection().
1: 				prepareCall(sql, resultSetType, resultSetConcurrency), sql);
1: 		}
1: 		catch (SQLException se)
1: 		{
1: 			notifyException(se);
1: 			throw se;
1: 		}
1: 	}
1: 
0:     public final java.util.Map getTypeMap() throws SQLException
1: 	{
1: 		try
1: 		{
1: 			return getRealConnection().getTypeMap();
1: 		}
1: 		catch (SQLException se)
1: 		{
1: 			notifyException(se);
1: 			throw se;
1: 		}
1: 	}
1: 
0:     public final void setTypeMap(java.util.Map map) throws SQLException
1: 	{
1: 		try
1: 		{
1: 			getRealConnection().setTypeMap(map);
1: 		}
1: 		catch (SQLException se)
1: 		{
1: 			notifyException(se);
1: 			throw se;
1: 		}
1: 	}
1: 
1: 	/////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	MINIONS
1: 	//
1: 	/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	  *	A little indirection for getting the real connection. 
0: 	  *
1: 	  *	@return	the current connection
1: 	  */
0: 	protected final Connection getRealConnection() throws SQLException {
1: 		if (isClosed)
0: 			throw Util.noCurrentConnection();
1: 
1: 		return control.getRealConnection();
1: 	}
1: 
0: 	protected final void notifyException(SQLException sqle) {
0: 		control.notifyException(sqle);
1: 	}
1: 
1: 	/**
1: 		Sync up the state of the underlying connection
1: 		with the state of this new handle.
1: 	*/
1: 	public void syncState() throws SQLException {
0: 		Connection conn = getRealConnection();
1: 
1: 		stateIsolationLevel = conn.getTransactionIsolation();
1: 		stateReadOnly = conn.isReadOnly();
1: 		stateAutoCommit = conn.getAutoCommit();
1: 	}
1: 
1: 	/**
1: 		Set the state of the underlying connection according to the
1: 		state of this connection's view of state.
1: 
1: 		@param complete If true set the complete state of the underlying
1: 		Connection, otherwise set only the Connection related state (ie.
1: 		the non-transaction specific state).
1: 
1: 		
1: 	*/
1: 	public void setState(boolean complete) throws SQLException {
1: 
0: 		Connection conn = getRealConnection();
1: 
1: 		if (complete) {
1: 			conn.setTransactionIsolation(stateIsolationLevel);
1: 			conn.setReadOnly(stateReadOnly);
1: 			conn.setAutoCommit(stateAutoCommit);
1: 		}
1: 	}
1: 
0: 	public BrokeredStatement newBrokeredStatement(BrokeredStatementControl statementControl) throws SQLException {
0: 		return new BrokeredStatement(statementControl, getJDBCLevel());
1: 	}
0: 	public BrokeredPreparedStatement newBrokeredStatement(BrokeredStatementControl statementControl, String sql, Object generatedKeys) throws SQLException {
0: 		return new BrokeredPreparedStatement(statementControl, getJDBCLevel(), sql);
1: 	}
0: 	public BrokeredCallableStatement newBrokeredStatement(BrokeredStatementControl statementControl, String sql) throws SQLException {
0: 		return new BrokeredCallableStatement(statementControl, getJDBCLevel(), sql);
1: 	}
1: 
0: 	protected int getJDBCLevel() { return 2;}
1: }
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:c6c4d4d
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:      * Obtain the name of the current schema. Not part of the
1:      * java.sql.Connection interface, but is accessible through the
1:      * EngineConnection interface, so that the NetworkServer can get at the
1:      * current schema for piggy-backing
1:      * @return the current schema name
1:      * @throws java.sql.SQLException
0:      */
1:     public String getCurrentSchemaName() throws SQLException {
0:         try {
1:             return getRealConnection().getCurrentSchemaName();
0:         }
1:         catch (SQLException se) {
1:             notifyException(se);
1:             throw se;
0:         }
0:     }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * See EmbedConnection#setPrepareIsolation
/////////////////////////////////////////////////////////////////////////
1: 	 * See EmbedConnection#getPrepareIsolation
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:660d738
/////////////////////////////////////////////////////////////////////////
0:     public java.util.Map getTypeMap() throws SQLException
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Tomohito Nakayama
-------------------------------------------------------------------------------
commit:e214c07
/////////////////////////////////////////////////////////////////////////
1:         private String connString;
/////////////////////////////////////////////////////////////////////////
1:      * Get the string representation for this connection.  Return
1:      * the class name/hash code and various debug information.
1:      * @return unique string representation for this connection
1:         if ( connString == null )
1:             String wrappedString;
0:             try
0:             {
1:                 wrappedString = getRealConnection().toString();
0:             }
0:             catch ( SQLException e )
0:             {
1:                 wrappedString = "<none>";
0:             }
0:             
1:             connString = this.getClass().getName() + "@" + this.hashCode() +
1:                 ", Wrapped Connection = " + wrappedString;
0:         
1:         return connString;
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.jdbc
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.jdbc;
0: 
0: import java.sql.Connection;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
0: import java.sql.CallableStatement;
0: import java.sql.DatabaseMetaData;
0: import java.sql.DriverManager;
0: import java.sql.SQLException;
0: import java.sql.SQLWarning;
0: 
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.impl.jdbc.Util;
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: 
0: /**
0:  * This is a rudimentary connection that delegates
0:  * EVERYTHING to Connection.  Its sole purpose is to
0:  * provide a way to replicate connections.  It has special
0:  * logic to reconstitute a connection on a server other
0:  * than where it was first run.
0:  *
0:  * @author jamie
0:  */
0: public class BrokeredConnection implements Connection
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
0: 
0: 	protected BrokeredConnectionControl control;
0: 	private boolean isClosed;
0: 
0: 	/**
0: 		Maintain state as seen by this Connection handle, not the state
0: 		of the underlying Connection it is attached to.
0: 	*/
0: 	private int stateIsolationLevel;
0: 	private boolean stateReadOnly;
0: 	private boolean stateAutoCommit;
0: 
0: 	/////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	CONSTRUCTORS
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 *	Public niladic constructor to satisfy Formatable interface.
0: 	 */
0: 	public	BrokeredConnection()
0: 	{
0: 	}
0: 
0: 	public	BrokeredConnection(BrokeredConnectionControl control)
0: 	{
0: 		this.control = control;
0: 	}
0: 
0: 	public final void setAutoCommit(boolean autoCommit) throws SQLException 
0: 	{
0: 		try {
0: 			control.checkAutoCommit(autoCommit);
0: 
0: 			getRealConnection().setAutoCommit(autoCommit);
0: 
0: 			stateAutoCommit = autoCommit;
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 	public final boolean getAutoCommit() throws SQLException 
0: 	{
0: 		try {
0: 			return getRealConnection().getAutoCommit();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 	public final Statement createStatement() throws SQLException 
0: 	{
0: 		try {
0: 			return control.wrapStatement(getRealConnection().createStatement());
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0: 	public final PreparedStatement prepareStatement(String sql)
0: 	    throws SQLException 
0: 	{
0: 		try {
0: 			return control.wrapStatement(getRealConnection().prepareStatement(sql), sql, null);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0: 	public final CallableStatement prepareCall(String sql) throws SQLException 
0: 	{
0: 		try {
0: 			return control.wrapStatement(getRealConnection().prepareCall(sql), sql);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0: 	public final String nativeSQL(String sql) throws SQLException
0: 	{
0: 		try {
0: 			return getRealConnection().nativeSQL(sql);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0: 	public final void commit() throws SQLException 
0: 	{
0: 		try {
0: 			control.checkCommit();
0: 			getRealConnection().commit();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0: 	public final void rollback() throws SQLException 
0: 	{
0: 		try {
0: 			control.checkRollback();
0: 			getRealConnection().rollback();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0: 	public final void close() throws SQLException 
0: 	{ 
0: 		if (isClosed)
0: 			return;
0: 
0: 		try {
0: 			if (!control.closingConnection()) {
0: 				isClosed = true;
0: 				return;
0: 			}
0: 
0: 			isClosed = true;
0: 
0: 
0: 			getRealConnection().close();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0: 	public final boolean isClosed() throws SQLException 
0: 	{
0: 		if (isClosed)
0: 			return true;
0: 		try {
0: 			boolean realIsClosed = getRealConnection().isClosed();
0: 			if (realIsClosed) {
0: 				control.closingConnection();
0: 				isClosed = true;
0: 			}
0: 			return realIsClosed;
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0: 	public final SQLWarning getWarnings() throws SQLException 
0: 	{
0: 		try {
0: 			return getRealConnection().getWarnings();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0: 	public final void clearWarnings() throws SQLException 
0: 	{
0: 		try {
0: 			getRealConnection().clearWarnings();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0: 	public final DatabaseMetaData getMetaData() throws SQLException 
0: 	{
0: 		try {
0: 			return getRealConnection().getMetaData();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0: 	public final void setReadOnly(boolean readOnly) throws SQLException 
0: 	{
0: 		try {
0: 			getRealConnection().setReadOnly(readOnly);
0: 			stateReadOnly = readOnly;
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0: 	public final boolean isReadOnly() throws SQLException 
0: 	{
0: 		try {
0: 			return getRealConnection().isReadOnly();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0: 	public final void setCatalog(String catalog) throws SQLException 
0: 	{
0: 		try {
0: 			getRealConnection().setCatalog(catalog);
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0: 	public final String getCatalog() throws SQLException 
0: 	{
0: 		try {
0: 			return getRealConnection().getCatalog();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0: 	public final void setTransactionIsolation(int level) throws SQLException 
0: 	{
0: 		try {
0: 			getRealConnection().setTransactionIsolation(level);
0: 			stateIsolationLevel = level;
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0: 	public final int getTransactionIsolation() throws SQLException
0: 	{
0: 		try {
0: 			return getRealConnection().getTransactionIsolation();
0: 		} catch (SQLException sqle) {
0: 			notifyException(sqle);
0: 			throw sqle;
0: 		}
0: 	}
0: 
0:     public final Statement createStatement(int resultSetType, int resultSetConcurrency) 
0:       throws SQLException
0: 	{
0: 		try
0: 		{
0: 			return control.wrapStatement(getRealConnection().
0: 				createStatement(resultSetType, resultSetConcurrency));
0: 		}
0: 		catch (SQLException se)
0: 		{
0: 			notifyException(se);
0: 			throw se;
0: 		}
0: 	}
0: 
0: 
0: 	public final PreparedStatement prepareStatement(String sql, int resultSetType, 
0: 					int resultSetConcurrency)
0:        throws SQLException
0: 	{
0: 		try
0: 		{
0: 			return control.wrapStatement(getRealConnection().
0: 				prepareStatement(sql, resultSetType, resultSetConcurrency), sql, null);
0: 		}
0: 		catch (SQLException se)
0: 		{
0: 			notifyException(se);
0: 			throw se;
0: 		}
0: 	}
0: 
0:     public final CallableStatement prepareCall(String sql, int resultSetType, 
0: 				 int resultSetConcurrency) throws SQLException
0: 	{
0: 		try
0: 		{
0: 			return control.wrapStatement(getRealConnection().
0: 				prepareCall(sql, resultSetType, resultSetConcurrency), sql);
0: 		}
0: 		catch (SQLException se)
0: 		{
0: 			notifyException(se);
0: 			throw se;
0: 		}
0: 	}
0: 
0:     public final java.util.Map getTypeMap() throws SQLException
0: 	{
0: 		try
0: 		{
0: 			return getRealConnection().getTypeMap();
0: 		}
0: 		catch (SQLException se)
0: 		{
0: 			notifyException(se);
0: 			throw se;
0: 		}
0: 	}
0: 
0:     public final void setTypeMap(java.util.Map map) throws SQLException
0: 	{
0: 		try
0: 		{
0: 			getRealConnection().setTypeMap(map);
0: 		}
0: 		catch (SQLException se)
0: 		{
0: 			notifyException(se);
0: 			throw se;
0: 		}
0: 	}
0: 
0: 	/////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	MINIONS
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	  *	A little indirection for getting the real connection. 
0: 	  *
0: 	  *	@return	the current connection
0: 	  */
0: 	protected final Connection getRealConnection() throws SQLException {
0: 		if (isClosed)
0: 			throw Util.noCurrentConnection();
0: 
0: 		return control.getRealConnection();
0: 	}
0: 
0: 	protected final void notifyException(SQLException sqle) {
0: 		control.notifyException(sqle);
0: 	}
0: 
0: 	/**
0: 		Sync up the state of the underlying connection
0: 		with the state of this new handle.
0: 	*/
0: 	public void syncState() throws SQLException {
0: 		Connection conn = getRealConnection();
0: 
0: 		stateIsolationLevel = conn.getTransactionIsolation();
0: 		stateReadOnly = conn.isReadOnly();
0: 		stateAutoCommit = conn.getAutoCommit();
0: 	}
0: 
0: 	/**
0: 		Set the state of the underlying connection according to the
0: 		state of this connection's view of state.
0: 
0: 		@param complete If true set the complete state of the underlying
0: 		Connection, otherwise set only the Connection related state (ie.
0: 		the non-transaction specific state).
0: 
0: 		
0: 	*/
0: 	public void setState(boolean complete) throws SQLException {
0: 
0: 		Connection conn = getRealConnection();
0: 
0: 		if (complete) {
0: 			conn.setTransactionIsolation(stateIsolationLevel);
0: 			conn.setReadOnly(stateReadOnly);
0: 			conn.setAutoCommit(stateAutoCommit);
0: 		}
0: 	}
0: 
0: 	public BrokeredStatement newBrokeredStatement(BrokeredStatementControl statementControl) throws SQLException {
0: 		return new BrokeredStatement(statementControl, getJDBCLevel());
0: 	}
0: 	public BrokeredPreparedStatement newBrokeredStatement(BrokeredStatementControl statementControl, String sql, Object generatedKeys) throws SQLException {
0: 		return new BrokeredPreparedStatement(statementControl, getJDBCLevel(), sql);
0: 	}
0: 	public BrokeredCallableStatement newBrokeredStatement(BrokeredStatementControl statementControl, String sql) throws SQLException {
0: 		return new BrokeredCallableStatement(statementControl, getJDBCLevel(), sql);
0: 	}
0: 
0: 	protected int getJDBCLevel() { return 2;}
0: }
============================================================================