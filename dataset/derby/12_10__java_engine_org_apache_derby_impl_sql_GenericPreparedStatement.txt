1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.GenericPreparedStatement
1:7fc54b9: 
1:67c1c96:    Licensed to the Apache Software Foundation (ASF) under one or more
1:67c1c96:    contributor license agreements.  See the NOTICE file distributed with
1:67c1c96:    this work for additional information regarding copyright ownership.
1:67c1c96:    The ASF licenses this file to you under the Apache License, Version 2.0
1:67c1c96:    (the "License"); you may not use this file except in compliance with
1:67c1c96:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
7:eac0369:  */
40:eac0369: 
1:eac0369: package org.apache.derby.impl.sql;
1:eac0369: 
1:a0dbbd7: import java.security.PrivilegedAction;
1:a0dbbd7: import java.security.AccessController;
1:eac0369: import java.sql.SQLWarning;
1:801cf0d: import java.sql.Timestamp;
1:f542632: import java.util.ArrayList;
1:f542632: import java.util.Collections;
1:c45f5b1: import java.util.List;
1:801cf0d: import org.apache.derby.catalog.Dependable;
1:801cf0d: import org.apache.derby.catalog.DependableFinder;
1:801cf0d: import org.apache.derby.catalog.UUID;
1:801cf0d: import org.apache.derby.iapi.error.StandardException;
1:801cf0d: import org.apache.derby.iapi.reference.SQLState;
1:801cf0d: import org.apache.derby.iapi.services.cache.Cacheable;
1:801cf0d: import org.apache.derby.iapi.services.context.ContextManager;
1:801cf0d: import org.apache.derby.iapi.services.context.ContextService;
1:6cc0702: import org.apache.derby.iapi.services.io.ArrayUtil;
1:801cf0d: import org.apache.derby.iapi.services.loader.GeneratedClass;
1:56c1dc2: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:801cf0d: import org.apache.derby.iapi.services.monitor.Monitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:801cf0d: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1:801cf0d: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1:801cf0d: import org.apache.derby.iapi.sql.Activation;
1:801cf0d: import org.apache.derby.iapi.sql.ParameterValueSet;
1:801cf0d: import org.apache.derby.iapi.sql.PreparedStatement;
1:801cf0d: import org.apache.derby.iapi.sql.ResultDescription;
1:801cf0d: import org.apache.derby.iapi.sql.ResultSet;
1:801cf0d: import org.apache.derby.iapi.sql.Statement;
1:801cf0d: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:801cf0d: import org.apache.derby.iapi.sql.conn.StatementContext;
1:801cf0d: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:801cf0d: import org.apache.derby.iapi.sql.depend.Provider;
1:801cf0d: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:801cf0d: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
1:801cf0d: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:801cf0d: import org.apache.derby.iapi.sql.dictionary.StatementPermission;
1:801cf0d: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:801cf0d: import org.apache.derby.iapi.sql.execute.ExecCursorTableReference;
1:801cf0d: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1:801cf0d: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:6cc0702: import org.apache.derby.iapi.types.DataTypeUtilities;
1:801cf0d: import org.apache.derby.iapi.util.ByteArray;
1:801cf0d: import org.apache.derby.impl.sql.compile.CursorNode;
1:801cf0d: import org.apache.derby.impl.sql.compile.StatementNode;
1:eac0369: 
6:eac0369: /**
1:eac0369:  * Basic implementation of prepared statement.
1:eac0369:  * relies on implementation of ResultDescription and Statement that
1:eac0369:  * are also in this package.
1:eac0369:  * <p>
1:eac0369:  * These are both dependents (of the schema objects and prepared statements
1:eac0369:  * they depend on) and providers.  Prepared statements that are providers
1:eac0369:  * are cursors that end up being used in positioned delete and update
1:eac0369:  * statements (at present).
1:eac0369:  * <p>
1:eac0369:  * This is impl with the regular prepared statements; they will never
1:eac0369:  * have the cursor info fields set.
1:eac0369:  * <p>
1:eac0369:  * Stored prepared statements extend this implementation
5:eac0369:  *
1:eac0369:  */
1:eac0369: public class GenericPreparedStatement
1:eac0369: 	implements ExecPreparedStatement
12:eac0369: {
1:eac0369: 	///////////////////////////////////////////////
2:eac0369: 	//
1:eac0369: 	// WARNING: when adding members to this class, be
1:eac0369: 	// sure to do the right thing in getClone(): if
1:eac0369: 	// it is PreparedStatement specific like finished,
1:eac0369: 	// then it shouldn't be copied, but stuff like parameters 
1:eac0369: 	// must be copied.	
1:eac0369: 	//
1:eac0369: 	////////////////////////////////////////////////
1:e4caed2: 
1:eac0369: 	////////////////////////////////////////////////
1:eac0369: 	// STATE that is copied by getClone()
1:eac0369: 	////////////////////////////////////////////////
1:eac0369: 	public Statement statement;
1:eac0369: 	protected GeneratedClass activationClass; // satisfies Activation
1:eac0369: 	protected ResultDescription resultDesc;
1:eac0369: 	protected DataTypeDescriptor[] paramTypeDescriptors;
1:eac0369: 	private String			spsName;
1:eac0369: 	private SQLWarning		warnings;
1:eac0369: 
1:eac0369: 	//If the query node for this statement references SESSION schema tables, mark it so in the boolean below
2:eac0369: 	//This information will be used by EXECUTE STATEMENT if it is executing a statement that was created with NOCOMPILE. Because
2:eac0369: 	//of NOCOMPILE, we could not catch SESSION schema table reference by the statement at CREATE STATEMENT time. Need to catch
2:eac0369: 	//such statements at EXECUTE STATEMENT time when the query is getting compiled.
1:eac0369: 	//This information will also be used to decide if the statement should be cached or not. Any statement referencing SESSION
1:eac0369: 	//schema tables will not be cached.
1:eac0369: 	private boolean		referencesSessionSchema;
1:eac0369: 
1:eac0369: 	// fields used for cursors
1:eac0369: 	protected ExecCursorTableReference	targetTable; 
1:71c8e86:     protected List<String>           updateColumns;
1:eac0369: 	protected int 						updateMode;
1:eac0369: 
1:eac0369: 	protected ConstantAction	executionConstants;
1:eac0369: 	protected Object[]	savedObjects;
1:801cf0d:     protected List<StatementPermission> requiredPermissionsList;
1:eac0369: 
1:eac0369: 	// fields for dependency tracking
1:eac0369: 	protected String UUIDString;
1:eac0369: 	protected UUID   UUIDValue;
1:eac0369: 
1:eac0369: 	private boolean needsSavepoint;
1:eac0369: 
1:eac0369: 	private String execStmtName;
1:eac0369: 	private String execSchemaName;
1:eac0369: 	protected boolean isAtomic;
1:eac0369: 	protected String sourceTxt;
1:eac0369: 
1:eac0369: 	private int inUseCount;
1:eac0369: 
1:eac0369: 	// true if the statement is being compiled.
1:6995fff:     private boolean compilingStatement;
1:eac0369: 
1:3554916:     /** True if the statement was invalidated while it was being compiled. */
1:be1b5ea:     boolean invalidatedWhileCompiling;
1:eac0369: 
1:eac0369: 	////////////////////////////////////////////////
1:eac0369: 	// STATE that is not copied by getClone()
1:eac0369: 	////////////////////////////////////////////////
1:eac0369: 	// fields for run time stats
1:eac0369: 	protected long parseTime;
1:eac0369: 	protected long bindTime;
1:eac0369: 	protected long optimizeTime;
1:eac0369: 	protected long generateTime;
1:eac0369: 	protected long compileTime;
1:eac0369: 	protected Timestamp beginCompileTimestamp;
1:eac0369: 	protected Timestamp endCompileTimestamp;
1:eac0369: 
1:eac0369: 	//private boolean finished;
1:eac0369: 	protected boolean isValid;
1:eac0369: 	protected boolean spsAction;
1:eac0369: 
1:eac0369: 	// state for caching.
1:eac0369: 	/**
1:eac0369: 		If non-null then this object is the cacheable
1:eac0369: 		that holds us in the cache.
1:eac0369: 	*/
1:eac0369: 	private Cacheable cacheHolder;
1:eac0369: 
1:f9a0689:     /**
1:f9a0689:      * Incremented for each (re)compile.
1:f9a0689:      */
1:f9a0689:     private long versionCounter;
1:f9a0689: 
1:f542632:     /**
1:f542632:      * Holder for row counts and execution count. Used for determining
1:f542632:      * whether the statement should be recompiled.
1:f542632:      */
1:f542632:     private RowCountStatistics rowCountStats = new RowCountStatistics();
1:f542632: 
1:eac0369: 	//
1:eac0369: 	// constructors
1:eac0369: 	//
1:eac0369: 
1:d387dac: 	GenericPreparedStatement() {
1:eac0369: 		/* Get the UUID for this prepared statement */
1:eac0369: 		UUIDFactory uuidFactory = 
1:56c1dc2: 			getMonitor().getUUIDFactory();
1:eac0369: 
1:eac0369: 		UUIDValue = uuidFactory.createUUID();
1:eac0369: 		UUIDString = UUIDValue.toString();
1:eac0369: 		spsAction = false;
18:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 */
1:eac0369: 	public GenericPreparedStatement(Statement st)
1:a0dbbd7: 	{
1:eac0369: 		this();
1:eac0369: 
1:eac0369: 		statement = st;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// PreparedStatement interface
1:eac0369: 	//
1:eac0369: 	public synchronized boolean	upToDate()
2:eac0369: 		throws StandardException
1:a0dbbd7: 	{
1:6832893: 		return isUpToDate();
1:eac0369: 	}
1:eac0369: 
1:6832893:     /**
1:6832893:      * Check whether this statement is up to date and its generated class is
1:6832893:      * identical to the supplied class object.
1:6832893:      * @see ExecPreparedStatement#upToDate(GeneratedClass)
1:6832893:      */
1:6832893:     public synchronized boolean upToDate(GeneratedClass gc) {
1:6832893:         return (activationClass == gc) && isUpToDate();
1:6832893:     }
1:6832893: 
1:6832893:     /**
1:6832893:      * Unsynchronized helper method for {@link #upToDate()} and {@link
1:6832893:      * #upToDate(GeneratedClass)}. Checks whether this statement is up to date.
1:6832893:      *
1:6832893:      * @return {@code true} if this statement is up to date, {@code false}
1:6832893:      * otherwise
1:6832893:      */
1:6832893:     private boolean isUpToDate() {
1:6832893:         return isValid && (activationClass != null) && !compilingStatement;
1:6832893:     }
1:6832893: 
1:6995fff:     /** Check if this statement is currently being compiled. */
1:6995fff:     final synchronized boolean isCompiling() {
1:6995fff:         return compilingStatement;
1:6995fff:     }
1:6995fff: 
1:6995fff:     /**
1:6995fff:      * Signal that the statement is about to be compiled. This will block
1:6995fff:      * others from attempting to compile it.
1:6995fff:      */
1:6995fff:     final synchronized void beginCompiling() {
1:6995fff:         compilingStatement = true;
1:6995fff:         setActivationClass(null);
1:6995fff:     }
1:6995fff: 
1:6995fff:     /**
1:6995fff:      * Signal that we're done compiling the statement and unblock others
1:6995fff:      * that are waiting for the compilation to finish.
1:6995fff:      */
1:6995fff:     final synchronized void endCompiling() {
1:6995fff:         compilingStatement = false;
1:6995fff:         notifyAll();
1:6995fff:     }
1:6995fff: 
1:85132a2: 	public void rePrepare(LanguageConnectionContext lcc) 
1:eac0369: 		throws StandardException {
1:7b6ad6d:         rePrepare(lcc, false);
1:7b6ad6d:     }
1:7b6ad6d: 
1:7b6ad6d:     public void rePrepare(LanguageConnectionContext lcc, boolean forMetaData)
1:7b6ad6d:         throws StandardException {
1:08d2c15: 		if (!upToDate()) {
1:7b6ad6d:             PreparedStatement ps = statement.prepare(lcc, forMetaData);
1:7fc54b9: 
1:85132a2: 			if (SanityManager.DEBUG)
1:85132a2: 				SanityManager.ASSERT(ps == this, "ps != this");
1:85132a2: 		}
1:08d2c15: 	}
1:08d2c15: 
1:eac0369: 	/**
1:eac0369: 	 * Get a new activation instance.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if finished.
1:eac0369: 	 */
1:77603a1: 	public Activation getActivation(LanguageConnectionContext lcc,
1:77603a1: 									boolean scrollable)
1:77603a1: 		throws StandardException
1:eac0369: 	{
1:77603a1: 		Activation ac;
1:77603a1: 		synchronized (this) {
1:77603a1: 			GeneratedClass gc = getActivationClass();
1:eac0369: 
1:77603a1: 			if (gc == null) {
1:85132a2: 				rePrepare(lcc);
1:77603a1: 				gc = getActivationClass();
1:77603a1: 			}
1:77603a1: 
1:77603a1: 			ac = new GenericActivationHolder(lcc, gc, this, scrollable);
1:77603a1: 
1:77603a1: 			inUseCount++;
1:eac0369: 		}
1:77603a1: 		// DERBY-2689. Close unused activations-- this method should be called
1:77603a1: 		// when I'm not holding a lock on a prepared statement to avoid
1:77603a1: 		// deadlock.
1:77603a1: 		lcc.closeUnusedActivations();
1:99d7d8b: 
1:e3883f5: 		Activation parentAct = null;
1:6950a39: 		StatementContext stmctx = lcc.getStatementContext();
1:6950a39: 
1:6950a39: 		if (stmctx != null) {
1:e3883f5: 			// If not null, parentAct represents one of 1) the activation of a
1:e3883f5: 			// calling statement and this activation corresponds to a statement
1:e3883f5: 			// inside a stored procedure or function, and 2) the activation of
1:e3883f5: 			// a statement that performs a substatement, e.g. trigger body
1:e3883f5: 			// execution.
1:e3883f5: 			parentAct = stmctx.getActivation();
1:6950a39: 		}
1:6950a39: 
1:e3883f5: 		ac.setParentActivation(parentAct);
1:eac0369: 
1:eac0369: 		return ac;
1:3fcea8a: 	}
1:3fcea8a: 
1:e3883f5: 	/**
1:e3883f5: 	 * @see PreparedStatement#executeSubStatement(LanguageConnectionContext, boolean, long)
1:e3883f5: 	 */
1:e3883f5:     public ResultSet executeSubStatement(LanguageConnectionContext lcc,
1:e3883f5: 										 boolean rollbackParentContext,
1:e3883f5: 										 long timeoutMillis)
1:eac0369: 		throws StandardException
1:3fcea8a: 	{
1:e3883f5: 		Activation parent = lcc.getLastActivation();
1:eac0369: 		Activation a = getActivation(lcc, false);
1:eac0369: 		a.setSingleExecution();
1:e3883f5: 		lcc.setupSubStatementSessionContext(parent);
1:7b6ad6d:         return executeStmt(a, rollbackParentContext, false, timeoutMillis);
1:eac0369: 	}
1:eac0369: 
1:3fcea8a: 	/**
1:e3883f5: 	 * @see PreparedStatement#executeSubStatement(Activation, Activation, boolean, long)
1:e3883f5: 	 */
1:e3883f5:     public ResultSet executeSubStatement(Activation parent,
1:e3883f5: 										 Activation activation,
1:e3883f5: 										 boolean rollbackParentContext,
1:e3883f5: 										 long timeoutMillis)
1:e3883f5: 		throws StandardException
1:e3883f5: 	{
1:e3883f5: 		parent.getLanguageConnectionContext().
1:e3883f5: 			setupSubStatementSessionContext(parent);
1:7b6ad6d:         return executeStmt(activation, rollbackParentContext,
1:7b6ad6d:                            false, timeoutMillis);
1:e3883f5: 	}
1:e3883f5: 
1:e3883f5: 
1:e3883f5: 	/**
1:e3883f5: 	 * @see PreparedStatement#execute
1:e3883f5: 	 */
1:e3883f5: 	public ResultSet execute(Activation activation,
1:7b6ad6d:                              boolean forMetaData,
1:e3883f5: 							 long timeoutMillis)
1:e3883f5: 			throws StandardException
1:e3883f5: 	{
1:7b6ad6d:         return executeStmt(activation, false, forMetaData, timeoutMillis);
1:e3883f5: 	}
1:e3883f5: 
1:e3883f5: 
1:e3883f5: 	/**
1:eac0369: 	  *	The guts of execution.
1:3fcea8a: 	  *
1:eac0369: 	  *	@param	activation					the activation to run.
1:eac0369: 	  * @param rollbackParentContext True if 1) the statement context is
1:eac0369: 	  *  NOT a top-level context, AND 2) in the event of a statement-level
1:eac0369: 	  *	 exception, the parent context needs to be rolled back, too.
1:7b6ad6d:       * @param forMetaData true if this is a meta-data query
1:1373f5a:       * @param timeoutMillis timeout value in milliseconds.
1:eac0369: 	  *	@return	the result set to be pawed through
1:eac0369: 	  *
1:eac0369: 	  *	@exception	StandardException thrown on error
1:3fcea8a: 	  */
1:e3883f5:     private ResultSet executeStmt(Activation activation,
1:e3883f5: 								  boolean rollbackParentContext,
1:7b6ad6d:                                   boolean forMetaData,
1:e3883f5: 								  long timeoutMillis)
1:1373f5a:         throws
1:1373f5a:             StandardException 
1:eac0369: 	{
1:eac0369: 		boolean				needToClearSavePoint = false;
1:eac0369: 
1:eac0369: 		if (activation == null || activation.getPreparedStatement() != this)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_WRONG_ACTIVATION, "execute");
1:eac0369: 		}
1:eac0369: 
1:eac0369: recompileOutOfDatePlan:
1:eac0369: 		while (true) {
1:eac0369: 			// verify the activation is for me--somehow.  NOTE: This is
1:eac0369: 			// different from the above check for whether the activation is
1:eac0369: 			// associated with the right PreparedStatement - it's conceivable
1:eac0369: 			// that someone could construct an activation of the wrong type
1:eac0369: 			// that points to the right PreparedStatement.
1:eac0369: 			//
1:eac0369: 			//SanityManager.ASSERT(activation instanceof activationClass, "executing wrong activation");
1:eac0369: 
1:eac0369: 			/* This is where we set and clear savepoints around each individual
1:eac0369: 			 * statement which needs one.  We don't set savepoints for cursors because
1:eac0369: 			 * they're not needed and they wouldn't work in a read only database.
1:eac0369: 			 * We can't set savepoints for commit/rollback because they'll get
1:eac0369: 			 * blown away before we try to clear them.
1:eac0369: 			 */
1:eac0369: 
1:eac0369: 			LanguageConnectionContext lccToUse = activation.getLanguageConnectionContext();
1:eac0369: 
1:eac0369:  			if (lccToUse.getLogStatementText())
1:eac0369: 			{
1:eac0369: 				HeaderPrintWriter istream = Monitor.getStream();
1:eac0369: 				String xactId = lccToUse.getTransactionExecute().getActiveStateTxIdString();
1:eac0369: 				String pvsString = "";
1:eac0369: 				ParameterValueSet pvs = activation.getParameterValueSet();
1:eac0369: 				if (pvs != null && pvs.getParameterCount() > 0)
1:eac0369: 				{
1:eac0369: 					pvsString = " with " + pvs.getParameterCount() +
1:eac0369: 							" parameters " + pvs.toString();
1:eac0369: 				}
1:eac0369: 				istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
1:eac0369: 										  xactId + 
1:eac0369: 										  "), " +
1:eac0369: 										  LanguageConnectionContext.lccStr +
1:eac0369: 										  lccToUse.getInstanceNumber() +
1:eac0369: 										  "), " +
1:eac0369: 										  LanguageConnectionContext.dbnameStr +
1:eac0369: 										  lccToUse.getDbname() +
1:eac0369: 										  "), " +
1:eac0369: 										  LanguageConnectionContext.drdaStr +
1:eac0369: 										  lccToUse.getDrdaID() +
1:eac0369: 										  "), Executing prepared statement: " +
1:eac0369: 										  getSource() +
1:eac0369: 										  " :End prepared statement" +
1:eac0369: 										  pvsString);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			ParameterValueSet pvs = activation.getParameterValueSet();
1:eac0369: 
1:eac0369: 			/* put it in try block to unlock the PS in any case
1:eac0369: 			 */
1:851bcbb: 			if (!spsAction) {
1:851bcbb: 			// only re-prepare if this isn't an SPS for a trigger-action;
1:851bcbb: 			// if it _is_ an SPS for a trigger action, then we can't just
1:851bcbb: 			// do a regular prepare because the statement might contain
1:851bcbb: 			// internal SQL that isn't allowed in other statements (such as a
1:851bcbb: 			// static method call to get the trigger context for retrieval
1:851bcbb: 			// of "new row" or "old row" values).  So in that case we
1:851bcbb: 			// skip the call to 'rePrepare' and if the statement is out
1:851bcbb: 			// of date, we'll get a NEEDS_COMPILE exception when we try
1:851bcbb: 			// to execute.  That exception will be caught by the executeSPS()
1:851bcbb: 			// method of the GenericTriggerExecutor class, and at that time
1:851bcbb: 			// the SPS action will be recompiled correctly.
1:7b6ad6d:                 rePrepare(lccToUse, forMetaData);
1:eac0369: 			}
1:3554916: 
1:eac0369: 			StatementContext statementContext = lccToUse.pushStatementContext(
1:5087be8: 				isAtomic, updateMode==CursorNode.READ_ONLY, getSource(), pvs, rollbackParentContext, timeoutMillis);
1:3554916: 
1:6950a39: 			statementContext.setActivation(activation);
1:6950a39: 
1:eac0369: 			if (needsSavepoint())
1:eac0369: 			{
1:eac0369: 				/* Mark this position in the log so that a statement
1:eac0369: 				* rollback will undo any changes.
1:eac0369: 				*/
1:eac0369: 				statementContext.setSavePoint();
1:eac0369: 				needToClearSavePoint = true;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (executionConstants != null)
1:eac0369: 			{
1:eac0369: 				lccToUse.validateStmtExecution(executionConstants);
1:eac0369: 			}
1:eac0369: 
1:801cf0d:             ResultSet resultSet;
1:3554916: 			try {
1:eac0369: 	
1:eac0369: 				resultSet = activation.execute();
1:eac0369: 
1:eac0369: 				resultSet.open();
1:eac0369: 			} catch (StandardException se) {
1:eac0369: 				/* Cann't handle recompiling SPS action recompile here */
1:eac0369: 				if (!se.getMessageId().equals(SQLState.LANG_STATEMENT_NEEDS_RECOMPILE)
1:eac0369: 						 || spsAction)
1:eac0369: 					throw se;
1:eac0369: 				statementContext.cleanupOnError(se);
1:3554916: 				continue recompileOutOfDatePlan;
1:eac0369: 
1:eac0369: 			}
1:eac0369: 
1:eac0369: 
1:eac0369: 			if (needToClearSavePoint)
1:eac0369: 			{
1:eac0369: 				/* We're done with our updates */
1:eac0369: 				statementContext.clearSavePoint();
1:eac0369: 			}
1:eac0369: 
1:0c5bc3a:             lccToUse.popStatementContext(statementContext, null);
1:0c5bc3a: 
1:0c5bc3a:             if (activation.getSQLSessionContextForChildren() != null) {
1:0c5bc3a:                 lccToUse.popNestedSessionContext(activation);
1:0c5bc3a:             }
1:eac0369: 
1:eac0369: 			if (activation.isSingleExecution() && resultSet.isClosed())
1:eac0369: 			{
1:eac0369: 				// if the result set is 'done', i.e. not openable,
1:eac0369: 				// then we can also release the activation.
1:eac0369: 				// Note that a result set with output parameters 
1:eac0369: 				// or rows to return is explicitly finished 
1:eac0369: 				// by the user.
1:eac0369: 				activation.close();
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return resultSet;
1:eac0369: 			
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public ResultDescription	getResultDescription()	{
1:eac0369: 		return resultDesc;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public DataTypeDescriptor[]	getParameterTypes()	{
1:3f7581c:         return ArrayUtil.copy(paramTypeDescriptors);
1:eac0369: 	}
1:eac0369: 
1:6cc0702:     /** Return the type of the parameter (0-based indexing) */
1:6cc0702:     public DataTypeDescriptor  getParameterType( int idx ) throws StandardException
1:6cc0702:     {
1:6cc0702: 		if ( paramTypeDescriptors == null )
1:6cc0702:         {
1:6cc0702: 			throw StandardException.newException( SQLState.NO_INPUT_PARAMETERS );
1:6cc0702: 		}
1:6cc0702: 
1:6cc0702: 		/* Check that the parameterIndex is in range. */
1:6cc0702: 		if ( (idx < 0) || (idx >= paramTypeDescriptors.length) )
1:6cc0702:         {
1:6cc0702: 			/* This message matches the one used by the DBMS */
1:6cc0702: 			throw StandardException.newException
1:a0dbbd7:                 (
1:6cc0702:                  SQLState.LANG_INVALID_PARAM_POSITION, 
1:ce40a31:                  idx+1,
1:ce40a31:                  paramTypeDescriptors.length
1:a0dbbd7:                  );
1:a0dbbd7: 		}
1:6cc0702: 
1:6cc0702:         return paramTypeDescriptors[ idx ];
1:6cc0702:     }
1:6cc0702:     
1:6cc0702: 
1:eac0369: 	public String getSource() {
1:eac0369: 		return (sourceTxt != null) ?
1:eac0369: 			sourceTxt : 
1:eac0369: 			(statement == null) ? 
1:eac0369: 				"null" : 
1:eac0369: 				statement.getSource();
1:6cc0702: 	}
1:eac0369: 
1:eac0369: 	public void setSource(String text)
1:a0dbbd7: 	{
1:eac0369: 		sourceTxt = text;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final void setSPSName(String name) {
1:eac0369: 		spsName = name;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String getSPSName() {
1:eac0369: 		return spsName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the total compile time for the associated query in milliseconds.
1:eac0369: 	 * Compile time can be divided into parse, bind, optimize and generate times.
1:eac0369: 	 * 
1:eac0369: 	 * @return long		The total compile time for the associated query in milliseconds.
1:eac0369: 	 */
1:eac0369: 	public long getCompileTimeInMillis()
1:eac0369: 	{
1:eac0369: 		return compileTime;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the parse time for the associated query in milliseconds.
1:eac0369: 	 * 
1:eac0369: 	 * @return long		The parse time for the associated query in milliseconds.
1:eac0369: 	 */
1:eac0369: 	public long getParseTimeInMillis()
1:eac0369: 	{
1:eac0369: 		return parseTime;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the bind time for the associated query in milliseconds.
1:eac0369: 	 * 
1:eac0369: 	 * @return long		The bind time for the associated query in milliseconds.
1:eac0369: 	 */
1:eac0369: 	public long getBindTimeInMillis()
1:eac0369: 	{
1:eac0369: 		return bindTime;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the optimize time for the associated query in milliseconds.
1:eac0369: 	 * 
1:eac0369: 	 * @return long		The optimize time for the associated query in milliseconds.
1:eac0369: 	 */
1:eac0369: 	public long getOptimizeTimeInMillis()
1:eac0369: 	{
1:eac0369: 		return optimizeTime;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the generate time for the associated query in milliseconds.
1:eac0369: 	 * 
1:eac0369: 	 * @return long		The generate time for the associated query in milliseconds.
1:eac0369: 	 */
1:eac0369: 	public long getGenerateTimeInMillis()
1:eac0369: 	{
1:eac0369: 		return generateTime;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the timestamp for the beginning of compilation
1:eac0369: 	 *
1:eac0369: 	 * @return Timestamp	The timestamp for the beginning of compilation.
1:eac0369: 	 */
1:eac0369: 	public Timestamp getBeginCompileTimestamp()
1:eac0369: 	{
1:6cc0702: 		return DataTypeUtilities.clone( beginCompileTimestamp );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the timestamp for the end of compilation
1:eac0369: 	 *
1:eac0369: 	 * @return Timestamp	The timestamp for the end of compilation.
1:eac0369: 	 */
1:eac0369: 	public Timestamp getEndCompileTimestamp()
1:eac0369: 	{
1:6cc0702: 		return DataTypeUtilities.clone( endCompileTimestamp );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void setCompileTimeWarnings(SQLWarning warnings) {
1:eac0369: 		this.warnings = warnings;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final SQLWarning getCompileTimeWarnings() {
1:eac0369: 		return warnings;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the compile time for this prepared statement.
1:eac0369: 	 *
1:eac0369: 	 * @param compileTime	The compile time
1:eac0369: 	 */
1:eac0369: 	protected void setCompileTimeMillis(long parseTime, long bindTime,
1:eac0369: 										long optimizeTime, 
1:eac0369: 										long generateTime,
1:eac0369: 										long compileTime,
1:eac0369: 										Timestamp beginCompileTimestamp,
1:eac0369: 										Timestamp endCompileTimestamp)
1:eac0369: 	{
1:eac0369: 		this.parseTime = parseTime;
1:eac0369: 		this.bindTime = bindTime;
1:eac0369: 		this.optimizeTime = optimizeTime;
1:eac0369: 		this.generateTime = generateTime;
1:eac0369: 		this.compileTime = compileTime;
1:eac0369: 		this.beginCompileTimestamp = beginCompileTimestamp;
1:eac0369: 		this.endCompileTimestamp = endCompileTimestamp;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Finish marks a statement as totally unusable.
1:eac0369: 	 */
1:eac0369: 	public void finish(LanguageConnectionContext lcc) {
1:eac0369: 
1:3554916: 		synchronized (this) {
1:eac0369: 			inUseCount--;
1:eac0369: 
1:eac0369: 			if (cacheHolder != null)
1:eac0369: 				return;
1:eac0369: 
1:eac0369: 			if (inUseCount != 0) {
1:eac0369: 				//if (SanityManager.DEBUG) {
1:eac0369: 				//	if (inUseCount < 0)
1:eac0369: 				//		SanityManager.THROWASSERT("inUseCount is negative " + inUseCount + " for " + this);
1:eac0369: 				//}
1:eac0369: 				return; 
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 			
1:eac0369: 		// invalidate any prepared statements that
1:eac0369: 		// depended on this statement (including this one)
1:eac0369: 		// prepareToInvalidate(this, DependencyManager.PREPARED_STATEMENT_INVALID);
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			/* NOTE: Since we are non-persistent, we "know" that no exception
1:eac0369: 			 * will be thrown under us.
1:eac0369: 			 */
1:eac0369: 			makeInvalid(DependencyManager.PREPARED_STATEMENT_RELEASE, lcc);
1:eac0369: 		}
1:eac0369: 		catch (StandardException se)
1:eac0369: 		{
1:7fc54b9: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:e7d2a42: 				SanityManager.THROWASSERT("Unexpected exception", se);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Set the Execution constants. This routine is called as we Prepare the
1:eac0369: 	 *	statement.
1:eac0369: 	 *
1:3fcea8a: 	 *	@param constantAction The big structure enclosing the Execution constants.
1:eac0369: 	 */
1:d387dac: 	final void	setConstantAction( ConstantAction constantAction )
1:eac0369: 	{
1:eac0369: 		executionConstants = constantAction;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Get the Execution constants. This routine is called at Execution time.
1:eac0369: 	 *
1:eac0369: 	 *	@return	ConstantAction	The big structure enclosing the Execution constants.
1:eac0369: 	 */
1:eac0369: 	public	final ConstantAction	getConstantAction()
1:eac0369: 	{
1:eac0369: 		return	executionConstants;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Set the saved objects. Called when compilation completes.
1:eac0369: 	 *
1:eac0369: 	 *	@param	objects	The objects to save from compilation
1:eac0369: 	 */
1:d387dac: 	final void	setSavedObjects( Object[] objects )
1:eac0369: 	{
1:eac0369: 		savedObjects = objects;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Get the specified saved object.
1:eac0369: 	 *
1:eac0369: 	 *	@param	objectNum	The object to get.
1:eac0369: 	 *	@return	the requested saved object.
1:eac0369: 	 */
1:eac0369: 	public final Object	getSavedObject(int objectNum)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			if (!(objectNum>=0 && objectNum<savedObjects.length))
3:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"request for savedObject entry "+objectNum+" invalid; "+
1:eac0369: 				"savedObjects has "+savedObjects.length+" entries");
1:eac0369: 		}
1:eac0369: 		return	savedObjects[objectNum];
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Get the saved objects.
1:eac0369: 	 *
1:eac0369: 	 *	@return all the saved objects
1:eac0369: 	 */
1:71c8e86:     public final List<Object> getSavedObjects()
1:eac0369: 	{
1:554386c:         // Return an unmodifiable view of the underlying array, so that
1:554386c:         // the caller cannot modify the internal state.
1:554386c:         return ArrayUtil.asReadOnlyList(savedObjects);
1:eac0369: 	}
1:eac0369: 
1:3554916: 	//
1:eac0369: 	// Dependent interface
1:eac0369: 	//
1:eac0369: 	/**
1:eac0369: 		Check that all of the dependent's dependencies are valid.
1:eac0369: 
1:eac0369: 		@return true if the dependent is currently valid
1:eac0369: 	 */
1:eac0369: 	public boolean isValid() {
1:eac0369: 		return isValid;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * set this prepared statement to be valid, currently used by
1:eac0369: 	 * GenericTriggerExecutor.
1:eac0369: 	 */
1:eac0369: 	public void setValid()
1:eac0369: 	{
1:eac0369: 		isValid = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Indicate this prepared statement is an SPS action, currently used
1:eac0369: 	 * by GenericTriggerExecutor.
1:eac0369: 	 */
1:eac0369: 	public void setSPSAction()
1:eac0369: 	{
1:eac0369: 		spsAction = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Prepare to mark the dependent as invalid (due to at least one of
1:eac0369: 		its dependencies being invalid).
1:eac0369: 
1:eac0369: 		@param	action	The action causing the invalidation
1:eac0369: 		@param	p		the provider
1:eac0369: 
1:eac0369: 		@exception StandardException thrown if unable to make it invalid
1:eac0369: 	 */
1:eac0369: 	public void prepareToInvalidate(Provider p, int action, 
1:eac0369: 									LanguageConnectionContext lcc) 
1:eac0369: 		throws StandardException {
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 			this statement can have other open result sets
1:eac0369: 			if another one is closing without any problems.
1:eac0369: 
1:eac0369: 			It is not a problem to create an index when there is an open
1:eac0369: 			result set, since it doesn't invalidate the access path that was
1:eac0369: 			chosen for the result set.
1:eac0369: 		*/
1:eac0369: 		switch (action) {
1:eac0369: 		case DependencyManager.CHANGED_CURSOR:
1:eac0369: 		case DependencyManager.CREATE_INDEX:
1:e4caed2: 			// Used by activations only:
1:e4caed2: 		case DependencyManager.RECHECK_PRIVILEGES:
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Verify that there are no activations with open result sets
1:eac0369: 		 * on this prepared statement.
1:eac0369: 		 */
1:eac0369: 		lcc.verifyNoOpenResultSets(this, p, action);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Mark the dependent as invalid (due to at least one of
1:eac0369: 		its dependencies being invalid).
1:eac0369: 
1:eac0369: 		@param	action	The action causing the invalidation
1:eac0369: 
1:94f158a: 	 	@exception StandardException Standard Derby error policy.
1:eac0369: 	 */
1:eac0369: 	public void makeInvalid(int action, LanguageConnectionContext lcc)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		boolean alreadyInvalid;
1:e4caed2: 
1:e4caed2: 		switch (action) {
1:e4caed2: 		case DependencyManager.RECHECK_PRIVILEGES:
1:e4caed2: 			return;
1:e4caed2: 		}
1:eac0369: 
3:eac0369: 		synchronized (this) {
1:eac0369: 
1:eac0369: 			if (compilingStatement)
1:3554916:             {
1:3554916:                 // Since the statement is in the process of being compiled,
1:3554916:                 // and at the end of the compilation it will set isValid to
1:3554916:                 // true and overwrite whatever we set it to here, set another
1:3554916:                 // flag to indicate that an invalidation was requested. A
1:3554916:                 // re-compilation will be triggered if this flag is set, but
1:3554916:                 // not until the current compilation is done.
1:3554916:                 invalidatedWhileCompiling = true;
1:eac0369: 				return;
1:3554916:             }
1:eac0369: 
1:eac0369: 			alreadyInvalid = !isValid;
1:eac0369: 		
1:eac0369: 			// make ourseleves invalid
1:3554916: 			isValid = false;
1:eac0369: 
1:eac0369: 			// block compiles while we are invalidating
1:6995fff:             beginCompiling();
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		try {
1:eac0369: 
1:eac0369: 			DependencyManager dm = lcc.getDataDictionary().getDependencyManager();
1:eac0369: 
1:eac0369: 			/* Clear out the old dependencies on this statement as we
1:eac0369: 			 * will build the new set during the reprepare in makeValid().
1:eac0369: 			 */
1:eac0369: 			dm.clearDependencies(lcc, this);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** If we are invalidating an EXECUTE STATEMENT because of a stale
1:eac0369: 			** plan, we also need to invalidate the stored prepared statement.
1:eac0369: 			*/
1:eac0369: 			if (execStmtName != null) {
1:eac0369: 				switch (action) {
1:eac0369: 				case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
1:eac0369: 				case DependencyManager.CHANGED_CURSOR:
1:eac0369: 				{
1:eac0369: 					/*
1:eac0369: 					** Get the DataDictionary, so we can get the descriptor for
1:eac0369: 					** the SPP to invalidate it.
1:eac0369: 					*/
1:eac0369: 					DataDictionary dd = lcc.getDataDictionary();
1:eac0369: 						
1:eac0369: 					SchemaDescriptor sd = dd.getSchemaDescriptor(execSchemaName, lcc.getTransactionCompile(), true);
1:eac0369: 					SPSDescriptor spsd = dd.getSPSDescriptor(execStmtName, sd);
1:eac0369: 					spsd.makeInvalid(action, lcc);
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 				}
1:eac0369: 			}
1:3554916: 		} finally {
1:6995fff:             endCompiling();
1:3554916: 		}
1:3554916: 	}
1:3554916: 
1:eac0369: 	/**
1:eac0369: 	 * Is this dependent persistent?  A stored dependency will be required
1:eac0369: 	 * if both the dependent and provider are persistent.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean		Whether or not this dependent is persistent.
1:eac0369: 	 */
1:eac0369: 	public boolean isPersistent()
1:eac0369: 	{
1:eac0369: 		/* Non-stored prepared statements are not persistent */
1:eac0369: 		return false;
1:3554916: 	}
1:3554916: 
1:eac0369: 	//
1:eac0369: 	// Dependable interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**		
1:eac0369: 		@return the stored form of this Dependable
1:eac0369: 
1:eac0369: 		@see Dependable#getDependableFinder
1:eac0369: 	 */
1:eac0369: 	public DependableFinder getDependableFinder()
1:eac0369: 	{
1:eac0369: 	    return null;
1:3554916: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the name of this Dependable.  (Useful for errors.)
1:eac0369: 	 *
1:eac0369: 	 * @return String	The name of this Dependable..
1:eac0369: 	 */
1:eac0369: 	public String getObjectName()
1:eac0369: 	{
1:eac0369: 		return UUIDString;
1:3554916: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the Dependable's UUID String.
1:eac0369: 	 *
1:eac0369: 	 * @return String	The Dependable's UUID String.
1:eac0369: 	 */
1:eac0369: 	public UUID getObjectID()
1:eac0369: 	{
1:eac0369: 		return UUIDValue;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the Dependable's class type.
1:eac0369: 	 *
1:eac0369: 	 * @return String		Classname that this Dependable belongs to.
1:eac0369: 	 */
1:eac0369: 	public String getClassType()
1:eac0369: 	{
1:eac0369: 		return Dependable.PREPARED_STATEMENT;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:6d9c32a: 	 * Return true if the query node for this statement references SESSION schema
1:6d9c32a: 	 * tables/views.
1:6d9c32a: 	 * This method gets called at the very beginning of the compile phase of any statement.
1:6d9c32a: 	 * If the statement which needs to be compiled is already found in cache, then there is
1:6d9c32a: 	 * no need to compile it again except the case when the statement is referencing SESSION
1:6d9c32a: 	 * schema objects. There is a small window where such a statement might get cached 
1:6d9c32a: 	 * temporarily (a statement referencing SESSION schema object will be removed from the
1:6d9c32a: 	 * cache after the bind phase is over because that is when we know for sure that the 
1:6d9c32a: 	 * statement is referencing SESSION schema objects.)
1:eac0369: 	 *
1:eac0369: 	 * @return	true if references SESSION schema tables, else false
1:eac0369: 	 */
1:eac0369: 	public boolean referencesSessionSchema()
1:eac0369: 	{
2:eac0369: 		return referencesSessionSchema;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:6d9c32a: 	 * Return true if the QueryTreeNode references SESSION schema tables/views.
1:6d9c32a: 	 * The return value is also saved in the local field because it will be 
1:6d9c32a: 	 * used by referencesSessionSchema() method. 
1:6d9c32a: 	 * This method gets called when the statement is not found in cache and 
1:6d9c32a: 	 * hence it is getting compiled.
1:6d9c32a: 	 * At the beginning of compilation for any statement, first we check if
1:6d9c32a: 	 * the statement's plan already exist in the cache. If not, then we add
1:6d9c32a: 	 * the statement to the cache and continue with the parsing and binding.
1:6d9c32a: 	 * At the end of the binding, this method gets called to see if the 
1:6d9c32a: 	 * QueryTreeNode references a SESSION schema object. If it does, then
1:6d9c32a: 	 * we want to remove it from the cache, since any statements referencing
1:6d9c32a: 	 * SESSION schema objects should never get cached.  
1:eac0369: 	 *
1:6d9c32a: 	 * @return	true if references SESSION schema tables/views, else false
1:eac0369: 	 */
1:92c7572: 	public boolean referencesSessionSchema(StatementNode qt)
1:6d9c32a: 	throws StandardException {
1:6d9c32a: 		//If the query references a SESSION schema table (temporary or permanent), then
1:6d9c32a: 		// mark so in this statement
1:eac0369: 		referencesSessionSchema = qt.referencesSessionSchema();
1:6d9c32a: 		return(referencesSessionSchema);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// class interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Makes the prepared statement valid, assigning
1:eac0369: 		values for its query tree, generated class,
1:eac0369: 		and associated information.
1:eac0369: 
1:eac0369: 		@param qt the query tree for this statement
1:eac0369: 
1:eac0369: 		@exception StandardException thrown on failure.
1:eac0369: 	 */
1:92c7572: 	void completeCompile(StatementNode qt)
1:eac0369: 						throws StandardException {
1:eac0369: 		//if (finished)
1:eac0369: 		//	throw StandardException.newException(SQLState.LANG_STATEMENT_CLOSED, "completeCompile()");
1:eac0369: 
1:eac0369: 		paramTypeDescriptors = qt.getParameterTypes();
1:eac0369: 
1:eac0369: 		// erase cursor info in case statement text changed
1:eac0369: 		if (targetTable!=null) {
1:eac0369: 			targetTable = null;
1:eac0369: 			updateMode = 0;
1:eac0369: 			updateColumns = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// get the result description (null for non-cursor statements)
1:eac0369: 		// would we want to reuse an old resultDesc?
1:eac0369: 		// or do we need to always replace in case this was select *?
1:eac0369: 		resultDesc = qt.makeResultDescription();
1:eac0369: 
1:eac0369: 		// would look at resultDesc.getStatementType() but it
1:eac0369: 		// doesn't call out cursors as such, so we check
1:eac0369: 		// the root node type instead.
1:eac0369: 
1:eac0369: 		if (resultDesc != null)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 				For cursors, we carry around some extra information.
1:eac0369: 			 */
1:dda453e:             setCursorInfo((CursorInfo) qt.getCursorInfo());
1:eac0369: 		}
1:eac0369: 		isValid = true;
1:eac0369: 
1:f542632:         rowCountStats.reset();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public GeneratedClass getActivationClass()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return activationClass;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void setActivationClass(GeneratedClass ac)
1:eac0369: 	{
1:eac0369: 		activationClass = ac;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// ExecPreparedStatement
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * the update mode of the cursor
1:eac0369: 	 *
1:eac0369: 	 * @return	The update mode of the cursor
1:eac0369: 	 */
1:eac0369: 	public int	getUpdateMode() {
1:eac0369: 		return updateMode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * the target table of the cursor
1:eac0369: 	 *
1:eac0369: 	 * @return	target table of the cursor
1:eac0369: 	 */
1:eac0369: 	public ExecCursorTableReference getTargetTable() 
1:eac0369: 	{
1:08d2c15: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(targetTable!=null, "Not a cursor, no target table");
1:eac0369: 		}
1:eac0369: 		return targetTable;
1:eac0369: 	}
1:eac0369: 
1:dda453e:     public boolean hasUpdateColumns() {
1:dda453e:         return updateColumns != null && !updateColumns.isEmpty();
1:dda453e:     }
1:eac0369: 
1:dda453e:     public boolean isUpdateColumn(String columnName) {
1:dda453e:         return updateColumns != null && updateColumns.contains(columnName);
1:dda453e:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the cursor info in a single chunk.  Used
1:eac0369: 	 * by StrorablePreparedStatement
1:eac0369: 	 */
1:eac0369: 	public Object getCursorInfo()
1:eac0369: 	{
1:eac0369: 		return new CursorInfo(
1:eac0369: 			updateMode,
1:eac0369: 			targetTable, 
1:eac0369: 			updateColumns);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void setCursorInfo(CursorInfo cursorInfo)
1:eac0369: 	{
2:eac0369: 		if (cursorInfo != null)
1:eac0369: 		{
2:eac0369: 			updateMode = cursorInfo.updateMode;
2:eac0369: 			targetTable = cursorInfo.targetTable;
2:eac0369: 			updateColumns = cursorInfo.updateColumns;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// class implementation
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the byte code saver for this statement.
1:eac0369: 	 * Overridden for StorablePreparedStatement.  We
1:eac0369: 	 * don't want to save anything
1:eac0369: 	 *
1:eac0369: 	 * @return a byte code saver (null for us)
1:eac0369: 	 */
1:eac0369: 	ByteArray getByteCodeSaver()
1:eac0369: 	{
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Does this statement need a savepoint?  
1:eac0369: 	 * 
1:eac0369: 	 * @return true if this statement needs a savepoint.
1:eac0369: 	 */
1:eac0369: 	public boolean needsSavepoint()
1:eac0369: 	{
1:eac0369: 		return needsSavepoint;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the stmts 'needsSavepoint' state.  Used
1:eac0369: 	 * by an SPS to convey whether the underlying stmt
1:eac0369: 	 * needs a savepoint or not.
1:eac0369: 	 * 
1:eac0369: 	 * @param needsSavepoint true if this statement needs a savepoint.
1:eac0369: 	 */
1:eac0369: 	void setNeedsSavepoint(boolean needsSavepoint)
1:eac0369: 	{
1:eac0369: 	 	this.needsSavepoint = needsSavepoint;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the stmts 'isAtomic' state.  
1:eac0369: 	 * 
1:eac0369: 	 * @param isAtomic true if this statement must be atomic
1:eac0369: 	 * (i.e. it is not ok to do a commit/rollback in the middle)
1:eac0369: 	 */
1:eac0369: 	void setIsAtomic(boolean isAtomic)
1:eac0369: 	{
1:eac0369: 	 	this.isAtomic = isAtomic;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns whether or not this Statement requires should
1:eac0369: 	 * behave atomically -- i.e. whether a user is permitted
1:eac0369: 	 * to do a commit/rollback during the execution of this
1:eac0369: 	 * statement.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not this Statement is atomic
1:eac0369: 	 */
1:eac0369: 	public boolean isAtomic()
1:eac0369: 	{
1:eac0369: 		return isAtomic;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the name of the statement and schema for an "execute statement"
1:eac0369: 	 * command.
1:eac0369: 	 */
1:eac0369: 	void setExecuteStatementNameAndSchema(String execStmtName,
1:eac0369: 												 String execSchemaName)
1:eac0369: 	{
1:eac0369: 		this.execStmtName = execStmtName;
1:eac0369: 		this.execSchemaName = execSchemaName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get a new prepared statement that is a shallow copy
1:eac0369: 	 * of the current one.
1:eac0369: 	 *
1:eac0369: 	 * @return a new prepared statement
1:eac0369: 	 * 
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public ExecPreparedStatement getClone() throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		GenericPreparedStatement clone = new GenericPreparedStatement(statement);
1:eac0369: 
1:eac0369: 		clone.activationClass = getActivationClass();
1:eac0369: 		clone.resultDesc = resultDesc;
1:eac0369: 		clone.paramTypeDescriptors = paramTypeDescriptors;
1:eac0369: 		clone.executionConstants = executionConstants;
1:eac0369: 		clone.UUIDString = UUIDString;
1:eac0369: 		clone.UUIDValue = UUIDValue;
1:eac0369: 		clone.savedObjects = savedObjects;
1:eac0369: 		clone.execStmtName = execStmtName;
1:eac0369: 		clone.execSchemaName = execSchemaName;
1:eac0369: 		clone.isAtomic = isAtomic;
1:eac0369: 		clone.sourceTxt = sourceTxt;
1:eac0369: 		clone.targetTable = targetTable;
1:eac0369: 		clone.updateColumns = updateColumns;
1:eac0369: 		clone.updateMode = updateMode;	
1:eac0369: 		clone.needsSavepoint = needsSavepoint;
1:f542632:         clone.rowCountStats = rowCountStats;
1:eac0369: 
1:eac0369: 		return clone;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// cache holder stuff.
1:eac0369: 	public void setCacheHolder(Cacheable cacheHolder) {
1:eac0369: 
1:eac0369: 		this.cacheHolder = cacheHolder;
1:eac0369: 
1:eac0369: 		if (cacheHolder == null) {
1:eac0369: 
1:eac0369: 			// need to invalidate the statement
1:eac0369: 			if (!isValid || (inUseCount != 0))
1:eac0369: 				return;
1:eac0369: 
1:a0dbbd7: 			ContextManager cm = getContextService().getCurrentContextManager();
1:eac0369: 			LanguageConnectionContext lcc = 
1:eac0369: 				(LanguageConnectionContext) 
1:eac0369: 				(cm.getContext(LanguageConnectionContext.CONTEXT_ID));
1:eac0369: 
1:eac0369: 			// invalidate any prepared statements that
1:eac0369: 			// depended on this statement (including this one)
1:eac0369: 			// prepareToInvalidate(this, DependencyManager.PREPARED_STATEMENT_INVALID);
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				/* NOTE: Since we are non-persistent, we "know" that no exception
1:eac0369: 				 * will be thrown under us.
1:eac0369: 				 */
1:eac0369: 				makeInvalid(DependencyManager.PREPARED_STATEMENT_RELEASE, lcc);
1:eac0369: 			}
1:eac0369: 			catch (StandardException se)
1:eac0369: 			{
4:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:e7d2a42: 					SanityManager.THROWASSERT("Unexpected exception", se);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:801cf0d:     @Override
1:eac0369: 	public String toString() {
1:eac0369: 		return getObjectName();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public boolean isStorable() {
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:801cf0d:     public void setRequiredPermissionsList(
1:801cf0d:             List<StatementPermission> requiredPermissionsList)
1:eac0369: 	{
1:c45f5b1: 		this.requiredPermissionsList = requiredPermissionsList;
1:eac0369: 	}
1:eac0369: 
1:801cf0d:     public List<StatementPermission> getRequiredPermissionsList()
1:eac0369: 	{
1:c45f5b1: 		return requiredPermissionsList;
1:f9a0689: 	}
1:f9a0689: 
1:f9a0689:     public final long getVersionCounter() {
1:f9a0689:         return versionCounter;
1:f9a0689:     }
1:f9a0689: 
1:f9a0689:     public final void incrementVersionCounter() {
1:f9a0689:         ++versionCounter;
1:f542632:     }
1:f542632: 
1:f542632:     // Stale plan checking.
1:f542632: 
1:f542632:     /**
1:f542632:      * This class holds information about stale plan check interval,
1:f542632:      * execution count and row count statistics for a GenericPreparedStatement.
1:f542632:      *
1:f542632:      * The fields and methods should ideally live in GenericPreparedStatement,
1:f542632:      * not in a separate class. However, triggers clone the GPS on each
1:f542632:      * execution, which means the statistics would be reset on each execution
1:f542632:      * if they lived directly inside GPS. Instead, keep the statistics in an
1:f542632:      * object that can be shared between multiple GPS instances when they
1:f542632:      * are cloned.
1:f542632:      */
1:f542632:     private static class RowCountStatistics {
1:f542632:         private int stalePlanCheckInterval;
1:f542632:         private int executionCount;
1:71c8e86:         private ArrayList<Long> rowCounts;
1:f542632: 
1:f542632:         // No synchronization for executionCount. Since it's accessed on
1:f542632:         // every execution, we want to avoid synchronization. Nothing serious
1:f542632:         // happens if the execution count is off, we just risk checking for
1:f542632:         // stale plans at a different frequency than specified by
1:f542632:         // derby.language.stalePlanCheckInterval.
1:f542632:         //
1:f542632:         // We might want to use a java.util.concurrent.atomic.AtomicInteger
1:f542632:         // and its atomic incrementAndGet() method once support for pre-Java 5
1:f542632:         // JVMs is dropped.
1:f542632: 
1:f542632:         /** @see ExecPreparedStatement#incrementExecutionCount() */
1:f542632:         int incrementExecutionCount() {
1:f542632:             return ++executionCount;
1:f542632:         }
1:f542632: 
1:f542632:         /** @see ExecPreparedStatement#getInitialRowCount(int, long) */
1:f542632:         synchronized long getInitialRowCount(int rsNum, long rowCount) {
1:f542632:             // Allocate the list of row counts lazily.
1:f542632:             if (rowCounts == null) {
1:71c8e86:                 rowCounts = new ArrayList<Long>();
1:f542632:             }
1:f542632: 
1:f542632:             // Make sure the list is big enough to hold the row count for
1:f542632:             // the specified result set number.
1:f542632:             if (rsNum >= rowCounts.size()) {
1:f542632:                 int newSize = rsNum + 1;
1:f542632:                 rowCounts.addAll(
1:71c8e86:                                  Collections.nCopies(newSize - rowCounts.size(), (Long) null));
1:f542632:             }
1:f542632: 
1:f542632:             // Get the initial row count for the specified result set, and
1:f542632:             // set it if it is not already set.
1:71c8e86:             Long initialCount = rowCounts.get(rsNum);
1:f542632:             if (initialCount == null) {
1:bb5be6f:                 rowCounts.set(rsNum, rowCount);
1:f542632:                 return rowCount;
1:f542632:             } else {
1:f542632:                 return initialCount.longValue();
1:f542632:             }
1:f542632:         }
1:f542632: 
1:f542632:         // No synchronization for stale plan check interval. Same reason as
1:f542632:         // stated above for executionCount. Since int accesses are guaranteed
1:f542632:         // atomic, the worst that could happen is that one thread sees it as
1:f542632:         // uninitialized (zero) when another thread in fact has initialized it,
1:f542632:         // and we end up doing the initialization work twice.
1:f542632: 
1:f542632:         /** @see ExecPreparedStatement#setStalePlanCheckInterval(int) */
1:f542632:         void setStalePlanCheckInterval(int interval) {
1:f542632:             stalePlanCheckInterval = interval;
1:f542632:         }
1:f542632: 
1:f542632:         /** @see ExecPreparedStatement#getStalePlanCheckInterval() */
1:f542632:         int getStalePlanCheckInterval() {
1:f542632:             return stalePlanCheckInterval;
1:f542632:         }
1:f542632: 
1:f542632:         /** Reset all the row count statistics. */
1:f542632:         synchronized void reset() {
1:f542632:             stalePlanCheckInterval = 0;
1:f542632:             executionCount = 0;
1:f542632:             rowCounts = null;
1:f542632:         }
1:f542632:     }
1:f542632: 
1:f542632:     /** @see ExecPreparedStatement#incrementExecutionCount() */
1:f542632:     public int incrementExecutionCount() {
1:f542632:         return rowCountStats.incrementExecutionCount();
1:f542632:     }
1:f542632: 
1:f542632:     /** @see ExecPreparedStatement#setStalePlanCheckInterval(int) */
1:f542632:     public void setStalePlanCheckInterval(int interval) {
1:f542632:         rowCountStats.setStalePlanCheckInterval(interval);
1:f542632:     }
1:f542632: 
1:f542632:     /** @see ExecPreparedStatement#getStalePlanCheckInterval() */
1:f542632:     public int getStalePlanCheckInterval() {
1:f542632:         return rowCountStats.getStalePlanCheckInterval();
1:f542632:     }
1:f542632: 
1:f542632:     /** @see ExecPreparedStatement#getInitialRowCount(int, long) */
1:f542632:     public long getInitialRowCount(int rsNum, long currentRowCount) {
1:f542632:         return rowCountStats.getInitialRowCount(rsNum, currentRowCount);
1:a0dbbd7:     }
1:a0dbbd7:     
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of the ContextService. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  ContextService    getContextService()
1:a0dbbd7:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ContextService>()
1:56c1dc2:              {
1:56c1dc2:                  public ContextService run()
1:a0dbbd7:                  {
1:56c1dc2:                      return ContextService.getFactory();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:a0dbbd7:     }
1:56c1dc2: 
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:a0dbbd7:     }
1:a0dbbd7: 
1:a0dbbd7: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                  idx+1,
1:                  paramTypeDescriptors.length
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
/////////////////////////////////////////////////////////////////////////
1: 			getMonitor().getUUIDFactory();
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ContextService>()
1:              {
1:                  public ContextService run()
1:                      return ContextService.getFactory();
1:              }
1:              );
1:     }
1: 
1:     
1:     /**
1:      * Privileged Monitor lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
1: import java.security.AccessController;
/////////////////////////////////////////////////////////////////////////
1: 			ContextManager cm = getContextService().getCurrentContextManager();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged lookup of the ContextService. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ContextService    getContextService()
1:     {
0:         if ( System.getSecurityManager() == null )
1:         {
0:             return ContextService.getFactory();
1:         }
0:         else
1:         {
0:             return AccessController.doPrivileged
1:                 (
0:                  new PrivilegedAction<ContextService>()
1:                  {
0:                      public ContextService run()
1:                      {
0:                          return ContextService.getFactory();
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:     protected List<String>           updateColumns;
/////////////////////////////////////////////////////////////////////////
1:     public final List<Object> getSavedObjects()
/////////////////////////////////////////////////////////////////////////
1:         private ArrayList<Long> rowCounts;
/////////////////////////////////////////////////////////////////////////
1:                 rowCounts = new ArrayList<Long>();
/////////////////////////////////////////////////////////////////////////
1:                                  Collections.nCopies(newSize - rowCounts.size(), (Long) null));
1:             Long initialCount = rowCounts.get(rsNum);
commit:6cc0702
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.ArrayUtil;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.DataTypeUtilities;
/////////////////////////////////////////////////////////////////////////
0: 		return (DataTypeDescriptor[]) ArrayUtil.copy( paramTypeDescriptors );
1:     /** Return the type of the parameter (0-based indexing) */
1:     public DataTypeDescriptor  getParameterType( int idx ) throws StandardException
1:     {
1: 		if ( paramTypeDescriptors == null )
1:         {
1: 			throw StandardException.newException( SQLState.NO_INPUT_PARAMETERS );
1: 		}
1: 
1: 		/* Check that the parameterIndex is in range. */
1: 		if ( (idx < 0) || (idx >= paramTypeDescriptors.length) )
1:         {
1: 			/* This message matches the one used by the DBMS */
1: 			throw StandardException.newException
0:                 (
1:                  SQLState.LANG_INVALID_PARAM_POSITION, 
0:                  new Integer( idx+1 ),
0:                  new Integer( paramTypeDescriptors.length )
0:                  );
1: 		}
1: 
1:         return paramTypeDescriptors[ idx ];
1:     }
1:     
1: 
/////////////////////////////////////////////////////////////////////////
1: 		return DataTypeUtilities.clone( beginCompileTimestamp );
/////////////////////////////////////////////////////////////////////////
1: 		return DataTypeUtilities.clone( endCompileTimestamp );
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:bb5be6f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 rowCounts.set(rsNum, rowCount);
commit:7b6ad6d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         rePrepare(lcc, false);
1:     }
1: 
1:     public void rePrepare(LanguageConnectionContext lcc, boolean forMetaData)
1:         throws StandardException {
1:             PreparedStatement ps = statement.prepare(lcc, forMetaData);
/////////////////////////////////////////////////////////////////////////
1:         return executeStmt(a, rollbackParentContext, false, timeoutMillis);
/////////////////////////////////////////////////////////////////////////
1:         return executeStmt(activation, rollbackParentContext,
1:                            false, timeoutMillis);
/////////////////////////////////////////////////////////////////////////
1:                              boolean forMetaData,
1:         return executeStmt(activation, false, forMetaData, timeoutMillis);
/////////////////////////////////////////////////////////////////////////
1:       * @param forMetaData true if this is a meta-data query
/////////////////////////////////////////////////////////////////////////
1:                                   boolean forMetaData,
/////////////////////////////////////////////////////////////////////////
1:                 rePrepare(lccToUse, forMetaData);
commit:6995fff
/////////////////////////////////////////////////////////////////////////
1:     private boolean compilingStatement;
/////////////////////////////////////////////////////////////////////////
1:     /** Check if this statement is currently being compiled. */
1:     final synchronized boolean isCompiling() {
1:         return compilingStatement;
1:     }
1: 
1:     /**
1:      * Signal that the statement is about to be compiled. This will block
1:      * others from attempting to compile it.
1:      */
1:     final synchronized void beginCompiling() {
1:         compilingStatement = true;
1:         setActivationClass(null);
1:     }
1: 
1:     /**
1:      * Signal that we're done compiling the statement and unblock others
1:      * that are waiting for the compilation to finish.
1:      */
1:     final synchronized void endCompiling() {
1:         compilingStatement = false;
1:         notifyAll();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             beginCompiling();
/////////////////////////////////////////////////////////////////////////
1:             endCompiling();
commit:3f7581c
/////////////////////////////////////////////////////////////////////////
1:         return ArrayUtil.copy(paramTypeDescriptors);
commit:554386c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.ArrayUtil;
/////////////////////////////////////////////////////////////////////////
0:     public final List getSavedObjects()
1:         // Return an unmodifiable view of the underlying array, so that
1:         // the caller cannot modify the internal state.
1:         return ArrayUtil.asReadOnlyList(savedObjects);
commit:dda453e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected List                      updateColumns;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             setCursorInfo((CursorInfo) qt.getCursorInfo());
/////////////////////////////////////////////////////////////////////////
1:     public boolean hasUpdateColumns() {
1:         return updateColumns != null && !updateColumns.isEmpty();
1:     }
1:     public boolean isUpdateColumn(String columnName) {
1:         return updateColumns != null && updateColumns.contains(columnName);
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:f542632
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.util.ReuseFactory;
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Holder for row counts and execution count. Used for determining
1:      * whether the statement should be recompiled.
1:      */
1:     private RowCountStatistics rowCountStats = new RowCountStatistics();
1: 
/////////////////////////////////////////////////////////////////////////
1:         rowCountStats.reset();
/////////////////////////////////////////////////////////////////////////
1:         clone.rowCountStats = rowCountStats;
/////////////////////////////////////////////////////////////////////////
1: 
1:     // Stale plan checking.
1: 
1:     /**
1:      * This class holds information about stale plan check interval,
1:      * execution count and row count statistics for a GenericPreparedStatement.
1:      *
1:      * The fields and methods should ideally live in GenericPreparedStatement,
1:      * not in a separate class. However, triggers clone the GPS on each
1:      * execution, which means the statistics would be reset on each execution
1:      * if they lived directly inside GPS. Instead, keep the statistics in an
1:      * object that can be shared between multiple GPS instances when they
1:      * are cloned.
1:      */
1:     private static class RowCountStatistics {
1:         private int stalePlanCheckInterval;
1:         private int executionCount;
0:         private ArrayList rowCounts;
1: 
1:         // No synchronization for executionCount. Since it's accessed on
1:         // every execution, we want to avoid synchronization. Nothing serious
1:         // happens if the execution count is off, we just risk checking for
1:         // stale plans at a different frequency than specified by
1:         // derby.language.stalePlanCheckInterval.
1:         //
1:         // We might want to use a java.util.concurrent.atomic.AtomicInteger
1:         // and its atomic incrementAndGet() method once support for pre-Java 5
1:         // JVMs is dropped.
1: 
1:         /** @see ExecPreparedStatement#incrementExecutionCount() */
1:         int incrementExecutionCount() {
1:             return ++executionCount;
1:         }
1: 
1:         /** @see ExecPreparedStatement#getInitialRowCount(int, long) */
1:         synchronized long getInitialRowCount(int rsNum, long rowCount) {
1:             // Allocate the list of row counts lazily.
1:             if (rowCounts == null) {
0:                 rowCounts = new ArrayList();
1:             }
1: 
1:             // Make sure the list is big enough to hold the row count for
1:             // the specified result set number.
1:             if (rsNum >= rowCounts.size()) {
1:                 int newSize = rsNum + 1;
1:                 rowCounts.addAll(
0:                         Collections.nCopies(newSize - rowCounts.size(), null));
1:             }
1: 
1:             // Get the initial row count for the specified result set, and
1:             // set it if it is not already set.
0:             Long initialCount = (Long) rowCounts.get(rsNum);
1:             if (initialCount == null) {
0:                 rowCounts.set(rsNum, ReuseFactory.getLong(rowCount));
1:                 return rowCount;
1:             } else {
1:                 return initialCount.longValue();
1:             }
1:         }
1: 
1:         // No synchronization for stale plan check interval. Same reason as
1:         // stated above for executionCount. Since int accesses are guaranteed
1:         // atomic, the worst that could happen is that one thread sees it as
1:         // uninitialized (zero) when another thread in fact has initialized it,
1:         // and we end up doing the initialization work twice.
1: 
1:         /** @see ExecPreparedStatement#setStalePlanCheckInterval(int) */
1:         void setStalePlanCheckInterval(int interval) {
1:             stalePlanCheckInterval = interval;
1:         }
1: 
1:         /** @see ExecPreparedStatement#getStalePlanCheckInterval() */
1:         int getStalePlanCheckInterval() {
1:             return stalePlanCheckInterval;
1:         }
1: 
1:         /** Reset all the row count statistics. */
1:         synchronized void reset() {
1:             stalePlanCheckInterval = 0;
1:             executionCount = 0;
1:             rowCounts = null;
1:         }
1:     }
1: 
1:     /** @see ExecPreparedStatement#incrementExecutionCount() */
1:     public int incrementExecutionCount() {
1:         return rowCountStats.incrementExecutionCount();
1:     }
1: 
1:     /** @see ExecPreparedStatement#setStalePlanCheckInterval(int) */
1:     public void setStalePlanCheckInterval(int interval) {
1:         rowCountStats.setStalePlanCheckInterval(interval);
1:     }
1: 
1:     /** @see ExecPreparedStatement#getStalePlanCheckInterval() */
1:     public int getStalePlanCheckInterval() {
1:         return rowCountStats.getStalePlanCheckInterval();
1:     }
1: 
1:     /** @see ExecPreparedStatement#getInitialRowCount(int, long) */
1:     public long getInitialRowCount(int rsNum, long currentRowCount) {
1:         return rowCountStats.getInitialRowCount(rsNum, currentRowCount);
1:     }
commit:be1b5ea
/////////////////////////////////////////////////////////////////////////
1:     boolean invalidatedWhileCompiling;
/////////////////////////////////////////////////////////////////////////
0:                 rePrepare(lccToUse);
commit:df381dd
/////////////////////////////////////////////////////////////////////////
0:                     // compiled. If so, the newly compiled plan may or may
commit:3554916
/////////////////////////////////////////////////////////////////////////
1:     /** True if the statement was invalidated while it was being compiled. */
0:     private boolean invalidatedWhileCompiling;
/////////////////////////////////////////////////////////////////////////
1: 
0:                 final int depth = lccToUse.getStatementDepth();
1:                 try {
0:                     rePrepare(lccToUse);
1:                 } finally {
0:                     boolean recompile = false;
1: 
0:                     // Check if the statement was invalidated while it was
0:                     // compiled. The compiled version of the statement may or
0:                     // not be up to date anymore, so we recompile the statement
0:                     // if this happens. Note that this is checked in a finally
0:                     // block, so we also retry if an exception was thrown. The
0:                     // exception was probably thrown because of the changes
0:                     // that invalidated the statement. If not, recompiling
0:                     // will also fail, and the exception will be exposed to
0:                     // the caller.
1:                     //
0:                     // invalidatedWhileCompiling and isValid are protected by
0:                     // synchronization on "this".
1:                     synchronized (this) {
0:                         if (invalidatedWhileCompiling) {
1:                             isValid = false;
0:                             invalidatedWhileCompiling = false;
0:                             recompile = true;
1:                         }
1:                     }
1: 
0:                     if (recompile) {
0:                         // A new statement context is pushed while compiling.
0:                         // Typically, this context is popped by an error
0:                         // handler at a higher level. But since we retry the
0:                         // compilation, the error handler won't be invoked, so
0:                         // the stack must be reset to its original state first.
0:                         while (lccToUse.getStatementDepth() > depth) {
0:                             lccToUse.popStatementContext(
0:                                     lccToUse.getStatementContext(), null);
1:                         }
1: 
1:                         continue recompileOutOfDatePlan;
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             {
1:                 // Since the statement is in the process of being compiled,
1:                 // and at the end of the compilation it will set isValid to
1:                 // true and overwrite whatever we set it to here, set another
1:                 // flag to indicate that an invalidation was requested. A
1:                 // re-compilation will be triggered if this flag is set, but
1:                 // not until the current compilation is done.
1:                 invalidatedWhileCompiling = true;
1:             }
commit:85132a2
/////////////////////////////////////////////////////////////////////////
1: 	public void rePrepare(LanguageConnectionContext lcc) 
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.ASSERT(ps == this, "ps != this");
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 				rePrepare(lcc);
commit:7fc54b9
/////////////////////////////////////////////////////////////////////////
0: 	public PreparedStatement rePrepare(LanguageConnectionContext lcc)
0: 			return ps;
1: 
0: 		return this;
/////////////////////////////////////////////////////////////////////////
0: 				PreparedStatement ps = rePrepare(lcc);
1: 
1: 				if (SanityManager.DEBUG)
0: 					SanityManager.ASSERT(ps == this, "ps != this");
commit:6832893
/////////////////////////////////////////////////////////////////////////
1: 		return isUpToDate();
1:     /**
1:      * Check whether this statement is up to date and its generated class is
1:      * identical to the supplied class object.
1:      * @see ExecPreparedStatement#upToDate(GeneratedClass)
1:      */
1:     public synchronized boolean upToDate(GeneratedClass gc) {
1:         return (activationClass == gc) && isUpToDate();
1:     }
1: 
1:     /**
1:      * Unsynchronized helper method for {@link #upToDate()} and {@link
1:      * #upToDate(GeneratedClass)}. Checks whether this statement is up to date.
1:      *
1:      * @return {@code true} if this statement is up to date, {@code false}
1:      * otherwise
1:      */
1:     private boolean isUpToDate() {
1:         return isValid && (activationClass != null) && !compilingStatement;
1:     }
1: 
commit:77603a1
/////////////////////////////////////////////////////////////////////////
1: 	public Activation getActivation(LanguageConnectionContext lcc,
1: 									boolean scrollable)
1: 		throws StandardException
1: 		Activation ac;
1: 		synchronized (this) {
1: 			GeneratedClass gc = getActivationClass();
1: 			if (gc == null) {
0: 				rePrepare(lcc);
1: 				gc = getActivationClass();
1: 			}
1: 
1: 			ac = new GenericActivationHolder(lcc, gc, this, scrollable);
1: 
1: 			inUseCount++;
1: 		// DERBY-2689. Close unused activations-- this method should be called
1: 		// when I'm not holding a lock on a prepared statement to avoid
1: 		// deadlock.
1: 		lcc.closeUnusedActivations();
commit:e7d2a42
/////////////////////////////////////////////////////////////////////////
1: 				SanityManager.THROWASSERT("Unexpected exception", se);
/////////////////////////////////////////////////////////////////////////
1: 					SanityManager.THROWASSERT("Unexpected exception", se);
commit:fade7e9
/////////////////////////////////////////////////////////////////////////
0: 		return execute(a, rollbackParentContext, timeoutMillis);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.conn.SQLSessionContext;
/////////////////////////////////////////////////////////////////////////
1:             lccToUse.popStatementContext(statementContext, null);
1: 
1:             if (activation.getSQLSessionContextForChildren() != null) {
1:                 lccToUse.popNestedSessionContext(activation);
1:             }
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Timestamp;
1: import org.apache.derby.catalog.Dependable;
1: import org.apache.derby.catalog.DependableFinder;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.cache.Cacheable;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.io.ArrayUtil;
1: import org.apache.derby.iapi.services.loader.GeneratedClass;
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.ParameterValueSet;
1: import org.apache.derby.iapi.sql.PreparedStatement;
1: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.sql.Statement;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.conn.StatementContext;
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: import org.apache.derby.iapi.sql.depend.Provider;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.StatementPermission;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.sql.execute.ExecCursorTableReference;
1: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataTypeUtilities;
1: import org.apache.derby.iapi.util.ByteArray;
0: import org.apache.derby.iapi.util.ReuseFactory;
1: import org.apache.derby.impl.sql.compile.CursorNode;
1: import org.apache.derby.impl.sql.compile.StatementNode;
/////////////////////////////////////////////////////////////////////////
1:     protected List<StatementPermission> requiredPermissionsList;
/////////////////////////////////////////////////////////////////////////
1:             ResultSet resultSet;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     public void setRequiredPermissionsList(
1:             List<StatementPermission> requiredPermissionsList)
1:     public List<StatementPermission> getRequiredPermissionsList()
commit:f9a0689
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Incremented for each (re)compile.
1:      */
1:     private long versionCounter;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     public final long getVersionCounter() {
1:         return versionCounter;
1:     }
1: 
1:     public final void incrementVersionCounter() {
1:         ++versionCounter;
1:     }
commit:e3883f5
/////////////////////////////////////////////////////////////////////////
1: 		Activation parentAct = null;
1: 			// If not null, parentAct represents one of 1) the activation of a
1: 			// calling statement and this activation corresponds to a statement
1: 			// inside a stored procedure or function, and 2) the activation of
1: 			// a statement that performs a substatement, e.g. trigger body
1: 			// execution.
1: 			parentAct = stmctx.getActivation();
1: 		ac.setParentActivation(parentAct);
1: 	/**
1: 	 * @see PreparedStatement#executeSubStatement(LanguageConnectionContext, boolean, long)
1: 	 */
1:     public ResultSet executeSubStatement(LanguageConnectionContext lcc,
1: 										 boolean rollbackParentContext,
1: 										 long timeoutMillis)
1: 		Activation parent = lcc.getLastActivation();
1: 		lcc.setupSubStatementSessionContext(parent);
0: 		return executeStmt(a, rollbackParentContext, timeoutMillis);
1: 	 * @see PreparedStatement#executeSubStatement(Activation, Activation, boolean, long)
1: 	 */
1:     public ResultSet executeSubStatement(Activation parent,
1: 										 Activation activation,
1: 										 boolean rollbackParentContext,
1: 										 long timeoutMillis)
1: 		throws StandardException
1: 	{
1: 		parent.getLanguageConnectionContext().
1: 			setupSubStatementSessionContext(parent);
0: 		return executeStmt(activation, rollbackParentContext, timeoutMillis);
1: 	}
1: 
1: 
1: 	/**
1: 	 * @see PreparedStatement#execute
1: 	 */
1: 	public ResultSet execute(Activation activation,
1: 							 long timeoutMillis)
1: 			throws StandardException
1: 	{
0: 		return executeStmt(activation, false, timeoutMillis);
1: 	}
1: 
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1:     private ResultSet executeStmt(Activation activation,
1: 								  boolean rollbackParentContext,
1: 								  long timeoutMillis)
commit:e4caed2
/////////////////////////////////////////////////////////////////////////
1: 			// Used by activations only:
1: 		case DependencyManager.RECHECK_PRIVILEGES:
/////////////////////////////////////////////////////////////////////////
1: 
1: 		switch (action) {
1: 		case DependencyManager.RECHECK_PRIVILEGES:
1: 			return;
1: 		}
1: 
commit:6950a39
/////////////////////////////////////////////////////////////////////////
0: 		Activation callingAct = null;
1: 		StatementContext stmctx = lcc.getStatementContext();
1: 
1: 		if (stmctx != null) {
0: 			// if not null, callingAct represents the activation of
0: 			// a calling statement and this activation corresponds to
0: 			// a statement inside a stored procedure or function
0: 			callingAct = stmctx.getActivation();
1: 		}
1: 
0: 		ac.setCallActivation(callingAct);
/////////////////////////////////////////////////////////////////////////
1: 			statementContext.setActivation(activation);
1: 
commit:99d7d8b
/////////////////////////////////////////////////////////////////////////
0: 		ac.setCallActivation(lcc.getCaller());
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4793bcc
/////////////////////////////////////////////////////////////////////////
commit:08d2c15
/////////////////////////////////////////////////////////////////////////
1: 		if (!upToDate()) {
0: 			PreparedStatement ps = statement.prepare(lcc);
1: 
1: 			if (SanityManager.DEBUG)
0: 				SanityManager.ASSERT(ps == this, "ps != this");
1: 		}
/////////////////////////////////////////////////////////////////////////
commit:92c7572
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.sql.compile.StatementNode;
/////////////////////////////////////////////////////////////////////////
1: 	public boolean referencesSessionSchema(StatementNode qt)
/////////////////////////////////////////////////////////////////////////
1: 	void completeCompile(StatementNode qt)
commit:b771bbc
/////////////////////////////////////////////////////////////////////////
0: 		return  isValid && (activationClass != null) && !compilingStatement;
commit:d387dac
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	GenericPreparedStatement() {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	final void	setConstantAction( ConstantAction constantAction )
/////////////////////////////////////////////////////////////////////////
1: 	final void	setSavedObjects( Object[] objects )
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3fcea8a
/////////////////////////////////////////////////////////////////////////
0:     private long timeoutMillis; // Timeout value, in milliseconds.
/////////////////////////////////////////////////////////////////////////
0:         timeoutMillis = 0L; // 0 means no timeout; default.
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Sets a timeout value for execution of this statement.
0:      * Will also apply to each row fetch from the ResultSet
0:      * produced by this statement.
1:      *
0:      * @param timeoutMillis Timeout value in milliseconds. 0 means no timeout.
1:      */
0:     public void setQueryTimeout(long timeoutMillis)
1:     {
0:         this.timeoutMillis = timeoutMillis;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0: 				isAtomic, getSource(), pvs, rollbackParentContext, timeoutMillis);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 *	@param constantAction The big structure enclosing the Execution constants.
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.GenericPreparedStatement
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql;
1: 
0: import org.apache.derby.iapi.reference.JDBC20Translation;
1: 
0: import	org.apache.derby.catalog.Dependable;
0: import	org.apache.derby.catalog.DependableFinder;
1: 
0: import org.apache.derby.iapi.services.context.Context;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.services.monitor.ModuleFactory;
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.cache.Cacheable;
1: 
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.iapi.util.ByteArray;
1: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
1: 
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: import org.apache.derby.iapi.sql.PreparedStatement;
0: import org.apache.derby.iapi.sql.Statement;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Activation;
1: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecCursorTableReference;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.Provider;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
1: 
0: import org.apache.derby.impl.sql.compile.QueryTreeNode;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.Property;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
1: 
0: import java.sql.Timestamp;
1: import java.sql.SQLWarning;
0: import java.util.Vector;
1: 
1: /**
1:  * Basic implementation of prepared statement.
1:  * relies on implementation of ResultDescription and Statement that
1:  * are also in this package.
1:  * <p>
1:  * These are both dependents (of the schema objects and prepared statements
1:  * they depend on) and providers.  Prepared statements that are providers
1:  * are cursors that end up being used in positioned delete and update
1:  * statements (at present).
1:  * <p>
1:  * This is impl with the regular prepared statements; they will never
1:  * have the cursor info fields set.
1:  * <p>
1:  * Stored prepared statements extend this implementation
1:  *
0:  * @author ames
1:  */
1: public class GenericPreparedStatement
1: 	implements ExecPreparedStatement
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	///////////////////////////////////////////////
1: 	//
1: 	// WARNING: when adding members to this class, be
1: 	// sure to do the right thing in getClone(): if
1: 	// it is PreparedStatement specific like finished,
1: 	// then it shouldn't be copied, but stuff like parameters 
1: 	// must be copied.	
1: 	//
1: 	////////////////////////////////////////////////
1: 
1: 	////////////////////////////////////////////////
1: 	// STATE that is copied by getClone()
1: 	////////////////////////////////////////////////
1: 	public Statement statement;
1: 	protected GeneratedClass activationClass; // satisfies Activation
1: 	protected ResultDescription resultDesc;
1: 	protected DataTypeDescriptor[] paramTypeDescriptors;
1: 	private String			spsName;
1: 	private SQLWarning		warnings;
1: 
1: 	//If the query node for this statement references SESSION schema tables, mark it so in the boolean below
1: 	//This information will be used by EXECUTE STATEMENT if it is executing a statement that was created with NOCOMPILE. Because
1: 	//of NOCOMPILE, we could not catch SESSION schema table reference by the statement at CREATE STATEMENT time. Need to catch
1: 	//such statements at EXECUTE STATEMENT time when the query is getting compiled.
1: 	//This information will also be used to decide if the statement should be cached or not. Any statement referencing SESSION
1: 	//schema tables will not be cached.
1: 	private boolean		referencesSessionSchema;
1: 
1: 	// fields used for cursors
1: 	protected ExecCursorTableReference	targetTable; 
0: 	protected ResultColumnDescriptor[]	targetColumns; 
0: 	protected String[] 					updateColumns; 
1: 	protected int 						updateMode;
1: 
1: 	protected ConstantAction	executionConstants;
1: 	protected Object[]	savedObjects;
1: 
1: 	// fields for dependency tracking
1: 	protected String UUIDString;
1: 	protected UUID   UUIDValue;
1: 
0: 	private ParameterValueSet params;
1: 	private boolean needsSavepoint;
1: 
1: 	private String execStmtName;
1: 	private String execSchemaName;
1: 	protected boolean isAtomic;
1: 	protected String sourceTxt;
1: 
1: 	private int inUseCount;
1: 
1: 	// true if the statement is being compiled.
0: 	boolean compilingStatement;
1: 
1: 
1: 	////////////////////////////////////////////////
1: 	// STATE that is not copied by getClone()
1: 	////////////////////////////////////////////////
1: 	// fields for run time stats
1: 	protected long parseTime;
1: 	protected long bindTime;
1: 	protected long optimizeTime;
1: 	protected long generateTime;
1: 	protected long compileTime;
1: 	protected Timestamp beginCompileTimestamp;
1: 	protected Timestamp endCompileTimestamp;
1: 
1: 	//private boolean finished;
1: 	protected boolean isValid;
1: 	protected boolean spsAction;
1: 
1: 	// state for caching.
1: 	/**
1: 		If non-null then this object is the cacheable
1: 		that holds us in the cache.
1: 	*/
1: 	private Cacheable cacheHolder;
1: 
1: 	//
1: 	// constructors
1: 	//
1: 
0: 	protected GenericPreparedStatement() {
1: 		/* Get the UUID for this prepared statement */
1: 		UUIDFactory uuidFactory = 
0: 			Monitor.getMonitor().getUUIDFactory();
1: 
1: 		UUIDValue = uuidFactory.createUUID();
1: 		UUIDString = UUIDValue.toString();
1: 		spsAction = false;
1: 	}
1: 
1: 	/**
1: 	 */
1: 	public GenericPreparedStatement(Statement st)
1: 	{
1: 		this();
1: 
1: 		statement = st;
1: 	}
1: 
1: 	//
1: 	// PreparedStatement interface
1: 	//
1: 	public synchronized boolean	upToDate()
1: 		throws StandardException
1: 	{
0: 		boolean	upToDate =  isValid && (activationClass != null) && !compilingStatement;
1: 
0: 		// this if for the Plugin
0: 		if ( executionConstants != null )
1: 	    {
0: 			boolean		constantsUpToDate = executionConstants.upToDate();
0: 			upToDate = upToDate && constantsUpToDate;
1: 		}
1: 
0: 		return upToDate;
1: 	}
1: 
0: 	public void rePrepare(LanguageConnectionContext lcc) 
1: 		throws StandardException {
0: 		if (!upToDate())
0: 		    makeValid(lcc);
1: 	}
1: 
1: 	/**
1: 	 * Get a new activation instance.
1: 	 *
1: 	 * @exception StandardException thrown if finished.
1: 	 */
0: 	public synchronized Activation	getActivation(LanguageConnectionContext lcc, boolean scrollable) throws StandardException 
1: 	{
0: 		GeneratedClass gc = getActivationClass();
1: 
0: 		if (gc == null) {
0: 			rePrepare(lcc);
0: 			gc = getActivationClass();
1: 		}
1: 
0: 		Activation ac = new GenericActivationHolder(lcc, gc, this, scrollable);
1: 
0: 		if (params != null)
1: 		{
0: 			ac.setParameters(params, null);
1: 		}
1: 
0: 		inUseCount++;
1: 
1: 		return ac;
1: 	}
1: 
0: 	public ResultSet execute(LanguageConnectionContext lcc, boolean rollbackParentContext)
1: 		throws StandardException
1: 	{
1: 		Activation a = getActivation(lcc, false);
1: 		a.setSingleExecution();
0: 		return execute(a, false, false, rollbackParentContext);
1: 	}
1: 
1: 	/**
1: 	  *	The guts of execution.
1: 	  *
1: 	  *	@param	activation					the activation to run.
0: 	  * @param	executeQuery				Called via executeQuery
0: 	  * @param	executeUpdate				Called via executeUpdate
1: 	  * @param rollbackParentContext True if 1) the statement context is
1: 	  *  NOT a top-level context, AND 2) in the event of a statement-level
1: 	  *	 exception, the parent context needs to be rolled back, too.
1: 	  *	@return	the result set to be pawed through
1: 	  *
1: 	  *	@exception	StandardException thrown on error
1: 	  */
1: 
0: 	public ResultSet execute
0: 	(Activation activation, boolean executeQuery, boolean executeUpdate,
0: 		boolean rollbackParentContext) throws StandardException 
1: 	{
1: 		boolean				needToClearSavePoint = false;
1: 
1: 		if (activation == null || activation.getPreparedStatement() != this)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_WRONG_ACTIVATION, "execute");
1: 		}
1: 
1: recompileOutOfDatePlan:
1: 		while (true) {
1: 			// verify the activation is for me--somehow.  NOTE: This is
1: 			// different from the above check for whether the activation is
1: 			// associated with the right PreparedStatement - it's conceivable
1: 			// that someone could construct an activation of the wrong type
1: 			// that points to the right PreparedStatement.
1: 			//
1: 			//SanityManager.ASSERT(activation instanceof activationClass, "executing wrong activation");
1: 
1: 			/* This is where we set and clear savepoints around each individual
1: 			 * statement which needs one.  We don't set savepoints for cursors because
1: 			 * they're not needed and they wouldn't work in a read only database.
1: 			 * We can't set savepoints for commit/rollback because they'll get
1: 			 * blown away before we try to clear them.
1: 			 */
1: 
1: 			LanguageConnectionContext lccToUse = activation.getLanguageConnectionContext();
1: 
1:  			if (lccToUse.getLogStatementText())
1: 			{
1: 				HeaderPrintWriter istream = Monitor.getStream();
1: 				String xactId = lccToUse.getTransactionExecute().getActiveStateTxIdString();
1: 				String pvsString = "";
1: 				ParameterValueSet pvs = activation.getParameterValueSet();
1: 				if (pvs != null && pvs.getParameterCount() > 0)
1: 				{
1: 					pvsString = " with " + pvs.getParameterCount() +
1: 							" parameters " + pvs.toString();
1: 				}
1: 				istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
1: 										  xactId + 
1: 										  "), " +
1: 										  LanguageConnectionContext.lccStr +
1: 										  lccToUse.getInstanceNumber() +
1: 										  "), " +
1: 										  LanguageConnectionContext.dbnameStr +
1: 										  lccToUse.getDbname() +
1: 										  "), " +
1: 										  LanguageConnectionContext.drdaStr +
1: 										  lccToUse.getDrdaID() +
1: 										  "), Executing prepared statement: " +
1: 										  getSource() +
1: 										  " :End prepared statement" +
1: 										  pvsString);
1: 			}
1: 
1: 			ParameterValueSet pvs = activation.getParameterValueSet();
1: 
1: 			/* put it in try block to unlock the PS in any case
1: 			 */
0: 			rePrepare(lccToUse);
1: 
1: 			StatementContext statementContext = lccToUse.pushStatementContext(
0: 				isAtomic, getSource(), pvs, rollbackParentContext);
1: 
1: 			if (needsSavepoint())
1: 			{
1: 				/* Mark this position in the log so that a statement
1: 				* rollback will undo any changes.
1: 				*/
1: 				statementContext.setSavePoint();
1: 				needToClearSavePoint = true;
1: 			}
1: 
1: 			if (executionConstants != null)
1: 			{
1: 				lccToUse.validateStmtExecution(executionConstants);
1: 			}
1: 
0: 			ResultSet resultSet = null;
1: 			try {
1: 	
1: 				resultSet = activation.execute();
1: 
1: 				resultSet.open();
1: 			} catch (StandardException se) {
1: 				/* Cann't handle recompiling SPS action recompile here */
1: 				if (!se.getMessageId().equals(SQLState.LANG_STATEMENT_NEEDS_RECOMPILE)
1: 						 || spsAction)
1: 					throw se;
1: 				statementContext.cleanupOnError(se);
0: 				continue recompileOutOfDatePlan;
1: 
1: 			}
1: 
1: 
1: 			if (needToClearSavePoint)
1: 			{
1: 				/* We're done with our updates */
1: 				statementContext.clearSavePoint();
1: 			}
1: 
0: 			lccToUse.popStatementContext(statementContext, null);					
1: 
1: 			if (activation.isSingleExecution() && resultSet.isClosed())
1: 			{
1: 				// if the result set is 'done', i.e. not openable,
1: 				// then we can also release the activation.
1: 				// Note that a result set with output parameters 
1: 				// or rows to return is explicitly finished 
1: 				// by the user.
1: 				activation.close();
1: 			}
1: 
1: 
0: 			/* executeQuery() not allowed on statements
0: 			 * that return a row count,
0: 			 * executeUpdate() not allowed on statements
0: 			 * that return a ResultSet.
0: 			 * We need to do the test here so that any
0: 			 * exeception will rollback to the statement
0: 			 * savepoint.
1: 			 */
0: 			if ( (! resultSet.returnsRows()) && executeQuery)
1: 			{
0: 				throw StandardException.newException(SQLState.LANG_INVALID_CALL_TO_EXECUTE_QUERY);
1: 			}
1: 
0: 			if ( resultSet.returnsRows() && executeUpdate)
1: 			{
0: 				throw StandardException.newException(SQLState.LANG_INVALID_CALL_TO_EXECUTE_UPDATE);
1: 			}
1: 			return resultSet;
1: 			
1: 		}
1: 	}
1: 
1: 	public ResultDescription	getResultDescription()	{
1: 		return resultDesc;
1: 	}
1: 
1: 	public DataTypeDescriptor[]	getParameterTypes()	{
0: 		return paramTypeDescriptors;
1: 	}
1: 
1: 	public String getSource() {
1: 		return (sourceTxt != null) ?
1: 			sourceTxt : 
1: 			(statement == null) ? 
1: 				"null" : 
1: 				statement.getSource();
1: 	}
1: 
1: 	public void setSource(String text)
1: 	{
1: 		sourceTxt = text;
1: 	}
1: 
1: 	public final void setSPSName(String name) {
1: 		spsName = name;
1: 	}
1: 
1: 	public String getSPSName() {
1: 		return spsName;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Get the total compile time for the associated query in milliseconds.
1: 	 * Compile time can be divided into parse, bind, optimize and generate times.
1: 	 * 
1: 	 * @return long		The total compile time for the associated query in milliseconds.
1: 	 */
1: 	public long getCompileTimeInMillis()
1: 	{
1: 		return compileTime;
1: 	}
1: 
1: 	/**
1: 	 * Get the parse time for the associated query in milliseconds.
1: 	 * 
1: 	 * @return long		The parse time for the associated query in milliseconds.
1: 	 */
1: 	public long getParseTimeInMillis()
1: 	{
1: 		return parseTime;
1: 	}
1: 
1: 	/**
1: 	 * Get the bind time for the associated query in milliseconds.
1: 	 * 
1: 	 * @return long		The bind time for the associated query in milliseconds.
1: 	 */
1: 	public long getBindTimeInMillis()
1: 	{
1: 		return bindTime;
1: 	}
1: 
1: 	/**
1: 	 * Get the optimize time for the associated query in milliseconds.
1: 	 * 
1: 	 * @return long		The optimize time for the associated query in milliseconds.
1: 	 */
1: 	public long getOptimizeTimeInMillis()
1: 	{
1: 		return optimizeTime;
1: 	}
1: 
1: 	/**
1: 	 * Get the generate time for the associated query in milliseconds.
1: 	 * 
1: 	 * @return long		The generate time for the associated query in milliseconds.
1: 	 */
1: 	public long getGenerateTimeInMillis()
1: 	{
1: 		return generateTime;
1: 	}
1: 
1: 	/**
1: 	 * Get the timestamp for the beginning of compilation
1: 	 *
1: 	 * @return Timestamp	The timestamp for the beginning of compilation.
1: 	 */
1: 	public Timestamp getBeginCompileTimestamp()
1: 	{
0: 		return beginCompileTimestamp;
1: 	}
1: 
1: 	/**
1: 	 * Get the timestamp for the end of compilation
1: 	 *
1: 	 * @return Timestamp	The timestamp for the end of compilation.
1: 	 */
1: 	public Timestamp getEndCompileTimestamp()
1: 	{
0: 		return endCompileTimestamp;
1: 	}
1: 
1: 	void setCompileTimeWarnings(SQLWarning warnings) {
1: 		this.warnings = warnings;
1: 	}
1: 
1: 	public final SQLWarning getCompileTimeWarnings() {
1: 		return warnings;
1: 	}
1: 
1: 	/**
1: 	 * Set the compile time for this prepared statement.
1: 	 *
1: 	 * @param compileTime	The compile time
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	protected void setCompileTimeMillis(long parseTime, long bindTime,
1: 										long optimizeTime, 
1: 										long generateTime,
1: 										long compileTime,
1: 										Timestamp beginCompileTimestamp,
1: 										Timestamp endCompileTimestamp)
1: 	{
1: 		this.parseTime = parseTime;
1: 		this.bindTime = bindTime;
1: 		this.optimizeTime = optimizeTime;
1: 		this.generateTime = generateTime;
1: 		this.compileTime = compileTime;
1: 		this.beginCompileTimestamp = beginCompileTimestamp;
1: 		this.endCompileTimestamp = endCompileTimestamp;
1: 	}
1: 
1: 
1: 	/**
1: 		Finish marks a statement as totally unusable.
1: 	 */
1: 	public void finish(LanguageConnectionContext lcc) {
1: 
1: 		synchronized (this) {
1: 			inUseCount--;
1: 
1: 			if (cacheHolder != null)
1: 				return;
1: 
1: 			if (inUseCount != 0) {
1: 				//if (SanityManager.DEBUG) {
1: 				//	if (inUseCount < 0)
1: 				//		SanityManager.THROWASSERT("inUseCount is negative " + inUseCount + " for " + this);
1: 				//}
1: 				return; 
1: 			}
1: 		}
1: 			
1: 		// invalidate any prepared statements that
1: 		// depended on this statement (including this one)
1: 		// prepareToInvalidate(this, DependencyManager.PREPARED_STATEMENT_INVALID);
1: 		try
1: 		{
1: 			/* NOTE: Since we are non-persistent, we "know" that no exception
1: 			 * will be thrown under us.
1: 			 */
1: 			makeInvalid(DependencyManager.PREPARED_STATEMENT_RELEASE, lcc);
1: 		}
1: 		catch (StandardException se)
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
0: 				se.printStackTrace(System.out);
1: 				SanityManager.THROWASSERT(
0: 					"Unexpected exception - " + se);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 *	Set the Execution constants. This routine is called as we Prepare the
1: 	 *	statement.
1: 	 *
0: 	 *	@param	ConstantAction	The big structure enclosing the Execution constants.
1: 	 */
0: 	public	final void	setConstantAction( ConstantAction constantAction )
1: 	{
1: 		executionConstants = constantAction;
1: 	}
1: 
1: 
1: 	/**
1: 	 *	Get the Execution constants. This routine is called at Execution time.
1: 	 *
1: 	 *	@return	ConstantAction	The big structure enclosing the Execution constants.
1: 	 */
1: 	public	final ConstantAction	getConstantAction()
1: 	{
1: 		return	executionConstants;
1: 	}
1: 
1: 	/**
1: 	 *	Set the saved objects. Called when compilation completes.
1: 	 *
1: 	 *	@param	objects	The objects to save from compilation
1: 	 */
0: 	public	final void	setSavedObjects( Object[] objects )
1: 	{
1: 		savedObjects = objects;
1: 	}
1: 
1: 	/**
1: 	 *	Get the specified saved object.
1: 	 *
1: 	 *	@param	objectNum	The object to get.
1: 	 *	@return	the requested saved object.
1: 	 */
1: 	public final Object	getSavedObject(int objectNum)
1: 	{
1: 		if (SanityManager.DEBUG) {
1: 			if (!(objectNum>=0 && objectNum<savedObjects.length))
1: 			SanityManager.THROWASSERT(
1: 				"request for savedObject entry "+objectNum+" invalid; "+
1: 				"savedObjects has "+savedObjects.length+" entries");
1: 		}
1: 		return	savedObjects[objectNum];
1: 	}
1: 
1: 	/**
1: 	 *	Get the saved objects.
1: 	 *
1: 	 *	@return all the saved objects
1: 	 */
0: 	public	final Object[]	getSavedObjects()
1: 	{
0: 		return	savedObjects;
1: 	}
1: 
1: 	//
1: 	// Dependent interface
1: 	//
1: 	/**
1: 		Check that all of the dependent's dependencies are valid.
1: 
1: 		@return true if the dependent is currently valid
1: 	 */
1: 	public boolean isValid() {
1: 		return isValid;
1: 	}
1: 
1: 	/**
1: 	 * set this prepared statement to be valid, currently used by
1: 	 * GenericTriggerExecutor.
1: 	 */
1: 	public void setValid()
1: 	{
1: 		isValid = true;
1: 	}
1: 
1: 	/**
1: 	 * Indicate this prepared statement is an SPS action, currently used
1: 	 * by GenericTriggerExecutor.
1: 	 */
1: 	public void setSPSAction()
1: 	{
1: 		spsAction = true;
1: 	}
1: 
1: 	/**
1: 		Prepare to mark the dependent as invalid (due to at least one of
1: 		its dependencies being invalid).
1: 
1: 		@param	action	The action causing the invalidation
1: 		@param	p		the provider
1: 
1: 		@exception StandardException thrown if unable to make it invalid
1: 	 */
1: 	public void prepareToInvalidate(Provider p, int action, 
1: 									LanguageConnectionContext lcc) 
1: 		throws StandardException {
1: 
1: 		/*
1: 			this statement can have other open result sets
1: 			if another one is closing without any problems.
1: 
1: 			It is not a problem to create an index when there is an open
1: 			result set, since it doesn't invalidate the access path that was
1: 			chosen for the result set.
1: 		*/
1: 		switch (action) {
1: 		case DependencyManager.CHANGED_CURSOR:
1: 		case DependencyManager.CREATE_INDEX:
1: 			return;
1: 		}
1: 
1: 		/* Verify that there are no activations with open result sets
1: 		 * on this prepared statement.
1: 		 */
1: 		lcc.verifyNoOpenResultSets(this, p, action);
1: 	}
1: 
1: 
1: 	/**
1: 		Mark the dependent as invalid (due to at least one of
1: 		its dependencies being invalid).
1: 
1: 		@param	action	The action causing the invalidation
1: 
0: 	 	@exception StandardException Standard Cloudscape error policy.
1: 	 */
1: 	public void makeInvalid(int action, LanguageConnectionContext lcc)
1: 		 throws StandardException
1: 	{
1: 
1: 		boolean alreadyInvalid;
1: 		
1: 		synchronized (this) {
1: 
1: 			if (compilingStatement)
1: 				return;
1: 
1: 			alreadyInvalid = !isValid;
1: 		
1: 			// make ourseleves invalid
0: 			isValid = false;
1: 
1: 			// block compiles while we are invalidating
0: 			compilingStatement = true;
1: 		}
1: 
1: 		try {
1: 
1: 			DependencyManager dm = lcc.getDataDictionary().getDependencyManager();
1: 
0: 			if (!alreadyInvalid)
1: 			{
0: 				dm.invalidateFor(this, action, lcc);
1: 			}
1: 
1: 			/* Clear out the old dependencies on this statement as we
1: 			 * will build the new set during the reprepare in makeValid().
1: 			 */
1: 			dm.clearDependencies(lcc, this);
1: 
1: 			/*
1: 			** If we are invalidating an EXECUTE STATEMENT because of a stale
1: 			** plan, we also need to invalidate the stored prepared statement.
1: 			*/
1: 			if (execStmtName != null) {
1: 				switch (action) {
1: 				case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
1: 				case DependencyManager.CHANGED_CURSOR:
1: 				{
1: 					/*
1: 					** Get the DataDictionary, so we can get the descriptor for
1: 					** the SPP to invalidate it.
1: 					*/
1: 					DataDictionary dd = lcc.getDataDictionary();
1: 						
1: 					SchemaDescriptor sd = dd.getSchemaDescriptor(execSchemaName, lcc.getTransactionCompile(), true);
1: 					SPSDescriptor spsd = dd.getSPSDescriptor(execStmtName, sd);
1: 					spsd.makeInvalid(action, lcc);
1: 					break;
1: 				}
1: 				}
1: 			}
0: 		} finally {
1: 			synchronized (this) {
0: 				compilingStatement = false;
0: 				notifyAll();
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
0: 		Attempt to revalidate the dependent. For prepared statements,
0: 		this could go through its dependencies and check that they
0: 		are up to date; if not, it would recompile the statement.
0: 		Any failure during this attempt should throw
0: 		StandardException.unableToRevalidate().
1: 
0: 		@exception StandardException thrown if unable to make it valid
1: 	 */
0: 	public void makeValid(LanguageConnectionContext lcc) 
1: 		throws StandardException 
1: 	{
0: 		PreparedStatement ps;
1: 
0: 		// REMIND: will want to go through dependency list
0: 		// and check if we can make it valid just on faith,
0: 		// i.e. when it was marked 'possibly invalid' due
0: 		// to a rollback or some similar action.
1: 
0: 		// this ends up calling makeValid(qt, ac) below:
0: 		ps = statement.prepare(lcc);
1: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(ps == this, "ps != this");
1: 	}
1: 
1: 	/**
1: 	 * Is this dependent persistent?  A stored dependency will be required
1: 	 * if both the dependent and provider are persistent.
1: 	 *
1: 	 * @return boolean		Whether or not this dependent is persistent.
1: 	 */
1: 	public boolean isPersistent()
1: 	{
1: 		/* Non-stored prepared statements are not persistent */
1: 		return false;
1: 	}
1: 
1: 	//
1: 	// Dependable interface
1: 	//
1: 
1: 	/**		
1: 		@return the stored form of this Dependable
1: 
1: 		@see Dependable#getDependableFinder
1: 	 */
1: 	public DependableFinder getDependableFinder()
1: 	{
1: 	    return null;
1: 	}
1: 
1: 	/**
1: 	 * Return the name of this Dependable.  (Useful for errors.)
1: 	 *
1: 	 * @return String	The name of this Dependable..
1: 	 */
1: 	public String getObjectName()
1: 	{
1: 		return UUIDString;
1: 	}
1: 
1: 	/**
1: 	 * Get the Dependable's UUID String.
1: 	 *
1: 	 * @return String	The Dependable's UUID String.
1: 	 */
1: 	public UUID getObjectID()
1: 	{
1: 		return UUIDValue;
1: 	}
1: 
1: 	/**
1: 	 * Get the Dependable's class type.
1: 	 *
1: 	 * @return String		Classname that this Dependable belongs to.
1: 	 */
1: 	public String getClassType()
1: 	{
1: 		return Dependable.PREPARED_STATEMENT;
1: 	}
1: 
1: 	/**
0: 	 * Return true if the query node for this statement references SESSION schema tables.
1: 	 *
1: 	 * @return	true if references SESSION schema tables, else false
1: 	 */
1: 	public boolean referencesSessionSchema()
1: 	{
1: 		return referencesSessionSchema;
1: 	}
1: 
1: 	//
1: 	// class interface
1: 	//
1: 
1: 	/**
1: 		Makes the prepared statement valid, assigning
1: 		values for its query tree, generated class,
1: 		and associated information.
1: 
1: 		@param qt the query tree for this statement
0: 		@param dtd	The DataTypeDescriptors for the parameters, if any
0: 		@param ac the generated class for this statement
1: 
0: 		@return	true if there is a reference to SESSION schema tables, else false
1: 
1: 		@exception StandardException thrown on failure.
1: 	 */
0: 	boolean completeCompile(QueryTreeNode qt)
1: 						throws StandardException {
1: 		//if (finished)
1: 		//	throw StandardException.newException(SQLState.LANG_STATEMENT_CLOSED, "completeCompile()");
1: 
1: 		paramTypeDescriptors = qt.getParameterTypes();
1: 
0: 		//If the query references a SESSION schema table (temporary or permanent), then mark so in this statement
1: 		//This information will be used by EXECUTE STATEMENT if it is executing a statement that was created with NOCOMPILE. Because
1: 		//of NOCOMPILE, we could not catch SESSION schema table reference by the statement at CREATE STATEMENT time. Need to catch
1: 		//such statements at EXECUTE STATEMENT time when the query is getting compiled.
1: 		referencesSessionSchema = qt.referencesSessionSchema();
1: 
1: 		// erase cursor info in case statement text changed
1: 		if (targetTable!=null) {
1: 			targetTable = null;
1: 			updateMode = 0;
1: 			updateColumns = null;
0: 			targetColumns = null;
1: 		}
1: 
1: 		// get the result description (null for non-cursor statements)
1: 		// would we want to reuse an old resultDesc?
1: 		// or do we need to always replace in case this was select *?
1: 		resultDesc = qt.makeResultDescription();
1: 
1: 		// would look at resultDesc.getStatementType() but it
1: 		// doesn't call out cursors as such, so we check
1: 		// the root node type instead.
1: 
1: 		if (resultDesc != null)
1: 		{
1: 			/*
1: 				For cursors, we carry around some extra information.
1: 			 */
0: 			CursorInfo cursorInfo = (CursorInfo)qt.getCursorInfo();
1: 			if (cursorInfo != null)
1: 			{
1: 				targetTable = cursorInfo.targetTable;
0: 				targetColumns = cursorInfo.targetColumns;
1: 				updateColumns = cursorInfo.updateColumns;
1: 				updateMode = cursorInfo.updateMode;
1: 			}
1: 		}
1: 		isValid = true;
1: 
0: 		//if this statement is referencing session schema tables, then we do not want cache it. 
1: 		return referencesSessionSchema;
1: 	}
1: 
1: 	public GeneratedClass getActivationClass()
1: 		throws StandardException
1: 	{
1: 		return activationClass;
1: 	}
1: 
1: 	void setActivationClass(GeneratedClass ac)
1: 	{
1: 		activationClass = ac;
1: 	}
1: 
1: 	//
1: 	// ExecPreparedStatement
1: 	//
1: 
1: 	/**
1: 	 * the update mode of the cursor
1: 	 *
1: 	 * @return	The update mode of the cursor
1: 	 */
1: 	public int	getUpdateMode() {
1: 		return updateMode;
1: 	}
1: 
1: 	/**
1: 	 * the target table of the cursor
1: 	 *
1: 	 * @return	target table of the cursor
1: 	 */
1: 	public ExecCursorTableReference getTargetTable() 
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(targetTable!=null, "Not a cursor, no target table");
1: 		}
1: 		return targetTable;
1: 	}
1: 
1: 	/**
0: 	 * the target columns of the cursor as a result column list
1: 	 *
0: 	 * @return	target columns of the cursor as a result column list
1: 	 */
0: 	public ResultColumnDescriptor[]	getTargetColumns() {
0: 		return targetColumns;
1: 	}
1: 
1: 	/**
0: 	 * the update columns of the cursor as a update column list
1: 	 *
0: 	 * @return	update columns of the cursor as a array of strings
1: 	 */
0: 	public String[]	getUpdateColumns() 
1: 	{
0: 		return updateColumns;
1: 	}
1: 
1: 	/**
1: 	 * Return the cursor info in a single chunk.  Used
1: 	 * by StrorablePreparedStatement
1: 	 */
1: 	public Object getCursorInfo()
1: 	{
1: 		return new CursorInfo(
1: 			updateMode,
1: 			targetTable, 
0: 			targetColumns,
1: 			updateColumns);
1: 	}
1: 
1: 	void setCursorInfo(CursorInfo cursorInfo)
1: 	{
1: 		if (cursorInfo != null)
1: 		{
1: 			updateMode = cursorInfo.updateMode;
1: 			targetTable = cursorInfo.targetTable;
0: 			targetColumns = cursorInfo.targetColumns;
1: 			updateColumns = cursorInfo.updateColumns;
1: 		}
1: 	}
1: 
1: 
1: 	//
1: 	// class implementation
1: 	//
1: 
1: 	/**
1: 	 * Get the byte code saver for this statement.
1: 	 * Overridden for StorablePreparedStatement.  We
1: 	 * don't want to save anything
1: 	 *
1: 	 * @return a byte code saver (null for us)
1: 	 */
1: 	ByteArray getByteCodeSaver()
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/**
0: 	 * Set parameters to be associated with this
0: 	 * statement.  Used to process EXECUTE STATMENT <name>
0: 	 * USING <resultSet> statements -- the <resultSet>
0: 	 * is evaluated and a parameter list is generated.
0: 	 * That list is saved using this call.  Parameters
0: 	 * are set in the activation when it is created
0: 	 * (see getActivation). 
1: 	 * 
0: 	 * @param params the parameters
1: 	 */
0: 	protected void setParams(ParameterValueSet params)
1: 	{
0: 		this.params = params;
1: 	}
1: 
1: 	/**
1: 	 * Does this statement need a savepoint?  
1: 	 * 
1: 	 * @return true if this statement needs a savepoint.
1: 	 */
1: 	public boolean needsSavepoint()
1: 	{
1: 		return needsSavepoint;
1: 	}
1: 
1: 	/**
1: 	 * Set the stmts 'needsSavepoint' state.  Used
1: 	 * by an SPS to convey whether the underlying stmt
1: 	 * needs a savepoint or not.
1: 	 * 
1: 	 * @param needsSavepoint true if this statement needs a savepoint.
1: 	 */
1: 	void setNeedsSavepoint(boolean needsSavepoint)
1: 	{
1: 	 	this.needsSavepoint = needsSavepoint;
1: 	}
1: 
1: 	/**
1: 	 * Set the stmts 'isAtomic' state.  
1: 	 * 
1: 	 * @param isAtomic true if this statement must be atomic
1: 	 * (i.e. it is not ok to do a commit/rollback in the middle)
1: 	 */
1: 	void setIsAtomic(boolean isAtomic)
1: 	{
1: 	 	this.isAtomic = isAtomic;
1: 	}
1: 
1: 	/**
1: 	 * Returns whether or not this Statement requires should
1: 	 * behave atomically -- i.e. whether a user is permitted
1: 	 * to do a commit/rollback during the execution of this
1: 	 * statement.
1: 	 *
1: 	 * @return boolean	Whether or not this Statement is atomic
1: 	 */
1: 	public boolean isAtomic()
1: 	{
1: 		return isAtomic;
1: 	}
1: 
1: 	/**
1: 	 * Set the name of the statement and schema for an "execute statement"
1: 	 * command.
1: 	 */
1: 	void setExecuteStatementNameAndSchema(String execStmtName,
1: 												 String execSchemaName)
1: 	{
1: 		this.execStmtName = execStmtName;
1: 		this.execSchemaName = execSchemaName;
1: 	}
1: 
1: 	/**
1: 	 * Get a new prepared statement that is a shallow copy
1: 	 * of the current one.
1: 	 *
1: 	 * @return a new prepared statement
1: 	 * 
1: 	 * @exception StandardException on error
1: 	 */
1: 	public ExecPreparedStatement getClone() throws StandardException
1: 	{
1: 
1: 		GenericPreparedStatement clone = new GenericPreparedStatement(statement);
1: 
1: 		clone.activationClass = getActivationClass();
1: 		clone.resultDesc = resultDesc;
1: 		clone.paramTypeDescriptors = paramTypeDescriptors;
1: 		clone.executionConstants = executionConstants;
1: 		clone.UUIDString = UUIDString;
1: 		clone.UUIDValue = UUIDValue;
1: 		clone.savedObjects = savedObjects;
1: 		clone.execStmtName = execStmtName;
1: 		clone.execSchemaName = execSchemaName;
1: 		clone.isAtomic = isAtomic;
1: 		clone.sourceTxt = sourceTxt;
1: 		clone.targetTable = targetTable;
0: 		clone.targetColumns = targetColumns;
1: 		clone.updateColumns = updateColumns;
1: 		clone.updateMode = updateMode;	
0: 		clone.params = params;
1: 		clone.needsSavepoint = needsSavepoint;
1: 
1: 		return clone;
1: 	}
1: 
1: 	// cache holder stuff.
1: 	public void setCacheHolder(Cacheable cacheHolder) {
1: 
1: 		this.cacheHolder = cacheHolder;
1: 
1: 		if (cacheHolder == null) {
1: 
1: 			// need to invalidate the statement
1: 			if (!isValid || (inUseCount != 0))
1: 				return;
1: 
0: 			ContextManager cm = ContextService.getFactory().getCurrentContextManager();
1: 			LanguageConnectionContext lcc = 
1: 				(LanguageConnectionContext) 
1: 				(cm.getContext(LanguageConnectionContext.CONTEXT_ID));
1: 
1: 			// invalidate any prepared statements that
1: 			// depended on this statement (including this one)
1: 			// prepareToInvalidate(this, DependencyManager.PREPARED_STATEMENT_INVALID);
1: 			try
1: 			{
1: 				/* NOTE: Since we are non-persistent, we "know" that no exception
1: 				 * will be thrown under us.
1: 				 */
1: 				makeInvalid(DependencyManager.PREPARED_STATEMENT_RELEASE, lcc);
1: 			}
1: 			catch (StandardException se)
1: 			{
1: 				if (SanityManager.DEBUG)
1: 				{
0: 					se.printStackTrace(System.out);
1: 					SanityManager.THROWASSERT(
0: 						"Unexpected exception - " + se);
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	public String toString() {
1: 		return getObjectName();
1: 	}
1: 
1: 	public boolean isStorable() {
1: 		return false;
1: 	}
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 	 	@exception StandardException Standard Derby error policy.
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:67c1c96
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 	protected List requiredPermissionsList;
/////////////////////////////////////////////////////////////////////////
0: 
0: 	public void setRequiredPermissionsList( List requiredPermissionsList)
0: 	{
1: 		this.requiredPermissionsList = requiredPermissionsList;
0: 	}
0: 
0: 	public List getRequiredPermissionsList()
0: 	{
1: 		return requiredPermissionsList;
0: 	}
commit:6d9c32a
/////////////////////////////////////////////////////////////////////////
1: 	 * Return true if the query node for this statement references SESSION schema
1: 	 * tables/views.
1: 	 * This method gets called at the very beginning of the compile phase of any statement.
1: 	 * If the statement which needs to be compiled is already found in cache, then there is
1: 	 * no need to compile it again except the case when the statement is referencing SESSION
1: 	 * schema objects. There is a small window where such a statement might get cached 
1: 	 * temporarily (a statement referencing SESSION schema object will be removed from the
1: 	 * cache after the bind phase is over because that is when we know for sure that the 
1: 	 * statement is referencing SESSION schema objects.)
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	/**
1: 	 * Return true if the QueryTreeNode references SESSION schema tables/views.
1: 	 * The return value is also saved in the local field because it will be 
1: 	 * used by referencesSessionSchema() method. 
1: 	 * This method gets called when the statement is not found in cache and 
1: 	 * hence it is getting compiled.
1: 	 * At the beginning of compilation for any statement, first we check if
1: 	 * the statement's plan already exist in the cache. If not, then we add
1: 	 * the statement to the cache and continue with the parsing and binding.
1: 	 * At the end of the binding, this method gets called to see if the 
1: 	 * QueryTreeNode references a SESSION schema object. If it does, then
1: 	 * we want to remove it from the cache, since any statements referencing
1: 	 * SESSION schema objects should never get cached.  
0: 	 *
1: 	 * @return	true if references SESSION schema tables/views, else false
0: 	 */
0: 	public boolean referencesSessionSchema(QueryTreeNode qt)
1: 	throws StandardException {
1: 		//If the query references a SESSION schema table (temporary or permanent), then
1: 		// mark so in this statement
0: 		referencesSessionSchema = qt.referencesSessionSchema();
1: 		return(referencesSessionSchema);
0: 	}
/////////////////////////////////////////////////////////////////////////
0: 	void completeCompile(QueryTreeNode qt)
/////////////////////////////////////////////////////////////////////////
0: 		return;
commit:851bcbb
/////////////////////////////////////////////////////////////////////////
1: 			if (!spsAction) {
1: 			// only re-prepare if this isn't an SPS for a trigger-action;
1: 			// if it _is_ an SPS for a trigger action, then we can't just
1: 			// do a regular prepare because the statement might contain
1: 			// internal SQL that isn't allowed in other statements (such as a
1: 			// static method call to get the trigger context for retrieval
1: 			// of "new row" or "old row" values).  So in that case we
1: 			// skip the call to 'rePrepare' and if the statement is out
1: 			// of date, we'll get a NEEDS_COMPILE exception when we try
1: 			// to execute.  That exception will be caught by the executeSPS()
1: 			// method of the GenericTriggerExecutor class, and at that time
1: 			// the SPS action will be recompiled correctly.
0: 				rePrepare(lccToUse);
0: 			}
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:5087be8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.sql.compile.CursorNode;
/////////////////////////////////////////////////////////////////////////
1: 				isAtomic, updateMode==CursorNode.READ_ONLY, getSource(), pvs, rollbackParentContext, timeoutMillis);
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
commit:1373f5a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public ResultSet execute(LanguageConnectionContext lcc,
0:                              boolean rollbackParentContext,
0:                              long timeoutMillis)
0: 		return execute(a, false, false, rollbackParentContext, timeoutMillis);
/////////////////////////////////////////////////////////////////////////
1:       * @param timeoutMillis timeout value in milliseconds.
0:     public ResultSet execute(Activation activation,
0:                              boolean executeQuery,
0:                              boolean executeUpdate,
0:                              boolean rollbackParentContext,
0:                              long timeoutMillis)
1:         throws
1:             StandardException 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql;
0: 
0: import org.apache.derby.iapi.reference.JDBC20Translation;
0: 
0: import	org.apache.derby.catalog.Dependable;
0: import	org.apache.derby.catalog.DependableFinder;
0: 
0: import org.apache.derby.iapi.services.context.Context;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.services.monitor.ModuleFactory;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.cache.Cacheable;
0: 
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.iapi.util.ByteArray;
0: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
0: 
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: import org.apache.derby.iapi.sql.PreparedStatement;
0: import org.apache.derby.iapi.sql.Statement;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecCursorTableReference;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.Provider;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
0: 
0: import org.apache.derby.impl.sql.compile.QueryTreeNode;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.Property;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: 
0: import java.sql.Timestamp;
0: import java.sql.SQLWarning;
0: import java.util.Vector;
0: 
0: /**
0:  * Basic implementation of prepared statement.
0:  * relies on implementation of ResultDescription and Statement that
0:  * are also in this package.
0:  * <p>
0:  * These are both dependents (of the schema objects and prepared statements
0:  * they depend on) and providers.  Prepared statements that are providers
0:  * are cursors that end up being used in positioned delete and update
0:  * statements (at present).
0:  * <p>
0:  * This is impl with the regular prepared statements; they will never
0:  * have the cursor info fields set.
0:  * <p>
0:  * Stored prepared statements extend this implementation
0:  *
0:  * @author ames
0:  */
0: public class GenericPreparedStatement
0: 	implements ExecPreparedStatement
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	///////////////////////////////////////////////
0: 	//
0: 	// WARNING: when adding members to this class, be
0: 	// sure to do the right thing in getClone(): if
0: 	// it is PreparedStatement specific like finished,
0: 	// then it shouldn't be copied, but stuff like parameters 
0: 	// must be copied.	
0: 	//
0: 	////////////////////////////////////////////////
0: 
0: 	////////////////////////////////////////////////
0: 	// STATE that is copied by getClone()
0: 	////////////////////////////////////////////////
0: 	public Statement statement;
0: 	protected GeneratedClass activationClass; // satisfies Activation
0: 	protected ResultDescription resultDesc;
0: 	protected DataTypeDescriptor[] paramTypeDescriptors;
0: 	private String			spsName;
0: 	private SQLWarning		warnings;
0: 
0: 	//If the query node for this statement references SESSION schema tables, mark it so in the boolean below
0: 	//This information will be used by EXECUTE STATEMENT if it is executing a statement that was created with NOCOMPILE. Because
0: 	//of NOCOMPILE, we could not catch SESSION schema table reference by the statement at CREATE STATEMENT time. Need to catch
0: 	//such statements at EXECUTE STATEMENT time when the query is getting compiled.
0: 	//This information will also be used to decide if the statement should be cached or not. Any statement referencing SESSION
0: 	//schema tables will not be cached.
0: 	private boolean		referencesSessionSchema;
0: 
0: 	// fields used for cursors
0: 	protected ExecCursorTableReference	targetTable; 
0: 	protected ResultColumnDescriptor[]	targetColumns; 
0: 	protected String[] 					updateColumns; 
0: 	protected int 						updateMode;
0: 
0: 	protected ConstantAction	executionConstants;
0: 	protected Object[]	savedObjects;
0: 
0: 	// fields for dependency tracking
0: 	protected String UUIDString;
0: 	protected UUID   UUIDValue;
0: 
0: 	private ParameterValueSet params;
0: 	private boolean needsSavepoint;
0: 
0: 	private String execStmtName;
0: 	private String execSchemaName;
0: 	protected boolean isAtomic;
0: 	protected String sourceTxt;
0: 
0: 	private int inUseCount;
0: 
0: 	// true if the statement is being compiled.
0: 	boolean compilingStatement;
0: 
0: 
0: 	////////////////////////////////////////////////
0: 	// STATE that is not copied by getClone()
0: 	////////////////////////////////////////////////
0: 	// fields for run time stats
0: 	protected long parseTime;
0: 	protected long bindTime;
0: 	protected long optimizeTime;
0: 	protected long generateTime;
0: 	protected long compileTime;
0: 	protected Timestamp beginCompileTimestamp;
0: 	protected Timestamp endCompileTimestamp;
0: 
0: 	//private boolean finished;
0: 	protected boolean isValid;
0: 	protected boolean spsAction;
0: 
0: 	// state for caching.
0: 	/**
0: 		If non-null then this object is the cacheable
0: 		that holds us in the cache.
0: 	*/
0: 	private Cacheable cacheHolder;
0: 
0: 	//
0: 	// constructors
0: 	//
0: 
0: 	protected GenericPreparedStatement() {
0: 		/* Get the UUID for this prepared statement */
0: 		UUIDFactory uuidFactory = 
0: 			Monitor.getMonitor().getUUIDFactory();
0: 
0: 		UUIDValue = uuidFactory.createUUID();
0: 		UUIDString = UUIDValue.toString();
0: 		spsAction = false;
0: 	}
0: 
0: 	/**
0: 	 */
0: 	public GenericPreparedStatement(Statement st)
0: 	{
0: 		this();
0: 
0: 		statement = st;
0: 	}
0: 
0: 	//
0: 	// PreparedStatement interface
0: 	//
0: 	public synchronized boolean	upToDate()
0: 		throws StandardException
0: 	{
0: 		boolean	upToDate =  isValid && (activationClass != null) && !compilingStatement;
0: 
0: 		// this if for the Plugin
0: 		if ( executionConstants != null )
0: 	    {
0: 			boolean		constantsUpToDate = executionConstants.upToDate();
0: 			upToDate = upToDate && constantsUpToDate;
0: 		}
0: 
0: 		return upToDate;
0: 	}
0: 
0: 	public void rePrepare(LanguageConnectionContext lcc) 
0: 		throws StandardException {
0: 		if (!upToDate())
0: 		    makeValid(lcc);
0: 	}
0: 
0: 	/**
0: 	 * Get a new activation instance.
0: 	 *
0: 	 * @exception StandardException thrown if finished.
0: 	 */
0: 	public synchronized Activation	getActivation(LanguageConnectionContext lcc, boolean scrollable) throws StandardException 
0: 	{
0: 		GeneratedClass gc = getActivationClass();
0: 
0: 		if (gc == null) {
0: 			rePrepare(lcc);
0: 			gc = getActivationClass();
0: 		}
0: 
0: 		Activation ac = new GenericActivationHolder(lcc, gc, this, scrollable);
0: 
0: 		if (params != null)
0: 		{
0: 			ac.setParameters(params, null);
0: 		}
0: 
0: 		inUseCount++;
0: 
0: 		return ac;
0: 	}
0: 
0: 	public ResultSet execute(LanguageConnectionContext lcc, boolean rollbackParentContext)
0: 		throws StandardException
0: 	{
0: 		Activation a = getActivation(lcc, false);
0: 		a.setSingleExecution();
0: 		return execute(a, false, false, rollbackParentContext);
0: 	}
0: 
0: 	/**
0: 	  *	The guts of execution.
0: 	  *
0: 	  *	@param	activation					the activation to run.
0: 	  * @param	executeQuery				Called via executeQuery
0: 	  * @param	executeUpdate				Called via executeUpdate
0: 	  * @param rollbackParentContext True if 1) the statement context is
0: 	  *  NOT a top-level context, AND 2) in the event of a statement-level
0: 	  *	 exception, the parent context needs to be rolled back, too.
0: 	  *	@return	the result set to be pawed through
0: 	  *
0: 	  *	@exception	StandardException thrown on error
0: 	  */
0: 
0: 	public ResultSet execute
0: 	(Activation activation, boolean executeQuery, boolean executeUpdate,
0: 		boolean rollbackParentContext) throws StandardException 
0: 	{
0: 		boolean				needToClearSavePoint = false;
0: 
0: 		if (activation == null || activation.getPreparedStatement() != this)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_WRONG_ACTIVATION, "execute");
0: 		}
0: 
0: recompileOutOfDatePlan:
0: 		while (true) {
0: 			// verify the activation is for me--somehow.  NOTE: This is
0: 			// different from the above check for whether the activation is
0: 			// associated with the right PreparedStatement - it's conceivable
0: 			// that someone could construct an activation of the wrong type
0: 			// that points to the right PreparedStatement.
0: 			//
0: 			//SanityManager.ASSERT(activation instanceof activationClass, "executing wrong activation");
0: 
0: 			/* This is where we set and clear savepoints around each individual
0: 			 * statement which needs one.  We don't set savepoints for cursors because
0: 			 * they're not needed and they wouldn't work in a read only database.
0: 			 * We can't set savepoints for commit/rollback because they'll get
0: 			 * blown away before we try to clear them.
0: 			 */
0: 
0: 			LanguageConnectionContext lccToUse = activation.getLanguageConnectionContext();
0: 
0:  			if (lccToUse.getLogStatementText())
0: 			{
0: 				HeaderPrintWriter istream = Monitor.getStream();
0: 				String xactId = lccToUse.getTransactionExecute().getActiveStateTxIdString();
0: 				String pvsString = "";
0: 				ParameterValueSet pvs = activation.getParameterValueSet();
0: 				if (pvs != null && pvs.getParameterCount() > 0)
0: 				{
0: 					pvsString = " with " + pvs.getParameterCount() +
0: 							" parameters " + pvs.toString();
0: 				}
0: 				istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
0: 										  xactId + 
0: 										  "), " +
0: 										  LanguageConnectionContext.lccStr +
0: 										  lccToUse.getInstanceNumber() +
0: 										  "), " +
0: 										  LanguageConnectionContext.dbnameStr +
0: 										  lccToUse.getDbname() +
0: 										  "), " +
0: 										  LanguageConnectionContext.drdaStr +
0: 										  lccToUse.getDrdaID() +
0: 										  "), Executing prepared statement: " +
0: 										  getSource() +
0: 										  " :End prepared statement" +
0: 										  pvsString);
0: 			}
0: 
0: 			ParameterValueSet pvs = activation.getParameterValueSet();
0: 
0: 			/* put it in try block to unlock the PS in any case
0: 			 */
0: 			rePrepare(lccToUse);
0: 
0: 			StatementContext statementContext = lccToUse.pushStatementContext(
0: 				isAtomic, getSource(), pvs, rollbackParentContext);
0: 
0: 			if (needsSavepoint())
0: 			{
0: 				/* Mark this position in the log so that a statement
0: 				* rollback will undo any changes.
0: 				*/
0: 				statementContext.setSavePoint();
0: 				needToClearSavePoint = true;
0: 			}
0: 
0: 			if (executionConstants != null)
0: 			{
0: 				lccToUse.validateStmtExecution(executionConstants);
0: 			}
0: 
0: 			ResultSet resultSet = null;
0: 			try {
0: 	
0: 				resultSet = activation.execute();
0: 
0: 				resultSet.open();
0: 			} catch (StandardException se) {
0: 				/* Cann't handle recompiling SPS action recompile here */
0: 				if (!se.getMessageId().equals(SQLState.LANG_STATEMENT_NEEDS_RECOMPILE)
0: 						 || spsAction)
0: 					throw se;
0: 				statementContext.cleanupOnError(se);
0: 				continue recompileOutOfDatePlan;
0: 
0: 			}
0: 
0: 
0: 			if (needToClearSavePoint)
0: 			{
0: 				/* We're done with our updates */
0: 				statementContext.clearSavePoint();
0: 			}
0: 
0: 			lccToUse.popStatementContext(statementContext, null);					
0: 
0: 			if (activation.isSingleExecution() && resultSet.isClosed())
0: 			{
0: 				// if the result set is 'done', i.e. not openable,
0: 				// then we can also release the activation.
0: 				// Note that a result set with output parameters 
0: 				// or rows to return is explicitly finished 
0: 				// by the user.
0: 				activation.close();
0: 			}
0: 
0: 
0: 			/* executeQuery() not allowed on statements
0: 			 * that return a row count,
0: 			 * executeUpdate() not allowed on statements
0: 			 * that return a ResultSet.
0: 			 * We need to do the test here so that any
0: 			 * exeception will rollback to the statement
0: 			 * savepoint.
0: 			 */
0: 			if ( (! resultSet.returnsRows()) && executeQuery)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_INVALID_CALL_TO_EXECUTE_QUERY);
0: 			}
0: 
0: 			if ( resultSet.returnsRows() && executeUpdate)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_INVALID_CALL_TO_EXECUTE_UPDATE);
0: 			}
0: 			return resultSet;
0: 			
0: 		}
0: 	}
0: 
0: 	public ResultDescription	getResultDescription()	{
0: 		return resultDesc;
0: 	}
0: 
0: 	public DataTypeDescriptor[]	getParameterTypes()	{
0: 		return paramTypeDescriptors;
0: 	}
0: 
0: 	public String getSource() {
0: 		return (sourceTxt != null) ?
0: 			sourceTxt : 
0: 			(statement == null) ? 
0: 				"null" : 
0: 				statement.getSource();
0: 	}
0: 
0: 	public void setSource(String text)
0: 	{
0: 		sourceTxt = text;
0: 	}
0: 
0: 	public final void setSPSName(String name) {
0: 		spsName = name;
0: 	}
0: 
0: 	public String getSPSName() {
0: 		return spsName;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Get the total compile time for the associated query in milliseconds.
0: 	 * Compile time can be divided into parse, bind, optimize and generate times.
0: 	 * 
0: 	 * @return long		The total compile time for the associated query in milliseconds.
0: 	 */
0: 	public long getCompileTimeInMillis()
0: 	{
0: 		return compileTime;
0: 	}
0: 
0: 	/**
0: 	 * Get the parse time for the associated query in milliseconds.
0: 	 * 
0: 	 * @return long		The parse time for the associated query in milliseconds.
0: 	 */
0: 	public long getParseTimeInMillis()
0: 	{
0: 		return parseTime;
0: 	}
0: 
0: 	/**
0: 	 * Get the bind time for the associated query in milliseconds.
0: 	 * 
0: 	 * @return long		The bind time for the associated query in milliseconds.
0: 	 */
0: 	public long getBindTimeInMillis()
0: 	{
0: 		return bindTime;
0: 	}
0: 
0: 	/**
0: 	 * Get the optimize time for the associated query in milliseconds.
0: 	 * 
0: 	 * @return long		The optimize time for the associated query in milliseconds.
0: 	 */
0: 	public long getOptimizeTimeInMillis()
0: 	{
0: 		return optimizeTime;
0: 	}
0: 
0: 	/**
0: 	 * Get the generate time for the associated query in milliseconds.
0: 	 * 
0: 	 * @return long		The generate time for the associated query in milliseconds.
0: 	 */
0: 	public long getGenerateTimeInMillis()
0: 	{
0: 		return generateTime;
0: 	}
0: 
0: 	/**
0: 	 * Get the timestamp for the beginning of compilation
0: 	 *
0: 	 * @return Timestamp	The timestamp for the beginning of compilation.
0: 	 */
0: 	public Timestamp getBeginCompileTimestamp()
0: 	{
0: 		return beginCompileTimestamp;
0: 	}
0: 
0: 	/**
0: 	 * Get the timestamp for the end of compilation
0: 	 *
0: 	 * @return Timestamp	The timestamp for the end of compilation.
0: 	 */
0: 	public Timestamp getEndCompileTimestamp()
0: 	{
0: 		return endCompileTimestamp;
0: 	}
0: 
0: 	void setCompileTimeWarnings(SQLWarning warnings) {
0: 		this.warnings = warnings;
0: 	}
0: 
0: 	public final SQLWarning getCompileTimeWarnings() {
0: 		return warnings;
0: 	}
0: 
0: 	/**
0: 	 * Set the compile time for this prepared statement.
0: 	 *
0: 	 * @param compileTime	The compile time
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	protected void setCompileTimeMillis(long parseTime, long bindTime,
0: 										long optimizeTime, 
0: 										long generateTime,
0: 										long compileTime,
0: 										Timestamp beginCompileTimestamp,
0: 										Timestamp endCompileTimestamp)
0: 	{
0: 		this.parseTime = parseTime;
0: 		this.bindTime = bindTime;
0: 		this.optimizeTime = optimizeTime;
0: 		this.generateTime = generateTime;
0: 		this.compileTime = compileTime;
0: 		this.beginCompileTimestamp = beginCompileTimestamp;
0: 		this.endCompileTimestamp = endCompileTimestamp;
0: 	}
0: 
0: 
0: 	/**
0: 		Finish marks a statement as totally unusable.
0: 	 */
0: 	public void finish(LanguageConnectionContext lcc) {
0: 
0: 		synchronized (this) {
0: 			inUseCount--;
0: 
0: 			if (cacheHolder != null)
0: 				return;
0: 
0: 			if (inUseCount != 0) {
0: 				//if (SanityManager.DEBUG) {
0: 				//	if (inUseCount < 0)
0: 				//		SanityManager.THROWASSERT("inUseCount is negative " + inUseCount + " for " + this);
0: 				//}
0: 				return; 
0: 			}
0: 		}
0: 			
0: 		// invalidate any prepared statements that
0: 		// depended on this statement (including this one)
0: 		// prepareToInvalidate(this, DependencyManager.PREPARED_STATEMENT_INVALID);
0: 		try
0: 		{
0: 			/* NOTE: Since we are non-persistent, we "know" that no exception
0: 			 * will be thrown under us.
0: 			 */
0: 			makeInvalid(DependencyManager.PREPARED_STATEMENT_RELEASE, lcc);
0: 		}
0: 		catch (StandardException se)
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				se.printStackTrace(System.out);
0: 				SanityManager.THROWASSERT(
0: 					"Unexpected exception - " + se);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 *	Set the Execution constants. This routine is called as we Prepare the
0: 	 *	statement.
0: 	 *
0: 	 *	@param	ConstantAction	The big structure enclosing the Execution constants.
0: 	 */
0: 	public	final void	setConstantAction( ConstantAction constantAction )
0: 	{
0: 		executionConstants = constantAction;
0: 	}
0: 
0: 
0: 	/**
0: 	 *	Get the Execution constants. This routine is called at Execution time.
0: 	 *
0: 	 *	@return	ConstantAction	The big structure enclosing the Execution constants.
0: 	 */
0: 	public	final ConstantAction	getConstantAction()
0: 	{
0: 		return	executionConstants;
0: 	}
0: 
0: 	/**
0: 	 *	Set the saved objects. Called when compilation completes.
0: 	 *
0: 	 *	@param	objects	The objects to save from compilation
0: 	 */
0: 	public	final void	setSavedObjects( Object[] objects )
0: 	{
0: 		savedObjects = objects;
0: 	}
0: 
0: 	/**
0: 	 *	Get the specified saved object.
0: 	 *
0: 	 *	@param	objectNum	The object to get.
0: 	 *	@return	the requested saved object.
0: 	 */
0: 	public final Object	getSavedObject(int objectNum)
0: 	{
0: 		if (SanityManager.DEBUG) {
0: 			if (!(objectNum>=0 && objectNum<savedObjects.length))
0: 			SanityManager.THROWASSERT(
0: 				"request for savedObject entry "+objectNum+" invalid; "+
0: 				"savedObjects has "+savedObjects.length+" entries");
0: 		}
0: 		return	savedObjects[objectNum];
0: 	}
0: 
0: 	/**
0: 	 *	Get the saved objects.
0: 	 *
0: 	 *	@return all the saved objects
0: 	 */
0: 	public	final Object[]	getSavedObjects()
0: 	{
0: 		return	savedObjects;
0: 	}
0: 
0: 	//
0: 	// Dependent interface
0: 	//
0: 	/**
0: 		Check that all of the dependent's dependencies are valid.
0: 
0: 		@return true if the dependent is currently valid
0: 	 */
0: 	public boolean isValid() {
0: 		return isValid;
0: 	}
0: 
0: 	/**
0: 	 * set this prepared statement to be valid, currently used by
0: 	 * GenericTriggerExecutor.
0: 	 */
0: 	public void setValid()
0: 	{
0: 		isValid = true;
0: 	}
0: 
0: 	/**
0: 	 * Indicate this prepared statement is an SPS action, currently used
0: 	 * by GenericTriggerExecutor.
0: 	 */
0: 	public void setSPSAction()
0: 	{
0: 		spsAction = true;
0: 	}
0: 
0: 	/**
0: 		Prepare to mark the dependent as invalid (due to at least one of
0: 		its dependencies being invalid).
0: 
0: 		@param	action	The action causing the invalidation
0: 		@param	p		the provider
0: 
0: 		@exception StandardException thrown if unable to make it invalid
0: 	 */
0: 	public void prepareToInvalidate(Provider p, int action, 
0: 									LanguageConnectionContext lcc) 
0: 		throws StandardException {
0: 
0: 		/*
0: 			this statement can have other open result sets
0: 			if another one is closing without any problems.
0: 
0: 			It is not a problem to create an index when there is an open
0: 			result set, since it doesn't invalidate the access path that was
0: 			chosen for the result set.
0: 		*/
0: 		switch (action) {
0: 		case DependencyManager.CHANGED_CURSOR:
0: 		case DependencyManager.CREATE_INDEX:
0: 			return;
0: 		}
0: 
0: 		/* Verify that there are no activations with open result sets
0: 		 * on this prepared statement.
0: 		 */
0: 		lcc.verifyNoOpenResultSets(this, p, action);
0: 	}
0: 
0: 
0: 	/**
0: 		Mark the dependent as invalid (due to at least one of
0: 		its dependencies being invalid).
0: 
0: 		@param	action	The action causing the invalidation
0: 
0: 	 	@exception StandardException Standard Cloudscape error policy.
0: 	 */
0: 	public void makeInvalid(int action, LanguageConnectionContext lcc)
0: 		 throws StandardException
0: 	{
0: 
0: 		boolean alreadyInvalid;
0: 		
0: 		synchronized (this) {
0: 
0: 			if (compilingStatement)
0: 				return;
0: 
0: 			alreadyInvalid = !isValid;
0: 		
0: 			// make ourseleves invalid
0: 			isValid = false;
0: 
0: 			// block compiles while we are invalidating
0: 			compilingStatement = true;
0: 		}
0: 
0: 		try {
0: 
0: 			DependencyManager dm = lcc.getDataDictionary().getDependencyManager();
0: 
0: 			if (!alreadyInvalid)
0: 			{
0: 				dm.invalidateFor(this, action, lcc);
0: 			}
0: 
0: 			/* Clear out the old dependencies on this statement as we
0: 			 * will build the new set during the reprepare in makeValid().
0: 			 */
0: 			dm.clearDependencies(lcc, this);
0: 
0: 			/*
0: 			** If we are invalidating an EXECUTE STATEMENT because of a stale
0: 			** plan, we also need to invalidate the stored prepared statement.
0: 			*/
0: 			if (execStmtName != null) {
0: 				switch (action) {
0: 				case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
0: 				case DependencyManager.CHANGED_CURSOR:
0: 				{
0: 					/*
0: 					** Get the DataDictionary, so we can get the descriptor for
0: 					** the SPP to invalidate it.
0: 					*/
0: 					DataDictionary dd = lcc.getDataDictionary();
0: 						
0: 					SchemaDescriptor sd = dd.getSchemaDescriptor(execSchemaName, lcc.getTransactionCompile(), true);
0: 					SPSDescriptor spsd = dd.getSPSDescriptor(execStmtName, sd);
0: 					spsd.makeInvalid(action, lcc);
0: 					break;
0: 				}
0: 				}
0: 			}
0: 		} finally {
0: 			synchronized (this) {
0: 				compilingStatement = false;
0: 				notifyAll();
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 		Attempt to revalidate the dependent. For prepared statements,
0: 		this could go through its dependencies and check that they
0: 		are up to date; if not, it would recompile the statement.
0: 		Any failure during this attempt should throw
0: 		StandardException.unableToRevalidate().
0: 
0: 		@exception StandardException thrown if unable to make it valid
0: 	 */
0: 	public void makeValid(LanguageConnectionContext lcc) 
0: 		throws StandardException 
0: 	{
0: 		PreparedStatement ps;
0: 
0: 		// REMIND: will want to go through dependency list
0: 		// and check if we can make it valid just on faith,
0: 		// i.e. when it was marked 'possibly invalid' due
0: 		// to a rollback or some similar action.
0: 
0: 		// this ends up calling makeValid(qt, ac) below:
0: 		ps = statement.prepare(lcc);
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(ps == this, "ps != this");
0: 	}
0: 
0: 	/**
0: 	 * Is this dependent persistent?  A stored dependency will be required
0: 	 * if both the dependent and provider are persistent.
0: 	 *
0: 	 * @return boolean		Whether or not this dependent is persistent.
0: 	 */
0: 	public boolean isPersistent()
0: 	{
0: 		/* Non-stored prepared statements are not persistent */
0: 		return false;
0: 	}
0: 
0: 	//
0: 	// Dependable interface
0: 	//
0: 
0: 	/**		
0: 		@return the stored form of this Dependable
0: 
0: 		@see Dependable#getDependableFinder
0: 	 */
0: 	public DependableFinder getDependableFinder()
0: 	{
0: 	    return null;
0: 	}
0: 
0: 	/**
0: 	 * Return the name of this Dependable.  (Useful for errors.)
0: 	 *
0: 	 * @return String	The name of this Dependable..
0: 	 */
0: 	public String getObjectName()
0: 	{
0: 		return UUIDString;
0: 	}
0: 
0: 	/**
0: 	 * Get the Dependable's UUID String.
0: 	 *
0: 	 * @return String	The Dependable's UUID String.
0: 	 */
0: 	public UUID getObjectID()
0: 	{
0: 		return UUIDValue;
0: 	}
0: 
0: 	/**
0: 	 * Get the Dependable's class type.
0: 	 *
0: 	 * @return String		Classname that this Dependable belongs to.
0: 	 */
0: 	public String getClassType()
0: 	{
0: 		return Dependable.PREPARED_STATEMENT;
0: 	}
0: 
0: 	/**
0: 	 * Return true if the query node for this statement references SESSION schema tables.
0: 	 *
0: 	 * @return	true if references SESSION schema tables, else false
0: 	 */
0: 	public boolean referencesSessionSchema()
0: 	{
0: 		return referencesSessionSchema;
0: 	}
0: 
0: 	//
0: 	// class interface
0: 	//
0: 
0: 	/**
0: 		Makes the prepared statement valid, assigning
0: 		values for its query tree, generated class,
0: 		and associated information.
0: 
0: 		@param qt the query tree for this statement
0: 		@param dtd	The DataTypeDescriptors for the parameters, if any
0: 		@param ac the generated class for this statement
0: 
0: 		@return	true if there is a reference to SESSION schema tables, else false
0: 
0: 		@exception StandardException thrown on failure.
0: 	 */
0: 	boolean completeCompile(QueryTreeNode qt)
0: 						throws StandardException {
0: 		//if (finished)
0: 		//	throw StandardException.newException(SQLState.LANG_STATEMENT_CLOSED, "completeCompile()");
0: 
0: 		paramTypeDescriptors = qt.getParameterTypes();
0: 
0: 		//If the query references a SESSION schema table (temporary or permanent), then mark so in this statement
0: 		//This information will be used by EXECUTE STATEMENT if it is executing a statement that was created with NOCOMPILE. Because
0: 		//of NOCOMPILE, we could not catch SESSION schema table reference by the statement at CREATE STATEMENT time. Need to catch
0: 		//such statements at EXECUTE STATEMENT time when the query is getting compiled.
0: 		referencesSessionSchema = qt.referencesSessionSchema();
0: 
0: 		// erase cursor info in case statement text changed
0: 		if (targetTable!=null) {
0: 			targetTable = null;
0: 			updateMode = 0;
0: 			updateColumns = null;
0: 			targetColumns = null;
0: 		}
0: 
0: 		// get the result description (null for non-cursor statements)
0: 		// would we want to reuse an old resultDesc?
0: 		// or do we need to always replace in case this was select *?
0: 		resultDesc = qt.makeResultDescription();
0: 
0: 		// would look at resultDesc.getStatementType() but it
0: 		// doesn't call out cursors as such, so we check
0: 		// the root node type instead.
0: 
0: 		if (resultDesc != null)
0: 		{
0: 			/*
0: 				For cursors, we carry around some extra information.
0: 			 */
0: 			CursorInfo cursorInfo = (CursorInfo)qt.getCursorInfo();
0: 			if (cursorInfo != null)
0: 			{
0: 				targetTable = cursorInfo.targetTable;
0: 				targetColumns = cursorInfo.targetColumns;
0: 				updateColumns = cursorInfo.updateColumns;
0: 				updateMode = cursorInfo.updateMode;
0: 			}
0: 		}
0: 		isValid = true;
0: 
0: 		//if this statement is referencing session schema tables, then we do not want cache it. 
0: 		return referencesSessionSchema;
0: 	}
0: 
0: 	public GeneratedClass getActivationClass()
0: 		throws StandardException
0: 	{
0: 		return activationClass;
0: 	}
0: 
0: 	void setActivationClass(GeneratedClass ac)
0: 	{
0: 		activationClass = ac;
0: 	}
0: 
0: 	//
0: 	// ExecPreparedStatement
0: 	//
0: 
0: 	/**
0: 	 * the update mode of the cursor
0: 	 *
0: 	 * @return	The update mode of the cursor
0: 	 */
0: 	public int	getUpdateMode() {
0: 		return updateMode;
0: 	}
0: 
0: 	/**
0: 	 * the target table of the cursor
0: 	 *
0: 	 * @return	target table of the cursor
0: 	 */
0: 	public ExecCursorTableReference getTargetTable() 
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(targetTable!=null, "Not a cursor, no target table");
0: 		}
0: 		return targetTable;
0: 	}
0: 
0: 	/**
0: 	 * the target columns of the cursor as a result column list
0: 	 *
0: 	 * @return	target columns of the cursor as a result column list
0: 	 */
0: 	public ResultColumnDescriptor[]	getTargetColumns() {
0: 		return targetColumns;
0: 	}
0: 
0: 	/**
0: 	 * the update columns of the cursor as a update column list
0: 	 *
0: 	 * @return	update columns of the cursor as a array of strings
0: 	 */
0: 	public String[]	getUpdateColumns() 
0: 	{
0: 		return updateColumns;
0: 	}
0: 
0: 	/**
0: 	 * Return the cursor info in a single chunk.  Used
0: 	 * by StrorablePreparedStatement
0: 	 */
0: 	public Object getCursorInfo()
0: 	{
0: 		return new CursorInfo(
0: 			updateMode,
0: 			targetTable, 
0: 			targetColumns,
0: 			updateColumns);
0: 	}
0: 
0: 	void setCursorInfo(CursorInfo cursorInfo)
0: 	{
0: 		if (cursorInfo != null)
0: 		{
0: 			updateMode = cursorInfo.updateMode;
0: 			targetTable = cursorInfo.targetTable;
0: 			targetColumns = cursorInfo.targetColumns;
0: 			updateColumns = cursorInfo.updateColumns;
0: 		}
0: 	}
0: 
0: 
0: 	//
0: 	// class implementation
0: 	//
0: 
0: 	/**
0: 	 * Get the byte code saver for this statement.
0: 	 * Overridden for StorablePreparedStatement.  We
0: 	 * don't want to save anything
0: 	 *
0: 	 * @return a byte code saver (null for us)
0: 	 */
0: 	ByteArray getByteCodeSaver()
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Set parameters to be associated with this
0: 	 * statement.  Used to process EXECUTE STATMENT <name>
0: 	 * USING <resultSet> statements -- the <resultSet>
0: 	 * is evaluated and a parameter list is generated.
0: 	 * That list is saved using this call.  Parameters
0: 	 * are set in the activation when it is created
0: 	 * (see getActivation). 
0: 	 * 
0: 	 * @param params the parameters
0: 	 */
0: 	protected void setParams(ParameterValueSet params)
0: 	{
0: 		this.params = params;
0: 	}
0: 
0: 	/**
0: 	 * Does this statement need a savepoint?  
0: 	 * 
0: 	 * @return true if this statement needs a savepoint.
0: 	 */
0: 	public boolean needsSavepoint()
0: 	{
0: 		return needsSavepoint;
0: 	}
0: 
0: 	/**
0: 	 * Set the stmts 'needsSavepoint' state.  Used
0: 	 * by an SPS to convey whether the underlying stmt
0: 	 * needs a savepoint or not.
0: 	 * 
0: 	 * @param needsSavepoint true if this statement needs a savepoint.
0: 	 */
0: 	void setNeedsSavepoint(boolean needsSavepoint)
0: 	{
0: 	 	this.needsSavepoint = needsSavepoint;
0: 	}
0: 
0: 	/**
0: 	 * Set the stmts 'isAtomic' state.  
0: 	 * 
0: 	 * @param isAtomic true if this statement must be atomic
0: 	 * (i.e. it is not ok to do a commit/rollback in the middle)
0: 	 */
0: 	void setIsAtomic(boolean isAtomic)
0: 	{
0: 	 	this.isAtomic = isAtomic;
0: 	}
0: 
0: 	/**
0: 	 * Returns whether or not this Statement requires should
0: 	 * behave atomically -- i.e. whether a user is permitted
0: 	 * to do a commit/rollback during the execution of this
0: 	 * statement.
0: 	 *
0: 	 * @return boolean	Whether or not this Statement is atomic
0: 	 */
0: 	public boolean isAtomic()
0: 	{
0: 		return isAtomic;
0: 	}
0: 
0: 	/**
0: 	 * Set the name of the statement and schema for an "execute statement"
0: 	 * command.
0: 	 */
0: 	void setExecuteStatementNameAndSchema(String execStmtName,
0: 												 String execSchemaName)
0: 	{
0: 		this.execStmtName = execStmtName;
0: 		this.execSchemaName = execSchemaName;
0: 	}
0: 
0: 	/**
0: 	 * Get a new prepared statement that is a shallow copy
0: 	 * of the current one.
0: 	 *
0: 	 * @return a new prepared statement
0: 	 * 
0: 	 * @exception StandardException on error
0: 	 */
0: 	public ExecPreparedStatement getClone() throws StandardException
0: 	{
0: 
0: 		GenericPreparedStatement clone = new GenericPreparedStatement(statement);
0: 
0: 		clone.activationClass = getActivationClass();
0: 		clone.resultDesc = resultDesc;
0: 		clone.paramTypeDescriptors = paramTypeDescriptors;
0: 		clone.executionConstants = executionConstants;
0: 		clone.UUIDString = UUIDString;
0: 		clone.UUIDValue = UUIDValue;
0: 		clone.savedObjects = savedObjects;
0: 		clone.execStmtName = execStmtName;
0: 		clone.execSchemaName = execSchemaName;
0: 		clone.isAtomic = isAtomic;
0: 		clone.sourceTxt = sourceTxt;
0: 		clone.targetTable = targetTable;
0: 		clone.targetColumns = targetColumns;
0: 		clone.updateColumns = updateColumns;
0: 		clone.updateMode = updateMode;	
0: 		clone.params = params;
0: 		clone.needsSavepoint = needsSavepoint;
0: 
0: 		return clone;
0: 	}
0: 
0: 	// cache holder stuff.
0: 	public void setCacheHolder(Cacheable cacheHolder) {
0: 
0: 		this.cacheHolder = cacheHolder;
0: 
0: 		if (cacheHolder == null) {
0: 
0: 			// need to invalidate the statement
0: 			if (!isValid || (inUseCount != 0))
0: 				return;
0: 
0: 			ContextManager cm = ContextService.getFactory().getCurrentContextManager();
0: 			LanguageConnectionContext lcc = 
0: 				(LanguageConnectionContext) 
0: 				(cm.getContext(LanguageConnectionContext.CONTEXT_ID));
0: 
0: 			// invalidate any prepared statements that
0: 			// depended on this statement (including this one)
0: 			// prepareToInvalidate(this, DependencyManager.PREPARED_STATEMENT_INVALID);
0: 			try
0: 			{
0: 				/* NOTE: Since we are non-persistent, we "know" that no exception
0: 				 * will be thrown under us.
0: 				 */
0: 				makeInvalid(DependencyManager.PREPARED_STATEMENT_RELEASE, lcc);
0: 			}
0: 			catch (StandardException se)
0: 			{
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					se.printStackTrace(System.out);
0: 					SanityManager.THROWASSERT(
0: 						"Unexpected exception - " + se);
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	public String toString() {
0: 		return getObjectName();
0: 	}
0: 
0: 	public boolean isStorable() {
0: 		return false;
0: 	}
0: }
============================================================================