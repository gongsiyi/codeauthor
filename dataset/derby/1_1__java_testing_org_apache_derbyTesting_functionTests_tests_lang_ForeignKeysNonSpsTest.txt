1:efb65fe: /*
1:efb65fe: 
1:efb65fe:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ForeignKeysNonSpsTest
1:efb65fe: 
1:efb65fe:    Licensed to the Apache Software Foundation (ASF) under one or more
1:efb65fe:    contributor license agreements.  See the NOTICE file distributed with
1:efb65fe:    this work for additional information regarding copyright ownership.
1:efb65fe:    The ASF licenses this file to you under the Apache License, Version 2.0
1:efb65fe:    (the "License"); you may not use this file except in compliance with
1:efb65fe:    the License.  You may obtain a copy of the License at
1:efb65fe: 
1:efb65fe:      http://www.apache.org/licenses/LICENSE-2.0
1:efb65fe: 
1:efb65fe:    Unless required by applicable law or agreed to in writing, software
1:efb65fe:    distributed under the License is distributed on an "AS IS" BASIS,
1:efb65fe:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:efb65fe:    See the License for the specific language governing permissions and
1:efb65fe:    limitations under the License.
1:efb65fe: 
1:efb65fe:  */
1:efb65fe: 
1:efb65fe: package org.apache.derbyTesting.functionTests.tests.lang;
1:efb65fe: 
1:efb65fe: import java.sql.CallableStatement;
1:efb65fe: import java.sql.PreparedStatement;
1:efb65fe: import java.sql.ResultSet;
1:efb65fe: import java.sql.SQLException;
1:efb65fe: import java.sql.Statement;
1:efb65fe: import junit.framework.Test;
1:efb65fe: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:efb65fe: import org.apache.derbyTesting.junit.JDBC;
1:efb65fe: import org.apache.derbyTesting.junit.TestConfiguration;
1:efb65fe: 
1:efb65fe: /**
1:efb65fe:  * Test of foreign key constraints. Converted from the old harness test
1:efb65fe:  * lang/fk_nonSPS.sql
1:efb65fe:  */
1:efb65fe: public final class ForeignKeysNonSpsTest extends BaseJDBCTestCase {
1:efb65fe: 
1:efb65fe:     private static final int WAIT_TIMEOUT_DURATION = 4;
1:efb65fe: 
1:efb65fe:     /**
1:efb65fe:      * Public constructor required for running test as standalone JUnit.
1:efb65fe:      * @param name test name
1:efb65fe:      */
1:efb65fe:     public ForeignKeysNonSpsTest (String name) {
1:efb65fe:         super(name);
1:efb65fe:     }
1:efb65fe: 
1:efb65fe:     /**
1:efb65fe:      * JUnit handle
1:efb65fe:      * @return this JUnit test
1:efb65fe:      */
1:efb65fe:     public static Test suite() {
1:efb65fe:         return TestConfiguration.defaultSuite(ForeignKeysNonSpsTest.class);
1:efb65fe:     }
1:efb65fe: 
1:efb65fe:     public void testForeignKeys() throws Exception {
1:efb65fe:         ResultSet rs;
1:efb65fe:         PreparedStatement pSt;
1:efb65fe:         String [][] expRS;
1:efb65fe:         final Statement st = createStatement();
1:efb65fe:         final int initialCardSysDepends = numberOfRowsInSysdepends(st);
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "CREATE PROCEDURE WAIT_FOR_POST_COMMIT() DYNAMIC "
1:efb65fe:             + "RESULT SETS 0 LANGUAGE JAVA EXTERNAL NAME "
1:efb65fe:             + "'org.apache.derbyTesting.functionTests.util.T_Access"
1:efb65fe:             + ".waitForPostCommitToFinish' PARAMETER STYLE JAVA");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table p (c1 char(1), y int not null, c2 "
1:efb65fe:             + "char(1), x int not null, constraint pk primary key (x,y))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table f (x int not null, s smallint, y int "
1:efb65fe:             + "not null, constraint fk foreign key (x,y) references p)");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("insert into p values ('1',1,'1',1)");
1:efb65fe: 
1:efb65fe:         // should pass, foreign key constraint satisfied
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "insert into f "
1:efb65fe:             + "values "
1:efb65fe:             + "	(1,1,1),"
1:efb65fe:             + "	(1,1,1),"
1:efb65fe:             + "	(1,1,1),	"
1:efb65fe:             + "	(1,1,1),"
1:efb65fe:             + "	(1, 0, 1),"
1:efb65fe:             + "	(1,1,1),"
1:efb65fe:             + "	(1,0,1),"
1:efb65fe:             + "	(1, 0, 1)");
1:efb65fe: 
1:efb65fe:         // should FAIL, foreign key constraint violated
1:efb65fe:         assertUpdateCount(st, 8, "delete from f");
1:efb65fe: 
1:efb65fe:         assertStatementError("23503", st,
1:efb65fe:             " insert into f "
1:efb65fe:             + "values "
1:efb65fe:             + "	(1,1,1),"
1:efb65fe:             + "	(1,1,1),"
1:efb65fe:             + "	(1,1,1),	"
1:efb65fe:             + "	(1,1,1),"
1:efb65fe:             + "	(1, 1, 1),"
1:efb65fe:             + "	(2,1,666),"
1:efb65fe:             + "	(1,1,0),"
1:efb65fe:             + "	(0, 1, 0)");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table f");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // make sure boundary conditions are ok, null insert set
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table f (c1 char(1), y int, c2 char(1), x "
1:efb65fe:             + "int, constraint fk foreign key (x,y) references p)");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("insert into f select * from p where 1 = 2");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table f");
1:efb65fe:         st.executeUpdate("drop table p");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // self referencing
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table s (x int not null primary key, y int "
1:efb65fe:             + "references s, z int references s)");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "insert into s "
1:efb65fe:             + "values "
1:efb65fe:             + "	(1,1,1),"
1:efb65fe:             + "	(2,1,1),"
1:efb65fe:             + "	(10,2,1),	"
1:efb65fe:             + "	(11,1,2),"
1:efb65fe:             + "	(12,4,4),"
1:efb65fe:             + "	(4,1,1),"
1:efb65fe:             + "	(13,null,null),"
1:efb65fe:             + "	(14,1,2),"
1:efb65fe:             + "	(15,null, 1)");
1:efb65fe: 
1:efb65fe:         assertUpdateCount(st, 9, "delete from s");
1:efb65fe: 
1:efb65fe:         // bad
1:efb65fe:         assertStatementError("23503", st,
1:efb65fe:             "insert into s "
1:efb65fe:             + "values "
1:efb65fe:             + "	(1,1,1),"
1:efb65fe:             + "	(2,1,1),"
1:efb65fe:             + "	(10,2,1),	"
1:efb65fe:             + "	(11,1,2),"
1:efb65fe:             + "	(12,4,4),"
1:efb65fe:             + "	(4,1,1),"
1:efb65fe:             + "	(13,null,null),"
1:efb65fe:             + "	(14,1,2),"
1:efb65fe:             + "	(15,666, 1)");
1:efb65fe: 
1:efb65fe:         // now a test for depenencies. the insert will create new
1:efb65fe:         // index conglomerate numbers, so we want to test that a
1:efb65fe:         // statement with a constraint check that is dependent on
1:efb65fe:         // the conglomerate number that is being changed is invalidated
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table x (x int not null, y int, constraint "
1:efb65fe:             + "pk primary key (x))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table y (x int , y int, constraint fk "
1:efb65fe:             + "foreign key (x) references x)");
1:efb65fe: 
1:efb65fe:         final PreparedStatement pStIx = prepareStatement(
1:efb65fe:             "insert into x	values" +
1:efb65fe:             "(0,0)," +
1:efb65fe:             "(1,1)," +
1:efb65fe:             "(2,2)");
1:efb65fe: 
1:efb65fe:         final PreparedStatement pStIx2 = prepareStatement(
1:efb65fe:             "insert into x values" +
1:efb65fe:             "(3,3),"+
1:efb65fe:             "(4,4)");
1:efb65fe: 
1:efb65fe:         final PreparedStatement pStIy = prepareStatement(
1:efb65fe:             "insert into y values" +
1:efb65fe:             "(0,0)," +
1:efb65fe:             "(1,1)," +
1:efb65fe:             "(2,2)");
1:efb65fe: 
1:efb65fe:         final PreparedStatement dy = prepareStatement(
1:efb65fe:             "delete from y where x = 1");
1:efb65fe: 
1:efb65fe:         final PreparedStatement dx = prepareStatement(
1:efb65fe:             "delete from x where x = 1");
1:efb65fe: 
1:efb65fe:         assertUpdateCount(pStIx, 3);
1:efb65fe: 
1:efb65fe:         setAutoCommit(false);
1:efb65fe: 
1:efb65fe:         commit();
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         assertUpdateCount(dy, 0);
1:efb65fe:         assertUpdateCount(dx, 1);
1:efb65fe: 
1:efb65fe:         // will fail, no key 1 in x
1:efb65fe:         assertStatementError("23503", pStIy);
1:efb65fe: 
1:efb65fe:         rollback();
1:efb65fe: 
1:efb65fe:         assertUpdateCount(pStIy, 3);
1:efb65fe:         assertUpdateCount(dy, 1);
1:efb65fe:         assertUpdateCount(dx, 1);
1:efb65fe: 
1:efb65fe:         pStIx.close();
1:efb65fe:         pStIx2.close();
1:efb65fe:         pStIy.close();
1:efb65fe:         dy.close();
1:efb65fe:         dx.close();
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table y");
1:efb65fe:         st.executeUpdate("drop table x");
1:efb65fe:         st.executeUpdate("drop table s");
1:efb65fe: 
1:efb65fe:         setAutoCommit(true);
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // ** insert fkddl.sql simple syntax checks column constraint
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table p1 (x int not null, constraint pk1 "
1:efb65fe:             + "primary key(x))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table u1 (x int not null unique)");
1:efb65fe: 
1:efb65fe:         // table constraint
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table p2 (x int not null, y dec(5,2) not "
1:efb65fe:             + "null, constraint pk2 primary key (x,y))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table u2 (x int not null, y dec(5,2) not "
1:efb65fe:             + "null, constraint uk2 unique (x,y))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table p3 (x char(10) not null, constraint "
1:efb65fe:             + "pk3 primary key (x))");
1:efb65fe: 
1:efb65fe:         // for future use
1:efb65fe:         st.executeUpdate("create schema otherschema");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table otherschema.p1 (x int not null primary key)");
1:efb65fe: 
1:efb65fe:         // Negative test cases for foreign key TABLE constraints
1:efb65fe:         // negative: fk table, no table
1:efb65fe:         assertStatementError("X0Y46", st,
1:efb65fe:             "create table f (x int, constraint fk foreign key "
1:efb65fe:             + "(x) references notthere)");
1:efb65fe: 
1:efb65fe:         // negative: fk table, bad column
1:efb65fe:         assertStatementError("X0Y44", st,
1:efb65fe:             "create table f (x int, constraint fk foreign key "
1:efb65fe:             + "(x) references p1(notthere))");
1:efb65fe: 
1:efb65fe:         // negative: fk table, no constraint
1:efb65fe:         assertStatementError("X0Y44", st,
1:efb65fe:             "create table f (x int, constraint fk foreign key "
1:efb65fe:             + "(x) references p2(y))");
1:efb65fe: 
1:efb65fe:         // negative: fk table, wrong type
1:efb65fe:         assertStatementError("X0Y44", st,
1:efb65fe:             "create table f (x smallint, constraint fk foreign "
1:efb65fe:             + "key (x) references p1(x))");
1:efb65fe: 
1:efb65fe:         // negative: cannot reference a system table
1:efb65fe:         assertStatementError("42Y08", st,
1:efb65fe:             "create table f (x char(36), constraint fk foreign "
1:efb65fe:             + "key (x) references sys.sysforeignkeys(constraintid))");
1:efb65fe: 
1:efb65fe:         // negative: bad schema
1:efb65fe:         assertStatementError("42Y07", st,
1:efb65fe:             "create table f (x char(36), constraint fk foreign "
1:efb65fe:             + "key (x) references badschema.x)");
1:efb65fe: 
1:efb65fe:         // negative: bad column list
1:efb65fe:         assertStatementError("42X93", st,
1:efb65fe:             "create table f (x dec(5,2), y int, constraint fk "
1:efb65fe:             + "foreign key (x,z) references p2(x,y))");
1:efb65fe: 
1:efb65fe:         // negative: wrong number of columns
1:efb65fe:         assertStatementError("X0Y44", st,
1:efb65fe:             "create table f (x dec(5,2), y int, constraint fk "
1:efb65fe:             + "foreign key (x) references p2(x,y))");
1:efb65fe: 
1:efb65fe:         assertStatementError("X0Y44", st,
1:efb65fe:             " create table f (x dec(5,2), y int, constraint fk "
1:efb65fe:             + "foreign key (x,y) references p2(x))");
1:efb65fe: 
1:efb65fe:         // Negative test cases for foreign key COLUMN constraints
1:efb65fe:         // negative: fk column, no table
1:efb65fe:         assertStatementError("X0Y46", st,
1:efb65fe:             "create table f (x int references notthere)");
1:efb65fe: 
1:efb65fe:         // negative: fk column, bad column
1:efb65fe:         assertStatementError("X0Y44", st,
1:efb65fe:             "create table f (x int references p1(notthere))");
1:efb65fe: 
1:efb65fe:         // negative: fk column, no constraint
1:efb65fe:         assertStatementError("X0Y44", st,
1:efb65fe:             "create table f (x int references p2(y))");
1:efb65fe: 
1:efb65fe:         // negative: fk column, wrong type
1:efb65fe:         assertStatementError("X0Y44", st,
1:efb65fe:             "create table f (x smallint references p1(x))");
1:efb65fe: 
1:efb65fe:         // negative: cannot reference a system table
1:efb65fe:         assertStatementError("42Y08", st,
1:efb65fe:             "create table f (x char(36) references "
1:efb65fe:             + "sys.sysforeignkeys(constraintid))");
1:efb65fe: 
1:efb65fe:         // negative: bad schema
1:efb65fe:         assertStatementError("42Y07", st,
1:efb65fe:             "create table f (x char(36) references badschema.x)");
1:efb65fe: 
1:efb65fe:         // Some type checks.  Types must match exactly ok
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table f (d dec(5,2), i int, constraint fk "
1:efb65fe:             + "foreign key (i,d) references p2(x,y))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " drop table f");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table f (i int, d dec(5,2), constraint fk "
1:efb65fe:             + "foreign key (i,d) references p2(x,y))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table f");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table f (d dec(5,2), i int, constraint fk "
1:efb65fe:             + "foreign key (i,d) references u2(x,y))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table f");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table f (i int, d dec(5,2), constraint fk "
1:efb65fe:             + "foreign key (i,d) references u2(x,y))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table f");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table f (c char(10) references p3(x))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table f");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // type mismatch
1:efb65fe:         assertStatementError("X0Y44", st,
1:efb65fe:             "create table f (i int, d dec(5,1), constraint fk "
1:efb65fe:             + "foreign key (i,d) references p2(x,y))");
1:efb65fe: 
1:efb65fe:         assertStatementError("X0Y44", st,
1:efb65fe:             " create table f (i int, d dec(4,2), constraint fk "
1:efb65fe:             + "foreign key (i,d) references p2(x,y))");
1:efb65fe: 
1:efb65fe:         assertStatementError("X0Y44", st,
1:efb65fe:             " create table f (i int, d dec(4,2), constraint fk "
1:efb65fe:             + "foreign key (i,d) references p2(x,y))");
1:efb65fe: 
1:efb65fe:         assertStatementError("X0Y44", st,
1:efb65fe:             " create table f (i int, d numeric(5,2), constraint "
1:efb65fe:             + "fk foreign key (i,d) references p2(x,y))");
1:efb65fe: 
1:efb65fe:         assertStatementError("X0Y44", st,
1:efb65fe:             " create table f (c char(11) references p3(x))");
1:efb65fe: 
1:efb65fe:         assertStatementError("X0Y44", st,
1:efb65fe:             " create table f (c varchar(10) references p3(x))");
1:efb65fe: 
1:efb65fe:         // wrong order
1:efb65fe:         assertStatementError("X0Y44", st,
1:efb65fe:             "create table f (d dec(5,2), i int, constraint fk "
1:efb65fe:             + "foreign key (d,i) references p2(x,y))");
1:efb65fe: 
1:efb65fe:         // check system tables
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table f (x int, constraint fk foreign key "
1:efb65fe:             + "(x) references p1)");
1:efb65fe: 
1:efb65fe:         rs = st.executeQuery(
1:efb65fe:             " select constraintname, referencecount "
1:efb65fe:             + "	from sys.sysconstraints c, sys.sysforeignkeys fk"
1:efb65fe:             + "	where fk.keyconstraintid = c.constraintid order by "
1:efb65fe:             + "constraintname");
1:efb65fe: 
1:efb65fe:         expRS = new String [][]{{"PK1", "1"}};
1:efb65fe: 
1:efb65fe:         JDBC.assertFullResultSet(rs, expRS, true);
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table f2 (x int, constraint fk2 foreign key "
1:efb65fe:             + "(x) references p1(x))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table f3 (x int, constraint fk3 foreign key "
1:efb65fe:             + "(x) references p1(x))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table f4 (x int, constraint fk4 foreign key "
1:efb65fe:             + "(x) references p1(x))");
1:efb65fe: 
1:efb65fe:         rs = st.executeQuery(
1:efb65fe:             " select distinct constraintname, referencecount "
1:efb65fe:             + "	from sys.sysconstraints c, sys.sysforeignkeys fk"
1:efb65fe:             + "	where fk.keyconstraintid = c.constraintid order by "
1:efb65fe:             + "constraintname");
1:efb65fe: 
1:efb65fe:         expRS = new String [][]{{"PK1", "4"}};
1:efb65fe: 
1:efb65fe:         JDBC.assertFullResultSet(rs, expRS, true);
1:efb65fe: 
1:efb65fe:         rs = st.executeQuery(
1:efb65fe:             " select constraintname "
1:efb65fe:             + "	from sys.sysconstraints c, sys.sysforeignkeys fk"
1:efb65fe:             + "	where fk.constraintid = c.constraintid"
1:efb65fe:             + "	order by 1");
1:efb65fe: 
1:efb65fe:         expRS = new String [][]
1:efb65fe:         {
1:efb65fe:             {"FK"},
1:efb65fe:             {"FK2"},
1:efb65fe:             {"FK3"},
1:efb65fe:             {"FK4"}
1:efb65fe:         };
1:efb65fe: 
1:efb65fe:         JDBC.assertFullResultSet(rs, expRS, true);
1:efb65fe: 
1:efb65fe:         // we should not be able to drop the primary key
1:efb65fe:         assertStatementError("X0Y25", st,
1:efb65fe:             "alter table p1 drop constraint pk1");
1:efb65fe: 
1:efb65fe:         assertStatementError("X0Y25", st, "drop table p1");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // now lets drop the foreign keys and try again
1:efb65fe:         st.executeUpdate("drop table f2");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table f3");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table f4");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         rs = st.executeQuery(
1:efb65fe:             " select constraintname, referencecount "
1:efb65fe:             + "	from sys.sysconstraints c, sys.sysforeignkeys fk"
1:efb65fe:             + "	where fk.keyconstraintid = c.constraintid order by "
1:efb65fe:             + "constraintname");
1:efb65fe: 
1:efb65fe:         expRS = new String [][]{{"PK1", "1"}};
1:efb65fe: 
1:efb65fe:         JDBC.assertFullResultSet(rs, expRS, true);
1:efb65fe: 
1:efb65fe:         st.executeUpdate(" alter table f drop constraint fk");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         st.executeUpdate("alter table p1 drop constraint pk1");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // we shouldn't be able to add an fk on p1 now
1:efb65fe:         assertStatementError("X0Y41", st,
1:efb65fe:             "alter table f add constraint fk foreign key (x) "
1:efb65fe:             + "references p1");
1:efb65fe: 
1:efb65fe:         // add the constraint and try again
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "alter table p1 add constraint pk1 primary key (x)");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table f2 (x int, constraint fk2 foreign key "
1:efb65fe:             + "(x) references p1(x))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table f3 (x int, constraint fk3 foreign key "
1:efb65fe:             + "(x) references p1(x))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table f4 (x int, constraint fk4 foreign key "
1:efb65fe:             + "(x) references p1(x))");
1:efb65fe: 
1:efb65fe:         // drop constraint
1:efb65fe:         st.executeUpdate("alter table f4 drop constraint fk4");
1:efb65fe:         st.executeUpdate("alter table f3 drop constraint fk3");
1:efb65fe:         st.executeUpdate("alter table f2 drop constraint fk2");
1:efb65fe:         st.executeUpdate("alter table p1 drop constraint pk1");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // all fks are gone, right?
1:efb65fe:         rs = st.executeQuery(
1:efb65fe:             "select constraintname "
1:efb65fe:             + "	from sys.sysconstraints c, sys.sysforeignkeys fk"
1:efb65fe:             + "	where fk.constraintid = c.constraintid order by "
1:efb65fe:             + "constraintname");
1:efb65fe: 
1:efb65fe:         JDBC.assertDrainResults(rs, 0);
1:efb65fe: 
1:efb65fe:         // cleanup what we have done so far
1:efb65fe:         st.executeUpdate("drop table p1");
1:efb65fe:         st.executeUpdate("drop table p2");
1:efb65fe:         st.executeUpdate("drop table u1");
1:efb65fe:         st.executeUpdate("drop table u2");
1:efb65fe:         st.executeUpdate("drop table otherschema.p1");
1:efb65fe:         st.executeUpdate("drop schema otherschema restrict");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // will return dependencies for SPS metadata queries now
1:efb65fe:         // created by default database is created.
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table default_sysdepends_count(a int)");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " insert into default_sysdepends_count select "
1:efb65fe:             + "count(*) from sys.sysdepends");
1:efb65fe: 
1:efb65fe:         rs = st.executeQuery(
1:efb65fe:             " select * from default_sysdepends_count");
1:efb65fe: 
1:efb65fe:         expRS = new String [][]{{Integer.toString(initialCardSysDepends)}};
1:efb65fe: 
1:efb65fe:         JDBC.assertFullResultSet(rs, expRS, true);
1:efb65fe: 
1:efb65fe:         // now we are going to do some self referencing tests.
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table selfref (p char(10) not null primary key, "
1:efb65fe:             + "		f char(10) references selfref)");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table selfref");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table selfref (p char(10) not null, "
1:efb65fe:             + "		f char(10) references selfref, "
1:efb65fe:             + "		constraint pk primary key (p))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table selfref");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table selfref (p char(10) not null, f char(10), "
1:efb65fe:             + "		constraint f foreign key (f) references selfref(p), "
1:efb65fe:             + "		constraint pk primary key (p))");
1:efb65fe: 
1:efb65fe:         // should fail
1:efb65fe:         assertStatementError("X0Y25", st,
1:efb65fe:             "alter table selfref drop constraint pk");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "alter table selfref drop constraint f");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " alter table selfref drop constraint pk");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table selfref");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // what if a pk references another pk?  should just drop
1:efb65fe:         // the direct references (nothing special, really)
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table pr1(x int not null, "
1:efb65fe:             + "		constraint pkr1 primary key (x))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table pr2(x int not null, "
1:efb65fe:             + "		constraint pkr2 primary key(x), "
1:efb65fe:             + "		constraint fpkr2 foreign key (x) references pr1)");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table pr3(x int not null, "
1:efb65fe:             + "		constraint pkr3 primary key(x), "
1:efb65fe:             + "		constraint fpkr3 foreign key (x) references pr2)");
1:efb65fe: 
1:efb65fe:         rs = st.executeQuery(
1:efb65fe:             " select constraintname, referencecount from "
1:efb65fe:             + "sys.sysconstraints order by constraintname");
1:efb65fe: 
1:efb65fe:         expRS = new String [][]
1:efb65fe:         {
1:efb65fe:             {"FPKR2", "0"},
1:efb65fe:             {"FPKR3", "0"},
1:efb65fe:             {"PK3", "0"},
1:efb65fe:             {"PKR1", "1"},
1:efb65fe:             {"PKR2", "1"},
1:efb65fe:             {"PKR3", "0"}
1:efb65fe:         };
1:efb65fe: 
1:efb65fe:         JDBC.assertFullResultSet(rs, expRS, true);
1:efb65fe: 
1:efb65fe:         // now drop constraint pkr1
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "alter table pr2 drop constraint fpkr2");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " alter table pr1 drop constraint pkr1");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // pkr1 and pfkr2 are gone
1:efb65fe:         rs = st.executeQuery(
1:efb65fe:             "select constraintname, referencecount from "
1:efb65fe:             + "sys.sysconstraints order by constraintname");
1:efb65fe: 
1:efb65fe:         expRS = new String [][]
1:efb65fe:         {
1:efb65fe:             {"FPKR3", "0"},
1:efb65fe:             {"PK3", "0"},
1:efb65fe:             {"PKR2", "1"},
1:efb65fe:             {"PKR3", "0"}
1:efb65fe:         };
1:efb65fe: 
1:efb65fe:         JDBC.assertFullResultSet(rs, expRS, true);
1:efb65fe: 
1:efb65fe:         // cleanup
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "drop table pr3");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table pr2");
1:efb65fe:         st.executeUpdate("drop table pr1");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // should return 0, confirm no unexpected dependencies
1:efb65fe:         // verify that all rows in sys.sysdepends got dropped
1:efb65fe:         // apart from sps dependencies
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table default_sysdepends_count2(a int)");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " insert into default_sysdepends_count2 select "
1:efb65fe:             + "count(*) from sys.sysdepends");
1:efb65fe: 
1:efb65fe:         rs = st.executeQuery(
1:efb65fe:             " select default_sysdepends_count2.a - "
1:efb65fe:             + "default_sysdepends_count.a"
1:efb65fe:             + "    from default_sysdepends_count2, default_sysdepends_count");
1:efb65fe: 
1:efb65fe:         expRS = new String [][]{{"0"}};
1:efb65fe: 
1:efb65fe:         JDBC.assertFullResultSet(rs, expRS, true);
1:efb65fe: 
1:efb65fe:         // dependencies and spses
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table x (x int not null primary key, y int, "
1:efb65fe:             + "constraint xfk foreign key (y) references x)");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table y (x int, constraint yfk foreign key "
1:efb65fe:             + "(x) references x)");
1:efb65fe: 
1:efb65fe:         final PreparedStatement ss = prepareStatement(
1:efb65fe:             "select * from x");
1:efb65fe: 
1:efb65fe:         final PreparedStatement si = prepareStatement(
1:efb65fe:             "insert into x values (1,1)");
1:efb65fe: 
1:efb65fe:         final PreparedStatement su = prepareStatement(
1:efb65fe:             "update x set x = x+1, y=y+1");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " alter table x drop constraint xfk");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         setAutoCommit(false);
1:efb65fe: 
1:efb65fe:         // drop the referenced fk, should force su to be
1:efb65fe:         // recompiled since it no longer has to check the foreign
1:efb65fe:         // key table
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "alter table y drop constraint yfk");
1:efb65fe: 
1:efb65fe:         commit();
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table y");
1:efb65fe: 
1:efb65fe:         commit();
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         st.executeUpdate("drop table x");
1:efb65fe: 
1:efb65fe:         ss.close();
1:efb65fe:         si.close();
1:efb65fe:         su.close();
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table f3");
1:efb65fe:         st.executeUpdate("drop table f2");
1:efb65fe:         st.executeUpdate("drop table f");
1:efb65fe: 
1:efb65fe:         commit();
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // verify that all rows in sys.sysdepends got dropped
1:efb65fe:         // apart from sps dependencies Since, with beetle 5352; we
1:efb65fe:         // create metadata SPS for network server at database
1:efb65fe:         // bootup time so the dependencies for SPS are there.
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table default_sysdepends_count3(a int)");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " insert into default_sysdepends_count3 select "
1:efb65fe:             + "count(*) from sys.sysdepends");
1:efb65fe: 
1:efb65fe:         rs = st.executeQuery(
1:efb65fe:             " select default_sysdepends_count3.a - "
1:efb65fe:             + "default_sysdepends_count.a"
1:efb65fe:             + "    from default_sysdepends_count3, default_sysdepends_count");
1:efb65fe: 
1:efb65fe:         expRS = new String [][]{{"0"}};
1:efb65fe: 
1:efb65fe:         JDBC.assertFullResultSet(rs, expRS, true);
1:efb65fe: 
1:efb65fe:         // ** insert fkdml.sql
1:efb65fe:         setAutoCommit(true);
1:efb65fe: 
1:efb65fe:         // DML and foreign keys
1:efb65fe:         assertStatementError("42Y55", st, "drop table s");
1:efb65fe:         assertStatementError("42Y55", st, "drop table f3");
1:efb65fe:         assertStatementError("42Y55", st, "drop table f2");
1:efb65fe:         assertStatementError("42Y55", st, "drop table f");
1:efb65fe:         assertStatementError("42Y55", st, "drop table p");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table p (x int not null, y int not null, "
1:efb65fe:             + "constraint pk primary key (x,y))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table f (x int, y int, constraint fk "
1:efb65fe:             + "foreign key (x,y) references p)");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " insert into p values (1,1)");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         st.executeUpdate("insert into f values (1,1)");
1:efb65fe: 
1:efb65fe:         // fail
1:efb65fe:         assertStatementError("23503", st, "insert into f values (2,1)");
1:efb65fe:         assertStatementError("23503", st, " insert into f values (1,2)");
1:efb65fe: 
1:efb65fe:         // nulls are ok
1:efb65fe:         st.executeUpdate("insert into f values (1,null)");
1:efb65fe:         st.executeUpdate("insert into f values (null,null)");
1:efb65fe:         st.executeUpdate("insert into f values (1,null)");
1:efb65fe: 
1:efb65fe:         // update on pk, fail
1:efb65fe:         assertStatementError("23503", st, "update p set x = 2");
1:efb65fe:         assertStatementError("23503", st, "update p set y = 2");
1:efb65fe:         assertStatementError("23503", st, "update p set x = 1, y = 2");
1:efb65fe:         assertStatementError("23503", st, "update p set x = 2, y = 1");
1:efb65fe:         assertStatementError("23503", st, "update p set x = 2, y = 2");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         assertUpdateCount(st, 1, "update p set x = 1, y = 1");
1:efb65fe: 
1:efb65fe:         // delete pk, fail
1:efb65fe:         assertStatementError("23503", st, "delete from p");
1:efb65fe: 
1:efb65fe:         // delete fk, ok
1:efb65fe:         assertUpdateCount(st, 4, "delete from f");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("insert into f values (1,1)");
1:efb65fe: 
1:efb65fe:         // update fk, fail
1:efb65fe:         assertStatementError("23503", st, "update f set x = 2");
1:efb65fe:         assertStatementError("23503", st, "update f set y = 2");
1:efb65fe:         assertStatementError("23503", st, "update f set x = 1, y = 2");
1:efb65fe:         assertStatementError("23503", st, "update f set x = 2, y = 1");
1:efb65fe: 
1:efb65fe:         // update fk, ok
1:efb65fe:         assertUpdateCount(st, 1, "update f set x = 1, y = 1");
1:efb65fe: 
1:efb65fe:         // nulls ok
1:efb65fe:         assertUpdateCount(st, 1, "update f set x = null, y = 1");
1:efb65fe:         assertUpdateCount(st, 1, "update f set x = 1, y = null");
1:efb65fe:         assertUpdateCount(st, 1, "update f set x = null, y = null");
1:efb65fe:         assertUpdateCount(st, 1, "delete from f");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("insert into f values (1,1)");
1:efb65fe:         st.executeUpdate("insert into p values (2,2)");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         assertUpdateCount(st, 1, "update f set x = x+1, y = y+1");
1:efb65fe: 
1:efb65fe:         rs = st.executeQuery("select * from f");
1:efb65fe: 
1:efb65fe:         expRS = new String [][]{{"2", "2"}};
1:efb65fe: 
1:efb65fe:         JDBC.assertFullResultSet(rs, expRS, true);
1:efb65fe: 
1:efb65fe:         rs = st.executeQuery("select * from p");
1:efb65fe: 
1:efb65fe:         expRS = new String [][]
1:efb65fe:         {
1:efb65fe:             {"1", "1"},
1:efb65fe:             {"2", "2"}
1:efb65fe:         };
1:efb65fe: 
1:efb65fe:         JDBC.assertFullResultSet(rs, expRS, true);
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         assertUpdateCount(st, 2, "update p set x = x+1, y = y+1");
1:efb65fe: 
1:efb65fe:         // fail
1:efb65fe:         assertStatementError("23503", st, "update p set x = x+1, y = y+1");
1:efb65fe: 
1:efb65fe:         // BOUNDARY CONDITIONS
1:efb65fe:         assertUpdateCount(st, 1, "delete from f");
1:efb65fe:         assertUpdateCount(st, 2, "delete from p");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("insert into f select * from f");
1:efb65fe: 
1:efb65fe:         assertUpdateCount(st, 0, "delete from p where x = 9999");
1:efb65fe:         assertUpdateCount(st, 0, "update p set x = x+1, y=y+1 where x = 999");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("insert into p values (1,1)");
1:efb65fe:         st.executeUpdate("insert into f values (1,1)");
1:efb65fe: 
1:efb65fe:         assertUpdateCount(st, 0, "update p set x = x+1, y=y+1 where x = 999");
1:efb65fe:         assertUpdateCount(st, 0, "delete from p where x = 9999");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("insert into f select * from f");
1:efb65fe: 
1:efb65fe:         // test a CURSOR
1:efb65fe:         assertUpdateCount(st, 2, "delete from f");
1:efb65fe:         assertUpdateCount(st, 1, "delete from p");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("insert into p values (1,1)");
1:efb65fe:         st.executeUpdate("insert into f values (1,1)");
1:efb65fe: 
1:efb65fe:         setAutoCommit(false);
1:efb65fe: 
1:efb65fe:         final Statement uS = createStatement(
1:efb65fe:             ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
1:efb65fe:         ResultSet r = uS.executeQuery("select * from p for update of x");
1:efb65fe:         r.next();
1:efb65fe:         assertEquals(r.getString(1), "1");
1:efb65fe:         assertEquals(r.getString(2), "1");
1:efb65fe: 
1:efb65fe:         try {
1:efb65fe:             // UPDATE on table 'P' caused a violation of foreign
1:efb65fe:             // key constraint 'FK' for key (1,1).
1:efb65fe:             r.updateInt("X", 666);
1:efb65fe:         } catch (SQLException e) {
1:efb65fe:             assertSQLState("23503", e);
1:efb65fe:         }
1:efb65fe: 
1:efb65fe:         r.close();
1:efb65fe: 
1:efb65fe:         r = uS.executeQuery("select * from f for update of x");
1:efb65fe:         r.next();
1:efb65fe:         assertEquals(r.getString(1), "1");
1:efb65fe:         assertEquals(r.getString(2), "1");
1:efb65fe: 
1:efb65fe:         try {
1:efb65fe:             // UPDATE on table 'F' caused a violation of foreign
1:efb65fe:             // key constraint 'FK' for key (666,1).
1:efb65fe:             r.updateInt("X", 666);
1:efb65fe:         } catch (SQLException e) {
1:efb65fe:             assertSQLState("23503", e);
1:efb65fe:         }
1:efb65fe: 
1:efb65fe:         r.close();
1:efb65fe: 
1:efb65fe:         commit();
1:efb65fe:         setAutoCommit(true);
1:efb65fe: 
1:efb65fe:         assertUpdateCount(st, 1, "delete from f");
1:efb65fe:         assertUpdateCount(st, 1, "delete from p");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("insert into p values (0,0), (1,1), (2,2), (3,3), (4,4)");
1:efb65fe:         st.executeUpdate("insert into f values (1,1)");
1:efb65fe: 
1:efb65fe:         // lets add some additional foreign keys to the mix
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table f2 (x int, y int, constraint fk2 "
1:efb65fe:             + "foreign key (x,y) references p)");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("insert into f2 values (2,2)");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table f3 (x int, y int, constraint fk3 "
1:efb65fe:             + "foreign key (x,y) references p)");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("insert into f3 values (3,3)");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         assertUpdateCount(st, 5, "update p set x = x+1, y = y+1");
1:efb65fe: 
1:efb65fe:         // error, fk1
1:efb65fe:         assertStatementError("23503", st, "update p set x = x+1");
1:efb65fe:         assertStatementError("23503", st, "update p set y = y+1");
1:efb65fe:         assertStatementError("23503", st, "update p set x = x+1, y = y+1");
1:efb65fe: 
1:efb65fe:         // fail of fk3
1:efb65fe:         assertStatementError("23503", st, "update p set y = 666 where y = 3");
1:efb65fe: 
1:efb65fe:         // fail of fk2
1:efb65fe:         assertStatementError("23503", st, "update p set x = 666 where x = 2");
1:efb65fe: 
1:efb65fe:         // cleanup
1:efb65fe:         st.executeUpdate("drop table f");
1:efb65fe:         st.executeUpdate("drop table f2");
1:efb65fe:         st.executeUpdate("drop table f3");
1:efb65fe:         st.executeUpdate("drop table p");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // SELF REFERENCING
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table s (x int not null primary key, y int "
1:efb65fe:             + "references s, z int references s)");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         st.executeUpdate("insert into s values (1,null,null)");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         assertUpdateCount(st, 1, "update s set y = 1");
1:efb65fe: 
1:efb65fe:         // fail
1:efb65fe:         assertStatementError("23503", st, "update s set z = 2");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         assertUpdateCount(st, 1, "update s set z = 1");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         st.executeUpdate("insert into s values (2, 1, 1)");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         assertUpdateCount(st, 1, "update s set x = 666 where x = 2");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         assertUpdateCount(st, 2, "update s set x = x+1, y = y+1, z = z+1");
1:efb65fe:         assertUpdateCount(st, 2, "delete from s");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         st.executeUpdate("insert into s values (1,null,null)");
1:efb65fe:         st.executeUpdate("insert into s values (2,null,null)");
1:efb65fe:         assertUpdateCount(st, 1, "update s set y = 2 where x = 1");
1:efb65fe:         assertUpdateCount(st, 1, "update s set z = 1 where x = 2");
1:efb65fe: 
1:efb65fe:         rs = st.executeQuery("select * from s");
1:efb65fe: 
1:efb65fe:         expRS = new String [][]
1:efb65fe:         {
1:efb65fe:             {"1", "2", null},
1:efb65fe:             {"2", null, "1"}
1:efb65fe:         };
1:efb65fe: 
1:efb65fe:         JDBC.assertFullResultSet(rs, expRS, true);
1:efb65fe: 
1:efb65fe:         // fail
1:efb65fe:         assertStatementError("23503", st, "update s set x = 0 where x = 1");
1:efb65fe: 
1:efb65fe:         // Now we are going to do a short but sweet check to make
1:efb65fe:         // sure we are actually hitting the correct columns
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table p (c1 char(1), y int not null, c2 "
1:efb65fe:             + "char(1), x int not null, constraint pk primary key (x,y))");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " create table f (x int, s smallint, y int, "
1:efb65fe:             + "constraint fk foreign key (x,y) references p)");
1:efb65fe: 
1:efb65fe:         st.executeUpdate(
1:efb65fe:             " insert into p values ('1',1,'1',1)");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         st.executeUpdate("insert into f values (1,1,1)");
1:efb65fe:         st.executeUpdate("insert into p values ('0',0,'0',0)");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         assertUpdateCount(st, 2, "update p set x = x+1, y=y+1");
1:efb65fe: 
1:efb65fe:         // fail
1:efb65fe:         assertStatementError("23503", st, "delete from p where y = 1");
1:efb65fe:         assertStatementError("23503", st, "insert into f values (1,1,4)");
1:efb65fe: 
1:efb65fe:         assertUpdateCount(st, 1, "delete from f");
1:efb65fe:         assertUpdateCount(st, 2, "delete from p");
1:efb65fe: 
1:efb65fe:         // Lets make sure we don't interact poorly with 'normal'
1:efb65fe:         // deferred dml
1:efb65fe:         st.executeUpdate("insert into p values ('1',1,'1',1)");
1:efb65fe:         st.executeUpdate("insert into f values (1,1,1)");
1:efb65fe:         st.executeUpdate("insert into p values ('0',0,'0',0)");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         assertUpdateCount(st, 2,
1:efb65fe:             "update p set x = x+1, y=y+1 where x < (select "
1:efb65fe:             + "max(x)+10000 from p)");
1:efb65fe: 
1:efb65fe:         // fail
1:efb65fe:         assertStatementError("23503", st,
1:efb65fe:             "delete from p where y = 1 and y in (select y from p)");
1:efb65fe: 
1:efb65fe:         // inserts
1:efb65fe:         st.executeUpdate(
1:efb65fe:             "create table f2 (x int, t smallint, y int)");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("insert into f2 values (1,1,4)");
1:efb65fe: 
1:efb65fe:         // fail
1:efb65fe:         assertStatementError("23503", st,"insert into f select * from f2");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         st.executeUpdate("insert into f2 values (1,1,1)");
1:efb65fe:         st.executeUpdate("insert into f select * from f2 where y = 1");
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table f2");
1:efb65fe:         st.executeUpdate("drop table f");
1:efb65fe:         st.executeUpdate("drop table p");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         // PREPARED STATEMENTS
1:efb65fe:         assertStatementError("42Y55", st, "drop table f");
1:efb65fe:         assertStatementError("42Y55", st, "drop table p");
1:efb65fe: 
1:efb65fe:         //the reason for this wait call is to wait unitil system
1:efb65fe:         // tables row deletesare completed other wise we will get
1:efb65fe:         // different order fk checksthat will lead different error
1:efb65fe:         // messages depending on when post commit thread runs
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         pSt = prepareStatement(
1:efb65fe:             "create table p (w int not null primary key, x int "
1:efb65fe:             + "references p, y int not null, z int not null, "
1:efb65fe:             + "constraint uyz unique (y,z))");
1:efb65fe: 
1:efb65fe:         assertUpdateCount(pSt, 0);
1:efb65fe: 
1:efb65fe: 
1:efb65fe:         pSt = prepareStatement(
1:efb65fe:             "create table f (w int references p, x int, y int, z "
1:efb65fe:             + "int, constraint fk foreign key (y,z) references p (y,z))");
1:efb65fe: 
1:efb65fe:         assertUpdateCount(pSt, 0);
1:efb65fe: 
1:efb65fe: 
1:efb65fe:         pSt = prepareStatement(
1:efb65fe:             "alter table f drop constraint fk");
1:efb65fe: 
1:efb65fe:         assertUpdateCount(pSt, 0);
1:efb65fe: 
1:efb65fe: 
1:efb65fe:         //the reason for this wait call is to wait unitil system
1:efb65fe:         // tables row deletesare completed other wise we will get
1:efb65fe:         // different order fk checks
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         pSt = prepareStatement(
1:efb65fe:             "alter table f add constraint fk foreign key (y,z) "
1:efb65fe:             + "references p (y,z)");
1:efb65fe: 
1:efb65fe:         assertUpdateCount(pSt, 0);
1:efb65fe: 
1:efb65fe: 
1:efb65fe:         PreparedStatement sf = prepareStatement(
1:efb65fe:             "insert into f values (1,1,1,1)");
1:efb65fe: 
1:efb65fe:         PreparedStatement sp = prepareStatement(
1:efb65fe:             "insert into p values (1,1,1,1)");
1:efb65fe: 
1:efb65fe:         // fail
1:efb65fe:         assertStatementError("23503", sf);
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         assertUpdateCount(sp, 1);
1:efb65fe:         assertUpdateCount(sf, 1);
1:efb65fe: 
1:efb65fe:         st.executeUpdate(" insert into p values (2,2,2,2)");
1:efb65fe: 
1:efb65fe: 
1:efb65fe:         pSt = prepareStatement(
1:efb65fe:             "update f set w=w+1, x = x+1, y=y+1, z=z+1");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         assertUpdateCount(pSt, 1);
1:efb65fe: 
1:efb65fe:         pSt = prepareStatement("update p set w=w+1, x = x+1, y=y+1, z=z+1");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         assertUpdateCount(pSt, 2);
1:efb65fe: 
1:efb65fe:         pSt = prepareStatement("delete from p where x =1");
1:efb65fe: 
1:efb65fe:         // ok
1:efb65fe:         assertUpdateCount(pSt, 0);
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop table f");
1:efb65fe:         st.executeUpdate("drop table p");
1:efb65fe: 
1:efb65fe:         waitForPostCommit();
1:efb65fe: 
1:efb65fe:         st.executeUpdate("drop procedure WAIT_FOR_POST_COMMIT");
1:efb65fe: 
1:efb65fe:         rollback();
1:efb65fe:         st.close();
1:efb65fe:     }
1:efb65fe: 
1:efb65fe:     /**
1:efb65fe:      * Get a count of number of rows in SYS.SYSDEPENDS
1:efb65fe:      */
1:efb65fe:     private int numberOfRowsInSysdepends(Statement st) throws SQLException {
1:efb65fe:     	final ResultSet rs = 
1:efb65fe:             st.executeQuery("SELECT COUNT(*) FROM SYS.SYSDEPENDS");
1:efb65fe:     	rs.next();
1:efb65fe:         final int result = rs.getInt(1);
1:efb65fe:     	rs.close();
1:efb65fe:         return result;
1:efb65fe:     }
1:efb65fe: 
1:efb65fe:     private void waitForPostCommit() throws SQLException {
1:efb65fe:         final CallableStatement s = 
1:efb65fe:             prepareCall("CALL WAIT_FOR_POST_COMMIT()");
1:efb65fe:         assertUpdateCount(s, 0);
1:efb65fe:         s.close();
1:efb65fe:     }
1:efb65fe: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
commit:efb65fe
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ForeignKeysNonSpsTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.CallableStatement;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
0: import java.util.Properties;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Test of foreign key constraints. Converted from the old harness test
1:  * lang/fk_nonSPS.sql
1:  */
1: public final class ForeignKeysNonSpsTest extends BaseJDBCTestCase {
1: 
1:     private static final int WAIT_TIMEOUT_DURATION = 4;
1: 
1:     /**
1:      * Public constructor required for running test as standalone JUnit.
1:      * @param name test name
1:      */
1:     public ForeignKeysNonSpsTest (String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * JUnit handle
1:      * @return this JUnit test
1:      */
1:     public static Test suite() {
1:         return TestConfiguration.defaultSuite(ForeignKeysNonSpsTest.class);
1:     }
1: 
1:     public void testForeignKeys() throws Exception {
1:         ResultSet rs;
1:         PreparedStatement pSt;
1:         String [][] expRS;
1:         final Statement st = createStatement();
1:         final int initialCardSysDepends = numberOfRowsInSysdepends(st);
1: 
1:         st.executeUpdate(
1:             "CREATE PROCEDURE WAIT_FOR_POST_COMMIT() DYNAMIC "
1:             + "RESULT SETS 0 LANGUAGE JAVA EXTERNAL NAME "
1:             + "'org.apache.derbyTesting.functionTests.util.T_Access"
1:             + ".waitForPostCommitToFinish' PARAMETER STYLE JAVA");
1: 
1:         st.executeUpdate(
1:             " create table p (c1 char(1), y int not null, c2 "
1:             + "char(1), x int not null, constraint pk primary key (x,y))");
1: 
1:         st.executeUpdate(
1:             " create table f (x int not null, s smallint, y int "
1:             + "not null, constraint fk foreign key (x,y) references p)");
1: 
1:         st.executeUpdate("insert into p values ('1',1,'1',1)");
1: 
1:         // should pass, foreign key constraint satisfied
1:         st.executeUpdate(
1:             "insert into f "
1:             + "values "
1:             + "	(1,1,1),"
1:             + "	(1,1,1),"
1:             + "	(1,1,1),	"
1:             + "	(1,1,1),"
1:             + "	(1, 0, 1),"
1:             + "	(1,1,1),"
1:             + "	(1,0,1),"
1:             + "	(1, 0, 1)");
1: 
1:         // should FAIL, foreign key constraint violated
1:         assertUpdateCount(st, 8, "delete from f");
1: 
1:         assertStatementError("23503", st,
1:             " insert into f "
1:             + "values "
1:             + "	(1,1,1),"
1:             + "	(1,1,1),"
1:             + "	(1,1,1),	"
1:             + "	(1,1,1),"
1:             + "	(1, 1, 1),"
1:             + "	(2,1,666),"
1:             + "	(1,1,0),"
1:             + "	(0, 1, 0)");
1: 
1:         st.executeUpdate("drop table f");
1: 
1:         waitForPostCommit();
1: 
1:         // make sure boundary conditions are ok, null insert set
1:         st.executeUpdate(
1:             "create table f (c1 char(1), y int, c2 char(1), x "
1:             + "int, constraint fk foreign key (x,y) references p)");
1: 
1:         st.executeUpdate("insert into f select * from p where 1 = 2");
1: 
1:         st.executeUpdate("drop table f");
1:         st.executeUpdate("drop table p");
1: 
1:         waitForPostCommit();
1: 
1:         // self referencing
1:         st.executeUpdate(
1:             "create table s (x int not null primary key, y int "
1:             + "references s, z int references s)");
1: 
1:         // ok
1:         st.executeUpdate(
1:             "insert into s "
1:             + "values "
1:             + "	(1,1,1),"
1:             + "	(2,1,1),"
1:             + "	(10,2,1),	"
1:             + "	(11,1,2),"
1:             + "	(12,4,4),"
1:             + "	(4,1,1),"
1:             + "	(13,null,null),"
1:             + "	(14,1,2),"
1:             + "	(15,null, 1)");
1: 
1:         assertUpdateCount(st, 9, "delete from s");
1: 
1:         // bad
1:         assertStatementError("23503", st,
1:             "insert into s "
1:             + "values "
1:             + "	(1,1,1),"
1:             + "	(2,1,1),"
1:             + "	(10,2,1),	"
1:             + "	(11,1,2),"
1:             + "	(12,4,4),"
1:             + "	(4,1,1),"
1:             + "	(13,null,null),"
1:             + "	(14,1,2),"
1:             + "	(15,666, 1)");
1: 
1:         // now a test for depenencies. the insert will create new
1:         // index conglomerate numbers, so we want to test that a
1:         // statement with a constraint check that is dependent on
1:         // the conglomerate number that is being changed is invalidated
1:         st.executeUpdate(
1:             "create table x (x int not null, y int, constraint "
1:             + "pk primary key (x))");
1: 
1:         st.executeUpdate(
1:             " create table y (x int , y int, constraint fk "
1:             + "foreign key (x) references x)");
1: 
1:         final PreparedStatement pStIx = prepareStatement(
1:             "insert into x	values" +
1:             "(0,0)," +
1:             "(1,1)," +
1:             "(2,2)");
1: 
1:         final PreparedStatement pStIx2 = prepareStatement(
1:             "insert into x values" +
1:             "(3,3),"+
1:             "(4,4)");
1: 
1:         final PreparedStatement pStIy = prepareStatement(
1:             "insert into y values" +
1:             "(0,0)," +
1:             "(1,1)," +
1:             "(2,2)");
1: 
1:         final PreparedStatement dy = prepareStatement(
1:             "delete from y where x = 1");
1: 
1:         final PreparedStatement dx = prepareStatement(
1:             "delete from x where x = 1");
1: 
1:         assertUpdateCount(pStIx, 3);
1: 
1:         setAutoCommit(false);
1: 
1:         commit();
1: 
1:         // ok
1:         assertUpdateCount(dy, 0);
1:         assertUpdateCount(dx, 1);
1: 
1:         // will fail, no key 1 in x
1:         assertStatementError("23503", pStIy);
1: 
1:         rollback();
1: 
1:         assertUpdateCount(pStIy, 3);
1:         assertUpdateCount(dy, 1);
1:         assertUpdateCount(dx, 1);
1: 
1:         pStIx.close();
1:         pStIx2.close();
1:         pStIy.close();
1:         dy.close();
1:         dx.close();
1: 
1:         st.executeUpdate("drop table y");
1:         st.executeUpdate("drop table x");
1:         st.executeUpdate("drop table s");
1: 
1:         setAutoCommit(true);
1: 
1:         waitForPostCommit();
1: 
1:         // ** insert fkddl.sql simple syntax checks column constraint
1:         st.executeUpdate(
1:             "create table p1 (x int not null, constraint pk1 "
1:             + "primary key(x))");
1: 
1:         st.executeUpdate(
1:             " create table u1 (x int not null unique)");
1: 
1:         // table constraint
1:         st.executeUpdate(
1:             "create table p2 (x int not null, y dec(5,2) not "
1:             + "null, constraint pk2 primary key (x,y))");
1: 
1:         st.executeUpdate(
1:             " create table u2 (x int not null, y dec(5,2) not "
1:             + "null, constraint uk2 unique (x,y))");
1: 
1:         st.executeUpdate(
1:             " create table p3 (x char(10) not null, constraint "
1:             + "pk3 primary key (x))");
1: 
1:         // for future use
1:         st.executeUpdate("create schema otherschema");
1: 
1:         st.executeUpdate(
1:             " create table otherschema.p1 (x int not null primary key)");
1: 
1:         // Negative test cases for foreign key TABLE constraints
1:         // negative: fk table, no table
1:         assertStatementError("X0Y46", st,
1:             "create table f (x int, constraint fk foreign key "
1:             + "(x) references notthere)");
1: 
1:         // negative: fk table, bad column
1:         assertStatementError("X0Y44", st,
1:             "create table f (x int, constraint fk foreign key "
1:             + "(x) references p1(notthere))");
1: 
1:         // negative: fk table, no constraint
1:         assertStatementError("X0Y44", st,
1:             "create table f (x int, constraint fk foreign key "
1:             + "(x) references p2(y))");
1: 
1:         // negative: fk table, wrong type
1:         assertStatementError("X0Y44", st,
1:             "create table f (x smallint, constraint fk foreign "
1:             + "key (x) references p1(x))");
1: 
1:         // negative: cannot reference a system table
1:         assertStatementError("42Y08", st,
1:             "create table f (x char(36), constraint fk foreign "
1:             + "key (x) references sys.sysforeignkeys(constraintid))");
1: 
1:         // negative: bad schema
1:         assertStatementError("42Y07", st,
1:             "create table f (x char(36), constraint fk foreign "
1:             + "key (x) references badschema.x)");
1: 
1:         // negative: bad column list
1:         assertStatementError("42X93", st,
1:             "create table f (x dec(5,2), y int, constraint fk "
1:             + "foreign key (x,z) references p2(x,y))");
1: 
1:         // negative: wrong number of columns
1:         assertStatementError("X0Y44", st,
1:             "create table f (x dec(5,2), y int, constraint fk "
1:             + "foreign key (x) references p2(x,y))");
1: 
1:         assertStatementError("X0Y44", st,
1:             " create table f (x dec(5,2), y int, constraint fk "
1:             + "foreign key (x,y) references p2(x))");
1: 
1:         // Negative test cases for foreign key COLUMN constraints
1:         // negative: fk column, no table
1:         assertStatementError("X0Y46", st,
1:             "create table f (x int references notthere)");
1: 
1:         // negative: fk column, bad column
1:         assertStatementError("X0Y44", st,
1:             "create table f (x int references p1(notthere))");
1: 
1:         // negative: fk column, no constraint
1:         assertStatementError("X0Y44", st,
1:             "create table f (x int references p2(y))");
1: 
1:         // negative: fk column, wrong type
1:         assertStatementError("X0Y44", st,
1:             "create table f (x smallint references p1(x))");
1: 
1:         // negative: cannot reference a system table
1:         assertStatementError("42Y08", st,
1:             "create table f (x char(36) references "
1:             + "sys.sysforeignkeys(constraintid))");
1: 
1:         // negative: bad schema
1:         assertStatementError("42Y07", st,
1:             "create table f (x char(36) references badschema.x)");
1: 
1:         // Some type checks.  Types must match exactly ok
1:         st.executeUpdate(
1:             "create table f (d dec(5,2), i int, constraint fk "
1:             + "foreign key (i,d) references p2(x,y))");
1: 
1:         st.executeUpdate(
1:             " drop table f");
1: 
1:         waitForPostCommit();
1: 
1:         st.executeUpdate(
1:             " create table f (i int, d dec(5,2), constraint fk "
1:             + "foreign key (i,d) references p2(x,y))");
1: 
1:         st.executeUpdate("drop table f");
1: 
1:         waitForPostCommit();
1: 
1:         st.executeUpdate(
1:             " create table f (d dec(5,2), i int, constraint fk "
1:             + "foreign key (i,d) references u2(x,y))");
1: 
1:         st.executeUpdate("drop table f");
1: 
1:         waitForPostCommit();
1: 
1:         st.executeUpdate(
1:             " create table f (i int, d dec(5,2), constraint fk "
1:             + "foreign key (i,d) references u2(x,y))");
1: 
1:         st.executeUpdate("drop table f");
1: 
1:         waitForPostCommit();
1: 
1:         st.executeUpdate(
1:             " create table f (c char(10) references p3(x))");
1: 
1:         st.executeUpdate("drop table f");
1: 
1:         waitForPostCommit();
1: 
1:         // type mismatch
1:         assertStatementError("X0Y44", st,
1:             "create table f (i int, d dec(5,1), constraint fk "
1:             + "foreign key (i,d) references p2(x,y))");
1: 
1:         assertStatementError("X0Y44", st,
1:             " create table f (i int, d dec(4,2), constraint fk "
1:             + "foreign key (i,d) references p2(x,y))");
1: 
1:         assertStatementError("X0Y44", st,
1:             " create table f (i int, d dec(4,2), constraint fk "
1:             + "foreign key (i,d) references p2(x,y))");
1: 
1:         assertStatementError("X0Y44", st,
1:             " create table f (i int, d numeric(5,2), constraint "
1:             + "fk foreign key (i,d) references p2(x,y))");
1: 
1:         assertStatementError("X0Y44", st,
1:             " create table f (c char(11) references p3(x))");
1: 
1:         assertStatementError("X0Y44", st,
1:             " create table f (c varchar(10) references p3(x))");
1: 
1:         // wrong order
1:         assertStatementError("X0Y44", st,
1:             "create table f (d dec(5,2), i int, constraint fk "
1:             + "foreign key (d,i) references p2(x,y))");
1: 
1:         // check system tables
1:         st.executeUpdate(
1:             "create table f (x int, constraint fk foreign key "
1:             + "(x) references p1)");
1: 
1:         rs = st.executeQuery(
1:             " select constraintname, referencecount "
1:             + "	from sys.sysconstraints c, sys.sysforeignkeys fk"
1:             + "	where fk.keyconstraintid = c.constraintid order by "
1:             + "constraintname");
1: 
1:         expRS = new String [][]{{"PK1", "1"}};
1: 
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         st.executeUpdate(
1:             " create table f2 (x int, constraint fk2 foreign key "
1:             + "(x) references p1(x))");
1: 
1:         st.executeUpdate(
1:             " create table f3 (x int, constraint fk3 foreign key "
1:             + "(x) references p1(x))");
1: 
1:         st.executeUpdate(
1:             " create table f4 (x int, constraint fk4 foreign key "
1:             + "(x) references p1(x))");
1: 
1:         rs = st.executeQuery(
1:             " select distinct constraintname, referencecount "
1:             + "	from sys.sysconstraints c, sys.sysforeignkeys fk"
1:             + "	where fk.keyconstraintid = c.constraintid order by "
1:             + "constraintname");
1: 
1:         expRS = new String [][]{{"PK1", "4"}};
1: 
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         rs = st.executeQuery(
1:             " select constraintname "
1:             + "	from sys.sysconstraints c, sys.sysforeignkeys fk"
1:             + "	where fk.constraintid = c.constraintid"
1:             + "	order by 1");
1: 
1:         expRS = new String [][]
1:         {
1:             {"FK"},
1:             {"FK2"},
1:             {"FK3"},
1:             {"FK4"}
1:         };
1: 
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // we should not be able to drop the primary key
1:         assertStatementError("X0Y25", st,
1:             "alter table p1 drop constraint pk1");
1: 
1:         assertStatementError("X0Y25", st, "drop table p1");
1: 
1:         waitForPostCommit();
1: 
1:         // now lets drop the foreign keys and try again
1:         st.executeUpdate("drop table f2");
1: 
1:         st.executeUpdate("drop table f3");
1: 
1:         st.executeUpdate("drop table f4");
1: 
1:         waitForPostCommit();
1: 
1:         rs = st.executeQuery(
1:             " select constraintname, referencecount "
1:             + "	from sys.sysconstraints c, sys.sysforeignkeys fk"
1:             + "	where fk.keyconstraintid = c.constraintid order by "
1:             + "constraintname");
1: 
1:         expRS = new String [][]{{"PK1", "1"}};
1: 
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         st.executeUpdate(" alter table f drop constraint fk");
1: 
1:         waitForPostCommit();
1: 
1:         // ok
1:         st.executeUpdate("alter table p1 drop constraint pk1");
1: 
1:         waitForPostCommit();
1: 
1:         // we shouldn't be able to add an fk on p1 now
1:         assertStatementError("X0Y41", st,
1:             "alter table f add constraint fk foreign key (x) "
1:             + "references p1");
1: 
1:         // add the constraint and try again
1:         st.executeUpdate(
1:             "alter table p1 add constraint pk1 primary key (x)");
1: 
1:         st.executeUpdate(
1:             " create table f2 (x int, constraint fk2 foreign key "
1:             + "(x) references p1(x))");
1: 
1:         st.executeUpdate(
1:             " create table f3 (x int, constraint fk3 foreign key "
1:             + "(x) references p1(x))");
1: 
1:         st.executeUpdate(
1:             " create table f4 (x int, constraint fk4 foreign key "
1:             + "(x) references p1(x))");
1: 
1:         // drop constraint
1:         st.executeUpdate("alter table f4 drop constraint fk4");
1:         st.executeUpdate("alter table f3 drop constraint fk3");
1:         st.executeUpdate("alter table f2 drop constraint fk2");
1:         st.executeUpdate("alter table p1 drop constraint pk1");
1: 
1:         waitForPostCommit();
1: 
1:         // all fks are gone, right?
1:         rs = st.executeQuery(
1:             "select constraintname "
1:             + "	from sys.sysconstraints c, sys.sysforeignkeys fk"
1:             + "	where fk.constraintid = c.constraintid order by "
1:             + "constraintname");
1: 
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         // cleanup what we have done so far
1:         st.executeUpdate("drop table p1");
1:         st.executeUpdate("drop table p2");
1:         st.executeUpdate("drop table u1");
1:         st.executeUpdate("drop table u2");
1:         st.executeUpdate("drop table otherschema.p1");
1:         st.executeUpdate("drop schema otherschema restrict");
1: 
1:         waitForPostCommit();
1: 
1:         // will return dependencies for SPS metadata queries now
1:         // created by default database is created.
1:         st.executeUpdate(
1:             "create table default_sysdepends_count(a int)");
1: 
1:         st.executeUpdate(
1:             " insert into default_sysdepends_count select "
1:             + "count(*) from sys.sysdepends");
1: 
1:         rs = st.executeQuery(
1:             " select * from default_sysdepends_count");
1: 
1:         expRS = new String [][]{{Integer.toString(initialCardSysDepends)}};
1: 
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // now we are going to do some self referencing tests.
1:         st.executeUpdate(
1:             "create table selfref (p char(10) not null primary key, "
1:             + "		f char(10) references selfref)");
1: 
1:         st.executeUpdate("drop table selfref");
1: 
1:         waitForPostCommit();
1: 
1:         // ok
1:         st.executeUpdate(
1:             "create table selfref (p char(10) not null, "
1:             + "		f char(10) references selfref, "
1:             + "		constraint pk primary key (p))");
1: 
1:         st.executeUpdate("drop table selfref");
1: 
1:         waitForPostCommit();
1: 
1:         // ok
1:         st.executeUpdate(
1:             "create table selfref (p char(10) not null, f char(10), "
1:             + "		constraint f foreign key (f) references selfref(p), "
1:             + "		constraint pk primary key (p))");
1: 
1:         // should fail
1:         assertStatementError("X0Y25", st,
1:             "alter table selfref drop constraint pk");
1: 
1:         waitForPostCommit();
1: 
1:         // ok
1:         st.executeUpdate(
1:             "alter table selfref drop constraint f");
1: 
1:         st.executeUpdate(
1:             " alter table selfref drop constraint pk");
1: 
1:         st.executeUpdate("drop table selfref");
1: 
1:         waitForPostCommit();
1: 
1:         // what if a pk references another pk?  should just drop
1:         // the direct references (nothing special, really)
1:         st.executeUpdate(
1:             "create table pr1(x int not null, "
1:             + "		constraint pkr1 primary key (x))");
1: 
1:         st.executeUpdate(
1:             " create table pr2(x int not null, "
1:             + "		constraint pkr2 primary key(x), "
1:             + "		constraint fpkr2 foreign key (x) references pr1)");
1: 
1:         st.executeUpdate(
1:             " create table pr3(x int not null, "
1:             + "		constraint pkr3 primary key(x), "
1:             + "		constraint fpkr3 foreign key (x) references pr2)");
1: 
1:         rs = st.executeQuery(
1:             " select constraintname, referencecount from "
1:             + "sys.sysconstraints order by constraintname");
1: 
1:         expRS = new String [][]
1:         {
1:             {"FPKR2", "0"},
1:             {"FPKR3", "0"},
1:             {"PK3", "0"},
1:             {"PKR1", "1"},
1:             {"PKR2", "1"},
1:             {"PKR3", "0"}
1:         };
1: 
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // now drop constraint pkr1
1:         st.executeUpdate(
1:             "alter table pr2 drop constraint fpkr2");
1: 
1:         st.executeUpdate(
1:             " alter table pr1 drop constraint pkr1");
1: 
1:         waitForPostCommit();
1: 
1:         // pkr1 and pfkr2 are gone
1:         rs = st.executeQuery(
1:             "select constraintname, referencecount from "
1:             + "sys.sysconstraints order by constraintname");
1: 
1:         expRS = new String [][]
1:         {
1:             {"FPKR3", "0"},
1:             {"PK3", "0"},
1:             {"PKR2", "1"},
1:             {"PKR3", "0"}
1:         };
1: 
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // cleanup
1:         st.executeUpdate(
1:             "drop table pr3");
1: 
1:         st.executeUpdate("drop table pr2");
1:         st.executeUpdate("drop table pr1");
1: 
1:         waitForPostCommit();
1: 
1:         // should return 0, confirm no unexpected dependencies
1:         // verify that all rows in sys.sysdepends got dropped
1:         // apart from sps dependencies
1:         st.executeUpdate(
1:             "create table default_sysdepends_count2(a int)");
1: 
1:         st.executeUpdate(
1:             " insert into default_sysdepends_count2 select "
1:             + "count(*) from sys.sysdepends");
1: 
1:         rs = st.executeQuery(
1:             " select default_sysdepends_count2.a - "
1:             + "default_sysdepends_count.a"
1:             + "    from default_sysdepends_count2, default_sysdepends_count");
1: 
1:         expRS = new String [][]{{"0"}};
1: 
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // dependencies and spses
1:         st.executeUpdate(
1:             "create table x (x int not null primary key, y int, "
1:             + "constraint xfk foreign key (y) references x)");
1: 
1:         st.executeUpdate(
1:             " create table y (x int, constraint yfk foreign key "
1:             + "(x) references x)");
1: 
1:         final PreparedStatement ss = prepareStatement(
1:             "select * from x");
1: 
1:         final PreparedStatement si = prepareStatement(
1:             "insert into x values (1,1)");
1: 
1:         final PreparedStatement su = prepareStatement(
1:             "update x set x = x+1, y=y+1");
1: 
1:         st.executeUpdate(
1:             " alter table x drop constraint xfk");
1: 
1:         waitForPostCommit();
1: 
1:         setAutoCommit(false);
1: 
1:         // drop the referenced fk, should force su to be
1:         // recompiled since it no longer has to check the foreign
1:         // key table
1:         st.executeUpdate(
1:             "alter table y drop constraint yfk");
1: 
1:         commit();
1:         waitForPostCommit();
1: 
1:         st.executeUpdate("drop table y");
1: 
1:         commit();
1: 
1:         waitForPostCommit();
1: 
1:         // ok
1:         st.executeUpdate("drop table x");
1: 
1:         ss.close();
1:         si.close();
1:         su.close();
1: 
1:         st.executeUpdate("drop table f3");
1:         st.executeUpdate("drop table f2");
1:         st.executeUpdate("drop table f");
1: 
1:         commit();
1:         waitForPostCommit();
1: 
1:         // verify that all rows in sys.sysdepends got dropped
1:         // apart from sps dependencies Since, with beetle 5352; we
1:         // create metadata SPS for network server at database
1:         // bootup time so the dependencies for SPS are there.
1:         st.executeUpdate(
1:             "create table default_sysdepends_count3(a int)");
1: 
1:         st.executeUpdate(
1:             " insert into default_sysdepends_count3 select "
1:             + "count(*) from sys.sysdepends");
1: 
1:         rs = st.executeQuery(
1:             " select default_sysdepends_count3.a - "
1:             + "default_sysdepends_count.a"
1:             + "    from default_sysdepends_count3, default_sysdepends_count");
1: 
1:         expRS = new String [][]{{"0"}};
1: 
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // ** insert fkdml.sql
1:         setAutoCommit(true);
1: 
1:         // DML and foreign keys
1:         assertStatementError("42Y55", st, "drop table s");
1:         assertStatementError("42Y55", st, "drop table f3");
1:         assertStatementError("42Y55", st, "drop table f2");
1:         assertStatementError("42Y55", st, "drop table f");
1:         assertStatementError("42Y55", st, "drop table p");
1: 
1:         waitForPostCommit();
1: 
1:         st.executeUpdate(
1:             " create table p (x int not null, y int not null, "
1:             + "constraint pk primary key (x,y))");
1: 
1:         st.executeUpdate(
1:             " create table f (x int, y int, constraint fk "
1:             + "foreign key (x,y) references p)");
1: 
1:         st.executeUpdate(
1:             " insert into p values (1,1)");
1: 
1:         // ok
1:         st.executeUpdate("insert into f values (1,1)");
1: 
1:         // fail
1:         assertStatementError("23503", st, "insert into f values (2,1)");
1:         assertStatementError("23503", st, " insert into f values (1,2)");
1: 
1:         // nulls are ok
1:         st.executeUpdate("insert into f values (1,null)");
1:         st.executeUpdate("insert into f values (null,null)");
1:         st.executeUpdate("insert into f values (1,null)");
1: 
1:         // update on pk, fail
1:         assertStatementError("23503", st, "update p set x = 2");
1:         assertStatementError("23503", st, "update p set y = 2");
1:         assertStatementError("23503", st, "update p set x = 1, y = 2");
1:         assertStatementError("23503", st, "update p set x = 2, y = 1");
1:         assertStatementError("23503", st, "update p set x = 2, y = 2");
1: 
1:         // ok
1:         assertUpdateCount(st, 1, "update p set x = 1, y = 1");
1: 
1:         // delete pk, fail
1:         assertStatementError("23503", st, "delete from p");
1: 
1:         // delete fk, ok
1:         assertUpdateCount(st, 4, "delete from f");
1: 
1:         st.executeUpdate("insert into f values (1,1)");
1: 
1:         // update fk, fail
1:         assertStatementError("23503", st, "update f set x = 2");
1:         assertStatementError("23503", st, "update f set y = 2");
1:         assertStatementError("23503", st, "update f set x = 1, y = 2");
1:         assertStatementError("23503", st, "update f set x = 2, y = 1");
1: 
1:         // update fk, ok
1:         assertUpdateCount(st, 1, "update f set x = 1, y = 1");
1: 
1:         // nulls ok
1:         assertUpdateCount(st, 1, "update f set x = null, y = 1");
1:         assertUpdateCount(st, 1, "update f set x = 1, y = null");
1:         assertUpdateCount(st, 1, "update f set x = null, y = null");
1:         assertUpdateCount(st, 1, "delete from f");
1: 
1:         st.executeUpdate("insert into f values (1,1)");
1:         st.executeUpdate("insert into p values (2,2)");
1: 
1:         // ok
1:         assertUpdateCount(st, 1, "update f set x = x+1, y = y+1");
1: 
1:         rs = st.executeQuery("select * from f");
1: 
1:         expRS = new String [][]{{"2", "2"}};
1: 
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         rs = st.executeQuery("select * from p");
1: 
1:         expRS = new String [][]
1:         {
1:             {"1", "1"},
1:             {"2", "2"}
1:         };
1: 
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // ok
1:         assertUpdateCount(st, 2, "update p set x = x+1, y = y+1");
1: 
1:         // fail
1:         assertStatementError("23503", st, "update p set x = x+1, y = y+1");
1: 
1:         // BOUNDARY CONDITIONS
1:         assertUpdateCount(st, 1, "delete from f");
1:         assertUpdateCount(st, 2, "delete from p");
1: 
1:         st.executeUpdate("insert into f select * from f");
1: 
1:         assertUpdateCount(st, 0, "delete from p where x = 9999");
1:         assertUpdateCount(st, 0, "update p set x = x+1, y=y+1 where x = 999");
1: 
1:         st.executeUpdate("insert into p values (1,1)");
1:         st.executeUpdate("insert into f values (1,1)");
1: 
1:         assertUpdateCount(st, 0, "update p set x = x+1, y=y+1 where x = 999");
1:         assertUpdateCount(st, 0, "delete from p where x = 9999");
1: 
1:         st.executeUpdate("insert into f select * from f");
1: 
1:         // test a CURSOR
1:         assertUpdateCount(st, 2, "delete from f");
1:         assertUpdateCount(st, 1, "delete from p");
1: 
1:         st.executeUpdate("insert into p values (1,1)");
1:         st.executeUpdate("insert into f values (1,1)");
1: 
1:         setAutoCommit(false);
1: 
1:         final Statement uS = createStatement(
1:             ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
1:         ResultSet r = uS.executeQuery("select * from p for update of x");
1:         r.next();
1:         assertEquals(r.getString(1), "1");
1:         assertEquals(r.getString(2), "1");
1: 
1:         try {
1:             // UPDATE on table 'P' caused a violation of foreign
1:             // key constraint 'FK' for key (1,1).
1:             r.updateInt("X", 666);
1:         } catch (SQLException e) {
1:             assertSQLState("23503", e);
1:         }
1: 
1:         r.close();
1: 
1:         r = uS.executeQuery("select * from f for update of x");
1:         r.next();
1:         assertEquals(r.getString(1), "1");
1:         assertEquals(r.getString(2), "1");
1: 
1:         try {
1:             // UPDATE on table 'F' caused a violation of foreign
1:             // key constraint 'FK' for key (666,1).
1:             r.updateInt("X", 666);
1:         } catch (SQLException e) {
1:             assertSQLState("23503", e);
1:         }
1: 
1:         r.close();
1: 
1:         commit();
1:         setAutoCommit(true);
1: 
1:         assertUpdateCount(st, 1, "delete from f");
1:         assertUpdateCount(st, 1, "delete from p");
1: 
1:         st.executeUpdate("insert into p values (0,0), (1,1), (2,2), (3,3), (4,4)");
1:         st.executeUpdate("insert into f values (1,1)");
1: 
1:         // lets add some additional foreign keys to the mix
1:         st.executeUpdate(
1:             "create table f2 (x int, y int, constraint fk2 "
1:             + "foreign key (x,y) references p)");
1: 
1:         st.executeUpdate("insert into f2 values (2,2)");
1: 
1:         st.executeUpdate(
1:             " create table f3 (x int, y int, constraint fk3 "
1:             + "foreign key (x,y) references p)");
1: 
1:         st.executeUpdate("insert into f3 values (3,3)");
1: 
1:         // ok
1:         assertUpdateCount(st, 5, "update p set x = x+1, y = y+1");
1: 
1:         // error, fk1
1:         assertStatementError("23503", st, "update p set x = x+1");
1:         assertStatementError("23503", st, "update p set y = y+1");
1:         assertStatementError("23503", st, "update p set x = x+1, y = y+1");
1: 
1:         // fail of fk3
1:         assertStatementError("23503", st, "update p set y = 666 where y = 3");
1: 
1:         // fail of fk2
1:         assertStatementError("23503", st, "update p set x = 666 where x = 2");
1: 
1:         // cleanup
1:         st.executeUpdate("drop table f");
1:         st.executeUpdate("drop table f2");
1:         st.executeUpdate("drop table f3");
1:         st.executeUpdate("drop table p");
1: 
1:         waitForPostCommit();
1: 
1:         // SELF REFERENCING
1:         st.executeUpdate(
1:             "create table s (x int not null primary key, y int "
1:             + "references s, z int references s)");
1: 
1:         // ok
1:         st.executeUpdate("insert into s values (1,null,null)");
1: 
1:         // ok
1:         assertUpdateCount(st, 1, "update s set y = 1");
1: 
1:         // fail
1:         assertStatementError("23503", st, "update s set z = 2");
1: 
1:         // ok
1:         assertUpdateCount(st, 1, "update s set z = 1");
1: 
1:         // ok
1:         st.executeUpdate("insert into s values (2, 1, 1)");
1: 
1:         // ok
1:         assertUpdateCount(st, 1, "update s set x = 666 where x = 2");
1: 
1:         // ok
1:         assertUpdateCount(st, 2, "update s set x = x+1, y = y+1, z = z+1");
1:         assertUpdateCount(st, 2, "delete from s");
1: 
1:         // ok
1:         st.executeUpdate("insert into s values (1,null,null)");
1:         st.executeUpdate("insert into s values (2,null,null)");
1:         assertUpdateCount(st, 1, "update s set y = 2 where x = 1");
1:         assertUpdateCount(st, 1, "update s set z = 1 where x = 2");
1: 
1:         rs = st.executeQuery("select * from s");
1: 
1:         expRS = new String [][]
1:         {
1:             {"1", "2", null},
1:             {"2", null, "1"}
1:         };
1: 
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // fail
1:         assertStatementError("23503", st, "update s set x = 0 where x = 1");
1: 
1:         // Now we are going to do a short but sweet check to make
1:         // sure we are actually hitting the correct columns
1:         st.executeUpdate(
1:             "create table p (c1 char(1), y int not null, c2 "
1:             + "char(1), x int not null, constraint pk primary key (x,y))");
1: 
1:         st.executeUpdate(
1:             " create table f (x int, s smallint, y int, "
1:             + "constraint fk foreign key (x,y) references p)");
1: 
1:         st.executeUpdate(
1:             " insert into p values ('1',1,'1',1)");
1: 
1:         // ok
1:         st.executeUpdate("insert into f values (1,1,1)");
1:         st.executeUpdate("insert into p values ('0',0,'0',0)");
1: 
1:         // ok
1:         assertUpdateCount(st, 2, "update p set x = x+1, y=y+1");
1: 
1:         // fail
1:         assertStatementError("23503", st, "delete from p where y = 1");
1:         assertStatementError("23503", st, "insert into f values (1,1,4)");
1: 
1:         assertUpdateCount(st, 1, "delete from f");
1:         assertUpdateCount(st, 2, "delete from p");
1: 
1:         // Lets make sure we don't interact poorly with 'normal'
1:         // deferred dml
1:         st.executeUpdate("insert into p values ('1',1,'1',1)");
1:         st.executeUpdate("insert into f values (1,1,1)");
1:         st.executeUpdate("insert into p values ('0',0,'0',0)");
1: 
1:         // ok
1:         assertUpdateCount(st, 2,
1:             "update p set x = x+1, y=y+1 where x < (select "
1:             + "max(x)+10000 from p)");
1: 
1:         // fail
1:         assertStatementError("23503", st,
1:             "delete from p where y = 1 and y in (select y from p)");
1: 
1:         // inserts
1:         st.executeUpdate(
1:             "create table f2 (x int, t smallint, y int)");
1: 
1:         st.executeUpdate("insert into f2 values (1,1,4)");
1: 
1:         // fail
1:         assertStatementError("23503", st,"insert into f select * from f2");
1: 
1:         // ok
1:         st.executeUpdate("insert into f2 values (1,1,1)");
1:         st.executeUpdate("insert into f select * from f2 where y = 1");
1: 
1:         st.executeUpdate("drop table f2");
1:         st.executeUpdate("drop table f");
1:         st.executeUpdate("drop table p");
1: 
1:         waitForPostCommit();
1: 
1:         // PREPARED STATEMENTS
1:         assertStatementError("42Y55", st, "drop table f");
1:         assertStatementError("42Y55", st, "drop table p");
1: 
1:         //the reason for this wait call is to wait unitil system
1:         // tables row deletesare completed other wise we will get
1:         // different order fk checksthat will lead different error
1:         // messages depending on when post commit thread runs
1:         waitForPostCommit();
1: 
1:         pSt = prepareStatement(
1:             "create table p (w int not null primary key, x int "
1:             + "references p, y int not null, z int not null, "
1:             + "constraint uyz unique (y,z))");
1: 
1:         assertUpdateCount(pSt, 0);
1: 
1: 
1:         pSt = prepareStatement(
1:             "create table f (w int references p, x int, y int, z "
1:             + "int, constraint fk foreign key (y,z) references p (y,z))");
1: 
1:         assertUpdateCount(pSt, 0);
1: 
1: 
1:         pSt = prepareStatement(
1:             "alter table f drop constraint fk");
1: 
1:         assertUpdateCount(pSt, 0);
1: 
1: 
1:         //the reason for this wait call is to wait unitil system
1:         // tables row deletesare completed other wise we will get
1:         // different order fk checks
1:         waitForPostCommit();
1: 
1:         pSt = prepareStatement(
1:             "alter table f add constraint fk foreign key (y,z) "
1:             + "references p (y,z)");
1: 
1:         assertUpdateCount(pSt, 0);
1: 
1: 
1:         PreparedStatement sf = prepareStatement(
1:             "insert into f values (1,1,1,1)");
1: 
1:         PreparedStatement sp = prepareStatement(
1:             "insert into p values (1,1,1,1)");
1: 
1:         // fail
1:         assertStatementError("23503", sf);
1: 
1:         // ok
1:         assertUpdateCount(sp, 1);
1:         assertUpdateCount(sf, 1);
1: 
1:         st.executeUpdate(" insert into p values (2,2,2,2)");
1: 
1: 
1:         pSt = prepareStatement(
1:             "update f set w=w+1, x = x+1, y=y+1, z=z+1");
1: 
1:         // ok
1:         assertUpdateCount(pSt, 1);
1: 
1:         pSt = prepareStatement("update p set w=w+1, x = x+1, y=y+1, z=z+1");
1: 
1:         // ok
1:         assertUpdateCount(pSt, 2);
1: 
1:         pSt = prepareStatement("delete from p where x =1");
1: 
1:         // ok
1:         assertUpdateCount(pSt, 0);
1: 
1:         st.executeUpdate("drop table f");
1:         st.executeUpdate("drop table p");
1: 
1:         waitForPostCommit();
1: 
1:         st.executeUpdate("drop procedure WAIT_FOR_POST_COMMIT");
1: 
1:         rollback();
1:         st.close();
1:     }
1: 
1:     /**
1:      * Get a count of number of rows in SYS.SYSDEPENDS
1:      */
1:     private int numberOfRowsInSysdepends(Statement st) throws SQLException {
1:     	final ResultSet rs = 
1:             st.executeQuery("SELECT COUNT(*) FROM SYS.SYSDEPENDS");
1:     	rs.next();
1:         final int result = rs.getInt(1);
1:     	rs.close();
1:         return result;
1:     }
1: 
1:     private void waitForPostCommit() throws SQLException {
1:         final CallableStatement s = 
1:             prepareCall("CALL WAIT_FOR_POST_COMMIT()");
1:         assertUpdateCount(s, 0);
1:         s.close();
1:     }
1: }
============================================================================