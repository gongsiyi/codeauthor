1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.dictionary.SPSDescriptor
1:7ecc1f2: 
1:2e658c2:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2e658c2:    contributor license agreements.  See the NOTICE file distributed with
1:2e658c2:    this work for additional information regarding copyright ownership.
1:2e658c2:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2e658c2:    (the "License"); you may not use this file except in compliance with
1:2e658c2:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
27:eac0369: 
7:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.sql.dictionary;
1:eac0369: 
1:a0dbbd7: import java.security.PrivilegedAction;
1:a0dbbd7: import java.security.AccessController;
1:a0dbbd7: import java.security.AccessControlException;
1:a0dbbd7: import java.security.AccessControlContext;
1:201c012: import java.sql.Timestamp;
1:1620a2b: import java.util.ArrayList;
1:1620a2b: import java.util.List;
1:201c012: 
1:201c012: import org.apache.derby.catalog.Dependable;
1:201c012: import org.apache.derby.catalog.DependableFinder;
1:201c012: import org.apache.derby.catalog.UUID;
1:201c012: import org.apache.derby.iapi.error.StandardException;
1:201c012: import org.apache.derby.iapi.reference.SQLState;
1:201c012: import org.apache.derby.iapi.services.context.ContextManager;
1:201c012: import org.apache.derby.iapi.services.context.ContextService;
1:bc2c59e: import org.apache.derby.iapi.services.io.ArrayUtil;
1:201c012: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:201c012: import org.apache.derby.iapi.services.monitor.Monitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:201c012: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1:201c012: import org.apache.derby.iapi.sql.Statement;
1:201c012: import org.apache.derby.iapi.sql.StorablePreparedStatement;
1:201c012: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:201c012: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
1:201c012: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:201c012: import org.apache.derby.iapi.sql.depend.Dependent;
1:201c012: import org.apache.derby.iapi.sql.depend.Provider;
1:201c012: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1:201c012: import org.apache.derby.iapi.store.access.TransactionController;
1:201c012: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:bc2c59e: import org.apache.derby.iapi.types.DataTypeUtilities;
1:073b862: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
7:eac0369: /**
1:eac0369:  * A SPSDescriptor describes a Stored Prepared Statement.
1:eac0369:  * It correlates to a row in SYS.SYSSTATEMENTS.
6:eac0369:  *
1:eac0369:  * <B>SYNCHRONIZATION</B>: Stored prepared statements
1:eac0369:  * may be cached.  Thus they may be shared by multiple
1:eac0369:  * threads.  It is very hard for two threads to try
1:eac0369:  * to muck with an sps simultaeously because all ddl
1:eac0369:  * (including sps recompilation) clears out the sps
1:eac0369:  * cache and invalidates whatever statement held a
1:eac0369:  * cached sps.  But it is possible for two statements
1:eac0369:  * to do a prepare execute statment <x> at the exact
1:eac0369:  * same time, so both try to do an sps.prepare() at the 
1:eac0369:  * same time during code generation, so we synchronize
1:eac0369:  * most everything except getters on immutable objects
1:eac0369:  * just to be on the safe side.
1:eac0369:  *
1:eac0369:  *
1:eac0369:  */
1:f2fad75: public class SPSDescriptor extends UniqueSQLObjectDescriptor
1:f2fad75: 	implements Dependent, Provider
13:eac0369: {
1:eac0369: 	/**
1:eac0369: 	 * Statement types.  
1:eac0369: 	 * <UL>
1:1620a2b:      * <LI> SPS_TYPE_TRIGGER    - trigger</LI>
1:eac0369: 	 * <LI> SPS_TYPE_EXPLAIN	- explain (<B>NOT IMPLEMENTED</B>) </LI>
1:eac0369: 	 * <LI> SPS_TYPE_REGULAR	- catchall</LI>
1:eac0369: 	 * </UL>
1:eac0369: 	 */
1:eac0369: 	public static final char SPS_TYPE_TRIGGER	= 'T';
1:eac0369: 	public static final char SPS_TYPE_REGULAR	= 'S';
1:eac0369: 	public static final char SPS_TYPE_EXPLAIN	= 'X';
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	   interface to this class is:
1:eac0369: 	   <ol>
1:eac0369: 	   <li>public void prepare() throws StandardException;
1:eac0369: 	   <li>public void prepareAndRelease(LanguageConnectionContext lcc) 
1:eac0369: 	   throws StandardException;
1:eac0369: 	   <li>public void prepareAndRelease(...);
1:eac0369: 	   <li>public String	getQualifiedName();
1:eac0369: 	   <li>public char	getType();
1:eac0369: 	   <li>public String getTypeAsString();
1:eac0369: 	   <li>public boolean isValid();
1:eac0369: 	   <li>public boolean initiallyCompilable();
1:eac0369: 	   <li>public java.sql.Timestamp getCompileTime();
1:eac0369: 	   <li>public void setCompileTime();
1:eac0369: 	   <li>public String getText();
1:eac0369: 	   <li>public String getUsingText();
1:eac0369: 	   <li>public void setUsingText(String usingText);
1:eac0369: 	   <li>public void	setUUID(UUID uuid);
1:eac0369: 	   <li>public DataTypeDescriptor[] getParams() throws StandardException;
1:eac0369: 	   <li>public void setParams(DataTypeDescriptor[] params);
1:eac0369: 	   <li>Object[] getParameterDefaults()	throws StandardException;
1:eac0369: 	   <li>void setParameterDefaults(Object[] values);
1:eac0369: 	   <li>public UUID getCompSchemaId();
1:eac0369: 	   <li>public ExecPreparedStatement getPreparedStatement()
1:eac0369: 	   throws StandardException;
1:eac0369: 	   <li>public ExecPreparedStatement getPreparedStatement(boolean recompIfInvalid)
1:eac0369: 	   throws StandardException;
1:eac0369: 	   <li>public void revalidate(LanguageConnectionContext lcc)
1:eac0369: 			throws StandardException;
1:eac0369: 			</ol>
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	private static final int RECOMPILE = 1;
1:eac0369: 	private static final int INVALIDATE = 0;
1:eac0369: 
1:eac0369: 		
1:eac0369: 	// Class contents
1:1620a2b:     private final SchemaDescriptor sd;
1:1620a2b:     private final String name;
1:1620a2b:     private final UUID compSchemaId;
1:1620a2b:     private final char type;
1:179e593:     private String text;
1:1620a2b:     private final String usingText;
1:6efed4e:     private final UUID uuid;
1:1620a2b: 
1:eac0369: 	private	boolean					valid;
1:eac0369: 	private	ExecPreparedStatement	preparedStatement;
1:eac0369: 	private	DataTypeDescriptor		params[];
1:eac0369: 	private	Timestamp				compileTime;
1:ddd8800: 	/**
1:ddd8800: 	 * Old code - never used.
1:ddd8800: 	 */
1:ddd8800: 	private Object			paramDefaults[];
1:fed9c08:     private final boolean   initiallyCompilable;
1:eac0369: 	private	boolean					lookedUpParams;
1:eac0369: 	
1:eac0369: 	private UUIDFactory				uuidFactory;
1:eac0369: 
1:eac0369: 
1:eac0369: 	// constructors
1:eac0369: 	/**
1:eac0369: 	 * Constructor for a SPS Descriptor
1:eac0369: 	 *
1:eac0369: 	 * @param dataDictionary		The data dictionary that this descriptor lives in
1:eac0369: 	 * @param 	name 	the SPS name
1:eac0369: 	 * @param 	uuid	the UUID
1:eac0369: 	 * @param 	suuid	the schema UUID
1:eac0369: 	 * @param 	compSchemaUUID	the schema UUID at compilation time
1:6b50965: 	 * @param	type	type
1:eac0369: 	 * @param 	valid	is the sps valid
1:eac0369: 	 * @param 	text	the text for this statement
1:eac0369: 	 * @param	initiallyCompilable	is the statement initially compilable?
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public SPSDescriptor
1:eac0369: 				(DataDictionary		dataDictionary,
1:eac0369: 				String				name,
1:eac0369: 			   	UUID				uuid,
1:eac0369: 			   	UUID				suuid,
1:eac0369: 				UUID				compSchemaUUID,
1:eac0369: 				char				type,
1:eac0369: 			   	boolean				valid,
1:eac0369: 			   	String				text,
1:eac0369: 				boolean				initiallyCompilable ) throws StandardException
1:eac0369: 	{
1:ddd8800: 		this( dataDictionary, name, uuid, suuid, compSchemaUUID,
1:ddd8800: 				type, valid, text, (String) null, null, null, initiallyCompilable );
12:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor for a SPS Descriptor.  Used when
1:eac0369: 	 * constructing an SPS descriptor from a row
1:eac0369: 	 * in SYSSTATEMENTS.
1:eac0369: 	 *
1:eac0369: 	 * @param	dataDictionary		The data dictionary that this descriptor lives in
1:eac0369: 	 * @param 	name 	the SPS name
1:eac0369: 	 * @param 	uuid	the UUID
1:eac0369: 	 * @param 	suuid	the schema UUID
1:eac0369: 	 * @param 	compSchemaUUID	the schema UUID at compilation time
1:6b50965: 	 * @param	type	type
1:eac0369: 	 * @param 	valid	is the sps valid
1:eac0369: 	 * @param 	text	the text for this statement
2:eac0369: 	 * @param 	usingText	the text for the USING clause supplied to
2:eac0369: 	 *					CREATE or ALTER STATEMENT
1:eac0369: 	 * @param 	compileTime	the time this was compiled
1:eac0369: 	 * @param 	preparedStatement	the PreparedStatement
1:eac0369: 	 * @param	initiallyCompilable	is the statement initially compilable?
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public SPSDescriptor
1:eac0369: 				(DataDictionary	dataDictionary,
1:eac0369: 				String		name,
1:eac0369: 			   	UUID		uuid,
1:eac0369: 				UUID		suuid,
1:eac0369: 				UUID		compSchemaUUID,
1:eac0369: 				char		type,
1:eac0369: 			   	boolean		valid,
1:eac0369: 			   	String		text,
1:eac0369: 				String 		usingText,
1:eac0369: 			   	Timestamp	compileTime,
1:eac0369: 			   	ExecPreparedStatement	preparedStatement,
1:eac0369: 				boolean		initiallyCompilable ) throws StandardException
1:eac0369: 	{
1:eac0369: 		super( dataDictionary );
1:eac0369: 
1:6efed4e:         // Added this check when setUUID was removed, see DERBY-4918.
1:6efed4e:         if (uuid == null) {
1:6efed4e:             throw new IllegalArgumentException("UUID is null");
1:6efed4e:         }
1:eac0369: 		this.name = name;
2:eac0369: 		this.uuid = uuid; 
1:eac0369: 		this.type = type;
1:eac0369: 		this.text = text;
2:eac0369: 		this.usingText = usingText;
1:eac0369: 		this.valid = valid;
1:bc2c59e: 		this.compileTime = DataTypeUtilities.clone( compileTime );
1:eac0369: 		this.sd = dataDictionary.getSchemaDescriptor(suuid, null);
1:eac0369: 		this.preparedStatement = preparedStatement;
1:eac0369: 		this.compSchemaId = compSchemaUUID;
1:eac0369: 		this.initiallyCompilable = initiallyCompilable;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * FOR TRIGGERS ONLY
1:eac0369: 	 * <p>
1:eac0369: 	 * Generate the class for this SPS and immediately
1:eac0369: 	 * release it.  This is useful for cases where we
1:eac0369: 	 * don't want to immediately execute the statement 
1:eac0369: 	 * corresponding to this sps (e.g. CREATE STATEMENT).
1:eac0369:  	 * <p>
1:eac0369: 	 * <I>SIDE EFFECTS</I>: will update and SYSDEPENDS 
1:eac0369: 	 * with the prepared statement dependency info.
1:eac0369:  	 * 
1:eac0369: 	 * @param lcc the language connection context
1:eac0369: 	 * @param triggerTable the table descriptor to bind against.  Had
1:eac0369: 	 * 	better be null if this isn't a trigger sps.
1:3d7a3d4: 	 * @param tc the transaction controller
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public final synchronized void prepareAndRelease
1:eac0369: 	(
1:eac0369: 		LanguageConnectionContext	lcc, 
1:3d7a3d4: 		TableDescriptor				triggerTable,
1:3d7a3d4: 		TransactionController       tc
1:eac0369: 	) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (triggerTable != null)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(type == SPS_TYPE_TRIGGER, "only expect a table descriptor when we have a trigger");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		
1:3d7a3d4: 		compileStatement(lcc, triggerTable, tc);
1:eac0369: 	
1:eac0369: 		preparedStatement.makeInvalid(DependencyManager.PREPARED_STATEMENT_RELEASE, lcc);
1:eac0369: 	}
1:3d7a3d4: 	
1:3d7a3d4: 	/**
1:3d7a3d4: 	 * FOR TRIGGERS ONLY
1:3d7a3d4: 	 * <p>
1:3d7a3d4: 	 * Generate the class for this SPS and immediately
1:3d7a3d4: 	 * release it.  This is useful for cases where we
1:3d7a3d4: 	 * don't want to immediately execute the statement 
1:3d7a3d4: 	 * corresponding to this sps (e.g. CREATE STATEMENT).
1:3d7a3d4:  	 * <p>
1:3d7a3d4: 	 * <I>SIDE EFFECTS</I>: will update and SYSDEPENDS 
1:3d7a3d4: 	 * with the prepared statement dependency info.
1:3d7a3d4:  	 * 
1:3d7a3d4: 	 * @param lcc the language connection context
1:3d7a3d4: 	 * @param triggerTable the table descriptor to bind against.  Had
1:3d7a3d4: 	 * 	better be null if this isn't a trigger sps.
1:3d7a3d4: 	 *
1:3d7a3d4: 	 * @exception StandardException on error
1:3d7a3d4: 	 */
1:3d7a3d4: 	public final synchronized void prepareAndRelease
1:3d7a3d4: 	(
1:3d7a3d4: 		LanguageConnectionContext	lcc, 
1:3d7a3d4: 		TableDescriptor				triggerTable
1:3d7a3d4: 	) throws StandardException
1:3d7a3d4: 	{
1:3d7a3d4: 		prepareAndRelease(lcc, triggerTable, (TransactionController)null);
1:3d7a3d4: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the class for this SPS and immediately
1:eac0369: 	 * release it.  This is useful for cases where we
1:eac0369: 	 * don't want to immediately execute the statement 
1:eac0369: 	 * corresponding to this sps (e.g. CREATE STATEMENT).
1:eac0369:  	 * <p>
1:eac0369: 	 * <I>SIDE EFFECTS</I>: will update and SYSDEPENDS 
1:eac0369: 	 * with the prepared statement dependency info.
1:eac0369: 	 *
1:eac0369: 	 * @param lcc the language connection context
1:eac0369:  	 * 
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public final synchronized void prepareAndRelease(LanguageConnectionContext lcc) throws StandardException
1:eac0369: 	{
1:3d7a3d4: 		prepareAndRelease(lcc, (TableDescriptor)null, (TransactionController)null);
1:eac0369: 	}
1:eac0369: 
1:1620a2b:     /**
1:1620a2b:      * Compiles this SPS.
1:1620a2b:      * <p>
1:1620a2b:      * <em>Note:</em> This SPS may still be marked as invalid after this method
1:1620a2b:      * has completed, because an invalidation request may have been received
1:1620a2b:      * while compiling.
1:1620a2b:      *
1:1620a2b:      * @param lcc connection
1:1620a2b:      * @param triggerTable subject table (may be {@code null})
1:1620a2b:      * @param tc transaction controller to use (may be {@code null})
1:1620a2b:      * @throws StandardException if something fails
1:1620a2b:      */
1:1620a2b:     //@GuardedBy("this")
1:eac0369: 	private void compileStatement
1:eac0369: 	(
1:eac0369: 		LanguageConnectionContext	lcc,
1:3d7a3d4: 		TableDescriptor				triggerTable,
1:3d7a3d4: 		TransactionController       tc
1:eac0369: 	)
2:eac0369: 		throws StandardException
1:eac0369: 	{
1:5f7e18f: 		ContextManager cm = lcc.getContextManager();
1:eac0369: 		LanguageConnectionFactory	lcf = lcc.getLanguageConnectionFactory();
1:eac0369: 
1:eac0369: 		DataDictionary dd = getDataDictionary();
1:eac0369: 
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** If we are a trigger, then we have to go ahead
1:eac0369: 		** and locate the trigger's table descriptor and
1:eac0369: 		** push it on the lcc.  This is expensive, but
1:eac0369: 		** pretty atypical since trigger actions aren't
1:eac0369: 		** likely to be invalidated too often.  Also, when
1:eac0369: 		** possible, we already have the triggerTable.
1:eac0369: 		*/
1:eac0369: 		if (type == SPS_TYPE_TRIGGER && triggerTable == null)
1:eac0369: 		{
1:1620a2b:             // 49 because name consists of (see CreateTriggerConstantAction):
1:1620a2b:             // TRIGGER<ACTN|WHEN>_<UUID:36>_<UUID:36>
1:eac0369: 			String uuidStr = name.substring(49);
1:eac0369: 			triggerTable = dd.getTableDescriptor(recreateUUID(uuidStr));
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				if (triggerTable == null)
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT("couldn't find trigger table for trigger sps "+name);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (triggerTable != null)
1:eac0369: 		{
1:eac0369: 			lcc.pushTriggerTable(triggerTable);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// stored statements always stored as unicode.
1:5087be8: 		Statement 			stmt = lcf.getStatement(dd.getSchemaDescriptor(compSchemaId, null), text, true);
1:eac0369: 
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			preparedStatement = (ExecPreparedStatement) stmt.prepareStorable(
1:eac0369: 								lcc,
1:eac0369: 								preparedStatement, 
1:eac0369: 								getParameterDefaults(),
1:eac0369: 								getSchemaDescriptor(),
1:eac0369: 								type == SPS_TYPE_TRIGGER);
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			if (triggerTable != null)
1:eac0369: 			{
1:eac0369: 				lcc.popTriggerTable(triggerTable);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		//If this references a SESSION schema table (temporary or permanent), then throw an exception
1:eac0369: 		//This is if EXECUTE STATEMENT executing a statement that was created with NOCOMPILE. Because
1:eac0369: 		//of NOCOMPILE, we could not catch SESSION schema table reference by the statement at
1:eac0369: 		//CREATE STATEMENT time. And hence need to catch such statements at EXECUTE STATEMENT time
1:eac0369: 		//when the query is getting compiled.
1:eac0369: 		if (preparedStatement.referencesSessionSchema())
1:eac0369: 			throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
1:eac0369:       
1:eac0369: 		setCompileTime();
1:eac0369: 		setParams(preparedStatement.getParameterTypes());
1:eac0369: 
1:1ea68f8: 		if (!dd.isReadOnlyUpgrade()) {
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Indicate that we are going to write the data
1:eac0369: 			** dictionary.  We have probably already done this
1:eac0369: 			** but it is ok to call startWriting more than once.
1:eac0369: 			*/
1:eac0369: 			dd.startWriting(lcc);
1:eac0369: 
1:1620a2b:             DependencyManager dm = dd.getDependencyManager();
1:eac0369: 			/*
1:eac0369: 			** Clear out all the dependencies that exist
1:eac0369: 			** before we recreate them so we don't grow
1:eac0369: 			** SYS.SYSDEPENDS forever.
1:eac0369: 			*/
1:3d7a3d4: 			dm.clearDependencies(lcc, this, tc);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Copy over all the dependencies to me
1:eac0369: 			*/
1:eac0369: 			dm.copyDependencies(preparedStatement, 	// from
1:eac0369: 											this, 	// to
1:eac0369: 											false,	// persistent only
1:3d7a3d4: 											cm,
1:3d7a3d4: 											tc);
1:95971f2: 			//If this sps is for a trigger action, then add the depenency
1:95971f2: 			// between this sps and the trigger table DERBY-5120
1:95971f2: 			if (triggerTable != null) 
1:95971f2: 				dm.addDependency(this, triggerTable, lcc.getContextManager());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// mark it as valid
1:eac0369: 		valid = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the name of the sps.
1:eac0369: 	 *
1:eac0369: 	 * @return	A String containing the name of the statement.
1:eac0369: 	 */
1:eac0369: 	public final String	getName()
1:eac0369: 	{
1:eac0369: 		return name;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the full, qualified name of the statement.
1:eac0369: 	 *
1:eac0369: 	 * @return	A String containing the name of the statement.
1:eac0369: 	 */
1:eac0369: 	public final String	getQualifiedName()
1:eac0369: 	{
1:eac0369: 		return sd.getSchemaName() + "." + name;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the SchemaDescriptor for this SPS Descriptor.
1:eac0369: 	 *
1:eac0369: 	 * @return SchemaDescriptor	The SchemaDescriptor.
1:eac0369: 	 */
1:eac0369: 	public final SchemaDescriptor getSchemaDescriptor()
1:eac0369: 	{
1:eac0369: 		return sd;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets an identifier telling what type of table this is.
1:eac0369: 	 * Types match final ints in this interface.  Currently
1:eac0369: 	 * returns SPS_TYPE_REGULAR or SPS_TYPE_TRIGGER.
1:eac0369: 	 *
1:eac0369: 	 * @return	An identifier telling what type of statement
1:eac0369:  	 * we are.
1:eac0369: 	 */
1:eac0369: 	public final char getType()
1:eac0369: 	{
1:eac0369: 		return type;
1:eac0369: 	}	
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Simple little helper function to convert your type
1:eac0369: 	 * to a string, which is easier to use.
1:eac0369: 	 *
1:eac0369: 	 * @return type as a string
1:eac0369: 	 */	
1:1620a2b:     public final String getTypeAsString() {
1:1620a2b:         return String.valueOf(type);
1:1620a2b:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is the statement initially compilable?  
1:eac0369: 	 *
1:eac0369: 	 * @return	false if statement was created with the NOCOMPILE flag
1:eac0369: 	 *			true otherwise
1:eac0369: 	 */
1:eac0369: 	public boolean initiallyCompilable() { return initiallyCompilable; }
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Validate the type. <B>NOTE</B>: Only SPS_TYPE_REGULAR
1:eac0369: 	 * and SPS_TYPE_TRIGGER are currently valid.
1:eac0369: 	 *
1:eac0369: 	 * @param type the type
1:eac0369: 	 *
1:eac0369: 	 * @return true/false	
1:eac0369: 	 */
1:1620a2b:     public static boolean validType(char type)
1:eac0369: 	{
1:eac0369: 		return (type == SPSDescriptor.SPS_TYPE_REGULAR) || 
1:eac0369: 				(type == SPSDescriptor.SPS_TYPE_TRIGGER);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The time this prepared statement was compiled
1:eac0369: 	 *
1:eac0369: 	 * @return the time this class was last compiled
1:eac0369: 	 */
1:eac0369: 	public final synchronized Timestamp getCompileTime()
1:eac0369: 	{
1:bc2c59e: 		return DataTypeUtilities.clone( compileTime );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the compile time to now
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public final synchronized void setCompileTime()
1:eac0369: 	{
1:eac0369: 		compileTime = new Timestamp(System.currentTimeMillis());
1:eac0369: 	}
1:eac0369: 	 
1:eac0369: 	/**
1:eac0369: 	 * Get the text used to create this statement.
1:eac0369: 	 * Returns original text in a cleartext string.
1:eac0369: 	 *
1:eac0369: 	 * @return The text
1:eac0369: 	 */
1:bb6e925: 	public final synchronized String getText()
1:eac0369: 	{
1:eac0369: 		return text;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:179e593: 	 * It is possible that when a trigger is invalidated, the generated trigger
1:179e593: 	 * action sql associated with it needs to be regenerated. One example
1:179e593: 	 * of such a case would be when ALTER TABLE on the trigger table
1:179e593: 	 * changes the length of a column. The need for this code was found
1:179e593: 	 * as part of DERBY-4874 where the Alter table had changed the length 
1:179e593: 	 * of a varchar column from varchar(30) to varchar(64) but the generated 
1:179e593: 	 * trigger action plan continued to use varchar(30). To fix varchar(30) in
1:179e593: 	 * in trigger action sql to varchar(64), we need to regenerate the 
1:179e593: 	 * trigger action sql which is saved as stored prepared statement. This 
1:179e593: 	 * new trigger action sql will then get updated into SYSSTATEMENTS table.
1:179e593: 	 * DERBY-4874
1:179e593: 	 * 
1:179e593: 	 * @param newText
1:179e593: 	 */
1:bb6e925: 	public final synchronized void setText(String newText)
1:179e593: 	{
1:179e593: 		text = newText;
1:179e593: 	}
1:179e593: 	/**
1:eac0369: 	 * Get the text of the USING clause used on CREATE
1:eac0369: 	 * or ALTER statement.
1:eac0369: 	 *
1:eac0369: 	 * @return The text
1:eac0369: 	 */
1:1620a2b:     public final String getUsingText()
1:eac0369: 	{
1:eac0369: 		return usingText;
1:eac0369: 	}
1:eac0369: 
1:6efed4e:     /**
1:6efed4e:      * Gets the UUID of the SPS.
1:6efed4e:      *
1:6efed4e:      * @return The UUID.
1:6efed4e:      */
1:6efed4e:     public final UUID getUUID() {
1:eac0369: 		return uuid;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Get the array of date type descriptors for
1:eac0369: 	 * this statement.  Currently, we do a lookup
1:eac0369: 	 * if we don't already have the parameters saved.
1:eac0369: 	 * When SPSes are cached, the parameters should
1:eac0369: 	 * be set up when the sps is constructed.
1:eac0369: 	 *
1:eac0369: 	 * @return the array of data type descriptors
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public final synchronized DataTypeDescriptor[] getParams()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:1620a2b:         if (params == null && !lookedUpParams) {
1:073b862:             List<DataValueDescriptor> tmpDefaults = new ArrayList<DataValueDescriptor>();
1:1620a2b:             params = getDataDictionary().getSPSParams(this, tmpDefaults);
1:1620a2b:             paramDefaults = tmpDefaults.toArray();
1:1620a2b:             lookedUpParams = true;
1:1620a2b:         }
1:eac0369: 
1:3f7581c:         return ArrayUtil.copy(params);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the list of parameters for this statement
1:eac0369: 	 *
1:eac0369: 	 * @param params	the parameter list
1:eac0369: 	 */
1:eac0369: 	public final synchronized void setParams(DataTypeDescriptor params[])
1:eac0369: 	{
1:3f7581c:         this.params = ArrayUtil.copy(params);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the default parameter values for this 
1:eac0369: 	 * statement.  Default parameter values are
1:eac0369: 	 * supplied by a USING clause on either a
1:eac0369: 	 * CREATE or ALTER STATEMENT statement.
1:eac0369: 	 *
1:eac0369: 	 * @return the default parameter values
1:eac0369:  	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public final synchronized Object[] getParameterDefaults()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (paramDefaults == null)
1:bc2c59e:         {
1:eac0369: 			getParams();
1:bc2c59e:         }
1:eac0369: 
1:bc2c59e: 		return ArrayUtil.copy( paramDefaults );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the parameter defaults for this statement.
1:eac0369: 	 *
1:6b50965: 	 * @param values	the parameter defaults
1:eac0369: 	 */
1:eac0369: 	public final synchronized void setParameterDefaults(Object[] values)
1:eac0369: 	{
1:bc2c59e: 		this.paramDefaults = ArrayUtil.copy( values );
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Get the preparedStatement for this statement.
1:eac0369: 	 * If stmt is invalid or hasn't been compiled yet,
1:eac0369: 	 * it will be recompiled.
1:eac0369: 	 *
1:eac0369: 	 * @return the preparedStatement
1:eac0369:  	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public final ExecPreparedStatement getPreparedStatement()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return getPreparedStatement(true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the preparedStatement for this statement.
1:eac0369: 	 * Expects the prepared statement to have already
1:eac0369: 	 * been added to SYS.SYSSTATEMENTS.
1:eac0369: 	 * <p>
1:eac0369: 	 * Side Effects: will update SYS.SYSSTATEMENTS with
1:eac0369: 	 * the new plan if it needs to be recompiled.
1:eac0369: 	 *
1:eac0369: 	 * @param recompIfInvalid if false, never recompile even
1:eac0369: 	 *	if statement is invalid
1:eac0369: 	 *
1:eac0369: 	 * @return the preparedStatement
1:eac0369:  	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public final synchronized ExecPreparedStatement getPreparedStatement(boolean recompIfInvalid)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		//System.out.println("preparedStatement = " + preparedStatement);
1:eac0369: 		/*
1:eac0369: 		** Recompile if we are invalid, we don't have
1:eac0369: 		** a prepared statement, or the statements activation
1:eac0369: 		** has been cleared and cannot be reconstituted.
1:eac0369: 		*/
1:eac0369: 		if (recompIfInvalid &&
1:eac0369: 			(!valid ||
1:eac0369: 			 (preparedStatement == null)))
1:eac0369: 		{
1:a0dbbd7: 			ContextManager cm = getContextService().getCurrentContextManager();
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Find the language connection context.  Get
1:eac0369: 			** it each time in case a connection is dropped.
1:eac0369: 			*/
1:eac0369: 			LanguageConnectionContext lcc = (LanguageConnectionContext)
1:eac0369: 					cm.getContext(LanguageConnectionContext.CONTEXT_ID);
1:3d7a3d4: 			
1:eac0369: 
1:eac0369: 
1:1ea68f8: 			if (!lcc.getDataDictionary().isReadOnlyUpgrade()) {
1:eac0369: 
1:fed9c08:                 final String savepoint = lcc.getUniqueSavepointName();
1:fed9c08: 
1:c9ef166: 				// First try compiling in a nested transaction so we can 
1:c9ef166:                 // release the locks after the compilation, and not have them
1:c9ef166:                 // sit around in the parent transaction. But if we get lock 
1:c9ef166:                 // time out in the nested transaction, then go ahead and do 
1:c9ef166:                 // the compilation in the user transaction. When doing the 
1:c9ef166:                 // compilation in the user transaction, the locks acquired for 
1:c9ef166:                 // recompilation will be released at the end of the user 
1:c9ef166:                 // transaction (commit or abort).
1:eac0369: 				TransactionController nestedTC;
1:eac0369: 				try
1:eac0369: 				{
1:ceaf7df: 					nestedTC = 
1:ceaf7df:                         lcc.getTransactionCompile().startNestedUserTransaction(
1:ceaf7df:                             false, true);
1:ceaf7df: 
1:85e3e12:                     // DERBY-3693: The nested transaction may run into a lock
1:85e3e12:                     // conflict with its parent transaction, in which case we
1:5431e03:                     // don't want to wait for a timeout. If a lock timeout is
1:5431e03:                     // detected while we're executing the nested transaction,
1:5431e03:                     // we ignore the error and retry in the user transaction.
1:5431e03:                     // When retrying in the user transaction, we'll wait for
1:5431e03:                     // locks if necessary.
1:85e3e12:                     nestedTC.setNoLockWait(true);
1:fed9c08: 
1:fed9c08:                     // Set a savepoint so that the work in the nested
1:fed9c08:                     // transaction can be rolled back on error without
1:fed9c08:                     // aborting the parent transaction.
1:fed9c08:                     nestedTC.setSavePoint(savepoint, null);
1:eac0369: 				}
1:eac0369: 				catch (StandardException se)
1:eac0369: 				{
1:c9ef166: 					// If I cannot start a Nested User Transaction use the 
1:c9ef166:                     // parent transaction to do all the work.
1:c9ef166: 					nestedTC = null;
1:eac0369: 				}
1:01c5d89: 
1:eac0369: 				try
1:eac0369: 				{
1:3d7a3d4: 					prepareAndRelease(lcc, null, nestedTC);
1:eac0369: 					updateSYSSTATEMENTS(lcc, RECOMPILE, nestedTC);
1:eac0369: 				}
1:eac0369: 				catch (StandardException se)
1:eac0369: 				{
1:fed9c08:                     if (nestedTC != null)
1:fed9c08:                     {
1:fed9c08:                         // Roll back to savepoint to undo any work done by
1:fed9c08:                         // the nested transaction. We cannot abort the nested
1:fed9c08:                         // transaction in order to achieve the same, since
1:fed9c08:                         // that would also abort the parent transaction.
1:fed9c08:                         nestedTC.rollbackToSavePoint(savepoint, false, null);
1:fed9c08:                     }
1:fed9c08: 
1:9819cf8:                     if (
1:9819cf8:                         (nestedTC != null) &&
1:9819cf8:                         ( se.isLockTimeout() || se.isSelfDeadlock() )
1:9819cf8:                         )
1:eac0369: 					{
1:c9ef166:                         // Locks were set nowait, so a lock timeout here
1:c9ef166:                         // means that some lock request in the nested 
1:c9ef166:                         // transaction immediately conflicted.  A conflict
1:c9ef166:                         // with a parent lock would lead to a undetected 
1:c9ef166:                         // deadlock so must give up trying in the nested
1:c9ef166:                         // transaction and retry with parent transaction.
1:fed9c08:                         nestedTC.commit();
1:fed9c08:                         nestedTC.destroy();
1:fed9c08:                         nestedTC = null;
1:c9ef166: 
1:c9ef166: 						// if we couldn't do this with a nested transaction, 
1:c9ef166:                         // retry with parent-- we need to wait this time!
1:c9ef166:                         // Lock conflicts at this point are with other 
1:c9ef166:                         // transactions, so must wait.
1:3d7a3d4: 						prepareAndRelease(lcc, null, null);
2:eac0369: 						updateSYSSTATEMENTS(lcc, RECOMPILE, null);
1:eac0369: 					}
1:c9ef166: 					else 
1:c9ef166:                     {
1:c9ef166:                         throw se;
1:c9ef166:                     }
1:eac0369: 				}
1:eac0369: 				finally
1:eac0369: 				{
1:c9ef166: 					// no matter what, commit the nested transaction; 
1:c9ef166:                     // if something bad happened in the child transaction lets
1:c9ef166:                     // not abort the parent here.
2:eac0369: 					if (nestedTC != null)
1:eac0369: 					{
1:c9ef166: 						nestedTC.commit();
1:c9ef166: 						nestedTC.destroy();
1:eac0369: 					}
1:eac0369: 				} 
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return preparedStatement;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the compilation type schema id when this view
1:eac0369: 	 * was first bound.
1:eac0369: 	 *
1:eac0369: 	 * @return the schema UUID
1:eac0369: 	 */
1:eac0369: 	public final UUID getCompSchemaId()
1:eac0369: 	{
1:eac0369: 		return compSchemaId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the contents of the TableDescriptor
1:eac0369: 	 *
1:eac0369: 	 * @return The contents as a String
1:eac0369: 	 */
1:801cf0d:     @Override
1:eac0369: 	public final String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			return "SPSDescriptor:\n"+
1:eac0369: 				"\tname: "+sd.getSchemaName()+"."+name+"\n"+
1:eac0369: 				"\tuuid: "+uuid+"\n"+
1:eac0369: 				"\ttext: "+text+"\n"+
1:eac0369: 				"\tvalid: "+((valid) ? "TRUE" : "FALSE")+"\n" +
1:eac0369: 				"\tpreparedStatement: "+preparedStatement+"\n";
1:eac0369: 		}
2:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// PROVIDER INTERFACE
1:eac0369: 	//
1:eac0369: 	//////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**		
1:eac0369: 	 * Return the stored form of this provider
1:eac0369: 	 *
1:eac0369: 	 * @see Dependable#getDependableFinder
1:eac0369: 	 */
1:eac0369: 	public final DependableFinder getDependableFinder()
1:eac0369: 	{
1:eac0369: 	    return	getDependableFinder(StoredFormatIds.SPS_DESCRIPTOR_FINDER_V01_ID);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the name of this Provider.  (Useful for errors.)
1:eac0369: 	 *
1:eac0369: 	 * @return String	The name of this provider.
1:eac0369: 	 */
1:eac0369: 	public final String getObjectName()
1:eac0369: 	{
1:eac0369: 		return name;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the provider's UUID 
1:eac0369: 	 *
1:eac0369: 	 * @return String	The provider's UUID
1:eac0369: 	 */
1:eac0369: 	public final UUID getObjectID()
1:eac0369: 	{
1:eac0369: 		return uuid;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the provider's type.
1:eac0369: 	 *
1:eac0369: 	 * @return String The provider's type.
1:eac0369: 	 */
1:eac0369: 	public final String getClassType()
1:eac0369: 	{
1:eac0369: 		return Dependable.STORED_PREPARED_STATEMENT;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// DEPENDENT INTERFACE
1:eac0369: 	//
1:eac0369: 	//////////////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 	 * Check that all of the dependent's dependencies are valid.
1:eac0369: 	 *
1:eac0369: 	 * @return true if the dependent is currently valid
1:eac0369: 	 */
1:eac0369: 	public final synchronized boolean isValid()
1:eac0369: 	{
1:eac0369: 		return valid;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prepare to mark the dependent as invalid (due to at least one of
1:eac0369: 	 * its dependencies being invalid).
1:eac0369: 	 *
1:eac0369: 	 * @param action	The action causing the invalidation
1:eac0369: 	 * @param p		the provider
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if unable to make it invalid
1:eac0369: 	 */
1:1620a2b:     public final void prepareToInvalidate(
1:eac0369: 									Provider p, int action,
1:eac0369: 									LanguageConnectionContext lcc) 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		switch (action)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Things that don't affect us
1:eac0369: 			*/
1:eac0369: 		    case DependencyManager.CREATE_VIEW:
1:eac0369: 	
1:eac0369: 			/*
1:eac0369: 			** Things that force a recompile, but are
1:eac0369: 			** allowed.
1:eac0369: 			*/
1:eac0369: 			case DependencyManager.CREATE_INDEX:
1:eac0369: 			case DependencyManager.CREATE_CONSTRAINT:
1:eac0369: 			case DependencyManager.DROP_CONSTRAINT:
1:eac0369: 			case DependencyManager.DROP_INDEX:
1:eac0369: 			case DependencyManager.DROP_TABLE:
1:eac0369: 			case DependencyManager.DROP_VIEW: 
1:eac0369: 			case DependencyManager.DROP_METHOD_ALIAS:
1:81ad58c: 			case DependencyManager.DROP_SYNONYM:
1:eac0369: 			case DependencyManager.ALTER_TABLE:
1:eac0369: 			case DependencyManager.RENAME:
1:eac0369: 			case DependencyManager.RENAME_INDEX:
1:eac0369: 			case DependencyManager.PREPARED_STATEMENT_RELEASE:
1:eac0369: 			case DependencyManager.USER_RECOMPILE_REQUEST:
1:eac0369: 			case DependencyManager.CHANGED_CURSOR:
1:eac0369: 			case DependencyManager.BULK_INSERT:
1:eac0369: 			case DependencyManager.COMPRESS_TABLE:
1:eac0369: 			case DependencyManager.SET_CONSTRAINTS_ENABLE:
1:eac0369: 			case DependencyManager.SET_CONSTRAINTS_DISABLE:
1:eac0369: 			case DependencyManager.SET_TRIGGERS_ENABLE:
1:eac0369: 			case DependencyManager.SET_TRIGGERS_DISABLE:
1:eac0369: 			case DependencyManager.ROLLBACK:
1:eac0369: 			case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
1:eac0369: 			case DependencyManager.CREATE_TRIGGER:
1:eac0369: 			case DependencyManager.DROP_TRIGGER:
1:eac0369: 			case DependencyManager.DROP_COLUMN:
1:ee5857f: 			case DependencyManager.DROP_COLUMN_RESTRICT:
1:eac0369: 		    case DependencyManager.UPDATE_STATISTICS:
1:eac0369: 		    case DependencyManager.DROP_STATISTICS:
1:eac0369:     		case DependencyManager.TRUNCATE_TABLE:
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** The rest are errors
1:eac0369: 			*/
1:eac0369: 		    default:
1:eac0369: 
2:eac0369: 				DependencyManager dm;
1:eac0369: 
1:eac0369: 				dm = getDataDictionary().getDependencyManager();
1:eac0369: 				throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_S_P_S, 
1:eac0369: 					dm.getActionString(action), 
1:eac0369: 					p.getObjectName(), name);
1:eac0369: 
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark the dependent as invalid (due to at least one of
1:eac0369: 	 * its dependencies being invalid).
1:eac0369: 	 *
1:eac0369: 	 * @param	action	The action causing the invalidation
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if unable to make it invalid
1:eac0369: 	 */
1:eac0369: 	public final synchronized void makeInvalid(int action,
1:eac0369: 											   LanguageConnectionContext lcc) 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		DependencyManager dm;
1:eac0369: 
1:eac0369: 		dm = getDataDictionary().getDependencyManager();
1:eac0369: 
1:eac0369: 		switch (action)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Some things that don't affect stored prepared
1:eac0369: 	 		** statements.
1:eac0369: 			*/
1:eac0369: 			case DependencyManager.PREPARED_STATEMENT_RELEASE:
1:eac0369: 		    case DependencyManager.CREATE_VIEW:
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 		 	** Things that can invalidate a stored
1:eac0369: 			** prepared statement.
1:eac0369: 			*/
1:eac0369: 			case DependencyManager.CREATE_INDEX:
1:eac0369: 			case DependencyManager.CREATE_CONSTRAINT:
1:eac0369: 			case DependencyManager.DROP_CONSTRAINT:
1:eac0369: 			case DependencyManager.DROP_TABLE:
1:eac0369: 			case DependencyManager.DROP_INDEX:
1:eac0369: 			case DependencyManager.DROP_VIEW: 
1:eac0369: 			case DependencyManager.DROP_METHOD_ALIAS:
1:81ad58c: 			case DependencyManager.DROP_SYNONYM:
1:eac0369: 			case DependencyManager.ALTER_TABLE:
1:eac0369: 			case DependencyManager.RENAME:
1:eac0369: 			case DependencyManager.RENAME_INDEX:
1:eac0369: 			case DependencyManager.USER_RECOMPILE_REQUEST:
1:eac0369: 			case DependencyManager.CHANGED_CURSOR:
1:eac0369: 			case DependencyManager.BULK_INSERT:
1:eac0369: 			case DependencyManager.COMPRESS_TABLE:
1:eac0369: 			case DependencyManager.SET_CONSTRAINTS_ENABLE:
1:eac0369: 			case DependencyManager.SET_CONSTRAINTS_DISABLE:
1:eac0369: 			case DependencyManager.SET_TRIGGERS_ENABLE:
1:eac0369: 			case DependencyManager.SET_TRIGGERS_DISABLE:
1:eac0369: 			case DependencyManager.ROLLBACK:
1:eac0369: 			case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
1:eac0369: 			case DependencyManager.CREATE_TRIGGER:
1:eac0369: 			case DependencyManager.DROP_TRIGGER:
1:eac0369: 			case DependencyManager.DROP_COLUMN:
1:ee5857f: 			case DependencyManager.DROP_COLUMN_RESTRICT:
1:eac0369: 		    case DependencyManager.UPDATE_STATISTICS:
1:eac0369: 		    case DependencyManager.DROP_STATISTICS:
1:eac0369: 			case DependencyManager.TRUNCATE_TABLE:
1:eac0369: 				/*
1:eac0369: 				** If we are already invalid, don't write ourselves
1:eac0369: 				** out.  Just to be safe, we'll send out an invalidate
1:eac0369: 				** to our dependents either way.
1:eac0369: 				*/
1:eac0369: 				if (valid == true)
1:eac0369: 				{
1:eac0369: 					valid = false;
1:ae72a30:                     preparedStatement = null;
1:eac0369: 					updateSYSSTATEMENTS(lcc, INVALIDATE, null);
1:eac0369: 				}
1:801cf0d:                 dm.invalidateFor(
1:801cf0d:                         this, DependencyManager.USER_RECOMPILE_REQUEST, lcc);
1:eac0369: 				break;
1:eac0369: 			case DependencyManager.DROP_SPS:
1:eac0369: 				//System.out.println("SPSD " + preparedStatement);
2:eac0369: 				dm.clearDependencies(lcc, this);
1:eac0369: 				break;
1:eac0369: 	
1:eac0369: 		    default:
1:eac0369: 
1:eac0369: 				/* 
1:eac0369: 				** We should never get here, since we can't have dangling references 
1:eac0369: 				*/
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT("makeInvalid("+
1:eac0369: 						dm.getActionString(action)+
1:eac0369: 						") not expected to get called; should have failed in "+
1:eac0369: 						"prepareToInvalidate()");
1:eac0369: 				}
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Invalidate and revalidate.  The functional equivalent
1:eac0369: 	 * of calling makeInvalid() and makeValid(), except it
1:eac0369: 	 * is optimized.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public final synchronized void revalidate(LanguageConnectionContext lcc)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Mark it as invalid first to ensure that
1:eac0369: 		** we don't write SYSSTATEMENTS 2x.
1:eac0369: 		*/
1:eac0369: 		valid = false;
1:eac0369: 		makeInvalid(DependencyManager.USER_RECOMPILE_REQUEST, lcc);
3:eac0369: 		prepareAndRelease(lcc);
1:eac0369: 		updateSYSSTATEMENTS(lcc, RECOMPILE, null);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Load the underlying generatd class.  This is not expected
1:eac0369: 	 * to be used outside of the datadictionary package.  It
1:eac0369: 	 * is used for optimizing class loading for sps
1:eac0369: 	 * cacheing.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public void loadGeneratedClass() throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** On upgrade, we null out the statement body,
1:eac0369: 		** so handle that here.
1:eac0369: 		*/
1:eac0369: 		if (preparedStatement != null)
1:eac0369: 		{
1:eac0369: 			((StorablePreparedStatement)preparedStatement).loadGeneratedClass();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Update SYSSTATEMENTS with the changed the descriptor.  
1:eac0369: 	** Always done in the user XACT.
1:eac0369: 	** <p>
1:eac0369: 	** Ideally, the changes to SYSSTATEMENTS would be made 
1:eac0369: 	** in a separate xact as the current user xact, but this
1:eac0369: 	** is painful (you'ld need to get a new ContextManager
1:eac0369: 	** and then push all of the usual langauge contexts
1:eac0369: 	** onto it and THEN call AccessManager.getTransaction()),
1:eac0369: 	** and it wont work, because the xact is in a different
1:eac0369: 	** compatibility space and will self deadlock (e.g.
1:eac0369: 	** in the process of call DependencyManager.makeInvalid() 
1:eac0369: 	** we first did a DDdependableFinder.getDependable()
1:eac0369: 	** which called DataDictionaryImpl.getSPSDescriptor()
1:eac0369: 	** so we hold a lock on SYS.SYSSTATEMENTS by the
1:eac0369: 	** time we get a 2nd xact and try to drop the statement).
1:eac0369: 	*/
1:eac0369: 	private void updateSYSSTATEMENTS(LanguageConnectionContext lcc, int mode, TransactionController tc)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		DataDictionary dd = getDataDictionary();
1:eac0369: 
1:1ea68f8: 		if (dd.isReadOnlyUpgrade())
2:eac0369: 			return;
1:eac0369: 
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Get busy time
1:eac0369: 		*/
1:eac0369: 		dd.startWriting(lcc);	
1:eac0369: 
1:eac0369: 		if (tc == null) { //bug 4821 - tc will passed null if we want to use the user transaction
1:eac0369: 			tc = lcc.getTransactionExecute();
1:eac0369: 		}
1:eac0369: 
1:fed9c08:         dd.updateSPS(this, tc, (mode == RECOMPILE));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the UUID for the given string
1:eac0369: 	 *
1:6b50965: 	 * @param idString	the string
1:eac0369: 	 *
1:eac0369: 	 * @return the UUID
1:eac0369: 	 */
1:eac0369: 	private UUID recreateUUID(String idString)
1:eac0369: 	{
1:eac0369: 		if (uuidFactory == null)
1:eac0369: 		{
1:56c1dc2: 			uuidFactory = DataDescriptorGenerator.getMonitor().getUUIDFactory();
1:eac0369: 		}
1:eac0369: 		return uuidFactory.recreateUUID(idString);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see TupleDescriptor#getDescriptorType */
1:801cf0d:     @Override
1:eac0369: 	public String getDescriptorType() { return "Statement"; }
1:eac0369: 
1:eac0369: 	/** @see TupleDescriptor#getDescriptorName */
1:eac0369: 	// RESOLVE: some descriptors have getName.  some descriptors have
1:eac0369: 	// getTableName, getColumnName whatever! try and unify all of this to one
1:eac0369: 	// getDescriptorName! 
1:801cf0d:     @Override
1:eac0369: 	public String getDescriptorName() { return name; }
1:a0dbbd7: 
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of the ContextService. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  ContextService    getContextService()
1:a0dbbd7:     {
1:a0dbbd7:         if ( System.getSecurityManager() == null )
1:a0dbbd7:         {
1:a0dbbd7:             return ContextService.getFactory();
1:a0dbbd7:         }
1:a0dbbd7:         else
1:a0dbbd7:         {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:a0dbbd7:                  new PrivilegedAction<ContextService>()
1:a0dbbd7:                  {
1:a0dbbd7:                      public ContextService run()
1:a0dbbd7:                      {
1:a0dbbd7:                          return ContextService.getFactory();
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:eac0369: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: 			uuidFactory = DataDescriptorGenerator.getMonitor().getUUIDFactory();
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
1: import java.security.AccessController;
1: import java.security.AccessControlException;
1: import java.security.AccessControlContext;
/////////////////////////////////////////////////////////////////////////
1: 			ContextManager cm = getContextService().getCurrentContextManager();
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Privileged lookup of the ContextService. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ContextService    getContextService()
1:     {
1:         if ( System.getSecurityManager() == null )
1:         {
1:             return ContextService.getFactory();
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedAction<ContextService>()
1:                  {
1:                      public ContextService run()
1:                      {
1:                          return ContextService.getFactory();
1:                      }
1:                  }
1:                  );
1:         }
1:     }
commit:9819cf8
/////////////////////////////////////////////////////////////////////////
1:                     if (
1:                         (nestedTC != null) &&
1:                         ( se.isLockTimeout() || se.isSelfDeadlock() )
1:                         )
commit:073b862
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.DataValueDescriptor;
/////////////////////////////////////////////////////////////////////////
1:             List<DataValueDescriptor> tmpDefaults = new ArrayList<DataValueDescriptor>();
commit:f2fad75
/////////////////////////////////////////////////////////////////////////
1: public class SPSDescriptor extends UniqueSQLObjectDescriptor
1: 	implements Dependent, Provider
commit:bc2c59e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.ArrayUtil;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.DataTypeUtilities;
/////////////////////////////////////////////////////////////////////////
1: 		this.compileTime = DataTypeUtilities.clone( compileTime );
/////////////////////////////////////////////////////////////////////////
1: 		return DataTypeUtilities.clone( compileTime );
/////////////////////////////////////////////////////////////////////////
0: 		return (DataTypeDescriptor[]) ArrayUtil.copy( params );
/////////////////////////////////////////////////////////////////////////
0: 		this.params = (DataTypeDescriptor[]) ArrayUtil.copy( params );
/////////////////////////////////////////////////////////////////////////
1:         {
1:         }
1: 		return ArrayUtil.copy( paramDefaults );
/////////////////////////////////////////////////////////////////////////
1: 		this.paramDefaults = ArrayUtil.copy( values );
commit:3d7a3d4
/////////////////////////////////////////////////////////////////////////
1: 	 * @param tc the transaction controller
1: 		TableDescriptor				triggerTable,
1: 		TransactionController       tc
/////////////////////////////////////////////////////////////////////////
1: 		compileStatement(lcc, triggerTable, tc);
1: 	
1: 	/**
1: 	 * FOR TRIGGERS ONLY
1: 	 * <p>
1: 	 * Generate the class for this SPS and immediately
1: 	 * release it.  This is useful for cases where we
1: 	 * don't want to immediately execute the statement 
1: 	 * corresponding to this sps (e.g. CREATE STATEMENT).
1:  	 * <p>
1: 	 * <I>SIDE EFFECTS</I>: will update and SYSDEPENDS 
1: 	 * with the prepared statement dependency info.
1:  	 * 
1: 	 * @param lcc the language connection context
1: 	 * @param triggerTable the table descriptor to bind against.  Had
1: 	 * 	better be null if this isn't a trigger sps.
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public final synchronized void prepareAndRelease
1: 	(
1: 		LanguageConnectionContext	lcc, 
1: 		TableDescriptor				triggerTable
1: 	) throws StandardException
1: 	{
1: 		prepareAndRelease(lcc, triggerTable, (TransactionController)null);
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 		prepareAndRelease(lcc, (TableDescriptor)null, (TransactionController)null);
1: 		TableDescriptor				triggerTable,
1: 		TransactionController       tc
/////////////////////////////////////////////////////////////////////////
1: 			dm.clearDependencies(lcc, this, tc);
/////////////////////////////////////////////////////////////////////////
1: 											cm,
1: 											tc);
/////////////////////////////////////////////////////////////////////////
1: 			
/////////////////////////////////////////////////////////////////////////
1: 					prepareAndRelease(lcc, null, nestedTC);
/////////////////////////////////////////////////////////////////////////
1: 						prepareAndRelease(lcc, null, null);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:fed9c08
/////////////////////////////////////////////////////////////////////////
1:     private final boolean   initiallyCompilable;
/////////////////////////////////////////////////////////////////////////
1:                 final String savepoint = lcc.getUniqueSavepointName();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:                     // Set a savepoint so that the work in the nested
1:                     // transaction can be rolled back on error without
1:                     // aborting the parent transaction.
1:                     nestedTC.setSavePoint(savepoint, null);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     if (nestedTC != null)
1:                     {
1:                         // Roll back to savepoint to undo any work done by
1:                         // the nested transaction. We cannot abort the nested
1:                         // transaction in order to achieve the same, since
1:                         // that would also abort the parent transaction.
1:                         nestedTC.rollbackToSavePoint(savepoint, false, null);
1:                     }
1: 
0:                     if (nestedTC != null && se.isLockTimeout())
/////////////////////////////////////////////////////////////////////////
1:                         nestedTC.commit();
1:                         nestedTC.destroy();
1:                         nestedTC = null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         dd.updateSPS(this, tc, (mode == RECOMPILE));
commit:3f7581c
/////////////////////////////////////////////////////////////////////////
1:         return ArrayUtil.copy(params);
/////////////////////////////////////////////////////////////////////////
1:         this.params = ArrayUtil.copy(params);
commit:ae72a30
/////////////////////////////////////////////////////////////////////////
1:                     preparedStatement = null;
commit:1ea68f8
/////////////////////////////////////////////////////////////////////////
1: 		if (!dd.isReadOnlyUpgrade()) {
/////////////////////////////////////////////////////////////////////////
1: 			if (!lcc.getDataDictionary().isReadOnlyUpgrade()) {
/////////////////////////////////////////////////////////////////////////
1: 		if (dd.isReadOnlyUpgrade())
commit:8106edc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:5431e03
/////////////////////////////////////////////////////////////////////////
1:                     // don't want to wait for a timeout. If a lock timeout is
1:                     // detected while we're executing the nested transaction,
1:                     // we ignore the error and retry in the user transaction.
1:                     // When retrying in the user transaction, we'll wait for
1:                     // locks if necessary.
commit:85e3e12
/////////////////////////////////////////////////////////////////////////
1:                     // DERBY-3693: The nested transaction may run into a lock
1:                     // conflict with its parent transaction, in which case we
0:                     // don't want to wait for a timeout.
1:                     nestedTC.setNoLockWait(true);
commit:01c5d89
/////////////////////////////////////////////////////////////////////////
0: 				// DERBY-2584: If the first attempt to compile the query fails,
0: 				// we need to reset initiallyCompilable to make sure the
0: 				// prepared plan is fully stored to disk. Save the initial
0: 				// value here.
0: 				final boolean compilable = initiallyCompilable;
1: 
/////////////////////////////////////////////////////////////////////////
0: 						initiallyCompilable = compilable;
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:ee5857f
/////////////////////////////////////////////////////////////////////////
1: 			case DependencyManager.DROP_COLUMN_RESTRICT:
/////////////////////////////////////////////////////////////////////////
1: 			case DependencyManager.DROP_COLUMN_RESTRICT:
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 dm.invalidateFor(
1:                         this, DependencyManager.USER_RECOMPILE_REQUEST, lcc);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:ceaf7df
/////////////////////////////////////////////////////////////////////////
1: 					nestedTC = 
1:                         lcc.getTransactionCompile().startNestedUserTransaction(
1:                             false, true);
1: 
commit:c9ef166
/////////////////////////////////////////////////////////////////////////
1: 				// First try compiling in a nested transaction so we can 
1:                 // release the locks after the compilation, and not have them
1:                 // sit around in the parent transaction. But if we get lock 
1:                 // time out in the nested transaction, then go ahead and do 
1:                 // the compilation in the user transaction. When doing the 
1:                 // compilation in the user transaction, the locks acquired for 
1:                 // recompilation will be released at the end of the user 
1:                 // transaction (commit or abort).
/////////////////////////////////////////////////////////////////////////
1: 					// If I cannot start a Nested User Transaction use the 
1:                     // parent transaction to do all the work.
/////////////////////////////////////////////////////////////////////////
0: 					if (se.isLockTimeout())
1:                         // Locks were set nowait, so a lock timeout here
1:                         // means that some lock request in the nested 
1:                         // transaction immediately conflicted.  A conflict
1:                         // with a parent lock would lead to a undetected 
1:                         // deadlock so must give up trying in the nested
1:                         // transaction and retry with parent transaction.
1:                             nestedTC.commit();
1:                             nestedTC.destroy();
1:                             nestedTC = null;
1: 
1: 						// if we couldn't do this with a nested transaction, 
1:                         // retry with parent-- we need to wait this time!
1:                         // Lock conflicts at this point are with other 
1:                         // transactions, so must wait.
1: 					else 
1:                     {
1:                         throw se;
1:                     }
1: 					// no matter what, commit the nested transaction; 
1:                     // if something bad happened in the child transaction lets
1:                     // not abort the parent here.
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:95971f2
/////////////////////////////////////////////////////////////////////////
1: 			//If this sps is for a trigger action, then add the depenency
1: 			// between this sps and the trigger table DERBY-5120
1: 			if (triggerTable != null) 
1: 				dm.addDependency(this, triggerTable, lcc.getContextManager());
commit:bb6e925
/////////////////////////////////////////////////////////////////////////
1: 	public final synchronized String getText()
/////////////////////////////////////////////////////////////////////////
1: 	public final synchronized void setText(String newText)
commit:179e593
/////////////////////////////////////////////////////////////////////////
1:     private String text;
/////////////////////////////////////////////////////////////////////////
1: 	 * It is possible that when a trigger is invalidated, the generated trigger
1: 	 * action sql associated with it needs to be regenerated. One example
1: 	 * of such a case would be when ALTER TABLE on the trigger table
1: 	 * changes the length of a column. The need for this code was found
1: 	 * as part of DERBY-4874 where the Alter table had changed the length 
1: 	 * of a varchar column from varchar(30) to varchar(64) but the generated 
1: 	 * trigger action plan continued to use varchar(30). To fix varchar(30) in
1: 	 * in trigger action sql to varchar(64), we need to regenerate the 
1: 	 * trigger action sql which is saved as stored prepared statement. This 
1: 	 * new trigger action sql will then get updated into SYSSTATEMENTS table.
1: 	 * DERBY-4874
1: 	 * 
1: 	 * @param newText
1: 	 */
0: 	public final void setText(String newText)
1: 	{
1: 		text = newText;
1: 	}
1: 	/**
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6efed4e
/////////////////////////////////////////////////////////////////////////
1:     private final UUID uuid;
/////////////////////////////////////////////////////////////////////////
1:         // Added this check when setUUID was removed, see DERBY-4918.
1:         if (uuid == null) {
1:             throw new IllegalArgumentException("UUID is null");
1:         }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Gets the UUID of the SPS.
1:      *
1:      * @return The UUID.
1:      */
1:     public final UUID getUUID() {
commit:1620a2b
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * <LI> SPS_TYPE_TRIGGER    - trigger</LI>
/////////////////////////////////////////////////////////////////////////
1:     private final SchemaDescriptor sd;
1:     private final String name;
1:     private final UUID compSchemaId;
1:     private final char type;
0:     private final String text;
1:     private final String usingText;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Compiles this SPS.
1:      * <p>
1:      * <em>Note:</em> This SPS may still be marked as invalid after this method
1:      * has completed, because an invalidation request may have been received
1:      * while compiling.
1:      *
1:      * @param lcc connection
1:      * @param triggerTable subject table (may be {@code null})
1:      * @param tc transaction controller to use (may be {@code null})
1:      * @throws StandardException if something fails
1:      */
1:     //@GuardedBy("this")
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             // 49 because name consists of (see CreateTriggerConstantAction):
1:             // TRIGGER<ACTN|WHEN>_<UUID:36>_<UUID:36>
/////////////////////////////////////////////////////////////////////////
1:             DependencyManager dm = dd.getDependencyManager();
/////////////////////////////////////////////////////////////////////////
1:     public final String getTypeAsString() {
1:         return String.valueOf(type);
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public static boolean validType(char type)
/////////////////////////////////////////////////////////////////////////
1:     public final String getUsingText()
/////////////////////////////////////////////////////////////////////////
0:     public final synchronized UUID getUUID() {
/////////////////////////////////////////////////////////////////////////
1:         if (params == null && !lookedUpParams) {
0:             List tmpDefaults = new ArrayList();
1:             params = getDataDictionary().getSPSParams(this, tmpDefaults);
1:             paramDefaults = tmpDefaults.toArray();
1:             lookedUpParams = true;
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public final void prepareToInvalidate(
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:201c012
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Timestamp;
1: 
1: import org.apache.derby.catalog.Dependable;
1: import org.apache.derby.catalog.DependableFinder;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: import org.apache.derby.iapi.sql.Statement;
1: import org.apache.derby.iapi.sql.StorablePreparedStatement;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: import org.apache.derby.iapi.sql.depend.Dependent;
1: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
commit:08d2c15
/////////////////////////////////////////////////////////////////////////
commit:ddd8800
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Old code - never used.
1: 	 */
1: 	private Object			paramDefaults[];
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		this( dataDictionary, name, uuid, suuid, compSchemaUUID,
1: 				type, valid, text, (String) null, null, null, initiallyCompilable );
commit:4eece41
/////////////////////////////////////////////////////////////////////////
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.dictionary.SPSDescriptor
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:5f7e18f
/////////////////////////////////////////////////////////////////////////
1: 		ContextManager cm = lcc.getContextManager();
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.dictionary;
1: 
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
1: 
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.sql.Statement;
0: import org.apache.derby.iapi.sql.StorablePreparedStatement;
1: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.Dependency;
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1: 
0: import org.apache.derby.iapi.types.DataValueFactory;
1: 
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
1: 
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.catalog.Dependable;
0: import org.apache.derby.catalog.DependableFinder;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: 
0: import java.util.Enumeration;
0: import java.util.Vector;
0: import java.sql.Timestamp;
1: 
1: /**
1:  * A SPSDescriptor describes a Stored Prepared Statement.
1:  * It correlates to a row in SYS.SYSSTATEMENTS.
1:  *
1:  * <B>SYNCHRONIZATION</B>: Stored prepared statements
1:  * may be cached.  Thus they may be shared by multiple
1:  * threads.  It is very hard for two threads to try
1:  * to muck with an sps simultaeously because all ddl
1:  * (including sps recompilation) clears out the sps
1:  * cache and invalidates whatever statement held a
1:  * cached sps.  But it is possible for two statements
1:  * to do a prepare execute statment <x> at the exact
1:  * same time, so both try to do an sps.prepare() at the 
1:  * same time during code generation, so we synchronize
1:  * most everything except getters on immutable objects
1:  * just to be on the safe side.
1:  *
1:  *
0:  * @author jamie
1:  */
0: public class SPSDescriptor extends TupleDescriptor
0: 	implements UniqueSQLObjectDescriptor, Dependent, Provider
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	/**
1: 	 * Statement types.  
1: 	 * <UL>
0: 	 * <LI> SPS_TYPE_TRIGGER	- trigger (<B>NOT IMPLEMENTED</B>) </LI>
1: 	 * <LI> SPS_TYPE_EXPLAIN	- explain (<B>NOT IMPLEMENTED</B>) </LI>
1: 	 * <LI> SPS_TYPE_REGULAR	- catchall</LI>
1: 	 * </UL>
1: 	 */
1: 	public static final char SPS_TYPE_TRIGGER	= 'T';
1: 	public static final char SPS_TYPE_REGULAR	= 'S';
1: 	public static final char SPS_TYPE_EXPLAIN	= 'X';
1: 
1: 	/**
1: 	   interface to this class is:
1: 	   <ol>
1: 	   <li>public void prepare() throws StandardException;
1: 	   <li>public void prepareAndRelease(LanguageConnectionContext lcc) 
1: 	   throws StandardException;
1: 	   <li>public void prepareAndRelease(...);
1: 	   <li>public String	getQualifiedName();
1: 	   <li>public char	getType();
1: 	   <li>public String getTypeAsString();
1: 	   <li>public boolean isValid();
1: 	   <li>public boolean initiallyCompilable();
1: 	   <li>public java.sql.Timestamp getCompileTime();
1: 	   <li>public void setCompileTime();
1: 	   <li>public String getText();
1: 	   <li>public String getUsingText();
1: 	   <li>public void setUsingText(String usingText);
1: 	   <li>public void	setUUID(UUID uuid);
1: 	   <li>public DataTypeDescriptor[] getParams() throws StandardException;
1: 	   <li>public void setParams(DataTypeDescriptor[] params);
1: 	   <li>Object[] getParameterDefaults()	throws StandardException;
1: 	   <li>void setParameterDefaults(Object[] values);
1: 	   <li>public UUID getCompSchemaId();
1: 	   <li>public ExecPreparedStatement getPreparedStatement()
1: 	   throws StandardException;
1: 	   <li>public ExecPreparedStatement getPreparedStatement(boolean recompIfInvalid)
1: 	   throws StandardException;
1: 	   <li>public void revalidate(LanguageConnectionContext lcc)
1: 			throws StandardException;
1: 			</ol>
1: 	*/
1: 
1: 	private static final int RECOMPILE = 1;
1: 	private static final int INVALIDATE = 0;
1: 
1: 		
1: 	// Class contents
0: 	private SchemaDescriptor		sd;
0: 	private String					name;
0: 	private UUID					uuid;
0: 	private UUID					compSchemaId;
0: 	private char					type;
1: 	private	boolean					valid;
0: 	private	String					text;
0: 	private	String					usingText;
1: 	private	ExecPreparedStatement	preparedStatement;
1: 	private	DataTypeDescriptor		params[];
1: 	private	Timestamp				compileTime;
0: 	private	Object					paramDefaults[];
0: 	private	boolean					initiallyCompilable;
1: 	private	boolean					lookedUpParams;
1: 	
1: 	private UUIDFactory				uuidFactory;
1: 
1: 
1: 	// constructors
1: 	/**
1: 	 * Constructor for a SPS Descriptor
1: 	 *
1: 	 * @param dataDictionary		The data dictionary that this descriptor lives in
1: 	 * @param 	name 	the SPS name
1: 	 * @param 	uuid	the UUID
1: 	 * @param 	suuid	the schema UUID
1: 	 * @param 	compSchemaUUID	the schema UUID at compilation time
0: 	 * @param	char	type
1: 	 * @param 	valid	is the sps valid
1: 	 * @param 	text	the text for this statement
1: 	 * @param 	usingText	the text for the USING clause supplied to
1: 	 *					CREATE or ALTER STATEMENT
0: 	 * @param	paramDefaults	default values for the parameters (if
0: 	 *					any) in this statement.  Generated by a USING
0: 	 *					clause, for use by the optimizer.
1: 	 * @param	initiallyCompilable	is the statement initially compilable?
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public SPSDescriptor
1: 				(DataDictionary		dataDictionary,
1: 				String				name,
1: 			   	UUID				uuid,
1: 			   	UUID				suuid,
1: 				UUID				compSchemaUUID,
1: 				char				type,
1: 			   	boolean				valid,
1: 			   	String				text,
0: 				String				usingText,
0: 				Object[]			paramDefaults,
1: 				boolean				initiallyCompilable ) throws StandardException
1: 	{
0: 		this( dataDictionary, name, uuid, suuid, compSchemaUUID, type, valid, text, usingText, null, null, initiallyCompilable );
0: 		this.paramDefaults = paramDefaults;
1: 	}
1: 
1: 	/**
1: 	 * Constructor for a SPS Descriptor.  Used when
1: 	 * constructing an SPS descriptor from a row
1: 	 * in SYSSTATEMENTS.
1: 	 *
1: 	 * @param	dataDictionary		The data dictionary that this descriptor lives in
1: 	 * @param 	name 	the SPS name
1: 	 * @param 	uuid	the UUID
1: 	 * @param 	suuid	the schema UUID
1: 	 * @param 	compSchemaUUID	the schema UUID at compilation time
0: 	 * @param	char	type
1: 	 * @param 	valid	is the sps valid
1: 	 * @param 	text	the text for this statement
1: 	 * @param 	usingText	the text for the USING clause supplied to
1: 	 *					CREATE or ALTER STATEMENT
1: 	 * @param 	compileTime	the time this was compiled
1: 	 * @param 	preparedStatement	the PreparedStatement
1: 	 * @param	initiallyCompilable	is the statement initially compilable?
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public SPSDescriptor
1: 				(DataDictionary	dataDictionary,
1: 				String		name,
1: 			   	UUID		uuid,
1: 				UUID		suuid,
1: 				UUID		compSchemaUUID,
1: 				char		type,
1: 			   	boolean		valid,
1: 			   	String		text,
1: 				String 		usingText,
1: 			   	Timestamp	compileTime,
1: 			   	ExecPreparedStatement	preparedStatement,
1: 				boolean		initiallyCompilable ) throws StandardException
1: 	{
1: 		super( dataDictionary );
1: 
1: 		this.name = name;
1: 		this.uuid = uuid; 
1: 		this.type = type;
1: 		this.text = text;
1: 		this.usingText = usingText;
1: 		this.valid = valid;
0: 		this.compileTime = compileTime;
1: 		this.sd = dataDictionary.getSchemaDescriptor(suuid, null);
1: 		this.preparedStatement = preparedStatement;
1: 		this.compSchemaId = compSchemaUUID;
1: 		this.initiallyCompilable = initiallyCompilable;
1: 	}
1: 
1: 	/**
1: 	 * FOR TRIGGERS ONLY
1: 	 * <p>
1: 	 * Generate the class for this SPS and immediately
1: 	 * release it.  This is useful for cases where we
1: 	 * don't want to immediately execute the statement 
1: 	 * corresponding to this sps (e.g. CREATE STATEMENT).
1:  	 * <p>
1: 	 * <I>SIDE EFFECTS</I>: will update and SYSDEPENDS 
1: 	 * with the prepared statement dependency info.
1:  	 * 
1: 	 * @param lcc the language connection context
1: 	 * @param triggerTable the table descriptor to bind against.  Had
1: 	 * 	better be null if this isn't a trigger sps.
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public final synchronized void prepareAndRelease
1: 	(
1: 		LanguageConnectionContext	lcc, 
0: 		TableDescriptor				triggerTable
1: 	) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (triggerTable != null)
1: 			{
1: 				SanityManager.ASSERT(type == SPS_TYPE_TRIGGER, "only expect a table descriptor when we have a trigger");
1: 			}
1: 		}
1: 		
0: 		compileStatement(lcc, triggerTable);
1: 	
1: 		preparedStatement.makeInvalid(DependencyManager.PREPARED_STATEMENT_RELEASE, lcc);
1: 	}
1: 
1: 	/**
1: 	 * Generate the class for this SPS and immediately
1: 	 * release it.  This is useful for cases where we
1: 	 * don't want to immediately execute the statement 
1: 	 * corresponding to this sps (e.g. CREATE STATEMENT).
1:  	 * <p>
1: 	 * <I>SIDE EFFECTS</I>: will update and SYSDEPENDS 
1: 	 * with the prepared statement dependency info.
1: 	 *
1: 	 * @param lcc the language connection context
1:  	 * 
1: 	 * @exception StandardException on error
1: 	 */
1: 	public final synchronized void prepareAndRelease(LanguageConnectionContext lcc) throws StandardException
1: 	{
0: 		prepareAndRelease(lcc, (TableDescriptor)null);
1: 	}
1: 
1: 	private void compileStatement
1: 	(
1: 		LanguageConnectionContext	lcc,
0: 		TableDescriptor				triggerTable
1: 	)
1: 		throws StandardException
1: 	{
0: 		ContextManager cm = ContextService.getFactory().getCurrentContextManager();
1: 		DependencyManager dm;
0: 		ProviderInfo[] providerInfo;
1: 
1: 		LanguageConnectionFactory	lcf = lcc.getLanguageConnectionFactory();
1: 
1: 		DataDictionary dd = getDataDictionary();
1: 
1: 
1: 		/*
1: 		** If we are a trigger, then we have to go ahead
1: 		** and locate the trigger's table descriptor and
1: 		** push it on the lcc.  This is expensive, but
1: 		** pretty atypical since trigger actions aren't
1: 		** likely to be invalidated too often.  Also, when
1: 		** possible, we already have the triggerTable.
1: 		*/
1: 		if (type == SPS_TYPE_TRIGGER && triggerTable == null)
1: 		{
1: 			String uuidStr = name.substring(49);
1: 			triggerTable = dd.getTableDescriptor(recreateUUID(uuidStr));
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				if (triggerTable == null)
1: 				{
1: 					SanityManager.THROWASSERT("couldn't find trigger table for trigger sps "+name);
1: 				}
1: 			}
1: 		}
1: 
1: 		if (triggerTable != null)
1: 		{
1: 			lcc.pushTriggerTable(triggerTable);
1: 		}
1: 
1: 		// stored statements always stored as unicode.
0: 		Statement 			stmt = lcf.getStatement(dd.getSchemaDescriptor(compSchemaId, null), text);
1: 
1: 		try
1: 		{
1: 			preparedStatement = (ExecPreparedStatement) stmt.prepareStorable(
1: 								lcc,
1: 								preparedStatement, 
1: 								getParameterDefaults(),
1: 								getSchemaDescriptor(),
1: 								type == SPS_TYPE_TRIGGER);
1: 		}
1: 		finally
1: 		{
1: 			if (triggerTable != null)
1: 			{
1: 				lcc.popTriggerTable(triggerTable);
1: 			}
1: 		}
1: 
1: 		//If this references a SESSION schema table (temporary or permanent), then throw an exception
1: 		//This is if EXECUTE STATEMENT executing a statement that was created with NOCOMPILE. Because
1: 		//of NOCOMPILE, we could not catch SESSION schema table reference by the statement at
1: 		//CREATE STATEMENT time. And hence need to catch such statements at EXECUTE STATEMENT time
1: 		//when the query is getting compiled.
1: 		if (preparedStatement.referencesSessionSchema())
1: 			throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
1:       
1: 		setCompileTime();
1: 		setParams(preparedStatement.getParameterTypes());
1: 
0: 		if (!((org.apache.derby.impl.sql.catalog.DataDictionaryImpl) dd).readOnlyUpgrade) {
1: 
1: 			/*
1: 			** Indicate that we are going to write the data
1: 			** dictionary.  We have probably already done this
1: 			** but it is ok to call startWriting more than once.
1: 			*/
1: 			dd.startWriting(lcc);
1: 
0: 			dm = dd.getDependencyManager();
1: 			/*
1: 			** Clear out all the dependencies that exist
1: 			** before we recreate them so we don't grow
1: 			** SYS.SYSDEPENDS forever.
1: 			*/
1: 			dm.clearDependencies(lcc, this);
1: 
1: 			/*
1: 			** Copy over all the dependencies to me
1: 			*/
1: 			dm.copyDependencies(preparedStatement, 	// from
1: 											this, 	// to
1: 											false,	// persistent only
0: 											cm);
1: 		}
1: 
1: 		// mark it as valid
1: 		valid = true;
1: 	}
1: 
1: 	/**
1: 	 * Gets the name of the sps.
1: 	 *
1: 	 * @return	A String containing the name of the statement.
1: 	 */
1: 	public final String	getName()
1: 	{
1: 		return name;
1: 	}
1: 
1: 	/**
1: 	 * Gets the full, qualified name of the statement.
1: 	 *
1: 	 * @return	A String containing the name of the statement.
1: 	 */
1: 	public final String	getQualifiedName()
1: 	{
1: 		return sd.getSchemaName() + "." + name;
1: 	}
1: 
1: 	/**
1: 	 * Gets the SchemaDescriptor for this SPS Descriptor.
1: 	 *
1: 	 * @return SchemaDescriptor	The SchemaDescriptor.
1: 	 */
1: 	public final SchemaDescriptor getSchemaDescriptor()
1: 	{
1: 		return sd;
1: 	}
1: 
1: 	/**
1: 	 * Gets an identifier telling what type of table this is.
1: 	 * Types match final ints in this interface.  Currently
1: 	 * returns SPS_TYPE_REGULAR or SPS_TYPE_TRIGGER.
1: 	 *
1: 	 * @return	An identifier telling what type of statement
1:  	 * we are.
1: 	 */
1: 	public final char getType()
1: 	{
1: 		return type;
1: 	}	
1: 
1: 	/**
1: 	 * Simple little helper function to convert your type
1: 	 * to a string, which is easier to use.
1: 	 *
1: 	 * @return type as a string
1: 	 */	
0: 	public final String getTypeAsString()
1: 	{
0: 		char[] charArray = new char[1];
0: 		charArray[0] = type;
0: 		return new String(charArray);
1: 	}
1: 
1: 	/**
1: 	 * Is the statement initially compilable?  
1: 	 *
1: 	 * @return	false if statement was created with the NOCOMPILE flag
1: 	 *			true otherwise
1: 	 */
1: 	public boolean initiallyCompilable() { return initiallyCompilable; }
1: 	
1: 	/**
1: 	 * Validate the type. <B>NOTE</B>: Only SPS_TYPE_REGULAR
1: 	 * and SPS_TYPE_TRIGGER are currently valid.
1: 	 *
1: 	 * @param type the type
1: 	 *
1: 	 * @return true/false	
1: 	 */
0: 	public final static boolean validType(char type)
1: 	{
1: 		return (type == SPSDescriptor.SPS_TYPE_REGULAR) || 
1: 				(type == SPSDescriptor.SPS_TYPE_TRIGGER);
1: 	}
1: 
1: 	/**
1: 	 * The time this prepared statement was compiled
1: 	 *
1: 	 * @return the time this class was last compiled
1: 	 */
1: 	public final synchronized Timestamp getCompileTime()
1: 	{
0: 		return compileTime;
1: 	}
1: 
1: 	/**
1: 	 * Set the compile time to now
1: 	 *
1: 	 */
1: 	public final synchronized void setCompileTime()
1: 	{
1: 		compileTime = new Timestamp(System.currentTimeMillis());
1: 	}
1: 	 
1: 	/**
1: 	 * Get the text used to create this statement.
1: 	 * Returns original text in a cleartext string.
1: 	 *
1: 	 * @return The text
1: 	 */
0: 	public final String getText()
1: 	{
1: 		return text;
1: 	}
1: 
1: 	/**
1: 	 * Get the text of the USING clause used on CREATE
1: 	 * or ALTER statement.
1: 	 *
1: 	 * @return The text
1: 	 */
0: 	public final synchronized String getUsingText()
1: 	{
1: 		return usingText;
1: 	}
1: 
1: 	/**
0: 	 * Set the text of the USING clause. Used by
0: 	 * ALTER statement.
1: 	 *
0: 	 * @param usingText	the new value for the USING text
1: 	 */
0: 	public final synchronized void setUsingText(String usingText)
1: 	{
1: 		this.usingText = usingText;
1: 	}
1: 
1: 	/**
0: 	 * Sets the UUID of the SPS.
1: 	 *
0: 	 * @param uuid	The UUID of the SPS to be set in the descriptor
1: 	 */
0: 	public final synchronized void setUUID(UUID uuid)
1: 	{
1: 		this.uuid = uuid;
1: 	}
1: 
1: 	/**
0: 	 * Gets the UUID of the SPS.
1: 	 *
0: 	 * @return	the uuid
1: 	 */
0: 	public final UUID	getUUID()
1: 	{
1: 		return uuid;
1: 	}
1: 	
1: 	/**
1: 	 * Get the array of date type descriptors for
1: 	 * this statement.  Currently, we do a lookup
1: 	 * if we don't already have the parameters saved.
1: 	 * When SPSes are cached, the parameters should
1: 	 * be set up when the sps is constructed.
1: 	 *
1: 	 * @return the array of data type descriptors
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public final synchronized DataTypeDescriptor[] getParams()
1: 		throws StandardException
1: 	{
0: 		if (params == null && !lookedUpParams)
1: 		{
0: 			Vector v = new Vector();
0: 			params = getDataDictionary().getSPSParams(this, v);
0: 			paramDefaults = new Object[v.size()];	
0: 			Enumeration iterator = v.elements();
0: 			for (int i = 0; iterator.hasMoreElements(); i++)
1: 			{
0: 				paramDefaults[i] = iterator.nextElement();
1: 			}
1: 
0: 			lookedUpParams = true;
1: 		}
1: 
0: 		return params;
1: 	}
1: 
1: 	/**
1: 	 * Set the list of parameters for this statement
1: 	 *
1: 	 * @param params	the parameter list
1: 	 */
1: 	public final synchronized void setParams(DataTypeDescriptor params[])
1: 	{
0: 		this.params = params;
1: 	}
1: 
1: 	/**
1: 	 * Get the default parameter values for this 
1: 	 * statement.  Default parameter values are
1: 	 * supplied by a USING clause on either a
1: 	 * CREATE or ALTER STATEMENT statement.
1: 	 *
1: 	 * @return the default parameter values
1:  	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public final synchronized Object[] getParameterDefaults()
1: 		throws StandardException
1: 	{
1: 		if (paramDefaults == null)
1: 			getParams();
1: 
0: 		return paramDefaults;
1: 	}
1: 
1: 	/**
1: 	 * Set the parameter defaults for this statement.
1: 	 *
0: 	 * @param params	the parameter defaults
1: 	 */
1: 	public final synchronized void setParameterDefaults(Object[] values)
1: 	{
0: 		this.paramDefaults = values;
1: 	}
1: 	
1: 	/**
0: 	 * Get the constant action for this statement
1: 	 *
0: 	 * @return the constant action
1: 	 */
0: 	//public final synchronized ConstantAction getConstantAction()
0: 	//{
0: 	//	return preparedStatement.getConstantAction();
0: 	//}
1: 	
1: 	/**
1: 	 * Get the preparedStatement for this statement.
1: 	 * If stmt is invalid or hasn't been compiled yet,
1: 	 * it will be recompiled.
1: 	 *
1: 	 * @return the preparedStatement
1:  	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public final ExecPreparedStatement getPreparedStatement()
1: 		throws StandardException
1: 	{
1: 		return getPreparedStatement(true);
1: 	}
1: 
1: 	/**
1: 	 * Get the preparedStatement for this statement.
1: 	 * Expects the prepared statement to have already
1: 	 * been added to SYS.SYSSTATEMENTS.
1: 	 * <p>
1: 	 * Side Effects: will update SYS.SYSSTATEMENTS with
1: 	 * the new plan if it needs to be recompiled.
1: 	 *
1: 	 * @param recompIfInvalid if false, never recompile even
1: 	 *	if statement is invalid
1: 	 *
1: 	 * @return the preparedStatement
1:  	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public final synchronized ExecPreparedStatement getPreparedStatement(boolean recompIfInvalid)
1: 		throws StandardException
1: 	{
1: 		//System.out.println("preparedStatement = " + preparedStatement);
1: 		/*
1: 		** Recompile if we are invalid, we don't have
1: 		** a prepared statement, or the statements activation
1: 		** has been cleared and cannot be reconstituted.
1: 		*/
1: 		if (recompIfInvalid &&
1: 			(!valid ||
1: 			 (preparedStatement == null)))
1: 		{
0: 			ContextManager cm = ContextService.getFactory().getCurrentContextManager();
1: 
1: 			/*
1: 			** Find the language connection context.  Get
1: 			** it each time in case a connection is dropped.
1: 			*/
1: 			LanguageConnectionContext lcc = (LanguageConnectionContext)
1: 					cm.getContext(LanguageConnectionContext.CONTEXT_ID);
1: 			prepareAndRelease(lcc);
1: 
1: 
0: 			if (!((org.apache.derby.impl.sql.catalog.DataDictionaryImpl) (lcc.getDataDictionary())).readOnlyUpgrade) {
1: 
0: 				//bug 4821 - First try compiling on a nested transaction so we can release
0: 				//the locks after the compilation. But if we get lock time out on the
0: 				//nested transaction, then go ahead and do the compilation on the user
0: 				//transaction. When doing the compilation on user transaction, the locks
0: 				//acquired for recompilation will be released at the end of the user transaction.
1: 				TransactionController nestedTC;
1: 				try
1: 				{
0: 					nestedTC = lcc.getTransactionCompile().startNestedUserTransaction(false);
1: 				}
1: 				catch (StandardException se)
1: 				{
0: 					// If I cannot start a Nested User Transaction use the parent
0: 					// transaction to do all the work.
0: 					nestedTC = null;
1: 				}
1: 
1: 				try
1: 				{
1: 					updateSYSSTATEMENTS(lcc, RECOMPILE, nestedTC);
1: 				}
1: 				catch (StandardException se)
1: 				{
0: 					if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT))
1: 					{
1: 						if (nestedTC != null)
1: 						{
0: 						nestedTC.commit();
0: 						nestedTC.destroy();
0: 						nestedTC = null;
1: 						}
0: 						// if we couldn't do this with a nested xaction, retry with
0: 						// parent-- we need to wait this time!
1: 						updateSYSSTATEMENTS(lcc, RECOMPILE, null);
1: 					}
0: 					else throw se;
1: 				}
1: 				finally
1: 				{
0: 					// no matter what, commit the nested transaction; if something
0: 					// bad happened in the child xaction lets not abort the parent
0: 					// here.
1: 					if (nestedTC != null)
1: 					{
0: 						nestedTC.commit();
0: 						nestedTC.destroy();
1: 					}
1: 				} 
1: 			}
1: 		}
1: 
1: 		return preparedStatement;
1: 	}
1: 
1: 	/**
1: 	 * Get the compilation type schema id when this view
1: 	 * was first bound.
1: 	 *
1: 	 * @return the schema UUID
1: 	 */
1: 	public final UUID getCompSchemaId()
1: 	{
1: 		return compSchemaId;
1: 	}
1: 
1: 	/**
1: 	 * Prints the contents of the TableDescriptor
1: 	 *
1: 	 * @return The contents as a String
1: 	 */
1: 	public final String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return "SPSDescriptor:\n"+
1: 				"\tname: "+sd.getSchemaName()+"."+name+"\n"+
1: 				"\tuuid: "+uuid+"\n"+
1: 				"\ttext: "+text+"\n"+
1: 				"\tvalid: "+((valid) ? "TRUE" : "FALSE")+"\n" +
1: 				"\tpreparedStatement: "+preparedStatement+"\n";
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	//////////////////////////////////////////////////////
1: 	//
1: 	// PROVIDER INTERFACE
1: 	//
1: 	//////////////////////////////////////////////////////
1: 
1: 	/**		
1: 	 * Return the stored form of this provider
1: 	 *
1: 	 * @see Dependable#getDependableFinder
1: 	 */
1: 	public final DependableFinder getDependableFinder()
1: 	{
1: 	    return	getDependableFinder(StoredFormatIds.SPS_DESCRIPTOR_FINDER_V01_ID);
1: 	}
1: 
1: 	/**
1: 	 * Return the name of this Provider.  (Useful for errors.)
1: 	 *
1: 	 * @return String	The name of this provider.
1: 	 */
1: 	public final String getObjectName()
1: 	{
1: 		return name;
1: 	}
1: 
1: 	/**
1: 	 * Get the provider's UUID 
1: 	 *
1: 	 * @return String	The provider's UUID
1: 	 */
1: 	public final UUID getObjectID()
1: 	{
1: 		return uuid;
1: 	}
1: 
1: 	/**
1: 	 * Get the provider's type.
1: 	 *
1: 	 * @return String The provider's type.
1: 	 */
1: 	public final String getClassType()
1: 	{
1: 		return Dependable.STORED_PREPARED_STATEMENT;
1: 	}
1: 
1: 	//////////////////////////////////////////////////////
1: 	//
1: 	// DEPENDENT INTERFACE
1: 	//
1: 	//////////////////////////////////////////////////////
1: 	/**
1: 	 * Check that all of the dependent's dependencies are valid.
1: 	 *
1: 	 * @return true if the dependent is currently valid
1: 	 */
1: 	public final synchronized boolean isValid()
1: 	{
1: 		return valid;
1: 	}
1: 
1: 	/**
1: 	 * Prepare to mark the dependent as invalid (due to at least one of
1: 	 * its dependencies being invalid).
1: 	 *
1: 	 * @param action	The action causing the invalidation
1: 	 * @param p		the provider
1: 	 *
1: 	 * @exception StandardException thrown if unable to make it invalid
1: 	 */
0: 	public final synchronized void prepareToInvalidate(
1: 									Provider p, int action,
1: 									LanguageConnectionContext lcc) 
1: 		throws StandardException
1: 	{
1: 		switch (action)
1: 		{
1: 			/*
1: 			** Things that don't affect us
1: 			*/
1: 		    case DependencyManager.CREATE_VIEW:
1: 	
1: 			/*
1: 			** Things that force a recompile, but are
1: 			** allowed.
1: 			*/
1: 			case DependencyManager.CREATE_INDEX:
1: 			case DependencyManager.CREATE_CONSTRAINT:
1: 			case DependencyManager.DROP_CONSTRAINT:
1: 			case DependencyManager.DROP_INDEX:
1: 			case DependencyManager.DROP_TABLE:
1: 			case DependencyManager.DROP_VIEW: 
1: 			case DependencyManager.DROP_METHOD_ALIAS:
1: 			case DependencyManager.ALTER_TABLE:
1: 			case DependencyManager.RENAME:
1: 			case DependencyManager.RENAME_INDEX:
1: 			case DependencyManager.PREPARED_STATEMENT_RELEASE:
1: 			case DependencyManager.USER_RECOMPILE_REQUEST:
1: 			case DependencyManager.CHANGED_CURSOR:
1: 			case DependencyManager.BULK_INSERT:
1: 			case DependencyManager.COMPRESS_TABLE:
1: 			case DependencyManager.SET_CONSTRAINTS_ENABLE:
1: 			case DependencyManager.SET_CONSTRAINTS_DISABLE:
1: 			case DependencyManager.SET_TRIGGERS_ENABLE:
1: 			case DependencyManager.SET_TRIGGERS_DISABLE:
1: 			case DependencyManager.ROLLBACK:
1: 			case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
1: 			case DependencyManager.CREATE_TRIGGER:
1: 			case DependencyManager.DROP_TRIGGER:
0: 			case DependencyManager.DROP_TABLE_CASCADE:
0: 			case DependencyManager.DROP_VIEW_CASCADE:
1: 			case DependencyManager.DROP_COLUMN:
0: 			case DependencyManager.DROP_COLUMN_CASCADE:
1: 		    case DependencyManager.UPDATE_STATISTICS:
1: 		    case DependencyManager.DROP_STATISTICS:
1:     		case DependencyManager.TRUNCATE_TABLE:
1: 				break;
1: 
1: 			/*
1: 			** The rest are errors
1: 			*/
1: 		    default:
1: 
1: 				DependencyManager dm;
1: 
1: 				dm = getDataDictionary().getDependencyManager();
1: 				throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_S_P_S, 
1: 					dm.getActionString(action), 
1: 					p.getObjectName(), name);
1: 
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Mark the dependent as invalid (due to at least one of
1: 	 * its dependencies being invalid).
1: 	 *
1: 	 * @param	action	The action causing the invalidation
1: 	 *
1: 	 * @exception StandardException thrown if unable to make it invalid
1: 	 */
1: 	public final synchronized void makeInvalid(int action,
1: 											   LanguageConnectionContext lcc) 
1: 		throws StandardException
1: 	{
1: 		DependencyManager dm;
1: 
1: 		dm = getDataDictionary().getDependencyManager();
1: 
1: 		switch (action)
1: 		{
1: 			/*
1: 			** Some things that don't affect stored prepared
1: 	 		** statements.
1: 			*/
1: 			case DependencyManager.PREPARED_STATEMENT_RELEASE:
1: 		    case DependencyManager.CREATE_VIEW:
1: 				break;
1: 
1: 			/*
1: 		 	** Things that can invalidate a stored
1: 			** prepared statement.
1: 			*/
1: 			case DependencyManager.CREATE_INDEX:
1: 			case DependencyManager.CREATE_CONSTRAINT:
1: 			case DependencyManager.DROP_CONSTRAINT:
1: 			case DependencyManager.DROP_TABLE:
1: 			case DependencyManager.DROP_INDEX:
1: 			case DependencyManager.DROP_VIEW: 
1: 			case DependencyManager.DROP_METHOD_ALIAS:
1: 			case DependencyManager.ALTER_TABLE:
1: 			case DependencyManager.RENAME:
1: 			case DependencyManager.RENAME_INDEX:
1: 			case DependencyManager.USER_RECOMPILE_REQUEST:
1: 			case DependencyManager.CHANGED_CURSOR:
1: 			case DependencyManager.BULK_INSERT:
1: 			case DependencyManager.COMPRESS_TABLE:
1: 			case DependencyManager.SET_CONSTRAINTS_ENABLE:
1: 			case DependencyManager.SET_CONSTRAINTS_DISABLE:
1: 			case DependencyManager.SET_TRIGGERS_ENABLE:
1: 			case DependencyManager.SET_TRIGGERS_DISABLE:
1: 			case DependencyManager.ROLLBACK:
1: 			case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
1: 			case DependencyManager.CREATE_TRIGGER:
1: 			case DependencyManager.DROP_TRIGGER:
0: 			case DependencyManager.DROP_TABLE_CASCADE:
0: 			case DependencyManager.DROP_VIEW_CASCADE:
1: 			case DependencyManager.DROP_COLUMN:
0: 			case DependencyManager.DROP_COLUMN_CASCADE:
1: 		    case DependencyManager.UPDATE_STATISTICS:
1: 		    case DependencyManager.DROP_STATISTICS:
1: 			case DependencyManager.TRUNCATE_TABLE:
1: 				/*
1: 				** If we are already invalid, don't write ourselves
1: 				** out.  Just to be safe, we'll send out an invalidate
1: 				** to our dependents either way.
1: 				*/
1: 				if (valid == true)
1: 				{
1: 					valid = false;
1: 					updateSYSSTATEMENTS(lcc, INVALIDATE, null);
1: 				}
0: 				dm.invalidateFor(this, dm.USER_RECOMPILE_REQUEST, lcc);
1: 				break;
1: 			case DependencyManager.DROP_SPS:
1: 				//System.out.println("SPSD " + preparedStatement);
1: 				dm.clearDependencies(lcc, this);
1: 				break;
1: 	
1: 		    default:
1: 
1: 				/* 
1: 				** We should never get here, since we can't have dangling references 
1: 				*/
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.THROWASSERT("makeInvalid("+
1: 						dm.getActionString(action)+
1: 						") not expected to get called; should have failed in "+
1: 						"prepareToInvalidate()");
1: 				}
1: 				break;
1: 
1: 		}
1: 
1: 	}
1: 
1: 	/**
0:      * Attempt to revalidate the dependent. For prepared statements,
0: 	 * this could go through its dependencies and check that they
0: 	 * are up to date; if not, it would recompile the statement.
0: 	 * Any failure during this attempt should throw
0: 	 * StandardException.unableToRevalidate().
1: 	 *
0: 	 * @exception StandardException thrown if unable to make it valid
1: 	 */
0: 	public final synchronized void makeValid(LanguageConnectionContext lcc) 
1: 		throws StandardException
1: 	{
0: 		if (valid)
1: 		{
1: 			return;
1: 		}
1: 		prepareAndRelease(lcc);
1: 
1: 		updateSYSSTATEMENTS(lcc, RECOMPILE, null);
1: 		
1: 	}
1: 
1: 	/**
1: 	 * Invalidate and revalidate.  The functional equivalent
1: 	 * of calling makeInvalid() and makeValid(), except it
1: 	 * is optimized.
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public final synchronized void revalidate(LanguageConnectionContext lcc)
1: 		throws StandardException
1: 	{
1: 		/*
1: 		** Mark it as invalid first to ensure that
1: 		** we don't write SYSSTATEMENTS 2x.
1: 		*/
1: 		valid = false;
1: 		makeInvalid(DependencyManager.USER_RECOMPILE_REQUEST, lcc);
1: 		prepareAndRelease(lcc);
1: 		updateSYSSTATEMENTS(lcc, RECOMPILE, null);
1: 	}
1: 
1: 	/**
1: 	 * Load the underlying generatd class.  This is not expected
1: 	 * to be used outside of the datadictionary package.  It
1: 	 * is used for optimizing class loading for sps
1: 	 * cacheing.
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public void loadGeneratedClass() throws StandardException
1: 	{
1: 		/*
1: 		** On upgrade, we null out the statement body,
1: 		** so handle that here.
1: 		*/
1: 		if (preparedStatement != null)
1: 		{
1: 			((StorablePreparedStatement)preparedStatement).loadGeneratedClass();
1: 		}
1: 	}
1: 
1: 	/*
1: 	** Update SYSSTATEMENTS with the changed the descriptor.  
1: 	** Always done in the user XACT.
1: 	** <p>
1: 	** Ideally, the changes to SYSSTATEMENTS would be made 
1: 	** in a separate xact as the current user xact, but this
1: 	** is painful (you'ld need to get a new ContextManager
1: 	** and then push all of the usual langauge contexts
1: 	** onto it and THEN call AccessManager.getTransaction()),
1: 	** and it wont work, because the xact is in a different
1: 	** compatibility space and will self deadlock (e.g.
1: 	** in the process of call DependencyManager.makeInvalid() 
1: 	** we first did a DDdependableFinder.getDependable()
1: 	** which called DataDictionaryImpl.getSPSDescriptor()
1: 	** so we hold a lock on SYS.SYSSTATEMENTS by the
1: 	** time we get a 2nd xact and try to drop the statement).
1: 	*/
1: 	private void updateSYSSTATEMENTS(LanguageConnectionContext lcc, int mode, TransactionController tc)
1: 		throws StandardException
1: 	{
0: 		int[] 					colsToUpdate;
0: 		boolean					updateSYSCOLUMNS,  recompile;
0: 		//bug 4821 - we want to wait for locks if updating sysstatements on parent transaction
0: 		boolean wait = false;
0: 		boolean firstCompilation = false;
0: 		if (mode == RECOMPILE)
1: 		{
0: 			recompile = true;
0: 			updateSYSCOLUMNS = true;
0: 			if(!initiallyCompilable)
1: 			{
0: 				firstCompilation = true;
0: 				initiallyCompilable = true;
1: 			}
1: 		}
1: 		else
1: 		{
0: 			recompile = false;
0: 			updateSYSCOLUMNS = false;
1: 		}
1: 
1: 		DataDictionary dd = getDataDictionary();
1: 
0: 		if (((org.apache.derby.impl.sql.catalog.DataDictionaryImpl) dd).readOnlyUpgrade)
1: 			return;
1: 
1: 
1: 		/*
1: 		** Get busy time
1: 		*/
1: 		dd.startWriting(lcc);	
1: 
1: 		if (tc == null) { //bug 4821 - tc will passed null if we want to use the user transaction
1: 			tc = lcc.getTransactionExecute();
0: 			wait = true;
1: 		}
1: 
0: 		dd.updateSPS(this,
0: 					 tc, 
0: 					 recompile,
0: 					 updateSYSCOLUMNS,
0: 					 wait,
0: 					 firstCompilation);
1: 	}
1: 
1: 	/**
1: 	 * Get the UUID for the given string
1: 	 *
0: 	 * @param the string
1: 	 *
1: 	 * @return the UUID
1: 	 */
1: 	private UUID recreateUUID(String idString)
1: 	{
1: 		if (uuidFactory == null)
1: 		{
0: 			uuidFactory = Monitor.getMonitor().getUUIDFactory();
1: 		}
1: 		return uuidFactory.recreateUUID(idString);
1: 	}
1: 
1: 	/** @see TupleDescriptor#getDescriptorType */
1: 	public String getDescriptorType() { return "Statement"; }
1: 
1: 	/** @see TupleDescriptor#getDescriptorName */
1: 	// RESOLVE: some descriptors have getName.  some descriptors have
1: 	// getTableName, getColumnName whatever! try and unify all of this to one
1: 	// getDescriptorName! 
1: 	public String getDescriptorName() { return name; }
1: 	
1: }
1: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2e658c2
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param	type	type
/////////////////////////////////////////////////////////////////////////
1: 	 * @param	type	type
/////////////////////////////////////////////////////////////////////////
1: 	 * @param values	the parameter defaults
/////////////////////////////////////////////////////////////////////////
1: 	 * @param idString	the string
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:93e7f0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:81ad58c
/////////////////////////////////////////////////////////////////////////
1: 			case DependencyManager.DROP_SYNONYM:
/////////////////////////////////////////////////////////////////////////
1: 			case DependencyManager.DROP_SYNONYM:
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:5087be8
/////////////////////////////////////////////////////////////////////////
1: 		Statement 			stmt = lcf.getStatement(dd.getSchemaDescriptor(compSchemaId, null), text, true);
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql.dictionary;
0: 
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.sql.Statement;
0: import org.apache.derby.iapi.sql.StorablePreparedStatement;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.Dependency;
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.sql.depend.ProviderInfo;
0: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: 
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.catalog.Dependable;
0: import org.apache.derby.catalog.DependableFinder;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: 
0: import java.util.Enumeration;
0: import java.util.Vector;
0: import java.sql.Timestamp;
0: 
0: /**
0:  * A SPSDescriptor describes a Stored Prepared Statement.
0:  * It correlates to a row in SYS.SYSSTATEMENTS.
0:  *
0:  * <B>SYNCHRONIZATION</B>: Stored prepared statements
0:  * may be cached.  Thus they may be shared by multiple
0:  * threads.  It is very hard for two threads to try
0:  * to muck with an sps simultaeously because all ddl
0:  * (including sps recompilation) clears out the sps
0:  * cache and invalidates whatever statement held a
0:  * cached sps.  But it is possible for two statements
0:  * to do a prepare execute statment <x> at the exact
0:  * same time, so both try to do an sps.prepare() at the 
0:  * same time during code generation, so we synchronize
0:  * most everything except getters on immutable objects
0:  * just to be on the safe side.
0:  *
0:  *
0:  * @author jamie
0:  */
0: public class SPSDescriptor extends TupleDescriptor
0: 	implements UniqueSQLObjectDescriptor, Dependent, Provider
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	/**
0: 	 * Statement types.  
0: 	 * <UL>
0: 	 * <LI> SPS_TYPE_TRIGGER	- trigger (<B>NOT IMPLEMENTED</B>) </LI>
0: 	 * <LI> SPS_TYPE_EXPLAIN	- explain (<B>NOT IMPLEMENTED</B>) </LI>
0: 	 * <LI> SPS_TYPE_REGULAR	- catchall</LI>
0: 	 * </UL>
0: 	 */
0: 	public static final char SPS_TYPE_TRIGGER	= 'T';
0: 	public static final char SPS_TYPE_REGULAR	= 'S';
0: 	public static final char SPS_TYPE_EXPLAIN	= 'X';
0: 
0: 	/**
0: 	   interface to this class is:
0: 	   <ol>
0: 	   <li>public void prepare() throws StandardException;
0: 	   <li>public void prepareAndRelease(LanguageConnectionContext lcc) 
0: 	   throws StandardException;
0: 	   <li>public void prepareAndRelease(...);
0: 	   <li>public String	getQualifiedName();
0: 	   <li>public char	getType();
0: 	   <li>public String getTypeAsString();
0: 	   <li>public boolean isValid();
0: 	   <li>public boolean initiallyCompilable();
0: 	   <li>public java.sql.Timestamp getCompileTime();
0: 	   <li>public void setCompileTime();
0: 	   <li>public String getText();
0: 	   <li>public String getUsingText();
0: 	   <li>public void setUsingText(String usingText);
0: 	   <li>public void	setUUID(UUID uuid);
0: 	   <li>public DataTypeDescriptor[] getParams() throws StandardException;
0: 	   <li>public void setParams(DataTypeDescriptor[] params);
0: 	   <li>Object[] getParameterDefaults()	throws StandardException;
0: 	   <li>void setParameterDefaults(Object[] values);
0: 	   <li>public UUID getCompSchemaId();
0: 	   <li>public ExecPreparedStatement getPreparedStatement()
0: 	   throws StandardException;
0: 	   <li>public ExecPreparedStatement getPreparedStatement(boolean recompIfInvalid)
0: 	   throws StandardException;
0: 	   <li>public void revalidate(LanguageConnectionContext lcc)
0: 			throws StandardException;
0: 			</ol>
0: 	*/
0: 
0: 	private static final int RECOMPILE = 1;
0: 	private static final int INVALIDATE = 0;
0: 
0: 		
0: 	// Class contents
0: 	private SchemaDescriptor		sd;
0: 	private String					name;
0: 	private UUID					uuid;
0: 	private UUID					compSchemaId;
0: 	private char					type;
0: 	private	boolean					valid;
0: 	private	String					text;
0: 	private	String					usingText;
0: 	private	ExecPreparedStatement	preparedStatement;
0: 	private	DataTypeDescriptor		params[];
0: 	private	Timestamp				compileTime;
0: 	private	Object					paramDefaults[];
0: 	private	boolean					initiallyCompilable;
0: 	private	boolean					lookedUpParams;
0: 	
0: 	private UUIDFactory				uuidFactory;
0: 
0: 
0: 	// constructors
0: 	/**
0: 	 * Constructor for a SPS Descriptor
0: 	 *
0: 	 * @param dataDictionary		The data dictionary that this descriptor lives in
0: 	 * @param 	name 	the SPS name
0: 	 * @param 	uuid	the UUID
0: 	 * @param 	suuid	the schema UUID
0: 	 * @param 	compSchemaUUID	the schema UUID at compilation time
0: 	 * @param	char	type
0: 	 * @param 	valid	is the sps valid
0: 	 * @param 	text	the text for this statement
0: 	 * @param 	usingText	the text for the USING clause supplied to
0: 	 *					CREATE or ALTER STATEMENT
0: 	 * @param	paramDefaults	default values for the parameters (if
0: 	 *					any) in this statement.  Generated by a USING
0: 	 *					clause, for use by the optimizer.
0: 	 * @param	initiallyCompilable	is the statement initially compilable?
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public SPSDescriptor
0: 				(DataDictionary		dataDictionary,
0: 				String				name,
0: 			   	UUID				uuid,
0: 			   	UUID				suuid,
0: 				UUID				compSchemaUUID,
0: 				char				type,
0: 			   	boolean				valid,
0: 			   	String				text,
0: 				String				usingText,
0: 				Object[]			paramDefaults,
0: 				boolean				initiallyCompilable ) throws StandardException
0: 	{
0: 		this( dataDictionary, name, uuid, suuid, compSchemaUUID, type, valid, text, usingText, null, null, initiallyCompilable );
0: 		this.paramDefaults = paramDefaults;
0: 	}
0: 
0: 	/**
0: 	 * Constructor for a SPS Descriptor.  Used when
0: 	 * constructing an SPS descriptor from a row
0: 	 * in SYSSTATEMENTS.
0: 	 *
0: 	 * @param	dataDictionary		The data dictionary that this descriptor lives in
0: 	 * @param 	name 	the SPS name
0: 	 * @param 	uuid	the UUID
0: 	 * @param 	suuid	the schema UUID
0: 	 * @param 	compSchemaUUID	the schema UUID at compilation time
0: 	 * @param	char	type
0: 	 * @param 	valid	is the sps valid
0: 	 * @param 	text	the text for this statement
0: 	 * @param 	usingText	the text for the USING clause supplied to
0: 	 *					CREATE or ALTER STATEMENT
0: 	 * @param 	compileTime	the time this was compiled
0: 	 * @param 	preparedStatement	the PreparedStatement
0: 	 * @param	initiallyCompilable	is the statement initially compilable?
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public SPSDescriptor
0: 				(DataDictionary	dataDictionary,
0: 				String		name,
0: 			   	UUID		uuid,
0: 				UUID		suuid,
0: 				UUID		compSchemaUUID,
0: 				char		type,
0: 			   	boolean		valid,
0: 			   	String		text,
0: 				String 		usingText,
0: 			   	Timestamp	compileTime,
0: 			   	ExecPreparedStatement	preparedStatement,
0: 				boolean		initiallyCompilable ) throws StandardException
0: 	{
0: 		super( dataDictionary );
0: 
0: 		this.name = name;
0: 		this.uuid = uuid; 
0: 		this.type = type;
0: 		this.text = text;
0: 		this.usingText = usingText;
0: 		this.valid = valid;
0: 		this.compileTime = compileTime;
0: 		this.sd = dataDictionary.getSchemaDescriptor(suuid, null);
0: 		this.preparedStatement = preparedStatement;
0: 		this.compSchemaId = compSchemaUUID;
0: 		this.initiallyCompilable = initiallyCompilable;
0: 	}
0: 
0: 	/**
0: 	 * FOR TRIGGERS ONLY
0: 	 * <p>
0: 	 * Generate the class for this SPS and immediately
0: 	 * release it.  This is useful for cases where we
0: 	 * don't want to immediately execute the statement 
0: 	 * corresponding to this sps (e.g. CREATE STATEMENT).
0:  	 * <p>
0: 	 * <I>SIDE EFFECTS</I>: will update and SYSDEPENDS 
0: 	 * with the prepared statement dependency info.
0:  	 * 
0: 	 * @param lcc the language connection context
0: 	 * @param triggerTable the table descriptor to bind against.  Had
0: 	 * 	better be null if this isn't a trigger sps.
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public final synchronized void prepareAndRelease
0: 	(
0: 		LanguageConnectionContext	lcc, 
0: 		TableDescriptor				triggerTable
0: 	) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (triggerTable != null)
0: 			{
0: 				SanityManager.ASSERT(type == SPS_TYPE_TRIGGER, "only expect a table descriptor when we have a trigger");
0: 			}
0: 		}
0: 		
0: 		compileStatement(lcc, triggerTable);
0: 	
0: 		preparedStatement.makeInvalid(DependencyManager.PREPARED_STATEMENT_RELEASE, lcc);
0: 	}
0: 
0: 	/**
0: 	 * Generate the class for this SPS and immediately
0: 	 * release it.  This is useful for cases where we
0: 	 * don't want to immediately execute the statement 
0: 	 * corresponding to this sps (e.g. CREATE STATEMENT).
0:  	 * <p>
0: 	 * <I>SIDE EFFECTS</I>: will update and SYSDEPENDS 
0: 	 * with the prepared statement dependency info.
0: 	 *
0: 	 * @param lcc the language connection context
0:  	 * 
0: 	 * @exception StandardException on error
0: 	 */
0: 	public final synchronized void prepareAndRelease(LanguageConnectionContext lcc) throws StandardException
0: 	{
0: 		prepareAndRelease(lcc, (TableDescriptor)null);
0: 	}
0: 
0: 	private void compileStatement
0: 	(
0: 		LanguageConnectionContext	lcc,
0: 		TableDescriptor				triggerTable
0: 	)
0: 		throws StandardException
0: 	{
0: 		ContextManager cm = ContextService.getFactory().getCurrentContextManager();
0: 		DependencyManager dm;
0: 		ProviderInfo[] providerInfo;
0: 
0: 		LanguageConnectionFactory	lcf = lcc.getLanguageConnectionFactory();
0: 
0: 		DataDictionary dd = getDataDictionary();
0: 
0: 
0: 		/*
0: 		** If we are a trigger, then we have to go ahead
0: 		** and locate the trigger's table descriptor and
0: 		** push it on the lcc.  This is expensive, but
0: 		** pretty atypical since trigger actions aren't
0: 		** likely to be invalidated too often.  Also, when
0: 		** possible, we already have the triggerTable.
0: 		*/
0: 		if (type == SPS_TYPE_TRIGGER && triggerTable == null)
0: 		{
0: 			String uuidStr = name.substring(49);
0: 			triggerTable = dd.getTableDescriptor(recreateUUID(uuidStr));
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (triggerTable == null)
0: 				{
0: 					SanityManager.THROWASSERT("couldn't find trigger table for trigger sps "+name);
0: 				}
0: 			}
0: 		}
0: 
0: 		if (triggerTable != null)
0: 		{
0: 			lcc.pushTriggerTable(triggerTable);
0: 		}
0: 
0: 		// stored statements always stored as unicode.
0: 		Statement 			stmt = lcf.getStatement(dd.getSchemaDescriptor(compSchemaId, null), text);
0: 
0: 		try
0: 		{
0: 			preparedStatement = (ExecPreparedStatement) stmt.prepareStorable(
0: 								lcc,
0: 								preparedStatement, 
0: 								getParameterDefaults(),
0: 								getSchemaDescriptor(),
0: 								type == SPS_TYPE_TRIGGER);
0: 		}
0: 		finally
0: 		{
0: 			if (triggerTable != null)
0: 			{
0: 				lcc.popTriggerTable(triggerTable);
0: 			}
0: 		}
0: 
0: 		//If this references a SESSION schema table (temporary or permanent), then throw an exception
0: 		//This is if EXECUTE STATEMENT executing a statement that was created with NOCOMPILE. Because
0: 		//of NOCOMPILE, we could not catch SESSION schema table reference by the statement at
0: 		//CREATE STATEMENT time. And hence need to catch such statements at EXECUTE STATEMENT time
0: 		//when the query is getting compiled.
0: 		if (preparedStatement.referencesSessionSchema())
0: 			throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
0:       
0: 		setCompileTime();
0: 		setParams(preparedStatement.getParameterTypes());
0: 
0: 		if (!((org.apache.derby.impl.sql.catalog.DataDictionaryImpl) dd).readOnlyUpgrade) {
0: 
0: 			/*
0: 			** Indicate that we are going to write the data
0: 			** dictionary.  We have probably already done this
0: 			** but it is ok to call startWriting more than once.
0: 			*/
0: 			dd.startWriting(lcc);
0: 
0: 			dm = dd.getDependencyManager();
0: 			/*
0: 			** Clear out all the dependencies that exist
0: 			** before we recreate them so we don't grow
0: 			** SYS.SYSDEPENDS forever.
0: 			*/
0: 			dm.clearDependencies(lcc, this);
0: 
0: 			/*
0: 			** Copy over all the dependencies to me
0: 			*/
0: 			dm.copyDependencies(preparedStatement, 	// from
0: 											this, 	// to
0: 											false,	// persistent only
0: 											cm);
0: 		}
0: 
0: 		// mark it as valid
0: 		valid = true;
0: 	}
0: 
0: 	/**
0: 	 * Gets the name of the sps.
0: 	 *
0: 	 * @return	A String containing the name of the statement.
0: 	 */
0: 	public final String	getName()
0: 	{
0: 		return name;
0: 	}
0: 
0: 	/**
0: 	 * Gets the full, qualified name of the statement.
0: 	 *
0: 	 * @return	A String containing the name of the statement.
0: 	 */
0: 	public final String	getQualifiedName()
0: 	{
0: 		return sd.getSchemaName() + "." + name;
0: 	}
0: 
0: 	/**
0: 	 * Gets the SchemaDescriptor for this SPS Descriptor.
0: 	 *
0: 	 * @return SchemaDescriptor	The SchemaDescriptor.
0: 	 */
0: 	public final SchemaDescriptor getSchemaDescriptor()
0: 	{
0: 		return sd;
0: 	}
0: 
0: 	/**
0: 	 * Gets an identifier telling what type of table this is.
0: 	 * Types match final ints in this interface.  Currently
0: 	 * returns SPS_TYPE_REGULAR or SPS_TYPE_TRIGGER.
0: 	 *
0: 	 * @return	An identifier telling what type of statement
0:  	 * we are.
0: 	 */
0: 	public final char getType()
0: 	{
0: 		return type;
0: 	}	
0: 
0: 	/**
0: 	 * Simple little helper function to convert your type
0: 	 * to a string, which is easier to use.
0: 	 *
0: 	 * @return type as a string
0: 	 */	
0: 	public final String getTypeAsString()
0: 	{
0: 		char[] charArray = new char[1];
0: 		charArray[0] = type;
0: 		return new String(charArray);
0: 	}
0: 
0: 	/**
0: 	 * Is the statement initially compilable?  
0: 	 *
0: 	 * @return	false if statement was created with the NOCOMPILE flag
0: 	 *			true otherwise
0: 	 */
0: 	public boolean initiallyCompilable() { return initiallyCompilable; }
0: 	
0: 	/**
0: 	 * Validate the type. <B>NOTE</B>: Only SPS_TYPE_REGULAR
0: 	 * and SPS_TYPE_TRIGGER are currently valid.
0: 	 *
0: 	 * @param type the type
0: 	 *
0: 	 * @return true/false	
0: 	 */
0: 	public final static boolean validType(char type)
0: 	{
0: 		return (type == SPSDescriptor.SPS_TYPE_REGULAR) || 
0: 				(type == SPSDescriptor.SPS_TYPE_TRIGGER);
0: 	}
0: 
0: 	/**
0: 	 * The time this prepared statement was compiled
0: 	 *
0: 	 * @return the time this class was last compiled
0: 	 */
0: 	public final synchronized Timestamp getCompileTime()
0: 	{
0: 		return compileTime;
0: 	}
0: 
0: 	/**
0: 	 * Set the compile time to now
0: 	 *
0: 	 */
0: 	public final synchronized void setCompileTime()
0: 	{
0: 		compileTime = new Timestamp(System.currentTimeMillis());
0: 	}
0: 	 
0: 	/**
0: 	 * Get the text used to create this statement.
0: 	 * Returns original text in a cleartext string.
0: 	 *
0: 	 * @return The text
0: 	 */
0: 	public final String getText()
0: 	{
0: 		return text;
0: 	}
0: 
0: 	/**
0: 	 * Get the text of the USING clause used on CREATE
0: 	 * or ALTER statement.
0: 	 *
0: 	 * @return The text
0: 	 */
0: 	public final synchronized String getUsingText()
0: 	{
0: 		return usingText;
0: 	}
0: 
0: 	/**
0: 	 * Set the text of the USING clause. Used by
0: 	 * ALTER statement.
0: 	 *
0: 	 * @param usingText	the new value for the USING text
0: 	 */
0: 	public final synchronized void setUsingText(String usingText)
0: 	{
0: 		this.usingText = usingText;
0: 	}
0: 
0: 	/**
0: 	 * Sets the UUID of the SPS.
0: 	 *
0: 	 * @param uuid	The UUID of the SPS to be set in the descriptor
0: 	 */
0: 	public final synchronized void setUUID(UUID uuid)
0: 	{
0: 		this.uuid = uuid;
0: 	}
0: 
0: 	/**
0: 	 * Gets the UUID of the SPS.
0: 	 *
0: 	 * @return	the uuid
0: 	 */
0: 	public final UUID	getUUID()
0: 	{
0: 		return uuid;
0: 	}
0: 	
0: 	/**
0: 	 * Get the array of date type descriptors for
0: 	 * this statement.  Currently, we do a lookup
0: 	 * if we don't already have the parameters saved.
0: 	 * When SPSes are cached, the parameters should
0: 	 * be set up when the sps is constructed.
0: 	 *
0: 	 * @return the array of data type descriptors
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public final synchronized DataTypeDescriptor[] getParams()
0: 		throws StandardException
0: 	{
0: 		if (params == null && !lookedUpParams)
0: 		{
0: 			Vector v = new Vector();
0: 			params = getDataDictionary().getSPSParams(this, v);
0: 			paramDefaults = new Object[v.size()];	
0: 			Enumeration iterator = v.elements();
0: 			for (int i = 0; iterator.hasMoreElements(); i++)
0: 			{
0: 				paramDefaults[i] = iterator.nextElement();
0: 			}
0: 
0: 			lookedUpParams = true;
0: 		}
0: 
0: 		return params;
0: 	}
0: 
0: 	/**
0: 	 * Set the list of parameters for this statement
0: 	 *
0: 	 * @param params	the parameter list
0: 	 */
0: 	public final synchronized void setParams(DataTypeDescriptor params[])
0: 	{
0: 		this.params = params;
0: 	}
0: 
0: 	/**
0: 	 * Get the default parameter values for this 
0: 	 * statement.  Default parameter values are
0: 	 * supplied by a USING clause on either a
0: 	 * CREATE or ALTER STATEMENT statement.
0: 	 *
0: 	 * @return the default parameter values
0:  	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public final synchronized Object[] getParameterDefaults()
0: 		throws StandardException
0: 	{
0: 		if (paramDefaults == null)
0: 			getParams();
0: 
0: 		return paramDefaults;
0: 	}
0: 
0: 	/**
0: 	 * Set the parameter defaults for this statement.
0: 	 *
0: 	 * @param params	the parameter defaults
0: 	 */
0: 	public final synchronized void setParameterDefaults(Object[] values)
0: 	{
0: 		this.paramDefaults = values;
0: 	}
0: 	
0: 	/**
0: 	 * Get the constant action for this statement
0: 	 *
0: 	 * @return the constant action
0: 	 */
0: 	//public final synchronized ConstantAction getConstantAction()
0: 	//{
0: 	//	return preparedStatement.getConstantAction();
0: 	//}
0: 	
0: 	/**
0: 	 * Get the preparedStatement for this statement.
0: 	 * If stmt is invalid or hasn't been compiled yet,
0: 	 * it will be recompiled.
0: 	 *
0: 	 * @return the preparedStatement
0:  	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public final ExecPreparedStatement getPreparedStatement()
0: 		throws StandardException
0: 	{
0: 		return getPreparedStatement(true);
0: 	}
0: 
0: 	/**
0: 	 * Get the preparedStatement for this statement.
0: 	 * Expects the prepared statement to have already
0: 	 * been added to SYS.SYSSTATEMENTS.
0: 	 * <p>
0: 	 * Side Effects: will update SYS.SYSSTATEMENTS with
0: 	 * the new plan if it needs to be recompiled.
0: 	 *
0: 	 * @param recompIfInvalid if false, never recompile even
0: 	 *	if statement is invalid
0: 	 *
0: 	 * @return the preparedStatement
0:  	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public final synchronized ExecPreparedStatement getPreparedStatement(boolean recompIfInvalid)
0: 		throws StandardException
0: 	{
0: 		//System.out.println("preparedStatement = " + preparedStatement);
0: 		/*
0: 		** Recompile if we are invalid, we don't have
0: 		** a prepared statement, or the statements activation
0: 		** has been cleared and cannot be reconstituted.
0: 		*/
0: 		if (recompIfInvalid &&
0: 			(!valid ||
0: 			 (preparedStatement == null)))
0: 		{
0: 			ContextManager cm = ContextService.getFactory().getCurrentContextManager();
0: 
0: 			/*
0: 			** Find the language connection context.  Get
0: 			** it each time in case a connection is dropped.
0: 			*/
0: 			LanguageConnectionContext lcc = (LanguageConnectionContext)
0: 					cm.getContext(LanguageConnectionContext.CONTEXT_ID);
0: 			prepareAndRelease(lcc);
0: 
0: 
0: 			if (!((org.apache.derby.impl.sql.catalog.DataDictionaryImpl) (lcc.getDataDictionary())).readOnlyUpgrade) {
0: 
0: 				//bug 4821 - First try compiling on a nested transaction so we can release
0: 				//the locks after the compilation. But if we get lock time out on the
0: 				//nested transaction, then go ahead and do the compilation on the user
0: 				//transaction. When doing the compilation on user transaction, the locks
0: 				//acquired for recompilation will be released at the end of the user transaction.
0: 				TransactionController nestedTC;
0: 				try
0: 				{
0: 					nestedTC = lcc.getTransactionCompile().startNestedUserTransaction(false);
0: 				}
0: 				catch (StandardException se)
0: 				{
0: 					// If I cannot start a Nested User Transaction use the parent
0: 					// transaction to do all the work.
0: 					nestedTC = null;
0: 				}
0: 
0: 				try
0: 				{
0: 					updateSYSSTATEMENTS(lcc, RECOMPILE, nestedTC);
0: 				}
0: 				catch (StandardException se)
0: 				{
0: 					if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT))
0: 					{
0: 						if (nestedTC != null)
0: 						{
0: 						nestedTC.commit();
0: 						nestedTC.destroy();
0: 						nestedTC = null;
0: 						}
0: 						// if we couldn't do this with a nested xaction, retry with
0: 						// parent-- we need to wait this time!
0: 						updateSYSSTATEMENTS(lcc, RECOMPILE, null);
0: 					}
0: 					else throw se;
0: 				}
0: 				finally
0: 				{
0: 					// no matter what, commit the nested transaction; if something
0: 					// bad happened in the child xaction lets not abort the parent
0: 					// here.
0: 					if (nestedTC != null)
0: 					{
0: 						nestedTC.commit();
0: 						nestedTC.destroy();
0: 					}
0: 				} 
0: 			}
0: 		}
0: 
0: 		return preparedStatement;
0: 	}
0: 
0: 	/**
0: 	 * Get the compilation type schema id when this view
0: 	 * was first bound.
0: 	 *
0: 	 * @return the schema UUID
0: 	 */
0: 	public final UUID getCompSchemaId()
0: 	{
0: 		return compSchemaId;
0: 	}
0: 
0: 	/**
0: 	 * Prints the contents of the TableDescriptor
0: 	 *
0: 	 * @return The contents as a String
0: 	 */
0: 	public final String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "SPSDescriptor:\n"+
0: 				"\tname: "+sd.getSchemaName()+"."+name+"\n"+
0: 				"\tuuid: "+uuid+"\n"+
0: 				"\ttext: "+text+"\n"+
0: 				"\tvalid: "+((valid) ? "TRUE" : "FALSE")+"\n" +
0: 				"\tpreparedStatement: "+preparedStatement+"\n";
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	//////////////////////////////////////////////////////
0: 	//
0: 	// PROVIDER INTERFACE
0: 	//
0: 	//////////////////////////////////////////////////////
0: 
0: 	/**		
0: 	 * Return the stored form of this provider
0: 	 *
0: 	 * @see Dependable#getDependableFinder
0: 	 */
0: 	public final DependableFinder getDependableFinder()
0: 	{
0: 	    return	getDependableFinder(StoredFormatIds.SPS_DESCRIPTOR_FINDER_V01_ID);
0: 	}
0: 
0: 	/**
0: 	 * Return the name of this Provider.  (Useful for errors.)
0: 	 *
0: 	 * @return String	The name of this provider.
0: 	 */
0: 	public final String getObjectName()
0: 	{
0: 		return name;
0: 	}
0: 
0: 	/**
0: 	 * Get the provider's UUID 
0: 	 *
0: 	 * @return String	The provider's UUID
0: 	 */
0: 	public final UUID getObjectID()
0: 	{
0: 		return uuid;
0: 	}
0: 
0: 	/**
0: 	 * Get the provider's type.
0: 	 *
0: 	 * @return String The provider's type.
0: 	 */
0: 	public final String getClassType()
0: 	{
0: 		return Dependable.STORED_PREPARED_STATEMENT;
0: 	}
0: 
0: 	//////////////////////////////////////////////////////
0: 	//
0: 	// DEPENDENT INTERFACE
0: 	//
0: 	//////////////////////////////////////////////////////
0: 	/**
0: 	 * Check that all of the dependent's dependencies are valid.
0: 	 *
0: 	 * @return true if the dependent is currently valid
0: 	 */
0: 	public final synchronized boolean isValid()
0: 	{
0: 		return valid;
0: 	}
0: 
0: 	/**
0: 	 * Prepare to mark the dependent as invalid (due to at least one of
0: 	 * its dependencies being invalid).
0: 	 *
0: 	 * @param action	The action causing the invalidation
0: 	 * @param p		the provider
0: 	 *
0: 	 * @exception StandardException thrown if unable to make it invalid
0: 	 */
0: 	public final synchronized void prepareToInvalidate(
0: 									Provider p, int action,
0: 									LanguageConnectionContext lcc) 
0: 		throws StandardException
0: 	{
0: 		switch (action)
0: 		{
0: 			/*
0: 			** Things that don't affect us
0: 			*/
0: 		    case DependencyManager.CREATE_VIEW:
0: 	
0: 			/*
0: 			** Things that force a recompile, but are
0: 			** allowed.
0: 			*/
0: 			case DependencyManager.CREATE_INDEX:
0: 			case DependencyManager.CREATE_CONSTRAINT:
0: 			case DependencyManager.DROP_CONSTRAINT:
0: 			case DependencyManager.DROP_INDEX:
0: 			case DependencyManager.DROP_TABLE:
0: 			case DependencyManager.DROP_VIEW: 
0: 			case DependencyManager.DROP_METHOD_ALIAS:
0: 			case DependencyManager.ALTER_TABLE:
0: 			case DependencyManager.RENAME:
0: 			case DependencyManager.RENAME_INDEX:
0: 			case DependencyManager.PREPARED_STATEMENT_RELEASE:
0: 			case DependencyManager.USER_RECOMPILE_REQUEST:
0: 			case DependencyManager.CHANGED_CURSOR:
0: 			case DependencyManager.BULK_INSERT:
0: 			case DependencyManager.COMPRESS_TABLE:
0: 			case DependencyManager.SET_CONSTRAINTS_ENABLE:
0: 			case DependencyManager.SET_CONSTRAINTS_DISABLE:
0: 			case DependencyManager.SET_TRIGGERS_ENABLE:
0: 			case DependencyManager.SET_TRIGGERS_DISABLE:
0: 			case DependencyManager.ROLLBACK:
0: 			case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
0: 			case DependencyManager.CREATE_TRIGGER:
0: 			case DependencyManager.DROP_TRIGGER:
0: 			case DependencyManager.DROP_TABLE_CASCADE:
0: 			case DependencyManager.DROP_VIEW_CASCADE:
0: 			case DependencyManager.DROP_COLUMN:
0: 			case DependencyManager.DROP_COLUMN_CASCADE:
0: 		    case DependencyManager.UPDATE_STATISTICS:
0: 		    case DependencyManager.DROP_STATISTICS:
0:     		case DependencyManager.TRUNCATE_TABLE:
0: 				break;
0: 
0: 			/*
0: 			** The rest are errors
0: 			*/
0: 		    default:
0: 
0: 				DependencyManager dm;
0: 
0: 				dm = getDataDictionary().getDependencyManager();
0: 				throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_S_P_S, 
0: 					dm.getActionString(action), 
0: 					p.getObjectName(), name);
0: 
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Mark the dependent as invalid (due to at least one of
0: 	 * its dependencies being invalid).
0: 	 *
0: 	 * @param	action	The action causing the invalidation
0: 	 *
0: 	 * @exception StandardException thrown if unable to make it invalid
0: 	 */
0: 	public final synchronized void makeInvalid(int action,
0: 											   LanguageConnectionContext lcc) 
0: 		throws StandardException
0: 	{
0: 		DependencyManager dm;
0: 
0: 		dm = getDataDictionary().getDependencyManager();
0: 
0: 		switch (action)
0: 		{
0: 			/*
0: 			** Some things that don't affect stored prepared
0: 	 		** statements.
0: 			*/
0: 			case DependencyManager.PREPARED_STATEMENT_RELEASE:
0: 		    case DependencyManager.CREATE_VIEW:
0: 				break;
0: 
0: 			/*
0: 		 	** Things that can invalidate a stored
0: 			** prepared statement.
0: 			*/
0: 			case DependencyManager.CREATE_INDEX:
0: 			case DependencyManager.CREATE_CONSTRAINT:
0: 			case DependencyManager.DROP_CONSTRAINT:
0: 			case DependencyManager.DROP_TABLE:
0: 			case DependencyManager.DROP_INDEX:
0: 			case DependencyManager.DROP_VIEW: 
0: 			case DependencyManager.DROP_METHOD_ALIAS:
0: 			case DependencyManager.ALTER_TABLE:
0: 			case DependencyManager.RENAME:
0: 			case DependencyManager.RENAME_INDEX:
0: 			case DependencyManager.USER_RECOMPILE_REQUEST:
0: 			case DependencyManager.CHANGED_CURSOR:
0: 			case DependencyManager.BULK_INSERT:
0: 			case DependencyManager.COMPRESS_TABLE:
0: 			case DependencyManager.SET_CONSTRAINTS_ENABLE:
0: 			case DependencyManager.SET_CONSTRAINTS_DISABLE:
0: 			case DependencyManager.SET_TRIGGERS_ENABLE:
0: 			case DependencyManager.SET_TRIGGERS_DISABLE:
0: 			case DependencyManager.ROLLBACK:
0: 			case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
0: 			case DependencyManager.CREATE_TRIGGER:
0: 			case DependencyManager.DROP_TRIGGER:
0: 			case DependencyManager.DROP_TABLE_CASCADE:
0: 			case DependencyManager.DROP_VIEW_CASCADE:
0: 			case DependencyManager.DROP_COLUMN:
0: 			case DependencyManager.DROP_COLUMN_CASCADE:
0: 		    case DependencyManager.UPDATE_STATISTICS:
0: 		    case DependencyManager.DROP_STATISTICS:
0: 			case DependencyManager.TRUNCATE_TABLE:
0: 				/*
0: 				** If we are already invalid, don't write ourselves
0: 				** out.  Just to be safe, we'll send out an invalidate
0: 				** to our dependents either way.
0: 				*/
0: 				if (valid == true)
0: 				{
0: 					valid = false;
0: 					updateSYSSTATEMENTS(lcc, INVALIDATE, null);
0: 				}
0: 				dm.invalidateFor(this, dm.USER_RECOMPILE_REQUEST, lcc);
0: 				break;
0: 			case DependencyManager.DROP_SPS:
0: 				//System.out.println("SPSD " + preparedStatement);
0: 				dm.clearDependencies(lcc, this);
0: 				break;
0: 	
0: 		    default:
0: 
0: 				/* 
0: 				** We should never get here, since we can't have dangling references 
0: 				*/
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT("makeInvalid("+
0: 						dm.getActionString(action)+
0: 						") not expected to get called; should have failed in "+
0: 						"prepareToInvalidate()");
0: 				}
0: 				break;
0: 
0: 		}
0: 
0: 	}
0: 
0: 	/**
0:      * Attempt to revalidate the dependent. For prepared statements,
0: 	 * this could go through its dependencies and check that they
0: 	 * are up to date; if not, it would recompile the statement.
0: 	 * Any failure during this attempt should throw
0: 	 * StandardException.unableToRevalidate().
0: 	 *
0: 	 * @exception StandardException thrown if unable to make it valid
0: 	 */
0: 	public final synchronized void makeValid(LanguageConnectionContext lcc) 
0: 		throws StandardException
0: 	{
0: 		if (valid)
0: 		{
0: 			return;
0: 		}
0: 		prepareAndRelease(lcc);
0: 
0: 		updateSYSSTATEMENTS(lcc, RECOMPILE, null);
0: 		
0: 	}
0: 
0: 	/**
0: 	 * Invalidate and revalidate.  The functional equivalent
0: 	 * of calling makeInvalid() and makeValid(), except it
0: 	 * is optimized.
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public final synchronized void revalidate(LanguageConnectionContext lcc)
0: 		throws StandardException
0: 	{
0: 		/*
0: 		** Mark it as invalid first to ensure that
0: 		** we don't write SYSSTATEMENTS 2x.
0: 		*/
0: 		valid = false;
0: 		makeInvalid(DependencyManager.USER_RECOMPILE_REQUEST, lcc);
0: 		prepareAndRelease(lcc);
0: 		updateSYSSTATEMENTS(lcc, RECOMPILE, null);
0: 	}
0: 
0: 	/**
0: 	 * Load the underlying generatd class.  This is not expected
0: 	 * to be used outside of the datadictionary package.  It
0: 	 * is used for optimizing class loading for sps
0: 	 * cacheing.
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public void loadGeneratedClass() throws StandardException
0: 	{
0: 		/*
0: 		** On upgrade, we null out the statement body,
0: 		** so handle that here.
0: 		*/
0: 		if (preparedStatement != null)
0: 		{
0: 			((StorablePreparedStatement)preparedStatement).loadGeneratedClass();
0: 		}
0: 	}
0: 
0: 	/*
0: 	** Update SYSSTATEMENTS with the changed the descriptor.  
0: 	** Always done in the user XACT.
0: 	** <p>
0: 	** Ideally, the changes to SYSSTATEMENTS would be made 
0: 	** in a separate xact as the current user xact, but this
0: 	** is painful (you'ld need to get a new ContextManager
0: 	** and then push all of the usual langauge contexts
0: 	** onto it and THEN call AccessManager.getTransaction()),
0: 	** and it wont work, because the xact is in a different
0: 	** compatibility space and will self deadlock (e.g.
0: 	** in the process of call DependencyManager.makeInvalid() 
0: 	** we first did a DDdependableFinder.getDependable()
0: 	** which called DataDictionaryImpl.getSPSDescriptor()
0: 	** so we hold a lock on SYS.SYSSTATEMENTS by the
0: 	** time we get a 2nd xact and try to drop the statement).
0: 	*/
0: 	private void updateSYSSTATEMENTS(LanguageConnectionContext lcc, int mode, TransactionController tc)
0: 		throws StandardException
0: 	{
0: 		int[] 					colsToUpdate;
0: 		boolean					updateSYSCOLUMNS,  recompile;
0: 		//bug 4821 - we want to wait for locks if updating sysstatements on parent transaction
0: 		boolean wait = false;
0: 		boolean firstCompilation = false;
0: 		if (mode == RECOMPILE)
0: 		{
0: 			recompile = true;
0: 			updateSYSCOLUMNS = true;
0: 			if(!initiallyCompilable)
0: 			{
0: 				firstCompilation = true;
0: 				initiallyCompilable = true;
0: 			}
0: 		}
0: 		else
0: 		{
0: 			recompile = false;
0: 			updateSYSCOLUMNS = false;
0: 		}
0: 
0: 		DataDictionary dd = getDataDictionary();
0: 
0: 		if (((org.apache.derby.impl.sql.catalog.DataDictionaryImpl) dd).readOnlyUpgrade)
0: 			return;
0: 
0: 
0: 		/*
0: 		** Get busy time
0: 		*/
0: 		dd.startWriting(lcc);	
0: 
0: 		if (tc == null) { //bug 4821 - tc will passed null if we want to use the user transaction
0: 			tc = lcc.getTransactionExecute();
0: 			wait = true;
0: 		}
0: 
0: 		dd.updateSPS(this,
0: 					 tc, 
0: 					 recompile,
0: 					 updateSYSCOLUMNS,
0: 					 wait,
0: 					 firstCompilation);
0: 	}
0: 
0: 	/**
0: 	 * Get the UUID for the given string
0: 	 *
0: 	 * @param the string
0: 	 *
0: 	 * @return the UUID
0: 	 */
0: 	private UUID recreateUUID(String idString)
0: 	{
0: 		if (uuidFactory == null)
0: 		{
0: 			uuidFactory = Monitor.getMonitor().getUUIDFactory();
0: 		}
0: 		return uuidFactory.recreateUUID(idString);
0: 	}
0: 
0: 	/** @see TupleDescriptor#getDescriptorType */
0: 	public String getDescriptorType() { return "Statement"; }
0: 
0: 	/** @see TupleDescriptor#getDescriptorName */
0: 	// RESOLVE: some descriptors have getName.  some descriptors have
0: 	// getTableName, getColumnName whatever! try and unify all of this to one
0: 	// getDescriptorName! 
0: 	public String getDescriptorName() { return name; }
0: 	
0: }
0: 
============================================================================