1:eac0369: /*
1:6b95f61: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.types.DataValueFactoryImpl
1:6b95f61: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:a1970a9: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:a1970a9: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:a1970a9: 
1:eac0369:  */
1:a1970a9: 
1:eac0369: package org.apache.derby.iapi.types;
1:e11914a: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:7ecc1f2: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:7ecc1f2: 
1:eac0369: import org.apache.derby.iapi.services.i18n.LocaleFinder;
1:e11914a: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:e11914a: import org.apache.derby.iapi.services.monitor.ModuleControl;
1:6b95f61: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:722a889: import org.apache.derby.iapi.services.monitor.Monitor;
1:767d656: 
1:6b95f61: import org.apache.derby.iapi.reference.Attribute;
1:767d656: import org.apache.derby.iapi.reference.SQLState;
1:767d656: 
1:a0dbbd7: import java.security.AccessController;
1:a0dbbd7: import java.security.PrivilegedAction;
1:a0dbbd7: 
1:638f1b4: import java.sql.Blob;
1:638f1b4: import java.sql.Clob;
1:eac0369: import java.sql.Date;
1:eac0369: import java.sql.Time;
1:eac0369: import java.sql.Timestamp;
1:2a58829: 
1:b5e1331: import java.text.Collator;
1:b5e1331: import java.text.RuleBasedCollator;
1:b5e1331: 
1:2ca9dc6: import java.util.Properties;
1:2ca9dc6: import java.util.Locale;
1:7ecc1f2: 
1:eac0369: import org.apache.derby.iapi.db.DatabaseContext;
1:a0dbbd7: import org.apache.derby.iapi.services.context.Context;
1:eac0369: import org.apache.derby.iapi.services.context.ContextService;
1:7ecc1f2: 
1:9373fed: /**
1:5465561:  * Core implementation of DataValueFactory.
1:5212101:  *
1:eac0369:  * @see DataValueFactory
1:e11914a:  */
1:5465561: public final class DataValueFactoryImpl implements DataValueFactory, ModuleControl
54:eac0369: {
1:5465561:         private LocaleFinder localeFinder;
1:2ca9dc6:         //BasicDatabase first boots DVF in it's boot method and then sets 
1:2ca9dc6:         //this databaseLocale in DVF.
1:2ca9dc6:     	private Locale databaseLocale;
1:b5e1331:     	//Following Collator object will be initialized using databaseLocale.  
1:b5e1331:     	private RuleBasedCollator collatorForCharacterTypes;
1:767d656: 
1:e11914a:         /*
1:e11914a:          ** ModuleControl methods.
1:767d656:          */
1:e11914a:         
1:e11914a:     	/* (non-Javadoc)
1:e11914a:     	 * @see org.apache.derby.iapi.services.monitor.ModuleControl#boot(boolean, java.util.Properties)
1:e11914a:     	 */
1:e11914a:     	public void boot(boolean create, Properties properties) throws StandardException {
1:e11914a:     		
1:56c1dc2:     		ModuleFactory monitor = getMonitor();
1:6b95f61:     		//The Locale on monitor has already been set by the boot code in
1:6b95f61:     		//BasicDatabase so we can simply do a get here.
1:6b95f61:     		//This Locale will be either the Locale obtained from the territory
1:6b95f61:     		//attribute supplied by the user on the JDBC url at database create
1:6b95f61:     		//time or if user didn't provide the territory attribute at database
1:6b95f61:     		//create time, then it will be set to the default JVM locale. The
1:6b95f61:     		//Locale object will be used to construct the Collator object which
1:6b95f61:     		//will be used if user has requested territory based collation.
1:6b95f61:     		databaseLocale = monitor.getLocale(this);
1:6b95f61: 
1:6b95f61:     		//If we are here for database create time, verify that there is 
1:6b95f61:     		//Collator support for the database's locale. If not, then we 
1:6b95f61:     		//will throw an exception. 
1:6b95f61:     		//Notice that this Collator support check is happening only during 
1:6b95f61:     		//database creation time. This is because, during database create
1:6b95f61:     		//time, DVF has access to collation property of the database and
1:6b95f61:     		//hence it can do the Collator support check
1:6b95f61:     		//(collation property is available through JDBC url at the database
1:6b95f61:     		//create time, if user has asked for a particular collation) eg
1:6b95f61:     		//connect 'jdbc:derby:db;create=true;territory=no;collation=TERRITORY_BASED';
1:6b95f61:     		//Once the database is created, the collation property gets
1:6b95f61:     		//saved in the database and during susbsequent boots of the
1:6b95f61:     		//database, collation attribute of the database is only available
1:6b95f61:     		//once store has finished reading it. So, during subsequent 
1:6b95f61:     		//database boot up time, the collation attribute of the database 
1:6b95f61:     		//will be checked the first time a collation operation is done.
1:6b95f61:     		//And if the Collator support is not found at that point, user will 
1:6b95f61:     		//get an exception for Collator unavailability. This first 
1:6b95f61:     		//collation operation can happen if the database needs to be 
1:6b95f61:     		//recovered during boot time or otherwise it will happen when the
1:6b95f61:     		//user has executed a SQL which requires collation operation.
1:6b95f61: 	    	if (create) {
1:6b95f61: 	    		//Get the collation property from the JDBC url(this will be 
1:6b95f61: 	    		//available only during database create time). It can only have 
1:6b95f61: 	    		//one of the 2 possible values - UCS_BASIC or TERRITORY_BASED.
1:6b95f61: 	    		//This property can only be specified at database create time.
1:6b95f61: 	    		//If the user has requested for territory based database, then 
1:6b95f61: 	    		//verify that JVM has Collator support for the database locale.
1:6b95f61: 	    		String userDefinedCollation = 
1:5212101: 	    			properties.getProperty(Attribute.COLLATION);
1:6b95f61: 	    		if (userDefinedCollation != null) {//Invalid value handling
1:5212101: 					int collationType = DataTypeDescriptor.getCollationType(userDefinedCollation);
1:5212101: 					if (collationType != StringDataValue.COLLATION_TYPE_UCS_BASIC) {
1:5212101: 						if (collationType >= StringDataValue.COLLATION_TYPE_TERRITORY_BASED
1:5212101: 								&& collationType <  StringDataValue.COLLATION_TYPE_TERRITORY_BASED_IDENTICAL) {
1:5212101: 							int strength = collationType - StringDataValue.COLLATION_TYPE_TERRITORY_BASED_PRIMARY;
1:5212101: 							collatorForCharacterTypes = verifyCollatorSupport(strength);
1:5212101: 						} else
1:5212101: 							throw StandardException.newException(SQLState.INVALID_COLLATION, userDefinedCollation);
1:5212101: 					}
1:92268ac: 	    		}    		
1:6b95f61: 	    	}
1:6b95f61:     	}
1:92268ac: 
1:e11914a:     	/* (non-Javadoc)
1:e11914a:     	 * @see org.apache.derby.iapi.services.monitor.ModuleControl#stop()
1:a1aaa63:     	 */
1:e11914a:     	public void stop() {
1:b5e1331:     	}
1:b5e1331:  
1:767d656:         /**
1:eac0369:          * @see DataValueFactory#getDataValue
1:eac0369:          *
1:e11914a:          */
1:eac0369:         public NumberDataValue getDataValue(int value, NumberDataValue previous)
9:eac0369:                                                         throws StandardException
1:a0dbbd7:         {
8:eac0369:                 if (previous == null)
1:c8c1551:                         return new SQLInteger(value);
8:eac0369:                 previous.setValue(value);
8:eac0369:                 return previous;
1:2ca9dc6:         }
1:2ca9dc6: 
1:eac0369:         public NumberDataValue getDataValue(Integer value, NumberDataValue previous)
1:d7f7457:                         throws StandardException
1:92268ac:         {
1:cf58aec:                 if (previous == null)
1:cf58aec:                 {
3:eac0369:                         return new SQLInteger(value);
1:e11914a:                 }
1:9373fed: 
1:cf58aec:                 previous.setValue(value);
1:cf58aec:                 return previous;
1:e11914a:         }
1:9373fed: 
1:eac0369:         public NumberDataValue getDataValue(char value, NumberDataValue previous)
1:cf58aec:                                                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
1:eac0369:                         return new SQLInteger(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
60:eac0369:         }
1:9373fed: 
1:eac0369:         public NumberDataValue getDataValue(short value, NumberDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
2:eac0369:                         return new SQLSmallint(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:9373fed: 
1:eac0369:         public NumberDataValue getDataValue(Short value, NumberDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
1:4309044:                         return new SQLSmallint(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:e11914a: 
1:eac0369:         public NumberDataValue getDataValue(byte value, NumberDataValue previous)
1:eac0369:                                 throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
2:eac0369:                         return new SQLTinyint(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:e11914a: 
1:eac0369:         public NumberDataValue getDataValue(Byte value, NumberDataValue previous)
1:eac0369:                                 throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
1:4309044:                         return new SQLTinyint(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:e11914a: 
1:eac0369:         public NumberDataValue getDataValue(long value, NumberDataValue previous)
1:eac0369:                                 throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
2:eac0369:                         return new SQLLongint(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
67:eac0369: 
1:eac0369: 
1:eac0369:         public NumberDataValue getDataValue(Long value, NumberDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
1:4309044:                         return new SQLLongint(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369: 
1:eac0369:         public NumberDataValue getDataValue(float value, NumberDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
2:eac0369:                         return new SQLReal(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369: 
1:eac0369:         public NumberDataValue getDataValue(Float value, NumberDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
1:4309044:                         return new SQLReal(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369: 
1:eac0369:         public NumberDataValue getDataValue(double value, NumberDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
2:eac0369:                         return new SQLDouble(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369: 
1:eac0369:         public NumberDataValue getDataValue(Double value, NumberDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
1:4309044:                         return new SQLDouble(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369: 
1:2a58829:         public final NumberDataValue getDecimalDataValue(Number value, NumberDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:5465561:             NumberDataValue retValue =
1:5465561:                     (previous == null) ? getNullDecimal(null) : previous;
1:5465561:             retValue.setValue(value);
1:5465561:             return retValue;
1:eac0369:         }
1:eac0369: 
1:eac0369:         public BooleanDataValue getDataValue(boolean value,
1:eac0369:                                                                                 BooleanDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
2:eac0369:                         return new SQLBoolean(value);
1:eac0369:         
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369: 
1:eac0369:         public BooleanDataValue getDataValue(Boolean value,
1:eac0369:                                                                                         BooleanDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
1:4309044:                         return new SQLBoolean(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369: 
1:eac0369:         public BitDataValue getBitDataValue(byte[] value) throws StandardException
1:eac0369:         {
1:eac0369:                 return new SQLBit(value);
1:eac0369:         }
1:eac0369: 
1:eac0369:         public BitDataValue getBitDataValue(byte[] value, BitDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
1:eac0369:                         return new SQLBit(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369: 
1:eac0369:         public BitDataValue getVarbitDataValue(byte[] value, BitDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
2:eac0369:                         return new SQLVarbit(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369: 
1:eac0369: 
1:eac0369:         // LONGVARBIT
1:eac0369: 
1:eac0369:         public BitDataValue getLongVarbitDataValue(byte[] value, BitDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
2:eac0369:                         return new SQLLongVarbit(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369: 
1:eac0369:         // BLOB
1:eac0369: 
1:eac0369:         public BitDataValue getBlobDataValue(byte[] value, BitDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
2:eac0369:                         return new SQLBlob(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369: 
1:638f1b4:         public BitDataValue getBlobDataValue(Blob value, BitDataValue previous)
1:638f1b4:                         throws StandardException
1:638f1b4:         {
1:638f1b4:             if (previous == null) { return new SQLBlob(value); }
1:638f1b4:             previous.setValue(value);
1:638f1b4:             return previous;
1:638f1b4:         }
1:638f1b4: 
1:eac0369:         // CHAR
1:eac0369:         public StringDataValue getCharDataValue(String value)
1:eac0369:         {
1:eac0369:                 return new SQLChar(value);
1:eac0369:         }
1:eac0369: 
1:eac0369:         public StringDataValue getCharDataValue(String value,
4:eac0369:                                                                                         StringDataValue previous)
1:eac0369:                                                                                                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
1:eac0369:                         return new SQLChar(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369:         
1:a1aaa63:         /**
1:9373fed:          * Return a StringDataValue to represent a SQL CHAR
1:9373fed:          * with the given collation re-using previous if not null.
1:9373fed:          */
1:9373fed:         public StringDataValue getCharDataValue(String value,
1:9373fed:                 StringDataValue previous, int collationType)
1:9373fed:             throws StandardException
1:9373fed:         {
1:b5e1331:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:9373fed:                 return getCharDataValue(value, previous);
1:9373fed:             
1:9373fed:             if (previous == null)
1:9373fed:                 return new CollatorSQLChar(value, getCharacterCollator(collationType));
1:9373fed:             
1:9373fed:             previous.setValue(value);
1:9373fed:             return previous;
1:9373fed:         }
1:9373fed: 
1:9373fed:         
1:eac0369: 
1:eac0369:         public StringDataValue getVarcharDataValue(String value)
1:eac0369:         {
1:eac0369:                 return new SQLVarchar(value);
1:eac0369:         }
1:eac0369: 
1:eac0369:         public StringDataValue getVarcharDataValue(String value,
1:eac0369:                                                                                                 StringDataValue previous)
1:eac0369:                                                                                                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
1:eac0369:                         return new SQLVarchar(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369:         
1:9373fed:         /**
1:9373fed:          * Return a StringDataValue to represent a SQL VARCHAR
1:9373fed:          * with the given collation re-using previous if not null.
1:9373fed:          */
1:9373fed:         public StringDataValue getVarcharDataValue(String value,
1:9373fed:                 StringDataValue previous, int collationType)
1:9373fed:             throws StandardException
1:9373fed:         {
1:a1aaa63:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:9373fed:                 return getVarcharDataValue(value, previous);
1:9373fed:             
1:9373fed:             if (previous == null)
1:9373fed:                 return new CollatorSQLVarchar(value,
1:9373fed:                         getCharacterCollator(collationType));
1:9373fed:             
1:9373fed:             previous.setValue(value);
1:9373fed:             return previous;
1:9373fed:         }
1:eac0369: 
1:eac0369:         public StringDataValue getLongvarcharDataValue(String value)
1:eac0369:         {
1:eac0369:                 return new SQLLongvarchar(value);
1:eac0369:         }
1:eac0369: 
1:eac0369:         public StringDataValue getLongvarcharDataValue(String value,
1:eac0369:                                                                                                         StringDataValue previous)
1:eac0369:                                                                                                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
1:eac0369:                         return new SQLLongvarchar(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369:         
1:9373fed:         /**
1:9373fed:          * Return a StringDataValue to represent a SQL LONG VARCHAR
1:9373fed:          * with the given collation re-using previous if not null.
1:9373fed:          */
1:9373fed:         public StringDataValue getLongvarcharDataValue(String value,
1:9373fed:                 StringDataValue previous, int collationType)
1:9373fed:             throws StandardException
1:9373fed:         {
1:a1aaa63:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:9373fed:                 return getLongvarcharDataValue(value, previous);
1:9373fed:             
1:9373fed:             if (previous == null)
1:9373fed:                 return new CollatorSQLLongvarchar(value,
1:9373fed:                         getCharacterCollator(collationType));
1:9373fed:             
1:9373fed:             previous.setValue(value);
1:9373fed:             return previous;
1:9373fed:         }
1:eac0369: 
1:eac0369:         public StringDataValue getClobDataValue(String value, StringDataValue previous) throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
2:eac0369:                         return new SQLClob(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369:         
1:638f1b4:         public StringDataValue getClobDataValue(Clob value, StringDataValue previous) throws StandardException
1:638f1b4:         {
1:638f1b4:             if (previous == null) { return new SQLClob(value); }
1:638f1b4:             
1:638f1b4:             previous.setValue(value);
1:638f1b4:             return previous;
1:638f1b4:         }
1:638f1b4: 
1:85e788b:         public StringDataValue getClobDataValue(Clob value,
1:85e788b:                 StringDataValue previous, int collationType)
1:85e788b:             throws StandardException
1:85e788b:         {
1:85e788b:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:85e788b:                 return getClobDataValue(value, previous);
1:85e788b:             
1:85e788b:             if (previous == null)
1:85e788b:             {
1:85e788b:                 return new CollatorSQLClob(value,
1:85e788b:                         getCharacterCollator(collationType));
1:85e788b:             }
1:85e788b:             
1:85e788b:             previous.setValue(value);
1:85e788b:             return previous;
1:85e788b:         }
1:638f1b4:     
1:9373fed:         /**
1:9373fed:          * Return a StringDataValue to represent a SQL CLOB
1:9373fed:          * with the given collation re-using previous if not null.
1:9373fed:          */
1:9373fed:         public StringDataValue getClobDataValue(String value,
1:9373fed:                 StringDataValue previous, int collationType)
1:9373fed:             throws StandardException
1:9373fed:         {
1:9373fed:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:9373fed:                 return getClobDataValue(value, previous);
1:9373fed:             
1:9373fed:             if (previous == null)
1:9373fed:                 return new CollatorSQLClob(value,
1:9373fed:                         getCharacterCollator(collationType));
1:9373fed:             
1:9373fed:             previous.setValue(value);
1:9373fed:             return previous;
1:9373fed:         }
1:eac0369: 
1:eac0369:         public DateTimeDataValue getDataValue(Date value,
1:eac0369:                                                                                         DateTimeDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
2:eac0369:                         return new SQLDate(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369: 
1:eac0369:         public DateTimeDataValue getDataValue(Time value,
1:eac0369:                                                                                         DateTimeDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
2:eac0369:                         return new SQLTime(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369: 
1:eac0369:         public DateTimeDataValue getDataValue(Timestamp value,
1:eac0369:                                                                                         DateTimeDataValue previous)
1:eac0369:                         throws StandardException
1:eac0369:         {
1:eac0369:                 if (previous == null)
2:eac0369:                         return new SQLTimestamp(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:2dd0b6f:          * Implement the date SQL function: construct a SQL date from a string, number, or timestamp.
1:57cb998:          *
1:2dd0b6f:          * @param operand Must be a date, a number, or a string convertible to a date.
1:eac0369:          *
1:2dd0b6f:          * @exception StandardException standard error policy
1:eac0369:          */
1:2dd0b6f:         public DateTimeDataValue getDate( DataValueDescriptor operand) throws StandardException
1:eac0369:         {
1:2dd0b6f:                 return SQLDate.computeDateFunction( operand, this);
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:2dd0b6f:          * Implement the timestamp SQL function: construct a SQL timestamp from a string, or timestamp.
1:eac0369:          *
1:2dd0b6f:          * @param operand Must be a timestamp or a string convertible to a timestamp.
4:2dd0b6f:          *
1:2dd0b6f:          * @exception StandardException standard error policy
1:eac0369:          */
1:2dd0b6f:         public DateTimeDataValue getTimestamp( DataValueDescriptor operand) throws StandardException
1:eac0369:         {
1:2dd0b6f:                 return SQLTimestamp.computeTimestampFunction( operand, this);
1:eac0369:         }
1:eac0369: 
1:eac0369:         public DateTimeDataValue getTimestamp( DataValueDescriptor date, DataValueDescriptor time) throws StandardException
1:eac0369:         {
1:eac0369:             return new SQLTimestamp( date, time);
1:eac0369:         }
1:eac0369: 
1:eac0369:         public UserDataValue getDataValue(Object value,
1:eac0369:                                                                                 UserDataValue previous)
1:eac0369:         {
1:eac0369:                 if (previous == null)
2:eac0369:                         return new UserType(value);
1:eac0369:                 ((UserType) previous).setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369: 
1:eac0369:         public RefDataValue getDataValue(RowLocation value, RefDataValue previous)
1:eac0369:         {
1:eac0369:                 if (previous == null)
2:eac0369:                         return new SQLRef(value);
1:eac0369:                 previous.setValue(value);
1:eac0369:                 return previous;
1:eac0369:         }
1:eac0369: 
1:eac0369:         public NumberDataValue          getNullInteger(NumberDataValue dataValue) 
1:eac0369:         {
5:eac0369:                 if (dataValue == null)
1:eac0369:                 {
2:eac0369:                         return new SQLInteger();
1:eac0369:                 }
1:a0dbbd7:                 else
1:a0dbbd7:                 {
5:eac0369:                         dataValue.setToNull();
5:eac0369:                         return dataValue;
1:767d656:                 }
1:767d656:         }
1:767d656: 
1:eac0369:         public NumberDataValue getNullShort(NumberDataValue dataValue)
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
2:eac0369:                         return new SQLSmallint();
1:767d656:                 }
1:57cb998:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:767d656:                 }
1:767d656:         }
1:767d656: 
1:eac0369:         public NumberDataValue getNullLong(NumberDataValue dataValue)
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
2:eac0369:                         return new SQLLongint();
1:eac0369:                 }
1:b5e1331:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:a1aaa63: 
1:eac0369:         public NumberDataValue getNullByte(NumberDataValue dataValue)
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
2:eac0369:                         return new SQLTinyint();
1:eac0369:                 }
19:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:a1aaa63: 
1:eac0369:         public NumberDataValue getNullFloat(NumberDataValue dataValue)
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
2:eac0369:                         return new SQLReal();
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:a1aaa63: 
1:eac0369:         public NumberDataValue getNullDouble(NumberDataValue dataValue)
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
2:eac0369:                         return new SQLDouble();
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:eac0369: 
1:5465561:         public final NumberDataValue getNullDecimal(NumberDataValue dataValue)
1:5465561:         {
1:5465561:             if (dataValue == null) {
1:5465561:                 return new SQLDecimal();
1:5465561:             }
1:5465561: 
1:5465561:             dataValue.setToNull();
1:5465561:             return dataValue;
1:5465561:         }
1:5465561: 
1:eac0369:         public BooleanDataValue getNullBoolean(BooleanDataValue dataValue)
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
3:eac0369:                         return new SQLBoolean();
1:cf58aec:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:eac0369: 
1:eac0369:         public BitDataValue             getNullBit(BitDataValue dataValue) throws StandardException
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
1:eac0369:                         return getBitDataValue((byte[]) null);
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:eac0369: 
1:eac0369: 
1:eac0369:         public BitDataValue             getNullVarbit(BitDataValue dataValue) throws StandardException
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
1:c8c1551:                         return new SQLVarbit();
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:eac0369: 
1:eac0369:         // LONGVARBIT
1:eac0369:         public BitDataValue getNullLongVarbit(BitDataValue dataValue) throws StandardException
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
1:c8c1551:                         return new SQLLongVarbit();
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:eac0369: 
1:eac0369:         /// BLOB
1:eac0369:         public BitDataValue getNullBlob(BitDataValue dataValue) throws StandardException
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
1:c8c1551:                         return new SQLBlob();
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:eac0369: 
1:eac0369:         // CHAR
1:eac0369:         public StringDataValue          getNullChar(StringDataValue dataValue)
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
1:eac0369:                         return getCharDataValue((String) null);
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:767d656:         /**
1:a1aaa63:          * Get a SQL CHAR set to NULL with collation set to collationType.
1:a1aaa63:          * If the supplied value is null then get a new value,
1:a1aaa63:          * otherwise set it to null and return that value.
1:767d656:          */
1:a1aaa63:         public StringDataValue         getNullChar(StringDataValue previous,
1:a1aaa63:                 int collationType)
1:6b95f61:         throws StandardException
1:a1aaa63:         {
1:767d656:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:a1aaa63:                 return getNullChar(previous);
1:a1aaa63:             
1:a1aaa63:             if (previous == null)
1:a1aaa63:                 return new CollatorSQLChar(getCharacterCollator(collationType));
1:a1aaa63:             
1:a1aaa63:             previous.setToNull();
1:a1aaa63:             return previous;
1:a1aaa63:          }
1:eac0369: 
1:eac0369:         public StringDataValue          getNullVarchar(StringDataValue dataValue)
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
1:eac0369:                         return getVarcharDataValue((String) null);
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:eac0369:         
1:a1aaa63:         /**
1:a1aaa63:          * Get a SQL VARCHAR set to NULL with collation set to collationType.
1:a1aaa63:          * If the supplied value is null then get a new value,
1:a1aaa63:          * otherwise set it to null and return that value.
1:a1aaa63:          */
1:a1aaa63:         public StringDataValue         getNullVarchar(StringDataValue previous,
1:a1aaa63:                 int collationType)
1:6b95f61:         throws StandardException
1:a1aaa63:         {
1:767d656:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:a1aaa63:                 return getNullChar(previous);
1:a1aaa63:             
1:a1aaa63:             if (previous == null)
1:a1aaa63:                 return new CollatorSQLVarchar(getCharacterCollator(collationType));
1:a1aaa63:             
1:a1aaa63:             previous.setToNull();
1:a1aaa63:             return previous;
1:a1aaa63:         }
1:eac0369: 
1:eac0369:         public StringDataValue          getNullLongvarchar(StringDataValue dataValue)
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
1:eac0369:                         return getLongvarcharDataValue((String) null);
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:eac0369:         
1:a1aaa63:         /**
1:a1aaa63:          * Get a SQL LONG VARCHAR set to NULL with collation set to collationType.
1:a1aaa63:          * If the supplied value is null then get a new value,
1:a1aaa63:          * otherwise set it to null and return that value.
1:a1aaa63:          */
1:a1aaa63:         public StringDataValue         getNullLongvarchar(StringDataValue previous,
1:a1aaa63:                 int collationType)
1:6b95f61:         throws StandardException
1:a1aaa63:         {
1:a1aaa63:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:a1aaa63:                 return getNullChar(previous);
1:a1aaa63:             
1:a1aaa63:             if (previous == null)
1:a1aaa63:                 return new CollatorSQLLongvarchar(getCharacterCollator(collationType));
1:a1aaa63:             
1:a1aaa63:             previous.setToNull();
1:a1aaa63:             return previous;
1:a1aaa63:         }
1:eac0369: 
1:eac0369:         public StringDataValue          getNullClob(StringDataValue dataValue)
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
1:c8c1551:                         return new SQLClob();
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:eac0369:         
1:a1aaa63:         /**
1:a1aaa63:          * Get a SQL CLOB set to NULL with collation set to collationType.
1:a1aaa63:          * If the supplied value is null then get a new value,
1:a1aaa63:          * otherwise set it to null and return that value.
1:a1aaa63:          */
1:a1aaa63:         public StringDataValue         getNullClob(StringDataValue previous,
1:a1aaa63:                 int collationType)
1:6b95f61:         throws StandardException
1:a1aaa63:         {
1:a1aaa63:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:a1aaa63:                 return getNullChar(previous);
1:a1aaa63:             
1:a1aaa63:             if (previous == null)
1:a1aaa63:                 return new CollatorSQLClob(getCharacterCollator(collationType));
1:a1aaa63:             
1:a1aaa63:             previous.setToNull();
1:a1aaa63:             return previous;
1:a1aaa63:         }
1:eac0369: 
1:eac0369:         public UserDataValue            getNullObject(UserDataValue dataValue)
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
1:4309044:                         return new UserType((Object) null);
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:eac0369: 
1:eac0369:         public RefDataValue             getNullRef(RefDataValue dataValue)
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
1:c8c1551:                         return new SQLRef();
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:eac0369: 
1:eac0369:         public DateTimeDataValue        getNullDate(DateTimeDataValue dataValue)
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
1:eac0369:                     try
1:eac0369:                     {
1:4309044:                         return new SQLDate((Date) null);
1:eac0369:                     }
1:eac0369:                     catch( StandardException se)
1:eac0369:                     {
1:eac0369:                         if( SanityManager.DEBUG)
1:eac0369:                         {
1:eac0369:                             SanityManager.THROWASSERT( "Could not get a null date.", se);
1:eac0369:                         }
1:eac0369:                         return null;
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:eac0369: 
1:eac0369:         public DateTimeDataValue        getNullTime(DateTimeDataValue dataValue)
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
1:eac0369:                     try
1:eac0369:                     {
1:4309044:                         return new SQLTime((Time) null);
1:eac0369:                     }
1:eac0369:                     catch( StandardException se)
1:eac0369:                     {
1:eac0369:                         if( SanityManager.DEBUG)
1:eac0369:                         {
1:eac0369:                             SanityManager.THROWASSERT( "Could not get a null time.", se);
1:eac0369:                         }
1:eac0369:                         return null;
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:eac0369: 
1:eac0369:         public DateTimeDataValue        getNullTimestamp(DateTimeDataValue dataValue)
1:eac0369:         {
1:eac0369:                 if (dataValue == null)
1:eac0369:                 {
1:eac0369:                     try
1:eac0369:                     {
1:4309044:                         return new SQLTimestamp((Timestamp) null);
1:eac0369:                     }
1:eac0369:                     catch( StandardException se)
1:eac0369:                     {
1:eac0369:                         if( SanityManager.DEBUG)
1:eac0369:                         {
1:eac0369:                             SanityManager.THROWASSERT( "Could not get a null timestamp.", se);
1:eac0369:                         }
1:eac0369:                         return null;
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         dataValue.setToNull();
1:eac0369:                         return dataValue;
1:eac0369:                 }
1:eac0369:         }
1:eac0369: 
1:eac0369:     public DateTimeDataValue getDateValue( String dateStr, boolean isJdbcEscape) throws StandardException
1:eac0369:     {
1:eac0369:         return new SQLDate( dateStr, isJdbcEscape, getLocaleFinder());
1:eac0369:     } // end of getDateValue( String dateStr)
1:eac0369: 
1:eac0369:     public DateTimeDataValue getTimeValue( String timeStr, boolean isJdbcEscape) throws StandardException
1:eac0369:     {
1:eac0369:         return new SQLTime( timeStr, isJdbcEscape, getLocaleFinder());
1:eac0369:     } // end of getTimeValue( String timeStr)
1:eac0369: 
1:eac0369:     public DateTimeDataValue getTimestampValue( String timestampStr, boolean isJdbcEscape) throws StandardException
1:eac0369:     {
1:eac0369:         return new SQLTimestamp( timestampStr, isJdbcEscape, getLocaleFinder());
1:eac0369:     } // end of getTimestampValue( String timestampStr)
1:eac0369: 
1:eac0369:     /**
2:099e28f:      * getXMLDataValue:
1:099e28f:      * Get a null XML  value.  If a non-null XMLDataValue is
1:099e28f:      * received then re-use that instance, otherwise create
1:099e28f: 	 * a new one.
1:099e28f:      * @param previous An XMLDataValue instance to re-use.
2:099e28f:      * @return An XMLDataValue instance corresponding to a
1:099e28f:      *  NULL value.  If an XMLDataValue was received, the
1:099e28f:      *  returned XMLDataValue is the same instance as the one
1:099e28f:      *  received, but the actual data has been set to a
1:099e28f:      *  SQL null value.
1:099e28f:      * @exception StandardException Thrown on error
1:eac0369:      */
1:099e28f:     public XMLDataValue getXMLDataValue(XMLDataValue previous)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:099e28f: 		return getNullXML(previous);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:099e28f:      * getNullXML:
1:099e28f:      * Get an XML with a SQL null value. If the supplied value is
1:099e28f:      * null then get a new value, otherwise set it to null and return 
1:099e28f:      * that value.
1:099e28f:      * @param dataValue An XMLDataValue instance to re-use.
1:099e28f:      * @return An XMLDataValue instance corresponding to a
1:099e28f:      *  NULL value.  If an XMLDataValue was received, the
1:099e28f:      *  returned XMLDataValue is the same instance as the one
1:099e28f:      *  received, but the actual data has been set to null.
1:eac0369:      */
1:099e28f:     public XMLDataValue getNullXML(XMLDataValue dataValue)
1:eac0369:     {
1:eac0369:         if (dataValue == null)
1:c8c1551:             return new XML();
1:57cb998:         else {
1:eac0369:             dataValue.setToNull();
1:eac0369:             return dataValue;
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:b5e1331:     /** @see DataValueFactory#getCharacterCollator(int) */
1:6b95f61:     public RuleBasedCollator getCharacterCollator(int collationType) 
1:6b95f61:     throws StandardException {
1:57cb998:     	if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:b5e1331:     		return (RuleBasedCollator)null;
1:6b95f61:     	else if (collatorForCharacterTypes == null) {
1:6b95f61:     		//This is the first access to Collator because otherwise
1:6b95f61:     		//it will not be null. Verify that JVM has support for
1:6b95f61:     		//the Collator for the database locale.
1:5212101: 			//	Calculate the collator strength. COLLATION_TYPE_TERRITORY_BASED use strength -1, i e unspecified.
1:5212101: 			int strength = collationType - StringDataValue.COLLATION_TYPE_TERRITORY_BASED_PRIMARY;
1:5212101:     		collatorForCharacterTypes = verifyCollatorSupport(strength);
1:6b95f61:     		return collatorForCharacterTypes;    	    		
1:6b95f61:     	} else
1:767d656:     		return collatorForCharacterTypes;    	
1:767d656:     }
1:6b95f61:     
1:6b95f61:     /**
1:106919e:      * Verify that JVM has support for the Collator for the database's locale.
1:6b95f61:      *
1:5212101: 	 * @param strength Collator strength or -1 for locale default.
1:6b95f61:      * @return Collator for database's locale
1:6b95f61:      * @throws StandardException if JVM does not have support for Collator
1:6b95f61:      */
1:5212101:     private RuleBasedCollator verifyCollatorSupport(int strength)
1:6b95f61:     throws StandardException {
1:6b95f61:     	Locale[] availLocales =  Collator.getAvailableLocales();
1:6b95f61:     	//Verify that Collator can be instantiated for the given locale.
1:6b95f61:     	boolean localeFound = false;
1:6b95f61:     	for (int i=0; i<availLocales.length;i++)
1:6b95f61:     	{
1:6b95f61:     		if (availLocales[i].equals(databaseLocale)) {
1:6b95f61:     			localeFound = true;
1:6b95f61:     			break;
1:6b95f61:     		}
1:6b95f61:     	}
1:6b95f61:     	if (!localeFound)
1:6b95f61: 			throw StandardException.newException(
1:6b95f61: 					SQLState.COLLATOR_NOT_FOUND_FOR_LOCALE, 
1:6b95f61: 					databaseLocale.toString());
1:6b95f61:     	
1:5212101:     	RuleBasedCollator collator = (RuleBasedCollator)Collator.getInstance(databaseLocale);
1:5212101: 
1:5212101: 		if (strength != -1)
1:5212101: 			collator.setStrength(strength);
1:5212101: 
1:5212101: 		return collator;
1:6b95f61:     }
3:099e28f:     /** 
1:57cb998:      * @see DataValueFactory#getNull(int, int)
3:099e28f:      */
1:57cb998:     public DataValueDescriptor getNull(int formatId, int collationType) 
1:57cb998:     throws StandardException {
1:767d656: 
1:5465561:         DataValueDescriptor returnDVD =
1:5465561:             DataValueFactoryImpl.getNullDVDWithUCS_BASICcollation(formatId);
1:5465561: 
1:5465561:         // If we are dealing with default collation, then we have got the
1:5465561:         // right DVD already. Just return it.
1:5465561:         if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC) {
1:5465561:             return returnDVD;
1:5465561:         }
1:5465561: 
1:5465561:         // If we are dealing with territory based collation and returnDVD is
1:5465561:         // of type StringDataValue, then we need to return a StringDataValue
1:5465561:         // with territory based collation.
1:5465561:         if (returnDVD instanceof StringDataValue) {
1:5465561:             return ((StringDataValue) returnDVD)
1:5465561:                     .getValue(getCharacterCollator(collationType));
1:5465561:         }
1:5465561: 
1:5465561:         // Otherwise, it's not a StringDataValue, and it can be returned
1:5465561:         // as it is.
1:5465561:         return returnDVD;
1:57cb998:     }
1:57cb998:     
1:57cb998:     /**
1:57cb998:      * This method will return a DVD based on the formatId. It doesn't take
1:57cb998:      * into account the collation that should be associated with collation
1:57cb998:      * sensitive DVDs, which are all the character type DVDs. Such DVDs 
1:57cb998:      * returned from this method have default UCS_BASIC collation associated
1:5465561:      * with them. If collation associated should be territory based, then that
1:57cb998:      * needs to be handled by the caller of this method. An example of such 
1:57cb998:      * code in the caller can be seen in DataValueFactory.getNull method.
1:57cb998:      * 
1:57cb998:      * @param formatId Return a DVD based on the format id
1:57cb998:      * @return DataValueDescriptor with default collation of UCS_BASIC 
1:57cb998:      */
1:722a889:     public static DataValueDescriptor getNullDVDWithUCS_BASICcollation(
1:722a889:     int formatId) {
1:b5e1331: 
1:57cb998:         switch (formatId) {
1:57cb998:         /* Wrappers */
1:57cb998:         case StoredFormatIds.SQL_BIT_ID: return new SQLBit();
1:57cb998:         case StoredFormatIds.SQL_BOOLEAN_ID: return new SQLBoolean();
1:57cb998:         case StoredFormatIds.SQL_CHAR_ID: return new SQLChar();
1:57cb998:         case StoredFormatIds.SQL_DATE_ID: return new SQLDate();
1:5465561:         case StoredFormatIds.SQL_DECIMAL_ID: return new SQLDecimal();
1:57cb998:         case StoredFormatIds.SQL_DOUBLE_ID: return new SQLDouble();
1:57cb998:         case StoredFormatIds.SQL_INTEGER_ID: return new SQLInteger();
1:57cb998:         case StoredFormatIds.SQL_LONGINT_ID: return new SQLLongint();
1:57cb998:         case StoredFormatIds.SQL_REAL_ID: return new SQLReal();
1:57cb998:         case StoredFormatIds.SQL_REF_ID: return new SQLRef();
1:57cb998:         case StoredFormatIds.SQL_SMALLINT_ID: return new SQLSmallint();
1:57cb998:         case StoredFormatIds.SQL_TIME_ID: return new SQLTime();
1:57cb998:         case StoredFormatIds.SQL_TIMESTAMP_ID: return new SQLTimestamp();
1:57cb998:         case StoredFormatIds.SQL_TINYINT_ID: return new SQLTinyint();
1:57cb998:         case StoredFormatIds.SQL_VARCHAR_ID: return new SQLVarchar();
1:57cb998:         case StoredFormatIds.SQL_LONGVARCHAR_ID: return new SQLLongvarchar();
1:57cb998:         case StoredFormatIds.SQL_VARBIT_ID: return new SQLVarbit();
1:57cb998:         case StoredFormatIds.SQL_LONGVARBIT_ID: return new SQLLongVarbit();
1:57cb998:         case StoredFormatIds.SQL_USERTYPE_ID_V3: return new UserType();
1:57cb998:         case StoredFormatIds.SQL_BLOB_ID: return new SQLBlob();
1:57cb998:         case StoredFormatIds.SQL_CLOB_ID: return new SQLClob();
1:57cb998:         case StoredFormatIds.XML_ID: return new XML();
1:722a889:         case StoredFormatIds.ACCESS_HEAP_ROW_LOCATION_V1_ID: 
1:722a889:         // This is an specific implementation of RowLocation, known to be
1:722a889:         // a DTD.  
1:722a889:              return(
1:722a889:                  new org.apache.derby.impl.store.access.heap.HeapRowLocation());
1:57cb998:         default:return null;
1:57cb998:         }
1:767d656:     }
1:eac0369: 
1:eac0369:         // RESOLVE: This is here to find the LocaleFinder (i.e. the Database)
1:eac0369:         // on first access. This is necessary because the Monitor can't find
1:eac0369:         // the Database at boot time, because the Database is not done booting.
1:eac0369:         // See LanguageConnectionFactory.
1:eac0369:         private LocaleFinder getLocaleFinder()
1:eac0369:         {
1:eac0369:                 if (localeFinder == null)
1:a0dbbd7:                 {
1:a0dbbd7:                         DatabaseContext dc = (DatabaseContext) getContext(DatabaseContext.CONTEXT_ID);
1:eac0369:                         if( dc != null)
1:eac0369:                             localeFinder = dc.getDatabase();
1:a0dbbd7:                 }
1:eac0369: 
1:eac0369:                 return localeFinder;
1:a0dbbd7:         }
1:a0dbbd7:     
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of a Context. Package protected so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     static  Context    getContext( final String contextID )
1:a0dbbd7:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<Context>()
1:56c1dc2:              {
1:56c1dc2:                  public Context run()
1:a0dbbd7:                  {
1:56c1dc2:                      return ContextService.getContext( contextID );
1:56c1dc2:                  }
1:a0dbbd7:              }
1:56c1dc2:              );
1:a0dbbd7:     }
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:a0dbbd7: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1:     		ModuleFactory monitor = getMonitor();
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<Context>()
1:              {
1:                  public Context run()
1:                      return ContextService.getContext( contextID );
1:              }
1:              );
1:     
1:     /**
1:      * Privileged Monitor lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
1:     }
1: 
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.Context;
/////////////////////////////////////////////////////////////////////////
1:                         DatabaseContext dc = (DatabaseContext) getContext(DatabaseContext.CONTEXT_ID);
1:     
1:     /**
1:      * Privileged lookup of a Context. Package protected so that user code
1:      * can't call this entry point.
1:      */
1:     static  Context    getContext( final String contextID )
1:     {
0:         if ( System.getSecurityManager() == null )
1:         {
0:             return ContextService.getContext( contextID );
1:         }
1:         else
1:         {
0:             return AccessController.doPrivileged
0:                 (
0:                  new PrivilegedAction<Context>()
1:                  {
0:                      public Context run()
1:                      {
0:                          return ContextService.getContext( contextID );
1:                      }
1:                  }
0:                  );
1:         }
1:     }
commit:6b23802
/////////////////////////////////////////////////////////////////////////
0:     		RegisteredFormatIds.setDecimalClassName( decimalImplementation.getClass().getName() );
commit:85e788b
/////////////////////////////////////////////////////////////////////////
1:         public StringDataValue getClobDataValue(Clob value,
1:                 StringDataValue previous, int collationType)
1:             throws StandardException
1:         {
1:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:                 return getClobDataValue(value, previous);
1:             
1:             if (previous == null)
1:             {
1:                 return new CollatorSQLClob(value,
1:                         getCharacterCollator(collationType));
1:             }
1:             
1:             previous.setValue(value);
1:             return previous;
1:         }
commit:9495437
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:92268ac
/////////////////////////////////////////////////////////////////////////
0:         public StringDataValue          getNullPassword(StringDataValue dataValue)
1:         {
0:             return new SQLPassword();
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
0:         case StoredFormatIds.SQL_PASSWORD_ID: return new SQLPassword();
commit:638f1b4
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Blob;
1: import java.sql.Clob;
0: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
1:         public BitDataValue getBlobDataValue(Blob value, BitDataValue previous)
1:                         throws StandardException
1:         {
1:             if (previous == null) { return new SQLBlob(value); }
1:             previous.setValue(value);
1:             return previous;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         public StringDataValue getClobDataValue(Clob value, StringDataValue previous) throws StandardException
1:         {
1:             if (previous == null) { return new SQLClob(value); }
1:             
1:             previous.setValue(value);
1:             return previous;
1:         }
1: 
1:     
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5465561
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  * Core implementation of DataValueFactory.
1: public final class DataValueFactoryImpl implements DataValueFactory, ModuleControl
1:         private LocaleFinder localeFinder;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             NumberDataValue retValue =
1:                     (previous == null) ? getNullDecimal(null) : previous;
1:             retValue.setValue(value);
1:             return retValue;
/////////////////////////////////////////////////////////////////////////
1:         public final NumberDataValue getNullDecimal(NumberDataValue dataValue)
1:         {
1:             if (dataValue == null) {
1:                 return new SQLDecimal();
1:             }
1: 
1:             dataValue.setToNull();
1:             return dataValue;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         DataValueDescriptor returnDVD =
1:             DataValueFactoryImpl.getNullDVDWithUCS_BASICcollation(formatId);
1: 
1:         // If we are dealing with default collation, then we have got the
1:         // right DVD already. Just return it.
1:         if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC) {
1:             return returnDVD;
1:         }
1: 
1:         // If we are dealing with territory based collation and returnDVD is
1:         // of type StringDataValue, then we need to return a StringDataValue
1:         // with territory based collation.
1:         if (returnDVD instanceof StringDataValue) {
1:             return ((StringDataValue) returnDVD)
1:                     .getValue(getCharacterCollator(collationType));
1:         }
1: 
1:         // Otherwise, it's not a StringDataValue, and it can be returned
1:         // as it is.
1:         return returnDVD;
/////////////////////////////////////////////////////////////////////////
1:      * with them. If collation associated should be territory based, then that
/////////////////////////////////////////////////////////////////////////
1:         case StoredFormatIds.SQL_DECIMAL_ID: return new SQLDecimal();
commit:5212101
/////////////////////////////////////////////////////////////////////////
1: 	    			properties.getProperty(Attribute.COLLATION);
1: 					int collationType = DataTypeDescriptor.getCollationType(userDefinedCollation);
1: 					if (collationType != StringDataValue.COLLATION_TYPE_UCS_BASIC) {
1: 						if (collationType >= StringDataValue.COLLATION_TYPE_TERRITORY_BASED
1: 								&& collationType <  StringDataValue.COLLATION_TYPE_TERRITORY_BASED_IDENTICAL) {
1: 							int strength = collationType - StringDataValue.COLLATION_TYPE_TERRITORY_BASED_PRIMARY;
1: 							collatorForCharacterTypes = verifyCollatorSupport(strength);
1: 						} else
1: 							throw StandardException.newException(SQLState.INVALID_COLLATION, userDefinedCollation);
1: 					}
/////////////////////////////////////////////////////////////////////////
1: 			//	Calculate the collator strength. COLLATION_TYPE_TERRITORY_BASED use strength -1, i e unspecified.
1: 			int strength = collationType - StringDataValue.COLLATION_TYPE_TERRITORY_BASED_PRIMARY;
1:     		collatorForCharacterTypes = verifyCollatorSupport(strength);
/////////////////////////////////////////////////////////////////////////
1:      *
1: 	 * @param strength Collator strength or -1 for locale default.
1:     private RuleBasedCollator verifyCollatorSupport(int strength)
/////////////////////////////////////////////////////////////////////////
1:     	RuleBasedCollator collator = (RuleBasedCollator)Collator.getInstance(databaseLocale);
1: 
1: 		if (strength != -1)
1: 			collator.setStrength(strength);
1: 
1: 		return collator;
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:4309044
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         return new SQLSmallint(value);
/////////////////////////////////////////////////////////////////////////
1:                         return new SQLTinyint(value);
/////////////////////////////////////////////////////////////////////////
1:                         return new SQLLongint(value);
/////////////////////////////////////////////////////////////////////////
1:                         return new SQLReal(value);
/////////////////////////////////////////////////////////////////////////
1:                         return new SQLDouble(value);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         return new SQLBoolean(value);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         return new UserType((Object) null);
/////////////////////////////////////////////////////////////////////////
1:                         return new SQLDate((Date) null);
/////////////////////////////////////////////////////////////////////////
1:                         return new SQLTime((Time) null);
/////////////////////////////////////////////////////////////////////////
1:                         return new SQLTimestamp((Timestamp) null);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:106919e
/////////////////////////////////////////////////////////////////////////
1:      * Verify that JVM has support for the Collator for the database's locale.
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:6b95f61
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1: import org.apache.derby.iapi.reference.Attribute;
0: import org.apache.derby.iapi.reference.Property;
/////////////////////////////////////////////////////////////////////////
1:     		    		
0:     		NumberDataType.ZERO_DECIMAL = decimalImplementation;    		
1: 
0:     		ModuleFactory monitor = Monitor.getMonitor();
1:     		//The Locale on monitor has already been set by the boot code in
1:     		//BasicDatabase so we can simply do a get here.
1:     		//This Locale will be either the Locale obtained from the territory
1:     		//attribute supplied by the user on the JDBC url at database create
1:     		//time or if user didn't provide the territory attribute at database
1:     		//create time, then it will be set to the default JVM locale. The
1:     		//Locale object will be used to construct the Collator object which
1:     		//will be used if user has requested territory based collation.
1:     		databaseLocale = monitor.getLocale(this);
1: 
1:     		//If we are here for database create time, verify that there is 
1:     		//Collator support for the database's locale. If not, then we 
1:     		//will throw an exception. 
1:     		//Notice that this Collator support check is happening only during 
1:     		//database creation time. This is because, during database create
1:     		//time, DVF has access to collation property of the database and
1:     		//hence it can do the Collator support check
1:     		//(collation property is available through JDBC url at the database
1:     		//create time, if user has asked for a particular collation) eg
1:     		//connect 'jdbc:derby:db;create=true;territory=no;collation=TERRITORY_BASED';
1:     		//Once the database is created, the collation property gets
1:     		//saved in the database and during susbsequent boots of the
1:     		//database, collation attribute of the database is only available
1:     		//once store has finished reading it. So, during subsequent 
1:     		//database boot up time, the collation attribute of the database 
1:     		//will be checked the first time a collation operation is done.
1:     		//And if the Collator support is not found at that point, user will 
1:     		//get an exception for Collator unavailability. This first 
1:     		//collation operation can happen if the database needs to be 
1:     		//recovered during boot time or otherwise it will happen when the
1:     		//user has executed a SQL which requires collation operation.
1: 	    	if (create) {
1: 	    		//Get the collation property from the JDBC url(this will be 
1: 	    		//available only during database create time). It can only have 
1: 	    		//one of the 2 possible values - UCS_BASIC or TERRITORY_BASED.
1: 	    		//This property can only be specified at database create time.
1: 	    		//If the user has requested for territory based database, then 
1: 	    		//verify that JVM has Collator support for the database locale.
1: 	    		String userDefinedCollation = 
0: 	    			properties.getProperty(Attribute.COLLATION);		
1: 	    		if (userDefinedCollation != null) {//Invalid value handling
0: 	    			if (!userDefinedCollation.equalsIgnoreCase(Property.UCS_BASIC_COLLATION)
0: 	    					&& !userDefinedCollation.equalsIgnoreCase(Property.TERRITORY_BASED_COLLATION))
0: 	    				throw StandardException.newException(SQLState.INVALID_COLLATION, userDefinedCollation);
0: 	    			if (userDefinedCollation.equalsIgnoreCase(Property.TERRITORY_BASED_COLLATION))
0: 	    				collatorForCharacterTypes = verifyCollatorSupport();
1: 	    		}    		
1: 	    	}
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     public RuleBasedCollator getCharacterCollator(int collationType) 
1:     throws StandardException {
1:     	else if (collatorForCharacterTypes == null) {
1:     		//This is the first access to Collator because otherwise
1:     		//it will not be null. Verify that JVM has support for
1:     		//the Collator for the database locale.
0:     		collatorForCharacterTypes = verifyCollatorSupport();
1:     		return collatorForCharacterTypes;    	    		
1:     	} else
1:     
1:     /**
0:      * Verify that JVM has support for the Collator for the datbase's locale.
1:      * 
1:      * @return Collator for database's locale
1:      * @throws StandardException if JVM does not have support for Collator
1:      */
0:     private RuleBasedCollator verifyCollatorSupport() 
1:     throws StandardException {
1:     	Locale[] availLocales =  Collator.getAvailableLocales();
1:     	//Verify that Collator can be instantiated for the given locale.
1:     	boolean localeFound = false;
1:     	for (int i=0; i<availLocales.length;i++)
1:     	{
1:     		if (availLocales[i].equals(databaseLocale)) {
1:     			localeFound = true;
1:     			break;
1:     		}
1:     	}
1:     	if (!localeFound)
1: 			throw StandardException.newException(
1: 					SQLState.COLLATOR_NOT_FOUND_FOR_LOCALE, 
1: 					databaseLocale.toString());
1:     	
0:     	return (RuleBasedCollator) Collator.getInstance(databaseLocale);
1:     }
commit:111785f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:57cb998
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @see DataValueFactory#getNull(int, int)
1:     public DataValueDescriptor getNull(int formatId, int collationType) 
1:     throws StandardException {
0:     	//For StoredFormatIds.SQL_DECIMAL_ID, different implementations are 
0:     	//required for different VMs. getNullDecimal method is not static and 
0:     	//hence can't be called in the static getNullDVDWithUCS_BASICcollation
0:     	//method in this class. That is why StoredFormatIds.SQL_DECIMAL_ID is 
0:     	//getting handled here.
0:     	if (formatId == StoredFormatIds.SQL_DECIMAL_ID)
0:     		return getNullDecimal(null);
1: 		else {
0: 			DataValueDescriptor returnDVD = 
0: 				DataValueFactoryImpl.getNullDVDWithUCS_BASICcollation(formatId);
0: 			//If we are dealing with default collation, then we have got the
0: 			//right DVD already. Just return it.
1: 			if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
0: 				return returnDVD;			
0: 			//If we are dealing with territory based collation and returnDVD is 
0: 			//of type StringDataValue, then we need to return a StringDataValue   
0: 			//with territory based collation.
0: 			if (returnDVD instanceof StringDataValue) 
0: 				return ((StringDataValue)returnDVD).getValue(getCharacterCollator(collationType));
1: 			else
0: 				return returnDVD;			
1:     }
1:     
1:     /**
1:      * This method will return a DVD based on the formatId. It doesn't take
1:      * into account the collation that should be associated with collation
1:      * sensitive DVDs, which are all the character type DVDs. Such DVDs 
1:      * returned from this method have default UCS_BASIC collation associated
0:      * with them. If collation associated should be terriotry based, then that
1:      * needs to be handled by the caller of this method. An example of such 
1:      * code in the caller can be seen in DataValueFactory.getNull method.
1:      * 
0:      * Another thing to note is this method does not deal with format id
0:      * associated with decimal. This is because different implementation are
0:      * required for different VMs. This is again something that needs to be
0:      * handled by the caller. An example of such code in the caller can be 
0:      * seen in DataValueFactory.getNull method.
1:      *  
1:      * @param formatId Return a DVD based on the format id
1:      * @return DataValueDescriptor with default collation of UCS_BASIC 
1:      */
0:     public static DataValueDescriptor getNullDVDWithUCS_BASICcollation(int formatId){
1:         switch (formatId) {
1:         /* Wrappers */
1:         case StoredFormatIds.SQL_BIT_ID: return new SQLBit();
1:         case StoredFormatIds.SQL_BOOLEAN_ID: return new SQLBoolean();
1:         case StoredFormatIds.SQL_CHAR_ID: return new SQLChar();
1:         case StoredFormatIds.SQL_DATE_ID: return new SQLDate();
1:         case StoredFormatIds.SQL_DOUBLE_ID: return new SQLDouble();
1:         case StoredFormatIds.SQL_INTEGER_ID: return new SQLInteger();
1:         case StoredFormatIds.SQL_LONGINT_ID: return new SQLLongint();
0:         case StoredFormatIds.SQL_NATIONAL_CHAR_ID: return new SQLNationalChar();
0:         case StoredFormatIds.SQL_NATIONAL_LONGVARCHAR_ID: return new SQLNationalLongvarchar();
0:         case StoredFormatIds.SQL_NATIONAL_VARCHAR_ID: return new SQLNationalVarchar();
1:         case StoredFormatIds.SQL_REAL_ID: return new SQLReal();
1:         case StoredFormatIds.SQL_REF_ID: return new SQLRef();
1:         case StoredFormatIds.SQL_SMALLINT_ID: return new SQLSmallint();
1:         case StoredFormatIds.SQL_TIME_ID: return new SQLTime();
1:         case StoredFormatIds.SQL_TIMESTAMP_ID: return new SQLTimestamp();
1:         case StoredFormatIds.SQL_TINYINT_ID: return new SQLTinyint();
1:         case StoredFormatIds.SQL_VARCHAR_ID: return new SQLVarchar();
1:         case StoredFormatIds.SQL_LONGVARCHAR_ID: return new SQLLongvarchar();
1:         case StoredFormatIds.SQL_VARBIT_ID: return new SQLVarbit();
1:         case StoredFormatIds.SQL_LONGVARBIT_ID: return new SQLLongVarbit();
1:         case StoredFormatIds.SQL_USERTYPE_ID_V3: return new UserType();
1:         case StoredFormatIds.SQL_BLOB_ID: return new SQLBlob();
1:         case StoredFormatIds.SQL_CLOB_ID: return new SQLClob();
0:         case StoredFormatIds.SQL_NCLOB_ID: return new SQLNClob();
1:         case StoredFormatIds.XML_ID: return new XML();
1:         default:return null;
1:         }
commit:d19a66f
/////////////////////////////////////////////////////////////////////////
0: 				//return a StringDataValue with territory based collation.
0: 					return ((StringDataValue)returnObject).getValue(getCharacterCollator(collationType));
/////////////////////////////////////////////////////////////////////////
0: 					//return a StringDataValue with territory based collation.
0: 						return ((StringDataValue)returnObject).getValue(getCharacterCollator(collationType));
commit:767d656
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.FormatableInstanceGetter;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.loader.ClassInfo;
0: import org.apache.derby.iapi.services.loader.InstanceGetter;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
/////////////////////////////////////////////////////////////////////////
1:     	/** 
0:     	 * For performance purposes, cache InstanceGetters for various formatid
0:     	 * as we get them in getInstanceUsingFormatIdAndCollationType method.
1:     	 */ 
0:     	private InstanceGetter[] instanceGettersForFormatIds;
1: 
/////////////////////////////////////////////////////////////////////////
1:     		return collatorForCharacterTypes;    	
1:     }
1: 
1:     /** 
0:      * @see DataValueFactory#getInstanceUsingFormatIdAndCollationType(int, int)
1:      */
0:     public Object getInstanceUsingFormatIdAndCollationType(
0:     		int formatId, int collationType) throws StandardException {
0: 		String className;
0: 		int fmtIdPositionInInstanceGetterArray;
0: 		InstanceGetter instanceGetter;
1: 
0: 		try {
0: 			fmtIdPositionInInstanceGetterArray = 
0: 				formatId - StoredFormatIds.MIN_TWO_BYTE_FORMAT_ID;
0: 			//If this is the first time this method is getting called, then
0: 			//instanceGettersForFormatIds will be null. If so, allocate it.
0: 			if (instanceGettersForFormatIds == null) {
0: 				instanceGettersForFormatIds = new InstanceGetter[RegisteredFormatIds.TwoByte.length];
1: 			}
0: 			//Check if we have already called this method for the passed format
0: 			//id. 
0: 			instanceGetter = 
0: 				instanceGettersForFormatIds[fmtIdPositionInInstanceGetterArray];
0: 			//If following if is true, then this method has already been called
0: 			//for the passed format id. We can just use the cached InstanceGetter
0: 			//from instanceGettersForFormatIds
0: 			if (instanceGetter != null) {
0: 				//Get the object from the InstanceGetter
0: 				Object returnObject = instanceGetter.getNewInstance();
0: 				//If we are dealing with default collation, then we have 
0: 				//got the right DVD already. Just return it.
1: 				if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
0: 					return returnObject;
0: 				//If we are dealing with territory based collation and 
0: 				//the object is of type StringDataValue, then we need to 
0: 				//create a StringDataValue with territory based collation.
0: 				if (returnObject instanceof StringDataValue) 
0: 					((StringDataValue)returnObject).getValue(getCharacterCollator(collationType));
0: 				return returnObject;
1: 			}
0: 			//This is the first time this method has been called for the passed
0: 			//format id and hence it's InstanceGetter is not in 
0: 			//instanceGettersForFormatIds. Get the InstanceGetter's name for
0: 			//this format id from RegisteredFormatIds
0: 			className = RegisteredFormatIds.TwoByte[fmtIdPositionInInstanceGetterArray];
0: 		} catch (ArrayIndexOutOfBoundsException aioobe) {
0: 			className = null;
0: 			fmtIdPositionInInstanceGetterArray = 0;
0: 		} catch (Exception ite) {
0: 			throw StandardException.newException(SQLState.REGISTERED_CLASS_INSTANCE_ERROR,
0: 					ite, new Integer(formatId), "XX" /*ci.getClassName()*/);
1: 		}
1: 
0: 		if (className != null) {
0: 			Throwable t;
0: 			try {
0: 				Class clazz = Class.forName(className);
0: 				// See if the InstanceGetter class for this format id is a 
0: 				//FormatableInstanceGetter
0: 				if (FormatableInstanceGetter.class.isAssignableFrom(clazz)) {
0: 					FormatableInstanceGetter tfig = (FormatableInstanceGetter) clazz.newInstance();
0: 					tfig.setFormatId(formatId);
0: 					//Cache this InstanceGetter in instanceGettersForFormatIds
0: 					instanceGettersForFormatIds[fmtIdPositionInInstanceGetterArray] = tfig;
0: 					//Get the object from the InstanceGetter
0: 					Object returnObject = tfig.getNewInstance();
0: 					//If we are dealing with default collation, then we have 
0: 					//got the right DVD already. Just return it.
1: 					if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
0: 						return returnObject;
0: 					//If we are dealing with territory based collation and 
0: 					//the object is of type StringDataValue, then we need to 
0: 					//create a StringDataValue with territory based collation.
0: 					if (returnObject instanceof StringDataValue) 
0: 						((StringDataValue)returnObject).getValue(getCharacterCollator(collationType));
0: 						return returnObject;
1: 				}
0: 				//InstanceGetter is not of the type FormatableInstanceGetter
0: 				instanceGettersForFormatIds[fmtIdPositionInInstanceGetterArray] = new ClassInfo(clazz);
0: 				return instanceGettersForFormatIds[fmtIdPositionInInstanceGetterArray].getNewInstance();
0: 			} catch (ClassNotFoundException cnfe) {
0: 				t = cnfe;
0: 			} catch (IllegalAccessException iae) {
0: 				t = iae;
0: 			} catch (InstantiationException ie) {
0: 				t = ie;
0: 			} catch (LinkageError le) {
0: 				t = le;
0: 			} catch (java.lang.reflect.InvocationTargetException ite) {
0: 				t = ite;
1: 			}
0: 			throw StandardException.newException(SQLState.REGISTERED_CLASS_LINAKGE_ERROR,
0: 				t, FormatIdUtil.formatIdToString(formatId), className);
1: 		}
0: 		throw StandardException.newException(SQLState.REGISTERED_CLASS_NONE, FormatIdUtil.formatIdToString(formatId));    	
commit:b5e1331
/////////////////////////////////////////////////////////////////////////
1: import java.text.Collator;
1: import java.text.RuleBasedCollator;
1: 
/////////////////////////////////////////////////////////////////////////
1:     	//Following Collator object will be initialized using databaseLocale.  
1:     	private RuleBasedCollator collatorForCharacterTypes;
/////////////////////////////////////////////////////////////////////////
0:     	collatorForCharacterTypes = 
0:     		(RuleBasedCollator) Collator.getInstance(databaseLocale);
1:     }
1: 
1:     /** @see DataValueFactory#getCharacterCollator(int) */
0:     public RuleBasedCollator getCharacterCollator(int collationType){
1:     	if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:     		return (RuleBasedCollator)null;
1:     	else
0:     		return collatorForCharacterTypes;
1:     	
commit:2ca9dc6
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
1:         //BasicDatabase first boots DVF in it's boot method and then sets 
1:         //this databaseLocale in DVF.
1:     	private Locale databaseLocale;
/////////////////////////////////////////////////////////////////////////
0:     /** @see DataValueFactory#setLocale(Locale) */
0:     public void setLocale(Locale localeOfTheDatabase){
0:     	databaseLocale = localeOfTheDatabase;
1:     }
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:a1aaa63
/////////////////////////////////////////////////////////////////////////
1:         /**
1:          * Get a SQL CHAR set to NULL with collation set to collationType.
1:          * If the supplied value is null then get a new value,
1:          * otherwise set it to null and return that value.
1:          */
1:         public StringDataValue         getNullChar(StringDataValue previous,
1:                 int collationType)
1:         {
1:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:                 return getNullChar(previous);
1:             
1:             if (previous == null)
1:                 return new CollatorSQLChar(getCharacterCollator(collationType));
1:             
1:             previous.setToNull();
1:             return previous;
1:          }
/////////////////////////////////////////////////////////////////////////
1:         
1:         /**
1:          * Get a SQL VARCHAR set to NULL with collation set to collationType.
1:          * If the supplied value is null then get a new value,
1:          * otherwise set it to null and return that value.
1:          */
1:         public StringDataValue         getNullVarchar(StringDataValue previous,
1:                 int collationType)
1:         {
1:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:                 return getNullChar(previous);
1:             
1:             if (previous == null)
1:                 return new CollatorSQLVarchar(getCharacterCollator(collationType));
1:             
1:             previous.setToNull();
1:             return previous;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         
1:         /**
1:          * Get a SQL LONG VARCHAR set to NULL with collation set to collationType.
1:          * If the supplied value is null then get a new value,
1:          * otherwise set it to null and return that value.
1:          */
1:         public StringDataValue         getNullLongvarchar(StringDataValue previous,
1:                 int collationType)
1:         {
1:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:                 return getNullChar(previous);
1:             
1:             if (previous == null)
1:                 return new CollatorSQLLongvarchar(getCharacterCollator(collationType));
1:             
1:             previous.setToNull();
1:             return previous;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         
1:         /**
1:          * Get a SQL CLOB set to NULL with collation set to collationType.
1:          * If the supplied value is null then get a new value,
1:          * otherwise set it to null and return that value.
1:          */
1:         public StringDataValue         getNullClob(StringDataValue previous,
1:                 int collationType)
1:         {
1:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:                 return getNullChar(previous);
1:             
1:             if (previous == null)
1:                 return new CollatorSQLClob(getCharacterCollator(collationType));
1:             
1:             previous.setToNull();
1:             return previous;
1:         }
commit:9373fed
/////////////////////////////////////////////////////////////////////////
1:         
1:         /**
1:          * Return a StringDataValue to represent a SQL CHAR
1:          * with the given collation re-using previous if not null.
1:          */
1:         public StringDataValue getCharDataValue(String value,
1:                 StringDataValue previous, int collationType)
1:             throws StandardException
1:         {
1:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:                 return getCharDataValue(value, previous);
1:             
1:             if (previous == null)
1:                 return new CollatorSQLChar(value, getCharacterCollator(collationType));
1:             
1:             previous.setValue(value);
1:             return previous;
1:         }
1: 
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         /**
1:          * Return a StringDataValue to represent a SQL VARCHAR
1:          * with the given collation re-using previous if not null.
1:          */
1:         public StringDataValue getVarcharDataValue(String value,
1:                 StringDataValue previous, int collationType)
1:             throws StandardException
1:         {
0:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:                 return getVarcharDataValue(value, previous);
1:             
1:             if (previous == null)
1:                 return new CollatorSQLVarchar(value,
1:                         getCharacterCollator(collationType));
1:             
1:             previous.setValue(value);
1:             return previous;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         
1:         /**
1:          * Return a StringDataValue to represent a SQL LONG VARCHAR
1:          * with the given collation re-using previous if not null.
1:          */
1:         public StringDataValue getLongvarcharDataValue(String value,
1:                 StringDataValue previous, int collationType)
1:             throws StandardException
1:         {
0:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:                 return getLongvarcharDataValue(value, previous);
1:             
1:             if (previous == null)
1:                 return new CollatorSQLLongvarchar(value,
1:                         getCharacterCollator(collationType));
1:             
1:             previous.setValue(value);
1:             return previous;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         
1:         /**
1:          * Return a StringDataValue to represent a SQL CLOB
1:          * with the given collation re-using previous if not null.
1:          */
1:         public StringDataValue getClobDataValue(String value,
1:                 StringDataValue previous, int collationType)
1:             throws StandardException
1:         {
0:             if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:                 return getClobDataValue(value, previous);
1:             
1:             if (previous == null)
1:                 return new CollatorSQLClob(value,
1:                         getCharacterCollator(collationType));
1:             
1:             previous.setValue(value);
1:             return previous;
1:         }
commit:c8c1551
/////////////////////////////////////////////////////////////////////////
1:                         return new SQLInteger(value);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         return new SQLVarbit();
/////////////////////////////////////////////////////////////////////////
1:                         return new SQLLongVarbit();
/////////////////////////////////////////////////////////////////////////
1:                         return new SQLBlob();
/////////////////////////////////////////////////////////////////////////
1:                         return new SQLClob();
/////////////////////////////////////////////////////////////////////////
1:                         return new SQLRef();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             return new XML();
commit:a1970a9
/////////////////////////////////////////////////////////////////////////
1:     		
0:     		// Generate a DECIMAL value represetentation of 0
0:     		decimalImplementation = decimalImplementation.getNewNull();
0:     		decimalImplementation.setValue(0L);
0:     		NumberDataType.ZERO_DECIMAL = decimalImplementation;
1:     		
1:     		
1:     		
commit:e11914a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.RegisteredFormatIds;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
0: abstract class DataValueFactoryImpl implements DataValueFactory, ModuleControl
1:         
1:         /*
1:          ** ModuleControl methods.
1:          */
1:         
1:     	/* (non-Javadoc)
1:     	 * @see org.apache.derby.iapi.services.monitor.ModuleControl#boot(boolean, java.util.Properties)
1:     	 */
1:     	public void boot(boolean create, Properties properties) throws StandardException {
1:     		
0:     		DataValueDescriptor decimalImplementation = getNullDecimal(null);
1:     		
0:     		TypeId.decimalImplementation = decimalImplementation;
0:     		RegisteredFormatIds.TwoByte[StoredFormatIds.SQL_DECIMAL_ID]
0:     									= decimalImplementation.getClass().getName();
1:     		
1:     	}
1:     	/* (non-Javadoc)
1:     	 * @see org.apache.derby.iapi.services.monitor.ModuleControl#stop()
1:     	 */
1:     	public void stop() {
1:     	}
1:  
commit:2a58829
/////////////////////////////////////////////////////////////////////////
0:    Copyright 1999, 2005 The Apache Software Foundation or its licensors, as applicable.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
0:  * Core implementation of DataValueFactory. Does not implement
0:  * methods required to generate DataValueDescriptor implementations
0:  * for the DECIMAL datatype. J2ME and J2SE require different implementations.
0: abstract class DataValueFactoryImpl implements DataValueFactory
0:         DataValueFactoryImpl()
/////////////////////////////////////////////////////////////////////////
0:         public final NumberDataValue getDecimalDataValue(Number value)
/////////////////////////////////////////////////////////////////////////
1:         public final NumberDataValue getDecimalDataValue(Number value, NumberDataValue previous)
/////////////////////////////////////////////////////////////////////////
0:         public final NumberDataValue getDecimalDataValue(String value,
/////////////////////////////////////////////////////////////////////////
commit:d7f7457
/////////////////////////////////////////////////////////////////////////
0:         public NumberDataValue getDecimalDataValue(Number value)
1: 			throws StandardException
0: 			NumberDataValue ndv = getNullDecimal((NumberDataValue) null);
0: 			ndv.setValue(value);
0: 			return ndv;
0:         public NumberDataValue getDecimalDataValue(Number value, NumberDataValue previous)
commit:ded6889
/////////////////////////////////////////////////////////////////////////
0:     public      DataValueFactoryImpl()
commit:cf58aec
/////////////////////////////////////////////////////////////////////////
0:         public NumberDataValue getDecimalDataValue(BigDecimal value)
/////////////////////////////////////////////////////////////////////////
0:         public NumberDataValue getDecimalDataValue(BigDecimal value, NumberDataValue previous)
0:                         return getDecimalDataValue(value);
0:         public NumberDataValue getDecimalDataValue(Long value, NumberDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
0:                         previous = new SQLDecimal();
1:                 previous.setValue(value);
1:                 return previous;
1:         }
/////////////////////////////////////////////////////////////////////////
0:         public NumberDataValue getNullDecimal(NumberDataValue dataValue)
commit:509ccb9
/////////////////////////////////////////////////////////////////////////
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.DataValueFactoryImpl
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.BitDataValue;
0: import org.apache.derby.iapi.types.DateTimeDataValue;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.types.UserDataValue;
0: import org.apache.derby.iapi.types.RefDataValue;
1: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: import org.apache.derby.iapi.services.i18n.LocaleFinder;
1: 
0: import org.apache.derby.iapi.types.*;
1: 
0: import java.math.BigDecimal;
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
0: import java.sql.Types;
0: import java.util.Locale;
1: 
1: import org.apache.derby.iapi.db.DatabaseContext;
1: import org.apache.derby.iapi.services.context.ContextService;
1: 
1: /**
0:  * This class implements DataValueFactory.
1:  *
1:  * @see DataValueFactory
1:  */
0: public class DataValueFactoryImpl implements DataValueFactory
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0:         LocaleFinder localeFinder;
1: 
1:         /**
0:           *     Make the constructor public.
1:           *
1:           */
0:     public      DataValueFactoryImpl(LocaleFinder localeFinder)
1:         {
0:                 this.localeFinder = localeFinder;
1:         }
1: 
1:         /**
1:          * @see DataValueFactory#getDataValue
1:          *
1:          */
0:         public NumberDataValue getDataValue(int value)
1:         {
1:                 return new SQLInteger(value);
1:         }
1: 
1:         public NumberDataValue getDataValue(int value, NumberDataValue previous)
1:                                                         throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLInteger(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public NumberDataValue getDataValue(Integer value)
1:         {
0:                 if (value != null)
0:                         return new SQLInteger(value.intValue());
1:                 else
1:                         return new SQLInteger();
1:         }
1: 
1:         public NumberDataValue getDataValue(Integer value, NumberDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
1:                 {
0:                         return getDataValue(value);
1:                 }
1: 
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public NumberDataValue getDataValue(char value)
1:         {
1:                 return new SQLInteger(value);
1:         }
1: 
1:         public NumberDataValue getDataValue(char value, NumberDataValue previous)
1:                                                         throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLInteger(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public NumberDataValue getDataValue(short value)
1:         {
1:                 return new SQLSmallint(value);
1:         }
1: 
1:         public NumberDataValue getDataValue(short value, NumberDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLSmallint(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public NumberDataValue getDataValue(Short value)
1:         {
0:                 if (value != null)
0:                         return new SQLSmallint(value.shortValue());
1:                 else
1:                         return new SQLSmallint();
1:         }
1: 
1:         public NumberDataValue getDataValue(Short value, NumberDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
0:                         return getDataValue(value);
1: 
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public NumberDataValue getDataValue(byte value)
1:         {
1:                 return new SQLTinyint(value);
1:         }
1: 
1:         public NumberDataValue getDataValue(byte value, NumberDataValue previous)
1:                                 throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLTinyint(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public NumberDataValue getDataValue(Byte value)
1:         {
0:                 if (value != null)
0:                         return new SQLTinyint(value.byteValue());
1:                 else
1:                         return new SQLTinyint();
1:         }
1: 
1:         public NumberDataValue getDataValue(Byte value, NumberDataValue previous)
1:                                 throws StandardException
1:         {
1:                 if (previous == null)
0:                         return getDataValue(value);
1: 
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public NumberDataValue getDataValue(long value)
1:         {
1:                 return new SQLLongint(value);
1:         }
1: 
1:         public NumberDataValue getDataValue(long value, NumberDataValue previous)
1:                                 throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLLongint(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public NumberDataValue getDataValue(Long value)
1:         {
0:                 if (value != null)
0:                         return new SQLLongint(value.longValue());
1:                 else
1:                         return new SQLLongint();
1:         }
1: 
1:         public NumberDataValue getDataValue(Long value, NumberDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
0:                         return getDataValue(value);
1: 
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public NumberDataValue getDataValue(float value)
1:                 throws StandardException
1:         {
1:                 return new SQLReal(value);
1:         }
1: 
1:         public NumberDataValue getDataValue(float value, NumberDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLReal(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public NumberDataValue getDataValue(Float value)
1:                 throws StandardException
1:         {
0:                 if (value != null)
0:                         return new SQLReal(value.floatValue());
1:                 else
1:                         return new SQLReal();
1:         }
1: 
1:         public NumberDataValue getDataValue(Float value, NumberDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
0:                         return getDataValue(value);
1: 
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public NumberDataValue getDataValue(double value) throws StandardException
1:         {
1:                 return new SQLDouble(value);
1:         }
1: 
1:         public NumberDataValue getDataValue(double value, NumberDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLDouble(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public NumberDataValue getDataValue(Double value) throws StandardException
1:         {
0:                 if (value != null)
0:                         return new SQLDouble(value.doubleValue());
1:                 else
1:                         return new SQLDouble();
1:         }
1: 
1:         public NumberDataValue getDataValue(Double value, NumberDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
0:                         return getDataValue(value);
1: 
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public NumberDataValue getDataValue(BigDecimal value)
1:         {
0:                 if (value != null)
0:                         return new SQLDecimal(value);
1:                 else
0:                         return new SQLDecimal();
1:         }
1: 
0:         public NumberDataValue getDataValue(BigDecimal value,
0:                                                                                 NumberDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
0:                         return getDataValue(value);
1: 
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public NumberDataValue getDecimalDataValue(String value) throws StandardException
1:         {
0:                 if (value != null)
0:                         return new SQLDecimal(value);
1:                 else
0:                         return new SQLDecimal();
1:         }
1: 
0:         public NumberDataValue getDecimalDataValue(String value,
0:                                                                                                 NumberDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
0:                         return getDecimalDataValue(value);
1: 
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public BooleanDataValue getDataValue(boolean value)
1:         {
1:                 return new SQLBoolean(value);
1:         }
1: 
1:         public BooleanDataValue getDataValue(boolean value,
1:                                                                                 BooleanDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLBoolean(value);
1:         
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public BooleanDataValue getDataValue(Boolean value)
1:         {
0:                 if (value != null)
0:                         return new SQLBoolean(value.booleanValue());
1:                 else
1:                         return new SQLBoolean();
1:         }
1: 
1:         public BooleanDataValue getDataValue(Boolean value,
1:                                                                                         BooleanDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
0:                         return getDataValue(value);
1: 
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public BooleanDataValue getDataValue(BooleanDataValue value)
1:         {
0:                 if (value != null)
0:                         return value;
1:                 else
1:                         return new SQLBoolean();
1:         }
1: 
1:         public BitDataValue getBitDataValue(byte[] value) throws StandardException
1:         {
1:                 return new SQLBit(value);
1:         }
1: 
1:         public BitDataValue getBitDataValue(byte[] value, BitDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLBit(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public BitDataValue getVarbitDataValue(byte[] value)
1:         {
1:                 return new SQLVarbit(value);
1:         }
1: 
1:         public BitDataValue getVarbitDataValue(byte[] value, BitDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLVarbit(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
1: 
1:         // LONGVARBIT
1: 
0:         public BitDataValue getLongVarbitDataValue(byte[] value) throws StandardException
1:         {
1:                 return new SQLLongVarbit(value);
1:         }
1: 
1:         public BitDataValue getLongVarbitDataValue(byte[] value, BitDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLLongVarbit(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
1:         // BLOB
0:         public BitDataValue getBlobDataValue(byte[] value) throws StandardException
1:         {
1:                 return new SQLBlob(value);
1:         }
1: 
1:         public BitDataValue getBlobDataValue(byte[] value, BitDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLBlob(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
1:         // CHAR
1:         public StringDataValue getCharDataValue(String value)
1:         {
1:                 return new SQLChar(value);
1:         }
1: 
1:         public StringDataValue getCharDataValue(String value,
1:                                                                                         StringDataValue previous)
1:                                                                                                         throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLChar(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
1:         public StringDataValue getVarcharDataValue(String value)
1:         {
1:                 return new SQLVarchar(value);
1:         }
1: 
1:         public StringDataValue getVarcharDataValue(String value,
1:                                                                                                 StringDataValue previous)
1:                                                                                                         throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLVarchar(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
1:         public StringDataValue getLongvarcharDataValue(String value)
1:         {
1:                 return new SQLLongvarchar(value);
1:         }
1: 
0:         public StringDataValue getClobDataValue(String value)
1:         {
1:                 return new SQLClob(value);
1:         }
1: 
1:         public StringDataValue getLongvarcharDataValue(String value,
1:                                                                                                         StringDataValue previous)
1:                                                                                                         throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLLongvarchar(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
1:         public StringDataValue getClobDataValue(String value, StringDataValue previous) throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLClob(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         //
0:         public StringDataValue getNationalCharDataValue(String value)
1:         {
0:                 return new SQLNationalChar(value, getLocaleFinder());
1:         }
1: 
0:         public StringDataValue getNationalCharDataValue(String value,
1:                                                                                         StringDataValue previous)
1:                                                                                                         throws StandardException
1:         {
1:                 if (previous == null)
0:                         return new SQLNationalChar(value, getLocaleFinder());
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public StringDataValue getNationalVarcharDataValue(String value)
1:         {
0:                 return new SQLNationalVarchar(value, getLocaleFinder());
1:         }
1: 
0:         public StringDataValue getNationalVarcharDataValue(String value,
1:                                                                                                 StringDataValue previous)
1:                                                                                                         throws StandardException
1:         {
1:                 if (previous == null)
0:                         return new SQLNationalVarchar(value, getLocaleFinder());
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public StringDataValue getNationalLongvarcharDataValue(String value)
1:         {
0:                 return new SQLNationalLongvarchar(value, getLocaleFinder());
1:         }
1: 
0:         public StringDataValue getNationalLongvarcharDataValue(String value,
1:                                                                                                         StringDataValue previous)
1:                                                                                                         throws StandardException
1:         {
1:                 if (previous == null)
0:                         return new SQLNationalLongvarchar(value, getLocaleFinder());
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public StringDataValue getNClobDataValue(String value)
1:         {
0:                 return new SQLNClob(value, getLocaleFinder());
1:         }
1: 
0:         public StringDataValue getNClobDataValue(String value, StringDataValue previous)
1:             throws StandardException
1:         {
1:                 if (previous == null)
0:                         return new SQLNClob(value, getLocaleFinder());
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public DateTimeDataValue getDataValue(Date value) throws StandardException
1:         {
1:                 return new SQLDate(value);
1:         }
1: 
1:         public DateTimeDataValue getDataValue(Date value,
1:                                                                                         DateTimeDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLDate(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public DateTimeDataValue getDataValue(Time value) throws StandardException
1:         {
1:                 return new SQLTime(value);
1:         }
1: 
1:         public DateTimeDataValue getDataValue(Time value,
1:                                                                                         DateTimeDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLTime(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
0:         public DateTimeDataValue getDataValue(Timestamp value) throws StandardException
1:         {
1:                 return new SQLTimestamp(value);
1:         }
1: 
1:         public DateTimeDataValue getDataValue(Timestamp value,
1:                                                                                         DateTimeDataValue previous)
1:                         throws StandardException
1:         {
1:                 if (previous == null)
1:                         return new SQLTimestamp(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
1:         public DateTimeDataValue getTimestamp( DataValueDescriptor date, DataValueDescriptor time) throws StandardException
1:         {
1:             return new SQLTimestamp( date, time);
1:         }
1: 
0:         public UserDataValue getDataValue(Object value)
1:         {
1:                 return new UserType(value);
1:         }
1: 
1:         public UserDataValue getDataValue(Object value,
1:                                                                                 UserDataValue previous)
1:         {
1:                 if (previous == null)
1:                         return new UserType(value);
1:                 ((UserType) previous).setValue(value);
1:                 return previous;
1:         }
1: 
0:         public RefDataValue getDataValue(RowLocation value)
1:         {
1:                 return new SQLRef(value);
1:         }
1: 
1:         public RefDataValue getDataValue(RowLocation value, RefDataValue previous)
1:         {
1:                 if (previous == null)
1:                         return new SQLRef(value);
1:                 previous.setValue(value);
1:                 return previous;
1:         }
1: 
1:         public NumberDataValue          getNullInteger(NumberDataValue dataValue) 
1:         {
1:                 if (dataValue == null)
1:                 {
1:                         return new SQLInteger();
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         public NumberDataValue getNullShort(NumberDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
1:                         return new SQLSmallint();
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         public NumberDataValue getNullLong(NumberDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
1:                         return new SQLLongint();
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         public NumberDataValue getNullByte(NumberDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
1:                         return new SQLTinyint();
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         public NumberDataValue getNullFloat(NumberDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
1:                         return new SQLReal();
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         public NumberDataValue getNullDouble(NumberDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
1:                         return new SQLDouble();
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
0:         public NumberDataValue getNullBigDecimal(NumberDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
0:                         return new SQLDecimal();
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         public BooleanDataValue getNullBoolean(BooleanDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
1:                         return new SQLBoolean();
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         public BitDataValue             getNullBit(BitDataValue dataValue) throws StandardException
1:         {
1:                 if (dataValue == null)
1:                 {
1:                         return getBitDataValue((byte[]) null);
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1: 
1:         public BitDataValue             getNullVarbit(BitDataValue dataValue) throws StandardException
1:         {
1:                 if (dataValue == null)
1:                 {
0:                         return getVarbitDataValue((byte[]) null);
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         // LONGVARBIT
1:         public BitDataValue getNullLongVarbit(BitDataValue dataValue) throws StandardException
1:         {
1:                 if (dataValue == null)
1:                 {
0:                         return getLongVarbitDataValue((byte[]) null);
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         /// BLOB
1:         public BitDataValue getNullBlob(BitDataValue dataValue) throws StandardException
1:         {
1:                 if (dataValue == null)
1:                 {
0:                         return getBlobDataValue((byte[]) null);
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         // CHAR
1:         public StringDataValue          getNullChar(StringDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
1:                         return getCharDataValue((String) null);
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         public StringDataValue          getNullVarchar(StringDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
1:                         return getVarcharDataValue((String) null);
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         public StringDataValue          getNullLongvarchar(StringDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
1:                         return getLongvarcharDataValue((String) null);
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         public StringDataValue          getNullClob(StringDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
0:                         return getClobDataValue((String) null);
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
0:         public StringDataValue          getNullNationalChar(StringDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
0:                         return getNationalCharDataValue((String) null);
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
0:         public StringDataValue          getNullNationalVarchar(StringDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
0:                         return getNationalVarcharDataValue((String) null);
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
0:         public StringDataValue          getNullNationalLongvarchar(StringDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
0:                         return getNationalLongvarcharDataValue((String) null);
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
0:         public StringDataValue          getNullNClob(StringDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
0:                         return getNClobDataValue((String) null);
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         public UserDataValue            getNullObject(UserDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
0:                         return getDataValue((Object) null);
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         public RefDataValue             getNullRef(RefDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
0:                         return getDataValue((RowLocation) null);
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         public DateTimeDataValue        getNullDate(DateTimeDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
1:                     try
1:                     {
0:                         return getDataValue((Date) null);
1:                     }
1:                     catch( StandardException se)
1:                     {
1:                         if( SanityManager.DEBUG)
1:                         {
1:                             SanityManager.THROWASSERT( "Could not get a null date.", se);
1:                         }
1:                         return null;
1:                     }
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         public DateTimeDataValue        getNullTime(DateTimeDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
1:                     try
1:                     {
0:                         return getDataValue((Time) null);
1:                     }
1:                     catch( StandardException se)
1:                     {
1:                         if( SanityManager.DEBUG)
1:                         {
1:                             SanityManager.THROWASSERT( "Could not get a null time.", se);
1:                         }
1:                         return null;
1:                     }
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:         public DateTimeDataValue        getNullTimestamp(DateTimeDataValue dataValue)
1:         {
1:                 if (dataValue == null)
1:                 {
1:                     try
1:                     {
0:                         return getDataValue((Timestamp) null);
1:                     }
1:                     catch( StandardException se)
1:                     {
1:                         if( SanityManager.DEBUG)
1:                         {
1:                             SanityManager.THROWASSERT( "Could not get a null timestamp.", se);
1:                         }
1:                         return null;
1:                     }
1:                 }
1:                 else
1:                 {
1:                         dataValue.setToNull();
1:                         return dataValue;
1:                 }
1:         }
1: 
1:     public DateTimeDataValue getDateValue( String dateStr, boolean isJdbcEscape) throws StandardException
1:     {
1:         return new SQLDate( dateStr, isJdbcEscape, getLocaleFinder());
1:     } // end of getDateValue( String dateStr)
1: 
1:     public DateTimeDataValue getTimeValue( String timeStr, boolean isJdbcEscape) throws StandardException
1:     {
1:         return new SQLTime( timeStr, isJdbcEscape, getLocaleFinder());
1:     } // end of getTimeValue( String timeStr)
1: 
1:     public DateTimeDataValue getTimestampValue( String timestampStr, boolean isJdbcEscape) throws StandardException
1:     {
1:         return new SQLTimestamp( timestampStr, isJdbcEscape, getLocaleFinder());
1:     } // end of getTimestampValue( String timestampStr)
1: 
1: 
1:         // RESOLVE: This is here to find the LocaleFinder (i.e. the Database)
1:         // on first access. This is necessary because the Monitor can't find
1:         // the Database at boot time, because the Database is not done booting.
1:         // See LanguageConnectionFactory.
1:         private LocaleFinder getLocaleFinder()
1:         {
1:                 if (localeFinder == null)
1:                 {
0:                         DatabaseContext dc = (DatabaseContext) ContextService.getContext(DatabaseContext.CONTEXT_ID);
1:                         if( dc != null)
1:                             localeFinder = dc.getDatabase();
1:                 }
1: 
1:                 return localeFinder;
1:         }
1: }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:722a889
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.Monitor;
/////////////////////////////////////////////////////////////////////////
1:     public static DataValueDescriptor getNullDVDWithUCS_BASICcollation(
1:     int formatId) {
0: 
/////////////////////////////////////////////////////////////////////////
1:         case StoredFormatIds.ACCESS_HEAP_ROW_LOCATION_V1_ID: 
1:         // This is an specific implementation of RowLocation, known to be
1:         // a DTD.  
1:              return(
1:                  new org.apache.derby.impl.store.access.heap.HeapRowLocation());
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:099e28f
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * getXMLDataValue:
0:      * Get a SQL null value with XML type.
1:      * @return An XMLDataValue instance corresponding to a
0:      *  a NULL value.
1:      */
0:     public XMLDataValue getXMLDataValue()
0:     {
0:         return new XML();
0:     }
0: 
1:     /**
1:      * getXMLDataValue:
1:      * Get a null XML  value.  If a non-null XMLDataValue is
1:      * received then re-use that instance, otherwise create
1: 	 * a new one.
1:      * @param previous An XMLDataValue instance to re-use.
1:      * @return An XMLDataValue instance corresponding to a
1:      *  NULL value.  If an XMLDataValue was received, the
1:      *  returned XMLDataValue is the same instance as the one
1:      *  received, but the actual data has been set to a
1:      *  SQL null value.
1:      * @exception StandardException Thrown on error
1:      */
1:     public XMLDataValue getXMLDataValue(XMLDataValue previous)
0: 		throws StandardException
0:     {
1: 		return getNullXML(previous);
0:     }
0: 
1:     /**
1:      * getNullXML:
1:      * Get an XML with a SQL null value. If the supplied value is
1:      * null then get a new value, otherwise set it to null and return 
1:      * that value.
1:      * @param dataValue An XMLDataValue instance to re-use.
1:      * @return An XMLDataValue instance corresponding to a
1:      *  NULL value.  If an XMLDataValue was received, the
1:      *  returned XMLDataValue is the same instance as the one
1:      *  received, but the actual data has been set to null.
1:      */
1:     public XMLDataValue getNullXML(XMLDataValue dataValue)
0:     {
0:         if (dataValue == null)
0:             return getXMLDataValue();
0:         else {
0:             dataValue.setToNull();
0:             return dataValue;
0:         }
0:     }
0: 
commit:2dd0b6f
/////////////////////////////////////////////////////////////////////////
0:         /**
1:          * Implement the date SQL function: construct a SQL date from a string, number, or timestamp.
1:          *
1:          * @param operand Must be a date, a number, or a string convertible to a date.
1:          *
1:          * @exception StandardException standard error policy
0:          */
1:         public DateTimeDataValue getDate( DataValueDescriptor operand) throws StandardException
0:         {
1:                 return SQLDate.computeDateFunction( operand, this);
0:         }
0: 
0:         /**
1:          * Implement the timestamp SQL function: construct a SQL timestamp from a string, or timestamp.
1:          *
1:          * @param operand Must be a timestamp or a string convertible to a timestamp.
1:          *
1:          * @exception StandardException standard error policy
0:          */
1:         public DateTimeDataValue getTimestamp( DataValueDescriptor operand) throws StandardException
0:         {
1:                 return SQLTimestamp.computeTimestampFunction( operand, this);
0:         }
0: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.types;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.BitDataValue;
0: import org.apache.derby.iapi.types.DateTimeDataValue;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.types.UserDataValue;
0: import org.apache.derby.iapi.types.RefDataValue;
0: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import org.apache.derby.iapi.services.i18n.LocaleFinder;
0: 
0: import org.apache.derby.iapi.types.*;
0: 
0: import java.math.BigDecimal;
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
0: import java.sql.Types;
0: import java.util.Locale;
0: 
0: import org.apache.derby.iapi.db.DatabaseContext;
0: import org.apache.derby.iapi.services.context.ContextService;
0: 
0: /**
0:  * This class implements DataValueFactory.
0:  *
0:  * @see DataValueFactory
0:  */
0: public class DataValueFactoryImpl implements DataValueFactory
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0:         LocaleFinder localeFinder;
0: 
0:         /**
0:           *     Make the constructor public.
0:           *
0:           */
0:     public      DataValueFactoryImpl(LocaleFinder localeFinder)
0:         {
0:                 this.localeFinder = localeFinder;
0:         }
0: 
0:         /**
0:          * @see DataValueFactory#getDataValue
0:          *
0:          */
0:         public NumberDataValue getDataValue(int value)
0:         {
0:                 return new SQLInteger(value);
0:         }
0: 
0:         public NumberDataValue getDataValue(int value, NumberDataValue previous)
0:                                                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLInteger(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public NumberDataValue getDataValue(Integer value)
0:         {
0:                 if (value != null)
0:                         return new SQLInteger(value.intValue());
0:                 else
0:                         return new SQLInteger();
0:         }
0: 
0:         public NumberDataValue getDataValue(Integer value, NumberDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                 {
0:                         return getDataValue(value);
0:                 }
0: 
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public NumberDataValue getDataValue(char value)
0:         {
0:                 return new SQLInteger(value);
0:         }
0: 
0:         public NumberDataValue getDataValue(char value, NumberDataValue previous)
0:                                                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLInteger(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public NumberDataValue getDataValue(short value)
0:         {
0:                 return new SQLSmallint(value);
0:         }
0: 
0:         public NumberDataValue getDataValue(short value, NumberDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLSmallint(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public NumberDataValue getDataValue(Short value)
0:         {
0:                 if (value != null)
0:                         return new SQLSmallint(value.shortValue());
0:                 else
0:                         return new SQLSmallint();
0:         }
0: 
0:         public NumberDataValue getDataValue(Short value, NumberDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return getDataValue(value);
0: 
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public NumberDataValue getDataValue(byte value)
0:         {
0:                 return new SQLTinyint(value);
0:         }
0: 
0:         public NumberDataValue getDataValue(byte value, NumberDataValue previous)
0:                                 throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLTinyint(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public NumberDataValue getDataValue(Byte value)
0:         {
0:                 if (value != null)
0:                         return new SQLTinyint(value.byteValue());
0:                 else
0:                         return new SQLTinyint();
0:         }
0: 
0:         public NumberDataValue getDataValue(Byte value, NumberDataValue previous)
0:                                 throws StandardException
0:         {
0:                 if (previous == null)
0:                         return getDataValue(value);
0: 
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public NumberDataValue getDataValue(long value)
0:         {
0:                 return new SQLLongint(value);
0:         }
0: 
0:         public NumberDataValue getDataValue(long value, NumberDataValue previous)
0:                                 throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLLongint(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public NumberDataValue getDataValue(Long value)
0:         {
0:                 if (value != null)
0:                         return new SQLLongint(value.longValue());
0:                 else
0:                         return new SQLLongint();
0:         }
0: 
0:         public NumberDataValue getDataValue(Long value, NumberDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return getDataValue(value);
0: 
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public NumberDataValue getDataValue(float value)
0:                 throws StandardException
0:         {
0:                 return new SQLReal(value);
0:         }
0: 
0:         public NumberDataValue getDataValue(float value, NumberDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLReal(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public NumberDataValue getDataValue(Float value)
0:                 throws StandardException
0:         {
0:                 if (value != null)
0:                         return new SQLReal(value.floatValue());
0:                 else
0:                         return new SQLReal();
0:         }
0: 
0:         public NumberDataValue getDataValue(Float value, NumberDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return getDataValue(value);
0: 
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public NumberDataValue getDataValue(double value) throws StandardException
0:         {
0:                 return new SQLDouble(value);
0:         }
0: 
0:         public NumberDataValue getDataValue(double value, NumberDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLDouble(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public NumberDataValue getDataValue(Double value) throws StandardException
0:         {
0:                 if (value != null)
0:                         return new SQLDouble(value.doubleValue());
0:                 else
0:                         return new SQLDouble();
0:         }
0: 
0:         public NumberDataValue getDataValue(Double value, NumberDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return getDataValue(value);
0: 
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public NumberDataValue getDataValue(BigDecimal value)
0:         {
0:                 if (value != null)
0:                         return new SQLDecimal(value);
0:                 else
0:                         return new SQLDecimal();
0:         }
0: 
0:         public NumberDataValue getDataValue(BigDecimal value,
0:                                                                                 NumberDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return getDataValue(value);
0: 
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public NumberDataValue getDecimalDataValue(String value) throws StandardException
0:         {
0:                 if (value != null)
0:                         return new SQLDecimal(value);
0:                 else
0:                         return new SQLDecimal();
0:         }
0: 
0:         public NumberDataValue getDecimalDataValue(String value,
0:                                                                                                 NumberDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return getDecimalDataValue(value);
0: 
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public BooleanDataValue getDataValue(boolean value)
0:         {
0:                 return new SQLBoolean(value);
0:         }
0: 
0:         public BooleanDataValue getDataValue(boolean value,
0:                                                                                 BooleanDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLBoolean(value);
0:         
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public BooleanDataValue getDataValue(Boolean value)
0:         {
0:                 if (value != null)
0:                         return new SQLBoolean(value.booleanValue());
0:                 else
0:                         return new SQLBoolean();
0:         }
0: 
0:         public BooleanDataValue getDataValue(Boolean value,
0:                                                                                         BooleanDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return getDataValue(value);
0: 
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public BooleanDataValue getDataValue(BooleanDataValue value)
0:         {
0:                 if (value != null)
0:                         return value;
0:                 else
0:                         return new SQLBoolean();
0:         }
0: 
0:         public BitDataValue getBitDataValue(byte[] value) throws StandardException
0:         {
0:                 return new SQLBit(value);
0:         }
0: 
0:         public BitDataValue getBitDataValue(byte[] value, BitDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLBit(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public BitDataValue getVarbitDataValue(byte[] value)
0:         {
0:                 return new SQLVarbit(value);
0:         }
0: 
0:         public BitDataValue getVarbitDataValue(byte[] value, BitDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLVarbit(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0: 
0:         // LONGVARBIT
0: 
0:         public BitDataValue getLongVarbitDataValue(byte[] value) throws StandardException
0:         {
0:                 return new SQLLongVarbit(value);
0:         }
0: 
0:         public BitDataValue getLongVarbitDataValue(byte[] value, BitDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLLongVarbit(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         // BLOB
0:         public BitDataValue getBlobDataValue(byte[] value) throws StandardException
0:         {
0:                 return new SQLBlob(value);
0:         }
0: 
0:         public BitDataValue getBlobDataValue(byte[] value, BitDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLBlob(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         // CHAR
0:         public StringDataValue getCharDataValue(String value)
0:         {
0:                 return new SQLChar(value);
0:         }
0: 
0:         public StringDataValue getCharDataValue(String value,
0:                                                                                         StringDataValue previous)
0:                                                                                                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLChar(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public StringDataValue getVarcharDataValue(String value)
0:         {
0:                 return new SQLVarchar(value);
0:         }
0: 
0:         public StringDataValue getVarcharDataValue(String value,
0:                                                                                                 StringDataValue previous)
0:                                                                                                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLVarchar(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public StringDataValue getLongvarcharDataValue(String value)
0:         {
0:                 return new SQLLongvarchar(value);
0:         }
0: 
0:         public StringDataValue getClobDataValue(String value)
0:         {
0:                 return new SQLClob(value);
0:         }
0: 
0:         public StringDataValue getLongvarcharDataValue(String value,
0:                                                                                                         StringDataValue previous)
0:                                                                                                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLLongvarchar(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public StringDataValue getClobDataValue(String value, StringDataValue previous) throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLClob(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         //
0:         public StringDataValue getNationalCharDataValue(String value)
0:         {
0:                 return new SQLNationalChar(value, getLocaleFinder());
0:         }
0: 
0:         public StringDataValue getNationalCharDataValue(String value,
0:                                                                                         StringDataValue previous)
0:                                                                                                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLNationalChar(value, getLocaleFinder());
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public StringDataValue getNationalVarcharDataValue(String value)
0:         {
0:                 return new SQLNationalVarchar(value, getLocaleFinder());
0:         }
0: 
0:         public StringDataValue getNationalVarcharDataValue(String value,
0:                                                                                                 StringDataValue previous)
0:                                                                                                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLNationalVarchar(value, getLocaleFinder());
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public StringDataValue getNationalLongvarcharDataValue(String value)
0:         {
0:                 return new SQLNationalLongvarchar(value, getLocaleFinder());
0:         }
0: 
0:         public StringDataValue getNationalLongvarcharDataValue(String value,
0:                                                                                                         StringDataValue previous)
0:                                                                                                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLNationalLongvarchar(value, getLocaleFinder());
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public StringDataValue getNClobDataValue(String value)
0:         {
0:                 return new SQLNClob(value, getLocaleFinder());
0:         }
0: 
0:         public StringDataValue getNClobDataValue(String value, StringDataValue previous)
0:             throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLNClob(value, getLocaleFinder());
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public DateTimeDataValue getDataValue(Date value) throws StandardException
0:         {
0:                 return new SQLDate(value);
0:         }
0: 
0:         public DateTimeDataValue getDataValue(Date value,
0:                                                                                         DateTimeDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLDate(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public DateTimeDataValue getDataValue(Time value) throws StandardException
0:         {
0:                 return new SQLTime(value);
0:         }
0: 
0:         public DateTimeDataValue getDataValue(Time value,
0:                                                                                         DateTimeDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLTime(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public DateTimeDataValue getDataValue(Timestamp value) throws StandardException
0:         {
0:                 return new SQLTimestamp(value);
0:         }
0: 
0:         public DateTimeDataValue getDataValue(Timestamp value,
0:                                                                                         DateTimeDataValue previous)
0:                         throws StandardException
0:         {
0:                 if (previous == null)
0:                         return new SQLTimestamp(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public DateTimeDataValue getTimestamp( DataValueDescriptor date, DataValueDescriptor time) throws StandardException
0:         {
0:             return new SQLTimestamp( date, time);
0:         }
0: 
0:         public UserDataValue getDataValue(Object value)
0:         {
0:                 return new UserType(value);
0:         }
0: 
0:         public UserDataValue getDataValue(Object value,
0:                                                                                 UserDataValue previous)
0:         {
0:                 if (previous == null)
0:                         return new UserType(value);
0:                 ((UserType) previous).setValue(value);
0:                 return previous;
0:         }
0: 
0:         public RefDataValue getDataValue(RowLocation value)
0:         {
0:                 return new SQLRef(value);
0:         }
0: 
0:         public RefDataValue getDataValue(RowLocation value, RefDataValue previous)
0:         {
0:                 if (previous == null)
0:                         return new SQLRef(value);
0:                 previous.setValue(value);
0:                 return previous;
0:         }
0: 
0:         public NumberDataValue          getNullInteger(NumberDataValue dataValue) 
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return new SQLInteger();
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public NumberDataValue getNullShort(NumberDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return new SQLSmallint();
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public NumberDataValue getNullLong(NumberDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return new SQLLongint();
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public NumberDataValue getNullByte(NumberDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return new SQLTinyint();
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public NumberDataValue getNullFloat(NumberDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return new SQLReal();
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public NumberDataValue getNullDouble(NumberDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return new SQLDouble();
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public NumberDataValue getNullBigDecimal(NumberDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return new SQLDecimal();
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public BooleanDataValue getNullBoolean(BooleanDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return new SQLBoolean();
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public BitDataValue             getNullBit(BitDataValue dataValue) throws StandardException
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return getBitDataValue((byte[]) null);
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0: 
0:         public BitDataValue             getNullVarbit(BitDataValue dataValue) throws StandardException
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return getVarbitDataValue((byte[]) null);
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         // LONGVARBIT
0:         public BitDataValue getNullLongVarbit(BitDataValue dataValue) throws StandardException
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return getLongVarbitDataValue((byte[]) null);
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         /// BLOB
0:         public BitDataValue getNullBlob(BitDataValue dataValue) throws StandardException
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return getBlobDataValue((byte[]) null);
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         // CHAR
0:         public StringDataValue          getNullChar(StringDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return getCharDataValue((String) null);
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public StringDataValue          getNullVarchar(StringDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return getVarcharDataValue((String) null);
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public StringDataValue          getNullLongvarchar(StringDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return getLongvarcharDataValue((String) null);
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public StringDataValue          getNullClob(StringDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return getClobDataValue((String) null);
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public StringDataValue          getNullNationalChar(StringDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return getNationalCharDataValue((String) null);
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public StringDataValue          getNullNationalVarchar(StringDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return getNationalVarcharDataValue((String) null);
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public StringDataValue          getNullNationalLongvarchar(StringDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return getNationalLongvarcharDataValue((String) null);
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public StringDataValue          getNullNClob(StringDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return getNClobDataValue((String) null);
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public UserDataValue            getNullObject(UserDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return getDataValue((Object) null);
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public RefDataValue             getNullRef(RefDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                         return getDataValue((RowLocation) null);
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public DateTimeDataValue        getNullDate(DateTimeDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                     try
0:                     {
0:                         return getDataValue((Date) null);
0:                     }
0:                     catch( StandardException se)
0:                     {
0:                         if( SanityManager.DEBUG)
0:                         {
0:                             SanityManager.THROWASSERT( "Could not get a null date.", se);
0:                         }
0:                         return null;
0:                     }
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public DateTimeDataValue        getNullTime(DateTimeDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                     try
0:                     {
0:                         return getDataValue((Time) null);
0:                     }
0:                     catch( StandardException se)
0:                     {
0:                         if( SanityManager.DEBUG)
0:                         {
0:                             SanityManager.THROWASSERT( "Could not get a null time.", se);
0:                         }
0:                         return null;
0:                     }
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:         public DateTimeDataValue        getNullTimestamp(DateTimeDataValue dataValue)
0:         {
0:                 if (dataValue == null)
0:                 {
0:                     try
0:                     {
0:                         return getDataValue((Timestamp) null);
0:                     }
0:                     catch( StandardException se)
0:                     {
0:                         if( SanityManager.DEBUG)
0:                         {
0:                             SanityManager.THROWASSERT( "Could not get a null timestamp.", se);
0:                         }
0:                         return null;
0:                     }
0:                 }
0:                 else
0:                 {
0:                         dataValue.setToNull();
0:                         return dataValue;
0:                 }
0:         }
0: 
0:     public DateTimeDataValue getDateValue( String dateStr, boolean isJdbcEscape) throws StandardException
0:     {
0:         return new SQLDate( dateStr, isJdbcEscape, getLocaleFinder());
0:     } // end of getDateValue( String dateStr)
0: 
0:     public DateTimeDataValue getTimeValue( String timeStr, boolean isJdbcEscape) throws StandardException
0:     {
0:         return new SQLTime( timeStr, isJdbcEscape, getLocaleFinder());
0:     } // end of getTimeValue( String timeStr)
0: 
0:     public DateTimeDataValue getTimestampValue( String timestampStr, boolean isJdbcEscape) throws StandardException
0:     {
0:         return new SQLTimestamp( timestampStr, isJdbcEscape, getLocaleFinder());
0:     } // end of getTimestampValue( String timestampStr)
0: 
0: 
0:         // RESOLVE: This is here to find the LocaleFinder (i.e. the Database)
0:         // on first access. This is necessary because the Monitor can't find
0:         // the Database at boot time, because the Database is not done booting.
0:         // See LanguageConnectionFactory.
0:         private LocaleFinder getLocaleFinder()
0:         {
0:                 if (localeFinder == null)
0:                 {
0:                         DatabaseContext dc = (DatabaseContext) ContextService.getContext(DatabaseContext.CONTEXT_ID);
0:                         if( dc != null)
0:                             localeFinder = dc.getDatabase();
0:                 }
0: 
0:                 return localeFinder;
0:         }
0: }
============================================================================