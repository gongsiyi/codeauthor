1:bb29639: /**
1:bb29639:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.jdbapi.XATest
1:bb29639:  *  
1:bb29639:  * Licensed to the Apache Software Foundation (ASF) under one
1:bb29639:  * or more contributor license agreements.  See the NOTICE file
1:bb29639:  * distributed with this work for additional information
1:bb29639:  * regarding copyright ownership.  The ASF licenses this file
1:bb29639:  * to you under the Apache License, Version 2.0 (the
1:bb29639:  * "License"); you may not use this file except in compliance
1:bb29639:  * with the License.  You may obtain a copy of the License at
1:bb29639:  *
1:bb29639:  *   http://www.apache.org/licenses/LICENSE-2.0
1:bb29639:  *
1:bb29639:  * Unless required by applicable law or agreed to in writing,
1:bb29639:  * software distributed under the License is distributed on an
1:bb29639:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:bb29639:  * KIND, either express or implied.  See the License for the
1:bb29639:  * specific language governing permissions and limitations
1:bb29639:  * under the License.
23:6e10422:  */
1:175a740: 
1:6e10422: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:3fe2281: 
1:175a740: 
1:5b78c4e: import java.sql.CallableStatement;
1:6e10422: import java.sql.Connection;
1:6e10422: import java.sql.PreparedStatement;
1:6e10422: import java.sql.ResultSet;
1:6e10422: import java.sql.SQLException;
1:6e10422: import java.sql.Statement;
1:175a740: import java.util.ArrayList;
1:6e10422: import javax.sql.XAConnection;
1:6e10422: import javax.sql.XADataSource;
1:6e10422: import javax.transaction.xa.XAException;
1:6e10422: import javax.transaction.xa.XAResource;
1:6e10422: import javax.transaction.xa.Xid;
1:88b727b: import static junit.framework.Assert.fail;
1:bb29639: import junit.framework.Test;
1:88b727b: import org.apache.derby.shared.common.reference.SQLState;
1:88b727b: import org.apache.derbyTesting.functionTests.util.DeadlockWatchdog;
1:bb29639: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:88b727b: import static org.apache.derbyTesting.junit.BaseJDBCTestCase.assertSQLState;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:bb29639: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:3fe2281: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:bb29639: import org.apache.derbyTesting.junit.J2EEDataSource;
1:bb29639: import org.apache.derbyTesting.junit.JDBC;
1:88b727b: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:bb29639: import org.apache.derbyTesting.junit.TestConfiguration;
1:3fe2281: import org.apache.derbyTesting.junit.Utilities;
1:bb29639: import org.apache.derbyTesting.junit.XATestUtil;
1:175a740: 
1:bb29639: public class XATest extends BaseJDBCTestCase {
1:88b727b:     //create own policy file
1:88b727b:     private static final String POLICY_FILE_NAME =
1:88b727b:             "org/apache/derbyTesting/functionTests/tests/jdbcapi/XATest.policy";
1:175a740: 
1:3fe2281:     public static final String LOCKTIMEOUT="40XL1";
1:3fe2281:     
1:bb29639:     public XATest(String name) {
1:bb29639:         super(name);
1:0bf3bf8: 
1:175a740:     }
1:175a740: 
1:88b727b:     /**
1:6e10422:      * A single connection and 1 phase commit.
1:bb29639:      * 
1:6e10422:      * 
1:bb29639:      * Original "SQL" from xaSimplePositive.sql <code>
1:6e10422:      xa_connect ;
1:6e10422:      xa_start xa_noflags 0;
1:4388f15:      xa_getconnection;
1:6e10422:      drop table foo;
1:6e10422:      create table foo (a int);
1:6e10422:      insert into foo values (0);
5:6e10422:      select * from foo;
1:6e10422:      run resource '/org/apache/derbyTesting/functionTests/tests/store/global_xactTable.view';
1:6e10422:      select * from global_xactTable where gxid is not null order by gxid;
1:6e10422:      xa_end xa_success 0;
1:6e10422:      xa_commit xa_1phase 0;
1:175a740:      
1:6e10422:      xa_datasource 'wombat' shutdown;
2:6e10422:      </code>
1:bb29639:      * 
1:bb29639:      * @throws SQLException
1:3bb8c05:      * @throws XAException
1:bb29639:      * @throws XAException
1:3bb8c05:      */
1:bb29639:     public void testSingleConnectionOnePhaseCommit() throws SQLException,
1:bb29639:             XAException {
1:3bb8c05: 
1:bb29639:         XADataSource xads = J2EEDataSource.getXADataSource();
1:bb29639:         J2EEDataSource.setBeanProperty(xads, "databaseName", "wombat");
1:3bb8c05: 
1:bb29639:         XAConnection xac = xads.getXAConnection();
1:175a740: 
1:bb29639:         XAResource xar = xac.getXAResource();
1:175a740: 
1:bb29639:         Xid xid = XATestUtil.getXid(0, 32, 46);
1:175a740: 
1:bb29639:         xar.start(xid, XAResource.TMNOFLAGS);
1:4f2355d: 
1:bb29639:         Connection conn = xac.getConnection();
1:bb29639:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, conn.getHoldability());
1:1128268: 
1:bb29639:         Statement s = conn.createStatement();
1:bb29639:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, s
1:bb29639:                 .getResultSetHoldability());
1:1128268: 
1:bb29639:         s.execute("create table foo (a int)");
1:bb29639:         s.executeUpdate("insert into foo values (0)");
1:1128268: 
1:bb29639:         ResultSet rs = s.executeQuery("select * from foo");
1:bb29639:         JDBC.assertDrainResults(rs, 1);
1:1128268: 
1:bb29639:         String[][] expectedRows = { { "(0", "ACTIVE", "false", "APP",
1:bb29639:                 "UserTransaction" } };
1:0bf3bf8: 
1:bb29639:         XATestUtil.checkXATransactionView(conn, expectedRows);
1:0bf3bf8: 
1:bb29639:         s.close();
1:bb29639:         xar.end(xid, XAResource.TMSUCCESS);
1:bb29639: 
1:bb29639:         // 1 phase commit
1:bb29639:         xar.commit(xid, true);
1:bb29639: 
1:bb29639:         conn.close();
1:bb29639:         xac.close();
1:bb29639: 
1:3bb8c05:     }
1:2c70a31: 
1:4388f15:     /*
1:6e10422:      * Two interleaving transaction and prepare/commit prepare/rollback.
1:3bb8c05:      * 
1:6e10422:      * (original test said two connections but only one connection was opened)
1:bb29639:      * 
1:bb29639:      * <code> xa_datasource 'wombat'; xa_connect user 'sku' password 'testxa' ;
1:bb29639:      * 
1:bb29639:      * xa_start xa_noflags 1; xa_getconnection; insert into APP.foo values (1);
1:bb29639:      * xa_end xa_suspend 1;
1:bb29639:      * 
1:bb29639:      * xa_start xa_noflags 2; insert into APP.foo values (2); xa_end xa_suspend
1:bb29639:      * 2;
1:bb29639:      * 
1:bb29639:      * xa_start xa_resume 1; insert into APP.foo values (3); xa_end xa_suspend
1:bb29639:      * 1;
1:bb29639:      * 
1:bb29639:      * xa_start xa_resume 2; insert into APP.foo values (4); select * from
1:bb29639:      * APP.global_xactTable where gxid is not null order by gxid; -- this
1:bb29639:      * prepare won't work since transaction 1 has been suspended - XA_PROTO
1:bb29639:      * xa_prepare 1;
1:bb29639:      * 
1:bb29639:      * select * from APP.global_xactTable where gxid is not null order by gxid;
1:bb29639:      * xa_end xa_success 2; -- this assumes a resume xa_end xa_success 1;
1:bb29639:      * xa_prepare 1; xa_prepare 2; -- both transactions should be prepared
1:bb29639:      * select * from APP.global_xactTable where gxid is not null order by gxid; --
1:bb29639:      * NOTE: The following call to "xa_recover xa_startrscan" is apt to --
1:bb29639:      * return the result set rows in reverse order when changes to -- the Derby
1:bb29639:      * engine affect the number of transactions that it takes -- to create a
1:bb29639:      * database. The transactions are stored in a hash table -- based on a
1:bb29639:      * global and local id, and when the number of transactions -- changes, the
1:bb29639:      * (internal) local id can change, which may lead to a -- change in the
1:bb29639:      * result set order. This order is determined by the -- JVM's hashing
1:bb29639:      * algorithm. Examples of changes to the engine that -- can affect this
1:bb29639:      * include ones that cause more commits or that -- change the amount of data
1:bb29639:      * being stored, such as changes to the -- metadata statements (which is
1:bb29639:      * what prompted this explanation in -- the first place). Ultimately, the
1:bb29639:      * problem is that there is no -- way to order the return values from
1:bb29639:      * "xa_recover" since it is an -- ij internal statement, not SQL...
1:bb29639:      * xa_recover xa_startrscan; xa_recover xa_noflags;
1:bb29639:      * 
1:bb29639:      * xa_commit xa_2Phase 1; xa_rollback 2; -- check results xa_start
1:bb29639:      * xa_noflags 3; select * from APP.global_xactTable where gxid is not null
1:bb29639:      * order by gxid; select * from APP.foo; xa_end xa_success 3;
1:bb29639:      * 
1:bb29639:      * xa_prepare 3; -- should fail with XA_NOTA because we prepared a read only
1:bb29639:      * transaction xa_commit xa_1Phase 3; disconnect; </code>
1:4388f15:      */
1:bb29639:     public void testInterleavingTransactions() throws SQLException, XAException {
1:5b78c4e:         Statement preStatement = getConnection().createStatement();
1:5b78c4e:         preStatement.execute("create table fooInterleaving (a int)");
1:5b78c4e:         preStatement.execute("insert into fooInterleaving values (0)");
1:5b78c4e:         preStatement.close();
1:5b78c4e:         
1:bb29639:         XADataSource xads = J2EEDataSource.getXADataSource();
1:bb29639: 
1:bb29639:         XAConnection xac = xads.getXAConnection("sku", "testxa");
1:bb29639:         XAResource xar = xac.getXAResource();
1:bb29639: 
1:bb29639:         Xid xid1 = XATestUtil.getXid(1, 93, 18);
1:bb29639:         Xid xid2 = XATestUtil.getXid(2, 45, 77);
1:bb29639: 
1:bb29639:         xar.start(xid1, XAResource.TMNOFLAGS);
1:bb29639: 
1:bb29639:         Connection conn = xac.getConnection();
1:bb29639: 
1:bb29639:         Statement s = conn.createStatement();
1:5b78c4e:         s.executeUpdate("insert into APP.fooInterleaving values (1)");
1:bb29639:         xar.end(xid1, XAResource.TMSUSPEND);
1:bb29639: 
1:bb29639:         xar.start(xid2, XAResource.TMNOFLAGS);
1:5b78c4e:         s.executeUpdate("insert into APP.fooInterleaving values (2)");
1:bb29639:         xar.end(xid2, XAResource.TMSUSPEND);
1:bb29639: 
1:bb29639:         xar.start(xid1, XAResource.TMRESUME);
1:5b78c4e:         s.executeUpdate("insert into APP.fooInterleaving values (3)");
1:bb29639:         xar.end(xid1, XAResource.TMSUSPEND);
1:bb29639: 
1:bb29639:         xar.start(xid2, XAResource.TMRESUME);
1:5b78c4e:         s.executeUpdate("insert into APP.fooInterleaving values (4)");
1:bb29639: 
1:bb29639:         String[][] expectedRows = {
1:bb29639:                 { "(1", "ACTIVE", "false", "SKU", "UserTransaction" },
1:bb29639:                 { "(2", "ACTIVE", "false", "SKU", "UserTransaction" } };
1:bb29639: 
1:bb29639:         XATestUtil.checkXATransactionView(conn, expectedRows);
1:bb29639: 
1:bb29639:         // this prepare won't work since
1:bb29639:         // transaction 1 has been suspended - XA_PROTO
1:175a740:         try {
2:6e10422:             xar.prepare(xid1);
1:bb29639:             fail("FAIL - prepare on suspended transaction");
18:6e10422:         } catch (XAException e) {
1:bb29639:             if (e.errorCode != XAException.XAER_PROTO)
1:bb29639:                 XATestUtil.dumpXAException(
1:bb29639:                         "FAIL - prepare on suspended transaction", e);
1:bb29639: 
1:175a740:         }
1:bb29639: 
1:bb29639:         // check it was not prepared
1:bb29639: 
1:bb29639:         XATestUtil.checkXATransactionView(conn, expectedRows);
1:bb29639: 
1:bb29639:         xar.end(xid2, XAResource.TMSUCCESS);
1:bb29639: 
1:bb29639:         xar.end(xid1, XAResource.TMSUCCESS);
1:bb29639: 
1:bb29639:         xar.prepare(xid1);
1:bb29639:         xar.prepare(xid2);
1:bb29639: 
1:bb29639:         // both should be prepared.
1:bb29639:         expectedRows = new String[][] {
1:bb29639:                 { "(1", "PREPARED", "false", "SKU", "UserTransaction" },
1:bb29639:                 { "(2", "PREPARED", "false", "SKU", "UserTransaction" } };
1:bb29639: 
1:bb29639:         XATestUtil.checkXATransactionView(conn, expectedRows);
1:bb29639: 
1:bb29639:         Xid[] recoveredStart = xar.recover(XAResource.TMSTARTRSCAN);
1:bb29639:         assertEquals(2, recoveredStart.length);
1:bb29639:         Xid[] recovered = xar.recover(XAResource.TMNOFLAGS);
1:bb29639:         assertEquals(0, recovered.length);
1:bb29639:         Xid[] recoveredEnd = xar.recover(XAResource.TMENDRSCAN);
1:bb29639:         assertEquals(0, recoveredEnd.length);
1:bb29639: 
1:bb29639:         for (int i = 0; i < recoveredStart.length; i++) {
1:bb29639:             Xid xid = recoveredStart[i];
1:bb29639:             if (xid.getFormatId() == 1) {
1:bb29639:                 // commit 1 with 2pc
1:bb29639:                 xar.commit(xid, false);
1:bb29639:             } else if (xid.getFormatId() == 2) {
1:bb29639:                 xar.rollback(xid);
1:bb29639:             } else {
1:bb29639:                 fail("FAIL: unknown xact");
1:bb29639:             }
1:bb29639:         }
1:bb29639: 
1:bb29639:         // check the results
1:bb29639:         Xid xid3 = XATestUtil.getXid(3, 2, 101);
1:bb29639:         xar.start(xid3, XAResource.TMNOFLAGS);
1:bb29639:         expectedRows = new String[][] { { "(3", "IDLE", "NULL", "SKU",
1:bb29639:                 "UserTransaction" } };
1:bb29639:         XATestUtil.checkXATransactionView(conn, expectedRows);
1:5b78c4e:         ResultSet rs = s.executeQuery("select * from APP.fooInterleaving");
1:bb29639:         expectedRows = new String[][] { { "0" }, { "1" }, { "3" } };
1:bb29639:         JDBC.assertFullResultSet(rs, expectedRows);
1:bb29639: 
1:bb29639:         rs.close();
1:bb29639:         xar.end(xid3, XAResource.TMSUCCESS);
1:bb29639: 
1:bb29639:         int pr = xar.prepare(xid3);
1:bb29639:         if (pr != XAResource.XA_RDONLY)
1:bb29639:             fail("FAIL - prepare on read only xact returned " + pr);
1:bb29639: 
1:bb29639:         try {
1:bb29639:             xar.commit(xid3, true);
1:bb29639:             fail("FAIL - 2pc commit on read-only xact");
1:bb29639:         } catch (XAException e) {
1:bb29639:             if (e.errorCode != XAException.XAER_NOTA)
1:bb29639:                 throw e;
1:bb29639:         }
1:bb29639: 
1:bb29639:         s.close();
1:bb29639:         conn.close();
1:bb29639:         xac.close();
1:bb29639: 
1:0bf3bf8:     }
1:0bf3bf8: 
1:3bb8c05:     /**
1:bb29639:      * Tests on INIT STATE (no tr Original SQL from xaStateTran.sql. <code>
1:0bf3bf8: 
1:6e10422:      -- the following should error XAER_NOTA
1:6e10422:      xa_start xa_join 11;
1:6e10422:      -- the following should error XAER_NOTA
1:6e10422:      xa_start xa_resume 11;
1:6e10422:      -- the following should error XAER_NOTA
1:6e10422:      xa_end xa_success 11;
1:6e10422:      -- the following should error XAER_NOTA
1:6e10422:      xa_end xa_fail 11;
1:6e10422:      -- the following should error XAER_NOTA
1:6e10422:      xa_end xa_suspend 11;
1:6e10422:      -- the following should error XAER_NOTA
1:6e10422:      xa_prepare 11;
1:6e10422:      -- the following should error XAER_NOTA
1:6e10422:      xa_commit xa_1phase 11;
1:6e10422:      -- the following should error XAER_NOTA
1:6e10422:      xa_commit xa_2phase 11;
1:6e10422:      -- the following should error XAER_NOTA
1:6e10422:      xa_rollback 11;
1:6e10422:      -- the following should error XAER_NOTA
1:6e10422:      xa_forget 11;
1:6e10422:      </code>
1:e07f9c9:      */
1:bb29639:     public void testNoTransaction() throws SQLException, XAException {
1:bb29639:         XADataSource xads = J2EEDataSource.getXADataSource();
1:bb29639:         XAConnection xac = xads.getXAConnection();
1:bb29639:         XAResource xar = xac.getXAResource();
1:bb29639: 
1:bb29639:         Xid xid11 = XATestUtil.getXid(11, 3, 128);
1:bb29639: 
1:4388f15:         try {
1:bb29639:             xar.start(xid11, XAResource.TMJOIN);
1:6e10422:         } catch (XAException e) {
1:bb29639:             if (e.errorCode != XAException.XAER_NOTA)
1:bb29639:                 throw e;
1:bb29639:         }
1:bb29639: 
1:bb29639:         try {
1:bb29639:             xar.start(xid11, XAResource.TMRESUME);
1:bb29639:         } catch (XAException e) {
1:bb29639:             if (e.errorCode != XAException.XAER_NOTA)
1:bb29639:                 throw e;
1:bb29639:         }
1:bb29639: 
1:bb29639:         try {
1:bb29639:             xar.end(xid11, XAResource.TMSUCCESS);
1:bb29639:         } catch (XAException e) {
1:bb29639:             if (e.errorCode != XAException.XAER_NOTA)
1:bb29639:                 throw e;
1:bb29639:         }
1:bb29639:         try {
1:bb29639:             xar.end(xid11, XAResource.TMFAIL);
1:bb29639:         } catch (XAException e) {
1:bb29639:             if (e.errorCode != XAException.XAER_NOTA)
1:bb29639:                 throw e;
1:bb29639:         }
1:bb29639: 
1:bb29639:         try {
1:bb29639:             xar.end(xid11, XAResource.TMSUSPEND);
1:bb29639:         } catch (XAException e) {
1:bb29639:             if (e.errorCode != XAException.XAER_NOTA)
1:bb29639:                 throw e;
1:bb29639:         }
1:bb29639: 
1:bb29639:         try {
1:bb29639:             xar.prepare(xid11);
1:bb29639:         } catch (XAException e) {
1:bb29639:             if (e.errorCode != XAException.XAER_NOTA)
1:bb29639:                 throw e;
1:bb29639:         }
1:bb29639:         try {
1:bb29639:             xar.commit(xid11, false);
1:bb29639:         } catch (XAException e) {
1:bb29639:             if (e.errorCode != XAException.XAER_NOTA)
1:bb29639:                 throw e;
1:bb29639:         }
1:bb29639:         try {
1:bb29639:             xar.commit(xid11, true);
1:bb29639:         } catch (XAException e) {
1:bb29639:             if (e.errorCode != XAException.XAER_NOTA)
1:bb29639:                 throw e;
1:bb29639:         }
1:bb29639:         try {
1:bb29639:             xar.rollback(xid11);
1:bb29639:         } catch (XAException e) {
1:bb29639:             if (e.errorCode != XAException.XAER_NOTA)
1:bb29639:                 throw e;
1:bb29639:         }
1:bb29639:         try {
1:bb29639:             xar.forget(xid11);
1:bb29639:         } catch (XAException e) {
1:bb29639:             if (e.errorCode != XAException.XAER_NOTA)
1:bb29639:                 throw e;
1:0bf3bf8:         }
1:0bf3bf8:     }
1:bb29639: 
1:bb29639:     /**
1:6e10422:      * Morph a connection between local anf global transactions.
1:6e10422:      */
1:bb29639:     public void testMorph() throws SQLException, XAException {
1:5b78c4e:         Statement preStatement = getConnection().createStatement();
1:5b78c4e:         preStatement.execute("create table fooMorph (a int)");
1:5b78c4e:         preStatement.executeUpdate("insert into APP.fooMorph values (0)");
1:5b78c4e:         preStatement.executeUpdate("insert into APP.fooMorph values (1)");
1:5b78c4e:         preStatement.executeUpdate("insert into APP.fooMorph values (2)");
1:5b78c4e:         preStatement.executeUpdate("insert into APP.fooMorph values (3)");
1:5b78c4e:         preStatement.executeUpdate("insert into APP.fooMorph values (4)");
1:5b78c4e:         preStatement.close();
1:5b78c4e:         
1:bb29639:         XADataSource xads = J2EEDataSource.getXADataSource();
1:bb29639:         XAConnection xac = xads.getXAConnection();
1:bb29639: 
1:bb29639:         XAResource xar = xac.getXAResource();
1:bb29639: 
1:bb29639:         Connection conn = xac.getConnection();
1:bb29639: 
1:bb29639:         /*
1:bb29639:          * autocommit off; insert into foo values (1); select * from
1:bb29639:          * global_xactTable where gxid is not null order by gxid,username;
1:bb29639:          * commit;
1:bb29639:          */
1:bb29639:         conn.setAutoCommit(false);
1:bb29639:         Statement s = conn.createStatement();
1:5b78c4e:         s.executeUpdate("insert into APP.fooMorph values (2001)");
1:bb29639:         // no rows expected
1:bb29639:         XATestUtil.checkXATransactionView(conn, null);
1:bb29639:         conn.commit();
1:5b78c4e: 
1:bb29639:         /*
1:bb29639:          * autocommit on; insert into foo values (2); select * from
1:bb29639:          * global_xactTable where gxid is not null order by gxid,username;
1:bb29639:          * 
1:bb29639:          */
1:bb29639: 
1:bb29639:         conn.setAutoCommit(true);
1:5b78c4e:         s.executeUpdate("insert into APP.fooMorph values (2002)");
1:bb29639:         XATestUtil.checkXATransactionView(conn, null);
1:bb29639: 
1:bb29639:         /*
1:bb29639:          * -- morph the connection to a global transaction xa_start xa_noflags
1:bb29639:          * 1; select * from global_xactTable where gxid is not null order by
1:bb29639:          * gxid,username; insert into foo values (3);
1:bb29639:          */
1:bb29639: 
1:bb29639:         Xid xid = XATestUtil.getXid(1001, 66, 13);
1:bb29639:         xar.start(xid, XAResource.TMNOFLAGS);
1:bb29639:         String[][] expectedRows = { { "(1", "IDLE", "NULL", "APP",
1:bb29639:                 "UserTransaction" } };
1:bb29639:         XATestUtil.checkXATransactionView(conn, expectedRows);
1:5b78c4e:         s.executeUpdate("insert into APP.fooMorph values (2003)");
1:bb29639: 
1:bb29639:         /*
1:bb29639:          * -- disallowed commit; -- disallowed rollback; -- disallowed
1:bb29639:          * autocommit on; -- OK autocommit off;
1:bb29639:          */
1:bb29639:         try {
1:bb29639:             conn.commit();
1:bb29639:             fail("FAIL: commit allowed in global xact");
1:bb29639:         } catch (SQLException e) {
1:bb29639:         }
1:bb29639: 
1:4388f15:         try {
4:6e10422:             conn.rollback();
1:bb29639:             fail("FAIL: roll back allowed in global xact");
1:bb29639:         } catch (SQLException e) {
1:bb29639:         }
1:bb29639:         try {
1:bb29639:             conn.setAutoCommit(true);
1:bb29639:             fail("FAIL: setAutoCommit(true) allowed " + "in global xact");
1:bb29639:         } catch (SQLException e) {
1:bb29639:         }
1:bb29639:         try {
1:bb29639:             conn.setSavepoint();
1:bb29639:             fail("FAIL: setSavepoint() allowed in global xact");
1:bb29639:         } catch (SQLException e) {
1:bb29639:         }
1:bb29639:         try {
1:bb29639:             conn.setSavepoint("badsavepoint");
1:bb29639:             fail("FAIL: setSavepoint(String) allowed in " + "global xact");
1:bb29639:         } catch (SQLException e) {
1:bb29639:         }
1:bb29639: 
1:bb29639:         conn.setAutoCommit(false);
1:bb29639: 
1:bb29639:         // s was created in local mode so it has holdibilty
1:bb29639:         // set, will execute but ResultSet will have close on commit
1:bb29639: 
1:bb29639:         // DERBY-1158 query with holdable statement
1:5b78c4e:         s.executeQuery("select * from APP.fooMorph where A >= 2000").close();
1:bb29639:         s.close();
1:bb29639: 
1:bb29639:         // statement created in global xact is CLOSE_CURSORS_AT_COMMIT
1:bb29639:         s = conn.createStatement();
1:bb29639:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, s
1:bb29639:                 .getResultSetHoldability());
1:bb29639: 
1:bb29639:         /*
1:bb29639:          * select * from foo; xa_end xa_success 1; xa_prepare 1;
1:bb29639:          */
1:5b78c4e:         ResultSet rs = s.executeQuery("select * from APP.fooMorph where A >= 2000");
1:bb29639:         expectedRows = new String[][] { { "2001" }, { "2002" }, { "2003" } };
1:bb29639: 
1:bb29639:         rs.close();
1:bb29639: 
1:bb29639:         xar.end(xid, XAResource.TMSUCCESS);
1:bb29639:         xar.prepare(xid);
1:bb29639: 
1:bb29639:         /*
1:bb29639:          * -- dup id xa_start xa_noflags 1;
1:bb29639:          */
1:bb29639:         try {
1:bb29639:             xar.start(xid, XAResource.TMNOFLAGS);
1:bb29639:             fail("FAIL - start with duplicate XID");
1:bb29639:         } catch (XAException e) {
1:bb29639:             if (e.errorCode != XAException.XAER_DUPID)
1:bb29639:                 throw e;
1:bb29639:         }
1:bb29639: 
1:bb29639:         /*
1:bb29639:          * xa_start xa_noflags 2; -- still should disallow autommit; autocommit
1:bb29639:          * on; -- still should disallow commit and rollback commit; rollback;
1:bb29639:          * select * from global_xactTable where gxid is not null order by
1:bb29639:          * gxid,username; xa_end xa_suspend 2;
1:bb29639:          */
1:bb29639: 
1:bb29639:         Xid xid2 = XATestUtil.getXid(1002, 23, 3);
1:bb29639:         xar.start(xid2, XAResource.TMNOFLAGS);
1:bb29639:         try {
1:2d08e7a:             conn.commit();
1:bb29639:             fail("FAIL: commit allowed in global xact");
1:bb29639:         } catch (SQLException e) {
1:bb29639:         }
1:bb29639:         try {
1:bb29639:             conn.rollback();
1:bb29639:             fail("FAIL: roll back allowed in global xact");
1:bb29639:         } catch (SQLException e) {
1:bb29639:         }
1:bb29639:         try {
1:bb29639:             conn.setAutoCommit(true);
1:bb29639:             fail("FAIL: setAutoCommit(true) allowed in global xact");
1:bb29639:         } catch (SQLException e) {
1:bb29639:         }
1:bb29639:         conn.setAutoCommit(false);
1:1a7cb26: 
1:bb29639:         xar.end(xid2, XAResource.TMSUSPEND);
1:1a7cb26: 
1:bb29639:         /*
1:bb29639:          * -- get local connection again xa_getconnection;
1:bb29639:          * 
1:bb29639:          * insert into foo values (5); -- autocommit should be on by default;
1:bb29639:          * commit;
1:bb29639:          * 
1:bb29639:          * autocommit off; insert into foo values (6); -- commit and rollback is
1:bb29639:          * allowed on local connection rollback;
1:bb29639:          * 
1:bb29639:          * insert into foo values (6); commit;
1:bb29639:          */
1:bb29639:         conn = xac.getConnection();
1:bb29639:         s = conn.createStatement();
1:5b78c4e:         s.executeUpdate("insert into APP.fooMorph values (2005)");
1:bb29639:         conn.commit();
1:bb29639:         conn.setAutoCommit(false);
1:5b78c4e:         s.executeUpdate("insert into APP.fooMorph values (2006)");
1:bb29639:         conn.rollback();
1:5b78c4e:         s.executeUpdate("insert into APP.fooMorph values (2007)");
1:bb29639:         conn.commit();
1:2d08e7a: 
1:bb29639:         expectedRows = new String[][] {
1:bb29639:                 { "(1", "PREPARED", "false", "APP", "UserTransaction" },
1:bb29639:                 { "(1", "IDLE", "NULL", "APP", "UserTransaction" } };
1:bb29639:         XATestUtil.checkXATransactionView(conn, expectedRows);
1:bb29639:         /*
1:bb29639:          * -- I am still able to commit other global transactions while I am
1:bb29639:          * attached to a -- local transaction. xa_commit xa_2phase 1; xa_end
1:bb29639:          * xa_success 2; xa_rollback 2;
1:bb29639:          */
1:bb29639:         xar.commit(xid, false);
1:bb29639:         xar.end(xid2, XAResource.TMSUCCESS);
1:bb29639:         xar.rollback(xid2);
1:1128268: 
1:bb29639:         XATestUtil.checkXATransactionView(conn, null);
1:5b78c4e:         rs = s.executeQuery("select * from APP.fooMorph where A >= 2000");
1:bb29639:         expectedRows = new String[][] { { "2001" }, { "2002" }, { "2003" },
1:bb29639:                 { "2005" }, { "2007" } };
1:bb29639:         JDBC.assertFullResultSet(rs, expectedRows);
1:bb29639:         rs.close();
1:6bbc8fb:         conn.rollback();
1:bb29639:         conn.close();
1:1128268: 
1:bb29639:         /*
1:bb29639:          * xa_getconnection; select * from global_xactTable where gxid is not
1:bb29639:          * null order by gxid,username; select * from foo; autocommit off;
1:bb29639:          * delete from foo;
1:bb29639:          */
1:bb29639:         conn = xac.getConnection();
1:bb29639:         conn.setAutoCommit(false);
1:bb29639:         s = conn.createStatement();
1:5b78c4e:         s.executeUpdate("delete from app.fooMorph");
1:5b78c4e:         rs = s.executeQuery("select * from APP.fooMorph");
1:bb29639:         JDBC.assertEmpty(rs);
1:bb29639:         rs.close();
1:bb29639: 
1:bb29639:         /*
1:bb29639:          * -- yanking a local connection away should rollback the changes
1:bb29639:          */
1:bb29639:         conn = xac.getConnection();
1:bb29639:         conn.setAutoCommit(false);
1:bb29639:         s = conn.createStatement();
1:5b78c4e:         rs = s.executeQuery("select * from APP.fooMorph where A >= 2000");
1:bb29639:         expectedRows = new String[][] { { "2001" }, { "2002" }, { "2003" },
1:bb29639:                 { "2005" }, { "2007" } };
1:bb29639:         JDBC.assertFullResultSet(rs, expectedRows);
1:bb29639: 
1:bb29639:         /*
1:bb29639:          * -- cannot morph it if the local transaction is not idle xa_start
1:bb29639:          * xa_noflags 3; commit; -- now morph it to a global transaction
1:bb29639:          * xa_start xa_noflags 3;
1:bb29639:          */
1:bb29639:         Xid xid3 = XATestUtil.getXid(1003, 27, 9);
1:bb29639:         try {
3:6e10422:             xar.start(xid3, XAResource.TMNOFLAGS);
1:bb29639:             fail("FAIL XAResource.start on a global transaction with an active local transaction (autocommit false)");
1:bb29639:         } catch (XAException xae) {
1:bb29639:             if (xae.errorCode != XAException.XAER_OUTSIDE)
1:bb29639:                 throw xae;
1:bb29639:         }
1:bb29639:         conn.commit();
1:bb29639:         xar.start(xid3, XAResource.TMNOFLAGS);
1:bb29639: 
1:bb29639:         /*
1:bb29639:          * -- now I shouldn't be able to yank it xa_getconnection;
1:bb29639:          */
1:bb29639:         // DERBY-341 - client skip XAConnection with active local xact
1:bb29639:         if (usingEmbedded()) {
1:4388f15:             try {
1:6e10422:                 xac.getConnection();
1:bb29639:                 fail("FAIL: getConnection with active global xact");
1:175a740:             } catch (SQLException sqle) {
1:bb29639:                 assertSQLState("XJ059", sqle);
1:4388f15:             }
1:4388f15:         }
1:bb29639:         /*
1:bb29639:          * select * from foo; delete from foo;
1:bb29639:          * 
1:bb29639:          * xa_end xa_fail 3; xa_rollback 3; -- local connection again
1:bb29639:          * xa_getconnection; select * from global_xactTable where gxid is not
1:bb29639:          * null order by gxid,username; select * from foo;
1:bb29639:          */
1:bb29639:         s = conn.createStatement();
1:5b78c4e:         s.executeUpdate("delete from APP.fooMorph");
1:5b78c4e:         rs = s.executeQuery("select * from APP.fooMorph where A >= 2000");
1:bb29639:         JDBC.assertEmpty(rs);
1:bb29639: 
1:bb29639:         rs.close();
1:bb29639:         try {
1:bb29639:             xar.end(xid3, XAResource.TMFAIL);
1:bb29639:         } catch (XAException e) {
1:bb29639:             if (e.errorCode != XAException.XA_RBROLLBACK)
1:bb29639:                 throw e;
1:bb29639:         }
1:bb29639:         xar.rollback(xid3);
1:bb29639: 
1:bb29639:         conn = xac.getConnection();
1:bb29639:         s = conn.createStatement();
1:5b78c4e:         rs = s.executeQuery("select * from APP.fooMorph where A >= 2000");
1:bb29639:         expectedRows = new String[][] { { "2001" }, { "2002" }, { "2003" },
1:bb29639:                 { "2005" }, { "2007" } };
1:bb29639:         JDBC.assertFullResultSet(rs, expectedRows);
1:bb29639:         rs.close();
1:bb29639: 
1:bb29639:         s.close();
1:bb29639:         conn.close();
1:175a740: 
1:4388f15:     }
1:175a740: 
1:5b78c4e:     /**
1:5b78c4e:      * This test checks the fix on DERBY-4310, for not repreparing PreparedStatements
1:5b78c4e:      * upon calling close() on them.
1:5b78c4e:      */
1:5b78c4e:     public void testDerby4310PreparedStatement() throws SQLException, XAException {
1:5b78c4e:         XADataSource xads = J2EEDataSource.getXADataSource();
1:5b78c4e:         J2EEDataSource.setBeanProperty(xads, "databaseName", "wombat");
1:5b78c4e: 
1:5b78c4e:         XAConnection xaconn = xads.getXAConnection();
1:5b78c4e:        
1:5b78c4e:         XAResource xar = xaconn.getXAResource();
1:5b78c4e:         Xid xid = XATestUtil.getXid(1,93,18);
1:5b78c4e:         
1:5b78c4e:         /* Create the table and insert some records into it. */
1:5b78c4e:         Connection conn = xaconn.getConnection();
1:5b78c4e:         Statement s = conn.createStatement();
1:5b78c4e:         s.executeUpdate("CREATE TABLE foo4310_PS (I INT)");
1:5b78c4e: 
1:5b78c4e:         conn.createStatement().executeUpdate("insert into APP.foo4310_PS values (0)");
1:5b78c4e:         conn.createStatement().executeUpdate("insert into APP.foo4310_PS values (1)");
1:5b78c4e:         conn.createStatement().executeUpdate("insert into APP.foo4310_PS values (2)");
1:5b78c4e:         conn.commit();
1:5b78c4e:         
1:5b78c4e:         /* Prepare and execute the statement to be tested */
1:5b78c4e:         PreparedStatement ps = conn.prepareStatement("SELECT * FROM APP.foo4310_PS");
1:5b78c4e:         ps.executeQuery().close();
1:5b78c4e: 
1:5b78c4e:         /* Start and end a transaction on the XAResource object */
1:5b78c4e:         xar.start(xid, XAResource.TMNOFLAGS);
1:5b78c4e:         xar.end(xid, XAResource.TMSUCCESS);
1:5b78c4e:         
1:5b78c4e:         /* Drop the table on a parallel, regular connection */
1:5b78c4e:         Connection conn2 = getConnection();
1:5b78c4e:         Statement s2 = conn2.createStatement();
1:5b78c4e:         s2.execute("DROP TABLE foo4310_PS");
1:5b78c4e:         conn2.commit();
1:5b78c4e:         conn2.close();
1:5b78c4e:         
1:5b78c4e:         try {
1:5b78c4e:             /* Try to close the prepared statement. This would throw an exception
1:5b78c4e:              * before the fix, claiming that the table was not found. */
1:5b78c4e:             ps.close();
1:5b78c4e:         } finally {
1:5b78c4e:             /* Rollback the transaction and close the connections */
1:5b78c4e:             xar.rollback(xid);
1:5b78c4e:             conn.close();
1:5b78c4e:             xaconn.close();
1:5b78c4e:         }
1:5b78c4e:         
1:5b78c4e:     }
1:5b78c4e:     
1:5b78c4e:     /**
1:5b78c4e:      * This test checks the fix on DERBY-4310, for not repreparing CallableStatements
1:5b78c4e:      * upon calling close() on them.
1:5b78c4e:      */
1:5b78c4e:     public void testDerby4310CallableStatement() throws SQLException, XAException {
1:5b78c4e:         XADataSource xads = J2EEDataSource.getXADataSource();
1:5b78c4e:         J2EEDataSource.setBeanProperty(xads, "databaseName", "wombat");
1:5b78c4e: 
1:5b78c4e:         XAConnection xaconn = xads.getXAConnection();
1:5b78c4e:        
1:5b78c4e:         XAResource xar = xaconn.getXAResource();
1:5b78c4e:         Xid xid = XATestUtil.getXid(1,93,18);
1:5b78c4e:         
1:5b78c4e:         /* Create the procedure bazed on XATest.zeroArg() */
1:5b78c4e:         Connection conn = xaconn.getConnection();
1:5b78c4e:         Statement s = conn.createStatement();
1:5b78c4e:         s.executeUpdate("CREATE PROCEDURE ZA() LANGUAGE JAVA "+
1:5b78c4e:                         "EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.jdbcapi.XATest.zeroArg' "+
1:5b78c4e:                         "PARAMETER STYLE JAVA");
1:5b78c4e:         conn.commit();
1:5b78c4e:         
1:5b78c4e:         /* Prepare and execute CallableStatement based on the procedure above */
1:5b78c4e:         CallableStatement cs = conn.prepareCall("CALL ZA()");
1:5b78c4e:         cs.execute();
1:5b78c4e: 
1:5b78c4e:         /* Start and end a transaction on the XAResource object */
1:5b78c4e:         xar.start(xid, XAResource.TMNOFLAGS);
1:5b78c4e:         xar.end(xid, XAResource.TMSUCCESS);
1:5b78c4e:         
1:5b78c4e:         /* Drop the procedure on a parallel, regular connection */
1:5b78c4e:         Connection conn2 = getConnection();
1:5b78c4e:         Statement s2 = conn2.createStatement();
1:5b78c4e:         s2.execute("DROP PROCEDURE ZA");
1:5b78c4e:         conn2.commit();
1:5b78c4e:         conn2.close();
1:5b78c4e:         
1:5b78c4e:         try {
1:5b78c4e:             /* Try to close the prepared statement. This would throw an exception
1:5b78c4e:              * before the fix, claiming that the table was not found. */
1:5b78c4e:             cs.close();
1:5b78c4e:         } finally {
1:5b78c4e:             /* Rollback the transaction and close the connections */
1:5b78c4e:             xar.rollback(xid);
1:5b78c4e:             conn.close();
1:5b78c4e:             xaconn.close();
1:5b78c4e:         }
1:5b78c4e:         
1:5b78c4e:     }
1:5b78c4e:     
1:5b78c4e:     /**
1:bb29639:      * Derby-966 holdability and global/location transactions. (work in
1:bb29639:      * progress)
1:6e10422:      */
1:bb29639:     public void testDerby966() throws SQLException, XAException {
1:5b78c4e:         Statement preStatement = getConnection().createStatement();
1:5b78c4e:         preStatement.execute("create table foo966 (a int)");
1:5b78c4e:         preStatement.executeUpdate("insert into APP.foo966 values (0)");
1:5b78c4e:         preStatement.executeUpdate("insert into APP.foo966 values (1)");
1:5b78c4e:         preStatement.executeUpdate("insert into APP.foo966 values (2)");
1:5b78c4e:         preStatement.executeUpdate("insert into APP.foo966 values (3)");
1:5b78c4e:         preStatement.executeUpdate("insert into APP.foo966 values (4)");
1:5b78c4e:         preStatement.executeUpdate("insert into APP.foo966 values (2001)");
1:5b78c4e:         preStatement.executeUpdate("insert into APP.foo966 values (2002)");
1:5b78c4e:         preStatement.executeUpdate("insert into APP.foo966 values (2003)");
1:5b78c4e:         preStatement.executeUpdate("insert into APP.foo966 values (2005)");
1:5b78c4e:         preStatement.executeUpdate("insert into APP.foo966 values (2007)");
1:5b78c4e:         preStatement.close();
1:5b78c4e:         
1:bb29639:         XADataSource xads = J2EEDataSource.getXADataSource();
1:bb29639:         XAConnection xac = xads.getXAConnection();
1:bb29639:         XAResource xar = xac.getXAResource();
1:175a740: 
1:3bb8c05:         Xid xid = XATestUtil.getXid(996, 9, 48);
1:175a740: 
1:bb29639:         Connection conn = xac.getConnection();
1:1128268: 
1:bb29639:         // Obtain Statements and PreparedStatements
1:bb29639:         // with all the holdability options.
1:bb29639:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, conn.getHoldability());
1:0bf3bf8: 
1:bb29639:         Statement sdh = conn.createStatement();
1:bb29639:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, sdh
1:bb29639:                 .getResultSetHoldability());
1:bb29639: 
1:5b78c4e:         checkHeldRS(conn, sdh, sdh.executeQuery("select * from app.foo966"));
1:5b78c4e:         PreparedStatement psdh = conn.prepareStatement("SELECT * FROM APP.foo966");
1:bb29639:         PreparedStatement psdh_d = conn
1:5b78c4e:                 .prepareStatement("DELETE FROM APP.foo966 WHERE A < -99");
1:bb29639:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, psdh
1:bb29639:                 .getResultSetHoldability());
1:bb29639:         checkHeldRS(conn, psdh, psdh.executeQuery());
1:bb29639: 
1:bb29639:         Statement shh = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:bb29639:                 ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:bb29639:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, shh
1:bb29639:                 .getResultSetHoldability());
1:5b78c4e:         checkHeldRS(conn, shh, shh.executeQuery("select * from app.foo966"));
1:5b78c4e:         PreparedStatement pshh = conn.prepareStatement("SELECT * FROM APP.foo966",
1:bb29639:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:0bf3bf8:                 ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:bb29639:         PreparedStatement pshh_d = conn.prepareStatement(
1:5b78c4e:                 "DELETE FROM APP.foo966 WHERE A < -99",
1:bb29639:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:bb29639:                 ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:bb29639:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, shh
1:bb29639:                 .getResultSetHoldability());
1:bb29639:         checkHeldRS(conn, pshh, pshh.executeQuery());
1:175a740: 
1:bb29639:         Statement sch = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:bb29639:                 ResultSet.CONCUR_READ_ONLY, ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:bb29639:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, sch
1:bb29639:                 .getResultSetHoldability());
1:175a740: 
1:5b78c4e:         checkHeldRS(conn, sch, sch.executeQuery("select * from app.foo966"));
1:5b78c4e:         PreparedStatement psch = conn.prepareStatement("SELECT * FROM APP.foo966",
1:bb29639:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:bb29639:                 ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:bb29639:         PreparedStatement psch_d = conn.prepareStatement(
1:5b78c4e:                 "DELETE FROM APP.foo966 WHERE A < -99",
1:bb29639:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:bb29639:                 ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:bb29639:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psch_d
1:bb29639:                 .getResultSetHoldability());
1:bb29639:         checkHeldRS(conn, psch, psch.executeQuery());
1:bb29639: 
1:bb29639:         // set the connection's holdabilty to false
1:bb29639:         conn.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:bb29639: 
1:bb29639:         Statement sdc = conn.createStatement();
1:bb29639:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, sdc
1:bb29639:                 .getResultSetHoldability());
1:5b78c4e:         checkHeldRS(conn, sdc, sdc.executeQuery("select * from app.foo966"));
1:5b78c4e:         PreparedStatement psdc = conn.prepareStatement("SELECT * FROM APP.foo966");
1:bb29639:         PreparedStatement psdc_d = conn
1:5b78c4e:                 .prepareStatement("DELETE FROM APP.foo966 WHERE A < -99");
1:bb29639:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psdc
1:bb29639:                 .getResultSetHoldability());
1:bb29639:         checkHeldRS(conn, psdc, psdc.executeQuery());
1:bb29639: 
1:bb29639:         Statement shc = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:bb29639:                 ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:bb29639:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psdc
1:bb29639:                 .getResultSetHoldability());
1:5b78c4e:         checkHeldRS(conn, shc, shc.executeQuery("select * from app.foo966"));
1:5b78c4e:         PreparedStatement pshc = conn.prepareStatement("SELECT * FROM APP.foo966",
1:bb29639:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:bb29639:                 ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:bb29639:         PreparedStatement pshc_d = conn.prepareStatement(
1:5b78c4e:                 "DELETE FROM APP.foo966 WHERE A < -99",
1:bb29639:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:bb29639:                 ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:bb29639:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, pshc
1:bb29639:                 .getResultSetHoldability());
1:bb29639: 
1:bb29639:         checkHeldRS(conn, pshc, pshc.executeQuery());
1:bb29639: 
1:bb29639:         Statement scc = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:bb29639:                 ResultSet.CONCUR_READ_ONLY, ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:bb29639:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, scc
1:bb29639:                 .getResultSetHoldability());
1:5b78c4e:         checkHeldRS(conn, scc, scc.executeQuery("select * from app.foo966"));
1:5b78c4e:         PreparedStatement pscc = conn.prepareStatement("SELECT * FROM APP.foo966",
1:bb29639:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:bb29639:                 ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:bb29639:         PreparedStatement pscc_d = conn.prepareStatement(
1:5b78c4e:                 "DELETE FROM APP.foo966 WHERE A < -99",
1:bb29639:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:bb29639:                 ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:bb29639:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, pscc
1:bb29639:                 .getResultSetHoldability());
1:bb29639: 
1:bb29639:         checkHeldRS(conn, pscc, pscc.executeQuery());
1:bb29639: 
1:bb29639:         // Revert back to holdable
1:bb29639:         conn.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:bb29639: 
1:5b78c4e:         ResultSet rs = sdh.executeQuery("SELECT * FROM APP.foo966");
3:6e10422:         rs.next();
1:bb29639:         // before commit
1:bb29639:         assertEquals(0, +rs.getInt(1));
8:6e10422:         conn.commit();
1:bb29639:         // aftercommit
1:bb29639:         rs.next();
1:bb29639:         assertEquals(1, rs.getInt(1));
1:bb29639:         rs.close();
1:bb29639: 
1:bb29639:         // ensure a transaction is active to test DERBY-1025
1:5b78c4e:         rs = sdh.executeQuery("SELECT * FROM APP.foo966");
1:bb29639: 
1:bb29639:         // This switch to global is ok because conn
1:bb29639:         // is in auto-commit mode, thus the start performs
1:bb29639:         // an implicit commit to complete the local transaction.
1:bb29639: 
1:bb29639:         // start a global xact and test those statements.
1:bb29639:         xar.start(xid, XAResource.TMNOFLAGS);
1:bb29639: 
1:bb29639:         // Statements not returning ResultSet's should be ok
1:5b78c4e:         sdh.executeUpdate("DELETE FROM APP.foo966 where A < -99");
1:5b78c4e:         shh.executeUpdate("DELETE FROM APP.foo966 where A < -99");
1:5b78c4e:         sch.executeUpdate("DELETE FROM APP.foo966 where A < -99");
1:bb29639: 
1:e18f54b:         ArrayList<ResultSet> openRS = new ArrayList<ResultSet>();
1:bb29639: 
1:bb29639:         // Statements obtained while default was hold.
1:bb29639:         // All should work, holability will be downgraded
1:bb29639:         // to close on commit for those Statements with hold set.
1:5b78c4e:         openRS.add(sdh.executeQuery("SELECT * FROM APP.foo966"));
1:5b78c4e:         openRS.add(shh.executeQuery("SELECT * FROM APP.foo966"));
1:5b78c4e:         openRS.add(sch.executeQuery("SELECT * FROM APP.foo966"));
1:bb29639: 
1:bb29639:         // PreparedStatements obtained while default was hold.
1:bb29639:         // Holdability should be downgraded.
1:bb29639:         openRS.add(psdh.executeQuery());
1:bb29639:         openRS.add(pshh.executeQuery());
1:bb29639:         openRS.add(psch.executeQuery());
1:bb29639: 
1:bb29639:         // Statements not returning ResultSet's should be ok
1:bb29639:         psdh_d.executeUpdate();
1:bb29639:         pshh_d.executeUpdate();
1:bb29639:         psch_d.executeUpdate();
1:bb29639: 
1:bb29639:         // Statements not returning ResultSet's should be ok
1:5b78c4e:         sdc.executeUpdate("DELETE FROM APP.foo966 where A < -99");
1:5b78c4e:         shc.executeUpdate("DELETE FROM APP.foo966 where A < -99");
1:5b78c4e:         scc.executeUpdate("DELETE FROM APP.foo966 where A < -99");
1:bb29639: 
1:bb29639:         // Statements obtained while default was close.
1:bb29639:         // all should return close on commit ResultSets
1:5b78c4e:         openRS.add(sdc.executeQuery("SELECT * FROM APP.foo966"));
1:5b78c4e:         openRS.add(shc.executeQuery("SELECT * FROM APP.foo966"));
1:5b78c4e:         openRS.add(scc.executeQuery("SELECT * FROM APP.foo966"));
1:bb29639: 
1:bb29639:         // PreparedStatements obtained while default was close.
1:bb29639:         openRS.add(psdc.executeQuery());
1:bb29639:         openRS.add(pshc.executeQuery());
1:bb29639:         openRS.add(pscc.executeQuery());
1:bb29639: 
1:bb29639:         // Statements not returning ResultSet's should be ok
1:bb29639:         psdc_d.executeUpdate();
1:bb29639:         pshc_d.executeUpdate();
1:bb29639:         pscc_d.executeUpdate();
1:bb29639: 
1:bb29639:         // All the ResultSets should be open. Run a simple
1:bb29639:         // test, clearWarnings throws an error if the ResultSet
1:bb29639:         // is closed. Also would be nice here to use the new
1:bb29639:         // JDBC 4.0 method getHoldabilty to ensure the
1:bb29639:         // holdability is reported correctly.
1:bb29639:         int orsCount = 0;
1:e18f54b:         for (ResultSet ors : openRS) {
1:bb29639:             ors.clearWarnings();
1:bb29639:             orsCount++;
1:175a740:         }
1:bb29639:         assertEquals("Incorrect number of open result sets", 12, orsCount);
1:bb29639: 
1:bb29639:         // Test we cannot switch the connection to holdable
1:bb29639:         try {
1:bb29639:             conn.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:bb29639:             fail("FAIL - set holdability in global xact.");
1:bb29639:         } catch (SQLException sqle) {
1:bb29639:             assertSQLState("XJ05C", sqle);
1:bb29639:         }
1:bb29639: 
1:bb29639:         // JDBC 4.0 (proposed final draft) section allows
1:bb29639:         // drivers to change the holdability when creating
1:bb29639:         // a Statement object and attach a warning to the Connection.
1:bb29639:         Statement sglobalhold = conn.createStatement(
1:bb29639:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:bb29639:                 ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:bb29639:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, sglobalhold
1:bb29639:                 .getResultSetHoldability());
1:bb29639: 
1:bb29639:         sglobalhold.close();
1:bb29639: 
1:bb29639:         // DERBY2481 Client does not downgrade PreparedStatement holdability
1:bb29639:         if (!usingDerbyNetClient()) {
1:bb29639:             PreparedStatement psglobalhold = conn.prepareStatement(
1:5b78c4e:                     "SELECT * FROM APP.foo966", ResultSet.TYPE_FORWARD_ONLY,
1:bb29639:                     ResultSet.CONCUR_READ_ONLY,
1:bb29639:                     ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:bb29639:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psglobalhold
1:bb29639:                     .getResultSetHoldability());
1:bb29639: 
1:bb29639:             psglobalhold.close();
1:bb29639: 
1:bb29639:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, sdh
1:bb29639:                     .getResultSetHoldability());
1:bb29639:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, sch
1:bb29639:                     .getResultSetHoldability());
1:bb29639: 
1:bb29639:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psdh
1:bb29639:                     .getResultSetHoldability());
1:bb29639:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, pshh
1:bb29639:                     .getResultSetHoldability());
1:bb29639:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psch
1:bb29639:                     .getResultSetHoldability());
1:bb29639: 
1:bb29639:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, sdc
1:bb29639:                     .getResultSetHoldability());
1:bb29639:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, shc
1:bb29639:                     .getResultSetHoldability());
1:bb29639:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, scc
1:bb29639:                     .getResultSetHoldability());
1:bb29639: 
1:bb29639:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psdh_d
1:bb29639:                     .getResultSetHoldability());
1:bb29639:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, pshh_d
1:bb29639:                     .getResultSetHoldability());
1:bb29639:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psch_d
1:bb29639:                     .getResultSetHoldability());
1:bb29639:         }
1:bb29639: 
1:bb29639:         xar.end(xid, XAResource.TMSUCCESS);
1:bb29639:         if (xar.prepare(xid) != XAResource.XA_RDONLY)
1:bb29639:             fail("FAIL prepare didn't indicate r/o");
1:bb29639: 
1:bb29639:         // All the ResultSets should be closed. Run a simple
1:bb29639:         // test, clearWarnings throws an error if the ResultSet
1:bb29639:         // is closed.
1:bb29639:         int crsCount = 0;
1:e18f54b:         for (ResultSet crs : openRS) {
1:bb29639:             try {
1:bb29639:                 crs.clearWarnings();
1:bb29639:             } catch (SQLException sqle) {
1:bb29639:             }
1:bb29639:             crsCount++;
1:bb29639:         }
1:bb29639:         assertEquals("After global transaction closed ResultSets ", 12,
1:bb29639:                 crsCount);
1:bb29639: 
1:bb29639:         // Check the statements revert to holdable as required.
1:bb29639:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, sdh
1:bb29639:                 .getResultSetHoldability());
1:bb29639:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, shh
1:bb29639:                 .getResultSetHoldability());
1:bb29639:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, sch
1:bb29639:                 .getResultSetHoldability());
1:bb29639: 
1:bb29639:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, psdh
1:bb29639:                 .getResultSetHoldability());
1:bb29639:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, pshh
1:bb29639:                 .getResultSetHoldability());
1:bb29639:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psch
1:bb29639:                 .getResultSetHoldability());
1:bb29639: 
1:bb29639:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, sdc
1:bb29639:                 .getResultSetHoldability());
1:bb29639:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, shc
1:bb29639:                 .getResultSetHoldability());
1:bb29639:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, scc
1:bb29639:                 .getResultSetHoldability());
1:bb29639: 
1:bb29639:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, psdh_d
1:bb29639:                 .getResultSetHoldability());
1:bb29639:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, pshh_d
1:bb29639:                 .getResultSetHoldability());
1:bb29639:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psch_d
1:bb29639:                 .getResultSetHoldability());
1:bb29639: 
1:83f11b8:         // intermittently we get a failure in this test if we do not
1:83f11b8:         // rollback, see DERBY-6248.
1:83f11b8:         conn.rollback();
1:bb29639:         conn.close();
1:bb29639: 
1:bb29639:     }
1:bb29639: 
1:bb29639:     /**
1:3bb8c05:      * DERBY-4731
1:2c70a31:      * Test using a GLOBAL TEMPORARY TABLE  table in an
1:2c70a31:      * XA transaction and leaving it active during two phase commit.
1:2c70a31:      * Before the fix this test would throw the following at commit
1:2c70a31:      * time:
1:2c70a31:      * ERROR 40XT0: An internal error was identified by RawStore module. 
1:2c70a31:      *
1:2c70a31:      *
1:bb29639:      * @throws XAException 
1:3bb8c05:      * @throws SQLException 
1:6e10422:      * 
1:6e10422:      */
1:2c70a31:     public void testXATempTableD4731_RawStore() 
1:2c70a31:         throws SQLException, XAException {
1:af45571:         doXATempTableD4731Work(true, false, XATestUtil.getXid(997, 9, 49));
1:af45571:     }
1:4f2355d:     
1:175a740: 
1:af45571:     /**
1:af45571:      * DERBY-4735 Temp tables with XA transactions
1:3bb8c05:      * an Assert will occur on prepare if only
1:3bb8c05:      * temp table work is done in the xact.
1:3bb8c05:      *
1:3bb8c05:      * @throws XAException 
1:3bb8c05:      * @throws SQLException 
1:2c70a31:      * 
1:3bb8c05:      */
1:af45571:     public void xtestXATempTableD4735_Assert() 
1:2c70a31:         throws SQLException, XAException {
1:3bb8c05: 
1:af45571:           doXATempTableD4731Work(false, false, XATestUtil.getXid(999,  11, 51));
1:af45571:           doXATempTableD4731Work(false, true,  XATestUtil.getXid(1000, 12, 52));
1:3bb8c05:     }
1:3bb8c05: 
1:3bb8c05:     /**
1:af45571:      * DERBY-4743 Temp tables with XA transactions
1:af45571:      *
1:6819a86:      * Verifies that global temporary table can not be accessed after the
1:6819a86:      * commit of the XA transaction.
1:af45571:      *
1:af45571:      * @throws XAException 
1:af45571:      * @throws SQLException 
1:af45571:      * 
1:af45571:      */
1:6819a86:     public void testXATempTableD4743() 
1:af45571:         throws SQLException, XAException {
1:af45571: 
1:af45571:           doXATempTableD4731Work(true, true, XATestUtil.getXid(998, 10, 50));
1:175a740:     }
1:af45571:  
1:3fe2281:     /**
1:3fe2281:      * DERBY-5552 Check that lock timeout does not destroy connection
1:3fe2281:      * during an XA Transaction.
1:3fe2281:      * 
1:3fe2281:      * @throws SQLException
1:3fe2281:      * @throws XAException
1:3fe2281:      */
1:3fe2281:     public void testXALockTimeout() throws SQLException, XAException {
1:3fe2281:         XADataSource xads = J2EEDataSource.getXADataSource();
1:3fe2281:         J2EEDataSource.setBeanProperty(xads, "databaseName", "wombat");
1:3fe2281:        
1:3fe2281:         // Get the first connection and lock table in 
1:3fe2281:         // xa transaction
1:3fe2281:         XAConnection xaconn = xads.getXAConnection();
1:3fe2281:         XAResource xar = xaconn.getXAResource();
1:3fe2281:         Xid xid = XATestUtil.getXid(998,10,50);
1:3fe2281:    
1:3fe2281:         Connection conn = xaconn.getConnection();
1:3fe2281:         Statement s = conn.createStatement();
1:3fe2281:         xar.start(xid, XAResource.TMNOFLAGS);
1:3fe2281:         s.executeUpdate("INSERT INTO TABLT VALUES(2)");
1:3fe2281:         
1:3fe2281:         // Get a second connection and global xact
1:3fe2281:         // and try to select causing lock timeout
1:3fe2281:         XAConnection xaconn2 = xads.getXAConnection();
1:3fe2281:         XAResource xar2 = xaconn2.getXAResource();
1:3fe2281:         Xid xid2 = XATestUtil.getXid(999,11,51);
1:3fe2281:         Connection conn2 = xaconn2.getConnection();
1:3fe2281:         // Set to serializable so we get lock timeout
1:3fe2281:         conn2.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1:3fe2281:         xar2.start(xid2, XAResource.TMNOFLAGS);
1:3fe2281:         Statement s2 = conn2.createStatement();
1:3fe2281:         s2.executeUpdate("INSERT INTO TABLT VALUES(3)");
1:3fe2281:         assertGlobalXactCount(2);
1:3fe2281:         try {
1:3fe2281:             ResultSet rs = s2.executeQuery("SELECT * FROM TABLT");
1:3fe2281:             fail("Should have gotten lock timeout error: " + LOCKTIMEOUT);
1:3fe2281:         } catch (SQLException se) {
1:3fe2281:             assertSQLState(LOCKTIMEOUT,se);
1:3fe2281:             }
1:3fe2281:         // After the lock timeout we just have one global transaction.
1:3fe2281:         // lock timeout implicitly rolled back xid2
1:3fe2281:         assertGlobalXactCount(1);
1:3fe2281:         assertConnOK(conn);
1:3fe2281:         // DERBY-5552 Make sure connection is ok after lock timeout
1:3fe2281:         assertConnOK(conn2);
1:3fe2281:         //Should be able to end and commit xid1
1:3fe2281:         xar.end(xid, XAResource.TMSUCCESS);
1:3fe2281:         xar.prepare(xid);
1:3fe2281:         xar.commit(xid, false);
1:3fe2281:         
1:3fe2281:         // xid2 should have already been rolled back so end should fail
1:3fe2281:         try {    
1:3fe2281:             xar2.end(xid2, XAResource.TMSUCCESS);
1:3fe2281:             fail("Should have gotten exception ending xid2");
1:3fe2281:         } catch (XAException xae) {
1:3fe2281:             //xae.printStackTrace();
1:3fe2281:             assertEquals(XAException.XA_RBTIMEOUT, xae.errorCode);
1:3fe2281:             
1:3fe2281:         } 
1:3fe2281:      
1:3fe2281:         // Should have no locks on TABLT
1:3fe2281:         Statement drops = createStatement();
1:3fe2281:         drops.executeUpdate("DROP TABLE TABLT");
1:3fe2281:         // verify there are no more global transactions
1:3fe2281:         assertGlobalXactCount(0);
1:3fe2281:         
1:3fe2281:         // Need to explicitly rollback xid2 as it ended with
1:3fe2281:         // an implicit rollback XA_RBTIMEOUT
1:3fe2281:         xar2.rollback(xid2);
1:3fe2281:         
1:3fe2281:         // Make sure both connections can be used to make a new global xact
1:3fe2281:         xar.start(xid, XAResource.TMNOFLAGS);
1:3fe2281:         s.executeUpdate("CREATE TABLE TABLT (I INT)");
1:3fe2281:         s.executeUpdate("INSERT INTO TABLT VALUES(1)");
1:3fe2281:         xar.end(xid, XAResource.TMSUCCESS);
1:3fe2281:         xar.prepare(xid);
1:3fe2281:         xar.commit(xid, false);
1:3fe2281:         
1:3fe2281:         // now the other connection ..
1:3fe2281:         xar2.start(xid2, XAResource.TMNOFLAGS);
1:3fe2281:         s2.executeUpdate("INSERT INTO TABLT VALUES(2)");
1:3fe2281:         xar2.end(xid2, XAResource.TMSUCCESS);
1:3fe2281:         xar.prepare(xid2);
1:3fe2281:         xar.commit(xid2, false);
1:3fe2281:         assertGlobalXactCount(0);
1:3fe2281:         conn.close();
1:3fe2281:         xaconn.close();
1:3fe2281:         conn2.close();
1:3fe2281:         xaconn2.close();
1:3fe2281:         
1:3fe2281:     }
1:3fe2281:     
1:e07f9c9:     /**
1:88b727b:      * DERBY-6879 Check that a XA transaction timeout while a cleanupOnError is
1:88b727b:      * being performed does not cause a Java level deadlock.
1:88b727b:      *
1:88b727b:      * The strategy is to cause a XA statement to wait for a period that is
1:88b727b:      * longer than the XA transaction timeout which will allow the timeout to
1:88b727b:      * cancel the XA transaction. That is accomplished by locking a table using
1:88b727b:      * a standard connection and then issuing a select on the same table using a
1:88b727b:      * XA connection. The select will wait for the required locks to be
1:88b727b:      * available up to the lock timeout. For the test to work correctly the XA
1:88b727b:      * transaction timeout must be less than the lock timeout.
1:88b727b:      *
1:88b727b:      * A dealock watchdog is used to detect the deadlock until the DERBY-6879
1:88b727b:      * issue is fixed.
1:88b727b:      *
1:88b727b:      * @throws SQLException
1:88b727b:      * @throws XAException
1:88b727b:      */
1:88b727b:     public void testDerby6879() throws SQLException, XAException {
1:88b727b:         XADataSource xads = J2EEDataSource.getXADataSource();
1:88b727b:         J2EEDataSource.setBeanProperty(xads, "databaseName", "wombat");
1:88b727b: 
1:88b727b:         Connection conn = J2EEDataSource.getConnectionPoolDataSource().getPooledConnection().getConnection();
1:88b727b:         conn.setAutoCommit(false);
1:88b727b:         Statement s = conn.createStatement();
1:88b727b:         s.execute("LOCK TABLE TABLT IN EXCLUSIVE MODE");
1:88b727b: 
1:88b727b:         // Get a second connection and global xact
1:88b727b:         // and try to select causing lock timeout
1:88b727b:         XAConnection xaconn2 = xads.getXAConnection();
1:88b727b:         XAResource xar2 = xaconn2.getXAResource();
1:88b727b:         xar2.setTransactionTimeout(2);
1:88b727b:         Xid xid2 = XATestUtil.getXid(6879, 11, 51);
1:88b727b:         Connection conn2 = xaconn2.getConnection();
1:88b727b:         // Set to serializable so we get lock timeout
1:88b727b:         conn2.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1:88b727b:         xar2.start(xid2, XAResource.TMNOFLAGS);
1:88b727b:         Statement s2 = conn2.createStatement();
1:88b727b:         assertGlobalXactCount(1);
1:88b727b:         DeadlockWatchdog wd = new DeadlockWatchdog(30 * 1000);
1:88b727b:         wd.start();
1:88b727b:         try {
1:88b727b:             ResultSet rs = s2.executeQuery("SELECT * FROM TABLT");
1:88b727b:             fail("Should have gotten lock timeout error: " + LOCKTIMEOUT);
1:88b727b:         } catch (SQLException se) {
1:88b727b:             assertSQLState(LOCKTIMEOUT, se);
1:88b727b:         }
1:88b727b:         wd.stop();
1:88b727b: 
1:88b727b:         // xid2 should have already been rolled back so end should fail
1:88b727b:         try {
1:88b727b:             xar2.end(xid2, XAResource.TMSUCCESS);
1:88b727b:             fail("Should have gotten exception ending xid2");
1:88b727b:         } catch (XAException xae) {
1:88b727b:             assertTrue(xae.errorCode >= XAException.XAER_OUTSIDE || xae.errorCode <= XAException.XAER_ASYNC);
1:88b727b:         }
1:88b727b: 
1:88b727b:         conn.commit();
1:88b727b: 
1:88b727b:         conn.close();
1:88b727b:         conn2.close();
1:88b727b:         xaconn2.close();
1:88b727b:     }
1:88b727b:     
1:2c70a31:     
8:6e10422:     /**
1:3bb8c05:      * The two cases for DERBY-4371 do essentially the same thing. Except doing
1:2c70a31:      * logged work causes the RawStore error and doing only temp table 
1:2c70a31:      * operations causes the assert.
1:3bb8c05:      *  
1:3bb8c05:      * @param doLoggedWorkInXact
1:3bb8c05:      * @throws SQLException
1:3bb8c05:      * @throws XAException
1:3bb8c05:      */
1:2c70a31:     private void doXATempTableD4731Work(
1:2c70a31:     boolean doLoggedWorkInXact,
1:af45571:     boolean access_temp_table_after_xaendandcommit,
1:2c70a31:     Xid     xid)
1:2c70a31:         throws SQLException, XAException{
1:3bb8c05: 
1:3bb8c05:         XADataSource xads = J2EEDataSource.getXADataSource();
1:3bb8c05:         XAConnection xaconn = xads.getXAConnection();
1:3bb8c05:         XAResource xar = xaconn.getXAResource();
1:2c70a31: 
1:3bb8c05:         xar.start(xid, XAResource.TMNOFLAGS);
1:3bb8c05:         Connection conn = xaconn.getConnection();
1:3bb8c05:         Statement s = conn.createStatement(); 
1:3bb8c05:         if (doLoggedWorkInXact){
1:3bb8c05:             // need to do some real work in our transaction
1:3bb8c05:             // so make a table
1:3bb8c05:             makeARealTable(s);
1:3bb8c05:         }
1:3bb8c05:         
1:3bb8c05:         // make the temp table
1:3bb8c05:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.T1 ( XWSID INT, XCTID INT, XIID CHAR(26), XVID SMALLINT, XLID CHAR(8) FOR BIT DATA) ON COMMIT DELETE ROWS NOT LOGGED ON ROLLBACK DELETE ROWS");
1:2c70a31: 
1:3bb8c05:         // insert a row
1:2c70a31:         PreparedStatement ps = 
1:2c70a31:             conn.prepareStatement("INSERT INTO SESSION.T1 VALUES (?,?,?,?,?)");
1:3bb8c05:         ps.setInt(1,1);
1:3bb8c05:         ps.setInt(2,1);
1:3bb8c05:         ps.setString(3,"hello");
1:3bb8c05:         ps.setShort(4, (short) 1);
1:3bb8c05:         ps.setBytes(5, new byte[] {0x0,0x1});
1:3bb8c05:         ps.executeUpdate();
1:3bb8c05:         ResultSet rs = s.executeQuery("SELECT count(*) FROM SESSION.t1");
1:3bb8c05:         JDBC.assertFullResultSet(rs, new String[][] {{"1"}});
1:1a7cb26:         rs.close();
1:2c70a31:         // You could work around the issue by dropping the TEMP table
1:3bb8c05:         //s.executeUpdate("DROP TABLE SESSION.T1");
1:3bb8c05:         xar.end(xid, XAResource.TMSUCCESS);
1:2c70a31: 
1:2c70a31:         assertEquals(
1:2c70a31:             (doLoggedWorkInXact ? XAResource.XA_OK : XAResource.XA_RDONLY),
1:2c70a31:             xar.prepare(xid));
1:af45571: 
1:452d467:         if (doLoggedWorkInXact)
1:452d467:         {
1:452d467:             // if you don't do logged work in the transaction, then the 
1:452d467:             // prepare with be done with XAResource.XA_RDONLY.  If you
1:452d467:             // try to commit a prepared read only transaction you will get 
1:452d467:             // an error, so only commit prepared transactions here that did
1:452d467:             // some "real" logged work.
1:3bb8c05:             xar.commit(xid,false); 
1:3bb8c05:         }
1:3bb8c05: 
1:af45571:         if (access_temp_table_after_xaendandcommit)
1:af45571:         {
1:6819a86:             // temp table should not be available after commit of an XA
1:6819a86:             // transaction.
1:6819a86:             assertStatementError(
1:6819a86:                 "42X05", s, "SELECT count(*) FROM SESSION.t1");
1:e07f9c9:             conn.commit();
1:452d467:         }
1:3bb8c05: 
1:3bb8c05: 
1:3bb8c05:         s.close();
1:3bb8c05:         conn.close();
1:3bb8c05:         xaconn.close();
1:af45571:     }
1:af45571: 
1:af45571: 
1:3bb8c05:     private void makeARealTable(Statement s) throws SQLException {
1:3bb8c05:         try {
1:3bb8c05:             s.executeUpdate("DROP TABLE REALTABLE1");
1:3bb8c05:         } catch (SQLException se) {
1:3bb8c05:             {
1:3bb8c05:             s.executeUpdate("CREATE TABLE REALTABLE1 (i int)");
1:3bb8c05:             }
1:3bb8c05:         }
1:3bb8c05:     }
1:3bb8c05:     
1:3bb8c05:     /**
1:bb29639:      * Check the held state of a ResultSet by fetching one row, executing a
1:bb29639:      * commit and then fetching the next. Checks the held state matches the
1:bb29639:      * behaviour.
1:bb29639:      */
1:bb29639:     private static void checkHeldRS(Connection conn, Statement s, ResultSet rs)
1:bb29639:             throws SQLException {
1:bb29639:         // DERBY-1008 - can't run with client
1:bb29639:         if (!usingDerbyNetClient()) {
1:bb29639:             if (s.getConnection() != conn)
1:bb29639:                 fail("FAIL - mismatched statement & Connection");
1:bb29639:         }
1:bb29639:         if (rs.getStatement() != s) {
1:bb29639:             // DERBY-1009
1:bb29639:             fail("FAIL - mismatched statement & ResultSet "
1:bb29639:                     + " Statement class " + s.getClass()
1:bb29639:                     + " ResultSet' Statements class "
1:bb29639:                     + rs.getStatement().getClass());
1:bb29639:         }
1:bb29639: 
1:bb29639:         boolean held = (ResultSet.HOLD_CURSORS_OVER_COMMIT == s
1:bb29639:                 .getResultSetHoldability());
1:bb29639:         rs.next();
1:bb29639:         assertEquals(0, rs.getInt(1));
1:bb29639:         conn.commit();
1:bb29639: 
1:bb29639:         try {
1:bb29639:             rs.next();
1:bb29639:         } catch (SQLException sqle) {
1:bb29639:             boolean ok = !held;
1:bb29639: 
1:bb29639:             if (ok) {
1:bb29639:                 assertSQLState("XCL16", sqle);
1:bb29639:             } else {
1:bb29639:                 fail("Held cursor closed on commit");
1:bb29639:             }
1:bb29639:         }
1:bb29639: 
1:2d08e7a:         rs.close();
1:6e10422:         conn.commit();
1:175a740:     }
1:bb29639:     
1:6e10422:     /** 
1:5b78c4e:      * Dummy method for testDerby4310* fixtures
1:5b78c4e:      */
1:5b78c4e:     public static void zeroArg() {  }
1:bb29639: 
1:bb29639:     public static Test baseSuite(String name) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:bb29639:         suite.addTestSuite(XATest.class);
1:bb29639: 
1:bb29639:         return new CleanDatabaseTestSetup(suite) {
1:bb29639:             /**
1:bb29639:              * Creates the table used in the test cases.
1:bb29639:              * 
1:bb29639:              */
1:bb29639:             protected void decorateSQL(Statement s) throws SQLException {
1:4c80863:                 XATestUtil.createXATransactionView(s);
1:3fe2281:                 // Table for lock timeout test
1:3fe2281:                 s.executeUpdate("CREATE TABLE TABLT (I INT)");
1:3fe2281:                 s.executeUpdate("INSERT INTO TABLT VALUES(1)");
1:bb29639:             }
1:bb29639: 
1:bb29639:         };
1:bb29639:     }
1:3fe2281:     
1:3fe2281:     /**
1:3fe2281:      * Excecute a simple SQL statement to assert that the connection is valid
1:3fe2281:      * @param conn Connection to check
1:3fe2281:      * @throws SQLException on error
1:3fe2281:      */
1:3fe2281:     private static void assertConnOK(Connection conn) throws SQLException{
1:3fe2281:         Statement s = conn.createStatement();
1:3fe2281:         ResultSet rs = s.executeQuery("VALUES(1)");
1:3fe2281:         JDBC.assertSingleValueResultSet(rs, "1");
1:3fe2281:       }
1:3fe2281:     
1:3fe2281:     
1:3fe2281:     /**
1:3fe2281:      * Verify the expected number of global transactions.
1:3fe2281:      * Run test with -Dderby.tests.debug to see the full transaction table on the
1:3fe2281:      * console
1:3fe2281:      * 
1:3fe2281:      * @param expectedCount expected number of global transaction
1:3fe2281:      * @throws SQLException on error
1:3fe2281:      */
1:3fe2281:     private void assertGlobalXactCount(int expectedCount ) throws SQLException {
1:3fe2281:         Connection conn = openDefaultConnection();
1:3fe2281:         Statement s = conn.createStatement();
1:3fe2281:         ResultSet rs = s.executeQuery(
1:3fe2281:               "SELECT COUNT(*) FROM syscs_diag.transaction_table WHERE GLOBAL_XID IS NOT NULL");
1:3fe2281:         rs.next();
1:3fe2281:         int count = rs.getInt(1);
1:3fe2281:         if (TestConfiguration.getCurrent().isVerbose()) {
1:3fe2281:             System.out.println("assertGlobalXactCount(" + expectedCount +
1:3fe2281:                     "): Full Transaction Table ...");
1:3fe2281:             Utilities.showResultSet(s.executeQuery(
1:3fe2281:                     "SELECT * FROM syscs_diag.transaction_table"));
1:3fe2281:         }
1:3fe2281:         assertTrue("Expected " + expectedCount + "global transactions but saw " + count, expectedCount == count);
1:3fe2281:     }
1:3fe2281:     
1:6e10422:     /**
1:bb29639:      * Runs the test fixtures in embedded and client.
1:bb29639:      * 
1:bb29639:      * @return test suite
1:6e10422:      */
1:bb29639:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("XATest");
1:bb29639:         // no XA for JSR169
1:bb29639:         if (JDBC.vmSupportsJSR169())
2:bb29639:             return suite;
1:5b78c4e: 
1:bb29639:         suite.addTest(baseSuite("XATest:embedded"));
1:bb29639: 
1:bb29639:         suite.addTest(TestConfiguration
1:bb29639:                 .clientServerDecorator(baseSuite("XATest:client")));
1:3fe2281:         
1:88b727b:         Test test = DatabasePropertyTestSetup.setLockTimeouts(suite, 3, 5);
1:88b727b:         test = decorateWithPolicy(test);
1:88b727b:         return test;
1:88b727b:     }   
1:88b727b:     
1:88b727b:     // grant ALL FILES execute, and getPolicy permissions,
1:88b727b:     // as well as write for the trace files.
1:88b727b:     private static Test decorateWithPolicy(Test test) {
1:88b727b:         //
1:88b727b:         // Install a security manager using the initial policy file. This is 
1:88b727b:         // needed foro the DeadlockWatchdog to allow it to access the ThreadMXBean
1:88b727b:         // to check for a deadlock
1:88b727b:         //
1:88b727b:         return new SecurityManagerSetup(test, POLICY_FILE_NAME);
1:1128268:     }
1:88b727b:     
1:88b727b:     
1:0bf3bf8: }
1:88b727b: 
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:88b727b
/////////////////////////////////////////////////////////////////////////
1: import static junit.framework.Assert.fail;
1: import org.apache.derby.shared.common.reference.SQLState;
1: import org.apache.derbyTesting.functionTests.util.DeadlockWatchdog;
1: import static org.apache.derbyTesting.junit.BaseJDBCTestCase.assertSQLState;
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:     //create own policy file
1:     private static final String POLICY_FILE_NAME =
1:             "org/apache/derbyTesting/functionTests/tests/jdbcapi/XATest.policy";
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * DERBY-6879 Check that a XA transaction timeout while a cleanupOnError is
1:      * being performed does not cause a Java level deadlock.
1:      *
1:      * The strategy is to cause a XA statement to wait for a period that is
1:      * longer than the XA transaction timeout which will allow the timeout to
1:      * cancel the XA transaction. That is accomplished by locking a table using
1:      * a standard connection and then issuing a select on the same table using a
1:      * XA connection. The select will wait for the required locks to be
1:      * available up to the lock timeout. For the test to work correctly the XA
1:      * transaction timeout must be less than the lock timeout.
1:      *
1:      * A dealock watchdog is used to detect the deadlock until the DERBY-6879
1:      * issue is fixed.
1:      *
1:      * @throws SQLException
1:      * @throws XAException
1:      */
1:     public void testDerby6879() throws SQLException, XAException {
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         J2EEDataSource.setBeanProperty(xads, "databaseName", "wombat");
1: 
1:         Connection conn = J2EEDataSource.getConnectionPoolDataSource().getPooledConnection().getConnection();
1:         conn.setAutoCommit(false);
1:         Statement s = conn.createStatement();
1:         s.execute("LOCK TABLE TABLT IN EXCLUSIVE MODE");
1: 
1:         // Get a second connection and global xact
1:         // and try to select causing lock timeout
1:         XAConnection xaconn2 = xads.getXAConnection();
1:         XAResource xar2 = xaconn2.getXAResource();
1:         xar2.setTransactionTimeout(2);
1:         Xid xid2 = XATestUtil.getXid(6879, 11, 51);
1:         Connection conn2 = xaconn2.getConnection();
1:         // Set to serializable so we get lock timeout
1:         conn2.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1:         xar2.start(xid2, XAResource.TMNOFLAGS);
1:         Statement s2 = conn2.createStatement();
1:         assertGlobalXactCount(1);
1:         DeadlockWatchdog wd = new DeadlockWatchdog(30 * 1000);
1:         wd.start();
1:         try {
1:             ResultSet rs = s2.executeQuery("SELECT * FROM TABLT");
1:             fail("Should have gotten lock timeout error: " + LOCKTIMEOUT);
1:         } catch (SQLException se) {
1:             assertSQLState(LOCKTIMEOUT, se);
1:         }
1:         wd.stop();
1: 
1:         // xid2 should have already been rolled back so end should fail
1:         try {
1:             xar2.end(xid2, XAResource.TMSUCCESS);
1:             fail("Should have gotten exception ending xid2");
1:         } catch (XAException xae) {
1:             assertTrue(xae.errorCode >= XAException.XAER_OUTSIDE || xae.errorCode <= XAException.XAER_ASYNC);
1:         }
1: 
1:         conn.commit();
1: 
1:         conn.close();
1:         conn2.close();
1:         xaconn2.close();
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         Test test = DatabasePropertyTestSetup.setLockTimeouts(suite, 3, 5);
1:         test = decorateWithPolicy(test);
1:         return test;
1:     }   
1:     
1:     // grant ALL FILES execute, and getPolicy permissions,
1:     // as well as write for the trace files.
1:     private static Test decorateWithPolicy(Test test) {
1:         //
1:         // Install a security manager using the initial policy file. This is 
1:         // needed foro the DeadlockWatchdog to allow it to access the ThreadMXBean
1:         // to check for a deadlock
1:         //
1:         return new SecurityManagerSetup(test, POLICY_FILE_NAME);
1:     
1:     
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("XATest");
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:83f11b8
/////////////////////////////////////////////////////////////////////////
1:         // intermittently we get a failure in this test if we do not
1:         // rollback, see DERBY-6248.
1:         conn.rollback();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e18f54b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<ResultSet> openRS = new ArrayList<ResultSet>();
/////////////////////////////////////////////////////////////////////////
1:         for (ResultSet ors : openRS) {
/////////////////////////////////////////////////////////////////////////
1:         for (ResultSet crs : openRS) {
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:3fe2281
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.Utilities;
1:     public static final String LOCKTIMEOUT="40XL1";
1:     
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * DERBY-5552 Check that lock timeout does not destroy connection
1:      * during an XA Transaction.
1:      * 
1:      * @throws SQLException
1:      * @throws XAException
1:      */
1:     public void testXALockTimeout() throws SQLException, XAException {
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         J2EEDataSource.setBeanProperty(xads, "databaseName", "wombat");
1:        
1:         // Get the first connection and lock table in 
1:         // xa transaction
1:         XAConnection xaconn = xads.getXAConnection();
1:         XAResource xar = xaconn.getXAResource();
1:         Xid xid = XATestUtil.getXid(998,10,50);
1:    
1:         Connection conn = xaconn.getConnection();
1:         Statement s = conn.createStatement();
1:         xar.start(xid, XAResource.TMNOFLAGS);
1:         s.executeUpdate("INSERT INTO TABLT VALUES(2)");
1:         
1:         // Get a second connection and global xact
1:         // and try to select causing lock timeout
1:         XAConnection xaconn2 = xads.getXAConnection();
1:         XAResource xar2 = xaconn2.getXAResource();
1:         Xid xid2 = XATestUtil.getXid(999,11,51);
1:         Connection conn2 = xaconn2.getConnection();
1:         // Set to serializable so we get lock timeout
1:         conn2.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1:         xar2.start(xid2, XAResource.TMNOFLAGS);
1:         Statement s2 = conn2.createStatement();
1:         s2.executeUpdate("INSERT INTO TABLT VALUES(3)");
1:         assertGlobalXactCount(2);
1:         try {
1:             ResultSet rs = s2.executeQuery("SELECT * FROM TABLT");
1:             fail("Should have gotten lock timeout error: " + LOCKTIMEOUT);
1:         } catch (SQLException se) {
1:             assertSQLState(LOCKTIMEOUT,se);
1:             }
1:         // After the lock timeout we just have one global transaction.
1:         // lock timeout implicitly rolled back xid2
1:         assertGlobalXactCount(1);
1:         assertConnOK(conn);
1:         // DERBY-5552 Make sure connection is ok after lock timeout
1:         assertConnOK(conn2);
1:         //Should be able to end and commit xid1
1:         xar.end(xid, XAResource.TMSUCCESS);
1:         xar.prepare(xid);
1:         xar.commit(xid, false);
1:         
1:         // xid2 should have already been rolled back so end should fail
1:         try {    
1:             xar2.end(xid2, XAResource.TMSUCCESS);
1:             fail("Should have gotten exception ending xid2");
1:         } catch (XAException xae) {
1:             //xae.printStackTrace();
1:             assertEquals(XAException.XA_RBTIMEOUT, xae.errorCode);
1:             
1:         } 
1:      
1:         // Should have no locks on TABLT
1:         Statement drops = createStatement();
1:         drops.executeUpdate("DROP TABLE TABLT");
1:         // verify there are no more global transactions
1:         assertGlobalXactCount(0);
1:         
1:         // Need to explicitly rollback xid2 as it ended with
1:         // an implicit rollback XA_RBTIMEOUT
1:         xar2.rollback(xid2);
1:         
1:         // Make sure both connections can be used to make a new global xact
1:         xar.start(xid, XAResource.TMNOFLAGS);
1:         s.executeUpdate("CREATE TABLE TABLT (I INT)");
1:         s.executeUpdate("INSERT INTO TABLT VALUES(1)");
1:         xar.end(xid, XAResource.TMSUCCESS);
1:         xar.prepare(xid);
1:         xar.commit(xid, false);
1:         
1:         // now the other connection ..
1:         xar2.start(xid2, XAResource.TMNOFLAGS);
1:         s2.executeUpdate("INSERT INTO TABLT VALUES(2)");
1:         xar2.end(xid2, XAResource.TMSUCCESS);
1:         xar.prepare(xid2);
1:         xar.commit(xid2, false);
1:         assertGlobalXactCount(0);
1:         conn.close();
1:         xaconn.close();
1:         conn2.close();
1:         xaconn2.close();
1:         
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:                 // Table for lock timeout test
1:                 s.executeUpdate("CREATE TABLE TABLT (I INT)");
1:                 s.executeUpdate("INSERT INTO TABLT VALUES(1)");
1:     
1:     /**
1:      * Excecute a simple SQL statement to assert that the connection is valid
1:      * @param conn Connection to check
1:      * @throws SQLException on error
1:      */
1:     private static void assertConnOK(Connection conn) throws SQLException{
1:         Statement s = conn.createStatement();
1:         ResultSet rs = s.executeQuery("VALUES(1)");
1:         JDBC.assertSingleValueResultSet(rs, "1");
1:       }
1:     
1:     
1:     /**
1:      * Verify the expected number of global transactions.
1:      * Run test with -Dderby.tests.debug to see the full transaction table on the
1:      * console
1:      * 
1:      * @param expectedCount expected number of global transaction
1:      * @throws SQLException on error
1:      */
1:     private void assertGlobalXactCount(int expectedCount ) throws SQLException {
1:         Connection conn = openDefaultConnection();
1:         Statement s = conn.createStatement();
1:         ResultSet rs = s.executeQuery(
1:               "SELECT COUNT(*) FROM syscs_diag.transaction_table WHERE GLOBAL_XID IS NOT NULL");
1:         rs.next();
1:         int count = rs.getInt(1);
1:         if (TestConfiguration.getCurrent().isVerbose()) {
1:             System.out.println("assertGlobalXactCount(" + expectedCount +
1:                     "): Full Transaction Table ...");
1:             Utilities.showResultSet(s.executeQuery(
1:                     "SELECT * FROM syscs_diag.transaction_table"));
1:         }
1:         assertTrue("Expected " + expectedCount + "global transactions but saw " + count, expectedCount == count);
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         
0:         return DatabasePropertyTestSetup.setLockTimeouts(suite, 3, 5);
commit:3bb8c05
/////////////////////////////////////////////////////////////////////////
1:      * DERBY-4731
0:      * test using a GLOBAL TEMPORARY TABLE  table in an
0:      * XA transaction adn leaving it active during two phase commit 
1:      * @throws XAException 
1:      * @throws SQLException 
1:      * 
1:      */
0:     public void xtestXATempTableD4731_RawStore() throws SQLException, XAException {
0:         doXATempTableD4731Work(true);
1:     }
1:     
1: 
1:     /**
0:      * DERBY-4731 Temp tables with XA transactions
1:      * an Assert will occur on prepare if only
1:      * temp table work is done in the xact.
1:      * @throws XAException 
1:      * @throws SQLException 
1:      * 
1:      */
0:     public void xtestXATempTableD4731_Assert() throws SQLException, XAException {
0:         doXATempTableD4731Work(false);
1:     }
1:  
1:     
1:     /**
1:      * The two cases for DERBY-4371 do essentially the same thing. Except doing
0:      * logged work causes the RawStore error and doing only temp table operations
0:      * causes the assert.
1:      *  
1:      * @param doLoggedWorkInXact
1:      * @throws SQLException
1:      * @throws XAException
1:      */
0:     private void doXATempTableD4731Work(boolean doLoggedWorkInXact) throws SQLException, XAException{
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         XAConnection xaconn = xads.getXAConnection();
1:         XAResource xar = xaconn.getXAResource();
1: 
1:         Xid xid = XATestUtil.getXid(996, 9, 48);
1:         xar.start(xid, XAResource.TMNOFLAGS);
1:         Connection conn = xaconn.getConnection();
1:         Statement s = conn.createStatement(); 
1:         if (doLoggedWorkInXact){
1:             // need to do some real work in our transaction
1:             // so make a table
1:             makeARealTable(s);
1:         }
1:         
1:         // make the temp table
1:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.T1 ( XWSID INT, XCTID INT, XIID CHAR(26), XVID SMALLINT, XLID CHAR(8) FOR BIT DATA) ON COMMIT DELETE ROWS NOT LOGGED ON ROLLBACK DELETE ROWS");
1:         // insert a row
0:         PreparedStatement ps = conn.prepareStatement("INSERT INTO SESSION.T1 VALUES (?,?,?,?,?)");
1:         ps.setInt(1,1);
1:         ps.setInt(2,1);
1:         ps.setString(3,"hello");
1:         ps.setShort(4, (short) 1);
1:         ps.setBytes(5, new byte[] {0x0,0x1});
1:         ps.executeUpdate();
1:         ResultSet rs = s.executeQuery("SELECT count(*) FROM SESSION.t1");
1:         JDBC.assertFullResultSet(rs, new String[][] {{"1"}});
0:         // You could work arond the issue by dropping the TEMP table
1:         //s.executeUpdate("DROP TABLE SESSION.T1");
1:         xar.end(xid, XAResource.TMSUCCESS);
0:         assertEquals(XAResource.XA_OK,xar.prepare(xid));
1:         xar.commit(xid,false); 
1:         s.close();
1:         conn.close();
1:         xaconn.close();
1:     }
1: 
1:     private void makeARealTable(Statement s) throws SQLException {
1:         try {
1:             s.executeUpdate("DROP TABLE REALTABLE1");
1:         } catch (SQLException se) {
1:             {
1:             s.executeUpdate("CREATE TABLE REALTABLE1 (i int)");
1:             }
1:         }
1:     }
1:     
1: 
1:     
1:     /**
commit:5b78c4e
/////////////////////////////////////////////////////////////////////////
1: import java.sql.CallableStatement;
/////////////////////////////////////////////////////////////////////////
1:         Statement preStatement = getConnection().createStatement();
1:         preStatement.execute("create table fooInterleaving (a int)");
1:         preStatement.execute("insert into fooInterleaving values (0)");
1:         preStatement.close();
1:         
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate("insert into APP.fooInterleaving values (1)");
1:         s.executeUpdate("insert into APP.fooInterleaving values (2)");
1:         s.executeUpdate("insert into APP.fooInterleaving values (3)");
1:         s.executeUpdate("insert into APP.fooInterleaving values (4)");
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs = s.executeQuery("select * from APP.fooInterleaving");
/////////////////////////////////////////////////////////////////////////
1:         Statement preStatement = getConnection().createStatement();
1:         preStatement.execute("create table fooMorph (a int)");
1:         preStatement.executeUpdate("insert into APP.fooMorph values (0)");
1:         preStatement.executeUpdate("insert into APP.fooMorph values (1)");
1:         preStatement.executeUpdate("insert into APP.fooMorph values (2)");
1:         preStatement.executeUpdate("insert into APP.fooMorph values (3)");
1:         preStatement.executeUpdate("insert into APP.fooMorph values (4)");
1:         preStatement.close();
1:         
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate("insert into APP.fooMorph values (2001)");
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate("insert into APP.fooMorph values (2002)");
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate("insert into APP.fooMorph values (2003)");
/////////////////////////////////////////////////////////////////////////
1:         s.executeQuery("select * from APP.fooMorph where A >= 2000").close();
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs = s.executeQuery("select * from APP.fooMorph where A >= 2000");
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate("insert into APP.fooMorph values (2005)");
1:         s.executeUpdate("insert into APP.fooMorph values (2006)");
1:         s.executeUpdate("insert into APP.fooMorph values (2007)");
/////////////////////////////////////////////////////////////////////////
1:         rs = s.executeQuery("select * from APP.fooMorph where A >= 2000");
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate("delete from app.fooMorph");
1:         rs = s.executeQuery("select * from APP.fooMorph");
/////////////////////////////////////////////////////////////////////////
1:         rs = s.executeQuery("select * from APP.fooMorph where A >= 2000");
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate("delete from APP.fooMorph");
1:         rs = s.executeQuery("select * from APP.fooMorph where A >= 2000");
/////////////////////////////////////////////////////////////////////////
1:         rs = s.executeQuery("select * from APP.fooMorph where A >= 2000");
/////////////////////////////////////////////////////////////////////////
1:      * This test checks the fix on DERBY-4310, for not repreparing PreparedStatements
1:      * upon calling close() on them.
1:      */
1:     public void testDerby4310PreparedStatement() throws SQLException, XAException {
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         J2EEDataSource.setBeanProperty(xads, "databaseName", "wombat");
1: 
1:         XAConnection xaconn = xads.getXAConnection();
1:        
1:         XAResource xar = xaconn.getXAResource();
1:         Xid xid = XATestUtil.getXid(1,93,18);
1:         
1:         /* Create the table and insert some records into it. */
1:         Connection conn = xaconn.getConnection();
1:         Statement s = conn.createStatement();
1:         s.executeUpdate("CREATE TABLE foo4310_PS (I INT)");
1: 
1:         conn.createStatement().executeUpdate("insert into APP.foo4310_PS values (0)");
1:         conn.createStatement().executeUpdate("insert into APP.foo4310_PS values (1)");
1:         conn.createStatement().executeUpdate("insert into APP.foo4310_PS values (2)");
1:         conn.commit();
1:         
1:         /* Prepare and execute the statement to be tested */
1:         PreparedStatement ps = conn.prepareStatement("SELECT * FROM APP.foo4310_PS");
1:         ps.executeQuery().close();
1: 
1:         /* Start and end a transaction on the XAResource object */
1:         xar.start(xid, XAResource.TMNOFLAGS);
1:         xar.end(xid, XAResource.TMSUCCESS);
1:         
1:         /* Drop the table on a parallel, regular connection */
1:         Connection conn2 = getConnection();
1:         Statement s2 = conn2.createStatement();
1:         s2.execute("DROP TABLE foo4310_PS");
1:         conn2.commit();
1:         conn2.close();
1:         
1:         try {
1:             /* Try to close the prepared statement. This would throw an exception
1:              * before the fix, claiming that the table was not found. */
1:             ps.close();
1:         } finally {
1:             /* Rollback the transaction and close the connections */
1:             xar.rollback(xid);
1:             conn.close();
1:             xaconn.close();
1:         }
1:         
1:     }
1:     
1:     /**
1:      * This test checks the fix on DERBY-4310, for not repreparing CallableStatements
1:      * upon calling close() on them.
1:      */
1:     public void testDerby4310CallableStatement() throws SQLException, XAException {
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         J2EEDataSource.setBeanProperty(xads, "databaseName", "wombat");
1: 
1:         XAConnection xaconn = xads.getXAConnection();
1:        
1:         XAResource xar = xaconn.getXAResource();
1:         Xid xid = XATestUtil.getXid(1,93,18);
1:         
1:         /* Create the procedure bazed on XATest.zeroArg() */
1:         Connection conn = xaconn.getConnection();
1:         Statement s = conn.createStatement();
1:         s.executeUpdate("CREATE PROCEDURE ZA() LANGUAGE JAVA "+
1:                         "EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.jdbcapi.XATest.zeroArg' "+
1:                         "PARAMETER STYLE JAVA");
1:         conn.commit();
1:         
1:         /* Prepare and execute CallableStatement based on the procedure above */
1:         CallableStatement cs = conn.prepareCall("CALL ZA()");
1:         cs.execute();
1: 
1:         /* Start and end a transaction on the XAResource object */
1:         xar.start(xid, XAResource.TMNOFLAGS);
1:         xar.end(xid, XAResource.TMSUCCESS);
1:         
1:         /* Drop the procedure on a parallel, regular connection */
1:         Connection conn2 = getConnection();
1:         Statement s2 = conn2.createStatement();
1:         s2.execute("DROP PROCEDURE ZA");
1:         conn2.commit();
1:         conn2.close();
1:         
1:         try {
1:             /* Try to close the prepared statement. This would throw an exception
1:              * before the fix, claiming that the table was not found. */
1:             cs.close();
1:         } finally {
1:             /* Rollback the transaction and close the connections */
1:             xar.rollback(xid);
1:             conn.close();
1:             xaconn.close();
1:         }
1:         
1:     }
1:     
1:     /**
1:         Statement preStatement = getConnection().createStatement();
1:         preStatement.execute("create table foo966 (a int)");
1:         preStatement.executeUpdate("insert into APP.foo966 values (0)");
1:         preStatement.executeUpdate("insert into APP.foo966 values (1)");
1:         preStatement.executeUpdate("insert into APP.foo966 values (2)");
1:         preStatement.executeUpdate("insert into APP.foo966 values (3)");
1:         preStatement.executeUpdate("insert into APP.foo966 values (4)");
1:         preStatement.executeUpdate("insert into APP.foo966 values (2001)");
1:         preStatement.executeUpdate("insert into APP.foo966 values (2002)");
1:         preStatement.executeUpdate("insert into APP.foo966 values (2003)");
1:         preStatement.executeUpdate("insert into APP.foo966 values (2005)");
1:         preStatement.executeUpdate("insert into APP.foo966 values (2007)");
1:         preStatement.close();
1:         
/////////////////////////////////////////////////////////////////////////
1:         checkHeldRS(conn, sdh, sdh.executeQuery("select * from app.foo966"));
1:         PreparedStatement psdh = conn.prepareStatement("SELECT * FROM APP.foo966");
1:                 .prepareStatement("DELETE FROM APP.foo966 WHERE A < -99");
/////////////////////////////////////////////////////////////////////////
1:         checkHeldRS(conn, shh, shh.executeQuery("select * from app.foo966"));
1:         PreparedStatement pshh = conn.prepareStatement("SELECT * FROM APP.foo966",
1:                 "DELETE FROM APP.foo966 WHERE A < -99",
/////////////////////////////////////////////////////////////////////////
1:         checkHeldRS(conn, sch, sch.executeQuery("select * from app.foo966"));
1:         PreparedStatement psch = conn.prepareStatement("SELECT * FROM APP.foo966",
1:                 "DELETE FROM APP.foo966 WHERE A < -99",
/////////////////////////////////////////////////////////////////////////
1:         checkHeldRS(conn, sdc, sdc.executeQuery("select * from app.foo966"));
1:         PreparedStatement psdc = conn.prepareStatement("SELECT * FROM APP.foo966");
1:                 .prepareStatement("DELETE FROM APP.foo966 WHERE A < -99");
/////////////////////////////////////////////////////////////////////////
1:         checkHeldRS(conn, shc, shc.executeQuery("select * from app.foo966"));
1:         PreparedStatement pshc = conn.prepareStatement("SELECT * FROM APP.foo966",
1:                 "DELETE FROM APP.foo966 WHERE A < -99",
/////////////////////////////////////////////////////////////////////////
1:         checkHeldRS(conn, scc, scc.executeQuery("select * from app.foo966"));
1:         PreparedStatement pscc = conn.prepareStatement("SELECT * FROM APP.foo966",
1:                 "DELETE FROM APP.foo966 WHERE A < -99",
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs = sdh.executeQuery("SELECT * FROM APP.foo966");
/////////////////////////////////////////////////////////////////////////
1:         rs = sdh.executeQuery("SELECT * FROM APP.foo966");
/////////////////////////////////////////////////////////////////////////
1:         sdh.executeUpdate("DELETE FROM APP.foo966 where A < -99");
1:         shh.executeUpdate("DELETE FROM APP.foo966 where A < -99");
1:         sch.executeUpdate("DELETE FROM APP.foo966 where A < -99");
1:         openRS.add(sdh.executeQuery("SELECT * FROM APP.foo966"));
1:         openRS.add(shh.executeQuery("SELECT * FROM APP.foo966"));
1:         openRS.add(sch.executeQuery("SELECT * FROM APP.foo966"));
/////////////////////////////////////////////////////////////////////////
1:         sdc.executeUpdate("DELETE FROM APP.foo966 where A < -99");
1:         shc.executeUpdate("DELETE FROM APP.foo966 where A < -99");
1:         scc.executeUpdate("DELETE FROM APP.foo966 where A < -99");
1:         openRS.add(sdc.executeQuery("SELECT * FROM APP.foo966"));
1:         openRS.add(shc.executeQuery("SELECT * FROM APP.foo966"));
1:         openRS.add(scc.executeQuery("SELECT * FROM APP.foo966"));
/////////////////////////////////////////////////////////////////////////
1:                     "SELECT * FROM APP.foo966", ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
1:     
1:     /** 
1:      * Dummy method for testDerby4310* fixtures
1:      */
1:     public static void zeroArg() {  }
/////////////////////////////////////////////////////////////////////////
1: 
commit:6bbc8fb
/////////////////////////////////////////////////////////////////////////
1:         conn.rollback();
commit:bb29639
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.jdbapi.XATest
1:  *  
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.J2EEDataSource;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: import org.apache.derbyTesting.junit.XATestUtil;
1: public class XATest extends BaseJDBCTestCase {
1:     public XATest(String name) {
1:         super(name);
1:      * 
1:      * Original "SQL" from xaSimplePositive.sql <code>
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @throws SQLException
1:      * @throws XAException
1:      * @throws XAException
1:     public void testSingleConnectionOnePhaseCommit() throws SQLException,
1:             XAException {
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         J2EEDataSource.setBeanProperty(xads, "databaseName", "wombat");
1:         XAConnection xac = xads.getXAConnection();
1:         XAResource xar = xac.getXAResource();
1:         Xid xid = XATestUtil.getXid(0, 32, 46);
1:         xar.start(xid, XAResource.TMNOFLAGS);
1:         Connection conn = xac.getConnection();
1:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, conn.getHoldability());
1:         Statement s = conn.createStatement();
1:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, s
1:                 .getResultSetHoldability());
1:         s.execute("create table foo (a int)");
1:         s.executeUpdate("insert into foo values (0)");
1:         ResultSet rs = s.executeQuery("select * from foo");
1:         JDBC.assertDrainResults(rs, 1);
1:         String[][] expectedRows = { { "(0", "ACTIVE", "false", "APP",
1:                 "UserTransaction" } };
1:         XATestUtil.checkXATransactionView(conn, expectedRows);
1:         s.close();
1:         xar.end(xid, XAResource.TMSUCCESS);
1: 
1:         // 1 phase commit
1:         xar.commit(xid, true);
1: 
1:         conn.close();
1:         xac.close();
1: 
1:      * 
1:      * <code> xa_datasource 'wombat'; xa_connect user 'sku' password 'testxa' ;
1:      * 
1:      * xa_start xa_noflags 1; xa_getconnection; insert into APP.foo values (1);
1:      * xa_end xa_suspend 1;
1:      * 
1:      * xa_start xa_noflags 2; insert into APP.foo values (2); xa_end xa_suspend
1:      * 2;
1:      * 
1:      * xa_start xa_resume 1; insert into APP.foo values (3); xa_end xa_suspend
1:      * 1;
1:      * 
1:      * xa_start xa_resume 2; insert into APP.foo values (4); select * from
1:      * APP.global_xactTable where gxid is not null order by gxid; -- this
1:      * prepare won't work since transaction 1 has been suspended - XA_PROTO
1:      * xa_prepare 1;
1:      * 
1:      * select * from APP.global_xactTable where gxid is not null order by gxid;
1:      * xa_end xa_success 2; -- this assumes a resume xa_end xa_success 1;
1:      * xa_prepare 1; xa_prepare 2; -- both transactions should be prepared
1:      * select * from APP.global_xactTable where gxid is not null order by gxid; --
1:      * NOTE: The following call to "xa_recover xa_startrscan" is apt to --
1:      * return the result set rows in reverse order when changes to -- the Derby
1:      * engine affect the number of transactions that it takes -- to create a
1:      * database. The transactions are stored in a hash table -- based on a
1:      * global and local id, and when the number of transactions -- changes, the
1:      * (internal) local id can change, which may lead to a -- change in the
1:      * result set order. This order is determined by the -- JVM's hashing
1:      * algorithm. Examples of changes to the engine that -- can affect this
1:      * include ones that cause more commits or that -- change the amount of data
1:      * being stored, such as changes to the -- metadata statements (which is
1:      * what prompted this explanation in -- the first place). Ultimately, the
1:      * problem is that there is no -- way to order the return values from
1:      * "xa_recover" since it is an -- ij internal statement, not SQL...
1:      * xa_recover xa_startrscan; xa_recover xa_noflags;
1:      * 
1:      * xa_commit xa_2Phase 1; xa_rollback 2; -- check results xa_start
1:      * xa_noflags 3; select * from APP.global_xactTable where gxid is not null
1:      * order by gxid; select * from APP.foo; xa_end xa_success 3;
1:      * 
1:      * xa_prepare 3; -- should fail with XA_NOTA because we prepared a read only
1:      * transaction xa_commit xa_1Phase 3; disconnect; </code>
1:     public void testInterleavingTransactions() throws SQLException, XAException {
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1: 
1:         XAConnection xac = xads.getXAConnection("sku", "testxa");
1:         XAResource xar = xac.getXAResource();
1: 
1:         Xid xid1 = XATestUtil.getXid(1, 93, 18);
1:         Xid xid2 = XATestUtil.getXid(2, 45, 77);
1: 
1:         xar.start(xid1, XAResource.TMNOFLAGS);
1: 
1:         Connection conn = xac.getConnection();
1: 
1:         Statement s = conn.createStatement();
0:         s.executeUpdate("insert into APP.foo values (1)");
1:         xar.end(xid1, XAResource.TMSUSPEND);
1: 
1:         xar.start(xid2, XAResource.TMNOFLAGS);
0:         s.executeUpdate("insert into APP.foo values (2)");
1:         xar.end(xid2, XAResource.TMSUSPEND);
1: 
1:         xar.start(xid1, XAResource.TMRESUME);
0:         s.executeUpdate("insert into APP.foo values (3)");
1:         xar.end(xid1, XAResource.TMSUSPEND);
1: 
1:         xar.start(xid2, XAResource.TMRESUME);
0:         s.executeUpdate("insert into APP.foo values (4)");
1: 
1:         String[][] expectedRows = {
1:                 { "(1", "ACTIVE", "false", "SKU", "UserTransaction" },
1:                 { "(2", "ACTIVE", "false", "SKU", "UserTransaction" } };
1: 
1:         XATestUtil.checkXATransactionView(conn, expectedRows);
1: 
1:         // this prepare won't work since
1:         // transaction 1 has been suspended - XA_PROTO
1:             fail("FAIL - prepare on suspended transaction");
1:             if (e.errorCode != XAException.XAER_PROTO)
1:                 XATestUtil.dumpXAException(
1:                         "FAIL - prepare on suspended transaction", e);
1: 
1: 
1:         // check it was not prepared
1: 
1:         XATestUtil.checkXATransactionView(conn, expectedRows);
1: 
1:         xar.end(xid2, XAResource.TMSUCCESS);
1: 
1:         xar.end(xid1, XAResource.TMSUCCESS);
1: 
1:         xar.prepare(xid1);
1:         xar.prepare(xid2);
1: 
1:         // both should be prepared.
1:         expectedRows = new String[][] {
1:                 { "(1", "PREPARED", "false", "SKU", "UserTransaction" },
1:                 { "(2", "PREPARED", "false", "SKU", "UserTransaction" } };
1: 
1:         XATestUtil.checkXATransactionView(conn, expectedRows);
1: 
1:         Xid[] recoveredStart = xar.recover(XAResource.TMSTARTRSCAN);
1:         assertEquals(2, recoveredStart.length);
1:         Xid[] recovered = xar.recover(XAResource.TMNOFLAGS);
1:         assertEquals(0, recovered.length);
1:         Xid[] recoveredEnd = xar.recover(XAResource.TMENDRSCAN);
1:         assertEquals(0, recoveredEnd.length);
1: 
1:         for (int i = 0; i < recoveredStart.length; i++) {
1:             Xid xid = recoveredStart[i];
1:             if (xid.getFormatId() == 1) {
1:                 // commit 1 with 2pc
1:                 xar.commit(xid, false);
1:             } else if (xid.getFormatId() == 2) {
1:                 xar.rollback(xid);
1:             } else {
1:                 fail("FAIL: unknown xact");
1:             }
1:         }
1: 
1:         // check the results
1:         Xid xid3 = XATestUtil.getXid(3, 2, 101);
1:         xar.start(xid3, XAResource.TMNOFLAGS);
1:         expectedRows = new String[][] { { "(3", "IDLE", "NULL", "SKU",
1:                 "UserTransaction" } };
1:         XATestUtil.checkXATransactionView(conn, expectedRows);
0:         ResultSet rs = s.executeQuery("select * from APP.foo");
1:         expectedRows = new String[][] { { "0" }, { "1" }, { "3" } };
1:         JDBC.assertFullResultSet(rs, expectedRows);
1: 
1:         rs.close();
1:         xar.end(xid3, XAResource.TMSUCCESS);
1: 
1:         int pr = xar.prepare(xid3);
1:         if (pr != XAResource.XA_RDONLY)
1:             fail("FAIL - prepare on read only xact returned " + pr);
1: 
1:         try {
1:             xar.commit(xid3, true);
1:             fail("FAIL - 2pc commit on read-only xact");
1:         } catch (XAException e) {
1:             if (e.errorCode != XAException.XAER_NOTA)
1:                 throw e;
1:         }
1: 
1:         s.close();
1:         conn.close();
1:         xac.close();
1: 
1:     /**
1:      * Tests on INIT STATE (no tr Original SQL from xaStateTran.sql. <code>
/////////////////////////////////////////////////////////////////////////
1:     public void testNoTransaction() throws SQLException, XAException {
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         XAConnection xac = xads.getXAConnection();
1:         XAResource xar = xac.getXAResource();
1: 
1:         Xid xid11 = XATestUtil.getXid(11, 3, 128);
1: 
1:             xar.start(xid11, XAResource.TMJOIN);
1:             if (e.errorCode != XAException.XAER_NOTA)
1:                 throw e;
1:         }
1: 
1:         try {
1:             xar.start(xid11, XAResource.TMRESUME);
1:         } catch (XAException e) {
1:             if (e.errorCode != XAException.XAER_NOTA)
1:                 throw e;
1:         }
1: 
1:         try {
1:             xar.end(xid11, XAResource.TMSUCCESS);
1:         } catch (XAException e) {
1:             if (e.errorCode != XAException.XAER_NOTA)
1:                 throw e;
1:         }
1:         try {
1:             xar.end(xid11, XAResource.TMFAIL);
1:         } catch (XAException e) {
1:             if (e.errorCode != XAException.XAER_NOTA)
1:                 throw e;
1:         }
1: 
1:         try {
1:             xar.end(xid11, XAResource.TMSUSPEND);
1:         } catch (XAException e) {
1:             if (e.errorCode != XAException.XAER_NOTA)
1:                 throw e;
1:         }
1: 
1:         try {
1:             xar.prepare(xid11);
1:         } catch (XAException e) {
1:             if (e.errorCode != XAException.XAER_NOTA)
1:                 throw e;
1:         }
1:         try {
1:             xar.commit(xid11, false);
1:         } catch (XAException e) {
1:             if (e.errorCode != XAException.XAER_NOTA)
1:                 throw e;
1:         }
1:         try {
1:             xar.commit(xid11, true);
1:         } catch (XAException e) {
1:             if (e.errorCode != XAException.XAER_NOTA)
1:                 throw e;
1:         }
1:         try {
1:             xar.rollback(xid11);
1:         } catch (XAException e) {
1:             if (e.errorCode != XAException.XAER_NOTA)
1:                 throw e;
1:         }
1:         try {
1:             xar.forget(xid11);
1:         } catch (XAException e) {
1:             if (e.errorCode != XAException.XAER_NOTA)
1:                 throw e;
1:     public void testMorph() throws SQLException, XAException {
1: 
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         XAConnection xac = xads.getXAConnection();
1: 
1:         XAResource xar = xac.getXAResource();
1: 
1:         Connection conn = xac.getConnection();
1: 
1:         /*
1:          * autocommit off; insert into foo values (1); select * from
1:          * global_xactTable where gxid is not null order by gxid,username;
1:          * commit;
1:          */
1:         conn.setAutoCommit(false);
1:         Statement s = conn.createStatement();
0:         s.executeUpdate("insert into APP.foo values (2001)");
1:         // no rows expected
1:         XATestUtil.checkXATransactionView(conn, null);
1:         conn.commit();
1: 
1:         /*
1:          * autocommit on; insert into foo values (2); select * from
1:          * global_xactTable where gxid is not null order by gxid,username;
1:          * 
1:          */
1: 
1:         conn.setAutoCommit(true);
0:         s.executeUpdate("insert into APP.foo values (2002)");
1:         XATestUtil.checkXATransactionView(conn, null);
1: 
1:         /*
1:          * -- morph the connection to a global transaction xa_start xa_noflags
1:          * 1; select * from global_xactTable where gxid is not null order by
1:          * gxid,username; insert into foo values (3);
1:          */
1: 
1:         Xid xid = XATestUtil.getXid(1001, 66, 13);
1:         xar.start(xid, XAResource.TMNOFLAGS);
1:         String[][] expectedRows = { { "(1", "IDLE", "NULL", "APP",
1:                 "UserTransaction" } };
1:         XATestUtil.checkXATransactionView(conn, expectedRows);
0:         s.executeUpdate("insert into APP.foo values (2003)");
1: 
1:         /*
1:          * -- disallowed commit; -- disallowed rollback; -- disallowed
1:          * autocommit on; -- OK autocommit off;
1:          */
1:         try {
1:             conn.commit();
1:             fail("FAIL: commit allowed in global xact");
1:         } catch (SQLException e) {
1:         }
1:             fail("FAIL: roll back allowed in global xact");
1:         } catch (SQLException e) {
1:         }
1:         try {
1:             conn.setAutoCommit(true);
1:             fail("FAIL: setAutoCommit(true) allowed " + "in global xact");
1:         } catch (SQLException e) {
1:         }
1:         try {
1:             conn.setSavepoint();
1:             fail("FAIL: setSavepoint() allowed in global xact");
1:         } catch (SQLException e) {
1:         }
1:         try {
1:             conn.setSavepoint("badsavepoint");
1:             fail("FAIL: setSavepoint(String) allowed in " + "global xact");
1:         } catch (SQLException e) {
1:         }
1: 
1:         conn.setAutoCommit(false);
1: 
1:         // s was created in local mode so it has holdibilty
1:         // set, will execute but ResultSet will have close on commit
1: 
1:         // DERBY-1158 query with holdable statement
0:         s.executeQuery("select * from APP.foo where A >= 2000").close();
1:         s.close();
1: 
1:         // statement created in global xact is CLOSE_CURSORS_AT_COMMIT
1:         s = conn.createStatement();
1:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, s
1:                 .getResultSetHoldability());
1: 
1:         /*
1:          * select * from foo; xa_end xa_success 1; xa_prepare 1;
1:          */
0:         ResultSet rs = s.executeQuery("select * from APP.foo where A >= 2000");
1:         expectedRows = new String[][] { { "2001" }, { "2002" }, { "2003" } };
1: 
1:         rs.close();
1: 
1:         xar.end(xid, XAResource.TMSUCCESS);
1:         xar.prepare(xid);
1: 
1:         /*
1:          * -- dup id xa_start xa_noflags 1;
1:          */
1:         try {
1:             xar.start(xid, XAResource.TMNOFLAGS);
1:             fail("FAIL - start with duplicate XID");
1:         } catch (XAException e) {
1:             if (e.errorCode != XAException.XAER_DUPID)
1:                 throw e;
1:         }
1: 
1:         /*
1:          * xa_start xa_noflags 2; -- still should disallow autommit; autocommit
1:          * on; -- still should disallow commit and rollback commit; rollback;
1:          * select * from global_xactTable where gxid is not null order by
1:          * gxid,username; xa_end xa_suspend 2;
1:          */
1: 
1:         Xid xid2 = XATestUtil.getXid(1002, 23, 3);
1:         xar.start(xid2, XAResource.TMNOFLAGS);
1:         try {
1:             fail("FAIL: commit allowed in global xact");
1:         } catch (SQLException e) {
1:         }
1:         try {
1:             conn.rollback();
1:             fail("FAIL: roll back allowed in global xact");
1:         } catch (SQLException e) {
1:         }
1:         try {
1:             conn.setAutoCommit(true);
1:             fail("FAIL: setAutoCommit(true) allowed in global xact");
1:         } catch (SQLException e) {
1:         }
1:         conn.setAutoCommit(false);
1:         xar.end(xid2, XAResource.TMSUSPEND);
1:         /*
1:          * -- get local connection again xa_getconnection;
1:          * 
1:          * insert into foo values (5); -- autocommit should be on by default;
1:          * commit;
1:          * 
1:          * autocommit off; insert into foo values (6); -- commit and rollback is
1:          * allowed on local connection rollback;
1:          * 
1:          * insert into foo values (6); commit;
1:          */
1:         conn = xac.getConnection();
1:         s = conn.createStatement();
0:         s.executeUpdate("insert into APP.foo values (2005)");
1:         conn.commit();
1:         conn.setAutoCommit(false);
0:         s.executeUpdate("insert into APP.foo values (2006)");
1:         conn.rollback();
0:         s.executeUpdate("insert into APP.foo values (2007)");
1:         conn.commit();
1:         expectedRows = new String[][] {
1:                 { "(1", "PREPARED", "false", "APP", "UserTransaction" },
1:                 { "(1", "IDLE", "NULL", "APP", "UserTransaction" } };
1:         XATestUtil.checkXATransactionView(conn, expectedRows);
1:         /*
1:          * -- I am still able to commit other global transactions while I am
1:          * attached to a -- local transaction. xa_commit xa_2phase 1; xa_end
1:          * xa_success 2; xa_rollback 2;
1:          */
1:         xar.commit(xid, false);
1:         xar.end(xid2, XAResource.TMSUCCESS);
1:         xar.rollback(xid2);
1:         XATestUtil.checkXATransactionView(conn, null);
0:         rs = s.executeQuery("select * from APP.foo where A >= 2000");
1:         expectedRows = new String[][] { { "2001" }, { "2002" }, { "2003" },
1:                 { "2005" }, { "2007" } };
1:         JDBC.assertFullResultSet(rs, expectedRows);
1:         rs.close();
1:         conn.close();
1:         /*
1:          * xa_getconnection; select * from global_xactTable where gxid is not
1:          * null order by gxid,username; select * from foo; autocommit off;
1:          * delete from foo;
1:          */
1:         conn = xac.getConnection();
1:         conn.setAutoCommit(false);
1:         s = conn.createStatement();
0:         s.executeUpdate("delete from app.foo");
0:         rs = s.executeQuery("select * from APP.foo");
1:         JDBC.assertEmpty(rs);
1:         rs.close();
1: 
1:         /*
1:          * -- yanking a local connection away should rollback the changes
1:          */
1:         conn = xac.getConnection();
1:         conn.setAutoCommit(false);
1:         s = conn.createStatement();
0:         rs = s.executeQuery("select * from APP.foo where A >= 2000");
1:         expectedRows = new String[][] { { "2001" }, { "2002" }, { "2003" },
1:                 { "2005" }, { "2007" } };
1:         JDBC.assertFullResultSet(rs, expectedRows);
1: 
1:         /*
1:          * -- cannot morph it if the local transaction is not idle xa_start
1:          * xa_noflags 3; commit; -- now morph it to a global transaction
1:          * xa_start xa_noflags 3;
1:          */
1:         Xid xid3 = XATestUtil.getXid(1003, 27, 9);
1:         try {
1:             fail("FAIL XAResource.start on a global transaction with an active local transaction (autocommit false)");
1:         } catch (XAException xae) {
1:             if (xae.errorCode != XAException.XAER_OUTSIDE)
1:                 throw xae;
1:         }
1:         conn.commit();
1:         xar.start(xid3, XAResource.TMNOFLAGS);
1:         /*
1:          * -- now I shouldn't be able to yank it xa_getconnection;
1:          */
1:         // DERBY-341 - client skip XAConnection with active local xact
1:         if (usingEmbedded()) {
1:                 fail("FAIL: getConnection with active global xact");
1:                 assertSQLState("XJ059", sqle);
1:         /*
1:          * select * from foo; delete from foo;
1:          * 
1:          * xa_end xa_fail 3; xa_rollback 3; -- local connection again
1:          * xa_getconnection; select * from global_xactTable where gxid is not
1:          * null order by gxid,username; select * from foo;
1:          */
1:         s = conn.createStatement();
0:         s.executeUpdate("delete from APP.foo");
0:         rs = s.executeQuery("select * from APP.foo where A >= 2000");
1:         JDBC.assertEmpty(rs);
1: 
1:         rs.close();
1:         try {
1:             xar.end(xid3, XAResource.TMFAIL);
1:         } catch (XAException e) {
1:             if (e.errorCode != XAException.XA_RBROLLBACK)
1:                 throw e;
1:         }
1:         xar.rollback(xid3);
1: 
1:         conn = xac.getConnection();
1:         s = conn.createStatement();
0:         rs = s.executeQuery("select * from APP.foo where A >= 2000");
1:         expectedRows = new String[][] { { "2001" }, { "2002" }, { "2003" },
1:                 { "2005" }, { "2007" } };
1:         JDBC.assertFullResultSet(rs, expectedRows);
1:         rs.close();
1: 
1:         s.close();
1:         conn.close();
1: 
1:      * Derby-966 holdability and global/location transactions. (work in
1:      * progress)
1:     public void testDerby966() throws SQLException, XAException {
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         XAConnection xac = xads.getXAConnection();
1:         XAResource xar = xac.getXAResource();
0:         Xid xid = XATestUtil.getXid(996, 9, 48);
1:         Connection conn = xac.getConnection();
1:         // Obtain Statements and PreparedStatements
1:         // with all the holdability options.
1:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, conn.getHoldability());
1:         Statement sdh = conn.createStatement();
1:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, sdh
1:                 .getResultSetHoldability());
1: 
0:         checkHeldRS(conn, sdh, sdh.executeQuery("select * from app.foo"));
0:         PreparedStatement psdh = conn.prepareStatement("SELECT * FROM APP.FOO");
1:         PreparedStatement psdh_d = conn
0:                 .prepareStatement("DELETE FROM APP.FOO WHERE A < -99");
1:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, psdh
1:                 .getResultSetHoldability());
1:         checkHeldRS(conn, psdh, psdh.executeQuery());
1: 
1:         Statement shh = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, shh
1:                 .getResultSetHoldability());
0:         checkHeldRS(conn, shh, shh.executeQuery("select * from app.foo"));
0:         PreparedStatement pshh = conn.prepareStatement("SELECT * FROM APP.FOO",
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:         PreparedStatement pshh_d = conn.prepareStatement(
0:                 "DELETE FROM APP.FOO WHERE A < -99",
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:                 ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, shh
1:                 .getResultSetHoldability());
1:         checkHeldRS(conn, pshh, pshh.executeQuery());
1:         Statement sch = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_READ_ONLY, ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, sch
1:                 .getResultSetHoldability());
0:         checkHeldRS(conn, sch, sch.executeQuery("select * from app.foo"));
0:         PreparedStatement psch = conn.prepareStatement("SELECT * FROM APP.FOO",
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:                 ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:         PreparedStatement psch_d = conn.prepareStatement(
0:                 "DELETE FROM APP.FOO WHERE A < -99",
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:                 ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psch_d
1:                 .getResultSetHoldability());
1:         checkHeldRS(conn, psch, psch.executeQuery());
1: 
1:         // set the connection's holdabilty to false
1:         conn.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
1: 
1:         Statement sdc = conn.createStatement();
1:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, sdc
1:                 .getResultSetHoldability());
0:         checkHeldRS(conn, sdc, sdc.executeQuery("select * from app.foo"));
0:         PreparedStatement psdc = conn.prepareStatement("SELECT * FROM APP.FOO");
1:         PreparedStatement psdc_d = conn
0:                 .prepareStatement("DELETE FROM APP.FOO WHERE A < -99");
1:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psdc
1:                 .getResultSetHoldability());
1:         checkHeldRS(conn, psdc, psdc.executeQuery());
1: 
1:         Statement shc = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psdc
1:                 .getResultSetHoldability());
0:         checkHeldRS(conn, shc, shc.executeQuery("select * from app.foo"));
0:         PreparedStatement pshc = conn.prepareStatement("SELECT * FROM APP.FOO",
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:                 ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:         PreparedStatement pshc_d = conn.prepareStatement(
0:                 "DELETE FROM APP.FOO WHERE A < -99",
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:                 ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, pshc
1:                 .getResultSetHoldability());
1: 
1:         checkHeldRS(conn, pshc, pshc.executeQuery());
1: 
1:         Statement scc = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_READ_ONLY, ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, scc
1:                 .getResultSetHoldability());
0:         checkHeldRS(conn, scc, scc.executeQuery("select * from app.foo"));
0:         PreparedStatement pscc = conn.prepareStatement("SELECT * FROM APP.FOO",
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:                 ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:         PreparedStatement pscc_d = conn.prepareStatement(
0:                 "DELETE FROM APP.FOO WHERE A < -99",
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:                 ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, pscc
1:                 .getResultSetHoldability());
1: 
1:         checkHeldRS(conn, pscc, pscc.executeQuery());
1: 
1:         // Revert back to holdable
1:         conn.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
1: 
0:         ResultSet rs = sdh.executeQuery("SELECT * FROM APP.FOO");
1:         // before commit
1:         assertEquals(0, +rs.getInt(1));
1:         // aftercommit
1:         rs.next();
1:         assertEquals(1, rs.getInt(1));
1:         rs.close();
1: 
1:         // ensure a transaction is active to test DERBY-1025
0:         rs = sdh.executeQuery("SELECT * FROM APP.FOO");
1: 
1:         // This switch to global is ok because conn
1:         // is in auto-commit mode, thus the start performs
1:         // an implicit commit to complete the local transaction.
1: 
1:         // start a global xact and test those statements.
1:         xar.start(xid, XAResource.TMNOFLAGS);
1: 
1:         // Statements not returning ResultSet's should be ok
0:         sdh.executeUpdate("DELETE FROM APP.FOO where A < -99");
0:         shh.executeUpdate("DELETE FROM APP.FOO where A < -99");
0:         sch.executeUpdate("DELETE FROM APP.FOO where A < -99");
1: 
0:         ArrayList openRS = new ArrayList();
1: 
1:         // Statements obtained while default was hold.
1:         // All should work, holability will be downgraded
1:         // to close on commit for those Statements with hold set.
0:         openRS.add(sdh.executeQuery("SELECT * FROM APP.FOO"));
0:         openRS.add(shh.executeQuery("SELECT * FROM APP.FOO"));
0:         openRS.add(sch.executeQuery("SELECT * FROM APP.FOO"));
1: 
1:         // PreparedStatements obtained while default was hold.
1:         // Holdability should be downgraded.
1:         openRS.add(psdh.executeQuery());
1:         openRS.add(pshh.executeQuery());
1:         openRS.add(psch.executeQuery());
1: 
1:         // Statements not returning ResultSet's should be ok
1:         psdh_d.executeUpdate();
1:         pshh_d.executeUpdate();
1:         psch_d.executeUpdate();
1: 
1:         // Statements not returning ResultSet's should be ok
0:         sdc.executeUpdate("DELETE FROM APP.FOO where A < -99");
0:         shc.executeUpdate("DELETE FROM APP.FOO where A < -99");
0:         scc.executeUpdate("DELETE FROM APP.FOO where A < -99");
1: 
1:         // Statements obtained while default was close.
1:         // all should return close on commit ResultSets
0:         openRS.add(sdc.executeQuery("SELECT * FROM APP.FOO"));
0:         openRS.add(shc.executeQuery("SELECT * FROM APP.FOO"));
0:         openRS.add(scc.executeQuery("SELECT * FROM APP.FOO"));
1: 
1:         // PreparedStatements obtained while default was close.
1:         openRS.add(psdc.executeQuery());
1:         openRS.add(pshc.executeQuery());
1:         openRS.add(pscc.executeQuery());
1: 
1:         // Statements not returning ResultSet's should be ok
1:         psdc_d.executeUpdate();
1:         pshc_d.executeUpdate();
1:         pscc_d.executeUpdate();
1: 
1:         // All the ResultSets should be open. Run a simple
1:         // test, clearWarnings throws an error if the ResultSet
1:         // is closed. Also would be nice here to use the new
1:         // JDBC 4.0 method getHoldabilty to ensure the
1:         // holdability is reported correctly.
1:         int orsCount = 0;
0:         for (Iterator i = openRS.iterator(); i.hasNext();) {
0:             ResultSet ors = (ResultSet) i.next();
1:             ors.clearWarnings();
1:             orsCount++;
1:         assertEquals("Incorrect number of open result sets", 12, orsCount);
1: 
1:         // Test we cannot switch the connection to holdable
1:         try {
1:             conn.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:             fail("FAIL - set holdability in global xact.");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ05C", sqle);
1:         }
1: 
1:         // JDBC 4.0 (proposed final draft) section allows
1:         // drivers to change the holdability when creating
1:         // a Statement object and attach a warning to the Connection.
1:         Statement sglobalhold = conn.createStatement(
1:                 ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
1:                 ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, sglobalhold
1:                 .getResultSetHoldability());
1: 
1:         sglobalhold.close();
1: 
1:         // DERBY2481 Client does not downgrade PreparedStatement holdability
1:         if (!usingDerbyNetClient()) {
1:             PreparedStatement psglobalhold = conn.prepareStatement(
0:                     "SELECT * FROM APP.FOO", ResultSet.TYPE_FORWARD_ONLY,
1:                     ResultSet.CONCUR_READ_ONLY,
1:                     ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psglobalhold
1:                     .getResultSetHoldability());
1: 
1:             psglobalhold.close();
1: 
1:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, sdh
1:                     .getResultSetHoldability());
1:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, sch
1:                     .getResultSetHoldability());
1: 
1:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psdh
1:                     .getResultSetHoldability());
1:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, pshh
1:                     .getResultSetHoldability());
1:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psch
1:                     .getResultSetHoldability());
1: 
1:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, sdc
1:                     .getResultSetHoldability());
1:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, shc
1:                     .getResultSetHoldability());
1:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, scc
1:                     .getResultSetHoldability());
1: 
1:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psdh_d
1:                     .getResultSetHoldability());
1:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, pshh_d
1:                     .getResultSetHoldability());
1:             assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psch_d
1:                     .getResultSetHoldability());
1:         }
1: 
1:         xar.end(xid, XAResource.TMSUCCESS);
1:         if (xar.prepare(xid) != XAResource.XA_RDONLY)
1:             fail("FAIL prepare didn't indicate r/o");
1: 
1:         // All the ResultSets should be closed. Run a simple
1:         // test, clearWarnings throws an error if the ResultSet
1:         // is closed.
1:         int crsCount = 0;
0:         for (Iterator i = openRS.iterator(); i.hasNext();) {
0:             ResultSet crs = (ResultSet) i.next();
1:             try {
1:                 crs.clearWarnings();
1:             } catch (SQLException sqle) {
1:             }
1:             crsCount++;
1:         }
1:         assertEquals("After global transaction closed ResultSets ", 12,
1:                 crsCount);
1: 
1:         // Check the statements revert to holdable as required.
1:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, sdh
1:                 .getResultSetHoldability());
1:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, shh
1:                 .getResultSetHoldability());
1:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, sch
1:                 .getResultSetHoldability());
1: 
1:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, psdh
1:                 .getResultSetHoldability());
1:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, pshh
1:                 .getResultSetHoldability());
1:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psch
1:                 .getResultSetHoldability());
1: 
1:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, sdc
1:                 .getResultSetHoldability());
1:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, shc
1:                 .getResultSetHoldability());
1:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, scc
1:                 .getResultSetHoldability());
1: 
1:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, psdh_d
1:                 .getResultSetHoldability());
1:         assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, pshh_d
1:                 .getResultSetHoldability());
1:         assertEquals(ResultSet.CLOSE_CURSORS_AT_COMMIT, psch_d
1:                 .getResultSetHoldability());
1: 
1:         conn.close();
1: 
1:     }
1: 
1:     /**
1:      * Check the held state of a ResultSet by fetching one row, executing a
1:      * commit and then fetching the next. Checks the held state matches the
1:      * behaviour.
1:      */
1:     private static void checkHeldRS(Connection conn, Statement s, ResultSet rs)
1:             throws SQLException {
1:         // DERBY-1008 - can't run with client
1:         if (!usingDerbyNetClient()) {
1:             if (s.getConnection() != conn)
1:                 fail("FAIL - mismatched statement & Connection");
1:         }
1:         if (rs.getStatement() != s) {
1:             // DERBY-1009
1:             fail("FAIL - mismatched statement & ResultSet "
1:                     + " Statement class " + s.getClass()
1:                     + " ResultSet' Statements class "
1:                     + rs.getStatement().getClass());
1:         }
1: 
1:         boolean held = (ResultSet.HOLD_CURSORS_OVER_COMMIT == s
1:                 .getResultSetHoldability());
1:         rs.next();
1:         assertEquals(0, rs.getInt(1));
1:         conn.commit();
1: 
1:         try {
1:             rs.next();
1:         } catch (SQLException sqle) {
1:             boolean ok = !held;
1: 
1:             if (ok) {
1:                 assertSQLState("XCL16", sqle);
1:             } else {
1:                 fail("Held cursor closed on commit");
1:             }
1:         }
1: 
1: 
1:     public static Test baseSuite(String name) {
0:         TestSuite suite = new TestSuite(name);
1:         suite.addTestSuite(XATest.class);
1: 
1:         return new CleanDatabaseTestSetup(suite) {
1:             /**
1:              * Creates the table used in the test cases.
1:              * 
1:              */
1:             protected void decorateSQL(Statement s) throws SQLException {
0:                 Connection conn = getConnection();
0:                 XATestUtil.createXATransactionView(conn);
1:             }
1: 
1:         };
1:     }
1: 
1:      * Runs the test fixtures in embedded and client.
1:      * 
1:      * @return test suite
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("XATest");
1:         // no XA for JSR169
1:         if (JDBC.vmSupportsJSR169())
1:             return suite;
1:         suite.addTest(baseSuite("XATest:embedded"));
1: 
1:         suite.addTest(TestConfiguration
1:                 .clientServerDecorator(baseSuite("XATest:client")));
1:         return suite;
commit:1a7cb26
/////////////////////////////////////////////////////////////////////////
1:             rs.close();
1:            
0:             // ensure a transaction is active to test DERBY-1025
0:             rs = sdh.executeQuery("SELECT * FROM APP.FOO");
1:            
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:452d467
/////////////////////////////////////////////////////////////////////////
1:         if (doLoggedWorkInXact)
1:         {
1:             // if you don't do logged work in the transaction, then the 
1:             // prepare with be done with XAResource.XA_RDONLY.  If you
1:             // try to commit a prepared read only transaction you will get 
1:             // an error, so only commit prepared transactions here that did
1:             // some "real" logged work.
0:             xar.commit(xid,false); 
1:         }
commit:6819a86
/////////////////////////////////////////////////////////////////////////
1:      * Verifies that global temporary table can not be accessed after the
1:      * commit of the XA transaction.
1:     public void testXATempTableD4743() 
/////////////////////////////////////////////////////////////////////////
1:             // temp table should not be available after commit of an XA
1:             // transaction.
1:             assertStatementError(
1:                 "42X05", s, "SELECT count(*) FROM SESSION.t1");
commit:2d08e7a
/////////////////////////////////////////////////////////////////////////
1:         rs.close();
/////////////////////////////////////////////////////////////////////////
0:             rs.close();
1:             conn.commit();
1: 
commit:af45571
/////////////////////////////////////////////////////////////////////////
1:         doXATempTableD4731Work(true, false, XATestUtil.getXid(997, 9, 49));
1:      * DERBY-4735 Temp tables with XA transactions
/////////////////////////////////////////////////////////////////////////
1:     public void xtestXATempTableD4735_Assert() 
1:           doXATempTableD4731Work(false, false, XATestUtil.getXid(999,  11, 51));
1:           doXATempTableD4731Work(false, true,  XATestUtil.getXid(1000, 12, 52));
1:     }
1: 
1:     /**
1:      * DERBY-4743 Temp tables with XA transactions
1:      *
0:      * Will throw an error in network server when attempt is made to 
0:      * access the global temporary table after the end and commit.
1:      *
1:      * @throws XAException 
1:      * @throws SQLException 
1:      * 
1:      */
0:     public void xtestXATempTableD4743() 
1:         throws SQLException, XAException {
1: 
1:           doXATempTableD4731Work(true, true, XATestUtil.getXid(998, 10, 50));
/////////////////////////////////////////////////////////////////////////
1:     boolean access_temp_table_after_xaendandcommit,
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (access_temp_table_after_xaendandcommit)
1:         {
0:             // is temp table empty after the commit?
0:             rs = s.executeQuery("SELECT count(*) FROM SESSION.t1");
0:             JDBC.assertFullResultSet(rs, new String[][] {{"0"}});
1:         }
1: 
1: 
commit:2c70a31
/////////////////////////////////////////////////////////////////////////
1:      * Test using a GLOBAL TEMPORARY TABLE  table in an
1:      * XA transaction and leaving it active during two phase commit.
1:      * Before the fix this test would throw the following at commit
1:      * time:
1:      * ERROR 40XT0: An internal error was identified by RawStore module. 
1:      *
1:      *
1:     public void testXATempTableD4731_RawStore() 
1:         throws SQLException, XAException {
0:         doXATempTableD4731Work(true, XATestUtil.getXid(997, 9, 49));
0:      * DERBY-XXXX Temp tables with XA transactions
1:      *
0:     public void xtestXATempTableDXXXX_Assert() 
1:         throws SQLException, XAException {
1: 
0:           doXATempTableD4731Work(false, XATestUtil.getXid(998, 10, 50));
1:      * logged work causes the RawStore error and doing only temp table 
1:      * operations causes the assert.
1:     private void doXATempTableD4731Work(
1:     boolean doLoggedWorkInXact,
1:     Xid     xid)
1:         throws SQLException, XAException{
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         PreparedStatement ps = 
1:             conn.prepareStatement("INSERT INTO SESSION.T1 VALUES (?,?,?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:         // You could work around the issue by dropping the TEMP table
1: 
1:         assertEquals(
1:             (doLoggedWorkInXact ? XAResource.XA_OK : XAResource.XA_RDONLY),
1:             xar.prepare(xid));
1: 
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4c80863
/////////////////////////////////////////////////////////////////////////
1:                 XATestUtil.createXATransactionView(s);
commit:4f2355d
/////////////////////////////////////////////////////////////////////////
1:            
/////////////////////////////////////////////////////////////////////////
1:  
/////////////////////////////////////////////////////////////////////////
commit:175a740
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             ArrayList openRS = new ArrayList();
1:             
0:             // Statements obtained while default was hold.
0:             // All should work, holability will be downgraded
0:             // to close on commit for those Statements with hold set.
0:             openRS.add(sdh.executeQuery("SELECT * FROM APP.FOO"));
0:             openRS.add(shh.executeQuery("SELECT * FROM APP.FOO"));
0:             openRS.add(sch.executeQuery("SELECT * FROM APP.FOO"));
1: 
0:             // Holdability should be downgraded.
0:             openRS.add(psdh.executeQuery());
0:             openRS.add(pshh.executeQuery());
0:             openRS.add(psch.executeQuery());
/////////////////////////////////////////////////////////////////////////
1: 
1:             }             
1:  
0:             // Statements obtained while default was close.
0:             // all should return close on commit ResultSets
0:             openRS.add(sdc.executeQuery("SELECT * FROM APP.FOO"));
0:             openRS.add(shc.executeQuery("SELECT * FROM APP.FOO"));
0:             openRS.add(scc.executeQuery("SELECT * FROM APP.FOO"));
0:             openRS.add(psdc.executeQuery());
0:             openRS.add(pshc.executeQuery());
0:             openRS.add(pscc.executeQuery());
/////////////////////////////////////////////////////////////////////////
1:             
0:             // All the ResultSets should be open. Run a simple
0:             // test, clearWarnings throws an error if the ResultSet
0:             // is closed. Also would be nice here to use the new
0:             // JDBC 4.0 method getHoldabilty to ensure the
0:             // holdability is reported correctly.
0:             int orsCount = 0;
0:             for (Iterator i = openRS.iterator(); i.hasNext();) {
0:                 ResultSet ors = (ResultSet) i.next();
0:                 ors.clearWarnings();
0:                 orsCount++;
1:             }
0:             System.out.println("Global transaction open ResultSets " + orsCount);
/////////////////////////////////////////////////////////////////////////
1:             
0:             if (!TestUtil.isDerbyNetClientFramework()) { //DERBY-1158 in progress
0:             // Show the holdability for all the Statements while
0:             // in the global transaction, all should be close on commit.
0:             showHoldStatus("Global xact Statement sdh ", sdh);
0:             showHoldStatus("Global xact Statement shh ", shh);
0:             showHoldStatus("Global xact Statement sch ", sch);
1:             
0:             showHoldStatus("Global xact Statement psdh ", psdh);
0:             showHoldStatus("Global xact Statement pshh ", pshh);
0:             showHoldStatus("Global xact Statement psch ", psch);
1:             
0:             showHoldStatus("Global xact Statement sdc ", sdc);
0:             showHoldStatus("Global xact Statement shc ", shc);
0:             showHoldStatus("Global xact Statement scc ", scc);
1:  
0:             showHoldStatus("Global xact Statement psdh_d ", psdh_d);
0:             showHoldStatus("Global xact Statement pshh_d ", pshh_d);
0:             showHoldStatus("Global xact Statement psch_d ", psch_d);
1:             }
1:  
0:             // All the ResultSets should be closed. Run a simple
0:             // test, clearWarnings throws an error if the ResultSet
0:             // is closed.
0:             int crsCount = 0;
0:             for (Iterator i = openRS.iterator(); i.hasNext();) {
0:                 ResultSet crs = (ResultSet) i.next();
1:                 try {
0:                     crs.clearWarnings();
1:                 } catch (SQLException sqle) {
1:                 }
0:                 crsCount++;
1:             }
0:             System.out.println("After global transaction closed ResultSets " + crsCount);
1: 
1:             
0:             // Check the statements revert to holdable as required.
0:             showHoldStatus("Global xact Statement sdh ", sdh);
0:             showHoldStatus("Global xact Statement shh ", shh);
0:             showHoldStatus("Global xact Statement sch ", sch);
1:             
0:             showHoldStatus("Global xact Statement psdh ", psdh);
0:             showHoldStatus("Global xact Statement pshh ", pshh);
0:             showHoldStatus("Global xact Statement psch ", psch);
1:  
0:             showHoldStatus("Global xact Statement sdc ", sdc);
0:             showHoldStatus("Global xact Statement shc ", shc);
0:             showHoldStatus("Global xact Statement scc ", scc);
1:             
0:             showHoldStatus("Global xact Statement psdh_d ", psdh_d);
0:             showHoldStatus("Global xact Statement pshh_d ", pshh_d);
0:             showHoldStatus("Global xact Statement psch_d ", psch_d);
1:             
/////////////////////////////////////////////////////////////////////////
0:         s.getConnection().clearWarnings();
commit:1128268
/////////////////////////////////////////////////////////////////////////
0: import java.sql.SQLWarning;
/////////////////////////////////////////////////////////////////////////
0:             // set, will execute but ResultSet will have close on commit
1: 
0:             if (TestUtil.isDerbyNetClientFramework()) { // DERBY-1158
0:             s.executeQuery("select * from APP.foo where A >= 2000").close();
0:             System.out.println("OK: query with holdable statement");
1:             
1:             
/////////////////////////////////////////////////////////////////////////
0:             // All should work, holability will be downgraded
0:             // to close on commit for those Statements with hold set.
0:             if (TestUtil.isDerbyNetClientFramework()) { // DERBY-1158
0:             sdh.executeQuery("SELECT * FROM APP.FOO").close();
0:             shh.executeQuery("SELECT * FROM APP.FOO").close();
/////////////////////////////////////////////////////////////////////////
0:                 System.out.println("FAIL - held Statement in global psdf");
0:                 System.out.println("FAIL - held Statement in global pshh");
/////////////////////////////////////////////////////////////////////////
0:             if (TestUtil.isDerbyNetClientFramework()) { // DERBY-1158
0:             shc.executeQuery("SELECT * FROM APP.FOO").close();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             // JDBC 4.0 (proposed final draft) section allows
0:             // drivers to change the holdability when creating
0:             // a Statement object and attach a warning to the Connection.
0:             Statement sglobalhold = conn.createStatement(
0:             showHoldStatus("Global createStatement(hold)", sglobalhold);
0:             sglobalhold.close();
1: 
0:             PreparedStatement psglobalhold = conn.prepareStatement(
0:             showHoldStatus("Global prepareStatement(hold)", psglobalhold);
0:             psglobalhold.close();
1: 
1:         
/////////////////////////////////////////////////////////////////////////
0:         SQLWarning w = s.getConnection().getWarnings();
0:         while (w != null)
0:         {
0:             System.out.println(w.getSQLState() + " :" + w.toString());
0:             w = w.getNextWarning();
1:         }
1:         
commit:0bf3bf8
/////////////////////////////////////////////////////////////////////////
0:             PreparedStatement psdh_d = conn.prepareStatement("DELETE FROM APP.FOO WHERE A < -99");
/////////////////////////////////////////////////////////////////////////
0:             PreparedStatement pshh_d =
0:                 conn.prepareStatement("DELETE FROM APP.FOO WHERE A < -99",
0:                         ResultSet.TYPE_FORWARD_ONLY,
0:                         ResultSet.CONCUR_READ_ONLY,
1:                         ResultSet.HOLD_CURSORS_OVER_COMMIT);
/////////////////////////////////////////////////////////////////////////
0:             PreparedStatement psch_d =
0:                 conn.prepareStatement("DELETE FROM APP.FOO WHERE A < -99",
0:                         ResultSet.TYPE_FORWARD_ONLY,
0:                         ResultSet.CONCUR_READ_ONLY,
0:                         ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:              showHoldStatus("Local(held) close Prepared", psch);
/////////////////////////////////////////////////////////////////////////
0:             PreparedStatement psdc_d = conn.prepareStatement("DELETE FROM APP.FOO WHERE A < -99");
/////////////////////////////////////////////////////////////////////////
0:             PreparedStatement pshc_d =
0:                 conn.prepareStatement("DELETE FROM APP.FOO WHERE A < -99",
0:                         ResultSet.TYPE_FORWARD_ONLY,
0:                         ResultSet.CONCUR_READ_ONLY,
0:                         ResultSet.HOLD_CURSORS_OVER_COMMIT);
/////////////////////////////////////////////////////////////////////////
0:             PreparedStatement pscc_d =
0:                 conn.prepareStatement("DELETE FROM APP.FOO WHERE A < -99",
0:                         ResultSet.TYPE_FORWARD_ONLY,
0:                         ResultSet.CONCUR_READ_ONLY,
0:                         ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:              showHoldStatus("Local(close) close Prepared", pscc);
/////////////////////////////////////////////////////////////////////////
1:                         
0:             // Statements not returning ResultSet's should be ok
0:             if (!TestUtil.isDerbyNetClientFramework()) { // DERBY-1159
0:             sdh.executeUpdate("DELETE FROM APP.FOO where A < -99");
0:             shh.executeUpdate("DELETE FROM APP.FOO where A < -99");
0:             sch.executeUpdate("DELETE FROM APP.FOO where A < -99");
1:             }
1:             
/////////////////////////////////////////////////////////////////////////
1:             
0:             // Statements not returning ResultSet's should be ok
0:             if (!TestUtil.isDerbyNetClientFramework()) { // DERBY-1159
0:             psdh_d.executeUpdate();
0:             pshh_d.executeUpdate();
0:             psch_d.executeUpdate();
1:             }
/////////////////////////////////////////////////////////////////////////
0:             // Statements not returning ResultSet's should be ok
0:             if (!TestUtil.isDerbyNetClientFramework()) { // DERBY-1159
0:             sdc.executeUpdate("DELETE FROM APP.FOO where A < -99");
0:             shc.executeUpdate("DELETE FROM APP.FOO where A < -99");
0:             scc.executeUpdate("DELETE FROM APP.FOO where A < -99");
1:             }
1:             
/////////////////////////////////////////////////////////////////////////
1:             
0:             // Statements not returning ResultSet's should be ok
0:             if (!TestUtil.isDerbyNetClientFramework()) { // DERBY-1159
0:             psdc_d.executeUpdate();
0:             pshc_d.executeUpdate();
0:             pscc_d.executeUpdate();
1:             }
1: 
commit:4388f15
/////////////////////////////////////////////////////////////////////////
0:                    
0:             // Test we cannot switch the connection to holdable
0:             // or create a statement with holdable.
1:             try {
0:                 conn.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:                 System.out.println("FAIL - set holdability in global xact.");
0:             } catch (SQLException sqle)
0:             {
0:                 TestUtil.dumpSQLExceptions(sqle, true);
1:             }
1:             try {
0:                     conn.createStatement(
0:                     ResultSet.TYPE_FORWARD_ONLY,
0:                     ResultSet.CONCUR_READ_ONLY,
0:                     ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:                     System.out.println("FAIL - Statement holdability in global xact.");
0:             } catch (SQLException sqle) {
0:                 TestUtil.dumpSQLExceptions(sqle, true);
1:             }
1:             try {
0:                 conn.prepareStatement(
0:                 "SELECT * FROM APP.FOO",
0:                 ResultSet.TYPE_FORWARD_ONLY,
0:                 ResultSet.CONCUR_READ_ONLY,
0:                 ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:                 System.out.println("FAIL - PreparedStatement holdability in global xact.");
0:         } catch (SQLException sqle) {
0:             TestUtil.dumpSQLExceptions(sqle, true);
1:         }
0:             conn.close();
0:             
/////////////////////////////////////////////////////////////////////////
1:     /*
0:      * 5 interleaving transactions.
0:      * Taken from the SQL test xaANotherTest.
0:      * <code>
0: xa_connect user 'mamta' password 'mamta' ;
0: 
0: -- global connection 1
0: xa_start xa_noflags 1;
1: xa_getconnection;
0: insert into APP.foo values (1);
0: xa_end xa_suspend 1;
0: 
0: -- global connection 2
0: xa_start xa_noflags 2;
0: insert into APP.foo values (2);
0: xa_end xa_suspend 2;
0: 
0: -- global connection 3
0: xa_start xa_noflags 3;
0: insert into APP.foo values (3);
0: xa_end xa_suspend 3;
0: 
0: -- global connection 4
0: xa_start xa_noflags 4;
0: insert into APP.foo values (4);
0: xa_end xa_suspend 4;
0: 
0: -- global connection 5
0: xa_start xa_noflags 5;
0: insert into APP.foo values (5);
0: xa_end xa_suspend 5;
0: 
0: xa_start xa_resume 1;
0: insert into APP.foo values (11);
0: xa_end xa_suspend 1;
0: 
0: xa_start xa_resume 5;
0: insert into APP.foo values (55);
0: xa_end xa_suspend 5;
0: 
0: xa_start xa_resume 2;
0: insert into APP.foo values (22);
0: xa_end xa_suspend 2;
0: 
0: xa_start xa_resume 4;
0: insert into APP.foo values (44);
0: xa_end xa_suspend 4;
0: 
0: xa_start xa_resume 3;
0: insert into APP.foo values (33);
0: xa_end xa_suspend 3;
0: 
0: -- prepare all the global connections except the first one. This way, we will see all
0: -- the global transactions prepared so far after the database shutdown and restart.
0: xa_end xa_success 2;
0: xa_prepare 2;
0: xa_end xa_success 3;
0: xa_prepare 3;
0: xa_end xa_success 4;
0: xa_prepare 4;
0: xa_end xa_success 5;
0: xa_prepare 5;
0: 
0:      * </code>
1:      */
0:     private static void interleavingTransactions5(XADataSource xads) throws SQLException
0:     {
0:         System.out.println("interleavingTransactions5");
0:         
0:         XAConnection xac = xads.getXAConnection("mamta", "mamtapwd");
0:         
0:     }
0:  
commit:11a698e
/////////////////////////////////////////////////////////////////////////
0:             if (TestUtil.isDerbyNetClientFramework()) {
0:                 System.out.println("DERBY-1004 Call conn.close to avoid exception with client");
0:             }
/////////////////////////////////////////////////////////////////////////
0:             if (TestUtil.isDerbyNetClientFramework()) {
0:                 System.out.println("DERBY-1004 Call conn.rollback to avoid exception with client");
0:             }
/////////////////////////////////////////////////////////////////////////
0:                 System.out.println("FAIL XAResource.start on a global transaction with an active local transaction (autocommit false)");
0:                 if (xae.errorCode != XAException.XAER_OUTSIDE)
0:                 System.out.println("Correct XAException on starting a global transaction with an active local transaction (autocommit false)");
/////////////////////////////////////////////////////////////////////////
0:             if (TestUtil.isDerbyNetClientFramework()) {
0:                 System.out.println("DERBY-341 - Client skipping XAConnection with active local transaction");              
0:             } else {
/////////////////////////////////////////////////////////////////////////
0:             }
/////////////////////////////////////////////////////////////////////////
0:             if (TestUtil.isDerbyNetClientFramework()) {
0:                 System.out.println("DERBY-1025 Call conn.commit to avoid exception with client");
0:             }
/////////////////////////////////////////////////////////////////////////
0:             boolean ok = !held;
0:             boolean showError = true;
0:             if (ok) {
0:                 if (TestUtil.isEmbeddedFramework()) {
0:                     if ("XCL16".equals(sqle.getSQLState()))
0:                         showError = false;
0:                 } else if (TestUtil.isDerbyNetClientFramework()) {
0:                     // No SQL state yet from client error.
0:                     showError = false;
0:                 }
0:             }
0:             if (showError)
0:                 TestUtil.dumpSQLExceptions(sqle, ok);
0:             else if (ok)
0:                 System.out.println("Non-held ResultSet correctly closed after commit");
commit:e07f9c9
/////////////////////////////////////////////////////////////////////////
0:         
0:         showHoldStatus("initial ", dmc);
0:         
/////////////////////////////////////////////////////////////////////////
0:             
0:             showHoldStatus("XA ", conn);
0:             showHoldStatus("XA ", s);
/////////////////////////////////////////////////////////////////////////
0:             sqle.printStackTrace(System.out);
/////////////////////////////////////////////////////////////////////////
0:                 if ((xae.errorCode != XAException.XAER_OUTSIDE)
0:                     &&
0:                     // DERBY-1024
0:                     (xae.errorCode != XAException.XAER_RMFAIL))
/////////////////////////////////////////////////////////////////////////
0:             showHoldStatus("Local ", conn);
/////////////////////////////////////////////////////////////////////////
0:             rs.next(); System.out.println("BGBC " + rs.getInt(1));
0:             rs.next(); System.out.println("BGAC " + rs.getInt(1));
0:             // This switch to global is ok because conn
0:             // is in auto-commit mode, thus the start performs
0:             // an implicit commit to complete the local transaction.
0:             
0:             // DERBY-1025 Client only bug
0:             if (TestUtil.isDerbyNetClientFramework())
1:                 conn.commit();
0:             System.out.println("START GLOBAL TRANSACTION");
/////////////////////////////////////////////////////////////////////////
0:             xar.end(xid, XAResource.TMSUCCESS);
0:             if (xar.prepare(xid) != XAResource.XA_RDONLY)
0:                 System.out.println("FAIL prepare didn't indicate r/o");
0:             
0:             System.out.println("derby966 complete");
0:                 
/////////////////////////////////////////////////////////////////////////
0:         System.out.println("ResultSet " + holdStatus(s.getResultSetHoldability()));
0:             while (rs.next())
0:             {
0:                 rs.getInt(1);
0:                 System.out.println("  AC A=" + rs.getInt(1));
0:             }
0:              TestUtil.dumpSQLExceptions(sqle, !held);
/////////////////////////////////////////////////////////////////////////
0:         System.out.println(tag + "Statement holdable " +
0:                 holdStatus(s.getResultSetHoldability()));
1:     /**
0:      * Show the held status of the Connection.
1:     */
0:     private static void showHoldStatus(String tag, Connection conn) throws SQLException
0:     {
0:         System.out.println(tag + "Connection holdable " +
0:                 holdStatus(conn.getHoldability()));
0:     }
0:     
0:     private static String holdStatus(int holdability)
0:     {
0:         String s;
0:         switch (holdability)
0:         {
0:         case ResultSet.CLOSE_CURSORS_AT_COMMIT:
0:             s = "CLOSE_CURSORS_AT_COMMIT ";
0:             break;
0:         case ResultSet.HOLD_CURSORS_OVER_COMMIT:
0:             s = "HOLD_CURSORS_OVER_COMMIT ";
0:             break;
0:         default:
0:             s = "UNKNOWN HOLDABILITY ";
0:             break;
0:         }
0:         
0:         return s + Integer.toString(holdability);
0:     }
0:     
commit:6e10422
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:  Derby - Class org.apache.derby.impl.services.bytecode.CodeChunk
0: 
0:  Copyright 2006 The Apache Software Foundation or its licensors, as applicable.
0: 
0:  Licensed under the Apache License, Version 2.0 (the "License");
0:  you may not use this file except in compliance with the License.
0:  You may obtain a copy of the License at
0: 
0:  http://www.apache.org/licenses/LICENSE-2.0
0: 
0:  Unless required by applicable law or agreed to in writing, software
0:  distributed under the License is distributed on an "AS IS" BASIS,
0:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  See the License for the specific language governing permissions and
0:  limitations under the License.
0: 
1:  */
0: 
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
0: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
0: import java.util.Properties;
0: 
1: import javax.sql.XAConnection;
1: import javax.sql.XADataSource;
1: import javax.transaction.xa.XAException;
1: import javax.transaction.xa.XAResource;
1: import javax.transaction.xa.Xid;
0: 
0: import org.apache.derby.tools.JDBCDisplayUtil;
0: import org.apache.derby.tools.ij;
0: import org.apache.derbyTesting.functionTests.util.TestUtil;
0: import org.apache.derbyTesting.functionTests.util.XATestUtil;
0: 
1: /**
0:  * XATests harvested from SQL XA tests.
0:  * Modified so that they can be run with NetworkServer.
1:  */
0: public class XATest {
0: 
1:     /**
0:      * Run all the tests.
1:      */
0:     public static void main(String[] args) throws Exception {
0:         ij.getPropertyArg(args);
0:         Connection dmc = ij.startJBMS();
0: 
0:         XATestUtil.createXATransactionView(dmc);
0:         dmc.close();
0: 
0:         XADataSource dsx = TestUtil.getXADataSource(cleanProperties());
0: 
0:         // tests originally from xaSimplePositive.sql
0:         singleConnectionOnePhaseCommit(dsx);
0:         xaShutdown();
0:         interleavingTransactions(dsx);
0: 
0:         xaShutdown();
0: 
0:         // tests originally from xaStateTran.sql
0:         noTransaction(dsx);
0: 
0:         // test originally from xaMorph.sql
0:         morph(dsx);
0:         
0:         // DERBY-966 holdability testing
0:         derby966(dsx);
0: 
0:         System.out.println("XATest complete");
0:     }
0: 
1:     /**
0:      * Get the basic set of properties for an XADataSource.
0:      * Only sets databaseName to wombat.
0:      * @return
1:      */
0:     private static Properties cleanProperties() {
0:         Properties dsAttrs = new Properties();
0:         dsAttrs.setProperty("databaseName", "wombat");
0:         return dsAttrs;
0:     }
0: 
1:     /**
0:      * Shutdown the database through an XADataSource.
1:      */
0:     private static void xaShutdown() {
0: 
0:         Properties dsAttrs = cleanProperties();
0: 
0:         if (TestUtil.isEmbeddedFramework())
0:             dsAttrs.put("shutdownDatabase", "shutdown");
0:         else
0:             dsAttrs.put("connectionAttributes", "shutdown=true");
0: 
0:         XADataSource dsx = TestUtil.getXADataSource(dsAttrs);
0: 
0:         try {
0:             dsx.getXAConnection().getConnection();
0:         } catch (SQLException sqle) {
0:             if ("08006".equals(sqle.getSQLState()))
0:                 return;
0:             TestUtil.dumpSQLExceptions(sqle);
0:         }
0:         System.out.println("FAIL: no exception on shutdown");
0:     }
0: 
0:     /*
0:      ** Test cases
1:      */
0: 
1:     /**
1:      * A single connection and 1 phase commit.
1:      * 
0:      
0:      Original "SQL" from xaSimplePositive.sql
0:      <code>
1:      xa_connect ;
1:      xa_start xa_noflags 0;
0:      xa_getconnection;
1:      drop table foo;
1:      create table foo (a int);
1:      insert into foo values (0);
1:      select * from foo;
1:      run resource '/org/apache/derbyTesting/functionTests/tests/store/global_xactTable.view';
1:      select * from global_xactTable where gxid is not null order by gxid;
1:      xa_end xa_success 0;
1:      xa_commit xa_1phase 0;
0:      
1:      xa_datasource 'wombat' shutdown;
1:      </code>
0:      * @throws SQLException 
0:      * @throws XAException 
1:      */
0:     private static void singleConnectionOnePhaseCommit(XADataSource xads) {
0:         System.out.println("singleConnectionOnePhaseCommit");
0:         try {
0:             XAConnection xac = xads.getXAConnection();
0: 
0:             XAResource xar = xac.getXAResource();
0: 
0:             Xid xid = XATestUtil.getXid(0, 32, 46);
0: 
0:             xar.start(xid, XAResource.TMNOFLAGS);
0: 
0:             Connection conn = xac.getConnection();
0: 
0:             Statement s = conn.createStatement();
0: 
0:             s.execute("create table foo (a int)");
0:             s.executeUpdate("insert into foo values (0)");
0: 
0:             ResultSet rs = s.executeQuery("select * from foo");
0:             JDBCDisplayUtil.DisplayResults(System.out, rs, conn);
0:             rs.close();
0: 
0:             XATestUtil.showXATransactionView(conn);
0: 
0:             s.close();
0:             xar.end(xid, XAResource.TMSUCCESS);
0: 
0:             // 1 phase commit
0:             xar.commit(xid, true);
0: 
0:             conn.close();
0:             xac.close();
0: 
0:         } catch (SQLException sqle) {
0:             TestUtil.dumpSQLExceptions(sqle);
1:         } catch (XAException e) {
0:             XATestUtil.dumpXAException("singleConnectionOnePhaseCommit", e);
0:         }
0:     }
0: 
0:     /*
1:      * Two interleaving transaction and prepare/commit prepare/rollback.
1:      * 
1:      * (original test said two connections but only one connection was opened)
0: 
0:      <code>
0:      xa_datasource 'wombat';
0:      xa_connect user 'sku' password 'testxa' ;
0: 
0:      xa_start xa_noflags 1;
0:      xa_getconnection;
0:      insert into APP.foo values (1);
0:      xa_end xa_suspend 1;
0: 
0:      xa_start xa_noflags 2;
0:      insert into APP.foo values (2);
0:      xa_end xa_suspend 2;
0: 
0:      xa_start xa_resume 1;
0:      insert into APP.foo values (3);
0:      xa_end xa_suspend 1;
0: 
0:      xa_start xa_resume 2;
0:      insert into APP.foo values (4);
0:      select * from APP.global_xactTable where gxid is not null order by gxid;
0:      -- this prepare won't work since transaction 1 has been suspended - XA_PROTO
0:      xa_prepare 1;
0: 
0:      select * from APP.global_xactTable where gxid is not null order by gxid;
0:      xa_end xa_success 2;
0: 
0:      -- this assumes a resume
0:      xa_end xa_success 1;
0:      xa_prepare 1;
0:      xa_prepare 2;
0: 
0:      -- both transactions should be prepared
0:      select * from APP.global_xactTable where gxid is not null order by gxid;
0: 
0:      -- NOTE: The following call to "xa_recover xa_startrscan" is apt to
0:      -- return the result set rows in reverse order when changes to
0:      -- the Derby engine affect the number of transactions that it takes
0:      -- to create a database.  The transactions are stored in a hash table
0:      -- based on a global and local id, and when the number of transactions
0:      -- changes, the (internal) local id can change, which may lead to a
0:      -- change in the result set order.  This order is determined by the
0:      -- JVM's hashing algorithm. Examples of changes to the engine that
0:      -- can affect this include ones that cause more commits or that
0:      -- change the amount of data being stored, such as changes to the
0:      -- metadata statements (which is what prompted this explanation in
0:      -- the first place).  Ultimately, the problem is that there is no
0:      -- way to order the return values from "xa_recover" since it is an
0:      -- ij internal statement, not SQL...
0:      xa_recover xa_startrscan;
0:      xa_recover xa_noflags;
0: 
0:      xa_commit xa_2Phase 1;
0:      xa_rollback 2;
0: 
0:      -- check results
0:      xa_start xa_noflags 3;
0:      select * from APP.global_xactTable where gxid is not null order by gxid;
0:      select * from APP.foo;
0:      xa_end xa_success 3;
0: 
0:      xa_prepare 3;
0: 
0:      -- should fail with XA_NOTA because we prepared a read only transaction 
0:      xa_commit xa_1Phase 3;
0:      disconnect;
1:      </code>
1:      */
0:     private static void interleavingTransactions(XADataSource xads) {
0:         System.out.println("interleavingTransactions");
0:         try {
0:             XAConnection xac = xads.getXAConnection("sku", "testxa");
0:             XAResource xar = xac.getXAResource();
0: 
0:             Xid xid1 = XATestUtil.getXid(1, 93, 18);
0:             Xid xid2 = XATestUtil.getXid(2, 45, 77);
0: 
0:             xar.start(xid1, XAResource.TMNOFLAGS);
0: 
0:             Connection conn = xac.getConnection();
0: 
0:             Statement s = conn.createStatement();
0:             s.executeUpdate("insert into APP.foo values (1)");
0:             xar.end(xid1, XAResource.TMSUSPEND);
0: 
0:             xar.start(xid2, XAResource.TMNOFLAGS);
0:             s.executeUpdate("insert into APP.foo values (2)");
0:             xar.end(xid2, XAResource.TMSUSPEND);
0: 
0:             xar.start(xid1, XAResource.TMRESUME);
0:             s.executeUpdate("insert into APP.foo values (3)");
0:             xar.end(xid1, XAResource.TMSUSPEND);
0: 
0:             xar.start(xid2, XAResource.TMRESUME);
0:             s.executeUpdate("insert into APP.foo values (4)");
0: 
0:             XATestUtil.showXATransactionView(conn);
0: 
0:             // this prepare won't work since
0:             // transaction 1 has been suspended - XA_PROTO
0:             try {
1:                 xar.prepare(xid1);
0:                 System.out.println("FAIL - prepare on suspended transaction");
1:             } catch (XAException e) {
0:                 if (e.errorCode != XAException.XAER_PROTO)
0:                     XATestUtil.dumpXAException(
0:                             "FAIL - prepare on suspended transaction", e);
0: 
0:             }
0: 
0:             // check it was not prepared
0:             XATestUtil.showXATransactionView(conn);
0: 
0:             xar.end(xid2, XAResource.TMSUCCESS);
0: 
0:             xar.end(xid1, XAResource.TMSUCCESS);
0: 
1:             xar.prepare(xid1);
0:             xar.prepare(xid2);
0: 
0:             // both should be prepared.
0:             XATestUtil.showXATransactionView(conn);
0: 
0:             Xid[] recoveredStart = xar.recover(XAResource.TMSTARTRSCAN);
0:             System.out.println("recovered start " + recoveredStart.length);
0:             Xid[] recovered = xar.recover(XAResource.TMNOFLAGS);
0:             System.out.println("recovered " + recovered.length);
0:             Xid[] recoveredEnd = xar.recover(XAResource.TMENDRSCAN);
0:             System.out.println("recovered end " + recoveredEnd.length);
0: 
0:             for (int i = 0; i < recoveredStart.length; i++) {
0:                 Xid xid = recoveredStart[i];
0:                 if (xid.getFormatId() == 1) {
0:                     // commit 1 with 2pc
0:                     xar.commit(xid, false);
0:                 } else if (xid.getFormatId() == 2) {
0:                     xar.rollback(xid);
0:                 } else {
0:                     System.out.println("FAIL: unknown xact");
0:                 }
0:             }
0: 
0:             // check the results
0:             Xid xid3 = XATestUtil.getXid(3, 2, 101);
1:             xar.start(xid3, XAResource.TMNOFLAGS);
0:             XATestUtil.showXATransactionView(conn);
0:             ResultSet rs = s.executeQuery("select * from APP.foo");
0:             JDBCDisplayUtil.DisplayResults(System.out, rs, conn);
0:             rs.close();
0:             xar.end(xid3, XAResource.TMSUCCESS);
0: 
0:             int pr = xar.prepare(xid3);
0:             if (pr != XAResource.XA_RDONLY)
0:                 System.out.println("FAIL - prepare on read only xact returned "
0:                         + pr);
0: 
0:             try {
0:                 xar.commit(xid3, true);
0:                 System.out.println("FAIL - 2pc commit on read-only xact");
1:             } catch (XAException e) {
0:                 if (e.errorCode != XAException.XAER_NOTA)
0:                     throw e;
0:             }
0: 
0:             s.close();
0:             conn.close();
0:             xac.close();
0:         } catch (SQLException sqle) {
0:             TestUtil.dumpSQLExceptions(sqle);
1:         } catch (XAException e) {
0:             XATestUtil.dumpXAException("interleavingTransactions", e);
0:         }
0:     }
0: 
1:     /**  
0:      Tests on INIT STATE (no tr
0:      Original SQL from xaStateTran.sql. 
0:      <code>
0: 
1:      -- the following should error XAER_NOTA
1:      xa_start xa_join 11;
1:      -- the following should error XAER_NOTA
1:      xa_start xa_resume 11;
1:      -- the following should error XAER_NOTA
1:      xa_end xa_success 11;
1:      -- the following should error XAER_NOTA
1:      xa_end xa_fail 11;
1:      -- the following should error XAER_NOTA
1:      xa_end xa_suspend 11;
1:      -- the following should error XAER_NOTA
1:      xa_prepare 11;
1:      -- the following should error XAER_NOTA
1:      xa_commit xa_1phase 11;
1:      -- the following should error XAER_NOTA
1:      xa_commit xa_2phase 11;
1:      -- the following should error XAER_NOTA
1:      xa_rollback 11;
1:      -- the following should error XAER_NOTA
1:      xa_forget 11;
1:      </code>
1:      */
0:     private static void noTransaction(XADataSource xads) {
0:         System.out.println("noTransaction");
0:         try {
0:             XAConnection xac = xads.getXAConnection();
0:             XAResource xar = xac.getXAResource();
0: 
0:             Xid xid11 = XATestUtil.getXid(11, 3, 128);
0: 
0:             try {
0:                 xar.start(xid11, XAResource.TMJOIN);
1:             } catch (XAException e) {
0:                 if (e.errorCode != XAException.XAER_NOTA)
0:                     throw e;
0:             }
0: 
0:             try {
0:                 xar.start(xid11, XAResource.TMRESUME);
1:             } catch (XAException e) {
0:                 if (e.errorCode != XAException.XAER_NOTA)
0:                     throw e;
0:             }
0: 
0:             try {
0:                 xar.end(xid11, XAResource.TMSUCCESS);
1:             } catch (XAException e) {
0:                 if (e.errorCode != XAException.XAER_NOTA)
0:                     throw e;
0:             }
0:             try {
0:                 xar.end(xid11, XAResource.TMFAIL);
1:             } catch (XAException e) {
0:                 if (e.errorCode != XAException.XAER_NOTA)
0:                     throw e;
0:             }
0: 
0:             try {
0:                 xar.end(xid11, XAResource.TMSUSPEND);
1:             } catch (XAException e) {
0:                 if (e.errorCode != XAException.XAER_NOTA)
0:                     throw e;
0:             }
0: 
0:             try {
0:                 xar.prepare(xid11);
1:             } catch (XAException e) {
0:                 if (e.errorCode != XAException.XAER_NOTA)
0:                     throw e;
0:             }
0:             try {
0:                 xar.commit(xid11, false);
1:             } catch (XAException e) {
0:                 if (e.errorCode != XAException.XAER_NOTA)
0:                     throw e;
0:             }
0:             try {
0:                 xar.commit(xid11, true);
1:             } catch (XAException e) {
0:                 if (e.errorCode != XAException.XAER_NOTA)
0:                     throw e;
0:             }
0:             try {
0:                 xar.rollback(xid11);
1:             } catch (XAException e) {
0:                 if (e.errorCode != XAException.XAER_NOTA)
0:                     throw e;
0:             }
0:             try {
0:                 xar.forget(xid11);
1:             } catch (XAException e) {
0:                 if (e.errorCode != XAException.XAER_NOTA)
0:                     throw e;
0:             }
0:         } catch (SQLException e) {
0:             TestUtil.dumpSQLExceptions(e);
1:         } catch (XAException e) {
0:             XATestUtil.dumpXAException("noTransaction", e);
0:         }
0:     }
0: 
1:     /**
1:      * Morph a connection between local anf global transactions.
1:      */
0:     private static void morph(XADataSource xads) {
0:         System.out.println("morph");
0: 
0:         try {
0:             XAConnection xac = xads.getXAConnection();
0: 
0:             XAResource xar = xac.getXAResource();
0: 
0:             Connection conn = xac.getConnection();
0: 
0:             /*
0:              autocommit off;
0:              insert into foo values (1);
0:              select * from global_xactTable where gxid is not null order by gxid,username;
0:              commit;
1:              */
0:             conn.setAutoCommit(false);
0:             Statement s = conn.createStatement();
0:             s.executeUpdate("insert into APP.foo values (2001)");
0:             XATestUtil.showXATransactionView(conn);
1:             conn.commit();
0: 
0:             /*
0:              autocommit on;
0:              insert into foo values (2);
0:              select * from global_xactTable where gxid is not null order by gxid,username;
0:              
1:              */
0: 
0:             conn.setAutoCommit(true);
0:             s.executeUpdate("insert into APP.foo values (2002)");
0:             XATestUtil.showXATransactionView(conn);
0: 
0:             /*
0:              -- morph the connection to a global transaction
0:              xa_start xa_noflags 1;
0:              select * from global_xactTable where gxid is not null order by gxid,username;
0:              insert into foo values (3);
1:              */
0: 
0:             Xid xid = XATestUtil.getXid(1001, 66, 13);
0:             xar.start(xid, XAResource.TMNOFLAGS);
0:             XATestUtil.showXATransactionView(conn);
0:             s.executeUpdate("insert into APP.foo values (2003)");
0: 
0:             /*
0:              -- disallowed
0:              commit;
0:              -- disallowed
0:              rollback;
0:              -- disallowed
0:              autocommit on;
0:              -- OK
0:              autocommit off;
1:              */
0:             try {
1:                 conn.commit();
0:                 System.out.println("FAIL: commit allowed in global xact");
0:             } catch (SQLException e) {
0:             }
0: 
0:             try {
1:                 conn.rollback();
0:                 System.out.println("FAIL: roll back allowed in global xact");
0:             } catch (SQLException e) {
0:             }
0:             try {
0:                 conn.setAutoCommit(true);
0:                 System.out
0:                         .println("FAIL: setAutoCommit(true) allowed in global xact");
0:             } catch (SQLException e) {
0:             }
0:             conn.setAutoCommit(false);
0: 
0:             // s was created in local mode so it has holdibilty
0:             // set, 
0:             try {
0:                 s.executeQuery("select * from APP.foo where A >= 2000");
0:                 System.out.println("FAIL: query with holdable statement");
0:             } catch (SQLException sqle) {
0:                 TestUtil.dumpSQLExceptions(sqle, true);
0:             }
0:             s.close();
0: 
0:             s = conn.createStatement();
0:             boolean holdable = s.getResultSetHoldability() == ResultSet.HOLD_CURSORS_OVER_COMMIT;
0:             System.out.println("Statement created in global has holdabilty: "
0:                     + holdable);
0: 
0:             /*
1:              select * from foo;
0:              xa_end xa_success 1;
0:              xa_prepare 1;
1:              */
0:             ResultSet rs = s
0:                     .executeQuery("select * from APP.foo where A >= 2000");
0:             JDBCDisplayUtil.DisplayResults(System.out, rs, conn);
0:             rs.close();
0: 
0:             xar.end(xid, XAResource.TMSUCCESS);
0:             xar.prepare(xid);
0: 
0:             /*
0:              -- dup id
0:              xa_start xa_noflags 1;
1:              */
0:             try {
0:                 xar.start(xid, XAResource.TMNOFLAGS);
0:                 System.out.println("FAIL - start with duplicate XID");
1:             } catch (XAException e) {
0:                 if (e.errorCode != XAException.XAER_DUPID)
0:                     throw e;
0:             }
0: 
0:             /*
0:              xa_start xa_noflags 2;
0:              -- still should disallow autommit;
0:              autocommit on;
0:              -- still should disallow commit and rollback 
0:              commit;
0:              rollback;
0:              select * from global_xactTable where gxid is not null order by gxid,username;
0:              xa_end xa_suspend 2;
1:              */
0: 
0:             Xid xid2 = XATestUtil.getXid(1002, 23, 3);
0:             xar.start(xid2, XAResource.TMNOFLAGS);
0:             try {
1:                 conn.commit();
0:                 System.out.println("FAIL: commit allowed in global xact");
0:             } catch (SQLException e) {
0:             }
0:             try {
1:                 conn.rollback();
0:                 System.out.println("FAIL: roll back allowed in global xact");
0:             } catch (SQLException e) {
0:             }
0:             try {
0:                 conn.setAutoCommit(true);
0:                 System.out
0:                         .println("FAIL: setAutoCommit(true) allowed in global xact");
0:             } catch (SQLException e) {
0:             }
0:             conn.setAutoCommit(false);
0: 
0:             xar.end(xid2, XAResource.TMSUSPEND);
0: 
0:             // DERBY-1004
0:             if (TestUtil.isDerbyNetClientFramework())
0:                 conn.close();
0: 
0:             /*
0:              -- get local connection again
0:              xa_getconnection;
0: 
0:              insert into foo values (5);
0: 
0:              -- autocommit should be on by default;
0:              commit;
0: 
0:              autocommit off;
0:              insert into foo values (6);
0: 
0:              -- commit and rollback is allowed on local connection
0:              rollback;
0: 
0:              insert into foo values (6);
0:              commit;
1:              */
0:             conn = xac.getConnection();
0:             s = conn.createStatement();
0:             s.executeUpdate("insert into APP.foo values (2005)");
1:             conn.commit();
0:             conn.setAutoCommit(false);
0:             s.executeUpdate("insert into APP.foo values (2006)");
1:             conn.rollback();
0:             s.executeUpdate("insert into APP.foo values (2007)");
1:             conn.commit();
0: 
0:             XATestUtil.showXATransactionView(conn);
0:             /*
0:              -- I am still able to commit other global transactions while I am attached to a
0:              -- local transaction.
0:              xa_commit xa_2phase 1;
0:              xa_end xa_success 2;
0:              xa_rollback 2;
1:              */
0:             xar.commit(xid, false);
0:             xar.end(xid2, XAResource.TMSUCCESS);
0:             xar.rollback(xid2);
0: 
0:             XATestUtil.showXATransactionView(conn);
0:             rs = s.executeQuery("select * from APP.foo where A >= 2000");
0:             JDBCDisplayUtil.DisplayResults(System.out, rs, conn);
0:             rs.close();
0: 
0:             conn.close();
0: 
0:             /*
0:              xa_getconnection;
0:              select * from global_xactTable where gxid is not null order by gxid,username;
1:              select * from foo;
0:              autocommit off;
0:              delete from foo;
1:              */
0:             conn = xac.getConnection();
0:             conn.setAutoCommit(false);
0:             s = conn.createStatement();
0:             s.executeUpdate("delete from app.foo");
0:             rs = s.executeQuery("select * from APP.foo");
0:             JDBCDisplayUtil.DisplayResults(System.out, rs, conn);
0:             rs.close();
0: 
0:             // DERBY-1004
0:             if (TestUtil.isDerbyNetClientFramework())
1:                 conn.rollback();
0:             /*
0:              -- yanking a local connection away should rollback the changes
1:              */
0:             conn = xac.getConnection();
0:             conn.setAutoCommit(false);
0:             s = conn.createStatement();
0:             rs = s.executeQuery("select * from APP.foo where A >= 2000");
0:             JDBCDisplayUtil.DisplayResults(System.out, rs, conn);
0:             rs.close();
0: 
0:             /*
0:              -- cannot morph it if the local transaction is not idle
0:              xa_start xa_noflags 3;
0:              commit;
0:              -- now morph it to a global transaction
0:              xa_start xa_noflags 3;
1:              */
0:             Xid xid3 = XATestUtil.getXid(1003, 27, 9);
0:             try {
1:                 xar.start(xid3, XAResource.TMNOFLAGS);
0:             } catch (XAException xae) {
0:                 if (xae.errorCode != XAException.XAER_OUTSIDE)
0:                     throw xae;
0:             }
1:             conn.commit();
1:             xar.start(xid3, XAResource.TMNOFLAGS);
0: 
0:             /*
0:              -- now I shouldn't be able to yank it
0:              xa_getconnection;
1:              */
0:             try {
1:                 xac.getConnection();
0:                 System.out
0:                         .println("FAIL: getConnection with active global xact");
0:             } catch (SQLException sqle) {
0:                 TestUtil.dumpSQLExceptions(sqle, true);
0:             }
0:             /*
1:              select * from foo;
0:              delete from foo;
0: 
0:              xa_end xa_fail 3;
0:              xa_rollback 3;
0: 
0:              -- local connection again
0:              xa_getconnection;
0:              select * from global_xactTable where gxid is not null order by gxid,username;
1:              select * from foo;
1:              */
0:             s = conn.createStatement();
0:             s.executeUpdate("delete from APP.foo");
0:             rs = s.executeQuery("select * from APP.foo where A >= 2000");
0:             JDBCDisplayUtil.DisplayResults(System.out, rs, conn);
0:             rs.close();
0:             try {
0:                 xar.end(xid3, XAResource.TMFAIL);
1:             } catch (XAException e) {
0:                 if (e.errorCode != XAException.XA_RBROLLBACK)
0:                     throw e;
0:             }
0:             xar.rollback(xid3);
0: 
0:             conn = xac.getConnection();
0:             s = conn.createStatement();
0:             rs = s.executeQuery("select * from APP.foo where A >= 2000");
0:             JDBCDisplayUtil.DisplayResults(System.out, rs, conn);
0:             rs.close();
0: 
0:             s.close();
0:             conn.close();
0: 
0:         } catch (SQLException e) {
0:             TestUtil.dumpSQLExceptions(e);
0:             e.printStackTrace(System.out);
1:         } catch (XAException e) {
0:             XATestUtil.dumpXAException("morph", e);
0:         }
0: 
0:     }
0:     
1:     /**
0:      * Derby-966 holdability and global/location transactions.
0:      * (work in progress)
1:      */
0:     private static void derby966(XADataSource xads)
0:     {
0:         System.out.println("derby966");
0:         
0:         try {
0:             XAConnection xac = xads.getXAConnection();
0:             XAResource xar = xac.getXAResource();
0: 
0:             Xid xid = XATestUtil.getXid(996, 9, 48);
0:             
0:             Connection conn = xac.getConnection();
0:             
0:             // Obtain Statements and PreparedStatements
0:             // with all the holdability options.
0:             
0:             boolean hold =
0:                 conn.getHoldability() == ResultSet.HOLD_CURSORS_OVER_COMMIT;
0:             
0:             System.out.println("Local connection holdable " + hold);
0:            
0:             Statement sdh = conn.createStatement();
0:             showHoldStatus("Local(held) default ", sdh);
0:             checkHeldRS(conn, sdh, sdh.executeQuery("select * from app.foo"));
0:             PreparedStatement psdh = conn.prepareStatement("SELECT * FROM APP.FOO");
0:             showHoldStatus("Local(held) default Prepared", psdh);
0:             checkHeldRS(conn, psdh, psdh.executeQuery());
0:             
0:             Statement shh = conn.createStatement(
0:                     ResultSet.TYPE_FORWARD_ONLY,
0:                     ResultSet.CONCUR_READ_ONLY,
0:                     ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:             showHoldStatus("Local(held) held ", shh);
0:             checkHeldRS(conn, shh, shh.executeQuery("select * from app.foo"));
0:             PreparedStatement pshh =
0:                 conn.prepareStatement("SELECT * FROM APP.FOO",
0:                         ResultSet.TYPE_FORWARD_ONLY,
0:                         ResultSet.CONCUR_READ_ONLY,
0:                         ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:             showHoldStatus("Local(held) held Prepared", pshh);
0:             checkHeldRS(conn, pshh, pshh.executeQuery());
0:                         
0:             Statement sch = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
0:                     ResultSet.CONCUR_READ_ONLY,
0:                     ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:             showHoldStatus("Local(held) close ", sch);
0:             checkHeldRS(conn, sch, sch.executeQuery("select * from app.foo"));
0:             PreparedStatement psch =
0:                 conn.prepareStatement("SELECT * FROM APP.FOO",
0:                         ResultSet.TYPE_FORWARD_ONLY,
0:                         ResultSet.CONCUR_READ_ONLY,
0:                         ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:             showHoldStatus("Local(held) close Prepared", psch);
0:             checkHeldRS(conn, psch, psch.executeQuery());
0:          
0:             // set the connection's holdabilty to false
0:             conn.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:             
0:             Statement sdc = conn.createStatement();
0:             showHoldStatus("Local(close) default ", sdc);
0:             checkHeldRS(conn, sdc, sdc.executeQuery("select * from app.foo"));
0:             PreparedStatement psdc = conn.prepareStatement("SELECT * FROM APP.FOO");
0:             showHoldStatus("Local(close) default Prepared", psdc);
0:             checkHeldRS(conn, psdc, psdc.executeQuery());
0:  
0:             Statement shc = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
0:                     ResultSet.CONCUR_READ_ONLY,
0:                     ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:             showHoldStatus("Local(close) held ", shc);
0:             checkHeldRS(conn, shc, shc.executeQuery("select * from app.foo"));
0:             PreparedStatement pshc =
0:                 conn.prepareStatement("SELECT * FROM APP.FOO",
0:                         ResultSet.TYPE_FORWARD_ONLY,
0:                         ResultSet.CONCUR_READ_ONLY,
0:                         ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:             showHoldStatus("Local(close) held Prepared", pshc);
0:             checkHeldRS(conn, pshc, pshc.executeQuery());
0:             
0:             Statement scc = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
0:                     ResultSet.CONCUR_READ_ONLY,
0:                     ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:             showHoldStatus("Local(close) close ", scc);
0:             checkHeldRS(conn, scc, scc.executeQuery("select * from app.foo"));
0:             PreparedStatement pscc =
0:                 conn.prepareStatement("SELECT * FROM APP.FOO",
0:                         ResultSet.TYPE_FORWARD_ONLY,
0:                         ResultSet.CONCUR_READ_ONLY,
0:                         ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:             showHoldStatus("Local(close) close Prepared", pscc);
0:             checkHeldRS(conn, pscc, pscc.executeQuery());
0:             
0:             // Revert back to holdable
0:             conn.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
0:             
0:             ResultSet rs = sdh.executeQuery("SELECT * FROM APP.FOO");
1:             conn.commit();
1:             rs.next();
0:             
0:             // start a global xact and test those statements.
0:             xar.start(xid, XAResource.TMNOFLAGS);
0:             
0:             // Statements obtained while default was hold.
0:             // Only sch should work as held cursors not supported in XA
0:             try {
0:                 sdh.executeQuery("SELECT * FROM APP.FOO").close();
0:                 System.out.println("FAIL - held Statement in global");
0:             } catch (SQLException e) {
0:                 TestUtil.dumpSQLExceptions(e, true);
0:             }
0:             try {
0:                 shh.executeQuery("SELECT * FROM APP.FOO").close();
0:                 System.out.println("FAIL - held Statement in global");
0:             } catch (SQLException e) {
0:                 TestUtil.dumpSQLExceptions(e, true);
0:             }
0:             sch.executeQuery("SELECT * FROM APP.FOO").close();
0:             
0:             // PreparedStatements obtained while default was hold.
0:             // Only sch should work as held cursors not supported in XA
0:             try {
0:                 psdh.executeQuery().close();
0:                 System.out.println("FAIL - held Statement in global");
0:             } catch (SQLException e) {
0:                 TestUtil.dumpSQLExceptions(e, true);
0:             }
0:             try {
0:                 pshh.executeQuery().close();
0:                 System.out.println("FAIL - held Statement in global");
0:             } catch (SQLException e) {
0:                 TestUtil.dumpSQLExceptions(e, true);
0:             }
0:             psch.executeQuery().close();
0:              
0:             // Statements obtained while default was close.
0:             // Only sch should work as held cursors not supported in XA
0:             sdc.executeQuery("SELECT * FROM APP.FOO").close();
0:             try {
0:                 shc.executeQuery("SELECT * FROM APP.FOO").close();
0:                 System.out.println("FAIL - held Statement in global");
0:             } catch (SQLException e) {
0:                 TestUtil.dumpSQLExceptions(e, true);
0:             }
0:             scc.executeQuery("SELECT * FROM APP.FOO").close();
0:             
0:             // PreparedStatements obtained while default was close.
0:            psdc.executeQuery().close();
0:            try {
0:                 pshc.executeQuery().close();
0:                 System.out.println("FAIL - held Statement in global");
0:             } catch (SQLException e) {
0:                 TestUtil.dumpSQLExceptions(e, true);
0:             }
0:             pscc.executeQuery().close();
0:             
0:         } catch (SQLException e) {
0:             TestUtil.dumpSQLExceptions(e);
0:             e.printStackTrace(System.out);
1:         } catch (XAException e) {
0:             XATestUtil.dumpXAException("derby966", e);
0:         }
0:     }
0:     
1:     /**
0:      * Check the held state of a ResultSet by fetching
0:      * one row, executing a commit and then fetching the
0:      * next. Checks the held state matches the behaviour.
1:     */
0:     private static void checkHeldRS(Connection conn,
0:             Statement s, ResultSet rs) throws SQLException
0:     {
0:         if (s.getConnection() != conn)
0:             System.out.println("FAIL - mismatched statement & Connection");
0:         if (rs.getStatement() != s)
0:         {
0:             // DERBY-1009
0:             System.out.println("FAIL - mismatched statement & ResultSet");
0:             System.out.println("Statement class " + s.getClass());
0:             System.out.println("ResultSet' Statements class " + rs.getStatement().getClass());
0:          }
0: 
0:         boolean held = s.getResultSetHoldability() ==
0:             ResultSet.HOLD_CURSORS_OVER_COMMIT;
0:         
0:         
0:         
0:         System.out.println("held " + held);
0:         
1:         rs.next();
0:         System.out.println("  BC A=" + rs.getInt(1));
1:         conn.commit();
0:        
0:         try {
1:            rs.next();
0:            rs.getInt(1);
0:            System.out.println("  AC A=" + rs.getInt(1));
0:            if (!held)
0:                System.out.println("FAIL: non-held cursor not closed by commit");
0:         } catch (SQLException sqle)
0:         {
0:             TestUtil.dumpSQLExceptions(sqle, !held);
0:         }
0:         
0:         rs.close();
1:         conn.commit();
0:     }
0:     
1:     /**
0:      * Show the held status of the Statement.
1:     */
0:     private static void showHoldStatus(String tag, Statement s) throws SQLException
0:     {
0:         boolean hold =
0:             s.getResultSetHoldability() == ResultSet.HOLD_CURSORS_OVER_COMMIT;
0:         
0:         System.out.println(tag + "Statement holdable " + hold);
0:     }
0: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
commit:dff95a1
/////////////////////////////////////////////////////////////////////////
0:  Licensed to the Apache Software Foundation (ASF) under one or more
0:  contributor license agreements.  See the NOTICE file distributed with
0:  this work for additional information regarding copyright ownership.
0:  The ASF licenses this file to You under the Apache License, Version 2.0
0:  (the "License"); you may not use this file except in compliance with
0:  the License.  You may obtain a copy of the License at
commit:4a95eeb
/////////////////////////////////////////////////////////////////////////
0:         // for cleaning up, make a clean new connection
0:         Connection dmc2 = ij.startJBMS();
0:         cleanUp(dmc2);
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0:     private static void cleanUp(Connection conn) throws SQLException
0:     {
0:         String testObjects[] = { "view XATESTUTIL.global_xactTable", 
0:                                  "schema XATESTUTIL restrict", "table app.foo", "table foo" };
0:         Statement stmt = conn.createStatement();
0:         TestUtil.cleanUpTest(stmt, testObjects);
0:         conn.commit();
0:         stmt.close();
0:     }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:494a328
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:6b858b2
/////////////////////////////////////////////////////////////////////////
0:                         .println("FAIL: setAutoCommit(true) allowed "+
0: 				 "in global xact");
0:             try {
0:                 conn.setSavepoint();
0:                 System.out
0:                     .println("FAIL: setSavepoint() allowed in global xact");
0:             } catch (SQLException e) {}
0:             try {
0:                 conn.setSavepoint("badsavepoint");
0:                 System.out
0:                     .println("FAIL: setAutoCommit(String) allowed in "+
0:                              "global xact");
0:             } catch (SQLException e) {}
0: 
============================================================================