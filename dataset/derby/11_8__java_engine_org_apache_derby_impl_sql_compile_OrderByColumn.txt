1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.OrderByColumn
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:eac0369: 
6:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:7a9ce7e: import org.apache.derby.iapi.sql.compile.Visitor;
1:eac0369: 
3:eac0369: /**
1:eac0369:  * An OrderByColumn is a column in the ORDER BY clause.  An OrderByColumn
1:eac0369:  * can be ordered ascending or descending.
4:eac0369:  *
1:eac0369:  * We need to make sure that the named columns are
1:eac0369:  * columns in that query, and that positions are within range.
1:eac0369:  *
1:eac0369:  */
1:3bb140c: class OrderByColumn extends OrderedColumn {
1:eac0369: 
1:eac0369: 	private ResultColumn	resultCol;
1:eac0369: 	private boolean			ascending = true;
1:cc30c0c: 	private boolean			nullsOrderedLow = false;
1:a15163c: 	private ValueNode expression;
1:2bb13ac: 	private OrderByList     list;
1:eac0369:     /**
1:baadbde:      * If this sort key is added to the result column list then it is at result column position
1:baadbde:      * 1 + resultColumnList.size() - resultColumnList.getOrderBySelect() + addedColumnOffset
1:dbed020:      * If the sort key is already in the result column list then addedColumnOffset &lt; 0.
1:eac0369:      */
1:baadbde:     private int addedColumnOffset = -1;
1:eac0369: 
1:eac0369: 
1:eac0369:    	/**
1:3bb140c:      * Constructor.
1:eac0369: 	 *
1:a15163c: 	 * @param expression            Expression of this column
1:3bb140c:      * @param cm                    The context manager
1:eac0369: 	 */
1:3bb140c:     OrderByColumn(ValueNode expression, ContextManager cm)
9:eac0369: 	{
1:3bb140c:         super(cm);
1:3bb140c:         this.expression = expression;
3:eac0369: 	}
1:7a9ce7e: 	
1:2bb13ac: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString() {
1:eac0369: 		if (SanityManager.DEBUG) {
1:c9a1206: 			return
1:c9a1206: 				"nullsOrderedLow: " + nullsOrderedLow + "\n" +
1:c9a1206: 				"ascending; " + ascending + "\n" +
1:c9a1206: 				"addedColumnOffset: " + addedColumnOffset + "\n" +
1:c9a1206: 				super.toString();
1:eac0369: 		} else {
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:c9a1206: 
1:c9a1206: 	/**
1:c9a1206: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:c9a1206: 	 * how tree printing is supposed to work.
1:c9a1206: 	 *
1:c9a1206: 	 * @param depth		The depth of this node in the tree
1:c9a1206: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:c9a1206: 	{
1:c9a1206: 		if (SanityManager.DEBUG)
1:c9a1206: 		{
1:c9a1206: 			super.printSubNodes(depth);
1:c9a1206: 
1:c9a1206: 			if (expression != null) {
1:c9a1206: 				printLabel(depth, "expression: ");
1:c9a1206: 				expression.treePrint(depth + 1);
1:c9a1206: 			}
1:c9a1206: 
1:c9a1206: 			if (resultCol != null) {
1:c9a1206: 				printLabel(depth, "resultCol: ");
1:c9a1206: 				resultCol.treePrint(depth + 1);
1:c9a1206: 			}
1:c9a1206: 		}
1:c9a1206: 	}
1:c9a1206: 
1:eac0369: 	/**
1:eac0369: 	 * Mark the column as descending order
1:eac0369: 	 */
1:3bb140c:     void setDescending() {
1:eac0369: 		ascending = false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the column order.  Overrides 
1:eac0369: 	 * OrderedColumn.isAscending.
1:eac0369: 	 *
1:eac0369: 	 * @return true if ascending, false if descending
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isAscending() {
1:eac0369: 		return ascending;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:cc30c0c: 	 * Mark the column as ordered NULL values lower than non-NULL values.
1:cc30c0c: 	 */
1:3bb140c:     void setNullsOrderedLow() {
1:cc30c0c: 		nullsOrderedLow = true;
1:cc30c0c: 	}
1:cc30c0c: 
1:cc30c0c: 	/**
1:cc30c0c: 	 * Get the column NULL ordering. Overrides
1:cc30c0c: 	 * OrderedColumn.getIsNullsOrderedLow.
1:cc30c0c: 	 *
1:cc30c0c: 	 * @return true if NULLs ordered low, false if NULLs ordered high
1:cc30c0c: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isNullsOrderedLow() {
1:cc30c0c: 		return nullsOrderedLow;
1:cc30c0c: 	}
1:cc30c0c: 
1:cc30c0c: 	/**
1:eac0369: 	 * Get the underlying ResultColumn.
1:eac0369: 	 *
1:eac0369: 	 * @return The underlying ResultColumn.
1:eac0369: 	 */
1:eac0369: 	ResultColumn getResultColumn()
1:eac0369: 	{
1:eac0369: 		return resultCol;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the underlying expression, skipping over ResultColumns that
1:eac0369: 	 * are marked redundant.
1:eac0369: 	 */
1:eac0369: 	ValueNode getNonRedundantExpression()
1:eac0369: 	{
1:eac0369: 		ResultColumn	rc;
1:eac0369: 		ValueNode		value;
1:eac0369: 		ColumnReference	colref = null;
1:eac0369: 
1:eac0369: 		for (rc = resultCol; rc.isRedundant(); rc = colref.getSource())
1:eac0369: 		{
1:eac0369: 			value = rc.getExpression();
1:eac0369: 
1:eac0369: 			if (value instanceof ColumnReference)
1:eac0369: 			{
1:eac0369: 				colref = (ColumnReference) value;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 						"value should be a ColumnReference, but is a " +
1:eac0369: 						value.getClass().getName());
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return rc.getExpression();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this column.
1:eac0369: 	 *
1:2bb13ac: 	 * During binding, we may discover that this order by column was pulled
1:2bb13ac: 	 * up into the result column list, but is now a duplicate, because the
1:2bb13ac: 	 * actual result column was expanded into the result column list when "*"
1:2bb13ac: 	 * expressions were replaced with the list of the table's columns. In such
1:2bb13ac: 	 * a situation, we will end up calling back to the OrderByList to
1:2bb13ac: 	 * adjust the addedColumnOffset values of the columns; the "oblist"
1:2bb13ac: 	 * parameter exists to allow that callback to be performed.
1:2bb13ac: 	 *
1:eac0369: 	 * @param target	The result set being selected from
1:2bb13ac: 	 * @param oblist    OrderByList which contains this column
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 * @exception StandardException		Thrown when column not found
1:eac0369: 	 */
1:3bb140c:     void bindOrderByColumn(ResultSetNode target, OrderByList oblist)
1:eac0369: 				throws StandardException 
1:7a9ce7e: 	{
1:2bb13ac: 		this.list = oblist;
1:2bb13ac: 
1:a15163c: 		if(expression instanceof ColumnReference){
1:eac0369: 		
1:a15163c: 			ColumnReference cr = (ColumnReference) expression;
1:eac0369: 			
1:a15163c: 			resultCol = resolveColumnReference(target,
1:a15163c: 							   cr);
1:eac0369: 			
1:eac0369: 			columnPosition = resultCol.getColumnPosition();
1:eac0369: 
1:2939b68: 			if (addedColumnOffset >= 0 &&
1:2939b68: 					target instanceof SelectNode &&
1:2939b68: 					( (SelectNode)target ).hasDistinct())
1:b0456a0: 				throw StandardException.newException(SQLState.LANG_DISTINCT_ORDER_BY, cr.getColumnName());
1:a15163c: 		}else if(isReferedColByNum(expression)){
1:a480224: 			
1:baadbde: 			ResultColumnList targetCols = target.getResultColumns();
1:a15163c: 			columnPosition = ((Integer)expression.getConstantValueAsObject()).intValue();
1:eac0369: 			resultCol = targetCols.getOrderByColumn(columnPosition);
1:d2a6cce: 
1:d2a6cce: 			/* Column is out of range if either a) resultCol is null, OR
1:d2a6cce: 			 * b) resultCol points to a column that is not visible to the
1:d2a6cce: 			 * user (i.e. it was generated internally).
1:d2a6cce: 			 */
1:d2a6cce: 			if ((resultCol == null) ||
1:d2a6cce: 				(resultCol.getColumnPosition() > targetCols.visibleSize()))
1:d2a6cce: 			{
1:a15163c: 				throw StandardException.newException(SQLState.LANG_COLUMN_OUT_OF_RANGE, 
1:a15163c: 								     String.valueOf(columnPosition));
1:7a9ce7e: 			}
1:eac0369: 
1:a15163c: 		}else{
1:49300a7:             if (list.isTableValueCtorOrdering()) {
1:49300a7:                 // For VALUES, we only allow ordering by column number,
1:49300a7:                 // SQL-92 style. This is a more general expression, so throw.
1:49300a7:                 throw StandardException.newException(
1:49300a7:                         SQLState.LANG_TABLE_VALUE_CTOR_RESTRICTION);
1:49300a7:             }
1:49300a7: 
1:a480224: 			/*checks for the conditions when using distinct*/
1:2939b68: 			if (addedColumnOffset >= 0 &&
1:2939b68: 					target instanceof SelectNode &&
1:a480224: 					((SelectNode)target).hasDistinct() &&
1:a480224: 					!expressionMatch(target))
1:a480224: 			{
1:a6d25cd:                 CollectNodesVisitor<ColumnReference> collectNodesVisitor =
1:a6d25cd:                     new CollectNodesVisitor<ColumnReference>(
1:a6d25cd:                         ColumnReference.class);
1:a480224: 				expression.accept(collectNodesVisitor);
1:a480224: 
1:a6d25cd:                 for (ColumnReference cr1 : collectNodesVisitor.getList())
1:a480224: 				{//visits through the columns in this OrderByColumn
1:3bb140c:                     String col=cr1.getColumnName();
1:3bb140c:                     boolean match = columnMatchFound(target,cr1);
1:a480224: 					/* breaks if a match not found, this is needed
1:a480224: 					 * because all column references in this
1:a480224: 					 * OrderByColumn should be there in the select
1:a480224: 					 * clause.*/
1:a480224: 					if(!match)
1:a480224: 						throw StandardException.newException(
1:a480224: 								SQLState.LANG_DISTINCT_ORDER_BY,
1:a480224: 								col);
1:a480224: 				}
1:a480224: 			}
1:a480224: 
1:a480224: 			if( SanityManager.DEBUG)
1:a480224: 				SanityManager.ASSERT( addedColumnOffset >= 0,
1:a480224: 				"Order by expression was not pulled into the result column list");
1:a480224: 			resolveAddedColumn(target);
1:475f87e: 			if (resultCol == null)
1:475f87e: 				throw StandardException.newException(SQLState.LANG_UNION_ORDER_BY);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Verify that the column is orderable
1:eac0369: 		resultCol.verifyOrderable();
1:eac0369: 	}
1:eac0369: 
1:a480224: 	/**
1:a480224: 	 * Checks whether the whole expression (OrderByColumn) itself
1:a480224: 	 * found in the select clause.
1:a480224: 	 * @param target Result set
1:a480224: 	 * @return boolean: whether any expression match found
1:a480224: 	 * @throws StandardException
1:a480224: 	 */
1:a480224: 	private boolean expressionMatch(ResultSetNode target)
1:a480224: 										throws StandardException{
1:a480224: 		ResultColumnList rcl=target.getResultColumns();
1:a480224: 		for (int i=1; i<=rcl.visibleSize();i++){
1:a480224: 			//since RCs are 1 based
1:a480224: 			if((rcl.getResultColumn(i)).isEquivalent(
1:a480224: 					resultCol))
1:a480224: 				return true;
1:a480224: 		}
1:a480224: 		return false;
1:a480224: 	}
1:a480224: 
1:a480224: 	/**
1:a480224: 	 * This method checks a ColumnReference of this OrderByColumn
1:a480224: 	 * against the ColumnReferences of the select clause of the query.
1:a480224: 	 * @param target result set
1:a480224: 	 * @param crOfExpression the CR to be checked
1:a480224: 	 * @return whether a match found or not
1:a480224: 	 * @throws StandardException
1:a480224: 	 */
1:a480224: 	private boolean columnMatchFound(ResultSetNode target,
1:a480224: 			ColumnReference crOfExpression) throws StandardException{
1:a480224: 		ResultColumnList rcl=target.getResultColumns();
1:a480224: 		for (int i=1; i<=rcl.visibleSize();
1:a480224: 		i++){//grab the RCs related to select clause
1:a480224: 			ValueNode exp=rcl.getResultColumn(i).getExpression();
1:a480224: 			if(exp instanceof ColumnReference)
1:a480224: 			{//visits through the columns in the select clause
1:a480224: 				ColumnReference cr2 =
1:a480224: 					(ColumnReference) (exp);
1:a480224: 				if(crOfExpression.isEquivalent(cr2))
1:a480224: 					return true;
1:a480224: 			}
1:a480224: 		}
1:a480224: 		return false;
1:a480224: 	}
1:a480224: 
1:d2a6cce:     /**
1:d2a6cce:      * Assuming this OrderByColumn was "pulled" into the received target's
1:d2a6cce:      * ResultColumnList (because it wasn't there to begin with), use
1:d2a6cce:      * this.addedColumnOffset to figure out which of the target's result
1:d2a6cce:      * columns is the one corresponding to "this".
1:d2a6cce:      *
1:d2a6cce:      * The desired position is w.r.t. the original, user-specified result
1:d2a6cce:      * column list--which is what "visibleSize()" gives us.  I.e. To get
1:d2a6cce:      * this OrderByColumn's position in target's RCL, first subtract out
1:d2a6cce:      * all columns which were "pulled" into the RCL for GROUP BY or ORDER
1:d2a6cce:      * BY, then add "this.addedColumnOffset". As an example, if the query
1:d2a6cce:      * was:
1:d2a6cce:      *
1:d2a6cce:      *   select sum(j) as s from t1 group by i, k order by k, sum(k)
1:d2a6cce:      *
1:d2a6cce:      * then we will internally add columns "K" and "SUM(K)" to the RCL for
1:d2a6cce:      * ORDER BY, *AND* we will add a generated column "I" to the RCL for
1:d2a6cce:      * GROUP BY.  Thus we end up with four result columns:
1:d2a6cce:      *
1:d2a6cce:      *          (1)        (2)  (3)   (4)
1:d2a6cce:      *  select sum(j) as s, K, SUM(K), I from t1 ...
1:d2a6cce:      *
1:d2a6cce:      * So when we get here and we want to find out which column "this"
1:d2a6cce:      * corresponds to, we begin by taking the total number of VISIBLE
1:d2a6cce:      * columns, which is 1 (i.e. 4 total columns minus 1 GROUP BY column
1:d2a6cce:      * minus 2 ORDER BY columns).  Then we add this.addedColumnOffset in
1:d2a6cce:      * order to find the target column position.  Since addedColumnOffset
1:d2a6cce:      * is 0-based, an addedColumnOffset value of "0" means we want the
1:d2a6cce:      * the first ORDER BY column added to target's RCL, "1" means we want
1:d2a6cce:      * the second ORDER BY column added, etc.  So if we assume that
1:d2a6cce:      * this.addedColumnOffset is "1" in this example then we add that
1:d2a6cce:      * to the RCL's "visible size". And finally, we add 1 more to account
1:d2a6cce:      * for fact that addedColumnOffset is 0-based while column positions
1:d2a6cce:      * are 1-based. This gives:
1:d2a6cce:      *
1:d2a6cce:      *  position = 1 + 1 + 1 = 3
1:d2a6cce:      *
1:d2a6cce:      * which points to SUM(K) in the RCL.  Thus an addedColumnOffset
1:d2a6cce:      * value of "1" resolves to column SUM(K) in target's RCL; similarly,
1:d2a6cce:      * an addedColumnOffset value of "0" resolves to "K". DERBY-3303.
1:d2a6cce:      */
1:baadbde:     private void resolveAddedColumn(ResultSetNode target)
1:eac0369:     {
1:baadbde:         ResultColumnList targetCols = target.getResultColumns();
1:d2a6cce:         columnPosition = targetCols.visibleSize() + addedColumnOffset + 1;
1:baadbde:         resultCol = targetCols.getResultColumn( columnPosition);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Pull up this orderby column if it doesn't appear in the resultset
1:eac0369: 	 *
1:eac0369: 	 * @param target	The result set being selected from
1:eac0369: 	 *
1:eac0369: 	 */
1:3bb140c:     void pullUpOrderByColumn(ResultSetNode target)
1:eac0369: 				throws StandardException 
1:eac0369: 	{
2:a15163c:         ResultColumnList targetCols = target.getResultColumns();
1:eac0369: 
1:baadbde:         if(expression instanceof ColumnReference){
1:eac0369: 
1:a15163c: 			ColumnReference cr = (ColumnReference) expression;
1:eac0369: 
1:2bb13ac: 			resultCol = targetCols.findResultColumnForOrderBy(
1:b0456a0:                     cr.getColumnName(), cr.getQualifiedTableName());
1:eac0369: 
1:a15163c: 			if(resultCol == null){
1:3bb140c:                resultCol = new ResultColumn(
1:3bb140c:                         cr.getColumnName(), cr, getContextManager());
1:eac0369: 				targetCols.addResultColumn(resultCol);
1:baadbde:                 addedColumnOffset = targetCols.getOrderBySelect();
1:eac0369: 				targetCols.incOrderBySelect();
1:eac0369: 			}
1:eac0369: 			
1:a15163c: 		}else if(!isReferedColByNum(expression)){
1:3bb140c:            resultCol = new ResultColumn(
1:3bb140c:                     (String)null, expression, getContextManager());
1:a15163c: 			targetCols.addResultColumn(resultCol);
1:baadbde:             addedColumnOffset = targetCols.getOrderBySelect();
1:a15163c: 			targetCols.incOrderBySelect();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Order by columns now point to the PRN above the node of interest.
1:eac0369: 	 * We need them to point to the RCL under that one.  This is useful
1:eac0369: 	 * when combining sorts where we need to reorder the sorting
1:eac0369: 	 * columns.
1:eac0369: 	 */
1:eac0369: 	void resetToSourceRC()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (! (resultCol.getExpression() instanceof VirtualColumnNode))
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"resultCol.getExpression() expected to be instanceof VirtualColumnNode " +
1:eac0369: 					", not " + resultCol.getExpression().getClass().getName());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:e9ec322: 		resultCol = resultCol.getExpression().getSourceResultColumn();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this OrderByColumn constant, according to the given predicate list?
1:eac0369: 	 * A constant column is one where all the column references it uses are
1:eac0369: 	 * compared equal to constants.
1:eac0369: 	 */
1:eac0369: 	boolean constantColumn(PredicateList whereClause)
1:eac0369: 	{
1:eac0369: 		ValueNode sourceExpr = resultCol.getExpression();
1:eac0369: 
1:eac0369: 		return sourceExpr.constantExpression(whereClause);
1:eac0369: 	}
1:baadbde: 
1:eac0369: 	/**
1:eac0369: 	 * Remap all the column references under this OrderByColumn to their
1:eac0369: 	 * expressions.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void remapColumnReferencesToExpressions() throws StandardException
1:eac0369: 	{
1:eac0369: 		resultCol.setExpression(
1:eac0369: 			resultCol.getExpression().remapColumnReferencesToExpressions());
1:eac0369: 	}
1:baadbde: 
1:a15163c: 	private static boolean isReferedColByNum(ValueNode expression) 
2:a15163c: 	throws StandardException{
1:baadbde: 		
1:300e268:        return expression instanceof NumericConstantNode &&
1:300e268:                expression.getConstantValueAsObject() instanceof Integer;
1:eac0369: 	}
1:baadbde: 
1:baadbde: 	
1:baadbde: 	private ResultColumn resolveColumnReference(ResultSetNode target,
1:a15163c: 							   ColumnReference cr)
1:3bb140c:             throws StandardException {
1:eac0369: 		int					sourceTableNumber = -1;
1:baadbde: 		
1:eac0369: 		//bug 5716 - for db2 compatibility - no qualified names allowed in order by clause when union/union all operator is used 
1:a15163c: 
1:a15163c: 		if (target instanceof SetOperatorNode && cr.getTableName() != null){
1:a15163c: 			String fullName = cr.getSQLColumnName();
1:eac0369: 			throw StandardException.newException(SQLState.LANG_QUALIFIED_COLUMN_NAME_NOT_ALLOWED, fullName);
1:eac0369: 		}
1:a15163c: 
1:b0456a0: 		if(cr.getQualifiedTableName() != null){
1:b0456a0: 			TableName tableNameNode = cr.getQualifiedTableName();
7:a15163c: 
1:a15163c: 			FromTable fromTable = target.getFromTableByName(tableNameNode.getTableName(),
1:a15163c: 									(tableNameNode.hasSchema() ?
1:a15163c: 									 tableNameNode.getSchemaName():null),
1:a15163c: 									true);
1:a15163c: 			if(fromTable == null){
1:a15163c: 				fromTable = target.getFromTableByName(tableNameNode.getTableName(),
1:a15163c: 								      (tableNameNode.hasSchema() ?
1:a15163c: 								       tableNameNode.getSchemaName():null),
1:a15163c: 								      false);
1:a15163c: 				if(fromTable == null){
1:b0456a0: 					String fullName = cr.getQualifiedTableName().toString();
1:eac0369: 					throw StandardException.newException(SQLState.LANG_EXPOSED_NAME_NOT_FOUND, fullName);
1:eac0369: 				}
1:eac0369: 			}
1:a15163c: 
1:eac0369: 			/* HACK - if the target is a UnionNode, then we have to
1:eac0369: 			 * have special code to get the sourceTableNumber.  This is
1:eac0369: 			 * because of the gyrations we go to with building the RCLs
1:eac0369: 			 * for a UnionNode.
1:eac0369: 			 */
1:a15163c: 			if (target instanceof SetOperatorNode)
1:eac0369: 			{
1:eac0369: 				sourceTableNumber = ((FromTable) target).getTableNumber();
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				sourceTableNumber = fromTable.getTableNumber();
1:eac0369: 			}
1:a15163c: 			
1:eac0369: 		}
1:a15163c: 
2:eac0369: 		ResultColumnList	targetCols = target.getResultColumns();
1:eac0369: 
1:3bb140c:         ResultColumn resCol = targetCols.getOrderByColumnToBind(
1:3bb140c:                             cr.getColumnName(),
1:b0456a0: 							cr.getQualifiedTableName(),
1:2bb13ac: 							sourceTableNumber,
1:2bb13ac: 							this);
1:baadbde:         /* Search targetCols before using addedColumnOffset because select list wildcards, '*',
1:baadbde:          * are expanded after pullUpOrderByColumn is called. A simple column reference in the
1:baadbde:          * order by clause may be found in the user specified select list now even though it was
1:baadbde:          * not found when pullUpOrderByColumn was called.
1:eac0369:          */
1:3bb140c:         if( resCol == null && addedColumnOffset >= 0)
1:baadbde:             resolveAddedColumn(target);
1:eac0369: 							
1:3bb140c:         if (resCol == null || resCol.isNameGenerated()){
1:b0456a0: 			String errString = cr.getColumnName();
1:eac0369: 			throw StandardException.newException(SQLState.LANG_ORDER_BY_COLUMN_NOT_FOUND, errString);
1:eac0369: 		}
1:eac0369: 
1:3bb140c:         return resCol;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:2bb13ac: 	 * Reset addedColumnOffset to indicate that column is no longer added
1:2bb13ac: 	 *
1:2bb13ac: 	 * An added column is one which was artificially added to the result
1:2bb13ac: 	 * column list due to its presence in the ORDER BY clause, as opposed to
1:2bb13ac: 	 * having been explicitly selected by the user. Since * is not expanded
1:2bb13ac: 	 * until after the ORDER BY columns have been pulled up, we may add a
1:2bb13ac: 	 * column, then later decide it is a duplicate of an explicitly selected
1:2bb13ac: 	 * column. In that case, this method is called, and it does the following:
1:2bb13ac: 	 * - resets addedColumnOffset to -1 to indicate this is not an added col
1:2bb13ac: 	 * - calls back to the OrderByList to adjust any other added cols
1:2bb13ac: 	 */
1:2bb13ac: 	void clearAddedColumnOffset()
1:2bb13ac: 	{
1:2bb13ac: 		list.closeGap(addedColumnOffset);
1:2bb13ac: 		addedColumnOffset = -1;
1:2bb13ac: 	}
1:2bb13ac: 	/**
1:2bb13ac: 	 * Adjust addedColumnOffset to reflect that a column has been removed
1:2bb13ac: 	 *
1:2bb13ac: 	 * This routine is called when a previously-added result column has been
1:2bb13ac: 	 * removed due to being detected as a duplicate. If that added column had
1:2bb13ac: 	 * a lower offset than our column, we decrement our offset to reflect that
1:2bb13ac: 	 * we have just been moved down one slot in the result column list.
1:2bb13ac: 	 *
1:2bb13ac: 	 * @param gap   offset of the column which has just been removed from list
1:2bb13ac: 	 */
1:2bb13ac: 	void collapseAddedColumnGap(int gap)
1:2bb13ac: 	{
1:2bb13ac: 		if (addedColumnOffset > gap)
1:2bb13ac: 			addedColumnOffset--;
1:2bb13ac: 	}
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:7a9ce7e: 	 *
1:7a9ce7e: 	 * @param v the visitor
1:7a9ce7e: 	 *
1:7a9ce7e: 	 * @exception StandardException on error
1:7a9ce7e: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:7a9ce7e: 		throws StandardException
1:7a9ce7e: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:7a9ce7e: 
1:aebfb28: 		if (expression != null)
1:7a9ce7e: 		{
1:7a9ce7e: 			expression = (ValueNode)expression.accept(v);
1:7a9ce7e: 		}
1:7a9ce7e: 	}
1:7a9ce7e: 
1:4d044a3:     ValueNode getExpression() {
1:4d044a3:         return expression;
1:4d044a3:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * If the sort key is already in the result column list then addedColumnOffset &lt; 0.
commit:b0456a0
/////////////////////////////////////////////////////////////////////////
1: 				throw StandardException.newException(SQLState.LANG_DISTINCT_ORDER_BY, cr.getColumnName());
/////////////////////////////////////////////////////////////////////////
1:                     cr.getColumnName(), cr.getQualifiedTableName());
/////////////////////////////////////////////////////////////////////////
1: 		if(cr.getQualifiedTableName() != null){
1: 			TableName tableNameNode = cr.getQualifiedTableName();
/////////////////////////////////////////////////////////////////////////
1: 					String fullName = cr.getQualifiedTableName().toString();
/////////////////////////////////////////////////////////////////////////
1: 							cr.getQualifiedTableName(),
/////////////////////////////////////////////////////////////////////////
1: 			String errString = cr.getColumnName();
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:7b2b4db
/////////////////////////////////////////////////////////////////////////
commit:cc30c0c
/////////////////////////////////////////////////////////////////////////
1: 	private boolean			nullsOrderedLow = false;
/////////////////////////////////////////////////////////////////////////
1: 	 * Mark the column as ordered NULL values lower than non-NULL values.
1: 	 */
0: 	public void setNullsOrderedLow() {
1: 		nullsOrderedLow = true;
1: 	}
1: 
1: 	/**
1: 	 * Get the column NULL ordering. Overrides
1: 	 * OrderedColumn.getIsNullsOrderedLow.
1: 	 *
1: 	 * @return true if NULLs ordered low, false if NULLs ordered high
1: 	 */
0: 	public boolean isNullsOrderedLow() {
1: 		return nullsOrderedLow;
1: 	}
1: 
1: 	/**
commit:2939b68
/////////////////////////////////////////////////////////////////////////
1: 			if (addedColumnOffset >= 0 &&
1: 					target instanceof SelectNode &&
1: 					( (SelectNode)target ).hasDistinct())
0: 				throw StandardException.newException(SQLState.LANG_DISTINCT_ORDER_BY, cr.columnName);
/////////////////////////////////////////////////////////////////////////
1: 			if (addedColumnOffset >= 0 &&
1: 					target instanceof SelectNode &&
0: 					( (SelectNode)target ).hasDistinct())
0: 				throw StandardException.newException(SQLState.LANG_DISTINCT_ORDER_BY_EXPRESSION);
commit:475f87e
/////////////////////////////////////////////////////////////////////////
1: 		if (resultCol == null)
1: 			throw StandardException.newException(SQLState.LANG_UNION_ORDER_BY);
commit:2bb13ac
/////////////////////////////////////////////////////////////////////////
1: 	private OrderByList     list;
/////////////////////////////////////////////////////////////////////////
1: 	 * During binding, we may discover that this order by column was pulled
1: 	 * up into the result column list, but is now a duplicate, because the
1: 	 * actual result column was expanded into the result column list when "*"
1: 	 * expressions were replaced with the list of the table's columns. In such
1: 	 * a situation, we will end up calling back to the OrderByList to
1: 	 * adjust the addedColumnOffset values of the columns; the "oblist"
1: 	 * parameter exists to allow that callback to be performed.
1: 	 *
1: 	 * @param oblist    OrderByList which contains this column
0: 	public void bindOrderByColumn(ResultSetNode target, OrderByList oblist)
1: 		this.list = oblist;
1: 
/////////////////////////////////////////////////////////////////////////
1: 			resultCol = targetCols.findResultColumnForOrderBy(
0:                     cr.getColumnName(), cr.getTableNameNode());
/////////////////////////////////////////////////////////////////////////
0: 		resultCol = targetCols.getOrderByColumnToBind(cr.getColumnName(),
1: 							sourceTableNumber,
1: 							this);
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Reset addedColumnOffset to indicate that column is no longer added
1: 	 *
1: 	 * An added column is one which was artificially added to the result
1: 	 * column list due to its presence in the ORDER BY clause, as opposed to
1: 	 * having been explicitly selected by the user. Since * is not expanded
1: 	 * until after the ORDER BY columns have been pulled up, we may add a
1: 	 * column, then later decide it is a duplicate of an explicitly selected
1: 	 * column. In that case, this method is called, and it does the following:
1: 	 * - resets addedColumnOffset to -1 to indicate this is not an added col
1: 	 * - calls back to the OrderByList to adjust any other added cols
1: 	 */
1: 	void clearAddedColumnOffset()
1: 	{
1: 		list.closeGap(addedColumnOffset);
1: 		addedColumnOffset = -1;
1: 	}
1: 	/**
1: 	 * Adjust addedColumnOffset to reflect that a column has been removed
1: 	 *
1: 	 * This routine is called when a previously-added result column has been
1: 	 * removed due to being detected as a duplicate. If that added column had
1: 	 * a lower offset than our column, we decrement our offset to reflect that
1: 	 * we have just been moved down one slot in the result column list.
1: 	 *
1: 	 * @param gap   offset of the column which has just been removed from list
1: 	 */
1: 	void collapseAddedColumnGap(int gap)
1: 	{
1: 		if (addedColumnOffset > gap)
1: 			addedColumnOffset--;
1: 	}
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextManager;
/////////////////////////////////////////////////////////////////////////
1: class OrderByColumn extends OrderedColumn {
/////////////////////////////////////////////////////////////////////////
1:      * Constructor.
1:      * @param cm                    The context manager
1:     OrderByColumn(ValueNode expression, ContextManager cm)
1:         super(cm);
0:         setNodeType(C_NodeTypes.ORDER_BY_COLUMN);
1:         this.expression = expression;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     void setDescending() {
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isAscending() {
1:     void setNullsOrderedLow() {
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isNullsOrderedLow() {
/////////////////////////////////////////////////////////////////////////
1:     void bindOrderByColumn(ResultSetNode target, OrderByList oblist)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     String col=cr1.getColumnName();
1:                     boolean match = columnMatchFound(target,cr1);
/////////////////////////////////////////////////////////////////////////
1:     void pullUpOrderByColumn(ResultSetNode target)
/////////////////////////////////////////////////////////////////////////
1:                resultCol = new ResultColumn(
1:                         cr.getColumnName(), cr, getContextManager());
1:            resultCol = new ResultColumn(
1:                     (String)null, expression, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:             throws StandardException {
/////////////////////////////////////////////////////////////////////////
1:         ResultColumn resCol = targetCols.getOrderByColumnToBind(
1:                             cr.getColumnName(),
/////////////////////////////////////////////////////////////////////////
1:         if( resCol == null && addedColumnOffset >= 0)
1:         if (resCol == null || resCol.isNameGenerated()){
1:         return resCol;
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:300e268
/////////////////////////////////////////////////////////////////////////
1:        return expression instanceof NumericConstantNode &&
1:                expression.getConstantValueAsObject() instanceof Integer;
commit:49300a7
/////////////////////////////////////////////////////////////////////////
1:             if (list.isTableValueCtorOrdering()) {
1:                 // For VALUES, we only allow ordering by column number,
1:                 // SQL-92 style. This is a more general expression, so throw.
1:                 throw StandardException.newException(
1:                         SQLState.LANG_TABLE_VALUE_CTOR_RESTRICTION);
1:             }
1: 
commit:4d044a3
/////////////////////////////////////////////////////////////////////////
1:     ValueNode getExpression() {
1:         return expression;
1:     }
commit:7a9ce7e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.compile.Visitable;
1: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.
1: 	 *
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v)
1: 		throws StandardException
1: 	{
0: 		Visitable returnNode = v.visit(this);
1: 
0: 		if (v.skipChildren(this))
1: 		{
0: 			return returnNode;
1: 		}
1: 
0: 		if (expression != null && !v.stopTraversal())
1: 		{
1: 			expression = (ValueNode)expression.accept(v);
1: 		}
0: 		return returnNode;
1: 	}
1: 
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
1: 			return
1: 				"nullsOrderedLow: " + nullsOrderedLow + "\n" +
1: 				"ascending; " + ascending + "\n" +
1: 				"addedColumnOffset: " + addedColumnOffset + "\n" +
1: 				super.toString();
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 */
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (expression != null) {
1: 				printLabel(depth, "expression: ");
1: 				expression.treePrint(depth + 1);
1: 			}
1: 
1: 			if (resultCol != null) {
1: 				printLabel(depth, "resultCol: ");
1: 				resultCol.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a6d25cd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 CollectNodesVisitor<ColumnReference> collectNodesVisitor =
1:                     new CollectNodesVisitor<ColumnReference>(
1:                         ColumnReference.class);
1:                 for (ColumnReference cr1 : collectNodesVisitor.getList())
commit:a480224
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1: 			/*checks for the conditions when using distinct*/
0: 			if (addedColumnOffset >= 0 &&
0: 					target instanceof SelectNode &&
1: 					((SelectNode)target).hasDistinct() &&
1: 					!expressionMatch(target))
1: 			{
0: 				String col=null;
0: 				boolean match=false;
1: 
0: 				CollectNodesVisitor collectNodesVisitor =
0: 					new CollectNodesVisitor(ColumnReference.class);
1: 				expression.accept(collectNodesVisitor);
1: 
0: 				for (Iterator it = collectNodesVisitor.getList().iterator();
0: 				it.hasNext(); )
1: 				{//visits through the columns in this OrderByColumn
0: 					ColumnReference cr1=(ColumnReference)it.next();
0: 					col=cr1.getColumnName();
0: 					match = columnMatchFound(target,cr1);
1: 					/* breaks if a match not found, this is needed
1: 					 * because all column references in this
1: 					 * OrderByColumn should be there in the select
1: 					 * clause.*/
1: 					if(!match)
1: 						throw StandardException.newException(
1: 								SQLState.LANG_DISTINCT_ORDER_BY,
1: 								col);
1: 				}
1: 			}
1: 
1: 			if( SanityManager.DEBUG)
1: 				SanityManager.ASSERT( addedColumnOffset >= 0,
1: 				"Order by expression was not pulled into the result column list");
1: 			resolveAddedColumn(target);
0: 			if (resultCol == null)
0: 				throw StandardException.newException(SQLState.LANG_UNION_ORDER_BY);
1: 	/**
1: 	 * Checks whether the whole expression (OrderByColumn) itself
1: 	 * found in the select clause.
1: 	 * @param target Result set
1: 	 * @return boolean: whether any expression match found
1: 	 * @throws StandardException
1: 	 */
1: 	private boolean expressionMatch(ResultSetNode target)
1: 										throws StandardException{
1: 		ResultColumnList rcl=target.getResultColumns();
1: 		for (int i=1; i<=rcl.visibleSize();i++){
1: 			//since RCs are 1 based
1: 			if((rcl.getResultColumn(i)).isEquivalent(
1: 					resultCol))
1: 				return true;
1: 		}
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * This method checks a ColumnReference of this OrderByColumn
1: 	 * against the ColumnReferences of the select clause of the query.
1: 	 * @param target result set
1: 	 * @param crOfExpression the CR to be checked
1: 	 * @return whether a match found or not
1: 	 * @throws StandardException
1: 	 */
1: 	private boolean columnMatchFound(ResultSetNode target,
1: 			ColumnReference crOfExpression) throws StandardException{
1: 		ResultColumnList rcl=target.getResultColumns();
1: 		for (int i=1; i<=rcl.visibleSize();
1: 		i++){//grab the RCs related to select clause
1: 			ValueNode exp=rcl.getResultColumn(i).getExpression();
1: 			if(exp instanceof ColumnReference)
1: 			{//visits through the columns in the select clause
1: 				ColumnReference cr2 =
1: 					(ColumnReference) (exp);
1: 				if(crOfExpression.isEquivalent(cr2))
1: 					return true;
1: 			}
1: 		}
1: 		return false;
1: 	}
1: 
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
1: 		if (expression != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
author:Army
-------------------------------------------------------------------------------
commit:d2a6cce
/////////////////////////////////////////////////////////////////////////
1: 
1: 			/* Column is out of range if either a) resultCol is null, OR
1: 			 * b) resultCol points to a column that is not visible to the
1: 			 * user (i.e. it was generated internally).
1: 			 */
1: 			if ((resultCol == null) ||
1: 				(resultCol.getColumnPosition() > targetCols.visibleSize()))
1: 			{
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Assuming this OrderByColumn was "pulled" into the received target's
1:      * ResultColumnList (because it wasn't there to begin with), use
1:      * this.addedColumnOffset to figure out which of the target's result
1:      * columns is the one corresponding to "this".
1:      *
1:      * The desired position is w.r.t. the original, user-specified result
1:      * column list--which is what "visibleSize()" gives us.  I.e. To get
1:      * this OrderByColumn's position in target's RCL, first subtract out
1:      * all columns which were "pulled" into the RCL for GROUP BY or ORDER
1:      * BY, then add "this.addedColumnOffset". As an example, if the query
1:      * was:
1:      *
1:      *   select sum(j) as s from t1 group by i, k order by k, sum(k)
1:      *
1:      * then we will internally add columns "K" and "SUM(K)" to the RCL for
1:      * ORDER BY, *AND* we will add a generated column "I" to the RCL for
1:      * GROUP BY.  Thus we end up with four result columns:
1:      *
1:      *          (1)        (2)  (3)   (4)
1:      *  select sum(j) as s, K, SUM(K), I from t1 ...
1:      *
1:      * So when we get here and we want to find out which column "this"
1:      * corresponds to, we begin by taking the total number of VISIBLE
1:      * columns, which is 1 (i.e. 4 total columns minus 1 GROUP BY column
1:      * minus 2 ORDER BY columns).  Then we add this.addedColumnOffset in
1:      * order to find the target column position.  Since addedColumnOffset
1:      * is 0-based, an addedColumnOffset value of "0" means we want the
1:      * the first ORDER BY column added to target's RCL, "1" means we want
1:      * the second ORDER BY column added, etc.  So if we assume that
1:      * this.addedColumnOffset is "1" in this example then we add that
1:      * to the RCL's "visible size". And finally, we add 1 more to account
1:      * for fact that addedColumnOffset is 0-based while column positions
1:      * are 1-based. This gives:
1:      *
1:      *  position = 1 + 1 + 1 = 3
1:      *
1:      * which points to SUM(K) in the RCL.  Thus an addedColumnOffset
1:      * value of "1" resolves to column SUM(K) in target's RCL; similarly,
1:      * an addedColumnOffset value of "0" resolves to "K". DERBY-3303.
1:      */
1:         columnPosition = targetCols.visibleSize() + addedColumnOffset + 1;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:e9ec322
/////////////////////////////////////////////////////////////////////////
1: 		resultCol = resultCol.getExpression().getSourceResultColumn();
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.OrderByColumn
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.types.TypeId;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
1: /**
1:  * An OrderByColumn is a column in the ORDER BY clause.  An OrderByColumn
1:  * can be ordered ascending or descending.
1:  *
1:  * We need to make sure that the named columns are
1:  * columns in that query, and that positions are within range.
1:  *
0:  * @author ames
1:  */
0: public class OrderByColumn extends OrderedColumn {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	private ResultColumn	resultCol;
0: 	private String			columnName;
0: 	private	String			correlationName;
0: 	private String	schemaName;
1: 	private boolean			ascending = true;
1: 
1: 	/**
0: 	 * Initializer.
1: 	 *
0: 	 * @param columnName		The name of the column being referenced
0: 	 * @param correlationName	The correlation name, if any
1: 	 */
0: 	public void init(
0: 						Object columnName, 
0: 						Object correlationName,
0: 						Object schemaName) 
1: 	{
0: 		this.columnName = (String) columnName;
0: 		this.correlationName = (String) correlationName;
0: 		this.schemaName = (String) schemaName;
1: 	}
1: 
1: 	/**
0: 	 * Initializer.
1: 	 *
0: 	 * @param columnPosition	The position of the column being referenced
1: 	 */
0: 	public void init(Object columnPosition) {
0: 		this.columnPosition = ((Integer) columnPosition).intValue();
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 	public String toString() {
1: 		if (SanityManager.DEBUG) {
0: 			return "columnName: " + columnName + "\n" +
0: 				"correlationName: " + correlationName + "\n" +
0: 				"schemaName: " + schemaName + "\n" +
0: 				super.toString();
1: 		} else {
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Get the name of this column
1: 	 *
0: 	 * @return	The name of this column
1: 	 */
0: 	public String getColumnName() {
0: 		return columnName;
1: 	}
1: 
1: 	/**
1: 	 * Mark the column as descending order
1: 	 */
0: 	public void setDescending() {
1: 		ascending = false;
1: 	}
1: 
1: 	/**
1: 	 * Get the column order.  Overrides 
1: 	 * OrderedColumn.isAscending.
1: 	 *
1: 	 * @return true if ascending, false if descending
1: 	 */
0: 	public boolean isAscending() {
1: 		return ascending;
1: 	}
1: 
1: 	/**
1: 	 * Get the underlying ResultColumn.
1: 	 *
1: 	 * @return The underlying ResultColumn.
1: 	 */
1: 	ResultColumn getResultColumn()
1: 	{
1: 		return resultCol;
1: 	}
1: 
1: 	/**
1: 	 * Get the underlying expression, skipping over ResultColumns that
1: 	 * are marked redundant.
1: 	 */
1: 	ValueNode getNonRedundantExpression()
1: 	{
1: 		ResultColumn	rc;
1: 		ValueNode		value;
1: 		ColumnReference	colref = null;
1: 
1: 		for (rc = resultCol; rc.isRedundant(); rc = colref.getSource())
1: 		{
1: 			value = rc.getExpression();
1: 
1: 			if (value instanceof ColumnReference)
1: 			{
1: 				colref = (ColumnReference) value;
1: 			}
1: 			else
1: 			{
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.THROWASSERT(
1: 						"value should be a ColumnReference, but is a " +
1: 						value.getClass().getName());
1: 				}
1: 			}
1: 		}
1: 
1: 		return rc.getExpression();
1: 	}
1: 
1: 	/**
1: 	 * Bind this column.
1: 	 *
1: 	 * @param target	The result set being selected from
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 * @exception StandardException		Thrown when column not found
1: 	 */
0: 	public void bindOrderByColumn(ResultSetNode target)
1: 				throws StandardException 
1: 	{
1: 		int					sourceTableNumber = -1;
1: 		ResultColumnList	targetCols = target.getResultColumns();
1: 
1: 		//bug 5716 - for db2 compatibility - no qualified names allowed in order by clause when union/union all operator is used 
0: 		if (target instanceof UnionNode && correlationName != null)
1: 		{
0: 			String fullName = (schemaName != null) ?
0: 				(schemaName + "." + correlationName + "." + columnName) :
0: 				(correlationName + "." + columnName);
1: 			throw StandardException.newException(SQLState.LANG_QUALIFIED_COLUMN_NAME_NOT_ALLOWED, fullName);
1: 		}
0: 		/* If the correlation name is non-null then we need to verify that it
0: 		 * is a valid exposed name.  
1: 		 */
0: 		if (correlationName != null)
1: 		{
0: 			/* Find the matching FromTable visible in the current scope.
0: 			 * We first try a full match on both schema and table name.  If no
0: 			 * match, then we go for same table id.
1: 			 */
0: 			FromTable fromTable = target.getFromTableByName(correlationName, schemaName, true);
0: 			if (fromTable == null)
1: 			{
0: 				fromTable = target.getFromTableByName(correlationName, schemaName, false);
0: 				if (fromTable == null)
1: 				{
0: 					String fullName = (schemaName != null) ?
0: 										(schemaName + "." + correlationName) : 
0: 										correlationName;
0: 					// correlation name is not an exposed name in the current scope
1: 					throw StandardException.newException(SQLState.LANG_EXPOSED_NAME_NOT_FOUND, fullName);
1: 				}
1: 			}
1: 			
1: 			/* HACK - if the target is a UnionNode, then we have to
1: 			 * have special code to get the sourceTableNumber.  This is
1: 			 * because of the gyrations we go to with building the RCLs
1: 			 * for a UnionNode.
1: 			 */
0: 			if (target instanceof UnionNode)
1: 			{
1: 				sourceTableNumber = ((FromTable) target).getTableNumber();
1: 			}
1: 			else
1: 			{
1: 				sourceTableNumber = fromTable.getTableNumber();
1: 			}
1: 		}
1: 
0: 		if (columnName != null) 
1: 		{
0: 			/* If correlation name is not null, then we look an RC whose expression is a
0: 			 * ColumnReference with the same table number as the FromTable with 
0: 			 * correlationName as its exposed name.
0: 			 * If correlation name is null, then we simply look for an RC whose name matches
0: 			 * columnName.
1: 			 */
0: 			resultCol = targetCols.getOrderByColumn(columnName, correlationName, sourceTableNumber);
1: 
0: 			/* DB2 doesn't allow ordering using generated column name */
0: 			if ((resultCol == null) || resultCol.isNameGenerated())
1: 			{
0: 				String errString = (correlationName == null) ?
0: 									columnName :
0: 									correlationName + "." + columnName;
1: 				throw StandardException.newException(SQLState.LANG_ORDER_BY_COLUMN_NOT_FOUND, errString);
1: 			}
1: 			columnPosition = resultCol.getColumnPosition();
1: 		}
0: 		else {
1: 			resultCol = targetCols.getOrderByColumn(columnPosition);
0: 			if (resultCol == null) {
0: 				throw StandardException.newException(SQLState.LANG_COLUMN_OUT_OF_RANGE, String.valueOf(columnPosition));
1: 			}
1: 		}
1: 
1: 		// Verify that the column is orderable
1: 		resultCol.verifyOrderable();
1: 	}
1: 
1: 	/**
1: 	 * Pull up this orderby column if it doesn't appear in the resultset
1: 	 *
1: 	 * @param target	The result set being selected from
1: 	 *
1: 	 */
0: 	public void pullUpOrderByColumn(ResultSetNode target)
1: 				throws StandardException 
1: 	{
0: 		if (columnName != null) 
1: 		{
0: 			/* If correlation name is not null, then we look an RC whose expression is a
0: 			 * ColumnReference with the same table number as the FromTable with 
0: 			 * correlationName as its exposed name.
0: 			 * If correlation name is null, then we simply look for an RC whose name matches
0: 			 * columnName.
1: 			 */
1: 			ResultColumnList	targetCols = target.getResultColumns();
0: 			resultCol = targetCols.getOrderByColumn(columnName, correlationName);
0: 			if (resultCol == null) 
0: 			{// add this order by column to the result set
1: 
0: 				TableName tabName = null;
0: 				if (schemaName != null || correlationName != null)
1: 				{
0: 					tabName = (TableName) getNodeFactory().getNode(
0: 																   C_NodeTypes.TABLE_NAME,
0: 																   schemaName,
0: 																   correlationName,
0: 																   getContextManager());
1: 				}
1: 
0: 				ColumnReference cr = (ColumnReference) getNodeFactory().getNode(
0: 																		   C_NodeTypes.COLUMN_REFERENCE,
0: 																		   columnName,
0: 																		   tabName,
0: 																		   getContextManager());
1: 				
0: 				resultCol = (ResultColumn) getNodeFactory().getNode(
0: 															   C_NodeTypes.RESULT_COLUMN,
0: 															   columnName,
0: 															   cr, // column reference
0: 															   getContextManager());
1: 
1: 				targetCols.addResultColumn(resultCol);
1: 				targetCols.incOrderBySelect();
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Order by columns now point to the PRN above the node of interest.
1: 	 * We need them to point to the RCL under that one.  This is useful
1: 	 * when combining sorts where we need to reorder the sorting
1: 	 * columns.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void resetToSourceRC()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (! (resultCol.getExpression() instanceof VirtualColumnNode))
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"resultCol.getExpression() expected to be instanceof VirtualColumnNode " +
1: 					", not " + resultCol.getExpression().getClass().getName());
1: 			}
1: 		}
1: 
0: 		VirtualColumnNode vcn = (VirtualColumnNode) resultCol.getExpression();
0: 		resultCol = vcn.getSourceResultColumn();
1: 	}
1: 
1: 	/**
1: 	 * Is this OrderByColumn constant, according to the given predicate list?
1: 	 * A constant column is one where all the column references it uses are
1: 	 * compared equal to constants.
1: 	 */
1: 	boolean constantColumn(PredicateList whereClause)
1: 	{
1: 		ValueNode sourceExpr = resultCol.getExpression();
1: 
1: 		return sourceExpr.constantExpression(whereClause);
1: 	}
1: 
1: 	/**
1: 	 * Remap all the column references under this OrderByColumn to their
1: 	 * expressions.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void remapColumnReferencesToExpressions() throws StandardException
1: 	{
1: 		resultCol.setExpression(
1: 			resultCol.getExpression().remapColumnReferencesToExpressions());
1: 	}
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:41943bb
/////////////////////////////////////////////////////////////////////////
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:baadbde
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.util.ReuseFactory;
1: 
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * If this sort key is added to the result column list then it is at result column position
1:      * 1 + resultColumnList.size() - resultColumnList.getOrderBySelect() + addedColumnOffset
0:      * If the sort key is already in the result column list then addedColumnOffset < 0.
0:      */
1:     private int addedColumnOffset = -1;
0:    	/**
/////////////////////////////////////////////////////////////////////////
0:             if( SanityManager.DEBUG)
0:                 SanityManager.ASSERT( addedColumnOffset >= 0,
0:                                       "Order by expression was not pulled into the result column list");
1:             resolveAddedColumn(target);
1:     private void resolveAddedColumn(ResultSetNode target)
0:     {
1:         ResultColumnList targetCols = target.getResultColumns();
0:         columnPosition = targetCols.size() - targetCols.getOrderBySelect() + addedColumnOffset + 1;
1:         resultCol = targetCols.getResultColumn( columnPosition);
0:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         ResultColumnList targetCols = target.getResultColumns();
1: 
0:         // If the target is generated for a select node then we must also pull the order by column
0:         // into the select list of the subquery.
0:         if((target instanceof SelectNode) && ((SelectNode) target).getGeneratedForGroupbyClause())
0:         {
0:             if( SanityManager.DEBUG)
0:                 SanityManager.ASSERT( target.getFromList().size() == 1
0:                                       && (target.getFromList().elementAt(0) instanceof FromSubquery)
0:                                       && targetCols.size() == 1
0:                                       && targetCols.getResultColumn(1) instanceof AllResultColumn,
0:                                       "Unexpected structure of selectNode generated for a group by clause");
1: 
0:             ResultSetNode subquery = ((FromSubquery) target.getFromList().elementAt(0)).getSubquery();
0:             pullUpOrderByColumn( subquery);
0:             if( resultCol == null) // The order by column is referenced by number
0:                 return;
1: 
0:             // ResultCol is in the subquery's ResultColumnList. We have to transform this OrderByColumn
0:             // so that it refers to the column added to the subquery. We assume that the select list
0:             // in the top level target is a (generated) AllResultColumn node, so the this order by expression
0:             // does not have to be pulled into the the top level ResultColumnList.  Just change this
0:             // OrderByColumn to be a reference to the added column. We cannot use an integer column
0:             // number because the subquery can have a '*' in its select list, causing the column
0:             // number to change when the '*' is expanded.
0:             resultCol = null;
0:             targetCols.copyOrderBySelect( subquery.getResultColumns());
0:             return;
0:         }
1: 
1:         if(expression instanceof ColumnReference){
0:                                                     cr.getTableNameNode());
/////////////////////////////////////////////////////////////////////////
1:                 addedColumnOffset = targetCols.getOrderBySelect();
1:             addedColumnOffset = targetCols.getOrderBySelect();
/////////////////////////////////////////////////////////////////////////
1: 	private ResultColumn resolveColumnReference(ResultSetNode target,
/////////////////////////////////////////////////////////////////////////
0: 							cr.getTableNameNode(),
1:         /* Search targetCols before using addedColumnOffset because select list wildcards, '*',
1:          * are expanded after pullUpOrderByColumn is called. A simple column reference in the
1:          * order by clause may be found in the user specified select list now even though it was
1:          * not found when pullUpOrderByColumn was called.
0:          */
0:         if( resultCol == null && addedColumnOffset >= 0)
0:             resolveAddedColumn(target);
commit:a15163c
/////////////////////////////////////////////////////////////////////////
1: 	private ValueNode expression;
1: 
0:     	/**
1: 	 * @param expression            Expression of this column
0: 	public void init(Object expression)
0: 		this.expression = (ValueNode)expression;
1: 	
/////////////////////////////////////////////////////////////////////////
0: 			return expression.toString();
/////////////////////////////////////////////////////////////////////////
1: 		if(expression instanceof ColumnReference){
1: 		
1: 			ColumnReference cr = (ColumnReference) expression;
1: 			
1: 			resultCol = resolveColumnReference(target,
1: 							   cr);
1: 			
0: 			columnPosition = resultCol.getColumnPosition();
1: 		}else if(isReferedColByNum(expression)){
1: 			
1: 			ResultColumnList targetCols = target.getResultColumns();
1: 			columnPosition = ((Integer)expression.getConstantValueAsObject()).intValue();
0: 			resultCol = targetCols.getOrderByColumn(columnPosition);
1: 			
0: 			if (resultCol == null) {
1: 				throw StandardException.newException(SQLState.LANG_COLUMN_OUT_OF_RANGE, 
1: 								     String.valueOf(columnPosition));
0: 			}
1: 
1: 		}else{
1: 			ResultColumnList targetCols = target.getResultColumns();
0: 			ResultColumn col = null;
0: 			int i = 1;
1: 			
0: 			for(i = 1;
0: 			    i <= targetCols.size();
0: 			    i  ++){
1: 				
0: 				col = targetCols.getOrderByColumn(i);
0: 				if(col != null && 
0: 				   col.getExpression() == expression){
1: 					
0: 					break;
0: 			resultCol = col;
0: 			columnPosition = i;
1: 		    
/////////////////////////////////////////////////////////////////////////
0: 		if(expression instanceof ColumnReference){
1: 			ColumnReference cr = (ColumnReference) expression;
0: 			ResultColumnList targetCols = target.getResultColumns();
0: 			resultCol = targetCols.getOrderByColumn(cr.getColumnName(),
0: 								cr.tableName != null ? 
0: 								cr.tableName.getFullTableName():
0: 								null);
1: 			if(resultCol == null){
0: 				resultCol = (ResultColumn) getNodeFactory().getNode(C_NodeTypes.RESULT_COLUMN,
0: 										    cr.getColumnName(),
0: 										    cr,
0: 										    getContextManager());
0: 			
1: 		}else if(!isReferedColByNum(expression)){
0: 			ResultColumnList	targetCols = target.getResultColumns();
0: 			resultCol = (ResultColumn) getNodeFactory().getNode(C_NodeTypes.RESULT_COLUMN,
0: 									    null,
0: 									    expression,
0: 									    getContextManager());
1: 			targetCols.addResultColumn(resultCol);
1: 			targetCols.incOrderBySelect();
/////////////////////////////////////////////////////////////////////////
0: 
1: 	private static boolean isReferedColByNum(ValueNode expression) 
1: 	throws StandardException{
0: 		
0: 		if(!expression.isConstantExpression()){
0: 			return false;
0: 		}
0: 		
0: 		return expression.getConstantValueAsObject() instanceof Integer;
0: 	}
0: 
0: 	
0: 	private static ResultColumn resolveColumnReference(ResultSetNode target,
1: 							   ColumnReference cr)
1: 	throws StandardException{
0: 		
0: 		ResultColumn resultCol = null;
0: 		
0: 		int					sourceTableNumber = -1;
0: 		
0: 		//bug 5716 - for db2 compatibility - no qualified names allowed in order by clause when union/union all operator is used 
0: 
1: 		if (target instanceof SetOperatorNode && cr.getTableName() != null){
1: 			String fullName = cr.getSQLColumnName();
0: 			throw StandardException.newException(SQLState.LANG_QUALIFIED_COLUMN_NAME_NOT_ALLOWED, fullName);
0: 		}
0: 
0: 		if(cr.getTableNameNode() != null){
0: 			TableName tableNameNode = cr.getTableNameNode();
0: 
1: 			FromTable fromTable = target.getFromTableByName(tableNameNode.getTableName(),
1: 									(tableNameNode.hasSchema() ?
1: 									 tableNameNode.getSchemaName():null),
1: 									true);
1: 			if(fromTable == null){
1: 				fromTable = target.getFromTableByName(tableNameNode.getTableName(),
1: 								      (tableNameNode.hasSchema() ?
1: 								       tableNameNode.getSchemaName():null),
1: 								      false);
1: 				if(fromTable == null){
0: 					String fullName = cr.getTableNameNode().toString();
0: 					throw StandardException.newException(SQLState.LANG_EXPOSED_NAME_NOT_FOUND, fullName);
0: 				}
0: 			}
0: 
0: 			/* HACK - if the target is a UnionNode, then we have to
0: 			 * have special code to get the sourceTableNumber.  This is
0: 			 * because of the gyrations we go to with building the RCLs
0: 			 * for a UnionNode.
0: 			 */
1: 			if (target instanceof SetOperatorNode)
0: 			{
0: 				sourceTableNumber = ((FromTable) target).getTableNumber();
0: 			}
0: 			else
0: 			{
0: 				sourceTableNumber = fromTable.getTableNumber();
0: 			}
0: 			
0: 		}
0: 
0: 		ResultColumnList	targetCols = target.getResultColumns();
0: 
0: 		resultCol = targetCols.getOrderByColumn(cr.getColumnName(),
0: 							cr.getTableName(),
0: 							sourceTableNumber);
0: 							
0: 		if (resultCol == null || resultCol.isNameGenerated()){
0: 			String errString = cr.columnName;
0: 			throw StandardException.newException(SQLState.LANG_ORDER_BY_COLUMN_NOT_FOUND, errString);
0: 		}
0: 
0: 		return resultCol;
0: 
0: 	}
0: 
commit:6200b38
/////////////////////////////////////////////////////////////////////////
0: 		if (target instanceof SetOperatorNode && correlationName != null)
/////////////////////////////////////////////////////////////////////////
0: 			if (target instanceof SetOperatorNode)
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: /**
0:  * An OrderByColumn is a column in the ORDER BY clause.  An OrderByColumn
0:  * can be ordered ascending or descending.
0:  *
0:  * We need to make sure that the named columns are
0:  * columns in that query, and that positions are within range.
0:  *
0:  * @author ames
0:  */
0: public class OrderByColumn extends OrderedColumn {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	private ResultColumn	resultCol;
0: 	private String			columnName;
0: 	private	String			correlationName;
0: 	private String	schemaName;
0: 	private boolean			ascending = true;
0: 
0: 	/**
0: 	 * Initializer.
0: 	 *
0: 	 * @param columnName		The name of the column being referenced
0: 	 * @param correlationName	The correlation name, if any
0: 	 */
0: 	public void init(
0: 						Object columnName, 
0: 						Object correlationName,
0: 						Object schemaName) 
0: 	{
0: 		this.columnName = (String) columnName;
0: 		this.correlationName = (String) correlationName;
0: 		this.schemaName = (String) schemaName;
0: 	}
0: 
0: 	/**
0: 	 * Initializer.
0: 	 *
0: 	 * @param columnPosition	The position of the column being referenced
0: 	 */
0: 	public void init(Object columnPosition) {
0: 		this.columnPosition = ((Integer) columnPosition).intValue();
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 	public String toString() {
0: 		if (SanityManager.DEBUG) {
0: 			return "columnName: " + columnName + "\n" +
0: 				"correlationName: " + correlationName + "\n" +
0: 				"schemaName: " + schemaName + "\n" +
0: 				super.toString();
0: 		} else {
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the name of this column
0: 	 *
0: 	 * @return	The name of this column
0: 	 */
0: 	public String getColumnName() {
0: 		return columnName;
0: 	}
0: 
0: 	/**
0: 	 * Mark the column as descending order
0: 	 */
0: 	public void setDescending() {
0: 		ascending = false;
0: 	}
0: 
0: 	/**
0: 	 * Get the column order.  Overrides 
0: 	 * OrderedColumn.isAscending.
0: 	 *
0: 	 * @return true if ascending, false if descending
0: 	 */
0: 	public boolean isAscending() {
0: 		return ascending;
0: 	}
0: 
0: 	/**
0: 	 * Get the underlying ResultColumn.
0: 	 *
0: 	 * @return The underlying ResultColumn.
0: 	 */
0: 	ResultColumn getResultColumn()
0: 	{
0: 		return resultCol;
0: 	}
0: 
0: 	/**
0: 	 * Get the underlying expression, skipping over ResultColumns that
0: 	 * are marked redundant.
0: 	 */
0: 	ValueNode getNonRedundantExpression()
0: 	{
0: 		ResultColumn	rc;
0: 		ValueNode		value;
0: 		ColumnReference	colref = null;
0: 
0: 		for (rc = resultCol; rc.isRedundant(); rc = colref.getSource())
0: 		{
0: 			value = rc.getExpression();
0: 
0: 			if (value instanceof ColumnReference)
0: 			{
0: 				colref = (ColumnReference) value;
0: 			}
0: 			else
0: 			{
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT(
0: 						"value should be a ColumnReference, but is a " +
0: 						value.getClass().getName());
0: 				}
0: 			}
0: 		}
0: 
0: 		return rc.getExpression();
0: 	}
0: 
0: 	/**
0: 	 * Bind this column.
0: 	 *
0: 	 * @param target	The result set being selected from
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 * @exception StandardException		Thrown when column not found
0: 	 */
0: 	public void bindOrderByColumn(ResultSetNode target)
0: 				throws StandardException 
0: 	{
0: 		int					sourceTableNumber = -1;
0: 		ResultColumnList	targetCols = target.getResultColumns();
0: 
0: 		//bug 5716 - for db2 compatibility - no qualified names allowed in order by clause when union/union all operator is used 
0: 		if (target instanceof UnionNode && correlationName != null)
0: 		{
0: 			String fullName = (schemaName != null) ?
0: 				(schemaName + "." + correlationName + "." + columnName) :
0: 				(correlationName + "." + columnName);
0: 			throw StandardException.newException(SQLState.LANG_QUALIFIED_COLUMN_NAME_NOT_ALLOWED, fullName);
0: 		}
0: 		/* If the correlation name is non-null then we need to verify that it
0: 		 * is a valid exposed name.  
0: 		 */
0: 		if (correlationName != null)
0: 		{
0: 			/* Find the matching FromTable visible in the current scope.
0: 			 * We first try a full match on both schema and table name.  If no
0: 			 * match, then we go for same table id.
0: 			 */
0: 			FromTable fromTable = target.getFromTableByName(correlationName, schemaName, true);
0: 			if (fromTable == null)
0: 			{
0: 				fromTable = target.getFromTableByName(correlationName, schemaName, false);
0: 				if (fromTable == null)
0: 				{
0: 					String fullName = (schemaName != null) ?
0: 										(schemaName + "." + correlationName) : 
0: 										correlationName;
0: 					// correlation name is not an exposed name in the current scope
0: 					throw StandardException.newException(SQLState.LANG_EXPOSED_NAME_NOT_FOUND, fullName);
0: 				}
0: 			}
0: 			
0: 			/* HACK - if the target is a UnionNode, then we have to
0: 			 * have special code to get the sourceTableNumber.  This is
0: 			 * because of the gyrations we go to with building the RCLs
0: 			 * for a UnionNode.
0: 			 */
0: 			if (target instanceof UnionNode)
0: 			{
0: 				sourceTableNumber = ((FromTable) target).getTableNumber();
0: 			}
0: 			else
0: 			{
0: 				sourceTableNumber = fromTable.getTableNumber();
0: 			}
0: 		}
0: 
0: 		if (columnName != null) 
0: 		{
0: 			/* If correlation name is not null, then we look an RC whose expression is a
0: 			 * ColumnReference with the same table number as the FromTable with 
0: 			 * correlationName as its exposed name.
0: 			 * If correlation name is null, then we simply look for an RC whose name matches
0: 			 * columnName.
0: 			 */
0: 			resultCol = targetCols.getOrderByColumn(columnName, correlationName, sourceTableNumber);
0: 
0: 			/* DB2 doesn't allow ordering using generated column name */
0: 			if ((resultCol == null) || resultCol.isNameGenerated())
0: 			{
0: 				String errString = (correlationName == null) ?
0: 									columnName :
0: 									correlationName + "." + columnName;
0: 				throw StandardException.newException(SQLState.LANG_ORDER_BY_COLUMN_NOT_FOUND, errString);
0: 			}
0: 			columnPosition = resultCol.getColumnPosition();
0: 		}
0: 		else {
0: 			resultCol = targetCols.getOrderByColumn(columnPosition);
0: 			if (resultCol == null) {
0: 				throw StandardException.newException(SQLState.LANG_COLUMN_OUT_OF_RANGE, String.valueOf(columnPosition));
0: 			}
0: 		}
0: 
0: 		// Verify that the column is orderable
0: 		resultCol.verifyOrderable();
0: 	}
0: 
0: 	/**
0: 	 * Pull up this orderby column if it doesn't appear in the resultset
0: 	 *
0: 	 * @param target	The result set being selected from
0: 	 *
0: 	 */
0: 	public void pullUpOrderByColumn(ResultSetNode target)
0: 				throws StandardException 
0: 	{
0: 		if (columnName != null) 
0: 		{
0: 			/* If correlation name is not null, then we look an RC whose expression is a
0: 			 * ColumnReference with the same table number as the FromTable with 
0: 			 * correlationName as its exposed name.
0: 			 * If correlation name is null, then we simply look for an RC whose name matches
0: 			 * columnName.
0: 			 */
0: 			ResultColumnList	targetCols = target.getResultColumns();
0: 			resultCol = targetCols.getOrderByColumn(columnName, correlationName);
0: 			if (resultCol == null) 
0: 			{// add this order by column to the result set
0: 
0: 				TableName tabName = null;
0: 				if (schemaName != null || correlationName != null)
0: 				{
0: 					tabName = (TableName) getNodeFactory().getNode(
0: 																   C_NodeTypes.TABLE_NAME,
0: 																   schemaName,
0: 																   correlationName,
0: 																   getContextManager());
0: 				}
0: 
0: 				ColumnReference cr = (ColumnReference) getNodeFactory().getNode(
0: 																		   C_NodeTypes.COLUMN_REFERENCE,
0: 																		   columnName,
0: 																		   tabName,
0: 																		   getContextManager());
0: 				
0: 				resultCol = (ResultColumn) getNodeFactory().getNode(
0: 															   C_NodeTypes.RESULT_COLUMN,
0: 															   columnName,
0: 															   cr, // column reference
0: 															   getContextManager());
0: 
0: 				targetCols.addResultColumn(resultCol);
0: 				targetCols.incOrderBySelect();
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Order by columns now point to the PRN above the node of interest.
0: 	 * We need them to point to the RCL under that one.  This is useful
0: 	 * when combining sorts where we need to reorder the sorting
0: 	 * columns.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void resetToSourceRC()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (! (resultCol.getExpression() instanceof VirtualColumnNode))
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"resultCol.getExpression() expected to be instanceof VirtualColumnNode " +
0: 					", not " + resultCol.getExpression().getClass().getName());
0: 			}
0: 		}
0: 
0: 		VirtualColumnNode vcn = (VirtualColumnNode) resultCol.getExpression();
0: 		resultCol = vcn.getSourceResultColumn();
0: 	}
0: 
0: 	/**
0: 	 * Is this OrderByColumn constant, according to the given predicate list?
0: 	 * A constant column is one where all the column references it uses are
0: 	 * compared equal to constants.
0: 	 */
0: 	boolean constantColumn(PredicateList whereClause)
0: 	{
0: 		ValueNode sourceExpr = resultCol.getExpression();
0: 
0: 		return sourceExpr.constantExpression(whereClause);
0: 	}
0: 
0: 	/**
0: 	 * Remap all the column references under this OrderByColumn to their
0: 	 * expressions.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void remapColumnReferencesToExpressions() throws StandardException
0: 	{
0: 		resultCol.setExpression(
0: 			resultCol.getExpression().remapColumnReferencesToExpressions());
0: 	}
0: }
============================================================================