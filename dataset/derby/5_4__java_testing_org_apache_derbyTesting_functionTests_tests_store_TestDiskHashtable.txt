1:b223f72: /*
2:b223f72: 
1:b223f72:    Derby - Class org.apache.derbyTesting.functionTests.tests.store.TestDiskHashtable
1:b223f72: 
1:dff95a1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:dff95a1:    contributor license agreements.  See the NOTICE file distributed with
1:dff95a1:    this work for additional information regarding copyright ownership.
1:dff95a1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:dff95a1:    (the "License"); you may not use this file except in compliance with
1:dff95a1:    the License.  You may obtain a copy of the License at
1:b223f72: 
1:b223f72:       http://www.apache.org/licenses/LICENSE-2.0
1:b223f72: 
1:b223f72:    Unless required by applicable law or agreed to in writing, software
1:b223f72:    distributed under the License is distributed on an "AS IS" BASIS,
1:b223f72:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b223f72:    See the License for the specific language governing permissions and
1:b223f72:    limitations under the License.
1:b223f72: 
1:b223f72:  */
1:b223f72: 
1:b223f72: package org.apache.derbyTesting.functionTests.tests.store;
1:b223f72: 
1:b223f72: import java.sql.Connection;
1:b223f72: import java.sql.ResultSet;
1:b223f72: import java.sql.SQLException;
1:b223f72: import java.sql.Statement;
1:b223f72: 
1:b223f72: import java.util.BitSet;
1:b223f72: import java.util.Enumeration;
1:b223f72: import java.util.HashMap;
1:e76d29e: import java.util.List;
1:b223f72: import java.util.Vector;
1:b223f72: 
1:b223f72: import org.apache.derby.iapi.error.PublicAPI;
1:b223f72: import org.apache.derby.iapi.error.StandardException;
1:b223f72: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
1:b223f72: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:b223f72: import org.apache.derby.iapi.store.access.DiskHashtable;
1:b223f72: import org.apache.derby.iapi.store.access.KeyHasher;
1:b223f72: import org.apache.derby.iapi.store.access.TransactionController;
1:b223f72: import org.apache.derby.iapi.types.DataValueDescriptor;
1:b223f72: import org.apache.derby.iapi.types.Orderable;
1:b223f72: import org.apache.derby.iapi.types.SQLInteger;
1:b223f72: import org.apache.derby.iapi.types.SQLLongint;
1:b223f72: import org.apache.derby.iapi.types.SQLVarchar;
1:b223f72: import org.apache.derby.tools.ij;
1:b223f72: import org.apache.derbyTesting.functionTests.util.TestUtil;
1:b223f72: 
1:b223f72: /**
1:b223f72:  * This program tests the org.apache.derby.iapi.store.access.DiskHashtable class.
1:b223f72:  * The unit test interface is not used because that is undocumented and very difficult to decipher.
1:b223f72:  * Furthermore it is difficult to diagnose problems when using the unit test interface.
1:b223f72:  *
1:b223f72:  * Created: Wed Feb 09 15:44:12 2005
1:b223f72:  *
1:b223f72:  * @version 1.0
1:b223f72:  */
1:b223f72: public class TestDiskHashtable 
1:b223f72: {
1:b223f72:     private TransactionController tc;
1:b223f72:     private int failed = 0;
1:b223f72:     
1:b223f72:     public static void main( String args[])
1:b223f72:     {
1:b223f72:         int failed = 1;
1:b223f72: 
1:b223f72: 		REPORT("Test DiskHashtable starting");
1:b223f72:         try
1:b223f72:         {
1:b223f72: 			// use the ij utility to read the property file and
1:b223f72: 			// make the initial connection.
1:b223f72: 			ij.getPropertyArg(args);
1:b223f72: 			Connection conn = ij.startJBMS();
1:b223f72:             Statement stmt = conn.createStatement();
1:b223f72:             stmt.execute("CREATE FUNCTION testDiskHashtable() returns INTEGER EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.store.TestDiskHashtable.runTests' LANGUAGE JAVA PARAMETER STYLE JAVA");
1:b223f72:             ResultSet rs = stmt.executeQuery( "values( testDiskHashtable())");
1:b223f72:             if( rs.next())
1:b223f72:                 failed = rs.getInt(1);
1:b223f72:             stmt.close();
1:b223f72:             conn.close();
1:b223f72:         }
1:b223f72:         catch( SQLException e)
1:b223f72:         {
1:b223f72: 			TestUtil.dumpSQLExceptions( e);
1:b223f72:             failed = 1;
1:b223f72:         }
1:b223f72:         catch( Throwable t)
1:b223f72:         {
1:b223f72: 			REPORT("FAIL -- unexpected exception:" + t.toString());
1:b223f72:             failed = 1;
1:b223f72: 		}
1:b223f72:         REPORT( (failed == 0) ? "OK" : "FAILED");
1:b223f72:         System.exit( (failed == 0) ? 0 : 1);
1:b223f72:     }
1:b223f72: 
1:b223f72:     private void REPORT_FAILURE(String msg)
1:b223f72:     {
1:b223f72:         failed = 1;
1:b223f72:         REPORT( msg);
1:b223f72:     }
1:b223f72:     
1:b223f72:     private static void REPORT(String msg)
1:b223f72:     {
1:b223f72:         System.out.println( msg);
1:b223f72:     }
1:b223f72:     
1:b223f72:     public static int runTests() throws SQLException
1:b223f72:     {
1:b223f72:         TestDiskHashtable tester = new TestDiskHashtable();
1:b223f72:         return tester.doIt();
1:b223f72:     }
1:b223f72: 
1:b223f72:     private TestDiskHashtable() throws SQLException
1:b223f72:     {
1:b223f72:         LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
1:b223f72:         if( lcc == null)
1:b223f72:             throw new SQLException( "Cannot get the LCC");
1:b223f72:         tc = lcc.getTransactionExecute();
1:b223f72:     }
1:b223f72: 
1:b223f72:     private int doIt() throws SQLException
1:b223f72:     {
1:b223f72: 		try {
1:b223f72: 
1:b223f72: 
1:b223f72:             REPORT( "Starting single key, keep duplicates test");
1:b223f72:             testOneVariant( tc, false, singleKeyTemplate, singleKeyCols, singleKeyRows);
1:b223f72:             REPORT( "Starting single key, remove duplicates test");
1:b223f72:             testOneVariant( tc, true, singleKeyTemplate, singleKeyCols, singleKeyRows);
1:b223f72:             REPORT( "Starting multiple key, keep duplicates test");
1:b223f72:             testOneVariant( tc, false, multiKeyTemplate, multiKeyCols, multiKeyRows);
1:b223f72:             REPORT( "Starting multiple key, remove duplicates test");
1:b223f72:             testOneVariant( tc, true, multiKeyTemplate, multiKeyCols, multiKeyRows);
1:b223f72: 
1:b223f72: 			tc.commit();
1:b223f72: 		}
1:b223f72: 		catch (StandardException se)
1:b223f72: 		{
1:b223f72:             throw PublicAPI.wrapStandardException( se);
1:b223f72:         }
1:b223f72:         return failed;
1:b223f72:     } // end of doIt
1:b223f72: 
1:b223f72:     private static final DataValueDescriptor[] singleKeyTemplate = { new SQLInteger(), new SQLVarchar()};
1:b223f72:     private static final int[] singleKeyCols = {0};
1:b223f72:     private static final DataValueDescriptor[][] singleKeyRows =
1:b223f72:     {
1:b223f72:         {new SQLInteger(1), new SQLVarchar("abcd")},
1:b223f72:         {new SQLInteger(2), new SQLVarchar("abcd")},
1:b223f72:         {new SQLInteger(3), new SQLVarchar("e")},
1:b223f72:         {new SQLInteger(1), new SQLVarchar("zz")}
1:b223f72:     };
1:b223f72: 
1:b223f72:     private static final DataValueDescriptor[] multiKeyTemplate = { new SQLLongint(), new SQLVarchar(), new SQLInteger()};
1:b223f72:     private static final int[] multiKeyCols = {1, 0};
1:b223f72:     private static final DataValueDescriptor[][] multiKeyRows =
1:b223f72:     {
1:b223f72:         {new SQLLongint(1), new SQLVarchar( "aa"), multiKeyTemplate[2].getNewNull()},
1:b223f72:         {new SQLLongint(2), new SQLVarchar( "aa"), new SQLInteger(1)},
1:b223f72:         {new SQLLongint(2), new SQLVarchar( "aa"), new SQLInteger(2)},
1:b223f72:         {new SQLLongint(2), new SQLVarchar( "b"), new SQLInteger(1)}
1:b223f72:     };
1:b223f72: 
1:b223f72:     private static final int LOTS_OF_ROWS_COUNT = 50000;
1:b223f72:     
1:b223f72:     private void testOneVariant( TransactionController tc,
1:b223f72:                                  boolean removeDups,
1:b223f72:                                  DataValueDescriptor[] template,
2:b223f72:                                  int[] keyCols,
1:b223f72:                                  DataValueDescriptor[][] rows)
1:b223f72:         throws StandardException
1:b223f72:     {
1:b61f876:         DiskHashtable dht = 
1:b61f876:             new DiskHashtable(
1:b61f876:                     tc, 
1:b61f876:                     template, 
1:b61f876:                     (int[]) null, // default collation
1:b61f876:                     keyCols, 
1:b61f876:                     removeDups, 
1:b61f876:                     false);
1:b61f876: 
1:b223f72:         boolean[] isDuplicate = new boolean[ rows.length];
1:b223f72:         boolean[] found = new boolean[ rows.length];
1:c393694:         HashMap<Object, Vector<DataValueDescriptor[]>> simpleHash =
1:c393694:             new HashMap<Object, Vector<DataValueDescriptor[]>>(rows.length);
1:b223f72: 
1:c393694:         testElements( removeDups, dht, 0, rows, isDuplicate, found);
1:b223f72: 
1:b223f72:         for( int i = 0; i < rows.length; i++)
1:b223f72:         {
1:b223f72:             Object key = KeyHasher.buildHashKey( rows[i], keyCols);
1:c393694:             Vector<DataValueDescriptor[]> al = simpleHash.get( key);
1:b223f72:             isDuplicate[i] = (al != null);
1:b223f72:             if( al == null)
1:b223f72:             {
1:c393694:                 al = new Vector<DataValueDescriptor[]>(4);
1:b223f72:                 simpleHash.put( key, al);
1:b223f72:             }
1:b223f72:             if( (!removeDups) || !isDuplicate[i])
1:b223f72:                 al.add( rows[i]);
1:b223f72:             
1:b223f72:             if( dht.put( key, rows[i]) != (removeDups ? (!isDuplicate[i]) : true))
1:b223f72:                 REPORT_FAILURE( "  put returned wrong value on row " + i);
1:b223f72: 
1:b223f72:             for( int j = 0; j <= i; j++)
1:b223f72:             {
1:b223f72:                 key = KeyHasher.buildHashKey( rows[j], keyCols);
1:b223f72:                 if( ! rowsEqual( dht.get( key), simpleHash.get( key)))
1:b223f72:                     REPORT_FAILURE( "  get returned wrong value on key " + j);
1:b223f72:             }
1:b223f72: 
1:c393694:             testElements( removeDups, dht, i+1, rows, isDuplicate, found);
1:b223f72:         }
1:b223f72:         // Remove them
1:b223f72:         for( int i = 0; i < rows.length; i++)
1:b223f72:         {
1:b223f72:             Object key = KeyHasher.buildHashKey( rows[i], keyCols);
1:b223f72:             if( ! rowsEqual( dht.remove( key), simpleHash.get( key)))
1:b223f72:                 REPORT_FAILURE( "  remove returned wrong value on key " + i);
1:b223f72:             simpleHash.remove( key);
1:b223f72:             if( dht.get( key) != null)
1:b223f72:                 REPORT_FAILURE( "  remove did not delete key " + i);
1:b223f72:         }
1:c393694:         testElements( removeDups, dht, 0, rows, isDuplicate, found);
1:b223f72: 
1:b223f72:         testLargeTable( dht, keyCols, rows[0]);
1:b223f72:         dht.close();
1:b223f72:     } // end of testOneVariant
1:b223f72: 
1:b223f72:     private void testLargeTable( DiskHashtable dht,
1:b223f72:                                  int[] keyCols,
1:b223f72:                                  DataValueDescriptor[] aRow)
1:b223f72:         throws StandardException
1:b223f72:     {
1:b223f72:         // Add a lot of elements
1:b223f72:         // If there are two or more key columns then we will vary the first two key columns, using an approximately
1:b223f72:         // square matrix of integer key values. Because the hash generator is commutative key (i,j) hashes into the
1:b223f72:         // same bucket as key (j,i), testing the case where different keys hash into the same bucket.
1:b223f72:         int key1Count = (keyCols.length > 1) ? ((int) Math.round( Math.sqrt( (double) LOTS_OF_ROWS_COUNT))) : 1;
1:b223f72:         int key0Count = (LOTS_OF_ROWS_COUNT + key1Count - 1)/key1Count;
1:b223f72: 
1:b223f72:         DataValueDescriptor[] row = new DataValueDescriptor[ aRow.length];
1:b223f72:         for( int i = 0; i < row.length; i++)
1:854dd10:             row[i] = aRow[i].cloneValue(false);
1:b223f72:         
1:b223f72:         for( int key0Idx = 0; key0Idx < key0Count; key0Idx++)
1:b223f72:         {
1:b223f72:             row[ keyCols[0]].setValue( key0Idx);
1:b223f72:             for( int key1Idx = 0; key1Idx < key1Count; key1Idx++)
1:b223f72:             {
1:b223f72:                 if( keyCols.length > 1)
1:b223f72:                     row[ keyCols[1]].setValue( key1Idx);
1:b223f72:                 Object key = KeyHasher.buildHashKey( row, keyCols);
1:b223f72:                 if( ! dht.put( key, row))
1:b223f72:                 {
1:b223f72:                     REPORT_FAILURE( "  put returned wrong value for key(" + key0Idx + "," + key1Idx + ")");
1:b223f72:                     key0Idx = key0Count;
1:b223f72:                     break;
1:b223f72:                 }
1:b223f72:             }
1:b223f72:         }
1:b223f72:         for( int key0Idx = 0; key0Idx < key0Count; key0Idx++)
1:b223f72:         {
1:b223f72:             row[ keyCols[0]].setValue( key0Idx);
1:b223f72:             for( int key1Idx = 0; key1Idx < key1Count; key1Idx++)
1:b223f72:             {
1:b223f72:                 if( keyCols.length > 1)
1:b223f72:                     row[ keyCols[1]].setValue( key1Idx);
1:b223f72:                 Object key = KeyHasher.buildHashKey( row, keyCols);
1:b223f72:                 if( ! rowsEqual( dht.get( key), row))
1:b223f72:                 {
1:b223f72:                     REPORT_FAILURE( "  large table get returned wrong value for key(" + key0Idx + "," + key1Idx + ")");
1:b223f72:                     key0Idx = key0Count;
1:b223f72:                     break;
1:b223f72:                 }
1:b223f72:             }
1:b223f72:         }
1:b223f72:         BitSet found = new BitSet(key0Count * key1Count);
1:b223f72:         Enumeration elements = dht.elements();
1:b223f72:         while( elements.hasMoreElements())
1:b223f72:         {
1:b223f72:             Object el = elements.nextElement();
1:b223f72:             if( ! (el instanceof DataValueDescriptor[]))
1:b223f72:             {
1:b223f72:                 REPORT_FAILURE( "  large table enumeration returned wrong element type");
1:b223f72:                 break;
1:b223f72:             }
1:b223f72:             DataValueDescriptor[] fetchedRow = (DataValueDescriptor[]) el;
1:b223f72:             
1:b223f72:             int i = fetchedRow[ keyCols[0]].getInt() * key1Count;
1:b223f72:             if( keyCols.length > 1)
1:b223f72:                 i += fetchedRow[ keyCols[1]].getInt();
1:b223f72:             if( i >= key0Count * key1Count)
1:b223f72:             {
1:b223f72:                 REPORT_FAILURE( "  large table enumeration returned invalid element");
1:b223f72:                 break;
1:b223f72:             }
1:b223f72:                 
1:b223f72:             if( found.get(i))
1:b223f72:             {
1:b223f72:                 REPORT_FAILURE( "  large table enumeration returned same element twice");
1:b223f72:                 break;
1:b223f72:             }
1:b223f72:             found.set(i);
1:b223f72:         }
1:b223f72:         for( int i = key0Count * key1Count - 1; i >= 0; i--)
1:b223f72:         {
1:b223f72:             if( !found.get(i))
1:b223f72:             {
1:b223f72:                 REPORT_FAILURE( "  large table enumeration missed at least one element");
1:b223f72:                 break;
1:b223f72:             }
1:b223f72:         }
1:b223f72:     } // end of testLargeTable
1:b223f72: 
1:b223f72:     private void testElements( boolean removeDups,
1:b223f72:                                DiskHashtable dht,
1:b223f72:                                int rowCount,
1:b223f72:                                DataValueDescriptor[][] rows,
1:b223f72:                                boolean[] isDuplicate,
1:b223f72:                                boolean[] found)
1:b223f72:         throws StandardException
1:b223f72:     {
1:b223f72:         for( int i = 0; i < rowCount; i++)
1:b223f72:             found[i] = false;
1:b223f72:         
1:b223f72:         for( Enumeration e = dht.elements(); e.hasMoreElements();)
1:b223f72:         {
1:b223f72:             Object el = e.nextElement();
1:b223f72:             if( el == null)
1:b223f72:             {
1:b223f72:                 REPORT_FAILURE( "  table enumeration returned a null element");
1:b223f72:                 return;
1:b223f72:             }
1:b223f72:             if( el instanceof DataValueDescriptor[])
1:b223f72:                 checkElement( (DataValueDescriptor[]) el, rowCount, rows, found);
1:e76d29e:             else if (el instanceof List)
1:b223f72:             {
1:e76d29e:                 List v = (List) el;
1:b223f72:                 for( int i = 0; i < v.size(); i++)
1:b223f72:                     checkElement( (DataValueDescriptor[]) v.get(i), rowCount, rows, found);
1:b223f72:             }
1:b223f72:             else if( el == null)
1:b223f72:             {
1:b223f72:                 REPORT_FAILURE( "  table enumeration returned an incorrect element type");
1:b223f72:                 return;
1:b223f72:             }
1:b223f72:         }
1:b223f72:         for( int i = 0; i < rowCount; i++)
1:b223f72:         {
1:b223f72:             if( (removeDups && isDuplicate[i]))
1:b223f72:             {
1:b223f72:                 if( found[i])
1:b223f72:                 {
1:b223f72:                     REPORT_FAILURE( "  table enumeration did not remove duplicates");
1:b223f72:                     return;
1:b223f72:                 }
1:b223f72:             }
1:b223f72:             else if( ! found[i])
1:b223f72:             {
1:b223f72:                 REPORT_FAILURE( "  table enumeration missed at least one element");
1:b223f72:                 return;
1:b223f72:             }
1:b223f72:         }
1:b223f72:     } // end of testElements
1:b223f72: 
1:b223f72:     private void checkElement( DataValueDescriptor[] fetchedRow,
1:b223f72:                                int rowCount,
1:b223f72:                                DataValueDescriptor[][] rows,
1:b223f72:                                boolean[] found)
1:b223f72:         throws StandardException
1:b223f72:     {
1:b223f72:         for( int i = 0; i < rowCount; i++)
1:b223f72:         {
1:b223f72:             if( rowsEqual( fetchedRow, rows[i]))
1:b223f72:             {
1:b223f72:                 if( found[i])
1:b223f72:                 {
1:b223f72:                     REPORT_FAILURE( "  table enumeration returned the same element twice");
1:b223f72:                     return;
1:b223f72:                 }
1:b223f72:                 found[i] = true;
1:b223f72:                 return;
1:b223f72:             }
1:b223f72:         }
1:b223f72:         REPORT_FAILURE( "  table enumeration returned an incorrect element");
1:b223f72:     } // end of checkElement
1:b223f72: 
1:b223f72:     private boolean rowsEqual( Object r1, Object r2)
1:b223f72:         throws StandardException
1:b223f72:     {
1:b223f72:         if( r1 == null)
1:b223f72:             return r2 == null;
1:b223f72: 
1:b223f72:         if( r1 instanceof DataValueDescriptor[])
1:b223f72:         {
1:b223f72:             DataValueDescriptor[] row1 = (DataValueDescriptor[]) r1;
1:b223f72:             DataValueDescriptor[] row2;
1:b223f72:             
1:e76d29e:             if (r2 instanceof List)
1:b223f72:             {
1:e76d29e:                 List v2 = (List) r2;
1:b223f72:                 if( v2.size() != 1)
1:b223f72:                     return false;
1:e76d29e:                 row2 = (DataValueDescriptor[]) v2.get(0);
1:b223f72:             }
1:b223f72:             else if( r2 instanceof DataValueDescriptor[])
1:b223f72:                 row2 = (DataValueDescriptor[]) r2;
1:b223f72:             else
1:b223f72:                 return false;
1:b223f72:             
1:b223f72:             if( row1.length != row2.length)
1:b223f72:                 return false;
1:b223f72:             for( int i = 0; i < row1.length; i++)
1:b223f72:             {
1:b223f72:                 if( ! row1[i].compare( Orderable.ORDER_OP_EQUALS, row2[i], true, true))
1:b223f72:                     return false;
1:b223f72:             }
1:b223f72:             return true;
1:b223f72:         }
1:e76d29e:         if (r1 instanceof List)
1:b223f72:         {
1:e76d29e:             if (!(r2 instanceof List))
1:b223f72:                 return false;
1:e76d29e:             List v1 = (List) r1;
1:e76d29e:             List v2 = (List) r2;
1:b223f72:             if( v1.size() != v2.size())
1:b223f72:                 return false;
1:b223f72:             for( int i = v1.size() - 1; i >= 0; i--)
1:b223f72:             {
1:e76d29e:                 if (!rowsEqual(v1.get(i), v2.get(i)))
1:b223f72:                     return false;
1:b223f72:             }
1:b223f72:             return true;
1:b223f72:         }
1:b223f72:         // What is it then?
1:b223f72:         return r1.equals( r2);
1:b223f72:     } // end of rowsEqual
1:b223f72: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e76d29e
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:             else if (el instanceof List)
1:                 List v = (List) el;
/////////////////////////////////////////////////////////////////////////
1:             if (r2 instanceof List)
1:                 List v2 = (List) r2;
1:                 row2 = (DataValueDescriptor[]) v2.get(0);
/////////////////////////////////////////////////////////////////////////
1:         if (r1 instanceof List)
1:             if (!(r2 instanceof List))
1:             List v1 = (List) r1;
1:             List v2 = (List) r2;
1:                 if (!rowsEqual(v1.get(i), v2.get(i)))
commit:c393694
/////////////////////////////////////////////////////////////////////////
1:         HashMap<Object, Vector<DataValueDescriptor[]>> simpleHash =
1:             new HashMap<Object, Vector<DataValueDescriptor[]>>(rows.length);
1:         testElements( removeDups, dht, 0, rows, isDuplicate, found);
1:             Vector<DataValueDescriptor[]> al = simpleHash.get( key);
1:                 al = new Vector<DataValueDescriptor[]>(4);
/////////////////////////////////////////////////////////////////////////
1:             testElements( removeDups, dht, i+1, rows, isDuplicate, found);
/////////////////////////////////////////////////////////////////////////
1:         testElements( removeDups, dht, 0, rows, isDuplicate, found);
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:854dd10
/////////////////////////////////////////////////////////////////////////
1:             row[i] = aRow[i].cloneValue(false);
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b61f876
/////////////////////////////////////////////////////////////////////////
1:         DiskHashtable dht = 
1:             new DiskHashtable(
1:                     tc, 
1:                     template, 
1:                     (int[]) null, // default collation
1:                     keyCols, 
1:                     removeDups, 
1:                     false);
1: 
commit:b223f72
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.store.TestDiskHashtable
1: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.store;
1: 
1: import java.sql.Connection;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import java.util.BitSet;
1: import java.util.Enumeration;
1: import java.util.HashMap;
1: import java.util.Vector;
1: 
1: import org.apache.derby.iapi.error.PublicAPI;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.store.access.DiskHashtable;
1: import org.apache.derby.iapi.store.access.KeyHasher;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.Orderable;
1: import org.apache.derby.iapi.types.SQLInteger;
1: import org.apache.derby.iapi.types.SQLLongint;
1: import org.apache.derby.iapi.types.SQLVarchar;
1: import org.apache.derby.tools.ij;
1: import org.apache.derbyTesting.functionTests.util.TestUtil;
1: 
1: /**
1:  * This program tests the org.apache.derby.iapi.store.access.DiskHashtable class.
1:  * The unit test interface is not used because that is undocumented and very difficult to decipher.
1:  * Furthermore it is difficult to diagnose problems when using the unit test interface.
1:  *
1:  * Created: Wed Feb 09 15:44:12 2005
1:  *
0:  * @author <a href="mailto:klebanof@us.ibm.com">Jack Klebanoff</a>
1:  * @version 1.0
1:  */
1: public class TestDiskHashtable 
1: {
1:     private TransactionController tc;
1:     private int failed = 0;
1:     
1:     public static void main( String args[])
1:     {
1:         int failed = 1;
1: 
1: 		REPORT("Test DiskHashtable starting");
1:         try
1:         {
1: 			// use the ij utility to read the property file and
1: 			// make the initial connection.
1: 			ij.getPropertyArg(args);
1: 			Connection conn = ij.startJBMS();
1:             Statement stmt = conn.createStatement();
1:             stmt.execute("CREATE FUNCTION testDiskHashtable() returns INTEGER EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.store.TestDiskHashtable.runTests' LANGUAGE JAVA PARAMETER STYLE JAVA");
1:             ResultSet rs = stmt.executeQuery( "values( testDiskHashtable())");
1:             if( rs.next())
1:                 failed = rs.getInt(1);
1:             stmt.close();
1:             conn.close();
1:         }
1:         catch( SQLException e)
1:         {
1: 			TestUtil.dumpSQLExceptions( e);
1:             failed = 1;
1:         }
1:         catch( Throwable t)
1:         {
1: 			REPORT("FAIL -- unexpected exception:" + t.toString());
1:             failed = 1;
1: 		}
1:         REPORT( (failed == 0) ? "OK" : "FAILED");
1:         System.exit( (failed == 0) ? 0 : 1);
1:     }
1: 
1:     private void REPORT_FAILURE(String msg)
1:     {
1:         failed = 1;
1:         REPORT( msg);
1:     }
1:     
1:     private static void REPORT(String msg)
1:     {
1:         System.out.println( msg);
1:     }
1:     
1:     public static int runTests() throws SQLException
1:     {
1:         TestDiskHashtable tester = new TestDiskHashtable();
1:         return tester.doIt();
1:     }
1: 
1:     private TestDiskHashtable() throws SQLException
1:     {
1:         LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
1:         if( lcc == null)
1:             throw new SQLException( "Cannot get the LCC");
1:         tc = lcc.getTransactionExecute();
1:     }
1: 
1:     private int doIt() throws SQLException
1:     {
1: 		try {
1: 
1: 
1:             REPORT( "Starting single key, keep duplicates test");
1:             testOneVariant( tc, false, singleKeyTemplate, singleKeyCols, singleKeyRows);
1:             REPORT( "Starting single key, remove duplicates test");
1:             testOneVariant( tc, true, singleKeyTemplate, singleKeyCols, singleKeyRows);
1:             REPORT( "Starting multiple key, keep duplicates test");
1:             testOneVariant( tc, false, multiKeyTemplate, multiKeyCols, multiKeyRows);
1:             REPORT( "Starting multiple key, remove duplicates test");
1:             testOneVariant( tc, true, multiKeyTemplate, multiKeyCols, multiKeyRows);
1: 
1: 			tc.commit();
1: 		}
1: 		catch (StandardException se)
1: 		{
1:             throw PublicAPI.wrapStandardException( se);
1:         }
1:         return failed;
1:     } // end of doIt
1: 
1:     private static final DataValueDescriptor[] singleKeyTemplate = { new SQLInteger(), new SQLVarchar()};
1:     private static final int[] singleKeyCols = {0};
1:     private static final DataValueDescriptor[][] singleKeyRows =
1:     {
1:         {new SQLInteger(1), new SQLVarchar("abcd")},
1:         {new SQLInteger(2), new SQLVarchar("abcd")},
1:         {new SQLInteger(3), new SQLVarchar("e")},
1:         {new SQLInteger(1), new SQLVarchar("zz")}
1:     };
1: 
1:     private static final DataValueDescriptor[] multiKeyTemplate = { new SQLLongint(), new SQLVarchar(), new SQLInteger()};
1:     private static final int[] multiKeyCols = {1, 0};
1:     private static final DataValueDescriptor[][] multiKeyRows =
1:     {
1:         {new SQLLongint(1), new SQLVarchar( "aa"), multiKeyTemplate[2].getNewNull()},
1:         {new SQLLongint(2), new SQLVarchar( "aa"), new SQLInteger(1)},
1:         {new SQLLongint(2), new SQLVarchar( "aa"), new SQLInteger(2)},
1:         {new SQLLongint(2), new SQLVarchar( "b"), new SQLInteger(1)}
1:     };
1: 
1:     private static final int LOTS_OF_ROWS_COUNT = 50000;
1:     
1:     private void testOneVariant( TransactionController tc,
1:                                  boolean removeDups,
1:                                  DataValueDescriptor[] template,
1:                                  int[] keyCols,
1:                                  DataValueDescriptor[][] rows)
1:         throws StandardException
1:     {
0:         DiskHashtable dht = new DiskHashtable(tc, template, keyCols, removeDups, false);
1:         boolean[] isDuplicate = new boolean[ rows.length];
1:         boolean[] found = new boolean[ rows.length];
0:         HashMap simpleHash = new HashMap( rows.length);
1: 
0:         testElements( removeDups, dht, keyCols, 0, rows, simpleHash, isDuplicate, found);
1: 
1:         for( int i = 0; i < rows.length; i++)
1:         {
1:             Object key = KeyHasher.buildHashKey( rows[i], keyCols);
0:             Vector al = (Vector) simpleHash.get( key);
1:             isDuplicate[i] = (al != null);
1:             if( al == null)
1:             {
0:                 al = new Vector(4);
1:                 simpleHash.put( key, al);
1:             }
1:             if( (!removeDups) || !isDuplicate[i])
1:                 al.add( rows[i]);
1:             
1:             if( dht.put( key, rows[i]) != (removeDups ? (!isDuplicate[i]) : true))
1:                 REPORT_FAILURE( "  put returned wrong value on row " + i);
1: 
1:             for( int j = 0; j <= i; j++)
1:             {
1:                 key = KeyHasher.buildHashKey( rows[j], keyCols);
1:                 if( ! rowsEqual( dht.get( key), simpleHash.get( key)))
1:                     REPORT_FAILURE( "  get returned wrong value on key " + j);
1:             }
1: 
0:             testElements( removeDups, dht, keyCols, i+1, rows, simpleHash, isDuplicate, found);
1:         }
1:         // Remove them
1:         for( int i = 0; i < rows.length; i++)
1:         {
1:             Object key = KeyHasher.buildHashKey( rows[i], keyCols);
1:             if( ! rowsEqual( dht.remove( key), simpleHash.get( key)))
1:                 REPORT_FAILURE( "  remove returned wrong value on key " + i);
1:             simpleHash.remove( key);
1:             if( dht.get( key) != null)
1:                 REPORT_FAILURE( "  remove did not delete key " + i);
1:         }
0:         testElements( removeDups, dht, keyCols, 0, rows, simpleHash, isDuplicate, found);
1: 
1:         testLargeTable( dht, keyCols, rows[0]);
1:         dht.close();
1:     } // end of testOneVariant
1: 
1:     private void testLargeTable( DiskHashtable dht,
1:                                  int[] keyCols,
1:                                  DataValueDescriptor[] aRow)
1:         throws StandardException
1:     {
1:         // Add a lot of elements
1:         // If there are two or more key columns then we will vary the first two key columns, using an approximately
1:         // square matrix of integer key values. Because the hash generator is commutative key (i,j) hashes into the
1:         // same bucket as key (j,i), testing the case where different keys hash into the same bucket.
1:         int key1Count = (keyCols.length > 1) ? ((int) Math.round( Math.sqrt( (double) LOTS_OF_ROWS_COUNT))) : 1;
1:         int key0Count = (LOTS_OF_ROWS_COUNT + key1Count - 1)/key1Count;
1: 
1:         DataValueDescriptor[] row = new DataValueDescriptor[ aRow.length];
1:         for( int i = 0; i < row.length; i++)
0:             row[i] = aRow[i].getClone();
1:         
1:         for( int key0Idx = 0; key0Idx < key0Count; key0Idx++)
1:         {
1:             row[ keyCols[0]].setValue( key0Idx);
1:             for( int key1Idx = 0; key1Idx < key1Count; key1Idx++)
1:             {
1:                 if( keyCols.length > 1)
1:                     row[ keyCols[1]].setValue( key1Idx);
1:                 Object key = KeyHasher.buildHashKey( row, keyCols);
1:                 if( ! dht.put( key, row))
1:                 {
1:                     REPORT_FAILURE( "  put returned wrong value for key(" + key0Idx + "," + key1Idx + ")");
1:                     key0Idx = key0Count;
1:                     break;
1:                 }
1:             }
1:         }
1:         for( int key0Idx = 0; key0Idx < key0Count; key0Idx++)
1:         {
1:             row[ keyCols[0]].setValue( key0Idx);
1:             for( int key1Idx = 0; key1Idx < key1Count; key1Idx++)
1:             {
1:                 if( keyCols.length > 1)
1:                     row[ keyCols[1]].setValue( key1Idx);
1:                 Object key = KeyHasher.buildHashKey( row, keyCols);
1:                 if( ! rowsEqual( dht.get( key), row))
1:                 {
1:                     REPORT_FAILURE( "  large table get returned wrong value for key(" + key0Idx + "," + key1Idx + ")");
1:                     key0Idx = key0Count;
1:                     break;
1:                 }
1:             }
1:         }
1:         BitSet found = new BitSet(key0Count * key1Count);
1:         Enumeration elements = dht.elements();
1:         while( elements.hasMoreElements())
1:         {
1:             Object el = elements.nextElement();
1:             if( ! (el instanceof DataValueDescriptor[]))
1:             {
1:                 REPORT_FAILURE( "  large table enumeration returned wrong element type");
1:                 break;
1:             }
1:             DataValueDescriptor[] fetchedRow = (DataValueDescriptor[]) el;
1:             
1:             int i = fetchedRow[ keyCols[0]].getInt() * key1Count;
1:             if( keyCols.length > 1)
1:                 i += fetchedRow[ keyCols[1]].getInt();
1:             if( i >= key0Count * key1Count)
1:             {
1:                 REPORT_FAILURE( "  large table enumeration returned invalid element");
1:                 break;
1:             }
1:                 
1:             if( found.get(i))
1:             {
1:                 REPORT_FAILURE( "  large table enumeration returned same element twice");
1:                 break;
1:             }
1:             found.set(i);
1:         }
1:         for( int i = key0Count * key1Count - 1; i >= 0; i--)
1:         {
1:             if( !found.get(i))
1:             {
1:                 REPORT_FAILURE( "  large table enumeration missed at least one element");
1:                 break;
1:             }
1:         }
1:     } // end of testLargeTable
1: 
1:     private void testElements( boolean removeDups,
1:                                DiskHashtable dht,
1:                                int[] keyCols,
1:                                int rowCount,
1:                                DataValueDescriptor[][] rows,
0:                                HashMap simpleHash,
1:                                boolean[] isDuplicate,
1:                                boolean[] found)
1:         throws StandardException
1:     {
1:         for( int i = 0; i < rowCount; i++)
1:             found[i] = false;
1:         
1:         for( Enumeration e = dht.elements(); e.hasMoreElements();)
1:         {
1:             Object el = e.nextElement();
1:             if( el == null)
1:             {
1:                 REPORT_FAILURE( "  table enumeration returned a null element");
1:                 return;
1:             }
1:             if( el instanceof DataValueDescriptor[])
1:                 checkElement( (DataValueDescriptor[]) el, rowCount, rows, found);
0:             else if( el instanceof Vector)
1:             {
0:                 Vector v = (Vector) el;
1:                 for( int i = 0; i < v.size(); i++)
1:                     checkElement( (DataValueDescriptor[]) v.get(i), rowCount, rows, found);
1:             }
1:             else if( el == null)
1:             {
1:                 REPORT_FAILURE( "  table enumeration returned an incorrect element type");
1:                 return;
1:             }
1:         }
1:         for( int i = 0; i < rowCount; i++)
1:         {
1:             if( (removeDups && isDuplicate[i]))
1:             {
1:                 if( found[i])
1:                 {
1:                     REPORT_FAILURE( "  table enumeration did not remove duplicates");
1:                     return;
1:                 }
1:             }
1:             else if( ! found[i])
1:             {
1:                 REPORT_FAILURE( "  table enumeration missed at least one element");
1:                 return;
1:             }
1:         }
1:     } // end of testElements
1: 
1:     private void checkElement( DataValueDescriptor[] fetchedRow,
1:                                int rowCount,
1:                                DataValueDescriptor[][] rows,
1:                                boolean[] found)
1:         throws StandardException
1:     {
1:         for( int i = 0; i < rowCount; i++)
1:         {
1:             if( rowsEqual( fetchedRow, rows[i]))
1:             {
1:                 if( found[i])
1:                 {
1:                     REPORT_FAILURE( "  table enumeration returned the same element twice");
1:                     return;
1:                 }
1:                 found[i] = true;
1:                 return;
1:             }
1:         }
1:         REPORT_FAILURE( "  table enumeration returned an incorrect element");
1:     } // end of checkElement
1: 
1:     private boolean rowsEqual( Object r1, Object r2)
1:         throws StandardException
1:     {
1:         if( r1 == null)
1:             return r2 == null;
1: 
1:         if( r1 instanceof DataValueDescriptor[])
1:         {
1:             DataValueDescriptor[] row1 = (DataValueDescriptor[]) r1;
1:             DataValueDescriptor[] row2;
1:             
0:             if( r2 instanceof Vector)
1:             {
0:                 Vector v2 = (Vector) r2;
1:                 if( v2.size() != 1)
1:                     return false;
0:                 row2 = (DataValueDescriptor[]) v2.elementAt(0);
1:             }
1:             else if( r2 instanceof DataValueDescriptor[])
1:                 row2 = (DataValueDescriptor[]) r2;
1:             else
1:                 return false;
1:             
1:             if( row1.length != row2.length)
1:                 return false;
1:             for( int i = 0; i < row1.length; i++)
1:             {
1:                 if( ! row1[i].compare( Orderable.ORDER_OP_EQUALS, row2[i], true, true))
1:                     return false;
1:             }
1:             return true;
1:         }
0:         if( r1 instanceof Vector)
1:         {
0:             if( !(r2 instanceof Vector))
1:                 return false;
0:             Vector v1 = (Vector) r1;
0:             Vector v2 = (Vector) r2;
1:             if( v1.size() != v2.size())
1:                 return false;
1:             for( int i = v1.size() - 1; i >= 0; i--)
1:             {
0:                 if( ! rowsEqual( v1.elementAt( i), v2.elementAt(i)))
1:                     return false;
1:             }
1:             return true;
1:         }
1:         // What is it then?
1:         return r1.equals( r2);
1:     } // end of rowsEqual
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:dff95a1
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Derby - Class org.apache.derbyTesting.functionTests.tests.store.TestDiskHashtable
0: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0: 
0:  */
0: 
0: package org.apache.derbyTesting.functionTests.tests.store;
0: 
0: import java.sql.Connection;
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import java.sql.Statement;
0: 
0: import java.util.BitSet;
0: import java.util.Enumeration;
0: import java.util.HashMap;
0: import java.util.Vector;
0: 
0: import org.apache.derby.iapi.error.PublicAPI;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.store.access.DiskHashtable;
0: import org.apache.derby.iapi.store.access.KeyHasher;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.Orderable;
0: import org.apache.derby.iapi.types.SQLInteger;
0: import org.apache.derby.iapi.types.SQLLongint;
0: import org.apache.derby.iapi.types.SQLVarchar;
0: import org.apache.derby.tools.ij;
0: import org.apache.derbyTesting.functionTests.util.TestUtil;
0: 
0: /**
0:  * This program tests the org.apache.derby.iapi.store.access.DiskHashtable class.
0:  * The unit test interface is not used because that is undocumented and very difficult to decipher.
0:  * Furthermore it is difficult to diagnose problems when using the unit test interface.
0:  *
0:  * Created: Wed Feb 09 15:44:12 2005
0:  *
0:  * @author <a href="mailto:klebanof@us.ibm.com">Jack Klebanoff</a>
0:  * @version 1.0
0:  */
0: public class TestDiskHashtable 
0: {
0:     private TransactionController tc;
0:     private int failed = 0;
0:     
0:     public static void main( String args[])
0:     {
0:         int failed = 1;
0: 
0: 		REPORT("Test DiskHashtable starting");
0:         try
0:         {
0: 			// use the ij utility to read the property file and
0: 			// make the initial connection.
0: 			ij.getPropertyArg(args);
0: 			Connection conn = ij.startJBMS();
0:             Statement stmt = conn.createStatement();
0:             stmt.execute("CREATE FUNCTION testDiskHashtable() returns INTEGER EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.store.TestDiskHashtable.runTests' LANGUAGE JAVA PARAMETER STYLE JAVA");
0:             ResultSet rs = stmt.executeQuery( "values( testDiskHashtable())");
0:             if( rs.next())
0:                 failed = rs.getInt(1);
0:             stmt.close();
0:             conn.close();
0:         }
0:         catch( SQLException e)
0:         {
0: 			TestUtil.dumpSQLExceptions( e);
0:             failed = 1;
0:         }
0:         catch( Throwable t)
0:         {
0: 			REPORT("FAIL -- unexpected exception:" + t.toString());
0:             failed = 1;
0: 		}
0:         REPORT( (failed == 0) ? "OK" : "FAILED");
0:         System.exit( (failed == 0) ? 0 : 1);
0:     }
0: 
0:     private void REPORT_FAILURE(String msg)
0:     {
0:         failed = 1;
0:         REPORT( msg);
0:     }
0:     
0:     private static void REPORT(String msg)
0:     {
0:         System.out.println( msg);
0:     }
0:     
0:     public static int runTests() throws SQLException
0:     {
0:         TestDiskHashtable tester = new TestDiskHashtable();
0:         return tester.doIt();
0:     }
0: 
0:     private TestDiskHashtable() throws SQLException
0:     {
0:         LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
0:         if( lcc == null)
0:             throw new SQLException( "Cannot get the LCC");
0:         tc = lcc.getTransactionExecute();
0:     }
0: 
0:     private int doIt() throws SQLException
0:     {
0: 		try {
0: 
0: 
0:             REPORT( "Starting single key, keep duplicates test");
0:             testOneVariant( tc, false, singleKeyTemplate, singleKeyCols, singleKeyRows);
0:             REPORT( "Starting single key, remove duplicates test");
0:             testOneVariant( tc, true, singleKeyTemplate, singleKeyCols, singleKeyRows);
0:             REPORT( "Starting multiple key, keep duplicates test");
0:             testOneVariant( tc, false, multiKeyTemplate, multiKeyCols, multiKeyRows);
0:             REPORT( "Starting multiple key, remove duplicates test");
0:             testOneVariant( tc, true, multiKeyTemplate, multiKeyCols, multiKeyRows);
0: 
0: 			tc.commit();
0: 		}
0: 		catch (StandardException se)
0: 		{
0:             throw PublicAPI.wrapStandardException( se);
0:         }
0:         return failed;
0:     } // end of doIt
0: 
0:     private static final DataValueDescriptor[] singleKeyTemplate = { new SQLInteger(), new SQLVarchar()};
0:     private static final int[] singleKeyCols = {0};
0:     private static final DataValueDescriptor[][] singleKeyRows =
0:     {
0:         {new SQLInteger(1), new SQLVarchar("abcd")},
0:         {new SQLInteger(2), new SQLVarchar("abcd")},
0:         {new SQLInteger(3), new SQLVarchar("e")},
0:         {new SQLInteger(1), new SQLVarchar("zz")}
0:     };
0: 
0:     private static final DataValueDescriptor[] multiKeyTemplate = { new SQLLongint(), new SQLVarchar(), new SQLInteger()};
0:     private static final int[] multiKeyCols = {1, 0};
0:     private static final DataValueDescriptor[][] multiKeyRows =
0:     {
0:         {new SQLLongint(1), new SQLVarchar( "aa"), multiKeyTemplate[2].getNewNull()},
0:         {new SQLLongint(2), new SQLVarchar( "aa"), new SQLInteger(1)},
0:         {new SQLLongint(2), new SQLVarchar( "aa"), new SQLInteger(2)},
0:         {new SQLLongint(2), new SQLVarchar( "b"), new SQLInteger(1)}
0:     };
0: 
0:     private static final int LOTS_OF_ROWS_COUNT = 50000;
0:     
0:     private void testOneVariant( TransactionController tc,
0:                                  boolean removeDups,
0:                                  DataValueDescriptor[] template,
0:                                  int[] keyCols,
0:                                  DataValueDescriptor[][] rows)
0:         throws StandardException
0:     {
0:         DiskHashtable dht = new DiskHashtable(tc, template, keyCols, removeDups, false);
0:         boolean[] isDuplicate = new boolean[ rows.length];
0:         boolean[] found = new boolean[ rows.length];
0:         HashMap simpleHash = new HashMap( rows.length);
0: 
0:         testElements( removeDups, dht, keyCols, 0, rows, simpleHash, isDuplicate, found);
0: 
0:         for( int i = 0; i < rows.length; i++)
0:         {
0:             Object key = KeyHasher.buildHashKey( rows[i], keyCols);
0:             Vector al = (Vector) simpleHash.get( key);
0:             isDuplicate[i] = (al != null);
0:             if( al == null)
0:             {
0:                 al = new Vector(4);
0:                 simpleHash.put( key, al);
0:             }
0:             if( (!removeDups) || !isDuplicate[i])
0:                 al.add( rows[i]);
0:             
0:             if( dht.put( key, rows[i]) != (removeDups ? (!isDuplicate[i]) : true))
0:                 REPORT_FAILURE( "  put returned wrong value on row " + i);
0: 
0:             for( int j = 0; j <= i; j++)
0:             {
0:                 key = KeyHasher.buildHashKey( rows[j], keyCols);
0:                 if( ! rowsEqual( dht.get( key), simpleHash.get( key)))
0:                     REPORT_FAILURE( "  get returned wrong value on key " + j);
0:             }
0: 
0:             testElements( removeDups, dht, keyCols, i+1, rows, simpleHash, isDuplicate, found);
0:         }
0:         // Remove them
0:         for( int i = 0; i < rows.length; i++)
0:         {
0:             Object key = KeyHasher.buildHashKey( rows[i], keyCols);
0:             if( ! rowsEqual( dht.remove( key), simpleHash.get( key)))
0:                 REPORT_FAILURE( "  remove returned wrong value on key " + i);
0:             simpleHash.remove( key);
0:             if( dht.get( key) != null)
0:                 REPORT_FAILURE( "  remove did not delete key " + i);
0:         }
0:         testElements( removeDups, dht, keyCols, 0, rows, simpleHash, isDuplicate, found);
0: 
0:         testLargeTable( dht, keyCols, rows[0]);
0:         dht.close();
0:     } // end of testOneVariant
0: 
0:     private void testLargeTable( DiskHashtable dht,
0:                                  int[] keyCols,
0:                                  DataValueDescriptor[] aRow)
0:         throws StandardException
0:     {
0:         // Add a lot of elements
0:         // If there are two or more key columns then we will vary the first two key columns, using an approximately
0:         // square matrix of integer key values. Because the hash generator is commutative key (i,j) hashes into the
0:         // same bucket as key (j,i), testing the case where different keys hash into the same bucket.
0:         int key1Count = (keyCols.length > 1) ? ((int) Math.round( Math.sqrt( (double) LOTS_OF_ROWS_COUNT))) : 1;
0:         int key0Count = (LOTS_OF_ROWS_COUNT + key1Count - 1)/key1Count;
0: 
0:         DataValueDescriptor[] row = new DataValueDescriptor[ aRow.length];
0:         for( int i = 0; i < row.length; i++)
0:             row[i] = aRow[i].getClone();
0:         
0:         for( int key0Idx = 0; key0Idx < key0Count; key0Idx++)
0:         {
0:             row[ keyCols[0]].setValue( key0Idx);
0:             for( int key1Idx = 0; key1Idx < key1Count; key1Idx++)
0:             {
0:                 if( keyCols.length > 1)
0:                     row[ keyCols[1]].setValue( key1Idx);
0:                 Object key = KeyHasher.buildHashKey( row, keyCols);
0:                 if( ! dht.put( key, row))
0:                 {
0:                     REPORT_FAILURE( "  put returned wrong value for key(" + key0Idx + "," + key1Idx + ")");
0:                     key0Idx = key0Count;
0:                     break;
0:                 }
0:             }
0:         }
0:         for( int key0Idx = 0; key0Idx < key0Count; key0Idx++)
0:         {
0:             row[ keyCols[0]].setValue( key0Idx);
0:             for( int key1Idx = 0; key1Idx < key1Count; key1Idx++)
0:             {
0:                 if( keyCols.length > 1)
0:                     row[ keyCols[1]].setValue( key1Idx);
0:                 Object key = KeyHasher.buildHashKey( row, keyCols);
0:                 if( ! rowsEqual( dht.get( key), row))
0:                 {
0:                     REPORT_FAILURE( "  large table get returned wrong value for key(" + key0Idx + "," + key1Idx + ")");
0:                     key0Idx = key0Count;
0:                     break;
0:                 }
0:             }
0:         }
0:         BitSet found = new BitSet(key0Count * key1Count);
0:         Enumeration elements = dht.elements();
0:         while( elements.hasMoreElements())
0:         {
0:             Object el = elements.nextElement();
0:             if( ! (el instanceof DataValueDescriptor[]))
0:             {
0:                 REPORT_FAILURE( "  large table enumeration returned wrong element type");
0:                 break;
0:             }
0:             DataValueDescriptor[] fetchedRow = (DataValueDescriptor[]) el;
0:             
0:             int i = fetchedRow[ keyCols[0]].getInt() * key1Count;
0:             if( keyCols.length > 1)
0:                 i += fetchedRow[ keyCols[1]].getInt();
0:             if( i >= key0Count * key1Count)
0:             {
0:                 REPORT_FAILURE( "  large table enumeration returned invalid element");
0:                 break;
0:             }
0:                 
0:             if( found.get(i))
0:             {
0:                 REPORT_FAILURE( "  large table enumeration returned same element twice");
0:                 break;
0:             }
0:             found.set(i);
0:         }
0:         for( int i = key0Count * key1Count - 1; i >= 0; i--)
0:         {
0:             if( !found.get(i))
0:             {
0:                 REPORT_FAILURE( "  large table enumeration missed at least one element");
0:                 break;
0:             }
0:         }
0:     } // end of testLargeTable
0: 
0:     private void testElements( boolean removeDups,
0:                                DiskHashtable dht,
0:                                int[] keyCols,
0:                                int rowCount,
0:                                DataValueDescriptor[][] rows,
0:                                HashMap simpleHash,
0:                                boolean[] isDuplicate,
0:                                boolean[] found)
0:         throws StandardException
0:     {
0:         for( int i = 0; i < rowCount; i++)
0:             found[i] = false;
0:         
0:         for( Enumeration e = dht.elements(); e.hasMoreElements();)
0:         {
0:             Object el = e.nextElement();
0:             if( el == null)
0:             {
0:                 REPORT_FAILURE( "  table enumeration returned a null element");
0:                 return;
0:             }
0:             if( el instanceof DataValueDescriptor[])
0:                 checkElement( (DataValueDescriptor[]) el, rowCount, rows, found);
0:             else if( el instanceof Vector)
0:             {
0:                 Vector v = (Vector) el;
0:                 for( int i = 0; i < v.size(); i++)
0:                     checkElement( (DataValueDescriptor[]) v.get(i), rowCount, rows, found);
0:             }
0:             else if( el == null)
0:             {
0:                 REPORT_FAILURE( "  table enumeration returned an incorrect element type");
0:                 return;
0:             }
0:         }
0:         for( int i = 0; i < rowCount; i++)
0:         {
0:             if( (removeDups && isDuplicate[i]))
0:             {
0:                 if( found[i])
0:                 {
0:                     REPORT_FAILURE( "  table enumeration did not remove duplicates");
0:                     return;
0:                 }
0:             }
0:             else if( ! found[i])
0:             {
0:                 REPORT_FAILURE( "  table enumeration missed at least one element");
0:                 return;
0:             }
0:         }
0:     } // end of testElements
0: 
0:     private void checkElement( DataValueDescriptor[] fetchedRow,
0:                                int rowCount,
0:                                DataValueDescriptor[][] rows,
0:                                boolean[] found)
0:         throws StandardException
0:     {
0:         for( int i = 0; i < rowCount; i++)
0:         {
0:             if( rowsEqual( fetchedRow, rows[i]))
0:             {
0:                 if( found[i])
0:                 {
0:                     REPORT_FAILURE( "  table enumeration returned the same element twice");
0:                     return;
0:                 }
0:                 found[i] = true;
0:                 return;
0:             }
0:         }
0:         REPORT_FAILURE( "  table enumeration returned an incorrect element");
0:     } // end of checkElement
0: 
0:     private boolean rowsEqual( Object r1, Object r2)
0:         throws StandardException
0:     {
0:         if( r1 == null)
0:             return r2 == null;
0: 
0:         if( r1 instanceof DataValueDescriptor[])
0:         {
0:             DataValueDescriptor[] row1 = (DataValueDescriptor[]) r1;
0:             DataValueDescriptor[] row2;
0:             
0:             if( r2 instanceof Vector)
0:             {
0:                 Vector v2 = (Vector) r2;
0:                 if( v2.size() != 1)
0:                     return false;
0:                 row2 = (DataValueDescriptor[]) v2.elementAt(0);
0:             }
0:             else if( r2 instanceof DataValueDescriptor[])
0:                 row2 = (DataValueDescriptor[]) r2;
0:             else
0:                 return false;
0:             
0:             if( row1.length != row2.length)
0:                 return false;
0:             for( int i = 0; i < row1.length; i++)
0:             {
0:                 if( ! row1[i].compare( Orderable.ORDER_OP_EQUALS, row2[i], true, true))
0:                     return false;
0:             }
0:             return true;
0:         }
0:         if( r1 instanceof Vector)
0:         {
0:             if( !(r2 instanceof Vector))
0:                 return false;
0:             Vector v1 = (Vector) r1;
0:             Vector v2 = (Vector) r2;
0:             if( v1.size() != v2.size())
0:                 return false;
0:             for( int i = v1.size() - 1; i >= 0; i--)
0:             {
0:                 if( ! rowsEqual( v1.elementAt( i), v2.elementAt(i)))
0:                     return false;
0:             }
0:             return true;
0:         }
0:         // What is it then?
0:         return r1.equals( r2);
0:     } // end of rowsEqual
0: }
============================================================================