1:eac0369: /*
37:eac0369: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.services.loader.ClassInspector
1:7ecc1f2: 
1:6baf18b:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6baf18b:    contributor license agreements.  See the NOTICE file distributed with
1:6baf18b:    this work for additional information regarding copyright ownership.
1:6baf18b:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6baf18b:    (the "License"); you may not use this file except in compliance with
1:6baf18b:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
8:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.services.loader;
1:7b398e9: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import java.lang.reflect.*;
1:4e5e965: import java.util.ArrayList;
1:4e5e965: import java.util.HashMap;
1:eac0369: 
7:eac0369: /**
1:eac0369: 	Methods to find out relationships between classes and methods within a class.
1:eac0369: 	All class names within this interface are treated as java language class names,
1:eac0369: 	e.g. int, COM.foo.Myclass, int[], java.lang.Object[]. That is java internal
1:eac0369: 	class names as defined in the class file format are not understood.
1:eac0369: */
1:c8603c4: public class ClassInspector
9:eac0369: {
1:eac0369: 	private static final String[] primTypeNames =
1:eac0369: 		{"boolean", "byte", "char", "short", "int", "long", "float", "double"};
1:eac0369: 
1:eac0369: 	// collect these as static, instead of each time allocates these new
1:eac0369: 	// Strings for every method resolution
1:eac0369: 
1:eac0369: 	private static final String[] nonPrimTypeNames =
1:eac0369: 		{"java.lang.Boolean", "java.lang.Byte", "java.lang.Character",
1:eac0369: 		 "java.lang.Short", "java.lang.Integer", "java.lang.Long",
1:eac0369: 		 "java.lang.Float", "java.lang.Double"};
1:eac0369: 
1:b50def6:     private static final String OBJECT_TYPE_NAME = "java.lang.Object";
1:b50def6:     private static final String STRING_TYPE_NAME = "java.lang.String";
1:886e6e1:     private static final String BIGDECIMAL_TYPE_NAME = "java.math.BigDecimal";
1:b50def6: 
1:eac0369: 	private final ClassFactory cf;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		DO NOT USE! use the method in ClassFactory.
1:eac0369: 	*/
1:eac0369: 	public ClassInspector(ClassFactory cf) {
1:eac0369: 		this.cf = cf;
26:eac0369: 	}
1:7b398e9: 	
1:7b398e9: 	/**
1:eac0369: 	 * Is the given object an instance of the named class?
1:3bcc92e: 	 *
1:eac0369: 	 * @param className	The name of the class
1:eac0369: 	 * @param obj		The object to test to see if it's an instance
1:eac0369: 	 *			of the named class
3:eac0369: 	 *
1:eac0369: 	 * @return	true if obj is an instanceof className, false if not
1:3bcc92e: 	 */
1:eac0369: 	public boolean instanceOf(String className, Object obj)
1:eac0369: 		throws ClassNotFoundException
1:3bcc92e: 	{
1:71c8e86: 		Class<?> clazz = getClass(className);
1:eac0369: 		// is className an untyped null
1:eac0369: 		if (clazz == null)
6:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		return clazz.isInstance(obj);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is one named class assignable to another named class or interface?
1:eac0369: 	 *
1:eac0369: 	 * @param fromClassName	The name of the class to be assigned
1:eac0369: 	 * @param toClassName	The name of the class to be assigned to
1:eac0369: 	 *
1:eac0369: 	 * @return	true if an object of type fromClass can be assigned to an
1:eac0369: 	 *			object of type toClass, false if not.
1:c8603c4: 	 */
1:eac0369: 	public boolean assignableTo(String fromClassName, String toClassName)
1:7b398e9: 	{
1:eac0369: 		try
1:eac0369: 		{
1:073b862: 			Class<?> toClass = getClass(toClassName);
1:eac0369: 			// is toClass an untyped null
1:eac0369: 			if (toClass == null) {
1:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 
1:073b862: 			Class<?> fromClass = getClass(fromClassName);
1:eac0369: 
1:eac0369: 			// is fromClass an untyped null
1:eac0369: 			if (fromClass == null)
1:eac0369: 				return !toClass.isPrimitive() || (toClass == Void.TYPE);
1:eac0369: 
1:eac0369: 
1:eac0369: 			return toClass.isAssignableFrom(fromClass);
1:eac0369: 		}
1:eac0369: 		catch (ClassNotFoundException cnfe)
1:eac0369: 		{
1:eac0369: 			/* If either class can't be found, they can't be assigned */
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Does the named class exist, and is it accessible?
1:eac0369: 	 *
1:eac0369: 	 * @param className	The name of the class to test for existence
1:eac0369: 	 *
1:eac0369: 	 * @return	true if the class exists and is accessible, false if not
1:7b398e9: 	 */
1:eac0369: 	public boolean accessible(String className)
1:eac0369: 		throws ClassNotFoundException
1:eac0369: 	{
1:71c8e86: 		Class<?> theClass = getClass(className);
1:eac0369: 		if (theClass == null)
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		/* Classes must be public to be accessible */
1:eac0369: 		if (! Modifier.isPublic(theClass.getModifiers()))
1:eac0369: 			return false;
1:eac0369: 
3:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the Java name of the return type from a Member representing
1:eac0369: 	 * a method or the type of a Member representing a field.
1:eac0369: 	 *
1:6b50965: 	 * @param member		A Member representing the method for
1:eac0369: 	 *						which we want the return type.
1:eac0369: 	 *
1:eac0369: 	 * @return	A Java-language-style string describing the return type of
1:eac0369: 	 *			the method (for example, it returns "int" instead of "I".
1:eac0369: 	 */
1:eac0369: 	public String getType(Member member)
1:eac0369: 	{
1:eac0369: 		Class type;
1:eac0369: 
1:eac0369: 		if (member instanceof Method)
1:eac0369: 			type = ((Method) member).getReturnType();
1:eac0369: 		else if (member instanceof Field)
1:eac0369: 			type = ((Field) member).getType();
1:eac0369: 		else if (member instanceof Constructor)
1:eac0369: 			type = ((Constructor) member).getDeclaringClass();
1:eac0369: 		else
1:eac0369: 			type = Void.TYPE;
1:eac0369: 
1:eac0369: 		return ClassInspector.readableClassName(type);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Find a public method that implements a given signature.
1:eac0369: 	 * The signature is given using the full Java class names of the types.
1:eac0369: 	 <BR>
1:c6892a1: 	 * A untyped null parameter is indicated by passing in an empty string ("")
1:eac0369: 	 * as its class name.
1:eac0369: 	 <BR>
1:c6892a1: 	 If receiverType represents an interface then the methods of java.lang.Object
1:c6892a1: 	 are included in the candidate list.
1:eac0369: 	 <BR>
1:eac0369: 	 If the caller is simply checking to see that a public method with the
1:eac0369: 	 specified name exists, regardless of the signature, exists, then the
1:eac0369: 	 caller should pass in a null for parmTypes.  (This is useful for checking
1:eac0369: 	 the validity of a method alias when creating one.)
1:eac0369: 	 <BR>
1:eac0369: 	 We use a two-pass algorithm to resolve methods.  In the first pass, we
1:eac0369: 	 use all "object" types to try to match a method.  If this fails, in the
1:eac0369: 	 second pass, an array of "primitive" types (if the parameter has one,
1:eac0369: 	 otherwise the same object type is used) is passed in, as well as the
1:eac0369: 	 "object" type array.  For each parameter of a method, we try to match it
1:eac0369: 	 against either the "object" type, or the "primitive" type.  Of all the
1:eac0369: 	 qualified candidate methods found, we choose the closest one to the input
1:eac0369: 	 parameter types.  This involves comparing methods whose parameters are
1:eac0369: 	 mixed "object" and "primitive" types in the second pass.  This is
1:eac0369: 	 eventually handled in classConvertableFromTo.
1:eac0369: 	 *
1:6b50965: 	 * @param receiverType	The class name of the receiver
1:eac0369: 	 * @param methodName	The name of the method
1:eac0369: 	 * @param parmTypes		An array of class names representing the
1:eac0369: 	 *						parameter types.  Pass a zero-element array if
1:eac0369: 	 *						there are no parameters.  Pass a null if it is
1:eac0369: 	 *						okay to match any signature.
1:eac0369: 	 * @param primParmTypes This is used in the second pass of the two-pass
1:eac0369: 	 *						method resolution algorithm.  Use primitive type
1:eac0369: 	 *						if it has one, otherwise use same object type
1:eac0369: 	 * @param isParam		Array of booleans telling whether parameter is a ?.
1:eac0369: 	 * @param staticMethod	Find a static method.
1:eac0369: 	   @param repeatLastParameter If true the last parameter may be repeated any number of times (total count must be greater than one).
1:c6892a1: 	   If false the last parameter is matched as usual. This also requires an exact match on the last parameter type.
1:eac0369: 	 *
1:eac0369: 	 * @return	A Member representing the matching method.  Returns null
1:eac0369: 	 *			if no such method.
1:eac0369: 	 *
1:eac0369: 	 * @exception ClassNotFoundException	One or more of the classes does
1:eac0369: 	 *										not exist.
1:eac0369: 	 * @exception StandardException			Thrown on ambiguous method invocation.
1:eac0369: 	 *
1:eac0369: 	 * @see	Member
1:eac0369: 	 * @see Modifier
1:eac0369: 	 */
1:232d09a: 	public Member findPublicMethod
1:232d09a:         (
1:232d09a:          String receiverType,
1:232d09a:          String methodName,
1:232d09a:          String[] parmTypes,
1:232d09a:          String[] primParmTypes,
1:232d09a:          boolean[] isParam,
1:232d09a:          boolean staticMethod,
1:232d09a:          boolean repeatLastParameter,
1:232d09a:          boolean hasVarargs
1:232d09a:          )
1:232d09a:         throws ClassNotFoundException, StandardException
1:eac0369: 	{
1:073b862: 		Class<?> receiverClass = getClass(receiverType);
1:eac0369: 		if (receiverClass == null)
1:f52a50f: 			return null;
1:eac0369: 
1:eac0369: 		// primitives don't have methods
1:eac0369: 		// note that arrays do since they are objects they have
1:eac0369: 		// all the methods of java.lang.Object
1:eac0369: 		if (receiverClass.isPrimitive()) {
5:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// if parmTypes is null, then the caller is simply 
1:eac0369: 		// looking to see if any public method with the
1:eac0369: 		// specified name exists, regardless of its signature
1:eac0369: 		if (parmTypes == null) {
1:eac0369: 			Method[] methods = receiverClass.getMethods();
1:eac0369: 			
1:eac0369: 			for (int index = 0; index < methods.length; index++) {
1:eac0369: 				if (staticMethod) {
1:eac0369: 					if (!Modifier.isStatic(methods[index].getModifiers())) {
3:eac0369: 						continue;
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:232d09a:                 // If the routine was declared to be varargs, then we eliminate
1:232d09a:                 // all non-varargs methods from consideration
1:232d09a:                 if ( hasVarargs && !isVarArgsMethod( methods[index] ) ) { continue; }
1:232d09a: 
1:eac0369: 				if (methodName.equals(methods[index].getName())) {
1:eac0369: 					// We found a match
1:eac0369: 					return methods[index];
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			// No match
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// convert the parameter types to classes
1:eac0369: 		Class[] paramClasses = new Class[parmTypes.length];
1:eac0369: 		Class[] primParamClasses = null;
1:eac0369: 		if (primParmTypes != null)
1:eac0369: 			primParamClasses = new Class[primParmTypes.length];
1:eac0369: 		for (int i = 0; i < paramClasses.length; i++)
1:eac0369: 		{
1:eac0369: 			paramClasses[i] = getClass(parmTypes[i]);
1:eac0369: 			if (primParmTypes == null)
1:eac0369: 				continue;
1:eac0369: 			if (primParmTypes[i].equals(parmTypes[i]))  // no separate primitive
1:eac0369: 				primParamClasses[i] = null;
1:eac0369: 			else
1:eac0369: 				primParamClasses[i] = getClass(primParmTypes[i]);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// no overloading possible if there are no arguments, so perform
1:68573fc: 		// an exact match lookup.
1:68573fc: 		if (paramClasses.length == 0) {
1:68573fc: 
1:3bcc92e: 			try {
1:eac0369: 				Method method = receiverClass.getMethod(methodName, paramClasses);
1:3bcc92e: 
1:eac0369: 				if (staticMethod) {
1:eac0369: 					if (!Modifier.isStatic(method.getModifiers()))
1:f52a50f: 						return null;
1:3bcc92e: 				}
1:3bcc92e: 
1:f52a50f: 				return method;
1:3bcc92e: 
1:eac0369: 				} catch (NoSuchMethodException nsme2) {
1:eac0369: 
1:eac0369: 
1:eac0369: 					// if we are an interface then the method could be defined on Object
1:eac0369: 					if (!receiverClass.isInterface())
1:f52a50f: 						return null;
1:3bcc92e: 				}
1:f52a50f: 		}
1:eac0369: 
1:eac0369: 		// now the tricky method resolution
1:eac0369: 		Member[] methodList = receiverClass.getMethods();
1:eac0369: 		// if we have an interface we need to add the methods of Object into the mix
1:eac0369: 		if (receiverClass.isInterface()) {
1:eac0369: 
1:eac0369: 			Member[] objectMethods = java.lang.Object.class.getMethods();
1:eac0369: 			if (methodList.length == 0) {
1:eac0369: 				methodList = objectMethods;
1:f52a50f: 			} else {
1:eac0369: 				Member[] set = new Member[methodList.length + objectMethods.length];
1:eac0369: 				System.arraycopy(methodList, 0, set, 0, methodList.length);
1:eac0369: 				System.arraycopy(objectMethods, 0, set, methodList.length, objectMethods.length);
1:eac0369: 				methodList = set;
1:f52a50f: 			}
1:f52a50f: 		}
1:f52a50f: 
1:232d09a: 		return resolveMethod
1:232d09a:             (
1:232d09a:              receiverClass, methodName, paramClasses,
1:232d09a:              primParamClasses, isParam, staticMethod, repeatLastParameter, methodList,
1:232d09a:              hasVarargs
1:232d09a:              );
1:f52a50f: 	}
1:f52a50f: 
1:eac0369: 
1:3bcc92e: 	/**
1:eac0369: 	 * Find a public field  for a class.
1:c6892a1: 	   This follows the semantics of the java compiler for locating a field.
1:eac0369: 	   This means if a field fieldName exists in the class with package, private or
1:eac0369: 	   protected then an error is raised. Even if the field hides a field fieldName
1:eac0369: 	   in a super-class/super--interface. See the JVM spec on fields.
1:eac0369: 	 *
1:6b50965: 	 * @param receiverType	The class name of the receiver
1:eac0369: 	 * @param fieldName		The name of the field
1:eac0369: 	 * @param staticField	Find a static field
1:eac0369: 	 *
1:eac0369: 	 * @return	A Member representing the matching field.  
1:eac0369: 	 * @exception StandardException	Class or field does not exist or is not public or a security exception.
1:eac0369: 	 *
1:eac0369: 	 * @see	Member
1:eac0369: 	 * @see Modifier
1:eac0369: 	 */
1:eac0369: 	public Member findPublicField(String receiverType,
1:eac0369: 								String fieldName,
1:eac0369: 								boolean staticField)
1:c8603c4: 					throws StandardException
1:c8603c4: 	{
1:0ad97c9: 
1:eac0369: 		Exception e = null;
1:68573fc: 		try {
1:c8603c4: 
1:71c8e86: 			Class<?> receiverClass = getClass(receiverType);
1:eac0369: 			if (receiverClass == null)
1:f52a50f: 				return null;
1:eac0369: 			if (receiverClass.isArray() || receiverClass.isPrimitive()) {
1:eac0369: 				// arrays don't have fields (the fake field 'length' is not returned here)
1:eac0369: 				return null;
1:c8603c4: 			}
1:68573fc:   
1:eac0369: 			int modifier = staticField ? (Modifier.PUBLIC | Modifier.STATIC) : Modifier.PUBLIC;
1:eac0369: 
1:eac0369: 			// Look for a public field first
1:eac0369: 			Field publicField = receiverClass.getField(fieldName);
1:eac0369: 
1:eac0369: 			if ((publicField.getModifiers() & modifier) == modifier)
1:7b398e9: 			{
1:eac0369: 				/*
1:eac0369: 					If the class is an interface then we avoid looking for a declared field
1:eac0369: 					that can hide a super-class's public field and not be accessable. This is because
1:eac0369: 					a interface's fields are always public. This avoids a security check.
1:eac0369: 				*/
1:eac0369: 				if (receiverClass.isInterface() || (publicField.getDeclaringClass().equals(receiverClass)))
1:eac0369: 					return publicField;
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 					Now check to see if there is a declared field that hides the public field.
1:eac0369: 				*/
1:eac0369: 
1:7b398e9: 				try {
1:eac0369: 
1:eac0369: 					Field declaredField = receiverClass.getDeclaredField(fieldName);
1:eac0369: 
3:eac0369: 					if (SanityManager.DEBUG) {
1:eac0369: 
1:eac0369: 						if ((declaredField.getModifiers() & Modifier.PUBLIC) == Modifier.PUBLIC)
1:eac0369: 							SanityManager.THROWASSERT("declared field not expected to be public here " + declaredField);
1:f52a50f: 					}
1:eac0369: 
1:eac0369: 				} catch (NoSuchFieldException nsfe) {
1:eac0369: 
1:eac0369: 					// no field hides the public field in the super class
1:eac0369: 					return publicField;
1:f52a50f: 				}
1:f52a50f: 			}
1:eac0369: 
1:eac0369: 		} catch (ClassNotFoundException cnfe) {
1:eac0369: 			e = cnfe;
1:eac0369: 		} catch (NoSuchFieldException nsfep) {
1:eac0369: 			e = nsfep;
1:eac0369: 		} catch (SecurityException se) {
1:eac0369: 			e = se;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		throw StandardException.newException(
1:eac0369: 			staticField ? SQLState.LANG_NO_STATIC_FIELD_FOUND : SQLState.LANG_NO_FIELD_FOUND, 
1:eac0369: 								e, fieldName, receiverType);
1:eac0369: 	}
1:eac0369: 
1:c8603c4: 	/**
1:eac0369: 	 * Find a public constructor that implements a given signature.
1:eac0369: 	 * The signature is given using the full Java class names of the types.
1:eac0369: 	 <BR>
1:c6892a1: 	 * A untyped null parameter is indicated by passing in an empty string ("")
1:eac0369: 	 * as its class name. 
1:eac0369: 	 *
1:eac0369: 	 * @param receiverType	The class name of the receiver
1:eac0369: 	 * @param parmTypes		An array of class names representing the
1:eac0369: 	 *						parameter types.  Pass a zero-element array if
1:eac0369: 	 *						there are no parameters.
1:eac0369: 	 * @param primParmTypes This is used in the second pass of the two-pass
1:eac0369: 	 *						method resolution algorithm.  Use primitive type
1:eac0369: 	 *						if it has one, otherwise use same object type
1:eac0369: 	 * @param isParam		Array of booleans telling whether parameter is a ?.
1:eac0369: 	 *
1:eac0369: 	 * @return	A Member representing the matching constructor.  Returns null
1:eac0369: 	 *			if no such constructor.
1:eac0369: 	 *
1:eac0369: 	 * @exception ClassNotFoundException	One or more of the classes does
1:eac0369: 	 *										not exist.
1:eac0369: 	 * @exception StandardException			Thrown on ambiguous constructor invocation.
1:eac0369: 	 *
1:eac0369: 	 * @see	Member
1:eac0369: 	 * @see Modifier
1:eac0369: 	 */
1:eac0369: 	public Member findPublicConstructor(String receiverType,
2:eac0369: 									String[] parmTypes,
2:eac0369: 									String[] primParmTypes,
1:eac0369: 									boolean[] isParam)
2:eac0369: 						throws ClassNotFoundException, StandardException 
1:eac0369: 	{
1:073b862: 		Class<?> receiverClass = getClass(receiverType);
1:eac0369: 		if (receiverClass == null)
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 		// arrays, primitives, and interfaces do not have constructors
1:eac0369: 		if (receiverClass.isArray() || receiverClass.isPrimitive() || receiverClass.isInterface()) {
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// convert the parameter types to classes
1:eac0369: 		Class[] paramClasses = new Class[parmTypes.length];
1:eac0369: 		Class[] primParamClasses = null;
1:eac0369: 		if (primParmTypes != null)
1:eac0369: 			primParamClasses = new Class[primParmTypes.length];
1:eac0369: 		boolean unknownParameters = false;
1:eac0369: 		for (int i = 0; i < paramClasses.length; i++) {
1:eac0369: 			paramClasses[i] = getClass(parmTypes[i]);
1:eac0369: 			if (paramClasses[i] == null)
1:eac0369: 				unknownParameters = true;
1:eac0369: 			if (primParmTypes == null)
1:eac0369: 				continue;
1:eac0369: 			if (primParmTypes[i].equals(parmTypes[i]))  // no separate primitive
1:eac0369: 				primParamClasses[i] = null;
1:eac0369: 			else
1:eac0369: 				primParamClasses[i] = getClass(primParmTypes[i]);
1:eac0369: 		}
1:eac0369: 
1:7b398e9: 		try {
1:eac0369: 
1:eac0369: 			if (!unknownParameters && (primParmTypes == null)) {
1:eac0369: 				// look for an exact match for first pass
1:eac0369: 				Member method = receiverClass.getConstructor(paramClasses);
1:eac0369: 
2:eac0369: 				return method;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		} catch (NoSuchMethodException nsme) {
1:eac0369: 
1:eac0369: 			// no overloading possible if there are no arguments
1:eac0369: 			if (paramClasses.length == 0)
1:eac0369: 				return null;
1:eac0369: 
1:eac0369: 			// now the tricky method resolution
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// name is only used for debugging
1:232d09a: 		return resolveMethod
1:232d09a:             (
1:232d09a:              receiverClass, "<init>", paramClasses, 
1:232d09a:              primParamClasses, isParam, false, false,
1:232d09a:              receiverClass.getConstructors(),
1:232d09a:              false
1:232d09a:              );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:0ad97c9: 	 * Given an implementation of a parameterized interface, return
1:4e5e965:      * the bounds on the type variables. May return null if type resolution
1:4e5e965:      * fails.
1:0ad97c9: 	 */
1:d861c23: 	public Class[][] getTypeBounds( Class parameterizedInterface, Class implementation )
1:0ad97c9:         throws StandardException
1:0ad97c9: 	{
1:4e5e965:         if ( implementation == null ) { return null; }
1:4e5e965: 
1:4e5e965:         Type[]  genericInterfaces = implementation.getGenericInterfaces();
1:4e5e965:         for ( Type genericInterface : genericInterfaces )
1:4e5e965:         {
1:4e5e965:             //
1:4e5e965:             // Look for the generic interface whose raw type is the
1:4e5e965:             // parameterized interface we're interested in.
1:4e5e965:             //
1:4e5e965:             if ( genericInterface instanceof ParameterizedType )
1:4e5e965:             {
1:4e5e965:                 ParameterizedType   pt = (ParameterizedType) genericInterface;
1:4e5e965:                 Type    rawType = pt.getRawType();
1:4e5e965: 
1:4e5e965:                 // found it!
1:4e5e965:                 if ( parameterizedInterface == rawType )
1:4e5e965:                 {
1:4e5e965:                     return findTypeBounds( pt );
1:4e5e965:                 }
1:4e5e965:             }
1:4e5e965:         }
1:4e5e965: 
1:4e5e965:         // couldn't find the interface we're looking for. check our superclass.
1:4e5e965:         return getTypeBounds( parameterizedInterface, implementation.getSuperclass() );
1:0ad97c9:     }
1:4e5e965: 
1:0ad97c9: 	/**
1:232d09a: 	 * Return true if the method or constructor supports varargs.
1:232d09a: 	 */
1:232d09a: 	public boolean  isVarArgsMethod( Member member )
1:232d09a: 	{
1:4e5e965:         if (member instanceof Method) {
1:4e5e965:             return ((Method) member).isVarArgs();
1:4e5e965:         } else if (member instanceof Constructor) {
1:4e5e965:             return ((Constructor) member).isVarArgs();
1:4e5e965:         } else {
1:3bcc92e:             return false;
1:4e5e965:         }
1:232d09a:     }
1:4e5e965: 
1:232d09a: 	/**
1:d861c23: 	 * Given an implementation of a parameterized interface, return
1:4e5e965:      * the actual types of the interface type variables.
1:4e5e965:      * May return null or an array of nulls if type resolution fails.
1:eac0369: 	 */
1:e1f49ca:     public Class<?>[] getGenericParameterTypes(
1:e1f49ca:             Class parameterizedType, Class implementation )
2:eac0369:         throws StandardException
1:eac0369: 	{
1:4e5e965:         // construct the inheritance chain stretching from the parameterized
1:4e5e965:         // type down to the concrete implemention
1:4e5e965:         ArrayList<Class<?>> chain =
1:4e5e965:                 getTypeChain(parameterizedType, implementation);
1:4e5e965: 
1:4e5e965:         // walk the chain, filling in a map of generic types to their
1:4e5e965:         // resolved types
1:4e5e965:         HashMap<Type, Type> resolvedTypes = getResolvedTypes(chain);
1:4e5e965: 
1:4e5e965:         // compose the resolved types together in order to compute the actual
1:4e5e965:         // classes which are plugged into the variables of the parameterized
1:4e5e965:         // type
1:4e5e965:         ArrayList<Class<?>> parameterTypes =
1:4e5e965:                 getParameterTypes(parameterizedType, resolvedTypes);
1:4e5e965: 
1:4e5e965:         // turn the list into an array
1:4e5e965:         if (parameterTypes == null) {
1:4e5e965:             return null;
1:4e5e965:         }
1:4e5e965: 
1:e1f49ca:         return parameterTypes.toArray(new Class<?>[parameterTypes.size()]);
1:eac0369:     }
1:4e5e965: 
1:eac0369: 	/**
1:eac0369: 	 * Get the parameter types for a method described by a Member as a String[].
1:eac0369: 	 *
1:eac0369: 	 * @param method	A Member describing a method
1:eac0369: 	 *
1:eac0369: 	 * @return	A String[] describing the parameters of the method
1:eac0369: 	 */
1:eac0369: 	public String[] getParameterTypes(Member method)
1:eac0369: 	{
1:232d09a: 
1:7b398e9: 		Class[] parameterClasses;
1:eac0369: 		if (method instanceof Method) {
1:eac0369: 			parameterClasses = ((Method) method).getParameterTypes();
1:7b398e9: 		} else {
1:eac0369: 			parameterClasses = ((Constructor) method).getParameterTypes();
1:7b398e9: 		}
1:7b398e9: 
1:eac0369: 		String[] parameterTypes = new String[parameterClasses.length];
1:7b398e9: 
1:eac0369: 		for (int i = 0; i < parameterTypes.length; i++) {
1:eac0369: 			parameterTypes[i] = ClassInspector.readableClassName(parameterClasses[i]);
1:7b398e9: 		}
1:7b398e9: 
1:eac0369: 		return parameterTypes;
1:7b398e9: 	}
1:7b398e9: 
1:7b398e9: 	/**
1:eac0369: 	 * Determine whether a type is a Java primitive, like int or boolean
1:eac0369: 	 *
1:eac0369: 	 * @param typeName	The name of the Java type
1:eac0369: 	 *
1:eac0369: 	 * @return	true if it's a primitive type
1:7b398e9: 	 */
1:eac0369: 	public static boolean primitiveType(String typeName)
1:7b398e9: 	{
1:eac0369: 		for (int i = 0; i < primTypeNames.length; i++)
1:7b398e9: 		{
1:eac0369: 			if (typeName.equals(primTypeNames[i]))
1:3bcc92e: 				return true;
1:7b398e9: 		}
1:7b398e9: 
1:3bcc92e: 		return false;
1:7b398e9: 	}
1:7b398e9: 
1:eac0369: 
1:7b398e9: 	/**
1:eac0369: 	 *  Tricky function to resolve a method.  If primParamClasses is null
1:eac0369: 	 *  we know it's first pass.  First pass try to match as all "object"
1:eac0369: 	 *  types, second pass try to match any combination of "object" and
1:eac0369: 	 *  "primitive" types.  Find the closest match among all the qualified
1:eac0369: 	 *  candidates.  If there's a tie, it's ambiguous.
1:5c04fbc:      *
1:5c04fbc:      *  The preceding paragraph is a bit misleading. As of release 10.4, the
1:5c04fbc:      *  second pass did not consider arbitrary combinations of primitive and
1:5c04fbc:      *  wrapper types. This is because the first pass removed from consideration
1:5c04fbc:      *  candidates which would be allowed under ANSI rules. As a fix for bug
1:5c04fbc:      *  DERBY-3652, we now allow primitive and wrapper type matches during
1:5c04fbc:      *  the first pass. The ANSI rules are documented in DERBY-3652.
1:5c04fbc:      *
1:eac0369: 	 *  @param receiverClass 	the class who holds the methods
1:eac0369: 	 *  @param methodName		the name of method
1:eac0369: 	 *	@param paramClasses		object type classes of input parameters
1:eac0369: 	 *  @param primParamClasses	primitive type classes or null
1:eac0369: 	 *  @param isParam			isParam (for ?) array
1:eac0369: 	 *  @param staticMethod		static method or not
1:6b50965: 	 *  @param methods			method stack
1:eac0369: 	 *  @return	the matched method
1:eac0369: 	 *
1:eac0369: 	 **/
1:232d09a: 	private Member resolveMethod
1:232d09a:         (
1:232d09a:          Class receiverClass,
1:232d09a:          String methodName,
1:232d09a:          Class[] paramClasses,
1:232d09a:          Class[] primParamClasses,
1:232d09a:          boolean[] isParam,
1:232d09a:          boolean staticMethod,
1:232d09a:          boolean repeatLastParameter,
1:232d09a:          Member[] methods,
1:232d09a:          boolean hasVarargs
1:232d09a:          )
1:232d09a:         throws StandardException
1:7b398e9: 	{
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 		  if (SanityManager.DEBUG_ON("MethodResolutionInfo"))
1:eac0369: 		  {
3:eac0369: 			SanityManager.DEBUG("MethodResolutionInfo",
1:eac0369: 				"MRI - Begin method resolution trace for " + methodName + 
1:eac0369: 				"() with " + paramClasses.length + (repeatLastParameter ? "+" : "") + " parameters");
1:eac0369: 
1:eac0369: 			for (int parmCtr = 0; parmCtr < paramClasses.length; parmCtr++)
1:eac0369: 			{
1:eac0369: 				SanityManager.DEBUG("MethodResolutionInfo",
1:eac0369: 					"MRI - Parameter #" + parmCtr +
1:eac0369: 					" is of type " + (paramClasses[parmCtr] == null ? "null" : paramClasses[parmCtr].getName()));
1:eac0369: 			}
1:eac0369: 		  }
1:eac0369: 		}
1:eac0369: 			
1:eac0369: 		/* Step through all the methods available in this class */
1:eac0369: 		int candidateIndex = -1;
1:eac0369: 
1:eac0369: 		boolean firstTimeAround = true;
1:eac0369: 		boolean	ambiguous;
1:eac0369: 		boolean somethingChanged;
1:eac0369: 		do {
1:eac0369: 
1:eac0369: 			ambiguous = false;
1:eac0369: 			somethingChanged = false;
1:eac0369: 
1:eac0369: nextMethod:	for (int i = 0; i < methods.length; i++) {
1:eac0369: 
1:eac0369: 				Member currentMethod = methods[i];
1:7b398e9: 
1:eac0369: 				// on second and later times around there will be null entries
1:eac0369: 				// also, don't compare ourself to ourself
1:eac0369: 				if ((currentMethod == null) ||
1:eac0369: 					(i == candidateIndex))
1:eac0369: 				{
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// must have the same number of parameters
1:eac0369: 				Class[] currentMethodParameters = currentMethod instanceof Method ?
1:eac0369: 					((Method) currentMethod).getParameterTypes():
1:eac0369: 					((Constructor) currentMethod).getParameterTypes();
1:eac0369: 
1:eac0369: 				// only check the basic stuff once
1:eac0369: 				if (firstTimeAround) {
1:eac0369: 
1:eac0369: 					if (repeatLastParameter) {
1:eac0369: 						// match any number of parameters greater or equal to
1:eac0369: 						// the passed in number, but repeating the last type.
1:eac0369: 						if (currentMethodParameters.length < paramClasses.length) {
2:eac0369: 							methods[i] = null; // remove non-applicable methods
1:eac0369: 							continue;
1:eac0369: 						}
1:eac0369: 
1:eac0369: 
4:eac0369: 					} else {
1:eac0369: 
1:68573fc: 						// regular match on parameter count
1:68573fc: 						if (currentMethodParameters.length != paramClasses.length) {
1:eac0369: 							methods[i] = null; // remove non-applicable methods
1:eac0369: 							continue;
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					/* Look only at methods that match the modifiers */
1:eac0369: 					if (staticMethod && !Modifier.isStatic(currentMethod.getModifiers())) {
1:eac0369: 						methods[i] = null; // remove non-applicable methods
1:eac0369: 						continue;
1:eac0369: 					}
1:eac0369: 
1:232d09a:                     // If the routine was declared to be varargs, then we eliminate
1:232d09a:                     // all non-varargs methods from consideration
1:232d09a: 					if ( hasVarargs && !isVarArgsMethod( currentMethod )) {
1:232d09a: 						methods[i] = null; // remove non-applicable methods
1:232d09a: 						continue;
1:232d09a: 					}
1:232d09a: 
1:eac0369: 					/* Look only at methods with the right name */
1:eac0369: 					if (!methodName.startsWith("<")) {
1:eac0369: 						if ( ! methodName.equals(currentMethod.getName())) {
1:eac0369: 							methods[i] = null; // remove non-applicable methods
1:eac0369: 							continue;
1:eac0369: 						}
1:eac0369: 					}	
1:eac0369: 
1:eac0369: 
1:eac0369: 					if (repeatLastParameter) {
1:eac0369: 						// With N parameters requested check all parameters from N-1 to end are equal
1:eac0369: 						// to the requested parameter.
1:eac0369: 						for (int pr = paramClasses.length - 1; pr < currentMethodParameters.length; pr++) {
1:eac0369: 							if (!currentMethodParameters[pr].equals(paramClasses[paramClasses.length - 1])) {
1:eac0369: 								methods[i] = null; // remove non-applicable methods
1:eac0369: 								continue nextMethod;
1:eac0369: 							}
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG) {
3:eac0369: 				  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
1:eac0369: 					SanityManager.DEBUG("MethodResolutionInfo", 
1:eac0369: 						"MRI - Considering :" + currentMethod.toString());
1:eac0369: 				  }
1:eac0369: 				}
1:eac0369: 
1:886e6e1:                 //
1:5c04fbc:                 // According to the ANSI rules, primitives and their
1:5c04fbc:                 // corresponding wrapper types are equally good for resolving
1:5c04fbc:                 // numeric arguments of user-coded functions and procedures. See
1:5c04fbc:                 // DERBY-3652 for a description of the ANSI rules.
1:886e6e1:                 //
1:5c04fbc: 				// can the required signature be converted to those of this method?
1:eac0369: 				if (!signatureConvertableFromTo(paramClasses, primParamClasses,
1:5c04fbc: 							currentMethodParameters, isParam, true)) {
1:eac0369: 
1:eac0369: 					if (SanityManager.DEBUG) {
1:eac0369: 					  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
1:eac0369: 						SanityManager.DEBUG("MethodResolutionInfo", 
1:eac0369: 							"MRI - Skipping :" + currentMethod.toString());
1:eac0369: 					  }
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					methods[i] = null; // remove non-applicable methods
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG) {
1:eac0369: 				  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
1:eac0369: 					SanityManager.DEBUG("MethodResolutionInfo",	"MRI - Match found ");
1:eac0369: 				  }
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				/* Is this the first match? */
1:eac0369: 				if (candidateIndex == -1)
1:eac0369: 				{
2:eac0369: 					candidateIndex = i;
1:eac0369: 					if (SanityManager.DEBUG) {
1:eac0369: 					  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
1:eac0369: 						SanityManager.DEBUG("MethodResolutionInfo",
1:eac0369: 						"MRI - Current method is now candidate");
1:eac0369: 					  }
1:eac0369: 					}
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 
1:886e6e1:                 //
1:6886d9e:                 // Before the fixes to DERBY-3652, we used to weed out
1:6886d9e:                 // ambiguities by applying the rules from section 15.11
1:6886d9e:                 // of the Java Language Specification. These are not the
1:6886d9e:                 // ANSI resolution rules however. The code to weed out
1:6886d9e:                 // ambiguities has been removed.
1:886e6e1:                 //
1:eac0369: 
1:eac0369: 				/* We have seen an ambiguous situation; one of the cases may
1:eac0369: 				 * tie on each parameter.
1:7b398e9: 				 */
1:eac0369: 				ambiguous = true;
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG) {
1:eac0369: 				  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
1:eac0369: 					SanityManager.DEBUG("MethodResolutionInfo", "MRI - Ambiguous match");
1:eac0369: 				  }
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			firstTimeAround = false;
1:eac0369: 		} while (ambiguous && somethingChanged);  
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 		  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
1:eac0369: 			SanityManager.DEBUG("MethodResolutionInfo",
1:eac0369: 				"MRI - End method resolution trace for " + methodName + "()" +
1:eac0369: 				"\nMRI - ");
1:eac0369: 		  }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Throw an exception here if the method invocation ambiguous */
1:eac0369: 		if (ambiguous)
1:eac0369: 		{
1:eac0369: 			/* Put the parameter type names into a single string */
1:a9c3863: 			StringBuffer parmTypesString = new StringBuffer();
1:eac0369: 			for (int i = 0; i < paramClasses.length; i++)
1:eac0369: 			{
1:eac0369: 				if (i != 0)
1:a9c3863: 					parmTypesString.append(", ");
1:a9c3863: 				parmTypesString.append(paramClasses[i] == null ? "null" : paramClasses[i].getName());
1:eac0369: 				if (primParamClasses != null && primParamClasses[i] != null)
1:a9c3863: 					parmTypesString.append("(").append(primParamClasses[i].getName()).append(")");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			throw StandardException.newException(SQLState.LANG_AMBIGUOUS_METHOD_INVOCATION, 
1:eac0369: 												receiverClass.getName(), 
1:eac0369: 												methodName,
1:a9c3863: 												parmTypesString.toString());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (candidateIndex == -1)
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			if (methods[candidateIndex] == null)
1:eac0369: 				SanityManager.THROWASSERT("methods is null at index " + candidateIndex);
1:eac0369: 		}
1:68573fc: 		return methods[candidateIndex];
1:eac0369: 	}
1:7b398e9: 
1:eac0369: 	/**
1:eac0369: 		Get (load) the class for the given class name.
1:eac0369: 		This method converts any java language class name
1:eac0369: 		into a Class object. This includes cases like String[]
1:eac0369: 		and primitive types.
1:eac0369: 		This will attempt to load the class from the application set.
1:eac0369: 
1:2542f1d: 		@exception ClassNotFoundException Class cannot be found, or
1:2542f1d: 		a SecurityException or LinkageException was thrown loading the class.
1:eac0369: 	*/
1:71c8e86: 	public Class<?> getClass(String className) throws ClassNotFoundException {
1:eac0369: 
1:eac0369: 		if ((className == null) || 
1:eac0369: 			(className.length() == 0))
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		int arrayDepth = 0;
1:eac0369: 		int classNameLength = className.length();
1:eac0369: 
1:eac0369: 		int position = classNameLength - 2;
1:eac0369: 
1:eac0369: 		while ((position >= 0) && className.substring(position, position + 2).equals("[]")) {
1:eac0369: 			arrayDepth++;
1:eac0369: 			position -= 2;
1:eac0369: 			classNameLength -= 2;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (classNameLength <= 0) {
1:eac0369: 			// a bogus class name, let Class.forName deal with the error.
1:eac0369: 			return Class.forName(className);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (arrayDepth != 0)
1:eac0369: 			className = className.substring(0, classNameLength);
1:eac0369: 
1:eac0369: 		Class baseClass = null;
1:eac0369: 
1:eac0369: 		if (classNameLength >=3 && classNameLength <=7) {
1:eac0369: 			if ("int".equals(className)) 
1:eac0369: 				baseClass = Integer.TYPE;
1:eac0369: 			else if ("short".equals(className)) 
1:eac0369: 				baseClass = Short.TYPE;
1:eac0369: 			else if ("boolean".equals(className)) 
1:eac0369: 				baseClass = Boolean.TYPE;
1:eac0369: 			else if ("byte".equals(className)) 
1:eac0369: 				baseClass = Byte.TYPE;
1:eac0369: 			else if ("float".equals(className)) 
1:eac0369: 				baseClass = Float.TYPE;
1:eac0369: 			else if ("double".equals(className)) 
1:eac0369: 				baseClass = Double.TYPE;
1:eac0369: 			else if ("long".equals(className)) 
1:eac0369: 				baseClass = Long.TYPE;
1:eac0369: 			else if ("char".equals(className)) 
1:eac0369: 				baseClass = Character.TYPE;
1:eac0369: 			else if ("void".equals(className)) 
1:eac0369: 				baseClass = Void.TYPE;
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		if (baseClass == null) {
1:eac0369: 			baseClass = cf.loadApplicationClass(className);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (arrayDepth == 0)
1:eac0369: 			return baseClass;
1:eac0369: 
1:eac0369: 		// need to create an actual instance of the array type
1:eac0369: 		// and get its class from that. There is no other documented
1:eac0369: 		// way to do this. While a getName() on an array class
1:eac0369: 		// returns [[[Lclassname; format it's not consistent
1:eac0369: 		// with primitive types, e.g.
1:886e6e1: 		//
1:eac0369: 		// Integer.TYPE.getName()   returns "int"
1:eac0369: 		// Class.forName(new int[0] returns "[I"
4:b50def6: 		// 
1:eac0369: 
1:eac0369: 		if (arrayDepth == 1)
1:eac0369: 			return Array.newInstance(baseClass, 0).getClass();
1:eac0369: 
1:eac0369: 		return Array.newInstance(baseClass, new int[arrayDepth]).getClass();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *  Can we convert a signature from fromTypes(primFromTypes) to toTypes.
1:eac0369: 	 *  "mixTypes" is a flag to show if object/primitive type conversion is
1:eac0369: 	 *  possible; this is used for comparing two candidate methods in the
1:eac0369: 	 *  second pass of the two pass method resolution.
1:eac0369: 	 *
1:eac0369: 	 *  @param fromTypes	from types' classes
1:eac0369: 	 *	@param primFromTypes primitive from types or null
1:eac0369: 	 *	@param toTypes		to types' classes
1:eac0369: 	 *	@param isParam		is parameter (?) or not
1:eac0369: 	 *	@param mixTypes		mixing object/primitive types for comparison
1:eac0369: 	 **/
1:eac0369: 	private boolean signatureConvertableFromTo(Class[] fromTypes, Class[] primFromTypes,
1:eac0369: 												 Class[] toTypes, boolean[] isParam,
1:68573fc: 												 boolean mixTypes) {
1:eac0369: 
1:eac0369: 		// In the case repeatLastParameter was true, then the two methods may have
1:eac0369: 		// different numbers of parameters. We need to compare only the non-repeated
1:eac0369: 		// parameters, which is the number of input parameters.
1:eac0369: 
1:eac0369: 		int checkCount = fromTypes.length;
1:68573fc: 		if (toTypes.length < checkCount)
1:eac0369: 			checkCount = toTypes.length;
1:eac0369: 
1:eac0369: 		for (int i = 0; i < checkCount; i++) {
1:eac0369: 
1:eac0369: 			Class fromClass = fromTypes[i];
1:68573fc: 			Class toClass = toTypes[i];
1:7b398e9: 
1:eac0369: 			// this means an untyped null was passed in. Can only ever be in the
1:eac0369: 			// from side as the null can only be in the signature passed in by
1:eac0369: 			// the caller of findPublicMethod. Any signatures of existing methods
1:eac0369: 			// are always typed.
1:eac0369: 			if (fromClass == null) {
1:eac0369: 
1:eac0369: 				// primitive types are only considered on
1:eac0369: 				// the 2nd pass
1:eac0369: 				if (toClass.isPrimitive())
1:7b398e9: 				{
1:eac0369: 					if ((primFromTypes == null)		// first pass
1:eac0369: 						|| (isParam != null && ! isParam[i]))
1:eac0369: 					{
1:4e5e965: 						return false;
1:7b398e9: 					}
1:eac0369: 				}
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 
1:eac0369: 			if ((!classConvertableFromTo(fromClass, toClass, mixTypes)) &&
1:eac0369: 				// primitive type, if any, also doesn't work
1:eac0369: 				((primFromTypes == null) || (primFromTypes[i] == null) ||
1:eac0369: 				 (!classConvertableFromTo(primFromTypes[i], toClass, mixTypes))
1:eac0369: 				))
1:232d09a: 				return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *  Can we convert a fromClass to toClass.
1:eac0369: 	 *  "mixTypes" is a flag to show if object/primitive type conversion is
1:eac0369: 	 *  possible; this is used for comparing two candidate methods in the
1:eac0369: 	 *  second pass of the two pass method resolution.
1:eac0369: 	 *
1:eac0369: 	 *  @param fromClass	from class
1:eac0369: 	 *	@param toClass		to class
1:eac0369: 	 *	@param mixTypes		mixing object/primitive types for comparison
1:eac0369: 	 **/
1:eac0369: 	protected boolean classConvertableFromTo(Class fromClass, Class toClass, boolean mixTypes) {
1:eac0369: 
1:b50def6:         //
1:7294977:         // ANSI rules do not allow widening
1:b50def6:         //
1:7294977:         if ( fromClass.getName().equals( toClass.getName() ) ) { return true; }
1:eac0369: 
1:ffac5c3:         //
1:ffac5c3:         // OUT and INOUT args are arrays. Compare the cell types rather than the array types.
1:ffac5c3:         //
1:ffac5c3:         if ( fromClass.isArray() && toClass.isArray() )
1:ffac5c3:         {
1:ffac5c3:             return classConvertableFromTo( fromClass.getComponentType(), toClass.getComponentType(), mixTypes );
1:ffac5c3:         }
1:ffac5c3: 
1:eac0369: 		// When comparing two candidate methods to see which one is closer,
1:eac0369: 		// we want to mix object type and primitive type, because they could
1:eac0369: 		// both be chosen in the second pass.  But when deciding if a method
1:eac0369: 		// is qualified (to be a candidate), we do not want to mix types at
1:eac0369: 		// any time, the reason is that we can NOT do more than one step
1:eac0369: 		// conversion: for example, input parameter is BigDecimal, we convert
1:eac0369: 		// it to double for method resolution, we can NOT convert it again to
1:eac0369: 		// Double to match a method. "(paramTypes, primParamTypes)" already
1:eac0369: 		// includes all the one-step conversions.  But at any time we do want
1:eac0369: 		// to see if two primitives are convertable.
1:eac0369: 		if ((!(toClass.isPrimitive() && fromClass.isPrimitive())) && (!mixTypes))
1:7b398e9: 			return false;
1:eac0369: 
1:eac0369: 		// There are nine predefined Class objects to represent the eight 
1:eac0369: 		// primitive Java types and void.  We also handle prim vs. non-prim
1:eac0369: 		// conversion of the same type.  boolean and double are only convertable
1:eac0369: 		// to themseleves.  void should never be seen here.  In the second pass
1:eac0369: 		// we treat primitive type and the corrsponding non-primitive type
1:eac0369: 		// uniformly
1:eac0369: 
1:eac0369: 		String fromName = fromClass.getName(), toName = toClass.getName();
1:eac0369: 		if ((fromClass == Boolean.TYPE) || fromName.equals(nonPrimTypeNames[0]))
1:b50def6: 		{
1:eac0369: 			if ((toClass == Boolean.TYPE) || toName.equals(nonPrimTypeNames[0]))
1:eac0369: 				return true;
1:eac0369: 		} else if ((fromClass == Byte.TYPE) || fromName.equals(nonPrimTypeNames[1]))
1:eac0369: 		{
1:eac0369: 			if ((toClass == Byte.TYPE) || toName.equals(nonPrimTypeNames[1]) ||
1:eac0369: 				// we never need to see if toClass is of wider "object" type,
1:eac0369: 				// because a wider "object" type and a narrower "primitive"
1:eac0369: 				// type can never both be candidate, eg, "int" and "Long" can
1:eac0369: 				// never both accomodate the same parameter; while "long" and
1:eac0369: 				// "Integer" can.
1:eac0369: 				(toClass == Short.TYPE) ||
2:eac0369: 				(toClass == Integer.TYPE) ||
3:eac0369: 				(toClass == Long.TYPE) ||
4:eac0369: 				(toClass == Float.TYPE) ||
5:eac0369: 				(toClass == Double.TYPE) )
1:eac0369: 				return true;
1:eac0369: 		} else if ((fromClass == Character.TYPE) || fromName.equals(nonPrimTypeNames[2]))
1:eac0369: 		{
1:eac0369: 			if ((toClass == Character.TYPE) || toName.equals(nonPrimTypeNames[2]) ||
1:eac0369: 				(toClass == Integer.TYPE) ||
1:eac0369: 				(toClass == Long.TYPE) ||
1:eac0369: 				(toClass == Float.TYPE) ||
1:eac0369: 				(toClass == Double.TYPE) )
1:eac0369: 				return true;
1:eac0369: 		} else if ((fromClass == Short.TYPE) || fromName.equals(nonPrimTypeNames[3]))
1:eac0369: 			{
1:7827537: 			if ((toClass == Short.TYPE) || toName.equals(nonPrimTypeNames[4]) )
1:eac0369: 				return true;
1:eac0369: 		} else if ((fromClass == Integer.TYPE) || fromName.equals(nonPrimTypeNames[4]))
1:eac0369: 		{
1:7542aac: 			if ((toClass == Integer.TYPE) || toName.equals(nonPrimTypeNames[4]) )
1:eac0369: 				return true;
1:eac0369: 		} else if ((fromClass == Long.TYPE) || fromName.equals(nonPrimTypeNames[5]))
1:eac0369: 		{
1:7542aac: 			if ((toClass == Long.TYPE) || toName.equals(nonPrimTypeNames[5]) )
1:eac0369: 				return true;
1:eac0369: 		} else if ((fromClass == Float.TYPE) || fromName.equals(nonPrimTypeNames[6]))
1:eac0369: 		{
1:7542aac: 			if ((toClass == Float.TYPE) || toName.equals(nonPrimTypeNames[6]) )
1:eac0369: 				return true;
1:eac0369: 		} else if ((fromClass == Double.TYPE) || fromName.equals(nonPrimTypeNames[7]))
1:eac0369: 		{
1:eac0369: 			if ((toClass == Double.TYPE) || toName.equals(nonPrimTypeNames[7]))
1:eac0369: 				return true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Translate a JVM-style type descriptor to a Java-language-style type
1:eac0369: 	 * name.
1:eac0369: 	 *
1:6b50965: 	 * @param clazz		The String that contains the JVM type name
1:eac0369: 	 *
1:eac0369: 	 * @return	The Java-language-style type name
1:eac0369: 	 */
1:eac0369: 	public static String readableClassName(Class clazz)
1:eac0369: 	{
1:eac0369: 		if (!clazz.isArray())
1:eac0369: 			return clazz.getName();
1:eac0369: 
1:eac0369: 		int arrayDepth = 0;
1:eac0369: 		do {
1:eac0369: 			arrayDepth++;
1:eac0369: 			clazz = clazz.getComponentType();
1:eac0369: 		} while (clazz.isArray());
1:eac0369: 
1:eac0369: 		StringBuffer sb = new StringBuffer(clazz.getName());
1:eac0369: 
1:eac0369: 		for (int i = 0; i < arrayDepth; i++) {
1:eac0369: 			sb.append("[]");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return sb.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the declaring class for a method.
1:eac0369: 	 *
1:eac0369: 	 * @param method	A Member describing a method
1:eac0369: 	 *
1:eac0369: 	 * @return	A String with the declaring class
1:eac0369: 	 *
1:eac0369: 	 * @see Member#getDeclaringClass
1:eac0369: 	 */
1:eac0369: 	public String getDeclaringClass(Member method)
1:eac0369: 	{
1:eac0369: 		return method.getDeclaringClass().getName();
1:7b398e9: 	}		
1:7b398e9: 
1:4e5e965:     /////////////////////////////////////////////////////////////////////////
1:4e5e965:     //
1:4e5e965:     // MINIONS FOR getTypeBounds()
1:4e5e965:     //
1:4e5e965:     /////////////////////////////////////////////////////////////////////////
1:4e5e965: 
1:4e5e965:     /**
1:4e5e965:      * Get the type bounds for all of the type variables of the given
1:4e5e965:      * parameterized type.
1:4e5e965:      */
1:4e5e965:     private Class[][] findTypeBounds(ParameterizedType pt) {
1:4e5e965:         Type[] actualTypeArguments = pt.getActualTypeArguments();
1:4e5e965:         int argCount = actualTypeArguments.length;
1:4e5e965:         Class[][] retval = new Class[argCount][];
1:4e5e965: 
1:4e5e965:         for (int i = 0; i < argCount; i++) {
1:4e5e965:             retval[ i] = boundType(actualTypeArguments[ i]);
1:4e5e965:         }
1:4e5e965: 
1:4e5e965:         return retval;
1:4e5e965:     }
1:4e5e965: 
1:4e5e965:     /**
1:4e5e965:      * Get the bounds for a single type variable.
1:4e5e965:      */
1:4e5e965:     private Class[] boundType(Type type) {
1:4e5e965:         if (type instanceof Class) {
1:4e5e965:             return new Class[]{(Class) type};
1:4e5e965:         } else if (type instanceof TypeVariable) {
1:4e5e965:             Type[] bounds = ((TypeVariable) type).getBounds();
1:4e5e965:             int count = bounds.length;
1:4e5e965:             Class[] retval = new Class[count];
1:4e5e965: 
1:4e5e965:             for (int i = 0; i < count; i++) {
1:4e5e965:                 retval[ i] = getRawType(bounds[ i]);
1:4e5e965:             }
1:4e5e965: 
1:4e5e965:             return retval;
1:4e5e965:         } else {
1:4e5e965:             return null;
1:4e5e965:         }
1:4e5e965:     }
1:4e5e965: 
1:4e5e965:     /**
1:4e5e965:      * Get the raw type of a type bound.
1:4e5e965:      */
1:4e5e965:     private Class getRawType(Type bound) {
1:4e5e965:         if (bound instanceof Class) {
1:4e5e965:             return (Class) bound;
1:4e5e965:         } else if (bound instanceof ParameterizedType) {
1:4e5e965:             return getRawType(((ParameterizedType) bound).getRawType());
1:4e5e965:         } else {
1:4e5e965:             return null;
1:4e5e965:         }
1:4e5e965:     }
1:4e5e965: 
1:4e5e965:     /////////////////////////////////////////////////////////////////////////
1:4e5e965:     //
1:4e5e965:     // MINIONS FOR getGenericParameterTypes()
1:4e5e965:     //
1:4e5e965:     /////////////////////////////////////////////////////////////////////////
1:4e5e965: 
1:4e5e965:     /**
1:4e5e965:      * Construct an inheritance chain of types stretching from a supertype down
1:4e5e965:      * to a concrete implementation.
1:4e5e965:      */
1:4e5e965:     private ArrayList<Class<?>> getTypeChain(Class<?> chainEnd, Class<?> start) {
1:4e5e965:         ArrayList<Class<?>> result = null;
1:4e5e965: 
1:4e5e965:         if (start == null) {
1:4e5e965:             return null;
1:4e5e965:         }
1:4e5e965: 
1:4e5e965:         if (!chainEnd.isAssignableFrom(start)) {
1:4e5e965:             return null;
1:4e5e965:         }
1:4e5e965: 
1:4e5e965:         if (start == chainEnd) {
1:4e5e965:             result = new ArrayList<Class<?>>();
1:4e5e965:         }
1:4e5e965: 
1:4e5e965:         if (result == null) {
1:4e5e965:             result = getTypeChain(chainEnd, start.getSuperclass());
1:4e5e965: 
1:4e5e965:             if (result == null) {
1:4e5e965:                 for (Class<?> iface : start.getInterfaces()) {
1:4e5e965:                     result = getTypeChain(chainEnd, iface);
1:4e5e965:                     if (result != null) {
1:4e5e965:                         break;
1:4e5e965:                     }
1:4e5e965:                 }
1:4e5e965:             }
1:4e5e965:         }
1:4e5e965: 
1:4e5e965:         if (result != null) {
1:4e5e965:             result.add(start);
1:4e5e965:         }
1:4e5e965: 
1:4e5e965:         return result;
1:4e5e965:     }
1:4e5e965: 
1:4e5e965:     /**
1:4e5e965:      * Given an inheritance chain of types, stretching from a superclass down
1:4e5e965:      * to a terminal concrete class, construct a map of generic types to their
1:4e5e965:      * resolved types.
1:4e5e965:      */
1:4e5e965:     private HashMap<Type, Type> getResolvedTypes(ArrayList<Class<?>> chain) {
1:4e5e965:         if (chain == null) {
1:4e5e965:             return null;
1:4e5e965:         }
1:4e5e965: 
1:4e5e965:         HashMap<Type, Type> resolvedTypes = new HashMap<Type, Type>();
1:4e5e965: 
1:4e5e965:         for (Class<?> klass : chain) {
1:4e5e965:             addResolvedTypes(resolvedTypes, klass.getGenericSuperclass());
1:4e5e965: 
1:4e5e965:             for (Type iface : klass.getGenericInterfaces()) {
1:4e5e965:                 addResolvedTypes(resolvedTypes, iface);
1:4e5e965:             }
1:4e5e965:         }
1:4e5e965: 
1:4e5e965:         return resolvedTypes;
1:4e5e965:     }
1:4e5e965: 
1:4e5e965:     /**
1:4e5e965:      * Given a generic type, add its parameter types to an evolving
1:4e5e965:      * map of resolved types. Some of the resolved types may be
1:4e5e965:      * generic type variables which will need further resolution from
1:4e5e965:      * other generic types.
1:4e5e965:      */
1:4e5e965:     private void addResolvedTypes(HashMap<Type, Type> resolvedTypes,
1:4e5e965:                                   Type genericType) {
1:4e5e965:         if (genericType == null) {
1:4e5e965:             return;
1:4e5e965:         }
1:4e5e965: 
1:4e5e965:         if (genericType instanceof ParameterizedType) {
1:4e5e965:             ParameterizedType pt = (ParameterizedType) genericType;
1:4e5e965:             Class rawType = (Class) pt.getRawType();
1:4e5e965: 
1:4e5e965:             Type[] actualTypeArguments = pt.getActualTypeArguments();
1:4e5e965:             TypeVariable[] typeParameters = rawType.getTypeParameters();
1:4e5e965:             for (int i = 0; i < actualTypeArguments.length; i++) {
1:4e5e965:                 resolvedTypes.put(typeParameters[i], actualTypeArguments[i]);
1:4e5e965:             }
1:4e5e965:         }
1:4e5e965:     }
1:4e5e965: 
1:4e5e965:     /**
1:4e5e965:      * Given a map of resolved types, compose them together in order
1:4e5e965:      * to resolve the actual concrete types that are plugged into the
1:4e5e965:      * parameterized type.
1:4e5e965:      */
1:4e5e965:     private ArrayList<Class<?>> getParameterTypes(
1:4e5e965:             Class<?> parameterizedType, HashMap<Type, Type> resolvedTypes) {
1:4e5e965:         if (resolvedTypes == null) {
1:4e5e965:             return null;
1:4e5e965:         }
1:4e5e965: 
1:4e5e965:         Type[] actualTypeArguments = parameterizedType.getTypeParameters();
1:4e5e965: 
1:4e5e965:         ArrayList<Class<?>> result = new ArrayList<Class<?>>();
1:4e5e965: 
1:4e5e965:         // resolve types by composing type variables.
1:4e5e965:         for (Type baseType : actualTypeArguments) {
1:4e5e965:             while (resolvedTypes.containsKey(baseType)) {
1:4e5e965:                 baseType = resolvedTypes.get(baseType);
1:4e5e965:             }
1:4e5e965: 
1:4e5e965:             result.add(getRawType(baseType));
1:4e5e965:         }
1:4e5e965: 
1:4e5e965:         return result;
1:4e5e965:     }
1:eac0369: }
1:eac0369: 
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:3bcc92e
/////////////////////////////////////////////////////////////////////////
0: 	 * Determine whether or not the received class can be
0: 	 * loaded.
1: 	 *
0: 	 * @param className The name of the class in question
0: 	 * @return True if className can be loaded, false otherwise
1: 	 */
0: 	public static boolean classIsLoadable(String className)
1: 	{
1: 		try {
1: 
0: 			Class.forName(className);
1: 			return true;
1: 
0: 		} catch (ClassNotFoundException ce) {
1: 			return false;
0: 		} catch (LinkageError ce) {
1: 			return false;
1: 		}
1: 	}
1: 
1: 	/**
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:     public Class<?>[] getGenericParameterTypes(
1:             Class parameterizedType, Class implementation )
/////////////////////////////////////////////////////////////////////////
1:         return parameterTypes.toArray(new Class<?>[parameterTypes.size()]);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4e5e965
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:      * the bounds on the type variables. May return null if type resolution
1:      * fails.
1:         if ( implementation == null ) { return null; }
1: 
1:         Type[]  genericInterfaces = implementation.getGenericInterfaces();
1:         for ( Type genericInterface : genericInterfaces )
1:         {
1:             //
1:             // Look for the generic interface whose raw type is the
1:             // parameterized interface we're interested in.
1:             //
1:             if ( genericInterface instanceof ParameterizedType )
1:             {
1:                 ParameterizedType   pt = (ParameterizedType) genericInterface;
1:                 Type    rawType = pt.getRawType();
1: 
1:                 // found it!
1:                 if ( parameterizedInterface == rawType )
1:                 {
1:                     return findTypeBounds( pt );
1:                 }
1:             }
1:         }
1: 
1:         // couldn't find the interface we're looking for. check our superclass.
1:         return getTypeBounds( parameterizedInterface, implementation.getSuperclass() );
1: 
1:         if (member instanceof Method) {
1:             return ((Method) member).isVarArgs();
1:         } else if (member instanceof Constructor) {
1:             return ((Constructor) member).isVarArgs();
1:         } else {
1:             return false;
1:         }
1: 
1:      * the actual types of the interface type variables.
1:      * May return null or an array of nulls if type resolution fails.
1:         // construct the inheritance chain stretching from the parameterized
1:         // type down to the concrete implemention
1:         ArrayList<Class<?>> chain =
1:                 getTypeChain(parameterizedType, implementation);
1: 
1:         // walk the chain, filling in a map of generic types to their
1:         // resolved types
1:         HashMap<Type, Type> resolvedTypes = getResolvedTypes(chain);
1: 
1:         // compose the resolved types together in order to compute the actual
1:         // classes which are plugged into the variables of the parameterized
1:         // type
1:         ArrayList<Class<?>> parameterTypes =
1:                 getParameterTypes(parameterizedType, resolvedTypes);
1: 
1:         // turn the list into an array
1:         if (parameterTypes == null) {
1:             return null;
1:         }
1: 
0:         return parameterTypes.toArray(new Class[parameterTypes.size()]);
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     // MINIONS FOR getTypeBounds()
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Get the type bounds for all of the type variables of the given
1:      * parameterized type.
1:      */
1:     private Class[][] findTypeBounds(ParameterizedType pt) {
1:         Type[] actualTypeArguments = pt.getActualTypeArguments();
1:         int argCount = actualTypeArguments.length;
1:         Class[][] retval = new Class[argCount][];
1: 
1:         for (int i = 0; i < argCount; i++) {
1:             retval[ i] = boundType(actualTypeArguments[ i]);
1:         }
1: 
1:         return retval;
1:     }
1: 
1:     /**
1:      * Get the bounds for a single type variable.
1:      */
1:     private Class[] boundType(Type type) {
1:         if (type instanceof Class) {
1:             return new Class[]{(Class) type};
1:         } else if (type instanceof TypeVariable) {
1:             Type[] bounds = ((TypeVariable) type).getBounds();
1:             int count = bounds.length;
1:             Class[] retval = new Class[count];
1: 
1:             for (int i = 0; i < count; i++) {
1:                 retval[ i] = getRawType(bounds[ i]);
1:             }
1: 
1:             return retval;
1:         } else {
1:             return null;
1:         }
1:     }
1: 
1:     /**
1:      * Get the raw type of a type bound.
1:      */
1:     private Class getRawType(Type bound) {
1:         if (bound instanceof Class) {
1:             return (Class) bound;
1:         } else if (bound instanceof ParameterizedType) {
1:             return getRawType(((ParameterizedType) bound).getRawType());
1:         } else {
1:             return null;
1:         }
1:     }
1: 
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     // MINIONS FOR getGenericParameterTypes()
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Construct an inheritance chain of types stretching from a supertype down
1:      * to a concrete implementation.
1:      */
1:     private ArrayList<Class<?>> getTypeChain(Class<?> chainEnd, Class<?> start) {
1:         ArrayList<Class<?>> result = null;
1: 
1:         if (start == null) {
1:             return null;
1:         }
1: 
1:         if (!chainEnd.isAssignableFrom(start)) {
1:             return null;
1:         }
1: 
1:         if (start == chainEnd) {
1:             result = new ArrayList<Class<?>>();
1:         }
1: 
1:         if (result == null) {
1:             result = getTypeChain(chainEnd, start.getSuperclass());
1: 
1:             if (result == null) {
1:                 for (Class<?> iface : start.getInterfaces()) {
1:                     result = getTypeChain(chainEnd, iface);
1:                     if (result != null) {
1:                         break;
1:                     }
1:                 }
1:             }
1:         }
1: 
1:         if (result != null) {
1:             result.add(start);
1:         }
1: 
1:         return result;
1:     }
1: 
1:     /**
1:      * Given an inheritance chain of types, stretching from a superclass down
1:      * to a terminal concrete class, construct a map of generic types to their
1:      * resolved types.
1:      */
1:     private HashMap<Type, Type> getResolvedTypes(ArrayList<Class<?>> chain) {
1:         if (chain == null) {
1:             return null;
1:         }
1: 
1:         HashMap<Type, Type> resolvedTypes = new HashMap<Type, Type>();
1: 
1:         for (Class<?> klass : chain) {
1:             addResolvedTypes(resolvedTypes, klass.getGenericSuperclass());
1: 
1:             for (Type iface : klass.getGenericInterfaces()) {
1:                 addResolvedTypes(resolvedTypes, iface);
1:             }
1:         }
1: 
1:         return resolvedTypes;
1:     }
1: 
1:     /**
1:      * Given a generic type, add its parameter types to an evolving
1:      * map of resolved types. Some of the resolved types may be
1:      * generic type variables which will need further resolution from
1:      * other generic types.
1:      */
1:     private void addResolvedTypes(HashMap<Type, Type> resolvedTypes,
1:                                   Type genericType) {
1:         if (genericType == null) {
1:             return;
1:         }
1: 
1:         if (genericType instanceof ParameterizedType) {
1:             ParameterizedType pt = (ParameterizedType) genericType;
1:             Class rawType = (Class) pt.getRawType();
1: 
1:             Type[] actualTypeArguments = pt.getActualTypeArguments();
1:             TypeVariable[] typeParameters = rawType.getTypeParameters();
1:             for (int i = 0; i < actualTypeArguments.length; i++) {
1:                 resolvedTypes.put(typeParameters[i], actualTypeArguments[i]);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Given a map of resolved types, compose them together in order
1:      * to resolve the actual concrete types that are plugged into the
1:      * parameterized type.
1:      */
1:     private ArrayList<Class<?>> getParameterTypes(
1:             Class<?> parameterizedType, HashMap<Type, Type> resolvedTypes) {
1:         if (resolvedTypes == null) {
1:             return null;
1:         }
1: 
1:         Type[] actualTypeArguments = parameterizedType.getTypeParameters();
1: 
1:         ArrayList<Class<?>> result = new ArrayList<Class<?>>();
1: 
1:         // resolve types by composing type variables.
1:         for (Type baseType : actualTypeArguments) {
1:             while (resolvedTypes.containsKey(baseType)) {
1:                 baseType = resolvedTypes.get(baseType);
1:             }
1: 
1:             result.add(getRawType(baseType));
1:         }
1: 
1:         return result;
1:     }
commit:c6892a1
/////////////////////////////////////////////////////////////////////////
1: 	 * A untyped null parameter is indicated by passing in an empty string ("")
1: 	 If receiverType represents an interface then the methods of java.lang.Object
1: 	 are included in the candidate list.
/////////////////////////////////////////////////////////////////////////
1: 	   If false the last parameter is matched as usual. This also requires an exact match on the last parameter type.
/////////////////////////////////////////////////////////////////////////
1: 	   This follows the semantics of the java compiler for locating a field.
/////////////////////////////////////////////////////////////////////////
1: 	 * A untyped null parameter is indicated by passing in an empty string ("")
commit:5283796
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1: 		Class<?> clazz = getClass(className);
/////////////////////////////////////////////////////////////////////////
1: 		Class<?> theClass = getClass(className);
/////////////////////////////////////////////////////////////////////////
1: 			Class<?> receiverClass = getClass(receiverType);
/////////////////////////////////////////////////////////////////////////
1: 	public Class<?> getClass(String className) throws ClassNotFoundException {
commit:073b862
/////////////////////////////////////////////////////////////////////////
1: 			Class<?> toClass = getClass(toClassName);
1: 			Class<?> fromClass = getClass(fromClassName);
/////////////////////////////////////////////////////////////////////////
1: 		Class<?> receiverClass = getClass(receiverType);
/////////////////////////////////////////////////////////////////////////
1: 		Class<?> receiverClass = getClass(receiverType);
commit:232d09a
/////////////////////////////////////////////////////////////////////////
1: 	public Member findPublicMethod
1:         (
1:          String receiverType,
1:          String methodName,
1:          String[] parmTypes,
1:          String[] primParmTypes,
1:          boolean[] isParam,
1:          boolean staticMethod,
1:          boolean repeatLastParameter,
1:          boolean hasVarargs
1:          )
1:         throws ClassNotFoundException, StandardException
/////////////////////////////////////////////////////////////////////////
1:                 // If the routine was declared to be varargs, then we eliminate
1:                 // all non-varargs methods from consideration
1:                 if ( hasVarargs && !isVarArgsMethod( methods[index] ) ) { continue; }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		return resolveMethod
1:             (
1:              receiverClass, methodName, paramClasses,
1:              primParamClasses, isParam, staticMethod, repeatLastParameter, methodList,
1:              hasVarargs
1:              );
/////////////////////////////////////////////////////////////////////////
1: 		return resolveMethod
1:             (
1:              receiverClass, "<init>", paramClasses, 
1:              primParamClasses, isParam, false, false,
1:              receiverClass.getConstructors(),
1:              false
1:              );
/////////////////////////////////////////////////////////////////////////
1: 	 * Return true if the method or constructor supports varargs.
1: 	 */
1: 	public boolean  isVarArgsMethod( Member member )
1: 	{
0:         // Varargs were introduced by Java 5. So this 1.4 ClassInspector always
0:         // return false;
1:         return false;
1:     }
1:     
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	private Member resolveMethod
1:         (
1:          Class receiverClass,
1:          String methodName,
1:          Class[] paramClasses,
1:          Class[] primParamClasses,
1:          boolean[] isParam,
1:          boolean staticMethod,
1:          boolean repeatLastParameter,
1:          Member[] methods,
1:          boolean hasVarargs
1:          )
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:                     // If the routine was declared to be varargs, then we eliminate
1:                     // all non-varargs methods from consideration
1: 					if ( hasVarargs && !isVarArgsMethod( currentMethod )) {
1: 						methods[i] = null; // remove non-applicable methods
1: 						continue;
1: 					}
1: 
commit:0ad97c9
/////////////////////////////////////////////////////////////////////////
1: 	 * Given an implementation of a parameterized interface, return
0:      * the actual types of the interface type variables. This method raises an exception if the
0:      * JVM does not support generics. May return null or an array of nulls if type resolution fails.
1: 	 */
0:     public Class[] getGenericParameterTypes( Class parameterizedType, Class implementation )
1:         throws StandardException
1: 	{
0: 		throw StandardException.newException( SQLState.VM_LEVEL_TOO_LOW, "Java 5" );
1:     }
1:     
1: 	/**
commit:d861c23
/////////////////////////////////////////////////////////////////////////
1: 	 * Given an implementation of a parameterized interface, return
0:      * the bounds on the type variables. This method raises an exception if the
1: 	public Class[][] getTypeBounds( Class parameterizedInterface, Class implementation )
commit:c8603c4
/////////////////////////////////////////////////////////////////////////
1: public class ClassInspector
/////////////////////////////////////////////////////////////////////////
0: 	 * Given an implementation of a parameterized class/interface, return
0:      * the actual concrete types of the parameters. Types are returned in the
0:      * order that they are declared by the parameterized class/interface.
0:      * So for instance, if the parameterized class is Map&lt;K,V&gt; and the
0:      * implementation is HashMap&lt;Integer,String&gt;, then the return value is
0:      * [ Integer.class, String.class ]. This method raises an exception if the
0:      * JVM does not support generics. May return null if type resolution fails.
1: 	 */
0: 	public Class[] getGenericParameterTypes( Class parameterizedType, Class implementation )
1:         throws StandardException
1: 	{
0: 		throw StandardException.newException( SQLState.VM_LEVEL_TOO_LOW, "Java 5" );
1:     }
1:     
1: 	/**
commit:ffac5c3
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // OUT and INOUT args are arrays. Compare the cell types rather than the array types.
1:         //
1:         if ( fromClass.isArray() && toClass.isArray() )
1:         {
1:             return classConvertableFromTo( fromClass.getComponentType(), toClass.getComponentType(), mixTypes );
1:         }
1: 
commit:7294977
/////////////////////////////////////////////////////////////////////////
1:         // ANSI rules do not allow widening
1:         if ( fromClass.getName().equals( toClass.getName() ) ) { return true; }
commit:886e6e1
/////////////////////////////////////////////////////////////////////////
1:     private static final String BIGDECIMAL_TYPE_NAME = "java.math.BigDecimal";
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // Also don't allow the widening of BigDecimal to Object. Otherwise, the
0:         // SQL signature
1:         //
0:         //    f( a numeric( 7, 2 ) ) returns numeric( 7, 2 )
1:         //
0:         // will incorrectly match the Java signature
1:         //
0:         //   public static BigDecimal f( Object a )
1:         //
1:         //
0:               (
0:                STRING_TYPE_NAME.equals( fromClass.getName() ) ||
0:                BIGDECIMAL_TYPE_NAME.equals( fromClass.getName() )
0:                ) && OBJECT_TYPE_NAME.equals( toClass.getName() )
commit:b50def6
/////////////////////////////////////////////////////////////////////////
1:     private static final String OBJECT_TYPE_NAME = "java.lang.Object";
1:     private static final String STRING_TYPE_NAME = "java.lang.String";
1: 
/////////////////////////////////////////////////////////////////////////
1:         //
0:         // Don't allow widening of String to Object. Otherwise, the SQL
0:         // signature
1:         //
0:         //    f( a varchar( 10 ) ) returns varchar( 10 )
1:         //
0:         // will incorrectly match the Java signature
1:         //
0:         //   public static String f( Object a )
1:         //
0:         // For a description of the ANSI signature matching rules, see
0:         // DERBY-3652.
1:         //
0: 		if (
0:             !(
0:               STRING_TYPE_NAME.equals( fromClass.getName() ) &&
0:               OBJECT_TYPE_NAME.equals( toClass.getName() )
0:               ) &&
0:             toClass.isAssignableFrom(fromClass)
0:             )
1:         {            
commit:6886d9e
/////////////////////////////////////////////////////////////////////////
0:                 //
1:                 // Before the fixes to DERBY-3652, we used to weed out
1:                 // ambiguities by applying the rules from section 15.11
1:                 // of the Java Language Specification. These are not the
1:                 // ANSI resolution rules however. The code to weed out
1:                 // ambiguities has been removed.
0:                 //
commit:7827537
/////////////////////////////////////////////////////////////////////////
1: 			if ((toClass == Short.TYPE) || toName.equals(nonPrimTypeNames[4]) )
commit:7542aac
/////////////////////////////////////////////////////////////////////////
1: 			if ((toClass == Integer.TYPE) || toName.equals(nonPrimTypeNames[4]) )
1: 			if ((toClass == Long.TYPE) || toName.equals(nonPrimTypeNames[5]) )
1: 			if ((toClass == Float.TYPE) || toName.equals(nonPrimTypeNames[6]) )
commit:5c04fbc
/////////////////////////////////////////////////////////////////////////
1:      *
1:      *  The preceding paragraph is a bit misleading. As of release 10.4, the
1:      *  second pass did not consider arbitrary combinations of primitive and
1:      *  wrapper types. This is because the first pass removed from consideration
1:      *  candidates which would be allowed under ANSI rules. As a fix for bug
1:      *  DERBY-3652, we now allow primitive and wrapper type matches during
1:      *  the first pass. The ANSI rules are documented in DERBY-3652.
1:      *
/////////////////////////////////////////////////////////////////////////
0:                 //
1:                 // According to the ANSI rules, primitives and their
1:                 // corresponding wrapper types are equally good for resolving
1:                 // numeric arguments of user-coded functions and procedures. See
1:                 // DERBY-3652 for a description of the ANSI rules.
0:                 //
1: 				// can the required signature be converted to those of this method?
1: 							currentMethodParameters, isParam, true)) {
commit:68573fc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		// an exact match lookup.
1: 		if (paramClasses.length == 0) {
1: 
1: 			try {
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 						// regular match on parameter count
1: 						if (currentMethodParameters.length != paramClasses.length) {
/////////////////////////////////////////////////////////////////////////
0: 							currentMethodParameters, isParam, false)) {
/////////////////////////////////////////////////////////////////////////
1: 		return methods[candidateIndex];
/////////////////////////////////////////////////////////////////////////
0: 		return signatureConvertableFromTo(TC, null, UC, isParam, true);
/////////////////////////////////////////////////////////////////////////
1: 												 boolean mixTypes) {
1: 		if (toTypes.length < checkCount)
1: 			Class toClass = toTypes[i];
/////////////////////////////////////////////////////////////////////////
commit:7b398e9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.info.JVMInfo;
1: 
/////////////////////////////////////////////////////////////////////////
0: 		// an exact match lookup. this short-circuiting will not work if the VM
0: 		// level supports varargs--this is because no arguments at all will
0: 		// still match a signature which is just a varargs argument
0: 		if ( !vmSupportsVarargs() && (paramClasses.length == 0) ) {
1:             try {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Class[]    varargsType = new Class[ methods.length ];
/////////////////////////////////////////////////////////////////////////
0:                 if ( firstTimeAround ) { varargsType[ i ] = getVarargsType( currentMethod ); }
1: 
/////////////////////////////////////////////////////////////////////////
0: 						// regular match on parameter count. a varargs method
0: 						// can have fewer arguments than the invoking expression.
0: 						if (
0:                             ( ( (currentMethodParameters.length-1) > paramClasses.length) && (varargsType[ i ] != null) ) ||
0:                             ( (currentMethodParameters.length != paramClasses.length) && (varargsType[ i ] == null) )
0:                             )
1:                         {
/////////////////////////////////////////////////////////////////////////
0:                                                 currentMethodParameters, isParam, false, varargsType[ i ])) {
/////////////////////////////////////////////////////////////////////////
1: 
0:         return methods[candidateIndex];
/////////////////////////////////////////////////////////////////////////
0: 		return signatureConvertableFromTo(TC, null, UC, isParam, true, null);
/////////////////////////////////////////////////////////////////////////
0: 	 *	@param varargsType  non-array type of last toTypes if the method/constructor has a varargs signature
0:                                                boolean mixTypes, Class varargsType) {
0: 		if ( (toTypes.length < checkCount) && (varargsType == null) )
0: 			Class toClass;
1: 
0:             // if the candidate method has a varargs signature, then the
0:             // concluding types must all be the type of the candidate's
0:             // last argument
0:             if ( (i >= (toTypes.length-1)) && (varargsType != null) )
1:             {
0:                 toClass = varargsType;
1:             }
0:             else { toClass = toTypes[ i ]; }
/////////////////////////////////////////////////////////////////////////
1:     /**
0: 	 * Get the type of the final, varargs argument to a method or
0: 	 * constructor. This is the base type (we strip off the array
0: 	 * marker). Returns null if this is not a varargs method or constructor.
1: 	 */
0: 	public static     Class    getVarargsType( Member member )
1: 	{
0:         if ( !memberHasVarargs( member ) ) { return null; }
1:         
1: 		Class[] parameterClasses;
0: 		if (member instanceof Method) {
0: 			parameterClasses = ((Method) member).getParameterTypes();
1: 		} else {
0: 			parameterClasses = ((Constructor) member).getParameterTypes();
1: 		}
0:         Class   lastParamType = parameterClasses[ parameterClasses.length - 1 ];
1: 
0:         // now strip off the array wrapper
0:         lastParamType = lastParamType.getComponentType();
1: 
0:         return lastParamType;
1:     }		
1: 
1:     /**
0: 	 * Report whether a method or constructor has a variable argument list at
0: 	 * the end. We use reflection so that we can compile this support on and for
0: 	 * versions of Java prior to Java 5.
1: 	 */
0: 	public static   boolean  memberHasVarargs( Member member )
1: 	{
0:         if ( !vmSupportsVarargs() ) { return false; }
1: 
1:         try {
0:             Method      isVarargsMethod = member.getClass().getMethod( "isVarArgs", null );
1: 
0:             return ((Boolean) isVarargsMethod.invoke( member, null )).booleanValue();
1:         }
0:         catch (Exception e)
1:         {
1:             return false;
1:         }
1: 	}		
1: 
1:     /**
0: 	 * Report whether the VM supports varargs in method signatures.
1: 	 */
0: 	public static   boolean  vmSupportsVarargs()
1: 	{
0:         return (JVMInfo.JDK_ID >= JVMInfo.J2SE_15);
1: 	}		
1: 
commit:6baf18b
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Lily Wei
-------------------------------------------------------------------------------
commit:a9c3863
/////////////////////////////////////////////////////////////////////////
1: 			StringBuffer parmTypesString = new StringBuffer();
1: 					parmTypesString.append(", ");
1: 				parmTypesString.append(paramClasses[i] == null ? "null" : paramClasses[i].getName());
1: 					parmTypesString.append("(").append(primParamClasses[i].getName()).append(")");
1: 												parmTypesString.toString());
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param member		A Member representing the method for
/////////////////////////////////////////////////////////////////////////
1: 	 * @param receiverType	The class name of the receiver
/////////////////////////////////////////////////////////////////////////
1: 	 * @param receiverType	The class name of the receiver
/////////////////////////////////////////////////////////////////////////
1: 	 *  @param methods			method stack
/////////////////////////////////////////////////////////////////////////
1: 	 * @param clazz		The String that contains the JVM type name
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:2542f1d
/////////////////////////////////////////////////////////////////////////
1: 		@exception ClassNotFoundException Class cannot be found, or
1: 		a SecurityException or LinkageException was thrown loading the class.
commit:4d80643
/////////////////////////////////////////////////////////////////////////
commit:f52a50f
/////////////////////////////////////////////////////////////////////////
0: import java.util.StringTokenizer;
0: import java.util.List;
0: import java.util.ArrayList;
0: import java.util.NoSuchElementException;
0: import java.util.Collections;
/////////////////////////////////////////////////////////////////////////
0: 		return resolveMethod(receiverClass, methodName, paramClasses,
0:     public Method findPublicMethod(String className, String signature, boolean isStatic) throws ClassNotFoundException {
0:         Class javaClass = getClass(className);
0:         StringTokenizer tokenizer = new StringTokenizer(signature, "(,)", true);
0:         try {
0:             String methodName = tokenizer.nextToken();
0:             if (!tokenizer.nextToken().equals("(")) {
1:                 return null;
1:             }
0:             List paramTypes;
0:             String token = tokenizer.nextToken();
0:             if (")".equals(token)) {
0:                 paramTypes = Collections.EMPTY_LIST;
1:             } else {
0:                 paramTypes = new ArrayList();
0:                 paramTypes.add(getClass(token));
0:                 while ((token = tokenizer.nextToken()).equals(",")) {
0:                     token = tokenizer.nextToken();
0:                     paramTypes.add(getClass(token));
1:                 }
1:             }
1: 
0:             Method method;
0:             try {
0:                 method = javaClass.getMethod(methodName, (Class[])paramTypes.toArray(new Class[paramTypes.size()]));
0:                 if (isStatic != Modifier.isStatic(method.getModifiers())) {
1:                     return null;
1:                 }
0:             } catch (NoSuchMethodException e) {
1:                 return null;
1:             }
1:             return method;
0:         } catch (NoSuchElementException e) {
1:             return null;
1:         }
1:     }
1: 
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.services.loader.ClassInspector
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.loader
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.services.loader;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import java.lang.reflect.*;
1: 
1: /**
1: 	Methods to find out relationships between classes and methods within a class.
1: 	All class names within this interface are treated as java language class names,
1: 	e.g. int, COM.foo.Myclass, int[], java.lang.Object[]. That is java internal
1: 	class names as defined in the class file format are not understood.
1: */
0: public final class ClassInspector
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	private static final String[] primTypeNames =
1: 		{"boolean", "byte", "char", "short", "int", "long", "float", "double"};
1: 
1: 	// collect these as static, instead of each time allocates these new
1: 	// Strings for every method resolution
1: 
1: 	private static final String[] nonPrimTypeNames =
1: 		{"java.lang.Boolean", "java.lang.Byte", "java.lang.Character",
1: 		 "java.lang.Short", "java.lang.Integer", "java.lang.Long",
1: 		 "java.lang.Float", "java.lang.Double"};
1: 
1: 	private final ClassFactory cf;
1: 
1: 	/**
1: 		DO NOT USE! use the method in ClassFactory.
1: 	*/
1: 	public ClassInspector(ClassFactory cf) {
1: 		this.cf = cf;
1: 	}
1: 	
1: 	/**
1: 	 * Is the given object an instance of the named class?
1: 	 *
1: 	 * @param className	The name of the class
1: 	 * @param obj		The object to test to see if it's an instance
1: 	 *			of the named class
1: 	 *
1: 	 * @return	true if obj is an instanceof className, false if not
1: 	 */
1: 	public boolean instanceOf(String className, Object obj)
1: 		throws ClassNotFoundException
1: 	{
0: 		Class clazz = getClass(className);
1: 		// is className an untyped null
1: 		if (clazz == null)
1: 			return false;
1: 
1: 		return clazz.isInstance(obj);
1: 	}
1: 
1: 	/**
1: 	 * Is one named class assignable to another named class or interface?
1: 	 *
1: 	 * @param fromClassName	The name of the class to be assigned
1: 	 * @param toClassName	The name of the class to be assigned to
1: 	 *
1: 	 * @return	true if an object of type fromClass can be assigned to an
1: 	 *			object of type toClass, false if not.
1: 	 */
1: 	public boolean assignableTo(String fromClassName, String toClassName)
1: 	{
1: 		try
1: 		{
0: 			Class toClass = getClass(toClassName);
1: 			// is toClass an untyped null
1: 			if (toClass == null) {
1: 				return false;
1: 			}
1: 
0: 			Class fromClass = getClass(fromClassName);
1: 
1: 			// is fromClass an untyped null
1: 			if (fromClass == null)
1: 				return !toClass.isPrimitive() || (toClass == Void.TYPE);
1: 
1: 
1: 			return toClass.isAssignableFrom(fromClass);
1: 		}
1: 		catch (ClassNotFoundException cnfe)
1: 		{
1: 			/* If either class can't be found, they can't be assigned */
1: 			return false;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Does the named class exist, and is it accessible?
1: 	 *
1: 	 * @param className	The name of the class to test for existence
1: 	 *
1: 	 * @return	true if the class exists and is accessible, false if not
1: 	 */
1: 	public boolean accessible(String className)
1: 		throws ClassNotFoundException
1: 	{
0: 		Class theClass = getClass(className);
1: 		if (theClass == null)
1: 			return false;
1: 
1: 		/* Classes must be public to be accessible */
1: 		if (! Modifier.isPublic(theClass.getModifiers()))
1: 			return false;
1: 
1: 		return true;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Get the Java name of the return type from a Member representing
1: 	 * a method or the type of a Member representing a field.
1: 	 *
0: 	 * @param method		A Member representing the method for
1: 	 *						which we want the return type.
1: 	 *
1: 	 * @return	A Java-language-style string describing the return type of
1: 	 *			the method (for example, it returns "int" instead of "I".
1: 	 */
1: 	public String getType(Member member)
1: 	{
1: 		Class type;
1: 
1: 		if (member instanceof Method)
1: 			type = ((Method) member).getReturnType();
1: 		else if (member instanceof Field)
1: 			type = ((Field) member).getType();
1: 		else if (member instanceof Constructor)
1: 			type = ((Constructor) member).getDeclaringClass();
1: 		else
1: 			type = Void.TYPE;
1: 
1: 		return ClassInspector.readableClassName(type);
1: 	}
1: 
1: 
1: 	/**
1: 	 * Find a public method that implements a given signature.
1: 	 * The signature is given using the full Java class names of the types.
1: 	 <BR>
0: 	 * A untyped null paramter is indicated by passing in an empty string ("")
1: 	 * as its class name.
1: 	 <BR>
0: 	 If receiverType respresents an interface then the methods of java.lang.Object
0: 	 arer included in the candidate list.
1: 	 <BR>
1: 	 If the caller is simply checking to see that a public method with the
1: 	 specified name exists, regardless of the signature, exists, then the
1: 	 caller should pass in a null for parmTypes.  (This is useful for checking
1: 	 the validity of a method alias when creating one.)
1: 	 <BR>
1: 	 We use a two-pass algorithm to resolve methods.  In the first pass, we
1: 	 use all "object" types to try to match a method.  If this fails, in the
1: 	 second pass, an array of "primitive" types (if the parameter has one,
1: 	 otherwise the same object type is used) is passed in, as well as the
1: 	 "object" type array.  For each parameter of a method, we try to match it
1: 	 against either the "object" type, or the "primitive" type.  Of all the
1: 	 qualified candidate methods found, we choose the closest one to the input
1: 	 parameter types.  This involves comparing methods whose parameters are
1: 	 mixed "object" and "primitive" types in the second pass.  This is
1: 	 eventually handled in classConvertableFromTo.
1: 	 *
0: 	 * @param receiverTypes	The class name of the receiver
1: 	 * @param methodName	The name of the method
1: 	 * @param parmTypes		An array of class names representing the
1: 	 *						parameter types.  Pass a zero-element array if
1: 	 *						there are no parameters.  Pass a null if it is
1: 	 *						okay to match any signature.
1: 	 * @param primParmTypes This is used in the second pass of the two-pass
1: 	 *						method resolution algorithm.  Use primitive type
1: 	 *						if it has one, otherwise use same object type
1: 	 * @param isParam		Array of booleans telling whether parameter is a ?.
1: 	 * @param staticMethod	Find a static method.
1: 	   @param repeatLastParameter If true the last parameter may be repeated any number of times (total count must be greater than one).
0: 	   If false the laste parameter is matched as usual. This also requires an exact match on the last parameter type.
1: 	 *
1: 	 * @return	A Member representing the matching method.  Returns null
1: 	 *			if no such method.
1: 	 *
1: 	 * @exception ClassNotFoundException	One or more of the classes does
1: 	 *										not exist.
1: 	 * @exception StandardException			Thrown on ambiguous method invocation.
1: 	 *
1: 	 * @see	Member
1: 	 * @see Modifier
1: 	 */
0: 	public Member findPublicMethod(String receiverType,
0: 								String methodName,
1: 								String[] parmTypes,
1: 								String[] primParmTypes,
0: 								boolean[] isParam,
0: 								boolean staticMethod,
0: 								boolean repeatLastParameter)
1: 					throws ClassNotFoundException, StandardException
1: 	{
0: 		Class receiverClass = getClass(receiverType);
1: 		if (receiverClass == null)
1: 			return null;
1: 
1: 		// primitives don't have methods
1: 		// note that arrays do since they are objects they have
1: 		// all the methods of java.lang.Object
1: 		if (receiverClass.isPrimitive()) {
1: 			return null;
1: 		}
1: 
1: 		// if parmTypes is null, then the caller is simply 
1: 		// looking to see if any public method with the
1: 		// specified name exists, regardless of its signature
1: 		if (parmTypes == null) {
1: 			Method[] methods = receiverClass.getMethods();
1: 			
1: 			for (int index = 0; index < methods.length; index++) {
1: 				if (staticMethod) {
1: 					if (!Modifier.isStatic(methods[index].getModifiers())) {
1: 						continue;
1: 					}
1: 				}
1: 
1: 				if (methodName.equals(methods[index].getName())) {
1: 					// We found a match
1: 					return methods[index];
1: 				}
1: 			}
1: 			// No match
1: 			return null;
1: 		}
1: 
1: 		// convert the parameter types to classes
1: 		Class[] paramClasses = new Class[parmTypes.length];
1: 		Class[] primParamClasses = null;
1: 		if (primParmTypes != null)
1: 			primParamClasses = new Class[primParmTypes.length];
1: 		for (int i = 0; i < paramClasses.length; i++)
1: 		{
1: 			paramClasses[i] = getClass(parmTypes[i]);
1: 			if (primParmTypes == null)
1: 				continue;
1: 			if (primParmTypes[i].equals(parmTypes[i]))  // no separate primitive
1: 				primParamClasses[i] = null;
1: 			else
1: 				primParamClasses[i] = getClass(primParmTypes[i]);
1: 		}
1: 
1: 		// no overloading possible if there are no arguments, so perform
0: 		// an exact match lookup.
0: 		if (paramClasses.length == 0) {
1: 
0: 			try {
1: 				Method method = receiverClass.getMethod(methodName, paramClasses);
1: 
1: 				if (staticMethod) {
1: 					if (!Modifier.isStatic(method.getModifiers()))
1: 						return null;
1: 				}
1: 
1: 				return method;
1: 
1: 				} catch (NoSuchMethodException nsme2) {
1: 
1: 
1: 					// if we are an interface then the method could be defined on Object
1: 					if (!receiverClass.isInterface())
1: 						return null;
1: 				}
1: 		}
1: 
1: 		// now the tricky method resolution
1: 		Member[] methodList = receiverClass.getMethods();
1: 		// if we have an interface we need to add the methods of Object into the mix
1: 		if (receiverClass.isInterface()) {
1: 
1: 			Member[] objectMethods = java.lang.Object.class.getMethods();
1: 			if (methodList.length == 0) {
1: 				methodList = objectMethods;
1: 			} else {
1: 				Member[] set = new Member[methodList.length + objectMethods.length];
1: 				System.arraycopy(methodList, 0, set, 0, methodList.length);
1: 				System.arraycopy(objectMethods, 0, set, methodList.length, objectMethods.length);
1: 				methodList = set;
1: 			}
1: 		}
1: 
0: 		return resolveMethod(receiverClass, methodName, paramClasses, 
0: 						primParamClasses, isParam, staticMethod, repeatLastParameter, methodList);
1: 	}
1: 
1: 	/**
1: 	 * Find a public field  for a class.
0: 	   This follows the sematics of the java compiler for locating a field.
1: 	   This means if a field fieldName exists in the class with package, private or
1: 	   protected then an error is raised. Even if the field hides a field fieldName
1: 	   in a super-class/super--interface. See the JVM spec on fields.
1: 	 *
1: 	 * @param receiverType	The class name of the receiver
1: 	 * @param fieldName		The name of the field
1: 	 * @param staticField	Find a static field
1: 	 *
1: 	 * @return	A Member representing the matching field.  
1: 	 * @exception StandardException	Class or field does not exist or is not public or a security exception.
1: 	 *
1: 	 * @see	Member
1: 	 * @see Modifier
1: 	 */
1: 	public Member findPublicField(String receiverType,
1: 								String fieldName,
1: 								boolean staticField)
1: 					throws StandardException
1: 	{
1: 
1: 		Exception e = null;
0: 		try {
1: 
0: 			Class receiverClass = getClass(receiverType);
1: 			if (receiverClass == null)
1: 				return null;
1: 			if (receiverClass.isArray() || receiverClass.isPrimitive()) {
1: 				// arrays don't have fields (the fake field 'length' is not returned here)
1: 				return null;
1: 			}
1:   
1: 			int modifier = staticField ? (Modifier.PUBLIC | Modifier.STATIC) : Modifier.PUBLIC;
1: 
1: 			// Look for a public field first
1: 			Field publicField = receiverClass.getField(fieldName);
1: 
1: 			if ((publicField.getModifiers() & modifier) == modifier)
1: 			{
1: 				/*
1: 					If the class is an interface then we avoid looking for a declared field
1: 					that can hide a super-class's public field and not be accessable. This is because
1: 					a interface's fields are always public. This avoids a security check.
1: 				*/
1: 				if (receiverClass.isInterface() || (publicField.getDeclaringClass().equals(receiverClass)))
1: 					return publicField;
1: 
1: 				/*
1: 					Now check to see if there is a declared field that hides the public field.
1: 				*/
1: 
0: 				try {
1: 
1: 					Field declaredField = receiverClass.getDeclaredField(fieldName);
1: 
1: 					if (SanityManager.DEBUG) {
1: 
1: 						if ((declaredField.getModifiers() & Modifier.PUBLIC) == Modifier.PUBLIC)
1: 							SanityManager.THROWASSERT("declared field not expected to be public here " + declaredField);
1: 					}
1: 
1: 				} catch (NoSuchFieldException nsfe) {
1: 
1: 					// no field hides the public field in the super class
1: 					return publicField;
1: 				}
1: 			}
1: 
1: 		} catch (ClassNotFoundException cnfe) {
1: 			e = cnfe;
1: 		} catch (NoSuchFieldException nsfep) {
1: 			e = nsfep;
1: 		} catch (SecurityException se) {
1: 			e = se;
1: 		}
1: 
1: 		throw StandardException.newException(
1: 			staticField ? SQLState.LANG_NO_STATIC_FIELD_FOUND : SQLState.LANG_NO_FIELD_FOUND, 
1: 								e, fieldName, receiverType);
1: 	}
1: 
1: 	/**
1: 	 * Find a public constructor that implements a given signature.
1: 	 * The signature is given using the full Java class names of the types.
1: 	 <BR>
0: 	 * A untyped null paramter is indicated by passing in an empty string ("")
1: 	 * as its class name. 
1: 	 *
0: 	 * @param receiverTypes	The class name of the receiver
1: 	 * @param parmTypes		An array of class names representing the
1: 	 *						parameter types.  Pass a zero-element array if
1: 	 *						there are no parameters.
1: 	 * @param primParmTypes This is used in the second pass of the two-pass
1: 	 *						method resolution algorithm.  Use primitive type
1: 	 *						if it has one, otherwise use same object type
1: 	 * @param isParam		Array of booleans telling whether parameter is a ?.
1: 	 *
1: 	 * @return	A Member representing the matching constructor.  Returns null
1: 	 *			if no such constructor.
1: 	 *
1: 	 * @exception ClassNotFoundException	One or more of the classes does
1: 	 *										not exist.
1: 	 * @exception StandardException			Thrown on ambiguous constructor invocation.
1: 	 *
1: 	 * @see	Member
1: 	 * @see Modifier
1: 	 */
1: 	public Member findPublicConstructor(String receiverType,
1: 									String[] parmTypes,
1: 									String[] primParmTypes,
1: 									boolean[] isParam)
1: 						throws ClassNotFoundException, StandardException 
1: 	{
0: 		Class receiverClass = getClass(receiverType);
1: 		if (receiverClass == null)
1: 			return null;
1: 
1: 		// arrays, primitives, and interfaces do not have constructors
1: 		if (receiverClass.isArray() || receiverClass.isPrimitive() || receiverClass.isInterface()) {
1: 			return null;
1: 		}
1: 
1: 		// convert the parameter types to classes
1: 		Class[] paramClasses = new Class[parmTypes.length];
1: 		Class[] primParamClasses = null;
1: 		if (primParmTypes != null)
1: 			primParamClasses = new Class[primParmTypes.length];
1: 		boolean unknownParameters = false;
1: 		for (int i = 0; i < paramClasses.length; i++) {
1: 			paramClasses[i] = getClass(parmTypes[i]);
1: 			if (paramClasses[i] == null)
1: 				unknownParameters = true;
1: 			if (primParmTypes == null)
1: 				continue;
1: 			if (primParmTypes[i].equals(parmTypes[i]))  // no separate primitive
1: 				primParamClasses[i] = null;
1: 			else
1: 				primParamClasses[i] = getClass(primParmTypes[i]);
1: 		}
1: 
0: 		try {
1: 
1: 			if (!unknownParameters && (primParmTypes == null)) {
1: 				// look for an exact match for first pass
1: 				Member method = receiverClass.getConstructor(paramClasses);
1: 
1: 				return method;
1: 			}
1: 
1: 		} catch (NoSuchMethodException nsme) {
1: 
1: 			// no overloading possible if there are no arguments
1: 			if (paramClasses.length == 0)
1: 				return null;
1: 
1: 			// now the tricky method resolution
1: 		}
1: 
1: 		// name is only used for debugging
0: 		return resolveMethod(receiverClass, "<init>", paramClasses, 
0: 							 primParamClasses, isParam, false, false,
0: 							 receiverClass.getConstructors());
1: 	}
1: 
1: 	/**
1: 	 * Get the parameter types for a method described by a Member as a String[].
1: 	 *
1: 	 * @param method	A Member describing a method
1: 	 *
1: 	 * @return	A String[] describing the parameters of the method
1: 	 */
1: 	public String[] getParameterTypes(Member method)
1: 	{
1: 
0: 		Class[] parameterClasses;
1: 		if (method instanceof Method) {
1: 			parameterClasses = ((Method) method).getParameterTypes();
1: 		} else {
1: 			parameterClasses = ((Constructor) method).getParameterTypes();
1: 		}
1: 
1: 		String[] parameterTypes = new String[parameterClasses.length];
1: 
1: 		for (int i = 0; i < parameterTypes.length; i++) {
1: 			parameterTypes[i] = ClassInspector.readableClassName(parameterClasses[i]);
1: 		}
1: 
1: 		return parameterTypes;
1: 	}
1: 
1: 	/**
1: 	 * Determine whether a type is a Java primitive, like int or boolean
1: 	 *
1: 	 * @param typeName	The name of the Java type
1: 	 *
1: 	 * @return	true if it's a primitive type
1: 	 */
1: 	public static boolean primitiveType(String typeName)
1: 	{
1: 		for (int i = 0; i < primTypeNames.length; i++)
1: 		{
1: 			if (typeName.equals(primTypeNames[i]))
1: 				return true;
1: 		}
1: 
1: 		return false;
1: 	}
1: 
1: 
1: 	/**
1: 	 *  Tricky function to resolve a method.  If primParamClasses is null
1: 	 *  we know it's first pass.  First pass try to match as all "object"
1: 	 *  types, second pass try to match any combination of "object" and
1: 	 *  "primitive" types.  Find the closest match among all the qualified
1: 	 *  candidates.  If there's a tie, it's ambiguous.
1: 	 *
1: 	 *  @param receiverClass 	the class who holds the methods
1: 	 *  @param methodName		the name of method
1: 	 *	@param paramClasses		object type classes of input parameters
1: 	 *  @param primParamClasses	primitive type classes or null
1: 	 *  @param isParam			isParam (for ?) array
1: 	 *  @param staticMethod		static method or not
0: 	 *  @param Member[] methods	method stack
1: 	 *  @return	the matched method
1: 	 *
1: 	 **/
0: 	private Member resolveMethod(
0: 				Class receiverClass,
0: 				String methodName,
0: 				Class[] paramClasses,
0: 				Class[] primParamClasses,
0: 				boolean[] isParam,
0: 				boolean staticMethod,
0: 				boolean repeatLastParameter,
0: 				Member[] methods)
1: 			throws StandardException
1: 	{
1: 
1: 		if (SanityManager.DEBUG) {
1: 		  if (SanityManager.DEBUG_ON("MethodResolutionInfo"))
1: 		  {
1: 			SanityManager.DEBUG("MethodResolutionInfo",
1: 				"MRI - Begin method resolution trace for " + methodName + 
1: 				"() with " + paramClasses.length + (repeatLastParameter ? "+" : "") + " parameters");
1: 
1: 			for (int parmCtr = 0; parmCtr < paramClasses.length; parmCtr++)
1: 			{
1: 				SanityManager.DEBUG("MethodResolutionInfo",
1: 					"MRI - Parameter #" + parmCtr +
1: 					" is of type " + (paramClasses[parmCtr] == null ? "null" : paramClasses[parmCtr].getName()));
1: 			}
1: 		  }
1: 		}
1: 			
1: 		/* Step through all the methods available in this class */
1: 		int candidateIndex = -1;
1: 
1: 		boolean firstTimeAround = true;
1: 		boolean	ambiguous;
1: 		boolean somethingChanged;
1: 		do {
1: 
1: 			ambiguous = false;
1: 			somethingChanged = false;
1: 
1: nextMethod:	for (int i = 0; i < methods.length; i++) {
1: 
1: 				Member currentMethod = methods[i];
1: 
1: 				// on second and later times around there will be null entries
1: 				// also, don't compare ourself to ourself
1: 				if ((currentMethod == null) ||
1: 					(i == candidateIndex))
1: 				{
1: 					continue;
1: 				}
1: 
1: 				// must have the same number of parameters
1: 				Class[] currentMethodParameters = currentMethod instanceof Method ?
1: 					((Method) currentMethod).getParameterTypes():
1: 					((Constructor) currentMethod).getParameterTypes();
1: 
1: 				// only check the basic stuff once
1: 				if (firstTimeAround) {
1: 
1: 					if (repeatLastParameter) {
1: 						// match any number of parameters greater or equal to
1: 						// the passed in number, but repeating the last type.
1: 						if (currentMethodParameters.length < paramClasses.length) {
1: 							methods[i] = null; // remove non-applicable methods
1: 							continue;
1: 						}
1: 
1: 
1: 					} else {
1: 
0: 						// regular match on parameter count
0: 						if (currentMethodParameters.length != paramClasses.length) {
1: 							methods[i] = null; // remove non-applicable methods
1: 							continue;
1: 						}
1: 					}
1: 
1: 					/* Look only at methods that match the modifiers */
1: 					if (staticMethod && !Modifier.isStatic(currentMethod.getModifiers())) {
1: 						methods[i] = null; // remove non-applicable methods
1: 						continue;
1: 					}
1: 
1: 					/* Look only at methods with the right name */
1: 					if (!methodName.startsWith("<")) {
1: 						if ( ! methodName.equals(currentMethod.getName())) {
1: 							methods[i] = null; // remove non-applicable methods
1: 							continue;
1: 						}
1: 					}	
1: 
1: 
1: 					if (repeatLastParameter) {
1: 						// With N parameters requested check all parameters from N-1 to end are equal
1: 						// to the requested parameter.
1: 						for (int pr = paramClasses.length - 1; pr < currentMethodParameters.length; pr++) {
1: 							if (!currentMethodParameters[pr].equals(paramClasses[paramClasses.length - 1])) {
1: 								methods[i] = null; // remove non-applicable methods
1: 								continue nextMethod;
1: 							}
1: 						}
1: 					}
1: 				}
1: 
1: 				if (SanityManager.DEBUG) {
1: 				  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
1: 					SanityManager.DEBUG("MethodResolutionInfo", 
1: 						"MRI - Considering :" + currentMethod.toString());
1: 				  }
1: 				}
1: 
1: 
0: 				// can the required signature be converted to those of this method
1: 				if (!signatureConvertableFromTo(paramClasses, primParamClasses,
0: 							currentMethodParameters, isParam, false)) {
1: 
1: 					if (SanityManager.DEBUG) {
1: 					  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
1: 						SanityManager.DEBUG("MethodResolutionInfo", 
1: 							"MRI - Skipping :" + currentMethod.toString());
1: 					  }
1: 					}
1: 
1: 					methods[i] = null; // remove non-applicable methods
1: 					continue;
1: 				}
1: 
1: 
1: 			if (SanityManager.DEBUG) {
1: 				  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
1: 					SanityManager.DEBUG("MethodResolutionInfo",	"MRI - Match found ");
1: 				  }
1: 				}
1: 
1: 				/* Is this the first match? */
1: 				if (candidateIndex == -1)
1: 				{
1: 					candidateIndex = i;
1: 					if (SanityManager.DEBUG) {
1: 					  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
1: 						SanityManager.DEBUG("MethodResolutionInfo",
1: 						"MRI - Current method is now candidate");
1: 					  }
1: 					}
1: 					continue;
1: 				}
1: 
0: 				/* Not the first match, so find out which one, if either one,
0: 				 * has the best match on the parameters.  (No narrowing
0: 				 * conversions.)  15.11 of Java Language Specification.
1: 				 */
1: 
0: 				Member candidateMethod = methods[candidateIndex];
1: 
0: 				// If the candidate method is more specific than the current
0: 				// method then the candidate method is still the maximally specific method
0: 				// Note at this point we could still have a ambiguous situation.
1: 
0: 				boolean candidateMoreOrEqual = isMethodMoreSpecificOrEqual(
0: 							candidateMethod, currentMethod, isParam);
0: 				boolean currentMoreOrEqual = isMethodMoreSpecificOrEqual(
0: 							currentMethod, candidateMethod, isParam);
0: 				if (candidateMoreOrEqual && ! currentMoreOrEqual) {
1: 					if (SanityManager.DEBUG) {
1: 					  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
1: 						SanityManager.DEBUG("MethodResolutionInfo",
0: 						"MRI - Candidate is still maximally specific");
1: 					  }
1: 					}
1: 					methods[i] = null; // remove non-applicable methods
1: 					continue;
1: 				}
1: 
0: 				// if the current method is more specific than the candidiate
0: 				// method then it becomes the new maximally specific method
0: 				// Note at this point we could still have a ambiguous situation.
1: 
0: 				if (currentMoreOrEqual && ! candidateMoreOrEqual) {
1: 					if (SanityManager.DEBUG) {
1: 					  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
1: 						SanityManager.DEBUG("MethodResolutionInfo",
0: 						"MRI - Current method is now candidate, replaced previous candidate");
1: 					  }
1: 					}
0: 					methods[candidateIndex] = null; // remove non-applicable methods
1: 					candidateIndex = i;
0: 					somethingChanged = true;
1: 					continue;
1: 				}
1: 
1: 				/* We have seen an ambiguous situation; one of the cases may
1: 				 * tie on each parameter.
1: 				 */
1: 				ambiguous = true;
1: 
1: 				if (SanityManager.DEBUG) {
1: 				  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
1: 					SanityManager.DEBUG("MethodResolutionInfo", "MRI - Ambiguous match");
1: 				  }
1: 				}
1: 			}
1: 			firstTimeAround = false;
1: 		} while (ambiguous && somethingChanged);  
1: 
1: 		if (SanityManager.DEBUG) {
1: 		  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
1: 			SanityManager.DEBUG("MethodResolutionInfo",
1: 				"MRI - End method resolution trace for " + methodName + "()" +
1: 				"\nMRI - ");
1: 		  }
1: 		}
1: 
1: 		/* Throw an exception here if the method invocation ambiguous */
1: 		if (ambiguous)
1: 		{
1: 			/* Put the parameter type names into a single string */
0: 			String	parmTypesString = "";
1: 			for (int i = 0; i < paramClasses.length; i++)
1: 			{
1: 				if (i != 0)
0: 					parmTypesString += ", ";
0: 				parmTypesString += (paramClasses[i] == null ? "null" : paramClasses[i].getName());
1: 				if (primParamClasses != null && primParamClasses[i] != null)
0: 					parmTypesString += "(" + primParamClasses[i].getName() + ")";
1: 			}
1: 
1: 			throw StandardException.newException(SQLState.LANG_AMBIGUOUS_METHOD_INVOCATION, 
1: 												receiverClass.getName(), 
1: 												methodName,
0: 												parmTypesString);
1: 		}
1: 
1: 		if (candidateIndex == -1)
1: 			return null;
1: 
1: 		if (SanityManager.DEBUG) {
1: 			if (methods[candidateIndex] == null)
1: 				SanityManager.THROWASSERT("methods is null at index " + candidateIndex);
1: 		}
0: 		return methods[candidateIndex];
1: 	}
1: 
1: 	/**
1: 		Get (load) the class for the given class name.
1: 		This method converts any java language class name
1: 		into a Class object. This includes cases like String[]
1: 		and primitive types.
1: 		This will attempt to load the class from the application set.
1: 
0: 		@exception ClassNotFoundException Class cannot be found.
1: 	*/
0: 	public Class getClass(String className) throws ClassNotFoundException {
1: 
1: 		if ((className == null) || 
1: 			(className.length() == 0))
1: 		{
1: 			return null;
1: 		}
1: 
1: 		int arrayDepth = 0;
1: 		int classNameLength = className.length();
1: 
1: 		int position = classNameLength - 2;
1: 
1: 		while ((position >= 0) && className.substring(position, position + 2).equals("[]")) {
1: 			arrayDepth++;
1: 			position -= 2;
1: 			classNameLength -= 2;
1: 		}
1: 
1: 		if (classNameLength <= 0) {
1: 			// a bogus class name, let Class.forName deal with the error.
1: 			return Class.forName(className);
1: 		}
1: 
1: 		if (arrayDepth != 0)
1: 			className = className.substring(0, classNameLength);
1: 
1: 		Class baseClass = null;
1: 
1: 		if (classNameLength >=3 && classNameLength <=7) {
1: 			if ("int".equals(className)) 
1: 				baseClass = Integer.TYPE;
1: 			else if ("short".equals(className)) 
1: 				baseClass = Short.TYPE;
1: 			else if ("boolean".equals(className)) 
1: 				baseClass = Boolean.TYPE;
1: 			else if ("byte".equals(className)) 
1: 				baseClass = Byte.TYPE;
1: 			else if ("float".equals(className)) 
1: 				baseClass = Float.TYPE;
1: 			else if ("double".equals(className)) 
1: 				baseClass = Double.TYPE;
1: 			else if ("long".equals(className)) 
1: 				baseClass = Long.TYPE;
1: 			else if ("char".equals(className)) 
1: 				baseClass = Character.TYPE;
1: 			else if ("void".equals(className)) 
1: 				baseClass = Void.TYPE;
1: 		}
1: 		
1: 		if (baseClass == null) {
1: 			baseClass = cf.loadApplicationClass(className);
1: 		}
1: 
1: 		if (arrayDepth == 0)
1: 			return baseClass;
1: 
1: 		// need to create an actual instance of the array type
1: 		// and get its class from that. There is no other documented
1: 		// way to do this. While a getName() on an array class
1: 		// returns [[[Lclassname; format it's not consistent
1: 		// with primitive types, e.g.
0: 		//
1: 		// Integer.TYPE.getName()   returns "int"
1: 		// Class.forName(new int[0] returns "[I"
0: 		// 
1: 
1: 		if (arrayDepth == 1)
1: 			return Array.newInstance(baseClass, 0).getClass();
1: 
1: 		return Array.newInstance(baseClass, new int[arrayDepth]).getClass();
1: 	}
1: 
1: 
1: 	/**
0: 		Is method/constructor T more or equally specific than method U.
1: 
0: 		See the Java Language Specification section 15.11.2.2.
1: 	*/
0: 	private boolean isMethodMoreSpecificOrEqual(Member T, Member U, boolean[] isParam) {
1: 
0: 		Class[] TC;
0: 		Class[] UC;
1: 
0: 		if (T instanceof Method) {
0: 			if (!classConvertableFromTo(T.getDeclaringClass(), U.getDeclaringClass(), true))
1: 				return false;
1: 
0: 			TC = ((Method) T).getParameterTypes();
0: 			UC = ((Method) U).getParameterTypes();
1: 		} else {
0: 			TC = ((Constructor) T).getParameterTypes();
0: 			UC = ((Constructor) U).getParameterTypes();
1: 		}
1: 
0: 		return signatureConvertableFromTo(TC, null, UC, isParam, true);
1: 	}
1: 
1: 	/**
1: 	 *  Can we convert a signature from fromTypes(primFromTypes) to toTypes.
1: 	 *  "mixTypes" is a flag to show if object/primitive type conversion is
1: 	 *  possible; this is used for comparing two candidate methods in the
1: 	 *  second pass of the two pass method resolution.
1: 	 *
1: 	 *  @param fromTypes	from types' classes
1: 	 *	@param primFromTypes primitive from types or null
1: 	 *	@param toTypes		to types' classes
1: 	 *	@param isParam		is parameter (?) or not
1: 	 *	@param mixTypes		mixing object/primitive types for comparison
1: 	 **/
1: 	private boolean signatureConvertableFromTo(Class[] fromTypes, Class[] primFromTypes,
1: 												 Class[] toTypes, boolean[] isParam,
0: 												 boolean mixTypes) {
1: 
1: 		// In the case repeatLastParameter was true, then the two methods may have
1: 		// different numbers of parameters. We need to compare only the non-repeated
1: 		// parameters, which is the number of input parameters.
1: 
1: 		int checkCount = fromTypes.length;
0: 		if (toTypes.length < checkCount)
1: 			checkCount = toTypes.length;
1: 
1: 		for (int i = 0; i < checkCount; i++) {
1: 
1: 			Class fromClass = fromTypes[i];
0: 			Class toClass = toTypes[i];
1: 
1: 			// this means an untyped null was passed in. Can only ever be in the
1: 			// from side as the null can only be in the signature passed in by
1: 			// the caller of findPublicMethod. Any signatures of existing methods
1: 			// are always typed.
1: 			if (fromClass == null) {
1: 
1: 				// primitive types are only considered on
1: 				// the 2nd pass
1: 				if (toClass.isPrimitive())
1: 				{
1: 					if ((primFromTypes == null)		// first pass
1: 						|| (isParam != null && ! isParam[i]))
1: 					{
1: 						return false;
1: 					}
1: 				}
1: 				continue;
1: 			}
1: 
1: 
1: 			if ((!classConvertableFromTo(fromClass, toClass, mixTypes)) &&
1: 				// primitive type, if any, also doesn't work
1: 				((primFromTypes == null) || (primFromTypes[i] == null) ||
1: 				 (!classConvertableFromTo(primFromTypes[i], toClass, mixTypes))
1: 				))
1: 				return false;
1: 		}
1: 
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 *  Can we convert a fromClass to toClass.
1: 	 *  "mixTypes" is a flag to show if object/primitive type conversion is
1: 	 *  possible; this is used for comparing two candidate methods in the
1: 	 *  second pass of the two pass method resolution.
1: 	 *
1: 	 *  @param fromClass	from class
1: 	 *	@param toClass		to class
1: 	 *	@param mixTypes		mixing object/primitive types for comparison
1: 	 **/
1: 	protected boolean classConvertableFromTo(Class fromClass, Class toClass, boolean mixTypes) {
1: 
0: 		if (toClass.isAssignableFrom(fromClass)) {
1: 			return true;
1: 		}
1: 
1: 		// When comparing two candidate methods to see which one is closer,
1: 		// we want to mix object type and primitive type, because they could
1: 		// both be chosen in the second pass.  But when deciding if a method
1: 		// is qualified (to be a candidate), we do not want to mix types at
1: 		// any time, the reason is that we can NOT do more than one step
1: 		// conversion: for example, input parameter is BigDecimal, we convert
1: 		// it to double for method resolution, we can NOT convert it again to
1: 		// Double to match a method. "(paramTypes, primParamTypes)" already
1: 		// includes all the one-step conversions.  But at any time we do want
1: 		// to see if two primitives are convertable.
1: 		if ((!(toClass.isPrimitive() && fromClass.isPrimitive())) && (!mixTypes))
1: 			return false;
1: 
1: 		// There are nine predefined Class objects to represent the eight 
1: 		// primitive Java types and void.  We also handle prim vs. non-prim
1: 		// conversion of the same type.  boolean and double are only convertable
1: 		// to themseleves.  void should never be seen here.  In the second pass
1: 		// we treat primitive type and the corrsponding non-primitive type
1: 		// uniformly
1: 
1: 		String fromName = fromClass.getName(), toName = toClass.getName();
1: 		if ((fromClass == Boolean.TYPE) || fromName.equals(nonPrimTypeNames[0]))
1: 		{
1: 			if ((toClass == Boolean.TYPE) || toName.equals(nonPrimTypeNames[0]))
1: 				return true;
1: 		} else if ((fromClass == Byte.TYPE) || fromName.equals(nonPrimTypeNames[1]))
1: 		{
1: 			if ((toClass == Byte.TYPE) || toName.equals(nonPrimTypeNames[1]) ||
1: 				// we never need to see if toClass is of wider "object" type,
1: 				// because a wider "object" type and a narrower "primitive"
1: 				// type can never both be candidate, eg, "int" and "Long" can
1: 				// never both accomodate the same parameter; while "long" and
1: 				// "Integer" can.
1: 				(toClass == Short.TYPE) ||
1: 				(toClass == Integer.TYPE) ||
1: 				(toClass == Long.TYPE) ||
1: 				(toClass == Float.TYPE) ||
1: 				(toClass == Double.TYPE) )
1: 				return true;
1: 		} else if ((fromClass == Character.TYPE) || fromName.equals(nonPrimTypeNames[2]))
1: 		{
1: 			if ((toClass == Character.TYPE) || toName.equals(nonPrimTypeNames[2]) ||
1: 				(toClass == Integer.TYPE) ||
1: 				(toClass == Long.TYPE) ||
1: 				(toClass == Float.TYPE) ||
1: 				(toClass == Double.TYPE) )
1: 				return true;
1: 		} else if ((fromClass == Short.TYPE) || fromName.equals(nonPrimTypeNames[3]))
1: 			{
0: 			if ((toClass == Short.TYPE) || toName.equals(nonPrimTypeNames[3]) ||
1: 				(toClass == Integer.TYPE) ||
1: 				(toClass == Long.TYPE) ||
1: 				(toClass == Float.TYPE) ||
1: 				(toClass == Double.TYPE) )
1: 				return true;
1: 		} else if ((fromClass == Integer.TYPE) || fromName.equals(nonPrimTypeNames[4]))
1: 		{
0: 			if ((toClass == Integer.TYPE) || toName.equals(nonPrimTypeNames[4]) ||
1: 				(toClass == Long.TYPE) ||
1: 				(toClass == Float.TYPE) ||
1: 				(toClass == Double.TYPE) )
1: 				return true;
1: 		} else if ((fromClass == Long.TYPE) || fromName.equals(nonPrimTypeNames[5]))
1: 		{
0: 			if ((toClass == Long.TYPE) || toName.equals(nonPrimTypeNames[5]) ||
1: 				(toClass == Float.TYPE) ||
1: 				(toClass == Double.TYPE) )
1: 				return true;
1: 		} else if ((fromClass == Float.TYPE) || fromName.equals(nonPrimTypeNames[6]))
1: 		{
0: 			if ((toClass == Float.TYPE) || toName.equals(nonPrimTypeNames[6]) ||
1: 				(toClass == Double.TYPE) )
1: 				return true;
1: 		} else if ((fromClass == Double.TYPE) || fromName.equals(nonPrimTypeNames[7]))
1: 		{
1: 			if ((toClass == Double.TYPE) || toName.equals(nonPrimTypeNames[7]))
1: 				return true;
1: 		}
1: 
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Translate a JVM-style type descriptor to a Java-language-style type
1: 	 * name.
1: 	 *
0: 	 * @param vmTypeName		The String that contains the JVM type name
1: 	 *
1: 	 * @return	The Java-language-style type name
1: 	 */
1: 	public static String readableClassName(Class clazz)
1: 	{
1: 		if (!clazz.isArray())
1: 			return clazz.getName();
1: 
1: 		int arrayDepth = 0;
1: 		do {
1: 			arrayDepth++;
1: 			clazz = clazz.getComponentType();
1: 		} while (clazz.isArray());
1: 
1: 		StringBuffer sb = new StringBuffer(clazz.getName());
1: 
1: 		for (int i = 0; i < arrayDepth; i++) {
1: 			sb.append("[]");
1: 		}
1: 
1: 		return sb.toString();
1: 	}
1: 
1: 	/**
1: 	 * Get the declaring class for a method.
1: 	 *
1: 	 * @param method	A Member describing a method
1: 	 *
1: 	 * @return	A String with the declaring class
1: 	 *
1: 	 * @see Member#getDeclaringClass
1: 	 */
1: 	public String getDeclaringClass(Member method)
1: 	{
1: 		return method.getDeclaringClass().getName();
1: 	}		
1: 
1: }
1: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.loader
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.services.loader;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import java.lang.reflect.*;
0: 
0: /**
0: 	Methods to find out relationships between classes and methods within a class.
0: 	All class names within this interface are treated as java language class names,
0: 	e.g. int, COM.foo.Myclass, int[], java.lang.Object[]. That is java internal
0: 	class names as defined in the class file format are not understood.
0: */
0: public final class ClassInspector
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	private static final String[] primTypeNames =
0: 		{"boolean", "byte", "char", "short", "int", "long", "float", "double"};
0: 
0: 	// collect these as static, instead of each time allocates these new
0: 	// Strings for every method resolution
0: 
0: 	private static final String[] nonPrimTypeNames =
0: 		{"java.lang.Boolean", "java.lang.Byte", "java.lang.Character",
0: 		 "java.lang.Short", "java.lang.Integer", "java.lang.Long",
0: 		 "java.lang.Float", "java.lang.Double"};
0: 
0: 	private final ClassFactory cf;
0: 
0: 	/**
0: 		DO NOT USE! use the method in ClassFactory.
0: 	*/
0: 	public ClassInspector(ClassFactory cf) {
0: 		this.cf = cf;
0: 	}
0: 	
0: 	/**
0: 	 * Is the given object an instance of the named class?
0: 	 *
0: 	 * @param className	The name of the class
0: 	 * @param obj		The object to test to see if it's an instance
0: 	 *			of the named class
0: 	 *
0: 	 * @return	true if obj is an instanceof className, false if not
0: 	 */
0: 	public boolean instanceOf(String className, Object obj)
0: 		throws ClassNotFoundException
0: 	{
0: 		Class clazz = getClass(className);
0: 		// is className an untyped null
0: 		if (clazz == null)
0: 			return false;
0: 
0: 		return clazz.isInstance(obj);
0: 	}
0: 
0: 	/**
0: 	 * Is one named class assignable to another named class or interface?
0: 	 *
0: 	 * @param fromClassName	The name of the class to be assigned
0: 	 * @param toClassName	The name of the class to be assigned to
0: 	 *
0: 	 * @return	true if an object of type fromClass can be assigned to an
0: 	 *			object of type toClass, false if not.
0: 	 */
0: 	public boolean assignableTo(String fromClassName, String toClassName)
0: 	{
0: 		try
0: 		{
0: 			Class toClass = getClass(toClassName);
0: 			// is toClass an untyped null
0: 			if (toClass == null) {
0: 				return false;
0: 			}
0: 
0: 			Class fromClass = getClass(fromClassName);
0: 
0: 			// is fromClass an untyped null
0: 			if (fromClass == null)
0: 				return !toClass.isPrimitive() || (toClass == Void.TYPE);
0: 
0: 
0: 			return toClass.isAssignableFrom(fromClass);
0: 		}
0: 		catch (ClassNotFoundException cnfe)
0: 		{
0: 			/* If either class can't be found, they can't be assigned */
0: 			return false;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Does the named class exist, and is it accessible?
0: 	 *
0: 	 * @param className	The name of the class to test for existence
0: 	 *
0: 	 * @return	true if the class exists and is accessible, false if not
0: 	 */
0: 	public boolean accessible(String className)
0: 		throws ClassNotFoundException
0: 	{
0: 		Class theClass = getClass(className);
0: 		if (theClass == null)
0: 			return false;
0: 
0: 		/* Classes must be public to be accessible */
0: 		if (! Modifier.isPublic(theClass.getModifiers()))
0: 			return false;
0: 
0: 		return true;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Get the Java name of the return type from a Member representing
0: 	 * a method or the type of a Member representing a field.
0: 	 *
0: 	 * @param method		A Member representing the method for
0: 	 *						which we want the return type.
0: 	 *
0: 	 * @return	A Java-language-style string describing the return type of
0: 	 *			the method (for example, it returns "int" instead of "I".
0: 	 */
0: 	public String getType(Member member)
0: 	{
0: 		Class type;
0: 
0: 		if (member instanceof Method)
0: 			type = ((Method) member).getReturnType();
0: 		else if (member instanceof Field)
0: 			type = ((Field) member).getType();
0: 		else if (member instanceof Constructor)
0: 			type = ((Constructor) member).getDeclaringClass();
0: 		else
0: 			type = Void.TYPE;
0: 
0: 		return ClassInspector.readableClassName(type);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Find a public method that implements a given signature.
0: 	 * The signature is given using the full Java class names of the types.
0: 	 <BR>
0: 	 * A untyped null paramter is indicated by passing in an empty string ("")
0: 	 * as its class name.
0: 	 <BR>
0: 	 If receiverType respresents an interface then the methods of java.lang.Object
0: 	 arer included in the candidate list.
0: 	 <BR>
0: 	 If the caller is simply checking to see that a public method with the
0: 	 specified name exists, regardless of the signature, exists, then the
0: 	 caller should pass in a null for parmTypes.  (This is useful for checking
0: 	 the validity of a method alias when creating one.)
0: 	 <BR>
0: 	 We use a two-pass algorithm to resolve methods.  In the first pass, we
0: 	 use all "object" types to try to match a method.  If this fails, in the
0: 	 second pass, an array of "primitive" types (if the parameter has one,
0: 	 otherwise the same object type is used) is passed in, as well as the
0: 	 "object" type array.  For each parameter of a method, we try to match it
0: 	 against either the "object" type, or the "primitive" type.  Of all the
0: 	 qualified candidate methods found, we choose the closest one to the input
0: 	 parameter types.  This involves comparing methods whose parameters are
0: 	 mixed "object" and "primitive" types in the second pass.  This is
0: 	 eventually handled in classConvertableFromTo.
0: 	 *
0: 	 * @param receiverTypes	The class name of the receiver
0: 	 * @param methodName	The name of the method
0: 	 * @param parmTypes		An array of class names representing the
0: 	 *						parameter types.  Pass a zero-element array if
0: 	 *						there are no parameters.  Pass a null if it is
0: 	 *						okay to match any signature.
0: 	 * @param primParmTypes This is used in the second pass of the two-pass
0: 	 *						method resolution algorithm.  Use primitive type
0: 	 *						if it has one, otherwise use same object type
0: 	 * @param isParam		Array of booleans telling whether parameter is a ?.
0: 	 * @param staticMethod	Find a static method.
0: 	   @param repeatLastParameter If true the last parameter may be repeated any number of times (total count must be greater than one).
0: 	   If false the laste parameter is matched as usual. This also requires an exact match on the last parameter type.
0: 	 *
0: 	 * @return	A Member representing the matching method.  Returns null
0: 	 *			if no such method.
0: 	 *
0: 	 * @exception ClassNotFoundException	One or more of the classes does
0: 	 *										not exist.
0: 	 * @exception StandardException			Thrown on ambiguous method invocation.
0: 	 *
0: 	 * @see	Member
0: 	 * @see Modifier
0: 	 */
0: 	public Member findPublicMethod(String receiverType,
0: 								String methodName,
0: 								String[] parmTypes,
0: 								String[] primParmTypes,
0: 								boolean[] isParam,
0: 								boolean staticMethod,
0: 								boolean repeatLastParameter)
0: 					throws ClassNotFoundException, StandardException
0: 	{
0: 		Class receiverClass = getClass(receiverType);
0: 		if (receiverClass == null)
0: 			return null;
0: 
0: 		// primitives don't have methods
0: 		// note that arrays do since they are objects they have
0: 		// all the methods of java.lang.Object
0: 		if (receiverClass.isPrimitive()) {
0: 			return null;
0: 		}
0: 
0: 		// if parmTypes is null, then the caller is simply 
0: 		// looking to see if any public method with the
0: 		// specified name exists, regardless of its signature
0: 		if (parmTypes == null) {
0: 			Method[] methods = receiverClass.getMethods();
0: 			
0: 			for (int index = 0; index < methods.length; index++) {
0: 				if (staticMethod) {
0: 					if (!Modifier.isStatic(methods[index].getModifiers())) {
0: 						continue;
0: 					}
0: 				}
0: 
0: 				if (methodName.equals(methods[index].getName())) {
0: 					// We found a match
0: 					return methods[index];
0: 				}
0: 			}
0: 			// No match
0: 			return null;
0: 		}
0: 
0: 		// convert the parameter types to classes
0: 		Class[] paramClasses = new Class[parmTypes.length];
0: 		Class[] primParamClasses = null;
0: 		if (primParmTypes != null)
0: 			primParamClasses = new Class[primParmTypes.length];
0: 		for (int i = 0; i < paramClasses.length; i++)
0: 		{
0: 			paramClasses[i] = getClass(parmTypes[i]);
0: 			if (primParmTypes == null)
0: 				continue;
0: 			if (primParmTypes[i].equals(parmTypes[i]))  // no separate primitive
0: 				primParamClasses[i] = null;
0: 			else
0: 				primParamClasses[i] = getClass(primParmTypes[i]);
0: 		}
0: 
0: 		// no overloading possible if there are no arguments, so perform
0: 		// an exact match lookup.
0: 		if (paramClasses.length == 0) {
0: 
0: 			try {
0: 				Method method = receiverClass.getMethod(methodName, paramClasses);
0: 
0: 				if (staticMethod) {
0: 					if (!Modifier.isStatic(method.getModifiers()))
0: 						return null;
0: 				}
0: 
0: 				return method;
0: 
0: 				} catch (NoSuchMethodException nsme2) {
0: 
0: 
0: 					// if we are an interface then the method could be defined on Object
0: 					if (!receiverClass.isInterface())
0: 						return null;
0: 				}
0: 		}
0: 
0: 		// now the tricky method resolution
0: 		Member[] methodList = receiverClass.getMethods();
0: 		// if we have an interface we need to add the methods of Object into the mix
0: 		if (receiverClass.isInterface()) {
0: 
0: 			Member[] objectMethods = java.lang.Object.class.getMethods();
0: 			if (methodList.length == 0) {
0: 				methodList = objectMethods;
0: 			} else {
0: 				Member[] set = new Member[methodList.length + objectMethods.length];
0: 				System.arraycopy(methodList, 0, set, 0, methodList.length);
0: 				System.arraycopy(objectMethods, 0, set, methodList.length, objectMethods.length);
0: 				methodList = set;
0: 			}
0: 		}
0: 
0: 		return resolveMethod(receiverClass, methodName, paramClasses, 
0: 						primParamClasses, isParam, staticMethod, repeatLastParameter, methodList);
0: 	}
0: 
0: 	/**
0: 	 * Find a public field  for a class.
0: 	   This follows the sematics of the java compiler for locating a field.
0: 	   This means if a field fieldName exists in the class with package, private or
0: 	   protected then an error is raised. Even if the field hides a field fieldName
0: 	   in a super-class/super--interface. See the JVM spec on fields.
0: 	 *
0: 	 * @param receiverType	The class name of the receiver
0: 	 * @param fieldName		The name of the field
0: 	 * @param staticField	Find a static field
0: 	 *
0: 	 * @return	A Member representing the matching field.  
0: 	 * @exception StandardException	Class or field does not exist or is not public or a security exception.
0: 	 *
0: 	 * @see	Member
0: 	 * @see Modifier
0: 	 */
0: 	public Member findPublicField(String receiverType,
0: 								String fieldName,
0: 								boolean staticField)
0: 					throws StandardException
0: 	{
0: 
0: 		Exception e = null;
0: 		try {
0: 
0: 			Class receiverClass = getClass(receiverType);
0: 			if (receiverClass == null)
0: 				return null;
0: 			if (receiverClass.isArray() || receiverClass.isPrimitive()) {
0: 				// arrays don't have fields (the fake field 'length' is not returned here)
0: 				return null;
0: 			}
0:   
0: 			int modifier = staticField ? (Modifier.PUBLIC | Modifier.STATIC) : Modifier.PUBLIC;
0: 
0: 			// Look for a public field first
0: 			Field publicField = receiverClass.getField(fieldName);
0: 
0: 			if ((publicField.getModifiers() & modifier) == modifier)
0: 			{
0: 				/*
0: 					If the class is an interface then we avoid looking for a declared field
0: 					that can hide a super-class's public field and not be accessable. This is because
0: 					a interface's fields are always public. This avoids a security check.
0: 				*/
0: 				if (receiverClass.isInterface() || (publicField.getDeclaringClass().equals(receiverClass)))
0: 					return publicField;
0: 
0: 				/*
0: 					Now check to see if there is a declared field that hides the public field.
0: 				*/
0: 
0: 				try {
0: 
0: 					Field declaredField = receiverClass.getDeclaredField(fieldName);
0: 
0: 					if (SanityManager.DEBUG) {
0: 
0: 						if ((declaredField.getModifiers() & Modifier.PUBLIC) == Modifier.PUBLIC)
0: 							SanityManager.THROWASSERT("declared field not expected to be public here " + declaredField);
0: 					}
0: 
0: 				} catch (NoSuchFieldException nsfe) {
0: 
0: 					// no field hides the public field in the super class
0: 					return publicField;
0: 				}
0: 			}
0: 
0: 		} catch (ClassNotFoundException cnfe) {
0: 			e = cnfe;
0: 		} catch (NoSuchFieldException nsfep) {
0: 			e = nsfep;
0: 		} catch (SecurityException se) {
0: 			e = se;
0: 		}
0: 
0: 		throw StandardException.newException(
0: 			staticField ? SQLState.LANG_NO_STATIC_FIELD_FOUND : SQLState.LANG_NO_FIELD_FOUND, 
0: 								e, fieldName, receiverType);
0: 	}
0: 
0: 	/**
0: 	 * Find a public constructor that implements a given signature.
0: 	 * The signature is given using the full Java class names of the types.
0: 	 <BR>
0: 	 * A untyped null paramter is indicated by passing in an empty string ("")
0: 	 * as its class name. 
0: 	 *
0: 	 * @param receiverTypes	The class name of the receiver
0: 	 * @param parmTypes		An array of class names representing the
0: 	 *						parameter types.  Pass a zero-element array if
0: 	 *						there are no parameters.
0: 	 * @param primParmTypes This is used in the second pass of the two-pass
0: 	 *						method resolution algorithm.  Use primitive type
0: 	 *						if it has one, otherwise use same object type
0: 	 * @param isParam		Array of booleans telling whether parameter is a ?.
0: 	 *
0: 	 * @return	A Member representing the matching constructor.  Returns null
0: 	 *			if no such constructor.
0: 	 *
0: 	 * @exception ClassNotFoundException	One or more of the classes does
0: 	 *										not exist.
0: 	 * @exception StandardException			Thrown on ambiguous constructor invocation.
0: 	 *
0: 	 * @see	Member
0: 	 * @see Modifier
0: 	 */
0: 	public Member findPublicConstructor(String receiverType,
0: 									String[] parmTypes,
0: 									String[] primParmTypes,
0: 									boolean[] isParam)
0: 						throws ClassNotFoundException, StandardException 
0: 	{
0: 		Class receiverClass = getClass(receiverType);
0: 		if (receiverClass == null)
0: 			return null;
0: 
0: 		// arrays, primitives, and interfaces do not have constructors
0: 		if (receiverClass.isArray() || receiverClass.isPrimitive() || receiverClass.isInterface()) {
0: 			return null;
0: 		}
0: 
0: 		// convert the parameter types to classes
0: 		Class[] paramClasses = new Class[parmTypes.length];
0: 		Class[] primParamClasses = null;
0: 		if (primParmTypes != null)
0: 			primParamClasses = new Class[primParmTypes.length];
0: 		boolean unknownParameters = false;
0: 		for (int i = 0; i < paramClasses.length; i++) {
0: 			paramClasses[i] = getClass(parmTypes[i]);
0: 			if (paramClasses[i] == null)
0: 				unknownParameters = true;
0: 			if (primParmTypes == null)
0: 				continue;
0: 			if (primParmTypes[i].equals(parmTypes[i]))  // no separate primitive
0: 				primParamClasses[i] = null;
0: 			else
0: 				primParamClasses[i] = getClass(primParmTypes[i]);
0: 		}
0: 
0: 		try {
0: 
0: 			if (!unknownParameters && (primParmTypes == null)) {
0: 				// look for an exact match for first pass
0: 				Member method = receiverClass.getConstructor(paramClasses);
0: 
0: 				return method;
0: 			}
0: 
0: 		} catch (NoSuchMethodException nsme) {
0: 
0: 			// no overloading possible if there are no arguments
0: 			if (paramClasses.length == 0)
0: 				return null;
0: 
0: 			// now the tricky method resolution
0: 		}
0: 
0: 		// name is only used for debugging
0: 		return resolveMethod(receiverClass, "<init>", paramClasses, 
0: 							 primParamClasses, isParam, false, false,
0: 							 receiverClass.getConstructors());
0: 	}
0: 
0: 	/**
0: 	 * Get the parameter types for a method described by a Member as a String[].
0: 	 *
0: 	 * @param method	A Member describing a method
0: 	 *
0: 	 * @return	A String[] describing the parameters of the method
0: 	 */
0: 	public String[] getParameterTypes(Member method)
0: 	{
0: 
0: 		Class[] parameterClasses;
0: 		if (method instanceof Method) {
0: 			parameterClasses = ((Method) method).getParameterTypes();
0: 		} else {
0: 			parameterClasses = ((Constructor) method).getParameterTypes();
0: 		}
0: 
0: 		String[] parameterTypes = new String[parameterClasses.length];
0: 
0: 		for (int i = 0; i < parameterTypes.length; i++) {
0: 			parameterTypes[i] = ClassInspector.readableClassName(parameterClasses[i]);
0: 		}
0: 
0: 		return parameterTypes;
0: 	}
0: 
0: 	/**
0: 	 * Determine whether a type is a Java primitive, like int or boolean
0: 	 *
0: 	 * @param typeName	The name of the Java type
0: 	 *
0: 	 * @return	true if it's a primitive type
0: 	 */
0: 	public static boolean primitiveType(String typeName)
0: 	{
0: 		for (int i = 0; i < primTypeNames.length; i++)
0: 		{
0: 			if (typeName.equals(primTypeNames[i]))
0: 				return true;
0: 		}
0: 
0: 		return false;
0: 	}
0: 
0: 
0: 	/**
0: 	 *  Tricky function to resolve a method.  If primParamClasses is null
0: 	 *  we know it's first pass.  First pass try to match as all "object"
0: 	 *  types, second pass try to match any combination of "object" and
0: 	 *  "primitive" types.  Find the closest match among all the qualified
0: 	 *  candidates.  If there's a tie, it's ambiguous.
0: 	 *
0: 	 *  @param receiverClass 	the class who holds the methods
0: 	 *  @param methodName		the name of method
0: 	 *	@param paramClasses		object type classes of input parameters
0: 	 *  @param primParamClasses	primitive type classes or null
0: 	 *  @param isParam			isParam (for ?) array
0: 	 *  @param staticMethod		static method or not
0: 	 *  @param Member[] methods	method stack
0: 	 *  @return	the matched method
0: 	 *
0: 	 **/
0: 	private Member resolveMethod(
0: 				Class receiverClass,
0: 				String methodName,
0: 				Class[] paramClasses,
0: 				Class[] primParamClasses,
0: 				boolean[] isParam,
0: 				boolean staticMethod,
0: 				boolean repeatLastParameter,
0: 				Member[] methods)
0: 			throws StandardException
0: 	{
0: 
0: 		if (SanityManager.DEBUG) {
0: 		  if (SanityManager.DEBUG_ON("MethodResolutionInfo"))
0: 		  {
0: 			SanityManager.DEBUG("MethodResolutionInfo",
0: 				"MRI - Begin method resolution trace for " + methodName + 
0: 				"() with " + paramClasses.length + (repeatLastParameter ? "+" : "") + " parameters");
0: 
0: 			for (int parmCtr = 0; parmCtr < paramClasses.length; parmCtr++)
0: 			{
0: 				SanityManager.DEBUG("MethodResolutionInfo",
0: 					"MRI - Parameter #" + parmCtr +
0: 					" is of type " + (paramClasses[parmCtr] == null ? "null" : paramClasses[parmCtr].getName()));
0: 			}
0: 		  }
0: 		}
0: 			
0: 		/* Step through all the methods available in this class */
0: 		int candidateIndex = -1;
0: 
0: 		boolean firstTimeAround = true;
0: 		boolean	ambiguous;
0: 		boolean somethingChanged;
0: 		do {
0: 
0: 			ambiguous = false;
0: 			somethingChanged = false;
0: 
0: nextMethod:	for (int i = 0; i < methods.length; i++) {
0: 
0: 				Member currentMethod = methods[i];
0: 
0: 				// on second and later times around there will be null entries
0: 				// also, don't compare ourself to ourself
0: 				if ((currentMethod == null) ||
0: 					(i == candidateIndex))
0: 				{
0: 					continue;
0: 				}
0: 
0: 				// must have the same number of parameters
0: 				Class[] currentMethodParameters = currentMethod instanceof Method ?
0: 					((Method) currentMethod).getParameterTypes():
0: 					((Constructor) currentMethod).getParameterTypes();
0: 
0: 				// only check the basic stuff once
0: 				if (firstTimeAround) {
0: 
0: 					if (repeatLastParameter) {
0: 						// match any number of parameters greater or equal to
0: 						// the passed in number, but repeating the last type.
0: 						if (currentMethodParameters.length < paramClasses.length) {
0: 							methods[i] = null; // remove non-applicable methods
0: 							continue;
0: 						}
0: 
0: 
0: 					} else {
0: 
0: 						// regular match on parameter count
0: 						if (currentMethodParameters.length != paramClasses.length) {
0: 							methods[i] = null; // remove non-applicable methods
0: 							continue;
0: 						}
0: 					}
0: 
0: 					/* Look only at methods that match the modifiers */
0: 					if (staticMethod && !Modifier.isStatic(currentMethod.getModifiers())) {
0: 						methods[i] = null; // remove non-applicable methods
0: 						continue;
0: 					}
0: 
0: 					/* Look only at methods with the right name */
0: 					if (!methodName.startsWith("<")) {
0: 						if ( ! methodName.equals(currentMethod.getName())) {
0: 							methods[i] = null; // remove non-applicable methods
0: 							continue;
0: 						}
0: 					}	
0: 
0: 
0: 					if (repeatLastParameter) {
0: 						// With N parameters requested check all parameters from N-1 to end are equal
0: 						// to the requested parameter.
0: 						for (int pr = paramClasses.length - 1; pr < currentMethodParameters.length; pr++) {
0: 							if (!currentMethodParameters[pr].equals(paramClasses[paramClasses.length - 1])) {
0: 								methods[i] = null; // remove non-applicable methods
0: 								continue nextMethod;
0: 							}
0: 						}
0: 					}
0: 				}
0: 
0: 				if (SanityManager.DEBUG) {
0: 				  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
0: 					SanityManager.DEBUG("MethodResolutionInfo", 
0: 						"MRI - Considering :" + currentMethod.toString());
0: 				  }
0: 				}
0: 
0: 
0: 				// can the required signature be converted to those of this method
0: 				if (!signatureConvertableFromTo(paramClasses, primParamClasses,
0: 							currentMethodParameters, isParam, false)) {
0: 
0: 					if (SanityManager.DEBUG) {
0: 					  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
0: 						SanityManager.DEBUG("MethodResolutionInfo", 
0: 							"MRI - Skipping :" + currentMethod.toString());
0: 					  }
0: 					}
0: 
0: 					methods[i] = null; // remove non-applicable methods
0: 					continue;
0: 				}
0: 
0: 
0: 			if (SanityManager.DEBUG) {
0: 				  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
0: 					SanityManager.DEBUG("MethodResolutionInfo",	"MRI - Match found ");
0: 				  }
0: 				}
0: 
0: 				/* Is this the first match? */
0: 				if (candidateIndex == -1)
0: 				{
0: 					candidateIndex = i;
0: 					if (SanityManager.DEBUG) {
0: 					  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
0: 						SanityManager.DEBUG("MethodResolutionInfo",
0: 						"MRI - Current method is now candidate");
0: 					  }
0: 					}
0: 					continue;
0: 				}
0: 
0: 				/* Not the first match, so find out which one, if either one,
0: 				 * has the best match on the parameters.  (No narrowing
0: 				 * conversions.)  15.11 of Java Language Specification.
0: 				 */
0: 
0: 				Member candidateMethod = methods[candidateIndex];
0: 
0: 				// If the candidate method is more specific than the current
0: 				// method then the candidate method is still the maximally specific method
0: 				// Note at this point we could still have a ambiguous situation.
0: 
0: 				boolean candidateMoreOrEqual = isMethodMoreSpecificOrEqual(
0: 							candidateMethod, currentMethod, isParam);
0: 				boolean currentMoreOrEqual = isMethodMoreSpecificOrEqual(
0: 							currentMethod, candidateMethod, isParam);
0: 				if (candidateMoreOrEqual && ! currentMoreOrEqual) {
0: 					if (SanityManager.DEBUG) {
0: 					  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
0: 						SanityManager.DEBUG("MethodResolutionInfo",
0: 						"MRI - Candidate is still maximally specific");
0: 					  }
0: 					}
0: 					methods[i] = null; // remove non-applicable methods
0: 					continue;
0: 				}
0: 
0: 				// if the current method is more specific than the candidiate
0: 				// method then it becomes the new maximally specific method
0: 				// Note at this point we could still have a ambiguous situation.
0: 
0: 				if (currentMoreOrEqual && ! candidateMoreOrEqual) {
0: 					if (SanityManager.DEBUG) {
0: 					  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
0: 						SanityManager.DEBUG("MethodResolutionInfo",
0: 						"MRI - Current method is now candidate, replaced previous candidate");
0: 					  }
0: 					}
0: 					methods[candidateIndex] = null; // remove non-applicable methods
0: 					candidateIndex = i;
0: 					somethingChanged = true;
0: 					continue;
0: 				}
0: 
0: 				/* We have seen an ambiguous situation; one of the cases may
0: 				 * tie on each parameter.
0: 				 */
0: 				ambiguous = true;
0: 
0: 				if (SanityManager.DEBUG) {
0: 				  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
0: 					SanityManager.DEBUG("MethodResolutionInfo", "MRI - Ambiguous match");
0: 				  }
0: 				}
0: 			}
0: 			firstTimeAround = false;
0: 		} while (ambiguous && somethingChanged);  
0: 
0: 		if (SanityManager.DEBUG) {
0: 		  if (SanityManager.DEBUG_ON("MethodResolutionInfo")) {
0: 			SanityManager.DEBUG("MethodResolutionInfo",
0: 				"MRI - End method resolution trace for " + methodName + "()" +
0: 				"\nMRI - ");
0: 		  }
0: 		}
0: 
0: 		/* Throw an exception here if the method invocation ambiguous */
0: 		if (ambiguous)
0: 		{
0: 			/* Put the parameter type names into a single string */
0: 			String	parmTypesString = "";
0: 			for (int i = 0; i < paramClasses.length; i++)
0: 			{
0: 				if (i != 0)
0: 					parmTypesString += ", ";
0: 				parmTypesString += (paramClasses[i] == null ? "null" : paramClasses[i].getName());
0: 				if (primParamClasses != null && primParamClasses[i] != null)
0: 					parmTypesString += "(" + primParamClasses[i].getName() + ")";
0: 			}
0: 
0: 			throw StandardException.newException(SQLState.LANG_AMBIGUOUS_METHOD_INVOCATION, 
0: 												receiverClass.getName(), 
0: 												methodName,
0: 												parmTypesString);
0: 		}
0: 
0: 		if (candidateIndex == -1)
0: 			return null;
0: 
0: 		if (SanityManager.DEBUG) {
0: 			if (methods[candidateIndex] == null)
0: 				SanityManager.THROWASSERT("methods is null at index " + candidateIndex);
0: 		}
0: 		return methods[candidateIndex];
0: 	}
0: 
0: 	/**
0: 		Get (load) the class for the given class name.
0: 		This method converts any java language class name
0: 		into a Class object. This includes cases like String[]
0: 		and primitive types.
0: 		This will attempt to load the class from the application set.
0: 
0: 		@exception ClassNotFoundException Class cannot be found.
0: 	*/
0: 	public Class getClass(String className) throws ClassNotFoundException {
0: 
0: 		if ((className == null) || 
0: 			(className.length() == 0))
0: 		{
0: 			return null;
0: 		}
0: 
0: 		int arrayDepth = 0;
0: 		int classNameLength = className.length();
0: 
0: 		int position = classNameLength - 2;
0: 
0: 		while ((position >= 0) && className.substring(position, position + 2).equals("[]")) {
0: 			arrayDepth++;
0: 			position -= 2;
0: 			classNameLength -= 2;
0: 		}
0: 
0: 		if (classNameLength <= 0) {
0: 			// a bogus class name, let Class.forName deal with the error.
0: 			return Class.forName(className);
0: 		}
0: 
0: 		if (arrayDepth != 0)
0: 			className = className.substring(0, classNameLength);
0: 
0: 		Class baseClass = null;
0: 
0: 		if (classNameLength >=3 && classNameLength <=7) {
0: 			if ("int".equals(className)) 
0: 				baseClass = Integer.TYPE;
0: 			else if ("short".equals(className)) 
0: 				baseClass = Short.TYPE;
0: 			else if ("boolean".equals(className)) 
0: 				baseClass = Boolean.TYPE;
0: 			else if ("byte".equals(className)) 
0: 				baseClass = Byte.TYPE;
0: 			else if ("float".equals(className)) 
0: 				baseClass = Float.TYPE;
0: 			else if ("double".equals(className)) 
0: 				baseClass = Double.TYPE;
0: 			else if ("long".equals(className)) 
0: 				baseClass = Long.TYPE;
0: 			else if ("char".equals(className)) 
0: 				baseClass = Character.TYPE;
0: 			else if ("void".equals(className)) 
0: 				baseClass = Void.TYPE;
0: 		}
0: 		
0: 		if (baseClass == null) {
0: 			baseClass = cf.loadApplicationClass(className);
0: 		}
0: 
0: 		if (arrayDepth == 0)
0: 			return baseClass;
0: 
0: 		// need to create an actual instance of the array type
0: 		// and get its class from that. There is no other documented
0: 		// way to do this. While a getName() on an array class
0: 		// returns [[[Lclassname; format it's not consistent
0: 		// with primitive types, e.g.
0: 		//
0: 		// Integer.TYPE.getName()   returns "int"
0: 		// Class.forName(new int[0] returns "[I"
0: 		// 
0: 
0: 		if (arrayDepth == 1)
0: 			return Array.newInstance(baseClass, 0).getClass();
0: 
0: 		return Array.newInstance(baseClass, new int[arrayDepth]).getClass();
0: 	}
0: 
0: 
0: 	/**
0: 		Is method/constructor T more or equally specific than method U.
0: 
0: 		See the Java Language Specification section 15.11.2.2.
0: 	*/
0: 	private boolean isMethodMoreSpecificOrEqual(Member T, Member U, boolean[] isParam) {
0: 
0: 		Class[] TC;
0: 		Class[] UC;
0: 
0: 		if (T instanceof Method) {
0: 			if (!classConvertableFromTo(T.getDeclaringClass(), U.getDeclaringClass(), true))
0: 				return false;
0: 
0: 			TC = ((Method) T).getParameterTypes();
0: 			UC = ((Method) U).getParameterTypes();
0: 		} else {
0: 			TC = ((Constructor) T).getParameterTypes();
0: 			UC = ((Constructor) U).getParameterTypes();
0: 		}
0: 
0: 		return signatureConvertableFromTo(TC, null, UC, isParam, true);
0: 	}
0: 
0: 	/**
0: 	 *  Can we convert a signature from fromTypes(primFromTypes) to toTypes.
0: 	 *  "mixTypes" is a flag to show if object/primitive type conversion is
0: 	 *  possible; this is used for comparing two candidate methods in the
0: 	 *  second pass of the two pass method resolution.
0: 	 *
0: 	 *  @param fromTypes	from types' classes
0: 	 *	@param primFromTypes primitive from types or null
0: 	 *	@param toTypes		to types' classes
0: 	 *	@param isParam		is parameter (?) or not
0: 	 *	@param mixTypes		mixing object/primitive types for comparison
0: 	 **/
0: 	private boolean signatureConvertableFromTo(Class[] fromTypes, Class[] primFromTypes,
0: 												 Class[] toTypes, boolean[] isParam,
0: 												 boolean mixTypes) {
0: 
0: 		// In the case repeatLastParameter was true, then the two methods may have
0: 		// different numbers of parameters. We need to compare only the non-repeated
0: 		// parameters, which is the number of input parameters.
0: 
0: 		int checkCount = fromTypes.length;
0: 		if (toTypes.length < checkCount)
0: 			checkCount = toTypes.length;
0: 
0: 		for (int i = 0; i < checkCount; i++) {
0: 
0: 			Class fromClass = fromTypes[i];
0: 			Class toClass = toTypes[i];
0: 
0: 			// this means an untyped null was passed in. Can only ever be in the
0: 			// from side as the null can only be in the signature passed in by
0: 			// the caller of findPublicMethod. Any signatures of existing methods
0: 			// are always typed.
0: 			if (fromClass == null) {
0: 
0: 				// primitive types are only considered on
0: 				// the 2nd pass
0: 				if (toClass.isPrimitive())
0: 				{
0: 					if ((primFromTypes == null)		// first pass
0: 						|| (isParam != null && ! isParam[i]))
0: 					{
0: 						return false;
0: 					}
0: 				}
0: 				continue;
0: 			}
0: 
0: 
0: 			if ((!classConvertableFromTo(fromClass, toClass, mixTypes)) &&
0: 				// primitive type, if any, also doesn't work
0: 				((primFromTypes == null) || (primFromTypes[i] == null) ||
0: 				 (!classConvertableFromTo(primFromTypes[i], toClass, mixTypes))
0: 				))
0: 				return false;
0: 		}
0: 
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 *  Can we convert a fromClass to toClass.
0: 	 *  "mixTypes" is a flag to show if object/primitive type conversion is
0: 	 *  possible; this is used for comparing two candidate methods in the
0: 	 *  second pass of the two pass method resolution.
0: 	 *
0: 	 *  @param fromClass	from class
0: 	 *	@param toClass		to class
0: 	 *	@param mixTypes		mixing object/primitive types for comparison
0: 	 **/
0: 	protected boolean classConvertableFromTo(Class fromClass, Class toClass, boolean mixTypes) {
0: 
0: 		if (toClass.isAssignableFrom(fromClass)) {
0: 			return true;
0: 		}
0: 
0: 		// When comparing two candidate methods to see which one is closer,
0: 		// we want to mix object type and primitive type, because they could
0: 		// both be chosen in the second pass.  But when deciding if a method
0: 		// is qualified (to be a candidate), we do not want to mix types at
0: 		// any time, the reason is that we can NOT do more than one step
0: 		// conversion: for example, input parameter is BigDecimal, we convert
0: 		// it to double for method resolution, we can NOT convert it again to
0: 		// Double to match a method. "(paramTypes, primParamTypes)" already
0: 		// includes all the one-step conversions.  But at any time we do want
0: 		// to see if two primitives are convertable.
0: 		if ((!(toClass.isPrimitive() && fromClass.isPrimitive())) && (!mixTypes))
0: 			return false;
0: 
0: 		// There are nine predefined Class objects to represent the eight 
0: 		// primitive Java types and void.  We also handle prim vs. non-prim
0: 		// conversion of the same type.  boolean and double are only convertable
0: 		// to themseleves.  void should never be seen here.  In the second pass
0: 		// we treat primitive type and the corrsponding non-primitive type
0: 		// uniformly
0: 
0: 		String fromName = fromClass.getName(), toName = toClass.getName();
0: 		if ((fromClass == Boolean.TYPE) || fromName.equals(nonPrimTypeNames[0]))
0: 		{
0: 			if ((toClass == Boolean.TYPE) || toName.equals(nonPrimTypeNames[0]))
0: 				return true;
0: 		} else if ((fromClass == Byte.TYPE) || fromName.equals(nonPrimTypeNames[1]))
0: 		{
0: 			if ((toClass == Byte.TYPE) || toName.equals(nonPrimTypeNames[1]) ||
0: 				// we never need to see if toClass is of wider "object" type,
0: 				// because a wider "object" type and a narrower "primitive"
0: 				// type can never both be candidate, eg, "int" and "Long" can
0: 				// never both accomodate the same parameter; while "long" and
0: 				// "Integer" can.
0: 				(toClass == Short.TYPE) ||
0: 				(toClass == Integer.TYPE) ||
0: 				(toClass == Long.TYPE) ||
0: 				(toClass == Float.TYPE) ||
0: 				(toClass == Double.TYPE) )
0: 				return true;
0: 		} else if ((fromClass == Character.TYPE) || fromName.equals(nonPrimTypeNames[2]))
0: 		{
0: 			if ((toClass == Character.TYPE) || toName.equals(nonPrimTypeNames[2]) ||
0: 				(toClass == Integer.TYPE) ||
0: 				(toClass == Long.TYPE) ||
0: 				(toClass == Float.TYPE) ||
0: 				(toClass == Double.TYPE) )
0: 				return true;
0: 		} else if ((fromClass == Short.TYPE) || fromName.equals(nonPrimTypeNames[3]))
0: 			{
0: 			if ((toClass == Short.TYPE) || toName.equals(nonPrimTypeNames[3]) ||
0: 				(toClass == Integer.TYPE) ||
0: 				(toClass == Long.TYPE) ||
0: 				(toClass == Float.TYPE) ||
0: 				(toClass == Double.TYPE) )
0: 				return true;
0: 		} else if ((fromClass == Integer.TYPE) || fromName.equals(nonPrimTypeNames[4]))
0: 		{
0: 			if ((toClass == Integer.TYPE) || toName.equals(nonPrimTypeNames[4]) ||
0: 				(toClass == Long.TYPE) ||
0: 				(toClass == Float.TYPE) ||
0: 				(toClass == Double.TYPE) )
0: 				return true;
0: 		} else if ((fromClass == Long.TYPE) || fromName.equals(nonPrimTypeNames[5]))
0: 		{
0: 			if ((toClass == Long.TYPE) || toName.equals(nonPrimTypeNames[5]) ||
0: 				(toClass == Float.TYPE) ||
0: 				(toClass == Double.TYPE) )
0: 				return true;
0: 		} else if ((fromClass == Float.TYPE) || fromName.equals(nonPrimTypeNames[6]))
0: 		{
0: 			if ((toClass == Float.TYPE) || toName.equals(nonPrimTypeNames[6]) ||
0: 				(toClass == Double.TYPE) )
0: 				return true;
0: 		} else if ((fromClass == Double.TYPE) || fromName.equals(nonPrimTypeNames[7]))
0: 		{
0: 			if ((toClass == Double.TYPE) || toName.equals(nonPrimTypeNames[7]))
0: 				return true;
0: 		}
0: 
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Translate a JVM-style type descriptor to a Java-language-style type
0: 	 * name.
0: 	 *
0: 	 * @param vmTypeName		The String that contains the JVM type name
0: 	 *
0: 	 * @return	The Java-language-style type name
0: 	 */
0: 	public static String readableClassName(Class clazz)
0: 	{
0: 		if (!clazz.isArray())
0: 			return clazz.getName();
0: 
0: 		int arrayDepth = 0;
0: 		do {
0: 			arrayDepth++;
0: 			clazz = clazz.getComponentType();
0: 		} while (clazz.isArray());
0: 
0: 		StringBuffer sb = new StringBuffer(clazz.getName());
0: 
0: 		for (int i = 0; i < arrayDepth; i++) {
0: 			sb.append("[]");
0: 		}
0: 
0: 		return sb.toString();
0: 	}
0: 
0: 	/**
0: 	 * Get the declaring class for a method.
0: 	 *
0: 	 * @param method	A Member describing a method
0: 	 *
0: 	 * @return	A String with the declaring class
0: 	 *
0: 	 * @see Member#getDeclaringClass
0: 	 */
0: 	public String getDeclaringClass(Member method)
0: 	{
0: 		return method.getDeclaringClass().getName();
0: 	}		
0: 
0: }
0: 
============================================================================