1:3f965ed: /*
1:3f965ed:  *
1:3f965ed:  * Derby - Class CharacterStreamsTest
1:3f965ed:  *
1:3f965ed:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:3f965ed:  * contributor license agreements.  See the NOTICE file distributed with
1:3f965ed:  * this work for additional information regarding copyright ownership.
1:3f965ed:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:3f965ed:  * (the "License"); you may not use this file except in compliance with
1:3f965ed:  * the License.  You may obtain a copy of the License at
1:3f965ed:  *
1:3f965ed:  *    http://www.apache.org/licenses/LICENSE-2.0
1:3f965ed:  *
1:3f965ed:  * Unless required by applicable law or agreed to in writing,
1:3f965ed:  * software distributed under the License is distributed on an
1:3f965ed:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:3f965ed:  * either express or implied. See the License for the specific
1:3f965ed:  * language governing permissions and limitations under the License.
1:3f965ed:  */
1:3f965ed: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:3f965ed: 
1:3f965ed: import java.io.ByteArrayInputStream;
1:3f965ed: import java.io.IOException;
1:3f965ed: import java.io.InputStream;
1:3f965ed: import java.io.Reader;
1:3f965ed: import java.io.StringReader;
1:3f965ed: import java.sql.PreparedStatement;
1:3f965ed: import java.sql.ResultSet;
1:3f965ed: import java.sql.SQLException;
1:3f965ed: import java.sql.Statement;
1:3f965ed: import junit.framework.Test;
1:a4a66c4: import org.apache.derbyTesting.functionTests.util.streams.CharAlphabet;
1:a4a66c4: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:3f965ed: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:3f965ed: import org.apache.derbyTesting.junit.TestConfiguration;
1:3f965ed: 
1:3f965ed: /**
1:3f965ed:  * Tests the following PreparedStatement methods:
1:dbed020:  *   -&gt; setCharacterStream(int parameterIndex, InputStream x, int length)
1:dbed020:  *   -&gt; setAsciiStream(int parameterIndex, Reader reader, int length)
1:3f965ed:  */
1:3f965ed: public class CharacterStreamsTest extends BaseJDBCTestCase {
1:3f965ed: 
1:3f965ed:     public static Test suite() {
1:3f965ed:         // Run only in embedded mode until DERBY-2017 is fixed.
1:3f965ed:         return TestConfiguration.embeddedSuite(CharacterStreamsTest.class);
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     /** Creates a new instance of CharacterStreamsTest */
1:3f965ed:     public CharacterStreamsTest(String name) {
1:3f965ed:         super(name);
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     /**
1:3f965ed:      * Test PreparedStatement.setAsciiStream() with column of type CHAR
1:3f965ed:      */
1:3f965ed:     public void testSetAsciiStreamIntoChar() throws Exception {
1:3f965ed:         runTestSetAsciiStream(1);
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     /**
1:3f965ed:      * Test PreparedStatement.setAsciiStream() with column of type VARCHAR
1:3f965ed:      */
1:3f965ed:     public void testSetAsciiStreamIntoVarchar() throws Exception {
1:3f965ed:         runTestSetAsciiStream(2);
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     /**
1:3f965ed:      * Test PreparedStatement.setAsciiStream() with column of type LONG VARCHAR
1:3f965ed:      */
1:3f965ed:     public void testSetAsciiStreamIntoLongVarchar() throws Exception {
1:3f965ed:         runTestSetAsciiStream(3);
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     /**
1:3f965ed:      * Test PreparedStatement.setAsciiStream() with column of type CLOB
1:3f965ed:      */
1:3f965ed:     public void testSetAsciiStreamIntoClob() throws Exception {
1:3f965ed:         runTestSetAsciiStream(4);
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     /**
1:3f965ed:      * Test PreparedStatement.setCharacterStream() with column of type CHAR
1:3f965ed:      */
1:3f965ed:     public void testSetCharacterStreamIntoChar() throws Exception {
1:3f965ed:         runTestSetCharacterStream(1);
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     /**
1:3f965ed:      * Test PreparedStatement.setCharacterStream() with column of type VARCHAR
1:3f965ed:      */
1:3f965ed:     public void testSetCharacterStreamIntoVarchar() throws Exception {
1:3f965ed:         runTestSetCharacterStream(2);
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     /**
1:3f965ed:      * Test PreparedStatement.setCharacterStream() with column of type
1:3f965ed:      * LONG VARCHAR
1:3f965ed:      */
1:3f965ed:     public void testSetCharacterStreamIntoLongVarchar() throws Exception {
1:3f965ed:         runTestSetCharacterStream(3);
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     /**
1:3f965ed:      * Test PreparedStatement.setCharacterStream() with column of type CLOB
1:3f965ed:      */
1:3f965ed:     public void testSetCharacterStreamIntoClob() throws Exception {
1:3f965ed:         runTestSetCharacterStream(4);
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     /**
1:3f965ed:      * Test PreparedStatement.setAsciiStream() with streams with sizes from
1:3f965ed:      * 60characters to 32K characters
1:3f965ed:      */
1:3f965ed:     public void testSetAsciiStreamLongValues() throws Exception {
1:3f965ed:         runTestSetAsciiStreamLongValues();
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     /**
1:3f965ed:      * Test PreparedStatement.setCharacterStream() with streams with sizes from
1:3f965ed:      * 60 characters to 32K characters
1:3f965ed:      */
1:3f965ed:     public void testSetCharacterStreamLongValues() throws Exception {
1:3f965ed:         runTestSetCharacterStreamLongValues();
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     private void runTestSetAsciiStream(int col) throws Exception {
1:3f965ed:         PreparedStatement psi = prepareStatement(
1:3f965ed:                 "insert into charstream(c, vc, lvc, lob) " +
1:3f965ed:                 "values(?,?,?,?)");
1:3f965ed:         PreparedStatement psq = prepareStatement(
1:3f965ed:                 "select id, c, {fn length(c)} AS CLEN, " +
1:3f965ed:                 "cast (vc as varchar(25)) AS VC, " +
1:3f965ed:                 "{fn length(vc)} AS VCLEN, " +
1:3f965ed:                 "cast (lvc as varchar(25)) AS LVC, " +
1:3f965ed:                 "{fn length(lvc)} AS LVCLEN, " +
1:3f965ed:                 "cast (lob as varchar(25)) AS LOB, " +
1:3f965ed:                 "{fn length(lob)} AS LOBLEN " +
1:3f965ed:                 "from charstream " +
1:3f965ed:                 "where id > ? order by 1");
1:3f965ed: 
1:3f965ed:         // test setAsciiStream into CHAR
1:3f965ed:         println("\nTest setAsciiStream into CHAR");
1:3f965ed:         psi.setString(1, null);
1:3f965ed:         psi.setString(2, null);
1:3f965ed:         psi.setString(3, null);
1:3f965ed:         psi.setString(4, null);
1:3f965ed:         int maxid = getMaxId();
1:3f965ed:         setAscii(psi, col);
1:3f965ed:         psq.setInt(1, maxid);
1:3f965ed:         verifyAsciiStreamResults(psq.executeQuery(), col);
1:3f965ed: 
1:3f965ed:         // Show results as various streams
1:3f965ed:         PreparedStatement psStreams = prepareStatement(
1:3f965ed:                 "SELECT id, c, vc, lvc, lob " +
1:3f965ed:                 "FROM charstream where id > ? order by 1");
1:3f965ed:         psStreams.setInt(1, maxid);
1:3f965ed:         verifyResultsUsingAsciiStream(psStreams.executeQuery(), col);
1:3f965ed:         verifyResultsUsingCharacterStream(psStreams.executeQuery(), col);
1:3f965ed:         verifyResultsUsingCharacterStreamBlock(psStreams.executeQuery(), col);
1:3f965ed:         psStreams.close();
1:3f965ed: 
1:3f965ed:         psi.close();
1:3f965ed:         psq.close();
1:3f965ed: 
1:3f965ed:     }
1:3f965ed:     private void runTestSetCharacterStream(int col) throws Exception {
1:3f965ed:         PreparedStatement psi = prepareStatement(
1:3f965ed:                 "insert into charstream(c, vc, lvc, lob) " +
1:3f965ed:                 "values(?,?,?,?)");
1:3f965ed:         PreparedStatement psq = prepareStatement(
1:3f965ed:                 "select id, c, {fn length(c)} AS CLEN, " +
1:3f965ed:                 "cast (vc as varchar(25)) AS VC, " +
1:3f965ed:                 "{fn length(vc)} AS VCLEN, " +
1:3f965ed:                 "cast (lvc as varchar(25)) AS LVC, " +
1:3f965ed:                 "{fn length(lvc)} AS LVCLEN, " +
1:3f965ed:                 "cast (lob as varchar(25)) AS LOB, " +
1:3f965ed:                 "{fn length(lob)} AS LOBLEN " +
1:3f965ed:                 "from charstream " +
1:3f965ed:                 "where id > ? order by 1");
1:3f965ed: 
1:3f965ed:         // test setCharacterStream into CHAR
1:3f965ed:         println("\nTest setCharacterStream into CHAR");
1:3f965ed:         psi.setString(1, null);
1:3f965ed:         psi.setString(2, null);
1:3f965ed:         psi.setString(3, null);
1:3f965ed:         psi.setString(4, null);
1:3f965ed:         int maxid = getMaxId();
1:3f965ed:         setCharacter(psi, col);
1:3f965ed:         psq.setInt(1, maxid);
1:3f965ed:         verifyCharStreamResults(psq.executeQuery(), col);
1:3f965ed: 
1:3f965ed:         psi.close();
1:3f965ed:         psq.close();
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     private void runTestSetAsciiStreamLongValues() throws Exception {
1:3f965ed:         // now insert long values using streams and check them programatically.
1:3f965ed:         PreparedStatement psi = prepareStatement(
1:3f965ed:                 "insert into charstream(c, vc, lvc, lob) " +
1:3f965ed:                 "values(?,?,?,?)");
1:3f965ed:         PreparedStatement psDel = prepareStatement("DELETE FROM charstream");
1:3f965ed:         PreparedStatement psq2 =
1:3f965ed:                 prepareStatement("select c, vc, lvc, lob from charstream");
1:3f965ed: 
1:3f965ed:         // now insert long values using streams and check them programatically.
1:3f965ed:         println("setAsciiStream(LONG ASCII STREAMS)");
1:3f965ed:         checkAsciiStreams(psDel, psi, psq2, 18, 104, 67, 67);
1:3f965ed:         checkAsciiStreams(psDel, psi, psq2, 25, 16732, 14563, 14563);
1:3f965ed:         checkAsciiStreams(psDel, psi, psq2, 1, 32433, 32673, 32673);
1:3f965ed:         checkAsciiStreams(psDel, psi, psq2, 0, 32532, 32700, 32700);
1:3f965ed: 
1:3f965ed:         psi.close();
1:3f965ed:         psDel.close();
1:3f965ed:         psq2.close();
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     private void runTestSetCharacterStreamLongValues() throws Exception {
1:3f965ed:         // now insert long values using streams and check them programatically.
1:3f965ed:         PreparedStatement psi = prepareStatement(
1:3f965ed:                 "insert into charstream(c, vc, lvc, lob) " +
1:3f965ed:                 "values(?,?,?,?)");
1:3f965ed:         PreparedStatement psDel = prepareStatement("DELETE FROM charstream");
1:a4a66c4:         PreparedStatement psqSQLLength = prepareStatement(
1:a4a66c4:                 "select length(c), length(vc), length(lvc), length(lob) " +
1:a4a66c4:                 "from charstream");
1:3f965ed:         PreparedStatement psq2 =
1:3f965ed:                 prepareStatement("select c, vc, lvc, lob from charstream");
1:3f965ed: 
1:3f965ed:         println("setCharacterStream(LONG CHARACTER STREAMS WITH UNICODE)");
1:a4a66c4:         checkCharacterStreams(
1:a4a66c4:                 psDel, psi, psq2, psqSQLLength, 14, 93, 55, 55, 0);
1:a4a66c4:         checkCharacterStreams(
1:a4a66c4:                 psDel, psi, psq2, psqSQLLength, 21, 10887, 10887, 10887, 3);
1:a4a66c4:         checkCharacterStreams(
1:a4a66c4:                 psDel, psi, psq2, psqSQLLength, 25, 19332, 18733, 18733, 0);
1:a4a66c4:         checkCharacterStreams(
1:a4a66c4:                 psDel, psi, psq2, psqSQLLength, 1, 32433, 32673, 32673, 0);
1:a4a66c4:         checkCharacterStreams(
1:a4a66c4:                 psDel, psi, psq2, psqSQLLength, 0, 32532, 32700, 32700, 0);
1:3f965ed: 
1:3f965ed:         psi.close();
1:3f965ed:         psDel.close();
1:3f965ed:         psq2.close();
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     private int getMaxId() throws SQLException {
1:3f965ed: 
1:3f965ed:         Statement stmt = createStatement();
1:3f965ed:         ResultSet rs = stmt.executeQuery("select max(id) from charstream");
1:3f965ed:         rs.next();
1:3f965ed:         int maxid = rs.getInt(1);
1:3f965ed:         rs.close();
1:3f965ed:         stmt.close();
1:3f965ed:         return maxid;
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     private void setAscii(PreparedStatement ps, int targetCol)
1:3f965ed:     throws Exception {
1:3f965ed:         byte[] asciiBytes = null;
1:3f965ed:         // correct byte count
1:3f965ed:         println("CORRECT NUMBER OF BYTES IN STREAM");
1:3f965ed:         asciiBytes = ASCII_VALUE.getBytes("US-ASCII");
1:3f965ed:         ps.setAsciiStream(targetCol,
1:3f965ed:                 new ByteArrayInputStream(asciiBytes), LEN_ASCII_VALUE);
1:3f965ed:         ps.executeUpdate();
1:3f965ed: 
1:3f965ed:         // less bytes than stream contains. JDBC 3.0 indicates it should throw
1:3f965ed:         // an exception (in Tutorial & reference book)
1:3f965ed:         println("MORE BYTES IN STREAM THAN PASSED IN VALUE");
1:3f965ed:         try {
1:3f965ed:             asciiBytes = "against Republicans George W. Bush ".
1:3f965ed:                     getBytes("US-ASCII");
1:3f965ed:             ps.setAsciiStream(targetCol,
1:3f965ed:                     new ByteArrayInputStream(asciiBytes), 19);
1:3f965ed:             ps.executeUpdate();
1:3f965ed:             fail("FAIL - MORE BYTES IN ASCII STREAM THAN SPECIFIED LENGTH");
1:3f965ed:         } catch (SQLException sqle) {
1:3f965ed:             assertSQLState("XJ001", sqle);
1:3f965ed:         }
1:3f965ed: 
1:3f965ed:         // more bytes than the stream contains JDBC 3.0 changed to indicate an
1:3f965ed:         // exception should be thrown. (in Tutorial & reference book)
1:3f965ed:         println("LESS BYTES IN STREAM THAN PASSED IN VALUE");
1:3f965ed:         try {
1:3f965ed:             asciiBytes = "and Dick Cheney.".getBytes("US-ASCII");
1:3f965ed:             ps.setAsciiStream(targetCol,
1:3f965ed:                     new ByteArrayInputStream(asciiBytes), 17);
1:3f965ed:             ps.executeUpdate();
1:3f965ed:             fail("FAIL - LESS BYTES IN ASCII STREAM THAN SPECIFIED LENGTH");
1:3f965ed:         } catch (SQLException sqle) {
1:3f965ed:             assertSQLState("XJ001", sqle);
1:3f965ed:         }
1:3f965ed: 
1:3f965ed:         // null
1:3f965ed:         println("NULL ASCII STREAM");
1:3f965ed:         ps.setAsciiStream(targetCol, null, 1);
1:3f965ed:         ps.executeUpdate();
1:3f965ed: 
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     private void setCharacter(PreparedStatement ps, int targetCol)
1:3f965ed:     throws Exception {
1:3f965ed:         Reader reader = null;
1:3f965ed: 
1:3f965ed:         // correct character count
1:3f965ed:         reader = new StringReader(CHAR_VALUE1);
1:3f965ed:         ps.setCharacterStream(targetCol, reader, LEN_CHAR_VALUE1);
1:3f965ed:         ps.executeUpdate();
1:3f965ed: 
1:3f965ed:         reader = new StringReader(CHAR_VALUE2);
1:3f965ed:         ps.setCharacterStream(targetCol, reader, LEN_CHAR_VALUE2);
1:3f965ed:         ps.executeUpdate();
1:3f965ed: 
1:3f965ed:         // less bytes than stream contains.
1:3f965ed:         try {
1:3f965ed:             reader = new StringReader("for comments he made at");
1:3f965ed:             ps.setCharacterStream(targetCol, reader, 20);
1:3f965ed:             ps.executeUpdate();
1:3f965ed:             fail("FAIL - MORE CHARACTERS IN READER THAN SPECIFIED LENGTH");
1:3f965ed:         } catch (SQLException sqle) {
1:3f965ed:             assertSQLState("XJ001", sqle);
1:3f965ed:         }
1:3f965ed: 
1:3f965ed:         // more bytes than the stream contains,
1:3f965ed:         // JDBC 3.0 changed to indicate an exception should be thrown.
1:3f965ed:         try {
1:3f965ed:             reader = new StringReader("a birthday party");
1:3f965ed:             ps.setCharacterStream(targetCol, reader, 17);
1:3f965ed:             ps.executeUpdate();
1:3f965ed:             fail("FAIL - LESS CHARACTERS IN READER THAN SPECIFIED LENGTH");
1:3f965ed:         } catch (SQLException sqle) {
1:3f965ed:             assertSQLState("XJ001", sqle);
1:3f965ed:         }
1:3f965ed: 
1:3f965ed:         // null
1:3f965ed:         ps.setCharacterStream(targetCol, null, 1);
1:3f965ed:         ps.executeUpdate();
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     private void verifyAsciiStreamResults(ResultSet rs, int col)
1:3f965ed:             throws Exception
1:3f965ed:     {
1:3f965ed:         String value;
1:3f965ed:         int length;
1:3f965ed: 
1:3f965ed:         // First row
1:3f965ed:         assertTrue("FAIL - row not found", rs.next());
1:3f965ed:         value = rs.getString(col * 2);
1:3f965ed:         assertFalse("FAIL - value should not be null", rs.wasNull());
1:3f965ed:         length = rs.getInt((col * 2) + 1);
1:3f965ed:         assertFalse("FAIL - length should not be null", rs.wasNull());
1:3f965ed: 
1:3f965ed:         assertEquals("FAIL - wrong value on column " + col,
1:3f965ed:                 ASCII_VALUE, value.trim());
1:3f965ed:         assertEquals("FAIL - wrong length " + col, LEN_ASCII_VALUE, length);
1:3f965ed: 
1:3f965ed:         // null row
1:3f965ed:         assertTrue("FAIL - row not found", rs.next());
1:3f965ed:         value = rs.getString(col * 2);
1:3f965ed:         assertTrue("FAIL - value should be null", rs.wasNull());
1:3f965ed:         length = rs.getInt((col * 2) + 1);
1:3f965ed:         assertTrue("FAIL - length should be null", rs.wasNull());
1:3f965ed: 
1:3f965ed:         assertEquals("FAIL - wrong value on column " + col, null, value);
1:3f965ed:         assertEquals("FAIL - wrong length " + col, 0, length);
1:3f965ed: 
1:3f965ed:         assertFalse("FAIL - more rows than expected", rs.next());
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     private void verifyCharStreamResults(ResultSet rs, int col)
1:3f965ed:     throws Exception {
1:3f965ed:         String value;
1:3f965ed:         int length;
1:3f965ed: 
1:3f965ed:         // First row
1:3f965ed:         assertTrue("FAIL - row not found", rs.next());
1:3f965ed:         value = rs.getString(col * 2);
1:3f965ed:         assertFalse("FAIL - value should not be null", rs.wasNull());
1:3f965ed:         length = rs.getInt((col * 2) + 1);
1:3f965ed:         assertFalse("FAIL - length should not be null", rs.wasNull());
1:3f965ed: 
1:3f965ed:         assertEquals("FAIL - wrong value on column " + col,
1:3f965ed:                 CHAR_VALUE1, value.trim());
1:3f965ed:         assertEquals("FAIL - wrong length " + col, LEN_CHAR_VALUE1, length);
1:3f965ed: 
1:3f965ed:         // Second row
1:3f965ed:         assertTrue("FAIL - row not found", rs.next());
1:3f965ed:         value = rs.getString(col * 2);
1:3f965ed:         assertFalse("FAIL - value should not be null", rs.wasNull());
1:3f965ed:         length = rs.getInt((col * 2) + 1);
1:3f965ed:         assertFalse("FAIL - length should not be null", rs.wasNull());
1:3f965ed: 
1:3f965ed:         assertEquals("FAIL - wrong value on column " + col,
1:3f965ed:                 CHAR_VALUE2, value.trim());
1:3f965ed:         assertEquals("FAIL - wrong length " + col, LEN_CHAR_VALUE2, length);
1:3f965ed: 
1:3f965ed:         // null row
1:3f965ed:         assertTrue("FAIL - row not found", rs.next());
1:3f965ed:         value = rs.getString(col * 2);
1:3f965ed:         assertTrue("FAIL - value should be null", rs.wasNull());
1:3f965ed:         length = rs.getInt((col * 2) + 1);
1:3f965ed:         assertTrue("FAIL - length should be null", rs.wasNull());
1:3f965ed: 
1:3f965ed:         assertEquals("FAIL - wrong value on column " + col, null, value);
1:3f965ed:         assertEquals("FAIL - wrong length " + col, 0, length);
1:3f965ed: 
1:3f965ed:         assertFalse("FAIL - more rows than expected", rs.next());
1:3f965ed:         rs.close();
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     private void verifyResultsUsingAsciiStream(ResultSet rs, int col)
1:3f965ed:             throws Exception
1:3f965ed:     {
1:3f965ed:         InputStream valueStream;
1:3f965ed:         String value;
1:3f965ed: 
1:3f965ed:         // First row
1:3f965ed:         assertTrue("FAIL - row not found", rs.next());
1:3f965ed:         valueStream = rs.getAsciiStream(col + 1);
1:3f965ed:         assertFalse("FAIL - value should not be null", rs.wasNull());
1:3f965ed: 
1:3f965ed:         byte[] valueBytes = new byte[LEN_ASCII_VALUE];
1:3f965ed:         assertEquals("FAIL - wrong length read from stream", LEN_ASCII_VALUE,
1:3f965ed:                 valueStream.read(valueBytes));
1:3f965ed:         assertEquals("FAIL - wrong value on column " + col,
1:3f965ed:                 ASCII_VALUE, new String(valueBytes, "US-ASCII"));
1:3f965ed: 
1:3f965ed:         // null row
1:3f965ed:         assertTrue("FAIL - row not found", rs.next());
1:3f965ed:         value = rs.getString(col + 1);
1:3f965ed:         assertTrue("FAIL - value should be null", rs.wasNull());
1:3f965ed: 
1:3f965ed:         assertEquals("FAIL - wrong value on column " + col, null, value);
1:3f965ed: 
1:3f965ed:         assertFalse("FAIL - more rows than expected", rs.next());
1:3f965ed:         rs.close();
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     private void verifyResultsUsingCharacterStream(ResultSet rs, int col)
1:3f965ed:             throws Exception
1:3f965ed:     {
1:3f965ed:         Reader valueReader;
1:3f965ed:         String value;
1:3f965ed: 
1:3f965ed:         // First row
1:3f965ed:         assertTrue("FAIL - row not found", rs.next());
1:3f965ed:         // Read characters one by one
1:3f965ed:         valueReader = rs.getCharacterStream(col + 1);
1:3f965ed:         StringBuffer sb = new StringBuffer();
1:3f965ed:         int c = 0;
1:3f965ed:         while ((c = valueReader.read()) != -1) {
1:3f965ed:             sb.append((char)c);
1:3f965ed:         }
1:3f965ed:         value = sb.toString().trim();
1:3f965ed:         assertEquals("FAIL - wrong length read from stream", LEN_ASCII_VALUE,
1:3f965ed:                 value.length());
1:3f965ed:         assertEquals("FAIL - wrong value on column " + col,
1:3f965ed:                 ASCII_VALUE, value);
1:3f965ed: 
1:3f965ed:         // null row
1:3f965ed:         assertTrue("FAIL - row not found", rs.next());
1:3f965ed:         value = rs.getString(col + 1);
1:3f965ed:         assertTrue("FAIL - value should be null", rs.wasNull());
1:3f965ed: 
1:3f965ed:         assertEquals("FAIL - wrong value on column " + col, null, value);
1:3f965ed: 
1:3f965ed:         assertFalse("FAIL - more rows than expected", rs.next());
1:3f965ed:         rs.close();
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     private void verifyResultsUsingCharacterStreamBlock(ResultSet rs, int col)
1:3f965ed:             throws Exception
1:3f965ed:     {
1:3f965ed:         Reader valueReader;
1:3f965ed:         String value;
1:3f965ed: 
1:3f965ed:         // First row
1:3f965ed:         assertTrue("FAIL - row not found", rs.next());
1:3f965ed:         valueReader = rs.getCharacterStream(col + 1);
1:3f965ed:         assertFalse("FAIL - value should not be null", rs.wasNull());
1:3f965ed:         // Read all characters in a block
1:3f965ed:         char[] valueChars = new char[LEN_ASCII_VALUE];
1:3f965ed:         assertEquals("FAIL - wrong length read from stream", LEN_ASCII_VALUE,
1:3f965ed:                 valueReader.read(valueChars));
1:3f965ed:         assertEquals("FAIL - wrong value on column " + col,
1:3f965ed:                 ASCII_VALUE, new String(valueChars));
1:3f965ed: 
1:3f965ed:         // null row
1:3f965ed:         assertTrue("FAIL - row not found", rs.next());
1:3f965ed:         value = rs.getString(col + 1);
1:3f965ed:         assertTrue("FAIL - value should be null", rs.wasNull());
1:3f965ed: 
1:3f965ed:         assertEquals("FAIL - wrong value on column " + col, null, value);
1:3f965ed: 
1:3f965ed:         assertFalse("FAIL - more rows than expected", rs.next());
1:3f965ed:         rs.close();
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     private void checkAsciiStreams(
1:3f965ed:             PreparedStatement psDel,
1:3f965ed:             PreparedStatement psi,
1:3f965ed:             PreparedStatement psq2,
2:3f965ed:             int cl, int vcl, int lvcl, int lob)
1:3f965ed:             throws SQLException, IOException {
1:3f965ed: 
1:3f965ed:         psDel.executeUpdate();
1:3f965ed: 
1:3f965ed:         // now insert long values using streams and check them programatically.
1:3f965ed:         psi.setAsciiStream(1, new c3AsciiStream(cl), cl);
1:3f965ed:         psi.setAsciiStream(2, new c3AsciiStream(vcl), vcl);
1:3f965ed:         psi.setAsciiStream(3, new c3AsciiStream(lvcl), lvcl);
1:3f965ed:         psi.setAsciiStream(4, new c3AsciiStream(lob), lob);
1:3f965ed:         psi.executeUpdate();
1:3f965ed: 
1:3f965ed:         ResultSet rs = psq2.executeQuery();
1:3f965ed:         rs.next();
1:3f965ed: 
1:3f965ed:         InputStream is = rs.getAsciiStream(1);
1:3f965ed:         checkAsciiStream(is, cl, 25);
1:3f965ed: 
1:3f965ed:         is = rs.getAsciiStream(2);
1:3f965ed:         checkAsciiStream(is, vcl, -1);
1:3f965ed: 
1:3f965ed:         is = rs.getAsciiStream(3);
1:3f965ed:         checkAsciiStream(is, lvcl, -1);
1:3f965ed: 
1:3f965ed:         is = rs.getAsciiStream(4);
1:3f965ed:         checkAsciiStream(is, lob, -1);
1:3f965ed: 
1:3f965ed:         rs.close();
1:3f965ed: 
1:3f965ed:         rs = psq2.executeQuery();
1:3f965ed:         rs.next();
1:3f965ed: 
1:3f965ed:         Reader r = rs.getCharacterStream(1);
1:3f965ed:         checkAsciiStream(r, cl, 25);
1:3f965ed: 
1:3f965ed:         r = rs.getCharacterStream(2);
1:3f965ed:         checkAsciiStream(r, vcl, -1);
1:3f965ed: 
1:3f965ed:         r = rs.getCharacterStream(3);
1:3f965ed:         checkAsciiStream(r, lvcl, -1);
1:3f965ed: 
1:3f965ed:         r = rs.getCharacterStream(4);
1:3f965ed:         checkAsciiStream(r, lob, -1);
1:3f965ed: 
1:3f965ed:         rs.close();
1:3f965ed: 
1:3f965ed:         // and check as Strings
1:3f965ed:         rs = psq2.executeQuery();
1:3f965ed:         rs.next();
1:3f965ed: 
1:3f965ed:         r = new StringReader(rs.getString(1));
1:3f965ed:         checkAsciiStream(r, cl, 25);
1:3f965ed: 
1:3f965ed:         r = new StringReader(rs.getString(2));
1:3f965ed:         checkAsciiStream(r, vcl, -1);
1:3f965ed: 
1:3f965ed:         r = new StringReader(rs.getString(3));
1:3f965ed:         checkAsciiStream(r, lvcl, -1);
1:3f965ed: 
1:3f965ed:         r = new StringReader(rs.getString(4));
1:3f965ed:         checkAsciiStream(r, lob, -1);
1:3f965ed: 
1:3f965ed:         rs.close();
1:3f965ed:     }
1:3f965ed: 
1:a4a66c4:     private Reader getSourceStream(int length, int bytesPerChar) {
1:a4a66c4:         switch (bytesPerChar) {
1:a4a66c4:             case 0:
1:a4a66c4:                 return new c3Reader(length);
1:a4a66c4:             case 1:
1:a4a66c4:                 return new LoopingAlphabetReader(length,
1:a4a66c4:                         CharAlphabet.modernLatinLowercase());
1:a4a66c4:             case 2:
1:a4a66c4:                 return new LoopingAlphabetReader(length,
1:a4a66c4:                         CharAlphabet.tamil());
1:a4a66c4:             case 3:
1:a4a66c4:                 return new LoopingAlphabetReader(length,
1:a4a66c4:                         CharAlphabet.cjkSubset());
1:a4a66c4:             default:
1:a4a66c4:                 fail("Illegal value of bytesPerChar: " + bytesPerChar);
1:a4a66c4:                 return null;
1:a4a66c4:         }
1:a4a66c4:     }
1:a4a66c4: 
1:3f965ed:     private void checkCharacterStreams(
1:3f965ed:             PreparedStatement psDel,
1:3f965ed:             PreparedStatement psi,
1:3f965ed:             PreparedStatement psq2,
1:a4a66c4:             PreparedStatement psqSQLLength,
1:a4a66c4:             int cl, int vcl, int lvcl, int lob,
1:a4a66c4:             int bytesPerChar)
1:3f965ed:             throws SQLException, IOException {
1:3f965ed:         psDel.executeUpdate();
1:3f965ed: 
1:a4a66c4:         psi.setCharacterStream(1, getSourceStream(cl, bytesPerChar), cl);
1:a4a66c4:         psi.setCharacterStream(2, getSourceStream(vcl, bytesPerChar), vcl);
1:a4a66c4:         psi.setCharacterStream(3, getSourceStream(lvcl, bytesPerChar), lvcl);
1:a4a66c4:         psi.setCharacterStream(4, getSourceStream(lob, bytesPerChar), lob);
1:3f965ed:         psi.executeUpdate();
1:3f965ed: 
1:a4a66c4:         ResultSet rsLength = psqSQLLength.executeQuery();
1:a4a66c4:         assertTrue(rsLength.next());
1:a4a66c4:         assertEquals(25, rsLength.getInt(1));   // CHAR
1:a4a66c4:         assertEquals(vcl, rsLength.getInt(2));  // VARCHAR
1:a4a66c4:         assertEquals(lvcl, rsLength.getInt(3)); // LONG VARCHAR
1:a4a66c4:         assertEquals(lob, rsLength.getInt(4));  //CLOB
1:a4a66c4:         assertFalse(rsLength.next());
1:a4a66c4:         rsLength.close();
1:a4a66c4: 
1:3f965ed:         ResultSet rs = psq2.executeQuery();
1:3f965ed:         rs.next();
1:3f965ed: 
1:3f965ed:         InputStream is = rs.getAsciiStream(1);
1:a4a66c4:         checkCharStream(is, cl, 25, bytesPerChar);
1:3f965ed: 
1:3f965ed:         is = rs.getAsciiStream(2);
1:a4a66c4:         checkCharStream(is, vcl, -1, bytesPerChar);
1:3f965ed: 
1:3f965ed:         is = rs.getAsciiStream(3);
1:a4a66c4:         checkCharStream(is, lvcl, -1, bytesPerChar);
1:3f965ed: 
1:3f965ed:         is = rs.getAsciiStream(4);
1:a4a66c4:         checkCharStream(is, lob, -1, bytesPerChar);
1:3f965ed: 
1:3f965ed:         rs.close();
1:3f965ed: 
1:3f965ed:         rs = psq2.executeQuery();
1:3f965ed:         rs.next();
1:3f965ed: 
1:3f965ed:         Reader r = rs.getCharacterStream(1);
1:a4a66c4:         checkCharStream(r, cl, 25, bytesPerChar);
1:3f965ed: 
1:3f965ed:         r = rs.getCharacterStream(2);
1:a4a66c4:         checkCharStream(r, vcl, -1, bytesPerChar);
1:3f965ed: 
1:3f965ed:         r = rs.getCharacterStream(3);
1:a4a66c4:         checkCharStream(r, lvcl, -1, bytesPerChar);
1:3f965ed: 
1:3f965ed:         r = rs.getCharacterStream(4);
1:a4a66c4:         checkCharStream(r, lob, -1, bytesPerChar);
1:3f965ed: 
1:3f965ed:         rs.close();
1:3f965ed: 
1:3f965ed:         // check converting them into Strings work
1:3f965ed:         rs = psq2.executeQuery();
1:3f965ed:         rs.next();
1:3f965ed: 
1:3f965ed:         String suv = rs.getString(1);
1:3f965ed:         r = new StringReader(suv);
1:a4a66c4:         checkCharStream(r, cl, 25, bytesPerChar);
1:3f965ed: 
1:3f965ed:         suv = rs.getString(2);
1:3f965ed:         r = new StringReader(suv);
1:a4a66c4:         checkCharStream(r, vcl, -1, bytesPerChar);
1:3f965ed: 
1:3f965ed:         suv = rs.getString(3);
1:3f965ed:         r = new StringReader(suv);
1:a4a66c4:         checkCharStream(r, lvcl, -1, bytesPerChar);
1:3f965ed: 
1:3f965ed:         suv = rs.getString(4);
1:3f965ed:         r = new StringReader(suv);
1:a4a66c4:         checkCharStream(r, lob, -1, bytesPerChar);
1:3f965ed: 
1:3f965ed:         rs.close();
1:3f965ed: 
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     private void checkAsciiStream(InputStream is, int length, int fixedLen)
1:3f965ed:             throws IOException
1:3f965ed:     {
1:3f965ed: 
1:3f965ed:         InputStream orig = new c3AsciiStream(length);
1:3f965ed: 
1:3f965ed:         int count = 0;
1:3f965ed:         for (;;) {
1:3f965ed: 
1:3f965ed:             int o = orig == null ?
1:3f965ed:                 (count == fixedLen ? -2 : 0x20) : orig.read();
1:3f965ed:             int c = is.read();
1:3f965ed:             if (o == -1) {
1:3f965ed:                 orig = null;
1:3f965ed:                 if (fixedLen != -1 && fixedLen != length)
1:3f965ed:                     o = ' ';
1:3f965ed:             }
1:3f965ed:             if (o == -2)
1:3f965ed:                 o = -1;
1:3f965ed: 
1:3f965ed:             assertEquals("FAIL - wrong value at position " + count, o, c);
1:3f965ed:             if (orig == null) {
1:3f965ed:                 if (fixedLen == -1)
1:3f965ed:                     break;
1:3f965ed:             }
1:3f965ed: 
1:3f965ed:             if (c == -1 && fixedLen != -1)
1:3f965ed:                 break;
1:3f965ed: 
1:3f965ed:             count++;
1:3f965ed:         }
1:3f965ed:         if (fixedLen != -1)
1:3f965ed:             length = fixedLen;
1:3f965ed: 
1:3f965ed:         assertEquals("FAIL - wrong length", length, count);
1:3f965ed:         is.close();
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     private void checkAsciiStream(Reader r, int length, int fixedLen)
1:3f965ed:             throws IOException
1:3f965ed:     {
1:3f965ed: 
1:3f965ed:         InputStream orig = new c3AsciiStream(length);
1:3f965ed: 
1:3f965ed:         int count = 0;
1:3f965ed:         for (;;) {
1:3f965ed: 
1:3f965ed:             int o = orig == null ?
1:3f965ed:                 (count == fixedLen ? -2 : 0x20) : orig.read();
1:3f965ed:             int c = r.read();
1:3f965ed:             if (o == -1) {
1:3f965ed:                 orig = null;
1:3f965ed:                 if (fixedLen != -1 && fixedLen != length)
1:3f965ed:                     o = ' ';
1:3f965ed:             }
1:3f965ed:             if (o == -2)
1:3f965ed:                 o = -1;
1:3f965ed: 
1:3f965ed:             assertEquals("FAIL - wrong value", o, c);
1:3f965ed:             if (orig == null) {
1:3f965ed:                 if (fixedLen == -1)
1:3f965ed:                     break;
1:3f965ed:             }
1:3f965ed: 
1:3f965ed:             if (c == -1 && fixedLen != -1)
1:3f965ed:                 break;
1:3f965ed: 
1:3f965ed:             count++;
1:3f965ed:         }
1:3f965ed:         if (fixedLen != -1)
1:3f965ed:             length = fixedLen;
1:3f965ed: 
1:3f965ed:         assertEquals("FAIL - wrong length", length, count);
1:3f965ed:         r.close();
1:3f965ed:     }
1:3f965ed: 
1:a4a66c4:     private void checkCharStream(InputStream is, int length, int fixedLen,
1:a4a66c4:                                  int bytesPerChar)
1:3f965ed:             throws IOException
1:3f965ed:     {
1:3f965ed: 
1:a4a66c4:         Reader orig = getSourceStream(length, bytesPerChar);
1:3f965ed: 
1:3f965ed:         int count = 0;
1:3f965ed:         for (;;) {
1:3f965ed: 
1:3f965ed:             int o = orig == null ?
1:3f965ed:                 (count == fixedLen ? -2 : 0x20) : orig.read();
1:3f965ed:             int c = is.read();
1:3f965ed:             if (o == -1) {
1:3f965ed:                 orig = null;
1:3f965ed:                 if (fixedLen != -1 && fixedLen != length)
1:3f965ed:                     o = ' ';
1:3f965ed:             }
1:3f965ed:             if (o == -2)
1:3f965ed:                 o = -1;
1:3f965ed: 
1:3f965ed:             if (o != -1) {
1:3f965ed:                 if (o <= 255)
1:3f965ed:                     o = o & 0xFF; // convert to single byte extended ASCII
1:3f965ed:                 else
1:3f965ed:                     o = '?'; // out of range character.
1:3f965ed:             }
1:3f965ed: 
1:3f965ed:             assertEquals("FAIL - wrong value", o, c);
1:3f965ed:             if (orig == null) {
1:3f965ed:                 if (fixedLen == -1)
1:3f965ed:                     break;
1:3f965ed:             }
1:3f965ed: 
1:3f965ed:             if (c == -1 && fixedLen != -1)
1:3f965ed:                 break;
1:3f965ed: 
1:3f965ed:             count++;
1:3f965ed:         }
1:3f965ed:         if (fixedLen != -1)
1:3f965ed:             length = fixedLen;
1:3f965ed: 
1:3f965ed:         assertEquals("FAIL - wrong length", length, count);
1:3f965ed:         is.close();
1:3f965ed:     }
1:3f965ed: 
1:a4a66c4:     private void checkCharStream(Reader r, int length, int fixedLen,
1:a4a66c4:                                  int bytesPerChar)
1:3f965ed:             throws IOException
1:3f965ed:     {
1:3f965ed: 
1:a4a66c4:         Reader orig = getSourceStream(length, bytesPerChar);
1:3f965ed: 
1:3f965ed:         int count = 0;
1:3f965ed:         for (;;) {
1:3f965ed: 
1:3f965ed:             int o = (orig == null) ?
1:3f965ed:                 (count == fixedLen ? -2 : 0x20) : orig.read();
1:3f965ed:             int c = r.read();
1:3f965ed:             if (o == -1) {
1:3f965ed:                 orig = null;
1:3f965ed:                 if (fixedLen != -1 && fixedLen != length)
1:3f965ed:                     o = ' ';
1:3f965ed:             }
1:3f965ed:             if (o == -2)
1:3f965ed:                 o = -1;
1:3f965ed: 
1:3f965ed:             assertEquals("FAIL - wrong value", o, c);
1:3f965ed:             if (orig == null) {
1:3f965ed:                 if (fixedLen == -1)
1:3f965ed:                     break;
1:3f965ed:             }
1:3f965ed: 
1:3f965ed:             if (c == -1 && fixedLen != -1)
1:3f965ed:                 break;
1:3f965ed: 
1:3f965ed:             count++;
1:3f965ed:         }
1:3f965ed:         if (fixedLen != -1)
1:3f965ed:             length = fixedLen;
1:3f965ed: 
1:3f965ed:         assertEquals("FAIL - wrong length", length, count);
1:3f965ed:         r.close();
1:3f965ed:     }
1:3f965ed: 
1:3f965ed: 
1:3f965ed:     protected void setUp() throws Exception {
1:3f965ed:         createStatement().executeUpdate(
1:3f965ed:                 "create table charstream(" +
1:3f965ed:                 "id int GENERATED ALWAYS AS IDENTITY primary key, " +
1:3f965ed:                 "c char(25), " +
1:3f965ed:                 "vc varchar(32532), " +
1:3f965ed:                 "lvc long varchar, " +
1:3f965ed:                 "lob clob(300K))");
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     protected void tearDown() throws Exception {
1:3f965ed:         rollback();
1:3f965ed:         createStatement().executeUpdate("DROP TABLE charstream");
1:3f965ed:         commit();
1:3f965ed:         super.tearDown();
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     private final static String ASCII_VALUE = "Lieberman ran with Gore";
1:3f965ed:     private final static int LEN_ASCII_VALUE = 23;
1:3f965ed: 
1:3f965ed:     private final static String CHAR_VALUE1 = "A Mississippi Republican";
1:3f965ed:     private final static int LEN_CHAR_VALUE1 = 24;
1:3f965ed: 
1:3f965ed:     private final static String CHAR_VALUE2 = "Lott has apologized";
1:3f965ed:     private final static int LEN_CHAR_VALUE2 = 19;
1:3f965ed: 
1:3f965ed: }
1:3f965ed: 
1:3f965ed: 
1:3f965ed: class c3AsciiStream extends InputStream {
1:3f965ed: 
1:3f965ed:     private final int size;
1:3f965ed:     private int count;
1:3f965ed:     c3AsciiStream(int size) {
1:3f965ed:         this.size = size;
1:3f965ed:     }
1:3f965ed:     public int read(byte[] buf, int off, int length) {
1:3f965ed:         if (count >= size)
1:3f965ed:             return -1;
1:3f965ed: 
1:3f965ed:         if (length > (size - count))
1:3f965ed:             length = (size - count);
1:3f965ed: 
1:3f965ed:         // ensure the readers don't always get a full buffer,
1:3f965ed:         // makes sure they are not assuming the buffer will be filled.
1:3f965ed: 
1:3f965ed:         if (length > 20)
1:3f965ed:             length -= 17;
1:3f965ed: 
1:3f965ed:         for (int i = 0; i < length ; i++) {
1:3f965ed:             buf[off + i] = (byte) count++;
1:3f965ed:         }
1:3f965ed: 
1:3f965ed:         return length;
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     private byte[] rd = new byte[1];
1:3f965ed:     public int read() {
1:3f965ed: 
1:3f965ed:         int read = read(rd, 0, 1);
1:3f965ed:         if (read == -1)
1:3f965ed:             return -1;
1:3f965ed:         return rd[0] & 0xFF;
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     public void close() {
1:3f965ed:     }
1:3f965ed: }
1:3f965ed: 
1:3f965ed: class c3Reader extends Reader {
1:3f965ed: 
1:3f965ed:     private final int size;
1:3f965ed:     private int count;
1:3f965ed:     c3Reader(int size) {
1:3f965ed:         this.size = size;
1:3f965ed:     }
1:3f965ed:     public int read(char[] buf, int off, int length) {
1:3f965ed:         if (count >= size)
1:3f965ed:             return -1;
1:3f965ed: 
1:3f965ed:         if (length > (size - count))
1:3f965ed:             length = (size - count);
1:3f965ed: 
1:3f965ed:         // ensure the readers don't always get a full buffer,
1:3f965ed:         // makes sure they are not assuming the buffer will be filled.
1:3f965ed: 
1:3f965ed:         if (length > 20)
1:3f965ed:             length -= 17;
1:3f965ed: 
1:3f965ed:         for (int i = 0; i < length ; i++) {
1:3f965ed:             char c;
1:3f965ed:             switch (count % 3) {
1:3f965ed:                 case 0:
1:3f965ed:                     c = (char) (count & 0x7F); // one byte UTF8
1:3f965ed:                     break;
1:3f965ed:                 case 1:
1:3f965ed:                     c = (char) ((count + 0x7F) & 0x07FF); // two byte UTF8
1:3f965ed:                     break;
1:3f965ed:                 default:
1:3f965ed:                 case 2:
1:3f965ed:                     c = (char) (count + 0x07FF); // three byte UTF8
1:3f965ed:                     break;
1:3f965ed: 
1:3f965ed:             }
1:3f965ed:             buf[off + i] = c;
1:3f965ed:             count++;
1:3f965ed:         }
1:3f965ed:         return length;
1:3f965ed:     }
1:3f965ed: 
1:3f965ed:     public void close() {
1:3f965ed:     }
1:3f965ed: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:  *   -&gt; setCharacterStream(int parameterIndex, InputStream x, int length)
1:  *   -&gt; setAsciiStream(int parameterIndex, Reader reader, int length)
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:a4a66c4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.streams.CharAlphabet;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement psqSQLLength = prepareStatement(
1:                 "select length(c), length(vc), length(lvc), length(lob) " +
1:                 "from charstream");
1:         checkCharacterStreams(
1:                 psDel, psi, psq2, psqSQLLength, 14, 93, 55, 55, 0);
1:         checkCharacterStreams(
1:                 psDel, psi, psq2, psqSQLLength, 21, 10887, 10887, 10887, 3);
1:         checkCharacterStreams(
1:                 psDel, psi, psq2, psqSQLLength, 25, 19332, 18733, 18733, 0);
1:         checkCharacterStreams(
1:                 psDel, psi, psq2, psqSQLLength, 1, 32433, 32673, 32673, 0);
1:         checkCharacterStreams(
1:                 psDel, psi, psq2, psqSQLLength, 0, 32532, 32700, 32700, 0);
/////////////////////////////////////////////////////////////////////////
1:     private Reader getSourceStream(int length, int bytesPerChar) {
1:         switch (bytesPerChar) {
1:             case 0:
1:                 return new c3Reader(length);
1:             case 1:
1:                 return new LoopingAlphabetReader(length,
1:                         CharAlphabet.modernLatinLowercase());
1:             case 2:
1:                 return new LoopingAlphabetReader(length,
1:                         CharAlphabet.tamil());
1:             case 3:
1:                 return new LoopingAlphabetReader(length,
1:                         CharAlphabet.cjkSubset());
1:             default:
1:                 fail("Illegal value of bytesPerChar: " + bytesPerChar);
1:                 return null;
1:         }
1:     }
1: 
1:             PreparedStatement psqSQLLength,
1:             int cl, int vcl, int lvcl, int lob,
1:             int bytesPerChar)
1:         psi.setCharacterStream(1, getSourceStream(cl, bytesPerChar), cl);
1:         psi.setCharacterStream(2, getSourceStream(vcl, bytesPerChar), vcl);
1:         psi.setCharacterStream(3, getSourceStream(lvcl, bytesPerChar), lvcl);
1:         psi.setCharacterStream(4, getSourceStream(lob, bytesPerChar), lob);
1:         ResultSet rsLength = psqSQLLength.executeQuery();
1:         assertTrue(rsLength.next());
1:         assertEquals(25, rsLength.getInt(1));   // CHAR
1:         assertEquals(vcl, rsLength.getInt(2));  // VARCHAR
1:         assertEquals(lvcl, rsLength.getInt(3)); // LONG VARCHAR
1:         assertEquals(lob, rsLength.getInt(4));  //CLOB
1:         assertFalse(rsLength.next());
1:         rsLength.close();
1: 
1:         checkCharStream(is, cl, 25, bytesPerChar);
1:         checkCharStream(is, vcl, -1, bytesPerChar);
1:         checkCharStream(is, lvcl, -1, bytesPerChar);
1:         checkCharStream(is, lob, -1, bytesPerChar);
/////////////////////////////////////////////////////////////////////////
1:         checkCharStream(r, cl, 25, bytesPerChar);
1:         checkCharStream(r, vcl, -1, bytesPerChar);
1:         checkCharStream(r, lvcl, -1, bytesPerChar);
1:         checkCharStream(r, lob, -1, bytesPerChar);
/////////////////////////////////////////////////////////////////////////
1:         checkCharStream(r, cl, 25, bytesPerChar);
1:         checkCharStream(r, vcl, -1, bytesPerChar);
1:         checkCharStream(r, lvcl, -1, bytesPerChar);
1:         checkCharStream(r, lob, -1, bytesPerChar);
/////////////////////////////////////////////////////////////////////////
1:     private void checkCharStream(InputStream is, int length, int fixedLen,
1:                                  int bytesPerChar)
1:         Reader orig = getSourceStream(length, bytesPerChar);
/////////////////////////////////////////////////////////////////////////
1:     private void checkCharStream(Reader r, int length, int fixedLen,
1:                                  int bytesPerChar)
1:         Reader orig = getSourceStream(length, bytesPerChar);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3f965ed
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class CharacterStreamsTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:  * either express or implied. See the License for the specific
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.io.ByteArrayInputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.Reader;
1: import java.io.StringReader;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Tests the following PreparedStatement methods:
0:  *   -> setCharacterStream(int parameterIndex, InputStream x, int length)
0:  *   -> setAsciiStream(int parameterIndex, Reader reader, int length)
1:  */
1: public class CharacterStreamsTest extends BaseJDBCTestCase {
1: 
1:     public static Test suite() {
1:         // Run only in embedded mode until DERBY-2017 is fixed.
1:         return TestConfiguration.embeddedSuite(CharacterStreamsTest.class);
1:     }
1: 
1:     /** Creates a new instance of CharacterStreamsTest */
1:     public CharacterStreamsTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Test PreparedStatement.setAsciiStream() with column of type CHAR
1:      */
1:     public void testSetAsciiStreamIntoChar() throws Exception {
1:         runTestSetAsciiStream(1);
1:     }
1: 
1:     /**
1:      * Test PreparedStatement.setAsciiStream() with column of type VARCHAR
1:      */
1:     public void testSetAsciiStreamIntoVarchar() throws Exception {
1:         runTestSetAsciiStream(2);
1:     }
1: 
1:     /**
1:      * Test PreparedStatement.setAsciiStream() with column of type LONG VARCHAR
1:      */
1:     public void testSetAsciiStreamIntoLongVarchar() throws Exception {
1:         runTestSetAsciiStream(3);
1:     }
1: 
1:     /**
1:      * Test PreparedStatement.setAsciiStream() with column of type CLOB
1:      */
1:     public void testSetAsciiStreamIntoClob() throws Exception {
1:         runTestSetAsciiStream(4);
1:     }
1: 
1:     /**
1:      * Test PreparedStatement.setCharacterStream() with column of type CHAR
1:      */
1:     public void testSetCharacterStreamIntoChar() throws Exception {
1:         runTestSetCharacterStream(1);
1:     }
1: 
1:     /**
1:      * Test PreparedStatement.setCharacterStream() with column of type VARCHAR
1:      */
1:     public void testSetCharacterStreamIntoVarchar() throws Exception {
1:         runTestSetCharacterStream(2);
1:     }
1: 
1:     /**
1:      * Test PreparedStatement.setCharacterStream() with column of type
1:      * LONG VARCHAR
1:      */
1:     public void testSetCharacterStreamIntoLongVarchar() throws Exception {
1:         runTestSetCharacterStream(3);
1:     }
1: 
1:     /**
1:      * Test PreparedStatement.setCharacterStream() with column of type CLOB
1:      */
1:     public void testSetCharacterStreamIntoClob() throws Exception {
1:         runTestSetCharacterStream(4);
1:     }
1: 
1:     /**
1:      * Test PreparedStatement.setAsciiStream() with streams with sizes from
1:      * 60characters to 32K characters
1:      */
1:     public void testSetAsciiStreamLongValues() throws Exception {
1:         runTestSetAsciiStreamLongValues();
1:     }
1: 
1:     /**
1:      * Test PreparedStatement.setCharacterStream() with streams with sizes from
1:      * 60 characters to 32K characters
1:      */
1:     public void testSetCharacterStreamLongValues() throws Exception {
1:         runTestSetCharacterStreamLongValues();
1:     }
1: 
1:     private void runTestSetAsciiStream(int col) throws Exception {
1:         PreparedStatement psi = prepareStatement(
1:                 "insert into charstream(c, vc, lvc, lob) " +
1:                 "values(?,?,?,?)");
1:         PreparedStatement psq = prepareStatement(
1:                 "select id, c, {fn length(c)} AS CLEN, " +
1:                 "cast (vc as varchar(25)) AS VC, " +
1:                 "{fn length(vc)} AS VCLEN, " +
1:                 "cast (lvc as varchar(25)) AS LVC, " +
1:                 "{fn length(lvc)} AS LVCLEN, " +
1:                 "cast (lob as varchar(25)) AS LOB, " +
1:                 "{fn length(lob)} AS LOBLEN " +
1:                 "from charstream " +
1:                 "where id > ? order by 1");
1: 
1:         // test setAsciiStream into CHAR
1:         println("\nTest setAsciiStream into CHAR");
1:         psi.setString(1, null);
1:         psi.setString(2, null);
1:         psi.setString(3, null);
1:         psi.setString(4, null);
1:         int maxid = getMaxId();
1:         setAscii(psi, col);
1:         psq.setInt(1, maxid);
1:         verifyAsciiStreamResults(psq.executeQuery(), col);
1: 
1:         // Show results as various streams
1:         PreparedStatement psStreams = prepareStatement(
1:                 "SELECT id, c, vc, lvc, lob " +
1:                 "FROM charstream where id > ? order by 1");
1:         psStreams.setInt(1, maxid);
1:         verifyResultsUsingAsciiStream(psStreams.executeQuery(), col);
1:         verifyResultsUsingCharacterStream(psStreams.executeQuery(), col);
1:         verifyResultsUsingCharacterStreamBlock(psStreams.executeQuery(), col);
1:         psStreams.close();
1: 
1:         psi.close();
1:         psq.close();
1: 
1:     }
1:     private void runTestSetCharacterStream(int col) throws Exception {
1:         PreparedStatement psi = prepareStatement(
1:                 "insert into charstream(c, vc, lvc, lob) " +
1:                 "values(?,?,?,?)");
1:         PreparedStatement psq = prepareStatement(
1:                 "select id, c, {fn length(c)} AS CLEN, " +
1:                 "cast (vc as varchar(25)) AS VC, " +
1:                 "{fn length(vc)} AS VCLEN, " +
1:                 "cast (lvc as varchar(25)) AS LVC, " +
1:                 "{fn length(lvc)} AS LVCLEN, " +
1:                 "cast (lob as varchar(25)) AS LOB, " +
1:                 "{fn length(lob)} AS LOBLEN " +
1:                 "from charstream " +
1:                 "where id > ? order by 1");
1: 
1:         // test setCharacterStream into CHAR
1:         println("\nTest setCharacterStream into CHAR");
1:         psi.setString(1, null);
1:         psi.setString(2, null);
1:         psi.setString(3, null);
1:         psi.setString(4, null);
1:         int maxid = getMaxId();
1:         setCharacter(psi, col);
1:         psq.setInt(1, maxid);
1:         verifyCharStreamResults(psq.executeQuery(), col);
1: 
1:         psi.close();
1:         psq.close();
1:     }
1: 
1:     private void runTestSetAsciiStreamLongValues() throws Exception {
1:         // now insert long values using streams and check them programatically.
1:         PreparedStatement psi = prepareStatement(
1:                 "insert into charstream(c, vc, lvc, lob) " +
1:                 "values(?,?,?,?)");
1:         PreparedStatement psDel = prepareStatement("DELETE FROM charstream");
1:         PreparedStatement psq2 =
1:                 prepareStatement("select c, vc, lvc, lob from charstream");
1: 
1:         // now insert long values using streams and check them programatically.
1:         println("setAsciiStream(LONG ASCII STREAMS)");
1:         checkAsciiStreams(psDel, psi, psq2, 18, 104, 67, 67);
1:         checkAsciiStreams(psDel, psi, psq2, 25, 16732, 14563, 14563);
1:         checkAsciiStreams(psDel, psi, psq2, 1, 32433, 32673, 32673);
1:         checkAsciiStreams(psDel, psi, psq2, 0, 32532, 32700, 32700);
1: 
1:         psi.close();
1:         psDel.close();
1:         psq2.close();
1:     }
1: 
1:     private void runTestSetCharacterStreamLongValues() throws Exception {
1:         // now insert long values using streams and check them programatically.
1:         PreparedStatement psi = prepareStatement(
1:                 "insert into charstream(c, vc, lvc, lob) " +
1:                 "values(?,?,?,?)");
1:         PreparedStatement psDel = prepareStatement("DELETE FROM charstream");
1:         PreparedStatement psq2 =
1:                 prepareStatement("select c, vc, lvc, lob from charstream");
1: 
1:         println("setCharacterStream(LONG CHARACTER STREAMS WITH UNICODE)");
0:         checkCharacterStreams(psDel, psi, psq2, 14, 93, 55, 55);
0:         checkCharacterStreams(psDel, psi, psq2, 25, 19332, 18733, 18733);
0:         checkCharacterStreams(psDel, psi, psq2, 1, 32433, 32673, 32673);
0:         checkCharacterStreams(psDel, psi, psq2, 0, 32532, 32700, 32700);
1: 
1:         psi.close();
1:         psDel.close();
1:         psq2.close();
1:     }
1: 
1:     private int getMaxId() throws SQLException {
1: 
1:         Statement stmt = createStatement();
1:         ResultSet rs = stmt.executeQuery("select max(id) from charstream");
1:         rs.next();
1:         int maxid = rs.getInt(1);
1:         rs.close();
1:         stmt.close();
1:         return maxid;
1:     }
1: 
1:     private void setAscii(PreparedStatement ps, int targetCol)
1:     throws Exception {
1:         byte[] asciiBytes = null;
1:         // correct byte count
1:         println("CORRECT NUMBER OF BYTES IN STREAM");
1:         asciiBytes = ASCII_VALUE.getBytes("US-ASCII");
1:         ps.setAsciiStream(targetCol,
1:                 new ByteArrayInputStream(asciiBytes), LEN_ASCII_VALUE);
1:         ps.executeUpdate();
1: 
1:         // less bytes than stream contains. JDBC 3.0 indicates it should throw
1:         // an exception (in Tutorial & reference book)
1:         println("MORE BYTES IN STREAM THAN PASSED IN VALUE");
1:         try {
1:             asciiBytes = "against Republicans George W. Bush ".
1:                     getBytes("US-ASCII");
1:             ps.setAsciiStream(targetCol,
1:                     new ByteArrayInputStream(asciiBytes), 19);
1:             ps.executeUpdate();
1:             fail("FAIL - MORE BYTES IN ASCII STREAM THAN SPECIFIED LENGTH");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ001", sqle);
1:         }
1: 
1:         // more bytes than the stream contains JDBC 3.0 changed to indicate an
1:         // exception should be thrown. (in Tutorial & reference book)
1:         println("LESS BYTES IN STREAM THAN PASSED IN VALUE");
1:         try {
1:             asciiBytes = "and Dick Cheney.".getBytes("US-ASCII");
1:             ps.setAsciiStream(targetCol,
1:                     new ByteArrayInputStream(asciiBytes), 17);
1:             ps.executeUpdate();
1:             fail("FAIL - LESS BYTES IN ASCII STREAM THAN SPECIFIED LENGTH");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ001", sqle);
1:         }
1: 
1:         // null
1:         println("NULL ASCII STREAM");
1:         ps.setAsciiStream(targetCol, null, 1);
1:         ps.executeUpdate();
1: 
1:     }
1: 
1:     private void setCharacter(PreparedStatement ps, int targetCol)
1:     throws Exception {
1:         Reader reader = null;
1: 
1:         // correct character count
1:         reader = new StringReader(CHAR_VALUE1);
1:         ps.setCharacterStream(targetCol, reader, LEN_CHAR_VALUE1);
1:         ps.executeUpdate();
1: 
1:         reader = new StringReader(CHAR_VALUE2);
1:         ps.setCharacterStream(targetCol, reader, LEN_CHAR_VALUE2);
1:         ps.executeUpdate();
1: 
1:         // less bytes than stream contains.
1:         try {
1:             reader = new StringReader("for comments he made at");
1:             ps.setCharacterStream(targetCol, reader, 20);
1:             ps.executeUpdate();
1:             fail("FAIL - MORE CHARACTERS IN READER THAN SPECIFIED LENGTH");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ001", sqle);
1:         }
1: 
1:         // more bytes than the stream contains,
1:         // JDBC 3.0 changed to indicate an exception should be thrown.
1:         try {
1:             reader = new StringReader("a birthday party");
1:             ps.setCharacterStream(targetCol, reader, 17);
1:             ps.executeUpdate();
1:             fail("FAIL - LESS CHARACTERS IN READER THAN SPECIFIED LENGTH");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ001", sqle);
1:         }
1: 
1:         // null
1:         ps.setCharacterStream(targetCol, null, 1);
1:         ps.executeUpdate();
1:     }
1: 
1:     private void verifyAsciiStreamResults(ResultSet rs, int col)
1:             throws Exception
1:     {
1:         String value;
1:         int length;
1: 
1:         // First row
1:         assertTrue("FAIL - row not found", rs.next());
1:         value = rs.getString(col * 2);
1:         assertFalse("FAIL - value should not be null", rs.wasNull());
1:         length = rs.getInt((col * 2) + 1);
1:         assertFalse("FAIL - length should not be null", rs.wasNull());
1: 
1:         assertEquals("FAIL - wrong value on column " + col,
1:                 ASCII_VALUE, value.trim());
1:         assertEquals("FAIL - wrong length " + col, LEN_ASCII_VALUE, length);
1: 
1:         // null row
1:         assertTrue("FAIL - row not found", rs.next());
1:         value = rs.getString(col * 2);
1:         assertTrue("FAIL - value should be null", rs.wasNull());
1:         length = rs.getInt((col * 2) + 1);
1:         assertTrue("FAIL - length should be null", rs.wasNull());
1: 
1:         assertEquals("FAIL - wrong value on column " + col, null, value);
1:         assertEquals("FAIL - wrong length " + col, 0, length);
1: 
1:         assertFalse("FAIL - more rows than expected", rs.next());
1:     }
1: 
1:     private void verifyCharStreamResults(ResultSet rs, int col)
1:     throws Exception {
1:         String value;
1:         int length;
1: 
1:         // First row
1:         assertTrue("FAIL - row not found", rs.next());
1:         value = rs.getString(col * 2);
1:         assertFalse("FAIL - value should not be null", rs.wasNull());
1:         length = rs.getInt((col * 2) + 1);
1:         assertFalse("FAIL - length should not be null", rs.wasNull());
1: 
1:         assertEquals("FAIL - wrong value on column " + col,
1:                 CHAR_VALUE1, value.trim());
1:         assertEquals("FAIL - wrong length " + col, LEN_CHAR_VALUE1, length);
1: 
1:         // Second row
1:         assertTrue("FAIL - row not found", rs.next());
1:         value = rs.getString(col * 2);
1:         assertFalse("FAIL - value should not be null", rs.wasNull());
1:         length = rs.getInt((col * 2) + 1);
1:         assertFalse("FAIL - length should not be null", rs.wasNull());
1: 
1:         assertEquals("FAIL - wrong value on column " + col,
1:                 CHAR_VALUE2, value.trim());
1:         assertEquals("FAIL - wrong length " + col, LEN_CHAR_VALUE2, length);
1: 
1:         // null row
1:         assertTrue("FAIL - row not found", rs.next());
1:         value = rs.getString(col * 2);
1:         assertTrue("FAIL - value should be null", rs.wasNull());
1:         length = rs.getInt((col * 2) + 1);
1:         assertTrue("FAIL - length should be null", rs.wasNull());
1: 
1:         assertEquals("FAIL - wrong value on column " + col, null, value);
1:         assertEquals("FAIL - wrong length " + col, 0, length);
1: 
1:         assertFalse("FAIL - more rows than expected", rs.next());
1:         rs.close();
1:     }
1: 
1:     private void verifyResultsUsingAsciiStream(ResultSet rs, int col)
1:             throws Exception
1:     {
1:         InputStream valueStream;
1:         String value;
1: 
1:         // First row
1:         assertTrue("FAIL - row not found", rs.next());
1:         valueStream = rs.getAsciiStream(col + 1);
1:         assertFalse("FAIL - value should not be null", rs.wasNull());
1: 
1:         byte[] valueBytes = new byte[LEN_ASCII_VALUE];
1:         assertEquals("FAIL - wrong length read from stream", LEN_ASCII_VALUE,
1:                 valueStream.read(valueBytes));
1:         assertEquals("FAIL - wrong value on column " + col,
1:                 ASCII_VALUE, new String(valueBytes, "US-ASCII"));
1: 
1:         // null row
1:         assertTrue("FAIL - row not found", rs.next());
1:         value = rs.getString(col + 1);
1:         assertTrue("FAIL - value should be null", rs.wasNull());
1: 
1:         assertEquals("FAIL - wrong value on column " + col, null, value);
1: 
1:         assertFalse("FAIL - more rows than expected", rs.next());
1:         rs.close();
1:     }
1: 
1:     private void verifyResultsUsingCharacterStream(ResultSet rs, int col)
1:             throws Exception
1:     {
1:         Reader valueReader;
1:         String value;
1: 
1:         // First row
1:         assertTrue("FAIL - row not found", rs.next());
1:         // Read characters one by one
1:         valueReader = rs.getCharacterStream(col + 1);
1:         StringBuffer sb = new StringBuffer();
1:         int c = 0;
1:         while ((c = valueReader.read()) != -1) {
1:             sb.append((char)c);
1:         }
1:         value = sb.toString().trim();
1:         assertEquals("FAIL - wrong length read from stream", LEN_ASCII_VALUE,
1:                 value.length());
1:         assertEquals("FAIL - wrong value on column " + col,
1:                 ASCII_VALUE, value);
1: 
1:         // null row
1:         assertTrue("FAIL - row not found", rs.next());
1:         value = rs.getString(col + 1);
1:         assertTrue("FAIL - value should be null", rs.wasNull());
1: 
1:         assertEquals("FAIL - wrong value on column " + col, null, value);
1: 
1:         assertFalse("FAIL - more rows than expected", rs.next());
1:         rs.close();
1:     }
1: 
1:     private void verifyResultsUsingCharacterStreamBlock(ResultSet rs, int col)
1:             throws Exception
1:     {
1:         Reader valueReader;
1:         String value;
1: 
1:         // First row
1:         assertTrue("FAIL - row not found", rs.next());
1:         valueReader = rs.getCharacterStream(col + 1);
1:         assertFalse("FAIL - value should not be null", rs.wasNull());
1:         // Read all characters in a block
1:         char[] valueChars = new char[LEN_ASCII_VALUE];
1:         assertEquals("FAIL - wrong length read from stream", LEN_ASCII_VALUE,
1:                 valueReader.read(valueChars));
1:         assertEquals("FAIL - wrong value on column " + col,
1:                 ASCII_VALUE, new String(valueChars));
1: 
1:         // null row
1:         assertTrue("FAIL - row not found", rs.next());
1:         value = rs.getString(col + 1);
1:         assertTrue("FAIL - value should be null", rs.wasNull());
1: 
1:         assertEquals("FAIL - wrong value on column " + col, null, value);
1: 
1:         assertFalse("FAIL - more rows than expected", rs.next());
1:         rs.close();
1:     }
1: 
1:     private void checkAsciiStreams(
1:             PreparedStatement psDel,
1:             PreparedStatement psi,
1:             PreparedStatement psq2,
1:             int cl, int vcl, int lvcl, int lob)
1:             throws SQLException, IOException {
1: 
1:         psDel.executeUpdate();
1: 
1:         // now insert long values using streams and check them programatically.
1:         psi.setAsciiStream(1, new c3AsciiStream(cl), cl);
1:         psi.setAsciiStream(2, new c3AsciiStream(vcl), vcl);
1:         psi.setAsciiStream(3, new c3AsciiStream(lvcl), lvcl);
1:         psi.setAsciiStream(4, new c3AsciiStream(lob), lob);
1:         psi.executeUpdate();
1: 
1:         ResultSet rs = psq2.executeQuery();
1:         rs.next();
1: 
1:         InputStream is = rs.getAsciiStream(1);
1:         checkAsciiStream(is, cl, 25);
1: 
1:         is = rs.getAsciiStream(2);
1:         checkAsciiStream(is, vcl, -1);
1: 
1:         is = rs.getAsciiStream(3);
1:         checkAsciiStream(is, lvcl, -1);
1: 
1:         is = rs.getAsciiStream(4);
1:         checkAsciiStream(is, lob, -1);
1: 
1:         rs.close();
1: 
1:         rs = psq2.executeQuery();
1:         rs.next();
1: 
1:         Reader r = rs.getCharacterStream(1);
1:         checkAsciiStream(r, cl, 25);
1: 
1:         r = rs.getCharacterStream(2);
1:         checkAsciiStream(r, vcl, -1);
1: 
1:         r = rs.getCharacterStream(3);
1:         checkAsciiStream(r, lvcl, -1);
1: 
1:         r = rs.getCharacterStream(4);
1:         checkAsciiStream(r, lob, -1);
1: 
1:         rs.close();
1: 
1:         // and check as Strings
1:         rs = psq2.executeQuery();
1:         rs.next();
1: 
1:         r = new StringReader(rs.getString(1));
1:         checkAsciiStream(r, cl, 25);
1: 
1:         r = new StringReader(rs.getString(2));
1:         checkAsciiStream(r, vcl, -1);
1: 
1:         r = new StringReader(rs.getString(3));
1:         checkAsciiStream(r, lvcl, -1);
1: 
1:         r = new StringReader(rs.getString(4));
1:         checkAsciiStream(r, lob, -1);
1: 
1:         rs.close();
1:     }
1: 
1:     private void checkCharacterStreams(
1:             PreparedStatement psDel,
1:             PreparedStatement psi,
1:             PreparedStatement psq2,
1:             int cl, int vcl, int lvcl, int lob)
1:             throws SQLException, IOException {
1:         psDel.executeUpdate();
1: 
0:         psi.setCharacterStream(1, new c3Reader(cl), cl);
0:         psi.setCharacterStream(2, new c3Reader(vcl), vcl);
0:         psi.setCharacterStream(3, new c3Reader(lvcl), lvcl);
0:         psi.setCharacterStream(4, new c3Reader(lob), lob);
1:         psi.executeUpdate();
1: 
1:         ResultSet rs = psq2.executeQuery();
1:         rs.next();
1: 
1:         InputStream is = rs.getAsciiStream(1);
0:         checkCharStream(is, cl, 25);
1: 
1:         is = rs.getAsciiStream(2);
0:         checkCharStream(is, vcl, -1);
1: 
1:         is = rs.getAsciiStream(3);
0:         checkCharStream(is, lvcl, -1);
1: 
1:         is = rs.getAsciiStream(4);
0:         checkCharStream(is, lob, -1);
1: 
1:         rs.close();
1: 
1:         rs = psq2.executeQuery();
1:         rs.next();
1: 
1:         Reader r = rs.getCharacterStream(1);
0:         checkCharStream(r, cl, 25);
1: 
1:         r = rs.getCharacterStream(2);
0:         checkCharStream(r, vcl, -1);
1: 
1:         r = rs.getCharacterStream(3);
0:         checkCharStream(r, lvcl, -1);
1: 
1:         r = rs.getCharacterStream(4);
0:         checkCharStream(r, lob, -1);
1: 
1:         rs.close();
1: 
1:         // check converting them into Strings work
1:         rs = psq2.executeQuery();
1:         rs.next();
1: 
1:         String suv = rs.getString(1);
1:         r = new StringReader(suv);
0:         checkCharStream(r, cl, 25);
1: 
1:         suv = rs.getString(2);
1:         r = new StringReader(suv);
0:         checkCharStream(r, vcl, -1);
1: 
1:         suv = rs.getString(3);
1:         r = new StringReader(suv);
0:         checkCharStream(r, lvcl, -1);
1: 
1:         suv = rs.getString(4);
1:         r = new StringReader(suv);
0:         checkCharStream(r, lob, -1);
1: 
1:         rs.close();
1: 
1:     }
1: 
1:     private void checkAsciiStream(InputStream is, int length, int fixedLen)
1:             throws IOException
1:     {
1: 
1:         InputStream orig = new c3AsciiStream(length);
1: 
1:         int count = 0;
1:         for (;;) {
1: 
1:             int o = orig == null ?
1:                 (count == fixedLen ? -2 : 0x20) : orig.read();
1:             int c = is.read();
1:             if (o == -1) {
1:                 orig = null;
1:                 if (fixedLen != -1 && fixedLen != length)
1:                     o = ' ';
1:             }
1:             if (o == -2)
1:                 o = -1;
1: 
1:             assertEquals("FAIL - wrong value at position " + count, o, c);
1:             if (orig == null) {
1:                 if (fixedLen == -1)
1:                     break;
1:             }
1: 
1:             if (c == -1 && fixedLen != -1)
1:                 break;
1: 
1:             count++;
1:         }
1:         if (fixedLen != -1)
1:             length = fixedLen;
1: 
1:         assertEquals("FAIL - wrong length", length, count);
1:         is.close();
1:     }
1: 
1:     private void checkAsciiStream(Reader r, int length, int fixedLen)
1:             throws IOException
1:     {
1: 
1:         InputStream orig = new c3AsciiStream(length);
1: 
1:         int count = 0;
1:         for (;;) {
1: 
1:             int o = orig == null ?
1:                 (count == fixedLen ? -2 : 0x20) : orig.read();
1:             int c = r.read();
1:             if (o == -1) {
1:                 orig = null;
1:                 if (fixedLen != -1 && fixedLen != length)
1:                     o = ' ';
1:             }
1:             if (o == -2)
1:                 o = -1;
1: 
1:             assertEquals("FAIL - wrong value", o, c);
1:             if (orig == null) {
1:                 if (fixedLen == -1)
1:                     break;
1:             }
1: 
1:             if (c == -1 && fixedLen != -1)
1:                 break;
1: 
1:             count++;
1:         }
1:         if (fixedLen != -1)
1:             length = fixedLen;
1: 
1:         assertEquals("FAIL - wrong length", length, count);
1:         r.close();
1:     }
1: 
0:     private void checkCharStream(InputStream is, int length, int fixedLen)
1:             throws IOException
1:     {
1: 
0:         Reader orig = new c3Reader(length);
1: 
1:         int count = 0;
1:         for (;;) {
1: 
1:             int o = orig == null ?
1:                 (count == fixedLen ? -2 : 0x20) : orig.read();
1:             int c = is.read();
1:             if (o == -1) {
1:                 orig = null;
1:                 if (fixedLen != -1 && fixedLen != length)
1:                     o = ' ';
1:             }
1:             if (o == -2)
1:                 o = -1;
1: 
1:             if (o != -1) {
1:                 if (o <= 255)
1:                     o = o & 0xFF; // convert to single byte extended ASCII
1:                 else
1:                     o = '?'; // out of range character.
1:             }
1: 
1:             assertEquals("FAIL - wrong value", o, c);
1:             if (orig == null) {
1:                 if (fixedLen == -1)
1:                     break;
1:             }
1: 
1:             if (c == -1 && fixedLen != -1)
1:                 break;
1: 
1:             count++;
1:         }
1:         if (fixedLen != -1)
1:             length = fixedLen;
1: 
1:         assertEquals("FAIL - wrong length", length, count);
1:         is.close();
1:     }
1: 
0:     private void checkCharStream(Reader r, int length, int fixedLen)
1:             throws IOException
1:     {
1: 
0:         Reader orig = new c3Reader(length);
1: 
1:         int count = 0;
1:         for (;;) {
1: 
1:             int o = (orig == null) ?
1:                 (count == fixedLen ? -2 : 0x20) : orig.read();
1:             int c = r.read();
1:             if (o == -1) {
1:                 orig = null;
1:                 if (fixedLen != -1 && fixedLen != length)
1:                     o = ' ';
1:             }
1:             if (o == -2)
1:                 o = -1;
1: 
1:             assertEquals("FAIL - wrong value", o, c);
1:             if (orig == null) {
1:                 if (fixedLen == -1)
1:                     break;
1:             }
1: 
1:             if (c == -1 && fixedLen != -1)
1:                 break;
1: 
1:             count++;
1:         }
1:         if (fixedLen != -1)
1:             length = fixedLen;
1: 
1:         assertEquals("FAIL - wrong length", length, count);
1:         r.close();
1:     }
1: 
1: 
1:     protected void setUp() throws Exception {
1:         createStatement().executeUpdate(
1:                 "create table charstream(" +
1:                 "id int GENERATED ALWAYS AS IDENTITY primary key, " +
1:                 "c char(25), " +
1:                 "vc varchar(32532), " +
1:                 "lvc long varchar, " +
1:                 "lob clob(300K))");
1:     }
1: 
1:     protected void tearDown() throws Exception {
1:         rollback();
1:         createStatement().executeUpdate("DROP TABLE charstream");
1:         commit();
1:         super.tearDown();
1:     }
1: 
1:     private final static String ASCII_VALUE = "Lieberman ran with Gore";
1:     private final static int LEN_ASCII_VALUE = 23;
1: 
1:     private final static String CHAR_VALUE1 = "A Mississippi Republican";
1:     private final static int LEN_CHAR_VALUE1 = 24;
1: 
1:     private final static String CHAR_VALUE2 = "Lott has apologized";
1:     private final static int LEN_CHAR_VALUE2 = 19;
1: 
1: }
1: 
1: 
1: class c3AsciiStream extends InputStream {
1: 
1:     private final int size;
1:     private int count;
1:     c3AsciiStream(int size) {
1:         this.size = size;
1:     }
1:     public int read(byte[] buf, int off, int length) {
1:         if (count >= size)
1:             return -1;
1: 
1:         if (length > (size - count))
1:             length = (size - count);
1: 
1:         // ensure the readers don't always get a full buffer,
1:         // makes sure they are not assuming the buffer will be filled.
1: 
1:         if (length > 20)
1:             length -= 17;
1: 
1:         for (int i = 0; i < length ; i++) {
1:             buf[off + i] = (byte) count++;
1:         }
1: 
1:         return length;
1:     }
1: 
1:     private byte[] rd = new byte[1];
1:     public int read() {
1: 
1:         int read = read(rd, 0, 1);
1:         if (read == -1)
1:             return -1;
1:         return rd[0] & 0xFF;
1:     }
1: 
1:     public void close() {
1:     }
1: }
1: 
1: class c3Reader extends Reader {
1: 
1:     private final int size;
1:     private int count;
1:     c3Reader(int size) {
1:         this.size = size;
1:     }
1:     public int read(char[] buf, int off, int length) {
1:         if (count >= size)
1:             return -1;
1: 
1:         if (length > (size - count))
1:             length = (size - count);
1: 
1:         // ensure the readers don't always get a full buffer,
1:         // makes sure they are not assuming the buffer will be filled.
1: 
1:         if (length > 20)
1:             length -= 17;
1: 
1:         for (int i = 0; i < length ; i++) {
1:             char c;
1:             switch (count % 3) {
1:                 case 0:
1:                     c = (char) (count & 0x7F); // one byte UTF8
1:                     break;
1:                 case 1:
1:                     c = (char) ((count + 0x7F) & 0x07FF); // two byte UTF8
1:                     break;
1:                 default:
1:                 case 2:
1:                     c = (char) (count + 0x07FF); // three byte UTF8
1:                     break;
1: 
1:             }
1:             buf[off + i] = c;
1:             count++;
1:         }
1:         return length;
1:     }
1: 
1:     public void close() {
1:     }
1: }
============================================================================