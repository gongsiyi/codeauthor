1:a30fb43: /*
21:a30fb43: 
1:a30fb43:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.TimeHandlingTest
1:a30fb43: 
1:a30fb43:    Licensed to the Apache Software Foundation (ASF) under one or more
1:a30fb43:    contributor license agreements.  See the NOTICE file distributed with
1:a30fb43:    this work for additional information regarding copyright ownership.
1:a30fb43:    The ASF licenses this file to You under the Apache License, Version 2.0
1:a30fb43:    (the "License"); you may not use this file except in compliance with
1:a30fb43:    the License.  You may obtain a copy of the License at
1:a30fb43: 
1:a30fb43:       http://www.apache.org/licenses/LICENSE-2.0
1:a30fb43: 
1:a30fb43:    Unless required by applicable law or agreed to in writing, software
1:a30fb43:    distributed under the License is distributed on an "AS IS" BASIS,
1:a30fb43:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:a30fb43:    See the License for the specific language governing permissions and
1:a30fb43:    limitations under the License.
1:a30fb43: 
1:a30fb43:  */
1:a30fb43: package org.apache.derbyTesting.functionTests.tests.lang;
1:a30fb43: 
1:76997ae: import java.sql.PreparedStatement;
1:a30fb43: import java.sql.ResultSet;
1:a30fb43: import java.sql.SQLException;
1:a30fb43: import java.sql.Statement;
1:a30fb43: import java.sql.Time;
1:a30fb43: import java.sql.Timestamp;
1:76997ae: import java.sql.Types;
1:a30fb43: import java.util.Calendar;
1:0c7cafc: import java.util.Random;
1:a30fb43: import junit.framework.Test;
1:a30fb43: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:a30fb43: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:c40688b: import org.apache.derbyTesting.junit.TestConfiguration;
1:a30fb43: 
1:a30fb43: 
1:a30fb43: public class TimeHandlingTest extends BaseJDBCTestCase {
1:76997ae:     
1:76997ae:     /**
1:76997ae:      * All the functions or expressions that result in
1:76997ae:      * a TIME value with the same value as CURRENT_TIME.
1:76997ae:      */
1:76997ae:     private static final String[] CURRENT_TIME_FUNCTIONS =
1:76997ae:     {"CURRENT TIME", "CURRENT_TIME"};
1:76997ae:     
1:76997ae:     /**
1:76997ae:      * All the functions or expressions that result in
1:76997ae:      * a TIMESTAMP value with the same value as CURRENT_TIMESTAMP.
1:76997ae:      */
1:76997ae:     private static final String[] CURRENT_TIMESTAMP_FUNCTIONS =
1:76997ae:     {"CURRENT TIMESTAMP", "CURRENT_TIMESTAMP"};    
1:a30fb43: 
1:76997ae:     /**
1:76997ae:      * Time to sleep that will result in different TIME values.
1:76997ae:      */
1:76997ae:     private static final long SLEEP_TIME = 2000;
1:a30fb43:     
1:76997ae:     /**
1:76997ae:      * Calendar for testing returned values.
1:76997ae:      */
1:a30fb43:     private Calendar cal;
1:76997ae: 
1:76997ae: 
1:c40688b:     /**
1:c40688b:      * Runs the tests in the default embedded configuration and then
1:c40688b:      * the client server configuration.
1:c40688b:      */
1:a30fb43:     public static Test suite()
2:a30fb43:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(TimeHandlingTest.class);
1:c40688b:         
1:eba07fc:         suite.addTest(TestConfiguration.clientServerSuite(TimeHandlingTest.class));
1:c40688b:         
1:a30fb43:         return new CleanDatabaseTestSetup(suite) {
1:a30fb43:             protected void decorateSQL(Statement s) throws SQLException {
1:a30fb43:                
1:a30fb43:                 s.execute("CREATE FUNCTION SLEEP() RETURNS INTEGER" +
1:a30fb43:                         " LANGUAGE JAVA PARAMETER STYLE JAVA" +
1:a30fb43:                         " NO SQL " +
1:a30fb43:                         " EXTERNAL NAME '"+
1:a30fb43:                         TimeHandlingTest.class.getName().concat(".sleep'"));
1:a30fb43:                 
1:a30fb43:                 s.execute("CREATE TABLE TIME_ALL (ID INT," +
1:a30fb43:                         " C_T TIME," +
1:a30fb43:                         " C_D DATE," +
1:76997ae:                         " C_TS TIMESTAMP)");
1:76997ae:                 
1:76997ae:                 for (int f = 0; f < CURRENT_TIME_FUNCTIONS.length; f++)
1:76997ae:                 {
1:76997ae:                     s.execute("ALTER TABLE TIME_ALL ADD COLUMN" +
1:76997ae:                             " D_T" + f + " TIME WITH DEFAULT " +
1:76997ae:                             CURRENT_TIME_FUNCTIONS[f]);
1:76997ae:                 }
1:76997ae:                 for (int f = 0; f < CURRENT_TIMESTAMP_FUNCTIONS.length; f++)
1:76997ae:                 {
1:76997ae:                     s.execute("ALTER TABLE TIME_ALL ADD COLUMN" +
1:76997ae:                             " D_TS" + f + " TIMESTAMP WITH DEFAULT " +
1:76997ae:                             CURRENT_TIMESTAMP_FUNCTIONS[f]);
1:76997ae:                 }
1:76997ae:            }
1:a30fb43:         };
9:a30fb43:     }
1:a30fb43:     
1:a30fb43:     /**
1:76997ae:      * Method for SQL SLEEP function. Sleeps for the time 
1:76997ae:      * that will result in a change in
1:76997ae:      * System.currentTimeMillis and a Derby TIME value.
1:a30fb43:      * @throws InterruptedException
1:a30fb43:      */
1:a30fb43:     public static int sleep() throws InterruptedException {
1:a30fb43:         Thread.sleep(SLEEP_TIME);
1:a30fb43:         return 0;
1:a30fb43:     }
1:a30fb43: 
1:a30fb43:     public TimeHandlingTest(String name) {
1:a30fb43:         super(name);
1:a30fb43:     }
1:a30fb43:     
1:a30fb43:     /**
1:0c7cafc:      * Simple set up, just get a Calendar
1:0c7cafc:      * and ensure the table T_ALL is empty.
1:0c7cafc:      * @throws SQLException 
1:a30fb43:      */
1:33efbae:     protected void setUp() throws SQLException
1:a30fb43:     {
1:a30fb43:         cal = Calendar.getInstance();
1:ea8303d:         Statement s  = createStatement();
1:ea8303d:         s.executeUpdate("DELETE FROM TIME_ALL");
1:ea8303d:         s.close();
1:a30fb43:     }
1:a30fb43:     
1:a30fb43:     /**
1:0c7cafc:      * Test inserting and selecting of TIME values.
1:0c7cafc:      * A set of random TIME values are inserted along with an
1:33efbae:      * identifier that encodes the time value. The values are then
1:0c7cafc:      * fetched and compared to a value calculated from the identifier.
1:0c7cafc:      * The returned values are fetched using checkTimeValue thus inheriting
1:0c7cafc:      * all the checks within that method.
1:c40688b:      * <BR>
1:bde1220:      * 
1:0c7cafc:      * @throws SQLException
1:0c7cafc:      */
1:33efbae:     public void testInsertTime() throws SQLException
1:0c7cafc:     {
1:0c7cafc:         getConnection().setAutoCommit(false);
1:0c7cafc:         // Insert a set of time values, 
1:0c7cafc: 
1:0c7cafc: 
1:0c7cafc:         Random r = new Random();
1:0c7cafc: 
1:0c7cafc:         // Insert 500 TIME values using a PreparedStatement,
1:0c7cafc:         // but randomly selecting the way the value is inserted
1:0c7cafc:         // between:
1:0c7cafc:         //  java.sql.Time object
1:0c7cafc:         //  String representation hh:mm:ss from Time.toString()
1:0c7cafc:         //  String representation hh.mm.ss
1:0c7cafc:         
1:0c7cafc:         // prime number used to select the way the
1:0c7cafc:         // selected value is inserted.
1:0c7cafc:         final int itk = 71;
1:0c7cafc: 
1:0c7cafc:         PreparedStatement ps = prepareStatement(
1:0c7cafc:            "INSERT INTO TIME_ALL(ID, C_T) VALUES (?, ?)");
1:0c7cafc:  
1:0c7cafc:         for (int i = 0; i < 500; i++) {
1:0c7cafc:             
1:0c7cafc:             // Just some big range from zero upwards
1:0c7cafc:             int id = r.nextInt(1000000);
1:0c7cafc:             ps.setInt(1, id);
1:0c7cafc:             
1:0c7cafc:             Time ct = getCodedTime(id);
1:0c7cafc:            
1:0c7cafc:             switch ((id % itk) % 3)
1:0c7cafc:             {
1:0c7cafc:             case 0: // Insert using Time object
1:0c7cafc:                 ps.setTime(2, ct);
1:0c7cafc:                 break;
1:0c7cafc:             case 1: // Insert using String provided by Time.toString() (hh:mm:ss)
1:0c7cafc:                 ps.setString(2, ct.toString());
1:0c7cafc:                 break;
1:0c7cafc:             case 2: // Insert using String format (hh.mm.ss)
1:0c7cafc:                 ps.setString(2, ct.toString().replace(':', '.'));
1:0c7cafc:                 break;
1:0c7cafc:             default:
1:0c7cafc:                fail("not reached");
1:0c7cafc:                
1:0c7cafc:              }
1:0c7cafc:             ps.executeUpdate();
1:0c7cafc:         }
1:0c7cafc:         ps.close();
1:0c7cafc:         commit();
1:0c7cafc:         
1:0c7cafc:         Statement s = createStatement();
1:0c7cafc:         
1:0c7cafc:         ResultSet rs = s.executeQuery("SELECT ID, C_T FROM TIME_ALL");
1:0c7cafc:         int rowCount = 0;
1:0c7cafc:         while (rs.next())
1:0c7cafc:         {
1:0c7cafc:             int id = rs.getInt(1);
1:0c7cafc:             Time t = checkTimeValue(rs, 2);          
1:0c7cafc:             assertTimeEqual(getCodedTime(id), t);
1:0c7cafc:             rowCount++;
1:0c7cafc:         }
1:0c7cafc:         rs.close();
1:0c7cafc:         s.close(); 
1:0c7cafc:         commit();
1:0c7cafc:         
1:0c7cafc:         assertEquals(rowCount, 500);
1:0c7cafc:     }
1:0c7cafc: 
1:0c7cafc:     /**
1:0c7cafc:      * Return a time simply encoded from an integer identifier
1:0c7cafc:      * and a set of fixed encoding keys, each a prime number.
1:0c7cafc:      * This allows a random value to be inserted into a table
1:0c7cafc:      * as a TIME and an INTEGER and thus checked for consistency
1:0c7cafc:      * on a SELECT.
1:0c7cafc:      * @param id
1:0c7cafc:      */
1:0c7cafc:     private Time getCodedTime(int id)
1:0c7cafc:     {
1:0c7cafc:         final int hk = 17;
1:0c7cafc:         final int mk = 41;
1:0c7cafc:         final int sk = 67;
1:0c7cafc: 
1:0c7cafc:         int hour = (id % hk) % 24;
1:0c7cafc:         int min = (id % mk) % 60;
1:0c7cafc:         int sec = (id % sk) % 60;
1:0c7cafc:         
1:0c7cafc:         return getTime19700101(hour, min ,sec);
1:0c7cafc:     }
1:0c7cafc: 
1:0c7cafc:     /**
1:a30fb43:      * Tests for CURRENT TIME and CURRENT_TIME.
1:a30fb43:      * A set of tests that ensure the CURRENT TIME maintains
1:76997ae:      * a single value for the life time of a statement and
1:76997ae:      * that (subject to the resolution) the returned value
1:76997ae:      * is correctly between the start time of the statement
1:76997ae:      * execution and the first fetch or completion.
1:c40688b:      * <BR>
1:bde1220:      * 
1:a30fb43:      * @throws SQLException
1:76997ae:      * @throws InterruptedException 
1:a30fb43:      */
1:bde1220:     public void testCurrentTime() throws SQLException, InterruptedException
1:76997ae:     {      
1:76997ae:         currentFunctionTests(Types.TIME, CURRENT_TIME_FUNCTIONS);      
1:76997ae:     }
1:76997ae:     
1:76997ae:     /**
1:76997ae:      * Tests for CURRENT TIMESTAMP functions.
1:76997ae:      * A set of tests that ensure the CURRENT TIMESTAMP maintains
1:76997ae:      * a single value for the life time of a statement and
1:76997ae:      * that (subject to the resolution) the returned value
1:76997ae:      * is correctly between the start time of the statement
1:76997ae:      * execution and the first fetch or completion.
1:76997ae:      * @throws SQLException
1:76997ae:      * @throws InterruptedException 
1:76997ae:      */
1:76997ae:     public void testCurrentTimestamp() throws SQLException, InterruptedException
1:76997ae:     {      
1:76997ae:         currentFunctionTests(Types.TIMESTAMP, CURRENT_TIMESTAMP_FUNCTIONS);      
1:76997ae:     }    
1:76997ae:     /**
1:76997ae:      * Test all the current timedate functions passed in that
1:76997ae:      * return the specified type. Generic function that checks
1:76997ae:      * the functions' are all identical in various situations
1:76997ae:      * and that the have the correct value, and change across
1:76997ae:      * executions.
1:76997ae:      * 
1:76997ae:      * @param jdbcType JDBC type, Types.TIME, DATE or TIMESTAMP.
1:76997ae:      * @param functions List of functions or expressions that map to the
1:76997ae:      * current time date value and return the specified type.
1:76997ae:      * @throws SQLException
1:76997ae:      * @throws InterruptedException 
1:76997ae:      */
1:76997ae:     private void currentFunctionTests(int jdbcType, String[] functions)
1:76997ae:     throws SQLException, InterruptedException
1:a30fb43:     {
1:a30fb43:         Statement s = createStatement();
1:76997ae: 
1:76997ae:         // Single value returned by each function.
1:76997ae:         for (int f = 0; f < functions.length; f++) {
1:76997ae:             checkCurrentQuery(jdbcType, s, "VALUES " + functions[f],
1:76997ae:                     new int[] {1}, 1);
1:76997ae:         }
1:a30fb43:         
1:76997ae:         // Create text for a single row in a VALUES clause,
1:76997ae:         // each function represented once.
1:76997ae:         StringBuffer rb = new StringBuffer("(");
1:76997ae:         for (int f = 0; f < functions.length; f++) {
1:76997ae:             if (f != 0)
1:76997ae:                 rb.append(", ");
1:76997ae:             rb.append(functions[f]);
1:76997ae:         }
1:76997ae:         rb.append(")");
1:76997ae:         String row = rb.toString();
1:a30fb43:         
1:76997ae:         int[] columns = new int[functions.length];
1:76997ae:         for (int f = 0; f < columns.length; f++)
1:76997ae:             columns[f] = f + 1;
1:a30fb43:         
1:76997ae:         // All the functions as a single row, all return the same value
1:76997ae:         String sql = "VALUES " + row;
1:76997ae:         checkCurrentQuery(jdbcType, s, sql, columns, functions.length);
1:76997ae: 
1:76997ae:         
1:76997ae:         // Check they produce the same value across multiple rows
1:76997ae:         sql = "VALUES " + row + "," + row + "," + row;
1:76997ae:         checkCurrentQuery(jdbcType, s, sql, columns, 3 * functions.length);
1:a30fb43: 
2:a30fb43:         // Check they produce the same value across multiple rows
1:a30fb43:         // with a forced sleep within row creaton
1:76997ae:         String sleepRow = row.substring(0, row.length() - 1)
1:76997ae:              + ", SLEEP())";
1:76997ae:         
1:76997ae:         sql =  "VALUES " + sleepRow + "," + sleepRow + "," + sleepRow;
1:76997ae:         checkCurrentQuery(jdbcType, s, sql, columns, 3 * functions.length);
1:76997ae: 
1:a30fb43:         
1:a30fb43:         // Check behaviour in non-queries.
1:76997ae:         String ccol = null;
1:76997ae:         String dcol = null;
1:76997ae:         switch (jdbcType)
1:76997ae:         {
1:76997ae:         case Types.TIME:
1:76997ae:             dcol = "D_T";
1:76997ae:             ccol = "C_T";
1:76997ae:             break;
1:76997ae:         case Types.TIMESTAMP:
1:76997ae:             dcol = "D_TS";
1:76997ae:             ccol = "C_TS";
1:76997ae:             break;            
1:76997ae:         case Types.DATE:
1:76997ae:             dcol = "D_D";
1:76997ae:             ccol = "C_D";
1:76997ae:             break; 
1:76997ae:         default:
1:76997ae:             fail("Unexpected JDBC Type " + jdbcType);
1:76997ae:         }
1:a30fb43:         
1:76997ae:         // All the functions as multiple rows,  one function per row.
1:76997ae:         StringBuffer rm = new StringBuffer();
1:76997ae:         for (int f = 0; f < functions.length; f++) {
1:76997ae:             if (f != 0)
1:76997ae:                 rm.append(", ");
1:76997ae:             rm.append(functions[f]);
1:76997ae:         }
1:76997ae:         String mrow = rm.toString();
1:a30fb43:         
1:76997ae:         // Select list with all the columns of this type
1:76997ae:         StringBuffer sb = new StringBuffer();
1:76997ae:         sb.append(ccol); // Column without the defaul
1:76997ae:         for (int f = 0; f < functions.length; f++) {
1:76997ae:             sb.append(", ");
1:76997ae:             sb.append(dcol);
1:76997ae:             sb.append(f);
1:76997ae:         }
1:76997ae:         String typeColumnList = sb.toString();
1:76997ae:         String selectAllType = "SELECT " + typeColumnList + " FROM TIME_ALL";
1:76997ae:         
1:76997ae:         int[] tableColumns = new int[columns.length + 1];
1:76997ae:         for (int i = 0; i < tableColumns.length; i++)
1:76997ae:             tableColumns[i] = i+1;
1:76997ae:                     
1:76997ae:         // Insert multiple rows, one per function
1:76997ae:         // Check all the inserted value and the default
1:76997ae:         // columns have the same value.
1:76997ae:         String insert = "INSERT INTO TIME_ALL(" + ccol + ") VALUES " + mrow;
2:a30fb43:         s.executeUpdate("DELETE FROM TIME_ALL");
1:76997ae:         long start = System.currentTimeMillis();
1:76997ae:         s.executeUpdate(insert);
1:76997ae:         long end = System.currentTimeMillis();
1:76997ae:         ResultSet rs = s.executeQuery(selectAllType);
7:a30fb43:         rs.next();
1:76997ae:         checkCurrentMultiple(jdbcType, start, end, rs, tableColumns, 
1:76997ae:                 functions.length * (functions.length + 1));
8:a30fb43:         rs.close();
1:a30fb43:         
1:a30fb43:         // Insert of multiple rows from a query with a delay
1:76997ae:         // All the functions as multiple rows,  one function per row
1:76997ae:         // with a SLEEP as the first column.
1:76997ae:         sb = new StringBuffer();
1:76997ae:         for (int f = 0; f < functions.length; f++) {
1:76997ae:             if (f != 0)
1:76997ae:                 sb.append(", ");
1:76997ae:             sb.append("(SLEEP(), ");
1:76997ae:             sb.append(functions[f]);
1:76997ae:             sb.append(")");
1:76997ae:         }
1:76997ae:         String mSleepRow = sb.toString();
1:76997ae:         
1:76997ae:         insert = "INSERT INTO TIME_ALL(ID, " + ccol + ") " +
1:76997ae:           " SELECT * FROM TABLE (VALUES " +
1:76997ae:           mSleepRow +
1:76997ae:           ") AS T";
1:76997ae:        
1:a30fb43:         s.executeUpdate("DELETE FROM TIME_ALL");
7:a30fb43:         start = System.currentTimeMillis();
1:76997ae:         s.executeUpdate(insert);
1:76997ae:         end = System.currentTimeMillis();
1:76997ae:         rs = s.executeQuery(selectAllType);
1:a30fb43:         rs.next();
1:76997ae:         checkCurrentMultiple(jdbcType, start, end, rs, tableColumns,
1:76997ae:                 functions.length * (functions.length + 1));
1:76997ae:         rs.close();
1:76997ae:         
1:76997ae:         // Ensure a PreparedStatement (psI) resets its current time correctly
1:76997ae:         // and does not get stuck with a single value for all executions.
1:76997ae:         PreparedStatement psQ = prepareStatement(
1:76997ae:                 selectAllType + " WHERE ID = ?");
1:76997ae:         
1:76997ae:         Object last = null;
1:76997ae:         for (int f = 0; f < functions.length; f++) {
1:76997ae:             PreparedStatement psI = prepareStatement("INSERT INTO TIME_ALL(ID, " +
1:76997ae:                     ccol + ")" +
1:76997ae:                     " VALUES (?, " + functions[f] +")");
1:76997ae:             s.executeUpdate("DELETE FROM TIME_ALL");
1:76997ae: 
1:76997ae:             for (int i = 1; i <=3; i++) {
1:76997ae:                psI.setInt(1, i);
1:76997ae:                psQ.setInt(1, i);   
1:76997ae:                start = System.currentTimeMillis();
1:76997ae:                psI.executeUpdate();
1:76997ae:                end = System.currentTimeMillis();
1:76997ae: 
1:76997ae:                rs = psQ.executeQuery();
1:76997ae:                rs.next();
1:76997ae:                Object next = checkCurrentMultiple(jdbcType, start, end, rs,
1:76997ae:                        tableColumns, functions.length + 1);
1:76997ae:                rs.close();
1:76997ae:                
1:76997ae:                if (last != null) {
1:76997ae:                    // This check is redundant because the last and next have
1:76997ae:                    // been checked they are within limit of the start and end.
1:76997ae:                    // But why not check it.
1:76997ae:                    assertFalse("CURRENT value not changed over executions",
1:76997ae:                            last.equals(next));
1:76997ae:                }
1:76997ae:                last = next;
1:76997ae:                      
1:76997ae:                // Ensure the next execution is meant to get a different value
1:76997ae:                Thread.sleep(SLEEP_TIME);
1:76997ae:             }
1:76997ae:             psI.close();
1:76997ae: 
1:76997ae:         }
1:76997ae: 
1:76997ae:         psQ.close();
1:a30fb43:         s.close();
1:a30fb43:     }
1:a30fb43:     
1:a30fb43:     /**
1:76997ae:      * Execute a query that uses CURRENT expressions directly.
1:76997ae:      * The time returned for these values should be between the
1:76997ae:      * start of execution and after the return from the first rs.next().
1:76997ae:      * @param sqlType
1:76997ae:      * @param s
1:76997ae:      * @param sql
1:76997ae:      * @param columns
1:76997ae:      * @param expectedCount
1:76997ae:      * @throws SQLException
1:76997ae:      */
1:76997ae:     private void checkCurrentQuery(int sqlType,
1:76997ae:             Statement s, String sql, int[] columns, int expectedCount)
1:76997ae:     throws SQLException
1:76997ae:     {
1:76997ae:         long start = System.currentTimeMillis();
1:76997ae:         ResultSet rs = s.executeQuery(sql);
1:76997ae:         rs.next();
1:76997ae:         long end = System.currentTimeMillis();
1:76997ae:         checkCurrentMultiple(sqlType, start, end, rs,
1:76997ae:                 columns, expectedCount);
1:76997ae:         rs.close();       
1:76997ae:     }
1:76997ae:     
1:76997ae:     /**
1:76997ae:      * Check the validity of all CURRENT time values returned and
1:76997ae:      * that they are identical.
1:76997ae:      * @param jdbcType Types.TIME or TIMESTAMP
1:76997ae:      * @param start Start of window for valid value.
1:76997ae:      * @param end End of window for valid value.
1:76997ae:      * @param rs Result set positioned  on row.
1:76997ae:      * @param columns Columns holding current values.
1:76997ae:      * @param expectedCount Total number of values exected to see
1:76997ae:      * (row count times column count)
1:76997ae:      * @throws SQLException
1:76997ae:      */
1:76997ae:     private Object checkCurrentMultiple(int jdbcType, long start, long end, ResultSet rs,
1:76997ae:             int[] columns, int expectedCount) throws SQLException
1:76997ae:    {
1:76997ae:         switch (jdbcType)
1:76997ae:         {
1:76997ae:         case Types.TIME:
1:76997ae:             return checkCurrentTimeMultiple(start, end, rs, columns, expectedCount);
1:76997ae:         case Types.TIMESTAMP:
1:76997ae:             return checkCurrentTimestampMultiple(start, end, rs, columns, expectedCount);
1:76997ae:         default:
1:76997ae:             fail("Unexpected type " + jdbcType);
1:76997ae:         return null;
1:76997ae:         }
1:76997ae:   }
1:76997ae:     
1:76997ae:     /**
1:a30fb43:      * Check a set of rows and columns with values set to CURRENT TIME
1:a30fb43:      * in a single statement are the same.
1:a30fb43:      * @param start Start time for the statement that set the values.
1:a30fb43:      * @param end End time for the statement that set the values.
1:a30fb43:      * @param rs ResultSet positioned on the first row.
1:a30fb43:      * @param columns Set of columns holding the TIME values
1:a30fb43:      * @param expectedCount Number of values we are execpted to check.
1:a30fb43:      * @throws SQLException
1:a30fb43:      */
1:76997ae:     private Time checkCurrentTimeMultiple(long start, long end, ResultSet rs,
1:a30fb43:             int[] columns, int expectedCount) throws SQLException
1:a30fb43:     {   
1:a30fb43:         // Result set is positioned on starting row
1:a30fb43:         // Since all values must be the same since they are based upon
1:a30fb43:         // CURRENT TIME from a single statement, pick one as the base
1:a30fb43:         // and compare the rest to it.
1:a30fb43:         Time base = checkCurrentTimeValue(start, end, rs, columns[0]);
1:a30fb43:         assertNotNull(base);
1:a30fb43:         int count = 1;
1:a30fb43:         
1:a30fb43:         // check the remaining columns on this row.
1:a30fb43:         for (int i = 1; i < columns.length; i++)
1:a30fb43:         {
1:a30fb43:             Time t = checkCurrentTimeValue(start, end, rs, columns[i]);
1:a30fb43:             assertEquals("CURENT TIME changed during execution", base, t);
1:a30fb43:             count++;
1:a30fb43:         }
1:76997ae:         
1:a30fb43:         // now check all columns on any remaining rows
1:a30fb43:         while (rs.next()) {
1:a30fb43:             for (int i = 0; i < columns.length; i++)
1:a30fb43:             {
1:a30fb43:                 Time t = checkCurrentTimeValue(start, end, rs, columns[i]);
1:a30fb43:                 assertEquals("CURENT TIME changed during execution", base, t);
1:a30fb43:                 count++;
1:a30fb43:             }
1:a30fb43:         }
1:a30fb43:         
1:a30fb43:         assertEquals(expectedCount, count);
1:76997ae:         
1:76997ae:         return base;
1:a30fb43:     }
1:76997ae:     /**
1:76997ae:      * Check a set of rows and columns with values set to CURRENT TIMESTAMP
1:76997ae:      * in a single statement are the same.
1:76997ae:      * @param start Start time for the statement that set the values.
1:76997ae:      * @param end End time for the statement that set the values.
1:76997ae:      * @param rs ResultSet positioned on the first row.
1:76997ae:      * @param columns Set of columns holding the TIME values
1:76997ae:      * @param expectedCount Number of values we are execpted to check.
1:76997ae:      * @throws SQLException
1:76997ae:      */
1:76997ae:     private Timestamp checkCurrentTimestampMultiple(long start, long end, ResultSet rs,
1:76997ae:             int[] columns, int expectedCount) throws SQLException
1:76997ae:     {   
1:76997ae:         // Result set is positioned on starting row
1:76997ae:         // Since all values must be the same since they are based upon
1:76997ae:         // CURRENT TIME from a single statement, pick one as the base
1:76997ae:         // and compare the rest to it.
1:76997ae:         Timestamp base = checkCurrentTimestampValue(start, end, rs, columns[0]);
1:76997ae:         assertNotNull(base);
1:76997ae:         int count = 1;
1:76997ae:         
1:76997ae:         // check the remaining columns on this row.
1:76997ae:         for (int i = 1; i < columns.length; i++)
1:76997ae:         {
1:76997ae:             Timestamp ts = checkCurrentTimestampValue(start, end, rs, columns[i]);
1:76997ae:             assertEquals("CURENT TIMESTAMP changed during execution", base, ts);
1:76997ae:             count++;
1:76997ae:         }
1:76997ae:         
1:76997ae:         // now check all columns on any remaining rows
1:76997ae:         while (rs.next()) {
1:76997ae:             for (int i = 0; i < columns.length; i++)
1:76997ae:             {
1:76997ae:                 Timestamp ts = checkCurrentTimestampValue(start, end, rs, columns[i]);
1:76997ae:                 assertEquals("CURENT TIMESTAMP changed during execution", base, ts);
1:76997ae:                 count++;
1:76997ae:             }
1:76997ae:         }
1:76997ae:         
1:76997ae:         assertEquals(expectedCount, count);
1:a30fb43:         
1:76997ae:         return base;
1:76997ae:     }    
1:a30fb43:     /**
1:a30fb43:      * Check the consistency of a ResultSet column that returns
1:a30fb43:      * a TIME value. Can be used for any column of type TIME.
1:a30fb43:      * 
1:a30fb43:      * @param rs ResultSet holding the column, positioned on a row
1:a30fb43:      * @param column Column with the TIME value.
1:a30fb43:      * @return Returns the Time object obtained from the column.
1:a30fb43:      * @throws SQLException
1:a30fb43:      */
1:a30fb43:     private Time checkTimeValue(ResultSet rs, int column) throws SQLException
1:a30fb43:     {
1:a30fb43:         assertEquals(java.sql.Types.TIME, rs.getMetaData().getColumnType(column));
1:a30fb43:         
2:a30fb43:         try {
1:a30fb43:             rs.getDate(column);
1:a30fb43:             fail("ResultSet.getDate() succeeded on TIME column");
1:a30fb43:         } catch (SQLException e) {
1:a30fb43:             assertSQLState("22005", e);
1:a30fb43:         }
1:a30fb43:   
1:a30fb43:         Time tv = rs.getTime(column);
1:a30fb43:         assertEquals(tv == null, rs.wasNull());
1:a30fb43:         
1:76997ae:         Object ov = rs.getObject(column);
1:76997ae:         assertEquals(ov == null, rs.wasNull());
1:76997ae:         
1:76997ae:         if (tv == null) {
1:76997ae:             assertNull(ov);
1:76997ae:             return null;
1:76997ae:         }
1:76997ae:         
1:76997ae:         assertTrue(ov instanceof java.sql.Time);
1:76997ae:         assertEquals(tv, ov);
1:76997ae:          
1:a30fb43:         // Check the date portion is set to 1970/01/01
1:76997ae:         assertTime1970(tv);
3:a30fb43:         cal.clear();
1:76997ae:         cal.setTime(tv);
1:a30fb43:         
1:a30fb43:         // Check the milli-seconds portion is 0
1:a30fb43:         // Derby does not support that precision in TIME
2:a30fb43:         assertEquals(0, cal.get(Calendar.MILLISECOND));
1:a30fb43:         
1:a30fb43:         long now = System.currentTimeMillis();
1:a30fb43:         Timestamp tsv = rs.getTimestamp(column);
1:0c7cafc:         long now2 = System.currentTimeMillis();
1:a30fb43:         assertNotNull(tsv);
1:a30fb43:         assertFalse(rs.wasNull());
1:33efbae: 
1:33efbae:         // Check if the timestamp is as expected. Skip the check if the test
1:33efbae:         // runs around midnight, since we don't know which date to expect in
1:33efbae:         // that case.
1:33efbae:         if (isDateEqual(now, new Timestamp(now2))) {
1:33efbae:             // When reading a TIME value with getTimestamp(), the date
1:33efbae:             // component of the timestamp will be based on the current date.
1:33efbae:             // See DERBY-889.
1:33efbae:             cal.clear();
1:33efbae:             cal.setTimeInMillis(now);
1:33efbae:             int thisYear = cal.get(Calendar.YEAR);
1:33efbae:             int thisMonth = cal.get(Calendar.MONTH);
1:33efbae:             int thisDate = cal.get(Calendar.DATE);
1:33efbae: 
1:33efbae:             // Construct a new timestamp based on the time component of the
1:33efbae:             // TIME value and the date component of the current time.
1:33efbae:             cal.clear();
1:33efbae:             cal.setTime(tv);
1:33efbae:             cal.set(thisYear, thisMonth, thisDate);
1:33efbae: 
1:33efbae:             // Verify that the timestamp returned from getTimestamp() is as
1:33efbae:             // expected.
1:33efbae:             Timestamp expectedValue = new Timestamp(cal.getTimeInMillis());
1:33efbae:             assertTimeEqual(expectedValue, tsv);
1:33efbae:         }
1:33efbae: 
1:a30fb43:         // DERBY-1811, DERBY-889 being fixed could add tests
1:0c7cafc:         // Check the returned date portion is the current date
1:0c7cafc:         // using the value from 'now' and 'now2'. Double check
1:0c7cafc:         // just in case this test runs at midnight.
1:0c7cafc:         if (!(isDateEqual(now, tsv) || isDateEqual(now2, tsv)))
1:0c7cafc:         {
1:0c7cafc:             fail("TIME to java.sql.Timestamp does not contain current date " + tsv);
1:0c7cafc:         }
1:76997ae:         
1:a30fb43:         String sv = rs.getString(column);
1:a30fb43:         assertNotNull(sv);
1:a30fb43:         assertFalse(rs.wasNull());
1:a30fb43:         
1:a30fb43:         // Assert the string converted back into a Time matches the Time returned.
1:a30fb43:         assertEquals("ResultSet String converted to java.sql.Time mismatch",
1:a30fb43:                 tv, getTime19700101(sv, cal));
1:a30fb43:         
1:a30fb43:         return tv;
1:a30fb43:     }
1:a30fb43:     
1:76997ae:     /**
1:76997ae:      * Check the consistency of a ResultSet column that returns
1:76997ae:      * a TIMESTAMP value. Can be used for any column of type TIMESTAMP.
1:76997ae:      * 
1:76997ae:      * @param rs ResultSet holding the column, positioned on a row
1:76997ae:      * @param column Column with the TIMESTAMP value.
1:76997ae:      * @return Returns the Time object obtained from the column.
1:76997ae:      * @throws SQLException
1:76997ae:      */
1:76997ae:     private Timestamp checkTimestampValue(ResultSet rs, int column) throws SQLException
1:76997ae:     {
1:76997ae:         assertEquals(java.sql.Types.TIMESTAMP,
1:76997ae:                 rs.getMetaData().getColumnType(column));
1:76997ae:         
1:76997ae:   
1:76997ae:         Timestamp tsv = rs.getTimestamp(column);
1:76997ae:         assertEquals(tsv == null, rs.wasNull());
1:76997ae:        
1:76997ae:         Object ov = rs.getObject(column);
1:76997ae:         assertEquals(ov == null, rs.wasNull());
1:76997ae:         
1:76997ae:         if (tsv == null) {
1:76997ae:             assertNull(ov);
1:76997ae:             return null;
1:76997ae:         }
1:76997ae: 
1:76997ae:         assertTrue(ov instanceof java.sql.Timestamp);
1:76997ae:         assertEquals(tsv, ov);
1:76997ae:        
1:76997ae:         Time tv = rs.getTime(column);
1:76997ae:         assertNotNull(tv);
1:76997ae:         assertFalse(rs.wasNull());
1:76997ae:  
1:76997ae:         // Check the date portion is set to 1970/01/01
1:76997ae:         assertTime1970(tv);
1:76997ae: 
1:76997ae:         // Check the TIME portion is set to the same as tv
1:33a2799:         assertTimeEqual(tv, tsv);
1:76997ae:                
1:76997ae:         String sv = rs.getString(column);
1:76997ae:         assertNotNull(sv);
1:76997ae:         assertFalse(rs.wasNull());
1:a30fb43:         
1:76997ae:         // Assert the string converted back into a Time matches the Time returned.
1:76997ae:         assertEquals("ResultSet String converted to java.sql.Timestamp mismatch",
1:76997ae:                 tsv, Timestamp.valueOf(sv));
1:76997ae:         
1:76997ae:         return tsv;
1:0c7cafc:     }    
1:0c7cafc: 
1:0c7cafc:     /**
1:76997ae:      * Check the consistency of a ResultSet column that returns
1:a30fb43:      * CURRENT TIME or a value set from CURRENT TIME.
1:a30fb43:      * 
1:76997ae:      * @param start Time the statement settng the value was executed
1:a30fb43:      * @param end Time after first rs.next() or update statement was executed
1:a30fb43:      * @param rs ResultSet holding the column, positioned on a row
1:a30fb43:      * @param column Column with the timestamp.
1:a30fb43:      * @return Returns the Time object obtained from the column.
1:a30fb43:      * @throws SQLException
1:a30fb43:      */
1:a30fb43:     private Time checkCurrentTimeValue(long start, long end,
1:a30fb43:             ResultSet rs, int column) throws SQLException
1:a30fb43:     {       
1:a30fb43:         Time tv = checkTimeValue(rs, column);
1:76997ae: 
1:a30fb43:         // The time returned should be between the value
1:a30fb43:         // of start and end (inclusive of both)
1:76997ae:         
1:a30fb43:         Time st = getTime19700101(start, cal);
1:a30fb43:         Time et = getTime19700101(end, cal);
1:a30fb43:         
1:a30fb43:         
1:a30fb43:         if (st.after(et)) {
1:a30fb43:             // Gone back in time!
1:a30fb43:             // Well test was running around midnight and the
1:a30fb43:             // time for the start time is equal to or before 23:59:59
1:a30fb43:             // and end time is equal to or after  00:00:00
1:a30fb43:             
1:a30fb43:             assertTrue("CURRENT TIME outside of range when test crossing midnight",
1:a30fb43:                (tv.equals(st) || tv.after(st))
1:a30fb43:                || (tv.equals(et) || tv.before(et)));
1:76997ae:         }
1:a30fb43:         else
1:a30fb43:         {
1:a30fb43:             // End time is after or equal to start time, expected case.
1:a30fb43: 
1:a30fb43:             // The returned time must not be before the
1:a30fb43:             // start time or after the end time.
1:a30fb43:             assertFalse("CURRENT TIME before start of statement", tv.before(st));
1:a30fb43:             assertFalse("CURRENT TIME after end of statement", tv.after(et));       
1:a30fb43:         }
1:a30fb43:         
1:a30fb43:         return tv;
1:a30fb43:     }
1:76997ae:     /**
1:a30fb43:      * Check the consistency of a ResultSet column that returns
1:76997ae:      * CURRENT TIMESTAMP or a value set from CURRENT TIMESTAMP.
1:76997ae:      * 
1:76997ae:      * @param start Time the statement settng the value was executed
1:76997ae:      * @param end Time after first rs.next() or update statement was executed
1:76997ae:      * @param rs ResultSet holding the column, positioned on a row
1:76997ae:      * @param column Column with the timestamp.
1:76997ae:      * @return Returns the Timestamp object obtained from the column.
1:76997ae:      * @throws SQLException
1:76997ae:      */
1:76997ae:     private Timestamp checkCurrentTimestampValue(long start, long end,
1:76997ae:             ResultSet rs, int column) throws SQLException
1:76997ae:     {       
1:76997ae:         Timestamp tsv = checkTimestampValue(rs, column);
1:76997ae: 
1:76997ae:         // The time returned should be between the value
1:76997ae:         // of start and end (inclusive of both)
1:76997ae:         
1:76997ae:         Timestamp st = new Timestamp(start);
1:76997ae:         Timestamp et = new Timestamp(end);
1:76997ae:         
1:76997ae:         
1:76997ae:         if (st.after(et)) {
1:76997ae:             // Gone back in time!
1:76997ae:             // Well test was running around midnight and the
1:76997ae:             // time for the start time is equal to or before 23:59:59
1:76997ae:             // and end time is equal to or after  00:00:00
1:a30fb43:             
1:76997ae:             assertTrue("CURRENT TIME outside of range when test crossing midnight",
1:76997ae:                (tsv.equals(st) || tsv.after(st))
1:76997ae:                || (tsv.equals(et) || tsv.before(et)));
1:76997ae:         }
1:76997ae:         else
1:76997ae:         {
1:76997ae:             // End time is after or equal to start time, expected case.
1:76997ae: 
1:76997ae:             // The returned time must not be before the
1:76997ae:             // start time or after the end time.
1:76997ae:             assertFalse("CURRENT TIME before start of statement", tsv.before(st));
1:76997ae:             assertFalse("CURRENT TIME after end of statement", tsv.after(et));       
1:76997ae:         }
1:76997ae:         
1:76997ae:         return tsv;
1:76997ae:     }
1:a30fb43: 
1:a30fb43:     /**
1:0c7cafc:      * Create a Time object that has its date components
1:0c7cafc:      * set to 1970/01/01 and its time to match the time
1:0c7cafc:      * represented by h, m and s. This matches Derby by
1:0c7cafc:      * setting the milli-second component to zero.
1:0c7cafc:      * <BR>
1:0c7cafc:      * Note that the Time(long) constructor for java.sql.Time
1:0c7cafc:      * does *not* set the date component to 1970/01/01.
1:0c7cafc:      * This is a requirement for JDBC java.sql.Time values though
1:0c7cafc:      */
1:0c7cafc:     private Time getTime19700101(int hour, int min, int sec)
1:0c7cafc:     {
1:0c7cafc:         cal.clear();
1:33efbae:         cal.set(1970, Calendar.JANUARY, 1, hour, min, sec);
2:a30fb43:         cal.set(Calendar.MILLISECOND, 0);
1:33efbae: 
1:33efbae:         Time to = new Time(cal.getTimeInMillis());
1:76997ae:         assertTime1970(to);
2:a30fb43:         return to;
1:a30fb43:     }
1:0c7cafc:     
1:a30fb43:     /**
1:a30fb43:      * Create a Time object that has its date components
1:a30fb43:      * set to 1970/01/01 and its time to match the time
1:a30fb43:      * represented by t and cal. This matches Derby by
1:a30fb43:      * setting the milli-second component to zero.
1:a30fb43:      * <BR>
1:a30fb43:      * Note that the Time(long) constructor for java.sql.Time
1:a30fb43:      * does *not* set the date component to 1970/01/01.
1:a30fb43:      * This is a requirement for JDBC java.sql.Time values though
1:a30fb43:      */
1:a30fb43:     private Time getTime19700101(long t, Calendar cal)
1:a30fb43:     {
1:a30fb43:         cal.clear();
1:33efbae:         cal.setTimeInMillis(t);
1:0c7cafc:         cal.set(1970, Calendar.JANUARY, 1);
1:0c7cafc:         cal.set(Calendar.MILLISECOND, 0);
1:33efbae: 
1:33efbae:         Time to = new Time(cal.getTimeInMillis());
1:0c7cafc:         assertTime1970(to);
1:0c7cafc:         return to;
1:0c7cafc:     }
1:0c7cafc:     
1:a30fb43:     /**
1:a30fb43:      * Create a Time object that has its date components
1:a30fb43:      * set to 1970/01/01 and its time to match the time
1:a30fb43:      * represented by t and cal. This matches Derby by
1:a30fb43:      * setting the milli-second component to zero.
1:a30fb43:      * <BR>
1:a30fb43:      * Note that the Time(long) constructor for java.sql.Time
1:a30fb43:      * does *not* set the date component to 1970/01/01.
1:a30fb43:      * This is a requirement for JDBC java.sql.Time values though
1:a30fb43:      */
1:a30fb43:     private Time getTime19700101(String s, Calendar cal)
1:a30fb43:     {
1:33efbae:         return getTime19700101(Time.valueOf(s).getTime(), cal);
1:a30fb43:     }
1:0c7cafc:     
1:a30fb43:     /**
1:a30fb43:      * Javadoc for java.sql.Time states the components of
1:a30fb43:      * date for a java.sql.Time value must be set to January 1, 1970.
1:a30fb43:      * Note that the java.sql.Time class does not enforce this,
1:a30fb43:      * it is up to the driver.
1:a30fb43:      * @param t
1:a30fb43:      */
1:76997ae:     private void assertTime1970(Time t) {
1:a30fb43:         
1:a30fb43:         /* Cannot do this because all these methods
1:a30fb43:          * throw IllegalArgumentException by definition,
1:a30fb43:          * see java.sql.Time javadoc.
1:a30fb43:  
1:a30fb43:         assertEquals(1970, t.getYear());
1:a30fb43:         assertEquals(0, t.getMonth());
1:a30fb43:         assertEquals(1, t.getDate());
1:a30fb43:         */
1:a30fb43:         cal.clear();
1:a30fb43:         cal.setTime(t);
1:a30fb43:         
1:a30fb43:         assertEquals(1970, cal.get(Calendar.YEAR));
1:a30fb43:         assertEquals(Calendar.JANUARY, cal.get(Calendar.MONTH));
1:a30fb43:         assertEquals(1, cal.get(Calendar.DATE));
1:a30fb43:     }
1:76997ae:     
1:76997ae:     /**
1:0c7cafc:      * Assert the SQL time portion of two SQL JDBC type
1:0c7cafc:      * types are equal.
1:df4020d:      * @param tv1 the first time to compare
1:df4020d:      * @param tv2 the second time to compare
1:76997ae:      */
1:0c7cafc:     private void assertTimeEqual(java.util.Date tv1, java.util.Date tv2)
1:76997ae:     {
1:76997ae:         cal.clear();
1:0c7cafc:         cal.setTime(tv1);
1:76997ae:                 
1:76997ae:         int hour = cal.get(Calendar.HOUR_OF_DAY);
1:76997ae:         int min = cal.get(Calendar.MINUTE);
1:76997ae:         int sec = cal.get(Calendar.SECOND);
1:76997ae:         int ms = cal.get(Calendar.MILLISECOND);
1:76997ae:                         
1:76997ae:         // Check the time portion is set to the same as tv
1:76997ae:         cal.clear();
1:0c7cafc:         cal.setTime(tv2);
1:76997ae:         assertEquals(hour, cal.get(Calendar.HOUR_OF_DAY));
1:76997ae:         assertEquals(min, cal.get(Calendar.MINUTE));
1:76997ae:         assertEquals(sec, cal.get(Calendar.SECOND));
1:76997ae:         assertEquals(ms, cal.get(Calendar.MILLISECOND));
1:76997ae:     }
1:0c7cafc:     
1:0c7cafc:     /**
1:0c7cafc:      * Check if the date portion of a Timestamp value
1:0c7cafc:      * is equal to the date portion of a time value
1:0c7cafc:      * represented in milli-seconds since 1970.
1:0c7cafc:      */
1:0c7cafc:     private boolean isDateEqual(long d, Timestamp tsv)
1:0c7cafc:     {
1:0c7cafc:         cal.clear();
1:33efbae:         cal.setTimeInMillis(d);
1:0c7cafc:         int day = cal.get(Calendar.DAY_OF_MONTH);
1:0c7cafc:         int month = cal.get(Calendar.MONTH);
1:0c7cafc:         int year = cal.get(Calendar.YEAR);
1:0c7cafc:         
1:0c7cafc:         cal.clear();
1:0c7cafc:         cal.setTime(tsv);
1:0c7cafc:         
1:0c7cafc:         return day == cal.get(Calendar.DAY_OF_MONTH)
1:0c7cafc:            && month == cal.get(Calendar.MONTH)
1:0c7cafc:            && year == cal.get(Calendar.YEAR);   
1:0c7cafc:     }
1:a30fb43: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite(TimeHandlingTest.class);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:33efbae
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     protected void setUp() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      * identifier that encodes the time value. The values are then
1:     public void testInsertTime() throws SQLException
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Check if the timestamp is as expected. Skip the check if the test
1:         // runs around midnight, since we don't know which date to expect in
1:         // that case.
1:         if (isDateEqual(now, new Timestamp(now2))) {
1:             // When reading a TIME value with getTimestamp(), the date
1:             // component of the timestamp will be based on the current date.
1:             // See DERBY-889.
1:             cal.clear();
1:             cal.setTimeInMillis(now);
1:             int thisYear = cal.get(Calendar.YEAR);
1:             int thisMonth = cal.get(Calendar.MONTH);
1:             int thisDate = cal.get(Calendar.DATE);
1: 
1:             // Construct a new timestamp based on the time component of the
1:             // TIME value and the date component of the current time.
1:             cal.clear();
1:             cal.setTime(tv);
1:             cal.set(thisYear, thisMonth, thisDate);
1: 
1:             // Verify that the timestamp returned from getTimestamp() is as
1:             // expected.
1:             Timestamp expectedValue = new Timestamp(cal.getTimeInMillis());
1:             assertTimeEqual(expectedValue, tsv);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         cal.set(1970, Calendar.JANUARY, 1, hour, min, sec);
1: 
1:         Time to = new Time(cal.getTimeInMillis());
/////////////////////////////////////////////////////////////////////////
1:         cal.setTimeInMillis(t);
1: 
1:         Time to = new Time(cal.getTimeInMillis());
/////////////////////////////////////////////////////////////////////////
1:         return getTime19700101(Time.valueOf(s).getTime(), cal);
/////////////////////////////////////////////////////////////////////////
1:         cal.setTimeInMillis(d);
author:Army
-------------------------------------------------------------------------------
commit:33a2799
/////////////////////////////////////////////////////////////////////////
1:         assertTimeEqual(tv, tsv);
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:bde1220
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * 
0:     public void testInertTime() throws SQLException, UnsupportedEncodingException
/////////////////////////////////////////////////////////////////////////
1:      * 
1:     public void testCurrentTime() throws SQLException, InterruptedException
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param tv1 the first time to compare
1:      * @param tv2 the second time to compare
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ea8303d
/////////////////////////////////////////////////////////////////////////
1:         Statement s  = createStatement();
1:         s.executeUpdate("DELETE FROM TIME_ALL");
1:         s.close();
commit:eba07fc
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(TestConfiguration.clientServerSuite(TimeHandlingTest.class));
commit:c40688b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Runs the tests in the default embedded configuration and then
1:      * the client server configuration.
0:      * @return
1:      */
0:         // Once DERBY-889 is fixed the methods should be renamed
0:         // and these lines removed so they are added under the default mechanism.
0:         suite.addTest(new TimeHandlingTest("derby889testInertTime"));
0:         suite.addTest(new TimeHandlingTest("derby889testCurrentTime"));
1:         
0:         suite.addTest(TestConfiguration.derbyClientServerDecorator(TimeHandlingTest.class));
1:         
/////////////////////////////////////////////////////////////////////////
1:      * <BR>
0:      * Once DERBY-889 is fixed this test should be renamed so that it
0:      * loses the prefix derby889 (and the specific adding of this test
0:      * in the suite() method removed.
0:     public void derby889testInertTime() throws SQLException, UnsupportedEncodingException
/////////////////////////////////////////////////////////////////////////
1:      * <BR>
0:      * Once DERBY-889 is fixed this test should be renamed so that it
0:      * loses the prefix derby889 (and the specific adding of this test
0:      * in the suite() method removed.
0:     public void derby889testCurrentTime() throws SQLException, InterruptedException
commit:0c7cafc
/////////////////////////////////////////////////////////////////////////
0: import java.io.UnsupportedEncodingException;
/////////////////////////////////////////////////////////////////////////
1: import java.util.Random;
/////////////////////////////////////////////////////////////////////////
1:      * Simple set up, just get a Calendar
1:      * and ensure the table T_ALL is empty.
1:      * @throws SQLException 
0:      * @throws UnsupportedEncodingException 
0:     protected void setUp() throws UnsupportedEncodingException, SQLException
0:         runSQLCommands("DELETE FROM TIME_ALL;");
1:      * Test inserting and selecting of TIME values.
1:      * A set of random TIME values are inserted along with an
0:      * identifer that encodes the time value. The values are then
1:      * fetched and compared to a value calculated from the identifier.
1:      * The returned values are fetched using checkTimeValue thus inheriting
1:      * all the checks within that method.
1:      * @throws SQLException
0:      * @throws UnsupportedEncodingException 
1:      */
0:     public void testInertTime() throws SQLException, UnsupportedEncodingException
1:     {
1:         getConnection().setAutoCommit(false);
1:         // Insert a set of time values, 
1: 
1: 
1:         Random r = new Random();
1: 
1:         // Insert 500 TIME values using a PreparedStatement,
1:         // but randomly selecting the way the value is inserted
1:         // between:
1:         //  java.sql.Time object
1:         //  String representation hh:mm:ss from Time.toString()
1:         //  String representation hh.mm.ss
1:         
1:         // prime number used to select the way the
1:         // selected value is inserted.
1:         final int itk = 71;
1: 
1:         PreparedStatement ps = prepareStatement(
1:            "INSERT INTO TIME_ALL(ID, C_T) VALUES (?, ?)");
1:  
1:         for (int i = 0; i < 500; i++) {
1:             
1:             // Just some big range from zero upwards
1:             int id = r.nextInt(1000000);
1:             ps.setInt(1, id);
1:             
1:             Time ct = getCodedTime(id);
1:            
1:             switch ((id % itk) % 3)
1:             {
1:             case 0: // Insert using Time object
1:                 ps.setTime(2, ct);
1:                 break;
1:             case 1: // Insert using String provided by Time.toString() (hh:mm:ss)
1:                 ps.setString(2, ct.toString());
1:                 break;
1:             case 2: // Insert using String format (hh.mm.ss)
1:                 ps.setString(2, ct.toString().replace(':', '.'));
1:                 break;
1:             default:
1:                fail("not reached");
1:                
1:              }
1:             ps.executeUpdate();
1:         }
1:         ps.close();
1:         commit();
1:         
1:         Statement s = createStatement();
1:         
1:         ResultSet rs = s.executeQuery("SELECT ID, C_T FROM TIME_ALL");
1:         int rowCount = 0;
1:         while (rs.next())
1:         {
1:             int id = rs.getInt(1);
1:             Time t = checkTimeValue(rs, 2);          
1:             assertTimeEqual(getCodedTime(id), t);
1:             rowCount++;
1:         }
1:         rs.close();
1:         s.close(); 
1:         commit();
1:         
1:         assertEquals(rowCount, 500);
1:     }
1: 
1:     /**
1:      * Return a time simply encoded from an integer identifier
1:      * and a set of fixed encoding keys, each a prime number.
1:      * This allows a random value to be inserted into a table
1:      * as a TIME and an INTEGER and thus checked for consistency
1:      * on a SELECT.
1:      * @param id
0:      * @return
1:      */
1:     private Time getCodedTime(int id)
1:     {
1:         final int hk = 17;
1:         final int mk = 41;
1:         final int sk = 67;
1: 
1:         int hour = (id % hk) % 24;
1:         int min = (id % mk) % 60;
1:         int sec = (id % sk) % 60;
1:         
1:         return getTime19700101(hour, min ,sec);
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         long now2 = System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
1:         // Check the returned date portion is the current date
1:         // using the value from 'now' and 'now2'. Double check
1:         // just in case this test runs at midnight.
1:         if (!(isDateEqual(now, tsv) || isDateEqual(now2, tsv)))
1:         {
1:             fail("TIME to java.sql.Timestamp does not contain current date " + tsv);
1:         }
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     /**
1:      * Create a Time object that has its date components
1:      * set to 1970/01/01 and its time to match the time
1:      * represented by h, m and s. This matches Derby by
1:      * setting the milli-second component to zero.
1:      * <BR>
1:      * Note that the Time(long) constructor for java.sql.Time
1:      * does *not* set the date component to 1970/01/01.
1:      * This is a requirement for JDBC java.sql.Time values though
1:      */
1:     private Time getTime19700101(int hour, int min, int sec)
1:     {
1:         cal.clear();
1:         cal.set(1970, Calendar.JANUARY, 1);
1:         cal.set(Calendar.MILLISECOND, 0);
1:         
0:         cal.set(Calendar.HOUR_OF_DAY, hour);
0:         cal.set(Calendar.MINUTE, min);
0:         cal.set(Calendar.SECOND, sec);
1:         
0:         Time to =  new Time(cal.getTime().getTime());
1:         assertTime1970(to);
1:         return to;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:      * Assert the SQL time portion of two SQL JDBC type
1:      * types are equal.
1:     private void assertTimeEqual(java.util.Date tv1, java.util.Date tv2)
1:         cal.setTime(tv1);
/////////////////////////////////////////////////////////////////////////
1:         cal.setTime(tv2);
1:     
1:     /**
1:      * Check if the date portion of a Timestamp value
1:      * is equal to the date portion of a time value
1:      * represented in milli-seconds since 1970.
1:      */
1:     private boolean isDateEqual(long d, Timestamp tsv)
1:     {
1:         cal.clear();
0:         cal.setTime(new java.util.Date(d));
1:         int day = cal.get(Calendar.DAY_OF_MONTH);
1:         int month = cal.get(Calendar.MONTH);
1:         int year = cal.get(Calendar.YEAR);
1:         
1:         cal.clear();
1:         cal.setTime(tsv);
1:         
1:         return day == cal.get(Calendar.DAY_OF_MONTH)
1:            && month == cal.get(Calendar.MONTH)
1:            && year == cal.get(Calendar.YEAR);   
1:     }
commit:76997ae
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * All the functions or expressions that result in
1:      * a TIME value with the same value as CURRENT_TIME.
1:      */
1:     private static final String[] CURRENT_TIME_FUNCTIONS =
1:     {"CURRENT TIME", "CURRENT_TIME"};
1:     
1:     /**
1:      * All the functions or expressions that result in
1:      * a TIMESTAMP value with the same value as CURRENT_TIMESTAMP.
1:      */
1:     private static final String[] CURRENT_TIMESTAMP_FUNCTIONS =
1:     {"CURRENT TIMESTAMP", "CURRENT_TIMESTAMP"};    
1:     /**
1:      * Time to sleep that will result in different TIME values.
1:      */
1:     private static final long SLEEP_TIME = 2000;
1:     /**
1:      * Calendar for testing returned values.
1:      */
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                         " C_TS TIMESTAMP)");
1:                 
1:                 for (int f = 0; f < CURRENT_TIME_FUNCTIONS.length; f++)
1:                 {
1:                     s.execute("ALTER TABLE TIME_ALL ADD COLUMN" +
1:                             " D_T" + f + " TIME WITH DEFAULT " +
1:                             CURRENT_TIME_FUNCTIONS[f]);
1:                 }
1:                 for (int f = 0; f < CURRENT_TIMESTAMP_FUNCTIONS.length; f++)
1:                 {
1:                     s.execute("ALTER TABLE TIME_ALL ADD COLUMN" +
1:                             " D_TS" + f + " TIMESTAMP WITH DEFAULT " +
1:                             CURRENT_TIMESTAMP_FUNCTIONS[f]);
1:                 }
1:            }
1:      * Method for SQL SLEEP function. Sleeps for the time 
1:      * that will result in a change in
1:      * System.currentTimeMillis and a Derby TIME value.
/////////////////////////////////////////////////////////////////////////
1:      * a single value for the life time of a statement and
1:      * that (subject to the resolution) the returned value
1:      * is correctly between the start time of the statement
1:      * execution and the first fetch or completion.
1:      * @throws InterruptedException 
0:     public void testCurrentTime() throws SQLException, InterruptedException
1:     {      
1:         currentFunctionTests(Types.TIME, CURRENT_TIME_FUNCTIONS);      
1:     }
1:     
1:     /**
1:      * Tests for CURRENT TIMESTAMP functions.
1:      * A set of tests that ensure the CURRENT TIMESTAMP maintains
1:      * a single value for the life time of a statement and
1:      * that (subject to the resolution) the returned value
1:      * is correctly between the start time of the statement
1:      * execution and the first fetch or completion.
1:      * @throws SQLException
1:      * @throws InterruptedException 
1:      */
1:     public void testCurrentTimestamp() throws SQLException, InterruptedException
1:     {      
1:         currentFunctionTests(Types.TIMESTAMP, CURRENT_TIMESTAMP_FUNCTIONS);      
1:     }    
1:     /**
1:      * Test all the current timedate functions passed in that
1:      * return the specified type. Generic function that checks
1:      * the functions' are all identical in various situations
1:      * and that the have the correct value, and change across
1:      * executions.
1:      * 
1:      * @param jdbcType JDBC type, Types.TIME, DATE or TIMESTAMP.
1:      * @param functions List of functions or expressions that map to the
1:      * current time date value and return the specified type.
1:      * @throws SQLException
1:      * @throws InterruptedException 
1:      */
1:     private void currentFunctionTests(int jdbcType, String[] functions)
1:     throws SQLException, InterruptedException
1: 
1:         // Single value returned by each function.
1:         for (int f = 0; f < functions.length; f++) {
1:             checkCurrentQuery(jdbcType, s, "VALUES " + functions[f],
1:                     new int[] {1}, 1);
1:         }
1:         // Create text for a single row in a VALUES clause,
1:         // each function represented once.
1:         StringBuffer rb = new StringBuffer("(");
1:         for (int f = 0; f < functions.length; f++) {
1:             if (f != 0)
1:                 rb.append(", ");
1:             rb.append(functions[f]);
1:         }
1:         rb.append(")");
1:         String row = rb.toString();
1:         int[] columns = new int[functions.length];
1:         for (int f = 0; f < columns.length; f++)
1:             columns[f] = f + 1;
1:         // All the functions as a single row, all return the same value
1:         String sql = "VALUES " + row;
1:         checkCurrentQuery(jdbcType, s, sql, columns, functions.length);
1: 
1:         
1:         // Check they produce the same value across multiple rows
1:         sql = "VALUES " + row + "," + row + "," + row;
1:         checkCurrentQuery(jdbcType, s, sql, columns, 3 * functions.length);
1:         String sleepRow = row.substring(0, row.length() - 1)
1:              + ", SLEEP())";
1:         
1:         sql =  "VALUES " + sleepRow + "," + sleepRow + "," + sleepRow;
1:         checkCurrentQuery(jdbcType, s, sql, columns, 3 * functions.length);
1: 
1:         String ccol = null;
1:         String dcol = null;
1:         switch (jdbcType)
1:         {
1:         case Types.TIME:
1:             dcol = "D_T";
1:             ccol = "C_T";
1:             break;
1:         case Types.TIMESTAMP:
1:             dcol = "D_TS";
1:             ccol = "C_TS";
1:             break;            
1:         case Types.DATE:
1:             dcol = "D_D";
1:             ccol = "C_D";
1:             break; 
1:         default:
1:             fail("Unexpected JDBC Type " + jdbcType);
1:         }
1:         // All the functions as multiple rows,  one function per row.
1:         StringBuffer rm = new StringBuffer();
1:         for (int f = 0; f < functions.length; f++) {
1:             if (f != 0)
1:                 rm.append(", ");
1:             rm.append(functions[f]);
1:         }
1:         String mrow = rm.toString();
1:         // Select list with all the columns of this type
1:         StringBuffer sb = new StringBuffer();
1:         sb.append(ccol); // Column without the defaul
1:         for (int f = 0; f < functions.length; f++) {
1:             sb.append(", ");
1:             sb.append(dcol);
1:             sb.append(f);
1:         }
1:         String typeColumnList = sb.toString();
1:         String selectAllType = "SELECT " + typeColumnList + " FROM TIME_ALL";
1:         
1:         int[] tableColumns = new int[columns.length + 1];
1:         for (int i = 0; i < tableColumns.length; i++)
1:             tableColumns[i] = i+1;
1:                     
1:         // Insert multiple rows, one per function
1:         // Check all the inserted value and the default
1:         // columns have the same value.
1:         String insert = "INSERT INTO TIME_ALL(" + ccol + ") VALUES " + mrow;
1:         long start = System.currentTimeMillis();
1:         s.executeUpdate(insert);
1:         long end = System.currentTimeMillis();
1:         ResultSet rs = s.executeQuery(selectAllType);
1:         checkCurrentMultiple(jdbcType, start, end, rs, tableColumns, 
1:                 functions.length * (functions.length + 1));
1:         // All the functions as multiple rows,  one function per row
1:         // with a SLEEP as the first column.
1:         sb = new StringBuffer();
1:         for (int f = 0; f < functions.length; f++) {
1:             if (f != 0)
1:                 sb.append(", ");
1:             sb.append("(SLEEP(), ");
1:             sb.append(functions[f]);
1:             sb.append(")");
1:         }
1:         String mSleepRow = sb.toString();
1:         
1:         insert = "INSERT INTO TIME_ALL(ID, " + ccol + ") " +
1:           " SELECT * FROM TABLE (VALUES " +
1:           mSleepRow +
1:           ") AS T";
1:        
1:         s.executeUpdate(insert);
1:         end = System.currentTimeMillis();
1:         rs = s.executeQuery(selectAllType);
1:         checkCurrentMultiple(jdbcType, start, end, rs, tableColumns,
1:                 functions.length * (functions.length + 1));
1:         rs.close();
1:         
1:         // Ensure a PreparedStatement (psI) resets its current time correctly
1:         // and does not get stuck with a single value for all executions.
1:         PreparedStatement psQ = prepareStatement(
1:                 selectAllType + " WHERE ID = ?");
1:         
1:         Object last = null;
1:         for (int f = 0; f < functions.length; f++) {
1:             PreparedStatement psI = prepareStatement("INSERT INTO TIME_ALL(ID, " +
1:                     ccol + ")" +
1:                     " VALUES (?, " + functions[f] +")");
1:             s.executeUpdate("DELETE FROM TIME_ALL");
1: 
1:             for (int i = 1; i <=3; i++) {
1:                psI.setInt(1, i);
1:                psQ.setInt(1, i);   
1:                start = System.currentTimeMillis();
1:                psI.executeUpdate();
1:                end = System.currentTimeMillis();
1: 
1:                rs = psQ.executeQuery();
1:                rs.next();
1:                Object next = checkCurrentMultiple(jdbcType, start, end, rs,
1:                        tableColumns, functions.length + 1);
1:                rs.close();
1:                
1:                if (last != null) {
1:                    // This check is redundant because the last and next have
1:                    // been checked they are within limit of the start and end.
1:                    // But why not check it.
1:                    assertFalse("CURRENT value not changed over executions",
1:                            last.equals(next));
1:                }
1:                last = next;
1:                      
1:                // Ensure the next execution is meant to get a different value
1:                Thread.sleep(SLEEP_TIME);
1:             }
1:             psI.close();
1: 
1:         }
1: 
1:         psQ.close();
1:      * Execute a query that uses CURRENT expressions directly.
1:      * The time returned for these values should be between the
1:      * start of execution and after the return from the first rs.next().
1:      * @param sqlType
1:      * @param s
1:      * @param sql
1:      * @param columns
1:      * @param expectedCount
1:      * @throws SQLException
1:      */
1:     private void checkCurrentQuery(int sqlType,
1:             Statement s, String sql, int[] columns, int expectedCount)
1:     throws SQLException
1:     {
1:         long start = System.currentTimeMillis();
1:         ResultSet rs = s.executeQuery(sql);
1:         rs.next();
1:         long end = System.currentTimeMillis();
1:         checkCurrentMultiple(sqlType, start, end, rs,
1:                 columns, expectedCount);
1:         rs.close();       
1:     }
1:     
1:     /**
1:      * Check the validity of all CURRENT time values returned and
1:      * that they are identical.
1:      * @param jdbcType Types.TIME or TIMESTAMP
1:      * @param start Start of window for valid value.
1:      * @param end End of window for valid value.
1:      * @param rs Result set positioned  on row.
1:      * @param columns Columns holding current values.
1:      * @param expectedCount Total number of values exected to see
1:      * (row count times column count)
0:      * @return
1:      * @throws SQLException
1:      */
1:     private Object checkCurrentMultiple(int jdbcType, long start, long end, ResultSet rs,
1:             int[] columns, int expectedCount) throws SQLException
1:    {
1:         switch (jdbcType)
1:         {
1:         case Types.TIME:
1:             return checkCurrentTimeMultiple(start, end, rs, columns, expectedCount);
1:         case Types.TIMESTAMP:
1:             return checkCurrentTimestampMultiple(start, end, rs, columns, expectedCount);
1:         default:
1:             fail("Unexpected type " + jdbcType);
1:         return null;
1:         }
1:   }
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     private Time checkCurrentTimeMultiple(long start, long end, ResultSet rs,
/////////////////////////////////////////////////////////////////////////
1:         
1:         return base;
1:     /**
1:      * Check a set of rows and columns with values set to CURRENT TIMESTAMP
1:      * in a single statement are the same.
1:      * @param start Start time for the statement that set the values.
1:      * @param end End time for the statement that set the values.
1:      * @param rs ResultSet positioned on the first row.
1:      * @param columns Set of columns holding the TIME values
1:      * @param expectedCount Number of values we are execpted to check.
1:      * @throws SQLException
1:      */
1:     private Timestamp checkCurrentTimestampMultiple(long start, long end, ResultSet rs,
1:             int[] columns, int expectedCount) throws SQLException
1:     {   
1:         // Result set is positioned on starting row
1:         // Since all values must be the same since they are based upon
1:         // CURRENT TIME from a single statement, pick one as the base
1:         // and compare the rest to it.
1:         Timestamp base = checkCurrentTimestampValue(start, end, rs, columns[0]);
1:         assertNotNull(base);
1:         int count = 1;
1:         
1:         // check the remaining columns on this row.
1:         for (int i = 1; i < columns.length; i++)
1:         {
1:             Timestamp ts = checkCurrentTimestampValue(start, end, rs, columns[i]);
1:             assertEquals("CURENT TIMESTAMP changed during execution", base, ts);
1:             count++;
1:         }
1:         
1:         // now check all columns on any remaining rows
1:         while (rs.next()) {
1:             for (int i = 0; i < columns.length; i++)
1:             {
1:                 Timestamp ts = checkCurrentTimestampValue(start, end, rs, columns[i]);
1:                 assertEquals("CURENT TIMESTAMP changed during execution", base, ts);
1:                 count++;
1:             }
1:         }
1:         
1:         assertEquals(expectedCount, count);
1:         
1:         return base;
1:     }    
/////////////////////////////////////////////////////////////////////////
1:         Object ov = rs.getObject(column);
1:         assertEquals(ov == null, rs.wasNull());
1:         
1:         if (tv == null) {
1:             assertNull(ov);
1:             return null;
1:         }
1:         
1:         assertTrue(ov instanceof java.sql.Time);
1:         assertEquals(tv, ov);
1:          
1:         assertTime1970(tv);
/////////////////////////////////////////////////////////////////////////
0:         assertTimeEqual(tv, tsv);
/////////////////////////////////////////////////////////////////////////
1:      * a TIMESTAMP value. Can be used for any column of type TIMESTAMP.
1:      * 
1:      * @param rs ResultSet holding the column, positioned on a row
1:      * @param column Column with the TIMESTAMP value.
1:      * @return Returns the Time object obtained from the column.
1:      * @throws SQLException
1:      */
1:     private Timestamp checkTimestampValue(ResultSet rs, int column) throws SQLException
1:     {
1:         assertEquals(java.sql.Types.TIMESTAMP,
1:                 rs.getMetaData().getColumnType(column));
1:         
1:   
1:         Timestamp tsv = rs.getTimestamp(column);
1:         assertEquals(tsv == null, rs.wasNull());
1:        
1:         Object ov = rs.getObject(column);
1:         assertEquals(ov == null, rs.wasNull());
1:         
1:         if (tsv == null) {
1:             assertNull(ov);
1:             return null;
1:         }
1: 
1:         assertTrue(ov instanceof java.sql.Timestamp);
1:         assertEquals(tsv, ov);
1:        
1:         Time tv = rs.getTime(column);
1:         assertNotNull(tv);
1:         assertFalse(rs.wasNull());
1:  
1:         // Check the date portion is set to 1970/01/01
1:         assertTime1970(tv);
1: 
1:         // Check the TIME portion is set to the same as tv
0:         // DERBY-1816 java.sql.Time values from TIMESTAMP
0:         // colummns lose their precision with client.
0:         if (!usingDerbyNetClient())
0:             assertTimeEqual(tv, tsv);
1:                
1:         String sv = rs.getString(column);
1:         assertNotNull(sv);
1:         assertFalse(rs.wasNull());
1:         
1:         // Assert the string converted back into a Time matches the Time returned.
1:         assertEquals("ResultSet String converted to java.sql.Timestamp mismatch",
1:                 tsv, Timestamp.valueOf(sv));
1:         
1:         return tsv;
1:     }    
1: 
1:     /**
1:      * Check the consistency of a ResultSet column that returns
1:      * @param start Time the statement settng the value was executed
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check the consistency of a ResultSet column that returns
1:      * CURRENT TIMESTAMP or a value set from CURRENT TIMESTAMP.
1:      * 
1:      * @param start Time the statement settng the value was executed
1:      * @param end Time after first rs.next() or update statement was executed
1:      * @param rs ResultSet holding the column, positioned on a row
1:      * @param column Column with the timestamp.
1:      * @return Returns the Timestamp object obtained from the column.
1:      * @throws SQLException
1:      */
1:     private Timestamp checkCurrentTimestampValue(long start, long end,
1:             ResultSet rs, int column) throws SQLException
1:     {       
1:         Timestamp tsv = checkTimestampValue(rs, column);
1: 
1:         // The time returned should be between the value
1:         // of start and end (inclusive of both)
1:         
1:         Timestamp st = new Timestamp(start);
1:         Timestamp et = new Timestamp(end);
1:         
1:         
1:         if (st.after(et)) {
1:             // Gone back in time!
1:             // Well test was running around midnight and the
1:             // time for the start time is equal to or before 23:59:59
1:             // and end time is equal to or after  00:00:00
1:             
1:             assertTrue("CURRENT TIME outside of range when test crossing midnight",
1:                (tsv.equals(st) || tsv.after(st))
1:                || (tsv.equals(et) || tsv.before(et)));
1:         }
1:         else
1:         {
1:             // End time is after or equal to start time, expected case.
1: 
1:             // The returned time must not be before the
1:             // start time or after the end time.
1:             assertFalse("CURRENT TIME before start of statement", tsv.before(st));
1:             assertFalse("CURRENT TIME after end of statement", tsv.after(et));       
1:         }
1:         
1:         return tsv;
1:     }  
/////////////////////////////////////////////////////////////////////////
1:         assertTime1970(to);
/////////////////////////////////////////////////////////////////////////
0:         assertTime1970(to);
/////////////////////////////////////////////////////////////////////////
1:     private void assertTime1970(Time t) {
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Assert the time portion of a java.sql.Timestamp
0:      * is equal to the value of a java.sql.Time.
0:      * @param tv
0:      * @param tsv
1:      */
0:     private void assertTimeEqual(Time tv, Timestamp tsv)
1:     {
1:         cal.clear();
1:         cal.setTime(tv);
1:                 
1:         int hour = cal.get(Calendar.HOUR_OF_DAY);
1:         int min = cal.get(Calendar.MINUTE);
1:         int sec = cal.get(Calendar.SECOND);
1:         int ms = cal.get(Calendar.MILLISECOND);
1:                         
1:         // Check the time portion is set to the same as tv
1:         cal.clear();
0:         cal.setTime(tsv);
1:         assertEquals(hour, cal.get(Calendar.HOUR_OF_DAY));
1:         assertEquals(min, cal.get(Calendar.MINUTE));
1:         assertEquals(sec, cal.get(Calendar.SECOND));
1:         assertEquals(ms, cal.get(Calendar.MILLISECOND));
1:     }
commit:a30fb43
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.TimeHandlingTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import java.sql.Connection;
0: import java.sql.Date;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.util.Calendar;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: 
1: 
1: public class TimeHandlingTest extends BaseJDBCTestCase {
1: 
0:     private static long SLEEP_TIME = 2000;
1:     
1:     private Calendar cal;
1:     
0:     // Determine a minimal sleep time that that consistently, based upon
0:     // ten tries, results in a change in System.currentTimeMillis.
0:     static {
0:         for (int ms = 50; ms <= 2000; ms +=50)
1:         {
0:             boolean seenChange = true;
0:             for (int i = 0; i < 10; i++) {
0:                 long start = System.currentTimeMillis();
1:                 try {
0:                     Thread.sleep(ms);
0:                 } catch (InterruptedException e) {
0:                     seenChange = false;
1:                 }
0:                 long end = System.currentTimeMillis();
1:                 
0:                 if (start == end) {
0:                     seenChange = false;
0:                     break;
1:                 }
1:             }
1:             
0:             if (seenChange) {
0:                 SLEEP_TIME = ms;
0:                 break;
1:             }
1:         }
1:     }
1:     
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite(TimeHandlingTest.class);
1:         
1:         return new CleanDatabaseTestSetup(suite) {
1:             protected void decorateSQL(Statement s) throws SQLException {
1:                
1:                 s.execute("CREATE FUNCTION SLEEP() RETURNS INTEGER" +
1:                         " LANGUAGE JAVA PARAMETER STYLE JAVA" +
1:                         " NO SQL " +
1:                         " EXTERNAL NAME '"+
1:                         TimeHandlingTest.class.getName().concat(".sleep'"));
1:                 
1:                 s.execute("CREATE TABLE TIME_ALL (ID INT," +
1:                         " C_T TIME," +
1:                         " C_D DATE," +
0:                         " C_TS TIMESTAMP," +
0:                         " D_T TIME DEFAULT CURRENT TIME," +
0:                         " D_D DATE  DEFAULT CURRENT DATE," +
0:                         " D_TS TIMESTAMP DEFAULT CURRENT TIMESTAMP)");
1: 
1:             }
1:         };
1:     }
1:     
1:     /**
0:      * Method for SQL SLEEP function. Sleeps for the time determined
0:      * at class initialization that will result in a change in
0:      * System.currentTimeMillis.
0:      * @return
1:      * @throws InterruptedException
1:      */
1:     public static int sleep() throws InterruptedException {
1:         Thread.sleep(SLEEP_TIME);
1:         return 0;
1:     }
1: 
1:     public TimeHandlingTest(String name) {
1:         super(name);
1:     }
1:     
1:     /**
0:      * Simple set up, just get a Calendar.
1:      */
0:     protected void setUp()
1:     {
1:         cal = Calendar.getInstance();
1:     }
1:     
1:     /**
1:      * Tests for CURRENT TIME and CURRENT_TIME.
1:      * A set of tests that ensure the CURRENT TIME maintains
0:      * a single value for the life time of a statement.
1:      * @throws SQLException
1:      */
0:     public void testCurrentTime() throws SQLException
1:     {
1:         Statement s = createStatement();
1:         
0:         // Simple CURRENT_TIME
0:         long start = System.currentTimeMillis();
0:         ResultSet rs = s.executeQuery("VALUES CURRENT TIME");
1:         rs.next();
0:         long end = System.currentTimeMillis();
0:         checkCurrentTimeValue(start, end, rs, 1);        
1:         rs.close();
1:         
0:         // Alternate CURRENT TIME
1:         start = System.currentTimeMillis();
0:         rs = s.executeQuery("VALUES CURRENT_TIME");
1:         rs.next();
0:         end = System.currentTimeMillis();
0:         checkCurrentTimeValue(start, end, rs, 1);
1:         rs.close();
1:         
0:         // Check they produce the same value
1:         start = System.currentTimeMillis();
0:         rs = s.executeQuery("VALUES (CURRENT_TIME, CURRENT TIME)");
1:         rs.next();
0:         end = System.currentTimeMillis();
0:         checkCurrentTimeMultiple(start, end, rs, new int[] {1,2}, 2);
1:         rs.close();
1: 
1:         // Check they produce the same value across multiple rows
1:         start = System.currentTimeMillis();
0:         rs = s.executeQuery(
0:                 "VALUES (CURRENT_TIME, CURRENT TIME), (CURRENT_TIME, CURRENT TIME),(CURRENT_TIME, CURRENT TIME)");
1:         rs.next();
0:         end = System.currentTimeMillis();       
0:         checkCurrentTimeMultiple(start, end, rs, new int[] {1,2}, 6);
1:         rs.close();
1:         
1:         // Check they produce the same value across multiple rows
1:         // with a forced sleep within row creaton
1:         start = System.currentTimeMillis();
0:         rs = s.executeQuery(
0:                 "VALUES (CURRENT_TIME, CURRENT TIME, SLEEP())," +
0:                 " (CURRENT_TIME, CURRENT TIME, SLEEP())," +
0:                 " (CURRENT_TIME, CURRENT TIME, SLEEP())");
1:         rs.next();
0:         end = System.currentTimeMillis();       
0:         checkCurrentTimeMultiple(start, end, rs, new int[] {1,2}, 6);
1:         rs.close(); 
1:         
1:         // Check behaviour in non-queries.
1:         
0:         // Simple insert of a single row
1:         s.executeUpdate("DELETE FROM TIME_ALL");
1:         start = System.currentTimeMillis();
0:         s.executeUpdate("INSERT INTO TIME_ALL(C_T) VALUES CURRENT TIME");
0:         end = start = System.currentTimeMillis();
0:         rs = s.executeQuery("SELECT C_T, D_T FROM TIME_ALL");
1:         rs.next();
0:         checkCurrentTimeMultiple(start, end, rs, new int[] {1,2}, 2);
1:         rs.close();
1:         
0:         // Insert of multiple rows
1:         s.executeUpdate("DELETE FROM TIME_ALL");
1:         start = System.currentTimeMillis();
0:         s.executeUpdate("INSERT INTO TIME_ALL(C_T) VALUES CURRENT TIME, CURRENT TIME, CURRENT TIME, CURRENT_TIME");
0:         end = start = System.currentTimeMillis();
0:         rs = s.executeQuery("SELECT C_T, D_T FROM TIME_ALL");
1:         rs.next();
0:         checkCurrentTimeMultiple(start, end, rs, new int[] {1,2}, 8);
1:         rs.close();
1:         
1:         // Insert of multiple rows from a query with a delay
1:         s.executeUpdate("DELETE FROM TIME_ALL");
1:         start = System.currentTimeMillis();
0:         s.executeUpdate("INSERT INTO TIME_ALL(ID, C_T) " +
0:                 " SELECT * FROM TABLE (VALUES " +
0:                 " (SLEEP(), CURRENT TIME), " +
0:                 " (SLEEP(), CURRENT TIME), " +
0:                 " (SLEEP(), CURRENT TIME), " +
0:                 " (SLEEP(), CURRENT TIME)) AS T");
0:         end = start = System.currentTimeMillis();
0:         rs = s.executeQuery("SELECT C_T, D_T FROM TIME_ALL");
1:         rs.next();
0:         checkCurrentTimeMultiple(start, end, rs, new int[] {1,2}, 8);
1:         rs.close();        
1:          
1:         s.close();
1:     }
1:     
1:     /**
1:      * Check a set of rows and columns with values set to CURRENT TIME
1:      * in a single statement are the same.
1:      * @param start Start time for the statement that set the values.
1:      * @param end End time for the statement that set the values.
1:      * @param rs ResultSet positioned on the first row.
1:      * @param columns Set of columns holding the TIME values
1:      * @param expectedCount Number of values we are execpted to check.
1:      * @throws SQLException
1:      */
0:     private void checkCurrentTimeMultiple(long start, long end, ResultSet rs,
1:             int[] columns, int expectedCount) throws SQLException
1:     {   
1:         // Result set is positioned on starting row
1:         // Since all values must be the same since they are based upon
1:         // CURRENT TIME from a single statement, pick one as the base
1:         // and compare the rest to it.
1:         Time base = checkCurrentTimeValue(start, end, rs, columns[0]);
1:         assertNotNull(base);
1:         int count = 1;
1:         
1:         // check the remaining columns on this row.
1:         for (int i = 1; i < columns.length; i++)
1:         {
1:             Time t = checkCurrentTimeValue(start, end, rs, columns[i]);
1:             assertEquals("CURENT TIME changed during execution", base, t);
1:             count++;
1:         }
1:         
1:         // now check all columns on any remaining rows
1:         while (rs.next()) {
1:             for (int i = 0; i < columns.length; i++)
1:             {
1:                 Time t = checkCurrentTimeValue(start, end, rs, columns[i]);
1:                 assertEquals("CURENT TIME changed during execution", base, t);
1:                 count++;
1:             }
1:         }
1:         
1:         assertEquals(expectedCount, count);
1:     }
1:     
1:     /**
1:      * Check the consistency of a ResultSet column that returns
1:      * a TIME value. Can be used for any column of type TIME.
1:      * 
1:      * @param rs ResultSet holding the column, positioned on a row
1:      * @param column Column with the TIME value.
1:      * @return Returns the Time object obtained from the column.
1:      * @throws SQLException
1:      */
1:     private Time checkTimeValue(ResultSet rs, int column) throws SQLException
1:     {
1:         assertEquals(java.sql.Types.TIME, rs.getMetaData().getColumnType(column));
1:         
1:         try {
1:             rs.getDate(column);
1:             fail("ResultSet.getDate() succeeded on TIME column");
1:         } catch (SQLException e) {
1:             assertSQLState("22005", e);
1:         }
1:   
1:         Time tv = rs.getTime(column);
1:         assertEquals(tv == null, rs.wasNull());
0:         if (tv == null)
0:             return null;
1:         
1:         // Check the date portion is set to 1970/01/01
0:         assertTime19700101(tv);
1:         cal.clear();
0:         cal.setTime(tv);
1:         
0:         int hour = cal.get(Calendar.HOUR_OF_DAY);
0:         int min = cal.get(Calendar.MINUTE);
0:         int sec = cal.get(Calendar.SECOND);
1:         
1:         // Check the milli-seconds portion is 0
1:         // Derby does not support that precision in TIME
1:         assertEquals(0, cal.get(Calendar.MILLISECOND));
1:         
1:         long now = System.currentTimeMillis();
1:         Timestamp tsv = rs.getTimestamp(column);
1:         assertNotNull(tsv);
1:         assertFalse(rs.wasNull());
1:         
0:         // Check the TIME portion is set to the same as tv
1:         cal.clear();
0:         cal.setTime(tsv);
0:         assertEquals(hour, cal.get(Calendar.HOUR_OF_DAY));
0:         assertEquals(min, cal.get(Calendar.MINUTE));
0:         assertEquals(sec, cal.get(Calendar.SECOND));
1:         assertEquals(0, cal.get(Calendar.MILLISECOND));
1:         
1:         // DERBY-1811, DERBY-889 being fixed could add tests
0:         // here to check the returned date portion is the current date
0:         // using the value from 'now'.
1:         
1:         
1:         String sv = rs.getString(column);
1:         assertNotNull(sv);
1:         assertFalse(rs.wasNull());
1:         
1:         // Assert the string converted back into a Time matches the Time returned.
1:         assertEquals("ResultSet String converted to java.sql.Time mismatch",
1:                 tv, getTime19700101(sv, cal));
1:         
1:         return tv;
1:     }
1:     
1:     /**
1:      * Check the consistency of a ResultSet column that returns
1:      * CURRENT TIME or a value set from CURRENT TIME.
1:      * 
0:      * @param start Time the query was executed
1:      * @param end Time after first rs.next() or update statement was executed
1:      * @param rs ResultSet holding the column, positioned on a row
1:      * @param column Column with the timestamp.
1:      * @return Returns the Time object obtained from the column.
1:      * @throws SQLException
1:      */
1:     private Time checkCurrentTimeValue(long start, long end,
1:             ResultSet rs, int column) throws SQLException
1:     {       
1:         Time tv = checkTimeValue(rs, column);
1: 
1:         // The time returned should be between the value
1:         // of start and end (inclusive of both)
1:         
1:         Time st = getTime19700101(start, cal);
1:         Time et = getTime19700101(end, cal);
1:         
1:         
1:         if (st.after(et)) {
1:             // Gone back in time!
1:             // Well test was running around midnight and the
1:             // time for the start time is equal to or before 23:59:59
1:             // and end time is equal to or after  00:00:00
1:             
1:             assertTrue("CURRENT TIME outside of range when test crossing midnight",
1:                (tv.equals(st) || tv.after(st))
1:                || (tv.equals(et) || tv.before(et)));
1:         }
1:         else
1:         {
1:             // End time is after or equal to start time, expected case.
1: 
1:             // The returned time must not be before the
1:             // start time or after the end time.
1:             assertFalse("CURRENT TIME before start of statement", tv.before(st));
1:             assertFalse("CURRENT TIME after end of statement", tv.after(et));       
1:         }
1:         
1:         return tv;
1:     }
1:     
1:     /**
1:      * Create a Time object that has its date components
1:      * set to 1970/01/01 and its time to match the time
1:      * represented by t and cal. This matches Derby by
1:      * setting the milli-second component to zero.
1:      * <BR>
1:      * Note that the Time(long) constructor for java.sql.Time
1:      * does *not* set the date component to 1970/01/01.
1:      * This is a requirement for JDBC java.sql.Time values though
1:      */
1:     private Time getTime19700101(long t, Calendar cal)
1:     {
1:         cal.clear();
0:         // JDK 1.3 can't call this!
0:         // cal.setTimeInMillis(t);
0:         cal.setTime(new Date(t));
0:         cal.set(1970, Calendar.JANUARY, 1);
1:         cal.set(Calendar.MILLISECOND, 0);
1:         
0:         Time to =  new Time(cal.getTime().getTime());
0:         assertTime19700101(to);
1:         return to;
1:     }
1:     
1:     /**
1:      * Create a Time object that has its date components
1:      * set to 1970/01/01 and its time to match the time
1:      * represented by t and cal. This matches Derby by
1:      * setting the milli-second component to zero.
1:      * <BR>
1:      * Note that the Time(long) constructor for java.sql.Time
1:      * does *not* set the date component to 1970/01/01.
1:      * This is a requirement for JDBC java.sql.Time values though
1:      */
1:     private Time getTime19700101(String s, Calendar cal)
1:     {
1:         cal.clear();
0:         // JDK 1.3 can't call this!
0:         // cal.setTimeInMillis(t);
0:         cal.setTime(Time.valueOf(s));
0:         cal.set(1970, Calendar.JANUARY, 1);
1:         cal.set(Calendar.MILLISECOND, 0);
1:         
0:         Time to =  new Time(cal.getTime().getTime());
0:         assertTime19700101(to);
1:         return to;
1:     }
1:     
1:     /**
1:      * Javadoc for java.sql.Time states the components of
1:      * date for a java.sql.Time value must be set to January 1, 1970.
1:      * Note that the java.sql.Time class does not enforce this,
1:      * it is up to the driver.
1:      * @param t
1:      */
0:     private void assertTime19700101(Time t){
1:         
1:         /* Cannot do this because all these methods
1:          * throw IllegalArgumentException by definition,
1:          * see java.sql.Time javadoc.
1:  
1:         assertEquals(1970, t.getYear());
1:         assertEquals(0, t.getMonth());
1:         assertEquals(1, t.getDate());
1:         */
1:         cal.clear();
1:         cal.setTime(t);
1:         
1:         assertEquals(1970, cal.get(Calendar.YEAR));
1:         assertEquals(Calendar.JANUARY, cal.get(Calendar.MONTH));
1:         assertEquals(1, cal.get(Calendar.DATE));
1:     }
1: }
============================================================================