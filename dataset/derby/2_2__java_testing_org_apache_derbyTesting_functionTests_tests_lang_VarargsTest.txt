1:f9596d4: /*
2:f9596d4: 
1:f9596d4:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.VarargsTest
1:f9596d4: 
1:f9596d4:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f9596d4:    contributor license agreements.  See the NOTICE file distributed with
1:f9596d4:    this work for additional information regarding copyright ownership.
1:f9596d4:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f9596d4:    (the "License"); you may not use this file except in compliance with
1:f9596d4:    the License.  You may obtain a copy of the License at
1:f9596d4: 
1:f9596d4:      http://www.apache.org/licenses/LICENSE-2.0
1:f9596d4: 
1:f9596d4:    Unless required by applicable law or agreed to in writing, software
1:f9596d4:    distributed under the License is distributed on an "AS IS" BASIS,
1:f9596d4:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f9596d4:    See the License for the specific language governing permissions and
1:f9596d4:    limitations under the License.
1:f9596d4: 
1:f9596d4:  */
1:f9596d4: 
1:f9596d4: package org.apache.derbyTesting.functionTests.tests.lang;
1:f9596d4: 
1:ba70926: import java.sql.CallableStatement;
1:f9596d4: import java.sql.Connection;
1:f9596d4: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:f9596d4: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:f9596d4: 
1:232d09a: /**
1:232d09a:  * <p>
1:f9596d4:  * Test routines with varargs. See DERBY-3069.
1:f9596d4:  * </p>
1:f9596d4:  */
1:f9596d4: public class VarargsTest  extends GeneratedColumnsHelper
1:f9596d4: {
1:f9596d4:     ///////////////////////////////////////////////////////////////////////////////////
1:f9596d4:     //
1:f9596d4:     // CONSTANTS
1:f9596d4:     //
1:f9596d4:     ///////////////////////////////////////////////////////////////////////////////////
1:f9596d4: 
1:f9596d4:     private static  final   String  NEEDS_DERBY_STYLE = "42ZC9";
1:f9596d4:     private static  final   String  NEEDS_JAVA_STYLE = "42ZCA";
1:f9596d4:     private static  final   String  RETURNS_RESULT_SETS = "42ZCB";
1:ba70926:     private static  final   String  AMBIGUOUS = "42X73";
1:ba70926:     private static  final   String  NO_SUCH_METHOD = "42X50";
1:8a818c8:     private static  final   String  BAD_TIME_FORMAT = "22007";
1:8a818c8:     private static  final   String  BAD_BOOLEAN_FORMAT = "22018";
1:8a818c8:     private static  final   String  NEEDS_DJRS_STYLE = "42ZB2";
1:615cb37:     private static  final   String  NEEDS_PARAMETER_MARKER = "42886";
1:f9596d4: 
1:f9596d4:     ///////////////////////////////////////////////////////////////////////////////////
1:f9596d4:     //
1:f9596d4:     // STATE
1:f9596d4:     //
1:f9596d4:     ///////////////////////////////////////////////////////////////////////////////////
1:f9596d4: 
1:f9596d4:     ///////////////////////////////////////////////////////////////////////////////////
1:f9596d4:     //
1:f9596d4:     // CONSTRUCTOR
1:f9596d4:     //
1:f9596d4:     ///////////////////////////////////////////////////////////////////////////////////
1:f9596d4: 
1:f9596d4: 
1:f9596d4:     /**
1:f9596d4:      * Create a new instance.
1:f9596d4:      */
1:f9596d4: 
1:f9596d4:     public VarargsTest(String name)
1:f9596d4:     {
1:f9596d4:         super(name);
1:f9596d4:     }
1:f9596d4: 
1:f9596d4:     ///////////////////////////////////////////////////////////////////////////////////
1:f9596d4:     //
1:f9596d4:     // JUnit BEHAVIOR
1:f9596d4:     //
1:f9596d4:     ///////////////////////////////////////////////////////////////////////////////////
1:f9596d4: 
1:f9596d4: 
1:615cb37:     /**
1:f9596d4:      * Construct top level suite in this JUnit test
1:f9596d4:      */
1:f9596d4:     public static Test suite()
1:f9596d4:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("UserDefinedAggregatesTest");
1:f9596d4: 
1:f9596d4:         suite.addTest( TestConfiguration.defaultSuite( VarargsTest.class ) );
1:f9596d4: 
1:f9596d4:         return suite;
1:f9596d4:     }
1:f9596d4: 
1:f9596d4:     ///////////////////////////////////////////////////////////////////////////////////
1:f9596d4:     //
1:f9596d4:     // TESTS
1:f9596d4:     //
1:f9596d4:     ///////////////////////////////////////////////////////////////////////////////////
1:f9596d4: 
1:8a818c8:     /**
1:615cb37:      * <p>
1:f9596d4:      * Basic syntax.
1:f9596d4:      * </p>
1:f9596d4:      */
1:f9596d4:     public void test_01_basicSyntax() throws Exception
1:f9596d4:     {
1:f9596d4:         Connection conn = getConnection();
1:f9596d4: 
1:f9596d4:         goodStatement
1:f9596d4:             ( conn,
1:f9596d4:               "create function varargsDerbyStyle( a int ... ) returns int\n" +
1:f9596d4:               "parameter style derby language java no sql\n" +
1:f9596d4:               "external name 'Foo.foo'\n"
1:f9596d4:               );
1:f9596d4:         goodStatement
1:f9596d4:             ( conn,
1:f9596d4:               "create function varargsTableFunction( a int ... )\n" +
1:f9596d4:               "returns table( b int )\n" +
1:f9596d4:               "language java parameter style derby_jdbc_result_set no sql\n" +
1:f9596d4:               "external name 'Foo.foo'\n"
1:f9596d4:               );
1:f9596d4:         goodStatement
1:f9596d4:             ( conn,
1:f9596d4:               "create function nonvarargsJavaStyle( a int ) returns int\n" +
1:f9596d4:               "parameter style java language java no sql\n" +
1:f9596d4:               "external name 'Foo.foo'\n"
1:f9596d4:               );
1:f9596d4:         goodStatement
1:f9596d4:             ( conn,
1:f9596d4:               "create procedure varargsDerbyStyle( a int ... )\n" +
1:f9596d4:               "language java parameter style derby no sql\n" +
1:f9596d4:               "external name 'Foo.foo'\n"
1:f9596d4:               );
1:f9596d4:         goodStatement
1:f9596d4:             ( conn,
1:f9596d4:               "create procedure nonvarargsJavaStyle( a int )\n" +
1:f9596d4:               "language java parameter style java no sql\n" +
1:f9596d4:               "external name 'Foo.foo'\n"
1:f9596d4:               );
1:232d09a: 
1:f9596d4:         // bad parameter style
1:f9596d4:         expectCompilationError
1:f9596d4:             ( NEEDS_DERBY_STYLE,
1:f9596d4:               "create function varargsJavaStyle( a int ... ) returns int\n" +
1:f9596d4:               "parameter style java language java no sql\n" +
1:f9596d4:               "external name 'Foo.foo'\n"
1:f9596d4:               );
1:f9596d4:         expectCompilationError
1:f9596d4:             ( NEEDS_JAVA_STYLE,
1:f9596d4:               "create function nonvarargsDerbyStyle( a int ) returns int\n" +
1:f9596d4:               "parameter style derby language java no sql\n" +
1:f9596d4:               "external name 'Foo.foo'\n"
1:f9596d4:               );
1:f9596d4:         expectCompilationError
1:f9596d4:             ( NEEDS_DERBY_STYLE,
1:f9596d4:               "create procedure varargsDerbyStyle( a int ... )\n" +
1:f9596d4:               "language java parameter style java no sql\n" +
1:f9596d4:               "external name 'Foo.foo'\n"
1:f9596d4:               );
1:f9596d4:         expectCompilationError
1:f9596d4:             ( NEEDS_JAVA_STYLE,
1:f9596d4:               "create procedure nonvarargsDerbyStyle( a int )\n" +
1:f9596d4:               "language java parameter style derby no sql\n" +
1:f9596d4:               "external name 'Foo.foo'\n"
1:f9596d4:               );
1:f9596d4: 
1:f9596d4:         // need at least one parameter in order to use varargs
1:f9596d4:         expectCompilationError
1:f9596d4:             ( SYNTAX_ERROR,
1:f9596d4:               "create function varargsDerbyStyleNoParam( ... ) returns int\n" +
1:f9596d4:               "parameter style derby language java no sql\n" +
1:f9596d4:               "external name 'Foo.foo'\n"
1:f9596d4:               );
1:f9596d4:         expectCompilationError
1:f9596d4:             ( SYNTAX_ERROR,
1:f9596d4:               "create procedure varargsDerbyStyleNoParam( ... )\n" +
1:f9596d4:               "language java parameter style derby no sql\n" +
1:f9596d4:               "external name 'Foo.foo'\n"
1:f9596d4:               );
1:f9596d4: 
1:f9596d4:         // bad because returns result sets
1:f9596d4:         expectCompilationError
1:f9596d4:             ( RETURNS_RESULT_SETS,
1:f9596d4:               "create procedure varargsDerbyStyle( a int ... )\n" +
1:f9596d4:               "language java parameter style derby no sql result sets 1\n" +
1:f9596d4:               "external name 'Foo.foo'\n"
1:f9596d4:               );
1:f9596d4:     }
1:f9596d4: 
1:ba70926:     /**
1:8a818c8:      * <p>
1:232d09a:      * Simple invocations to verify that varargs routines can be invoked.
1:232d09a:      * </p>
1:232d09a:      */
1:232d09a:     public void test_02_simple() throws Exception
1:232d09a:     {
1:232d09a:         if ( !vmSupportsVarargs() ) { return; }
1:8a818c8:         
1:232d09a:         Connection conn = getConnection();
1:232d09a: 
1:232d09a:         goodStatement
1:232d09a:             ( conn,
1:232d09a:               "create function maximum( a int ... ) returns int\n" +
1:232d09a:               "language java parameter style derby no sql deterministic\n" +
1:232d09a:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.max'\n"
1:232d09a:               );
1:232d09a:         goodStatement
1:232d09a:             ( conn,
1:232d09a:               "create function formatMessage( message varchar( 32672 ),  args varchar( 32672 ) ... ) returns varchar( 32672 )\n" +
1:232d09a:               "language java parameter style derby no sql deterministic\n" +
1:232d09a:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.formatMessage'\n"
1:232d09a:               );
1:232d09a: 
1:232d09a:         // 0 args
1:232d09a:         assertResults
1:232d09a:             (
1:232d09a:              conn,
1:232d09a:              "values maximum()",
1:232d09a:              new String[][]
1:232d09a:              {
1:232d09a:                  { null },
1:232d09a:              },
1:232d09a:              false
1:232d09a:              );
1:232d09a:         
1:232d09a:         // a null argument
1:232d09a:         assertResults
1:232d09a:             (
1:232d09a:              conn,
1:232d09a:              "values maximum( null )",
1:232d09a:              new String[][]
1:232d09a:              {
1:232d09a:                  { null },
1:232d09a:              },
1:232d09a:              false
1:232d09a:              );
1:232d09a:         
1:232d09a:         // one non-null argument
1:232d09a:         assertResults
1:232d09a:             (
1:232d09a:              conn,
1:232d09a:              "values maximum( 1 )",
1:232d09a:              new String[][]
1:232d09a:              {
1:232d09a:                  { "1" },
1:232d09a:              },
1:232d09a:              false
1:232d09a:              );
1:232d09a:          
1:232d09a:         // multiple arguments
1:232d09a:         assertResults
1:232d09a:             (
1:232d09a:              conn,
1:232d09a:              "values maximum( 1, 3, 2 )",
1:232d09a:              new String[][]
1:232d09a:              {
1:232d09a:                  { "3" },
1:232d09a:              },
1:232d09a:              false
1:232d09a:              );
1:232d09a:          
1:232d09a:         // verify that arguments are passed in the correct order
1:232d09a:         assertResults
1:232d09a:             (
1:232d09a:              conn,
1:232d09a:              "values formatMessage( 'First {0} then {1} then {2}', 'one', 'two', 'three' )",
1:232d09a:              new String[][]
1:232d09a:              {
1:232d09a:                  { "First one then two then three" },
1:232d09a:              },
1:232d09a:              false
1:232d09a:              );
1:232d09a:     }
1:232d09a: 
1:f9596d4:     /**
1:ba70926:      * <p>
1:ba70926:      * Misc tests for varargs routines.
1:ba70926:      * </p>
1:ba70926:      */
1:ba70926:     public void test_03_misc() throws Exception
1:ba70926:     {
1:ba70926:         if ( !vmSupportsVarargs() ) { return; }
1:ba70926: 
1:ba70926:         Connection conn = getConnection();
1:ba70926: 
1:ba70926:         // primitive and wrapper overloads make method resolution ambiguous
1:ba70926: 
1:ba70926:         goodStatement
1:ba70926:             ( conn,
1:ba70926:               "create function ambiguousTypes( a int ... ) returns int\n" +
1:ba70926:               "language java parameter style derby no sql deterministic\n" +
1:ba70926:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.ambiguousTypes'\n"
1:ba70926:               );
1:ba70926:         expectCompilationError( AMBIGUOUS, "values ambiguousTypes( 1, 2, 3 )" );
1:ba70926: 
1:ba70926:         // can resolve to a primitive-typed vararg
1:ba70926:         goodStatement
1:ba70926:             ( conn,
1:ba70926:               "create function maxInts( a int ... ) returns int\n" +
1:ba70926:               "language java parameter style derby no sql deterministic\n" +
1:ba70926:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.maxInts'\n"
1:ba70926:               );
1:ba70926:         assertResults
1:ba70926:             (
1:ba70926:              conn,
1:ba70926:              "values maxInts( 3 )",
1:ba70926:              new String[][]
1:ba70926:              {
1:ba70926:                  { "3" },
1:ba70926:              },
1:ba70926:              false
1:ba70926:              );
1:ba70926:         assertResults
1:ba70926:             (
1:ba70926:              conn,
1:ba70926:              "values maxInts( 1, 2, 5, 4, 3 )",
1:ba70926:              new String[][]
1:ba70926:              {
1:ba70926:                  { "5" },
1:ba70926:              },
1:ba70926:              false
1:ba70926:              );
1:ba70926: 
1:ba70926:         // error if the matching method isn't varargs
1:ba70926:         goodStatement
1:ba70926:             ( conn,
1:ba70926:               "create function nonVarargsMethod( a int ... ) returns int\n" +
1:ba70926:               "language java parameter style derby no sql deterministic\n" +
1:ba70926:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.nonVarargsMethod'\n"
1:ba70926:               );
1:ba70926:         expectCompilationError( NO_SUCH_METHOD, "values nonVarargsMethod( 3 )" );
1:ba70926:         
1:ba70926:         // correctly disambiguate similar varargs and non-varargs methods
1:ba70926:         goodStatement
1:ba70926:             ( conn,
1:ba70926:               "create function vnvr_vararg( a int ... ) returns int\n" +
1:ba70926:               "language java parameter style derby no sql deterministic\n" +
1:ba70926:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.vnvr'\n"
1:ba70926:               );
1:ba70926:         goodStatement
1:ba70926:             ( conn,
1:ba70926:               "create function vnvr_nonvararg( a int ) returns int\n" +
1:ba70926:               "language java parameter style java no sql deterministic\n" +
1:ba70926:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.vnvr'\n"
1:ba70926:               );
1:ba70926:         assertResults
1:ba70926:             (
1:ba70926:              conn,
1:ba70926:              "values vnvr_vararg( 3 )",
1:ba70926:              new String[][]
1:ba70926:              {
1:ba70926:                  { "3" },
1:ba70926:              },
1:ba70926:              false
1:ba70926:              );
1:ba70926:         assertResults
1:ba70926:             (
1:ba70926:              conn,
1:ba70926:              "values vnvr_nonvararg( 3 )",
1:ba70926:              new String[][]
1:ba70926:              {
1:ba70926:                  { "-3" },
1:ba70926:              },
1:ba70926:              false
1:ba70926:              );
1:ba70926:         
1:ba70926:         // correctly disambiguate overloads with different numbers of leading non-vararg arguments
1:ba70926:         goodStatement
1:ba70926:             ( conn,
1:ba70926:               "create function lnv( a int ... ) returns int\n" +
1:ba70926:               "language java parameter style derby no sql deterministic\n" +
1:ba70926:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.lnv'\n"
1:ba70926:               );
1:ba70926:         goodStatement
1:ba70926:             ( conn,
1:ba70926:               "create function lnv_1( a int, b int ... ) returns int\n" +
1:ba70926:               "language java parameter style derby no sql deterministic\n" +
1:ba70926:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.lnv'\n"
1:ba70926:               );
1:ba70926:         goodStatement
1:ba70926:             ( conn,
1:ba70926:               "create function lnv_2( a int, b int, c int ... ) returns int\n" +
1:ba70926:               "language java parameter style derby no sql deterministic\n" +
1:ba70926:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.lnv'\n"
1:ba70926:               );
1:ba70926:         assertResults
1:ba70926:             (
1:ba70926:              conn,
1:ba70926:              "values lnv( 5, 4, 3, 2, 1 )",
1:ba70926:              new String[][]
1:ba70926:              {
1:ba70926:                  { "5" },
1:ba70926:              },
1:ba70926:              false
1:ba70926:              );
1:ba70926:         assertResults
1:ba70926:             (
1:ba70926:              conn,
1:ba70926:              "values lnv_1( 5, 4, 3, 2, 1 )",
1:ba70926:              new String[][]
1:ba70926:              {
1:ba70926:                  { "4" },
1:ba70926:              },
1:ba70926:              false
1:ba70926:              );
1:ba70926:         assertResults
1:ba70926:             (
1:ba70926:              conn,
1:ba70926:              "values lnv_2( 5, 4, 3, 2, 1 )",
1:ba70926:              new String[][]
1:ba70926:              {
1:ba70926:                  { "3" },
1:ba70926:              },
1:ba70926:              false
1:ba70926:              );
1:ba70926:     }
1:ba70926:     
1:ba70926:     /**
1:ba70926:      * <p>
1:ba70926:      * Test in, out, and in/out procedure arguments which are varargs.
1:ba70926:      * </p>
1:ba70926:      */
1:ba70926:     public void test_04_inOut() throws Exception
1:ba70926:     {
1:ba70926:         if ( !vmSupportsVarargs() ) { return; }
1:ba70926: 
1:ba70926:         Connection conn = getConnection();
1:ba70926:         CallableStatement   cs =  null;
1:ba70926: 
1:ba70926:         // one input vararg
1:ba70926:         goodStatement
1:ba70926:             ( conn,
1:ba70926:               "create procedure inVarargs( out result varchar( 32672 ), b int ... )\n" +
1:ba70926:               "language java parameter style derby no sql deterministic\n" +
1:ba70926:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.inVarargs'\n"
1:ba70926:               );
1:ba70926:         cs = chattyPrepareCall
1:ba70926:             ( conn, "call inVarargs( ?, ? )" );
1:ba70926:         cs.registerOutParameter( 1, java.sql.Types.VARCHAR );
1:ba70926:         cs.setInt( 2, 5 );
1:ba70926:         cs.execute();
1:ba70926:         assertEquals( "RESULT:  5", cs.getString( 1 ) );
1:ba70926: 
1:ba70926:         cs = chattyPrepareCall
1:ba70926:             ( conn, "call inVarargs( ?, ?, ? )" );
1:ba70926:         cs.registerOutParameter( 1, java.sql.Types.VARCHAR );
1:ba70926:         cs.setInt( 2, 5 );
1:ba70926:         cs.setInt( 3, 4 );
1:ba70926:         cs.execute();
1:ba70926:         assertEquals( "RESULT:  5 4", cs.getString( 1 ) );
1:ba70926: 
1:ba70926:         cs = chattyPrepareCall
1:ba70926:             ( conn, "call inVarargs( ?, ?, ?, ? )" );
1:ba70926:         cs.registerOutParameter( 1, java.sql.Types.VARCHAR );
1:ba70926:         cs.setInt( 2, 5 );
1:ba70926:         cs.setInt( 3, 4 );
1:ba70926:         cs.setInt( 4, 3 );
1:ba70926:         cs.execute();
1:ba70926:         assertEquals( "RESULT:  5 4 3", cs.getString( 1 ) );
1:ba70926: 
1:ba70926:         // output vararg
1:ba70926:         goodStatement
1:ba70926:             ( conn,
1:ba70926:               "create procedure outVarargs( seed int, out b int ... )\n" +
1:ba70926:               "language java parameter style derby no sql deterministic\n" +
1:ba70926:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.outVarargs'\n"
1:ba70926:               );
1:ba70926:         cs = chattyPrepareCall
1:ba70926:             ( conn, "call outVarargs( ? )" );
1:ba70926:         cs.setInt( 1, 5 );
1:ba70926:         cs.execute();
1:ba70926: 
1:ba70926:         cs = chattyPrepareCall
1:ba70926:             ( conn, "call outVarargs( ?, ? )" );
1:ba70926:         cs.registerOutParameter( 2, java.sql.Types.INTEGER );
1:ba70926:         cs.setInt( 1, 5 );
1:ba70926:         cs.execute();
1:ba70926:         assertEquals( 5, cs.getInt( 2 ) );
1:ba70926: 
1:ba70926:         cs = chattyPrepareCall
1:ba70926:             ( conn, "call outVarargs( ?, ?, ? )" );
1:ba70926:         cs.registerOutParameter( 2, java.sql.Types.INTEGER );
1:ba70926:         cs.registerOutParameter( 3, java.sql.Types.INTEGER );
1:ba70926:         cs.setInt( 1, 5 );
1:ba70926:         cs.execute();
1:ba70926:         assertEquals( 5, cs.getInt( 2 ) );
1:ba70926:         assertEquals( 6, cs.getInt( 3 ) );
1:ba70926: 
1:ba70926:         cs = chattyPrepareCall
1:ba70926:             ( conn, "call outVarargs( ?, ?, ?, ? )" );
1:ba70926:         cs.registerOutParameter( 2, java.sql.Types.INTEGER );
1:ba70926:         cs.registerOutParameter( 3, java.sql.Types.INTEGER );
1:ba70926:         cs.registerOutParameter( 4, java.sql.Types.INTEGER );
1:ba70926:         cs.setInt( 1, 5 );
1:ba70926:         cs.execute();
1:ba70926:         assertEquals( 5, cs.getInt( 2 ) );
1:ba70926:         assertEquals( 6, cs.getInt( 3 ) );
1:ba70926:         assertEquals( 7, cs.getInt( 4 ) );
1:ba70926: 
1:ba70926:         // in/out vararg
1:ba70926:         goodStatement
1:ba70926:             ( conn,
1:ba70926:               "create procedure inoutVarargs( seed int, inout b int ... )\n" +
1:ba70926:               "language java parameter style derby no sql deterministic\n" +
1:ba70926:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.inoutVarargs'\n"
1:ba70926:               );
1:ba70926:         cs = chattyPrepareCall
1:ba70926:             ( conn, "call inoutVarargs( ? )" );
1:ba70926:         cs.setInt( 1, 5 );
1:ba70926:         cs.execute();
1:ba70926: 
1:ba70926:         cs = chattyPrepareCall
1:ba70926:             ( conn, "call inoutVarargs( ?, ? )" );
1:ba70926:         cs.registerOutParameter( 2, java.sql.Types.INTEGER );
1:ba70926:         cs.setInt( 1, 5 );
1:ba70926:         cs.setInt( 2, 3 );
1:ba70926:         cs.execute();
1:ba70926:         assertEquals( 8, cs.getInt( 2 ) );
1:ba70926: 
1:ba70926:         cs = chattyPrepareCall
1:ba70926:             ( conn, "call inoutVarargs( ?, ?, ? )" );
1:ba70926:         cs.registerOutParameter( 2, java.sql.Types.INTEGER );
1:ba70926:         cs.registerOutParameter( 3, java.sql.Types.INTEGER );
1:ba70926:         cs.setInt( 1, 5 );
1:ba70926:         cs.setInt( 2, 3 );
1:ba70926:         cs.setInt( 3, 10 );
1:ba70926:         cs.execute();
1:ba70926:         assertEquals( 8, cs.getInt( 2 ) );
1:ba70926:         assertEquals( 15, cs.getInt( 3 ) );
1:ba70926: 
1:ba70926:         cs = chattyPrepareCall
1:ba70926:             ( conn, "call inoutVarargs( ?, ?, ?, ? )" );
1:ba70926:         cs.registerOutParameter( 2, java.sql.Types.INTEGER );
1:ba70926:         cs.registerOutParameter( 3, java.sql.Types.INTEGER );
1:ba70926:         cs.registerOutParameter( 4, java.sql.Types.INTEGER );
1:ba70926:         cs.setInt( 1, 5 );
1:ba70926:         cs.setInt( 2, 3 );
1:ba70926:         cs.setInt( 3, 10 );
1:ba70926:         cs.setInt( 4, 100 );
1:ba70926:         cs.execute();
1:ba70926:         assertEquals( 8, cs.getInt( 2 ) );
1:ba70926:         assertEquals( 15, cs.getInt( 3 ) );
1:ba70926:         assertEquals( 105, cs.getInt( 4 ) );
1:ba70926: 
1:ba70926:     }
1:ba70926:     
1:f9596d4:     /**
1:f9596d4:      * <p>
1:8a818c8:      * Test varargs with all datatypes.
1:8a818c8:      * </p>
1:8a818c8:      */
1:8a818c8:     public void test_05_datatypes() throws Exception
1:8a818c8:     {
1:8a818c8:         if ( !vmSupportsVarargs() ) { return; }
1:8a818c8: 
1:8a818c8:         Connection conn = getConnection();
1:8a818c8: 
1:8a818c8:         goodStatement
1:8a818c8:             ( conn,
1:8a818c8:               "create function makeBlob( a varchar( 32672 ) ) returns blob\n" +
1:8a818c8:               "language java parameter style java no sql deterministic\n" +
1:8a818c8:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.makeBlob'\n"
1:8a818c8:               );
1:8a818c8:         goodStatement
1:8a818c8:             ( conn,
1:8a818c8:               "create function makeBytes( a varchar( 32672 ) ) returns char(1) for bit data\n" +
1:8a818c8:               "language java parameter style java no sql deterministic\n" +
1:8a818c8:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.makeBytes'\n"
1:8a818c8:               );
1:8a818c8:         goodStatement
1:8a818c8:             ( conn,
1:8a818c8:               "create function makeVarBytes( a varchar( 32672 ) ) returns varchar(10) for bit data\n" +
1:8a818c8:               "language java parameter style java no sql deterministic\n" +
1:8a818c8:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.makeBytes'\n"
1:8a818c8:               );
1:8a818c8:         goodStatement
1:8a818c8:             ( conn,
1:8a818c8:               "create function makeLongVarBytes( a varchar( 32672 ) ) returns long varchar for bit data\n" +
1:8a818c8:               "language java parameter style java no sql deterministic\n" +
1:8a818c8:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.makeBytes'\n"
1:8a818c8:               );
1:8a818c8:         goodStatement
1:8a818c8:             ( conn,
1:8a818c8:               "create function makeClob( a varchar( 32672 ) ) returns clob\n" +
1:8a818c8:               "language java parameter style java no sql deterministic\n" +
1:8a818c8:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.makeClob'\n"
1:8a818c8:               );
1:8a818c8:         goodStatement( conn, "create type Price external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:8a818c8:         goodStatement
1:8a818c8:             ( conn,
1:8a818c8:               "create function makePrice( currencyCode char( 3 ), amount decimal( 31, 5 ), timeInstant Timestamp )\n" +
1:8a818c8:               "returns Price language java parameter style java no sql\n" +
1:8a818c8:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice'\n");
1:8a818c8: 
1:8a818c8:         vetDatatype( conn, "boolean", "boolean", "true", "false", "true", "1", "1", "2" );
1:8a818c8: 
1:8a818c8:         vetDatatype( conn, "long", "bigint", "1", "2", "3", "1", "3", "6" );
1:8a818c8:         vetDatatype( conn, "int", "int", "1", "2", "3", "1", "3", "6" );
1:8a818c8:         vetDatatype( conn, "short", "smallint", "1", "2", "3", "1", "3", "6" );
1:8a818c8: 
1:8a818c8:         vetDatatype( conn, "bigdecimal", "decimal(5,2)", "1.0", "2.0", "3.0", "1", "3", "6" );
1:8a818c8:         vetDatatype( conn, "bigdecimal", "numeric(5,2)", "1.0", "2.0", "3.0", "1", "3", "6" );
1:8a818c8: 
1:8a818c8:         vetDatatype( conn, "double", "double", "1.0", "2.0", "3.0", "1.0", "3.0", "6.0" );
1:8a818c8:         vetDatatype( conn, "float", "real", "1.0", "2.0", "3.0", "1.0", "3.0", "6.0" );
1:8a818c8:         vetDatatype( conn, "double", "float", "1.0", "2.0", "3.0", "1.0", "3.0", "6.0" );
1:8a818c8: 
1:8a818c8:         vetDatatype( conn, "blob", "blob", "makeBlob( '1' )", "makeBlob( '2' )", "makeBlob( '3' )", "1", "3", "6" );
1:8a818c8:         vetDatatype( conn, "clob", "clob", "makeClob( '1' )", "makeClob( '2' )", "makeClob( '3' )", "1", "12", "123" );
1:8a818c8: 
1:8a818c8:         vetDatatype( conn, "byte[]", "char(1) for bit data", "makeBytes( '1' )", "makeBytes( '2' )", "makeBytes( '3' )", "1", "3", "6" );
1:8a818c8:         vetDatatype( conn, "byte[]", "varchar(10) for bit data", "makeVarBytes( '1' )", "makeVarBytes( '2' )", "makeVarBytes( '3' )", "1", "3", "6" );
1:8a818c8:         vetDatatype( conn, "byte[]", "long varchar for bit data", "makeLongVarBytes( '1' )", "makeLongVarBytes( '2' )", "makeLongVarBytes( '3' )", "1", "3", "6" );
1:8a818c8: 
1:8a818c8:         vetDatatype( conn, "String", "char(1)", "'1'", "'2'", "'3'", "1", "12", "123" );
1:8a818c8:         vetDatatype( conn, "String", "varchar(10)", "'1'", "'2'", "'3'", "1", "12", "123" );
1:8a818c8:         vetDatatype( conn, "String", "long varchar", "'1'", "'2'", "'3'", "1", "12", "123" );
1:8a818c8: 
1:8a818c8:         vetDatatype( conn, "date", "date", "date('1994-02-23')", "date('1995-02-23')", "date('1996-02-23')", "1", "2", "3" );
1:8a818c8:         vetDatatype( conn, "time", "time", "time('15:09:02')", "time('14:09:02')", "time('13:09:02')", "1", "2", "3" );
1:8a818c8:         vetDatatype( conn, "timestamp", "timestamp", "timestamp('1962-09-23 03:23:34.234')", "timestamp('1963-09-23 03:23:34.234')", "timestamp('1964-09-23 03:23:34.234')", "1", "2", "3" );
1:8a818c8: 
1:8a818c8:         vetDatatype
1:8a818c8:             (
1:8a818c8:              conn, "Price", "Price",
1:8a818c8:              "makePrice( 'USD', cast( 9.99 as decimal( 31, 5 ) ), timestamp('2009-10-16 14:24:43') )",
1:8a818c8:              "makePrice( 'USD', cast( 10.99 as decimal( 31, 5 ) ), timestamp('2009-10-16 14:24:43') )",
1:8a818c8:              "makePrice( 'USD', cast( 11.99 as decimal( 31, 5 ) ), timestamp('2009-10-16 14:24:43') )",
1:8a818c8:              "1", "2", "3" );
1:8a818c8: 
1:8a818c8:         //
1:8a818c8:         // Check that implicit coercions work correctly
1:8a818c8:         //
1:8a818c8:         goodStatement
1:8a818c8:             ( conn,
1:8a818c8:               "create table all_types\n" +
1:8a818c8:               "(\n" +
1:8a818c8:               "    bigint_col  bigint,\n" +
1:8a818c8:               "    blob_col    blob,\n" +
1:8a818c8:               "    boolean_col boolean,\n" +
1:8a818c8:               "    char_col    char( 1 ),\n" +
1:8a818c8:               "    char_for_bit_data_col   char( 1 ) for bit data,\n" +
1:8a818c8:               "    clob_col    clob,\n" +
1:8a818c8:               "    date_col    date,\n" +
1:8a818c8:               "    decimal_col decimal,\n" +
1:8a818c8:               "    double_col  double,\n" +
1:8a818c8:               "    float_col   float,\n" +
1:8a818c8:               "    integer_col int,\n" +
1:8a818c8:               "    long_varchar_col    long varchar,\n" +
1:8a818c8:               "    long_varchar_for_bit_data_col   long varchar for bit data,\n" +
1:8a818c8:               "    numeric_col    numeric,\n" +
1:8a818c8:               "    real_col       real,\n" +
1:8a818c8:               "    smallint_col   smallint,\n" +
1:8a818c8:               "    time_col       time,\n" +
1:8a818c8:               "    timestamp_col  timestamp,\n" +
1:8a818c8:               "    varchar_col    varchar( 5 ),\n" +
1:8a818c8:               "    varchar_for_bit_data_col  varchar( 10 ) for bit data,\n" +
1:8a818c8:               "    price_col    price\n" +
1:8a818c8:               ")\n"
1:8a818c8:               );
1:8a818c8:         goodStatement
1:8a818c8:             ( conn,
1:8a818c8:               "insert into all_types values\n" +
1:8a818c8:               "(\n" +
1:8a818c8:               "    1,\n" +
1:8a818c8:               "    makeBlob( '1' ),\n" +
1:8a818c8:               "    true,\n" +
1:8a818c8:               "    '1',\n" +
1:8a818c8:               "    makeBytes( '1' ),\n" +
1:8a818c8:               "    makeClob( '1' ),\n" +
1:8a818c8:               "    date( '1994-02-23' ),\n" +
1:8a818c8:               "    1.0,\n" +
1:8a818c8:               "    1.0,\n" +
1:8a818c8:               "    1.0,\n" +
1:8a818c8:               "    1,\n" +
1:8a818c8:               "    '1',\n" +
1:8a818c8:               "    makeLongVarBytes( '1' ),\n" +
1:8a818c8:               "    1.0,\n" +
1:8a818c8:               "    1.0,\n" +
1:8a818c8:               "    1,\n" +
1:8a818c8:               "    time( '15:09:02' ),\n" +
1:8a818c8:               "    timestamp( '1962-09-23 03:23:34.234' ),\n" +
1:8a818c8:               "    '1',\n" +
1:8a818c8:               "    makeVarBytes( '1' ),\n" +
1:8a818c8:               "    makePrice( 'USD', cast( 9.99 as decimal( 31, 5 ) ), timestamp('2009-10-16 14:24:43') )\n" +
1:8a818c8:               ")\n"
1:8a818c8:               );
1:8a818c8:         
1:8a818c8:         vetNumericCoercions( conn, "long", "bigint", "1" );
1:8a818c8:         vetNumericCoercions( conn, "int", "int", "1" );
1:8a818c8:         vetNumericCoercions( conn, "short", "smallint", "1" );
1:8a818c8:         vetNumericCoercions( conn, "bigdecimal", "decimal", "1" );
1:8a818c8:         vetNumericCoercions( conn, "bigdecimal", "numeric", "1" );
1:8a818c8:         vetNumericCoercions( conn, "float", "real", "1.0" );
1:8a818c8:         vetNumericCoercions( conn, "double", "double", "1.0" );
1:8a818c8:         vetNumericCoercions( conn, "double", "float", "1.0" );
1:8a818c8: 
1:8a818c8:         vetStringCoercions( conn, "String", "char(50)" );
1:8a818c8:         vetStringCoercions( conn, "clob", "clob" );
1:8a818c8:         vetStringCoercions( conn, "String", "varchar(50)" );
1:8a818c8:         vetStringCoercions( conn, "String", "long varchar" );
1:8a818c8: 
1:8a818c8:         vetTimeCoercions( conn, "date", "date" );
1:8a818c8:         vetTimeCoercions( conn, "time", "time" );
1:8a818c8:         vetTimeCoercions( conn, "timestamp", "timestamp" );
1:8a818c8: 
1:8a818c8:         vetBinaryCoercions( conn, "byte[]", "char(1) for bit data" );
1:8a818c8:         vetBinaryCoercions( conn, "byte[]", "varchar(10) for bit data" );
1:8a818c8:         vetBinaryCoercions( conn, "byte[]", "long varchar for bit data" );
1:8a818c8: 
1:8a818c8:         vetBooleanCoercions( conn, "boolean", "boolean" );
1:8a818c8: 
1:8a818c8:         vetPriceCoercions( conn, "Price", "Price" );
1:8a818c8:     }
1:8a818c8:     private void    vetDatatype
1:8a818c8:         (
1:8a818c8:          Connection conn,
1:8a818c8:          String javatype,
1:8a818c8:          String sqltype,
1:8a818c8:          String arg1,
1:8a818c8:          String arg2,
1:8a818c8:          String arg3,
1:8a818c8:          String result1,
1:8a818c8:          String result2,
1:8a818c8:          String result3
1:8a818c8:          )
1:8a818c8:         throws Exception
1:8a818c8:     {
1:8a818c8:         createAddFunc( conn, sqltype );
1:8a818c8: 
1:8a818c8:         // no varargs
1:8a818c8:         assertResults
1:8a818c8:             (
1:8a818c8:              conn,
1:8a818c8:              "values addFunc( '" + sqltype + "' )",
1:8a818c8:              new String[][]
1:8a818c8:              {
1:8a818c8:                  { null },
1:8a818c8:              },
1:8a818c8:              false
1:8a818c8:              );
1:8a818c8: 
1:8a818c8:         // one vararg
1:8a818c8:         assertResults
1:8a818c8:             (
1:8a818c8:              conn,
1:8a818c8:              "values addFunc( '" + sqltype + "', " + arg1 + " )",
1:8a818c8:              new String[][]
1:8a818c8:              {
1:8a818c8:                  { javatype + " " + sqltype + " " + result1 },
1:8a818c8:              },
1:8a818c8:              false
1:8a818c8:              );
1:8a818c8: 
1:8a818c8:         // two varargs
1:8a818c8:         assertResults
1:8a818c8:             (
1:8a818c8:              conn,
1:8a818c8:              "values addFunc( '" + sqltype + "', " + arg1 + ", " + arg2 + " )",
1:8a818c8:              new String[][]
1:8a818c8:              {
1:8a818c8:                  { javatype + " " + sqltype + " " + result2 },
1:8a818c8:              },
1:8a818c8:              false
1:8a818c8:              );
1:8a818c8: 
1:8a818c8:         // three varargs
1:8a818c8:         assertResults
1:8a818c8:             (
1:8a818c8:              conn,
1:8a818c8:              "values addFunc( '" + sqltype + "', " + arg1 + ", " + arg2 + ", " + arg3 + " )",
1:8a818c8:              new String[][]
1:8a818c8:              {
1:8a818c8:                  { javatype + " " + sqltype + " " + result3 },
1:8a818c8:              },
1:8a818c8:              false
1:8a818c8:              );
1:8a818c8: 
1:8a818c8:         dropAddFunc( conn );
1:8a818c8:     }
1:8a818c8:     private void    createAddFunc( Connection conn, String sqltype )
1:8a818c8:         throws Exception
1:8a818c8:     {
1:8a818c8:         goodStatement
1:8a818c8:             ( conn,
1:8a818c8:               "create function addFunc( seed varchar( 50 ), a " + sqltype + " ... ) returns varchar( 50 )\n" +
1:8a818c8:               "language java parameter style derby no sql deterministic\n" +
1:8a818c8:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.add'\n"
1:8a818c8:               );
1:8a818c8:     }
1:8a818c8:     private void    dropAddFunc( Connection conn )  throws Exception
1:8a818c8:     {
1:8a818c8:         goodStatement( conn, "drop function addFunc" );
1:8a818c8:     }
1:8a818c8: 
1:8a818c8:     private void    vetNumericCoercions
1:8a818c8:         ( Connection conn, String javatype, String sqltype, String expectedValue )
1:8a818c8:         throws Exception
1:8a818c8:     {
1:8a818c8:         createAddFunc( conn, sqltype );
1:8a818c8: 
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "bigint_col", expectedValue );
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "decimal_col", expectedValue );
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "double_col", expectedValue );
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "float_col", expectedValue );
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "integer_col", expectedValue );
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "numeric_col", expectedValue );
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "real_col", expectedValue );
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "smallint_col", expectedValue );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "blob_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "boolean_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "char_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "char_for_bit_data_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "clob_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "date_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "long_varchar_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "long_varchar_for_bit_data_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "time_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "timestamp_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "varchar_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "price_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         dropAddFunc( conn );
1:8a818c8:     }
1:8a818c8:     private void    vetGoodCoercion
1:8a818c8:         ( Connection conn, String javatype, String sqltype, String colname, String expectedValue )
1:8a818c8:         throws Exception
1:8a818c8:     {
1:8a818c8:         assertResults
1:8a818c8:             (
1:8a818c8:              conn,
1:8a818c8:              "select addFunc( '" + sqltype + "', " + colname + " ) from all_types",
1:8a818c8:              new String[][]
1:8a818c8:              {
1:8a818c8:                  { javatype + " " + sqltype + " " + expectedValue },
1:8a818c8:              },
1:8a818c8:              true
1:8a818c8:              );
1:8a818c8:     }
1:8a818c8:     private void    vetBadCoercion
1:8a818c8:         ( Connection conn, String sqltype, String colname, String sqlstate )
1:8a818c8:         throws Exception
1:8a818c8:     {
1:8a818c8:         expectCompilationError( sqlstate, "select addFunc( '" + sqltype + "', " + colname + " ) from all_types" );
1:8a818c8:     }
1:8a818c8:     
1:8a818c8:     private void    vetStringCoercions
1:8a818c8:         ( Connection conn, String javatype, String sqltype )
1:8a818c8:         throws Exception
1:8a818c8:     {
1:8a818c8:         createAddFunc( conn, sqltype );
1:8a818c8: 
1:8a818c8:         boolean isClob = javatype.equals( "clob" ) || sqltype.equals( "long varchar" );
1:8a818c8: 
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "char_col", "1" );
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "clob_col", "1" );
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "long_varchar_col", "1" );
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "varchar_col", "1" );
1:8a818c8: 
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "boolean_col", "true" );
1:8a818c8: 
1:8a818c8:         if ( isClob )
1:8a818c8:         {
1:8a818c8:             vetBadCoercion( conn, sqltype, "date_col", ILLEGAL_STORAGE );
1:8a818c8:             vetBadCoercion( conn, sqltype, "time_col", ILLEGAL_STORAGE );
1:8a818c8:             vetBadCoercion( conn, sqltype, "timestamp_col", ILLEGAL_STORAGE );
1:8a818c8:         }
1:8a818c8:         else
1:8a818c8:         {
1:8a818c8:             vetGoodCoercion( conn, javatype, sqltype, "date_col", "1994-02-23" );
1:8a818c8:             vetGoodCoercion( conn, javatype, sqltype, "time_col", "15:09:02" );
1:8a818c8:             vetGoodCoercion( conn, javatype, sqltype, "timestamp_col", "1962-09-23 03:23:34.234" );
1:8a818c8:         }
1:8a818c8:         
1:8a818c8:         vetBadCoercion( conn, sqltype, "bigint_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "decimal_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "double_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "float_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "integer_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "numeric_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "real_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "smallint_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "blob_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "char_for_bit_data_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "varchar_for_bit_data_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "long_varchar_for_bit_data_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "price_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         dropAddFunc( conn );
1:8a818c8:     }
1:8a818c8: 
1:8a818c8:     private void    vetTimeCoercions
1:8a818c8:         ( Connection conn, String javatype, String sqltype )
1:8a818c8:         throws Exception
1:8a818c8:     {
1:8a818c8:         createAddFunc( conn, sqltype );
1:8a818c8: 
1:8a818c8:         if ( javatype.equals( "date" ) )
1:8a818c8:         {
1:8a818c8:             vetGoodCoercion( conn, javatype, sqltype, "date_col", "1" );
1:8a818c8:         }
1:8a818c8:         else
1:8a818c8:         {
1:8a818c8:             vetBadCoercion( conn, sqltype, "date_col", ILLEGAL_STORAGE );
1:8a818c8:         }
1:8a818c8: 
1:8a818c8:         if ( javatype.equals( "time" ) )
1:8a818c8:         {
1:8a818c8:             vetGoodCoercion( conn, javatype, sqltype, "time_col", "1" );
1:8a818c8:         }
1:8a818c8:         else
1:8a818c8:         {
1:8a818c8:             vetBadCoercion( conn, sqltype, "time_col", ILLEGAL_STORAGE );
1:8a818c8:         }
1:8a818c8: 
1:8a818c8:         if ( javatype.equals( "timestamp" ) )
1:8a818c8:         {
1:8a818c8:             vetGoodCoercion( conn, javatype, sqltype, "timestamp_col", "1" );
1:8a818c8:         }
1:8a818c8:         else
1:8a818c8:         {
1:8a818c8:             vetBadCoercion( conn, sqltype, "timestamp_col", ILLEGAL_STORAGE );
1:8a818c8:         }
1:8a818c8: 
1:8a818c8:         vetBadFormat( conn, sqltype, "char_col", BAD_TIME_FORMAT );
1:8a818c8:         vetBadFormat( conn, sqltype, "varchar_col", BAD_TIME_FORMAT );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "clob_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "long_varchar_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "boolean_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "bigint_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "decimal_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "double_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "float_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "integer_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "numeric_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "real_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "smallint_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "blob_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "char_for_bit_data_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "varchar_for_bit_data_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "long_varchar_for_bit_data_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "price_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         dropAddFunc( conn );
1:8a818c8:     }
1:8a818c8:     private void    vetBadFormat
1:8a818c8:         ( Connection conn, String sqltype, String colname, String sqlstate )
1:8a818c8:         throws Exception
1:8a818c8:     {
1:8a818c8:         expectExecutionError( conn, sqlstate, "select addFunc( '" + sqltype + "', " + colname + " ) from all_types" );
1:8a818c8:     }
1:8a818c8: 
1:8a818c8:     private void    vetBinaryCoercions
1:8a818c8:         ( Connection conn, String javatype, String sqltype )
1:8a818c8:         throws Exception
1:8a818c8:     {
1:8a818c8:         createAddFunc( conn, sqltype );
1:8a818c8: 
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "char_for_bit_data_col", "1" );
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "varchar_for_bit_data_col", "1" );
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "long_varchar_for_bit_data_col", "1" );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "char_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "varchar_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "clob_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "long_varchar_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "date_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "time_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "timestamp_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "boolean_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "bigint_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "decimal_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "double_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "float_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "integer_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "numeric_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "real_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "smallint_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "blob_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "price_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         dropAddFunc( conn );
1:8a818c8:     }
1:8a818c8: 
1:8a818c8:     private void    vetBooleanCoercions
1:8a818c8:         ( Connection conn, String javatype, String sqltype )
1:8a818c8:         throws Exception
1:8a818c8:     {
1:8a818c8:         createAddFunc( conn, sqltype );
1:8a818c8: 
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "boolean_col", "1" );
1:8a818c8: 
1:8a818c8:         vetBadFormat( conn, sqltype, "char_col", BAD_BOOLEAN_FORMAT );
1:8a818c8:         vetBadFormat( conn, sqltype, "varchar_col", BAD_BOOLEAN_FORMAT );
1:8a818c8:         vetBadFormat( conn, sqltype, "clob_col", BAD_BOOLEAN_FORMAT );
1:8a818c8:         vetBadFormat( conn, sqltype, "long_varchar_col", BAD_BOOLEAN_FORMAT );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "char_for_bit_data_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "varchar_for_bit_data_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "long_varchar_for_bit_data_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "date_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "time_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "timestamp_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "bigint_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "decimal_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "double_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "float_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "integer_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "numeric_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "real_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "smallint_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "blob_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "price_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         dropAddFunc( conn );
1:8a818c8:     }
1:8a818c8: 
1:8a818c8:     private void    vetPriceCoercions
1:8a818c8:         ( Connection conn, String javatype, String sqltype )
1:8a818c8:         throws Exception
1:8a818c8:     {
1:8a818c8:         createAddFunc( conn, sqltype );
1:8a818c8: 
1:8a818c8:         vetGoodCoercion( conn, javatype, sqltype, "price_col", "1" );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "char_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "varchar_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "clob_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "long_varchar_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "boolean_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "char_for_bit_data_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "varchar_for_bit_data_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "long_varchar_for_bit_data_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "date_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "time_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "timestamp_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "bigint_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "decimal_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "double_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "float_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "integer_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "numeric_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "real_col", ILLEGAL_STORAGE );
1:8a818c8:         vetBadCoercion( conn, sqltype, "smallint_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         vetBadCoercion( conn, sqltype, "blob_col", ILLEGAL_STORAGE );
1:8a818c8: 
1:8a818c8:         dropAddFunc( conn );
1:8a818c8:     }
1:f9596d4: 
1:8a818c8:     /**
1:8a818c8:      * <p>
1:8a818c8:      * Test vararg table functions.
1:8a818c8:      * </p>
1:8a818c8:      */
1:8a818c8:     public void test_06_tableFunctions() throws Exception
1:8a818c8:     {
1:8a818c8:         if ( !vmSupportsVarargs() ) { return; }
1:8a818c8: 
1:8a818c8:         Connection conn = getConnection();
1:8a818c8: 
1:8a818c8:         // although varargs are allowed with table functions, the parameter style
1:8a818c8:         // must still be derby_jdbc_result_set
1:8a818c8:         expectCompilationError
1:8a818c8:             ( NEEDS_DJRS_STYLE,
1:8a818c8:               "create function tf_derby( rowValues varchar( 32672 ) )\n" +
1:8a818c8:               "returns table\n" +
1:8a818c8:               "(\n" +
1:8a818c8:               "    col1 varchar( 32672 )\n" +
1:8a818c8:               ")\n" +
1:8a818c8:               "language java parameter style derby no sql deterministic\n" +
1:8a818c8:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.oneColumnRows'\n"
1:8a818c8:               );
1:8a818c8:         expectCompilationError
1:8a818c8:             ( NEEDS_DJRS_STYLE,
1:8a818c8:               "create function tf_derby_varargs( rowValues varchar( 32672 ) ... )\n" +
1:8a818c8:               "returns table\n" +
1:8a818c8:               "(\n" +
1:8a818c8:               "    col1 varchar( 32672 )\n" +
1:8a818c8:               ")\n" +
1:8a818c8:               "language java parameter style derby no sql deterministic\n" +
1:8a818c8:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.oneColumnRows'\n"
1:8a818c8:               );
1:8a818c8: 
1:8a818c8:         // vararg table functions ok if the parameter style is derby_jdbc_result_set
1:8a818c8:         goodStatement
1:8a818c8:             ( conn,
1:8a818c8:               "create function oneColumnRows( rowValues varchar( 32672 ) ... )\n" +
1:8a818c8:               "returns table\n" +
1:8a818c8:               "(\n" +
1:8a818c8:               "    col1 varchar( 32672 )\n" +
1:8a818c8:               ")\n" +
1:8a818c8:               "language java parameter style derby_jdbc_result_set no sql deterministic\n" +
1:8a818c8:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.oneColumnRows'\n"
1:8a818c8:               );
1:8a818c8:         assertResults
1:8a818c8:             (
1:8a818c8:              conn,
1:8a818c8:              "select * from table( oneColumnRows() ) s",
1:8a818c8:              new String[][]
1:8a818c8:              {
1:8a818c8:              },
1:8a818c8:              false
1:8a818c8:              );
1:8a818c8:         assertResults
1:8a818c8:             (
1:8a818c8:              conn,
1:8a818c8:              "select * from table( oneColumnRows( 'one' ) ) s",
1:8a818c8:              new String[][]
1:8a818c8:              {
1:8a818c8:                  { "one" },
1:8a818c8:              },
1:8a818c8:              false
1:8a818c8:              );
1:8a818c8:         assertResults
1:8a818c8:             (
1:8a818c8:              conn,
1:8a818c8:              "select * from table( oneColumnRows( 'one', 'two' ) ) s",
1:8a818c8:              new String[][]
1:8a818c8:              {
1:8a818c8:                  { "one" },
1:8a818c8:                  { "two" },
1:8a818c8:              },
1:8a818c8:              false
1:8a818c8:              );
1:8a818c8:         assertResults
1:8a818c8:             (
1:8a818c8:              conn,
1:8a818c8:              "select * from table( oneColumnRows( 'one', 'two', 'three' ) ) s",
1:8a818c8:              new String[][]
1:8a818c8:              {
1:8a818c8:                  { "one" },
1:8a818c8:                  { "two" },
1:8a818c8:                  { "three" },
1:8a818c8:              },
1:8a818c8:              false
1:8a818c8:              );
1:8a818c8: 
1:8a818c8:     }
1:8a818c8: 
1:f9596d4:     /**
1:f9596d4:      * <p>
1:615cb37:      * Test for NPE reported on DERBY-6047.
1:615cb37:      * </p>
1:615cb37:      */
1:615cb37:     public void test_07_6047() throws Exception
1:615cb37:     {
1:615cb37:         Connection conn = getConnection();
1:615cb37: 
1:615cb37:         goodStatement
1:615cb37:             ( conn,
1:615cb37:               "create procedure PROC_6047( inout x int )\n" +
1:615cb37:               "parameter style java modifies sql data language java\n" +
1:615cb37:               "external name 'DUMMY.PROC_6047'\n"
1:615cb37:               );
1:615cb37: 
1:615cb37:         expectCompilationError
1:615cb37:             ( NEEDS_PARAMETER_MARKER,
1:615cb37:               "call PROC_6047(1)"
1:615cb37:               );
1:615cb37:     }
1:615cb37:     
1:232d09a:     ///////////////////////////////////////////////////////////////////////////////////
1:232d09a:     //
1:232d09a:     // MINIONS
1:232d09a:     //
1:232d09a:     ///////////////////////////////////////////////////////////////////////////////////
1:232d09a: 
1:232d09a:     /** Return true if the VM supports vararg methods */
1:232d09a:     private boolean vmSupportsVarargs() { return JDBC.vmSupportsJDBC3(); }
1:232d09a: 
1:f9596d4: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("UserDefinedAggregatesTest");
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:615cb37
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  NEEDS_PARAMETER_MARKER = "42886";
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Test for NPE reported on DERBY-6047.
1:      * </p>
1:      */
1:     public void test_07_6047() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         goodStatement
1:             ( conn,
1:               "create procedure PROC_6047( inout x int )\n" +
1:               "parameter style java modifies sql data language java\n" +
1:               "external name 'DUMMY.PROC_6047'\n"
1:               );
1: 
1:         expectCompilationError
1:             ( NEEDS_PARAMETER_MARKER,
1:               "call PROC_6047(1)"
1:               );
1:     }
1:     
commit:8a818c8
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  BAD_TIME_FORMAT = "22007";
1:     private static  final   String  BAD_BOOLEAN_FORMAT = "22018";
1:     private static  final   String  NEEDS_DJRS_STYLE = "42ZB2";
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Test varargs with all datatypes.
1:      * </p>
1:      */
1:     public void test_05_datatypes() throws Exception
1:     {
1:         if ( !vmSupportsVarargs() ) { return; }
1: 
1:         Connection conn = getConnection();
1: 
1:         goodStatement
1:             ( conn,
1:               "create function makeBlob( a varchar( 32672 ) ) returns blob\n" +
1:               "language java parameter style java no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.makeBlob'\n"
1:               );
1:         goodStatement
1:             ( conn,
1:               "create function makeBytes( a varchar( 32672 ) ) returns char(1) for bit data\n" +
1:               "language java parameter style java no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.makeBytes'\n"
1:               );
1:         goodStatement
1:             ( conn,
1:               "create function makeVarBytes( a varchar( 32672 ) ) returns varchar(10) for bit data\n" +
1:               "language java parameter style java no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.makeBytes'\n"
1:               );
1:         goodStatement
1:             ( conn,
1:               "create function makeLongVarBytes( a varchar( 32672 ) ) returns long varchar for bit data\n" +
1:               "language java parameter style java no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.makeBytes'\n"
1:               );
1:         goodStatement
1:             ( conn,
1:               "create function makeClob( a varchar( 32672 ) ) returns clob\n" +
1:               "language java parameter style java no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.makeClob'\n"
1:               );
1:         goodStatement( conn, "create type Price external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:         goodStatement
1:             ( conn,
1:               "create function makePrice( currencyCode char( 3 ), amount decimal( 31, 5 ), timeInstant Timestamp )\n" +
1:               "returns Price language java parameter style java no sql\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice'\n");
1: 
1:         vetDatatype( conn, "boolean", "boolean", "true", "false", "true", "1", "1", "2" );
1: 
1:         vetDatatype( conn, "long", "bigint", "1", "2", "3", "1", "3", "6" );
1:         vetDatatype( conn, "int", "int", "1", "2", "3", "1", "3", "6" );
1:         vetDatatype( conn, "short", "smallint", "1", "2", "3", "1", "3", "6" );
1: 
1:         vetDatatype( conn, "bigdecimal", "decimal(5,2)", "1.0", "2.0", "3.0", "1", "3", "6" );
1:         vetDatatype( conn, "bigdecimal", "numeric(5,2)", "1.0", "2.0", "3.0", "1", "3", "6" );
1: 
1:         vetDatatype( conn, "double", "double", "1.0", "2.0", "3.0", "1.0", "3.0", "6.0" );
1:         vetDatatype( conn, "float", "real", "1.0", "2.0", "3.0", "1.0", "3.0", "6.0" );
1:         vetDatatype( conn, "double", "float", "1.0", "2.0", "3.0", "1.0", "3.0", "6.0" );
1: 
1:         vetDatatype( conn, "blob", "blob", "makeBlob( '1' )", "makeBlob( '2' )", "makeBlob( '3' )", "1", "3", "6" );
1:         vetDatatype( conn, "clob", "clob", "makeClob( '1' )", "makeClob( '2' )", "makeClob( '3' )", "1", "12", "123" );
1: 
1:         vetDatatype( conn, "byte[]", "char(1) for bit data", "makeBytes( '1' )", "makeBytes( '2' )", "makeBytes( '3' )", "1", "3", "6" );
1:         vetDatatype( conn, "byte[]", "varchar(10) for bit data", "makeVarBytes( '1' )", "makeVarBytes( '2' )", "makeVarBytes( '3' )", "1", "3", "6" );
1:         vetDatatype( conn, "byte[]", "long varchar for bit data", "makeLongVarBytes( '1' )", "makeLongVarBytes( '2' )", "makeLongVarBytes( '3' )", "1", "3", "6" );
1: 
1:         vetDatatype( conn, "String", "char(1)", "'1'", "'2'", "'3'", "1", "12", "123" );
1:         vetDatatype( conn, "String", "varchar(10)", "'1'", "'2'", "'3'", "1", "12", "123" );
1:         vetDatatype( conn, "String", "long varchar", "'1'", "'2'", "'3'", "1", "12", "123" );
1: 
1:         vetDatatype( conn, "date", "date", "date('1994-02-23')", "date('1995-02-23')", "date('1996-02-23')", "1", "2", "3" );
1:         vetDatatype( conn, "time", "time", "time('15:09:02')", "time('14:09:02')", "time('13:09:02')", "1", "2", "3" );
1:         vetDatatype( conn, "timestamp", "timestamp", "timestamp('1962-09-23 03:23:34.234')", "timestamp('1963-09-23 03:23:34.234')", "timestamp('1964-09-23 03:23:34.234')", "1", "2", "3" );
1: 
1:         vetDatatype
1:             (
1:              conn, "Price", "Price",
1:              "makePrice( 'USD', cast( 9.99 as decimal( 31, 5 ) ), timestamp('2009-10-16 14:24:43') )",
1:              "makePrice( 'USD', cast( 10.99 as decimal( 31, 5 ) ), timestamp('2009-10-16 14:24:43') )",
1:              "makePrice( 'USD', cast( 11.99 as decimal( 31, 5 ) ), timestamp('2009-10-16 14:24:43') )",
1:              "1", "2", "3" );
1: 
1:         //
1:         // Check that implicit coercions work correctly
1:         //
1:         goodStatement
1:             ( conn,
1:               "create table all_types\n" +
1:               "(\n" +
1:               "    bigint_col  bigint,\n" +
1:               "    blob_col    blob,\n" +
1:               "    boolean_col boolean,\n" +
1:               "    char_col    char( 1 ),\n" +
1:               "    char_for_bit_data_col   char( 1 ) for bit data,\n" +
1:               "    clob_col    clob,\n" +
1:               "    date_col    date,\n" +
1:               "    decimal_col decimal,\n" +
1:               "    double_col  double,\n" +
1:               "    float_col   float,\n" +
1:               "    integer_col int,\n" +
1:               "    long_varchar_col    long varchar,\n" +
1:               "    long_varchar_for_bit_data_col   long varchar for bit data,\n" +
1:               "    numeric_col    numeric,\n" +
1:               "    real_col       real,\n" +
1:               "    smallint_col   smallint,\n" +
1:               "    time_col       time,\n" +
1:               "    timestamp_col  timestamp,\n" +
1:               "    varchar_col    varchar( 5 ),\n" +
1:               "    varchar_for_bit_data_col  varchar( 10 ) for bit data,\n" +
1:               "    price_col    price\n" +
1:               ")\n"
1:               );
1:         goodStatement
1:             ( conn,
1:               "insert into all_types values\n" +
1:               "(\n" +
1:               "    1,\n" +
1:               "    makeBlob( '1' ),\n" +
1:               "    true,\n" +
1:               "    '1',\n" +
1:               "    makeBytes( '1' ),\n" +
1:               "    makeClob( '1' ),\n" +
1:               "    date( '1994-02-23' ),\n" +
1:               "    1.0,\n" +
1:               "    1.0,\n" +
1:               "    1.0,\n" +
1:               "    1,\n" +
1:               "    '1',\n" +
1:               "    makeLongVarBytes( '1' ),\n" +
1:               "    1.0,\n" +
1:               "    1.0,\n" +
1:               "    1,\n" +
1:               "    time( '15:09:02' ),\n" +
1:               "    timestamp( '1962-09-23 03:23:34.234' ),\n" +
1:               "    '1',\n" +
1:               "    makeVarBytes( '1' ),\n" +
1:               "    makePrice( 'USD', cast( 9.99 as decimal( 31, 5 ) ), timestamp('2009-10-16 14:24:43') )\n" +
1:               ")\n"
1:               );
1:         
1:         vetNumericCoercions( conn, "long", "bigint", "1" );
1:         vetNumericCoercions( conn, "int", "int", "1" );
1:         vetNumericCoercions( conn, "short", "smallint", "1" );
1:         vetNumericCoercions( conn, "bigdecimal", "decimal", "1" );
1:         vetNumericCoercions( conn, "bigdecimal", "numeric", "1" );
1:         vetNumericCoercions( conn, "float", "real", "1.0" );
1:         vetNumericCoercions( conn, "double", "double", "1.0" );
1:         vetNumericCoercions( conn, "double", "float", "1.0" );
1: 
1:         vetStringCoercions( conn, "String", "char(50)" );
1:         vetStringCoercions( conn, "clob", "clob" );
1:         vetStringCoercions( conn, "String", "varchar(50)" );
1:         vetStringCoercions( conn, "String", "long varchar" );
1: 
1:         vetTimeCoercions( conn, "date", "date" );
1:         vetTimeCoercions( conn, "time", "time" );
1:         vetTimeCoercions( conn, "timestamp", "timestamp" );
1: 
1:         vetBinaryCoercions( conn, "byte[]", "char(1) for bit data" );
1:         vetBinaryCoercions( conn, "byte[]", "varchar(10) for bit data" );
1:         vetBinaryCoercions( conn, "byte[]", "long varchar for bit data" );
1: 
1:         vetBooleanCoercions( conn, "boolean", "boolean" );
1: 
1:         vetPriceCoercions( conn, "Price", "Price" );
1:     }
1:     private void    vetDatatype
1:         (
1:          Connection conn,
1:          String javatype,
1:          String sqltype,
1:          String arg1,
1:          String arg2,
1:          String arg3,
1:          String result1,
1:          String result2,
1:          String result3
1:          )
1:         throws Exception
1:     {
1:         createAddFunc( conn, sqltype );
1: 
1:         // no varargs
1:         assertResults
1:             (
1:              conn,
1:              "values addFunc( '" + sqltype + "' )",
1:              new String[][]
1:              {
1:                  { null },
1:              },
1:              false
1:              );
1: 
1:         // one vararg
1:         assertResults
1:             (
1:              conn,
1:              "values addFunc( '" + sqltype + "', " + arg1 + " )",
1:              new String[][]
1:              {
1:                  { javatype + " " + sqltype + " " + result1 },
1:              },
1:              false
1:              );
1: 
1:         // two varargs
1:         assertResults
1:             (
1:              conn,
1:              "values addFunc( '" + sqltype + "', " + arg1 + ", " + arg2 + " )",
1:              new String[][]
1:              {
1:                  { javatype + " " + sqltype + " " + result2 },
1:              },
1:              false
1:              );
1: 
1:         // three varargs
1:         assertResults
1:             (
1:              conn,
1:              "values addFunc( '" + sqltype + "', " + arg1 + ", " + arg2 + ", " + arg3 + " )",
1:              new String[][]
1:              {
1:                  { javatype + " " + sqltype + " " + result3 },
1:              },
1:              false
1:              );
1: 
1:         dropAddFunc( conn );
1:     }
1:     private void    createAddFunc( Connection conn, String sqltype )
1:         throws Exception
1:     {
1:         goodStatement
1:             ( conn,
1:               "create function addFunc( seed varchar( 50 ), a " + sqltype + " ... ) returns varchar( 50 )\n" +
1:               "language java parameter style derby no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.add'\n"
1:               );
1:     }
1:     private void    dropAddFunc( Connection conn )  throws Exception
1:     {
1:         goodStatement( conn, "drop function addFunc" );
1:     }
1: 
1:     private void    vetNumericCoercions
1:         ( Connection conn, String javatype, String sqltype, String expectedValue )
1:         throws Exception
1:     {
1:         createAddFunc( conn, sqltype );
1: 
1:         vetGoodCoercion( conn, javatype, sqltype, "bigint_col", expectedValue );
1:         vetGoodCoercion( conn, javatype, sqltype, "decimal_col", expectedValue );
1:         vetGoodCoercion( conn, javatype, sqltype, "double_col", expectedValue );
1:         vetGoodCoercion( conn, javatype, sqltype, "float_col", expectedValue );
1:         vetGoodCoercion( conn, javatype, sqltype, "integer_col", expectedValue );
1:         vetGoodCoercion( conn, javatype, sqltype, "numeric_col", expectedValue );
1:         vetGoodCoercion( conn, javatype, sqltype, "real_col", expectedValue );
1:         vetGoodCoercion( conn, javatype, sqltype, "smallint_col", expectedValue );
1: 
1:         vetBadCoercion( conn, sqltype, "blob_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "boolean_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "char_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "char_for_bit_data_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "clob_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "date_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "long_varchar_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "long_varchar_for_bit_data_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "time_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "timestamp_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "varchar_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "price_col", ILLEGAL_STORAGE );
1: 
1:         dropAddFunc( conn );
1:     }
1:     private void    vetGoodCoercion
1:         ( Connection conn, String javatype, String sqltype, String colname, String expectedValue )
1:         throws Exception
1:     {
1:         assertResults
1:             (
1:              conn,
1:              "select addFunc( '" + sqltype + "', " + colname + " ) from all_types",
1:              new String[][]
1:              {
1:                  { javatype + " " + sqltype + " " + expectedValue },
1:              },
1:              true
1:              );
1:     }
1:     private void    vetBadCoercion
1:         ( Connection conn, String sqltype, String colname, String sqlstate )
1:         throws Exception
1:     {
1:         expectCompilationError( sqlstate, "select addFunc( '" + sqltype + "', " + colname + " ) from all_types" );
1:     }
1:     
1:     private void    vetStringCoercions
1:         ( Connection conn, String javatype, String sqltype )
1:         throws Exception
1:     {
1:         createAddFunc( conn, sqltype );
1: 
1:         boolean isClob = javatype.equals( "clob" ) || sqltype.equals( "long varchar" );
1: 
1:         vetGoodCoercion( conn, javatype, sqltype, "char_col", "1" );
1:         vetGoodCoercion( conn, javatype, sqltype, "clob_col", "1" );
1:         vetGoodCoercion( conn, javatype, sqltype, "long_varchar_col", "1" );
1:         vetGoodCoercion( conn, javatype, sqltype, "varchar_col", "1" );
1: 
1:         vetGoodCoercion( conn, javatype, sqltype, "boolean_col", "true" );
1: 
1:         if ( isClob )
1:         {
1:             vetBadCoercion( conn, sqltype, "date_col", ILLEGAL_STORAGE );
1:             vetBadCoercion( conn, sqltype, "time_col", ILLEGAL_STORAGE );
1:             vetBadCoercion( conn, sqltype, "timestamp_col", ILLEGAL_STORAGE );
1:         }
1:         else
1:         {
1:             vetGoodCoercion( conn, javatype, sqltype, "date_col", "1994-02-23" );
1:             vetGoodCoercion( conn, javatype, sqltype, "time_col", "15:09:02" );
1:             vetGoodCoercion( conn, javatype, sqltype, "timestamp_col", "1962-09-23 03:23:34.234" );
1:         }
1:         
1:         vetBadCoercion( conn, sqltype, "bigint_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "decimal_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "double_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "float_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "integer_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "numeric_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "real_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "smallint_col", ILLEGAL_STORAGE );
1: 
1:         vetBadCoercion( conn, sqltype, "blob_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "char_for_bit_data_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "varchar_for_bit_data_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "long_varchar_for_bit_data_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "price_col", ILLEGAL_STORAGE );
1: 
1:         dropAddFunc( conn );
1:     }
1: 
1:     private void    vetTimeCoercions
1:         ( Connection conn, String javatype, String sqltype )
1:         throws Exception
1:     {
1:         createAddFunc( conn, sqltype );
1: 
1:         if ( javatype.equals( "date" ) )
1:         {
1:             vetGoodCoercion( conn, javatype, sqltype, "date_col", "1" );
1:         }
1:         else
1:         {
1:             vetBadCoercion( conn, sqltype, "date_col", ILLEGAL_STORAGE );
1:         }
1: 
1:         if ( javatype.equals( "time" ) )
1:         {
1:             vetGoodCoercion( conn, javatype, sqltype, "time_col", "1" );
1:         }
1:         else
1:         {
1:             vetBadCoercion( conn, sqltype, "time_col", ILLEGAL_STORAGE );
1:         }
1: 
1:         if ( javatype.equals( "timestamp" ) )
1:         {
1:             vetGoodCoercion( conn, javatype, sqltype, "timestamp_col", "1" );
1:         }
1:         else
1:         {
1:             vetBadCoercion( conn, sqltype, "timestamp_col", ILLEGAL_STORAGE );
1:         }
1: 
1:         vetBadFormat( conn, sqltype, "char_col", BAD_TIME_FORMAT );
1:         vetBadFormat( conn, sqltype, "varchar_col", BAD_TIME_FORMAT );
1: 
1:         vetBadCoercion( conn, sqltype, "clob_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "long_varchar_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "boolean_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "bigint_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "decimal_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "double_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "float_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "integer_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "numeric_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "real_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "smallint_col", ILLEGAL_STORAGE );
1: 
1:         vetBadCoercion( conn, sqltype, "blob_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "char_for_bit_data_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "varchar_for_bit_data_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "long_varchar_for_bit_data_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "price_col", ILLEGAL_STORAGE );
1: 
1:         dropAddFunc( conn );
1:     }
1:     private void    vetBadFormat
1:         ( Connection conn, String sqltype, String colname, String sqlstate )
1:         throws Exception
1:     {
1:         expectExecutionError( conn, sqlstate, "select addFunc( '" + sqltype + "', " + colname + " ) from all_types" );
1:     }
1: 
1:     private void    vetBinaryCoercions
1:         ( Connection conn, String javatype, String sqltype )
1:         throws Exception
1:     {
1:         createAddFunc( conn, sqltype );
1: 
1:         vetGoodCoercion( conn, javatype, sqltype, "char_for_bit_data_col", "1" );
1:         vetGoodCoercion( conn, javatype, sqltype, "varchar_for_bit_data_col", "1" );
1:         vetGoodCoercion( conn, javatype, sqltype, "long_varchar_for_bit_data_col", "1" );
1: 
1:         vetBadCoercion( conn, sqltype, "char_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "varchar_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "clob_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "long_varchar_col", ILLEGAL_STORAGE );
1: 
1:         vetBadCoercion( conn, sqltype, "date_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "time_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "timestamp_col", ILLEGAL_STORAGE );
1: 
1:         vetBadCoercion( conn, sqltype, "boolean_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "bigint_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "decimal_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "double_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "float_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "integer_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "numeric_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "real_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "smallint_col", ILLEGAL_STORAGE );
1: 
1:         vetBadCoercion( conn, sqltype, "blob_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "price_col", ILLEGAL_STORAGE );
1: 
1:         dropAddFunc( conn );
1:     }
1: 
1:     private void    vetBooleanCoercions
1:         ( Connection conn, String javatype, String sqltype )
1:         throws Exception
1:     {
1:         createAddFunc( conn, sqltype );
1: 
1:         vetGoodCoercion( conn, javatype, sqltype, "boolean_col", "1" );
1: 
1:         vetBadFormat( conn, sqltype, "char_col", BAD_BOOLEAN_FORMAT );
1:         vetBadFormat( conn, sqltype, "varchar_col", BAD_BOOLEAN_FORMAT );
1:         vetBadFormat( conn, sqltype, "clob_col", BAD_BOOLEAN_FORMAT );
1:         vetBadFormat( conn, sqltype, "long_varchar_col", BAD_BOOLEAN_FORMAT );
1: 
1:         vetBadCoercion( conn, sqltype, "char_for_bit_data_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "varchar_for_bit_data_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "long_varchar_for_bit_data_col", ILLEGAL_STORAGE );
1: 
1:         vetBadCoercion( conn, sqltype, "date_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "time_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "timestamp_col", ILLEGAL_STORAGE );
1: 
1:         vetBadCoercion( conn, sqltype, "bigint_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "decimal_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "double_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "float_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "integer_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "numeric_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "real_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "smallint_col", ILLEGAL_STORAGE );
1: 
1:         vetBadCoercion( conn, sqltype, "blob_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "price_col", ILLEGAL_STORAGE );
1: 
1:         dropAddFunc( conn );
1:     }
1: 
1:     private void    vetPriceCoercions
1:         ( Connection conn, String javatype, String sqltype )
1:         throws Exception
1:     {
1:         createAddFunc( conn, sqltype );
1: 
1:         vetGoodCoercion( conn, javatype, sqltype, "price_col", "1" );
1: 
1:         vetBadCoercion( conn, sqltype, "char_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "varchar_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "clob_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "long_varchar_col", ILLEGAL_STORAGE );
1: 
1:         vetBadCoercion( conn, sqltype, "boolean_col", ILLEGAL_STORAGE );
1: 
1:         vetBadCoercion( conn, sqltype, "char_for_bit_data_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "varchar_for_bit_data_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "long_varchar_for_bit_data_col", ILLEGAL_STORAGE );
1: 
1:         vetBadCoercion( conn, sqltype, "date_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "time_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "timestamp_col", ILLEGAL_STORAGE );
1: 
1:         vetBadCoercion( conn, sqltype, "bigint_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "decimal_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "double_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "float_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "integer_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "numeric_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "real_col", ILLEGAL_STORAGE );
1:         vetBadCoercion( conn, sqltype, "smallint_col", ILLEGAL_STORAGE );
1: 
1:         vetBadCoercion( conn, sqltype, "blob_col", ILLEGAL_STORAGE );
1: 
1:         dropAddFunc( conn );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Test vararg table functions.
1:      * </p>
1:      */
1:     public void test_06_tableFunctions() throws Exception
1:     {
1:         if ( !vmSupportsVarargs() ) { return; }
1: 
1:         Connection conn = getConnection();
1: 
1:         // although varargs are allowed with table functions, the parameter style
1:         // must still be derby_jdbc_result_set
1:         expectCompilationError
1:             ( NEEDS_DJRS_STYLE,
1:               "create function tf_derby( rowValues varchar( 32672 ) )\n" +
1:               "returns table\n" +
1:               "(\n" +
1:               "    col1 varchar( 32672 )\n" +
1:               ")\n" +
1:               "language java parameter style derby no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.oneColumnRows'\n"
1:               );
1:         expectCompilationError
1:             ( NEEDS_DJRS_STYLE,
1:               "create function tf_derby_varargs( rowValues varchar( 32672 ) ... )\n" +
1:               "returns table\n" +
1:               "(\n" +
1:               "    col1 varchar( 32672 )\n" +
1:               ")\n" +
1:               "language java parameter style derby no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.oneColumnRows'\n"
1:               );
1: 
1:         // vararg table functions ok if the parameter style is derby_jdbc_result_set
1:         goodStatement
1:             ( conn,
1:               "create function oneColumnRows( rowValues varchar( 32672 ) ... )\n" +
1:               "returns table\n" +
1:               "(\n" +
1:               "    col1 varchar( 32672 )\n" +
1:               ")\n" +
1:               "language java parameter style derby_jdbc_result_set no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.oneColumnRows'\n"
1:               );
1:         assertResults
1:             (
1:              conn,
1:              "select * from table( oneColumnRows() ) s",
1:              new String[][]
1:              {
1:              },
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "select * from table( oneColumnRows( 'one' ) ) s",
1:              new String[][]
1:              {
1:                  { "one" },
1:              },
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "select * from table( oneColumnRows( 'one', 'two' ) ) s",
1:              new String[][]
1:              {
1:                  { "one" },
1:                  { "two" },
1:              },
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "select * from table( oneColumnRows( 'one', 'two', 'three' ) ) s",
1:              new String[][]
1:              {
1:                  { "one" },
1:                  { "two" },
1:                  { "three" },
1:              },
1:              false
1:              );
1: 
1:     }
1: 
commit:ba70926
/////////////////////////////////////////////////////////////////////////
1: import java.sql.CallableStatement;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  AMBIGUOUS = "42X73";
1:     private static  final   String  NO_SUCH_METHOD = "42X50";
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Misc tests for varargs routines.
1:      * </p>
1:      */
1:     public void test_03_misc() throws Exception
1:     {
1:         if ( !vmSupportsVarargs() ) { return; }
1: 
1:         Connection conn = getConnection();
1: 
1:         // primitive and wrapper overloads make method resolution ambiguous
1: 
1:         goodStatement
1:             ( conn,
1:               "create function ambiguousTypes( a int ... ) returns int\n" +
1:               "language java parameter style derby no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.ambiguousTypes'\n"
1:               );
1:         expectCompilationError( AMBIGUOUS, "values ambiguousTypes( 1, 2, 3 )" );
1: 
1:         // can resolve to a primitive-typed vararg
1:         goodStatement
1:             ( conn,
1:               "create function maxInts( a int ... ) returns int\n" +
1:               "language java parameter style derby no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.maxInts'\n"
1:               );
1:         assertResults
1:             (
1:              conn,
1:              "values maxInts( 3 )",
1:              new String[][]
1:              {
1:                  { "3" },
1:              },
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "values maxInts( 1, 2, 5, 4, 3 )",
1:              new String[][]
1:              {
1:                  { "5" },
1:              },
1:              false
1:              );
1: 
1:         // error if the matching method isn't varargs
1:         goodStatement
1:             ( conn,
1:               "create function nonVarargsMethod( a int ... ) returns int\n" +
1:               "language java parameter style derby no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.nonVarargsMethod'\n"
1:               );
1:         expectCompilationError( NO_SUCH_METHOD, "values nonVarargsMethod( 3 )" );
1:         
1:         // correctly disambiguate similar varargs and non-varargs methods
1:         goodStatement
1:             ( conn,
1:               "create function vnvr_vararg( a int ... ) returns int\n" +
1:               "language java parameter style derby no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.vnvr'\n"
1:               );
1:         goodStatement
1:             ( conn,
1:               "create function vnvr_nonvararg( a int ) returns int\n" +
1:               "language java parameter style java no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.vnvr'\n"
1:               );
1:         assertResults
1:             (
1:              conn,
1:              "values vnvr_vararg( 3 )",
1:              new String[][]
1:              {
1:                  { "3" },
1:              },
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "values vnvr_nonvararg( 3 )",
1:              new String[][]
1:              {
1:                  { "-3" },
1:              },
1:              false
1:              );
1:         
1:         // correctly disambiguate overloads with different numbers of leading non-vararg arguments
1:         goodStatement
1:             ( conn,
1:               "create function lnv( a int ... ) returns int\n" +
1:               "language java parameter style derby no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.lnv'\n"
1:               );
1:         goodStatement
1:             ( conn,
1:               "create function lnv_1( a int, b int ... ) returns int\n" +
1:               "language java parameter style derby no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.lnv'\n"
1:               );
1:         goodStatement
1:             ( conn,
1:               "create function lnv_2( a int, b int, c int ... ) returns int\n" +
1:               "language java parameter style derby no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.lnv'\n"
1:               );
1:         assertResults
1:             (
1:              conn,
1:              "values lnv( 5, 4, 3, 2, 1 )",
1:              new String[][]
1:              {
1:                  { "5" },
1:              },
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "values lnv_1( 5, 4, 3, 2, 1 )",
1:              new String[][]
1:              {
1:                  { "4" },
1:              },
1:              false
1:              );
1:         assertResults
1:             (
1:              conn,
1:              "values lnv_2( 5, 4, 3, 2, 1 )",
1:              new String[][]
1:              {
1:                  { "3" },
1:              },
1:              false
1:              );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Test in, out, and in/out procedure arguments which are varargs.
1:      * </p>
1:      */
1:     public void test_04_inOut() throws Exception
1:     {
1:         if ( !vmSupportsVarargs() ) { return; }
1: 
1:         Connection conn = getConnection();
1:         CallableStatement   cs =  null;
1: 
1:         // one input vararg
1:         goodStatement
1:             ( conn,
1:               "create procedure inVarargs( out result varchar( 32672 ), b int ... )\n" +
1:               "language java parameter style derby no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.inVarargs'\n"
1:               );
1:         cs = chattyPrepareCall
1:             ( conn, "call inVarargs( ?, ? )" );
1:         cs.registerOutParameter( 1, java.sql.Types.VARCHAR );
1:         cs.setInt( 2, 5 );
1:         cs.execute();
1:         assertEquals( "RESULT:  5", cs.getString( 1 ) );
1: 
1:         cs = chattyPrepareCall
1:             ( conn, "call inVarargs( ?, ?, ? )" );
1:         cs.registerOutParameter( 1, java.sql.Types.VARCHAR );
1:         cs.setInt( 2, 5 );
1:         cs.setInt( 3, 4 );
1:         cs.execute();
1:         assertEquals( "RESULT:  5 4", cs.getString( 1 ) );
1: 
1:         cs = chattyPrepareCall
1:             ( conn, "call inVarargs( ?, ?, ?, ? )" );
1:         cs.registerOutParameter( 1, java.sql.Types.VARCHAR );
1:         cs.setInt( 2, 5 );
1:         cs.setInt( 3, 4 );
1:         cs.setInt( 4, 3 );
1:         cs.execute();
1:         assertEquals( "RESULT:  5 4 3", cs.getString( 1 ) );
1: 
1:         // output vararg
1:         goodStatement
1:             ( conn,
1:               "create procedure outVarargs( seed int, out b int ... )\n" +
1:               "language java parameter style derby no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.outVarargs'\n"
1:               );
1:         cs = chattyPrepareCall
1:             ( conn, "call outVarargs( ? )" );
1:         cs.setInt( 1, 5 );
1:         cs.execute();
1: 
1:         cs = chattyPrepareCall
1:             ( conn, "call outVarargs( ?, ? )" );
1:         cs.registerOutParameter( 2, java.sql.Types.INTEGER );
1:         cs.setInt( 1, 5 );
1:         cs.execute();
1:         assertEquals( 5, cs.getInt( 2 ) );
1: 
1:         cs = chattyPrepareCall
1:             ( conn, "call outVarargs( ?, ?, ? )" );
1:         cs.registerOutParameter( 2, java.sql.Types.INTEGER );
1:         cs.registerOutParameter( 3, java.sql.Types.INTEGER );
1:         cs.setInt( 1, 5 );
1:         cs.execute();
1:         assertEquals( 5, cs.getInt( 2 ) );
1:         assertEquals( 6, cs.getInt( 3 ) );
1: 
1:         cs = chattyPrepareCall
1:             ( conn, "call outVarargs( ?, ?, ?, ? )" );
1:         cs.registerOutParameter( 2, java.sql.Types.INTEGER );
1:         cs.registerOutParameter( 3, java.sql.Types.INTEGER );
1:         cs.registerOutParameter( 4, java.sql.Types.INTEGER );
1:         cs.setInt( 1, 5 );
1:         cs.execute();
1:         assertEquals( 5, cs.getInt( 2 ) );
1:         assertEquals( 6, cs.getInt( 3 ) );
1:         assertEquals( 7, cs.getInt( 4 ) );
1: 
1:         // in/out vararg
1:         goodStatement
1:             ( conn,
1:               "create procedure inoutVarargs( seed int, inout b int ... )\n" +
1:               "language java parameter style derby no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.inoutVarargs'\n"
1:               );
1:         cs = chattyPrepareCall
1:             ( conn, "call inoutVarargs( ? )" );
1:         cs.setInt( 1, 5 );
1:         cs.execute();
1: 
1:         cs = chattyPrepareCall
1:             ( conn, "call inoutVarargs( ?, ? )" );
1:         cs.registerOutParameter( 2, java.sql.Types.INTEGER );
1:         cs.setInt( 1, 5 );
1:         cs.setInt( 2, 3 );
1:         cs.execute();
1:         assertEquals( 8, cs.getInt( 2 ) );
1: 
1:         cs = chattyPrepareCall
1:             ( conn, "call inoutVarargs( ?, ?, ? )" );
1:         cs.registerOutParameter( 2, java.sql.Types.INTEGER );
1:         cs.registerOutParameter( 3, java.sql.Types.INTEGER );
1:         cs.setInt( 1, 5 );
1:         cs.setInt( 2, 3 );
1:         cs.setInt( 3, 10 );
1:         cs.execute();
1:         assertEquals( 8, cs.getInt( 2 ) );
1:         assertEquals( 15, cs.getInt( 3 ) );
1: 
1:         cs = chattyPrepareCall
1:             ( conn, "call inoutVarargs( ?, ?, ?, ? )" );
1:         cs.registerOutParameter( 2, java.sql.Types.INTEGER );
1:         cs.registerOutParameter( 3, java.sql.Types.INTEGER );
1:         cs.registerOutParameter( 4, java.sql.Types.INTEGER );
1:         cs.setInt( 1, 5 );
1:         cs.setInt( 2, 3 );
1:         cs.setInt( 3, 10 );
1:         cs.setInt( 4, 100 );
1:         cs.execute();
1:         assertEquals( 8, cs.getInt( 2 ) );
1:         assertEquals( 15, cs.getInt( 3 ) );
1:         assertEquals( 105, cs.getInt( 4 ) );
1: 
1:     }
1:     
commit:232d09a
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Simple invocations to verify that varargs routines can be invoked.
1:      * </p>
1:      */
1:     public void test_02_simple() throws Exception
1:     {
1:         if ( !vmSupportsVarargs() ) { return; }
1:         
1:         Connection conn = getConnection();
1: 
1:         goodStatement
1:             ( conn,
1:               "create function maximum( a int ... ) returns int\n" +
1:               "language java parameter style derby no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.max'\n"
1:               );
1:         goodStatement
1:             ( conn,
1:               "create function formatMessage( message varchar( 32672 ),  args varchar( 32672 ) ... ) returns varchar( 32672 )\n" +
1:               "language java parameter style derby no sql deterministic\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.VarargsRoutines.formatMessage'\n"
1:               );
1: 
1:         // 0 args
1:         assertResults
1:             (
1:              conn,
1:              "values maximum()",
1:              new String[][]
1:              {
1:                  { null },
1:              },
1:              false
1:              );
1:         
1:         // a null argument
1:         assertResults
1:             (
1:              conn,
1:              "values maximum( null )",
1:              new String[][]
1:              {
1:                  { null },
1:              },
1:              false
1:              );
1:         
1:         // one non-null argument
1:         assertResults
1:             (
1:              conn,
1:              "values maximum( 1 )",
1:              new String[][]
1:              {
1:                  { "1" },
1:              },
1:              false
1:              );
1:          
1:         // multiple arguments
1:         assertResults
1:             (
1:              conn,
1:              "values maximum( 1, 3, 2 )",
1:              new String[][]
1:              {
1:                  { "3" },
1:              },
1:              false
1:              );
1:          
1:         // verify that arguments are passed in the correct order
1:         assertResults
1:             (
1:              conn,
1:              "values formatMessage( 'First {0} then {1} then {2}', 'one', 'two', 'three' )",
1:              new String[][]
1:              {
1:                  { "First one then two then three" },
1:              },
1:              false
1:              );
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /** Return true if the VM supports vararg methods */
1:     private boolean vmSupportsVarargs() { return JDBC.vmSupportsJDBC3(); }
1: 
commit:f9596d4
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.VarargsTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.Connection;
0: import java.sql.DriverManager;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: import org.apache.derbyTesting.junit.Decorator;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: import org.apache.derbyTesting.junit.JDBC;
1: 
1: /**
1:  * <p>
1:  * Test routines with varargs. See DERBY-3069.
1:  * </p>
1:  */
1: public class VarargsTest  extends GeneratedColumnsHelper
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private static  final   String  NEEDS_DERBY_STYLE = "42ZC9";
1:     private static  final   String  NEEDS_JAVA_STYLE = "42ZCA";
1:     private static  final   String  RETURNS_RESULT_SETS = "42ZCB";
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Create a new instance.
1:      */
1: 
1:     public VarargsTest(String name)
1:     {
1:         super(name);
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // JUnit BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Construct top level suite in this JUnit test
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite       suite = new TestSuite( "UserDefinedAggregatesTest" );
1: 
1:         suite.addTest( TestConfiguration.defaultSuite( VarargsTest.class ) );
1: 
1:         return suite;
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // TESTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Basic syntax.
1:      * </p>
1:      */
1:     public void test_01_basicSyntax() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         goodStatement
1:             ( conn,
1:               "create function varargsDerbyStyle( a int ... ) returns int\n" +
1:               "parameter style derby language java no sql\n" +
1:               "external name 'Foo.foo'\n"
1:               );
1:         goodStatement
1:             ( conn,
1:               "create function varargsTableFunction( a int ... )\n" +
1:               "returns table( b int )\n" +
1:               "language java parameter style derby_jdbc_result_set no sql\n" +
1:               "external name 'Foo.foo'\n"
1:               );
1:         goodStatement
1:             ( conn,
1:               "create function nonvarargsJavaStyle( a int ) returns int\n" +
1:               "parameter style java language java no sql\n" +
1:               "external name 'Foo.foo'\n"
1:               );
1:         goodStatement
1:             ( conn,
1:               "create procedure varargsDerbyStyle( a int ... )\n" +
1:               "language java parameter style derby no sql\n" +
1:               "external name 'Foo.foo'\n"
1:               );
1:         goodStatement
1:             ( conn,
1:               "create procedure nonvarargsJavaStyle( a int )\n" +
1:               "language java parameter style java no sql\n" +
1:               "external name 'Foo.foo'\n"
1:               );
1: 
1:         // bad parameter style
1:         expectCompilationError
1:             ( NEEDS_DERBY_STYLE,
1:               "create function varargsJavaStyle( a int ... ) returns int\n" +
1:               "parameter style java language java no sql\n" +
1:               "external name 'Foo.foo'\n"
1:               );
1:         expectCompilationError
1:             ( NEEDS_JAVA_STYLE,
1:               "create function nonvarargsDerbyStyle( a int ) returns int\n" +
1:               "parameter style derby language java no sql\n" +
1:               "external name 'Foo.foo'\n"
1:               );
1:         expectCompilationError
1:             ( NEEDS_DERBY_STYLE,
1:               "create procedure varargsDerbyStyle( a int ... )\n" +
1:               "language java parameter style java no sql\n" +
1:               "external name 'Foo.foo'\n"
1:               );
1:         expectCompilationError
1:             ( NEEDS_JAVA_STYLE,
1:               "create procedure nonvarargsDerbyStyle( a int )\n" +
1:               "language java parameter style derby no sql\n" +
1:               "external name 'Foo.foo'\n"
1:               );
1: 
1:         // need at least one parameter in order to use varargs
1:         expectCompilationError
1:             ( SYNTAX_ERROR,
1:               "create function varargsDerbyStyleNoParam( ... ) returns int\n" +
1:               "parameter style derby language java no sql\n" +
1:               "external name 'Foo.foo'\n"
1:               );
1:         expectCompilationError
1:             ( SYNTAX_ERROR,
1:               "create procedure varargsDerbyStyleNoParam( ... )\n" +
1:               "language java parameter style derby no sql\n" +
1:               "external name 'Foo.foo'\n"
1:               );
1: 
1:         // bad because returns result sets
1:         expectCompilationError
1:             ( RETURNS_RESULT_SETS,
1:               "create procedure varargsDerbyStyle( a int ... )\n" +
1:               "language java parameter style derby no sql result sets 1\n" +
1:               "external name 'Foo.foo'\n"
1:               );
1:     }
1: 
1: }
============================================================================