1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.services.compiler.MethodBuilder
1:7ecc1f2: 
1:6baf18b:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6baf18b:    contributor license agreements.  See the NOTICE file distributed with
1:6baf18b:    this work for additional information regarding copyright ownership.
1:6baf18b:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6baf18b:    (the "License"); you may not use this file except in compliance with
1:6baf18b:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
5:eac0369: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.services.compiler;
1:eac0369: 
4:eac0369: /**
1:eac0369: 	MethodBuilder is used to generate the code for a method.
1:eac0369: 	<P>
1:eac0369: 
1:eac0369: 	The code for a method is built in a way that corresponds to the
1:eac0369: 	layout of the stack machine that is the Java Virtual Machine.
1:eac0369: 	Values are pushed on the stack, moved about on the stack
1:eac0369: 	and then popped off the stack by operations such as method
1:eac0369: 	calls. An understanding of hoe the JVM operates is useful
1:eac0369: 	before using this class.
1:eac0369: 
1:eac0369: 	<P>
1:eac0369: 	All the method descriptions below are generating bytecode
1:eac0369: 	to achieved the desired behaviour when the generated class
1:eac0369: 	is loaded. None of this class's methods calls actually
1:eac0369: 	invoke methods or create objects described by the callers.
1:0393775:  */
1:eac0369: public interface MethodBuilder {
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Declare the method throws an exception.
1:eac0369: 	   Must be called before any code is added
1:eac0369: 	   to the method.
1:0393775: 	 */
1:eac0369: 	public void addThrownException(String exceptionClass);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * return the name of the method.
1:eac0369: 	 */
1:eac0369: 	public String getName();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Indicate the method is complete. Once this
1:eac0369: 		call has been made the caller must discard
1:eac0369: 		the reference to this object.
1:eac0369: 	 */
1:eac0369: 	public void complete();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Push a parameter value.
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...  =&gt;
1:eac0369: 		      ...,param_value
1:eac0369: 		</PRE>
1:eac0369: 		@param id position of the parameter (zero based).
1:eac0369: 	*/
1:eac0369: 	public void getParameter(int id);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Push a byte constant onto the stack
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...  =&gt;
1:eac0369: 		      ...,byte_value
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void push(byte value);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Push a boolean constant onto the stack
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...  =&gt;
1:eac0369: 		      ...,boolean_value
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void push(boolean value);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Push a short constant onto the stack
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...  =&gt;
1:eac0369: 		      ...,short_value
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void push(short value);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Push a int constant onto the stack
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...  =&gt;
1:eac0369: 		      ...,int_value
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void push(int value);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Push a long constant onto the stack
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...  =&gt;
1:eac0369: 		      ...,long_value
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void push(long value);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Push a float constant onto the stack
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...  =&gt;
1:eac0369: 		      ...,float_value
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void push(float value);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Push a double constant onto the stack
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...  =&gt;
1:eac0369: 		      ...,double_value
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void push(double value);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Push a String constant onto the stack
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...  =&gt;
1:eac0369: 		      ...,String_value
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void push(String value);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Push a typed null onto the stack
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...  =&gt;
1:eac0369: 		      ...,null
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void pushNull(String className);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Push the contents of the local field onto the stack.
1:eac0369: 		This call pushes the this instance required to access the field itself.
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...  =&gt;
1:eac0369: 		      ...,field_value
1:eac0369: 		</PRE>
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public void getField(LocalField field);
1:0393775: 
1:0393775: 	/**
1:eac0369: 		Push the contents of the described field onto the stack.
1:eac0369: 		This call requires the instance (reference) to be pushed by the caller.
1:eac0369: 
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...,field_ref  =&gt;
1:eac0369: 		      ...,field_value
1:eac0369: 		</PRE>
1:eac0369: 		
1:eac0369: 	*/
1:eac0369: 	public void getField(String declaringClass, String fieldName, String fieldType);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Push the contents of the described static field onto the stack.
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...  =&gt;
1:eac0369: 		      ...,field_value
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void getStaticField(String declaringClass, String fieldName, String fieldType);
1:eac0369: 
1:eac0369: 	/**
1:afa871e: 	Pop the top stack value and store it in the local field. 
1:afa871e: 	This call pushes the this instance required to access the field itself.
1:afa871e: 	This call does not leave any value on the stack.
1:afa871e: 
1:afa871e: 	<PRE>
1:dbed020: 	Stack ...,value  =&gt;
1:afa871e: 	      ...
1:afa871e: 	</PRE>
1:afa871e: 	*/
1:afa871e: 	public void setField(LocalField field);
1:0393775: 
1:0393775: 	/**
1:eac0369: 		Pop the top stack value and store it in the local field. 
1:eac0369: 		This call pushes the this instance required to access the field itself.
1:eac0369: 		Like the Java language 'field = value', this leaves the value on the stack.
1:afa871e: 
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...,value  =&gt;
1:eac0369: 		      ...,value
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void putField(LocalField field);
1:eac0369: 
1:afa871e: 	/**
1:eac0369: 		Pop the top stack value and store it in the instance field of this class.
1:eac0369: 		This call pushes the this instance required to access the field itself.
1:eac0369: 		Like the Java language 'field = value', this leaves the value on the stack.
1:eac0369: 
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...,value  =&gt;
1:eac0369: 		      ...,value
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void putField(String fieldName, String fieldType);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Pop the top stack value and store it in the field.
1:eac0369: 		This call requires the instance to be pushed by the caller.
1:eac0369: 		Like the Java language 'field = value', this leaves the value on the stack.
1:eac0369: 
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...,field_ref,value  =&gt;
1:eac0369: 		      ...,value
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void putField(String declaringClass, String fieldName, String fieldType);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Initiate a sequence that calls a constructor, equivalent to the new operator in Java.
1:eac0369: 		After this call, the caller must push any arguments and then complete the
1:eac0369: 		construction with a call to pushNewComplete(). Only arguments to the constructor
1:eac0369: 		can be pushed onto the stack between the pushNewStart() and pushNewComplete() method
1:eac0369: 		calls.
1:eac0369: 
1:eac0369: 		<PRE>
1:dbed020: 		Stack ... =&gt; [unchanged]
1:eac0369: 		      ...
1:eac0369: 		</PRE>
1:eac0369: 
1:eac0369: 		@param className class name of object to be created.
1:eac0369: 	*/
1:eac0369: 	public void pushNewStart(String className);
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Complete the sequence that was started with pushNewStart().
1:eac0369: 		Pop the arguments to the constructor and push the reference
1:eac0369: 		to the newly created object.
1:eac0369: 
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...,value* =&gt; [numArgs number of values will be popped]
1:eac0369: 		      ...,new_ref
1:eac0369: 		</PRE>
1:eac0369: 
1:eac0369: 		@param numArgs number of arguments to the constructor (can be 0).
1:eac0369: 	*/
1:eac0369: 	public void pushNewComplete(int numArgs);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Create an instance of an array and push it onto the stack. 
1:eac0369: 
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...  =&gt;
1:eac0369: 		      ...,array_ref
1:eac0369: 		</PRE>
1:eac0369: 
1:eac0369: 		@param className - type of array.
1:eac0369: 		@param size - number of elements in the array
1:eac0369: 	*/
1:eac0369: 	public void pushNewArray(String className, int size);
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Push this onto the stack.
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...  =&gt;
1:eac0369: 		      ...,this_ref
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void pushThis();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Upcast the top stack value. This is used for correct method resolution
1:eac0369: 		by upcasting method parameters. It does not put any casting code into the
1:eac0369: 		byte code stream. Can only be used for refrences.
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...,ref =&gt;
1:eac0369: 		      ...,ref
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void upCast(String className);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Cast the top stack value. Correctly down-casts a reference or casts
1:eac0369: 		a primitive type (e.g. int to short).
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...,value =&gt;
1:eac0369: 		      ...,cast_value
1:eac0369: 		</PRE>
1:eac0369: 
1:eac0369: 		@param className type (primitive, interface or class) to cast to.
1:eac0369: 	*/
1:eac0369: 	public void cast(String className);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Pop the top stack value and push a boolean that is the result of
1:eac0369: 		an instanceof check on the popped reference.
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...,ref =&gt;
1:eac0369: 		      ...,boolean_value
1:eac0369: 		</PRE>.
1:eac0369: 	*/
1:eac0369: 	public void isInstanceOf(String className);
1:d6e8491: 	
1:d6e8491: 	/**
1:d6e8491: 	 * Pop the top value off the stack
1:d6e8491: 		<PRE>
1:dbed020: 		Stack ..., value =&gt;
1:d6e8491: 		      ...
1:d6e8491: 		</PRE>.
1:d6e8491: 	*/
1:d6e8491: 	public void pop();
1:d6e8491: 		
1:eac0369: 	/**
1:eac0369: 		End a statement.
1:eac0369: 		Pops the top-word of the stack, if any.
1:eac0369: 		Must only be called if zero or one item exists
1:eac0369: 		on the stack.
1:eac0369: 		<PRE>
1:dbed020: 		Stack value =&gt;
1:eac0369: 		      :empty:
1:eac0369: 		or
1:eac0369: 
1:dbed020: 		Stack :empty: =&gt;
1:eac0369: 		      :empty:
1:eac0369: 
1:eac0369: 		</PRE>.
1:eac0369: 	*/
1:eac0369: 	public void endStatement();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return from a method, optionally with a value.
1:eac0369: 		Must only be called if zero or one item exists
1:eac0369: 		on the stack. If the stack contains a single
1:eac0369: 		value then that is popped and used as the returned value.
1:eac0369: 		<PRE>
1:dbed020: 		Stack value =&gt;
1:eac0369: 		      :empty:
1:eac0369: 		or
1:eac0369: 
1:dbed020: 		Stack :empty: =&gt;
1:eac0369: 		      :empty:
1:eac0369: 
1:eac0369: 		</PRE>.
1:eac0369: 	*/
1:eac0369: 	public void methodReturn();
1:eac0369: 
1:eac0369: 	/**
1:4549ad4: 		Initiate a conditional sequence.
1:eac0369: 		The top value on the stack (a reference) is popped and compared to 'null'.
1:eac0369: 		If the value is null then the code following this call until the startElseCode()
1:eac0369: 		will be executed at runtime, otherwise the code following startElseCode() until
1:eac0369: 		the completeConditional() is called.
1:eac0369: 		<BR>
1:eac0369: 		E.g. 
1:eac0369: 
1:eac0369: 		<PRE>
1:eac0369: 		mb.callMethod(...); // pushes an object onto the stack
1:eac0369: 		mb.conditionalIfNull();
1:eac0369: 		  mb.push(3);
1:eac0369: 		mb.startElseCode();
1:eac0369: 		  mb.push(5);
1:eac0369: 		mb.completeConditional();
1:eac0369: 		// at this point 3 or 5 will be on the stack
1:eac0369: 		</PRE>
1:eac0369: 
1:eac0369: 		Each path through the ?: statement must leave the stack at the same depth
1:eac0369: 		as the other.
1:4549ad4: 		<BR>
1:4549ad4: 		If the if or else code pops values from the stack that were before the conditional
1:4549ad4: 		value, then they must use the same number of values from the stack.
1:eac0369: 
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...,ref =&gt;
1:eac0369: 		      ...
1:eac0369: 		</PRE>.
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public void conditionalIfNull();
1:4549ad4: 	
1:eac0369: 	/**
1:4549ad4: 		Initiate a conditional sequence.
1:eac0369: 		The top value on the stack must be a boolean and will be popped. If it
1:eac0369: 		is true then the code following this call until the startElseCode()
1:eac0369: 		will be executed at runtime, otherwise the code following startElseCode() until
1:4549ad4: 		the completeConditional() is called. See conditionalIfNull() for example
1:4549ad4: 		and restrictions.
1:eac0369: 
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...,boolean_value =&gt;
1:eac0369: 		      ...
1:eac0369: 		</PRE>.
1:eac0369: 	*/
1:eac0369: 	public void conditionalIf();
1:eac0369: 
1:eac0369: 	/**
1:4549ad4: 		Complete the true code path of a conditional.
1:eac0369: 	*/
1:eac0369: 	public void startElseCode();
1:eac0369: 
1:eac0369: 	/**
1:4549ad4: 		Complete a conditional which completes the false code path.
1:eac0369: 	*/
1:eac0369: 	public void completeConditional();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Call a method. The instance (receiver or reference) for non-static methods
1:eac0369: 		must be pushed by the caller. The instance (for non-static) and the arguments
1:eac0369: 		are popped of the stack, and the return value (if any) is pushed onto the stack.
1:eac0369: 		<BR>
1:eac0369: 		The type needs to be one of:
1:eac0369: 		<UL>
1:eac0369: 		<LI> VMOpcode.INVOKESTATIC - call a static method
1:eac0369: 		<LI> VMOpcode.INVOKEVIRTUAL - call method declared in the class or super-class.
1:eac0369: 		<LI> VMOpcode.INVOKEINTERFACE - call a method declared in an interface
1:eac0369: 		</UL>
1:eac0369: 
1:eac0369: 
1:eac0369: 		<PRE>
1:eac0369: 		static methods
1:eac0369: 
1:dbed020: 		Stack ...,value* =&gt; [numArgs number of values will be popped]
1:eac0369: 		      ...,return_value [void methods will not push a value]
1:eac0369: 
1:eac0369: 		non-static methods
1:eac0369: 
1:dbed020: 		Stack ...,ref,value* =&gt; [numArgs number of values will be popped]
1:eac0369: 		      ...,return_value [void methods will not push a value]
1:eac0369: 		</PRE>
1:eac0369: 
1:eac0369: 		<BR>
1:eac0369: 		The type of the arguments to the methods must exactly match the declared types
1:eac0369: 		of the parameters to the methods. If a argument is of the incorrect type the
1:eac0369: 		caller must up cast it or down cast it.
1:eac0369: 
1:eac0369: 		@param type type of method invocation
1:eac0369: 		@param declaringClass Class or interface the method is declared in. If it is a non-static
1:eac0369: 			method call then if declaringClass is null, the declared type is taken to be the
1:eac0369: 			type of the reference that will be popped.
1:eac0369: 
1:eac0369: 		@param methodName name of the method
1:eac0369: 		@param returnType class name or primitive type (including "void") of the return type of the method, can not be null.
1:eac0369: 		@param numArgs number of arguments to the method (can be 0).
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public int callMethod(short type, String declaringClass, String methodName,
1:eac0369: 		String returnType, int numArgs);
1:eac0369: 
1:eac0369: 	/**	
1:eac0369: 		Return an object that efficiently (to the implementation) describes a zero-argument method and
1:eac0369: 		can be used with the single argument callMethod(). Descriptions for the parameters to this
1:eac0369: 		method are the same as the five argument callMethod(). This allows the caller to cache frequently
1:eac0369: 		used methods. The returned object is only valid for use by this MethodBuilder.
1:eac0369: 		<BR>
1:eac0369: 		This call does not affect the Stack.
1:eac0369: 	*/
1:eac0369: 	public Object describeMethod(short opcode, String declaringClass, String methodName, String returnType);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Call a method previously described by describeMethod().
1:eac0369: 		<PRE>
1:eac0369: 		static methods
1:eac0369: 
1:dbed020: 		Stack ...,value* =&gt; [numArgs number of values will be popped]
1:eac0369: 		      ...,return_value [void methods will not push a value]
1:eac0369: 
1:eac0369: 		non-static methods
1:eac0369: 
1:dbed020: 		Stack ...,ref,value* =&gt; [numArgs number of values will be popped]
1:eac0369: 		      ...,return_value [void methods will not push a value]
1:eac0369: 		</PRE>
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public int callMethod(Object methodDescriptor);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Call super(). Caller must only add this to a constructor.
1:eac0369: 		<PRE>
1:eac0369: 
1:dbed020: 		Stack ... =&gt;
1:eac0369: 		      ... 
1:eac0369: 		</PRE>
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public void callSuper();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Pop an array refrence off the stack and push an element from that array.
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...,array_ref =&gt;
1:eac0369: 		      ...,value
1:eac0369: 		</PRE>
1:eac0369: 
1:eac0369: 		@param element Offset into the array (zero based)
1:eac0369: 	*/
1:eac0369: 	public void getArrayElement(int element);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Pop an array reference off the stack, store a value in the array at the passed in offset.
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...,array_ref, value =&gt;
1:eac0369: 		      ...
1:eac0369: 		</PRE>
1:eac0369: 
1:eac0369: 		@param element Offset into the array (zero based)
1:eac0369: 	*/
1:eac0369: 	public void setArrayElement(int element);
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Swap the top two values on the stack.
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...,valueA,valueB =&gt;
1:eac0369: 		      ...,valueB,valueA
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void swap();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Duplicate the top value on the stack.
1:eac0369: 		<PRE>
1:dbed020: 		Stack ...,value =&gt;
1:eac0369: 		      ...,value,value
1:eac0369: 		</PRE>
1:eac0369: 	*/
1:eac0369: 	public void dup();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Tell if statement number in this method builder hits limit.  This
1:eac0369: 		method builder keeps a counter of how many statements are added to it.
1:eac0369: 		Caller should call this function every time it tries to add a statement
1:eac0369: 		to this method builder (counter is increased by 1), then the function
1:eac0369: 		returns whether the accumulated statement number hits a limit.
1:eac0369: 		The reason of doing this is that Java compiler has a limit of 64K code
1:eac0369: 		size for each method.  We might hit this limit if an extremely long
1:eac0369: 		insert statement is issued, for example (see beetle 4293).  Counting
1:eac0369: 		statement number is an approximation without too much overhead.
1:eac0369: 	*/
1:eac0369: 	public boolean statementNumHitLimit(int noStatementsAdded);
1:eac0369: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...,field_ref  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 	Stack ...,value  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...,value  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...,value  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...,field_ref,value  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ... =&gt; [unchanged]
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...,value* =&gt; [numArgs number of values will be popped]
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...  =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...,ref =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...,value =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...,ref =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ..., value =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack value =&gt;
1: 		Stack :empty: =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack value =&gt;
1: 		Stack :empty: =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...,ref =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...,boolean_value =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...,value* =&gt; [numArgs number of values will be popped]
1: 		Stack ...,ref,value* =&gt; [numArgs number of values will be popped]
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...,value* =&gt; [numArgs number of values will be popped]
1: 		Stack ...,ref,value* =&gt; [numArgs number of values will be popped]
/////////////////////////////////////////////////////////////////////////
1: 		Stack ... =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...,array_ref =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...,array_ref, value =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...,valueA,valueB =&gt;
/////////////////////////////////////////////////////////////////////////
1: 		Stack ...,value =&gt;
commit:6baf18b
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f542632
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:0393775
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Push the contents of the static field onto the stack.
0:      * <pre>
0:      * Stack ... =>
0:      *       ...,field_value
0:      * </pre>
0:      *
0:      * @param field a static field
1:      */
0:     public void getStaticField(LocalField field);
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Pop the top stack value and store it in the static field.
0:      * <pre>
0:      * Stack ...,value =>
0:      *       ...
0:      * </pre>
0:      *
0:      * @param field a static field
1:      */
0:     public void setStaticField(LocalField field);
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4549ad4
/////////////////////////////////////////////////////////////////////////
1: 		Initiate a conditional sequence.
/////////////////////////////////////////////////////////////////////////
1: 		<BR>
1: 		If the if or else code pops values from the stack that were before the conditional
1: 		value, then they must use the same number of values from the stack.
/////////////////////////////////////////////////////////////////////////
1: 	
1: 		Initiate a conditional sequence.
1: 		the completeConditional() is called. See conditionalIfNull() for example
1: 		and restrictions.
/////////////////////////////////////////////////////////////////////////
1: 		Complete the true code path of a conditional.
1: 		Complete a conditional which completes the false code path.
commit:afa871e
/////////////////////////////////////////////////////////////////////////
1: 	Pop the top stack value and store it in the local field. 
1: 	This call pushes the this instance required to access the field itself.
1: 	This call does not leave any value on the stack.
1: 
1: 	<PRE>
0: 	Stack ...,value  =>
1: 	      ...
1: 	</PRE>
1: 	*/
1: 	public void setField(LocalField field);
1: 
1: 	/**
commit:d6e8491
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Pop the top value off the stack
1: 		<PRE>
0: 		Stack ..., value =>
1: 		      ...
1: 		</PRE>.
1: 	*/
1: 	public void pop();
1: 		
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.services.compiler.MethodBuilder
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.compiler
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.services.compiler;
1: 
1: /**
1: 	MethodBuilder is used to generate the code for a method.
1: 	<P>
1: 
1: 	The code for a method is built in a way that corresponds to the
1: 	layout of the stack machine that is the Java Virtual Machine.
1: 	Values are pushed on the stack, moved about on the stack
1: 	and then popped off the stack by operations such as method
1: 	calls. An understanding of hoe the JVM operates is useful
1: 	before using this class.
1: 
1: 	<P>
1: 	All the method descriptions below are generating bytecode
1: 	to achieved the desired behaviour when the generated class
1: 	is loaded. None of this class's methods calls actually
1: 	invoke methods or create objects described by the callers.
1:  */
1: public interface MethodBuilder {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/**
1: 	 * Declare the method throws an exception.
1: 	   Must be called before any code is added
1: 	   to the method.
1: 	 */
1: 	public void addThrownException(String exceptionClass);
1: 
1: 	/**
1: 	 * return the name of the method.
1: 	 */
1: 	public String getName();
1: 
1: 	/**
1: 		Indicate the method is complete. Once this
1: 		call has been made the caller must discard
1: 		the reference to this object.
1: 	 */
1: 	public void complete();
1: 
1: 	/**
1: 		Push a parameter value.
1: 		<PRE>
0: 		Stack ...  =>
1: 		      ...,param_value
1: 		</PRE>
1: 		@param id position of the parameter (zero based).
1: 	*/
1: 	public void getParameter(int id);
1: 
1: 	/**
1: 		Push a byte constant onto the stack
1: 		<PRE>
0: 		Stack ...  =>
1: 		      ...,byte_value
1: 		</PRE>
1: 	*/
1: 	public void push(byte value);
1: 
1: 	/**
1: 		Push a boolean constant onto the stack
1: 		<PRE>
0: 		Stack ...  =>
1: 		      ...,boolean_value
1: 		</PRE>
1: 	*/
1: 	public void push(boolean value);
1: 
1: 	/**
1: 		Push a short constant onto the stack
1: 		<PRE>
0: 		Stack ...  =>
1: 		      ...,short_value
1: 		</PRE>
1: 	*/
1: 	public void push(short value);
1: 
1: 	/**
1: 		Push a int constant onto the stack
1: 		<PRE>
0: 		Stack ...  =>
1: 		      ...,int_value
1: 		</PRE>
1: 	*/
1: 	public void push(int value);
1: 
1: 	/**
1: 		Push a long constant onto the stack
1: 		<PRE>
0: 		Stack ...  =>
1: 		      ...,long_value
1: 		</PRE>
1: 	*/
1: 	public void push(long value);
1: 
1: 	/**
1: 		Push a float constant onto the stack
1: 		<PRE>
0: 		Stack ...  =>
1: 		      ...,float_value
1: 		</PRE>
1: 	*/
1: 	public void push(float value);
1: 
1: 	/**
1: 		Push a double constant onto the stack
1: 		<PRE>
0: 		Stack ...  =>
1: 		      ...,double_value
1: 		</PRE>
1: 	*/
1: 	public void push(double value);
1: 
1: 	/**
1: 		Push a String constant onto the stack
1: 		<PRE>
0: 		Stack ...  =>
1: 		      ...,String_value
1: 		</PRE>
1: 	*/
1: 	public void push(String value);
1: 
1: 	/**
1: 		Push a typed null onto the stack
1: 		<PRE>
0: 		Stack ...  =>
1: 		      ...,null
1: 		</PRE>
1: 	*/
1: 	public void pushNull(String className);
1: 
1: 	/**
1: 		Push the contents of the local field onto the stack.
1: 		This call pushes the this instance required to access the field itself.
1: 		<PRE>
0: 		Stack ...  =>
1: 		      ...,field_value
1: 		</PRE>
1: 
1: 	*/
1: 	public void getField(LocalField field);
1: 
1: 	/**
1: 		Push the contents of the described field onto the stack.
1: 		This call requires the instance (reference) to be pushed by the caller.
1: 
1: 		<PRE>
0: 		Stack ...,field_ref  =>
1: 		      ...,field_value
1: 		</PRE>
1: 		
1: 	*/
1: 	public void getField(String declaringClass, String fieldName, String fieldType);
1: 
1: 	/**
1: 		Push the contents of the described static field onto the stack.
1: 		<PRE>
0: 		Stack ...  =>
1: 		      ...,field_value
1: 		</PRE>
1: 	*/
1: 	public void getStaticField(String declaringClass, String fieldName, String fieldType);
1: 
1: 	/**
1: 		Pop the top stack value and store it in the local field. 
1: 		This call pushes the this instance required to access the field itself.
1: 		Like the Java language 'field = value', this leaves the value on the stack.
1: 
1: 		<PRE>
0: 		Stack ...,value  =>
1: 		      ...,value
1: 		</PRE>
1: 	*/
1: 	public void putField(LocalField field);
1: 
1: 	/**
1: 		Pop the top stack value and store it in the instance field of this class.
1: 		This call pushes the this instance required to access the field itself.
1: 		Like the Java language 'field = value', this leaves the value on the stack.
1: 
1: 		<PRE>
0: 		Stack ...,value  =>
1: 		      ...,value
1: 		</PRE>
1: 	*/
1: 	public void putField(String fieldName, String fieldType);
1: 
1: 	/**
1: 		Pop the top stack value and store it in the field.
1: 		This call requires the instance to be pushed by the caller.
1: 		Like the Java language 'field = value', this leaves the value on the stack.
1: 
1: 		<PRE>
0: 		Stack ...,field_ref,value  =>
1: 		      ...,value
1: 		</PRE>
1: 	*/
1: 	public void putField(String declaringClass, String fieldName, String fieldType);
1: 
1: 	/**
1: 		Initiate a sequence that calls a constructor, equivalent to the new operator in Java.
1: 		After this call, the caller must push any arguments and then complete the
1: 		construction with a call to pushNewComplete(). Only arguments to the constructor
1: 		can be pushed onto the stack between the pushNewStart() and pushNewComplete() method
1: 		calls.
1: 
1: 		<PRE>
0: 		Stack ... => [unchanged]
1: 		      ...
1: 		</PRE>
1: 
1: 		@param className class name of object to be created.
1: 	*/
1: 	public void pushNewStart(String className);
1: 
1: 
1: 	/**
1: 		Complete the sequence that was started with pushNewStart().
1: 		Pop the arguments to the constructor and push the reference
1: 		to the newly created object.
1: 
1: 		<PRE>
0: 		Stack ...,value* => [numArgs number of values will be popped]
1: 		      ...,new_ref
1: 		</PRE>
1: 
1: 		@param numArgs number of arguments to the constructor (can be 0).
1: 	*/
1: 	public void pushNewComplete(int numArgs);
1: 
1: 	/**
1: 		Create an instance of an array and push it onto the stack. 
1: 
1: 		<PRE>
0: 		Stack ...  =>
1: 		      ...,array_ref
1: 		</PRE>
1: 
1: 		@param className - type of array.
1: 		@param size - number of elements in the array
1: 	*/
1: 	public void pushNewArray(String className, int size);
1: 
1: 
1: 	/**
1: 		Push this onto the stack.
1: 		<PRE>
0: 		Stack ...  =>
1: 		      ...,this_ref
1: 		</PRE>
1: 	*/
1: 	public void pushThis();
1: 
1: 	/**
1: 		Upcast the top stack value. This is used for correct method resolution
1: 		by upcasting method parameters. It does not put any casting code into the
1: 		byte code stream. Can only be used for refrences.
1: 		<PRE>
0: 		Stack ...,ref =>
1: 		      ...,ref
1: 		</PRE>
1: 	*/
1: 	public void upCast(String className);
1: 
1: 	/**
1: 		Cast the top stack value. Correctly down-casts a reference or casts
1: 		a primitive type (e.g. int to short).
1: 		<PRE>
0: 		Stack ...,value =>
1: 		      ...,cast_value
1: 		</PRE>
1: 
1: 		@param className type (primitive, interface or class) to cast to.
1: 	*/
1: 	public void cast(String className);
1: 
1: 	/**
1: 		Pop the top stack value and push a boolean that is the result of
1: 		an instanceof check on the popped reference.
1: 		<PRE>
0: 		Stack ...,ref =>
1: 		      ...,boolean_value
1: 		</PRE>.
1: 	*/
1: 	public void isInstanceOf(String className);
1: 
1: 	/**
1: 		End a statement.
1: 		Pops the top-word of the stack, if any.
1: 		Must only be called if zero or one item exists
1: 		on the stack.
1: 		<PRE>
0: 		Stack value =>
1: 		      :empty:
1: 		or
1: 
0: 		Stack :empty: =>
1: 		      :empty:
1: 
1: 		</PRE>.
1: 	*/
1: 	public void endStatement();
1: 
1: 	/**
1: 		Return from a method, optionally with a value.
1: 		Must only be called if zero or one item exists
1: 		on the stack. If the stack contains a single
1: 		value then that is popped and used as the returned value.
1: 		<PRE>
0: 		Stack value =>
1: 		      :empty:
1: 		or
1: 
0: 		Stack :empty: =>
1: 		      :empty:
1: 
1: 		</PRE>.
1: 	*/
1: 	public void methodReturn();
1: 
1: 	/**
0: 		Initiate a sequence that corresponds to the Java language 'ref == null ? ... : ...'.
1: 		The top value on the stack (a reference) is popped and compared to 'null'.
1: 		If the value is null then the code following this call until the startElseCode()
1: 		will be executed at runtime, otherwise the code following startElseCode() until
1: 		the completeConditional() is called.
1: 		<BR>
1: 		E.g. 
1: 
1: 		<PRE>
1: 		mb.callMethod(...); // pushes an object onto the stack
1: 		mb.conditionalIfNull();
1: 		  mb.push(3);
1: 		mb.startElseCode();
1: 		  mb.push(5);
1: 		mb.completeConditional();
1: 		// at this point 3 or 5 will be on the stack
1: 		</PRE>
1: 
1: 		Each path through the ?: statement must leave the stack at the same depth
1: 		as the other.
1: 
1: 		<PRE>
0: 		Stack ...,ref =>
1: 		      ...
1: 		</PRE>.
1: 
1: 	*/
1: 
1: 	public void conditionalIfNull();
1: 	/**
0: 		Initiate a sequence that corresponds to the Java language ' value ? ... : ...'.
1: 		The top value on the stack must be a boolean and will be popped. If it
1: 		is true then the code following this call until the startElseCode()
1: 		will be executed at runtime, otherwise the code following startElseCode() until
0: 		the completeConditional() is called. See conditionalIfNull() for example.
1: 
1: 		<PRE>
0: 		Stack ...,boolean_value =>
1: 		      ...
1: 		</PRE>.
1: 	*/
1: 	public void conditionalIf();
1: 
1: 	/**
0: 		Complete the true code path of a ?: operator.
1: 	*/
1: 	public void startElseCode();
1: 
1: 	/**
0: 		Complete the a ?: operator which completes the false code path.
1: 	*/
1: 	public void completeConditional();
1: 
1: 	/**
1: 		Call a method. The instance (receiver or reference) for non-static methods
1: 		must be pushed by the caller. The instance (for non-static) and the arguments
1: 		are popped of the stack, and the return value (if any) is pushed onto the stack.
1: 		<BR>
1: 		The type needs to be one of:
1: 		<UL>
1: 		<LI> VMOpcode.INVOKESTATIC - call a static method
1: 		<LI> VMOpcode.INVOKEVIRTUAL - call method declared in the class or super-class.
1: 		<LI> VMOpcode.INVOKEINTERFACE - call a method declared in an interface
1: 		</UL>
1: 
1: 
1: 		<PRE>
1: 		static methods
1: 
0: 		Stack ...,value* => [numArgs number of values will be popped]
1: 		      ...,return_value [void methods will not push a value]
1: 
1: 		non-static methods
1: 
0: 		Stack ...,ref,value* => [numArgs number of values will be popped]
1: 		      ...,return_value [void methods will not push a value]
1: 		</PRE>
1: 
1: 		<BR>
1: 		The type of the arguments to the methods must exactly match the declared types
1: 		of the parameters to the methods. If a argument is of the incorrect type the
1: 		caller must up cast it or down cast it.
1: 
1: 		@param type type of method invocation
1: 		@param declaringClass Class or interface the method is declared in. If it is a non-static
1: 			method call then if declaringClass is null, the declared type is taken to be the
1: 			type of the reference that will be popped.
1: 
1: 		@param methodName name of the method
1: 		@param returnType class name or primitive type (including "void") of the return type of the method, can not be null.
1: 		@param numArgs number of arguments to the method (can be 0).
1: 
1: 	*/
1: 	public int callMethod(short type, String declaringClass, String methodName,
1: 		String returnType, int numArgs);
1: 
1: 	/**	
1: 		Return an object that efficiently (to the implementation) describes a zero-argument method and
1: 		can be used with the single argument callMethod(). Descriptions for the parameters to this
1: 		method are the same as the five argument callMethod(). This allows the caller to cache frequently
1: 		used methods. The returned object is only valid for use by this MethodBuilder.
1: 		<BR>
1: 		This call does not affect the Stack.
1: 	*/
1: 	public Object describeMethod(short opcode, String declaringClass, String methodName, String returnType);
1: 
1: 	/**
1: 		Call a method previously described by describeMethod().
1: 		<PRE>
1: 		static methods
1: 
0: 		Stack ...,value* => [numArgs number of values will be popped]
1: 		      ...,return_value [void methods will not push a value]
1: 
1: 		non-static methods
1: 
0: 		Stack ...,ref,value* => [numArgs number of values will be popped]
1: 		      ...,return_value [void methods will not push a value]
1: 		</PRE>
1: 
1: 	*/
1: 	public int callMethod(Object methodDescriptor);
1: 
1: 	/**
1: 		Call super(). Caller must only add this to a constructor.
1: 		<PRE>
1: 
0: 		Stack ... =>
1: 		      ... 
1: 		</PRE>
1: 
1: 	*/
1: 	public void callSuper();
1: 
1: 	/**
1: 		Pop an array refrence off the stack and push an element from that array.
1: 		<PRE>
0: 		Stack ...,array_ref =>
1: 		      ...,value
1: 		</PRE>
1: 
1: 		@param element Offset into the array (zero based)
1: 	*/
1: 	public void getArrayElement(int element);
1: 
1: 	/**
1: 		Pop an array reference off the stack, store a value in the array at the passed in offset.
1: 		<PRE>
0: 		Stack ...,array_ref, value =>
1: 		      ...
1: 		</PRE>
1: 
1: 		@param element Offset into the array (zero based)
1: 	*/
1: 	public void setArrayElement(int element);
1: 
1: 
1: 	/**
1: 		Swap the top two values on the stack.
1: 		<PRE>
0: 		Stack ...,valueA,valueB =>
1: 		      ...,valueB,valueA
1: 		</PRE>
1: 	*/
1: 	public void swap();
1: 
1: 	/**
1: 		Duplicate the top value on the stack.
1: 		<PRE>
0: 		Stack ...,value =>
1: 		      ...,value,value
1: 		</PRE>
1: 	*/
1: 	public void dup();
1: 
1: 	/**
1: 		Tell if statement number in this method builder hits limit.  This
1: 		method builder keeps a counter of how many statements are added to it.
1: 		Caller should call this function every time it tries to add a statement
1: 		to this method builder (counter is increased by 1), then the function
1: 		returns whether the accumulated statement number hits a limit.
1: 		The reason of doing this is that Java compiler has a limit of 64K code
1: 		size for each method.  We might hit this limit if an extremely long
1: 		insert statement is issued, for example (see beetle 4293).  Counting
1: 		statement number is an approximation without too much overhead.
1: 	*/
1: 	public boolean statementNumHitLimit(int noStatementsAdded);
1: }
1: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.compiler
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.services.compiler;
0: 
0: /**
0: 	MethodBuilder is used to generate the code for a method.
0: 	<P>
0: 
0: 	The code for a method is built in a way that corresponds to the
0: 	layout of the stack machine that is the Java Virtual Machine.
0: 	Values are pushed on the stack, moved about on the stack
0: 	and then popped off the stack by operations such as method
0: 	calls. An understanding of hoe the JVM operates is useful
0: 	before using this class.
0: 
0: 	<P>
0: 	All the method descriptions below are generating bytecode
0: 	to achieved the desired behaviour when the generated class
0: 	is loaded. None of this class's methods calls actually
0: 	invoke methods or create objects described by the callers.
0:  */
0: public interface MethodBuilder {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/**
0: 	 * Declare the method throws an exception.
0: 	   Must be called before any code is added
0: 	   to the method.
0: 	 */
0: 	public void addThrownException(String exceptionClass);
0: 
0: 	/**
0: 	 * return the name of the method.
0: 	 */
0: 	public String getName();
0: 
0: 	/**
0: 		Indicate the method is complete. Once this
0: 		call has been made the caller must discard
0: 		the reference to this object.
0: 	 */
0: 	public void complete();
0: 
0: 	/**
0: 		Push a parameter value.
0: 		<PRE>
0: 		Stack ...  =>
0: 		      ...,param_value
0: 		</PRE>
0: 		@param id position of the parameter (zero based).
0: 	*/
0: 	public void getParameter(int id);
0: 
0: 	/**
0: 		Push a byte constant onto the stack
0: 		<PRE>
0: 		Stack ...  =>
0: 		      ...,byte_value
0: 		</PRE>
0: 	*/
0: 	public void push(byte value);
0: 
0: 	/**
0: 		Push a boolean constant onto the stack
0: 		<PRE>
0: 		Stack ...  =>
0: 		      ...,boolean_value
0: 		</PRE>
0: 	*/
0: 	public void push(boolean value);
0: 
0: 	/**
0: 		Push a short constant onto the stack
0: 		<PRE>
0: 		Stack ...  =>
0: 		      ...,short_value
0: 		</PRE>
0: 	*/
0: 	public void push(short value);
0: 
0: 	/**
0: 		Push a int constant onto the stack
0: 		<PRE>
0: 		Stack ...  =>
0: 		      ...,int_value
0: 		</PRE>
0: 	*/
0: 	public void push(int value);
0: 
0: 	/**
0: 		Push a long constant onto the stack
0: 		<PRE>
0: 		Stack ...  =>
0: 		      ...,long_value
0: 		</PRE>
0: 	*/
0: 	public void push(long value);
0: 
0: 	/**
0: 		Push a float constant onto the stack
0: 		<PRE>
0: 		Stack ...  =>
0: 		      ...,float_value
0: 		</PRE>
0: 	*/
0: 	public void push(float value);
0: 
0: 	/**
0: 		Push a double constant onto the stack
0: 		<PRE>
0: 		Stack ...  =>
0: 		      ...,double_value
0: 		</PRE>
0: 	*/
0: 	public void push(double value);
0: 
0: 	/**
0: 		Push a String constant onto the stack
0: 		<PRE>
0: 		Stack ...  =>
0: 		      ...,String_value
0: 		</PRE>
0: 	*/
0: 	public void push(String value);
0: 
0: 	/**
0: 		Push a typed null onto the stack
0: 		<PRE>
0: 		Stack ...  =>
0: 		      ...,null
0: 		</PRE>
0: 	*/
0: 	public void pushNull(String className);
0: 
0: 	/**
0: 		Push the contents of the local field onto the stack.
0: 		This call pushes the this instance required to access the field itself.
0: 		<PRE>
0: 		Stack ...  =>
0: 		      ...,field_value
0: 		</PRE>
0: 
0: 	*/
0: 	public void getField(LocalField field);
0: 
0: 	/**
0: 		Push the contents of the described field onto the stack.
0: 		This call requires the instance (reference) to be pushed by the caller.
0: 
0: 		<PRE>
0: 		Stack ...,field_ref  =>
0: 		      ...,field_value
0: 		</PRE>
0: 		
0: 	*/
0: 	public void getField(String declaringClass, String fieldName, String fieldType);
0: 
0: 	/**
0: 		Push the contents of the described static field onto the stack.
0: 		<PRE>
0: 		Stack ...  =>
0: 		      ...,field_value
0: 		</PRE>
0: 	*/
0: 	public void getStaticField(String declaringClass, String fieldName, String fieldType);
0: 
0: 	/**
0: 		Pop the top stack value and store it in the local field. 
0: 		This call pushes the this instance required to access the field itself.
0: 		Like the Java language 'field = value', this leaves the value on the stack.
0: 
0: 		<PRE>
0: 		Stack ...,value  =>
0: 		      ...,value
0: 		</PRE>
0: 	*/
0: 	public void putField(LocalField field);
0: 
0: 	/**
0: 		Pop the top stack value and store it in the instance field of this class.
0: 		This call pushes the this instance required to access the field itself.
0: 		Like the Java language 'field = value', this leaves the value on the stack.
0: 
0: 		<PRE>
0: 		Stack ...,value  =>
0: 		      ...,value
0: 		</PRE>
0: 	*/
0: 	public void putField(String fieldName, String fieldType);
0: 
0: 	/**
0: 		Pop the top stack value and store it in the field.
0: 		This call requires the instance to be pushed by the caller.
0: 		Like the Java language 'field = value', this leaves the value on the stack.
0: 
0: 		<PRE>
0: 		Stack ...,field_ref,value  =>
0: 		      ...,value
0: 		</PRE>
0: 	*/
0: 	public void putField(String declaringClass, String fieldName, String fieldType);
0: 
0: 	/**
0: 		Initiate a sequence that calls a constructor, equivalent to the new operator in Java.
0: 		After this call, the caller must push any arguments and then complete the
0: 		construction with a call to pushNewComplete(). Only arguments to the constructor
0: 		can be pushed onto the stack between the pushNewStart() and pushNewComplete() method
0: 		calls.
0: 
0: 		<PRE>
0: 		Stack ... => [unchanged]
0: 		      ...
0: 		</PRE>
0: 
0: 		@param className class name of object to be created.
0: 	*/
0: 	public void pushNewStart(String className);
0: 
0: 
0: 	/**
0: 		Complete the sequence that was started with pushNewStart().
0: 		Pop the arguments to the constructor and push the reference
0: 		to the newly created object.
0: 
0: 		<PRE>
0: 		Stack ...,value* => [numArgs number of values will be popped]
0: 		      ...,new_ref
0: 		</PRE>
0: 
0: 		@param numArgs number of arguments to the constructor (can be 0).
0: 	*/
0: 	public void pushNewComplete(int numArgs);
0: 
0: 	/**
0: 		Create an instance of an array and push it onto the stack. 
0: 
0: 		<PRE>
0: 		Stack ...  =>
0: 		      ...,array_ref
0: 		</PRE>
0: 
0: 		@param className - type of array.
0: 		@param size - number of elements in the array
0: 	*/
0: 	public void pushNewArray(String className, int size);
0: 
0: 
0: 	/**
0: 		Push this onto the stack.
0: 		<PRE>
0: 		Stack ...  =>
0: 		      ...,this_ref
0: 		</PRE>
0: 	*/
0: 	public void pushThis();
0: 
0: 	/**
0: 		Upcast the top stack value. This is used for correct method resolution
0: 		by upcasting method parameters. It does not put any casting code into the
0: 		byte code stream. Can only be used for refrences.
0: 		<PRE>
0: 		Stack ...,ref =>
0: 		      ...,ref
0: 		</PRE>
0: 	*/
0: 	public void upCast(String className);
0: 
0: 	/**
0: 		Cast the top stack value. Correctly down-casts a reference or casts
0: 		a primitive type (e.g. int to short).
0: 		<PRE>
0: 		Stack ...,value =>
0: 		      ...,cast_value
0: 		</PRE>
0: 
0: 		@param className type (primitive, interface or class) to cast to.
0: 	*/
0: 	public void cast(String className);
0: 
0: 	/**
0: 		Pop the top stack value and push a boolean that is the result of
0: 		an instanceof check on the popped reference.
0: 		<PRE>
0: 		Stack ...,ref =>
0: 		      ...,boolean_value
0: 		</PRE>.
0: 	*/
0: 	public void isInstanceOf(String className);
0: 
0: 	/**
0: 		End a statement.
0: 		Pops the top-word of the stack, if any.
0: 		Must only be called if zero or one item exists
0: 		on the stack.
0: 		<PRE>
0: 		Stack value =>
0: 		      :empty:
0: 		or
0: 
0: 		Stack :empty: =>
0: 		      :empty:
0: 
0: 		</PRE>.
0: 	*/
0: 	public void endStatement();
0: 
0: 	/**
0: 		Return from a method, optionally with a value.
0: 		Must only be called if zero or one item exists
0: 		on the stack. If the stack contains a single
0: 		value then that is popped and used as the returned value.
0: 		<PRE>
0: 		Stack value =>
0: 		      :empty:
0: 		or
0: 
0: 		Stack :empty: =>
0: 		      :empty:
0: 
0: 		</PRE>.
0: 	*/
0: 	public void methodReturn();
0: 
0: 	/**
0: 		Initiate a sequence that corresponds to the Java language 'ref == null ? ... : ...'.
0: 		The top value on the stack (a reference) is popped and compared to 'null'.
0: 		If the value is null then the code following this call until the startElseCode()
0: 		will be executed at runtime, otherwise the code following startElseCode() until
0: 		the completeConditional() is called.
0: 		<BR>
0: 		E.g. 
0: 
0: 		<PRE>
0: 		mb.callMethod(...); // pushes an object onto the stack
0: 		mb.conditionalIfNull();
0: 		  mb.push(3);
0: 		mb.startElseCode();
0: 		  mb.push(5);
0: 		mb.completeConditional();
0: 		// at this point 3 or 5 will be on the stack
0: 		</PRE>
0: 
0: 		Each path through the ?: statement must leave the stack at the same depth
0: 		as the other.
0: 
0: 		<PRE>
0: 		Stack ...,ref =>
0: 		      ...
0: 		</PRE>.
0: 
0: 	*/
0: 
0: 	public void conditionalIfNull();
0: 	/**
0: 		Initiate a sequence that corresponds to the Java language ' value ? ... : ...'.
0: 		The top value on the stack must be a boolean and will be popped. If it
0: 		is true then the code following this call until the startElseCode()
0: 		will be executed at runtime, otherwise the code following startElseCode() until
0: 		the completeConditional() is called. See conditionalIfNull() for example.
0: 
0: 		<PRE>
0: 		Stack ...,boolean_value =>
0: 		      ...
0: 		</PRE>.
0: 	*/
0: 	public void conditionalIf();
0: 
0: 	/**
0: 		Complete the true code path of a ?: operator.
0: 	*/
0: 	public void startElseCode();
0: 
0: 	/**
0: 		Complete the a ?: operator which completes the false code path.
0: 	*/
0: 	public void completeConditional();
0: 
0: 	/**
0: 		Call a method. The instance (receiver or reference) for non-static methods
0: 		must be pushed by the caller. The instance (for non-static) and the arguments
0: 		are popped of the stack, and the return value (if any) is pushed onto the stack.
0: 		<BR>
0: 		The type needs to be one of:
0: 		<UL>
0: 		<LI> VMOpcode.INVOKESTATIC - call a static method
0: 		<LI> VMOpcode.INVOKEVIRTUAL - call method declared in the class or super-class.
0: 		<LI> VMOpcode.INVOKEINTERFACE - call a method declared in an interface
0: 		</UL>
0: 
0: 
0: 		<PRE>
0: 		static methods
0: 
0: 		Stack ...,value* => [numArgs number of values will be popped]
0: 		      ...,return_value [void methods will not push a value]
0: 
0: 		non-static methods
0: 
0: 		Stack ...,ref,value* => [numArgs number of values will be popped]
0: 		      ...,return_value [void methods will not push a value]
0: 		</PRE>
0: 
0: 		<BR>
0: 		The type of the arguments to the methods must exactly match the declared types
0: 		of the parameters to the methods. If a argument is of the incorrect type the
0: 		caller must up cast it or down cast it.
0: 
0: 		@param type type of method invocation
0: 		@param declaringClass Class or interface the method is declared in. If it is a non-static
0: 			method call then if declaringClass is null, the declared type is taken to be the
0: 			type of the reference that will be popped.
0: 
0: 		@param methodName name of the method
0: 		@param returnType class name or primitive type (including "void") of the return type of the method, can not be null.
0: 		@param numArgs number of arguments to the method (can be 0).
0: 
0: 	*/
0: 	public int callMethod(short type, String declaringClass, String methodName,
0: 		String returnType, int numArgs);
0: 
0: 	/**	
0: 		Return an object that efficiently (to the implementation) describes a zero-argument method and
0: 		can be used with the single argument callMethod(). Descriptions for the parameters to this
0: 		method are the same as the five argument callMethod(). This allows the caller to cache frequently
0: 		used methods. The returned object is only valid for use by this MethodBuilder.
0: 		<BR>
0: 		This call does not affect the Stack.
0: 	*/
0: 	public Object describeMethod(short opcode, String declaringClass, String methodName, String returnType);
0: 
0: 	/**
0: 		Call a method previously described by describeMethod().
0: 		<PRE>
0: 		static methods
0: 
0: 		Stack ...,value* => [numArgs number of values will be popped]
0: 		      ...,return_value [void methods will not push a value]
0: 
0: 		non-static methods
0: 
0: 		Stack ...,ref,value* => [numArgs number of values will be popped]
0: 		      ...,return_value [void methods will not push a value]
0: 		</PRE>
0: 
0: 	*/
0: 	public int callMethod(Object methodDescriptor);
0: 
0: 	/**
0: 		Call super(). Caller must only add this to a constructor.
0: 		<PRE>
0: 
0: 		Stack ... =>
0: 		      ... 
0: 		</PRE>
0: 
0: 	*/
0: 	public void callSuper();
0: 
0: 	/**
0: 		Pop an array refrence off the stack and push an element from that array.
0: 		<PRE>
0: 		Stack ...,array_ref =>
0: 		      ...,value
0: 		</PRE>
0: 
0: 		@param element Offset into the array (zero based)
0: 	*/
0: 	public void getArrayElement(int element);
0: 
0: 	/**
0: 		Pop an array reference off the stack, store a value in the array at the passed in offset.
0: 		<PRE>
0: 		Stack ...,array_ref, value =>
0: 		      ...
0: 		</PRE>
0: 
0: 		@param element Offset into the array (zero based)
0: 	*/
0: 	public void setArrayElement(int element);
0: 
0: 
0: 	/**
0: 		Swap the top two values on the stack.
0: 		<PRE>
0: 		Stack ...,valueA,valueB =>
0: 		      ...,valueB,valueA
0: 		</PRE>
0: 	*/
0: 	public void swap();
0: 
0: 	/**
0: 		Duplicate the top value on the stack.
0: 		<PRE>
0: 		Stack ...,value =>
0: 		      ...,value,value
0: 		</PRE>
0: 	*/
0: 	public void dup();
0: 
0: 	/**
0: 		Tell if statement number in this method builder hits limit.  This
0: 		method builder keeps a counter of how many statements are added to it.
0: 		Caller should call this function every time it tries to add a statement
0: 		to this method builder (counter is increased by 1), then the function
0: 		returns whether the accumulated statement number hits a limit.
0: 		The reason of doing this is that Java compiler has a limit of 64K code
0: 		size for each method.  We might hit this limit if an extremely long
0: 		insert statement is issued, for example (see beetle 4293).  Counting
0: 		statement number is an approximation without too much overhead.
0: 	*/
0: 	public boolean statementNumHitLimit(int noStatementsAdded);
0: }
0: 
============================================================================