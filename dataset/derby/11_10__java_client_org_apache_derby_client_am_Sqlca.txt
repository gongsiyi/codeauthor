1:33776ff: /*
48:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.am.Sqlca
1:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:96889c1: */
1:d57ff17: 
1:33776ff: package org.apache.derby.client.am;
1:b850119: 
1:b850119: import java.sql.DataTruncation;
1:69e3d06: import java.sql.Types;
1:69e3d06: import java.util.Locale;
1:5d50d40: import org.apache.derby.client.net.Typdef;
1:b54db0f: import org.apache.derby.shared.common.error.ExceptionSeverity;
1:b54db0f: import org.apache.derby.shared.common.reference.SQLState;
1:d57ff17: import org.apache.derby.shared.common.error.MessageUtils;
1:7680ab7: 
1:70f7692: public abstract class Sqlca {
1:f26c60c: 
1:f26c60c:     // Indexes into sqlErrd_
1:0326967:     private  static  final   int HIGH_ORDER_ROW_COUNT = 0;
1:0326967:     private  static  final   int LOW_ORDER_ROW_COUNT = 1;
1:0326967:     private  static  final   int LOW_ORDER_UPDATE_COUNT = 2;
1:0326967:     private  static  final   int HIGH_ORDER_UPDATE_COUNT = 3;
1:f26c60c:     public  static  final   int SQL_ERR_LENGTH = 6;
1:0326967:     transient private ClientConnection connection_;
1:694fc08:     SqlException exceptionThrownOnStoredProcInvocation_;
1:70f7692:     boolean messageTextRetrievedContainsTokensOnly_ = true;
1:33776ff: 
1:70f7692:     // data corresponding to SQLCA fields
1:70f7692:     protected int sqlCode_;        // SQLCODE
1:96889c1:     /** A string representation of <code>sqlErrmcBytes_</code>. */
1:96889c1:     private String sqlErrmc_;
1:96889c1:     /** Array of errmc strings for each message in the chain. */
1:95049cf:     private String[] sqlErrmcMessages_;
1:96889c1:     /** SQL states for all the messages in the exception chain. */
1:96889c1:     private String[] sqlStates_;
1:70f7692:     // contain an error token
1:95049cf:     private String sqlErrp_;        // function name issuing error
1:70f7692:     protected int[] sqlErrd_;        // 6 diagnostic Information
1:95049cf:     private String sqlWarn_;        // 11 warning Flags
1:70f7692:     protected String sqlState_;       // SQLSTATE
1:33776ff: 
1:70f7692:     // raw sqlca data fields before unicode conversion
1:70f7692:     protected byte[] sqlErrmcBytes_;
1:70f7692:     protected byte[] sqlErrpBytes_;
1:70f7692:     protected byte[] sqlWarnBytes_;
1:99683a9:     
1:95049cf:     private boolean containsSqlcax_ = true;
1:95049cf:     private long rowsetRowCount_;
1:33776ff: 
1:70f7692:     // JDK stack trace calls e.getMessage(), so we must set some state on the sqlca that says return tokens only.
1:70f7692:     private boolean returnTokensOnlyInMessageText_ = false;
1:33776ff: 
1:70f7692:     transient private final Agent agent_;
1:33776ff: 
1:96889c1:     /** Cached error messages (to prevent multiple invocations of the stored
1:96889c1:      * procedure to get the same message). */
1:96889c1:     private String[] cachedMessages;
1:33776ff: 
1:69e3d06:     protected Sqlca(ClientConnection connection) {
1:70f7692:         connection_ = connection;
1:70f7692:         agent_ = connection_ != null ? connection_.agent_ : null;
5:70f7692:     }
1:b850119: 
1:70f7692:     void returnTokensOnlyInMessageText(boolean returnTokensOnlyInMessageText) {
1:70f7692:         returnTokensOnlyInMessageText_ = returnTokensOnlyInMessageText;
1:70f7692:     }
1:33776ff: 
1:b850119:     /**
1:96889c1:      * Returns the number of messages this SQLCA contains.
1:96889c1:      *
1:96889c1:      * @return number of messages
1:96889c1:      */
1:96889c1:     synchronized int numberOfMessages() {
1:96889c1:         initSqlErrmcMessages();
1:96889c1:         if (sqlErrmcMessages_ != null) {
1:96889c1:             return sqlErrmcMessages_.length;
1:96889c1:         }
1:96889c1:         // even if we don't have an array of errmc messages, we are able to get
1:96889c1:         // one message out of this sqlca (although it's not very readable)
1:96889c1:         return 1;
1:96889c1:     }
1:96889c1: 
1:70f7692:     synchronized public int getSqlCode() {
1:70f7692:         return sqlCode_;
1:70f7692:     }
1:70f7692: 
1:b54db0f:     /**
1:b54db0f:      * <p>
1:b54db0f:      * Get the error code based on the SQL code received from the server.
1:b54db0f:      * </p>
1:b54db0f:      *
1:b54db0f:      * <p>
1:b54db0f:      * The conversion from SQL code to error code happens like this:
1:b54db0f:      * </p>
1:b54db0f:      *
1:b54db0f:      * <ul>
1:b54db0f:      * <li>If the SQL code is 0, there is no error code because the Sqlca
1:b54db0f:      * doesn't represent an error. Return 0.</li>
1:b54db0f:      * <li>If the SQL code is positive, the Sqlca represents a warning, and
1:b54db0f:      * the SQL code represents the actual error code. Return the SQL code.</li>
1:b54db0f:      * <li>If the SQL code is negative, the Sqlca represents an error, and
1:b54db0f:      * the error code is {@code -(sqlCode+1)}.</li>
1:b54db0f:      * </ul>
1:b54db0f:      *
1:b54db0f:      * @see org.apache.derby.impl.drda.DRDAConnThread#getSqlCode(java.sql.SQLException)
1:b54db0f:      */
1:b54db0f:     public synchronized int getErrorCode() {
1:b54db0f:         // Warning or other non-error, return SQL code.
1:b54db0f:         if (sqlCode_ >= 0) return sqlCode_;
1:b54db0f: 
1:b54db0f:         // Negative SQL code means it is an error. Transform into a positive
1:b54db0f:         // error code.
1:b54db0f:         int errorCode = -(sqlCode_ + 1);
1:b54db0f: 
1:b54db0f:         // In auto-commit mode, the embedded driver promotes statement
1:b54db0f:         // severity to transaction severity. Do the same here to match.
1:b54db0f:         if (errorCode == ExceptionSeverity.STATEMENT_SEVERITY &&
1:b54db0f:                 connection_ != null && connection_.autoCommit_) {
1:b54db0f:             errorCode = ExceptionSeverity.TRANSACTION_SEVERITY;
1:b54db0f:         }
1:b54db0f: 
1:b54db0f:         return errorCode;
1:b54db0f:     }
1:b54db0f: 
1:70f7692:     synchronized public String getSqlErrmc() {
1:70f7692:         if (sqlErrmc_ != null) {
1:70f7692:             return sqlErrmc_;
1:70f7692:         }
1:70f7692: 
1:96889c1:         // sqlErrmc string is dependent on sqlErrmcMessages_ array having
1:96889c1:         // been built
1:96889c1:         initSqlErrmcMessages();
1:70f7692: 
1:96889c1:         // sqlErrmc will be built only if sqlErrmcMessages_ has been built.
1:70f7692:         // Otherwise, a null string will be returned.
1:96889c1:         if (sqlErrmcMessages_ == null) {
6:70f7692:             return null;
1:70f7692:         }
1:70f7692: 
1:70f7692:         // create 0-length String if no tokens
1:96889c1:         if (sqlErrmcMessages_.length == 0) {
1:70f7692:             sqlErrmc_ = "";
1:70f7692:             return sqlErrmc_;
1:70f7692:         }
1:70f7692: 
1:70f7692:         // concatenate tokens with sqlErrmcDelimiter delimiters into one String
1:70f7692:         StringBuffer buffer = new StringBuffer();
1:70f7692:         int indx;
1:96889c1:         for (indx = 0; indx < sqlErrmcMessages_.length - 1; indx++) {
1:96889c1:             buffer.append(sqlErrmcMessages_[indx]);
1:e47763a:             buffer.append(MessageUtils.SQLERRMC_MESSAGE_DELIMITER);
1:96889c1:             // all but the first message should be preceded by the SQL state
1:96889c1:             // and a colon (see DRDAConnThread.buildTokenizedSqlerrmc() on the
1:96889c1:             // server)
1:96889c1:             buffer.append(sqlStates_[indx+1]);
1:96889c1:             buffer.append(":");
1:70f7692:         }
1:70f7692:         // add the last token
1:96889c1:         buffer.append(sqlErrmcMessages_[indx]);
1:70f7692: 
1:70f7692:         // save as a string
1:70f7692:         sqlErrmc_ = buffer.toString();
1:70f7692:         return sqlErrmc_;
1:70f7692:     }
1:33776ff: 
1:96889c1:     /**
1:96889c1:      * Initialize and build the arrays <code>sqlErrmcMessages_</code> and
1:96889c1:      * <code>sqlStates_</code>.
1:96889c1:      */
1:96889c1:     private void initSqlErrmcMessages() {
1:96889c1:         if (sqlErrmcMessages_ == null || sqlStates_ == null) {
1:96889c1:             // processSqlErrmcTokens handles null sqlErrmcBytes_ case
1:96889c1:             processSqlErrmcTokens(sqlErrmcBytes_);
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:70f7692:     synchronized public String getSqlErrp() {
1:70f7692:         if (sqlErrp_ != null) {
2:70f7692:             return sqlErrp_;
1:70f7692:         }
1:33776ff: 
1:70f7692:         if (sqlErrpBytes_ == null) {
1:70f7692:             return null;
1:70f7692:         }
1:70f7692: 
1:a0b8943:         sqlErrp_ = bytes2String(sqlErrpBytes_, 0, sqlErrpBytes_.length);
1:a0b8943:         return sqlErrp_;
1:70f7692:     }
1:33776ff: 
1:95049cf:     private int[] getSqlErrd() {
1:70f7692:         if (sqlErrd_ != null) {
1:70f7692:             return sqlErrd_;
1:95049cf:         }
1:70f7692: 
1:f26c60c:         sqlErrd_ = new int[ SQL_ERR_LENGTH ]; // create an int array.
1:70f7692:         return sqlErrd_;
1:70f7692:     }
1:70f7692: 
1:b565f41:     String formatSqlErrd() {
1:95049cf:         return Utils.getStringFromInts(getSqlErrd());
1:95049cf:     }
1:95049cf: 
1:95049cf:     private final static String elevenBlanks = "           ";
1:95049cf: 
1:95049cf:     synchronized public String getSqlWarn() {
1:95049cf:         if (sqlWarn_ == null) {
1:95049cf:             if (sqlWarnBytes_ != null) {
1:a0b8943:                 sqlWarn_ = bytes2String(sqlWarnBytes_, 0, sqlWarnBytes_.length);
1:70f7692:             } else {
2:95049cf:                 sqlWarn_ = elevenBlanks;
1:95049cf:             }
1:70f7692:         }
1:95049cf:         return sqlWarn_;
1:70f7692:     }
1:70f7692: 
1:70f7692:     synchronized public String getSqlState() {
1:99683a9:         return sqlState_;
1:70f7692:     }
1:70f7692: 
1:96889c1:     /**
1:96889c1:      * Get the SQL state for a given error.
1:96889c1:      *
1:96889c1:      * @param messageNumber the error to retrieve SQL state for
1:96889c1:      * @return SQL state for the error
1:96889c1:      */
1:96889c1:     synchronized String getSqlState(int messageNumber) {
1:96889c1:         initSqlErrmcMessages();
1:96889c1:         if (sqlStates_ != null) {
1:96889c1:             return sqlStates_[messageNumber];
1:96889c1:         }
1:96889c1:         return getSqlState();
1:96889c1:     }
1:96889c1: 
1:d57ff17:     public Object [] getArgs(int messageNumber) {
1:d57ff17:         if (sqlErrmcMessages_ != null)
1:d57ff17: 	    return MessageUtils.getArgs(getSqlState(messageNumber),
1:d57ff17:                                         sqlErrmcMessages_[messageNumber] );
1:d57ff17:         return null;
1:d57ff17:     }
1:d57ff17: 
1:70f7692:     // Gets the formatted message, can throw an exception.
1:96889c1:     private String getMessage(int messageNumber) throws SqlException {
1:70f7692:         // should this be traced to see if we are calling a stored proc?
1:96889c1:         if (cachedMessages != null && cachedMessages[messageNumber] != null) {
1:96889c1:             return cachedMessages[messageNumber];
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (connection_ == null || connection_.isClosedX() || returnTokensOnlyInMessageText_) {
1:96889c1:             return getUnformattedMessage(messageNumber);
1:70f7692:         }
1:70f7692: 
1:69e3d06:         ClientCallableStatement cs = null;
1:70f7692:         synchronized (connection_) {
1:95049cf:             try {
1:70f7692:                 cs = connection_.prepareMessageProc("call SYSIBM.SQLCAMESSAGE(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
1:4c9b831:                 // Cannot let this statement commit the transaction. Otherwise, 
1:4c9b831:                 // calling getWarnings while navigating a ResultSet will 
1:4c9b831:                 // release and invalidate locators used by the cursor.
1:4c9b831:                 cs.isAutoCommittableStatement_ = false;
1:96889c1:                 String errmc = null;
1:96889c1:                 String sqlState = null;
1:96889c1: 
1:96889c1:                 if (sqlErrmcMessages_ != null) {
1:96889c1:                     errmc = sqlErrmcMessages_[messageNumber];
1:96889c1:                     sqlState = sqlStates_[messageNumber];
1:96889c1:                 }
1:96889c1: 
1:70f7692:                 // SQLCode: SQL return code.
1:96889c1:                 cs.setIntX(1, (messageNumber == 0) ? getSqlCode() : 0);
1:70f7692:                 // SQLErrml: Length of SQL error message tokens.
1:96889c1:                 cs.setShortX(2, (short) ((errmc == null) ? 0 : errmc.length()));
1:96889c1:                 // SQLErrmc: SQL error message tokens as a String
1:96889c1:                 cs.setStringX(3, errmc);
1:70f7692:                 // SQLErrp: Product signature.
1:70f7692:                 cs.setStringX(4, getSqlErrp());
1:70f7692:                 // SQLErrd: SQL internal error code.
1:70f7692:                 cs.setIntX(5, getSqlErrd()[0]);
1:70f7692:                 cs.setIntX(6, getSqlErrd()[1]);
1:70f7692:                 cs.setIntX(7, getSqlErrd()[2]);
1:70f7692:                 cs.setIntX(8, getSqlErrd()[3]);
1:70f7692:                 cs.setIntX(9, getSqlErrd()[4]);
1:70f7692:                 cs.setIntX(10, getSqlErrd()[5]);
1:70f7692:                 // SQLWarn: SQL warning flags.
1:95049cf:                 cs.setStringX(11, getSqlWarn());
1:70f7692:                 // SQLState: standard SQL state.
1:96889c1:                 cs.setStringX(12, sqlState);
1:70f7692:                 // MessageFileName: Not used by our driver, so set to null.
1:70f7692:                 cs.setStringX(13, null);
1:70f7692:                 // Locale: language preference requested for the return error message.
1:69e3d06:                 cs.setStringX(14, Locale.getDefault().toString());
1:70f7692:                 // server could return a locale different from what we requested
1:69e3d06:                 cs.registerOutParameterX(14, Types.VARCHAR);
1:70f7692:                 // Message: error message returned from SQLCAMessage stored procedure.
1:69e3d06:                 cs.registerOutParameterX(15, Types.LONGVARCHAR);
1:70f7692:                 // RCode: return code from SQLCAMessage stored procedure.
1:69e3d06:                 cs.registerOutParameterX(16, Types.INTEGER);
1:70f7692:                 cs.executeX();
1:70f7692: 
1:70f7692:                 if (cs.getIntX(16) == 0) {
1:70f7692:                     // Return the message text.
1:70f7692:                     messageTextRetrievedContainsTokensOnly_ = false;
1:70f7692:                     String message = cs.getStringX(15);
1:96889c1:                     if (cachedMessages == null) {
1:96889c1:                         cachedMessages = new String[numberOfMessages()];
1:96889c1:                     }
1:96889c1:                     cachedMessages[messageNumber] = message;
1:70f7692:                     return message;
1:70f7692:                 } else {
1:70f7692:                     // Stored procedure can't return a valid message text, so we return
1:70f7692:                     // unformated exception
1:96889c1:                     return getUnformattedMessage(messageNumber);
1:70f7692:                 }
1:70f7692:             } finally {
1:70f7692:                 if (cs != null) {
6:70f7692:                     try {
1:70f7692:                         cs.closeX();
1:d506170:                     } catch (SqlException doNothing) {
1:70f7692:                     }
1:70f7692:                 }
1:70f7692:             }
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:70f7692:     // May or may not get the formatted message depending upon datasource directives.  cannot throw exeption.
1:96889c1:     synchronized String getJDBCMessage(int messageNumber) {
1:70f7692:         // The transient connection_ member will only be null if the Sqlca has been deserialized
1:70f7692:         if (connection_ != null && connection_.retrieveMessageText_) {
1:70f7692:             try {
1:96889c1:                 return getMessage(messageNumber);
1:70f7692:             } catch (SqlException e) {
1:70f7692:                 // Invocation of stored procedure fails, so we return error message tokens directly.
1:694fc08:                 exceptionThrownOnStoredProcInvocation_ = e;
1:70f7692:                 chainDeferredExceptionsToAgentOrAsConnectionWarnings((SqlException) e);
1:96889c1:                 return getUnformattedMessage(messageNumber);
1:70f7692:             }
1:70f7692:         } else {
1:96889c1:             return getUnformattedMessage(messageNumber);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:96889c1:     /**
1:96889c1:      * Get the unformatted message text (in case we cannot ask the server).
1:96889c1:      *
1:96889c1:      * @param messageNumber which message number to get the text for
1:96889c1:      * @return string with details about the error
1:96889c1:      */
1:96889c1:     private String getUnformattedMessage(int messageNumber) {
1:b54db0f:         int errorCode;
1:96889c1:         String sqlState;
1:96889c1:         String sqlErrmc;
1:96889c1:         if (messageNumber == 0) {
1:96889c1:             // if the first exception in the chain is requested, return all the
1:96889c1:             // information we have
1:b54db0f:             errorCode = getErrorCode();
1:96889c1:             sqlState = getSqlState();
1:96889c1:             sqlErrmc = getSqlErrmc();
1:96889c1:         } else {
1:96889c1:             // otherwise, return information about the specified error only
1:b54db0f:             errorCode = 0;
1:96889c1:             sqlState = sqlStates_[messageNumber];
1:96889c1:             sqlErrmc = sqlErrmcMessages_[messageNumber];
1:96889c1:         }
1:b54db0f:         return "DERBY SQL error: ERRORCODE: " + errorCode + ", SQLSTATE: " +
1:96889c1:             sqlState + ", SQLERRMC: " + sqlErrmc;
1:70f7692:     }
1:33776ff: 
1:70f7692:     private void chainDeferredExceptionsToAgentOrAsConnectionWarnings(SqlException e) {
1:70f7692:         SqlException current = e;
1:70f7692:         while (current != null) {
1:70f7692:             SqlException next = (SqlException) current.getNextException();
1:70f7692:             current = current.copyAsUnchainedSQLException(agent_.logWriter_);
1:70f7692:             if (current.getErrorCode() == -440) {
1:70f7692:                 SqlWarning warningForStoredProcFailure = new SqlWarning(agent_.logWriter_,
1:e65b4db:                     new ClientMessageId(SQLState.UNABLE_TO_OBTAIN_MESSAGE_TEXT_FROM_SERVER));
1:d506170:                 warningForStoredProcFailure.setNextException(current.getSQLException());
1:70f7692:                 connection_.accumulate440WarningForMessageProcFailure(warningForStoredProcFailure);
1:70f7692:             } else if (current.getErrorCode() == -444) {
1:70f7692:                 SqlWarning warningForStoredProcFailure = new SqlWarning(agent_.logWriter_,
1:e65b4db:                     new ClientMessageId(SQLState.UNABLE_TO_OBTAIN_MESSAGE_TEXT_FROM_SERVER));
1:d506170:                 warningForStoredProcFailure.setNextException(current.getSQLException());
1:70f7692:                 connection_.accumulate444WarningForMessageProcFailure(warningForStoredProcFailure);
1:70f7692:             } else {
1:70f7692:                 agent_.accumulateDeferredException(current);
1:70f7692:             }
1:70f7692:             current = next;
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:96889c1:     /**
1:b850119:      * Get a {@code java.sql.DataTruncation} warning based on the information
1:b850119:      * in this SQLCA.
1:b850119:      *
1:b850119:      * @return a {@code java.sql.DataTruncation} instance
1:b850119:      */
1:b850119:     DataTruncation getDataTruncation() {
1:b850119:         // The network server has serialized all the parameters needed by
1:b850119:         // the constructor in the SQLERRMC field.
1:d57ff17:         String[] tokens = getSqlErrmc().split(MessageUtils.SQLERRMC_TOKEN_DELIMITER);
1:b850119:         return new DataTruncation(
1:b850119:                 Integer.parseInt(tokens[0]),                // index
1:b850119:                 Boolean.valueOf(tokens[1]).booleanValue(),  // parameter
1:b850119:                 Boolean.valueOf(tokens[2]).booleanValue(),  // read
1:b850119:                 Integer.parseInt(tokens[3]),                // dataSize
1:b850119:                 Integer.parseInt(tokens[4]));               // transferSize
1:b850119:     }
1:b850119: 
1:70f7692:     // ------------------- helper methods ----------------------------------------
1:70f7692: 
1:96889c1:     private void processSqlErrmcTokens(byte[] tokenBytes) {
1:70f7692:         if (tokenBytes == null) {
1:96889c1:             return;
1:70f7692:         }
1:70f7692: 
1:70f7692:         // create 0-length String tokens array if tokenBytes is 0-length
1:70f7692:         int length = tokenBytes.length;
1:70f7692:         if (length == 0) {
1:96889c1:             sqlStates_ = sqlErrmcMessages_ = new String[0];
1:96889c1:             return;
1:70f7692:         }
1:70f7692: 
1:a0b8943:         // tokenize and convert tokenBytes
1:a0b8943:         String fullString = bytes2String(tokenBytes, 0, length);
1:a0b8943:         String[] tokens = fullString.split("\\u0014{3}");
1:a0b8943:         String[] states = new String[tokens.length];
1:a0b8943:         states[0] = getSqlState();
1:a0b8943:         for (int i = 1; i < tokens.length; i++) {
1:a0b8943:             // All but the first message are preceded by the SQL state
1:a0b8943:             // (five characters) and a colon. Extract the SQL state and
1:a0b8943:             // clean up the token. See
1:a0b8943:             // DRDAConnThread.buildTokenizedSqlerrmc() for more details.
1:a0b8943:             int colonpos = tokens[i].indexOf(":");
1:a0b8943:             states[i] = tokens[i].substring(0, colonpos);
1:a0b8943:             tokens[i] = tokens[i].substring(colonpos + 1);
1:70f7692:         }
1:a0b8943:         sqlStates_ = states;
1:a0b8943:         sqlErrmcMessages_ = tokens;
1:70f7692:     }
1:70f7692: 
1:a0b8943:     protected String bytes2String(byte[] bytes, int offset, int length) {
1:5d50d40:         // Network server uses utf8 encoding
1:5d50d40:         return new String(bytes, offset, length, Typdef.UTF8ENCODING);
1:70f7692:     }
1:70f7692: 
1:f26c60c:     public long getUpdateCount() {
1:70f7692:         if (sqlErrd_ == null) {
1:f26c60c:             return 0L;
1:70f7692:         }
1:95049cf:         long    result = getSqlErrd()[ LOW_ORDER_UPDATE_COUNT ];
1:f26c60c:         result &= 0xFFFFFFFFL;
1:95049cf:         result |= ((long) getSqlErrd()[ HIGH_ORDER_UPDATE_COUNT ] << 32);
1:f26c60c:         return result;
1:70f7692:     }
1:70f7692: 
1:b13b17c:     public long getRowCount() throws DisconnectException {
1:95049cf:         return ((long) getSqlErrd()[ HIGH_ORDER_ROW_COUNT ] << 32) +
1:95049cf:                 getSqlErrd()[ LOW_ORDER_ROW_COUNT ];
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void setContainsSqlcax(boolean containsSqlcax) {
1:70f7692:         containsSqlcax_ = containsSqlcax;
1:70f7692:     }
1:70f7692: 
1:70f7692:     public boolean containsSqlcax() {
1:70f7692:         return containsSqlcax_;
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public void resetRowsetSqlca(ClientConnection connection,
1:70f7692:                                  int sqlCode,
1:95049cf:                                  String sqlState) {
1:70f7692:         connection_ = connection;
1:70f7692:         sqlCode_ = sqlCode;
1:99683a9:         sqlState_ = sqlState;
1:95049cf:         sqlErrpBytes_ = null;
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void setRowsetRowCount(long rowCount) {
1:70f7692:         rowsetRowCount_ = rowCount;
1:70f7692:     }
1:70f7692: 
1:70f7692:     public long getRowsetRowCount() {
1:70f7692:         return rowsetRowCount_;
1:70f7692:     }
1:70f7692: }
1:70f7692: 
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:e47763a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             buffer.append(MessageUtils.SQLERRMC_MESSAGE_DELIMITER);
commit:d57ff17
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.error.MessageUtils;
/////////////////////////////////////////////////////////////////////////
0:      * @see org.apache.derby.shared.common.error.MessageUtils#SQLERRMC_MESSAGE_DELIMITER
1:     
/////////////////////////////////////////////////////////////////////////
1:     public Object [] getArgs(int messageNumber) {
1:         if (sqlErrmcMessages_ != null)
1: 	    return MessageUtils.getArgs(getSqlState(messageNumber),
1:                                         sqlErrmcMessages_[messageNumber] );
1:         return null;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         String[] tokens = getSqlErrmc().split(MessageUtils.SQLERRMC_TOKEN_DELIMITER);
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:4c9b831
/////////////////////////////////////////////////////////////////////////
1:                 // Cannot let this statement commit the transaction. Otherwise, 
1:                 // calling getWarnings while navigating a ResultSet will 
1:                 // release and invalidate locators used by the cursor.
1:                 cs.isAutoCommittableStatement_ = false;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a0b8943
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         sqlErrp_ = bytes2String(sqlErrpBytes_, 0, sqlErrpBytes_.length);
1:         return sqlErrp_;
/////////////////////////////////////////////////////////////////////////
1:                 sqlWarn_ = bytes2String(sqlWarnBytes_, 0, sqlWarnBytes_.length);
/////////////////////////////////////////////////////////////////////////
1:         // tokenize and convert tokenBytes
1:         String fullString = bytes2String(tokenBytes, 0, length);
1:         String[] tokens = fullString.split("\\u0014{3}");
1:         String[] states = new String[tokens.length];
1:         states[0] = getSqlState();
1:         for (int i = 1; i < tokens.length; i++) {
1:             // All but the first message are preceded by the SQL state
1:             // (five characters) and a colon. Extract the SQL state and
1:             // clean up the token. See
1:             // DRDAConnThread.buildTokenizedSqlerrmc() for more details.
1:             int colonpos = tokens[i].indexOf(":");
1:             states[i] = tokens[i].substring(0, colonpos);
1:             tokens[i] = tokens[i].substring(colonpos + 1);
1:         sqlStates_ = states;
1:         sqlErrmcMessages_ = tokens;
1:     protected String bytes2String(byte[] bytes, int offset, int length) {
commit:b54db0f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.error.ExceptionSeverity;
1: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Get the error code based on the SQL code received from the server.
1:      * </p>
1:      *
1:      * <p>
1:      * The conversion from SQL code to error code happens like this:
1:      * </p>
1:      *
1:      * <ul>
1:      * <li>If the SQL code is 0, there is no error code because the Sqlca
1:      * doesn't represent an error. Return 0.</li>
1:      * <li>If the SQL code is positive, the Sqlca represents a warning, and
1:      * the SQL code represents the actual error code. Return the SQL code.</li>
1:      * <li>If the SQL code is negative, the Sqlca represents an error, and
1:      * the error code is {@code -(sqlCode+1)}.</li>
1:      * </ul>
1:      *
1:      * @see org.apache.derby.impl.drda.DRDAConnThread#getSqlCode(java.sql.SQLException)
1:      */
1:     public synchronized int getErrorCode() {
1:         // Warning or other non-error, return SQL code.
1:         if (sqlCode_ >= 0) return sqlCode_;
1: 
1:         // Negative SQL code means it is an error. Transform into a positive
1:         // error code.
1:         int errorCode = -(sqlCode_ + 1);
1: 
1:         // In auto-commit mode, the embedded driver promotes statement
1:         // severity to transaction severity. Do the same here to match.
1:         if (errorCode == ExceptionSeverity.STATEMENT_SEVERITY &&
1:                 connection_ != null && connection_.autoCommit_) {
1:             errorCode = ExceptionSeverity.TRANSACTION_SEVERITY;
1:         }
1: 
1:         return errorCode;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         int errorCode;
1:             errorCode = getErrorCode();
1:             errorCode = 0;
1:         return "DERBY SQL error: ERRORCODE: " + errorCode + ", SQLSTATE: " +
commit:b850119
/////////////////////////////////////////////////////////////////////////
1: import java.sql.DataTruncation;
/////////////////////////////////////////////////////////////////////////
0:     /** Token delimiter for SQLERRMC. */
0:     private final static String SQLERRMC_TOKEN_DELIMITER = "\u0014";
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Get a {@code java.sql.DataTruncation} warning based on the information
1:      * in this SQLCA.
1:      *
1:      * @return a {@code java.sql.DataTruncation} instance
1:      */
1:     DataTruncation getDataTruncation() {
1:         // The network server has serialized all the parameters needed by
1:         // the constructor in the SQLERRMC field.
0:         String[] tokens = getSqlErrmc().split(SQLERRMC_TOKEN_DELIMITER);
1:         return new DataTruncation(
1:                 Integer.parseInt(tokens[0]),                // index
1:                 Boolean.valueOf(tokens[1]).booleanValue(),  // parameter
1:                 Boolean.valueOf(tokens[2]).booleanValue(),  // read
1:                 Integer.parseInt(tokens[3]),                // dataSize
1:                 Integer.parseInt(tokens[4]));               // transferSize
1:     }
1: 
commit:96889c1
/////////////////////////////////////////////////////////////////////////
1:     /** A string representation of <code>sqlErrmcBytes_</code>. */
1:     private String sqlErrmc_;
1:     /** Array of errmc strings for each message in the chain. */
0:     protected String[] sqlErrmcMessages_;
1:     /** SQL states for all the messages in the exception chain. */
1:     private String[] sqlStates_;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Character sequence that separates the different messages in the errmc.
0:      * @see org.apache.derby.catalog.SystemProcedures#SQLERRMC_MESSAGE_DELIMITER
1:      */
0:     private static final String sqlErrmcDelimiter__ = "\u0014\u0014\u0014";
1:     /** Cached error messages (to prevent multiple invocations of the stored
1:      * procedure to get the same message). */
1:     private String[] cachedMessages;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns the number of messages this SQLCA contains.
1:      *
1:      * @return number of messages
1:      */
1:     synchronized int numberOfMessages() {
1:         initSqlErrmcMessages();
1:         if (sqlErrmcMessages_ != null) {
1:             return sqlErrmcMessages_.length;
1:         }
1:         // even if we don't have an array of errmc messages, we are able to get
1:         // one message out of this sqlca (although it's not very readable)
1:         return 1;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         // sqlErrmc string is dependent on sqlErrmcMessages_ array having
1:         // been built
1:         initSqlErrmcMessages();
1:         // sqlErrmc will be built only if sqlErrmcMessages_ has been built.
1:         if (sqlErrmcMessages_ == null) {
1:         if (sqlErrmcMessages_.length == 0) {
/////////////////////////////////////////////////////////////////////////
1:         for (indx = 0; indx < sqlErrmcMessages_.length - 1; indx++) {
1:             buffer.append(sqlErrmcMessages_[indx]);
1:             // all but the first message should be preceded by the SQL state
1:             // and a colon (see DRDAConnThread.buildTokenizedSqlerrmc() on the
1:             // server)
1:             buffer.append(sqlStates_[indx+1]);
1:             buffer.append(":");
1:         buffer.append(sqlErrmcMessages_[indx]);
1:     /**
1:      * Initialize and build the arrays <code>sqlErrmcMessages_</code> and
1:      * <code>sqlStates_</code>.
1:      */
1:     private void initSqlErrmcMessages() {
1:         if (sqlErrmcMessages_ == null || sqlStates_ == null) {
1:             // processSqlErrmcTokens handles null sqlErrmcBytes_ case
1:             processSqlErrmcTokens(sqlErrmcBytes_);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the SQL state for a given error.
1:      *
1:      * @param messageNumber the error to retrieve SQL state for
1:      * @return SQL state for the error
1:      */
1:     synchronized String getSqlState(int messageNumber) {
1:         initSqlErrmcMessages();
1:         if (sqlStates_ != null) {
1:             return sqlStates_[messageNumber];
1:         }
1:         return getSqlState();
1:     }
1: 
1:     private String getMessage(int messageNumber) throws SqlException {
1:         if (cachedMessages != null && cachedMessages[messageNumber] != null) {
1:             return cachedMessages[messageNumber];
1:             return getUnformattedMessage(messageNumber);
/////////////////////////////////////////////////////////////////////////
1:                 String errmc = null;
1:                 String sqlState = null;
1: 
1:                 if (sqlErrmcMessages_ != null) {
1:                     errmc = sqlErrmcMessages_[messageNumber];
1:                     sqlState = sqlStates_[messageNumber];
1:                 }
1: 
1:                 cs.setIntX(1, (messageNumber == 0) ? getSqlCode() : 0);
1:                 cs.setShortX(2, (short) ((errmc == null) ? 0 : errmc.length()));
1:                 // SQLErrmc: SQL error message tokens as a String
1:                 cs.setStringX(3, errmc);
/////////////////////////////////////////////////////////////////////////
1:                 cs.setStringX(12, sqlState);
/////////////////////////////////////////////////////////////////////////
1:                     if (cachedMessages == null) {
1:                         cachedMessages = new String[numberOfMessages()];
1:                     }
1:                     cachedMessages[messageNumber] = message;
1:                     return getUnformattedMessage(messageNumber);
/////////////////////////////////////////////////////////////////////////
1:     synchronized String getJDBCMessage(int messageNumber) {
1:                 return getMessage(messageNumber);
1:                 return getUnformattedMessage(messageNumber);
1:             return getUnformattedMessage(messageNumber);
0:     /**
1:      * Get the unformatted message text (in case we cannot ask the server).
1:      *
1:      * @param messageNumber which message number to get the text for
1:      * @return string with details about the error
1:      */
1:     private String getUnformattedMessage(int messageNumber) {
0:         int sqlCode;
1:         String sqlState;
1:         String sqlErrmc;
1:         if (messageNumber == 0) {
1:             // if the first exception in the chain is requested, return all the
1:             // information we have
0:             sqlCode = getSqlCode();
1:             sqlState = getSqlState();
1:             sqlErrmc = getSqlErrmc();
1:         } else {
1:             // otherwise, return information about the specified error only
0:             sqlCode = 0;
1:             sqlState = sqlStates_[messageNumber];
1:             sqlErrmc = sqlErrmcMessages_[messageNumber];
1:         }
0:         return "DERBY SQL error: SQLCODE: " + sqlCode + ", SQLSTATE: " +
1:             sqlState + ", SQLERRMC: " + sqlErrmc;
/////////////////////////////////////////////////////////////////////////
1:     private void processSqlErrmcTokens(byte[] tokenBytes) {
1:             return;
1:             sqlStates_ = sqlErrmcMessages_ = new String[0];
1:             return;
0:             String fullString = bytes2String(tokenBytes, 0, length);
0:             String[] tokens = fullString.split("\\u0014{3}");
0:             String[] states = new String[tokens.length];
0:             states[0] = getSqlState();
0:             for (int i = 1; i < tokens.length; i++) {
0:                 // All but the first message are preceded by the SQL state
0:                 // (five characters) and a colon. Extract the SQL state and
0:                 // clean up the token. See
0:                 // DRDAConnThread.buildTokenizedSqlerrmc() for more details.
0:                 states[i] = tokens[i].substring(0, 5);
0:                 tokens[i] = tokens[i].substring(6);
0:             sqlStates_ = states;
0:             sqlErrmcMessages_ = tokens;
0:             /* do nothing, the arrays continue to be null */
commit:694fc08
/////////////////////////////////////////////////////////////////////////
1:     SqlException exceptionThrownOnStoredProcInvocation_;
/////////////////////////////////////////////////////////////////////////
1:                 exceptionThrownOnStoredProcInvocation_ = e;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
1:     String formatSqlErrd() {
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     private  static  final   int HIGH_ORDER_ROW_COUNT = 0;
1:     private  static  final   int LOW_ORDER_ROW_COUNT = 1;
1:     private  static  final   int LOW_ORDER_UPDATE_COUNT = 2;
1:     private  static  final   int HIGH_ORDER_UPDATE_COUNT = 3;
1:     transient private ClientConnection connection_;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
1: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
0:     transient protected ClientConnection connection_;
/////////////////////////////////////////////////////////////////////////
1:     protected Sqlca(ClientConnection connection) {
/////////////////////////////////////////////////////////////////////////
0:         } catch (UnsupportedEncodingException e) {
/////////////////////////////////////////////////////////////////////////
1:         ClientCallableStatement cs = null;
/////////////////////////////////////////////////////////////////////////
1:                 cs.setStringX(14, Locale.getDefault().toString());
1:                 cs.registerOutParameterX(14, Types.VARCHAR);
1:                 cs.registerOutParameterX(15, Types.LONGVARCHAR);
1:                 cs.registerOutParameterX(16, Types.INTEGER);
/////////////////////////////////////////////////////////////////////////
0:         } catch (UnsupportedEncodingException e) {
0:             throws UnsupportedEncodingException {
/////////////////////////////////////////////////////////////////////////
1:     public void resetRowsetSqlca(ClientConnection connection,
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
0:     protected Sqlca(Connection connection) {
/////////////////////////////////////////////////////////////////////////
1:     public long getRowCount() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
0:     public void resetRowsetSqlca(Connection connection,
commit:95049cf
/////////////////////////////////////////////////////////////////////////
0: import java.io.UnsupportedEncodingException;
/////////////////////////////////////////////////////////////////////////
1:     private String[] sqlErrmcMessages_;
1:     private String sqlErrp_;        // function name issuing error
1:     private String sqlWarn_;        // 11 warning Flags
/////////////////////////////////////////////////////////////////////////
1:     private boolean containsSqlcax_ = true;
1:     private long rowsetRowCount_;
/////////////////////////////////////////////////////////////////////////
1:     private int[] getSqlErrd() {
/////////////////////////////////////////////////////////////////////////
0:     public String formatSqlErrd() {
1:         return Utils.getStringFromInts(getSqlErrd());
1:     }
0:     // what is this for??
0:     public int getReturnValue() {
0:         return getSqlErrd()[0];
1:     }
1: 
1:     private final static String elevenBlanks = "           ";
1: 
1:     synchronized public String getSqlWarn() {
1:         if (sqlWarn_ == null) {
1:             if (sqlWarnBytes_ != null) {
1:                 try {
0:                     sqlWarn_ =
0:                         bytes2String(sqlWarnBytes_, 0, sqlWarnBytes_.length);
0:                 } catch (UnsupportedEncodingException e) {
1:                     sqlWarn_ = elevenBlanks;
1:                 }
1:                 sqlWarn_ = elevenBlanks;
1:         return sqlWarn_;
/////////////////////////////////////////////////////////////////////////
1:                 cs.setStringX(11, getSqlWarn());
/////////////////////////////////////////////////////////////////////////
1:         long    result = getSqlErrd()[ LOW_ORDER_UPDATE_COUNT ];
1:         result |= ((long) getSqlErrd()[ HIGH_ORDER_UPDATE_COUNT ] << 32);
1:         return ((long) getSqlErrd()[ HIGH_ORDER_ROW_COUNT ] << 32) +
1:                 getSqlErrd()[ LOW_ORDER_ROW_COUNT ];
/////////////////////////////////////////////////////////////////////////
1:                                  String sqlState) {
1:         sqlErrpBytes_ = null;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:f26c60c
/////////////////////////////////////////////////////////////////////////
1: 
1:     // Indexes into sqlErrd_
0:     public  static  final   int HIGH_ORDER_ROW_COUNT = 0;
0:     public  static  final   int LOW_ORDER_ROW_COUNT = 1;
0:     public  static  final   int LOW_ORDER_UPDATE_COUNT = 2;
0:     public  static  final   int HIGH_ORDER_UPDATE_COUNT = 3;
1:     public  static  final   int SQL_ERR_LENGTH = 6;
/////////////////////////////////////////////////////////////////////////
1:         sqlErrd_ = new int[ SQL_ERR_LENGTH ]; // create an int array.
/////////////////////////////////////////////////////////////////////////
1:     public long getUpdateCount() {
1:             return 0L;
0:         long    result = sqlErrd_[ LOW_ORDER_UPDATE_COUNT ];
1:         result &= 0xFFFFFFFFL;
0:         result |= ((long) sqlErrd_[ HIGH_ORDER_UPDATE_COUNT ] << 32);
1:         return result;
0:         return ((long) sqlErrd_[ HIGH_ORDER_ROW_COUNT ] << 32) + sqlErrd_[ LOW_ORDER_ROW_COUNT ];
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:b75cf01
/////////////////////////////////////////////////////////////////////////
0:                 int colonpos = tokens[i].indexOf(":");
0:                 states[i] = tokens[i].substring(0, colonpos);
0:                 tokens[i] = tokens[i].substring(colonpos + 1);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:99683a9
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:         return sqlState_;
/////////////////////////////////////////////////////////////////////////
0:     protected String bytes2String(byte[] bytes, int offset, int length)
/////////////////////////////////////////////////////////////////////////
0:                                  String sqlState,
0:                                  byte[] sqlErrpBytes) {
1:         sqlState_ = sqlState;
commit:5d50d40
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.net.Typdef;
/////////////////////////////////////////////////////////////////////////
1:         // Network server uses utf8 encoding
1:         return new String(bytes, offset, length, Typdef.UTF8ENCODING);
author:David Van Couvering
-------------------------------------------------------------------------------
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId(SQLState.UNABLE_TO_OBTAIN_MESSAGE_TEXT_FROM_SERVER));
1:                     new ClientMessageId(SQLState.UNABLE_TO_OBTAIN_MESSAGE_TEXT_FROM_SERVER));
commit:7680ab7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.reference.SQLState;
1: 
/////////////////////////////////////////////////////////////////////////
0:                     new MessageId(SQLState.UNABLE_TO_OBTAIN_MESSAGE_TEXT_FROM_SERVER));
0:                     new MessageId(SQLState.UNABLE_TO_OBTAIN_MESSAGE_TEXT_FROM_SERVER));
commit:d506170
/////////////////////////////////////////////////////////////////////////
1:                     } catch (SqlException doNothing) {
/////////////////////////////////////////////////////////////////////////
0:                 exceptionThrownOnStoredProcInvocation_ = e.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:                 warningForStoredProcFailure.setNextException(current.getSQLException());
/////////////////////////////////////////////////////////////////////////
1:                 warningForStoredProcFailure.setNextException(current.getSQLException());
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1: public abstract class Sqlca {
0:     transient protected Connection connection_;
0:     java.sql.SQLException exceptionThrownOnStoredProcInvocation_;
1:     boolean messageTextRetrievedContainsTokensOnly_ = true;
1:     // data corresponding to SQLCA fields
1:     protected int sqlCode_;        // SQLCODE
0:     private String sqlErrmc_;       // A string with all error tokens delimited by sqlErrmcDelimiter
0:     protected String[] sqlErrmcTokens_; // A string array with each element
1:     // contain an error token
0:     protected String sqlErrp_;        // function name issuing error
1:     protected int[] sqlErrd_;        // 6 diagnostic Information
0:     protected char[] sqlWarn_;        // 11 warning Flags
1:     protected String sqlState_;       // SQLSTATE
1:     // raw sqlca data fields before unicode conversion
1:     protected byte[] sqlErrmcBytes_;
1:     protected byte[] sqlErrpBytes_;
1:     protected byte[] sqlWarnBytes_;
0:     protected byte[] sqlStateBytes_;
0:     protected int ccsid_;
0:     protected int sqlErrmcCcsid_;
0:     protected boolean containsSqlcax_ = true;
0:     protected long rowsetRowCount_;
0:     //public static final String sqlErrmcDelimiter = "\u00FF";
0:     private static final String sqlErrmcDelimiter__ = ";";
1:     // JDK stack trace calls e.getMessage(), so we must set some state on the sqlca that says return tokens only.
1:     private boolean returnTokensOnlyInMessageText_ = false;
1:     transient private final Agent agent_;
0:     private String cachedMessage;
0:     protected Sqlca(org.apache.derby.client.am.Connection connection) {
1:         connection_ = connection;
1:         agent_ = connection_ != null ? connection_.agent_ : null;
1:     void returnTokensOnlyInMessageText(boolean returnTokensOnlyInMessageText) {
1:         returnTokensOnlyInMessageText_ = returnTokensOnlyInMessageText;
1:     synchronized public int getSqlCode() {
1:         return sqlCode_;
1: 
1:     synchronized public String getSqlErrmc() {
1:         if (sqlErrmc_ != null) {
1:             return sqlErrmc_;
1:         }
1: 
0:         // sqlErrmc string is dependent on sqlErrmcTokens array having been built
0:         if (sqlErrmcTokens_ == null) {
0:             getSqlErrmcTokens();
1:         }
1: 
0:         // sqlErrmc will be build only if sqlErrmcTokens has been build.
1:         // Otherwise, a null string will be returned.
0:         if (sqlErrmcTokens_ == null) {
1:             return null;
1:         }
1: 
1:         // create 0-length String if no tokens
0:         if (sqlErrmcTokens_.length == 0) {
1:             sqlErrmc_ = "";
1:             return sqlErrmc_;
1:         }
1: 
1:         // concatenate tokens with sqlErrmcDelimiter delimiters into one String
1:         StringBuffer buffer = new StringBuffer();
1:         int indx;
0:         for (indx = 0; indx < sqlErrmcTokens_.length - 1; indx++) {
0:             buffer.append(sqlErrmcTokens_[indx]);
0:             buffer.append(sqlErrmcDelimiter__);
1:         }
1:         // add the last token
0:         buffer.append(sqlErrmcTokens_[indx]);
1: 
1:         // save as a string
1:         sqlErrmc_ = buffer.toString();
1:         return sqlErrmc_;
0:     synchronized public String[] getSqlErrmcTokens() {
0:         if (sqlErrmcTokens_ != null) {
0:             return sqlErrmcTokens_;
1:         }
0:         // processSqlErrmcTokens handles null sqlErrmcBytes_ case
0:         sqlErrmcTokens_ = processSqlErrmcTokens(sqlErrmcBytes_);
0:         return sqlErrmcTokens_;
1:     synchronized public String getSqlErrp() {
1:         if (sqlErrp_ != null) {
1:             return sqlErrp_;
1:         }
1:         if (sqlErrpBytes_ == null) {
1:             return null;
1:         }
1:         try {
0:             sqlErrp_ = bytes2String(sqlErrpBytes_,
0:                     0,
0:                     sqlErrpBytes_.length);
1:             return sqlErrp_;
0:         } catch (java.io.UnsupportedEncodingException e) {
0:             // leave sqlErrp as null.
1:             return null;
1: 
0:     public int[] getSqlErrd() {
1:         if (sqlErrd_ != null) {
1:             return sqlErrd_;
1:         }
1: 
0:         sqlErrd_ = new int[6]; // create an int array.
1:         return sqlErrd_;
0:     synchronized public char[] getSqlWarn() {
0:         if (sqlWarn_ != null) {
0:             return sqlWarn_;
1:         }
1: 
1:         try {
0:             if (sqlWarnBytes_ == null) {
0:                 sqlWarn_ = new char[]{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '}; // 11 blank.
1:             } else {
0:                 sqlWarn_ = bytes2String(sqlWarnBytes_, 0, sqlWarnBytes_.length).toCharArray();
1:             }
0:             return sqlWarn_;
0:         } catch (java.io.UnsupportedEncodingException e) {
0:             sqlWarn_ = new char[]{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '}; // 11 blank.
0:             return sqlWarn_;
1:         }
1:     synchronized public String getSqlState() {
0:         if (sqlState_ != null) {
0:             return sqlState_;
1:         }
0:         if (sqlStateBytes_ == null) {
1:             return null;
1:         }
1: 
1:         try {
0:             sqlState_ = bytes2String(sqlStateBytes_,
0:                     0,
0:                     sqlStateBytes_.length);
0:             return sqlState_;
0:         } catch (java.io.UnsupportedEncodingException e) {
0:             // leave sqlState as null.
1:             return null;
1:         }
1:     // Gets the formatted message, can throw an exception.
0:     synchronized public String getMessage() throws SqlException {
1:         // should this be traced to see if we are calling a stored proc?
0:         if (cachedMessage != null) {
0:             return cachedMessage;
1:         }
1: 
1:         if (connection_ == null || connection_.isClosedX() || returnTokensOnlyInMessageText_) {
0:             return getUnformattedMessage();
1:         }
1: 
0:         CallableStatement cs = null;
1:         synchronized (connection_) {
1:             try {
1:                 cs = connection_.prepareMessageProc("call SYSIBM.SQLCAMESSAGE(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
1: 
1:                 // SQLCode: SQL return code.
0:                 cs.setIntX(1, getSqlCode());
1:                 // SQLErrml: Length of SQL error message tokens.
0:                 cs.setShortX(2, (short) ((getSqlErrmc() != null) ? getSqlErrmc().length() : 0));
0:                 // SQLErrmc: SQL error message tokens as a String (delimited by semicolon ";").
0:                 cs.setStringX(3, getSqlErrmc());
1:                 // SQLErrp: Product signature.
1:                 cs.setStringX(4, getSqlErrp());
1:                 // SQLErrd: SQL internal error code.
1:                 cs.setIntX(5, getSqlErrd()[0]);
1:                 cs.setIntX(6, getSqlErrd()[1]);
1:                 cs.setIntX(7, getSqlErrd()[2]);
1:                 cs.setIntX(8, getSqlErrd()[3]);
1:                 cs.setIntX(9, getSqlErrd()[4]);
1:                 cs.setIntX(10, getSqlErrd()[5]);
1:                 // SQLWarn: SQL warning flags.
0:                 cs.setStringX(11, new String(getSqlWarn()));
1:                 // SQLState: standard SQL state.
0:                 cs.setStringX(12, getSqlState());
1:                 // MessageFileName: Not used by our driver, so set to null.
1:                 cs.setStringX(13, null);
1:                 // Locale: language preference requested for the return error message.
0:                 cs.setStringX(14, java.util.Locale.getDefault().toString());
1:                 // server could return a locale different from what we requested
0:                 cs.registerOutParameterX(14, java.sql.Types.VARCHAR);
1:                 // Message: error message returned from SQLCAMessage stored procedure.
0:                 cs.registerOutParameterX(15, java.sql.Types.LONGVARCHAR);
1:                 // RCode: return code from SQLCAMessage stored procedure.
0:                 cs.registerOutParameterX(16, java.sql.Types.INTEGER);
1:                 cs.executeX();
1: 
1:                 if (cs.getIntX(16) == 0) {
1:                     // Return the message text.
1:                     messageTextRetrievedContainsTokensOnly_ = false;
1:                     String message = cs.getStringX(15);
0:                     cachedMessage = message;
1:                     return message;
1:                 } else {
1:                     // Stored procedure can't return a valid message text, so we return
1:                     // unformated exception
0:                     return getUnformattedMessage();
1:                 }
1:             } finally {
1:                 if (cs != null) {
1:                     try {
1:                         cs.closeX();
0:                     } catch (java.sql.SQLException doNothing) {
1:                     }
1:                 }
1:             }
1:         }
1:     // May or may not get the formatted message depending upon datasource directives.  cannot throw exeption.
0:     public synchronized String getJDBCMessage() {
1:         // The transient connection_ member will only be null if the Sqlca has been deserialized
1:         if (connection_ != null && connection_.retrieveMessageText_) {
1:             try {
0:                 return getMessage();
1:             } catch (SqlException e) {
1:                 // Invocation of stored procedure fails, so we return error message tokens directly.
0:                 exceptionThrownOnStoredProcInvocation_ = e;
1:                 chainDeferredExceptionsToAgentOrAsConnectionWarnings((SqlException) e);
0:                 return getUnformattedMessage();
1:             }
1:         } else {
0:             return getUnformattedMessage();
1:         }
1: 
0:     private String getUnformattedMessage() {
0:         return "DERBY SQL error: SQLCODE: " + getSqlCode() + ", SQLSTATE: " + getSqlState() + ", SQLERRMC: " + getSqlErrmc();
1:     private void chainDeferredExceptionsToAgentOrAsConnectionWarnings(SqlException e) {
1:         SqlException current = e;
1:         while (current != null) {
1:             SqlException next = (SqlException) current.getNextException();
1:             current = current.copyAsUnchainedSQLException(agent_.logWriter_);
1:             if (current.getErrorCode() == -440) {
1:                 SqlWarning warningForStoredProcFailure = new SqlWarning(agent_.logWriter_,
0:                         " Unable to obtain message text from server." +
0:                         " See chained exception." +
0:                         " The stored procedure SYSIBM.SQLCAMESSAGE is not installed on server." +
0:                         " Contact your DBA.");
0:                 warningForStoredProcFailure.setNextException(current);
1:                 connection_.accumulate440WarningForMessageProcFailure(warningForStoredProcFailure);
1:             } else if (current.getErrorCode() == -444) {
1:                 SqlWarning warningForStoredProcFailure = new SqlWarning(agent_.logWriter_,
0:                         " Unable to obtain message text from server." +
0:                         " See chained exception." +
0:                         " The stored procedure SYSIBM.SQLCAMESSAGE cannot be accessed on the server." +
0:                         " Contact your DBA.");
0:                 warningForStoredProcFailure.setNextException(current);
1:                 connection_.accumulate444WarningForMessageProcFailure(warningForStoredProcFailure);
1:             } else {
1:                 agent_.accumulateDeferredException(current);
1:             }
1:             current = next;
1:         }
1:     }
0:     public boolean includesSqlCode(int[] codes) {
0:         for (int i = 0; i < codes.length; i++) {
0:             if (codes[i] == getSqlCode()) {
0:                 return true;
1:             }
1:         }
0:         return false;
1:     }
1:     // ------------------- helper methods ----------------------------------------
0:     private String[] processSqlErrmcTokens(byte[] tokenBytes) {
1:         if (tokenBytes == null) {
1:             return null;
1:         }
1:         // create 0-length String tokens array if tokenBytes is 0-length
1:         int length = tokenBytes.length;
1:         if (length == 0) {
0:             return new String[0];
1:         }
1:         try {
0:             // tokenize and convert tokenBytes
0:             java.io.ByteArrayOutputStream buffer = new java.io.ByteArrayOutputStream();
0:             java.util.LinkedList tokens = new java.util.LinkedList();
0:             // parse the error message tokens
0:             for (int index = 0; index < length - 1; index++) {
0:                 // non-delimiter - continue to write into buffer
0:                 if (tokenBytes[index] != -1)  // -1 is the delimiter '\xFF'
0:                 {
0:                     buffer.write(tokenBytes[index]);
1:                 }
0:                 // delimiter - convert current token and add to list
0:                 else {
0:                     tokens.add(bytes2String(buffer.toByteArray(), 0, buffer.size()));
0:                     buffer.reset();
1:                 }
1:             }
1: 
0:             int lastIndex = length - 1;
0:             // check for last byte not being a delimiter, i.e. part of last token
0:             if (tokenBytes[lastIndex] != -1) {
0:                 // write the last byte
0:                 buffer.write(tokenBytes[lastIndex]);
0:                 // convert the last token and add to list
0:                 tokens.add(bytes2String(buffer.toByteArray(), 0, buffer.size()));
1:             }
1: 
0:             // last byte is delimiter implying an empty String for last token
0:             else {
0:                 // convert current token, if one exists, and add to list
0:                 if (lastIndex != 0) {
0:                     tokens.add(bytes2String(buffer.toByteArray(), 0, buffer.size()));
1:                 }
0:                 // last token is an empty String
0:                 tokens.add("");
1:             }
1: 
0:             // create the String array and fill it with tokens.
0:             String[] tokenStrings = new String[tokens.size()];
1: 
0:             java.util.Iterator iterator = tokens.iterator();
0:             for (int i = 0; iterator.hasNext(); i++) {
0:                 tokenStrings[i] = (String) iterator.next();
1:             }
1: 
0:             return tokenStrings;
0:         } catch (java.io.UnsupportedEncodingException e) {
1:             return null;
1:         }
1:     }
1: 
0:     private String bytes2String(byte[] bytes, int offset, int length)
0:             throws java.io.UnsupportedEncodingException {
0:         return new String(bytes, offset, length);
1:     }
1: 
0:     public int getUpdateCount() {
1:         if (sqlErrd_ == null) {
0:             return 0;
1:         }
0:         return sqlErrd_[2];
1:     }
1: 
0:     public long getRowCount() throws org.apache.derby.client.am.DisconnectException {
0:         return ((long) sqlErrd_[0] << 32) + sqlErrd_[1];
1:     }
1: 
1:     public void setContainsSqlcax(boolean containsSqlcax) {
1:         containsSqlcax_ = containsSqlcax;
1:     }
1: 
1:     public boolean containsSqlcax() {
1:         return containsSqlcax_;
1:     }
1: 
0:     public void resetRowsetSqlca(org.apache.derby.client.am.Connection connection,
1:                                  int sqlCode,
0:                                  byte[] sqlStateBytes,
0:                                  byte[] sqlErrpBytes,
0:                                  int ccsid) {
1:         connection_ = connection;
1:         sqlCode_ = sqlCode;
0:         sqlStateBytes_ = sqlStateBytes;
0:         sqlErrpBytes_ = sqlErrpBytes;
0:         ccsid_ = ccsid;
1:     }
1: 
1:     public void setRowsetRowCount(long rowCount) {
1:         rowsetRowCount_ = rowCount;
1:     }
1: 
1:     public long getRowsetRowCount() {
1:         return rowsetRowCount_;
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.am.Sqlca
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
0: */
1: 
1: package org.apache.derby.client.am;
1: 
0: public abstract class Sqlca
0: {
0:   transient protected Connection connection_;
0:   java.sql.SQLException exceptionThrownOnStoredProcInvocation_;
0:   boolean messageTextRetrievedContainsTokensOnly_ = true;
1: 
0:   // data corresponding to SQLCA fields
0:   protected int      sqlCode_;        // SQLCODE
0:   private String     sqlErrmc_;       // A string with all error tokens delimited by sqlErrmcDelimiter
0:   protected String[] sqlErrmcTokens_; // A string array with each element
0:   // contain an error token
0:   protected String   sqlErrp_;        // function name issuing error
0:   protected int[]    sqlErrd_;        // 6 diagnostic Information
0:   protected char[]   sqlWarn_;        // 11 warning Flags
0:   protected String   sqlState_;       // SQLSTATE
1: 
0:   // raw sqlca data fields before unicode conversion
0:   protected byte[] sqlErrmcBytes_;
0:   protected byte[] sqlErrpBytes_;
0:   protected byte[] sqlWarnBytes_;
0:   protected byte[] sqlStateBytes_;
1: 
0:   protected int ccsid_;
0:   protected int sqlErrmcCcsid_;
0:   protected boolean containsSqlcax_ = true;
0:   protected long rowsetRowCount_;
1: 
0:   //public static final String sqlErrmcDelimiter = "\u00FF";
0:   private static final String sqlErrmcDelimiter__ = ";";
1: 
0:   // JDK stack trace calls e.getMessage(), so we must set some state on the sqlca that says return tokens only.
0:   private boolean returnTokensOnlyInMessageText_ = false;
1: 
0:   transient private final Agent agent_;
1: 
0:   private String cachedMessage;
1: 
0:   protected Sqlca (org.apache.derby.client.am.Connection connection)
0:   {
0:     connection_ = connection;
0:     agent_ = connection_ != null ? connection_.agent_ : null;
0:   }
1: 
0:   void returnTokensOnlyInMessageText (boolean returnTokensOnlyInMessageText)
0:   {
0:     returnTokensOnlyInMessageText_ = returnTokensOnlyInMessageText;
0:   }
1: 
0:   synchronized public int getSqlCode ()
0:   {
0:     return sqlCode_;
0:   }
1: 
0:   synchronized public String getSqlErrmc()
0:   {
0:     if (sqlErrmc_ != null)
0:       return sqlErrmc_;
1: 
0:     // sqlErrmc string is dependent on sqlErrmcTokens array having been built
0:     if (sqlErrmcTokens_ == null)
0:       getSqlErrmcTokens();
1: 
0:     // sqlErrmc will be build only if sqlErrmcTokens has been build.
0:     // Otherwise, a null string will be returned.
0:     if (sqlErrmcTokens_ == null)
0:       return null;
1: 
0:     // create 0-length String if no tokens
0:     if (sqlErrmcTokens_.length == 0) {
0:       sqlErrmc_ = "";
0:       return sqlErrmc_;
0:     }
1: 
0:     // concatenate tokens with sqlErrmcDelimiter delimiters into one String
0:     StringBuffer buffer = new StringBuffer();
0:     int indx;
0:     for (indx=0; indx < sqlErrmcTokens_.length-1; indx++) {
0:       buffer.append (sqlErrmcTokens_[indx]);
0:       buffer.append (sqlErrmcDelimiter__);
0:     }
0:     // add the last token
0:     buffer.append (sqlErrmcTokens_[indx]);
1: 
0:     // save as a string
0:     sqlErrmc_ = buffer.toString();
0:     return sqlErrmc_;
0:   }
1: 
0:   synchronized public String[] getSqlErrmcTokens ()
0:   {
0:     if (sqlErrmcTokens_ != null)
0:       return sqlErrmcTokens_;
1: 
0:     // processSqlErrmcTokens handles null sqlErrmcBytes_ case
0:     sqlErrmcTokens_ = processSqlErrmcTokens (sqlErrmcBytes_);
0:     return sqlErrmcTokens_;
0:   }
1: 
0:   synchronized public String getSqlErrp()
0:   {
0:     if (sqlErrp_ != null)
0:       return sqlErrp_;
1: 
0:     if (sqlErrpBytes_ == null)
0:       return null;
1: 
0:     try {
0:       sqlErrp_ = bytes2String (sqlErrpBytes_,
0:                                0,
0:                                sqlErrpBytes_.length
0:                                );
0:       return sqlErrp_;
0:     }
0:     catch (java.io.UnsupportedEncodingException e) {
0:       // leave sqlErrp as null.
0:       return null;
0:     }
0:   }
1: 
0:   public int[] getSqlErrd()
0:   {
0:     if (sqlErrd_ != null)
0:       return sqlErrd_;
1: 
0:     sqlErrd_ = new int[6]; // create an int array.
0:     return sqlErrd_;
0:   }
1: 
0:   synchronized public char[] getSqlWarn()
0:   {
0:     if (sqlWarn_ != null)
0:       return sqlWarn_;
1: 
0:     try {
0:       if (sqlWarnBytes_ == null)
0:         sqlWarn_ = new char[] {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '}; // 11 blank.
0:       else
0:         sqlWarn_ = bytes2String (sqlWarnBytes_, 0, sqlWarnBytes_.length ).toCharArray();
0:       return sqlWarn_;
0:     }
0:     catch (java.io.UnsupportedEncodingException e) {
0:       sqlWarn_ = new char[] {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '}; // 11 blank.
0:       return sqlWarn_;
0:     }
0:   }
1: 
0:   synchronized public String getSqlState()
0:   {
0:     if (sqlState_ != null)
0:       return sqlState_;
1: 
0:     if (sqlStateBytes_ == null)
0:       return null;
1: 
0:     try {
0:       sqlState_ = bytes2String (sqlStateBytes_,
0:                                 0,
0:                                 sqlStateBytes_.length
0:                                 );
0:       return sqlState_;
0:     }
0:     catch (java.io.UnsupportedEncodingException e) {
0:       // leave sqlState as null.
0:       return null;
0:     }
0:   }
1: 
0:   // Gets the formatted message, can throw an exception.
0:   synchronized public String getMessage () throws SqlException
0:   {
0:     // should this be traced to see if we are calling a stored proc?
0:     if (cachedMessage != null) return cachedMessage;
1: 
0:       if (connection_ == null || connection_.isClosedX() || returnTokensOnlyInMessageText_)
0:         return getUnformattedMessage();
1: 
0:     CallableStatement cs = null;
0:     synchronized (connection_) {
0:       try {
0:       cs = connection_.prepareMessageProc ("call SYSIBM.SQLCAMESSAGE(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
1: 
0:       // SQLCode: SQL return code.
0:         cs.setIntX (1, getSqlCode());
0:       // SQLErrml: Length of SQL error message tokens.
0:         cs.setShortX (2, (short) ((getSqlErrmc() != null)?getSqlErrmc().length():0));
0:       // SQLErrmc: SQL error message tokens as a String (delimited by semicolon ";").
0:         cs.setStringX (3, getSqlErrmc());
0:       // SQLErrp: Product signature.
0:         cs.setStringX (4, getSqlErrp());
0:       // SQLErrd: SQL internal error code.
0:         cs.setIntX (5,  getSqlErrd()[0]);
0:         cs.setIntX (6,  getSqlErrd()[1]);
0:         cs.setIntX (7,  getSqlErrd()[2]);
0:         cs.setIntX (8,  getSqlErrd()[3]);
0:         cs.setIntX (9,  getSqlErrd()[4]);
0:         cs.setIntX (10, getSqlErrd()[5]);
0:       // SQLWarn: SQL warning flags.
0:         cs.setStringX (11, new String (getSqlWarn()));
0:       // SQLState: standard SQL state.
0:         cs.setStringX (12, getSqlState());
0:       // MessageFileName: Not used by our driver, so set to null.
0:         cs.setStringX (13, null);
0:       // Locale: language preference requested for the return error message.
0:         cs.setStringX (14, java.util.Locale.getDefault().toString());
0:         // server could return a locale different from what we requested
0:         cs.registerOutParameterX (14, java.sql.Types.VARCHAR);
0:       // Message: error message returned from SQLCAMessage stored procedure.
0:         cs.registerOutParameterX (15, java.sql.Types.LONGVARCHAR);
0:       // RCode: return code from SQLCAMessage stored procedure.
0:         cs.registerOutParameterX (16, java.sql.Types.INTEGER);
0:         cs.executeX();
1: 
0:         if (cs.getIntX(16) == 0) {
0:           // Return the message text.
0:           messageTextRetrievedContainsTokensOnly_ = false;
0:           String message = cs.getStringX (15);
0:           cachedMessage = message;
0:           return message;
0:         } else {
0:           // Stored procedure can't return a valid message text, so we return
0: 		  // unformated exception
0:           return getUnformattedMessage();
0:         }
0:     }
0:     finally {
0:         if (cs != null) try { cs.closeX(); } catch (java.sql.SQLException doNothing) {}
0:       }
0:     }
0:   }
1: 
0:   // May or may not get the formatted message depending upon datasource directives.  cannot throw exeption.
0:   public synchronized String getJDBCMessage ()
0:   {
0:     // The transient connection_ member will only be null if the Sqlca has been deserialized
0:     if (connection_ != null && connection_.retrieveMessageText_) {
0:       try {
0:         return getMessage();
0:       }
0:       catch (SqlException e) { 
0:         // Invocation of stored procedure fails, so we return error message tokens directly.
0:         exceptionThrownOnStoredProcInvocation_ = e;
0:         chainDeferredExceptionsToAgentOrAsConnectionWarnings ((SqlException) e);
0:         return getUnformattedMessage ();
0:       }
0:     }
0:     else
0:       return getUnformattedMessage ();
0:   }
1: 
0:   private String getUnformattedMessage ()
0:   { return "DERBY SQL error: SQLCODE: " + getSqlCode() + ", SQLSTATE: " + getSqlState() + ", SQLERRMC: " + getSqlErrmc(); }
1: 
0:   private void chainDeferredExceptionsToAgentOrAsConnectionWarnings (SqlException e)
0:   {
0:     SqlException current = e;
0:     while (current != null) {
0:       SqlException next = (SqlException) current.getNextException();
0:       current = current.copyAsUnchainedSQLException (agent_.logWriter_);
0:       if (current.getErrorCode() == -440) {
0:         SqlWarning warningForStoredProcFailure = new SqlWarning (agent_.logWriter_,
0:           " Unable to obtain message text from server." +
0:           " See chained exception." +
0:           " The stored procedure SYSIBM.SQLCAMESSAGE is not installed on server." +
0:           " Contact your DBA.");
0:         warningForStoredProcFailure.setNextException (current);
0:         connection_.accumulate440WarningForMessageProcFailure (warningForStoredProcFailure);
0:       }
0:       else if (current.getErrorCode() == -444) {
0:         SqlWarning warningForStoredProcFailure = new SqlWarning (agent_.logWriter_,
0:           " Unable to obtain message text from server." +
0:           " See chained exception." +
0:           " The stored procedure SYSIBM.SQLCAMESSAGE cannot be accessed on the server." +
0:           " Contact your DBA.");
0:         warningForStoredProcFailure.setNextException (current);
0:         connection_.accumulate444WarningForMessageProcFailure (warningForStoredProcFailure);
0:       }
0:       else {
0:         agent_.accumulateDeferredException (current);
0:       }
0:       current = next;
0:     }
0:   }
1: 
0:   public boolean includesSqlCode (int[] codes)
0:   {
0:     for (int i=0; i<codes.length; i++) {
0:       if (codes[i] == getSqlCode()) return true;
0:     }
0:     return false;
0:   }
0:   // ------------------- helper methods ----------------------------------------
1: 
0:   private String[] processSqlErrmcTokens (byte[] tokenBytes)
0:   {
0:     if (tokenBytes == null)
0:       return null;
1: 
0:     // create 0-length String tokens array if tokenBytes is 0-length
0:     int length = tokenBytes.length;
0:     if (length == 0)
0:       return new String[0];
1: 
0:     try {
0:       // tokenize and convert tokenBytes
0:       java.io.ByteArrayOutputStream buffer = new java.io.ByteArrayOutputStream();
0:       java.util.LinkedList tokens = new java.util.LinkedList();
1: 
0:       // parse the error message tokens
0:       for (int index=0; index<length-1; index++) {
1: 
0:        // non-delimiter - continue to write into buffer
0:        if (tokenBytes[index] != -1)  // -1 is the delimiter '\xFF'
0:          buffer.write (tokenBytes[index]);
1: 
0:        // delimiter - convert current token and add to list
0:        else {
0:          tokens.add (bytes2String (buffer.toByteArray(), 0, buffer.size()));
0:          buffer.reset();
0:        }
0:       }
1: 
0:       int lastIndex = length-1;
0:       // check for last byte not being a delimiter, i.e. part of last token
0:       if (tokenBytes[lastIndex] != -1) {
0:        // write the last byte
0:        buffer.write (tokenBytes[lastIndex]);
0:        // convert the last token and add to list
0:        tokens.add (bytes2String (buffer.toByteArray(), 0, buffer.size()));
0:       }
1: 
0:       // last byte is delimiter implying an empty String for last token
0:       else {
0:        // convert current token, if one exists, and add to list
0:        if (lastIndex != 0)
0:          tokens.add (bytes2String (buffer.toByteArray(), 0, buffer.size()));
0:        // last token is an empty String
0:        tokens.add ("");
0:       }
1: 
0:       // create the String array and fill it with tokens.
0:       String[] tokenStrings = new String[tokens.size()];
1: 
0:       java.util.Iterator iterator = tokens.iterator();
0:       for (int i = 0; iterator.hasNext(); i++)
0:        tokenStrings[i] = (String) iterator.next();
1: 
0:       return tokenStrings;
0:     }
0:     catch (java.io.UnsupportedEncodingException e) {
0:       return null;
0:     }
0:   }
1: 
0:   private String bytes2String (byte[] bytes, int offset, int length )
0:     throws java.io.UnsupportedEncodingException
0:   {
0:       return new String (bytes, offset, length);
0:   }
1: 
0:   public int getUpdateCount ()
0:   {
0:     if (sqlErrd_ == null)
0:       return 0;
0:     return sqlErrd_[2];
0:   }
1: 
0:   public long getRowCount () throws org.apache.derby.client.am.DisconnectException
0:   {
0:     return ((long)sqlErrd_[0]<<32) + sqlErrd_[1];
0:   }
1: 
0:   public void setContainsSqlcax (boolean containsSqlcax)
0:   {
0:     containsSqlcax_ = containsSqlcax;
0:   }
1: 
0:   public boolean containsSqlcax ()
0:   {
0:     return containsSqlcax_;
0:   }
1: 
0:   public void resetRowsetSqlca (org.apache.derby.client.am.Connection connection,
0:                                 int sqlCode,
0:                                 byte[] sqlStateBytes,
0:                                 byte[] sqlErrpBytes,
0:                                 int ccsid)
0:   {
0:     connection_ = connection;
0:     sqlCode_ = sqlCode;
0:     sqlStateBytes_ = sqlStateBytes;
0:     sqlErrpBytes_ = sqlErrpBytes;
0:     ccsid_ = ccsid;
0:   }
1: 
0:   public void setRowsetRowCount (long rowCount)
0:   {
0:     rowsetRowCount_ = rowCount;
0:   }
1: 
0:   public long getRowsetRowCount ()
0:   {
0:     return rowsetRowCount_;
0:   }
0: }
1: 
============================================================================