1:042f338: /*
3:042f338: 
1:042f338:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.ConnectionMethodsTest
1:042f338: 
1:042f338:    Licensed to the Apache Software Foundation (ASF) under one or more
1:042f338:    contributor license agreements.  See the NOTICE file distributed with
1:042f338:    this work for additional information regarding copyright ownership.
1:042f338:    The ASF licenses this file to You under the Apache License, Version 2.0
1:042f338:    (the "License"); you may not use this file except in compliance with
1:042f338:    the License.  You may obtain a copy of the License at
1:042f338: 
1:042f338:       http://www.apache.org/licenses/LICENSE-2.0
1:042f338: 
1:042f338:    Unless required by applicable law or agreed to in writing, software
1:042f338:    distributed under the License is distributed on an "AS IS" BASIS,
1:042f338:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:042f338:    See the License for the specific language governing permissions and
1:042f338:    limitations under the License.
1:042f338: 
1:042f338:  */
1:042f338: 
1:042f338: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:042f338: 
1:042f338: import java.io.FileInputStream;
1:042f338: import java.io.FileNotFoundException;
1:042f338: import java.io.IOException;
1:042f338: import java.io.InputStream;
1:1ae02c9: import java.io.OutputStream;
1:1ae02c9: import java.security.AccessController;
1:1ae02c9: import java.security.PrivilegedActionException;
1:1ae02c9: import java.security.PrivilegedExceptionAction;
1:042f338: import java.sql.Blob;
1:042f338: import java.sql.Clob;
1:1ae02c9: import java.sql.Connection;
1:1ae02c9: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.ResultSet;
1:1ae02c9: import java.sql.SQLException;
1:e749e12: import java.sql.SQLFeatureNotSupportedException;
1:1ae02c9: import java.sql.Statement;
1:1ae02c9: import java.util.ArrayList;
1:1ae02c9: import java.util.concurrent.Executor;
1:f8cb3d7: import javax.sql.ConnectionPoolDataSource;
1:f8cb3d7: import javax.sql.PooledConnection;
1:f8cb3d7: import javax.sql.XAConnection;
1:f8cb3d7: import javax.sql.XADataSource;
1:1ae02c9: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:042f338: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:f8cb3d7: import org.apache.derbyTesting.junit.J2EEDataSource;
1:042f338: import org.apache.derbyTesting.junit.SupportFilesSetup;
2:042f338: import org.apache.derbyTesting.junit.TestConfiguration;
1:042f338: 
1:042f338: /**
1:042f338:  * This class is used to test the implementations of the JDBC 4.0 methods
1:042f338:  * in the Connection interface
1:042f338:  */
1:795f705: public class ConnectionMethodsTest extends Wrapper41Test
1:795f705: {
1:f8cb3d7:     public  static  final   String  CLOSED_CONNECTION = "08003";
1:f8cb3d7:     
1:795f705:     ///////////////////////////////////////////////////////////////////////
1:795f705:     //
1:795f705:     // NESTED CLASSES
1:795f705:     //
1:795f705:     ///////////////////////////////////////////////////////////////////////
1:795f705: 
1:795f705:     /** An Executor which runs in the current thread. */
1:795f705:     public static   final   class DirectExecutor implements Executor
1:795f705:     {
1:795f705:         public void execute(Runnable r)
1:795f705:         {
1:795f705:             r.run();
1:795f705:         }
1:795f705:     }
1:795f705: 
1:795f705:     ///////////////////////////////////////////////////////////////////////
1:795f705:     //
1:795f705:     // STATE
1:795f705:     //
1:795f705:     ///////////////////////////////////////////////////////////////////////
1:795f705: 
1:042f338:     FileInputStream is;
1:042f338: 
1:795f705:     ///////////////////////////////////////////////////////////////////////
1:795f705:     //
1:795f705:     // CONSTRUCTORS
1:795f705:     //
1:795f705:     ///////////////////////////////////////////////////////////////////////
1:795f705: 
1:042f338:     public ConnectionMethodsTest(String name) {
1:042f338:         super(name);
1:042f338:     }
1:042f338: 
1:795f705:     ///////////////////////////////////////////////////////////////////////
1:795f705:     //
1:795f705:     // JUnit SETUP
1:795f705:     //
1:795f705:     ///////////////////////////////////////////////////////////////////////
1:795f705: 
1:042f338:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("ConnectionMethodsTest");
1:042f338: 
1:042f338:         suite.addTest(baseSuite("ConnectionMethodsTest:embedded"));
1:042f338: 
1:042f338:         suite.addTest(
1:042f338:                 TestConfiguration.clientServerDecorator(
1:042f338:                 baseSuite("ConnectionMethodsTest:client")));
1:042f338:         return suite;
1:042f338:     }
1:042f338: 
1:042f338:     public static Test baseSuite(String name) {
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite(ConnectionMethodsTest.class, name);
1:1ae02c9: 
1:042f338:         Test test = new SupportFilesSetup(suite, new String[] {"functionTests/testData/ConnectionMethods/short.txt"} );
1:042f338:         return new CleanDatabaseTestSetup(test) {
1:042f338:             protected void decorateSQL(Statement s) throws SQLException {
1:042f338:                 s.execute("create table clobtable2(n int,clobcol CLOB)");
1:042f338:                 s.execute("create table blobtable2(n int,blobcol BLOB)");
1:795f705:                 s.execute("create table abort_table(a int)");
1:1837822:                 s.execute("create schema foo");
1:1837822:                 s.execute("create table foo.set_schema_table( a int )");
1:042f338:             }
1:042f338:         };
1:042f338:     }
1:795f705:     
1:795f705:     ///////////////////////////////////////////////////////////////////////
1:795f705:     //
1:795f705:     // TEST CASES
1:795f705:     //
1:795f705:     ///////////////////////////////////////////////////////////////////////
1:795f705: 
1:e749e12:     /**
1:042f338:      * Test the createClob method implementation in the Connection interface
1:042f338:      *
1:042f338:      * @exception SQLException, FileNotFoundException, Exception if error occurs
1:e749e12:      */
1:042f338:     public void testCreateClob() throws   SQLException,
1:042f338:             FileNotFoundException, IOException,
1:042f338:             Exception{
1:042f338: 
1:042f338:         Connection conn = getConnection();
1:042f338:         int b, c;
1:042f338:         Clob clob;
1:042f338: 
1:042f338:         Statement s = createStatement();
1:042f338: 
1:042f338:         PreparedStatement ps =
1:042f338:                 prepareStatement("insert into clobtable2 (n, clobcol)" + " values(?,?)");
1:042f338:         ps.setInt(1,1000);
1:042f338:         clob = conn.createClob();
1:042f338: 
1:042f338:         try {
1:0f26c83:             is = AccessController.doPrivileged(
1:0f26c83:                     new PrivilegedExceptionAction<FileInputStream>() {
1:0f26c83:                 public FileInputStream run() throws FileNotFoundException {
1:042f338:                     return new FileInputStream("extin/short.txt");
1:042f338:                 }
1:042f338:             });
1:042f338:         } catch (PrivilegedActionException e) {
1:042f338:             // e.getException() should be an instance of FileNotFoundException,
1:042f338:             // as only "checked" exceptions will be "wrapped" in a
1:042f338:             // PrivilegedActionException.
1:042f338:             throw (FileNotFoundException) e.getException();
1:042f338:         }
1:042f338:         OutputStream os = clob.setAsciiStream(1);
1:0f26c83:         ArrayList<Integer> beforeUpdateList = new ArrayList<Integer>();
1:042f338: 
1:042f338:         c = is.read();
1:042f338:         while(c>0) {
1:042f338:             os.write(c);
1:042f338:             beforeUpdateList.add(c);
1:042f338:             c = is.read();
1:042f338:         }
1:042f338:         ps.setClob(2, clob);
1:042f338:         ps.executeUpdate();
1:042f338: 
1:042f338:         Statement stmt = createStatement();
1:042f338:         ResultSet rs =
1:042f338:                 stmt.executeQuery("select clobcol from clobtable2 where n = 1000");
1:042f338:         assertTrue(rs.next());
1:042f338: 
1:042f338:         clob = rs.getClob(1);
1:042f338:         assertEquals(beforeUpdateList.size(), clob.length());
1:042f338: 
1:042f338:         //Get the InputStream from this Clob.
1:042f338:         InputStream in = clob.getAsciiStream();
1:0f26c83:         ArrayList<Integer> afterUpdateList = new ArrayList<Integer>();
1:042f338: 
1:042f338:         b = in.read();
1:042f338: 
1:042f338:         while (b > -1) {
1:042f338:             afterUpdateList.add(b);
1:042f338:             b = in.read();
1:042f338:         }
1:042f338: 
1:042f338:         assertEquals(beforeUpdateList.size(), afterUpdateList.size());
1:042f338: 
1:042f338:         //Now check if the two InputStreams
1:042f338:         //match
1:042f338:         for (int i = 0; i < clob.length(); i++) {
1:042f338:             assertEquals(beforeUpdateList.get(i), afterUpdateList.get(i));
1:042f338:         }
1:042f338: 
1:042f338:         os.close();
1:042f338:         is.close();
1:042f338: 
1:042f338:     }
1:795f705:     /**
1:042f338:      * Test the createBlob method implementation in the Connection interface
1:042f338:      *
1:042f338:      * @exception  SQLException, FileNotFoundException, Exception if error occurs
1:795f705:      */
1:042f338:     public void testCreateBlob() throws   SQLException,
1:042f338:             FileNotFoundException,
1:042f338:             IOException,
1:042f338:             Exception{
1:042f338: 
1:042f338:         Connection conn = getConnection();
1:042f338:         int b, c;
1:042f338:         Blob blob;
1:042f338: 
1:042f338:         Statement s = createStatement();
1:042f338:         PreparedStatement ps =
1:042f338:                 prepareStatement("insert into blobtable2 (n, blobcol)" + " values(?,?)");
1:042f338:         ps.setInt(1,1000);
1:042f338:         blob = conn.createBlob();
1:042f338: 
1:042f338:         try {
1:0f26c83:             is = AccessController.doPrivileged(
1:0f26c83:                     new PrivilegedExceptionAction<FileInputStream>() {
1:0f26c83:                 public FileInputStream run() throws FileNotFoundException {
1:042f338:                     return new FileInputStream("extin/short.txt");
1:042f338:                 }
1:042f338:             });
1:042f338:         } catch (PrivilegedActionException e) {
1:042f338:             // e.getException() should be an instance of FileNotFoundException,
1:042f338:             // as only "checked" exceptions will be "wrapped" in a
1:042f338:             // PrivilegedActionException.
1:042f338:             throw (FileNotFoundException) e.getException();
1:042f338:         }
1:042f338: 
1:042f338:         OutputStream os = blob.setBinaryStream(1);
1:0f26c83:         ArrayList<Integer> beforeUpdateList = new ArrayList<Integer>();
1:042f338: 
1:042f338:         int actualLength = 0;
1:042f338:         c = is.read();
1:042f338:         while(c>0) {
1:042f338:             os.write(c);
1:042f338:             beforeUpdateList.add(c);
1:042f338:             c = is.read();
1:042f338:             actualLength ++;
1:042f338:         }
1:042f338:         ps.setBlob(2, blob);
1:042f338:         ps.executeUpdate();
1:042f338: 
1:042f338:         Statement stmt = createStatement();
1:042f338:         ResultSet rs =
1:042f338:                 stmt.executeQuery("select blobcol from blobtable2 where n = 1000");
1:042f338:         assertTrue(rs.next());
1:042f338: 
1:042f338:         blob = rs.getBlob(1);
1:042f338:         assertEquals(beforeUpdateList.size(), blob.length());
1:042f338: 
1:042f338:         //Get the InputStream from this Blob.
1:042f338:         InputStream in = blob.getBinaryStream();
1:0f26c83:         ArrayList<Integer> afterUpdateList = new ArrayList<Integer>();
1:042f338: 
1:042f338:         b = in.read();
1:042f338: 
1:042f338:         while (b > -1) {
1:042f338:             afterUpdateList.add(b);
1:042f338:             b = in.read();
1:042f338:         }
1:042f338: 
1:042f338:         assertEquals(beforeUpdateList.size(), afterUpdateList.size());
1:042f338: 
1:042f338:         //Now check if the two InputStreams
1:042f338:         //match
1:042f338:         for (int i = 0; i < blob.length(); i++) {
1:042f338:             assertEquals(beforeUpdateList.get(i), afterUpdateList.get(i));
1:042f338:         }
1:042f338: 
1:042f338:         os.close();
1:042f338:         is.close();
1:042f338:     }
1:042f338:     /**
1:042f338:      * Test the Connection.isValid method
1:042f338:      *
1:042f338:      * @exception SQLException, Exception if error occurs
1:042f338:      */
1:042f338:     public void testConnectionIsValid() throws SQLException, Exception {
1:042f338:        /*
1:042f338:         * Test illegal parameter values
1:042f338:         */
1:042f338:         Connection conn = getConnection();
1:042f338:         try {
1:042f338:             conn.isValid(-1);  // Negative timeout
1:042f338:             fail("FAIL: isValid(-1): Invalid argument execption not thrown");
1:042f338: 
1:042f338:         } catch (SQLException e) {
1:042f338:             assertSQLState("XJ081", e);
1:042f338:         }
1:042f338: 
1:042f338:        /*
1:042f338:         * Test with no timeout
1:042f338:         */
1:042f338:         if (!conn.isValid(0)) {
1:042f338:             fail("FAIL: isValid(0): returned false");
1:042f338:         }
1:042f338: 
1:042f338:        /*
1:ad188f4:         * Test with a valid timeout.
1:ad188f4:         * The value is set very large; we expect
1:ad188f4:         * to complete and succeed much sooner. See DERBY-5912
1:042f338:         */
1:ad188f4:         if (!conn.isValid(200)) {
1:ad188f4:             fail("FAIL: isValid(200): returned false");
1:042f338:         }
1:042f338: 
1:042f338:        /*
1:042f338:         * Test on a closed connection
1:042f338:         */
1:042f338:         try {
1:042f338:             conn.close();
1:042f338:         } catch (SQLException e) {
1:042f338:             assertSQLState("08003", e);
1:042f338:         }
1:042f338: 
1:042f338:         if (conn.isValid(0)) {
1:042f338:             fail("FAIL: isValid(0) on closed connection: returned true");
1:042f338:         }
1:042f338: 
1:042f338:         /* Open a new connection and test it */
1:042f338:         conn = getConnection();
1:042f338:         if (!conn.isValid(0)) {
1:042f338:             fail("FAIL: isValid(0) on open connection: returned false");
1:042f338:         }
1:042f338: 
1:042f338:        /*
1:042f338:         * Test on stopped database
1:042f338:         */
1:042f338:         TestConfiguration.getCurrent().shutdownDatabase();
1:042f338: 
1:042f338:         /* Test if that connection is not valid */
1:042f338:         if (conn.isValid(0)) {
1:042f338:             fail("FAIL: isValid(0) on stopped database: returned true");
1:042f338:         }
1:042f338: 
1:042f338:         /* Start the database by getting a new connection to it */
1:042f338:         conn = getConnection();
1:042f338: 
1:042f338:         /* Check that a new connection to the newly started database is valid */
1:042f338:         if (!conn.isValid(0)) {
1:042f338:             fail("FAIL: isValid(0) on new connection: " +
1:042f338:                     "returned false");
1:042f338:         }
1:042f338: 
1:042f338:        /*
1:042f338:         * Test on stopped Network Server client
1:042f338:         */
1:042f338:         if ( !usingEmbedded() ) {
1:042f338: 
1:042f338:             TestConfiguration.getCurrent().stopNetworkServer();
1:042f338: 
1:042f338:             /* Test that the connection is not valid */
1:042f338:             if (conn.isValid(0)) {
1:042f338:                 fail("FAIL: isValid(0) on stopped database: returned true");
1:042f338:             }
1:042f338: 
1:042f338:            /*
1:042f338:             * Start the network server and get a new connection and check that
1:042f338:             * the new connection is valid.
1:042f338:             */
1:042f338:             TestConfiguration.getCurrent().startNetworkServer();
1:042f338: 
1:042f338:             // Get a new connection to the database
1:042f338:             conn = getConnection();
1:042f338: 
1:042f338:             /* Check that a new connection to the newly started Derby is valid */
1:042f338:             if (!conn.isValid(0)) {
1:042f338:                 fail("FAIL: isValid(0) on new connection: returned false");
1:042f338:             }
1:042f338:         }
1:042f338:     }
1:042f338:     
1:042f338:     /**
1:f8cb3d7:      * Test the JDBC 4.1 Connection.abort(Executor) method on physical connections.
1:042f338:      */
1:f8cb3d7:     public void testAbortPhysical() throws Exception
1:e749e12:     {
1:795f705:         //
1:795f705:         // In order to run this test, a special permission must be granted to
1:795f705:         // the jar file containing this method.
1:795f705:         //
1:795f705:         if ( !TestConfiguration.loadingFromJars() ) { return; }
1:795f705: 
1:795f705:         Connection conn0 = openUserConnection( "user0");
1:f8cb3d7:         Connection conn1 = openUserConnection( "user1");
1:f8cb3d7:         Connection conn2 = openUserConnection( "user2");
1:f8cb3d7: 
1:f8cb3d7:         abortVetter( conn0, conn1, conn2 );
1:f8cb3d7:     }
1:f8cb3d7:     
1:f8cb3d7:     /**
1:f8cb3d7:      * Test the JDBC 4.1 Connection.abort(Executor) method on pooled connections.
1:f8cb3d7:      */
1:f8cb3d7:     public void testAbortPooled() throws Exception
1:1837822:     {
1:f8cb3d7:         //
1:f8cb3d7:         // In order to run this test, a special permission must be granted to
1:f8cb3d7:         // the jar file containing this method.
1:f8cb3d7:         //
1:f8cb3d7:         if ( !TestConfiguration.loadingFromJars() ) { return; }
1:f8cb3d7: 
1:f8cb3d7:         ConnectionPoolDataSource cpDs =
1:f8cb3d7:                 J2EEDataSource.getConnectionPoolDataSource();
1:f8cb3d7:         
1:f8cb3d7:         PooledConnection conn0 = getPooledConnection( cpDs, "user0");
1:f8cb3d7:         PooledConnection conn1 = getPooledConnection( cpDs, "user1");
1:f8cb3d7:         PooledConnection conn2 = getPooledConnection( cpDs, "user2");
1:f8cb3d7: 
1:f8cb3d7:         abortVetter( conn0.getConnection(), conn1.getConnection(), conn2.getConnection() );
1:f8cb3d7: 
1:f8cb3d7:         // verify that the underlying physical connection is closed
1:f8cb3d7:         try {
1:f8cb3d7:             conn1.getConnection();
1:f8cb3d7:             fail( "Expected physical connection to be closed." );
1:f8cb3d7:         }
1:f8cb3d7:         catch (SQLException se)
1:f8cb3d7:         {
1:1837822:             assertSQLState( CLOSED_CONNECTION, se );
1:f8cb3d7:         }
1:f8cb3d7:     }
1:f8cb3d7:     private PooledConnection    getPooledConnection
1:f8cb3d7:         ( ConnectionPoolDataSource cpDs, String userName ) throws Exception
1:f8cb3d7:     {
1:f8cb3d7:         return cpDs.getPooledConnection( userName, getTestConfiguration().getPassword( userName ) );
1:f8cb3d7:     }
1:f8cb3d7:     
1:f8cb3d7:     /**
1:f8cb3d7:      * Test the JDBC 4.1 Connection.abort(Executor) method on XA connections.
1:f8cb3d7:      */
1:f8cb3d7:     public void testAbortXA() throws Exception
1:f8cb3d7:     {
1:f8cb3d7:         //
1:f8cb3d7:         // In order to run this test, a special permission must be granted to
1:f8cb3d7:         // the jar file containing this method.
1:f8cb3d7:         //
1:f8cb3d7:         if ( !TestConfiguration.loadingFromJars() ) { return; }
1:f8cb3d7: 
1:f8cb3d7:         XADataSource xads = J2EEDataSource.getXADataSource();
1:f8cb3d7:         
1:f8cb3d7:         XAConnection conn0 = getXAConnection( xads, "user0");
1:f8cb3d7:         XAConnection conn1 = getXAConnection( xads, "user1");
1:f8cb3d7:         XAConnection conn2 = getXAConnection( xads, "user2");
1:f8cb3d7: 
1:f8cb3d7:         abortVetter( conn0.getConnection(), conn1.getConnection(), conn2.getConnection() );
1:f8cb3d7: 
1:f8cb3d7:         // verify that the underlying physical connection is closed
1:f8cb3d7:         try {
1:f8cb3d7:             conn1.getConnection();
1:f8cb3d7:             fail( "Expected physical connection to be closed." );
1:f8cb3d7:         }
1:f8cb3d7:         catch (SQLException se)
1:f8cb3d7:         {
1:1837822:             assertSQLState( CLOSED_CONNECTION, se );
1:f8cb3d7:         }
1:f8cb3d7:     }
1:f8cb3d7:     private XAConnection    getXAConnection
1:f8cb3d7:         ( XADataSource xads, String userName ) throws Exception
1:f8cb3d7:     {
1:f8cb3d7:         return xads.getXAConnection( userName, getTestConfiguration().getPassword( userName ) );
1:f8cb3d7:     }
1:f8cb3d7: 
1:f8cb3d7:     /**
1:f8cb3d7:      * Test the JDBC 4.1 Connection.abort(Executor) method.
1:f8cb3d7:      */
1:f8cb3d7:     public void abortVetter( Connection conn0, Connection conn1, Connection conn2 ) throws Exception
1:f8cb3d7:     {
1:f8cb3d7:         // NOP if called on a closed connection
1:795f705:         conn0.close();
1:795f705:         Wrapper41Conn   wrapper0 = new Wrapper41Conn( conn0 );
1:795f705:         wrapper0.abort( new DirectExecutor() );
1:795f705: 
1:795f705:         conn1.setAutoCommit( false );
1:795f705:         final   Wrapper41Conn   wrapper1 = new Wrapper41Conn( conn1 );
1:795f705: 
1:795f705:         // the Executor may not be null
1:795f705:         try {
1:795f705:             wrapper1.abort( null );
1:795f705:         }
1:795f705:         catch (SQLException se)
1:f8cb3d7:         {
1:795f705:             assertSQLState( "XCZ02", se );
1:795f705:         }
1:795f705: 
1:795f705:         PreparedStatement   ps = prepareStatement
1:795f705:             ( conn1, "insert into app.abort_table( a ) values ( 1 )" );
1:795f705:         ps.execute();
1:795f705:         ps.close();
1:2add32c:         
1:2add32c:         ps = prepareStatement( conn1, "select * from app.abort_table");
1:2add32c:         ResultSet rsconn1 = ps.executeQuery();
1:2add32c:         assertTrue(rsconn1.next());
1:2add32c:         rsconn1.close();
1:2add32c:         ps.close();
1:2add32c:         
1:2add32c:         
1:795f705: 
1:795f705:         // abort the connection
1:795f705:         try {
1:795f705:             //
1:795f705:             // This doPrivileged block absolves outer code blocks (like JUnit)
1:795f705:             // of the need to be granted SQLPermission( "callAbort" ). However,
1:795f705:             // derbyTesting.jar still needs that permission.
1:795f705:             //
1:795f705:             AccessController.doPrivileged
1:795f705:                 (
1:795f705:                  new PrivilegedExceptionAction<Object>()
1:795f705:                  {
1:795f705:                      public Object    run() throws Exception
1:795f705:                      {
1:795f705:                          DirectExecutor  executor = new DirectExecutor();
1:795f705:                          wrapper1.abort( executor );
1:795f705:                          return null;
1:795f705:                      }
1:795f705:                  }
1:795f705:                  );
1:795f705:         }
1:795f705:         catch (Exception e)
1:795f705:         {
1:795f705:             e.printStackTrace();
1:795f705:             //
1:795f705:             // We need to fail now. But the connection holds locks
1:795f705:             // which prevent our test apparatus from cleaning up.
1:795f705:             // We need to release those locks before failing.
1:795f705:             //
1:795f705:             conn1.rollback();
1:795f705:             fail( "Could not abort connection!" );
1:795f705:         }
1:795f705: 
1:795f705:         // verify that the connection is closed
1:795f705:         try {
1:795f705:             prepareStatement( conn1, "select * from sys.systables" );
1:795f705:             fail( "Connection should be dead!" );
1:795f705:         }
1:795f705:         catch (SQLException se)
1:795f705:         {
2:f8cb3d7:             assertSQLState( CLOSED_CONNECTION, se );
1:795f705:         }
1:795f705: 
1:795f705:         // verify that the changes were rolled back
1:795f705:         ps = prepareStatement( conn2, "select * from app.abort_table" );
1:795f705:         ResultSet   rs = ps.executeQuery();
1:795f705:         assertFalse( rs.next() );
1:795f705:         rs.close();
1:795f705:         ps.close();
1:795f705:         conn2.close();
1:795f705:     }
1:795f705:     
1:1837822:     /**
1:1837822:      * Test the JDBC 4.1 Connection.getSchema() and setSchema() methods.
1:1837822:      */
1:1837822:     public void testGetSetSchema() throws Exception
1:1837822:     {
1:e749e12:         Connection  conn = getConnection();
1:1837822:         println( "Testing get/setSchema() on a " + conn.getClass().getName() );
1:1837822:         Wrapper41Conn   wrapper = new Wrapper41Conn( conn );
1:1837822: 
1:1837822:         assertEquals( "APP", wrapper.getSchema() );
1:1837822:         try {
1:1837822:             prepareStatement( "select * from set_schema_table" );
1:e749e12:         }
1:1837822:         catch (SQLException se)
1:e749e12:         {
1:1837822:             assertSQLState( "42X05", se );
1:1837822:         }
1:1837822: 
1:1837822:         wrapper.setSchema( "FOO" );
1:1837822:         assertEquals( "FOO", wrapper.getSchema() );
1:1837822: 
1:1837822:         prepareStatement( "select * from set_schema_table" );
1:1837822: 
1:1837822:         try {
1:1837822:             wrapper.setSchema( "foo" );
1:1837822:             fail( "Should not have been able to change to a non-existent schema." );
1:1837822:         }
1:1837822:         catch (SQLException se)
1:1837822:         {
1:1837822:             assertSQLState( "42Y07", se );
1:1837822:         }
1:1837822: 
1:1837822:         conn.close();
1:1837822:         
1:1837822:         try {
1:1837822:             wrapper.setSchema( "APP" );
1:1837822:             fail( "Should fail on a closed connection." );
1:1837822:         }
1:1837822:         catch (SQLException se)
1:1837822:         {
1:e749e12:             assertSQLState( CLOSED_CONNECTION, se );
1:1837822:         }
1:1837822: 
1:1837822:         try {
1:1837822:             wrapper.getSchema();
1:1837822:             fail( "Should fail on a closed connection." );
1:1837822:         }
1:1837822:         catch (SQLException se)
1:1837822:         {
1:e749e12:             assertSQLState( CLOSED_CONNECTION, se );
1:1837822:         }
1:1837822: 
1:1837822:     }
1:1837822:     
1:042f338:     /**
1:e749e12:      * Test the JDBC 4.1 Connection.getNetworkTimeout() and setNetworkTimeout() methods.
1:042f338:      */
1:e749e12:     public void testGetSetNetworkTimeout() throws Exception
1:795f705:     {
1:1837822:         Connection  conn = getConnection();
1:e749e12:         println( "Testing get/setNetoworkTimeout() on a " + conn.getClass().getName() );
1:e749e12:         Wrapper41Conn   wrapper = new Wrapper41Conn( conn );
1:e749e12: 
1:e749e12:         try {
1:e749e12:             wrapper.getNetworkTimeout();
1:cb8f861:             fail( "Should raise an Unimplemented Feature exception." );
1:e749e12:         }
1:e749e12:         catch (SQLException se)
1:e749e12:         {
1:cb8f861:             assertEquals( SQLFeatureNotSupportedException.class.getName(), se.getClass().getName() );
1:e749e12:         }
1:e749e12: 
1:e749e12:         try {
1:e749e12:             wrapper.setNetworkTimeout( null, 3 );
1:cb8f861:             fail( "Should raise an Unimplemented Feature exception." );
1:e749e12:         }
1:e749e12:         catch (SQLException se)
1:e749e12:         {
1:cb8f861:             assertEquals( SQLFeatureNotSupportedException.class.getName(), se.getClass().getName() );
1:e749e12:         }
1:e749e12: 
1:e749e12:         // now close the connection
1:e749e12:         conn.close();
1:e749e12:         
1:e749e12:         try {
1:e749e12:             wrapper.getNetworkTimeout();
1:e749e12:             fail( "Should raise an Unimplemented Feature exception." );
1:e749e12:         }
1:e749e12:         catch (SQLException se)
1:e749e12:         {
1:e749e12:             assertEquals( SQLFeatureNotSupportedException.class.getName(), se.getClass().getName() );
1:e749e12:         }
1:e749e12:         
1:e749e12:         try {
1:e749e12:             wrapper.setNetworkTimeout( null, 3 );
1:e749e12:             fail( "Should raise an Unimplemented Feature exception." );
1:e749e12:         }
1:e749e12:         catch (SQLException se)
1:795f705:         {
1:e749e12:             assertEquals( SQLFeatureNotSupportedException.class.getName(), se.getClass().getName() );
1:e749e12:         }
1:1837822:     }
1:e749e12:     
1:042f338: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.io.OutputStream;
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.util.ArrayList;
1: import java.util.concurrent.Executor;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("ConnectionMethodsTest");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite(ConnectionMethodsTest.class, name);
1: 
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:ad188f4
/////////////////////////////////////////////////////////////////////////
1:         * Test with a valid timeout.
1:         * The value is set very large; we expect
1:         * to complete and succeed much sooner. See DERBY-5912
1:         if (!conn.isValid(200)) {
1:             fail("FAIL: isValid(200): returned false");
author:Lily Wei
-------------------------------------------------------------------------------
commit:2add32c
/////////////////////////////////////////////////////////////////////////
1:         
1:         ps = prepareStatement( conn1, "select * from app.abort_table");
1:         ResultSet rsconn1 = ps.executeQuery();
1:         assertTrue(rsconn1.next());
1:         rsconn1.close();
1:         ps.close();
1:         
1:         
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:cb8f861
/////////////////////////////////////////////////////////////////////////
1:             fail( "Should raise an Unimplemented Feature exception." );
1:             assertEquals( SQLFeatureNotSupportedException.class.getName(), se.getClass().getName() );
1:             fail( "Should raise an Unimplemented Feature exception." );
1:             assertEquals( SQLFeatureNotSupportedException.class.getName(), se.getClass().getName() );
commit:e749e12
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLFeatureNotSupportedException;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test the JDBC 4.1 Connection.getNetworkTimeout() and setNetworkTimeout() methods.
1:      */
1:     public void testGetSetNetworkTimeout() throws Exception
1:     {
1:         Connection  conn = getConnection();
1:         println( "Testing get/setNetoworkTimeout() on a " + conn.getClass().getName() );
1:         Wrapper41Conn   wrapper = new Wrapper41Conn( conn );
1: 
1:         try {
1:             wrapper.getNetworkTimeout();
1:             fail( "Should raise an Unimplemented Feature exception." );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertEquals( SQLFeatureNotSupportedException.class.getName(), se.getClass().getName() );
1:         }
1: 
1:         try {
1:             wrapper.setNetworkTimeout( null, 3 );
1:             fail( "Should raise an Unimplemented Feature exception." );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertEquals( SQLFeatureNotSupportedException.class.getName(), se.getClass().getName() );
1:         }
1: 
1:         // now close the connection
1:         conn.close();
1:         
1:         try {
1:             wrapper.getNetworkTimeout();
0:             fail( "Should object that the connection is closed." );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( CLOSED_CONNECTION, se );
1:         }
1:         
1:         try {
1:             wrapper.setNetworkTimeout( null, 3 );
0:             fail( "Should object that the connection is closed." );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( CLOSED_CONNECTION, se );
1:         }
1:     }
1:     
commit:1837822
/////////////////////////////////////////////////////////////////////////
1:                 s.execute("create schema foo");
1:                 s.execute("create table foo.set_schema_table( a int )");
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test the JDBC 4.1 Connection.getSchema() and setSchema() methods.
1:      */
1:     public void testGetSetSchema() throws Exception
1:     {
1:         Connection  conn = getConnection();
1:         println( "Testing get/setSchema() on a " + conn.getClass().getName() );
1:         Wrapper41Conn   wrapper = new Wrapper41Conn( conn );
1: 
1:         assertEquals( "APP", wrapper.getSchema() );
1:         try {
1:             prepareStatement( "select * from set_schema_table" );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( "42X05", se );
1:         }
1: 
1:         wrapper.setSchema( "FOO" );
1:         assertEquals( "FOO", wrapper.getSchema() );
1: 
1:         prepareStatement( "select * from set_schema_table" );
1: 
1:         try {
1:             wrapper.setSchema( "foo" );
1:             fail( "Should not have been able to change to a non-existent schema." );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( "42Y07", se );
1:         }
1: 
1:         conn.close();
1:         
1:         try {
1:             wrapper.setSchema( "APP" );
1:             fail( "Should fail on a closed connection." );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( CLOSED_CONNECTION, se );
1:         }
1: 
1:         try {
1:             wrapper.getSchema();
1:             fail( "Should fail on a closed connection." );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( CLOSED_CONNECTION, se );
1:         }
1: 
1:     }
1:     
commit:f8cb3d7
/////////////////////////////////////////////////////////////////////////
1: import javax.sql.ConnectionPoolDataSource;
1: import javax.sql.PooledConnection;
1: import javax.sql.XAConnection;
1: import javax.sql.XADataSource;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.J2EEDataSource;
/////////////////////////////////////////////////////////////////////////
1:     public  static  final   String  CLOSED_CONNECTION = "08003";
1:     
/////////////////////////////////////////////////////////////////////////
1:      * Test the JDBC 4.1 Connection.abort(Executor) method on physical connections.
1:     public void testAbortPhysical() throws Exception
/////////////////////////////////////////////////////////////////////////
1:         Connection conn1 = openUserConnection( "user1");
1:         Connection conn2 = openUserConnection( "user2");
1: 
1:         abortVetter( conn0, conn1, conn2 );
1:     }
1:     
1:     /**
1:      * Test the JDBC 4.1 Connection.abort(Executor) method on pooled connections.
1:      */
1:     public void testAbortPooled() throws Exception
1:     {
1:         //
1:         // In order to run this test, a special permission must be granted to
1:         // the jar file containing this method.
1:         //
1:         if ( !TestConfiguration.loadingFromJars() ) { return; }
1: 
1:         ConnectionPoolDataSource cpDs =
1:                 J2EEDataSource.getConnectionPoolDataSource();
1:         
1:         PooledConnection conn0 = getPooledConnection( cpDs, "user0");
1:         PooledConnection conn1 = getPooledConnection( cpDs, "user1");
1:         PooledConnection conn2 = getPooledConnection( cpDs, "user2");
1: 
1:         abortVetter( conn0.getConnection(), conn1.getConnection(), conn2.getConnection() );
1: 
1:         // verify that the underlying physical connection is closed
1:         try {
1:             conn1.getConnection();
1:             fail( "Expected physical connection to be closed." );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( CLOSED_CONNECTION, se );
1:         }
1:     }
1:     private PooledConnection    getPooledConnection
1:         ( ConnectionPoolDataSource cpDs, String userName ) throws Exception
1:     {
1:         return cpDs.getPooledConnection( userName, getTestConfiguration().getPassword( userName ) );
1:     }
1:     
1:     /**
1:      * Test the JDBC 4.1 Connection.abort(Executor) method on XA connections.
1:      */
1:     public void testAbortXA() throws Exception
1:     {
1:         //
1:         // In order to run this test, a special permission must be granted to
1:         // the jar file containing this method.
1:         //
1:         if ( !TestConfiguration.loadingFromJars() ) { return; }
1: 
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         
1:         XAConnection conn0 = getXAConnection( xads, "user0");
1:         XAConnection conn1 = getXAConnection( xads, "user1");
1:         XAConnection conn2 = getXAConnection( xads, "user2");
1: 
1:         abortVetter( conn0.getConnection(), conn1.getConnection(), conn2.getConnection() );
1: 
1:         // verify that the underlying physical connection is closed
1:         try {
1:             conn1.getConnection();
1:             fail( "Expected physical connection to be closed." );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( CLOSED_CONNECTION, se );
1:         }
1:     }
1:     private XAConnection    getXAConnection
1:         ( XADataSource xads, String userName ) throws Exception
1:     {
1:         return xads.getXAConnection( userName, getTestConfiguration().getPassword( userName ) );
1:     }
1: 
1:     /**
1:      * Test the JDBC 4.1 Connection.abort(Executor) method.
1:      */
1:     public void abortVetter( Connection conn0, Connection conn1, Connection conn2 ) throws Exception
1:     {
1:         // NOP if called on a closed connection
/////////////////////////////////////////////////////////////////////////
0:             assertSQLState( CLOSED_CONNECTION, se );
commit:795f705
/////////////////////////////////////////////////////////////////////////
0: import java.util.concurrent.Executor;
/////////////////////////////////////////////////////////////////////////
1: public class ConnectionMethodsTest extends Wrapper41Test
1: {
1:     ///////////////////////////////////////////////////////////////////////
1:     //
1:     // NESTED CLASSES
1:     //
1:     ///////////////////////////////////////////////////////////////////////
1: 
1:     /** An Executor which runs in the current thread. */
1:     public static   final   class DirectExecutor implements Executor
1:     {
1:         public void execute(Runnable r)
1:         {
1:             r.run();
1:         }
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////
1:     ///////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTORS
1:     //
1:     ///////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////
1:     //
1:     // JUnit SETUP
1:     //
1:     ///////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                 s.execute("create table abort_table(a int)");
1:     
1:     ///////////////////////////////////////////////////////////////////////
1:     //
1:     // TEST CASES
1:     //
1:     ///////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Test the JDBC 4.1 Connection.abort(Executor) method.
1:      */
0:     public void testAbort() throws Exception
1:     {
1:         //
1:         // In order to run this test, a special permission must be granted to
1:         // the jar file containing this method.
1:         //
1:         if ( !TestConfiguration.loadingFromJars() ) { return; }
1: 
0:         // NOP if called on a closed connection
1:         Connection conn0 = openUserConnection( "user0");
1:         conn0.close();
1:         Wrapper41Conn   wrapper0 = new Wrapper41Conn( conn0 );
1:         wrapper0.abort( new DirectExecutor() );
1: 
0:         Connection conn1 = openUserConnection( "user1");
1:         conn1.setAutoCommit( false );
1:         final   Wrapper41Conn   wrapper1 = new Wrapper41Conn( conn1 );
1: 
1:         // the Executor may not be null
1:         try {
1:             wrapper1.abort( null );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertSQLState( "XCZ02", se );
1:         }
1: 
1:         PreparedStatement   ps = prepareStatement
1:             ( conn1, "insert into app.abort_table( a ) values ( 1 )" );
1:         ps.execute();
1:         ps.close();
1: 
1:         // abort the connection
1:         try {
1:             //
1:             // This doPrivileged block absolves outer code blocks (like JUnit)
1:             // of the need to be granted SQLPermission( "callAbort" ). However,
1:             // derbyTesting.jar still needs that permission.
1:             //
1:             AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object    run() throws Exception
1:                      {
1:                          DirectExecutor  executor = new DirectExecutor();
1:                          wrapper1.abort( executor );
1:                          return null;
1:                      }
1:                  }
1:                  );
1:         }
1:         catch (Exception e)
1:         {
1:             e.printStackTrace();
1:             //
1:             // We need to fail now. But the connection holds locks
1:             // which prevent our test apparatus from cleaning up.
1:             // We need to release those locks before failing.
1:             //
1:             conn1.rollback();
1:             fail( "Could not abort connection!" );
1:         }
1: 
1:         // verify that the connection is closed
1:         try {
1:             prepareStatement( conn1, "select * from sys.systables" );
1:             fail( "Connection should be dead!" );
1:         }
1:         catch (SQLException se)
1:         {
0:             assertSQLState( "08003", se );
1:         }
1: 
1:         // verify that the changes were rolled back
0:         Connection conn2 = openUserConnection( "user2");
1:         ps = prepareStatement( conn2, "select * from app.abort_table" );
1:         ResultSet   rs = ps.executeQuery();
1:         assertFalse( rs.next() );
1:         rs.close();
1:         ps.close();
1:         conn2.close();
1:     }
1:     
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:0f26c83
/////////////////////////////////////////////////////////////////////////
1:             is = AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<FileInputStream>() {
1:                 public FileInputStream run() throws FileNotFoundException {
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Integer> beforeUpdateList = new ArrayList<Integer>();
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Integer> afterUpdateList = new ArrayList<Integer>();
/////////////////////////////////////////////////////////////////////////
1:             is = AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<FileInputStream>() {
1:                 public FileInputStream run() throws FileNotFoundException {
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Integer> beforeUpdateList = new ArrayList<Integer>();
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Integer> afterUpdateList = new ArrayList<Integer>();
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:042f338
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.ConnectionMethodsTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1: 
0: import java.util.ArrayList;
0: import java.sql.Connection;
0: import java.sql.PreparedStatement;
0: import java.sql.ParameterMetaData;
0: import java.sql.ResultSet;
0: import java.sql.Statement;
0: import java.sql.SQLException;
1: import java.io.FileInputStream;
1: import java.io.FileNotFoundException;
0: import java.io.FilePermission;
1: import java.io.IOException;
0: import java.io.OutputStream;
1: import java.io.InputStream;
0: import java.sql.Connection;
0: import java.sql.PreparedStatement;
0: import java.sql.Statement;
0: import java.sql.SQLException;
1: import java.sql.Blob;
1: import java.sql.Clob;
0: import javax.sql.DataSource;
0: import java.security.AccessController;
0: import java.security.*;
0: import org.apache.derbyTesting.junit.NetworkServerTestSetup;
0: import org.apache.derby.drda.NetworkServerControl;
0: import org.apache.derby.jdbc.ClientDataSource;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
0: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
0: import org.apache.derbyTesting.junit.JDBCDataSource;
0: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: /**
1:  * This class is used to test the implementations of the JDBC 4.0 methods
1:  * in the Connection interface
1:  */
0: public class ConnectionMethodsTest extends BaseJDBCTestCase {
1: 
1:     FileInputStream is;
1: 
1:     public ConnectionMethodsTest(String name) {
1:         super(name);
1:     }
1: 
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("ConnectionMethodsTest");
1: 
1:         suite.addTest(baseSuite("ConnectionMethodsTest:embedded"));
1: 
1:         suite.addTest(
1:                 TestConfiguration.clientServerDecorator(
1:                 baseSuite("ConnectionMethodsTest:client")));
1:         return suite;
1:     }
1: 
1:     public static Test baseSuite(String name) {
0:         TestSuite suite = new TestSuite(ConnectionMethodsTest.class, name);
1:         Test test = new SupportFilesSetup(suite, new String[] {"functionTests/testData/ConnectionMethods/short.txt"} );
1:         return new CleanDatabaseTestSetup(test) {
1:             protected void decorateSQL(Statement s) throws SQLException {
1:                 s.execute("create table clobtable2(n int,clobcol CLOB)");
1:                 s.execute("create table blobtable2(n int,blobcol BLOB)");
1: 
1:             }
1:         };
1:     }
1:     /**
1:      * Test the createClob method implementation in the Connection interface
1:      *
1:      * @exception SQLException, FileNotFoundException, Exception if error occurs
1:      */
1:     public void testCreateClob() throws   SQLException,
1:             FileNotFoundException, IOException,
1:             Exception{
1: 
1:         Connection conn = getConnection();
1:         int b, c;
1:         Clob clob;
1: 
1:         Statement s = createStatement();
1: 
1:         PreparedStatement ps =
1:                 prepareStatement("insert into clobtable2 (n, clobcol)" + " values(?,?)");
1:         ps.setInt(1,1000);
1:         clob = conn.createClob();
1: 
1:         try {
0:             is = (FileInputStream) AccessController.doPrivileged(
0:                     new PrivilegedExceptionAction() {
0:                 public Object run() throws FileNotFoundException {
1:                     return new FileInputStream("extin/short.txt");
1:                 }
1:             });
1:         } catch (PrivilegedActionException e) {
1:             // e.getException() should be an instance of FileNotFoundException,
1:             // as only "checked" exceptions will be "wrapped" in a
1:             // PrivilegedActionException.
1:             throw (FileNotFoundException) e.getException();
1:         }
1:         OutputStream os = clob.setAsciiStream(1);
0:         ArrayList beforeUpdateList = new ArrayList();
1: 
1:         c = is.read();
1:         while(c>0) {
1:             os.write(c);
1:             beforeUpdateList.add(c);
1:             c = is.read();
1:         }
1:         ps.setClob(2, clob);
1:         ps.executeUpdate();
1: 
1:         Statement stmt = createStatement();
1:         ResultSet rs =
1:                 stmt.executeQuery("select clobcol from clobtable2 where n = 1000");
1:         assertTrue(rs.next());
1: 
1:         clob = rs.getClob(1);
1:         assertEquals(beforeUpdateList.size(), clob.length());
1: 
1:         //Get the InputStream from this Clob.
1:         InputStream in = clob.getAsciiStream();
0:         ArrayList afterUpdateList = new ArrayList();
1: 
1:         b = in.read();
1: 
1:         while (b > -1) {
1:             afterUpdateList.add(b);
1:             b = in.read();
1:         }
1: 
1:         assertEquals(beforeUpdateList.size(), afterUpdateList.size());
1: 
1:         //Now check if the two InputStreams
1:         //match
1:         for (int i = 0; i < clob.length(); i++) {
1:             assertEquals(beforeUpdateList.get(i), afterUpdateList.get(i));
1:         }
1: 
1:         os.close();
1:         is.close();
1: 
1:     }
1:     /**
1:      * Test the createBlob method implementation in the Connection interface
1:      *
1:      * @exception  SQLException, FileNotFoundException, Exception if error occurs
1:      */
1:     public void testCreateBlob() throws   SQLException,
1:             FileNotFoundException,
1:             IOException,
1:             Exception{
1: 
1:         Connection conn = getConnection();
1:         int b, c;
1:         Blob blob;
1: 
1:         Statement s = createStatement();
1:         PreparedStatement ps =
1:                 prepareStatement("insert into blobtable2 (n, blobcol)" + " values(?,?)");
1:         ps.setInt(1,1000);
1:         blob = conn.createBlob();
1: 
1:         try {
0:             is = (FileInputStream) AccessController.doPrivileged(
0:                     new PrivilegedExceptionAction() {
0:                 public Object run() throws FileNotFoundException {
1:                     return new FileInputStream("extin/short.txt");
1:                 }
1:             });
1:         } catch (PrivilegedActionException e) {
1:             // e.getException() should be an instance of FileNotFoundException,
1:             // as only "checked" exceptions will be "wrapped" in a
1:             // PrivilegedActionException.
1:             throw (FileNotFoundException) e.getException();
1:         }
1: 
1:         OutputStream os = blob.setBinaryStream(1);
0:         ArrayList beforeUpdateList = new ArrayList();
1: 
1:         int actualLength = 0;
1:         c = is.read();
1:         while(c>0) {
1:             os.write(c);
1:             beforeUpdateList.add(c);
1:             c = is.read();
1:             actualLength ++;
1:         }
1:         ps.setBlob(2, blob);
1:         ps.executeUpdate();
1: 
1:         Statement stmt = createStatement();
1:         ResultSet rs =
1:                 stmt.executeQuery("select blobcol from blobtable2 where n = 1000");
1:         assertTrue(rs.next());
1: 
1:         blob = rs.getBlob(1);
1:         assertEquals(beforeUpdateList.size(), blob.length());
1: 
1:         //Get the InputStream from this Blob.
1:         InputStream in = blob.getBinaryStream();
0:         ArrayList afterUpdateList = new ArrayList();
1: 
1:         b = in.read();
1: 
1:         while (b > -1) {
1:             afterUpdateList.add(b);
1:             b = in.read();
1:         }
1: 
1:         assertEquals(beforeUpdateList.size(), afterUpdateList.size());
1: 
1:         //Now check if the two InputStreams
1:         //match
1:         for (int i = 0; i < blob.length(); i++) {
1:             assertEquals(beforeUpdateList.get(i), afterUpdateList.get(i));
1:         }
1: 
1:         os.close();
1:         is.close();
1:     }
1:     /**
1:      * Test the Connection.isValid method
1:      *
1:      * @exception SQLException, Exception if error occurs
1:      */
1:     public void testConnectionIsValid() throws SQLException, Exception {
1:        /*
1:         * Test illegal parameter values
1:         */
1:         Connection conn = getConnection();
1:         try {
1:             conn.isValid(-1);  // Negative timeout
1:             fail("FAIL: isValid(-1): Invalid argument execption not thrown");
1: 
1:         } catch (SQLException e) {
1:             assertSQLState("XJ081", e);
1:         }
1: 
1:        /*
1:         * Test with no timeout
1:         */
1:         if (!conn.isValid(0)) {
1:             fail("FAIL: isValid(0): returned false");
1:         }
1: 
1:        /*
0:         * Test with a valid timeout
1:         */
0:         if (!conn.isValid(1)) {
0:             fail("FAIL: isValid(1): returned false");
1:         }
1: 
1:        /*
1:         * Test on a closed connection
1:         */
1:         try {
1:             conn.close();
1:         } catch (SQLException e) {
1:             assertSQLState("08003", e);
1:         }
1: 
1:         if (conn.isValid(0)) {
1:             fail("FAIL: isValid(0) on closed connection: returned true");
1:         }
1: 
1:         /* Open a new connection and test it */
1:         conn = getConnection();
1:         if (!conn.isValid(0)) {
1:             fail("FAIL: isValid(0) on open connection: returned false");
1:         }
1: 
1:        /*
1:         * Test on stopped database
1:         */
1:         TestConfiguration.getCurrent().shutdownDatabase();
1: 
1:         /* Test if that connection is not valid */
1:         if (conn.isValid(0)) {
1:             fail("FAIL: isValid(0) on stopped database: returned true");
1:         }
1: 
1:         /* Start the database by getting a new connection to it */
1:         conn = getConnection();
1: 
1:         /* Check that a new connection to the newly started database is valid */
1:         if (!conn.isValid(0)) {
1:             fail("FAIL: isValid(0) on new connection: " +
1:                     "returned false");
1:         }
1: 
1:        /*
1:         * Test on stopped Network Server client
1:         */
1:         if ( !usingEmbedded() ) {
1: 
1:             TestConfiguration.getCurrent().stopNetworkServer();
1: 
1:             /* Test that the connection is not valid */
1:             if (conn.isValid(0)) {
1:                 fail("FAIL: isValid(0) on stopped database: returned true");
1:             }
1: 
1:            /*
1:             * Start the network server and get a new connection and check that
1:             * the new connection is valid.
1:             */
1:             TestConfiguration.getCurrent().startNetworkServer();
1: 
1:             // Get a new connection to the database
1:             conn = getConnection();
1: 
1:             /* Check that a new connection to the newly started Derby is valid */
1:             if (!conn.isValid(0)) {
1:                 fail("FAIL: isValid(0) on new connection: returned false");
1:             }
1:         }
1:     }
1: }
============================================================================