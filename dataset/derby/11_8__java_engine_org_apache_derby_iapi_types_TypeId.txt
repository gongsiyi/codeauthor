1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.types.TypeId
1:7ecc1f2: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
41:eac0369: 
18:eac0369:  */
1:2e83f13: 
1:eac0369: package org.apache.derby.iapi.types;
1:eac0369: 
1:fbb0d4f: import java.sql.Types;
1:fbb0d4f: import org.apache.derby.catalog.TypeDescriptor;
1:eac0369: import org.apache.derby.catalog.types.BaseTypeIdImpl;
1:eac0369: import org.apache.derby.catalog.types.DecimalTypeIdImpl;
1:d039ced: import org.apache.derby.catalog.types.TypeDescriptorImpl;
1:eac0369: import org.apache.derby.catalog.types.UserDefinedTypeIdImpl;
1:2a5922a: import org.apache.derby.iapi.error.StandardException;
1:bead0ab: import org.apache.derby.iapi.reference.DRDAConstants;
1:fbb0d4f: import org.apache.derby.iapi.reference.Limits;
1:fbb0d4f: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:fbb0d4f: import org.apache.derby.iapi.services.loader.ClassFactory;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:b260d95: /**
1:2afe578:  * TypeId describes the static information about a SQL type
1:2afe578:  * independent of any specific attributes of the type such
1:2afe578:  * as length. So the TypeId for CHARACTER describes the
1:2afe578:  * fundamental information about CHARACTER. A specific
1:b260d95:  * type (e.g. CHARACTER(10)) is described by a TypeDescriptor for
1:b260d95:  * a catlog type and a DataTypeDescriptor for a runtime type.
1:b260d95:  * (note a DataTypeDescriptor adds runtime attributes to the
1:b260d95:  * TypeDescriptor it has).
1:b260d95:  * <P>
1:b260d95:  * A TypeId is immutable.
1:eac0369:    <P>
1:eac0369:  * The equals(Object) method can be used to determine if two typeIds are for the same type,
1:eac0369:  * which defines type id equality.
1:2afe578: 
1:eac0369: 
1:2afe578:    @see DataTypeDescriptor
1:e11914a:  */
1:eac0369: 
1:b260d95: public final class TypeId
21:eac0369: {
1:e11914a:         /**
1:eac0369:          * Various fixed numbers related to datatypes.
1:eac0369:          */
1:eac0369:         public static final int LONGINT_PRECISION                       = 19;
1:eac0369:         public static final int LONGINT_SCALE                           = 0;
1:eac0369:         public static final int LONGINT_MAXWIDTH                        = 8;
1:92268ac: 
1:eac0369:         public static final int INT_PRECISION                   = 10;
1:eac0369:         public static final int INT_SCALE                               = 0;
1:eac0369:         public static final int INT_MAXWIDTH                    = 4;
1:f2a5622: 
1:eac0369:         public static final int SMALLINT_PRECISION                      = 5;
1:eac0369:         public static final int SMALLINT_SCALE                          = 0;
1:eac0369:         public static final int SMALLINT_MAXWIDTH                       = 2;
1:eac0369: 
1:eac0369:         public static final int TINYINT_PRECISION                       = 3;
1:eac0369:         public static final int TINYINT_SCALE                           = 0;
1:eac0369:         public static final int TINYINT_MAXWIDTH                        = 1;
1:eac0369: 
1:eac0369: 	// precision in number of bits 
1:eac0369:         public static final int DOUBLE_PRECISION                        = 52;
1:eac0369: 	// the ResultSetMetaData needs to have the precision for numeric data
1:eac0369: 	// in decimal digits, rather than number of bits, so need a separate constant.
1:eac0369:         public static final int DOUBLE_PRECISION_IN_DIGITS              = 15;
1:eac0369:         public static final int DOUBLE_SCALE                            = 0;
1:eac0369:         public static final int DOUBLE_MAXWIDTH                         = 8;
1:eac0369: 
1:eac0369: 	// precision in number of bits 
1:eac0369:         public static final int REAL_PRECISION                  = 23;
1:eac0369: 	// the ResultSetMetaData needs to have the precision for numeric data
1:eac0369: 	// in decimal digits, rather than number of bits, so need a separate constant.
1:eac0369:         public static final int REAL_PRECISION_IN_DIGITS        = 7;
1:eac0369:         public static final int REAL_SCALE                              = 0;
1:eac0369:         public static final int REAL_MAXWIDTH                   = 4;
1:eac0369: 
1:b1f84c1:         public static final int DECIMAL_PRECISION                       = Limits.DB2_MAX_DECIMAL_PRECISION_SCALE;
1:b1f84c1:         public static final int DECIMAL_SCALE                           = Limits.DB2_MAX_DECIMAL_PRECISION_SCALE;
1:b1f84c1:         public static final int DECIMAL_MAXWIDTH                        = Limits.DB2_MAX_DECIMAL_PRECISION_SCALE;
1:eac0369: 
1:eac0369:         public static final int BOOLEAN_MAXWIDTH                        = 1;
1:eac0369: 
1:b1f84c1:         public static final int CHAR_MAXWIDTH           = Limits.DB2_CHAR_MAXWIDTH;
1:b1f84c1:         public static final int VARCHAR_MAXWIDTH        = Limits.DB2_VARCHAR_MAXWIDTH;
1:b1f84c1:         public static final int LONGVARCHAR_MAXWIDTH = Limits.DB2_LONGVARCHAR_MAXWIDTH;
1:b1f84c1:         public static final int BIT_MAXWIDTH            = Limits.DB2_CHAR_MAXWIDTH;
1:b1f84c1:         public static final int VARBIT_MAXWIDTH         = Limits.DB2_VARCHAR_MAXWIDTH;
1:b1f84c1:         public static final int LONGVARBIT_MAXWIDTH = Limits.DB2_LONGVARCHAR_MAXWIDTH;
1:eac0369: 
1:3fd26f3:         // not supposed to be limited! 4096G should be ok(?), if Derby can handle...
1:eac0369:         public static final int BLOB_MAXWIDTH = Integer.MAX_VALUE; // to change long
1:eac0369:         public static final int CLOB_MAXWIDTH = Integer.MAX_VALUE; // to change long
1:099e28f:         public static final int XML_MAXWIDTH = Integer.MAX_VALUE;
1:eac0369: 
1:fd58c3c:         // Max width for datetime values is the length of the
1:fd58c3c:         // string returned from a call to "toString()" on the
1:fd58c3c:         // java.sql.Date, java.sql.Time, and java.sql.Timestamp
1:fd58c3c:         // classes (the result of toString() on those classes
1:fd58c3c:         // is defined by the JDBC API).  This value is also
1:fd58c3c:         // used as the "precision" for those types.
1:fd58c3c:         public static final int DATE_MAXWIDTH           = 10;	// yyyy-mm-dd
1:fd58c3c:         public static final int TIME_MAXWIDTH           = 8;	// hh:mm:ss
1:bead0ab: 
1:1e90bf4:         // The format of java.sql.Timestamp.toString()
1:bead0ab:         // is yyyy-mm-dd hh:mm:ss.fffffffff
1:1e90bf4:         public static final int TIMESTAMP_MAXWIDTH      = DRDAConstants.DRDA_TIMESTAMP_LENGTH;	// yyyy-mm-dd hh:mm:ss.fffffffff
1:eac0369: 
1:fd58c3c:         // Scale DOES exist for time values.  For a TIMESTAMP value,
1:1e90bf4:         // it's 9 ('fffffffff'); for a TIME value, it's 0 (because there
1:fd58c3c:         // are no fractional seconds).  Note that date values do
1:fd58c3c:         // not have a scale.
1:fd58c3c:         public static final int TIME_SCALE           = 0;
1:1e90bf4:         public static final int TIMESTAMP_SCALE      = 9;
1:eac0369: 
1:eac0369:         /* These define all the type names for SQL92 and JDBC 
1:eac0369:          * NOTE: boolean is SQL3
1:eac0369:          */
1:eac0369:           //public static final String      BIT_NAME = "BIT";
1:eac0369:           //public static final String      VARBIT_NAME = "BIT VARYING";
1:eac0369:           //public static final String      LONGVARBIT_NAME = "LONG BIT VARYING";
1:eac0369: 
1:eac0369:         public static final String      BIT_NAME = "CHAR () FOR BIT DATA";
1:eac0369:         public static final String      VARBIT_NAME = "VARCHAR () FOR BIT DATA";
1:eac0369:         public static final String      LONGVARBIT_NAME = "LONG VARCHAR FOR BIT DATA";
1:eac0369:         public static final String      TINYINT_NAME = "TINYINT";
1:eac0369:         public static final String      SMALLINT_NAME = "SMALLINT";
1:eac0369:         public static final String      INTEGER_NAME = "INTEGER";
1:3bb140c:         public static final String      BIGINT_NAME = "BIGINT";
1:eac0369:         public static final String      FLOAT_NAME = "FLOAT";
1:eac0369:         public static final String      REAL_NAME = "REAL";
1:eac0369:         public static final String      DOUBLE_NAME = "DOUBLE";
1:eac0369:         public static final String      NUMERIC_NAME = "NUMERIC";
1:eac0369:         public static final String      DECIMAL_NAME = "DECIMAL";
1:eac0369:         public static final String      CHAR_NAME = "CHAR";
1:eac0369:         public static final String      VARCHAR_NAME = "VARCHAR";
1:eac0369:         public static final String      LONGVARCHAR_NAME = "LONG VARCHAR";
1:eac0369:         public static final String      DATE_NAME = "DATE";
1:eac0369:         public static final String      TIME_NAME = "TIME";
1:eac0369:         public static final String      TIMESTAMP_NAME = "TIMESTAMP";
1:eac0369:         public static final String      BINARY_NAME = "BINARY";
1:eac0369:         public static final String      VARBINARY_NAME = "VARBINARY";
1:eac0369:         public static final String      LONGVARBINARY_NAME = "LONGVARBINARY";
1:eac0369:         public static final String      BOOLEAN_NAME = "BOOLEAN";
1:eac0369:         public static final String      REF_NAME = "REF";
1:7cfb7e6:         public static final String      REF_CURSOR = "REF CURSOR";
1:eac0369:         public static final String      NATIONAL_CHAR_NAME = "NATIONAL CHAR";
1:eac0369:         public static final String      NATIONAL_VARCHAR_NAME = "NATIONAL CHAR VARYING";
1:eac0369:         public static final String      NATIONAL_LONGVARCHAR_NAME = "LONG NVARCHAR";
1:eac0369:         public static final String      BLOB_NAME = "BLOB";
1:eac0369:         public static final String      CLOB_NAME = "CLOB";
1:eac0369:         public static final String      NCLOB_NAME = "NCLOB";
1:eac0369: 
1:099e28f:         // Following use of "XML" is per SQL/XML (2003) spec,
1:099e28f:         // section "10.2 Type name determination".
1:099e28f:         public static final String      XML_NAME = "XML";
1:eac0369:         
1:054fa3a:         // ARRAY and STRUCT are JDBC 2.0 data types that are not
1:054fa3a:         // supported by Derby.
1:054fa3a:         public static final String      ARRAY_NAME = "ARRAY";
1:054fa3a:         public static final String      STRUCT_NAME = "STRUCT";
1:054fa3a: 
1:054fa3a:         // DATALINK is a JDBC 3.0 data type. Not supported by Derby.
1:054fa3a:         public static final String      DATALINK_NAME = "DATALINK";
1:054fa3a: 
1:054fa3a:         // ROWID and SQLXML are new types in JDBC 4.0. Not supported
1:054fa3a:         // by Derby.
1:054fa3a:         public static final String      ROWID_NAME = "ROWID";
1:054fa3a:         public static final String      SQLXML_NAME = "SQLXML";
1:054fa3a: 
13:eac0369:         /**
1:eac0369:          * The following constants define the type precedence hierarchy.
1:eac0369:          */
1:eac0369:         public static final int USER_PRECEDENCE  = 1000;
1:eac0369: 
1:099e28f:         public static final int XML_PRECEDENCE       = 180;
1:eac0369:         public static final int BLOB_PRECEDENCE = 170;
1:eac0369:         public static final int LONGVARBIT_PRECEDENCE = 160;
1:eac0369:         public static final int VARBIT_PRECEDENCE        = 150;
1:eac0369:         public static final int BIT_PRECEDENCE           = 140;
1:eac0369:         public static final int BOOLEAN_PRECEDENCE       = 130;
1:eac0369:         public static final int TIME_PRECEDENCE  = 120;
1:eac0369:         public static final int TIMESTAMP_PRECEDENCE = 110;
1:eac0369:         public static final int DATE_PRECEDENCE  = 100;
1:eac0369:         public static final int DOUBLE_PRECEDENCE        = 90;
1:eac0369:         public static final int REAL_PRECEDENCE  = 80;
1:eac0369:         public static final int DECIMAL_PRECEDENCE       = 70;
1:eac0369:         public static final int NUMERIC_PRECEDENCE       = 69;
1:eac0369:         public static final int LONGINT_PRECEDENCE       = 60;
1:eac0369:         public static final int INT_PRECEDENCE           = 50;
1:eac0369:         public static final int SMALLINT_PRECEDENCE = 40;
1:eac0369:         public static final int TINYINT_PRECEDENCE       = 30;
1:eac0369:         public static final int REF_PRECEDENCE           = 25;
1:eac0369:         public static final int CLOB_PRECEDENCE = 14;
1:eac0369:         public static final int LONGVARCHAR_PRECEDENCE = 12;
1:eac0369:         public static final int VARCHAR_PRECEDENCE  = 10;
1:eac0369:         public static final int CHAR_PRECEDENCE  = 0;
1:eac0369: 
1:eac0369:         /*
1:eac0369:         ** Static runtime fields for typeIds
1:eac0369:         ** These are put here because the system needs them init time.
1:eac0369:         */
1:b260d95:         public static final TypeId BOOLEAN_ID = create(
1:3bb140c:             StoredFormatIds.BOOLEAN_TYPE_ID,
1:3bb140c:             StoredFormatIds.BOOLEAN_TYPE_ID_IMPL);
1:2e83f13:         
1:b260d95:         public static final TypeId SMALLINT_ID = create(
1:3bb140c:             StoredFormatIds.SMALLINT_TYPE_ID,
1:3bb140c:             StoredFormatIds.SMALLINT_TYPE_ID_IMPL);
1:2e83f13: 
1:b260d95:         public static final TypeId INTEGER_ID = create(
1:3bb140c:             StoredFormatIds.INT_TYPE_ID,
1:3bb140c:             StoredFormatIds.INT_TYPE_ID_IMPL);
1:2e83f13: 
1:b260d95:         public static final TypeId CHAR_ID = create(
1:3bb140c:             StoredFormatIds.CHAR_TYPE_ID,
1:3bb140c:             StoredFormatIds.CHAR_TYPE_ID_IMPL);
1:2e83f13:         
1:eac0369:         /*
1:eac0369:         ** Others are created on demand by the getBuiltInTypeId(int),
1:eac0369:         ** if they are built-in (i.e.? Part of JDBC .Types),
1:111785f:         ** or by getBuiltInTypeId(string) if they are REF_NAME type.
1:eac0369:         */
1:eac0369: 
1:b260d95:         private static final TypeId TINYINT_ID = create(
1:3bb140c:             StoredFormatIds.TINYINT_TYPE_ID,
1:3bb140c:             StoredFormatIds.TINYINT_TYPE_ID_IMPL);
1:eac0369: 
1:7fd0c6e:         public static final TypeId BIGINT_ID = create(
1:3bb140c:             StoredFormatIds.BIGINT_TYPE_ID,
1:3bb140c:             StoredFormatIds.BIGINT_TYPE_ID_IMPL);
1:3bb140c: 
1:b260d95:         private static final TypeId REAL_ID = create(
1:3bb140c:             StoredFormatIds.REAL_TYPE_ID,
1:3bb140c:             StoredFormatIds.REAL_TYPE_ID_IMPL);
1:3bb140c: 
1:2782d72:         public static final TypeId DOUBLE_ID = create(
1:3bb140c:             StoredFormatIds.DOUBLE_TYPE_ID,
1:3bb140c:             StoredFormatIds.DOUBLE_TYPE_ID_IMPL);
1:3bb140c: 
1:3bb140c:         private static final TypeId DECIMAL_ID =  new TypeId(
1:3bb140c:             StoredFormatIds.DECIMAL_TYPE_ID,
1:3bb140c:             new DecimalTypeIdImpl(false));
1:3bb140c: 
1:3bb140c:         private static final TypeId NUMERIC_ID = new TypeId(
1:3bb140c:             StoredFormatIds.DECIMAL_TYPE_ID,
1:3bb140c:             new DecimalTypeIdImpl(true));
1:3bb140c: 
1:b260d95:         private static final TypeId VARCHAR_ID = create(
1:3bb140c:             StoredFormatIds.VARCHAR_TYPE_ID,
1:3bb140c:             StoredFormatIds.VARCHAR_TYPE_ID_IMPL);
1:3bb140c: 
1:b260d95:         private static final TypeId DATE_ID = create(
1:3bb140c:             StoredFormatIds.DATE_TYPE_ID,
1:3bb140c:             StoredFormatIds.DATE_TYPE_ID_IMPL);
1:3bb140c: 
1:b260d95:         private static final TypeId TIME_ID = create(
1:3bb140c:             StoredFormatIds.TIME_TYPE_ID,
1:3bb140c:             StoredFormatIds.TIME_TYPE_ID_IMPL);
1:3bb140c: 
1:b260d95:         private static final TypeId TIMESTAMP_ID = create(
1:3bb140c:             StoredFormatIds.TIMESTAMP_TYPE_ID,
1:3bb140c:             StoredFormatIds.TIMESTAMP_TYPE_ID_IMPL);
1:3bb140c: 
1:b260d95:         private static final TypeId BIT_ID = create(
1:3bb140c:             StoredFormatIds.BIT_TYPE_ID,
1:3bb140c:             StoredFormatIds.BIT_TYPE_ID_IMPL);
1:3bb140c: 
1:b260d95:         private static final TypeId VARBIT_ID = create(
1:3bb140c:             StoredFormatIds.VARBIT_TYPE_ID,
1:3bb140c:             StoredFormatIds.VARBIT_TYPE_ID_IMPL);
1:3bb140c: 
1:b260d95:         private static final TypeId REF_ID = create(
1:3bb140c:             StoredFormatIds.REF_TYPE_ID,
1:3bb140c:             StoredFormatIds.REF_TYPE_ID_IMPL);
1:3bb140c: 
1:b260d95:         private static final TypeId LONGVARCHAR_ID = create(
1:3bb140c:             StoredFormatIds.LONGVARCHAR_TYPE_ID,
1:3bb140c:             StoredFormatIds.LONGVARCHAR_TYPE_ID_IMPL);
1:3bb140c: 
1:b260d95:         private static final TypeId LONGVARBIT_ID = create(
1:3bb140c:             StoredFormatIds.LONGVARBIT_TYPE_ID,
1:3bb140c:             StoredFormatIds.LONGVARBIT_TYPE_ID_IMPL);
1:eac0369: 
1:b260d95:         private static final TypeId BLOB_ID = create(
1:3bb140c:             StoredFormatIds.BLOB_TYPE_ID,
1:3bb140c:             StoredFormatIds.BLOB_TYPE_ID_IMPL);
1:3bb140c: 
1:b260d95:         private static final TypeId CLOB_ID = create(
1:3bb140c:             StoredFormatIds.CLOB_TYPE_ID,
1:3bb140c:             StoredFormatIds.CLOB_TYPE_ID_IMPL);
1:3bb140c: 
1:b260d95:         private static final TypeId XML_ID = create(
1:3bb140c:             StoredFormatIds.XML_TYPE_ID,
1:3bb140c:             StoredFormatIds.XML_TYPE_ID_IMPL);
1:eac0369: 
1:f2a5622:     private static final TypeId[] ALL_BUILTIN_TYPE_IDS =
1:f2a5622:     {
1:f2a5622:         BOOLEAN_ID,
1:f2a5622:         SMALLINT_ID,
1:f2a5622:         INTEGER_ID,
1:f2a5622:         CHAR_ID,
1:f2a5622:         TINYINT_ID,
1:f2a5622:         BIGINT_ID,
1:f2a5622:         REAL_ID,
1:f2a5622:         DOUBLE_ID,
1:f2a5622:         DECIMAL_ID,
1:f2a5622:         NUMERIC_ID,
1:f2a5622:         VARCHAR_ID,
1:f2a5622:         DATE_ID,
1:f2a5622:         TIME_ID,
1:f2a5622:         TIMESTAMP_ID,
1:f2a5622:         BIT_ID,
1:f2a5622:         VARBIT_ID,
1:f2a5622:         REF_ID,
1:f2a5622:         LONGVARCHAR_ID,
1:f2a5622:         LONGVARBIT_ID,
1:f2a5622:         BLOB_ID,
1:f2a5622:         CLOB_ID,
1:f2a5622:         XML_ID,
1:f2a5622:     };
1:f2a5622: 
1:eac0369:         /*
1:eac0369:         ** Static methods to obtain TypeIds
1:eac0369:         */
1:b260d95:         
1:b260d95:         /**
1:b260d95:          * Create a TypeId for the given format identifiers using
1:b260d95:          * a BaseTypeIdImpl. Used to create the static final variables
1:b260d95:          * of this class.
1:b260d95:          */
1:b260d95:         private static TypeId create(int typeFormatId, int implTypeFormatId)
1:b260d95:         {
1:b260d95:             return new TypeId(typeFormatId, new BaseTypeIdImpl(implTypeFormatId)); 
1:92268ac:         }
1:92268ac: 
1:f2a5622:     /**
1:f2a5622:      * Return all of the builtin type ids.
1:f2a5622:      */
1:f2a5622:     public static TypeId[] getAllBuiltinTypeIds()
1:f2a5622:     {
1:f2a5622:         int count = ALL_BUILTIN_TYPE_IDS.length;
1:f2a5622: 
1:f2a5622:         TypeId[] retval = new TypeId[ count ];
1:f2a5622: 
1:f2a5622:         for ( int i = 0; i < count; i++ ) { retval[ i ] = ALL_BUILTIN_TYPE_IDS[ i ]; }
1:f2a5622: 
1:f2a5622:         return retval;
1:f2a5622:     }
1:4aef9b0:         
1:b260d95:         
1:d039ced:         /**
1:eac0369:          * Get a TypeId of the given JDBC type.  This factory method is
1:eac0369:          * intended to be used for built-in types.  For user-defined types,
1:eac0369:          * we will need a factory method that takes a Java type name.
1:92268ac:          *
1:eac0369:          * @param JDBCTypeId    The JDBC Id of the type, as listed in
1:eac0369:          *                      java.sql.Types
14:eac0369:          *
1:eac0369:          * @return      The appropriate TypeId, or null if there is no such
1:eac0369:          *                      TypeId.
1:92268ac:          */
1:92268ac: 
1:b260d95:         public static TypeId getBuiltInTypeId(int JDBCTypeId) {
1:b260d95: 
1:b260d95:         switch (JDBCTypeId) {
1:b260d95:         case Types.TINYINT:
1:b260d95:             return TINYINT_ID;
1:eac0369: 
1:b260d95:         case Types.SMALLINT:
1:b260d95:             return SMALLINT_ID;
1:eac0369: 
1:b260d95:         case Types.INTEGER:
1:b260d95:             return INTEGER_ID;
1:eac0369: 
1:b260d95:         case Types.BIGINT:
1:b260d95:             return BIGINT_ID;
1:eac0369: 
1:b260d95:         case Types.REAL:
1:b260d95:             return REAL_ID;
1:eac0369: 
1:b260d95:         case Types.FLOAT:
1:b260d95:         case Types.DOUBLE:
1:b260d95:             return DOUBLE_ID;
1:eac0369: 
1:b260d95:         case Types.DECIMAL:
1:b260d95:             return DECIMAL_ID;
1:eac0369: 
1:b260d95:         case Types.NUMERIC:
1:b260d95:             return NUMERIC_ID;
1:eac0369: 
1:b260d95:         case Types.CHAR:
1:b260d95:             return CHAR_ID;
1:eac0369: 
1:b260d95:         case Types.VARCHAR:
1:b260d95:             return VARCHAR_ID;
1:eac0369: 
1:b260d95:         case Types.DATE:
1:b260d95:             return DATE_ID;
1:b260d95:         case Types.TIME:
1:b260d95:             return TIME_ID;
1:eac0369: 
1:b260d95:         case Types.TIMESTAMP:
1:b260d95:             return TIMESTAMP_ID;
1:eac0369: 
1:b260d95:         case Types.BIT:
1:b260d95:         case Types.BOOLEAN:
1:b260d95:             return BOOLEAN_ID;
1:eac0369: 
1:b260d95:         case Types.BINARY:
1:b260d95:             return BIT_ID;
1:eac0369: 
1:b260d95:         case Types.VARBINARY:
1:b260d95:             return VARBIT_ID;
1:eac0369: 
1:b260d95:         case Types.LONGVARBINARY:
1:b260d95:             return LONGVARBIT_ID;
1:eac0369: 
1:b260d95:         case Types.LONGVARCHAR:
1:b260d95:             return LONGVARCHAR_ID;
1:eac0369: 
1:eac0369: 
1:b260d95:         case Types.BLOB:
1:b260d95:             return BLOB_ID;
1:b260d95: 
1:b260d95:         case Types.CLOB:
1:b260d95:             return CLOB_ID;
1:b260d95: 
1:e33b8d8:         case Types.SQLXML:
1:b260d95:             return XML_ID;
1:b260d95:             
1:b260d95:         default:
1:b260d95:             return null;
1:92268ac:         }
1:b260d95:     }
1:fbb0d4f: 
1:bbd82de:     public static TypeId getUserDefinedTypeId(String className)
1:2a5922a:         throws StandardException
1:92268ac:     {
1:bbd82de:         return new TypeId(StoredFormatIds.USERDEFINED_TYPE_ID_V3,
1:bbd82de:                                 new UserDefinedTypeIdImpl(className));
1:bbd82de:     }
1:eac0369: 
1:92268ac:     /**
1:53c606b:      * This factory  method is used for ANSI UDTs. If the className argument is null,
1:d039ced:      * then this TypeId will have to be bound.
1:53c606b:      *
1:53c606b:      * @param schemaName Schema that the type definition lives in.
1:53c606b:      * @param unqualifiedName The second part of the ANSI dot-separated name for the type.
1:53c606b:      * @param className The Java class which is bound to the schema-qualified name by the CREATE TYPE statement.
1:53c606b:      *
1:53c606b:      * @return A bound type TypeId describing this ANSI UDT.
1:d039ced:      */
1:d039ced:     public static TypeId getUserDefinedTypeId(String schemaName, String unqualifiedName, String className )
1:2a5922a:         throws StandardException
1:d039ced:     {
1:d039ced:         return new TypeId
1:d039ced:             (
1:d039ced:              StoredFormatIds.USERDEFINED_TYPE_ID_V3,
1:d039ced:              new UserDefinedTypeIdImpl(schemaName, unqualifiedName, className )
1:d039ced:              );
1:d039ced:     }
1:d039ced: 
1:4aef9b0:         /**
1:b260d95:          * Get a TypeId for the class that corresponds to the given Java type
1:b260d95:          * name.
1:b260d95:          * 
1:b260d95:          * @param javaTypeName
1:b260d95:          *            The name of the Java type
1:b260d95:          * 
1:b260d95:          * @return A TypeId for the SQL type that corresponds to the Java type,
1:b260d95:          *         null if there is no corresponding type.
1:eac0369:          */
1:eac0369:         public static TypeId getSQLTypeForJavaType(String javaTypeName)
1:2a5922a:             throws StandardException
1:bbd82de:         {
1:eac0369:                 if (javaTypeName.equals("java.lang.Boolean") ||
1:eac0369:                         javaTypeName.equals("boolean"))
1:fbb0d4f:                 {
1:b260d95:                         return BOOLEAN_ID;
1:b260d95:                 }
1:eac0369:                 else if (javaTypeName.equals("byte[]"))
1:eac0369:                 {
1:b260d95:                         return VARBIT_ID;
43:eac0369:                 }
1:eac0369:                 else if (javaTypeName.equals("java.lang.String"))
1:eac0369:                 {
1:b260d95:                         return VARCHAR_ID;
1:eac0369:                 }
1:eac0369:                 else if (javaTypeName.equals("java.lang.Integer") ||
1:eac0369:                                 javaTypeName.equals("int"))
1:eac0369:                 {
1:b260d95:                         return INTEGER_ID;
1:eac0369:                 }
1:eac0369:                 else if (javaTypeName.equals("byte"))
1:eac0369:                 {
1:b260d95:                         return TINYINT_ID;
1:eac0369:                 }
1:eac0369:                 else if (javaTypeName.equals("short"))
1:eac0369:                 {
1:b260d95:                     return SMALLINT_ID;
1:eac0369:                 }
1:eac0369:                 else if (javaTypeName.equals("java.lang.Long") ||
1:eac0369:                                 javaTypeName.equals("long"))
1:eac0369:                 {
1:b260d95:                      return BIGINT_ID;
1:eac0369:                 }
1:eac0369:                 else if (javaTypeName.equals("java.lang.Float") ||
1:eac0369:                                 javaTypeName.equals("float"))
1:eac0369:                 {
1:b260d95:                      return REAL_ID;
1:eac0369:                 }
1:eac0369:                 else if (javaTypeName.equals("java.lang.Double") ||
1:eac0369:                                 javaTypeName.equals("double"))
1:eac0369:                 {
1:b260d95:                     return DOUBLE_ID;
1:eac0369:                 }
1:eac0369:                 else if (javaTypeName.equals("java.math.BigDecimal"))
1:eac0369:                 {
1:b260d95:                     return DECIMAL_ID;
1:eac0369:                 }
1:eac0369:                 else if (javaTypeName.equals("java.sql.Date"))
1:eac0369:                 {
1:b260d95:                     return DATE_ID;
1:eac0369:                 }
1:eac0369:                 else if (javaTypeName.equals("java.sql.Time"))
1:eac0369:                 {
1:b260d95:                     return TIME_ID;
1:eac0369:                 }
1:eac0369:                 else if (javaTypeName.equals("java.sql.Timestamp"))
1:eac0369:                 {
1:b260d95:                     return TIMESTAMP_ID;
1:eac0369:                 }
1:eac0369:                 else if (javaTypeName.equals("java.sql.Blob"))
1:eac0369:                 {
1:b260d95:                     return BLOB_ID;
1:eac0369:                 }
1:eac0369:                 else if (javaTypeName.equals("java.sql.Clob"))
1:eac0369:                 {
1:b260d95:                     return CLOB_ID;
1:b260d95: 
1:eac0369:                 }
1:099e28f:                 else if (javaTypeName.equals("org.apache.derby.iapi.types.XML"))
1:eac0369:                 {
1:b260d95:                     return XML_ID;
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                         /*
1:eac0369:                         ** If it's a Java primitive type, return null to indicate that
1:eac0369:                         ** there is no corresponding SQL type (all the Java primitive
1:eac0369:                         ** types that have corresponding SQL types are handled above).
1:eac0369:                         **
1:eac0369:                         ** There is only one primitive type not mentioned above, char.
1:eac0369:                         */
1:eac0369:                         if (javaTypeName.equals("char"))
1:eac0369:                         {
1:eac0369:                                 return null;
1:eac0369:                         }
1:eac0369: 
1:eac0369:                         /*
1:eac0369:                         ** It's a non-primitive type (a class) that does not correspond
1:eac0369:                         ** to a SQL built-in type, so treat it as a user-defined type.
1:eac0369:                         */
1:bbd82de:                         return TypeId.getUserDefinedTypeId(javaTypeName);
1:eac0369:                 }
1:eac0369:         }
1:eac0369: 
1:fbb0d4f:         /**
1:b260d95:          * Given a SQL type name return the corresponding TypeId.
1:b260d95:          * @param SQLTypeName Name of SQL type
1:b260d95:          * @return TypeId or null if there is no corresponding SQL type.
1:b260d95:          */
1:eac0369:         public static TypeId getBuiltInTypeId(String SQLTypeName) {
1:eac0369: 
1:b260d95:         if (SQLTypeName.equals(BOOLEAN_NAME)) {
1:b260d95:             return BOOLEAN_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(CHAR_NAME)) {
1:b260d95:             return CHAR_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(DATE_NAME)) {
1:b260d95:             return DATE_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(DOUBLE_NAME)) {
1:b260d95:             return DOUBLE_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(FLOAT_NAME)) {
1:b260d95:             return DOUBLE_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(INTEGER_NAME)) {
1:b260d95:             return INTEGER_ID;
1:b260d95:         }
1:3bb140c:         if (SQLTypeName.equals(BIGINT_NAME)) {
1:b260d95:             return BIGINT_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(REAL_NAME)) {
1:b260d95:             return REAL_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(SMALLINT_NAME)) {
1:b260d95:             return SMALLINT_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(TIME_NAME)) {
1:b260d95:             return TIME_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(TIMESTAMP_NAME)) {
1:b260d95:             return TIMESTAMP_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(VARCHAR_NAME)) {
1:b260d95:             return VARCHAR_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(BIT_NAME)) {
1:b260d95:             return BIT_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(VARBIT_NAME)) {
1:b260d95:             return VARBIT_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(TINYINT_NAME)) {
1:b260d95:             return TINYINT_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(DECIMAL_NAME)) {
1:b260d95:             return DECIMAL_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(NUMERIC_NAME)) {
1:b260d95:             return NUMERIC_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(LONGVARCHAR_NAME)) {
1:b260d95:             return LONGVARCHAR_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(LONGVARBIT_NAME)) {
1:b260d95:             return LONGVARBIT_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(BLOB_NAME)) {
1:b260d95:             return BLOB_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(CLOB_NAME)) {
1:b260d95:             return CLOB_ID;
1:b260d95:         }
1:b260d95:         if (SQLTypeName.equals(XML_NAME)) {
1:b260d95:             return XML_ID;
1:eac0369:         }
1:eac0369: 
1:b260d95:         // Types defined below here are SQL types and non-JDBC types that are
1:b260d95:         // supported by Derby
1:b260d95:         if (SQLTypeName.equals(REF_NAME)) {
1:b260d95:             return REF_ID;
1:b260d95:         }
1:b260d95:         return null;
1:b260d95:     }
1:b260d95:       
1:eac0369:     /**
1:fbb0d4f:      * Get the TypeId (fundemental type information)
1:fbb0d4f:      * for a catalog type.
1:fbb0d4f:      * @param catalogType
1:fbb0d4f:      * @return TypeId that represents the base type, null if not applicable.
1:fbb0d4f:      */
1:d039ced:     public static TypeId getTypeId(TypeDescriptor catalogType)
1:92268ac:     {
1:d039ced:         TypeDescriptorImpl tdi = (TypeDescriptorImpl) catalogType;
1:fbb0d4f:         final int jdbcType = catalogType.getJDBCTypeId();
1:fbb0d4f:         TypeId typeId = TypeId.getBuiltInTypeId(jdbcType);
1:fbb0d4f:         if (typeId != null)
1:fbb0d4f:             return typeId;
1:fbb0d4f:         
1:fbb0d4f:         if (jdbcType == Types.JAVA_OBJECT) {
1:d039ced:             return new TypeId( StoredFormatIds.USERDEFINED_TYPE_ID_V3, tdi.getTypeId() );
1:d039ced:         }
1:d039ced: 
1:d039ced:         if ( tdi.isRowMultiSet() )
1:d039ced:         {
1:d039ced:             return new TypeId( StoredFormatIds.ROW_MULTISET_TYPE_ID_IMPL, tdi.getTypeId() );
1:fbb0d4f:         }
1:fbb0d4f:         
1:fbb0d4f:         return null;
1:fbb0d4f:     }
1:eac0369: 
1:eac0369:         /*
1:b260d95:          * * Instance fields and methods
1:b260d95:          */
1:eac0369: 
1:eac0369:         private BaseTypeIdImpl  baseTypeId;
1:eac0369:         private int                             formatId;
1:eac0369: 
1:eac0369:         /* Set in setTypeIdSpecificInstanceVariables() as needed */
1:eac0369:         private boolean                 isBitTypeId;
1:eac0369:         private boolean                 isLOBTypeId;
1:eac0369:         private boolean                 isBooleanTypeId;
1:eac0369:         private boolean                 isConcatableTypeId;
1:eac0369:         private boolean                 isDecimalTypeId;
1:eac0369:         private boolean                 isLongConcatableTypeId;
1:eac0369:         private boolean                 isNumericTypeId;
1:eac0369:         private boolean                 isRefTypeId;
1:eac0369:         private boolean                 isStringTypeId;
1:eac0369:         private boolean                 isFloatingPointTypeId;
1:eac0369:         private boolean                 isRealTypeId;
1:eac0369:         private boolean                 isDateTimeTimeStampTypeId;
1:eac0369:         private boolean                 isUserDefinedTypeId;
1:eac0369:         private int                             maxPrecision;
1:eac0369:         private int                             maxScale;
1:eac0369:         private int                             typePrecedence;
1:eac0369:         private String                  javaTypeName;
1:eac0369:         private int                             maxMaxWidth;
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Constructor for a TypeId
1:eac0369:          *
2:eac0369:          * @param formatId      Format id of specific type id.
1:eac0369:          * @param baseTypeId    The Base type id
1:eac0369:          */
1:eac0369:         public TypeId(int formatId, BaseTypeIdImpl baseTypeId)
1:eac0369:         {
3:eac0369:                 this.formatId = formatId;
2:eac0369:                 this.baseTypeId = baseTypeId;
4:eac0369:                 setTypeIdSpecificInstanceVariables();
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * we want equals to say if these are the same type id or not.
1:eac0369:          */
1:eac0369:         public boolean equals(Object that)
1:eac0369:         {
1:eac0369:                 if (that instanceof TypeId)
1:eac0369:                         return this.getSQLTypeName().equals(((TypeId)that).getSQLTypeName());
1:eac0369:                 else
2:eac0369:                         return false;
1:eac0369:         }
1:eac0369: 
1:eac0369:         /*
1:eac0369:           Hashcode which works with equals.
1:eac0369:           */
1:eac0369:         public int hashCode()
1:eac0369:         {
1:eac0369:                 return this.getSQLTypeName().hashCode();
1:eac0369:         }
1:eac0369: 
1:eac0369: 
1:eac0369:         private void setTypeIdSpecificInstanceVariables()
1:eac0369:         {
4:eac0369:                 switch (formatId)
1:eac0369:                 {
1:eac0369:                         case StoredFormatIds.BIT_TYPE_ID:
1:eac0369:                                 typePrecedence = BIT_PRECEDENCE;
2:eac0369:                                 javaTypeName = "byte[]";
1:eac0369:                                 maxMaxWidth = TypeId.BIT_MAXWIDTH;
1:eac0369:                                 isBitTypeId = true;
6:eac0369:                                 isConcatableTypeId = true;
23:eac0369:                                 break;
1:ff8ae29: 
1:eac0369:                         case StoredFormatIds.BOOLEAN_TYPE_ID:
1:ff8ae29:                                 maxPrecision = TypeId.BOOLEAN_MAXWIDTH;
1:eac0369:                                 typePrecedence = BOOLEAN_PRECEDENCE;
1:eac0369:                                 javaTypeName = "java.lang.Boolean";
1:eac0369:                                 maxMaxWidth = TypeId.BOOLEAN_MAXWIDTH;
1:eac0369:                                 isBooleanTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.CHAR_TYPE_ID:
1:eac0369:                                 typePrecedence = CHAR_PRECEDENCE;
6:eac0369:                                 javaTypeName = "java.lang.String";
1:eac0369:                                 maxMaxWidth = TypeId.CHAR_MAXWIDTH;
1:92268ac:                                 isStringTypeId = true;
1:92268ac:                                 isConcatableTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.DATE_TYPE_ID:
1:eac0369:                                 typePrecedence = DATE_PRECEDENCE;
1:eac0369:                                 javaTypeName = "java.sql.Date";
1:fd58c3c:                                 maxMaxWidth = TypeId.DATE_MAXWIDTH;
1:fd58c3c:                                 maxPrecision = TypeId.DATE_MAXWIDTH;
1:eac0369:                                 isDateTimeTimeStampTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.DECIMAL_TYPE_ID:
1:eac0369:                                 maxPrecision = TypeId.DECIMAL_PRECISION;
1:eac0369:                                 maxScale = TypeId.DECIMAL_SCALE;
1:eac0369:                                 typePrecedence = DECIMAL_PRECEDENCE;
1:eac0369:                                 javaTypeName = "java.math.BigDecimal";
1:eac0369:                                 maxMaxWidth = TypeId.DECIMAL_MAXWIDTH;
1:eac0369:                                 isDecimalTypeId = true;
1:eac0369:                                 isNumericTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.DOUBLE_TYPE_ID:
1:eac0369:                                 maxPrecision = TypeId.DOUBLE_PRECISION;
1:eac0369:                                 maxScale = TypeId.DOUBLE_SCALE;
1:eac0369:                                 typePrecedence = DOUBLE_PRECEDENCE;
1:eac0369:                                 javaTypeName = "java.lang.Double";
1:eac0369:                                 maxMaxWidth = TypeId.DOUBLE_MAXWIDTH;
1:eac0369:                                 isNumericTypeId = true;
1:eac0369: 								isFloatingPointTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.INT_TYPE_ID:
1:eac0369:                                 maxPrecision = TypeId.INT_PRECISION;
1:eac0369:                                 maxScale = TypeId.INT_SCALE;
1:eac0369:                                 typePrecedence = INT_PRECEDENCE;
1:eac0369:                                 javaTypeName = "java.lang.Integer";
1:eac0369:                                 maxMaxWidth = TypeId.INT_MAXWIDTH;
1:eac0369:                                 isNumericTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:3bb140c:                         case StoredFormatIds.BIGINT_TYPE_ID:
1:eac0369:                                 maxPrecision = TypeId.LONGINT_PRECISION;
1:eac0369:                                 maxScale = TypeId.LONGINT_SCALE;
1:eac0369:                                 typePrecedence = LONGINT_PRECEDENCE;
1:eac0369:                                 javaTypeName = "java.lang.Long";
1:eac0369:                                 maxMaxWidth = TypeId.LONGINT_MAXWIDTH;
1:eac0369:                                 isNumericTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.LONGVARBIT_TYPE_ID:
1:eac0369:                                 typePrecedence = LONGVARBIT_PRECEDENCE;
1:eac0369:                                 javaTypeName = "byte[]";
1:eac0369:                                 maxMaxWidth = TypeId.LONGVARBIT_MAXWIDTH;
1:eac0369:                                 isBitTypeId = true;
1:eac0369:                                 isConcatableTypeId = true;
2:eac0369:                                 isLongConcatableTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.LONGVARCHAR_TYPE_ID:
1:eac0369:                                 typePrecedence = LONGVARCHAR_PRECEDENCE;
1:eac0369:                                 javaTypeName = "java.lang.String";
1:eac0369:                                 maxMaxWidth = TypeId.LONGVARCHAR_MAXWIDTH;
6:eac0369:                                 isStringTypeId = true;
1:eac0369:                                 isConcatableTypeId = true;
1:eac0369:                                 isLongConcatableTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.REAL_TYPE_ID:
1:eac0369:                                 maxPrecision = TypeId.REAL_PRECISION;
1:eac0369:                                 maxScale = TypeId.REAL_SCALE;
1:eac0369:                                 typePrecedence = REAL_PRECEDENCE;
1:eac0369:                                 javaTypeName = "java.lang.Float";
1:eac0369:                                 maxMaxWidth = TypeId.REAL_MAXWIDTH;
1:eac0369:                                 isNumericTypeId = true;
1:eac0369:                                 isRealTypeId = true;
1:eac0369:                                 isFloatingPointTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.REF_TYPE_ID:
1:eac0369:                                 typePrecedence = REF_PRECEDENCE;
1:f2a5622:                                 javaTypeName = "java.sql.Ref";
1:eac0369:                                 isRefTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.SMALLINT_TYPE_ID:
1:eac0369:                                 maxPrecision = TypeId.SMALLINT_PRECISION;
1:eac0369:                                 maxScale = TypeId.SMALLINT_SCALE;
1:eac0369:                                 typePrecedence = SMALLINT_PRECEDENCE;
1:eac0369:                                 javaTypeName = "java.lang.Integer";
1:eac0369:                                 maxMaxWidth = TypeId.SMALLINT_MAXWIDTH;
1:eac0369:                                 isNumericTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.TIME_TYPE_ID:
1:eac0369:                                 typePrecedence = TIME_PRECEDENCE;
1:eac0369:                                 javaTypeName = "java.sql.Time";
1:fd58c3c:                                 maxScale = TypeId.TIME_SCALE;
1:fd58c3c:                                 maxMaxWidth = TypeId.TIME_MAXWIDTH;
1:fd58c3c:                                 maxPrecision = TypeId.TIME_MAXWIDTH;
1:eac0369:                                 isDateTimeTimeStampTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.TIMESTAMP_TYPE_ID:
1:eac0369:                                 typePrecedence = TIMESTAMP_PRECEDENCE;
1:eac0369:                                 javaTypeName = "java.sql.Timestamp";
1:fd58c3c:                                 maxScale = TypeId.TIMESTAMP_SCALE;
1:fd58c3c:                                 maxMaxWidth = TypeId.TIMESTAMP_MAXWIDTH;
1:fd58c3c:                                 maxPrecision = TypeId.TIMESTAMP_MAXWIDTH;
1:eac0369:                                 isDateTimeTimeStampTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.TINYINT_TYPE_ID:
1:eac0369:                                 maxPrecision = TypeId.TINYINT_PRECISION;
1:eac0369:                                 maxScale = TypeId.TINYINT_SCALE;
1:eac0369:                                 typePrecedence = TINYINT_PRECEDENCE;
1:eac0369:                                 javaTypeName = "java.lang.Integer";
1:eac0369:                                 maxMaxWidth = TypeId.TINYINT_MAXWIDTH;
1:eac0369:                                 isNumericTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
3:eac0369:                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
1:eac0369:                                 if (baseTypeId != null)
1:eac0369:                                 {
2:eac0369:                                         setUserTypeIdInfo();
1:eac0369:                                 }
1:eac0369:                                 else
1:eac0369:                                 {
1:eac0369:                                         typePrecedence = USER_PRECEDENCE;
1:eac0369:                                 }
4:eac0369:                                 maxMaxWidth = -1;
1:eac0369:                                 isUserDefinedTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.VARBIT_TYPE_ID:
1:eac0369:                                 typePrecedence = VARBIT_PRECEDENCE;
1:eac0369:                                 javaTypeName = "byte[]";
1:eac0369:                                 maxMaxWidth = TypeId.VARBIT_MAXWIDTH;
1:eac0369:                                 isBitTypeId = true;
1:eac0369:                                 isConcatableTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.BLOB_TYPE_ID:
1:eac0369:                                 typePrecedence = BLOB_PRECEDENCE;
1:806114c:                                 javaTypeName = "java.sql.Blob";
1:eac0369:                                 maxMaxWidth = TypeId.BLOB_MAXWIDTH;
1:eac0369:                                 isBitTypeId = true;
1:eac0369:                                 isConcatableTypeId = true;
2:eac0369:                                 isLongConcatableTypeId = true; // ??
2:eac0369:                                 isLOBTypeId = true;
1:92268ac:                                 break;
1:92268ac: 
1:eac0369:                         case StoredFormatIds.VARCHAR_TYPE_ID:
1:eac0369:                                 typePrecedence = VARCHAR_PRECEDENCE;
1:eac0369:                                 javaTypeName = "java.lang.String";
1:92268ac:                                 maxMaxWidth = TypeId.VARCHAR_MAXWIDTH;
1:eac0369:                                 isStringTypeId = true;
1:eac0369:                                 isConcatableTypeId = true;
1:eac0369:                                 break;
1:eac0369: 
1:4aac5f7:                       case StoredFormatIds.CLOB_TYPE_ID:
1:eac0369:                               typePrecedence = CLOB_PRECEDENCE;
1:806114c:                               javaTypeName = "java.sql.Clob";
1:eac0369:                               maxMaxWidth = TypeId.CLOB_MAXWIDTH;
1:eac0369:                               isStringTypeId = true;
1:eac0369:                               isConcatableTypeId = true;
1:eac0369:                               isLongConcatableTypeId = true; // ??
1:eac0369:                               isLOBTypeId = true;
1:eac0369:                               break;
1:eac0369: 
1:099e28f:                       case StoredFormatIds.XML_TYPE_ID:
1:be12a80: 
1:099e28f:                               typePrecedence = XML_PRECEDENCE;
1:099e28f:                               javaTypeName = "org.apache.derby.iapi.types.XML";
1:099e28f:                               maxMaxWidth = TypeId.XML_MAXWIDTH;
1:be12a80: 
1:be12a80:                               // We set this to true in order to disallow use
1:be12a80:                               // of the XML datatype for procedure/function args.
1:be12a80:                               isLongConcatableTypeId = true;
1:eac0369:                               break;
1:eac0369: 
1:eac0369:                 }
1:eac0369: 
1:eac0369:         }
1:eac0369:         /**
1:eac0369:          * JDBC has its own idea of type identifiers which is different from
1:3fd26f3:          * the Derby internal type ids.  The JDBC type ids are defined
1:eac0369:          * as public final static ints in java.sql.Types.  This method translates
1:3fd26f3:          * a Derby internal TypeId to a JDBC type id. For java objects this
1:eac0369:          * returns JAVA_OBJECT in Java2 and OTHER in JDK 1.1. For Boolean datatypes,
1:eac0369:          * this returns Type.BOOLEAN in JDK1.4 and Type.BIT for jdks prior to 1.4
1:eac0369:          *
1:eac0369:          * @return      The JDBC type Id for this type
1:eac0369:          */
1:eac0369:         public final int getJDBCTypeId()
1:eac0369:         {
1:eac0369:                 return baseTypeId.getJDBCTypeId();
1:eac0369:         }
1:eac0369:         /**
1:eac0369:          * Returns the SQL name of the datatype. If it is a user-defined type,
1:eac0369:          * it returns the full Java path name for the datatype, meaning the
1:eac0369:          * dot-separated path including the package names.
1:eac0369:          *
1:eac0369:          * @return      A String containing the SQL name of this type.
1:eac0369:          */
1:eac0369:         public String   getSQLTypeName()
1:eac0369:         {
1:eac0369:                 return baseTypeId.getSQLTypeName();
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
3:eac0369:          * Tell whether this is a built-in type.
3:eac0369:          * NOTE: There are 3 "classes" of types:
3:eac0369:          *                      built-in                - system provided types which are implemented internally
3:eac0369:          *                                                        (int, smallint, etc.)
3:eac0369:          *                      system built-in - system provided types, independent of implementation
3:eac0369:          *                                                        (date, time, etc.)
3:eac0369:          *                      user types              - types implemented outside of the system
3:eac0369:          *                                                        (java.lang.Integer, asdf.asdf.asdf, etc.)
1:eac0369:          *
3:eac0369:          * @return      true for built-in types, false for user-defined types.
1:eac0369:          */
1:eac0369:         public final boolean userType()
1:eac0369:         {
1:eac0369:                 return baseTypeId.userType();
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get the maximum precision of the type.  For types with variable
1:eac0369:          * precision, this is an arbitrary high precision.
1:eac0369:          *
1:eac0369:          * @return      The maximum precision of the type
1:eac0369:          */
1:eac0369:         public int getMaximumPrecision()
1:eac0369:         {
1:eac0369:                 return maxPrecision;
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get the maximum scale of the type.  For types with variable scale,
1:eac0369:          * this is an arbitrary high scale.
1:eac0369:          *
1:eac0369:          * @return      The maximum scale of the type
1:eac0369:          */
1:eac0369:         public int getMaximumScale()
1:eac0369:         {
1:eac0369:                 return maxScale;
1:eac0369:         }
1:eac0369: 
1:eac0369:         private void setUserTypeIdInfo()
1:eac0369:         {
2:eac0369:                 UserDefinedTypeIdImpl baseUserTypeId =
2:eac0369:                                                         (UserDefinedTypeIdImpl) baseTypeId;
1:eac0369:                 typePrecedence = USER_PRECEDENCE;
1:eac0369:                 javaTypeName = baseUserTypeId.getClassName();
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Does this TypeId represent a TypeId for a StringDataType.
1:eac0369:          *
1:eac0369:          * @return Whether or not this TypeId represents a TypeId for a StringDataType.
1:eac0369:          */
1:eac0369:         public boolean isStringTypeId()
1:eac0369:         {
1:eac0369:                 return isStringTypeId;
1:eac0369:         }
1:eac0369: 
1:eac0369: 		/**
1:eac0369: 		 * Is this a TypeId for DATE/TIME/TIMESTAMP
1:eac0369: 		 *
1:eac0369: 		 * @return true if this is a DATE/TIME/TIMESTAMP
1:eac0369: 		 */
1:eac0369: 		public boolean isDateTimeTimeStampTypeId()
1:eac0369: 		{
1:eac0369: 				return isDateTimeTimeStampTypeId;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/**
1:eac0369: 		 * Is this a TypeId for REAL
1:eac0369: 		 *
1:eac0369: 		 * @return true if this is a REAL
1:eac0369: 		 */
1:eac0369: 		public boolean isRealTypeId()
1:eac0369: 		{
1:eac0369: 				return isRealTypeId;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/**
1:eac0369: 		 * Is this a TypeId for floating point (REAL/DOUBLE)
1:eac0369: 		 *
1:eac0369: 		 * @return true if this is a REAL or DOUBLE
1:eac0369: 		 */
1:eac0369: 		public boolean isFloatingPointTypeId()
1:eac0369: 		{
1:eac0369: 				return isFloatingPointTypeId;
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		/**
1:eac0369: 		 * Is this a TypeId for DOUBLE
1:eac0369: 		 *
1:eac0369: 		 * @return true if this is a DOUBLE
1:eac0369: 		 */
1:eac0369: 		public boolean isDoubleTypeId()
1:eac0369: 		{
1:eac0369: 				return isFloatingPointTypeId && (! isRealTypeId);
1:eac0369: 		}
1:eac0369: 	
1:eac0369: 		/**
1:eac0369: 		 * Is this a fixed string type?
1:111785f: 		 * @return true if this is CHAR
1:eac0369: 		 */
1:eac0369: 		public boolean isFixedStringTypeId()
1:eac0369: 		{
1:111785f: 				return (formatId == StoredFormatIds.CHAR_TYPE_ID);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/** 
1:eac0369: 		 *Is this a Clob?
1:111785f: 		 * @return true if this is CLOB
1:eac0369: 		 */
1:eac0369: 		public boolean isClobTypeId()
1:eac0369: 		{
1:111785f: 			   return (formatId == StoredFormatIds.CLOB_TYPE_ID);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/** 
1:eac0369: 		 *Is this a Blob?
1:eac0369: 		 * @return true if this is BLOB
1:eac0369: 		 */
1:eac0369: 		public boolean isBlobTypeId()
1:eac0369: 		{
1:eac0369: 				return ((formatId == StoredFormatIds.BLOB_TYPE_ID));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	
1:eac0369: 		/** 
1:eac0369: 		 *Is this a LongVarchar?
1:eac0369: 		 * @return true if this is LongVarchar
1:eac0369: 		 */
1:eac0369: 		public boolean isLongVarcharTypeId()
1:eac0369: 		{
1:111785f: 				return (formatId == StoredFormatIds.LONGVARCHAR_TYPE_ID);
1:eac0369: 		}
1:eac0369: 
1:f432362: 		/** 
1:f432362: 		 *Is this a LongVarbinary?
1:f432362: 		 * @return true if this is LongVarbinary
1:f432362: 		 */
1:f432362: 		public boolean isLongVarbinaryTypeId()
1:f432362: 		{
1:f432362: 				return (formatId == StoredFormatIds.LONGVARBIT_TYPE_ID);
1:f432362: 		}
1:f432362: 
1:eac0369: 
1:eac0369: 		/** 
1:eac0369: 		 * Is this DATE/TIME or TIMESTAMP?
1:eac0369: 		 *
1:eac0369: 		 * @return true if this DATE/TIME or TIMESTAMP
1:eac0369: 		 */
1:eac0369: 		public boolean isDateTimeTimeStampTypeID()
1:eac0369: 		{
1:eac0369: 				return ((formatId == StoredFormatIds.DATE_TYPE_ID) ||
1:eac0369: 						(formatId == StoredFormatIds.TIME_TYPE_ID) ||
1:eac0369: 						(formatId == StoredFormatIds.TIMESTAMP_TYPE_ID));
1:eac0369: 		}
1:eac0369: 
1:c1a0ff2:         /**
1:c1a0ff2:          * Is this a TIMESTAMP?
1:c1a0ff2:          *
1:c1a0ff2:          * @return true if this is a TIMESTAMP
1:c1a0ff2:          */
1:c1a0ff2:         public boolean isTimestampId() {
1:c1a0ff2:             return (formatId == StoredFormatIds.TIMESTAMP_TYPE_ID);
1:c1a0ff2:         }
1:c1a0ff2: 
1:eac0369:         /** 
1:099e28f:          *Is this an XML doc?
1:4aef9b0:          * @return true if this is XML
1:4aef9b0:          */
1:099e28f:         public boolean isXMLTypeId()
1:4aef9b0:         {
1:099e28f:                return (formatId == StoredFormatIds.XML_TYPE_ID);
1:4aef9b0:         }
1:4aef9b0: 
1:4aef9b0: 	
1:eac0369:         /**
1:eac0369:          * Tell whether this type is orderable, that is, can participate
1:eac0369:          * in comparisons.
1:eac0369:          *
1:eac0369:          * @param cf    A ClassFactory
1:eac0369:          *
1:eac0369:          * @return      true for orderable types, false for non-orderable types.
1:eac0369:          */
1:eac0369:         public boolean orderable(ClassFactory cf)
1:eac0369:         {
1:eac0369:                 boolean orderable;
1:eac0369:                 switch (formatId)
1:eac0369:                 {
1:eac0369:                         // cmp not allowed, indexing not allowed
1:eac0369:                         case StoredFormatIds.BLOB_TYPE_ID:
1:eac0369:                         case StoredFormatIds.CLOB_TYPE_ID:
1:eac0369:                         case StoredFormatIds.LONGVARCHAR_TYPE_ID:
1:099e28f:                         case StoredFormatIds.XML_TYPE_ID:
1:077fe39:                         case StoredFormatIds.LONGVARBIT_TYPE_ID:
1:eac0369:                                 return false;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
1:eac0369:                                 /* Is this type orderable? */
1:eac0369: 
1:f2a5622:                             // The following code is disabled until we support
1:f2a5622:                             // comparable UDTs.
1:f2a5622:                             return false;
1:f2a5622: 
1:eac0369:                                 // For user java classes we are orderable if we
1:eac0369:                                 // implement java.lang.Orderable (JDK1.2) or
1:eac0369:                                 // have a int compareTo(Object) method (JDK1.1 or JDK1.2)
1:f2a5622:                             //                                UserDefinedTypeIdImpl baseUserTypeId =
1:f2a5622:                             //                                                                                (UserDefinedTypeIdImpl) baseTypeId;
1:f2a5622:                             //
1:f2a5622:                             //                                String className = baseUserTypeId.getClassName();
1:f2a5622:                             //
1:f2a5622:                             //                                try 
1:f2a5622:                             //                                {
1:f2a5622:                             //                                        Class c = cf.getClassInspector().getClass(className);
1:f2a5622:                             //                                        orderable = java.lang.Comparable.class.isAssignableFrom(c);
1:f2a5622:                             //                                } 
1:f2a5622:                             //                                catch (ClassNotFoundException cnfe) 
1:f2a5622:                             //                                {
1:f2a5622:                             //                                        orderable = false;
1:f2a5622:                             //                                } 
1:f2a5622:                                 //                                break;
1:eac0369: 
2:eac0369:                         default:
1:eac0369:                                 orderable = true;
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 return orderable;
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Each built-in type in JSQL has a precedence.  This precedence determines
1:eac0369:          * how to do type promotion when using binary operators.  For example, float
1:eac0369:          * has a higher precedence than int, so when adding an int to a float, the
1:eac0369:          * result type is float.
1:eac0369:          *
1:eac0369:          * The precedence for some types is arbitrary.  For example, it doesn't
1:eac0369:          * matter what the precedence of the boolean type is, since it can't be
1:eac0369:          * mixed with other types.  But the precedence for the number types is
1:eac0369:          * critical.  The SQL standard requires that exact numeric types be
1:eac0369:          * promoted to approximate numeric when one operator uses both.  Also,
1:eac0369:          * the precedence is arranged so that one will not lose precision when
1:eac0369:          * promoting a type.
1:eac0369:          * NOTE: char, varchar, and longvarchar must appear at the bottom of
1:eac0369:          * the hierarchy, but above USER_PRECEDENCE, since we allow the implicit
1:eac0369:          * conversion of those types to any other built-in system type.
1:eac0369:          *
1:eac0369:          * @return              The precedence of this type.
1:eac0369:          */
1:eac0369:         public int typePrecedence()
1:eac0369:         {
1:eac0369:                 return typePrecedence;
1:eac0369:         }
1:eac0369: 
1:eac0369:          /**
1:eac0369:          * Get the name of the corresponding Java type.
1:eac0369:          *
1:eac0369:          * Each SQL type has a corresponding Java type.  When a SQL value is
1:eac0369:          * passed to a Java method, it is translated to its corresponding Java
1:eac0369:          * type.  For example, when a SQL date column is passed to a method,
1:eac0369:          * it is translated to a java.sql.Date.
1:eac0369:          *
1:eac0369:          * @return      The name of the corresponding Java type.
1:eac0369:          */
1:eac0369:         public String getCorrespondingJavaTypeName()
1:eac0369:         {
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                         SanityManager.ASSERT(javaTypeName != null,
1:eac0369:                                 "javaTypeName expected to be non-null");
1:eac0369:                 }
1:eac0369:                 return javaTypeName;
1:eac0369:         }
1:eac0369: 
1:eac0369:          /**
1:eac0369:          * Get the name of the corresponding Java type.
1:eac0369:          *
1:eac0369:          * This method is used directly from EmbedResultSetMetaData (jdbc)
1:eac0369:          * to return the corresponding type (as choosen by getObject).
1:eac0369:          * It solves a specific problem for BLOB types where the 
1:eac0369:          * getCorrespondingJavaTypeName() is used internall for casting
1:eac0369:          * which doesn't work if changed from byte[] to java.sql.Blob.
1:eac0369:          * So we do it here instread, to avoid unexpected sideeffects.
1:eac0369:          *
1:eac0369:          * @return      The name of the corresponding Java type.
1:eac0369:          */
1:eac0369:         public String getResultSetMetaDataTypeName()
1:eac0369:         {
1:bd4b50b:             if ((BLOB_ID != null) && BLOB_ID.equals(this))
1:eac0369:                 return "java.sql.Blob";
1:bd4b50b:             if ((CLOB_ID != null) && CLOB_ID.equals(this))
2:eac0369:                 return "java.sql.Clob";
1:eac0369:             return getCorrespondingJavaTypeName();
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get the maximum maximum width of the type (that's not a typo).  For
1:eac0369:          * types with variable length, this is the absolute maximum for the type.
1:eac0369:          *
1:eac0369:          * @return      The maximum maximum width of the type
1:eac0369:          */
1:eac0369:         public int getMaximumMaximumWidth()
1:eac0369:         {
1:eac0369:                 return maxMaxWidth;
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Converts this TypeId, given a data type descriptor (including length/precision),
1:eac0369:          * to a string. E.g.
1:eac0369:          *
1:eac0369:          *                      VARCHAR(30)
1:eac0369:          *
1:eac0369:          *
1:eac0369:          *      For most data types, we just return the SQL type name.
1:eac0369:          *
1:eac0369:          *      @param  dts     Data type descriptor that holds the length/precision etc. as necessary
1:eac0369:          *
1:eac0369:          *       @return        String version of datatype, suitable for running through
1:eac0369:          *                      the Parser.
1:eac0369:          */
1:eac0369:         public String   toParsableString(DataTypeDescriptor dts)
1:eac0369:         {
1:2e83f13:                 return  baseTypeId.toParsableString(dts.getCatalogType());
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Is this a type id for a numeric type?
1:eac0369:          *
1:eac0369:          * @return Whether or not this a type id for a numeric type.
1:eac0369:          */
1:eac0369:         public boolean isNumericTypeId()
1:eac0369:         {
1:eac0369:                 return isNumericTypeId;
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Is this a type id for a decimal type?
1:eac0369:          *
1:eac0369:          * @return Whether or not this a type id for a decimal type.
1:eac0369:          */
1:eac0369:         public boolean isDecimalTypeId()
1:eac0369:         {
1:eac0369:                 return isDecimalTypeId;
1:eac0369:         }
1:eac0369: 
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Is this a type id for a boolean type?
1:eac0369:          *
1:eac0369:          * @return Whether or not this a type id for a boolean type.
1:eac0369:          */
1:eac0369:         public boolean isBooleanTypeId()
1:eac0369:         {
1:eac0369:                 return isBooleanTypeId;
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Is this a type id for a ref type?
1:eac0369:          *
1:eac0369:          * @return Whether or not this a type id for a ref type.
1:eac0369:          */
1:eac0369:         public boolean isRefTypeId()
1:eac0369:         {
1:eac0369:                 return isRefTypeId;
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Is this a type id for a concatable type?
1:eac0369:          *
1:eac0369:          * @return Whether or not this a type id for a concatable type.
1:eac0369:          */
1:eac0369:         public boolean isConcatableTypeId()
1:eac0369:         {
1:eac0369:                 return isConcatableTypeId;
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Is this a type id for a bit type?
1:eac0369:          *
1:eac0369:          * @return Whether or not this a type id for a bit type.
1:eac0369:          */
1:eac0369:         public boolean isBitTypeId()
1:eac0369:         {
1:eac0369:                 return isBitTypeId;
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Is this a type id for a LOB type?
1:eac0369:          *
1:eac0369:          * @return Whether or not this a type id for a LOB type.
1:eac0369:          */
1:eac0369:         public boolean isLOBTypeId()
1:eac0369:         {
1:eac0369:                 return isLOBTypeId;
1:eac0369:         }
1:eac0369: 
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Is this a type id for a long concatable type?
1:eac0369:          *
1:eac0369:          * @return Whether or not this a type id for a long concatable type.
1:eac0369:          */
1:eac0369:         public boolean isLongConcatableTypeId()
1:eac0369:         {
1:eac0369:                 return isLongConcatableTypeId;
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Is this a type id for a user defined type?
1:eac0369:          *
1:eac0369:          * @return Whether or not this a type id for a user defined type.
1:eac0369:          */
1:eac0369:         public boolean isUserDefinedTypeId()
1:eac0369:         {
1:eac0369:                 return isUserDefinedTypeId;
1:eac0369:         }
1:eac0369: 
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get the formatID which corresponds to this class.
1:eac0369:          *
1:eac0369:          *      @return the formatID of this class
1:eac0369:          */
1:eac0369:         public  int     getTypeFormatId()       
1:eac0369:         { 
1:eac0369:                 return formatId; 
1:eac0369:         }
1:eac0369: 
1:eac0369: 
1:eac0369:         /** 
1:eac0369:          *  Get SQL null value.
1:eac0369:          *  @return SQL null value for this type.
1:eac0369:          */
1:eac0369:         public DataValueDescriptor getNull()
1:eac0369:         {
1:eac0369:                 switch (formatId)
1:eac0369:                 {
1:eac0369:                         case StoredFormatIds.BIT_TYPE_ID:
1:eac0369:                                 return new SQLBit();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.BOOLEAN_TYPE_ID:
1:eac0369:                                 return new SQLBoolean();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.CHAR_TYPE_ID:
1:eac0369:                                 return new SQLChar();
1:eac0369: 
1:e11914a:                         // Implementation of DECIMAL can change.
1:eac0369:                         case StoredFormatIds.DECIMAL_TYPE_ID:
1:5465561:                             return new SQLDecimal();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.DOUBLE_TYPE_ID:
1:eac0369:                                 return new SQLDouble();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.INT_TYPE_ID:
1:eac0369:                                 return new SQLInteger();
1:eac0369: 
1:3bb140c:                         case StoredFormatIds.BIGINT_TYPE_ID:
1:eac0369:                                 return new SQLLongint();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.LONGVARBIT_TYPE_ID:
1:eac0369:                                 return new SQLLongVarbit();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.BLOB_TYPE_ID:
1:eac0369:                                 return new SQLBlob();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.CLOB_TYPE_ID:
1:eac0369:                                 return new SQLClob();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.LONGVARCHAR_TYPE_ID:
1:eac0369:                                 return new SQLLongvarchar();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.REAL_TYPE_ID:
1:eac0369:                                 return new SQLReal();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.REF_TYPE_ID:
1:eac0369:                                 return new SQLRef();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.SMALLINT_TYPE_ID:
1:eac0369:                                 return new SQLSmallint();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.TINYINT_TYPE_ID:
1:eac0369:                                 return new SQLTinyint();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.DATE_TYPE_ID:
1:eac0369:                                 return new SQLDate();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.TIME_TYPE_ID:
1:eac0369:                                 return new SQLTime();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.TIMESTAMP_TYPE_ID:
1:eac0369:                                 return new SQLTimestamp();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
1:eac0369:                                 return new UserType();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.VARBIT_TYPE_ID:
1:eac0369:                                 return new SQLVarbit();
1:eac0369: 
1:eac0369:                         case StoredFormatIds.VARCHAR_TYPE_ID:
1:eac0369:                                 return new SQLVarchar();
1:92268ac: 
1:099e28f:                         case StoredFormatIds.XML_TYPE_ID:
1:099e28f:                                 return new XML();
1:eac0369: 
1:eac0369:                         default:
1:eac0369:                                 if (SanityManager.DEBUG)
1:eac0369:                                 {
1:eac0369:                                         SanityManager.THROWASSERT(
1:eac0369:                                                 "unexpected formatId in getNull() - " + formatId);
1:eac0369:                                 }
1:eac0369:                                 return null;
1:eac0369:                 }
1:eac0369:         }
1:eac0369:         /**
1:eac0369:          * Is this type StreamStorable?
1:eac0369:          *
1:eac0369:          * @return      true if this type has variable length.
1:eac0369:          */
1:eac0369:         public boolean  streamStorable() {
1:eac0369:                 return isStringTypeId() || isBitTypeId();
1:eac0369:         }
1:eac0369: 
1:eac0369: 
1:eac0369:         //
1:eac0369:         //      Class methods
1:eac0369:         //
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get the approximate length of this type in bytes.
1:eac0369:          * For most datatypes this is just going to be
1:eac0369:          * dts.getMaximumWidth().  Some types, such as
1:eac0369:          * bit, will override this.
1:eac0369:          *
1:eac0369:          * @param dts Data type descriptor that holds the 
1:eac0369:          *              length/precision etc. as necessary
1:eac0369:          *
1:eac0369:          * @return the length in bytes
1:eac0369:          */
1:eac0369:         public int getApproximateLengthInBytes(DataTypeDescriptor dts)
1:eac0369:         {
1:eac0369:                 switch (formatId)
1:eac0369:                 {
1:eac0369:                         case StoredFormatIds.BIT_TYPE_ID:
1:eac0369:                                 return (int)(Math.ceil(dts.getMaximumWidth()/8d));
1:eac0369: 
1:eac0369:                         case StoredFormatIds.CHAR_TYPE_ID:
1:eac0369:                                 return (2 * dts.getMaximumWidth()) + 2;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.DECIMAL_TYPE_ID:
1:eac0369:                                 // Return 200 if precision is max int
1:eac0369:                                 if (dts.getPrecision() == Integer.MAX_VALUE)
1:eac0369:                                 {
1:eac0369:                                         return 200;
1:eac0369:                                 }
1:eac0369:                                 else
1:eac0369:                                 {
1:eac0369:                                         return 8 + (int) (Math.ceil(((double)dts.getPrecision())/2d));
1:eac0369:                                 }
1:eac0369: 
1:eac0369:                         case StoredFormatIds.LONGVARBIT_TYPE_ID:
1:eac0369:                         case StoredFormatIds.BLOB_TYPE_ID:
1:eac0369:                         case StoredFormatIds.CLOB_TYPE_ID:
1:099e28f:                         // RESOLVE: Should XML be here?  What's this value mean, anyway?
1:099e28f:                         case StoredFormatIds.XML_TYPE_ID:
1:eac0369:                                 return 10240;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.REF_TYPE_ID:
1:eac0369:                                 return 16;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
1:eac0369:                                 /* For user types we'll guess on the high side
1:eac0369:                                 ** (200) to avoid being too low in most cases.
1:eac0369:                                 */
1:eac0369:                                 return 200;
1:eac0369: 
1:eac0369:                         case StoredFormatIds.VARBIT_TYPE_ID:
1:eac0369:                                 // Return 200 if maximum width is max int
1:eac0369:                                 if (dts.getMaximumWidth() == Integer.MAX_VALUE)
1:eac0369:                                 {
1:eac0369:                                         return 200;
1:eac0369:                                 }
1:eac0369:                                 else
1:eac0369:                                 {
1:eac0369:                                         return (int)(Math.ceil(dts.getMaximumWidth()/8d));
1:eac0369:                                 }
1:eac0369: 
1:eac0369:                         case StoredFormatIds.VARCHAR_TYPE_ID:
1:eac0369:                         case StoredFormatIds.LONGVARCHAR_TYPE_ID:
1:eac0369:                                 // Return 200 if maximum width is max int
1:eac0369:                                 if (dts.getMaximumWidth() == Integer.MAX_VALUE)
1:eac0369:                                 {
1:eac0369:                                         return 200;
1:eac0369:                                 }
1:eac0369:                                 else
1:eac0369:                                 {
1:eac0369:                                         return (dts.getMaximumWidth() * 2) + 2;
1:eac0369:                                 }
1:eac0369:                         /*
1:eac0369:                         ** For Date/time we know the exact size
1:eac0369:                         ** thanks to some investigative work by
1:eac0369:                         ** someone or other (sad isn't it).  
1:eac0369:                         */
1:eac0369:                         case StoredFormatIds.DATE_TYPE_ID:
1:eac0369:                                 return 18;
1:eac0369:                         case StoredFormatIds.TIME_TYPE_ID:
1:eac0369:                                 return 16;
1:eac0369:                         case StoredFormatIds.TIMESTAMP_TYPE_ID:
1:eac0369:                                 return 29;
1:eac0369: 
1:eac0369:                         default:
1:eac0369:                                 return dts.getMaximumWidth();
1:eac0369:                 }
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get the base type id that is embedded in this type id.  The base type
1:eac0369:          * id is an object with a minimal implementation of TypeId that is intended
1:eac0369:          * to be usable on the client side.
1:eac0369:          */
1:eac0369:         public BaseTypeIdImpl getBaseTypeId()
1:eac0369:         {
1:eac0369:                 return baseTypeId;
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get the precision of the merge of two Decimals
1:eac0369:          *
1:eac0369:          * @param leftType the left type
1:eac0369:          * @param rightType the left type
1:eac0369:          *
1:eac0369:          * @return      the resultant precision
1:eac0369:          */
1:eac0369:         public int getPrecision(DataTypeDescriptor leftType,
1:eac0369:                                         DataTypeDescriptor rightType)
1:eac0369:         {
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                         if (formatId != StoredFormatIds.DECIMAL_TYPE_ID)
1:eac0369:                         {
1:eac0369:                                 SanityManager.THROWASSERT(
1:eac0369:                                         "getPrecision() not expected to be called for formatId - " + formatId);
1:eac0369:                         }
1:eac0369:                 }
1:eac0369:                 long lscale = (long)leftType.getScale();
1:eac0369:                 long rscale = (long)rightType.getScale();
1:eac0369:                 long lprec = (long)leftType.getPrecision();
1:eac0369:                 long rprec = (long)rightType.getPrecision();
1:eac0369:                 long val;
1:eac0369: 
1:eac0369:                 /*
1:eac0369:                 ** Take the maximum left of decimal digits plus the scale.
1:eac0369:                 */
1:eac0369:                 val = this.getScale(leftType, rightType) +
1:eac0369:                                         Math.max(lprec - lscale, rprec - rscale);
1:eac0369: 
1:eac0369:                 if (val > Integer.MAX_VALUE)
1:eac0369:                 {
1:eac0369:                         val = Integer.MAX_VALUE;
1:eac0369:                 }
1:eac0369:                 return (int)val;
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get the scale of the merge of two decimals
1:eac0369:          *
1:eac0369:          * @param leftType the left type
1:eac0369:          * @param rightType the left type
1:eac0369:          *
1:eac0369:          * @return      the resultant precision
1:eac0369:          */
1:eac0369:         public int getScale(DataTypeDescriptor leftType,
1:eac0369:                                                 DataTypeDescriptor rightType)
1:eac0369:         {
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                         if (formatId != StoredFormatIds.DECIMAL_TYPE_ID)
1:eac0369:                         {
1:eac0369:                                 SanityManager.THROWASSERT(
1:eac0369:                                         "getPrecision() not expected to be called for formatId - " + formatId);
1:eac0369:                         }
1:eac0369:                 }
1:eac0369:                 /*
1:eac0369:                 ** Retain greatest scale
1:eac0369:                 */
1:eac0369:                 return Math.max(leftType.getScale(), rightType.getScale());
1:eac0369:         }
1:eac0369: 
1:eac0369:         /**
1:4aac5f7:          * Does type hava a declared variable length (defined by the application).
1:4aac5f7:          * Examples are CHAR(10), CLOB(1M).
1:4aac5f7:          * Unbounded long types, like LONG VARCHAR return false here.
1:eac0369:          * @return boolean true if type is variable length false if not.  
1:eac0369:          */
1:eac0369:         public boolean variableLength()
1:eac0369:         {
1:eac0369:                 switch (formatId)
1:eac0369:                 {
1:eac0369:                         case StoredFormatIds.BIT_TYPE_ID:
1:eac0369:                         case StoredFormatIds.VARBIT_TYPE_ID:
1:eac0369:                         case StoredFormatIds.DECIMAL_TYPE_ID:
1:eac0369:                         case StoredFormatIds.CHAR_TYPE_ID:
1:eac0369:                         case StoredFormatIds.VARCHAR_TYPE_ID:
1:eac0369:                         case StoredFormatIds.BLOB_TYPE_ID:
1:eac0369:                         case StoredFormatIds.CLOB_TYPE_ID:
1:4aac5f7:                                  return true;
1:eac0369: 
1:eac0369:                         default:
1:eac0369:                                 return false;
1:eac0369:                 }
1:eac0369:         }
1:eac0369: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:2782d72
/////////////////////////////////////////////////////////////////////////
1:         public static final TypeId DOUBLE_ID = create(
commit:7fd0c6e
/////////////////////////////////////////////////////////////////////////
1:         public static final TypeId BIGINT_ID = create(
commit:7cfb7e6
/////////////////////////////////////////////////////////////////////////
1:         public static final String      REF_CURSOR = "REF CURSOR";
commit:9495437
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:92268ac
/////////////////////////////////////////////////////////////////////////
0:         public static final String      PASSWORD_NAME = "PASSWORD";
/////////////////////////////////////////////////////////////////////////
0:         public static final int PASSWORD_PRECEDENCE  = 200;
/////////////////////////////////////////////////////////////////////////
0:         public static final TypeId PASSWORD_ID = create(
0:                 StoredFormatIds.PASSWORD_TYPE_ID, StoredFormatIds.PASSWORD_TYPE_ID_IMPL);
/////////////////////////////////////////////////////////////////////////
1: 
0:         if ( tdi.getTypeId().getTypeFormatId() == StoredFormatIds.PASSWORD_TYPE_ID_IMPL )
1:         {
0:             return PASSWORD_ID;
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
0:         private boolean                 isPasswordTypeId;
/////////////////////////////////////////////////////////////////////////
0:                         case StoredFormatIds.PASSWORD_TYPE_ID:
0:                                 typePrecedence = PASSWORD_PRECEDENCE;
0:                                 javaTypeName = "char[]";
1:                                 maxMaxWidth = TypeId.VARCHAR_MAXWIDTH;
1:                                 isStringTypeId = true;
0:                                 isPasswordTypeId = true;
1:                                 isConcatableTypeId = true;
1:                                 break;
1: 
/////////////////////////////////////////////////////////////////////////
0:          * Does this TypeId represent a TypeId for a PASSWORD.
1:          *
0:          * @return Whether or not this TypeId represents a TypeId for a PASSWORD.
1:          */
0:         public boolean isPasswordTypeId()
1:         {
0:                 return isPasswordTypeId;
1:         }
1: 
1:         /**
/////////////////////////////////////////////////////////////////////////
0:                         case StoredFormatIds.PASSWORD_TYPE_ID:
0:                                 return new SQLPassword();
1: 
commit:1e90bf4
/////////////////////////////////////////////////////////////////////////
1:         // The format of java.sql.Timestamp.toString()
1:         public static final int TIMESTAMP_MAXWIDTH      = DRDAConstants.DRDA_TIMESTAMP_LENGTH;	// yyyy-mm-dd hh:mm:ss.fffffffff
1:         // it's 9 ('fffffffff'); for a TIME value, it's 0 (because there
1:         public static final int TIMESTAMP_SCALE      = 9;
commit:ff8ae29
/////////////////////////////////////////////////////////////////////////
1:                                 maxPrecision = TypeId.BOOLEAN_MAXWIDTH;
/////////////////////////////////////////////////////////////////////////
1: 
commit:bead0ab
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.DRDAConstants;
/////////////////////////////////////////////////////////////////////////
1: 
0:         // I believe that the following is wrong. The format of java.sql.Timestamp.toString()
1:         // is yyyy-mm-dd hh:mm:ss.fffffffff
0:         public static final int TIMESTAMP_MAXWIDTH      = DRDAConstants.DRDA_TIMESTAMP_LENGTH;	// yyyy-mm-dd hh:mm:ss.ffffff
commit:f2a5622
/////////////////////////////////////////////////////////////////////////
1:     private static final TypeId[] ALL_BUILTIN_TYPE_IDS =
1:     {
1:         BOOLEAN_ID,
1:         SMALLINT_ID,
1:         INTEGER_ID,
1:         CHAR_ID,
1:         TINYINT_ID,
1:         BIGINT_ID,
1:         REAL_ID,
1:         DOUBLE_ID,
1:         DECIMAL_ID,
1:         NUMERIC_ID,
1:         VARCHAR_ID,
1:         DATE_ID,
1:         TIME_ID,
1:         TIMESTAMP_ID,
1:         BIT_ID,
1:         VARBIT_ID,
1:         REF_ID,
1:         LONGVARCHAR_ID,
1:         LONGVARBIT_ID,
1:         BLOB_ID,
1:         CLOB_ID,
1:         XML_ID,
1:     };
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Return all of the builtin type ids.
1:      */
1:     public static TypeId[] getAllBuiltinTypeIds()
1:     {
1:         int count = ALL_BUILTIN_TYPE_IDS.length;
1: 
1:         TypeId[] retval = new TypeId[ count ];
1: 
1:         for ( int i = 0; i < count; i++ ) { retval[ i ] = ALL_BUILTIN_TYPE_IDS[ i ]; }
1: 
1:         return retval;
1:     }
/////////////////////////////////////////////////////////////////////////
1:                                 javaTypeName = "java.sql.Ref";
/////////////////////////////////////////////////////////////////////////
1:                             // The following code is disabled until we support
1:                             // comparable UDTs.
1:                             return false;
1: 
1:                             //                                UserDefinedTypeIdImpl baseUserTypeId =
1:                             //                                                                                (UserDefinedTypeIdImpl) baseTypeId;
1:                             //
1:                             //                                String className = baseUserTypeId.getClassName();
1:                             //
1:                             //                                try 
1:                             //                                {
1:                             //                                        Class c = cf.getClassInspector().getClass(className);
1:                             //                                        orderable = java.lang.Comparable.class.isAssignableFrom(c);
1:                             //                                } 
1:                             //                                catch (ClassNotFoundException cnfe) 
1:                             //                                {
1:                             //                                        orderable = false;
1:                             //                                } 
1:                                 //                                break;
/////////////////////////////////////////////////////////////////////////
commit:2a5922a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
/////////////////////////////////////////////////////////////////////////
1:             throws StandardException
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:             throws StandardException
commit:53c606b
/////////////////////////////////////////////////////////////////////////
1:      * This factory  method is used for ANSI UDTs. If the className argument is null,
1:      *
1:      * @param schemaName Schema that the type definition lives in.
1:      * @param unqualifiedName The second part of the ANSI dot-separated name for the type.
1:      * @param className The Java class which is bound to the schema-qualified name by the CREATE TYPE statement.
1:      *
1:      * @return A bound type TypeId describing this ANSI UDT.
commit:d039ced
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.types.TypeDescriptorImpl;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * This factory  method is used for UDTs. If the className argument is null,
1:      * then this TypeId will have to be bound.
1:      */
1:     public static TypeId getUserDefinedTypeId(String schemaName, String unqualifiedName, String className )
1:     {
1:         return new TypeId
1:             (
1:              StoredFormatIds.USERDEFINED_TYPE_ID_V3,
1:              new UserDefinedTypeIdImpl(schemaName, unqualifiedName, className )
1:              );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static TypeId getTypeId(TypeDescriptor catalogType)
1:         TypeDescriptorImpl tdi = (TypeDescriptorImpl) catalogType;
1:             return new TypeId( StoredFormatIds.USERDEFINED_TYPE_ID_V3, tdi.getTypeId() );
1:         }
1: 
1:         if ( tdi.isRowMultiSet() )
1:         {
1:             return new TypeId( StoredFormatIds.ROW_MULTISET_TYPE_ID_IMPL, tdi.getTypeId() );
commit:f432362
/////////////////////////////////////////////////////////////////////////
1: 		/** 
1: 		 *Is this a LongVarbinary?
1: 		 * @return true if this is LongVarbinary
1: 		 */
1: 		public boolean isLongVarbinaryTypeId()
1: 		{
1: 				return (formatId == StoredFormatIds.LONGVARBIT_TYPE_ID);
1: 		}
1: 
commit:4aef9b0
/////////////////////////////////////////////////////////////////////////
1:         /** 
0:          *Is this a ROW MULTISET?
1:          * @return true if this is XML
1:          */
0:         public boolean isRowMultiSetTypeId()
1:         {
0:                return (formatId == StoredFormatIds.ROW_MULTISET_CATALOG_ID);
1:         }
1: 
1: 
1: 	
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c1a0ff2
/////////////////////////////////////////////////////////////////////////
1:         /**
1:          * Is this a TIMESTAMP?
1:          *
1:          * @return true if this is a TIMESTAMP
1:          */
1:         public boolean isTimestampId() {
1:             return (formatId == StoredFormatIds.TIMESTAMP_TYPE_ID);
1:         }
1: 
commit:5465561
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                             return new SQLDecimal();
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         case Types.SQLXML:
commit:bbd82de
/////////////////////////////////////////////////////////////////////////
1:     public static TypeId getUserDefinedTypeId(String className)
0:         throws StandardException
1:     {
1:         return new TypeId(StoredFormatIds.USERDEFINED_TYPE_ID_V3,
1:                                 new UserDefinedTypeIdImpl(className));
1:     }
/////////////////////////////////////////////////////////////////////////
1:                         return TypeId.getUserDefinedTypeId(javaTypeName);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:054fa3a
/////////////////////////////////////////////////////////////////////////
1:         // ARRAY and STRUCT are JDBC 2.0 data types that are not
1:         // supported by Derby.
1:         public static final String      ARRAY_NAME = "ARRAY";
1:         public static final String      STRUCT_NAME = "STRUCT";
1: 
1:         // DATALINK is a JDBC 3.0 data type. Not supported by Derby.
1:         public static final String      DATALINK_NAME = "DATALINK";
1: 
1:         // ROWID and SQLXML are new types in JDBC 4.0. Not supported
1:         // by Derby.
1:         public static final String      ROWID_NAME = "ROWID";
1:         public static final String      SQLXML_NAME = "SQLXML";
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:be12a80
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:                               // We set this to true in order to disallow use
1:                               // of the XML datatype for procedure/function args.
1:                               isLongConcatableTypeId = true;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.error.StandardException;
/////////////////////////////////////////////////////////////////////////
1:         public static final String      BIGINT_NAME = "BIGINT";
/////////////////////////////////////////////////////////////////////////
1:             StoredFormatIds.BOOLEAN_TYPE_ID,
1:             StoredFormatIds.BOOLEAN_TYPE_ID_IMPL);
1:             StoredFormatIds.SMALLINT_TYPE_ID,
1:             StoredFormatIds.SMALLINT_TYPE_ID_IMPL);
1:             StoredFormatIds.INT_TYPE_ID,
1:             StoredFormatIds.INT_TYPE_ID_IMPL);
1:             StoredFormatIds.CHAR_TYPE_ID,
1:             StoredFormatIds.CHAR_TYPE_ID_IMPL);
/////////////////////////////////////////////////////////////////////////
1:             StoredFormatIds.TINYINT_TYPE_ID,
1:             StoredFormatIds.TINYINT_TYPE_ID_IMPL);
1:             StoredFormatIds.BIGINT_TYPE_ID,
1:             StoredFormatIds.BIGINT_TYPE_ID_IMPL);
1: 
1:             StoredFormatIds.REAL_TYPE_ID,
1:             StoredFormatIds.REAL_TYPE_ID_IMPL);
1: 
1:             StoredFormatIds.DOUBLE_TYPE_ID,
1:             StoredFormatIds.DOUBLE_TYPE_ID_IMPL);
1: 
1:         private static final TypeId DECIMAL_ID =  new TypeId(
1:             StoredFormatIds.DECIMAL_TYPE_ID,
1:             new DecimalTypeIdImpl(false));
1: 
1:         private static final TypeId NUMERIC_ID = new TypeId(
1:             StoredFormatIds.DECIMAL_TYPE_ID,
1:             new DecimalTypeIdImpl(true));
1: 
1:             StoredFormatIds.VARCHAR_TYPE_ID,
1:             StoredFormatIds.VARCHAR_TYPE_ID_IMPL);
1: 
1:             StoredFormatIds.DATE_TYPE_ID,
1:             StoredFormatIds.DATE_TYPE_ID_IMPL);
1: 
1:             StoredFormatIds.TIME_TYPE_ID,
1:             StoredFormatIds.TIME_TYPE_ID_IMPL);
1: 
1:             StoredFormatIds.TIMESTAMP_TYPE_ID,
1:             StoredFormatIds.TIMESTAMP_TYPE_ID_IMPL);
1: 
1:             StoredFormatIds.BIT_TYPE_ID,
1:             StoredFormatIds.BIT_TYPE_ID_IMPL);
1: 
1:             StoredFormatIds.VARBIT_TYPE_ID,
1:             StoredFormatIds.VARBIT_TYPE_ID_IMPL);
1: 
1:             StoredFormatIds.REF_TYPE_ID,
1:             StoredFormatIds.REF_TYPE_ID_IMPL);
1: 
1:             StoredFormatIds.LONGVARCHAR_TYPE_ID,
1:             StoredFormatIds.LONGVARCHAR_TYPE_ID_IMPL);
1: 
1:             StoredFormatIds.LONGVARBIT_TYPE_ID,
1:             StoredFormatIds.LONGVARBIT_TYPE_ID_IMPL);
1:             StoredFormatIds.BLOB_TYPE_ID,
1:             StoredFormatIds.BLOB_TYPE_ID_IMPL);
1: 
1:             StoredFormatIds.CLOB_TYPE_ID,
1:             StoredFormatIds.CLOB_TYPE_ID_IMPL);
1: 
1:             StoredFormatIds.XML_TYPE_ID,
1:             StoredFormatIds.XML_TYPE_ID_IMPL);
/////////////////////////////////////////////////////////////////////////
1:         if (SQLTypeName.equals(BIGINT_NAME)) {
/////////////////////////////////////////////////////////////////////////
1:                         case StoredFormatIds.BIGINT_TYPE_ID:
/////////////////////////////////////////////////////////////////////////
1:                         case StoredFormatIds.BIGINT_TYPE_ID:
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:fbb0d4f
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
1: import org.apache.derby.catalog.TypeDescriptor;
1: import org.apache.derby.iapi.reference.Limits;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:       
1:     /**
1:      * Get the TypeId (fundemental type information)
1:      * for a catalog type.
1:      * @param catalogType
1:      * @return TypeId that represents the base type, null if not applicable.
1:      */
0:     static TypeId getTypeId(TypeDescriptor catalogType)
1:     {
1:         final int jdbcType = catalogType.getJDBCTypeId();
1:         TypeId typeId = TypeId.getBuiltInTypeId(jdbcType);
1:         if (typeId != null)
1:             return typeId;
1:         
1:         if (jdbcType == Types.JAVA_OBJECT) {
0:             return TypeId.getUserDefinedTypeId(catalogType.getTypeName(), false);
1:         }
1:         
1:         return null;
1:     }
/////////////////////////////////////////////////////////////////////////
commit:b260d95
/////////////////////////////////////////////////////////////////////////
1:  * type (e.g. CHARACTER(10)) is described by a TypeDescriptor for
1:  * a catlog type and a DataTypeDescriptor for a runtime type.
1:  * (note a DataTypeDescriptor adds runtime attributes to the
1:  * TypeDescriptor it has).
1:  * <P>
1:  * A TypeId is immutable.
/////////////////////////////////////////////////////////////////////////
1: public final class TypeId
/////////////////////////////////////////////////////////////////////////
1:         public static final TypeId BOOLEAN_ID = create(
0:             StoredFormatIds.BOOLEAN_TYPE_ID, StoredFormatIds.BOOLEAN_TYPE_ID_IMPL);
1:         public static final TypeId SMALLINT_ID = create(
0:             StoredFormatIds.SMALLINT_TYPE_ID, StoredFormatIds.SMALLINT_TYPE_ID_IMPL);
1:         public static final TypeId INTEGER_ID = create(
0:             StoredFormatIds.INT_TYPE_ID, StoredFormatIds.INT_TYPE_ID_IMPL);
1:         public static final TypeId CHAR_ID = create(
0:             StoredFormatIds.CHAR_TYPE_ID, StoredFormatIds.CHAR_TYPE_ID_IMPL);
/////////////////////////////////////////////////////////////////////////
1:         private static final TypeId TINYINT_ID = create(
0:                 StoredFormatIds.TINYINT_TYPE_ID, StoredFormatIds.TINYINT_TYPE_ID_IMPL);;
0:         private static final TypeId BIGINT_ID = create(
0:             StoredFormatIds.LONGINT_TYPE_ID, StoredFormatIds.LONGINT_TYPE_ID_IMPL);
1:         private static final TypeId REAL_ID = create(
0:                 StoredFormatIds.REAL_TYPE_ID, StoredFormatIds.REAL_TYPE_ID_IMPL);
0:         private static final TypeId DOUBLE_ID = create(
0:                 StoredFormatIds.DOUBLE_TYPE_ID, StoredFormatIds.DOUBLE_TYPE_ID_IMPL);
0:         private static final TypeId DECIMAL_ID =  new TypeId(StoredFormatIds.DECIMAL_TYPE_ID, new DecimalTypeIdImpl(false));
0:         private static final TypeId NUMERIC_ID =  new TypeId(StoredFormatIds.DECIMAL_TYPE_ID, new DecimalTypeIdImpl(true));
1:         private static final TypeId VARCHAR_ID = create(
0:                 StoredFormatIds.VARCHAR_TYPE_ID, StoredFormatIds.VARCHAR_TYPE_ID_IMPL);
1:         private static final TypeId DATE_ID = create(
0:                 StoredFormatIds.DATE_TYPE_ID, StoredFormatIds.DATE_TYPE_ID_IMPL);
1:         private static final TypeId TIME_ID = create(
0:                 StoredFormatIds.TIME_TYPE_ID, StoredFormatIds.TIME_TYPE_ID_IMPL);
1:         private static final TypeId TIMESTAMP_ID = create(
0:                 StoredFormatIds.TIMESTAMP_TYPE_ID, StoredFormatIds.TIMESTAMP_TYPE_ID_IMPL);
1:         private static final TypeId BIT_ID = create(
0:                 StoredFormatIds.BIT_TYPE_ID, StoredFormatIds.BIT_TYPE_ID_IMPL);
1:         private static final TypeId VARBIT_ID = create(
0:                 StoredFormatIds.VARBIT_TYPE_ID, StoredFormatIds.VARBIT_TYPE_ID_IMPL);
1:         private static final TypeId REF_ID = create(
0:                 StoredFormatIds.REF_TYPE_ID, StoredFormatIds.REF_TYPE_ID_IMPL);
1:         private static final TypeId LONGVARCHAR_ID = create(
0:                 StoredFormatIds.LONGVARCHAR_TYPE_ID, StoredFormatIds.LONGVARCHAR_TYPE_ID_IMPL);
1:         private static final TypeId LONGVARBIT_ID = create(
0:                 StoredFormatIds.LONGVARBIT_TYPE_ID, StoredFormatIds.LONGVARBIT_TYPE_ID_IMPL);
1:         private static final TypeId BLOB_ID = create(
0:                 StoredFormatIds.BLOB_TYPE_ID, StoredFormatIds.BLOB_TYPE_ID_IMPL);
1:         private static final TypeId CLOB_ID = create(
0:                 StoredFormatIds.CLOB_TYPE_ID, StoredFormatIds.CLOB_TYPE_ID_IMPL);
1:         private static final TypeId XML_ID = create(
0:                 StoredFormatIds.XML_TYPE_ID, StoredFormatIds.XML_TYPE_ID_IMPL);
/////////////////////////////////////////////////////////////////////////
1:         
1:         /**
1:          * Create a TypeId for the given format identifiers using
1:          * a BaseTypeIdImpl. Used to create the static final variables
1:          * of this class.
1:          */
1:         private static TypeId create(int typeFormatId, int implTypeFormatId)
1:         {
1:             return new TypeId(typeFormatId, new BaseTypeIdImpl(implTypeFormatId)); 
1:         }
1:         
1:         
/////////////////////////////////////////////////////////////////////////
1:         public static TypeId getBuiltInTypeId(int JDBCTypeId) {
1:         switch (JDBCTypeId) {
1:         case Types.TINYINT:
1:             return TINYINT_ID;
1:         case Types.SMALLINT:
1:             return SMALLINT_ID;
1:         case Types.INTEGER:
1:             return INTEGER_ID;
1:         case Types.BIGINT:
1:             return BIGINT_ID;
1:         case Types.REAL:
1:             return REAL_ID;
1:         case Types.FLOAT:
1:         case Types.DOUBLE:
1:             return DOUBLE_ID;
1:         case Types.DECIMAL:
1:             return DECIMAL_ID;
1:         case Types.NUMERIC:
1:             return NUMERIC_ID;
1:         case Types.CHAR:
1:             return CHAR_ID;
1:         case Types.VARCHAR:
1:             return VARCHAR_ID;
1:         case Types.DATE:
1:             return DATE_ID;
1:         case Types.TIME:
1:             return TIME_ID;
1:         case Types.TIMESTAMP:
1:             return TIMESTAMP_ID;
1:         case Types.BIT:
1:         case Types.BOOLEAN:
1:             return BOOLEAN_ID;
1:         case Types.BINARY:
1:             return BIT_ID;
1:         case Types.VARBINARY:
1:             return VARBIT_ID;
1:         case Types.LONGVARBINARY:
1:             return LONGVARBIT_ID;
1:         case Types.LONGVARCHAR:
1:             return LONGVARCHAR_ID;
1:         case Types.BLOB:
1:             return BLOB_ID;
1: 
1:         case Types.CLOB:
1:             return CLOB_ID;
1: 
0:         case JDBC40Translation.SQLXML:
1:             return XML_ID;
1:             
1:         default:
1:             return null;
1:     }
/////////////////////////////////////////////////////////////////////////
1:          * Get a TypeId for the class that corresponds to the given Java type
1:          * name.
1:          * 
1:          * @param javaTypeName
1:          *            The name of the Java type
1:          * 
1:          * @return A TypeId for the SQL type that corresponds to the Java type,
1:          *         null if there is no corresponding type.
1:                         return BOOLEAN_ID;
1:                         return VARBIT_ID;
1:                         return VARCHAR_ID;
1:                         return INTEGER_ID;
1:                         return TINYINT_ID;
1:                     return SMALLINT_ID;
1:                      return BIGINT_ID;
1:                      return REAL_ID;
1:                     return DOUBLE_ID;
1:                     return DECIMAL_ID;
1:                     return DATE_ID;
1:                     return TIME_ID;
1:                     return TIMESTAMP_ID;
1:                     return BLOB_ID;
1:                     return CLOB_ID;
1: 
1:                     return XML_ID;
/////////////////////////////////////////////////////////////////////////
1:         /**
1:          * Given a SQL type name return the corresponding TypeId.
1:          * @param SQLTypeName Name of SQL type
1:          * @return TypeId or null if there is no corresponding SQL type.
1:          */
1:         if (SQLTypeName.equals(BOOLEAN_NAME)) {
1:             return BOOLEAN_ID;
1:         }
1:         if (SQLTypeName.equals(CHAR_NAME)) {
1:             return CHAR_ID;
1:         }
1:         if (SQLTypeName.equals(DATE_NAME)) {
1:             return DATE_ID;
1:         }
1:         if (SQLTypeName.equals(DOUBLE_NAME)) {
1:             return DOUBLE_ID;
1:         }
1:         if (SQLTypeName.equals(FLOAT_NAME)) {
1:             return DOUBLE_ID;
1:         }
1:         if (SQLTypeName.equals(INTEGER_NAME)) {
1:             return INTEGER_ID;
1:         }
0:         if (SQLTypeName.equals(LONGINT_NAME)) {
1:             return BIGINT_ID;
1:         }
1:         if (SQLTypeName.equals(REAL_NAME)) {
1:             return REAL_ID;
1:         }
1:         if (SQLTypeName.equals(SMALLINT_NAME)) {
1:             return SMALLINT_ID;
1:         }
1:         if (SQLTypeName.equals(TIME_NAME)) {
1:             return TIME_ID;
1:         }
1:         if (SQLTypeName.equals(TIMESTAMP_NAME)) {
1:             return TIMESTAMP_ID;
1:         }
1:         if (SQLTypeName.equals(VARCHAR_NAME)) {
1:             return VARCHAR_ID;
1:         }
1:         if (SQLTypeName.equals(BIT_NAME)) {
1:             return BIT_ID;
1:         }
1:         if (SQLTypeName.equals(VARBIT_NAME)) {
1:             return VARBIT_ID;
1:         }
1:         if (SQLTypeName.equals(TINYINT_NAME)) {
1:             return TINYINT_ID;
1:         }
1:         if (SQLTypeName.equals(DECIMAL_NAME)) {
1:             return DECIMAL_ID;
1:         }
1:         if (SQLTypeName.equals(NUMERIC_NAME)) {
1:             return NUMERIC_ID;
1:         }
1:         if (SQLTypeName.equals(LONGVARCHAR_NAME)) {
1:             return LONGVARCHAR_ID;
1:         }
1:         if (SQLTypeName.equals(LONGVARBIT_NAME)) {
1:             return LONGVARBIT_ID;
1:         }
1:         if (SQLTypeName.equals(BLOB_NAME)) {
1:             return BLOB_ID;
1:         }
1:         if (SQLTypeName.equals(CLOB_NAME)) {
1:             return CLOB_ID;
1:         }
1:         if (SQLTypeName.equals(XML_NAME)) {
1:             return XML_ID;
1:         // Types defined below here are SQL types and non-JDBC types that are
1:         // supported by Derby
1:         if (SQLTypeName.equals(REF_NAME)) {
1:             return REF_ID;
1:         }
1:         return null;
1:     }
1: 
1:          * * Instance fields and methods
1:          */
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:1a4ea31
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                   case Types.BOOLEAN:
/////////////////////////////////////////////////////////////////////////
0:                   case Types.BLOB:
0:                   case Types.CLOB:
/////////////////////////////////////////////////////////////////////////
0:                         return getBuiltInTypeId(Types.BLOB);
0:                         return getBuiltInTypeId(Types.CLOB);
/////////////////////////////////////////////////////////////////////////
0:                         return getBuiltInTypeId(Types.BLOB);
0:                         return getBuiltInTypeId(Types.CLOB);
commit:2e83f13
/////////////////////////////////////////////////////////////////////////
0:         public static final TypeId BOOLEAN_ID = new TypeId(
0:             StoredFormatIds.BOOLEAN_TYPE_ID,
0:                new BaseTypeIdImpl(StoredFormatIds.BOOLEAN_TYPE_ID_IMPL));
1:         
0:         public static final TypeId SMALLINT_ID = new TypeId(
0:                 StoredFormatIds.SMALLINT_TYPE_ID,
0:                 new BaseTypeIdImpl(StoredFormatIds.SMALLINT_TYPE_ID_IMPL));
1: 
0:         public static final TypeId INTEGER_ID = new TypeId(
0:             StoredFormatIds.INT_TYPE_ID,
0:             new BaseTypeIdImpl(StoredFormatIds.INT_TYPE_ID_IMPL));
1: 
0:         public static final TypeId CHAR_ID = new TypeId(
0:             StoredFormatIds.CHAR_TYPE_ID,
0:             new BaseTypeIdImpl(StoredFormatIds.CHAR_TYPE_ID_IMPL));
1:         
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:                           return SMALLINT_ID;
/////////////////////////////////////////////////////////////////////////
1:                 return  baseTypeId.toParsableString(dts.getCatalogType());
commit:01b5961
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.JDBC40Translation;
/////////////////////////////////////////////////////////////////////////
0:                   case JDBC40Translation.SQLXML:
/////////////////////////////////////////////////////////////////////////
0:                         return getBuiltInTypeId(JDBC40Translation.SQLXML);
commit:2afe578
/////////////////////////////////////////////////////////////////////////
1:  * TypeId describes the static information about a SQL type
1:  * independent of any specific attributes of the type such
1:  * as length. So the TypeId for CHARACTER describes the
1:  * fundamental information about CHARACTER. A specific
0:  * type (e.g. CHARACTER(10)) is described by a DataTypeDescriptor.
1: 
1:    @see DataTypeDescriptor
/////////////////////////////////////////////////////////////////////////
0:                                                                         new DecimalTypeIdImpl(false));
0:                                   DecimalTypeIdImpl numericTypeIdImpl = new DecimalTypeIdImpl(true);
commit:806114c
/////////////////////////////////////////////////////////////////////////
1:                                 javaTypeName = "java.sql.Blob";
/////////////////////////////////////////////////////////////////////////
1:                               javaTypeName = "java.sql.Clob";
/////////////////////////////////////////////////////////////////////////
0:                               javaTypeName = "java.sql.Clob";
commit:4aac5f7
/////////////////////////////////////////////////////////////////////////
1:          * Does type hava a declared variable length (defined by the application).
1:          * Examples are CHAR(10), CLOB(1M).
1:          * Unbounded long types, like LONG VARCHAR return false here.
/////////////////////////////////////////////////////////////////////////
1:                         case StoredFormatIds.CLOB_TYPE_ID:
1:                                  return true;
commit:08d6ce2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:2542f1d
/////////////////////////////////////////////////////////////////////////
commit:e11914a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.monitor.Monitor;
/////////////////////////////////////////////////////////////////////////
1:         /**
0:          * Implementation of DECIMAL datatype for generating holders through getNull.
0:          * Set by the booted DataValueFactory implementation.
1:          */
0:         static DataValueDescriptor		decimalImplementation;
/////////////////////////////////////////////////////////////////////////
1:                         // Implementation of DECIMAL can change.
0:                         	return decimalImplementation.getNewNull();
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.TypeId
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
0: import org.apache.derby.iapi.services.loader.ClassFactory;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.catalog.types.BaseTypeIdImpl;
1: import org.apache.derby.catalog.types.DecimalTypeIdImpl;
1: import org.apache.derby.catalog.types.UserDefinedTypeIdImpl;
1: 
0: import org.apache.derby.iapi.reference.DB2Limit;
1: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.types.*;
0: import org.apache.derby.iapi.types.*;
1: 
0: import org.apache.derby.iapi.reference.JDBC20Translation;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: 
0: import java.sql.Types;
1: 
1: /**
0:  * The TypeId interface provides methods to get information about datatype ids.
1:  
1:    <P>
1:  * The equals(Object) method can be used to determine if two typeIds are for the same type,
1:  * which defines type id equality.
1: 
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public final class TypeId implements Formatable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1:         /**
1:          * Various fixed numbers related to datatypes.
1:          */
1:         public static final int LONGINT_PRECISION                       = 19;
1:         public static final int LONGINT_SCALE                           = 0;
1:         public static final int LONGINT_MAXWIDTH                        = 8;
1: 
1:         public static final int INT_PRECISION                   = 10;
1:         public static final int INT_SCALE                               = 0;
1:         public static final int INT_MAXWIDTH                    = 4;
1: 
1:         public static final int SMALLINT_PRECISION                      = 5;
1:         public static final int SMALLINT_SCALE                          = 0;
1:         public static final int SMALLINT_MAXWIDTH                       = 2;
1: 
1:         public static final int TINYINT_PRECISION                       = 3;
1:         public static final int TINYINT_SCALE                           = 0;
1:         public static final int TINYINT_MAXWIDTH                        = 1;
1: 
1: 	// precision in number of bits 
1:         public static final int DOUBLE_PRECISION                        = 52;
1: 	// the ResultSetMetaData needs to have the precision for numeric data
1: 	// in decimal digits, rather than number of bits, so need a separate constant.
1:         public static final int DOUBLE_PRECISION_IN_DIGITS              = 15;
1:         public static final int DOUBLE_SCALE                            = 0;
1:         public static final int DOUBLE_MAXWIDTH                         = 8;
1: 
1: 	// precision in number of bits 
1:         public static final int REAL_PRECISION                  = 23;
1: 	// the ResultSetMetaData needs to have the precision for numeric data
1: 	// in decimal digits, rather than number of bits, so need a separate constant.
1:         public static final int REAL_PRECISION_IN_DIGITS        = 7;
1:         public static final int REAL_SCALE                              = 0;
1:         public static final int REAL_MAXWIDTH                   = 4;
1: 
0:         public static final int DECIMAL_PRECISION                       = DB2Limit.MAX_DECIMAL_PRECISION_SCALE;
0:         public static final int DECIMAL_SCALE                           = DB2Limit.MAX_DECIMAL_PRECISION_SCALE;
0:         public static final int DECIMAL_MAXWIDTH                        = DB2Limit.MAX_DECIMAL_PRECISION_SCALE;
1: 
1:         public static final int BOOLEAN_MAXWIDTH                        = 1;
1: 
0:         public static final int CHAR_MAXWIDTH           = DB2Limit.DB2_CHAR_MAXWIDTH;
0:         public static final int VARCHAR_MAXWIDTH        = DB2Limit.DB2_VARCHAR_MAXWIDTH;
0:         public static final int LONGVARCHAR_MAXWIDTH = DB2Limit.DB2_LONGVARCHAR_MAXWIDTH;
0:         public static final int NATIONAL_CHAR_MAXWIDTH  = Integer.MAX_VALUE;
0:         public static final int NATIONAL_VARCHAR_MAXWIDTH       = Integer.MAX_VALUE;
0:         public static final int NATIONAL_LONGVARCHAR_MAXWIDTH = DB2Limit.DB2_LONGVARCHAR_MAXWIDTH;
0:         public static final int BIT_MAXWIDTH            = DB2Limit.DB2_CHAR_MAXWIDTH;
0:         public static final int VARBIT_MAXWIDTH         = DB2Limit.DB2_VARCHAR_MAXWIDTH;
0:         public static final int LONGVARBIT_MAXWIDTH = DB2Limit.DB2_LONGVARCHAR_MAXWIDTH;
1: 
0:         // not supposed to be limited! 4096G should be ok(?), if Cloudscape can handle...
1:         public static final int BLOB_MAXWIDTH = Integer.MAX_VALUE; // to change long
1:         public static final int CLOB_MAXWIDTH = Integer.MAX_VALUE; // to change long
0:         public static final int NCLOB_MAXWIDTH = Integer.MAX_VALUE; // to change long
1: 
0:         public static final int DATE_MAXWIDTH           = 4;
0:         public static final int TIME_MAXWIDTH           = 8;
0:         public static final int TIMESTAMP_MAXWIDTH      = 12;
1: 
1:         /* These define all the type names for SQL92 and JDBC 
1:          * NOTE: boolean is SQL3
1:          */
1:           //public static final String      BIT_NAME = "BIT";
1:           //public static final String      VARBIT_NAME = "BIT VARYING";
1:           //public static final String      LONGVARBIT_NAME = "LONG BIT VARYING";
1: 
1:         public static final String      BIT_NAME = "CHAR () FOR BIT DATA";
1:         public static final String      VARBIT_NAME = "VARCHAR () FOR BIT DATA";
1:         public static final String      LONGVARBIT_NAME = "LONG VARCHAR FOR BIT DATA";
1:         public static final String      TINYINT_NAME = "TINYINT";
1:         public static final String      SMALLINT_NAME = "SMALLINT";
1:         public static final String      INTEGER_NAME = "INTEGER";
0:         public static final String      LONGINT_NAME = "BIGINT";
1:         public static final String      FLOAT_NAME = "FLOAT";
1:         public static final String      REAL_NAME = "REAL";
1:         public static final String      DOUBLE_NAME = "DOUBLE";
1:         public static final String      NUMERIC_NAME = "NUMERIC";
1:         public static final String      DECIMAL_NAME = "DECIMAL";
1:         public static final String      CHAR_NAME = "CHAR";
1:         public static final String      VARCHAR_NAME = "VARCHAR";
1:         public static final String      LONGVARCHAR_NAME = "LONG VARCHAR";
1:         public static final String      DATE_NAME = "DATE";
1:         public static final String      TIME_NAME = "TIME";
1:         public static final String      TIMESTAMP_NAME = "TIMESTAMP";
1:         public static final String      BINARY_NAME = "BINARY";
1:         public static final String      VARBINARY_NAME = "VARBINARY";
1:         public static final String      LONGVARBINARY_NAME = "LONGVARBINARY";
1:         public static final String      BOOLEAN_NAME = "BOOLEAN";
1:         public static final String      REF_NAME = "REF";
1:         public static final String      NATIONAL_CHAR_NAME = "NATIONAL CHAR";
1:         public static final String      NATIONAL_VARCHAR_NAME = "NATIONAL CHAR VARYING";
1:         public static final String      NATIONAL_LONGVARCHAR_NAME = "LONG NVARCHAR";
1:         public static final String      BLOB_NAME = "BLOB";
1:         public static final String      CLOB_NAME = "CLOB";
1:         public static final String      NCLOB_NAME = "NCLOB";
1:         
1:         /**
1:          * The following constants define the type precedence hierarchy.
1:          */
1:         public static final int USER_PRECEDENCE  = 1000;
1: 
1:         public static final int BLOB_PRECEDENCE = 170;
1:         public static final int LONGVARBIT_PRECEDENCE = 160;
1:         public static final int VARBIT_PRECEDENCE        = 150;
1:         public static final int BIT_PRECEDENCE           = 140;
1:         public static final int BOOLEAN_PRECEDENCE       = 130;
1:         public static final int TIME_PRECEDENCE  = 120;
1:         public static final int TIMESTAMP_PRECEDENCE = 110;
1:         public static final int DATE_PRECEDENCE  = 100;
1:         public static final int DOUBLE_PRECEDENCE        = 90;
1:         public static final int REAL_PRECEDENCE  = 80;
1:         public static final int DECIMAL_PRECEDENCE       = 70;
1:         public static final int NUMERIC_PRECEDENCE       = 69;
1:         public static final int LONGINT_PRECEDENCE       = 60;
1:         public static final int INT_PRECEDENCE           = 50;
1:         public static final int SMALLINT_PRECEDENCE = 40;
1:         public static final int TINYINT_PRECEDENCE       = 30;
1:         public static final int REF_PRECEDENCE           = 25;
0:         public static final int NATIONAL_LONGVARCHAR_PRECEDENCE = 18;
0:         public static final int NATIONAL_VARCHAR_PRECEDENCE  = 17;
0:         public static final int NATIONAL_CHAR_PRECEDENCE         = 16;
1:         public static final int CLOB_PRECEDENCE = 14;
0:         public static final int NCLOB_PRECEDENCE = 13; 
1:         public static final int LONGVARCHAR_PRECEDENCE = 12;
1:         public static final int VARCHAR_PRECEDENCE  = 10;
1:         public static final int CHAR_PRECEDENCE  = 0;
1: 
1:         /*
1:         ** Static runtime fields for typeIds
1:         ** These are put here because the system needs them init time.
1:         */
0:         public static final TypeId              BOOLEAN_ID = new TypeId(StoredFormatIds.BOOLEAN_TYPE_ID,
0:                                                                                                                         new BaseTypeIdImpl(StoredFormatIds.BOOLEAN_TYPE_ID_IMPL));
0:         public static final TypeId              INTEGER_ID = new TypeId(StoredFormatIds.INT_TYPE_ID,
0:                                                                                                                         new BaseTypeIdImpl(StoredFormatIds.INT_TYPE_ID_IMPL));
0:         public static final TypeId              CHAR_ID = new TypeId(StoredFormatIds.CHAR_TYPE_ID,
0:                                                                                                                  new BaseTypeIdImpl(StoredFormatIds.CHAR_TYPE_ID_IMPL));
1:         /*
1:         ** Others are created on demand by the getBuiltInTypeId(int),
1:         ** if they are built-in (i.e.? Part of JDBC .Types),
0:         ** or by getBuiltInTypeId(string) if they are NATIONAL types or REF_NAME type.
1:         */
1: 
0:         private static TypeId                   TINYINT_ID;
0:         private static TypeId                   SMALLINT_ID;
0:         private static TypeId                   LONGINT_ID;
0:         private static TypeId                   REAL_ID;
0:         private static TypeId                   DOUBLE_ID;
0:         private static TypeId                   DECIMAL_ID;
0:         private static TypeId                   NUMERIC_ID;
0:         private static TypeId                   VARCHAR_ID;
0:         private static TypeId                   NATIONAL_CHAR_ID;
0:         private static TypeId                   NATIONAL_LONGVARCHAR_ID;
0:         private static TypeId                   NATIONAL_VARCHAR_ID;
0:         private static TypeId                   DATE_ID;
0:         private static TypeId                   TIME_ID;
0:         private static TypeId                   TIMESTAMP_ID;
0:         private static TypeId                   BIT_ID;
0:         private static TypeId                   VARBIT_ID;
0:         private static TypeId                   REF_ID;
0:         private static TypeId                   LONGVARCHAR_ID;
0:         private static TypeId                   LONGVARBIT_ID;
1: 
0:         private static TypeId                   BLOB_ID;
0:         private static TypeId                   CLOB_ID;
0:         private static TypeId                   NCLOB_ID;
1: 
1: 
1: 
1:         /*
1:         ** Static methods to obtain TypeIds
1:         */
1:         /**
1:          * Get a TypeId of the given JDBC type.  This factory method is
1:          * intended to be used for built-in types.  For user-defined types,
1:          * we will need a factory method that takes a Java type name.
1:          *
1:          * @param JDBCTypeId    The JDBC Id of the type, as listed in
1:          *                      java.sql.Types
1:          *
1:          * @return      The appropriate TypeId, or null if there is no such
1:          *                      TypeId.
1:          */
1: 
0:         public static TypeId getBuiltInTypeId(int JDBCTypeId)
1:         {
0:                 TypeId ret = null;
1: 
0:                 switch (JDBCTypeId)
1:                 {
0:                   case Types.TINYINT:
0:                           ret = TINYINT_ID;
0:                           if (ret == null)
0:                                   ret = TINYINT_ID = new TypeId(StoredFormatIds.TINYINT_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.TINYINT_TYPE_ID_IMPL));
1:                           break;
1: 
0:                   case Types.SMALLINT:
0:                           ret = SMALLINT_ID;
0:                           if (ret == null)
0:                                   ret = SMALLINT_ID = new TypeId(StoredFormatIds.SMALLINT_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.SMALLINT_TYPE_ID_IMPL));
1:                           break;
1: 
0:                   case Types.INTEGER:
0:                           return INTEGER_ID;
1: 
0:                   case Types.BIGINT:
0:                           ret = LONGINT_ID;
0:                           if (ret == null)
0:                                   ret = LONGINT_ID = new TypeId(StoredFormatIds.LONGINT_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.LONGINT_TYPE_ID_IMPL));
1:                           break;
1: 
0:                   case Types.REAL:
0:                           ret = REAL_ID;
0:                           if (ret == null)
0:                                   ret = REAL_ID = new TypeId(StoredFormatIds.REAL_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.REAL_TYPE_ID_IMPL));
1:                           break;
1: 
0:                   case Types.FLOAT:
0:                   case Types.DOUBLE:
0:                           ret = DOUBLE_ID;
0:                           if (ret == null)
0:                                   ret = DOUBLE_ID = new TypeId(StoredFormatIds.DOUBLE_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.DOUBLE_TYPE_ID_IMPL));
1:                           break;
1: 
0:                   case Types.DECIMAL:
0:                           ret = DECIMAL_ID;
0:                           if (ret == null)
0:                                   ret = DECIMAL_ID = new TypeId(StoredFormatIds.DECIMAL_TYPE_ID,
0:                                                                         new DecimalTypeIdImpl());
1:                           break;
1: 
0:                   case Types.NUMERIC:
0:                           ret = NUMERIC_ID;
0:                           if (ret == null) {
0:                                   DecimalTypeIdImpl numericTypeIdImpl = new DecimalTypeIdImpl();
0:                                   numericTypeIdImpl.setNumericType();
0:                                   ret = NUMERIC_ID = new TypeId(StoredFormatIds.DECIMAL_TYPE_ID, numericTypeIdImpl);
1:                           }
1:                           break;
1: 
0:                   case Types.CHAR:
0:                           return CHAR_ID;
1: 
0:                   case Types.VARCHAR:
0:                           ret = VARCHAR_ID;
0:                           if (ret == null)
0:                                   ret = VARCHAR_ID = new TypeId(StoredFormatIds.VARCHAR_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.VARCHAR_TYPE_ID_IMPL));
1:                           break;
1: 
0:                   case Types.DATE:
0:                           ret = DATE_ID;
0:                           if (ret == null)
0:                                   ret = DATE_ID = new TypeId(StoredFormatIds.DATE_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.DATE_TYPE_ID_IMPL));
1:                           break;
1: 
0:                   case Types.TIME:
0:                           ret = TIME_ID;
0:                           if (ret == null)
0:                                   ret = TIME_ID = new TypeId(StoredFormatIds.TIME_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.TIME_TYPE_ID_IMPL));
1:                           break;
1: 
0:                   case Types.TIMESTAMP:
0:                           ret = TIMESTAMP_ID;
0:                           if (ret == null)
0:                                   ret = TIMESTAMP_ID = new TypeId(StoredFormatIds.TIMESTAMP_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.TIMESTAMP_TYPE_ID_IMPL));
1:                           break;
0:                   case Types.BIT:
0:                   case JDBC30Translation.SQL_TYPES_BOOLEAN:
0:                           return BOOLEAN_ID;
1: 
0:                   case Types.BINARY:
0:                           ret = BIT_ID;
0:                           if (ret == null)
0:                                   ret = BIT_ID = new TypeId(StoredFormatIds.BIT_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.BIT_TYPE_ID_IMPL));
1:                           break;
1: 
0:                   case Types.VARBINARY:
0:                           ret = VARBIT_ID;
0:                           if (ret == null)
0:                                   ret = VARBIT_ID = new TypeId(StoredFormatIds.VARBIT_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.VARBIT_TYPE_ID_IMPL));
1:                           break;
1: 
0:                   case Types.LONGVARBINARY:
0:                           ret = LONGVARBIT_ID;
0:                           if (ret == null)
0:                                   ret = LONGVARBIT_ID = new TypeId(StoredFormatIds.LONGVARBIT_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.LONGVARBIT_TYPE_ID_IMPL));
1:                           break;
1: 
0:                   case Types.LONGVARCHAR:
0:                       ret = LONGVARCHAR_ID;
0:                       if (ret == null)
0:                           ret = LONGVARCHAR_ID = new TypeId(StoredFormatIds.LONGVARCHAR_TYPE_ID,
0:                                                             new BaseTypeIdImpl(StoredFormatIds.LONGVARCHAR_TYPE_ID_IMPL));
1:                       break;
1: 
0:                   case JDBC20Translation.SQL_TYPES_BLOB:
0:                       ret = BLOB_ID;
0:                       if (ret == null)
0:                           ret = BLOB_ID = new TypeId(StoredFormatIds.BLOB_TYPE_ID,
0:                                                      new BaseTypeIdImpl(StoredFormatIds.BLOB_TYPE_ID_IMPL));
1:                       break;
1:                                                 
0:                   case JDBC20Translation.SQL_TYPES_CLOB:
0:                       ret = CLOB_ID;
0:                       if (ret == null)
0:                           ret = CLOB_ID = new TypeId(StoredFormatIds.CLOB_TYPE_ID,
0:                                                      new BaseTypeIdImpl(StoredFormatIds.CLOB_TYPE_ID_IMPL));
1:                       break;
1:                 }
0:                 return ret;
1:         }
1: 
0:         public static TypeId getUserDefinedTypeId(String className, boolean delimitedIdentifier)
1:         {
0:                 return new TypeId(StoredFormatIds.USERDEFINED_TYPE_ID_V3,
0:                                         new UserDefinedTypeIdImpl(className), delimitedIdentifier
0:                                         );
1:         }
1: 
1:         /**
0:          * Get a TypeId for the class that corresponds to the given
0:          * Java type name.
1:          *
0:          * @param javaTypeName          The name of the Java type
1:          *
0:          * @return      A TypeId for the SQL type that corresponds to
0:          *                      the Java type, null if there is no corresponding type.
1:          */
1:         public static TypeId getSQLTypeForJavaType(String javaTypeName)
1:         {
1:                 if (javaTypeName.equals("java.lang.Boolean") ||
1:                         javaTypeName.equals("boolean"))
1:                 {
0:                         return TypeId.BOOLEAN_ID;
1:                 }
1:                 else if (javaTypeName.equals("byte[]"))
1:                 {
0:                         return getBuiltInTypeId(Types.VARBINARY);
1:                 }
1:                 else if (javaTypeName.equals("java.lang.String"))
1:                 {
0:                         return getBuiltInTypeId(Types.VARCHAR);
1:                 }
1:                 else if (javaTypeName.equals("java.lang.Integer") ||
1:                                 javaTypeName.equals("int"))
1:                 {
0:                         return TypeId.INTEGER_ID;
1:                 }
1:                 else if (javaTypeName.equals("byte"))
1:                 {
0:                         return getBuiltInTypeId(Types.TINYINT);
1:                 }
1:                 else if (javaTypeName.equals("short"))
1:                 {
0:                         return getBuiltInTypeId(Types.SMALLINT);
1:                 }
1:                 else if (javaTypeName.equals("java.lang.Long") ||
1:                                 javaTypeName.equals("long"))
1:                 {
0:                         return getBuiltInTypeId(Types.BIGINT);
1:                 }
1:                 else if (javaTypeName.equals("java.lang.Float") ||
1:                                 javaTypeName.equals("float"))
1:                 {
0:                         return getBuiltInTypeId(Types.REAL);
1:                 }
1:                 else if (javaTypeName.equals("java.lang.Double") ||
1:                                 javaTypeName.equals("double"))
1:                 {
0:                         return getBuiltInTypeId(Types.DOUBLE);
1:                 }
1:                 else if (javaTypeName.equals("java.math.BigDecimal"))
1:                 {
0:                         return getBuiltInTypeId(Types.DECIMAL);
1:                 }
1:                 else if (javaTypeName.equals("java.sql.Date"))
1:                 {
0:                         return getBuiltInTypeId(Types.DATE);
1:                 }
1:                 else if (javaTypeName.equals("java.sql.Time"))
1:                 {
0:                         return getBuiltInTypeId(Types.TIME);
1:                 }
1:                 else if (javaTypeName.equals("java.sql.Timestamp"))
1:                 {
0:                         return getBuiltInTypeId(Types.TIMESTAMP);
1:                 }
1:                 else if (javaTypeName.equals("java.sql.Blob"))
1:                 {
0:                         return getBuiltInTypeId(JDBC20Translation.SQL_TYPES_BLOB);
1:                 }
1:                 else if (javaTypeName.equals("java.sql.Clob"))
1:                 {
0:                         return getBuiltInTypeId(JDBC20Translation.SQL_TYPES_CLOB);
1:                 }
1:                 else
1:                 {
1:                         /*
1:                         ** If it's a Java primitive type, return null to indicate that
1:                         ** there is no corresponding SQL type (all the Java primitive
1:                         ** types that have corresponding SQL types are handled above).
1:                         **
1:                         ** There is only one primitive type not mentioned above, char.
1:                         */
1:                         if (javaTypeName.equals("char"))
1:                         {
1:                                 return null;
1:                         }
1: 
1:                         /*
1:                         ** It's a non-primitive type (a class) that does not correspond
1:                         ** to a SQL built-in type, so treat it as a user-defined type.
1:                         */
0:                         return TypeId.getUserDefinedTypeId(javaTypeName, false);
1:                 }
1:         }
1: 
1:         public static TypeId getBuiltInTypeId(String SQLTypeName) {
1: 
0:                 if (SQLTypeName.equals(TypeId.BOOLEAN_NAME)) {
0:                         return TypeId.BOOLEAN_ID;
1:                 }
0:                 if (SQLTypeName.equals(TypeId.CHAR_NAME)) {
0:                         return TypeId.CHAR_ID;
1:                 }
0:                 if (SQLTypeName.equals(TypeId.DATE_NAME)) {
0:                         return getBuiltInTypeId(Types.DATE);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.DOUBLE_NAME)) {
0:                         return getBuiltInTypeId(Types.DOUBLE);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.FLOAT_NAME)) {
0:                         return getBuiltInTypeId(Types.DOUBLE);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.INTEGER_NAME)) {
0:                         return TypeId.INTEGER_ID;
1:                 }
0:                 if (SQLTypeName.equals(TypeId.LONGINT_NAME)) {
0:                         return getBuiltInTypeId(Types.BIGINT);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.REAL_NAME)) {
0:                         return getBuiltInTypeId(Types.REAL);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.SMALLINT_NAME)) {
0:                         return getBuiltInTypeId(Types.SMALLINT);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.TIME_NAME)) {
0:                         return getBuiltInTypeId(Types.TIME);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.TIMESTAMP_NAME)) {
0:                         return getBuiltInTypeId(Types.TIMESTAMP);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.VARCHAR_NAME)) {
0:                         return getBuiltInTypeId(Types.VARCHAR);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.BIT_NAME)) {
0:                         return getBuiltInTypeId(Types.BINARY);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.VARBIT_NAME)) {
0:                         return getBuiltInTypeId(Types.VARBINARY);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.TINYINT_NAME)) {
0:                         return getBuiltInTypeId(Types.TINYINT);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.DECIMAL_NAME)) {
0:                         return getBuiltInTypeId(Types.DECIMAL);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.NUMERIC_NAME)) {
0:                         return getBuiltInTypeId(Types.NUMERIC);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.LONGVARCHAR_NAME)) {
0:                         return getBuiltInTypeId(Types.LONGVARCHAR);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.LONGVARBIT_NAME)) {
0:                         return getBuiltInTypeId(Types.LONGVARBINARY);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.BLOB_NAME)) {
0:                         return getBuiltInTypeId(JDBC20Translation.SQL_TYPES_BLOB);
1:                 }
0:                 if (SQLTypeName.equals(TypeId.CLOB_NAME)) {
0:                         return getBuiltInTypeId(JDBC20Translation.SQL_TYPES_CLOB);
1:                 }
1: 
0:                 TypeId ret = null;
1: 
0:                 // Types defined below here are SQL types and non-JDBC types that are supported by Cloudscape
0:                 if (SQLTypeName.equals(TypeId.NCLOB_NAME)) {
0:                         ret = NCLOB_ID;
0:                         if (ret == null)
0:                                 ret = NCLOB_ID = new TypeId(StoredFormatIds.NCLOB_TYPE_ID,
0:                                                             new BaseTypeIdImpl(StoredFormatIds.NCLOB_TYPE_ID_IMPL));
0:                 } else if (SQLTypeName.equals(TypeId.NATIONAL_CHAR_NAME)) {
0:                         ret = NATIONAL_CHAR_ID;
0:                         if (ret == null)
0:                                 ret = NATIONAL_CHAR_ID = new TypeId(StoredFormatIds.NATIONAL_CHAR_TYPE_ID,
0:                                                                     new BaseTypeIdImpl(StoredFormatIds.NATIONAL_CHAR_TYPE_ID_IMPL));
1: 
0:                 } else if (SQLTypeName.equals(TypeId.NATIONAL_LONGVARCHAR_NAME)) {
0:                         ret = NATIONAL_LONGVARCHAR_ID;
0:                         if (ret == null)
0:                                 ret = NATIONAL_LONGVARCHAR_ID = new TypeId(StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID_IMPL));
1: 
0:                 } else if (SQLTypeName.equals(TypeId.NATIONAL_VARCHAR_NAME)) {
0:                         ret = NATIONAL_VARCHAR_ID;
0:                         if (ret == null)
0:                                 ret = NATIONAL_VARCHAR_ID = new TypeId(StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID_IMPL));
1: 
0:                 } else if (SQLTypeName.equals(TypeId.REF_NAME)) {
0:                         ret = REF_ID;
0:                         if (ret == null)
0:                                 ret = REF_ID = new TypeId(StoredFormatIds.REF_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.REF_TYPE_ID_IMPL));
1:                 }
0:                 return ret;
1:         }
1: 
1:         /*
0:         ** Instance fields and methods
1:         */
1: 
1:         private BaseTypeIdImpl  baseTypeId;
1:         private int                             formatId;
1: 
1:         /* Set in setTypeIdSpecificInstanceVariables() as needed */
0:         private boolean                 classNameWasDelimitedIdentifier;
0:         private boolean                 isBuiltIn = true;
1:         private boolean                 isBitTypeId;
1:         private boolean                 isLOBTypeId;
1:         private boolean                 isBooleanTypeId;
1:         private boolean                 isConcatableTypeId;
1:         private boolean                 isDecimalTypeId;
1:         private boolean                 isLongConcatableTypeId;
1:         private boolean                 isNumericTypeId;
1:         private boolean                 isRefTypeId;
1:         private boolean                 isStringTypeId;
1:         private boolean                 isFloatingPointTypeId;
1:         private boolean                 isRealTypeId;
1:         private boolean                 isDateTimeTimeStampTypeId;
1:         private boolean                 isUserDefinedTypeId;
1:         private int                             maxPrecision;
1:         private int                             maxScale;
1:         private int                             typePrecedence;
1:         private String                  javaTypeName;
1:         private int                             maxMaxWidth;
1: 
1:         /**
0:          * 1 argmument constructor. Needed for Formatable interface to work.
1:          *
1:          * @param formatId      Format id of specific type id.
1:          */
1: 
0:         public  TypeId(int formatId) 
1:         {
1:                 this.formatId = formatId;
1:                 setTypeIdSpecificInstanceVariables();
1:         }
1: 
1:         /**
1:          * Constructor for a TypeId
1:          *
1:          * @param formatId      Format id of specific type id.
1:          * @param baseTypeId    The Base type id
1:          */
1:         public TypeId(int formatId, BaseTypeIdImpl baseTypeId)
1:         {
1:                 this.formatId = formatId;
1:                 this.baseTypeId = baseTypeId;
1:                 setTypeIdSpecificInstanceVariables();
1:         }
1:         /**
0:          * Constructor for a TypeId for user defined types
1:          *
0:          * @param formatId                                                      Format id of specific type id.
0:          * @param baseTypeId                                            The Base type id
0:          * @param classNameWasDelimitedIdentifier       Whether or not the class name
0:          *                                                                                      was a delimited identifier
1:          */
0:         public TypeId(int formatId, BaseTypeIdImpl baseTypeId,
0:                                                  boolean classNameWasDelimitedIdentifier)
1:         {
1:                 this.formatId = formatId;
1:                 this.baseTypeId = baseTypeId;
0:                 this.classNameWasDelimitedIdentifier = classNameWasDelimitedIdentifier;
1:                 setTypeIdSpecificInstanceVariables();
1:         }
1: 
1:         /**
1:          * we want equals to say if these are the same type id or not.
1:          */
1:         public boolean equals(Object that)
1:         {
1:                 if (that instanceof TypeId)
1:                         return this.getSQLTypeName().equals(((TypeId)that).getSQLTypeName());
1:                 else
1:                         return false;
1:         }
1: 
1:         /*
1:           Hashcode which works with equals.
1:           */
1:         public int hashCode()
1:         {
1:                 return this.getSQLTypeName().hashCode();
1:         }
1: 
1: 
1:         private void setTypeIdSpecificInstanceVariables()
1:         {
1:                 switch (formatId)
1:                 {
1:                         case StoredFormatIds.BIT_TYPE_ID:
1:                                 typePrecedence = BIT_PRECEDENCE;
1:                                 javaTypeName = "byte[]";
1:                                 maxMaxWidth = TypeId.BIT_MAXWIDTH;
1:                                 isBitTypeId = true;
1:                                 isConcatableTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.BOOLEAN_TYPE_ID:
1:                                 typePrecedence = BOOLEAN_PRECEDENCE;
1:                                 javaTypeName = "java.lang.Boolean";
1:                                 maxMaxWidth = TypeId.BOOLEAN_MAXWIDTH;
1:                                 isBooleanTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.CHAR_TYPE_ID:
1:                                 typePrecedence = CHAR_PRECEDENCE;
1:                                 javaTypeName = "java.lang.String";
1:                                 maxMaxWidth = TypeId.CHAR_MAXWIDTH;
1:                                 isStringTypeId = true;
1:                                 isConcatableTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.DATE_TYPE_ID:
1:                                 typePrecedence = DATE_PRECEDENCE;
1:                                 javaTypeName = "java.sql.Date";
0:                                 /* this is used in ResultSetMetaData.getPrecision
0:                                  * undefined for datetime types
1:                                  */
1:                                 maxMaxWidth = -1;
1:                                 isDateTimeTimeStampTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.DECIMAL_TYPE_ID:
1:                                 maxPrecision = TypeId.DECIMAL_PRECISION;
1:                                 maxScale = TypeId.DECIMAL_SCALE;
1:                                 typePrecedence = DECIMAL_PRECEDENCE;
1:                                 javaTypeName = "java.math.BigDecimal";
1:                                 maxMaxWidth = TypeId.DECIMAL_MAXWIDTH;
1:                                 isDecimalTypeId = true;
1:                                 isNumericTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.DOUBLE_TYPE_ID:
1:                                 maxPrecision = TypeId.DOUBLE_PRECISION;
1:                                 maxScale = TypeId.DOUBLE_SCALE;
1:                                 typePrecedence = DOUBLE_PRECEDENCE;
1:                                 javaTypeName = "java.lang.Double";
1:                                 maxMaxWidth = TypeId.DOUBLE_MAXWIDTH;
1:                                 isNumericTypeId = true;
1: 								isFloatingPointTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.INT_TYPE_ID:
1:                                 maxPrecision = TypeId.INT_PRECISION;
1:                                 maxScale = TypeId.INT_SCALE;
1:                                 typePrecedence = INT_PRECEDENCE;
1:                                 javaTypeName = "java.lang.Integer";
1:                                 maxMaxWidth = TypeId.INT_MAXWIDTH;
1:                                 isNumericTypeId = true;
1:                                 break;
1: 
0:                         case StoredFormatIds.LONGINT_TYPE_ID:
1:                                 maxPrecision = TypeId.LONGINT_PRECISION;
1:                                 maxScale = TypeId.LONGINT_SCALE;
1:                                 typePrecedence = LONGINT_PRECEDENCE;
1:                                 javaTypeName = "java.lang.Long";
1:                                 maxMaxWidth = TypeId.LONGINT_MAXWIDTH;
1:                                 isNumericTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.LONGVARBIT_TYPE_ID:
1:                                 typePrecedence = LONGVARBIT_PRECEDENCE;
1:                                 javaTypeName = "byte[]";
1:                                 maxMaxWidth = TypeId.LONGVARBIT_MAXWIDTH;
1:                                 isBitTypeId = true;
1:                                 isConcatableTypeId = true;
1:                                 isLongConcatableTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.LONGVARCHAR_TYPE_ID:
1:                                 typePrecedence = LONGVARCHAR_PRECEDENCE;
1:                                 javaTypeName = "java.lang.String";
1:                                 maxMaxWidth = TypeId.LONGVARCHAR_MAXWIDTH;
1:                                 isStringTypeId = true;
1:                                 isConcatableTypeId = true;
1:                                 isLongConcatableTypeId = true;
1:                                 break;
1: 
0:                         case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0:                                 typePrecedence = NATIONAL_CHAR_PRECEDENCE;
1:                                 javaTypeName = "java.lang.String";
0:                                 maxMaxWidth = TypeId.NATIONAL_CHAR_MAXWIDTH;
1:                                 isStringTypeId = true;
1:                                 isConcatableTypeId = true;
1:                                 break;
1: 
0:                         case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID:
0:                                 typePrecedence = NATIONAL_LONGVARCHAR_PRECEDENCE;
1:                                 javaTypeName = "java.lang.String";
0:                                 maxMaxWidth = TypeId.NATIONAL_LONGVARCHAR_MAXWIDTH;
1:                                 isStringTypeId = true;
1:                                 isConcatableTypeId = true;
1:                                 isLongConcatableTypeId = true;
1:                                 break;
1: 
0:                         case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
0:                                 typePrecedence = NATIONAL_VARCHAR_PRECEDENCE;
1:                                 javaTypeName = "java.lang.String";
0:                                 maxMaxWidth = TypeId.NATIONAL_VARCHAR_MAXWIDTH;
1:                                 isStringTypeId = true;
1:                                 isConcatableTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.REAL_TYPE_ID:
1:                                 maxPrecision = TypeId.REAL_PRECISION;
1:                                 maxScale = TypeId.REAL_SCALE;
1:                                 typePrecedence = REAL_PRECEDENCE;
1:                                 javaTypeName = "java.lang.Float";
1:                                 maxMaxWidth = TypeId.REAL_MAXWIDTH;
1:                                 isNumericTypeId = true;
1:                                 isRealTypeId = true;
1:                                 isFloatingPointTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.REF_TYPE_ID:
1:                                 typePrecedence = REF_PRECEDENCE;
1:                                 isRefTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.SMALLINT_TYPE_ID:
1:                                 maxPrecision = TypeId.SMALLINT_PRECISION;
1:                                 maxScale = TypeId.SMALLINT_SCALE;
1:                                 typePrecedence = SMALLINT_PRECEDENCE;
1:                                 javaTypeName = "java.lang.Integer";
1:                                 maxMaxWidth = TypeId.SMALLINT_MAXWIDTH;
1:                                 isNumericTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.TIME_TYPE_ID:
1:                                 typePrecedence = TIME_PRECEDENCE;
1:                                 javaTypeName = "java.sql.Time";
0:                                 /* this is used in ResultSetMetaData.getPrecision
0:                                  * undefined for datetime types
1:                                  */
1:                                 maxMaxWidth = -1;
1:                                 isDateTimeTimeStampTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.TIMESTAMP_TYPE_ID:
1:                                 typePrecedence = TIMESTAMP_PRECEDENCE;
1:                                 javaTypeName = "java.sql.Timestamp";
0:                                 /* this is used in ResultSetMetaData.getPrecision
0:                                  * undefined for datetime types
1:                                  */
1:                                 maxMaxWidth = -1;
1:                                 isDateTimeTimeStampTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.TINYINT_TYPE_ID:
1:                                 maxPrecision = TypeId.TINYINT_PRECISION;
1:                                 maxScale = TypeId.TINYINT_SCALE;
1:                                 typePrecedence = TINYINT_PRECEDENCE;
1:                                 javaTypeName = "java.lang.Integer";
1:                                 maxMaxWidth = TypeId.TINYINT_MAXWIDTH;
1:                                 isNumericTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
1:                                 if (baseTypeId != null)
1:                                 {
1:                                         setUserTypeIdInfo();
1:                                 }
1:                                 else
1:                                 {
1:                                         typePrecedence = USER_PRECEDENCE;
1:                                 }
1:                                 maxMaxWidth = -1;
0:                                 isBuiltIn = false;
1:                                 isUserDefinedTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.VARBIT_TYPE_ID:
1:                                 typePrecedence = VARBIT_PRECEDENCE;
1:                                 javaTypeName = "byte[]";
1:                                 maxMaxWidth = TypeId.VARBIT_MAXWIDTH;
1:                                 isBitTypeId = true;
1:                                 isConcatableTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.BLOB_TYPE_ID:
1:                                 typePrecedence = BLOB_PRECEDENCE;
0:                                 // no java type name, can't be used as java object
1:                                 javaTypeName = "byte[]"; 
0:                                 //javaTypeName = "java.sql.Blob";  // doesn't work w casting
1:                                 maxMaxWidth = TypeId.BLOB_MAXWIDTH;
1:                                 isBitTypeId = true;
1:                                 isConcatableTypeId = true;
1:                                 isLongConcatableTypeId = true; // ??
1:                                 isLOBTypeId = true;
1:                                 break;
1: 
1:                         case StoredFormatIds.VARCHAR_TYPE_ID:
1:                                 typePrecedence = VARCHAR_PRECEDENCE;
1:                                 javaTypeName = "java.lang.String";
0:                                 maxMaxWidth = TypeId.VARCHAR_MAXWIDTH;
1:                                 isStringTypeId = true;
1:                                 isConcatableTypeId = true;
1:                                 break;
1: 
1:                       case StoredFormatIds.CLOB_TYPE_ID:
1:                               typePrecedence = CLOB_PRECEDENCE;
0:                               // no java type name, can't be used as java object
1:                               javaTypeName = "java.lang.String";
0:                               //javaTypeName = "java.sql.Clob"; // doesn't work w casting
1:                               maxMaxWidth = TypeId.CLOB_MAXWIDTH;
1:                               isStringTypeId = true;
1:                               isConcatableTypeId = true;
1:                               isLongConcatableTypeId = true; // ??
1:                               isLOBTypeId = true;
1:                               break;
1: 
0:                       case StoredFormatIds.NCLOB_TYPE_ID:
0:                               typePrecedence = NCLOB_PRECEDENCE;
0:                               // no java type name, can't be used as java object
1:                               javaTypeName = "java.lang.String"; 
0:                               //javaTypeName = "java.sql.Clob";  // doesn't work w casting
0:                               maxMaxWidth = TypeId.NCLOB_MAXWIDTH;
1:                               isStringTypeId = true;
1:                               isConcatableTypeId = true;
1:                               isLongConcatableTypeId = true; // ??
1:                               isLOBTypeId = true;
1:                               break;
1: 
1:                 }
1:         }
1:         /**
1:          * JDBC has its own idea of type identifiers which is different from
0:          * the Cloudscape internal type ids.  The JDBC type ids are defined
1:          * as public final static ints in java.sql.Types.  This method translates
0:          * a Cloudscape internal TypeId to a JDBC type id. For java objects this
1:          * returns JAVA_OBJECT in Java2 and OTHER in JDK 1.1. For Boolean datatypes,
1:          * this returns Type.BOOLEAN in JDK1.4 and Type.BIT for jdks prior to 1.4
1:          *
1:          * @return      The JDBC type Id for this type
1:          */
1:         public final int getJDBCTypeId()
1:         {
1:                 return baseTypeId.getJDBCTypeId();
1:         }
1:         /**
1:          * Returns the SQL name of the datatype. If it is a user-defined type,
1:          * it returns the full Java path name for the datatype, meaning the
1:          * dot-separated path including the package names.
1:          *
1:          * @return      A String containing the SQL name of this type.
1:          */
1:         public String   getSQLTypeName()
1:         {
1:                 return baseTypeId.getSQLTypeName();
1:         }
1: 
1:         /**
1:          * Tell whether this is a built-in type.
1:          * NOTE: There are 3 "classes" of types:
1:          *                      built-in                - system provided types which are implemented internally
1:          *                                                        (int, smallint, etc.)
1:          *                      system built-in - system provided types, independent of implementation
1:          *                                                        (date, time, etc.)
1:          *                      user types              - types implemented outside of the system
1:          *                                                        (java.lang.Integer, asdf.asdf.asdf, etc.)
1:          *
1:          * @return      true for built-in types, false for user-defined types.
1:          */
0:         public final boolean systemBuiltIn()
1:         {
0:                 return baseTypeId.systemBuiltIn();
1:         }
1: 
1:         /**
1:          * Tell whether this is a built-in type.
1:          * NOTE: There are 3 "classes" of types:
1:          *                      built-in                - system provided types which are implemented internally
1:          *                                                        (int, smallint, etc.)
1:          *                      system built-in - system provided types, independent of implementation
1:          *                                                        (date, time, etc.)
1:          *                      user types              - types implemented outside of the system
1:          *                                                        (java.lang.Integer, asdf.asdf.asdf, etc.)
1:          *
1:          * @return      true for built-in types, false for user-defined types.
1:          */
1:         public final boolean userType()
1:         {
1:                 return baseTypeId.userType();
1:         }
1: 
1:         /**
1:          * Get the maximum precision of the type.  For types with variable
1:          * precision, this is an arbitrary high precision.
1:          *
1:          * @return      The maximum precision of the type
1:          */
1:         public int getMaximumPrecision()
1:         {
1:                 return maxPrecision;
1:         }
1: 
1:         /**
1:          * Get the maximum scale of the type.  For types with variable scale,
1:          * this is an arbitrary high scale.
1:          *
1:          * @return      The maximum scale of the type
1:          */
1:         public int getMaximumScale()
1:         {
1:                 return maxScale;
1:         }
1: 
1:         /**
0:          * Set the nested BaseTypeId in this TypeId.
1:          */
0:         public void setNestedTypeId(BaseTypeIdImpl typeId)
1:         {
0:                 baseTypeId = typeId;
1:                 switch (formatId)
1:                 {
1:                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
1:                                 setUserTypeIdInfo();
1:                 }
1:         }
1: 
1:         private void setUserTypeIdInfo()
1:         {
1:                 UserDefinedTypeIdImpl baseUserTypeId =
1:                                                         (UserDefinedTypeIdImpl) baseTypeId;
1:                 typePrecedence = USER_PRECEDENCE;
1:                 javaTypeName = baseUserTypeId.getClassName();
1:         }
1: 
1:         /**
0:          * For user types, tell whether or not the class name was a
0:          * delimited identifier. For all other types, return false.
1:          *
0:          * @return Whether or not the class name was a delimited identifier.
1:          */
0:         public boolean getClassNameWasDelimitedIdentifier()
1:         {
0:                 return classNameWasDelimitedIdentifier;
1:         }
1: 
1:         /**
1:          * Does this TypeId represent a TypeId for a StringDataType.
1:          *
1:          * @return Whether or not this TypeId represents a TypeId for a StringDataType.
1:          */
1:         public boolean isStringTypeId()
1:         {
1:                 return isStringTypeId;
1:         }
1: 
1: 		/**
1: 		 * Is this a TypeId for DATE/TIME/TIMESTAMP
1: 		 *
1: 		 * @return true if this is a DATE/TIME/TIMESTAMP
1: 		 */
1: 		public boolean isDateTimeTimeStampTypeId()
1: 		{
1: 				return isDateTimeTimeStampTypeId;
1: 		}
1: 
1: 		/**
1: 		 * Is this a TypeId for REAL
1: 		 *
1: 		 * @return true if this is a REAL
1: 		 */
1: 		public boolean isRealTypeId()
1: 		{
1: 				return isRealTypeId;
1: 		}
1: 
1: 		/**
1: 		 * Is this a TypeId for floating point (REAL/DOUBLE)
1: 		 *
1: 		 * @return true if this is a REAL or DOUBLE
1: 		 */
1: 		public boolean isFloatingPointTypeId()
1: 		{
1: 				return isFloatingPointTypeId;
1: 		}
1: 		
1: 		/**
1: 		 * Is this a TypeId for DOUBLE
1: 		 *
1: 		 * @return true if this is a DOUBLE
1: 		 */
1: 		public boolean isDoubleTypeId()
1: 		{
1: 				return isFloatingPointTypeId && (! isRealTypeId);
1: 		}
1: 	
1: 		/**
1: 		 * Is this a fixed string type?
0: 		 * @return true if this is CHAR or NCHAR
1: 		 */
1: 		public boolean isFixedStringTypeId()
1: 		{
0: 				return ((formatId == StoredFormatIds.CHAR_TYPE_ID)||
0: 						(formatId == StoredFormatIds.NATIONAL_CHAR_TYPE_ID));
1: 		}
1: 
1: 		/** 
1: 		 *Is this a Clob?
0: 		 * @return true if this is CLOB or NCLOB
1: 		 */
1: 		public boolean isClobTypeId()
1: 		{
0: 			   return ((formatId == StoredFormatIds.CLOB_TYPE_ID)||
0: 					   (formatId == StoredFormatIds.NCLOB_TYPE_ID));
1: 		}
1: 
1: 		/** 
1: 		 *Is this a Blob?
1: 		 * @return true if this is BLOB
1: 		 */
1: 		public boolean isBlobTypeId()
1: 		{
1: 				return ((formatId == StoredFormatIds.BLOB_TYPE_ID));
1: 		}
1: 
1: 	
1: 		/** 
1: 		 *Is this a LongVarchar?
1: 		 * @return true if this is LongVarchar
1: 		 */
1: 		public boolean isLongVarcharTypeId()
1: 		{
0: 				return ((formatId == StoredFormatIds.LONGVARCHAR_TYPE_ID) ||
0: 						(formatId == StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID));
1: 		}
1: 
1: 
1: 		/** 
1: 		 * Is this DATE/TIME or TIMESTAMP?
1: 		 *
1: 		 * @return true if this DATE/TIME or TIMESTAMP
1: 		 */
1: 		public boolean isDateTimeTimeStampTypeID()
1: 		{
1: 				return ((formatId == StoredFormatIds.DATE_TYPE_ID) ||
1: 						(formatId == StoredFormatIds.TIME_TYPE_ID) ||
1: 						(formatId == StoredFormatIds.TIMESTAMP_TYPE_ID));
1: 		}
1: 
1:         /**
0:                 Does this type id represent a national character string.
0:                 If this returns true then isStringTypeId will also return true.
1:         */
0:         public boolean isNationalStringTypeId()
1:         {
1:                 switch (formatId)
1:                 {
1:                         default:
1:                                 return false;
1: 
0:                         case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0:                         case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID:
0:                         case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
0:                         case StoredFormatIds.NCLOB_TYPE_ID:
0:                                 return true;
1: 
1:                 }
1:         }
1: 
1:         /**
1:          * Tell whether this is a built-in type.
1:          * NOTE: There are 3 "classes" of types:
1:          *                      built-in                - system provided types which are implemented internally
1:          *                                                        (int, smallint, etc.)
1:          *                      system built-in - system provided types, independent of implementation
1:          *                                                        (date, time, etc.)
1:          *                      user types              - types implemented outside of the system
1:          *                                                        (java.lang.Integer, asdf.asdf.asdf, etc.)
1:          *
1:          * @return      true for built-in types, false for user-defined types.
1:          */
0:         public boolean builtIn()
1:         {
0:                 return isBuiltIn;
1:         }
1: 
1:         /**
1:          * Tell whether this type is orderable, that is, can participate
1:          * in comparisons.
1:          *
1:          * @param cf    A ClassFactory
1:          *
1:          * @return      true for orderable types, false for non-orderable types.
1:          */
1:         public boolean orderable(ClassFactory cf)
1:         {
1:                 boolean orderable;
1:                 switch (formatId)
1:                 {
1:                         // cmp not allowed, indexing not allowed
1:                         case StoredFormatIds.BLOB_TYPE_ID:
1:                         case StoredFormatIds.CLOB_TYPE_ID:
0:                         case StoredFormatIds.NCLOB_TYPE_ID:
0:                         case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID:
1:                         case StoredFormatIds.LONGVARCHAR_TYPE_ID:
1:                                 return false;
1: 
1:                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
1:                                 /* Is this type orderable? */
1: 
1:                                 // For user java classes we are orderable if we
1:                                 // implement java.lang.Orderable (JDK1.2) or
1:                                 // have a int compareTo(Object) method (JDK1.1 or JDK1.2)
1:                                 UserDefinedTypeIdImpl baseUserTypeId =
1:                                                                                 (UserDefinedTypeIdImpl) baseTypeId;
1: 
0:                                 String className = baseUserTypeId.getClassName();
1: 
0:                                 try 
1:                                 {
0:                                         Class c = cf.getClassInspector().getClass(className);
0:                                         orderable = java.lang.Comparable.class.isAssignableFrom(c);
1:                                 } 
0:                                 catch (ClassNotFoundException cnfe) 
1:                                 {
0:                                         orderable = false;
1:                                 } 
0:                                 catch (LinkageError le) 
1:                                 {
0:                                         orderable = false;
1:                                 }
1:                                 break;
1: 
1:                         default:
1:                                 orderable = true;
1:                 }
1: 
1:                 return orderable;
1:         }
1: 
1:         /**
1:          * Each built-in type in JSQL has a precedence.  This precedence determines
1:          * how to do type promotion when using binary operators.  For example, float
1:          * has a higher precedence than int, so when adding an int to a float, the
1:          * result type is float.
1:          *
1:          * The precedence for some types is arbitrary.  For example, it doesn't
1:          * matter what the precedence of the boolean type is, since it can't be
1:          * mixed with other types.  But the precedence for the number types is
1:          * critical.  The SQL standard requires that exact numeric types be
1:          * promoted to approximate numeric when one operator uses both.  Also,
1:          * the precedence is arranged so that one will not lose precision when
1:          * promoting a type.
1:          * NOTE: char, varchar, and longvarchar must appear at the bottom of
1:          * the hierarchy, but above USER_PRECEDENCE, since we allow the implicit
1:          * conversion of those types to any other built-in system type.
1:          *
1:          * @return              The precedence of this type.
1:          */
1:         public int typePrecedence()
1:         {
1:                 return typePrecedence;
1:         }
1: 
1:          /**
1:          * Get the name of the corresponding Java type.
1:          *
1:          * Each SQL type has a corresponding Java type.  When a SQL value is
1:          * passed to a Java method, it is translated to its corresponding Java
1:          * type.  For example, when a SQL date column is passed to a method,
1:          * it is translated to a java.sql.Date.
1:          *
1:          * @return      The name of the corresponding Java type.
1:          */
1:         public String getCorrespondingJavaTypeName()
1:         {
1:                 if (SanityManager.DEBUG)
1:                 {
0:                         if (formatId == StoredFormatIds.REF_TYPE_ID)
1:                         {
0:                                 SanityManager.THROWASSERT("getCorrespondingJavaTypeName not implemented for StoredFormatIds.REF_TYPE_ID");
1:                         }
1:                         SanityManager.ASSERT(javaTypeName != null,
1:                                 "javaTypeName expected to be non-null");
1:                 }
1:                 return javaTypeName;
1:         }
1: 
1:          /**
1:          * Get the name of the corresponding Java type.
1:          *
1:          * This method is used directly from EmbedResultSetMetaData (jdbc)
1:          * to return the corresponding type (as choosen by getObject).
1:          * It solves a specific problem for BLOB types where the 
1:          * getCorrespondingJavaTypeName() is used internall for casting
1:          * which doesn't work if changed from byte[] to java.sql.Blob.
1:          * So we do it here instread, to avoid unexpected sideeffects.
1:          *
1:          * @return      The name of the corresponding Java type.
1:          */
1:         public String getResultSetMetaDataTypeName()
1:         {
0:             if (BLOB_ID == this)
1:                 return "java.sql.Blob";
0:             if (CLOB_ID == this)
1:                 return "java.sql.Clob";
0:             if (NCLOB_ID == this)
1:                 return "java.sql.Clob";
1:             return getCorrespondingJavaTypeName();
1:         }
1: 
1:         /**
1:          * Get the maximum maximum width of the type (that's not a typo).  For
1:          * types with variable length, this is the absolute maximum for the type.
1:          *
1:          * @return      The maximum maximum width of the type
1:          */
1:         public int getMaximumMaximumWidth()
1:         {
1:                 return maxMaxWidth;
1:         }
1: 
1:         /**
1:          * Converts this TypeId, given a data type descriptor (including length/precision),
1:          * to a string. E.g.
1:          *
1:          *                      VARCHAR(30)
1:          *
1:          *
1:          *      For most data types, we just return the SQL type name.
1:          *
1:          *      @param  dts     Data type descriptor that holds the length/precision etc. as necessary
1:          *
1:          *       @return        String version of datatype, suitable for running through
1:          *                      the Parser.
1:          */
1:         public String   toParsableString(DataTypeDescriptor dts)
1:         {
0:                 return  baseTypeId.toParsableString(dts);
1:         }
1: 
1:         /**
1:          * Is this a type id for a numeric type?
1:          *
1:          * @return Whether or not this a type id for a numeric type.
1:          */
1:         public boolean isNumericTypeId()
1:         {
1:                 return isNumericTypeId;
1:         }
1: 
1:         /**
1:          * Is this a type id for a decimal type?
1:          *
1:          * @return Whether or not this a type id for a decimal type.
1:          */
1:         public boolean isDecimalTypeId()
1:         {
1:                 return isDecimalTypeId;
1:         }
1: 
1: 
1:         /**
1:          * Is this a type id for a boolean type?
1:          *
1:          * @return Whether or not this a type id for a boolean type.
1:          */
1:         public boolean isBooleanTypeId()
1:         {
1:                 return isBooleanTypeId;
1:         }
1: 
1:         /**
1:          * Is this a type id for a ref type?
1:          *
1:          * @return Whether or not this a type id for a ref type.
1:          */
1:         public boolean isRefTypeId()
1:         {
1:                 return isRefTypeId;
1:         }
1: 
1:         /**
1:          * Is this a type id for a concatable type?
1:          *
1:          * @return Whether or not this a type id for a concatable type.
1:          */
1:         public boolean isConcatableTypeId()
1:         {
1:                 return isConcatableTypeId;
1:         }
1: 
1:         /**
1:          * Is this a type id for a bit type?
1:          *
1:          * @return Whether or not this a type id for a bit type.
1:          */
1:         public boolean isBitTypeId()
1:         {
1:                 return isBitTypeId;
1:         }
1: 
1:         /**
1:          * Is this a type id for a LOB type?
1:          *
1:          * @return Whether or not this a type id for a LOB type.
1:          */
1:         public boolean isLOBTypeId()
1:         {
1:                 return isLOBTypeId;
1:         }
1: 
1: 
1:         /**
1:          * Is this a type id for a long concatable type?
1:          *
1:          * @return Whether or not this a type id for a long concatable type.
1:          */
1:         public boolean isLongConcatableTypeId()
1:         {
1:                 return isLongConcatableTypeId;
1:         }
1: 
1:         /**
1:          * Is this a type id for a user defined type?
1:          *
1:          * @return Whether or not this a type id for a user defined type.
1:          */
1:         public boolean isUserDefinedTypeId()
1:         {
1:                 return isUserDefinedTypeId;
1:         }
1: 
0:         // Formatable interface
1: 
1:         /**
0:          * Read this object from a stream of stored objects.
1:          *
0:          * @param in read this.
1:          *
0:          * @exception IOException                                       thrown on error
0:          * @exception ClassNotFoundException            thrown on error
1:          */
0:         public void readExternal( ObjectInput in )
0:                  throws IOException, ClassNotFoundException
1:         {
0:                 baseTypeId = (BaseTypeIdImpl) in.readObject();
0:                 /* We need to set the type specific variables
0:                  * for user types when reading back off of the
0:                  * disk becuse the baseTypeId was null when the
0:                  * 0 argument constructor was called.
1:                  */
1:                 switch (formatId)
1:                 {
1:                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
1:                                 setTypeIdSpecificInstanceVariables();
1:                 }
1:         }
1: 
1:         /**
0:          * Write this object to a stream of stored objects.
1:          *
0:          * @param out write bytes here.
1:          *
0:          * @exception IOException               thrown on error
1:          */
0:         public void writeExternal( ObjectOutput out )
0:                  throws IOException
1:         {
0:                 out.writeObject( baseTypeId );
1:         }
1: 
1:         /**
1:          * Get the formatID which corresponds to this class.
1:          *
1:          *      @return the formatID of this class
1:          */
1:         public  int     getTypeFormatId()       
1:         { 
1:                 return formatId; 
1:         }
1: 
1: 
1:         /** 
1:          *  Get SQL null value.
1:          *  @return SQL null value for this type.
1:          */
1:         public DataValueDescriptor getNull()
1:         {
1:                 switch (formatId)
1:                 {
1:                         case StoredFormatIds.BIT_TYPE_ID:
1:                                 return new SQLBit();
1: 
1:                         case StoredFormatIds.BOOLEAN_TYPE_ID:
1:                                 return new SQLBoolean();
1: 
1:                         case StoredFormatIds.CHAR_TYPE_ID:
1:                                 return new SQLChar();
1: 
1:                         case StoredFormatIds.DECIMAL_TYPE_ID:
0:                                 return new SQLDecimal();
1: 
1:                         case StoredFormatIds.DOUBLE_TYPE_ID:
1:                                 return new SQLDouble();
1: 
1:                         case StoredFormatIds.INT_TYPE_ID:
1:                                 return new SQLInteger();
1: 
0:                         case StoredFormatIds.LONGINT_TYPE_ID:
1:                                 return new SQLLongint();
1: 
1:                         case StoredFormatIds.LONGVARBIT_TYPE_ID:
1:                                 return new SQLLongVarbit();
1: 
1:                         case StoredFormatIds.BLOB_TYPE_ID:
1:                                 return new SQLBlob();
1: 
1:                         case StoredFormatIds.CLOB_TYPE_ID:
1:                                 return new SQLClob();
1: 
0:                         case StoredFormatIds.NCLOB_TYPE_ID:
0:                                 return new SQLNClob();
1: 
1:                         case StoredFormatIds.LONGVARCHAR_TYPE_ID:
1:                                 return new SQLLongvarchar();
1: 
0:                         case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0:                                 return new SQLNationalChar();
1: 
0:                         case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
0:                                 return new SQLNationalVarchar();
1: 
0:                         case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID:
0:                                 return new SQLNationalLongvarchar();
1: 
1:                         case StoredFormatIds.REAL_TYPE_ID:
1:                                 return new SQLReal();
1: 
1:                         case StoredFormatIds.REF_TYPE_ID:
1:                                 return new SQLRef();
1: 
1:                         case StoredFormatIds.SMALLINT_TYPE_ID:
1:                                 return new SQLSmallint();
1: 
1:                         case StoredFormatIds.TINYINT_TYPE_ID:
1:                                 return new SQLTinyint();
1: 
1:                         case StoredFormatIds.DATE_TYPE_ID:
1:                                 return new SQLDate();
1: 
1:                         case StoredFormatIds.TIME_TYPE_ID:
1:                                 return new SQLTime();
1: 
1:                         case StoredFormatIds.TIMESTAMP_TYPE_ID:
1:                                 return new SQLTimestamp();
1: 
1:                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
1:                                 return new UserType();
1: 
1:                         case StoredFormatIds.VARBIT_TYPE_ID:
1:                                 return new SQLVarbit();
1: 
1:                         case StoredFormatIds.VARCHAR_TYPE_ID:
1:                                 return new SQLVarchar();
1: 
1:                         default:
1:                                 if (SanityManager.DEBUG)
1:                                 {
1:                                         SanityManager.THROWASSERT(
1:                                                 "unexpected formatId in getNull() - " + formatId);
1:                                 }
1:                                 return null;
1:                 }
1:         }
1:         /**
1:          * Is this type StreamStorable?
1:          *
1:          * @return      true if this type has variable length.
1:          */
1:         public boolean  streamStorable() {
1:                 return isStringTypeId() || isBitTypeId();
1:         }
1: 
1: 
1:         //
1:         //      Class methods
1:         //
1: 
1:         /**
1:          * Get the approximate length of this type in bytes.
1:          * For most datatypes this is just going to be
1:          * dts.getMaximumWidth().  Some types, such as
1:          * bit, will override this.
1:          *
1:          * @param dts Data type descriptor that holds the 
1:          *              length/precision etc. as necessary
1:          *
1:          * @return the length in bytes
1:          */
1:         public int getApproximateLengthInBytes(DataTypeDescriptor dts)
1:         {
1:                 switch (formatId)
1:                 {
1:                         case StoredFormatIds.BIT_TYPE_ID:
1:                                 return (int)(Math.ceil(dts.getMaximumWidth()/8d));
1: 
1:                         case StoredFormatIds.CHAR_TYPE_ID:
0:                         case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
1:                                 return (2 * dts.getMaximumWidth()) + 2;
1: 
1:                         case StoredFormatIds.DECIMAL_TYPE_ID:
1:                                 // Return 200 if precision is max int
1:                                 if (dts.getPrecision() == Integer.MAX_VALUE)
1:                                 {
1:                                         return 200;
1:                                 }
1:                                 else
1:                                 {
1:                                         return 8 + (int) (Math.ceil(((double)dts.getPrecision())/2d));
1:                                 }
1: 
1:                         case StoredFormatIds.LONGVARBIT_TYPE_ID:
1:                         case StoredFormatIds.BLOB_TYPE_ID:
1:                         case StoredFormatIds.CLOB_TYPE_ID:
0:                         case StoredFormatIds.NCLOB_TYPE_ID:
1:                                 return 10240;
1: 
1:                         case StoredFormatIds.REF_TYPE_ID:
1:                                 return 16;
1: 
1:                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
1:                                 /* For user types we'll guess on the high side
1:                                 ** (200) to avoid being too low in most cases.
1:                                 */
1:                                 return 200;
1: 
1:                         case StoredFormatIds.VARBIT_TYPE_ID:
1:                                 // Return 200 if maximum width is max int
1:                                 if (dts.getMaximumWidth() == Integer.MAX_VALUE)
1:                                 {
1:                                         return 200;
1:                                 }
1:                                 else
1:                                 {
1:                                         return (int)(Math.ceil(dts.getMaximumWidth()/8d));
1:                                 }
1: 
0:                         case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
1:                         case StoredFormatIds.VARCHAR_TYPE_ID:
1:                         case StoredFormatIds.LONGVARCHAR_TYPE_ID:
0:                         case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID:
1:                                 // Return 200 if maximum width is max int
1:                                 if (dts.getMaximumWidth() == Integer.MAX_VALUE)
1:                                 {
1:                                         return 200;
1:                                 }
1:                                 else
1:                                 {
1:                                         return (dts.getMaximumWidth() * 2) + 2;
1:                                 }
1:                         /*
1:                         ** For Date/time we know the exact size
1:                         ** thanks to some investigative work by
1:                         ** someone or other (sad isn't it).  
1:                         */
1:                         case StoredFormatIds.DATE_TYPE_ID:
1:                                 return 18;
1:                         case StoredFormatIds.TIME_TYPE_ID:
1:                                 return 16;
1:                         case StoredFormatIds.TIMESTAMP_TYPE_ID:
1:                                 return 29;
1: 
1:                         default:
1:                                 return dts.getMaximumWidth();
1:                 }
1:         }
1: 
1:         /**
1:          * Get the base type id that is embedded in this type id.  The base type
1:          * id is an object with a minimal implementation of TypeId that is intended
1:          * to be usable on the client side.
1:          */
1:         public BaseTypeIdImpl getBaseTypeId()
1:         {
1:                 return baseTypeId;
1:         }
1: 
1:         /**
1:          * Get the precision of the merge of two Decimals
1:          *
1:          * @param leftType the left type
1:          * @param rightType the left type
1:          *
1:          * @return      the resultant precision
1:          */
1:         public int getPrecision(DataTypeDescriptor leftType,
1:                                         DataTypeDescriptor rightType)
1:         {
1:                 if (SanityManager.DEBUG)
1:                 {
1:                         if (formatId != StoredFormatIds.DECIMAL_TYPE_ID)
1:                         {
1:                                 SanityManager.THROWASSERT(
1:                                         "getPrecision() not expected to be called for formatId - " + formatId);
1:                         }
1:                 }
1:                 long lscale = (long)leftType.getScale();
1:                 long rscale = (long)rightType.getScale();
1:                 long lprec = (long)leftType.getPrecision();
1:                 long rprec = (long)rightType.getPrecision();
1:                 long val;
1: 
1:                 /*
1:                 ** Take the maximum left of decimal digits plus the scale.
1:                 */
1:                 val = this.getScale(leftType, rightType) +
1:                                         Math.max(lprec - lscale, rprec - rscale);
1: 
1:                 if (val > Integer.MAX_VALUE)
1:                 {
1:                         val = Integer.MAX_VALUE;
1:                 }
1:                 return (int)val;
1:         }
1: 
1:         /**
1:          * Get the scale of the merge of two decimals
1:          *
1:          * @param leftType the left type
1:          * @param rightType the left type
1:          *
1:          * @return      the resultant precision
1:          */
1:         public int getScale(DataTypeDescriptor leftType,
1:                                                 DataTypeDescriptor rightType)
1:         {
1:                 if (SanityManager.DEBUG)
1:                 {
1:                         if (formatId != StoredFormatIds.DECIMAL_TYPE_ID)
1:                         {
1:                                 SanityManager.THROWASSERT(
1:                                         "getPrecision() not expected to be called for formatId - " + formatId);
1:                         }
1:                 }
1:                 /*
1:                 ** Retain greatest scale
1:                 */
1:                 return Math.max(leftType.getScale(), rightType.getScale());
1:         }
1: 
1:         /**
0:          * Is type variable length
1:          * @return boolean true if type is variable length false if not.  
1:          */
1:         public boolean variableLength()
1:         {
1:                 switch (formatId)
1:                 {
1:                         case StoredFormatIds.BIT_TYPE_ID:
1:                         case StoredFormatIds.VARBIT_TYPE_ID:
1:                         case StoredFormatIds.DECIMAL_TYPE_ID:
1:                         case StoredFormatIds.CHAR_TYPE_ID:
1:                         case StoredFormatIds.VARCHAR_TYPE_ID:
0:                         case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0:                         case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
1:                         case StoredFormatIds.BLOB_TYPE_ID:
0: // none of the LONG_VARCHAR types are true here...????
0: //                        case StoredFormatIds.CLOB_TYPE_ID:
0: //                        case StoredFormatIds.NCLOB_TYPE_ID:
0:                                 return true;
1: 
1:                         default:
1:                                 return false;
1:                 }
1:         }
1: }
1: 
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:111785f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         ** or by getBuiltInTypeId(string) if they are REF_NAME type.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 if (SQLTypeName.equals(TypeId.REF_NAME)) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		 * @return true if this is CHAR
1: 				return (formatId == StoredFormatIds.CHAR_TYPE_ID);
1: 		 * @return true if this is CLOB
1: 			   return (formatId == StoredFormatIds.CLOB_TYPE_ID);
/////////////////////////////////////////////////////////////////////////
1: 				return (formatId == StoredFormatIds.LONGVARCHAR_TYPE_ID);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1:         // not supposed to be limited! 4096G should be ok(?), if Derby can handle...
/////////////////////////////////////////////////////////////////////////
0:                 // Types defined below here are SQL types and non-JDBC types that are supported by Derby
/////////////////////////////////////////////////////////////////////////
1:          * the Derby internal type ids.  The JDBC type ids are defined
1:          * a Derby internal TypeId to a JDBC type id. For java objects this
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:077fe39
/////////////////////////////////////////////////////////////////////////
1:                         case StoredFormatIds.LONGVARBIT_TYPE_ID:
commit:099e28f
/////////////////////////////////////////////////////////////////////////
1:         public static final int XML_MAXWIDTH = Integer.MAX_VALUE;
/////////////////////////////////////////////////////////////////////////
0: 
1:         // Following use of "XML" is per SQL/XML (2003) spec,
1:         // section "10.2 Type name determination".
1:         public static final String      XML_NAME = "XML";
1:         public static final int XML_PRECEDENCE       = 180;
/////////////////////////////////////////////////////////////////////////
0:         private static TypeId                   XML_ID;
/////////////////////////////////////////////////////////////////////////
0: 
0:                   // XML is not a JDBC type, so we have to check for our
0:                   // internal XML type.
1:                   case StoredFormatIds.XML_TYPE_ID:
0:                       ret = XML_ID;
0:                       if (ret == null)
0:                           ret = XML_ID = new TypeId(StoredFormatIds.XML_TYPE_ID,
0:                                                      new BaseTypeIdImpl(StoredFormatIds.XML_TYPE_ID_IMPL));
0:                       break;
/////////////////////////////////////////////////////////////////////////
1:                 else if (javaTypeName.equals("org.apache.derby.iapi.types.XML"))
0:                 {
0:                         return getBuiltInTypeId(StoredFormatIds.XML_TYPE_ID);
0:                 }
/////////////////////////////////////////////////////////////////////////
0:                 if (SQLTypeName.equals(TypeId.XML_NAME)) {
0:                         return getBuiltInTypeId(StoredFormatIds.XML_TYPE_ID);
0:                 }
/////////////////////////////////////////////////////////////////////////
1:                       case StoredFormatIds.XML_TYPE_ID:
1:                               typePrecedence = XML_PRECEDENCE;
1:                               javaTypeName = "org.apache.derby.iapi.types.XML";
1:                               maxMaxWidth = TypeId.XML_MAXWIDTH;
0:                               break;
0: 
/////////////////////////////////////////////////////////////////////////
0:         /** 
1:          *Is this an XML doc?
0:          * @return true if this is XML
0:          */
1:         public boolean isXMLTypeId()
0:         {
1:                return (formatId == StoredFormatIds.XML_TYPE_ID);
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
1:                         case StoredFormatIds.XML_TYPE_ID:
/////////////////////////////////////////////////////////////////////////
1:                         case StoredFormatIds.XML_TYPE_ID:
1:                                 return new XML();
0: 
/////////////////////////////////////////////////////////////////////////
1:                         // RESOLVE: Should XML be here?  What's this value mean, anyway?
0:                         case StoredFormatIds.XML_TYPE_ID:
/////////////////////////////////////////////////////////////////////////
0:                         // RESOLVE: does "variableLength" here mean simply
0:                         // that the length is variable, or that the user
0:                         // can specify a length, such as "char(20)"?  The
0:                         // answer to that determines where XML is supposed
0:                         // to be...
0:                         case StoredFormatIds.XML_TYPE_ID:
commit:fd58c3c
/////////////////////////////////////////////////////////////////////////
1:         // Max width for datetime values is the length of the
1:         // string returned from a call to "toString()" on the
1:         // java.sql.Date, java.sql.Time, and java.sql.Timestamp
1:         // classes (the result of toString() on those classes
1:         // is defined by the JDBC API).  This value is also
1:         // used as the "precision" for those types.
1:         public static final int DATE_MAXWIDTH           = 10;	// yyyy-mm-dd
1:         public static final int TIME_MAXWIDTH           = 8;	// hh:mm:ss
0:         public static final int TIMESTAMP_MAXWIDTH      = 26;	// yyyy-mm-dd hh:mm:ss.ffffff
0: 
1:         // Scale DOES exist for time values.  For a TIMESTAMP value,
0:         // it's 6 ('ffffff'); for a TIME value, it's 0 (because there
1:         // are no fractional seconds).  Note that date values do
1:         // not have a scale.
1:         public static final int TIME_SCALE           = 0;
0:         public static final int TIMESTAMP_SCALE      = 6;
/////////////////////////////////////////////////////////////////////////
1:                                 maxMaxWidth = TypeId.DATE_MAXWIDTH;
1:                                 maxPrecision = TypeId.DATE_MAXWIDTH;
/////////////////////////////////////////////////////////////////////////
1:                                 maxScale = TypeId.TIME_SCALE;
1:                                 maxMaxWidth = TypeId.TIME_MAXWIDTH;
1:                                 maxPrecision = TypeId.TIME_MAXWIDTH;
1:                                 maxScale = TypeId.TIMESTAMP_SCALE;
1:                                 maxMaxWidth = TypeId.TIMESTAMP_MAXWIDTH;
1:                                 maxPrecision = TypeId.TIMESTAMP_MAXWIDTH;
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
1:         public static final int DECIMAL_PRECISION                       = Limits.DB2_MAX_DECIMAL_PRECISION_SCALE;
1:         public static final int DECIMAL_SCALE                           = Limits.DB2_MAX_DECIMAL_PRECISION_SCALE;
1:         public static final int DECIMAL_MAXWIDTH                        = Limits.DB2_MAX_DECIMAL_PRECISION_SCALE;
1:         public static final int CHAR_MAXWIDTH           = Limits.DB2_CHAR_MAXWIDTH;
1:         public static final int VARCHAR_MAXWIDTH        = Limits.DB2_VARCHAR_MAXWIDTH;
1:         public static final int LONGVARCHAR_MAXWIDTH = Limits.DB2_LONGVARCHAR_MAXWIDTH;
0:         public static final int NATIONAL_LONGVARCHAR_MAXWIDTH = Limits.DB2_LONGVARCHAR_MAXWIDTH;
1:         public static final int BIT_MAXWIDTH            = Limits.DB2_CHAR_MAXWIDTH;
1:         public static final int VARBIT_MAXWIDTH         = Limits.DB2_VARCHAR_MAXWIDTH;
1:         public static final int LONGVARBIT_MAXWIDTH = Limits.DB2_LONGVARCHAR_MAXWIDTH;
commit:bd4b50b
/////////////////////////////////////////////////////////////////////////
1:             if ((BLOB_ID != null) && BLOB_ID.equals(this))
1:             if ((CLOB_ID != null) && CLOB_ID.equals(this))
0:             if ((NCLOB_ID != null) && NCLOB_ID.equals(this))
commit:225ade3
/////////////////////////////////////////////////////////////////////////
0:             if (BLOB_ID.equals(this))
0:             if (CLOB_ID.equals(this))
0:             if (NCLOB_ID.equals(this))
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.types;
0: 
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.catalog.types.BaseTypeIdImpl;
0: import org.apache.derby.catalog.types.DecimalTypeIdImpl;
0: import org.apache.derby.catalog.types.UserDefinedTypeIdImpl;
0: 
0: import org.apache.derby.iapi.reference.DB2Limit;
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.types.*;
0: import org.apache.derby.iapi.types.*;
0: 
0: import org.apache.derby.iapi.reference.JDBC20Translation;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: 
0: import java.sql.Types;
0: 
0: /**
0:  * The TypeId interface provides methods to get information about datatype ids.
0:  
0:    <P>
0:  * The equals(Object) method can be used to determine if two typeIds are for the same type,
0:  * which defines type id equality.
0: 
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public final class TypeId implements Formatable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0:         /**
0:          * Various fixed numbers related to datatypes.
0:          */
0:         public static final int LONGINT_PRECISION                       = 19;
0:         public static final int LONGINT_SCALE                           = 0;
0:         public static final int LONGINT_MAXWIDTH                        = 8;
0: 
0:         public static final int INT_PRECISION                   = 10;
0:         public static final int INT_SCALE                               = 0;
0:         public static final int INT_MAXWIDTH                    = 4;
0: 
0:         public static final int SMALLINT_PRECISION                      = 5;
0:         public static final int SMALLINT_SCALE                          = 0;
0:         public static final int SMALLINT_MAXWIDTH                       = 2;
0: 
0:         public static final int TINYINT_PRECISION                       = 3;
0:         public static final int TINYINT_SCALE                           = 0;
0:         public static final int TINYINT_MAXWIDTH                        = 1;
0: 
0: 	// precision in number of bits 
0:         public static final int DOUBLE_PRECISION                        = 52;
0: 	// the ResultSetMetaData needs to have the precision for numeric data
0: 	// in decimal digits, rather than number of bits, so need a separate constant.
0:         public static final int DOUBLE_PRECISION_IN_DIGITS              = 15;
0:         public static final int DOUBLE_SCALE                            = 0;
0:         public static final int DOUBLE_MAXWIDTH                         = 8;
0: 
0: 	// precision in number of bits 
0:         public static final int REAL_PRECISION                  = 23;
0: 	// the ResultSetMetaData needs to have the precision for numeric data
0: 	// in decimal digits, rather than number of bits, so need a separate constant.
0:         public static final int REAL_PRECISION_IN_DIGITS        = 7;
0:         public static final int REAL_SCALE                              = 0;
0:         public static final int REAL_MAXWIDTH                   = 4;
0: 
0:         public static final int DECIMAL_PRECISION                       = DB2Limit.MAX_DECIMAL_PRECISION_SCALE;
0:         public static final int DECIMAL_SCALE                           = DB2Limit.MAX_DECIMAL_PRECISION_SCALE;
0:         public static final int DECIMAL_MAXWIDTH                        = DB2Limit.MAX_DECIMAL_PRECISION_SCALE;
0: 
0:         public static final int BOOLEAN_MAXWIDTH                        = 1;
0: 
0:         public static final int CHAR_MAXWIDTH           = DB2Limit.DB2_CHAR_MAXWIDTH;
0:         public static final int VARCHAR_MAXWIDTH        = DB2Limit.DB2_VARCHAR_MAXWIDTH;
0:         public static final int LONGVARCHAR_MAXWIDTH = DB2Limit.DB2_LONGVARCHAR_MAXWIDTH;
0:         public static final int NATIONAL_CHAR_MAXWIDTH  = Integer.MAX_VALUE;
0:         public static final int NATIONAL_VARCHAR_MAXWIDTH       = Integer.MAX_VALUE;
0:         public static final int NATIONAL_LONGVARCHAR_MAXWIDTH = DB2Limit.DB2_LONGVARCHAR_MAXWIDTH;
0:         public static final int BIT_MAXWIDTH            = DB2Limit.DB2_CHAR_MAXWIDTH;
0:         public static final int VARBIT_MAXWIDTH         = DB2Limit.DB2_VARCHAR_MAXWIDTH;
0:         public static final int LONGVARBIT_MAXWIDTH = DB2Limit.DB2_LONGVARCHAR_MAXWIDTH;
0: 
0:         // not supposed to be limited! 4096G should be ok(?), if Cloudscape can handle...
0:         public static final int BLOB_MAXWIDTH = Integer.MAX_VALUE; // to change long
0:         public static final int CLOB_MAXWIDTH = Integer.MAX_VALUE; // to change long
0:         public static final int NCLOB_MAXWIDTH = Integer.MAX_VALUE; // to change long
0: 
0:         public static final int DATE_MAXWIDTH           = 4;
0:         public static final int TIME_MAXWIDTH           = 8;
0:         public static final int TIMESTAMP_MAXWIDTH      = 12;
0: 
0:         /* These define all the type names for SQL92 and JDBC 
0:          * NOTE: boolean is SQL3
0:          */
0:           //public static final String      BIT_NAME = "BIT";
0:           //public static final String      VARBIT_NAME = "BIT VARYING";
0:           //public static final String      LONGVARBIT_NAME = "LONG BIT VARYING";
0: 
0:         public static final String      BIT_NAME = "CHAR () FOR BIT DATA";
0:         public static final String      VARBIT_NAME = "VARCHAR () FOR BIT DATA";
0:         public static final String      LONGVARBIT_NAME = "LONG VARCHAR FOR BIT DATA";
0:         public static final String      TINYINT_NAME = "TINYINT";
0:         public static final String      SMALLINT_NAME = "SMALLINT";
0:         public static final String      INTEGER_NAME = "INTEGER";
0:         public static final String      LONGINT_NAME = "BIGINT";
0:         public static final String      FLOAT_NAME = "FLOAT";
0:         public static final String      REAL_NAME = "REAL";
0:         public static final String      DOUBLE_NAME = "DOUBLE";
0:         public static final String      NUMERIC_NAME = "NUMERIC";
0:         public static final String      DECIMAL_NAME = "DECIMAL";
0:         public static final String      CHAR_NAME = "CHAR";
0:         public static final String      VARCHAR_NAME = "VARCHAR";
0:         public static final String      LONGVARCHAR_NAME = "LONG VARCHAR";
0:         public static final String      DATE_NAME = "DATE";
0:         public static final String      TIME_NAME = "TIME";
0:         public static final String      TIMESTAMP_NAME = "TIMESTAMP";
0:         public static final String      BINARY_NAME = "BINARY";
0:         public static final String      VARBINARY_NAME = "VARBINARY";
0:         public static final String      LONGVARBINARY_NAME = "LONGVARBINARY";
0:         public static final String      BOOLEAN_NAME = "BOOLEAN";
0:         public static final String      REF_NAME = "REF";
0:         public static final String      NATIONAL_CHAR_NAME = "NATIONAL CHAR";
0:         public static final String      NATIONAL_VARCHAR_NAME = "NATIONAL CHAR VARYING";
0:         public static final String      NATIONAL_LONGVARCHAR_NAME = "LONG NVARCHAR";
0:         public static final String      BLOB_NAME = "BLOB";
0:         public static final String      CLOB_NAME = "CLOB";
0:         public static final String      NCLOB_NAME = "NCLOB";
0:         
0:         /**
0:          * The following constants define the type precedence hierarchy.
0:          */
0:         public static final int USER_PRECEDENCE  = 1000;
0: 
0:         public static final int BLOB_PRECEDENCE = 170;
0:         public static final int LONGVARBIT_PRECEDENCE = 160;
0:         public static final int VARBIT_PRECEDENCE        = 150;
0:         public static final int BIT_PRECEDENCE           = 140;
0:         public static final int BOOLEAN_PRECEDENCE       = 130;
0:         public static final int TIME_PRECEDENCE  = 120;
0:         public static final int TIMESTAMP_PRECEDENCE = 110;
0:         public static final int DATE_PRECEDENCE  = 100;
0:         public static final int DOUBLE_PRECEDENCE        = 90;
0:         public static final int REAL_PRECEDENCE  = 80;
0:         public static final int DECIMAL_PRECEDENCE       = 70;
0:         public static final int NUMERIC_PRECEDENCE       = 69;
0:         public static final int LONGINT_PRECEDENCE       = 60;
0:         public static final int INT_PRECEDENCE           = 50;
0:         public static final int SMALLINT_PRECEDENCE = 40;
0:         public static final int TINYINT_PRECEDENCE       = 30;
0:         public static final int REF_PRECEDENCE           = 25;
0:         public static final int NATIONAL_LONGVARCHAR_PRECEDENCE = 18;
0:         public static final int NATIONAL_VARCHAR_PRECEDENCE  = 17;
0:         public static final int NATIONAL_CHAR_PRECEDENCE         = 16;
0:         public static final int CLOB_PRECEDENCE = 14;
0:         public static final int NCLOB_PRECEDENCE = 13; 
0:         public static final int LONGVARCHAR_PRECEDENCE = 12;
0:         public static final int VARCHAR_PRECEDENCE  = 10;
0:         public static final int CHAR_PRECEDENCE  = 0;
0: 
0:         /*
0:         ** Static runtime fields for typeIds
0:         ** These are put here because the system needs them init time.
0:         */
0:         public static final TypeId              BOOLEAN_ID = new TypeId(StoredFormatIds.BOOLEAN_TYPE_ID,
0:                                                                                                                         new BaseTypeIdImpl(StoredFormatIds.BOOLEAN_TYPE_ID_IMPL));
0:         public static final TypeId              INTEGER_ID = new TypeId(StoredFormatIds.INT_TYPE_ID,
0:                                                                                                                         new BaseTypeIdImpl(StoredFormatIds.INT_TYPE_ID_IMPL));
0:         public static final TypeId              CHAR_ID = new TypeId(StoredFormatIds.CHAR_TYPE_ID,
0:                                                                                                                  new BaseTypeIdImpl(StoredFormatIds.CHAR_TYPE_ID_IMPL));
0:         /*
0:         ** Others are created on demand by the getBuiltInTypeId(int),
0:         ** if they are built-in (i.e.? Part of JDBC .Types),
0:         ** or by getBuiltInTypeId(string) if they are NATIONAL types or REF_NAME type.
0:         */
0: 
0:         private static TypeId                   TINYINT_ID;
0:         private static TypeId                   SMALLINT_ID;
0:         private static TypeId                   LONGINT_ID;
0:         private static TypeId                   REAL_ID;
0:         private static TypeId                   DOUBLE_ID;
0:         private static TypeId                   DECIMAL_ID;
0:         private static TypeId                   NUMERIC_ID;
0:         private static TypeId                   VARCHAR_ID;
0:         private static TypeId                   NATIONAL_CHAR_ID;
0:         private static TypeId                   NATIONAL_LONGVARCHAR_ID;
0:         private static TypeId                   NATIONAL_VARCHAR_ID;
0:         private static TypeId                   DATE_ID;
0:         private static TypeId                   TIME_ID;
0:         private static TypeId                   TIMESTAMP_ID;
0:         private static TypeId                   BIT_ID;
0:         private static TypeId                   VARBIT_ID;
0:         private static TypeId                   REF_ID;
0:         private static TypeId                   LONGVARCHAR_ID;
0:         private static TypeId                   LONGVARBIT_ID;
0: 
0:         private static TypeId                   BLOB_ID;
0:         private static TypeId                   CLOB_ID;
0:         private static TypeId                   NCLOB_ID;
0: 
0: 
0: 
0:         /*
0:         ** Static methods to obtain TypeIds
0:         */
0:         /**
0:          * Get a TypeId of the given JDBC type.  This factory method is
0:          * intended to be used for built-in types.  For user-defined types,
0:          * we will need a factory method that takes a Java type name.
0:          *
0:          * @param JDBCTypeId    The JDBC Id of the type, as listed in
0:          *                      java.sql.Types
0:          *
0:          * @return      The appropriate TypeId, or null if there is no such
0:          *                      TypeId.
0:          */
0: 
0:         public static TypeId getBuiltInTypeId(int JDBCTypeId)
0:         {
0:                 TypeId ret = null;
0: 
0:                 switch (JDBCTypeId)
0:                 {
0:                   case Types.TINYINT:
0:                           ret = TINYINT_ID;
0:                           if (ret == null)
0:                                   ret = TINYINT_ID = new TypeId(StoredFormatIds.TINYINT_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.TINYINT_TYPE_ID_IMPL));
0:                           break;
0: 
0:                   case Types.SMALLINT:
0:                           ret = SMALLINT_ID;
0:                           if (ret == null)
0:                                   ret = SMALLINT_ID = new TypeId(StoredFormatIds.SMALLINT_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.SMALLINT_TYPE_ID_IMPL));
0:                           break;
0: 
0:                   case Types.INTEGER:
0:                           return INTEGER_ID;
0: 
0:                   case Types.BIGINT:
0:                           ret = LONGINT_ID;
0:                           if (ret == null)
0:                                   ret = LONGINT_ID = new TypeId(StoredFormatIds.LONGINT_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.LONGINT_TYPE_ID_IMPL));
0:                           break;
0: 
0:                   case Types.REAL:
0:                           ret = REAL_ID;
0:                           if (ret == null)
0:                                   ret = REAL_ID = new TypeId(StoredFormatIds.REAL_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.REAL_TYPE_ID_IMPL));
0:                           break;
0: 
0:                   case Types.FLOAT:
0:                   case Types.DOUBLE:
0:                           ret = DOUBLE_ID;
0:                           if (ret == null)
0:                                   ret = DOUBLE_ID = new TypeId(StoredFormatIds.DOUBLE_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.DOUBLE_TYPE_ID_IMPL));
0:                           break;
0: 
0:                   case Types.DECIMAL:
0:                           ret = DECIMAL_ID;
0:                           if (ret == null)
0:                                   ret = DECIMAL_ID = new TypeId(StoredFormatIds.DECIMAL_TYPE_ID,
0:                                                                         new DecimalTypeIdImpl());
0:                           break;
0: 
0:                   case Types.NUMERIC:
0:                           ret = NUMERIC_ID;
0:                           if (ret == null) {
0:                                   DecimalTypeIdImpl numericTypeIdImpl = new DecimalTypeIdImpl();
0:                                   numericTypeIdImpl.setNumericType();
0:                                   ret = NUMERIC_ID = new TypeId(StoredFormatIds.DECIMAL_TYPE_ID, numericTypeIdImpl);
0:                           }
0:                           break;
0: 
0:                   case Types.CHAR:
0:                           return CHAR_ID;
0: 
0:                   case Types.VARCHAR:
0:                           ret = VARCHAR_ID;
0:                           if (ret == null)
0:                                   ret = VARCHAR_ID = new TypeId(StoredFormatIds.VARCHAR_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.VARCHAR_TYPE_ID_IMPL));
0:                           break;
0: 
0:                   case Types.DATE:
0:                           ret = DATE_ID;
0:                           if (ret == null)
0:                                   ret = DATE_ID = new TypeId(StoredFormatIds.DATE_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.DATE_TYPE_ID_IMPL));
0:                           break;
0: 
0:                   case Types.TIME:
0:                           ret = TIME_ID;
0:                           if (ret == null)
0:                                   ret = TIME_ID = new TypeId(StoredFormatIds.TIME_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.TIME_TYPE_ID_IMPL));
0:                           break;
0: 
0:                   case Types.TIMESTAMP:
0:                           ret = TIMESTAMP_ID;
0:                           if (ret == null)
0:                                   ret = TIMESTAMP_ID = new TypeId(StoredFormatIds.TIMESTAMP_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.TIMESTAMP_TYPE_ID_IMPL));
0:                           break;
0:                   case Types.BIT:
0:                   case JDBC30Translation.SQL_TYPES_BOOLEAN:
0:                           return BOOLEAN_ID;
0: 
0:                   case Types.BINARY:
0:                           ret = BIT_ID;
0:                           if (ret == null)
0:                                   ret = BIT_ID = new TypeId(StoredFormatIds.BIT_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.BIT_TYPE_ID_IMPL));
0:                           break;
0: 
0:                   case Types.VARBINARY:
0:                           ret = VARBIT_ID;
0:                           if (ret == null)
0:                                   ret = VARBIT_ID = new TypeId(StoredFormatIds.VARBIT_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.VARBIT_TYPE_ID_IMPL));
0:                           break;
0: 
0:                   case Types.LONGVARBINARY:
0:                           ret = LONGVARBIT_ID;
0:                           if (ret == null)
0:                                   ret = LONGVARBIT_ID = new TypeId(StoredFormatIds.LONGVARBIT_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.LONGVARBIT_TYPE_ID_IMPL));
0:                           break;
0: 
0:                   case Types.LONGVARCHAR:
0:                       ret = LONGVARCHAR_ID;
0:                       if (ret == null)
0:                           ret = LONGVARCHAR_ID = new TypeId(StoredFormatIds.LONGVARCHAR_TYPE_ID,
0:                                                             new BaseTypeIdImpl(StoredFormatIds.LONGVARCHAR_TYPE_ID_IMPL));
0:                       break;
0: 
0:                   case JDBC20Translation.SQL_TYPES_BLOB:
0:                       ret = BLOB_ID;
0:                       if (ret == null)
0:                           ret = BLOB_ID = new TypeId(StoredFormatIds.BLOB_TYPE_ID,
0:                                                      new BaseTypeIdImpl(StoredFormatIds.BLOB_TYPE_ID_IMPL));
0:                       break;
0:                                                 
0:                   case JDBC20Translation.SQL_TYPES_CLOB:
0:                       ret = CLOB_ID;
0:                       if (ret == null)
0:                           ret = CLOB_ID = new TypeId(StoredFormatIds.CLOB_TYPE_ID,
0:                                                      new BaseTypeIdImpl(StoredFormatIds.CLOB_TYPE_ID_IMPL));
0:                       break;
0:                 }
0:                 return ret;
0:         }
0: 
0:         public static TypeId getUserDefinedTypeId(String className, boolean delimitedIdentifier)
0:         {
0:                 return new TypeId(StoredFormatIds.USERDEFINED_TYPE_ID_V3,
0:                                         new UserDefinedTypeIdImpl(className), delimitedIdentifier
0:                                         );
0:         }
0: 
0:         /**
0:          * Get a TypeId for the class that corresponds to the given
0:          * Java type name.
0:          *
0:          * @param javaTypeName          The name of the Java type
0:          *
0:          * @return      A TypeId for the SQL type that corresponds to
0:          *                      the Java type, null if there is no corresponding type.
0:          */
0:         public static TypeId getSQLTypeForJavaType(String javaTypeName)
0:         {
0:                 if (javaTypeName.equals("java.lang.Boolean") ||
0:                         javaTypeName.equals("boolean"))
0:                 {
0:                         return TypeId.BOOLEAN_ID;
0:                 }
0:                 else if (javaTypeName.equals("byte[]"))
0:                 {
0:                         return getBuiltInTypeId(Types.VARBINARY);
0:                 }
0:                 else if (javaTypeName.equals("java.lang.String"))
0:                 {
0:                         return getBuiltInTypeId(Types.VARCHAR);
0:                 }
0:                 else if (javaTypeName.equals("java.lang.Integer") ||
0:                                 javaTypeName.equals("int"))
0:                 {
0:                         return TypeId.INTEGER_ID;
0:                 }
0:                 else if (javaTypeName.equals("byte"))
0:                 {
0:                         return getBuiltInTypeId(Types.TINYINT);
0:                 }
0:                 else if (javaTypeName.equals("short"))
0:                 {
0:                         return getBuiltInTypeId(Types.SMALLINT);
0:                 }
0:                 else if (javaTypeName.equals("java.lang.Long") ||
0:                                 javaTypeName.equals("long"))
0:                 {
0:                         return getBuiltInTypeId(Types.BIGINT);
0:                 }
0:                 else if (javaTypeName.equals("java.lang.Float") ||
0:                                 javaTypeName.equals("float"))
0:                 {
0:                         return getBuiltInTypeId(Types.REAL);
0:                 }
0:                 else if (javaTypeName.equals("java.lang.Double") ||
0:                                 javaTypeName.equals("double"))
0:                 {
0:                         return getBuiltInTypeId(Types.DOUBLE);
0:                 }
0:                 else if (javaTypeName.equals("java.math.BigDecimal"))
0:                 {
0:                         return getBuiltInTypeId(Types.DECIMAL);
0:                 }
0:                 else if (javaTypeName.equals("java.sql.Date"))
0:                 {
0:                         return getBuiltInTypeId(Types.DATE);
0:                 }
0:                 else if (javaTypeName.equals("java.sql.Time"))
0:                 {
0:                         return getBuiltInTypeId(Types.TIME);
0:                 }
0:                 else if (javaTypeName.equals("java.sql.Timestamp"))
0:                 {
0:                         return getBuiltInTypeId(Types.TIMESTAMP);
0:                 }
0:                 else if (javaTypeName.equals("java.sql.Blob"))
0:                 {
0:                         return getBuiltInTypeId(JDBC20Translation.SQL_TYPES_BLOB);
0:                 }
0:                 else if (javaTypeName.equals("java.sql.Clob"))
0:                 {
0:                         return getBuiltInTypeId(JDBC20Translation.SQL_TYPES_CLOB);
0:                 }
0:                 else
0:                 {
0:                         /*
0:                         ** If it's a Java primitive type, return null to indicate that
0:                         ** there is no corresponding SQL type (all the Java primitive
0:                         ** types that have corresponding SQL types are handled above).
0:                         **
0:                         ** There is only one primitive type not mentioned above, char.
0:                         */
0:                         if (javaTypeName.equals("char"))
0:                         {
0:                                 return null;
0:                         }
0: 
0:                         /*
0:                         ** It's a non-primitive type (a class) that does not correspond
0:                         ** to a SQL built-in type, so treat it as a user-defined type.
0:                         */
0:                         return TypeId.getUserDefinedTypeId(javaTypeName, false);
0:                 }
0:         }
0: 
0:         public static TypeId getBuiltInTypeId(String SQLTypeName) {
0: 
0:                 if (SQLTypeName.equals(TypeId.BOOLEAN_NAME)) {
0:                         return TypeId.BOOLEAN_ID;
0:                 }
0:                 if (SQLTypeName.equals(TypeId.CHAR_NAME)) {
0:                         return TypeId.CHAR_ID;
0:                 }
0:                 if (SQLTypeName.equals(TypeId.DATE_NAME)) {
0:                         return getBuiltInTypeId(Types.DATE);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.DOUBLE_NAME)) {
0:                         return getBuiltInTypeId(Types.DOUBLE);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.FLOAT_NAME)) {
0:                         return getBuiltInTypeId(Types.DOUBLE);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.INTEGER_NAME)) {
0:                         return TypeId.INTEGER_ID;
0:                 }
0:                 if (SQLTypeName.equals(TypeId.LONGINT_NAME)) {
0:                         return getBuiltInTypeId(Types.BIGINT);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.REAL_NAME)) {
0:                         return getBuiltInTypeId(Types.REAL);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.SMALLINT_NAME)) {
0:                         return getBuiltInTypeId(Types.SMALLINT);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.TIME_NAME)) {
0:                         return getBuiltInTypeId(Types.TIME);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.TIMESTAMP_NAME)) {
0:                         return getBuiltInTypeId(Types.TIMESTAMP);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.VARCHAR_NAME)) {
0:                         return getBuiltInTypeId(Types.VARCHAR);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.BIT_NAME)) {
0:                         return getBuiltInTypeId(Types.BINARY);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.VARBIT_NAME)) {
0:                         return getBuiltInTypeId(Types.VARBINARY);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.TINYINT_NAME)) {
0:                         return getBuiltInTypeId(Types.TINYINT);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.DECIMAL_NAME)) {
0:                         return getBuiltInTypeId(Types.DECIMAL);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.NUMERIC_NAME)) {
0:                         return getBuiltInTypeId(Types.NUMERIC);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.LONGVARCHAR_NAME)) {
0:                         return getBuiltInTypeId(Types.LONGVARCHAR);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.LONGVARBIT_NAME)) {
0:                         return getBuiltInTypeId(Types.LONGVARBINARY);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.BLOB_NAME)) {
0:                         return getBuiltInTypeId(JDBC20Translation.SQL_TYPES_BLOB);
0:                 }
0:                 if (SQLTypeName.equals(TypeId.CLOB_NAME)) {
0:                         return getBuiltInTypeId(JDBC20Translation.SQL_TYPES_CLOB);
0:                 }
0: 
0:                 TypeId ret = null;
0: 
0:                 // Types defined below here are SQL types and non-JDBC types that are supported by Cloudscape
0:                 if (SQLTypeName.equals(TypeId.NCLOB_NAME)) {
0:                         ret = NCLOB_ID;
0:                         if (ret == null)
0:                                 ret = NCLOB_ID = new TypeId(StoredFormatIds.NCLOB_TYPE_ID,
0:                                                             new BaseTypeIdImpl(StoredFormatIds.NCLOB_TYPE_ID_IMPL));
0:                 } else if (SQLTypeName.equals(TypeId.NATIONAL_CHAR_NAME)) {
0:                         ret = NATIONAL_CHAR_ID;
0:                         if (ret == null)
0:                                 ret = NATIONAL_CHAR_ID = new TypeId(StoredFormatIds.NATIONAL_CHAR_TYPE_ID,
0:                                                                     new BaseTypeIdImpl(StoredFormatIds.NATIONAL_CHAR_TYPE_ID_IMPL));
0: 
0:                 } else if (SQLTypeName.equals(TypeId.NATIONAL_LONGVARCHAR_NAME)) {
0:                         ret = NATIONAL_LONGVARCHAR_ID;
0:                         if (ret == null)
0:                                 ret = NATIONAL_LONGVARCHAR_ID = new TypeId(StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID_IMPL));
0: 
0:                 } else if (SQLTypeName.equals(TypeId.NATIONAL_VARCHAR_NAME)) {
0:                         ret = NATIONAL_VARCHAR_ID;
0:                         if (ret == null)
0:                                 ret = NATIONAL_VARCHAR_ID = new TypeId(StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID_IMPL));
0: 
0:                 } else if (SQLTypeName.equals(TypeId.REF_NAME)) {
0:                         ret = REF_ID;
0:                         if (ret == null)
0:                                 ret = REF_ID = new TypeId(StoredFormatIds.REF_TYPE_ID,
0:                                                                         new BaseTypeIdImpl(StoredFormatIds.REF_TYPE_ID_IMPL));
0:                 }
0:                 return ret;
0:         }
0: 
0:         /*
0:         ** Instance fields and methods
0:         */
0: 
0:         private BaseTypeIdImpl  baseTypeId;
0:         private int                             formatId;
0: 
0:         /* Set in setTypeIdSpecificInstanceVariables() as needed */
0:         private boolean                 classNameWasDelimitedIdentifier;
0:         private boolean                 isBuiltIn = true;
0:         private boolean                 isBitTypeId;
0:         private boolean                 isLOBTypeId;
0:         private boolean                 isBooleanTypeId;
0:         private boolean                 isConcatableTypeId;
0:         private boolean                 isDecimalTypeId;
0:         private boolean                 isLongConcatableTypeId;
0:         private boolean                 isNumericTypeId;
0:         private boolean                 isRefTypeId;
0:         private boolean                 isStringTypeId;
0:         private boolean                 isFloatingPointTypeId;
0:         private boolean                 isRealTypeId;
0:         private boolean                 isDateTimeTimeStampTypeId;
0:         private boolean                 isUserDefinedTypeId;
0:         private int                             maxPrecision;
0:         private int                             maxScale;
0:         private int                             typePrecedence;
0:         private String                  javaTypeName;
0:         private int                             maxMaxWidth;
0: 
0:         /**
0:          * 1 argmument constructor. Needed for Formatable interface to work.
0:          *
0:          * @param formatId      Format id of specific type id.
0:          */
0: 
0:         public  TypeId(int formatId) 
0:         {
0:                 this.formatId = formatId;
0:                 setTypeIdSpecificInstanceVariables();
0:         }
0: 
0:         /**
0:          * Constructor for a TypeId
0:          *
0:          * @param formatId      Format id of specific type id.
0:          * @param baseTypeId    The Base type id
0:          */
0:         public TypeId(int formatId, BaseTypeIdImpl baseTypeId)
0:         {
0:                 this.formatId = formatId;
0:                 this.baseTypeId = baseTypeId;
0:                 setTypeIdSpecificInstanceVariables();
0:         }
0:         /**
0:          * Constructor for a TypeId for user defined types
0:          *
0:          * @param formatId                                                      Format id of specific type id.
0:          * @param baseTypeId                                            The Base type id
0:          * @param classNameWasDelimitedIdentifier       Whether or not the class name
0:          *                                                                                      was a delimited identifier
0:          */
0:         public TypeId(int formatId, BaseTypeIdImpl baseTypeId,
0:                                                  boolean classNameWasDelimitedIdentifier)
0:         {
0:                 this.formatId = formatId;
0:                 this.baseTypeId = baseTypeId;
0:                 this.classNameWasDelimitedIdentifier = classNameWasDelimitedIdentifier;
0:                 setTypeIdSpecificInstanceVariables();
0:         }
0: 
0:         /**
0:          * we want equals to say if these are the same type id or not.
0:          */
0:         public boolean equals(Object that)
0:         {
0:                 if (that instanceof TypeId)
0:                         return this.getSQLTypeName().equals(((TypeId)that).getSQLTypeName());
0:                 else
0:                         return false;
0:         }
0: 
0:         /*
0:           Hashcode which works with equals.
0:           */
0:         public int hashCode()
0:         {
0:                 return this.getSQLTypeName().hashCode();
0:         }
0: 
0: 
0:         private void setTypeIdSpecificInstanceVariables()
0:         {
0:                 switch (formatId)
0:                 {
0:                         case StoredFormatIds.BIT_TYPE_ID:
0:                                 typePrecedence = BIT_PRECEDENCE;
0:                                 javaTypeName = "byte[]";
0:                                 maxMaxWidth = TypeId.BIT_MAXWIDTH;
0:                                 isBitTypeId = true;
0:                                 isConcatableTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.BOOLEAN_TYPE_ID:
0:                                 typePrecedence = BOOLEAN_PRECEDENCE;
0:                                 javaTypeName = "java.lang.Boolean";
0:                                 maxMaxWidth = TypeId.BOOLEAN_MAXWIDTH;
0:                                 isBooleanTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.CHAR_TYPE_ID:
0:                                 typePrecedence = CHAR_PRECEDENCE;
0:                                 javaTypeName = "java.lang.String";
0:                                 maxMaxWidth = TypeId.CHAR_MAXWIDTH;
0:                                 isStringTypeId = true;
0:                                 isConcatableTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.DATE_TYPE_ID:
0:                                 typePrecedence = DATE_PRECEDENCE;
0:                                 javaTypeName = "java.sql.Date";
0:                                 /* this is used in ResultSetMetaData.getPrecision
0:                                  * undefined for datetime types
0:                                  */
0:                                 maxMaxWidth = -1;
0:                                 isDateTimeTimeStampTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.DECIMAL_TYPE_ID:
0:                                 maxPrecision = TypeId.DECIMAL_PRECISION;
0:                                 maxScale = TypeId.DECIMAL_SCALE;
0:                                 typePrecedence = DECIMAL_PRECEDENCE;
0:                                 javaTypeName = "java.math.BigDecimal";
0:                                 maxMaxWidth = TypeId.DECIMAL_MAXWIDTH;
0:                                 isDecimalTypeId = true;
0:                                 isNumericTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.DOUBLE_TYPE_ID:
0:                                 maxPrecision = TypeId.DOUBLE_PRECISION;
0:                                 maxScale = TypeId.DOUBLE_SCALE;
0:                                 typePrecedence = DOUBLE_PRECEDENCE;
0:                                 javaTypeName = "java.lang.Double";
0:                                 maxMaxWidth = TypeId.DOUBLE_MAXWIDTH;
0:                                 isNumericTypeId = true;
0: 								isFloatingPointTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.INT_TYPE_ID:
0:                                 maxPrecision = TypeId.INT_PRECISION;
0:                                 maxScale = TypeId.INT_SCALE;
0:                                 typePrecedence = INT_PRECEDENCE;
0:                                 javaTypeName = "java.lang.Integer";
0:                                 maxMaxWidth = TypeId.INT_MAXWIDTH;
0:                                 isNumericTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.LONGINT_TYPE_ID:
0:                                 maxPrecision = TypeId.LONGINT_PRECISION;
0:                                 maxScale = TypeId.LONGINT_SCALE;
0:                                 typePrecedence = LONGINT_PRECEDENCE;
0:                                 javaTypeName = "java.lang.Long";
0:                                 maxMaxWidth = TypeId.LONGINT_MAXWIDTH;
0:                                 isNumericTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.LONGVARBIT_TYPE_ID:
0:                                 typePrecedence = LONGVARBIT_PRECEDENCE;
0:                                 javaTypeName = "byte[]";
0:                                 maxMaxWidth = TypeId.LONGVARBIT_MAXWIDTH;
0:                                 isBitTypeId = true;
0:                                 isConcatableTypeId = true;
0:                                 isLongConcatableTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.LONGVARCHAR_TYPE_ID:
0:                                 typePrecedence = LONGVARCHAR_PRECEDENCE;
0:                                 javaTypeName = "java.lang.String";
0:                                 maxMaxWidth = TypeId.LONGVARCHAR_MAXWIDTH;
0:                                 isStringTypeId = true;
0:                                 isConcatableTypeId = true;
0:                                 isLongConcatableTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0:                                 typePrecedence = NATIONAL_CHAR_PRECEDENCE;
0:                                 javaTypeName = "java.lang.String";
0:                                 maxMaxWidth = TypeId.NATIONAL_CHAR_MAXWIDTH;
0:                                 isStringTypeId = true;
0:                                 isConcatableTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID:
0:                                 typePrecedence = NATIONAL_LONGVARCHAR_PRECEDENCE;
0:                                 javaTypeName = "java.lang.String";
0:                                 maxMaxWidth = TypeId.NATIONAL_LONGVARCHAR_MAXWIDTH;
0:                                 isStringTypeId = true;
0:                                 isConcatableTypeId = true;
0:                                 isLongConcatableTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
0:                                 typePrecedence = NATIONAL_VARCHAR_PRECEDENCE;
0:                                 javaTypeName = "java.lang.String";
0:                                 maxMaxWidth = TypeId.NATIONAL_VARCHAR_MAXWIDTH;
0:                                 isStringTypeId = true;
0:                                 isConcatableTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.REAL_TYPE_ID:
0:                                 maxPrecision = TypeId.REAL_PRECISION;
0:                                 maxScale = TypeId.REAL_SCALE;
0:                                 typePrecedence = REAL_PRECEDENCE;
0:                                 javaTypeName = "java.lang.Float";
0:                                 maxMaxWidth = TypeId.REAL_MAXWIDTH;
0:                                 isNumericTypeId = true;
0:                                 isRealTypeId = true;
0:                                 isFloatingPointTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.REF_TYPE_ID:
0:                                 typePrecedence = REF_PRECEDENCE;
0:                                 isRefTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.SMALLINT_TYPE_ID:
0:                                 maxPrecision = TypeId.SMALLINT_PRECISION;
0:                                 maxScale = TypeId.SMALLINT_SCALE;
0:                                 typePrecedence = SMALLINT_PRECEDENCE;
0:                                 javaTypeName = "java.lang.Integer";
0:                                 maxMaxWidth = TypeId.SMALLINT_MAXWIDTH;
0:                                 isNumericTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.TIME_TYPE_ID:
0:                                 typePrecedence = TIME_PRECEDENCE;
0:                                 javaTypeName = "java.sql.Time";
0:                                 /* this is used in ResultSetMetaData.getPrecision
0:                                  * undefined for datetime types
0:                                  */
0:                                 maxMaxWidth = -1;
0:                                 isDateTimeTimeStampTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.TIMESTAMP_TYPE_ID:
0:                                 typePrecedence = TIMESTAMP_PRECEDENCE;
0:                                 javaTypeName = "java.sql.Timestamp";
0:                                 /* this is used in ResultSetMetaData.getPrecision
0:                                  * undefined for datetime types
0:                                  */
0:                                 maxMaxWidth = -1;
0:                                 isDateTimeTimeStampTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.TINYINT_TYPE_ID:
0:                                 maxPrecision = TypeId.TINYINT_PRECISION;
0:                                 maxScale = TypeId.TINYINT_SCALE;
0:                                 typePrecedence = TINYINT_PRECEDENCE;
0:                                 javaTypeName = "java.lang.Integer";
0:                                 maxMaxWidth = TypeId.TINYINT_MAXWIDTH;
0:                                 isNumericTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
0:                                 if (baseTypeId != null)
0:                                 {
0:                                         setUserTypeIdInfo();
0:                                 }
0:                                 else
0:                                 {
0:                                         typePrecedence = USER_PRECEDENCE;
0:                                 }
0:                                 maxMaxWidth = -1;
0:                                 isBuiltIn = false;
0:                                 isUserDefinedTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.VARBIT_TYPE_ID:
0:                                 typePrecedence = VARBIT_PRECEDENCE;
0:                                 javaTypeName = "byte[]";
0:                                 maxMaxWidth = TypeId.VARBIT_MAXWIDTH;
0:                                 isBitTypeId = true;
0:                                 isConcatableTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.BLOB_TYPE_ID:
0:                                 typePrecedence = BLOB_PRECEDENCE;
0:                                 // no java type name, can't be used as java object
0:                                 javaTypeName = "byte[]"; 
0:                                 //javaTypeName = "java.sql.Blob";  // doesn't work w casting
0:                                 maxMaxWidth = TypeId.BLOB_MAXWIDTH;
0:                                 isBitTypeId = true;
0:                                 isConcatableTypeId = true;
0:                                 isLongConcatableTypeId = true; // ??
0:                                 isLOBTypeId = true;
0:                                 break;
0: 
0:                         case StoredFormatIds.VARCHAR_TYPE_ID:
0:                                 typePrecedence = VARCHAR_PRECEDENCE;
0:                                 javaTypeName = "java.lang.String";
0:                                 maxMaxWidth = TypeId.VARCHAR_MAXWIDTH;
0:                                 isStringTypeId = true;
0:                                 isConcatableTypeId = true;
0:                                 break;
0: 
0:                       case StoredFormatIds.CLOB_TYPE_ID:
0:                               typePrecedence = CLOB_PRECEDENCE;
0:                               // no java type name, can't be used as java object
0:                               javaTypeName = "java.lang.String";
0:                               //javaTypeName = "java.sql.Clob"; // doesn't work w casting
0:                               maxMaxWidth = TypeId.CLOB_MAXWIDTH;
0:                               isStringTypeId = true;
0:                               isConcatableTypeId = true;
0:                               isLongConcatableTypeId = true; // ??
0:                               isLOBTypeId = true;
0:                               break;
0: 
0:                       case StoredFormatIds.NCLOB_TYPE_ID:
0:                               typePrecedence = NCLOB_PRECEDENCE;
0:                               // no java type name, can't be used as java object
0:                               javaTypeName = "java.lang.String"; 
0:                               //javaTypeName = "java.sql.Clob";  // doesn't work w casting
0:                               maxMaxWidth = TypeId.NCLOB_MAXWIDTH;
0:                               isStringTypeId = true;
0:                               isConcatableTypeId = true;
0:                               isLongConcatableTypeId = true; // ??
0:                               isLOBTypeId = true;
0:                               break;
0: 
0:                 }
0:         }
0:         /**
0:          * JDBC has its own idea of type identifiers which is different from
0:          * the Cloudscape internal type ids.  The JDBC type ids are defined
0:          * as public final static ints in java.sql.Types.  This method translates
0:          * a Cloudscape internal TypeId to a JDBC type id. For java objects this
0:          * returns JAVA_OBJECT in Java2 and OTHER in JDK 1.1. For Boolean datatypes,
0:          * this returns Type.BOOLEAN in JDK1.4 and Type.BIT for jdks prior to 1.4
0:          *
0:          * @return      The JDBC type Id for this type
0:          */
0:         public final int getJDBCTypeId()
0:         {
0:                 return baseTypeId.getJDBCTypeId();
0:         }
0:         /**
0:          * Returns the SQL name of the datatype. If it is a user-defined type,
0:          * it returns the full Java path name for the datatype, meaning the
0:          * dot-separated path including the package names.
0:          *
0:          * @return      A String containing the SQL name of this type.
0:          */
0:         public String   getSQLTypeName()
0:         {
0:                 return baseTypeId.getSQLTypeName();
0:         }
0: 
0:         /**
0:          * Tell whether this is a built-in type.
0:          * NOTE: There are 3 "classes" of types:
0:          *                      built-in                - system provided types which are implemented internally
0:          *                                                        (int, smallint, etc.)
0:          *                      system built-in - system provided types, independent of implementation
0:          *                                                        (date, time, etc.)
0:          *                      user types              - types implemented outside of the system
0:          *                                                        (java.lang.Integer, asdf.asdf.asdf, etc.)
0:          *
0:          * @return      true for built-in types, false for user-defined types.
0:          */
0:         public final boolean systemBuiltIn()
0:         {
0:                 return baseTypeId.systemBuiltIn();
0:         }
0: 
0:         /**
0:          * Tell whether this is a built-in type.
0:          * NOTE: There are 3 "classes" of types:
0:          *                      built-in                - system provided types which are implemented internally
0:          *                                                        (int, smallint, etc.)
0:          *                      system built-in - system provided types, independent of implementation
0:          *                                                        (date, time, etc.)
0:          *                      user types              - types implemented outside of the system
0:          *                                                        (java.lang.Integer, asdf.asdf.asdf, etc.)
0:          *
0:          * @return      true for built-in types, false for user-defined types.
0:          */
0:         public final boolean userType()
0:         {
0:                 return baseTypeId.userType();
0:         }
0: 
0:         /**
0:          * Get the maximum precision of the type.  For types with variable
0:          * precision, this is an arbitrary high precision.
0:          *
0:          * @return      The maximum precision of the type
0:          */
0:         public int getMaximumPrecision()
0:         {
0:                 return maxPrecision;
0:         }
0: 
0:         /**
0:          * Get the maximum scale of the type.  For types with variable scale,
0:          * this is an arbitrary high scale.
0:          *
0:          * @return      The maximum scale of the type
0:          */
0:         public int getMaximumScale()
0:         {
0:                 return maxScale;
0:         }
0: 
0:         /**
0:          * Set the nested BaseTypeId in this TypeId.
0:          */
0:         public void setNestedTypeId(BaseTypeIdImpl typeId)
0:         {
0:                 baseTypeId = typeId;
0:                 switch (formatId)
0:                 {
0:                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
0:                                 setUserTypeIdInfo();
0:                 }
0:         }
0: 
0:         private void setUserTypeIdInfo()
0:         {
0:                 UserDefinedTypeIdImpl baseUserTypeId =
0:                                                         (UserDefinedTypeIdImpl) baseTypeId;
0:                 typePrecedence = USER_PRECEDENCE;
0:                 javaTypeName = baseUserTypeId.getClassName();
0:         }
0: 
0:         /**
0:          * For user types, tell whether or not the class name was a
0:          * delimited identifier. For all other types, return false.
0:          *
0:          * @return Whether or not the class name was a delimited identifier.
0:          */
0:         public boolean getClassNameWasDelimitedIdentifier()
0:         {
0:                 return classNameWasDelimitedIdentifier;
0:         }
0: 
0:         /**
0:          * Does this TypeId represent a TypeId for a StringDataType.
0:          *
0:          * @return Whether or not this TypeId represents a TypeId for a StringDataType.
0:          */
0:         public boolean isStringTypeId()
0:         {
0:                 return isStringTypeId;
0:         }
0: 
0: 		/**
0: 		 * Is this a TypeId for DATE/TIME/TIMESTAMP
0: 		 *
0: 		 * @return true if this is a DATE/TIME/TIMESTAMP
0: 		 */
0: 		public boolean isDateTimeTimeStampTypeId()
0: 		{
0: 				return isDateTimeTimeStampTypeId;
0: 		}
0: 
0: 		/**
0: 		 * Is this a TypeId for REAL
0: 		 *
0: 		 * @return true if this is a REAL
0: 		 */
0: 		public boolean isRealTypeId()
0: 		{
0: 				return isRealTypeId;
0: 		}
0: 
0: 		/**
0: 		 * Is this a TypeId for floating point (REAL/DOUBLE)
0: 		 *
0: 		 * @return true if this is a REAL or DOUBLE
0: 		 */
0: 		public boolean isFloatingPointTypeId()
0: 		{
0: 				return isFloatingPointTypeId;
0: 		}
0: 		
0: 		/**
0: 		 * Is this a TypeId for DOUBLE
0: 		 *
0: 		 * @return true if this is a DOUBLE
0: 		 */
0: 		public boolean isDoubleTypeId()
0: 		{
0: 				return isFloatingPointTypeId && (! isRealTypeId);
0: 		}
0: 	
0: 		/**
0: 		 * Is this a fixed string type?
0: 		 * @return true if this is CHAR or NCHAR
0: 		 */
0: 		public boolean isFixedStringTypeId()
0: 		{
0: 				return ((formatId == StoredFormatIds.CHAR_TYPE_ID)||
0: 						(formatId == StoredFormatIds.NATIONAL_CHAR_TYPE_ID));
0: 		}
0: 
0: 		/** 
0: 		 *Is this a Clob?
0: 		 * @return true if this is CLOB or NCLOB
0: 		 */
0: 		public boolean isClobTypeId()
0: 		{
0: 			   return ((formatId == StoredFormatIds.CLOB_TYPE_ID)||
0: 					   (formatId == StoredFormatIds.NCLOB_TYPE_ID));
0: 		}
0: 
0: 		/** 
0: 		 *Is this a Blob?
0: 		 * @return true if this is BLOB
0: 		 */
0: 		public boolean isBlobTypeId()
0: 		{
0: 				return ((formatId == StoredFormatIds.BLOB_TYPE_ID));
0: 		}
0: 
0: 	
0: 		/** 
0: 		 *Is this a LongVarchar?
0: 		 * @return true if this is LongVarchar
0: 		 */
0: 		public boolean isLongVarcharTypeId()
0: 		{
0: 				return ((formatId == StoredFormatIds.LONGVARCHAR_TYPE_ID) ||
0: 						(formatId == StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID));
0: 		}
0: 
0: 
0: 		/** 
0: 		 * Is this DATE/TIME or TIMESTAMP?
0: 		 *
0: 		 * @return true if this DATE/TIME or TIMESTAMP
0: 		 */
0: 		public boolean isDateTimeTimeStampTypeID()
0: 		{
0: 				return ((formatId == StoredFormatIds.DATE_TYPE_ID) ||
0: 						(formatId == StoredFormatIds.TIME_TYPE_ID) ||
0: 						(formatId == StoredFormatIds.TIMESTAMP_TYPE_ID));
0: 		}
0: 
0:         /**
0:                 Does this type id represent a national character string.
0:                 If this returns true then isStringTypeId will also return true.
0:         */
0:         public boolean isNationalStringTypeId()
0:         {
0:                 switch (formatId)
0:                 {
0:                         default:
0:                                 return false;
0: 
0:                         case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0:                         case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID:
0:                         case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
0:                         case StoredFormatIds.NCLOB_TYPE_ID:
0:                                 return true;
0: 
0:                 }
0:         }
0: 
0:         /**
0:          * Tell whether this is a built-in type.
0:          * NOTE: There are 3 "classes" of types:
0:          *                      built-in                - system provided types which are implemented internally
0:          *                                                        (int, smallint, etc.)
0:          *                      system built-in - system provided types, independent of implementation
0:          *                                                        (date, time, etc.)
0:          *                      user types              - types implemented outside of the system
0:          *                                                        (java.lang.Integer, asdf.asdf.asdf, etc.)
0:          *
0:          * @return      true for built-in types, false for user-defined types.
0:          */
0:         public boolean builtIn()
0:         {
0:                 return isBuiltIn;
0:         }
0: 
0:         /**
0:          * Tell whether this type is orderable, that is, can participate
0:          * in comparisons.
0:          *
0:          * @param cf    A ClassFactory
0:          *
0:          * @return      true for orderable types, false for non-orderable types.
0:          */
0:         public boolean orderable(ClassFactory cf)
0:         {
0:                 boolean orderable;
0:                 switch (formatId)
0:                 {
0:                         // cmp not allowed, indexing not allowed
0:                         case StoredFormatIds.BLOB_TYPE_ID:
0:                         case StoredFormatIds.CLOB_TYPE_ID:
0:                         case StoredFormatIds.NCLOB_TYPE_ID:
0:                         case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID:
0:                         case StoredFormatIds.LONGVARCHAR_TYPE_ID:
0:                                 return false;
0: 
0:                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
0:                                 /* Is this type orderable? */
0: 
0:                                 // For user java classes we are orderable if we
0:                                 // implement java.lang.Orderable (JDK1.2) or
0:                                 // have a int compareTo(Object) method (JDK1.1 or JDK1.2)
0:                                 UserDefinedTypeIdImpl baseUserTypeId =
0:                                                                                 (UserDefinedTypeIdImpl) baseTypeId;
0: 
0:                                 String className = baseUserTypeId.getClassName();
0: 
0:                                 try 
0:                                 {
0:                                         Class c = cf.getClassInspector().getClass(className);
0:                                         orderable = java.lang.Comparable.class.isAssignableFrom(c);
0:                                 } 
0:                                 catch (ClassNotFoundException cnfe) 
0:                                 {
0:                                         orderable = false;
0:                                 } 
0:                                 catch (LinkageError le) 
0:                                 {
0:                                         orderable = false;
0:                                 }
0:                                 break;
0: 
0:                         default:
0:                                 orderable = true;
0:                 }
0: 
0:                 return orderable;
0:         }
0: 
0:         /**
0:          * Each built-in type in JSQL has a precedence.  This precedence determines
0:          * how to do type promotion when using binary operators.  For example, float
0:          * has a higher precedence than int, so when adding an int to a float, the
0:          * result type is float.
0:          *
0:          * The precedence for some types is arbitrary.  For example, it doesn't
0:          * matter what the precedence of the boolean type is, since it can't be
0:          * mixed with other types.  But the precedence for the number types is
0:          * critical.  The SQL standard requires that exact numeric types be
0:          * promoted to approximate numeric when one operator uses both.  Also,
0:          * the precedence is arranged so that one will not lose precision when
0:          * promoting a type.
0:          * NOTE: char, varchar, and longvarchar must appear at the bottom of
0:          * the hierarchy, but above USER_PRECEDENCE, since we allow the implicit
0:          * conversion of those types to any other built-in system type.
0:          *
0:          * @return              The precedence of this type.
0:          */
0:         public int typePrecedence()
0:         {
0:                 return typePrecedence;
0:         }
0: 
0:          /**
0:          * Get the name of the corresponding Java type.
0:          *
0:          * Each SQL type has a corresponding Java type.  When a SQL value is
0:          * passed to a Java method, it is translated to its corresponding Java
0:          * type.  For example, when a SQL date column is passed to a method,
0:          * it is translated to a java.sql.Date.
0:          *
0:          * @return      The name of the corresponding Java type.
0:          */
0:         public String getCorrespondingJavaTypeName()
0:         {
0:                 if (SanityManager.DEBUG)
0:                 {
0:                         if (formatId == StoredFormatIds.REF_TYPE_ID)
0:                         {
0:                                 SanityManager.THROWASSERT("getCorrespondingJavaTypeName not implemented for StoredFormatIds.REF_TYPE_ID");
0:                         }
0:                         SanityManager.ASSERT(javaTypeName != null,
0:                                 "javaTypeName expected to be non-null");
0:                 }
0:                 return javaTypeName;
0:         }
0: 
0:          /**
0:          * Get the name of the corresponding Java type.
0:          *
0:          * This method is used directly from EmbedResultSetMetaData (jdbc)
0:          * to return the corresponding type (as choosen by getObject).
0:          * It solves a specific problem for BLOB types where the 
0:          * getCorrespondingJavaTypeName() is used internall for casting
0:          * which doesn't work if changed from byte[] to java.sql.Blob.
0:          * So we do it here instread, to avoid unexpected sideeffects.
0:          *
0:          * @return      The name of the corresponding Java type.
0:          */
0:         public String getResultSetMetaDataTypeName()
0:         {
0:             if (BLOB_ID == this)
0:                 return "java.sql.Blob";
0:             if (CLOB_ID == this)
0:                 return "java.sql.Clob";
0:             if (NCLOB_ID == this)
0:                 return "java.sql.Clob";
0:             return getCorrespondingJavaTypeName();
0:         }
0: 
0:         /**
0:          * Get the maximum maximum width of the type (that's not a typo).  For
0:          * types with variable length, this is the absolute maximum for the type.
0:          *
0:          * @return      The maximum maximum width of the type
0:          */
0:         public int getMaximumMaximumWidth()
0:         {
0:                 return maxMaxWidth;
0:         }
0: 
0:         /**
0:          * Converts this TypeId, given a data type descriptor (including length/precision),
0:          * to a string. E.g.
0:          *
0:          *                      VARCHAR(30)
0:          *
0:          *
0:          *      For most data types, we just return the SQL type name.
0:          *
0:          *      @param  dts     Data type descriptor that holds the length/precision etc. as necessary
0:          *
0:          *       @return        String version of datatype, suitable for running through
0:          *                      the Parser.
0:          */
0:         public String   toParsableString(DataTypeDescriptor dts)
0:         {
0:                 return  baseTypeId.toParsableString(dts);
0:         }
0: 
0:         /**
0:          * Is this a type id for a numeric type?
0:          *
0:          * @return Whether or not this a type id for a numeric type.
0:          */
0:         public boolean isNumericTypeId()
0:         {
0:                 return isNumericTypeId;
0:         }
0: 
0:         /**
0:          * Is this a type id for a decimal type?
0:          *
0:          * @return Whether or not this a type id for a decimal type.
0:          */
0:         public boolean isDecimalTypeId()
0:         {
0:                 return isDecimalTypeId;
0:         }
0: 
0: 
0:         /**
0:          * Is this a type id for a boolean type?
0:          *
0:          * @return Whether or not this a type id for a boolean type.
0:          */
0:         public boolean isBooleanTypeId()
0:         {
0:                 return isBooleanTypeId;
0:         }
0: 
0:         /**
0:          * Is this a type id for a ref type?
0:          *
0:          * @return Whether or not this a type id for a ref type.
0:          */
0:         public boolean isRefTypeId()
0:         {
0:                 return isRefTypeId;
0:         }
0: 
0:         /**
0:          * Is this a type id for a concatable type?
0:          *
0:          * @return Whether or not this a type id for a concatable type.
0:          */
0:         public boolean isConcatableTypeId()
0:         {
0:                 return isConcatableTypeId;
0:         }
0: 
0:         /**
0:          * Is this a type id for a bit type?
0:          *
0:          * @return Whether or not this a type id for a bit type.
0:          */
0:         public boolean isBitTypeId()
0:         {
0:                 return isBitTypeId;
0:         }
0: 
0:         /**
0:          * Is this a type id for a LOB type?
0:          *
0:          * @return Whether or not this a type id for a LOB type.
0:          */
0:         public boolean isLOBTypeId()
0:         {
0:                 return isLOBTypeId;
0:         }
0: 
0: 
0:         /**
0:          * Is this a type id for a long concatable type?
0:          *
0:          * @return Whether or not this a type id for a long concatable type.
0:          */
0:         public boolean isLongConcatableTypeId()
0:         {
0:                 return isLongConcatableTypeId;
0:         }
0: 
0:         /**
0:          * Is this a type id for a user defined type?
0:          *
0:          * @return Whether or not this a type id for a user defined type.
0:          */
0:         public boolean isUserDefinedTypeId()
0:         {
0:                 return isUserDefinedTypeId;
0:         }
0: 
0:         // Formatable interface
0: 
0:         /**
0:          * Read this object from a stream of stored objects.
0:          *
0:          * @param in read this.
0:          *
0:          * @exception IOException                                       thrown on error
0:          * @exception ClassNotFoundException            thrown on error
0:          */
0:         public void readExternal( ObjectInput in )
0:                  throws IOException, ClassNotFoundException
0:         {
0:                 baseTypeId = (BaseTypeIdImpl) in.readObject();
0:                 /* We need to set the type specific variables
0:                  * for user types when reading back off of the
0:                  * disk becuse the baseTypeId was null when the
0:                  * 0 argument constructor was called.
0:                  */
0:                 switch (formatId)
0:                 {
0:                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
0:                                 setTypeIdSpecificInstanceVariables();
0:                 }
0:         }
0: 
0:         /**
0:          * Write this object to a stream of stored objects.
0:          *
0:          * @param out write bytes here.
0:          *
0:          * @exception IOException               thrown on error
0:          */
0:         public void writeExternal( ObjectOutput out )
0:                  throws IOException
0:         {
0:                 out.writeObject( baseTypeId );
0:         }
0: 
0:         /**
0:          * Get the formatID which corresponds to this class.
0:          *
0:          *      @return the formatID of this class
0:          */
0:         public  int     getTypeFormatId()       
0:         { 
0:                 return formatId; 
0:         }
0: 
0: 
0:         /** 
0:          *  Get SQL null value.
0:          *  @return SQL null value for this type.
0:          */
0:         public DataValueDescriptor getNull()
0:         {
0:                 switch (formatId)
0:                 {
0:                         case StoredFormatIds.BIT_TYPE_ID:
0:                                 return new SQLBit();
0: 
0:                         case StoredFormatIds.BOOLEAN_TYPE_ID:
0:                                 return new SQLBoolean();
0: 
0:                         case StoredFormatIds.CHAR_TYPE_ID:
0:                                 return new SQLChar();
0: 
0:                         case StoredFormatIds.DECIMAL_TYPE_ID:
0:                                 return new SQLDecimal();
0: 
0:                         case StoredFormatIds.DOUBLE_TYPE_ID:
0:                                 return new SQLDouble();
0: 
0:                         case StoredFormatIds.INT_TYPE_ID:
0:                                 return new SQLInteger();
0: 
0:                         case StoredFormatIds.LONGINT_TYPE_ID:
0:                                 return new SQLLongint();
0: 
0:                         case StoredFormatIds.LONGVARBIT_TYPE_ID:
0:                                 return new SQLLongVarbit();
0: 
0:                         case StoredFormatIds.BLOB_TYPE_ID:
0:                                 return new SQLBlob();
0: 
0:                         case StoredFormatIds.CLOB_TYPE_ID:
0:                                 return new SQLClob();
0: 
0:                         case StoredFormatIds.NCLOB_TYPE_ID:
0:                                 return new SQLNClob();
0: 
0:                         case StoredFormatIds.LONGVARCHAR_TYPE_ID:
0:                                 return new SQLLongvarchar();
0: 
0:                         case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0:                                 return new SQLNationalChar();
0: 
0:                         case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
0:                                 return new SQLNationalVarchar();
0: 
0:                         case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID:
0:                                 return new SQLNationalLongvarchar();
0: 
0:                         case StoredFormatIds.REAL_TYPE_ID:
0:                                 return new SQLReal();
0: 
0:                         case StoredFormatIds.REF_TYPE_ID:
0:                                 return new SQLRef();
0: 
0:                         case StoredFormatIds.SMALLINT_TYPE_ID:
0:                                 return new SQLSmallint();
0: 
0:                         case StoredFormatIds.TINYINT_TYPE_ID:
0:                                 return new SQLTinyint();
0: 
0:                         case StoredFormatIds.DATE_TYPE_ID:
0:                                 return new SQLDate();
0: 
0:                         case StoredFormatIds.TIME_TYPE_ID:
0:                                 return new SQLTime();
0: 
0:                         case StoredFormatIds.TIMESTAMP_TYPE_ID:
0:                                 return new SQLTimestamp();
0: 
0:                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
0:                                 return new UserType();
0: 
0:                         case StoredFormatIds.VARBIT_TYPE_ID:
0:                                 return new SQLVarbit();
0: 
0:                         case StoredFormatIds.VARCHAR_TYPE_ID:
0:                                 return new SQLVarchar();
0: 
0:                         default:
0:                                 if (SanityManager.DEBUG)
0:                                 {
0:                                         SanityManager.THROWASSERT(
0:                                                 "unexpected formatId in getNull() - " + formatId);
0:                                 }
0:                                 return null;
0:                 }
0:         }
0:         /**
0:          * Is this type StreamStorable?
0:          *
0:          * @return      true if this type has variable length.
0:          */
0:         public boolean  streamStorable() {
0:                 return isStringTypeId() || isBitTypeId();
0:         }
0: 
0: 
0:         //
0:         //      Class methods
0:         //
0: 
0:         /**
0:          * Get the approximate length of this type in bytes.
0:          * For most datatypes this is just going to be
0:          * dts.getMaximumWidth().  Some types, such as
0:          * bit, will override this.
0:          *
0:          * @param dts Data type descriptor that holds the 
0:          *              length/precision etc. as necessary
0:          *
0:          * @return the length in bytes
0:          */
0:         public int getApproximateLengthInBytes(DataTypeDescriptor dts)
0:         {
0:                 switch (formatId)
0:                 {
0:                         case StoredFormatIds.BIT_TYPE_ID:
0:                                 return (int)(Math.ceil(dts.getMaximumWidth()/8d));
0: 
0:                         case StoredFormatIds.CHAR_TYPE_ID:
0:                         case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0:                                 return (2 * dts.getMaximumWidth()) + 2;
0: 
0:                         case StoredFormatIds.DECIMAL_TYPE_ID:
0:                                 // Return 200 if precision is max int
0:                                 if (dts.getPrecision() == Integer.MAX_VALUE)
0:                                 {
0:                                         return 200;
0:                                 }
0:                                 else
0:                                 {
0:                                         return 8 + (int) (Math.ceil(((double)dts.getPrecision())/2d));
0:                                 }
0: 
0:                         case StoredFormatIds.LONGVARBIT_TYPE_ID:
0:                         case StoredFormatIds.BLOB_TYPE_ID:
0:                         case StoredFormatIds.CLOB_TYPE_ID:
0:                         case StoredFormatIds.NCLOB_TYPE_ID:
0:                                 return 10240;
0: 
0:                         case StoredFormatIds.REF_TYPE_ID:
0:                                 return 16;
0: 
0:                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
0:                                 /* For user types we'll guess on the high side
0:                                 ** (200) to avoid being too low in most cases.
0:                                 */
0:                                 return 200;
0: 
0:                         case StoredFormatIds.VARBIT_TYPE_ID:
0:                                 // Return 200 if maximum width is max int
0:                                 if (dts.getMaximumWidth() == Integer.MAX_VALUE)
0:                                 {
0:                                         return 200;
0:                                 }
0:                                 else
0:                                 {
0:                                         return (int)(Math.ceil(dts.getMaximumWidth()/8d));
0:                                 }
0: 
0:                         case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
0:                         case StoredFormatIds.VARCHAR_TYPE_ID:
0:                         case StoredFormatIds.LONGVARCHAR_TYPE_ID:
0:                         case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID:
0:                                 // Return 200 if maximum width is max int
0:                                 if (dts.getMaximumWidth() == Integer.MAX_VALUE)
0:                                 {
0:                                         return 200;
0:                                 }
0:                                 else
0:                                 {
0:                                         return (dts.getMaximumWidth() * 2) + 2;
0:                                 }
0:                         /*
0:                         ** For Date/time we know the exact size
0:                         ** thanks to some investigative work by
0:                         ** someone or other (sad isn't it).  
0:                         */
0:                         case StoredFormatIds.DATE_TYPE_ID:
0:                                 return 18;
0:                         case StoredFormatIds.TIME_TYPE_ID:
0:                                 return 16;
0:                         case StoredFormatIds.TIMESTAMP_TYPE_ID:
0:                                 return 29;
0: 
0:                         default:
0:                                 return dts.getMaximumWidth();
0:                 }
0:         }
0: 
0:         /**
0:          * Get the base type id that is embedded in this type id.  The base type
0:          * id is an object with a minimal implementation of TypeId that is intended
0:          * to be usable on the client side.
0:          */
0:         public BaseTypeIdImpl getBaseTypeId()
0:         {
0:                 return baseTypeId;
0:         }
0: 
0:         /**
0:          * Get the precision of the merge of two Decimals
0:          *
0:          * @param leftType the left type
0:          * @param rightType the left type
0:          *
0:          * @return      the resultant precision
0:          */
0:         public int getPrecision(DataTypeDescriptor leftType,
0:                                         DataTypeDescriptor rightType)
0:         {
0:                 if (SanityManager.DEBUG)
0:                 {
0:                         if (formatId != StoredFormatIds.DECIMAL_TYPE_ID)
0:                         {
0:                                 SanityManager.THROWASSERT(
0:                                         "getPrecision() not expected to be called for formatId - " + formatId);
0:                         }
0:                 }
0:                 long lscale = (long)leftType.getScale();
0:                 long rscale = (long)rightType.getScale();
0:                 long lprec = (long)leftType.getPrecision();
0:                 long rprec = (long)rightType.getPrecision();
0:                 long val;
0: 
0:                 /*
0:                 ** Take the maximum left of decimal digits plus the scale.
0:                 */
0:                 val = this.getScale(leftType, rightType) +
0:                                         Math.max(lprec - lscale, rprec - rscale);
0: 
0:                 if (val > Integer.MAX_VALUE)
0:                 {
0:                         val = Integer.MAX_VALUE;
0:                 }
0:                 return (int)val;
0:         }
0: 
0:         /**
0:          * Get the scale of the merge of two decimals
0:          *
0:          * @param leftType the left type
0:          * @param rightType the left type
0:          *
0:          * @return      the resultant precision
0:          */
0:         public int getScale(DataTypeDescriptor leftType,
0:                                                 DataTypeDescriptor rightType)
0:         {
0:                 if (SanityManager.DEBUG)
0:                 {
0:                         if (formatId != StoredFormatIds.DECIMAL_TYPE_ID)
0:                         {
0:                                 SanityManager.THROWASSERT(
0:                                         "getPrecision() not expected to be called for formatId - " + formatId);
0:                         }
0:                 }
0:                 /*
0:                 ** Retain greatest scale
0:                 */
0:                 return Math.max(leftType.getScale(), rightType.getScale());
0:         }
0: 
0:         /**
0:          * Is type variable length
0:          * @return boolean true if type is variable length false if not.  
0:          */
0:         public boolean variableLength()
0:         {
0:                 switch (formatId)
0:                 {
0:                         case StoredFormatIds.BIT_TYPE_ID:
0:                         case StoredFormatIds.VARBIT_TYPE_ID:
0:                         case StoredFormatIds.DECIMAL_TYPE_ID:
0:                         case StoredFormatIds.CHAR_TYPE_ID:
0:                         case StoredFormatIds.VARCHAR_TYPE_ID:
0:                         case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0:                         case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
0:                         case StoredFormatIds.BLOB_TYPE_ID:
0: // none of the LONG_VARCHAR types are true here...????
0: //                        case StoredFormatIds.CLOB_TYPE_ID:
0: //                        case StoredFormatIds.NCLOB_TYPE_ID:
0:                                 return true;
0: 
0:                         default:
0:                                 return false;
0:                 }
0:         }
0: }
0: 
============================================================================