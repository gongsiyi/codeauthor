1:f6c58c8: /*
1:f6c58c8: 
1:f6c58c8:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.LobRsGetterTest
1:f6c58c8: 
1:f6c58c8:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6c58c8:    contributor license agreements.  See the NOTICE file distributed with
1:f6c58c8:    this work for additional information regarding copyright ownership.
1:f6c58c8:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6c58c8:    (the "License"); you may not use this file except in compliance with
1:f6c58c8:    the License.  You may obtain a copy of the License at
1:f6c58c8: 
1:f6c58c8:       http://www.apache.org/licenses/LICENSE-2.0
1:f6c58c8: 
1:f6c58c8:    Unless required by applicable law or agreed to in writing, software
1:f6c58c8:    distributed under the License is distributed on an "AS IS" BASIS,
1:f6c58c8:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f6c58c8:    See the License for the specific language governing permissions and
1:f6c58c8:    limitations under the License.
1:f6c58c8: 
1:f6c58c8:  */
1:f6c58c8: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:f6c58c8: 
1:bde7b3b: import java.io.IOException;
1:bde7b3b: import java.sql.Blob;
1:bde7b3b: import java.sql.Clob;
1:f6c58c8: import java.sql.Connection;
1:f6c58c8: import java.sql.PreparedStatement;
1:f6c58c8: import java.sql.ResultSet;
1:f6c58c8: import java.sql.ResultSetMetaData;
1:f6c58c8: import java.sql.SQLException;
1:f6c58c8: import java.sql.Statement;
1:f6c58c8: import java.sql.Types;
1:bde7b3b: import java.util.Arrays;
1:f6c58c8: 
1:f6c58c8: import junit.framework.Test;
1:f6c58c8: 
1:f6c58c8: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:f6c58c8: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1:f6c58c8: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:f6c58c8: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:f6c58c8: import org.apache.derbyTesting.junit.JDBC;
1:f6c58c8: import org.apache.derbyTesting.junit.TestConfiguration;
1:f6c58c8: 
1:f6c58c8: /**
1:f6c58c8:  * Tests restrictions and special conditions that apply when calling result set
1:f6c58c8:  * getters on LOB columns.
1:f6c58c8:  * <p>
1:f6c58c8:  * Some relevant JIRAs:
1:f6c58c8:  * <ul> <li>
1:f6c58c8:  * <a href="https://issues.apache.org/jira/browse/DERBY-3844">DERBY-3844</a>
1:f6c58c8:  *      : has references to other JIRAs and some discussion</li>
1:f6c58c8:  *      <li>
1:f6c58c8:  * <a href="https://issues.apache.org/jira/browse/DERBY-5489">DERBY-5489</a>
1:f6c58c8:  *      : triggered the writing of this test and the following cleanup</li>
1:f6c58c8:  * </ul>
1:f6c58c8:  */
1:f6c58c8: public class LobRsGetterTest
1:f6c58c8:     extends BaseJDBCTestCase {
1:f6c58c8: 
1:f6c58c8:     private static final String TABLE = "LOB_RS_GETTER_TEST";
1:f6c58c8:     private static final boolean UNSUPPORTED = false;
1:f6c58c8:     private static final boolean SUPPORTED = true;
1:f6c58c8: 
1:f6c58c8:     private static final int BLOB = 0;
1:f6c58c8:     private static final int CLOB = 1;
1:f6c58c8: 
1:f6c58c8:     private static final int GET_BYTES = 0;
1:f6c58c8:     private static final int GET_STRING = 1;
1:f6c58c8:     private static final int GET_ASCII_STREAM = 2;
1:f6c58c8:     private static final int GET_BINARY_STREAM = 3;
1:f6c58c8:     private static final int GET_CHARACTER_STREAM = 4;
1:f6c58c8:     private static final int GET_CLOB = 5;
1:f6c58c8:     private static final int GET_BLOB = 6;
1:f6c58c8:     private static final int GET_OBJECT = 7;
1:f6c58c8: 
1:f6c58c8:     private static final boolean X = SUPPORTED;
1:f6c58c8:     /** Supported, but not marked as valid by the JDBC spec. */
1:f6c58c8:     private static final boolean E = SUPPORTED; // visual que in table only
1:ca48ab4:     private static final boolean u = UNSUPPORTED;
1:f6c58c8: 
1:f6c58c8:     /**
1:f6c58c8:      * Lists the compatible getters for {@literal BLOB} and {@literal CLOB}.
1:f6c58c8:      * <p>
1:f6c58c8:      * Note that the getters {@code getNCharacterStream}, {@code getNString}
1:f6c58c8:      * and {@code getNClob} aren't tested. They're not supported by Derby.
1:f6c58c8:      * <p>
1:f6c58c8:      * For notes on behavior when invoking the various character getters on
1:f6c58c8:      * binary columns, see
1:f6c58c8:      * <a href="http://db.apache.org/derby/papers/JDBCImplementation.html">
1:f6c58c8:      * JDBCImplementation.html</a>.
1:f6c58c8:      */
1:f6c58c8:     private static final boolean[][] COMPATIBLE_GETTERS = new boolean[][] {
1:f6c58c8:                                 /*   B  C */
1:f6c58c8:                                 /*   L  L */
1:f6c58c8:                                 /*   O  O */
1:f6c58c8:                                 /*   B  B */
1:ca48ab4:         /* getBytes             */ { X, u },
1:f6c58c8:         /* getString            */ { E, X },
1:f6c58c8:         /* getAsciiStream       */ { E, X },
1:ca48ab4:         /* getBinaryStream      */ { X, u },
1:f6c58c8:         /* getCharacterStream   */ { E, X },
1:ca48ab4:         /* getClob              */ { u, X },
1:ca48ab4:         /* getBlob              */ { X, u },
1:f6c58c8:         /* getObject            */ { X, X },
1:f6c58c8:     };
1:f6c58c8: 
1:bde7b3b:     /**
1:bde7b3b:      * The names of the various getters used in this test.
1:bde7b3b:      * <p>
1:bde7b3b:      * The positions/indexes must correspond to those in
1:bde7b3b:      * {@linkplain #COMPATIBLE_GETTERS}.
1:bde7b3b:      */
1:f6c58c8:     private static final String[] GETTER_NAMES = new String[] {
1:f6c58c8:         "getBytes", "getString", "getAsciiStream", "getBinaryStream",
1:f6c58c8:         "getCharacterStream", "getClob", "getBlob", "getObject"
1:f6c58c8:     };
1:f6c58c8: 
1:f6c58c8:     public LobRsGetterTest(String name) {
1:f6c58c8:         super(name);
1:f6c58c8:     }
1:f6c58c8: 
1:f6c58c8:     /** Returns a suite with all tests running with both embedded and client. */
1:f6c58c8:     public static Test suite() {
1:f6c58c8:         Test suite = TestConfiguration.defaultSuite(
1:f6c58c8:                 LobRsGetterTest.class, false);
1:f6c58c8:         return new CleanDatabaseTestSetup(suite) {
1:f6c58c8:              protected void decorateSQL(Statement s)
1:f6c58c8:                      throws SQLException {
1:f6c58c8:                  Connection con = s.getConnection();
1:f6c58c8:                  dropTable(con, TABLE);
1:f6c58c8:                  // NOTE: Do not insert a lot of data into this table, many
1:f6c58c8:                  //       of the tests iterate over all rows in the table.
1:f6c58c8:                  s.executeUpdate("create table " + TABLE + "(" +
1:f6c58c8:                          "id INT GENERATED ALWAYS AS IDENTITY, " +
1:f6c58c8:                          "dBlob BLOB, dClob CLOB)");
1:f6c58c8:                  // Insert a few rows with different characteristics:
1:f6c58c8:                  // multi page LOB, single page LOB, NULL
1:f6c58c8:                  PreparedStatement ps = con.prepareStatement(
1:f6c58c8:                          "insert into " + TABLE +
1:f6c58c8:                          "(dBlob, dClob) values (?,?)");
1:f6c58c8:                  int mpSize = 173*1024; // 173 KB or KChars
1:f6c58c8:                  int spSize = 300; // 300 B or chars
1:f6c58c8:                  ps.setBinaryStream(1,
1:f6c58c8:                          new LoopingAlphabetStream(mpSize), mpSize);
1:f6c58c8:                  ps.setCharacterStream(2,
1:f6c58c8:                          new LoopingAlphabetReader(mpSize), mpSize);
1:f6c58c8:                  ps.executeUpdate();
1:f6c58c8:                  ps.setBinaryStream(1,
1:f6c58c8:                          new LoopingAlphabetStream(spSize), spSize);
1:f6c58c8:                  ps.setCharacterStream(2,
1:f6c58c8:                          new LoopingAlphabetReader(spSize), spSize);
1:f6c58c8:                  ps.executeUpdate();
1:f6c58c8:                  ps.setNull(1, Types.BLOB);
1:f6c58c8:                  ps.setNull(2, Types.CLOB);
1:f6c58c8:                  ps.executeUpdate();
1:f6c58c8:                  // Make sure there are three rows.
1:f6c58c8:                  JDBC.assertDrainResults(
1:f6c58c8:                          s.executeQuery("select * from " + TABLE), 3);
1:f6c58c8:                  ps.close();
1:f6c58c8:                  s.close();
1:f6c58c8:              }
1:f6c58c8:         };
1:f6c58c8:     }
1:f6c58c8: 
1:bde7b3b:     /**
1:f6c58c8:      * Tests that all getters marked as supported don't throw an exception.
1:f6c58c8:      */
1:f6c58c8:     public void testBlobGettersSimple()
1:f6c58c8:             throws SQLException {
1:bde7b3b:         _testGettersSimple("dBlob", BLOB);
1:f6c58c8:     }
1:f6c58c8: 
1:f6c58c8:     /**
1:f6c58c8:      * Tests that all getters marked as supported don't throw an exception.
1:f6c58c8:      */
1:f6c58c8:     public void testClobGettersSimple()
1:f6c58c8:             throws SQLException {
1:bde7b3b:         _testGettersSimple("dClob", CLOB);
1:f6c58c8:     }
1:f6c58c8: 
1:f6c58c8:     /**
1:f6c58c8:      * Tests that all getters marked as unsupported throw an exception.
1:f6c58c8:      */
1:f6c58c8:     public void testBlobGettersSimpleNegative()
1:f6c58c8:             throws SQLException {
1:bde7b3b:         _testGettersSimpleNegative("dBlob", BLOB);
1:f6c58c8:     }
1:f6c58c8: 
1:f6c58c8:     /**
1:f6c58c8:      * Tests that all getters marked as unsupported throw an exception.
1:f6c58c8:      */
1:f6c58c8:     public void testClobGettersSimpleNegative()
1:f6c58c8:             throws SQLException {
1:bde7b3b:         _testGettersSimpleNegative("dClob", CLOB);
1:f6c58c8:     }
1:f6c58c8: 
1:f6c58c8:     /**
1:f6c58c8:      * Tests that multiple invocations of getters on the same column/row throw
1:f6c58c8:      * an exception in most cases.
1:f6c58c8:      * <p>
1:f6c58c8:      * For now {@code getBytes} and {@code getString} are behaving differently
1:f6c58c8:      * for BLOBs.
1:f6c58c8:      */
1:f6c58c8:     public void testBlobGettersMultiInvocation()
1:f6c58c8:             throws SQLException {
1:bde7b3b:         _testGettersMultiInvocation("dBlob", BLOB);
1:f6c58c8:     }
1:f6c58c8: 
1:f6c58c8:     /**
1:f6c58c8:      * Tests that multiple invocations of getters on the same column/row throw
1:f6c58c8:      * an exception in most cases.
1:f6c58c8:      * <p>
1:f6c58c8:      * For now {@code getString} is behaving differently for CLOBs.
1:f6c58c8:      */
1:f6c58c8:     public void testClobGettersMultiInvocation()
1:f6c58c8:             throws SQLException {
1:bde7b3b:         _testGettersMultiInvocation("dClob", CLOB);
1:f6c58c8:     }
1:f6c58c8: 
1:f6c58c8:     /**
1:f6c58c8:      * Tests that {@code getBytes} throws exception when invoked after any
1:f6c58c8:      * other getters than {@code getBytes} and {@code getString}.
1:f6c58c8:      */
1:f6c58c8:     public void testBlobGetXFollowedByGetBytes()
1:f6c58c8:             throws SQLException {
1:f6c58c8:         PreparedStatement ps = prepareStatement(
1:f6c58c8:                 "select dBlob from " + TABLE);
1:f6c58c8:         for (int getter=0; getter < COMPATIBLE_GETTERS.length; getter++) {
1:f6c58c8:             if (COMPATIBLE_GETTERS[getter][BLOB] == UNSUPPORTED) {
1:f6c58c8:                 continue;
1:f6c58c8:             }
1:f6c58c8:             ResultSet rs = ps.executeQuery();
1:f6c58c8:             assertTrue(rs.next());
1:f6c58c8:             invokeGetter(rs, BLOB, getter);
1:f6c58c8:             // The next call should fail unless the getter is getBytes.
1:f6c58c8:             try {
1:f6c58c8:                 invokeGetter(rs, BLOB, GET_BYTES);
1:f6c58c8:                 assertTrue("getBytes should have failed after: " +
1:f6c58c8:                         debugInfo(1, rs, BLOB, getter),
1:f6c58c8:                         getter == GET_BYTES || getter == GET_STRING);
1:f6c58c8:             } catch (SQLException sqle) {
1:f6c58c8:                 assertTrue(getter != GET_BYTES);
1:f6c58c8:                 assertSQLState(debugInfo(1, rs, BLOB, getter) +
1:f6c58c8:                         " followed by getBytes", "XCL18", sqle);
1:f6c58c8:             } finally {
1:f6c58c8:                 rs.close();
1:f6c58c8:             }
1:f6c58c8:         }
1:f6c58c8:     }
1:f6c58c8: 
1:f6c58c8:     /**
1:f6c58c8:      * Tests that {@code getString} throws exception when invoked after any
1:f6c58c8:      * other getter than {@code getString}.
1:f6c58c8:      */
1:f6c58c8:     public void testClobGetXFollowedByGetString()
1:f6c58c8:             throws SQLException {
1:f6c58c8:         PreparedStatement ps = prepareStatement(
1:f6c58c8:                 "select dClob from " + TABLE);
1:f6c58c8:         for (int getter=0; getter < COMPATIBLE_GETTERS.length; getter++) {
1:f6c58c8:             if (COMPATIBLE_GETTERS[getter][CLOB] == UNSUPPORTED) {
1:f6c58c8:                 continue;
1:f6c58c8:             }
1:f6c58c8:             ResultSet rs = ps.executeQuery();
1:f6c58c8:             assertTrue(rs.next());
1:f6c58c8:             invokeGetter(rs, CLOB, getter);
1:f6c58c8:             // The next call should fail unless the getter is getString.
1:f6c58c8:             try {
1:f6c58c8:                 invokeGetter(rs, CLOB, GET_STRING);
1:f6c58c8:                 assertTrue("getString should have failed after: " +
1:f6c58c8:                         debugInfo(1, rs, CLOB, getter),
1:f6c58c8:                         getter == GET_STRING);
1:f6c58c8:             } catch (SQLException sqle) {
1:f6c58c8:                 assertTrue(getter != GET_STRING);
1:f6c58c8:                 assertSQLState(debugInfo(1, rs, CLOB, getter) +
1:f6c58c8:                         " followed by getString", "XCL18", sqle);
1:f6c58c8:             } finally {
1:f6c58c8:                 rs.close();
1:f6c58c8:             }
1:f6c58c8:         }
1:f6c58c8:     }
1:f6c58c8: 
1:f6c58c8:     /**
1:bde7b3b:      * Tests that data returned by the last BLOB getter invokation is correct.
1:bde7b3b:      */
1:bde7b3b:     public void testCorrectBlobDataWithMultiCall()
1:bde7b3b:             throws IOException, SQLException {
1:bde7b3b:         setAutoCommit(false);
1:bde7b3b:         PreparedStatement psId = prepareStatement("select id from " + TABLE);
1:bde7b3b:         String select = "select dBlob from " + TABLE + " where id = ?";
1:bde7b3b:         PreparedStatement ps1 = prepareStatement(select);
1:bde7b3b:         PreparedStatement ps2 = prepareStatement(select);
1:bde7b3b:         ResultSet rsId = psId.executeQuery();
1:bde7b3b:         ResultSet rs1;
1:bde7b3b:         ResultSet rs2;
1:bde7b3b:         while (rsId.next()) {
1:bde7b3b:             ps1.setInt(1, rsId.getInt(1));
1:bde7b3b:             ps2.setInt(1, rsId.getInt(1));
1:bde7b3b: 
1:bde7b3b:             // getBytes - getString - getBinaryStream
1:bde7b3b:             rs1 = ps1.executeQuery();
1:bde7b3b:             assertTrue(rs1.next());
1:bde7b3b:             rs1.getBytes(1);
1:bde7b3b:             rs1.getString(1);
1:bde7b3b:             rs2 = ps2.executeQuery();
1:bde7b3b:             assertTrue(rs2.next());
1:bde7b3b:             assertEquals(rs2.getBinaryStream(1), rs1.getBinaryStream(1));
1:bde7b3b:             rs1.close();
1:bde7b3b:             rs2.close();
1:bde7b3b: 
1:bde7b3b:             // getString - getBytes - getBlob
1:bde7b3b:             rs1 = ps1.executeQuery();
1:bde7b3b:             assertTrue(rs1.next());
1:bde7b3b:             rs1.getString(1);
1:bde7b3b:             rs1.getBytes(1);
1:bde7b3b:             rs2 = ps2.executeQuery();
1:bde7b3b:             assertTrue(rs2.next());
1:bde7b3b:             assertEquals(rs2.getBlob(1), rs1.getBlob(1));
1:bde7b3b:             rs1.close();
1:bde7b3b:             rs2.close();
1:bde7b3b: 
1:bde7b3b:             // getBytes - getString - getCharacterStream
1:bde7b3b:             rs1 = ps1.executeQuery();
1:bde7b3b:             assertTrue(rs1.next());
1:bde7b3b:             rs1.getBytes(1);
1:bde7b3b:             rs1.getString(1);
1:bde7b3b:             rs2 = ps2.executeQuery();
1:bde7b3b:             assertTrue(rs2.next());
1:bde7b3b:             assertEquals(rs2.getCharacterStream(1), rs1.getCharacterStream(1));
1:bde7b3b:             rs1.close();
1:bde7b3b:             rs2.close();
1:bde7b3b: 
1:bde7b3b:             // getBytes - getString - getBytes
1:bde7b3b:             rs1 = ps1.executeQuery();
1:bde7b3b:             assertTrue(rs1.next());
1:bde7b3b:             rs1.getBytes(1);
1:bde7b3b:             rs1.getString(1);
1:bde7b3b:             rs2 = ps2.executeQuery();
1:bde7b3b:             assertTrue(rs2.next());
1:bde7b3b:             assertTrue(Arrays.equals(rs2.getBytes(1), rs1.getBytes(1)));
1:bde7b3b:             rs1.close();
1:bde7b3b:             rs2.close();
1:bde7b3b: 
1:bde7b3b:             // getBytes - getString - getString
1:bde7b3b:             rs1 = ps1.executeQuery();
1:bde7b3b:             assertTrue(rs1.next());
1:bde7b3b:             rs1.getBytes(1);
1:bde7b3b:             rs1.getString(1);
1:bde7b3b:             rs2 = ps2.executeQuery();
1:bde7b3b:             assertTrue(rs2.next());
1:bde7b3b:             assertEquals(rs2.getString(1), rs1.getString(1));
1:bde7b3b:             rs1.close();
1:bde7b3b:             rs2.close();
1:bde7b3b: 
1:bde7b3b:             // getString - getBytes - getObject
1:bde7b3b:             rs1 = ps1.executeQuery();
1:bde7b3b:             assertTrue(rs1.next());
1:bde7b3b:             rs1.getString(1);
1:bde7b3b:             rs1.getBytes(1);
1:bde7b3b:             rs2 = ps2.executeQuery();
1:bde7b3b:             assertTrue(rs2.next());
1:bde7b3b:             Blob b1 = (Blob)rs1.getObject(1);
1:bde7b3b:             Blob b2 = (Blob)rs2.getObject(1);
1:bde7b3b:             assertEquals(b2, b1);
1:bde7b3b:             rs1.close();
1:bde7b3b:             rs2.close();
1:bde7b3b: 
1:bde7b3b:             // getBytes - getString - getAsciiStream
1:bde7b3b:             rs1 = ps1.executeQuery();
1:bde7b3b:             assertTrue(rs1.next());
1:bde7b3b:             rs1.getBytes(1);
1:bde7b3b:             rs1.getString(1);
1:bde7b3b:             rs2 = ps2.executeQuery();
1:bde7b3b:             assertTrue(rs2.next());
1:bde7b3b:             assertEquals(rs2.getAsciiStream(1), rs1.getAsciiStream(1));
1:bde7b3b:             rs1.close();
1:bde7b3b:             rs2.close();
1:bde7b3b:         }
1:bde7b3b:         rollback();
1:bde7b3b:     }
1:bde7b3b: 
1:bde7b3b:     /**
1:bde7b3b:      * Tests that data returned by the last CLOB getter invokation is correct.
1:bde7b3b:      */
1:bde7b3b:     public void testCorrectClobDataWithMultiCall()
1:bde7b3b:             throws IOException, SQLException {
1:bde7b3b:         setAutoCommit(false);
1:bde7b3b:         PreparedStatement psId = prepareStatement(
1:bde7b3b:                 "select id, dClob from " + TABLE);
1:bde7b3b:         String select = "select dClob from " + TABLE + " where id = ?";
1:bde7b3b:         PreparedStatement ps1 = prepareStatement(select);
1:bde7b3b:         PreparedStatement ps2 = prepareStatement(select);
1:bde7b3b:         ResultSet rsId = psId.executeQuery();
1:bde7b3b:         ResultSet rs1;
1:bde7b3b:         ResultSet rs2;
1:bde7b3b:         while (rsId.next()) {
1:bde7b3b:             ps1.setInt(1, rsId.getInt(1));
1:bde7b3b:             ps2.setInt(1, rsId.getInt(1));
1:bde7b3b: 
1:bde7b3b:             // getString - getString
1:bde7b3b:             rs1 = ps1.executeQuery();
1:bde7b3b:             assertTrue(rs1.next());
1:bde7b3b:             rs1.getString(1);
1:bde7b3b:             rs2 = ps2.executeQuery();
1:bde7b3b:             assertTrue(rs2.next());
1:bde7b3b:             assertEquals(rs2.getString(1), rs1.getString(1));
1:bde7b3b:             rs1.close();
1:bde7b3b:             rs2.close();
1:bde7b3b: 
1:bde7b3b:             // getString - getCharacterStream
1:bde7b3b:             rs1 = ps1.executeQuery();
1:bde7b3b:             assertTrue(rs1.next());
1:bde7b3b:             rs1.getString(1);
1:bde7b3b:             rs2 = ps2.executeQuery();
1:bde7b3b:             assertTrue(rs2.next());
1:bde7b3b:             assertEquals(rs2.getCharacterStream(1), rs1.getCharacterStream(1));
1:bde7b3b:             rs1.close();
1:bde7b3b:             rs2.close();
1:bde7b3b: 
1:bde7b3b:             // getString - getClob
1:bde7b3b:             rs1 = ps1.executeQuery();
1:bde7b3b:             assertTrue(rs1.next());
1:bde7b3b:             rs1.getString(1);
1:bde7b3b:             rs2 = ps2.executeQuery();
1:bde7b3b:             assertTrue(rs2.next());
1:bde7b3b:             assertEquals(rs2.getClob(1), rs1.getClob(1));
1:bde7b3b:             rs1.close();
1:bde7b3b:             rs2.close();
1:bde7b3b: 
1:bde7b3b:             // getString - getObject
1:bde7b3b:             rs1 = ps1.executeQuery();
1:bde7b3b:             assertTrue(rs1.next());
1:bde7b3b:             rs1.getString(1);
1:bde7b3b:             rs2 = ps2.executeQuery();
1:bde7b3b:             assertTrue(rs2.next());
1:bde7b3b:             Clob b1 = (Clob)rs1.getObject(1);
1:bde7b3b:             Clob b2 = (Clob)rs2.getObject(1);
1:bde7b3b:             assertEquals(b2, b1);
1:bde7b3b:             rs1.close();
1:bde7b3b:             rs2.close();
1:bde7b3b: 
1:bde7b3b:             // getString - getAsciiStream
1:bde7b3b:             rs1 = ps1.executeQuery();
1:bde7b3b:             assertTrue(rs1.next());
1:bde7b3b:             rs1.getString(1);
1:bde7b3b:             rs2 = ps2.executeQuery();
1:bde7b3b:             assertTrue(rs2.next());
1:bde7b3b:             assertEquals(rs2.getAsciiStream(1), rs1.getAsciiStream(1));
1:bde7b3b:             rs1.close();
1:bde7b3b:             rs2.close();
1:bde7b3b:         }
1:bde7b3b:         rollback();
1:bde7b3b:     }
1:bde7b3b: 
1:bde7b3b:     private void _testGettersMultiInvocation(String columnName, int typeIdx)
1:f6c58c8:             throws SQLException {
1:f6c58c8:         PreparedStatement ps = prepareStatement(
1:f6c58c8:                 "select " + columnName + " from " + TABLE);
1:f6c58c8:         for (int getter=0; getter < COMPATIBLE_GETTERS.length; getter++) {
1:f6c58c8:             boolean supported = COMPATIBLE_GETTERS[getter][typeIdx];
1:f6c58c8:             if (!supported) {
1:f6c58c8:                 continue;
1:f6c58c8:             }
1:f6c58c8:             ResultSet rs = ps.executeQuery();
1:f6c58c8:             rs.next();
1:f6c58c8:             invokeGetter(rs, typeIdx, getter);
1:f6c58c8:             try {
1:f6c58c8:                 invokeGetter(rs, typeIdx, getter);
1:f6c58c8:                 if (getter != GET_BYTES && getter != GET_STRING) {
1:f6c58c8:                     fail("calling the getter twice should have failed: " +
1:f6c58c8:                         GETTER_NAMES[getter] + " on " + typeName(typeIdx));
1:f6c58c8:                 }
1:f6c58c8:             } catch (SQLException sqle) {
1:f6c58c8:                 assertSQLState("XCL18", sqle);
1:f6c58c8:             }
1:f6c58c8:         }
1:f6c58c8:     }
1:f6c58c8: 
1:bde7b3b:     private void _testGettersSimpleNegative(String columnName, int typeIdx)
1:f6c58c8:             throws SQLException {
1:f6c58c8:         PreparedStatement ps = prepareStatement(
1:f6c58c8:                 "select " + columnName + " from " + TABLE);
1:f6c58c8:         for (int getter=0; getter < COMPATIBLE_GETTERS.length; getter++) {
1:f6c58c8:             boolean supported = COMPATIBLE_GETTERS[getter][typeIdx];
1:f6c58c8:             if (supported) {
1:f6c58c8:                 continue;
1:f6c58c8:             }
1:f6c58c8:             ResultSet rs = ps.executeQuery();
1:f6c58c8:             while (rs.next()) {
1:f6c58c8:                 try {
1:f6c58c8:                     invokeGetter(rs, typeIdx, getter);
1:f6c58c8:                     if (!rs.wasNull()) {
1:f6c58c8:                         fail("expected getter to fail on non-NULL value: " +
1:f6c58c8:                                 debugInfo(1, rs, typeIdx, getter));
1:f6c58c8:                     }
1:f6c58c8:                 } catch (SQLException sqle) {
1:f6c58c8:                     assertSQLState("22005", sqle);
1:f6c58c8:                 }
1:f6c58c8:             }
1:f6c58c8:             rs.close();
1:f6c58c8:         }
1:f6c58c8:     }
1:f6c58c8: 
1:bde7b3b:     private void _testGettersSimple(String columnName, int typeIdx)
1:f6c58c8:             throws SQLException {
1:f6c58c8:         PreparedStatement ps = prepareStatement(
1:f6c58c8:                 "select " + columnName + " from " + TABLE);
1:f6c58c8:         for (int getter=0; getter < COMPATIBLE_GETTERS.length; getter++) {
1:f6c58c8:             boolean supported = COMPATIBLE_GETTERS[getter][typeIdx];
1:f6c58c8:             ResultSet rs = ps.executeQuery();
1:f6c58c8:             while (rs.next()) {
1:f6c58c8:                 try {
1:f6c58c8:                     invokeGetter(rs, typeIdx, getter);
1:f6c58c8:                     // We check for NULL before invoking the getter, so an
1:f6c58c8:                     // exception won't be thrown when invoking an unsupported
1:f6c58c8:                     // getter when the field value is NULL.
1:f6c58c8:                     if (!supported) {
1:f6c58c8:                         assertTrue("should not have worked: " +
1:f6c58c8:                                     debugInfo( 1, rs, typeIdx, getter),
1:f6c58c8:                                 rs.wasNull());
1:f6c58c8:                     }
1:f6c58c8:                 } catch (SQLException sqle) {
1:f6c58c8:                     if (!supported) {
1:f6c58c8:                         assertSQLState("22005", sqle);
1:f6c58c8:                     } else {
1:f6c58c8:                         throw sqle;
1:f6c58c8:                     }
1:f6c58c8:                 }
1:f6c58c8:             }
1:f6c58c8:             rs.close();
1:f6c58c8:         }
1:f6c58c8:         ps.close();
1:f6c58c8:     }
1:f6c58c8: 
1:f6c58c8:     /** Invokes the specified getter on column 1 of the result set. */
1:f6c58c8:     private void invokeGetter(ResultSet rs, int typeIdx, int getter)
1:f6c58c8:             throws SQLException {
1:f6c58c8:         invokeGetter(1, rs, typeIdx, getter);
1:f6c58c8:     }
1:f6c58c8: 
1:f6c58c8:     /** Invokes the specified getter on the given result set 1-based index. */
1:f6c58c8:     private void invokeGetter(int column, ResultSet rs, int typeIdx, int getter)
1:f6c58c8:             throws SQLException {
1:f6c58c8:         println("invoking " + debugInfo(column, rs, typeIdx, getter));
1:f6c58c8:         Object ret;
1:f6c58c8:         switch (getter) {
1:f6c58c8:             case GET_BYTES:
1:f6c58c8:                 ret = rs.getBytes(column);
1:f6c58c8:                 break;
1:f6c58c8:             case GET_STRING:
1:f6c58c8:                 ret = rs.getString(column);
1:f6c58c8:                 break;
1:f6c58c8:             case GET_ASCII_STREAM:
1:f6c58c8:                 ret = rs.getAsciiStream(column);
1:f6c58c8:                 break;
1:f6c58c8:             case GET_BINARY_STREAM:
1:f6c58c8:                 ret = rs.getBinaryStream(column);
1:f6c58c8:                 break;
1:f6c58c8:             case GET_CHARACTER_STREAM:
1:f6c58c8:                 ret = rs.getCharacterStream(column);
1:f6c58c8:                 break;
1:f6c58c8:             case GET_CLOB:
1:f6c58c8:                 ret = rs.getClob(column);
1:f6c58c8:                 break;
1:f6c58c8:             case GET_BLOB:
1:f6c58c8:                 ret = rs.getBlob(column);
1:f6c58c8:                 break;
1:f6c58c8:             case GET_OBJECT:
1:f6c58c8:                 ret = rs.getObject(column);
1:f6c58c8:                 break;
1:f6c58c8:             default:
1:f6c58c8:                 fail("unsupported getter index: " + getter);
1:f6c58c8:                 // Help the compiler a little.
1:f6c58c8:                 throw new IllegalStateException();
1:f6c58c8:         }
1:f6c58c8:         if (rs.wasNull()) {
1:f6c58c8:             assertNull(ret);
1:f6c58c8:         } else {
1:f6c58c8:             assertNotNull(ret);
1:f6c58c8:         }
1:f6c58c8:     }
1:f6c58c8: 
1:f6c58c8:     /** Returns the type name of the given test class specific type index. */
1:f6c58c8:     private String typeName(int typeIdx) {
1:f6c58c8:         switch (typeIdx) {
1:f6c58c8:             case BLOB:
1:f6c58c8:                 return "BLOB";
1:f6c58c8:             case CLOB:
1:f6c58c8:                 return  "CLOB";
1:f6c58c8:             default:
1:f6c58c8:                 return "UNKNOWN";
1:f6c58c8:         }
1:f6c58c8:     }
1:f6c58c8: 
1:f6c58c8:     /**
1:f6c58c8:      * Generates a debug string telling which getter failed.
1:f6c58c8:      *
1:f6c58c8:      * @param colIdx 1-based column index accessed on the result set
1:f6c58c8:      * @param rs the result set accessed
1:f6c58c8:      * @param typeIdx test class specific type (BLOB or CLOB)
1:f6c58c8:      * @param getter test class specific getter index
1:f6c58c8:      * @return Descriptive string.
1:f6c58c8:      * @throws SQLException if accessing result set meta data fails
1:f6c58c8:      */
1:f6c58c8:     private String debugInfo(int colIdx, ResultSet rs, int typeIdx, int getter)
1:f6c58c8:             throws SQLException {
1:f6c58c8:         ResultSetMetaData meta = rs.getMetaData();
1:f6c58c8:         return GETTER_NAMES[getter] + " on " + typeName(typeIdx) +
1:f6c58c8:                 " (meta:col=" + colIdx +
1:f6c58c8:                 ",type=" + meta.getColumnTypeName(colIdx) +
1:f6c58c8:                 ",name=" + meta.getColumnName(colIdx) + ")";
1:f6c58c8:     }
1:f6c58c8: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ca48ab4
/////////////////////////////////////////////////////////////////////////
1:     private static final boolean u = UNSUPPORTED;
/////////////////////////////////////////////////////////////////////////
1:         /* getBytes             */ { X, u },
1:         /* getBinaryStream      */ { X, u },
1:         /* getClob              */ { u, X },
1:         /* getBlob              */ { X, u },
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:bde7b3b
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.sql.Blob;
1: import java.sql.Clob;
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The names of the various getters used in this test.
1:      * <p>
1:      * The positions/indexes must correspond to those in
1:      * {@linkplain #COMPATIBLE_GETTERS}.
1:      */
/////////////////////////////////////////////////////////////////////////
1:         _testGettersSimple("dBlob", BLOB);
/////////////////////////////////////////////////////////////////////////
1:         _testGettersSimple("dClob", CLOB);
/////////////////////////////////////////////////////////////////////////
1:         _testGettersSimpleNegative("dBlob", BLOB);
/////////////////////////////////////////////////////////////////////////
1:         _testGettersSimpleNegative("dClob", CLOB);
/////////////////////////////////////////////////////////////////////////
1:         _testGettersMultiInvocation("dBlob", BLOB);
/////////////////////////////////////////////////////////////////////////
1:         _testGettersMultiInvocation("dClob", CLOB);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tests that data returned by the last BLOB getter invokation is correct.
1:      */
1:     public void testCorrectBlobDataWithMultiCall()
1:             throws IOException, SQLException {
1:         setAutoCommit(false);
1:         PreparedStatement psId = prepareStatement("select id from " + TABLE);
1:         String select = "select dBlob from " + TABLE + " where id = ?";
1:         PreparedStatement ps1 = prepareStatement(select);
1:         PreparedStatement ps2 = prepareStatement(select);
1:         ResultSet rsId = psId.executeQuery();
1:         ResultSet rs1;
1:         ResultSet rs2;
1:         while (rsId.next()) {
1:             ps1.setInt(1, rsId.getInt(1));
1:             ps2.setInt(1, rsId.getInt(1));
1: 
1:             // getBytes - getString - getBinaryStream
1:             rs1 = ps1.executeQuery();
1:             assertTrue(rs1.next());
1:             rs1.getBytes(1);
1:             rs1.getString(1);
1:             rs2 = ps2.executeQuery();
1:             assertTrue(rs2.next());
1:             assertEquals(rs2.getBinaryStream(1), rs1.getBinaryStream(1));
1:             rs1.close();
1:             rs2.close();
1: 
1:             // getString - getBytes - getBlob
1:             rs1 = ps1.executeQuery();
1:             assertTrue(rs1.next());
1:             rs1.getString(1);
1:             rs1.getBytes(1);
1:             rs2 = ps2.executeQuery();
1:             assertTrue(rs2.next());
1:             assertEquals(rs2.getBlob(1), rs1.getBlob(1));
1:             rs1.close();
1:             rs2.close();
1: 
1:             // getBytes - getString - getCharacterStream
1:             rs1 = ps1.executeQuery();
1:             assertTrue(rs1.next());
1:             rs1.getBytes(1);
1:             rs1.getString(1);
1:             rs2 = ps2.executeQuery();
1:             assertTrue(rs2.next());
1:             assertEquals(rs2.getCharacterStream(1), rs1.getCharacterStream(1));
1:             rs1.close();
1:             rs2.close();
1: 
1:             // getBytes - getString - getBytes
1:             rs1 = ps1.executeQuery();
1:             assertTrue(rs1.next());
1:             rs1.getBytes(1);
1:             rs1.getString(1);
1:             rs2 = ps2.executeQuery();
1:             assertTrue(rs2.next());
1:             assertTrue(Arrays.equals(rs2.getBytes(1), rs1.getBytes(1)));
1:             rs1.close();
1:             rs2.close();
1: 
1:             // getBytes - getString - getString
1:             rs1 = ps1.executeQuery();
1:             assertTrue(rs1.next());
1:             rs1.getBytes(1);
1:             rs1.getString(1);
1:             rs2 = ps2.executeQuery();
1:             assertTrue(rs2.next());
1:             assertEquals(rs2.getString(1), rs1.getString(1));
1:             rs1.close();
1:             rs2.close();
1: 
1:             // getString - getBytes - getObject
1:             rs1 = ps1.executeQuery();
1:             assertTrue(rs1.next());
1:             rs1.getString(1);
1:             rs1.getBytes(1);
1:             rs2 = ps2.executeQuery();
1:             assertTrue(rs2.next());
1:             Blob b1 = (Blob)rs1.getObject(1);
1:             Blob b2 = (Blob)rs2.getObject(1);
1:             assertEquals(b2, b1);
1:             rs1.close();
1:             rs2.close();
1: 
1:             // getBytes - getString - getAsciiStream
1:             rs1 = ps1.executeQuery();
1:             assertTrue(rs1.next());
1:             rs1.getBytes(1);
1:             rs1.getString(1);
1:             rs2 = ps2.executeQuery();
1:             assertTrue(rs2.next());
1:             assertEquals(rs2.getAsciiStream(1), rs1.getAsciiStream(1));
1:             rs1.close();
1:             rs2.close();
1:         }
1:         rollback();
1:     }
1: 
1:     /**
1:      * Tests that data returned by the last CLOB getter invokation is correct.
1:      */
1:     public void testCorrectClobDataWithMultiCall()
1:             throws IOException, SQLException {
1:         setAutoCommit(false);
1:         PreparedStatement psId = prepareStatement(
1:                 "select id, dClob from " + TABLE);
1:         String select = "select dClob from " + TABLE + " where id = ?";
1:         PreparedStatement ps1 = prepareStatement(select);
1:         PreparedStatement ps2 = prepareStatement(select);
1:         ResultSet rsId = psId.executeQuery();
1:         ResultSet rs1;
1:         ResultSet rs2;
1:         while (rsId.next()) {
1:             ps1.setInt(1, rsId.getInt(1));
1:             ps2.setInt(1, rsId.getInt(1));
1: 
1:             // getString - getString
1:             rs1 = ps1.executeQuery();
1:             assertTrue(rs1.next());
1:             rs1.getString(1);
1:             rs2 = ps2.executeQuery();
1:             assertTrue(rs2.next());
1:             assertEquals(rs2.getString(1), rs1.getString(1));
1:             rs1.close();
1:             rs2.close();
1: 
1:             // getString - getCharacterStream
1:             rs1 = ps1.executeQuery();
1:             assertTrue(rs1.next());
1:             rs1.getString(1);
1:             rs2 = ps2.executeQuery();
1:             assertTrue(rs2.next());
1:             assertEquals(rs2.getCharacterStream(1), rs1.getCharacterStream(1));
1:             rs1.close();
1:             rs2.close();
1: 
1:             // getString - getClob
1:             rs1 = ps1.executeQuery();
1:             assertTrue(rs1.next());
1:             rs1.getString(1);
1:             rs2 = ps2.executeQuery();
1:             assertTrue(rs2.next());
1:             assertEquals(rs2.getClob(1), rs1.getClob(1));
1:             rs1.close();
1:             rs2.close();
1: 
1:             // getString - getObject
1:             rs1 = ps1.executeQuery();
1:             assertTrue(rs1.next());
1:             rs1.getString(1);
1:             rs2 = ps2.executeQuery();
1:             assertTrue(rs2.next());
1:             Clob b1 = (Clob)rs1.getObject(1);
1:             Clob b2 = (Clob)rs2.getObject(1);
1:             assertEquals(b2, b1);
1:             rs1.close();
1:             rs2.close();
1: 
1:             // getString - getAsciiStream
1:             rs1 = ps1.executeQuery();
1:             assertTrue(rs1.next());
1:             rs1.getString(1);
1:             rs2 = ps2.executeQuery();
1:             assertTrue(rs2.next());
1:             assertEquals(rs2.getAsciiStream(1), rs1.getAsciiStream(1));
1:             rs1.close();
1:             rs2.close();
1:         }
1:         rollback();
1:     }
1: 
1:     private void _testGettersMultiInvocation(String columnName, int typeIdx)
/////////////////////////////////////////////////////////////////////////
1:     private void _testGettersSimpleNegative(String columnName, int typeIdx)
/////////////////////////////////////////////////////////////////////////
1:     private void _testGettersSimple(String columnName, int typeIdx)
commit:f6c58c8
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.LobRsGetterTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.Types;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Tests restrictions and special conditions that apply when calling result set
1:  * getters on LOB columns.
1:  * <p>
1:  * Some relevant JIRAs:
1:  * <ul> <li>
1:  * <a href="https://issues.apache.org/jira/browse/DERBY-3844">DERBY-3844</a>
1:  *      : has references to other JIRAs and some discussion</li>
1:  *      <li>
1:  * <a href="https://issues.apache.org/jira/browse/DERBY-5489">DERBY-5489</a>
1:  *      : triggered the writing of this test and the following cleanup</li>
1:  * </ul>
1:  */
1: public class LobRsGetterTest
1:     extends BaseJDBCTestCase {
1: 
1:     private static final String TABLE = "LOB_RS_GETTER_TEST";
1:     private static final boolean UNSUPPORTED = false;
1:     private static final boolean SUPPORTED = true;
1: 
1:     private static final int BLOB = 0;
1:     private static final int CLOB = 1;
1: 
1:     private static final int GET_BYTES = 0;
1:     private static final int GET_STRING = 1;
1:     private static final int GET_ASCII_STREAM = 2;
1:     private static final int GET_BINARY_STREAM = 3;
1:     private static final int GET_CHARACTER_STREAM = 4;
1:     private static final int GET_CLOB = 5;
1:     private static final int GET_BLOB = 6;
1:     private static final int GET_OBJECT = 7;
1: 
1:     private static final boolean X = SUPPORTED;
1:     /** Supported, but not marked as valid by the JDBC spec. */
1:     private static final boolean E = SUPPORTED; // visual que in table only
0:     private static final boolean _ = UNSUPPORTED;
1: 
1:     /**
1:      * Lists the compatible getters for {@literal BLOB} and {@literal CLOB}.
1:      * <p>
1:      * Note that the getters {@code getNCharacterStream}, {@code getNString}
1:      * and {@code getNClob} aren't tested. They're not supported by Derby.
1:      * <p>
1:      * For notes on behavior when invoking the various character getters on
1:      * binary columns, see
1:      * <a href="http://db.apache.org/derby/papers/JDBCImplementation.html">
1:      * JDBCImplementation.html</a>.
1:      */
1:     private static final boolean[][] COMPATIBLE_GETTERS = new boolean[][] {
1:                                 /*   B  C */
1:                                 /*   L  L */
1:                                 /*   O  O */
1:                                 /*   B  B */
0:         /* getBytes             */ { X, _ },
1:         /* getString            */ { E, X },
1:         /* getAsciiStream       */ { E, X },
0:         /* getBinaryStream      */ { X, _ },
1:         /* getCharacterStream   */ { E, X },
0:         /* getClob              */ { _, X },
0:         /* getBlob              */ { X, _ },
1:         /* getObject            */ { X, X },
1:     };
1: 
1:     private static final String[] GETTER_NAMES = new String[] {
1:         "getBytes", "getString", "getAsciiStream", "getBinaryStream",
1:         "getCharacterStream", "getClob", "getBlob", "getObject"
1:     };
1: 
1:     public LobRsGetterTest(String name) {
1:         super(name);
1:     }
1: 
1:     /** Returns a suite with all tests running with both embedded and client. */
1:     public static Test suite() {
1:         Test suite = TestConfiguration.defaultSuite(
1:                 LobRsGetterTest.class, false);
1:         return new CleanDatabaseTestSetup(suite) {
1:              protected void decorateSQL(Statement s)
1:                      throws SQLException {
1:                  Connection con = s.getConnection();
1:                  dropTable(con, TABLE);
1:                  // NOTE: Do not insert a lot of data into this table, many
1:                  //       of the tests iterate over all rows in the table.
1:                  s.executeUpdate("create table " + TABLE + "(" +
1:                          "id INT GENERATED ALWAYS AS IDENTITY, " +
1:                          "dBlob BLOB, dClob CLOB)");
1:                  // Insert a few rows with different characteristics:
1:                  // multi page LOB, single page LOB, NULL
1:                  PreparedStatement ps = con.prepareStatement(
1:                          "insert into " + TABLE +
1:                          "(dBlob, dClob) values (?,?)");
1:                  int mpSize = 173*1024; // 173 KB or KChars
1:                  int spSize = 300; // 300 B or chars
1:                  ps.setBinaryStream(1,
1:                          new LoopingAlphabetStream(mpSize), mpSize);
1:                  ps.setCharacterStream(2,
1:                          new LoopingAlphabetReader(mpSize), mpSize);
1:                  ps.executeUpdate();
1:                  ps.setBinaryStream(1,
1:                          new LoopingAlphabetStream(spSize), spSize);
1:                  ps.setCharacterStream(2,
1:                          new LoopingAlphabetReader(spSize), spSize);
1:                  ps.executeUpdate();
1:                  ps.setNull(1, Types.BLOB);
1:                  ps.setNull(2, Types.CLOB);
1:                  ps.executeUpdate();
1:                  // Make sure there are three rows.
1:                  JDBC.assertDrainResults(
1:                          s.executeQuery("select * from " + TABLE), 3);
1:                  ps.close();
1:                  s.close();
1:              }
1:         };
1:     }
1: 
1:     /**
1:      * Tests that all getters marked as supported don't throw an exception.
1:      */
1:     public void testBlobGettersSimple()
1:             throws SQLException {
0:         testGettersSimple("dBlob", BLOB);
1:     }
1: 
1:     /**
1:      * Tests that all getters marked as supported don't throw an exception.
1:      */
1:     public void testClobGettersSimple()
1:             throws SQLException {
0:         testGettersSimple("dClob", CLOB);
1:     }
1: 
1:     /**
1:      * Tests that all getters marked as unsupported throw an exception.
1:      */
1:     public void testBlobGettersSimpleNegative()
1:             throws SQLException {
0:         testGettersSimpleNegative("dBlob", BLOB);
1:     }
1: 
1:     /**
1:      * Tests that all getters marked as unsupported throw an exception.
1:      */
1:     public void testClobGettersSimpleNegative()
1:             throws SQLException {
0:         testGettersSimpleNegative("dClob", CLOB);
1:     }
1: 
1:     /**
1:      * Tests that multiple invocations of getters on the same column/row throw
1:      * an exception in most cases.
1:      * <p>
1:      * For now {@code getBytes} and {@code getString} are behaving differently
1:      * for BLOBs.
1:      */
1:     public void testBlobGettersMultiInvocation()
1:             throws SQLException {
0:         testGettersMultiInvocation("dBlob", BLOB);
1:     }
1: 
1:     /**
1:      * Tests that multiple invocations of getters on the same column/row throw
1:      * an exception in most cases.
1:      * <p>
1:      * For now {@code getString} is behaving differently for CLOBs.
1:      */
1:     public void testClobGettersMultiInvocation()
1:             throws SQLException {
0:         testGettersMultiInvocation("dClob", CLOB);
1:     }
1: 
1:     /**
1:      * Tests that {@code getBytes} throws exception when invoked after any
1:      * other getters than {@code getBytes} and {@code getString}.
1:      */
1:     public void testBlobGetXFollowedByGetBytes()
1:             throws SQLException {
1:         PreparedStatement ps = prepareStatement(
1:                 "select dBlob from " + TABLE);
1:         for (int getter=0; getter < COMPATIBLE_GETTERS.length; getter++) {
1:             if (COMPATIBLE_GETTERS[getter][BLOB] == UNSUPPORTED) {
1:                 continue;
1:             }
1:             ResultSet rs = ps.executeQuery();
1:             assertTrue(rs.next());
1:             invokeGetter(rs, BLOB, getter);
1:             // The next call should fail unless the getter is getBytes.
1:             try {
1:                 invokeGetter(rs, BLOB, GET_BYTES);
1:                 assertTrue("getBytes should have failed after: " +
1:                         debugInfo(1, rs, BLOB, getter),
0:                         // TODO: Is GET_STRING to be considerd valid for BLOB?
1:                         getter == GET_BYTES || getter == GET_STRING);
1:             } catch (SQLException sqle) {
1:                 assertTrue(getter != GET_BYTES);
1:                 assertSQLState(debugInfo(1, rs, BLOB, getter) +
1:                         " followed by getBytes", "XCL18", sqle);
1:             } finally {
1:                 rs.close();
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Tests that {@code getString} throws exception when invoked after any
1:      * other getter than {@code getString}.
1:      */
1:     public void testClobGetXFollowedByGetString()
1:             throws SQLException {
1:         PreparedStatement ps = prepareStatement(
1:                 "select dClob from " + TABLE);
1:         for (int getter=0; getter < COMPATIBLE_GETTERS.length; getter++) {
1:             if (COMPATIBLE_GETTERS[getter][CLOB] == UNSUPPORTED) {
1:                 continue;
1:             }
1:             ResultSet rs = ps.executeQuery();
1:             assertTrue(rs.next());
1:             invokeGetter(rs, CLOB, getter);
1:             // The next call should fail unless the getter is getString.
1:             try {
1:                 invokeGetter(rs, CLOB, GET_STRING);
1:                 assertTrue("getString should have failed after: " +
1:                         debugInfo(1, rs, CLOB, getter),
1:                         getter == GET_STRING);
1:             } catch (SQLException sqle) {
1:                 assertTrue(getter != GET_STRING);
1:                 assertSQLState(debugInfo(1, rs, CLOB, getter) +
1:                         " followed by getString", "XCL18", sqle);
1:             } finally {
1:                 rs.close();
1:             }
1:         }
1:     }
1: 
0:     private void testGettersMultiInvocation(String columnName, int typeIdx)
1:             throws SQLException {
1:         PreparedStatement ps = prepareStatement(
1:                 "select " + columnName + " from " + TABLE);
1:         for (int getter=0; getter < COMPATIBLE_GETTERS.length; getter++) {
1:             boolean supported = COMPATIBLE_GETTERS[getter][typeIdx];
1:             if (!supported) {
1:                 continue;
1:             }
1:             ResultSet rs = ps.executeQuery();
1:             rs.next();
1:             invokeGetter(rs, typeIdx, getter);
1:             try {
1:                 invokeGetter(rs, typeIdx, getter);
1:                 if (getter != GET_BYTES && getter != GET_STRING) {
1:                     fail("calling the getter twice should have failed: " +
1:                         GETTER_NAMES[getter] + " on " + typeName(typeIdx));
1:                 }
1:             } catch (SQLException sqle) {
1:                 assertSQLState("XCL18", sqle);
1:             }
1:         }
1:     }
1: 
0:     private void testGettersSimpleNegative(String columnName, int typeIdx)
1:             throws SQLException {
1:         PreparedStatement ps = prepareStatement(
1:                 "select " + columnName + " from " + TABLE);
1:         for (int getter=0; getter < COMPATIBLE_GETTERS.length; getter++) {
1:             boolean supported = COMPATIBLE_GETTERS[getter][typeIdx];
1:             if (supported) {
1:                 continue;
1:             }
1:             ResultSet rs = ps.executeQuery();
1:             while (rs.next()) {
1:                 try {
1:                     invokeGetter(rs, typeIdx, getter);
1:                     if (!rs.wasNull()) {
1:                         fail("expected getter to fail on non-NULL value: " +
1:                                 debugInfo(1, rs, typeIdx, getter));
1:                     }
1:                 } catch (SQLException sqle) {
1:                     assertSQLState("22005", sqle);
1:                 }
1:             }
1:             rs.close();
1:         }
1:     }
1: 
0:     private void testGettersSimple(String columnName, int typeIdx)
1:             throws SQLException {
1:         PreparedStatement ps = prepareStatement(
1:                 "select " + columnName + " from " + TABLE);
1:         for (int getter=0; getter < COMPATIBLE_GETTERS.length; getter++) {
1:             boolean supported = COMPATIBLE_GETTERS[getter][typeIdx];
1:             ResultSet rs = ps.executeQuery();
1:             while (rs.next()) {
1:                 try {
1:                     invokeGetter(rs, typeIdx, getter);
1:                     // We check for NULL before invoking the getter, so an
1:                     // exception won't be thrown when invoking an unsupported
1:                     // getter when the field value is NULL.
1:                     if (!supported) {
1:                         assertTrue("should not have worked: " +
1:                                     debugInfo( 1, rs, typeIdx, getter),
1:                                 rs.wasNull());
1:                     }
1:                 } catch (SQLException sqle) {
1:                     if (!supported) {
1:                         assertSQLState("22005", sqle);
1:                     } else {
1:                         throw sqle;
1:                     }
1:                 }
1:             }
1:             rs.close();
1:         }
1:         ps.close();
1:     }
1: 
1:     /** Invokes the specified getter on column 1 of the result set. */
1:     private void invokeGetter(ResultSet rs, int typeIdx, int getter)
1:             throws SQLException {
1:         invokeGetter(1, rs, typeIdx, getter);
1:     }
1: 
1:     /** Invokes the specified getter on the given result set 1-based index. */
1:     private void invokeGetter(int column, ResultSet rs, int typeIdx, int getter)
1:             throws SQLException {
1:         println("invoking " + debugInfo(column, rs, typeIdx, getter));
1:         Object ret;
1:         switch (getter) {
1:             case GET_BYTES:
1:                 ret = rs.getBytes(column);
1:                 break;
1:             case GET_STRING:
1:                 ret = rs.getString(column);
1:                 break;
1:             case GET_ASCII_STREAM:
1:                 ret = rs.getAsciiStream(column);
1:                 break;
1:             case GET_BINARY_STREAM:
1:                 ret = rs.getBinaryStream(column);
1:                 break;
1:             case GET_CHARACTER_STREAM:
1:                 ret = rs.getCharacterStream(column);
1:                 break;
1:             case GET_CLOB:
1:                 ret = rs.getClob(column);
1:                 break;
1:             case GET_BLOB:
1:                 ret = rs.getBlob(column);
1:                 break;
1:             case GET_OBJECT:
1:                 ret = rs.getObject(column);
1:                 break;
1:             default:
1:                 fail("unsupported getter index: " + getter);
1:                 // Help the compiler a little.
1:                 throw new IllegalStateException();
1:         }
1:         if (rs.wasNull()) {
1:             assertNull(ret);
1:         } else {
1:             assertNotNull(ret);
1:         }
1:     }
1: 
1:     /** Returns the type name of the given test class specific type index. */
1:     private String typeName(int typeIdx) {
1:         switch (typeIdx) {
1:             case BLOB:
1:                 return "BLOB";
1:             case CLOB:
1:                 return  "CLOB";
1:             default:
1:                 return "UNKNOWN";
1:         }
1:     }
1: 
1:     /**
1:      * Generates a debug string telling which getter failed.
1:      *
1:      * @param colIdx 1-based column index accessed on the result set
1:      * @param rs the result set accessed
1:      * @param typeIdx test class specific type (BLOB or CLOB)
1:      * @param getter test class specific getter index
1:      * @return Descriptive string.
1:      * @throws SQLException if accessing result set meta data fails
1:      */
1:     private String debugInfo(int colIdx, ResultSet rs, int typeIdx, int getter)
1:             throws SQLException {
1:         ResultSetMetaData meta = rs.getMetaData();
1:         return GETTER_NAMES[getter] + " on " + typeName(typeIdx) +
1:                 " (meta:col=" + colIdx +
1:                 ",type=" + meta.getColumnTypeName(colIdx) +
1:                 ",name=" + meta.getColumnName(colIdx) + ")";
1:     }
1: }
============================================================================