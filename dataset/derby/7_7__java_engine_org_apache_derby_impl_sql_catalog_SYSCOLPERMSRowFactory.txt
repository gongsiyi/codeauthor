1:b7730e4: /*
6:b7730e4: 
1:b7730e4:    Derby - Class org.apache.derby.impl.sql.catalog.SYSCOLPERMSRowFactory
1:b7730e4: 
1:f739ad1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f739ad1:    contributor license agreements.  See the NOTICE file distributed with
1:f739ad1:    this work for additional information regarding copyright ownership.
1:f739ad1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f739ad1:    (the "License"); you may not use this file except in compliance with
1:f739ad1:    the License.  You may obtain a copy of the License at
1:b7730e4: 
1:b7730e4:       http://www.apache.org/licenses/LICENSE-2.0
1:b7730e4: 
1:b7730e4:    Unless required by applicable law or agreed to in writing, software
1:b7730e4:    distributed under the License is distributed on an "AS IS" BASIS,
1:b7730e4:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b7730e4:    See the License for the specific language governing permissions and
1:b7730e4:    limitations under the License.
1:b7730e4: 
2:b7730e4:  */
1:b7730e4: 
1:b7730e4: package org.apache.derby.impl.sql.catalog;
1:b7730e4: 
1:b7730e4: import org.apache.derby.iapi.sql.dictionary.ColPermsDescriptor;
1:b7730e4: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
1:b7730e4: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:b7730e4: import org.apache.derby.iapi.sql.dictionary.StatisticsDescriptor;
1:b7730e4: import org.apache.derby.iapi.sql.dictionary.SystemColumn;
1:b7730e4: import org.apache.derby.iapi.sql.dictionary.TupleDescriptor;
1:b7730e4: import org.apache.derby.iapi.sql.dictionary.PermissionsDescriptor;
1:b7730e4: 
1:b7730e4: import org.apache.derby.iapi.error.StandardException;
1:b7730e4: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:b7730e4: import org.apache.derby.iapi.sql.execute.ExecRow;
1:b7730e4: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1:b7730e4: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1:eb47bdb: import org.apache.derby.iapi.types.SQLChar;
1:b7730e4: import org.apache.derby.iapi.types.TypeId;
1:4309044: import org.apache.derby.iapi.types.UserType;
1:b7730e4: import org.apache.derby.iapi.types.DataValueFactory;
1:b7730e4: import org.apache.derby.iapi.types.RowLocation;
1:b7730e4: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:b7730e4: import org.apache.derby.iapi.types.DataValueDescriptor;
1:b7730e4: import org.apache.derby.iapi.types.NumberDataValue;
1:b7730e4: import org.apache.derby.iapi.types.StringDataValue;
1:b7730e4: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1:b7730e4: import org.apache.derby.catalog.UUID;
1:b7730e4: import org.apache.derby.catalog.Statistics;
1:b7730e4: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:b7730e4: 
1:b7730e4: import java.sql.Timestamp;
1:b7730e4: 
2:b7730e4: /**
1:b7730e4:  * Factory for creating a SYSCOLPERMS row.
1:b7730e4:  *
1:b7730e4:  */
1:b7730e4: 
1:ea3f2e4: class SYSCOLPERMSRowFactory extends PermissionsCatalogRowFactory
5:b7730e4: {
1:b7730e4: 	static final String TABLENAME_STRING = "SYSCOLPERMS";
1:b7730e4: 
1:b7730e4:     // Column numbers for the SYSCOLPERMS table. 1 based
1:ac100d6: 	private static final int COLPERMSID_COL_NUM = 1;
1:2d2e717:     private static final int GRANTEE_COL_NUM = 2;
1:2d2e717:     private static final int GRANTOR_COL_NUM = 3;
1:2d2e717:     private static final int TABLEID_COL_NUM = 4;
1:2d2e717:     private static final int TYPE_COL_NUM = 5;
1:626d315:     protected static final int COLUMNS_COL_NUM = 6;
1:2d2e717:     private static final int COLUMN_COUNT = 6;
1:b7730e4: 
1:ea3f2e4:     static final int GRANTEE_TABLE_TYPE_GRANTOR_INDEX_NUM = 0;
1:ea3f2e4:     static final int COLPERMSID_INDEX_NUM = 1;
1:ea3f2e4:     static final int TABLEID_INDEX_NUM = 2;
1:626d315:     protected static final int TOTAL_NUM_OF_INDEXES = 3;
1:b7730e4: 	private static final int[][] indexColumnPositions = 
1:b7730e4: 	{ 
1:ac100d6: 		{ GRANTEE_COL_NUM, TABLEID_COL_NUM, TYPE_COL_NUM, GRANTOR_COL_NUM},
1:b7e13a9: 		{ COLPERMSID_COL_NUM },
1:b7e13a9: 		{ TABLEID_COL_NUM }
2:b7730e4: 	};
1:c2ff613: 
1:ee59de8:     public static final int
1:ee59de8:         GRANTEE_COL_NUM_IN_GRANTEE_TABLE_TYPE_GRANTOR_INDEX = 1;
1:ee59de8: 
1:b7e13a9:     private static final boolean[] indexUniqueness = { true, true, false};
1:b7730e4: 
1:b7730e4:     private	static final String[] uuids =
1:b7730e4:     {
1:b7730e4:         "286cc01e-0103-0e39-b8e7-00000010f010" // catalog UUID
1:b7730e4: 		,"6074401f-0103-0e39-b8e7-00000010f010"	// heap UUID
1:ac100d6: 		,"787c0020-0103-0e39-b8e7-00000010f010"	// index1
1:ac100d6: 		,"c9a3808d-010c-42a2-ae15-0000000f67f8" //index2
1:b7e13a9: 		,"80220011-010c-bc85-060d-000000109ab8" //index3
1:b7730e4:     };
1:b7730e4: 
1:6870e87:     SYSCOLPERMSRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf)
1:b7730e4: 	{
1:6870e87: 		super(uuidf,ef,dvf);
1:c2ff613: 		initInfo(COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, indexUniqueness, uuids);
3:b7730e4: 	}
1:b7730e4: 
1:b7730e4: 	public ExecRow makeRow(TupleDescriptor td, TupleDescriptor parent) throws StandardException
1:b7730e4: 	{
1:2d2e717:         UUID						oid;
1:2d2e717:         String colPermID = null;
1:b7730e4:         DataValueDescriptor grantee = null;
1:b7730e4:         DataValueDescriptor grantor = null;
1:b7730e4:         String tableID = null;
1:b7730e4:         String type = null;
1:b7730e4:         FormatableBitSet columns = null;
1:b7730e4: 
1:b7730e4:         if( td == null)
1:b7730e4:         {
1:b7730e4:             grantee = getNullAuthorizationID();
1:b7730e4:             grantor = getNullAuthorizationID();
1:b7730e4:         }
1:b7730e4:         else
1:b7730e4:         {
1:b7730e4:             ColPermsDescriptor cpd = (ColPermsDescriptor) td;
1:2d2e717:             oid = cpd.getUUID();
1:2d2e717:             if ( oid == null )
1:2d2e717:             {
1:2d2e717:             	oid = getUUIDFactory().createUUID();
1:2d2e717:             	cpd.setUUID(oid);           
1:2d2e717:             }
1:2d2e717:             colPermID = oid.toString();
1:b7730e4:             grantee = getAuthorizationID( cpd.getGrantee());
1:b7730e4:             grantor = getAuthorizationID( cpd.getGrantor());
1:b7730e4:             tableID = cpd.getTableUUID().toString();
1:b7730e4:             type = cpd.getType();
1:b7730e4:             columns = cpd.getColumns();
1:b7730e4:         }
1:b7730e4:         ExecRow row = getExecutionFactory().getValueRow( COLUMN_COUNT);
1:eb47bdb:         row.setColumn( COLPERMSID_COL_NUM, new SQLChar(colPermID));
1:b7730e4:         row.setColumn( GRANTEE_COL_NUM, grantee);
1:b7730e4:         row.setColumn( GRANTOR_COL_NUM, grantor);
1:eb47bdb:         row.setColumn( TABLEID_COL_NUM, new SQLChar(tableID));
1:eb47bdb:         row.setColumn( TYPE_COL_NUM, new SQLChar(type));
1:4309044:         row.setColumn( COLUMNS_COL_NUM, new UserType( (Object) columns));
2:b7730e4:         return row;
1:b7730e4:     } // end of makeRow
1:b7730e4: 
1:b7730e4: 	/** builds a tuple descriptor from a row */
1:b7730e4: 	public TupleDescriptor buildDescriptor(ExecRow row,
1:b7730e4:                                            TupleDescriptor parentTuple,
1:b7730e4:                                            DataDictionary	dataDictionary)
2:b7730e4: 		throws StandardException
1:b7730e4:     {
1:b7730e4:         if( SanityManager.DEBUG)
1:b7730e4:             SanityManager.ASSERT( row.nColumns() == COLUMN_COUNT,
1:b7730e4:                                   "Wrong size row passed to SYSCOLPERMSRowFactory.buildDescriptor");
1:b7730e4: 
1:ac100d6:         String colPermsUUIDString = row.getColumn( COLPERMSID_COL_NUM).getString();
1:2d2e717:         UUID colPermsUUID = getUUIDFactory().recreateUUID(colPermsUUIDString);
1:b7730e4:         String tableUUIDString = row.getColumn( TABLEID_COL_NUM).getString();
1:b7730e4:         UUID tableUUID = getUUIDFactory().recreateUUID(tableUUIDString);
1:b7730e4:         String type = row.getColumn( TYPE_COL_NUM).getString();
1:b7730e4:         FormatableBitSet columns = (FormatableBitSet) row.getColumn( COLUMNS_COL_NUM).getObject();
1:b7730e4:         if( SanityManager.DEBUG)
1:b7730e4:             SanityManager.ASSERT( "s".equals( type) || "S".equals( type) ||
1:b7730e4:                                   "u".equals( type) || "U".equals( type) ||
1:b7730e4:                                   "r".equals( type) || "R".equals( type),
1:b7730e4:                                   "Invalid type passed to SYSCOLPERMSRowFactory.buildDescriptor");
1:b7730e4: 
1:2d2e717:         ColPermsDescriptor colPermsDesc =
1:2d2e717: 	        new ColPermsDescriptor( dataDictionary, 
1:2d2e717:                     getAuthorizationID( row, GRANTEE_COL_NUM),
1:2d2e717:                     getAuthorizationID( row, GRANTOR_COL_NUM),
1:2d2e717:                     tableUUID, type, columns);
1:2d2e717:         colPermsDesc.setUUID(colPermsUUID);
1:2d2e717:         return colPermsDesc;
1:b7730e4:     } // end of buildDescriptor
1:b7730e4: 
1:b7730e4: 	/** builds a column list for the catalog */
1:ea3f2e4:     public SystemColumn[] buildColumnList()
1:2a5922a:         throws StandardException
1:b7730e4:     {
1:ea3f2e4:         return new SystemColumn[] {
1:ea3f2e4:            SystemColumnImpl.getUUIDColumn("COLPERMSID", false),
1:ea3f2e4:            SystemColumnImpl.getIdentifierColumn("GRANTEE", false),
1:ea3f2e4:            SystemColumnImpl.getIdentifierColumn("GRANTOR", false),
1:ea3f2e4:            SystemColumnImpl.getUUIDColumn("TABLEID", false),
1:ea3f2e4:            SystemColumnImpl.getIndicatorColumn("TYPE"),
1:ea3f2e4:            SystemColumnImpl.getJavaColumn("COLUMNS",
1:ea3f2e4:                    "org.apache.derby.iapi.services.io.FormatableBitSet", false)    
1:ea3f2e4:         };
1:ea3f2e4:     }
1:b7730e4: 
1:b7730e4: 	/**
1:b7730e4: 	 * builds an index key row for a given index number.
1:b7730e4: 	 */
1:b7730e4:   	public ExecIndexRow buildIndexKeyRow( int indexNumber,
1:b7730e4:                                           PermissionsDescriptor perm) 
1:b7730e4:   		throws StandardException
1:b7730e4:     {
1:b7730e4:         ExecIndexRow row = null;
1:b7730e4:         
2:b7730e4:         switch( indexNumber)
1:b7730e4:         {
2:b7730e4:         case GRANTEE_TABLE_TYPE_GRANTOR_INDEX_NUM:
1:b7730e4:             // RESOLVE We do not support the FOR GRANT OPTION, so column permission rows are unique on the
1:b7730e4:             // grantee, table UUID, and type columns. The grantor column will always have the name of the owner of the
1:b7730e4:             // table. So the index key, used for searching the index, only has grantee, table UUID, and type columns.
1:b7730e4:             // It does not have a grantor column.
1:b7730e4:             //
1:b7730e4:             // If we support FOR GRANT OPTION then there may be multiple table permissions rows for a
1:b7730e4:             // (grantee, tableID, type) combination. We must either handle the multiple rows, which is necessary for
1:b7730e4:             // checking permissions, or add a grantor column to the key, which is necessary for granting or revoking
1:b7730e4:             // permissions.
1:b7730e4:             row = getExecutionFactory().getIndexableRow( 3);
1:b7730e4:             row.setColumn(1, getAuthorizationID( perm.getGrantee()));
1:b7730e4:             ColPermsDescriptor colPerms = (ColPermsDescriptor) perm;
1:b7730e4:             String tableUUIDStr = colPerms.getTableUUID().toString();
1:eb47bdb:             row.setColumn(2, new SQLChar(tableUUIDStr));
1:eb47bdb:             row.setColumn(3, new SQLChar(colPerms.getType()));
1:b7e13a9:             break;
1:ac100d6:         case COLPERMSID_INDEX_NUM:
1:ac100d6:             row = getExecutionFactory().getIndexableRow( 1);
1:ac100d6:             String colPermsUUIDStr = perm.getObjectID().toString();
1:eb47bdb:             row.setColumn(1, new SQLChar(colPermsUUIDStr));
1:ac100d6:             break;
1:b7e13a9:         case TABLEID_INDEX_NUM:
1:b7e13a9:             row = getExecutionFactory().getIndexableRow( 1);
1:b7e13a9:             colPerms = (ColPermsDescriptor) perm;
1:b7e13a9:             tableUUIDStr = colPerms.getTableUUID().toString();
1:eb47bdb:             row.setColumn(1, new SQLChar(tableUUIDStr));
1:ac100d6:             break;
1:b7730e4:         }
1:b7730e4:         return row;
1:b7730e4:     } // end of buildIndexKeyRow
1:b7730e4:     
1:55f1cc9:     public int getPrimaryKeyIndexNumber()
1:b7730e4:     {
1:b7730e4:         return GRANTEE_TABLE_TYPE_GRANTOR_INDEX_NUM;
1:b7730e4:     }
1:b7730e4: 
1:b7730e4:     /**
1:b7730e4:      * Or a set of permissions in with a row from this catalog table
1:b7730e4:      *
1:b7730e4:      * @param row an existing row
1:b7730e4:      * @param perm a permission descriptor of the appropriate class for this PermissionsCatalogRowFactory class.
1:b7730e4:      * @param colsChanged An array with one element for each column in row. It is updated to
1:b7730e4:      *                    indicate which columns in row were changed
1:b7730e4:      *
1:b7730e4:      * @return The number of columns that were changed.
1:b7730e4:      *
1:b7730e4:      * @exception StandardException standard error policy
1:b7730e4:      */
1:b7730e4:     public int orPermissions( ExecRow row, PermissionsDescriptor perm, boolean[] colsChanged)
1:b7730e4:         throws StandardException
1:b7730e4:     {
1:b7730e4:         ColPermsDescriptor colPerms = (ColPermsDescriptor) perm;
1:b7730e4:         FormatableBitSet existingColSet = (FormatableBitSet) row.getColumn( COLUMNS_COL_NUM).getObject();
1:b7730e4:         FormatableBitSet newColSet = colPerms.getColumns();
1:b7730e4: 
1:b7730e4:         boolean changed = false;
1:b7730e4:         for( int i = newColSet.anySetBit(); i >= 0; i = newColSet.anySetBit(i))
1:b7730e4:         {
1:b7730e4:             if( ! existingColSet.get(i))
1:b7730e4:             {
1:b7730e4:                 existingColSet.set( i);
1:b7730e4:                 changed = true;
1:b7730e4:             }
1:b7730e4:         }
1:b7730e4:         if( changed)
1:b7730e4:         {
1:b7730e4:             colsChanged[ COLUMNS_COL_NUM - 1] = true;
1:b7730e4:             return 1;
1:b7730e4:         }
1:b7730e4:         return 0;
1:b7730e4:     } // end of orPermissions
1:b7730e4: 
1:b7730e4:     /**
1:b7730e4:      * Remove a set of permissions from a row from this catalog table
1:b7730e4:      *
1:b7730e4:      * @param row an existing row
1:b7730e4:      * @param perm a permission descriptor of the appropriate class for this PermissionsCatalogRowFactory class.
1:b7730e4:      * @param colsChanged An array with one element for each column in row. It is updated to
1:b7730e4:      *                    indicate which columns in row were changed
1:b7730e4:      *
1:b7730e4:      * @return -1 if there are no permissions left in the row, otherwise the number of columns that were changed.
1:b7730e4:      *
1:b7730e4:      * @exception StandardException standard error policy
1:b7730e4:      */
1:b7730e4:     public int removePermissions( ExecRow row, PermissionsDescriptor perm, boolean[] colsChanged)
1:b7730e4:         throws StandardException
1:b7730e4:     {
1:b7730e4:         ColPermsDescriptor colPerms = (ColPermsDescriptor) perm;
1:b7730e4:         FormatableBitSet removeColSet = colPerms.getColumns();
1:b7730e4:         if( removeColSet == null)
1:b7730e4:             // remove all of them
1:b7730e4:             return -1;
1:b7730e4:         
1:b7730e4:         FormatableBitSet existingColSet = (FormatableBitSet) row.getColumn( COLUMNS_COL_NUM).getObject();
1:b7730e4: 
1:b7730e4:         boolean changed = false;
1:b7730e4:         for( int i = removeColSet.anySetBit(); i >= 0; i = removeColSet.anySetBit(i))
1:b7730e4:         {
1:b7730e4:             if( existingColSet.get(i))
1:b7730e4:             {
1:b7730e4:                 existingColSet.clear( i);
1:b7730e4:                 changed = true;
1:b7730e4:             }
1:b7730e4:         }
1:b7730e4:         if( changed)
1:b7730e4:         {
1:b7730e4:             colsChanged[ COLUMNS_COL_NUM - 1] = true;
1:b7730e4:             if( existingColSet.anySetBit() < 0)
1:b7730e4:                 return -1; // No column privileges left
1:b7730e4:             return 1; // A change, but there are some privileges left
1:b7730e4:         }
1:b7730e4:         return 0; // no change
1:b7730e4:     } // end of removePermissions
1:7a1a699:     
1:7a1a699: 	/** 
1:7a1a699: 	 * @see PermissionsCatalogRowFactory#setUUIDOfThePassedDescriptor
1:7a1a699: 	 */
1:7a1a699:     public void setUUIDOfThePassedDescriptor(ExecRow row, PermissionsDescriptor perm)
1:7a1a699:     throws StandardException
1:7a1a699:     {
1:7a1a699:         DataValueDescriptor existingPermDVD = row.getColumn(COLPERMSID_COL_NUM);
1:7a1a699:         perm.setUUID(getUUIDFactory().recreateUUID(existingPermDVD.getString()));
1:7a1a699:     }
1:b7730e4: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:4309044
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.UserType;
/////////////////////////////////////////////////////////////////////////
1:         row.setColumn( COLUMNS_COL_NUM, new UserType( (Object) columns));
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:2a5922a
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:ee59de8
/////////////////////////////////////////////////////////////////////////
1:     public static final int
1:         GRANTEE_COL_NUM_IN_GRANTEE_TABLE_TYPE_GRANTOR_INDEX = 1;
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:6870e87
/////////////////////////////////////////////////////////////////////////
1:     SYSCOLPERMSRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf)
1: 		super(uuidf,ef,dvf);
commit:082459a
/////////////////////////////////////////////////////////////////////////
commit:eb47bdb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.SQLChar;
/////////////////////////////////////////////////////////////////////////
1:         row.setColumn( COLPERMSID_COL_NUM, new SQLChar(colPermID));
1:         row.setColumn( TABLEID_COL_NUM, new SQLChar(tableID));
1:         row.setColumn( TYPE_COL_NUM, new SQLChar(type));
/////////////////////////////////////////////////////////////////////////
1:             row.setColumn(2, new SQLChar(tableUUIDStr));
1:             row.setColumn(3, new SQLChar(colPerms.getType()));
1:             row.setColumn(1, new SQLChar(colPermsUUIDStr));
1:             row.setColumn(1, new SQLChar(tableUUIDStr));
commit:7aa6fa8
/////////////////////////////////////////////////////////////////////////
commit:ea3f2e4
/////////////////////////////////////////////////////////////////////////
1: class SYSCOLPERMSRowFactory extends PermissionsCatalogRowFactory
/////////////////////////////////////////////////////////////////////////
1:     static final int GRANTEE_TABLE_TYPE_GRANTOR_INDEX_NUM = 0;
1:     static final int COLPERMSID_INDEX_NUM = 1;
1:     static final int TABLEID_INDEX_NUM = 2;
/////////////////////////////////////////////////////////////////////////
0:     SYSCOLPERMSRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf,
/////////////////////////////////////////////////////////////////////////
1:     public SystemColumn[] buildColumnList()
1:         return new SystemColumn[] {
1:            SystemColumnImpl.getUUIDColumn("COLPERMSID", false),
1:            SystemColumnImpl.getIdentifierColumn("GRANTEE", false),
1:            SystemColumnImpl.getIdentifierColumn("GRANTOR", false),
1:            SystemColumnImpl.getUUIDColumn("TABLEID", false),
1:            SystemColumnImpl.getIndicatorColumn("TYPE"),
1:            SystemColumnImpl.getJavaColumn("COLUMNS",
1:                    "org.apache.derby.iapi.services.io.FormatableBitSet", false)    
1:         };
1:     }
commit:c2ff613
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 		initInfo(COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, indexUniqueness, uuids);
commit:55f1cc9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public int getPrimaryKeyIndexNumber()
commit:7a1a699
/////////////////////////////////////////////////////////////////////////
1:     
1: 	/** 
1: 	 * @see PermissionsCatalogRowFactory#setUUIDOfThePassedDescriptor
1: 	 */
1:     public void setUUIDOfThePassedDescriptor(ExecRow row, PermissionsDescriptor perm)
1:     throws StandardException
1:     {
1:         DataValueDescriptor existingPermDVD = row.getColumn(COLPERMSID_COL_NUM);
1:         perm.setUUID(getUUIDFactory().recreateUUID(existingPermDVD.getString()));
1:     }
commit:ac100d6
/////////////////////////////////////////////////////////////////////////
1: 	private static final int COLPERMSID_COL_NUM = 1;
/////////////////////////////////////////////////////////////////////////
0:     public static final int COLPERMSID_INDEX_NUM = 1;
1: 		{ GRANTEE_COL_NUM, TABLEID_COL_NUM, TYPE_COL_NUM, GRANTOR_COL_NUM},
0: 		{ COLPERMSID_COL_NUM }
0: 		{"GRANTEE", "TABLEID", "TYPE", "GRANTOR"},
0: 		{"COLPERMSID"}
0:     private static final boolean[] indexUniqueness = { true, true};
1: 		,"787c0020-0103-0e39-b8e7-00000010f010"	// index1
1: 		,"c9a3808d-010c-42a2-ae15-0000000f67f8" //index2
/////////////////////////////////////////////////////////////////////////
0:         row.setColumn( COLPERMSID_COL_NUM, dvf.getCharDataValue(colPermID));
/////////////////////////////////////////////////////////////////////////
1:         String colPermsUUIDString = row.getColumn( COLPERMSID_COL_NUM).getString();
/////////////////////////////////////////////////////////////////////////
0:             columnList[ COLPERMSID_COL_NUM - 1] =
0:                                       COLPERMSID_COL_NUM,
/////////////////////////////////////////////////////////////////////////
1:         case COLPERMSID_INDEX_NUM:
0:             row.setColumn(1, getDataValueFactory().getNullChar( (StringDataValue) null)); // COLPERMSID
1:             break;
/////////////////////////////////////////////////////////////////////////
0:         case COLPERMSID_INDEX_NUM:
1:             row = getExecutionFactory().getIndexableRow( 1);
1:             String colPermsUUIDStr = perm.getObjectID().toString();
0:             row.setColumn(1, getDataValueFactory().getCharDataValue( colPermsUUIDStr));
1:             break;
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
0: 	private static final int SYSCOLPERMS_COLPERMSID = 1;
1:     private static final int GRANTEE_COL_NUM = 2;
1:     private static final int GRANTOR_COL_NUM = 3;
1:     private static final int TABLEID_COL_NUM = 4;
1:     private static final int TYPE_COL_NUM = 5;
0:     private static final int COLUMNS_COL_NUM = 6;
1:     private static final int COLUMN_COUNT = 6;
/////////////////////////////////////////////////////////////////////////
1:         UUID						oid;
1:         String colPermID = null;
/////////////////////////////////////////////////////////////////////////
1:             oid = cpd.getUUID();
1:             if ( oid == null )
1:             {
1:             	oid = getUUIDFactory().createUUID();
1:             	cpd.setUUID(oid);           
1:             }
1:             colPermID = oid.toString();
/////////////////////////////////////////////////////////////////////////
0:         row.setColumn( SYSCOLPERMS_COLPERMSID, dvf.getCharDataValue(colPermID));
/////////////////////////////////////////////////////////////////////////
0:         String colPermsUUIDString = row.getColumn( SYSCOLPERMS_COLPERMSID).getString();
1:         UUID colPermsUUID = getUUIDFactory().recreateUUID(colPermsUUIDString);
/////////////////////////////////////////////////////////////////////////
1:         ColPermsDescriptor colPermsDesc =
1: 	        new ColPermsDescriptor( dataDictionary, 
1:                     getAuthorizationID( row, GRANTEE_COL_NUM),
1:                     getAuthorizationID( row, GRANTOR_COL_NUM),
1:                     tableUUID, type, columns);
1:         colPermsDesc.setUUID(colPermsUUID);
1:         return colPermsDesc;
/////////////////////////////////////////////////////////////////////////
0:             columnList[ SYSCOLPERMS_COLPERMSID - 1] =
0:                 new SystemColumnImpl( convertIdCase( "COLPERMSID"),
0:                                       SYSCOLPERMS_COLPERMSID,
0:                                       0, // precision
0:                                       0, // scale
0:                                       false, // nullability
0:                                       "CHAR",
0:                                       true,
0:                                       36);
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:626d315
/////////////////////////////////////////////////////////////////////////
1:     protected static final int COLUMNS_COL_NUM = 6;
1:     protected static final int TOTAL_NUM_OF_INDEXES = 3;
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f739ad1
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b7e13a9
/////////////////////////////////////////////////////////////////////////
0:     public static final int TABLEID_INDEX_NUM = 2;
1: 		{ COLPERMSID_COL_NUM },
1: 		{ TABLEID_COL_NUM }
0: 		{"COLPERMSID"},
0: 		{"TABLEID"}
1:     private static final boolean[] indexUniqueness = { true, true, false};
/////////////////////////////////////////////////////////////////////////
1: 		,"80220011-010c-bc85-060d-000000109ab8" //index3
/////////////////////////////////////////////////////////////////////////
1:         case TABLEID_INDEX_NUM:
0:             row.setColumn(1, getDataValueFactory().getNullChar( (StringDataValue) null)); // TABLEID
1:             break;
/////////////////////////////////////////////////////////////////////////
0:         case TABLEID_INDEX_NUM:
1:             row = getExecutionFactory().getIndexableRow( 1);
1:             colPerms = (ColPermsDescriptor) perm;
1:             tableUUIDStr = colPerms.getTableUUID().toString();
0:             row.setColumn(1, getDataValueFactory().getCharDataValue( tableUUIDStr));
0:             break;
commit:b7730e4
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.sql.catalog.SYSCOLPERMSRowFactory
1: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.catalog;
1: 
0: import org.apache.derby.iapi.sql.dictionary.PermissionsCatalogRowFactory;
1: import org.apache.derby.iapi.sql.dictionary.ColPermsDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.StatisticsDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.SystemColumn;
1: import org.apache.derby.iapi.sql.dictionary.TupleDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.PermissionsDescriptor;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.iapi.types.DataValueFactory;
1: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.NumberDataValue;
1: import org.apache.derby.iapi.types.StringDataValue;
1: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.catalog.Statistics;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: import java.sql.Timestamp;
1: 
1: /**
1:  * Factory for creating a SYSCOLPERMS row.
1:  *
1:  */
1: 
0: public class SYSCOLPERMSRowFactory extends PermissionsCatalogRowFactory
1: {
1: 	static final String TABLENAME_STRING = "SYSCOLPERMS";
1: 
1:     // Column numbers for the SYSCOLPERMS table. 1 based
0:     private static final int GRANTEE_COL_NUM = 1;
0:     private static final int GRANTOR_COL_NUM = 2;
0:     private static final int TABLEID_COL_NUM = 3;
0:     private static final int TYPE_COL_NUM = 4;
0:     private static final int COLUMNS_COL_NUM = 5;
0:     private static final int COLUMN_COUNT = 5;
1: 
0:     public static final int GRANTEE_TABLE_TYPE_GRANTOR_INDEX_NUM = 0;
1: 	private static final int[][] indexColumnPositions = 
1: 	{ 
0: 		{ GRANTEE_COL_NUM, TABLEID_COL_NUM, TYPE_COL_NUM, GRANTOR_COL_NUM}
1: 	};
0: 	private static final String[][] indexColumnNames =
1: 	{
0: 		{"GRANTEE", "TABLEID", "TYPE", "GRANTOR"}
1: 	};
0:     private static final boolean[] indexUniqueness = { true};
1: 
1:     private	static final String[] uuids =
1:     {
1:         "286cc01e-0103-0e39-b8e7-00000010f010" // catalog UUID
1: 		,"6074401f-0103-0e39-b8e7-00000010f010"	// heap UUID
0: 		,"787c0020-0103-0e39-b8e7-00000010f010"	// index
1:     };
1: 
0:     private SystemColumn[] columnList;
1: 
0:     public SYSCOLPERMSRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf,
0:                                  boolean convertIdToLower)
1: 	{
0: 		super(uuidf,ef,dvf,convertIdToLower);
0: 		initInfo(COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, indexColumnNames, indexUniqueness, uuids);
1: 	}
1: 
1: 	public ExecRow makeRow(TupleDescriptor td, TupleDescriptor parent) throws StandardException
1: 	{
1:         DataValueDescriptor grantee = null;
1:         DataValueDescriptor grantor = null;
1:         String tableID = null;
1:         String type = null;
1:         FormatableBitSet columns = null;
1: 
1:         if( td == null)
1:         {
1:             grantee = getNullAuthorizationID();
1:             grantor = getNullAuthorizationID();
1:         }
1:         else
1:         {
1:             ColPermsDescriptor cpd = (ColPermsDescriptor) td;
1:             grantee = getAuthorizationID( cpd.getGrantee());
1:             grantor = getAuthorizationID( cpd.getGrantor());
1:             tableID = cpd.getTableUUID().toString();
1:             type = cpd.getType();
1:             columns = cpd.getColumns();
1:         }
1:         ExecRow row = getExecutionFactory().getValueRow( COLUMN_COUNT);
1:         row.setColumn( GRANTEE_COL_NUM, grantee);
1:         row.setColumn( GRANTOR_COL_NUM, grantor);
0:         row.setColumn( TABLEID_COL_NUM, dvf.getCharDataValue( tableID));
0:         row.setColumn( TYPE_COL_NUM, dvf.getCharDataValue( type));
0:         row.setColumn( COLUMNS_COL_NUM, dvf.getDataValue( (Object) columns));
1:         return row;
1:     } // end of makeRow
1: 
1: 	/** builds a tuple descriptor from a row */
1: 	public TupleDescriptor buildDescriptor(ExecRow row,
1:                                            TupleDescriptor parentTuple,
1:                                            DataDictionary	dataDictionary)
1: 		throws StandardException
1:     {
1:         if( SanityManager.DEBUG)
1:             SanityManager.ASSERT( row.nColumns() == COLUMN_COUNT,
1:                                   "Wrong size row passed to SYSCOLPERMSRowFactory.buildDescriptor");
1: 
1:         String tableUUIDString = row.getColumn( TABLEID_COL_NUM).getString();
1:         UUID tableUUID = getUUIDFactory().recreateUUID(tableUUIDString);
1:         String type = row.getColumn( TYPE_COL_NUM).getString();
1:         FormatableBitSet columns = (FormatableBitSet) row.getColumn( COLUMNS_COL_NUM).getObject();
1:         if( SanityManager.DEBUG)
1:             SanityManager.ASSERT( "s".equals( type) || "S".equals( type) ||
1:                                   "u".equals( type) || "U".equals( type) ||
1:                                   "r".equals( type) || "R".equals( type),
1:                                   "Invalid type passed to SYSCOLPERMSRowFactory.buildDescriptor");
1: 
0:         return new ColPermsDescriptor( dataDictionary, 
0:                                        getAuthorizationID( row, GRANTEE_COL_NUM),
0:                                        getAuthorizationID( row, GRANTOR_COL_NUM),
0:                                        tableUUID, type, columns);
1:     } // end of buildDescriptor
1: 
1: 	/** builds a column list for the catalog */
0: 	public SystemColumn[] buildColumnList()
1:     {
0: 		if (columnList == null)
1:         {
0:             columnList = new SystemColumn[ COLUMN_COUNT];
1: 
0:             columnList[ GRANTEE_COL_NUM - 1] =
0:               new SystemColumnImpl( convertIdCase( "GRANTEE"),
0:                                     GRANTEE_COL_NUM,
0:                                     0, // precision
0:                                     0, // scale
0:                                     false, // nullability
0:                                     AUTHORIZATION_ID_TYPE,
0:                                     AUTHORIZATION_ID_IS_BUILTIN_TYPE,
0:                                     AUTHORIZATION_ID_LENGTH);
0:             columnList[ GRANTOR_COL_NUM - 1] =
0:               new SystemColumnImpl( convertIdCase( "GRANTOR"),
0:                                     GRANTOR_COL_NUM,
0:                                     0, // precision
0:                                     0, // scale
0:                                     false, // nullability
0:                                     AUTHORIZATION_ID_TYPE,
0:                                     AUTHORIZATION_ID_IS_BUILTIN_TYPE,
0:                                     AUTHORIZATION_ID_LENGTH);
0:             columnList[ TABLEID_COL_NUM - 1] =
0:               new SystemColumnImpl( convertIdCase( "TABLEID"),
0:                                     TABLEID_COL_NUM,
0:                                     0, // precision
0:                                     0, // scale
0:                                     false, // nullability
0:                                     "CHAR", // dataType
0:                                     true, // built-in type
0:                                     36);
0:             columnList[ TYPE_COL_NUM - 1] =
0:               new SystemColumnImpl( convertIdCase( "TYPE"),
0:                                     TYPE_COL_NUM,
0:                                     0, // precision
0:                                     0, // scale
0:                                     false, // nullability
0:                                     "CHAR", // dataType
0:                                     true, // built-in type
0:                                     1);
0:             columnList[ COLUMNS_COL_NUM - 1] =
0:               new SystemColumnImpl( convertIdCase( "COLUMNS"),
0:                                     COLUMNS_COL_NUM,
0:                                     0, // precision
0:                                     0, // scale
0:                                     false, // nullability
0:                                     "org.apache.derby.iapi.services.io.FormatableBitSet", // datatype
0:                                     false,							// built-in type
0:                                     DataTypeDescriptor.MAXIMUM_WIDTH_UNKNOWN // maxLength
0:                   );
1:         }
0: 		return columnList;
0:     } // end of buildColumnList
1: 
1: 	/**
0: 	 * builds an empty row given for a given index number.
1: 	 */
0:   	public ExecIndexRow buildEmptyIndexRow(int indexNumber,
0:                                            RowLocation rowLocation) 
1:   		throws StandardException
1:     {
0:         ExecIndexRow row = getExecutionFactory().getIndexableRow( indexColumnPositions[indexNumber].length + 1);
0:         row.setColumn( row.nColumns(), rowLocation);
1:         
1:         switch( indexNumber)
1:         {
1:         case GRANTEE_TABLE_TYPE_GRANTOR_INDEX_NUM:
0:             row.setColumn(1, getNullAuthorizationID()); // grantee
0:             row.setColumn(2, getDataValueFactory().getNullChar( (StringDataValue) null)); // table UUID
0:             row.setColumn(3, getDataValueFactory().getNullChar( (StringDataValue) null)); // type
0:             row.setColumn(4, getNullAuthorizationID()); // grantor
0:             break;
1:         }
1:         return row;
0:     } // end of buildEmptyIndexRow
1: 
1: 	/**
1: 	 * builds an index key row for a given index number.
1: 	 */
1:   	public ExecIndexRow buildIndexKeyRow( int indexNumber,
1:                                           PermissionsDescriptor perm) 
1:   		throws StandardException
1:     {
1:         ExecIndexRow row = null;
1:         
1:         switch( indexNumber)
1:         {
1:         case GRANTEE_TABLE_TYPE_GRANTOR_INDEX_NUM:
1:             // RESOLVE We do not support the FOR GRANT OPTION, so column permission rows are unique on the
1:             // grantee, table UUID, and type columns. The grantor column will always have the name of the owner of the
1:             // table. So the index key, used for searching the index, only has grantee, table UUID, and type columns.
1:             // It does not have a grantor column.
1:             //
1:             // If we support FOR GRANT OPTION then there may be multiple table permissions rows for a
1:             // (grantee, tableID, type) combination. We must either handle the multiple rows, which is necessary for
1:             // checking permissions, or add a grantor column to the key, which is necessary for granting or revoking
1:             // permissions.
1:             row = getExecutionFactory().getIndexableRow( 3);
1:             row.setColumn(1, getAuthorizationID( perm.getGrantee()));
1:             ColPermsDescriptor colPerms = (ColPermsDescriptor) perm;
1:             String tableUUIDStr = colPerms.getTableUUID().toString();
0:             row.setColumn(2, getDataValueFactory().getCharDataValue( tableUUIDStr));
0:             row.setColumn(3, getDataValueFactory().getCharDataValue( colPerms.getType()));
0:             break;
1:         }
1:         return row;
1:     } // end of buildIndexKeyRow
1:     
0:     public int getPrimaryIndexNumber()
1:     {
1:         return GRANTEE_TABLE_TYPE_GRANTOR_INDEX_NUM;
1:     }
1: 
1:     /**
1:      * Or a set of permissions in with a row from this catalog table
1:      *
1:      * @param row an existing row
1:      * @param perm a permission descriptor of the appropriate class for this PermissionsCatalogRowFactory class.
1:      * @param colsChanged An array with one element for each column in row. It is updated to
1:      *                    indicate which columns in row were changed
1:      *
1:      * @return The number of columns that were changed.
1:      *
1:      * @exception StandardException standard error policy
1:      */
1:     public int orPermissions( ExecRow row, PermissionsDescriptor perm, boolean[] colsChanged)
1:         throws StandardException
1:     {
1:         ColPermsDescriptor colPerms = (ColPermsDescriptor) perm;
1:         FormatableBitSet existingColSet = (FormatableBitSet) row.getColumn( COLUMNS_COL_NUM).getObject();
1:         FormatableBitSet newColSet = colPerms.getColumns();
1: 
1:         boolean changed = false;
1:         for( int i = newColSet.anySetBit(); i >= 0; i = newColSet.anySetBit(i))
1:         {
1:             if( ! existingColSet.get(i))
1:             {
1:                 existingColSet.set( i);
1:                 changed = true;
1:             }
1:         }
1:         if( changed)
1:         {
1:             colsChanged[ COLUMNS_COL_NUM - 1] = true;
1:             return 1;
1:         }
1:         return 0;
1:     } // end of orPermissions
1: 
1:     /**
1:      * Remove a set of permissions from a row from this catalog table
1:      *
1:      * @param row an existing row
1:      * @param perm a permission descriptor of the appropriate class for this PermissionsCatalogRowFactory class.
1:      * @param colsChanged An array with one element for each column in row. It is updated to
1:      *                    indicate which columns in row were changed
1:      *
1:      * @return -1 if there are no permissions left in the row, otherwise the number of columns that were changed.
1:      *
1:      * @exception StandardException standard error policy
1:      */
1:     public int removePermissions( ExecRow row, PermissionsDescriptor perm, boolean[] colsChanged)
1:         throws StandardException
1:     {
1:         ColPermsDescriptor colPerms = (ColPermsDescriptor) perm;
1:         FormatableBitSet removeColSet = colPerms.getColumns();
1:         if( removeColSet == null)
1:             // remove all of them
1:             return -1;
1:         
1:         FormatableBitSet existingColSet = (FormatableBitSet) row.getColumn( COLUMNS_COL_NUM).getObject();
1: 
1:         boolean changed = false;
1:         for( int i = removeColSet.anySetBit(); i >= 0; i = removeColSet.anySetBit(i))
1:         {
1:             if( existingColSet.get(i))
1:             {
1:                 existingColSet.clear( i);
1:                 changed = true;
1:             }
1:         }
1:         if( changed)
1:         {
1:             colsChanged[ COLUMNS_COL_NUM - 1] = true;
1:             if( existingColSet.anySetBit() < 0)
1:                 return -1; // No column privileges left
1:             return 1; // A change, but there are some privileges left
1:         }
1:         return 0; // no change
1:     } // end of removePermissions
1: }
============================================================================