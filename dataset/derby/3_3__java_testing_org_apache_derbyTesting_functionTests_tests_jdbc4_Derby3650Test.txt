1:0da1e72: package org.apache.derbyTesting.functionTests.tests.jdbc4;
29:0da1e72: 
1:0da1e72: import java.io.IOException;
1:0da1e72: import java.io.InputStream;
1:0da1e72: import java.io.Reader;
1:0da1e72: import java.sql.Blob;
1:0da1e72: import java.sql.Clob;
1:0da1e72: import java.sql.Connection;
1:0da1e72: import java.sql.PreparedStatement;
1:0da1e72: import java.sql.ResultSet;
1:0da1e72: import java.sql.SQLException;
1:0da1e72: import java.sql.Statement;
1:0da1e72: import java.util.Arrays;
1:0da1e72: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:0da1e72: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:0da1e72: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:0da1e72: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:0da1e72: import org.apache.derbyTesting.junit.TestConfiguration;
1:ea0e6d3: 
1:0da1e72: /*
1:0da1e72: Class org.apache.derbyTesting.functionTests.tests.jdbc4.Derby3650Test
1:0da1e72: 
1:0da1e72: Licensed to the Apache Software Foundation (ASF) under one or more
1:0da1e72: contributor license agreements.  See the NOTICE file distributed with
1:0da1e72: this work for additional information regarding copyright ownership.
1:0da1e72: The ASF licenses this file to you under the Apache License, Version 2.0
1:0da1e72: (the "License"); you may not use this file except in compliance with
1:0da1e72: the License.  You may obtain a copy of the License at
1:0da1e72: 
1:0da1e72:    http://www.apache.org/licenses/LICENSE-2.0
1:0da1e72: 
1:0da1e72: Unless required by applicable law or agreed to in writing, software
1:0da1e72: distributed under the License is distributed on an "AS IS" BASIS,
1:0da1e72: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:0da1e72: See the License for the specific language governing permissions and
1:0da1e72: limitations under the License.
1:0da1e72: 
2:0da1e72: */
1:ea0e6d3: 
2:0da1e72: /** 
1:0da1e72:  * These are tests to test the cases for DERBY-3650.
1:0da1e72:  * The tests won't pass until that bug is fixed. 
1:0da1e72:  */
1:0da1e72: 
1:ea0e6d3: public class Derby3650Test extends BaseJDBCTestCase 
1:ea0e6d3: {
1:ea0e6d3:     /**************************************************************************
1:ea0e6d3:      * Fields of the class
1:ea0e6d3:      **************************************************************************
1:ea0e6d3:      */
1:0da1e72: 
1:ea0e6d3:     // DERBY-3749 causes tests that commit after looking at the stream to 
1:ea0e6d3:     // break while trying to access the streams in subsequent rows.  When
1:ea0e6d3:     // that bug gets fixed, enable these tests.
1:ea0e6d3:     private static final boolean runDerby3749tests = false;
1:ea0e6d3: 
1:ea0e6d3:     /**************************************************************************
1:ea0e6d3:      * Constructors for This class:
1:ea0e6d3:      **************************************************************************
1:ea0e6d3:      */
1:ea0e6d3: 
1:ea0e6d3:     public Derby3650Test(String name) 
1:ea0e6d3:     {
1:0da1e72:         super(name);
8:0da1e72:     }
1:0da1e72:     
1:ea0e6d3:     public void setUp() 
1:ea0e6d3:         throws SQLException
1:ea0e6d3:     {
1:0da1e72:         getConnection().setAutoCommit(false);
1:0da1e72:     }
1:ea0e6d3: 
1:0da1e72: 
1:ea0e6d3:     /**************************************************************************
1:ea0e6d3:      * Private/Protected methods of This class:
1:ea0e6d3:      **************************************************************************
1:0da1e72:      */
1:ea0e6d3: 
1:ea0e6d3:     /**
1:ea0e6d3:      * Test select of multiple rows containing single clob column.
1:ea0e6d3:      * <p>
1:ea0e6d3:      * Expects input query to return 3 column's per row, which should be:
1:ea0e6d3:      * (id, length of clob, clob)  
1:ea0e6d3:      *
1:ea0e6d3:      * Will verify clob using verifyClob().
1:ea0e6d3:      * <p>
1:ea0e6d3:      * Runs the query 4 times testing the following combinations:
1:ea0e6d3:      *     free clob on each row = true,  commit xact after each row = true
1:ea0e6d3:      *     free clob on each row = true,  commit xact after each row = false
1:ea0e6d3:      *     free clob on each row = false, commit xact after each row = true
1:ea0e6d3:      *     free clob on each row = false, commit xact after each row = false
1:ea0e6d3:      *
1:ea0e6d3:      * @param query                 query to run.
1:ea0e6d3:      *
1:ea0e6d3:      * @exception  StandardException  Standard exception policy.
1:ea0e6d3:      **/
1:ea0e6d3:     private void runQueryCasesClob(
1:ea0e6d3:     String query)
1:ea0e6d3:         throws SQLException, IOException
1:ea0e6d3:     {
1:ea0e6d3:         if (runDerby3749tests)
1:ea0e6d3:             runQueryClob(query, true,  true);
1:ea0e6d3:         runQueryClob(query, true,  false);
1:ea0e6d3:         if (runDerby3749tests)
1:ea0e6d3:             runQueryClob(query, false, true);
1:ea0e6d3:         runQueryClob(query, false, false);
1:ea0e6d3:     }
1:ea0e6d3: 
1:ea0e6d3:     /**
1:ea0e6d3:      * Test select of multiple rows containing single clob column.
1:ea0e6d3:      * <p>
1:ea0e6d3:      * Expects input query to return 3 column's per row, which should be:
1:ea0e6d3:      * (id, length of clob, clob)  
1:ea0e6d3:      *
1:ea0e6d3:      * Will verify clob using verifyClob().
1:ea0e6d3:      * <p>
1:ea0e6d3:      *
1:ea0e6d3:      * @param query                 query to run.
1:ea0e6d3:      * @param freelob               true if we should free the lob after it has
1:ea0e6d3:      *                              been retrieved and verified.
1:ea0e6d3:      * @param commitAfterLobVerify  true if we should commit after the lob has
1:ea0e6d3:      *                              been retrieved and verified.
1:ea0e6d3:      *
1:ea0e6d3:      * @exception  StandardException  Standard exception policy.
1:ea0e6d3:      **/
1:ea0e6d3:     private void runQueryClob(
1:ea0e6d3:     String  query,
1:ea0e6d3:     boolean freelob,
1:ea0e6d3:     boolean commitAfterLobVerify)
1:ea0e6d3:         throws SQLException, IOException
1:ea0e6d3:     {
1:ea0e6d3:         PreparedStatement ps = prepareStatement(query);
1:ea0e6d3: 
1:0da1e72:         ResultSet rs = ps.executeQuery();
1:ea0e6d3:         while (rs.next()) 
1:ea0e6d3:         {
1:ea0e6d3:             int  id     = rs.getInt(1);
1:ea0e6d3:             int  length = rs.getInt(2);
1:ea0e6d3:             Clob clob   = rs.getClob(3);
1:ea0e6d3: 
1:ea0e6d3:             // verify that stream can be read and is right.
1:ea0e6d3:             verifyClob(
1:ea0e6d3:                 clob.getCharacterStream(), 
1:ea0e6d3:                 length,
1:ea0e6d3:                 new LoopingAlphabetReader(length));
1:ea0e6d3: 
1:0da1e72:             if (freelob)
1:0da1e72:                 clob.free();
1:0da1e72:             if (commitAfterLobVerify)
1:0da1e72:                 commit();
1:0da1e72:         }
1:0da1e72:         rs.close();
1:ea0e6d3:         commit();
1:ea0e6d3: 
1:ea0e6d3:         rs = ps.executeQuery();
1:ea0e6d3:         while (rs.next()) 
1:ea0e6d3:         {
1:ea0e6d3:             int  id     = rs.getInt(1);
1:ea0e6d3:             int  length = rs.getInt(2);
1:ea0e6d3: 
1:ea0e6d3:             // verify that stream can be read and is right.
1:ea0e6d3:             verifyClob(
1:ea0e6d3:                 rs.getCharacterStream(3),
1:ea0e6d3:                 length,
1:ea0e6d3:                 new LoopingAlphabetReader(length));
1:ea0e6d3: 
1:ea0e6d3:             if (commitAfterLobVerify)
1:ea0e6d3:                 commit();
1:0da1e72:         }
1:ea0e6d3:         rs.close();
1:ea0e6d3:         commit();
1:ea0e6d3: 
1:ea0e6d3:         ps.close();
1:ea0e6d3: 
1:0da1e72:     }
1:ea0e6d3: 
1:0da1e72:     /**
1:ea0e6d3:      * Test select of multiple rows containing single blob column.
1:ea0e6d3:      * <p>
1:ea0e6d3:      * Expects input query to return 3 column's per row, which should be:
1:ea0e6d3:      * (id, length of clob, clob)  
1:ea0e6d3:      * Will verify blob using verifyBlob().
1:ea0e6d3:      * <p>
1:ea0e6d3:      * Runs the query 4 times testing the following combinations:
1:ea0e6d3:      *     free blob on each row = true,  commit xact after each row = true
1:ea0e6d3:      *     free blob on each row = true,  commit xact after each row = false
1:ea0e6d3:      *     free blob on each row = false, commit xact after each row = true
1:ea0e6d3:      *     free blob on each row = false, commit xact after each row = false
1:ea0e6d3:      *
1:ea0e6d3:      * @param query                 query to run.
1:ea0e6d3:      *
1:ea0e6d3:      * @exception  StandardException  Standard exception policy.
1:ea0e6d3:      **/
1:ea0e6d3:     private void runQueryCasesBlob(
1:ea0e6d3:     String query)
1:ea0e6d3:         throws SQLException, IOException
1:ea0e6d3:     {
1:ea0e6d3:         if (runDerby3749tests)
1:ea0e6d3:             runQueryBlob(query, true,  true);
1:ea0e6d3:         runQueryBlob(query, true,  false);
1:ea0e6d3:         if (runDerby3749tests)
1:ea0e6d3:             runQueryBlob(query, false, true);
1:ea0e6d3:         runQueryBlob(query, false, false);
1:ea0e6d3:     }
1:ea0e6d3: 
1:ea0e6d3:     /**
1:ea0e6d3:      * Test select of multiple rows containing single blob column.
1:ea0e6d3:      * <p>
1:ea0e6d3:      * Expects input query to return single column per row, which is a blob.
1:ea0e6d3:      * Will verify blob using verifyBlob().
1:ea0e6d3:      * <p>
1:ea0e6d3:      *
1:ea0e6d3:      * @param query                 query to run.
1:ea0e6d3:      * @param freelob               true if we should free the lob after it has
1:ea0e6d3:      *                              been retrieved and verified.
1:ea0e6d3:      * @param commitAfterLobVerify  true if we should commit after the lob has
1:ea0e6d3:      *                              been retrieved and verified.
1:ea0e6d3:      *
1:ea0e6d3:      * @exception  StandardException  Standard exception policy.
1:ea0e6d3:      **/
1:ea0e6d3:     private void runQueryBlob(
1:ea0e6d3:     String  query,
1:ea0e6d3:     boolean freelob,
1:ea0e6d3:     boolean commitAfterLobVerify)
1:ea0e6d3:         throws SQLException, IOException
1:ea0e6d3:     {     
1:ea0e6d3:         PreparedStatement ps = prepareStatement(query);
1:ea0e6d3: 
1:0da1e72:         ResultSet rs = ps.executeQuery();
1:ea0e6d3:         while (rs.next()) 
2:0da1e72:         {
1:ea0e6d3:             Blob blob = rs.getBlob(3);
1:ea0e6d3:             verifyBlob(blob.getBinaryStream(), rs.getInt(2), rs.getInt(1));
1:0da1e72:             if (freelob)
1:0da1e72:                 blob.free();
1:0da1e72:             if (commitAfterLobVerify)
1:0da1e72:                 commit();
1:0da1e72:         }
1:0da1e72:         rs.close();
1:0da1e72:         rollback();
1:0da1e72: 
2:0da1e72:         rs = ps.executeQuery();
1:ea0e6d3:         while (rs.next()) 
1:ea0e6d3:         {
1:ea0e6d3:             // note, the order of "getXXX" is important.  This routine will
1:ea0e6d3:             // fail in network client if the 3rd arg is requested before the
1:ea0e6d3:             // 1st arg.  In that case attempts to read from the stream get
1:ea0e6d3:             // a closed error.  This is why the values are retrieved first
1:ea0e6d3:             // and then passed to the call.
1:ea0e6d3:             int         id      = rs.getInt(1);
1:ea0e6d3:             int         length  = rs.getInt(2);
1:ea0e6d3:             InputStream stream  = rs.getBinaryStream(3);
1:ea0e6d3: 
1:ea0e6d3:             verifyBlob(stream, length, id);
1:ea0e6d3: 
1:ea0e6d3:             if (commitAfterLobVerify)
1:ea0e6d3:                 commit();
1:ea0e6d3:         }
1:ea0e6d3:         rs.close();
1:ea0e6d3:         commit();
1:ea0e6d3: 
1:ea0e6d3:         ps.close();
1:0da1e72:     }
1:ea0e6d3: 
1:ea0e6d3:     private void verifyClob(Reader input, int length, Reader expected) 
1:ea0e6d3:         throws SQLException, IOException 
1:ea0e6d3:     {
1:ea0e6d3:         int input_char;
1:ea0e6d3:         int expect_char;
1:0da1e72:         int charcount = 0;
1:ea0e6d3: 
1:ea0e6d3:         do 
1:ea0e6d3:         {
1:ea0e6d3:             input_char  = input.read();
1:ea0e6d3:             expect_char = expected.read();
1:ea0e6d3: 
1:ea0e6d3:             if (input_char != -1) 
1:ea0e6d3:             {
1:0da1e72:                 charcount++;
1:ea0e6d3:                 if ((char) input_char != expect_char) 
1:ea0e6d3:                 {
1:ea0e6d3:                     fail("Unexpected Character " + (char) input_char + 
1:ea0e6d3:                             " expected " + (char) expect_char);
1:0da1e72:                 }
1:0da1e72:             }
1:ea0e6d3: 
1:ea0e6d3:         } while (input_char != -1) ;
1:ea0e6d3: 
1:ea0e6d3:         if (charcount != length)
1:ea0e6d3:         {
1:ea0e6d3:            fail("Unexpected character count " + charcount + 
1:ea0e6d3:                    "expected: " + length);
1:0da1e72:         }
1:0da1e72:     }
1:0da1e72:     
1:ea0e6d3:     private void verifyBlob(InputStream is, int length, int id) 
1:ea0e6d3:         throws SQLException, IOException 
1:ea0e6d3:     {
1:0da1e72:         int b;
1:0da1e72:         int bytecount = 0;
1:ea0e6d3:         do 
1:ea0e6d3:         {
1:0da1e72:             b = is.read();
1:ea0e6d3:             if (b != -1) 
1:ea0e6d3:             {
1:0da1e72:                 bytecount++;
1:ea0e6d3:                 if ((byte) b != id) 
1:ea0e6d3:                 {
1:ea0e6d3:                     fail("Unexpected byte value " + (byte) b + 
1:ea0e6d3:                             " expected: " + id);
1:0da1e72:                 }
1:0da1e72:             }
1:ea0e6d3:         } while (b != -1);
1:ea0e6d3: 
1:ea0e6d3:         if (bytecount != length)
1:ea0e6d3:         {
1:ea0e6d3:             fail("Unexpected byte count, got " + bytecount + 
1:ea0e6d3:                     "  expected " + length);
1:ea0e6d3:         }
1:0da1e72:     }
1:ea0e6d3: 
1:ea0e6d3:     /**************************************************************************
1:ea0e6d3:      * Public Methods of This class:
1:ea0e6d3:      **************************************************************************
1:ea0e6d3:      */
1:ea0e6d3: 
1:ea0e6d3: 
1:ea0e6d3:     /**
1:ea0e6d3:      * Test a nested loop join for clobs.
1:ea0e6d3:      * <p>
1:ea0e6d3:      * Test case of a 1 to many row join where the 1 row contains and returns
1:ea0e6d3:      * a clob as a stream.  Before fix for DERBY-3650 each row returned from
1:ea0e6d3:      * this join would contain a reference to the same stream which would fail
1:ea0e6d3:      * in various ways depending on commit, free, and reading the stream.
2:ea0e6d3:      *
1:ea0e6d3:      * @throws SQLException
1:ea0e6d3:      * @throws IOException
1:ea0e6d3:      */
1:ea0e6d3:     public void test1ToManyJoinClob() 
1:ea0e6d3:         throws SQLException, IOException     
1:ea0e6d3:     {           
1:ea0e6d3:         runQueryCasesClob(
1:ea0e6d3:             "select testClob.id, length, c from testClob " + 
1:ea0e6d3:                 "join jointab on jointab.id = testClob.id");
1:ea0e6d3:     }
1:ea0e6d3: 
1:ea0e6d3:     /**
1:ea0e6d3:      * Test a nested loop join for blobs.
1:ea0e6d3:      * <p>
1:ea0e6d3:      * Test case of a 1 to many row join where the 1 row contains and returns
1:ea0e6d3:      * a blob as a stream.  Before fix for DERBY-3650 each row returned from
1:ea0e6d3:      * this join would contain a reference to the same stream which would fail
1:ea0e6d3:      * in various ways depending on commit, free, and reading the stream.
1:ea0e6d3:      *
1:ea0e6d3:      * @throws SQLException
1:ea0e6d3:      * @throws IOException
1:ea0e6d3:      */
1:ea0e6d3:     public void test1ToManyJoinBlob() 
1:ea0e6d3:         throws SQLException, IOException     
1:ea0e6d3:     {     
1:ea0e6d3:         runQueryCasesBlob(
1:ea0e6d3:             "select testBlob.id, length, c from testBlob " +
1:ea0e6d3:                 "join jointab on jointab.id = testBlob.id");
1:ea0e6d3:     }
1:ea0e6d3: 
1:ea0e6d3: 
1:ea0e6d3:     public void test1ToManyHashJoinClob() 
1:ea0e6d3:         throws SQLException, IOException     
1:ea0e6d3:     {           
1:ea0e6d3:         runQueryCasesClob(
1:ea0e6d3:             "select testClob.id, length, c from " + 
1:ea0e6d3:             "--DERBY-PROPERTIES joinOrder=FIXED \n" + 
1:ea0e6d3:             "testClob --DERBY-PROPERTIES joinStrategy=HASH \n" + 
1:ea0e6d3:             "join jointab on jointab.id = testClob.id");
1:ea0e6d3: 
1:ea0e6d3:         runQueryCasesClob(
1:ea0e6d3:             "select jointab.id, length, c from " + 
1:ea0e6d3:             "--DERBY-PROPERTIES joinOrder=FIXED \n" + 
1:ea0e6d3:             "jointab --DERBY-PROPERTIES joinStrategy=HASH \n" + 
1:ea0e6d3:             "join testClob on jointab.id = testClob.id");
1:ea0e6d3:     }
1:ea0e6d3: 
1:ea0e6d3:     public void test1ToManyHashJoinBlob() 
1:ea0e6d3:         throws SQLException, IOException     
1:ea0e6d3:     {           
1:ea0e6d3:         runQueryCasesBlob(
1:ea0e6d3:             "select testBlob.id, length, c from " + 
1:ea0e6d3:             "--DERBY-PROPERTIES joinOrder=FIXED \n" + 
1:ea0e6d3:             "testBlob --DERBY-PROPERTIES joinStrategy=HASH \n" + 
1:ea0e6d3:             "join jointab on jointab.id = testBlob.id");
1:ea0e6d3: 
1:ea0e6d3:         runQueryCasesBlob(
1:ea0e6d3:             "select testBlob.id, length, c from " + 
1:ea0e6d3:             "--DERBY-PROPERTIES joinOrder=FIXED \n" + 
1:ea0e6d3:             "jointab --DERBY-PROPERTIES joinStrategy=HASH \n" + 
1:ea0e6d3:             "join testBlob on jointab.id = testBlob.id");
1:ea0e6d3:     }
1:ea0e6d3: 
1:ea0e6d3:     public void test1ToManyleftOuterJoinClob() 
1:ea0e6d3:         throws SQLException, IOException     
1:ea0e6d3:     {           
1:ea0e6d3:         runQueryCasesClob(
1:ea0e6d3:             "select testClob.id, length, c from testClob " + 
1:ea0e6d3:                 "left outer join jointab on jointab.id = testClob.id");
1:ea0e6d3: 
1:ea0e6d3:         runQueryCasesClob(
1:ea0e6d3:             "select jointab.id, length, c from jointab " + 
1:ea0e6d3:                 "left outer join testClob on jointab.id = testClob.id");
1:ea0e6d3:     }
1:ea0e6d3: 
1:ea0e6d3:     public void test1ToManyleftOuterJoinBlob() 
1:ea0e6d3:         throws SQLException, IOException     
1:ea0e6d3:     {           
1:ea0e6d3:         runQueryCasesBlob(
1:ea0e6d3:             "select testBlob.id, length, c from testBlob " + 
1:ea0e6d3:                 "left outer join jointab on jointab.id = testBlob.id");
1:ea0e6d3:         runQueryCasesBlob(
1:ea0e6d3:             "select jointab.id, length, c from jointab " + 
1:ea0e6d3:                 "left outer join testBlob on jointab.id = testBlob.id");
1:ea0e6d3:     }
1:ea0e6d3: 
1:ea0e6d3: 
1:ea0e6d3:     /**
1:ea0e6d3:      * Test straight select from a heap scan of multiple rows containing clobs.
1:ea0e6d3:      *
1:ea0e6d3:      * @throws SQLException
1:ea0e6d3:      * @throws IOException
1:ea0e6d3:      */
1:ea0e6d3:     public void testClobSelect() 
1:ea0e6d3:         throws SQLException, IOException     
1:ea0e6d3:     {           
1:ea0e6d3:         runQueryCasesClob("select id, length, c from testMultipleClob");
1:ea0e6d3:     }
1:ea0e6d3: 
1:ea0e6d3:     /**
1:ea0e6d3:      * Test straight select from a heap scan of multiple rows containing blobs.
1:ea0e6d3:      *
1:ea0e6d3:      * @throws SQLException
1:ea0e6d3:      * @throws IOException
1:ea0e6d3:      */
1:ea0e6d3:     public void testBlobSelect() 
1:ea0e6d3:         throws SQLException, IOException     
1:ea0e6d3:     {     
1:ea0e6d3:         runQueryCasesBlob("select id, length, c from testMultipleBlob");
1:0da1e72:     }
1:0da1e72:     
1:ea0e6d3:     private static void initializeClobTables(Statement stmt) 
1:ea0e6d3:         throws SQLException, IOException
1:ea0e6d3:     {
1:ea0e6d3:         // CLOB TEST SETUP...........................................
1:ea0e6d3:         stmt.executeUpdate(
1:ea0e6d3:             "CREATE TABLE testClob (id int, length int, c CLOB(2M))");
1:ea0e6d3: 
1:ea0e6d3:         Connection conn = stmt.getConnection();
1:ea0e6d3:         PreparedStatement ps = 
1:ea0e6d3:             conn.prepareStatement("INSERT INTO TestClob VALUES(?,?,?)");
1:ea0e6d3: 
1:ea0e6d3:         // insert 4 rows into "left" table containing clobs of join: 
1:ea0e6d3:         //     (1, clob), (1, clob), (2, clob), (2, clob)
1:ea0e6d3:         ps.setInt(            1, 1);
1:ea0e6d3:         ps.setInt(            2, 40000);
1:ea0e6d3:         ps.setCharacterStream(3, new LoopingAlphabetReader(40000));
1:ea0e6d3:         ps.executeUpdate();
1:ea0e6d3: 
1:ea0e6d3:         ps.setInt(            1, 1);
1:ea0e6d3:         ps.setInt(            2, 40001);
1:ea0e6d3:         ps.setCharacterStream(3, new LoopingAlphabetReader(40001));
1:ea0e6d3:         ps.executeUpdate();
1:ea0e6d3: 
1:ea0e6d3:         ps.setInt(            1, 2);
1:ea0e6d3:         ps.setInt(            2, 40002);
1:ea0e6d3:         ps.setCharacterStream(3, new LoopingAlphabetReader(40002));
1:ea0e6d3:         ps.executeUpdate();
1:ea0e6d3: 
1:ea0e6d3:         ps.setInt(            1, 2);
1:ea0e6d3:         ps.setInt(            2, 40003);
1:ea0e6d3:         ps.setCharacterStream(3, new LoopingAlphabetReader(40003));
1:ea0e6d3:         ps.executeUpdate();
1:ea0e6d3:         ps.close();
1:ea0e6d3: 
1:ea0e6d3:         stmt.executeUpdate(
1:ea0e6d3:             "CREATE TABLE testMultipleClob (id int, length int, c CLOB(2M))");
1:ea0e6d3:         ps = conn.prepareStatement(
1:ea0e6d3:                 "INSERT INTO testMultipleClob VALUES(?,?,?)");
1:ea0e6d3: 
1:ea0e6d3:         for (int i = 0; i < 100; i++)
1:ea0e6d3:         {
1:ea0e6d3:             ps.setInt(            1, i);
1:ea0e6d3:             ps.setInt(            2, 40000 + i);
1:ea0e6d3:             ps.setCharacterStream(3, new LoopingAlphabetReader(40000 + i));
1:ea0e6d3:             ps.executeUpdate();
1:ea0e6d3:         }
1:ea0e6d3:         ps.close();
1:ea0e6d3:         conn.commit();
1:ea0e6d3:     }
1:ea0e6d3: 
1:ea0e6d3:     private static void initializeBlobTables(Statement stmt) 
1:ea0e6d3:         throws SQLException, IOException
1:ea0e6d3:     {
1:ea0e6d3:         // BLOB TEST SETUP...........................................
1:ea0e6d3:         stmt.executeUpdate(
1:ea0e6d3:                 "CREATE TABLE testBlob (id int, length int, c BLOB(2M))");
1:ea0e6d3: 
1:ea0e6d3:         Connection conn = stmt.getConnection();
1:ea0e6d3:         PreparedStatement ps = 
1:ea0e6d3:             conn.prepareStatement("INSERT INTO TestBlob VALUES(?,?,?)");
1:ea0e6d3: 
1:ea0e6d3:         // insert 4 rows into "left" blob of join: 
1:ea0e6d3:         //     (1, 40000, blob), (1, 40001, blob), 
1:ea0e6d3:         //     (2, 40002, blob), (2, 40003, blob)
1:ea0e6d3:         byte[] mybytes = new byte[40000];
1:ea0e6d3:         Arrays.fill(mybytes, (byte) 1);
1:ea0e6d3:         ps.setInt(  1, 1);
1:ea0e6d3:         ps.setInt(  2, 40000);
1:ea0e6d3:         ps.setBytes(3, mybytes);
1:ea0e6d3:         ps.executeUpdate();
1:ea0e6d3: 
1:ea0e6d3:         mybytes = new byte[40001];
1:ea0e6d3:         Arrays.fill(mybytes, (byte) 1);
1:ea0e6d3:         ps.setInt(  1, 1);
1:ea0e6d3:         ps.setInt(  2, 40001);
1:ea0e6d3:         ps.setBytes(3, mybytes);
1:ea0e6d3:         ps.executeUpdate();
1:ea0e6d3: 
1:ea0e6d3:         mybytes = new byte[40002];
1:ea0e6d3:         Arrays.fill(mybytes, (byte) 2);
1:ea0e6d3:         ps.setInt(  1, 2);
1:ea0e6d3:         ps.setInt(  2, 40002);
1:ea0e6d3:         ps.setBytes(3, mybytes);
1:ea0e6d3:         ps.executeUpdate();
1:ea0e6d3: 
1:ea0e6d3:         mybytes = new byte[40003];
1:ea0e6d3:         Arrays.fill(mybytes, (byte) 2);
1:ea0e6d3:         ps.setInt(  1, 2);
1:ea0e6d3:         ps.setInt(  2, 40003);
1:ea0e6d3:         ps.setBytes(3, mybytes);
1:ea0e6d3:         ps.executeUpdate();
1:ea0e6d3: 
1:ea0e6d3:         ps.close();
1:ea0e6d3: 
1:ea0e6d3:         // insert 4 rows into "right" table of join: 
1:ea0e6d3:         stmt.executeUpdate("CREATE TABLE jointab (id int)");
1:ea0e6d3:         stmt.executeUpdate("INSERT INTO jointab values(1)");
1:ea0e6d3:         stmt.executeUpdate("INSERT INTO jointab values(1)");
1:ea0e6d3:         stmt.executeUpdate("INSERT INTO jointab values(2)");
1:ea0e6d3:         stmt.executeUpdate("INSERT INTO jointab values(2)");
1:ea0e6d3: 
1:ea0e6d3:         stmt.executeUpdate(
1:ea0e6d3:             "CREATE TABLE testMultipleBlob (id int, length int, c BLOB(2M))");
1:ea0e6d3:         ps = conn.prepareStatement(
1:ea0e6d3:                 "INSERT INTO testMultipleBlob VALUES(?,?,?)");
1:ea0e6d3: 
1:ea0e6d3:         for (int i = 0; i < 100; i++)
1:ea0e6d3:         {
1:ea0e6d3:             mybytes = new byte[40000 + i];
1:ea0e6d3:             Arrays.fill(mybytes, (byte) i);
1:ea0e6d3: 
1:ea0e6d3:             ps.setInt(  1, i);
1:ea0e6d3:             ps.setInt(  2, 40000 + i);
1:ea0e6d3:             ps.setBytes(3,mybytes);
1:ea0e6d3:             ps.executeUpdate();
1:ea0e6d3:         }
1:ea0e6d3:         ps.close();
1:ea0e6d3:         conn.commit();
1:ea0e6d3:     }
1:ea0e6d3: 
1:0da1e72:     
1:0da1e72:     protected static Test baseSuite(String name) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:0da1e72:         suite.addTestSuite(Derby3650Test.class);
1:0da1e72:         return new CleanDatabaseTestSetup(
1:0da1e72:                 DatabasePropertyTestSetup.setLockTimeouts(suite, 2, 4)) 
1:0da1e72:         {
1:0da1e72:             /**
1:0da1e72:              * Creates the tables used in the test cases.
1:0da1e72:              * @exception SQLException if a database error occurs
1:0da1e72:              */
1:0da1e72:             protected void decorateSQL(Statement stmt) throws SQLException
1:0da1e72:             {
1:ea0e6d3:                 try
1:ea0e6d3:                 {
1:ea0e6d3:                     initializeClobTables(stmt);
1:ea0e6d3:                     initializeBlobTables(stmt);
1:ea0e6d3:                 }
1:ea0e6d3:                 catch (IOException ioe)
1:ea0e6d3:                 {
1:ea0e6d3:                     fail("Unexpected I/O exception during setup: " + ioe);
1:ea0e6d3:                 }
1:0da1e72:             }
1:0da1e72:         };
1:0da1e72:     }
1:ea0e6d3: 
1:ea0e6d3: 
1:ea0e6d3:     public static Test suite() 
1:ea0e6d3:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("Derby3650Test");
1:0da1e72:         suite.addTest(baseSuite("Derby3650Test:embedded"));
1:0da1e72:         suite.addTest(TestConfiguration.clientServerDecorator(
1:0da1e72:             baseSuite("Derby3650Test:client")));
1:0da1e72:         return suite;
1:0da1e72: 
1:0da1e72:     }
1:0da1e72: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("Derby3650Test");
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:f025541
/////////////////////////////////////////////////////////////////////////
commit:ea0e6d3
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
0: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: public class Derby3650Test extends BaseJDBCTestCase 
1: {
1:     /**************************************************************************
1:      * Fields of the class
1:      **************************************************************************
1:      */
1:     // DERBY-3749 causes tests that commit after looking at the stream to 
1:     // break while trying to access the streams in subsequent rows.  When
1:     // that bug gets fixed, enable these tests.
1:     private static final boolean runDerby3749tests = false;
1: 
1:     /**************************************************************************
1:      * Constructors for This class:
1:      **************************************************************************
1:      */
1: 
1:     public Derby3650Test(String name) 
1:     {
1:     public void setUp() 
1:         throws SQLException
1:     {
1: 
1:     /**************************************************************************
1:      * Private/Protected methods of This class:
1:      **************************************************************************
1: 
1:     /**
1:      * Test select of multiple rows containing single clob column.
1:      * <p>
1:      * Expects input query to return 3 column's per row, which should be:
1:      * (id, length of clob, clob)  
1:      *
1:      * Will verify clob using verifyClob().
1:      * <p>
1:      * Runs the query 4 times testing the following combinations:
1:      *     free clob on each row = true,  commit xact after each row = true
1:      *     free clob on each row = true,  commit xact after each row = false
1:      *     free clob on each row = false, commit xact after each row = true
1:      *     free clob on each row = false, commit xact after each row = false
1:      *
1:      * @param query                 query to run.
1:      *
1:      * @exception  StandardException  Standard exception policy.
1:      **/
1:     private void runQueryCasesClob(
1:     String query)
1:         throws SQLException, IOException
1:     {
1:         if (runDerby3749tests)
1:             runQueryClob(query, true,  true);
1:         runQueryClob(query, true,  false);
1:         if (runDerby3749tests)
1:             runQueryClob(query, false, true);
1:         runQueryClob(query, false, false);
1:     }
1: 
1:     /**
1:      * Test select of multiple rows containing single clob column.
1:      * <p>
1:      * Expects input query to return 3 column's per row, which should be:
1:      * (id, length of clob, clob)  
1:      *
1:      * Will verify clob using verifyClob().
1:      * <p>
1:      *
1:      * @param query                 query to run.
1:      * @param freelob               true if we should free the lob after it has
1:      *                              been retrieved and verified.
1:      * @param commitAfterLobVerify  true if we should commit after the lob has
1:      *                              been retrieved and verified.
1:      *
1:      * @exception  StandardException  Standard exception policy.
1:      **/
1:     private void runQueryClob(
1:     String  query,
1:     boolean freelob,
1:     boolean commitAfterLobVerify)
1:         throws SQLException, IOException
1:     {
1:         PreparedStatement ps = prepareStatement(query);
1: 
1:         while (rs.next()) 
1:         {
1:             int  id     = rs.getInt(1);
1:             int  length = rs.getInt(2);
1:             Clob clob   = rs.getClob(3);
1: 
1:             // verify that stream can be read and is right.
1:             verifyClob(
1:                 clob.getCharacterStream(), 
1:                 length,
1:                 new LoopingAlphabetReader(length));
1: 
1:         commit();
1: 
1:         while (rs.next()) 
1:         {
1:             int  id     = rs.getInt(1);
1:             int  length = rs.getInt(2);
1: 
1:             // verify that stream can be read and is right.
1:             verifyClob(
1:                 rs.getCharacterStream(3),
1:                 length,
1:                 new LoopingAlphabetReader(length));
1: 
1:             if (commitAfterLobVerify)
1:                 commit();
1:         rs.close();
1:         commit();
1: 
1:         ps.close();
1: 
1: 
1:      * Test select of multiple rows containing single blob column.
1:      * <p>
1:      * Expects input query to return 3 column's per row, which should be:
1:      * (id, length of clob, clob)  
1:      * Will verify blob using verifyBlob().
1:      * <p>
1:      * Runs the query 4 times testing the following combinations:
1:      *     free blob on each row = true,  commit xact after each row = true
1:      *     free blob on each row = true,  commit xact after each row = false
1:      *     free blob on each row = false, commit xact after each row = true
1:      *     free blob on each row = false, commit xact after each row = false
1:      *
1:      * @param query                 query to run.
1:      *
1:      * @exception  StandardException  Standard exception policy.
1:      **/
1:     private void runQueryCasesBlob(
1:     String query)
1:         throws SQLException, IOException
1:     {
1:         if (runDerby3749tests)
1:             runQueryBlob(query, true,  true);
1:         runQueryBlob(query, true,  false);
1:         if (runDerby3749tests)
1:             runQueryBlob(query, false, true);
1:         runQueryBlob(query, false, false);
1:     }
1: 
1:     /**
1:      * Test select of multiple rows containing single blob column.
1:      * <p>
1:      * Expects input query to return single column per row, which is a blob.
1:      * Will verify blob using verifyBlob().
1:      * <p>
1:      *
1:      * @param query                 query to run.
1:      * @param freelob               true if we should free the lob after it has
1:      *                              been retrieved and verified.
1:      * @param commitAfterLobVerify  true if we should commit after the lob has
1:      *                              been retrieved and verified.
1:      *
1:      * @exception  StandardException  Standard exception policy.
1:      **/
1:     private void runQueryBlob(
1:     String  query,
1:     boolean freelob,
1:     boolean commitAfterLobVerify)
1:         throws SQLException, IOException
1:         PreparedStatement ps = prepareStatement(query);
1: 
1:         while (rs.next()) 
1:         {
1:             Blob blob = rs.getBlob(3);
1:             verifyBlob(blob.getBinaryStream(), rs.getInt(2), rs.getInt(1));
/////////////////////////////////////////////////////////////////////////
1:         rs = ps.executeQuery();
1:         while (rs.next()) 
1:         {
1:             // note, the order of "getXXX" is important.  This routine will
1:             // fail in network client if the 3rd arg is requested before the
1:             // 1st arg.  In that case attempts to read from the stream get
1:             // a closed error.  This is why the values are retrieved first
1:             // and then passed to the call.
1:             int         id      = rs.getInt(1);
1:             int         length  = rs.getInt(2);
1:             InputStream stream  = rs.getBinaryStream(3);
1: 
1:             verifyBlob(stream, length, id);
1: 
1:             if (commitAfterLobVerify)
1:                 commit();
1:         }
1:         rs.close();
1:         commit();
1: 
1:         ps.close();
1: 
1:     private void verifyClob(Reader input, int length, Reader expected) 
1:         throws SQLException, IOException 
1:     {
1:         int input_char;
1:         int expect_char;
1: 
1:         do 
1:         {
1:             input_char  = input.read();
1:             expect_char = expected.read();
1: 
1:             if (input_char != -1) 
1:             {
1:                 if ((char) input_char != expect_char) 
1:                 {
1:                     fail("Unexpected Character " + (char) input_char + 
1:                             " expected " + (char) expect_char);
1: 
1:         } while (input_char != -1) ;
1: 
1:         if (charcount != length)
1:         {
1:            fail("Unexpected character count " + charcount + 
1:                    "expected: " + length);
1:     private void verifyBlob(InputStream is, int length, int id) 
1:         throws SQLException, IOException 
1:     {
1:         do 
1:         {
1:             if (b != -1) 
1:             {
1:                 if ((byte) b != id) 
1:                 {
1:                     fail("Unexpected byte value " + (byte) b + 
1:                             " expected: " + id);
1:         } while (b != -1);
1: 
1:         if (bytecount != length)
1:         {
1:             fail("Unexpected byte count, got " + bytecount + 
1:                     "  expected " + length);
1:     }
1: 
1:     /**************************************************************************
1:      * Public Methods of This class:
1:      **************************************************************************
1:      */
1: 
1: 
1:     /**
1:      * Test a nested loop join for clobs.
1:      * <p>
1:      * Test case of a 1 to many row join where the 1 row contains and returns
1:      * a clob as a stream.  Before fix for DERBY-3650 each row returned from
1:      * this join would contain a reference to the same stream which would fail
1:      * in various ways depending on commit, free, and reading the stream.
1:      *
1:      * @throws SQLException
1:      * @throws IOException
1:      */
1:     public void test1ToManyJoinClob() 
1:         throws SQLException, IOException     
1:     {           
1:         runQueryCasesClob(
1:             "select testClob.id, length, c from testClob " + 
1:                 "join jointab on jointab.id = testClob.id");
1:     }
1: 
1:     /**
1:      * Test a nested loop join for blobs.
1:      * <p>
1:      * Test case of a 1 to many row join where the 1 row contains and returns
1:      * a blob as a stream.  Before fix for DERBY-3650 each row returned from
1:      * this join would contain a reference to the same stream which would fail
1:      * in various ways depending on commit, free, and reading the stream.
1:      *
1:      * @throws SQLException
1:      * @throws IOException
1:      */
1:     public void test1ToManyJoinBlob() 
1:         throws SQLException, IOException     
1:     {     
1:         runQueryCasesBlob(
1:             "select testBlob.id, length, c from testBlob " +
1:                 "join jointab on jointab.id = testBlob.id");
1:     }
1: 
1: 
1:     public void test1ToManyHashJoinClob() 
1:         throws SQLException, IOException     
1:     {           
1:         runQueryCasesClob(
1:             "select testClob.id, length, c from " + 
1:             "--DERBY-PROPERTIES joinOrder=FIXED \n" + 
1:             "testClob --DERBY-PROPERTIES joinStrategy=HASH \n" + 
1:             "join jointab on jointab.id = testClob.id");
1: 
1:         runQueryCasesClob(
1:             "select jointab.id, length, c from " + 
1:             "--DERBY-PROPERTIES joinOrder=FIXED \n" + 
1:             "jointab --DERBY-PROPERTIES joinStrategy=HASH \n" + 
1:             "join testClob on jointab.id = testClob.id");
1:     }
1: 
1:     public void test1ToManyHashJoinBlob() 
1:         throws SQLException, IOException     
1:     {           
1:         runQueryCasesBlob(
1:             "select testBlob.id, length, c from " + 
1:             "--DERBY-PROPERTIES joinOrder=FIXED \n" + 
1:             "testBlob --DERBY-PROPERTIES joinStrategy=HASH \n" + 
1:             "join jointab on jointab.id = testBlob.id");
1: 
1:         runQueryCasesBlob(
1:             "select testBlob.id, length, c from " + 
1:             "--DERBY-PROPERTIES joinOrder=FIXED \n" + 
1:             "jointab --DERBY-PROPERTIES joinStrategy=HASH \n" + 
1:             "join testBlob on jointab.id = testBlob.id");
1:     }
1: 
1:     public void test1ToManyleftOuterJoinClob() 
1:         throws SQLException, IOException     
1:     {           
1:         runQueryCasesClob(
1:             "select testClob.id, length, c from testClob " + 
1:                 "left outer join jointab on jointab.id = testClob.id");
1: 
1:         runQueryCasesClob(
1:             "select jointab.id, length, c from jointab " + 
1:                 "left outer join testClob on jointab.id = testClob.id");
1:     }
1: 
1:     public void test1ToManyleftOuterJoinBlob() 
1:         throws SQLException, IOException     
1:     {           
1:         runQueryCasesBlob(
1:             "select testBlob.id, length, c from testBlob " + 
1:                 "left outer join jointab on jointab.id = testBlob.id");
1:         runQueryCasesBlob(
1:             "select jointab.id, length, c from jointab " + 
1:                 "left outer join testBlob on jointab.id = testBlob.id");
1:     }
1: 
1: 
1:     /**
1:      * Test straight select from a heap scan of multiple rows containing clobs.
1:      *
0:      * @param freelob               true if we should free the lob after it has
0:      *                              been retrieved and verified.
1:      *
0:      * @param commitAfterLobVerify  true if we should commit after the lob has 
0:      *                              been retrieved and verified
1:      * @throws SQLException
1:      * @throws IOException
1:      */
1:     public void testClobSelect() 
1:         throws SQLException, IOException     
1:     {           
1:         runQueryCasesClob("select id, length, c from testMultipleClob");
1:     }
1: 
1:     /**
1:      * Test straight select from a heap scan of multiple rows containing blobs.
1:      *
1:      * @throws SQLException
1:      * @throws IOException
1:      */
1:     public void testBlobSelect() 
1:         throws SQLException, IOException     
1:     {     
1:         runQueryCasesBlob("select id, length, c from testMultipleBlob");
1:     private static void initializeClobTables(Statement stmt) 
1:         throws SQLException, IOException
1:     {
1:         // CLOB TEST SETUP...........................................
1:         stmt.executeUpdate(
1:             "CREATE TABLE testClob (id int, length int, c CLOB(2M))");
1: 
1:         Connection conn = stmt.getConnection();
1:         PreparedStatement ps = 
1:             conn.prepareStatement("INSERT INTO TestClob VALUES(?,?,?)");
1: 
1:         // insert 4 rows into "left" table containing clobs of join: 
1:         //     (1, clob), (1, clob), (2, clob), (2, clob)
1:         ps.setInt(            1, 1);
1:         ps.setInt(            2, 40000);
1:         ps.setCharacterStream(3, new LoopingAlphabetReader(40000));
1:         ps.executeUpdate();
1: 
1:         ps.setInt(            1, 1);
1:         ps.setInt(            2, 40001);
1:         ps.setCharacterStream(3, new LoopingAlphabetReader(40001));
1:         ps.executeUpdate();
1: 
1:         ps.setInt(            1, 2);
1:         ps.setInt(            2, 40002);
1:         ps.setCharacterStream(3, new LoopingAlphabetReader(40002));
1:         ps.executeUpdate();
1: 
1:         ps.setInt(            1, 2);
1:         ps.setInt(            2, 40003);
1:         ps.setCharacterStream(3, new LoopingAlphabetReader(40003));
1:         ps.executeUpdate();
1:         ps.close();
1: 
1:         stmt.executeUpdate(
1:             "CREATE TABLE testMultipleClob (id int, length int, c CLOB(2M))");
1:         ps = conn.prepareStatement(
1:                 "INSERT INTO testMultipleClob VALUES(?,?,?)");
1: 
1:         for (int i = 0; i < 100; i++)
1:         {
1:             ps.setInt(            1, i);
1:             ps.setInt(            2, 40000 + i);
1:             ps.setCharacterStream(3, new LoopingAlphabetReader(40000 + i));
1:             ps.executeUpdate();
1:         }
1:         ps.close();
1:         conn.commit();
1:     }
1: 
1:     private static void initializeBlobTables(Statement stmt) 
1:         throws SQLException, IOException
1:     {
1:         // BLOB TEST SETUP...........................................
1:         stmt.executeUpdate(
1:                 "CREATE TABLE testBlob (id int, length int, c BLOB(2M))");
1: 
1:         Connection conn = stmt.getConnection();
1:         PreparedStatement ps = 
1:             conn.prepareStatement("INSERT INTO TestBlob VALUES(?,?,?)");
1: 
1:         // insert 4 rows into "left" blob of join: 
1:         //     (1, 40000, blob), (1, 40001, blob), 
1:         //     (2, 40002, blob), (2, 40003, blob)
1:         byte[] mybytes = new byte[40000];
1:         Arrays.fill(mybytes, (byte) 1);
1:         ps.setInt(  1, 1);
1:         ps.setInt(  2, 40000);
1:         ps.setBytes(3, mybytes);
1:         ps.executeUpdate();
1: 
1:         mybytes = new byte[40001];
1:         Arrays.fill(mybytes, (byte) 1);
1:         ps.setInt(  1, 1);
1:         ps.setInt(  2, 40001);
1:         ps.setBytes(3, mybytes);
1:         ps.executeUpdate();
1: 
1:         mybytes = new byte[40002];
1:         Arrays.fill(mybytes, (byte) 2);
1:         ps.setInt(  1, 2);
1:         ps.setInt(  2, 40002);
1:         ps.setBytes(3, mybytes);
1:         ps.executeUpdate();
1: 
1:         mybytes = new byte[40003];
1:         Arrays.fill(mybytes, (byte) 2);
1:         ps.setInt(  1, 2);
1:         ps.setInt(  2, 40003);
1:         ps.setBytes(3, mybytes);
1:         ps.executeUpdate();
1: 
1:         ps.close();
1: 
1:         // insert 4 rows into "right" table of join: 
1:         stmt.executeUpdate("CREATE TABLE jointab (id int)");
1:         stmt.executeUpdate("INSERT INTO jointab values(1)");
1:         stmt.executeUpdate("INSERT INTO jointab values(1)");
1:         stmt.executeUpdate("INSERT INTO jointab values(2)");
1:         stmt.executeUpdate("INSERT INTO jointab values(2)");
1: 
1:         stmt.executeUpdate(
1:             "CREATE TABLE testMultipleBlob (id int, length int, c BLOB(2M))");
1:         ps = conn.prepareStatement(
1:                 "INSERT INTO testMultipleBlob VALUES(?,?,?)");
1: 
1:         for (int i = 0; i < 100; i++)
1:         {
1:             mybytes = new byte[40000 + i];
1:             Arrays.fill(mybytes, (byte) i);
1: 
1:             ps.setInt(  1, i);
1:             ps.setInt(  2, 40000 + i);
1:             ps.setBytes(3,mybytes);
1:             ps.executeUpdate();
1:         }
1:         ps.close();
1:         conn.commit();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 try
1:                 {
1:                     initializeClobTables(stmt);
1:                     initializeBlobTables(stmt);
1:                 }
1:                 catch (IOException ioe)
1:                 {
1:                     fail("Unexpected I/O exception during setup: " + ioe);
1:                 }
1: 
1: 
1:     public static Test suite() 
1:     {
/////////////////////////////////////////////////////////////////////////
commit:b2ae876
/////////////////////////////////////////////////////////////////////////
0:             verify40KClob(clob.getCharacterStream());
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:0da1e72
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1: 
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.Reader;
1: import java.sql.Blob;
1: import java.sql.Clob;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.util.Arrays;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /*
1: Class org.apache.derbyTesting.functionTests.tests.jdbc4.Derby3650Test
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to you under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1:    http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: /** 
1:  * These are tests to test the cases for DERBY-3650.
1:  * The tests won't pass until that bug is fixed. 
1:  */
1: 
0: public class Derby3650Test extends BaseJDBCTestCase {
1: 
0:     public Derby3650Test(String name) {
1:         super(name);
1:      
1:     }
1:     
0:     public void setup() throws SQLException{
1:         
1:         getConnection().setAutoCommit(false);
1:     }
1: 
1:    
1:     /**
0:      * If join returns clob in more than one row, test that the 
0:      * stream can be retrieved if free is not called.
0:      * @param freelob  true if we should free the lob after it has been retrieved and verified.
0:      * @param commitAfterLobVerify true if we should commit after the lob has been retrieved and verified
0:      * @throws SQLException
0:      * @throws IOException
1:      */
0:     public void test1ToManyJoinClob(boolean freelob, boolean commitAfterLobVerify) throws SQLException, IOException     
1:     {           
0:         PreparedStatement ps = prepareStatement(
0:         "select c from testClob join jointab on jointab.id = testClob.id");
1:         ResultSet rs = ps.executeQuery();
0:         while (rs.next()) {
0:             Clob clob = rs.getClob(1);
1:             if (freelob)
1:                 clob.free();
1:             if (commitAfterLobVerify)
1:                 commit();
0:             verify40KClob(clob.getCharacterStream());
1:         }
1:         rs.close();
1:         rs = ps.executeQuery();
0:         while (rs.next()) {
0:             verify40KClob(rs.getCharacterStream(1));            
1:         }
1:     }
1:     
1:     /**
0:      * If join returns clob in more than one row, test that the 
0:      * stream can be retrieved.
0:      * 
0:      * @param freelob  true if we should free the lob after it has been retrieved and verified.
0:      * @param commitAfterLobVerify true if we should commit after the lob has been retrieved and verified
0:      * @throws SQLException
0:      * @throws IOException
1:      */
1:     
0:     public void test1ToManyJoinBlob(boolean freelob, boolean commitAfterLobVerify) throws SQLException, IOException     
1:     {     
0:         PreparedStatement ps = prepareStatement(
0:         "select c from testBlob join jointab on jointab.id = testBlob.id");
1:         ResultSet rs = ps.executeQuery();
0:         while (rs.next()) {
0:             Blob blob = rs.getBlob(1);
0:             verify40KBlob(blob.getBinaryStream());
1:             if (freelob)
1:                 blob.free();
1:             if (commitAfterLobVerify)
1:                 commit();
1:         }
1:         rs.close();
1:         rollback();
1:         rs = ps.executeQuery();
0:         while (rs.next()) {
0:             verify40KBlob(rs.getBinaryStream(1));            
1:         }
1: 
1:         
1:     }
1:     
0:     public void test1ToManyJoinBlobNoFree() throws SQLException, IOException {
0:         test1ToManyJoinBlob(false,false);
1:         
1:     }
1:     
0:     public void test1ToManyJoinBlobWithFree() throws SQLException, IOException {
0:         test1ToManyJoinBlob(false,true); 
1:     }
1:     
0:     public void test1ToManyJoinBlobWithCommit() throws SQLException, IOException {
0:         test1ToManyJoinBlob(true,false); 
1:     }
1:     
1:     
0:     public void test1ToManyJoinClobNoFree() throws SQLException, IOException {
0:         test1ToManyJoinClob(false,false);
1:         
1:     }
1:     
0:     public void test1ToManyJoinClobWithFree() throws SQLException, IOException {
0:         test1ToManyJoinClob(false,true); 
1:     }
1:     
0:     public void test1ToManyJoinClobWithCommit() throws SQLException, IOException {
0:         test1ToManyJoinClob(true,false); 
1:     }
1:     
1:     
1:     
0:     private void verify40KClob(Reader r) throws SQLException, IOException {
1:         
0:         int c;
1:         int charcount = 0;
0:         do {
0:             c = r.read();
0:             if (c != -1) {
1:                 charcount++;
0:                 if ((char) c != 'a') {
0:                     fail("Unexpected Character " + (char)c);
1:                 }
1:             }
1:         }
0:         while (c != -1);
0:         if (charcount != 40000)
0:            fail("Unexcpected character count " + charcount);
1:      
1:     }
1:     
0:     private void verify40KBlob(InputStream is ) throws SQLException, IOException {
1:         int b;
1:         int bytecount = 0;
0:         do {
1:             b = is.read();
0:             if (b != -1) {
1:                 bytecount++;
0:                 if ((byte) b != (byte) 'a') {
0:                     fail("Unexpected byte value " + (byte) b);                    
1:                 }
1:             }
1:         }
0:         while (b != -1);
0:         if (bytecount != 40000)
0:             fail("Unexpected byte count");
1:      
1:     }
1:     
1:     
1:     protected static Test baseSuite(String name) {
0:         TestSuite suite = new TestSuite(name);
1:         suite.addTestSuite(Derby3650Test.class);
1:         return new CleanDatabaseTestSetup(
1:                 DatabasePropertyTestSetup.setLockTimeouts(suite, 2, 4)) 
1:         {
1:             /**
1:              * Creates the tables used in the test cases.
1:              * @exception SQLException if a database error occurs
1:              */
1:             protected void decorateSQL(Statement stmt) throws SQLException
1:             {
0:                 stmt.executeUpdate("CREATE TABLE testClob (id int, c CLOB(2M))");
0:                 Connection conn = stmt.getConnection();
0:                 PreparedStatement ps = conn.prepareStatement("INSERT INTO TestClob VALUES(?,?)");
0:                 ps.setInt(1,1);
0:                 char[] myval = new char[40000];
0:                 Arrays.fill(myval,'a');
0:                 ps.setString(2,new String(myval));
0:                 ps.executeUpdate();
0:                 ps.close();
0:                 stmt.executeUpdate("CREATE TABLE testBlob (id int, c BLOB(2M))");
0:                 ps = conn.prepareStatement("INSERT INTO TestBlob VALUES(?,?)");
0:                 ps.setInt(1,1);
0:                 byte[] mybytes = new byte[40000];
0:                 Arrays.fill(mybytes, (byte) 'a');
0:                 ps.setBytes(2,mybytes);
0:                 ps.executeUpdate();
0:                 ps.close();
0:                 stmt.executeUpdate("CREATE TABLE jointab (id int)");
0:                 stmt.executeUpdate("INSERT INTO jointab values(1)");
0:                 stmt.executeUpdate("INSERT INTO jointab values(1)");
1:            
1:            
1:                 
1:             }
1:         };
1:     }
0:     public static Test suite() {
0:         TestSuite suite = new TestSuite("Derby3650Test");
1:         suite.addTest(baseSuite("Derby3650Test:embedded"));
1:         suite.addTest(TestConfiguration.clientServerDecorator(
1:             baseSuite("Derby3650Test:client")));
1:         return suite;
1: 
1:     }
1: }
1:     
============================================================================