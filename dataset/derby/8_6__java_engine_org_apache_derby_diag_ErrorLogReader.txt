1:eac0369: /*
3:eac0369: 
1:345de35:    Derby - Class org.apache.derby.diag.ErrorLogReader
1:345de35: 
1:2f36947:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2f36947:    contributor license agreements.  See the NOTICE file distributed with
1:2f36947:    this work for additional information regarding copyright ownership.
1:2f36947:    The ASF licenses this file to You under the Apache License, Version 2.0
1:2f36947:    (the "License"); you may not use this file except in compliance with
1:2f36947:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.diag;
1:eac0369: 
1:eac0369: import java.io.BufferedReader;
1:eac0369: import java.io.FileNotFoundException;
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.InputStreamReader;
1:eac0369: import java.io.FileInputStream;
1:431cefd: import java.security.PrivilegedAction;
1:431cefd: import java.security.AccessController;
1:eac0369: 
1:eac0369: import java.sql.ResultSetMetaData;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.Types;
1:eac0369: import org.apache.derby.vti.VTITemplate;
1:b1f84c1: import org.apache.derby.iapi.reference.Limits;
1:431cefd: import org.apache.derby.iapi.reference.Property;
1:eac0369: import org.apache.derby.iapi.util.StringUtil;
1:eac0369: 
1:431cefd: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1:eac0369: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369: 	ErrorLogReader is a virtual table interface (VTI) which contains all the statements
1:eac0369: 	of "interest" in db2j.<!-- -->log or a specified file when
1:eac0369: 	db2j.<!-- -->language.<!-- -->logStatementText=true.
1:eac0369: 	
1:eac0369: 	
1:eac0369: 	<P>One use of this VTI is to determine the active transactions
1:eac0369: 	and the SQL statements in those transactions at a given point in time, say
1:eac0369: 	when a deadlock or lock timeout occurred.  In order to do that, you must first
1:eac0369: 	find the timestamp (timestampConstant) of interest in the error log.  
1:eac0369: 	The SQL to view the active transactions at a given in time is:
1:eac0369: 	<PRE>SELECT vti.ts, threadid, cast(xid as int) as xid_int, cast(lccid as int) as lccid_int, logtext 
1:eac0369: 		 FROM new org.apache.derby.diag.ErrorLogReader() vti, 
1:eac0369: 			(VALUES timestampConstant) t(ts)
1:dbed020: 		 WHERE vti.ts &lt;= t.ts AND 
1:dbed020: 				vti.ts &gt;
1:eac0369: 					(SELECT MAX(ts) IS NULL ? '2000-01-01 00:00:00.1' : MAX(ts)
1:eac0369: 					 FROM new org.apache.derby.diag.ErrorLogReader() vti_i
1:eac0369: 					 WHERE (logtext LIKE 'Committing%' OR
1:eac0369: 							logtext LIKE 'Rolling%') AND
1:dbed020: 						   vti.xid = vti_i.xid AND ts &lt; t.ts)
1:eac0369: 		 ORDER BY xid_int, vti.ts
1:eac0369: 	</PRE>
1:eac0369: 
1:eac0369: 	<P>The ErrorLogReader virtual table has the following columns:
1:eac0369: 	<UL><LI>TS varchar(26) - the timestamp of the statement.</LI>
1:eac0369: 	<LI>THREADID varchar(40) - the thread name.</LI>
1:eac0369: 	<LI>XID varchar(15) - the transaction ID.</LI>
1:eac0369: 	<LI>LCCID varchar(15) - the connection ID.</LI>
1:eac0369: 	<LI>DATABASE varchar(128) -  Database name
1:eac0369: 	<LI>DRDAID  varchar(50) - nullable. DRDA ID for network server session.
1:eac0369: 	<LI>LOGTEXT long varchar - text of the statement or commit or rollback.</LI>
1:eac0369: 	</UL>
1:eac0369: 
1:eac0369:  */
1:eac0369: public class ErrorLogReader extends VTITemplate
1:eac0369: {
1:eac0369: 	/*
1:eac0369: 	** private 
1:eac0369: 	*/
1:eac0369: 	private boolean gotFile;
1:eac0369: 	private InputStreamReader inputFileStreamReader;
1:eac0369: 	private InputStream inputStream;
1:eac0369: 	private BufferedReader bufferedReader;
1:eac0369: 	private String inputFileName;
1:eac0369: 
1:eac0369: 	// Variables for current row
1:eac0369: 	private String line;
1:70ff9b0: 	private int endTimestampIndex;
1:eac0369: 	private int threadIndex;
1:eac0369: 	private int xidIndex;
1:eac0369: 	private int lccidIndex;
1:eac0369: 	private int databaseIndex;
1:eac0369: 	private int drdaidIndex;
1:eac0369: 
1:eac0369: 
1:70ff9b0: 	private static final String END_TIMESTAMP = " Thread";
1:eac0369: 	private static final String PARAMETERS_STRING = "Parameters:";
1:eac0369: 	private static final String BEGIN_THREAD_STRING = "[";
1:eac0369: 	private static final String END_THREAD_STRING = "]";
1:eac0369: 	private static final String BEGIN_XID_STRING = "= ";
1:eac0369: 	private static final String END_XID_STRING = ")";
1:eac0369: 	private static final String BEGIN_DATABASE_STRING = "(DATABASE =";
1:eac0369: 	private static final String END_DATABASE_STRING = ")";
1:eac0369: 	private static final String BEGIN_DRDAID_STRING = "(DRDAID =";
1:eac0369: 	private static final String END_DRDAID_STRING = ")";
1:eac0369: 	private static final String BEGIN_EXECUTING_STRING = "Executing prepared";
1:eac0369: 	private static final String END_EXECUTING_STRING = " :End prepared";
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		ErrorLogReader() accesses the derby.log in
1:eac0369: 		derby.system.home, if set, otherwise it looks in the current directory.
1:eac0369: 		ErrorLogReader('filename') will access the specified
1:eac0369: 		file name.
1:eac0369: 	 */
1:431cefd: 	public ErrorLogReader() throws StandardException
1:eac0369: 	{
1:431cefd:         DiagUtil.checkAccess();
1:431cefd: 
1:0758fb6:         final String home = AccessController.doPrivileged
1:431cefd:             (
1:0758fb6:              new PrivilegedAction<String>()
1:431cefd:              {
1:0758fb6:                  public String run()
1:431cefd:                  {
1:431cefd:                      return System.getProperty( Property.SYSTEM_HOME_PROPERTY );
1:431cefd:                  }
1:431cefd:              }
1:431cefd:              );
1:eac0369: 
1:eac0369: 		inputFileName = "derby.log";
1:eac0369: 
1:eac0369: 		if (home != null)
1:eac0369: 		{
1:eac0369: 			inputFileName = home + "/" + inputFileName;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:431cefd: 	public ErrorLogReader(String inputFileName) throws StandardException
1:eac0369: 	{
1:431cefd:         DiagUtil.checkAccess();
1:431cefd: 
1:eac0369: 		this.inputFileName = inputFileName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#getMetaData
1:eac0369: 	 */
1:eac0369: 	public ResultSetMetaData getMetaData()
1:eac0369: 	{
1:eac0369: 		return metadata;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#next
1:eac0369: 		@exception SQLException If database-access error occurs.
1:eac0369: 	 */
1:eac0369: 	public boolean next() throws SQLException
1:eac0369: 	{
1:eac0369: 		if (! gotFile)
1:eac0369: 		{
1:eac0369: 			gotFile = true;
1:eac0369: 		    try 
1:eac0369: 			{
1:eac0369: 		        inputFileStreamReader = new InputStreamReader(new FileInputStream(inputFileName));
1:eac0369: 				bufferedReader = new BufferedReader(inputFileStreamReader, 32*1024);
1:eac0369: 			} 
1:eac0369: 			catch (FileNotFoundException ex) 
1:eac0369: 			{
1:eac0369: 				throw new SQLException(ex.getMessage());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		while (true)
1:eac0369: 		{
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				line = bufferedReader.readLine();
1:eac0369: 			}
1:eac0369: 			catch (java.io.IOException ioe)
1:eac0369: 			{
1:eac0369: 				throw new SQLException(ioe.getMessage());
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (line == null)
1:eac0369: 			{
1:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 
1:70ff9b0:             endTimestampIndex = line.indexOf( END_TIMESTAMP );
1:eac0369: 			threadIndex = line.indexOf(BEGIN_THREAD_STRING);
1:eac0369: 			xidIndex = line.indexOf(BEGIN_XID_STRING);
1:eac0369: 			lccidIndex = line.indexOf(BEGIN_XID_STRING, xidIndex + 1);
1:eac0369: 			databaseIndex = line.indexOf(BEGIN_DATABASE_STRING, lccidIndex + 1);
1:eac0369: 			drdaidIndex = line.indexOf(BEGIN_DRDAID_STRING, databaseIndex + 1);
1:eac0369: 
1:eac0369: 			// Skip parameters
1:eac0369: 			if (line.indexOf(PARAMETERS_STRING) != -1)
1:eac0369: 			{
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 
1:70ff9b0: 			if (endTimestampIndex != -1 && threadIndex != -1  && xidIndex != -1 && 
1:eac0369: 				databaseIndex != -1)
1:eac0369: 			{
1:eac0369: 				return true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#close
1:eac0369: 	 */
1:eac0369: 	public void close()
1:eac0369: 	{
1:eac0369: 		if (bufferedReader != null)
1:eac0369: 		{
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				bufferedReader.close();
1:eac0369: 				inputFileStreamReader.close();
1:eac0369: 			}
1:eac0369: 			catch (java.io.IOException ioe)
1:eac0369: 			{
1:eac0369: 				// eat exceptions during close;
1:eac0369: 			}
1:eac0369: 			finally
1:eac0369: 			{
1:eac0369: 				bufferedReader = null;
1:eac0369: 				inputFileStreamReader = null;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		All columns in the Db2jLogReader VTI have a of String type.
1:eac0369: 		@see java.sql.ResultSet#getString
1:eac0369: 		@exception SQLException If database-access error occurs.
1:eac0369: 	 */
1:eac0369: 	public String getString(int columnNumber)
1:eac0369: 		throws SQLException
1:eac0369: 	{
1:eac0369: 		switch (columnNumber)
1:eac0369: 		{
1:eac0369: 			case 1:
1:70ff9b0: 				return line.substring(0, endTimestampIndex);
1:eac0369: 
1:eac0369: 			case 2:
1:eac0369: 				return line.substring(threadIndex + 1, line.indexOf(END_THREAD_STRING));
1:eac0369: 
1:eac0369: 			case 3:
1:eac0369: 				return line.substring(xidIndex + 2, line.indexOf(END_XID_STRING, xidIndex));
1:eac0369: 
1:eac0369: 			case 4:
1:eac0369: 				return line.substring(lccidIndex + 2, line.indexOf(END_XID_STRING, lccidIndex));
1:eac0369: 
1:eac0369: 			case 5:
1:eac0369: 				return line.substring(databaseIndex + BEGIN_DATABASE_STRING.length(), line.indexOf(END_DATABASE_STRING, databaseIndex));
1:eac0369: 			case 6:
1:eac0369: 				return line.substring(drdaidIndex + BEGIN_DRDAID_STRING.length(), line.indexOf(END_DRDAID_STRING, drdaidIndex));
1:eac0369: 			case 7:
1:eac0369: 				/* Executing prepared statement is a special case as
1:eac0369: 				 * it could span multiple lines
1:eac0369: 				 */
1:a9c3863: 				StringBuffer output = new StringBuffer(64);
1:eac0369: 				if (line.indexOf(BEGIN_EXECUTING_STRING) == -1)
1:eac0369: 				{
1:a9c3863: 					output.append(line.substring(line.indexOf(END_DRDAID_STRING, drdaidIndex) + 3));
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 
1:eac0369: 				/* We need to build string until we find the end of the text */
1:eac0369: 				int endIndex = line.indexOf(END_EXECUTING_STRING, drdaidIndex);
1:eac0369: 				if (endIndex == -1)
1:eac0369: 				{
1:a9c3863: 					output.append(line.substring(line.indexOf(END_DRDAID_STRING, drdaidIndex) + 3));
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:a9c3863: 					output.append(line.substring(line.indexOf(END_XID_STRING, drdaidIndex) + 3,
1:a9c3863: 											endIndex));
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				while (endIndex == -1)
1:eac0369: 				{
1:eac0369: 					try
1:eac0369: 					{
1:eac0369: 						line = bufferedReader.readLine();
1:eac0369: 					}
1:eac0369: 					catch (java.io.IOException ioe)
1:eac0369: 					{
1:eac0369: 						throw new SQLException("Error reading file " + ioe);
1:eac0369: 					}
1:eac0369: 					endIndex = line.indexOf(END_EXECUTING_STRING);
1:eac0369: 					if (endIndex == -1)
1:eac0369: 					{
1:a9c3863: 						output.append(line);
1:eac0369: 					}
1:eac0369: 					else
1:eac0369: 					{
1:a9c3863: 						output.append(line.substring(0, endIndex));
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				}
1:eac0369: 
1:a9c3863: 				return StringUtil.truncate(output.toString(), Limits.DB2_VARCHAR_MAXWIDTH);
1:eac0369: 
1:eac0369: 			default:
1:eac0369: 				return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#wasNull
1:eac0369: 	 */
1:eac0369: 	public boolean wasNull()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* MetaData
1:eac0369: 	 */
1:eac0369: 	
1:70ff9b0: 	// column1: TS varchar(29) not null
1:eac0369: 	// column2: THREADID varchar(40) not null
1:eac0369: 	// column3: XID  varchar(15) not null
1:eac0369: 	// column4: LCCID  varchar(15) not null
1:eac0369: 	// column5: DATABASE varchar(128) not null
1:eac0369: 	// column6: DRDAID varchar(50) nullable
1:eac0369: 	// column5: LOGTEXT VARCHAR(max) not null
1:eac0369: 	private static final ResultColumnDescriptor[] columnInfo = {
1:70ff9b0: 		EmbedResultSetMetaData.getResultColumnDescriptor("TS", Types.VARCHAR, false, 29),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("THREADID", Types.VARCHAR, false, 40),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("XID", Types.VARCHAR, false, 15),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("LCCID", Types.VARCHAR, false, 15),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("DATABASE", Types.VARCHAR, false, 128),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("DRDAID", Types.VARCHAR, true, 50),
1:b1f84c1: 		EmbedResultSetMetaData.getResultColumnDescriptor("LOGTEXT",Types.VARCHAR, false, Limits.DB2_VARCHAR_MAXWIDTH)
1:eac0369: 	};
1:8514aa2: 
1:8514aa2:     private static final ResultSetMetaData metadata =
1:8514aa2:         new EmbedResultSetMetaData(columnInfo);
1:eac0369: 
1:eac0369: }
1:eac0369: 
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 		 WHERE vti.ts &lt;= t.ts AND 
1: 				vti.ts &gt;
1: 						   vti.xid = vti_i.xid AND ts &lt; t.ts)
commit:5570eb0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData40;
/////////////////////////////////////////////////////////////////////////
0: 	private static final ResultSetMetaData metadata = new EmbedResultSetMetaData40(columnInfo);
commit:0758fb6
/////////////////////////////////////////////////////////////////////////
1:         final String home = AccessController.doPrivileged
1:              new PrivilegedAction<String>()
1:                  public String run()
commit:431cefd
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
1: import java.security.AccessController;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.error.StandardException;
/////////////////////////////////////////////////////////////////////////
1: 	public ErrorLogReader() throws StandardException
1:         DiagUtil.checkAccess();
1: 
0:         final String home = (String)AccessController.doPrivileged
1:             (
0:              new PrivilegedAction()
1:              {
0:                  public Object run()
1:                  {
1:                      return System.getProperty( Property.SYSTEM_HOME_PROPERTY );
1:                  }
1:              }
1:              );
/////////////////////////////////////////////////////////////////////////
1: 	public ErrorLogReader(String inputFileName) throws StandardException
1:         DiagUtil.checkAccess();
1: 
commit:70ff9b0
/////////////////////////////////////////////////////////////////////////
1: 	private int endTimestampIndex;
/////////////////////////////////////////////////////////////////////////
1: 	private static final String END_TIMESTAMP = " Thread";
/////////////////////////////////////////////////////////////////////////
1:             endTimestampIndex = line.indexOf( END_TIMESTAMP );
/////////////////////////////////////////////////////////////////////////
1: 			if (endTimestampIndex != -1 && threadIndex != -1  && xidIndex != -1 && 
/////////////////////////////////////////////////////////////////////////
1: 				return line.substring(0, endTimestampIndex);
/////////////////////////////////////////////////////////////////////////
1: 	// column1: TS varchar(29) not null
/////////////////////////////////////////////////////////////////////////
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("TS", Types.VARCHAR, false, 29),
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8514aa2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static final ResultSetMetaData metadata =
1:         new EmbedResultSetMetaData(columnInfo);
author:Lily Wei
-------------------------------------------------------------------------------
commit:a9c3863
/////////////////////////////////////////////////////////////////////////
1: 				StringBuffer output = new StringBuffer(64);
1: 					output.append(line.substring(line.indexOf(END_DRDAID_STRING, drdaidIndex) + 3));
/////////////////////////////////////////////////////////////////////////
1: 					output.append(line.substring(line.indexOf(END_DRDAID_STRING, drdaidIndex) + 3));
1: 					output.append(line.substring(line.indexOf(END_XID_STRING, drdaidIndex) + 3,
1: 											endIndex));
/////////////////////////////////////////////////////////////////////////
1: 						output.append(line);
1: 						output.append(line.substring(0, endIndex));
1: 				return StringUtil.truncate(output.toString(), Limits.DB2_VARCHAR_MAXWIDTH);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:2f36947
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
0: 				output = StringUtil.truncate(output, Limits.DB2_VARCHAR_MAXWIDTH);
/////////////////////////////////////////////////////////////////////////
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("LOGTEXT",Types.VARCHAR, false, Limits.DB2_VARCHAR_MAXWIDTH)
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.diag.ErrorLogReader
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:4dede3b
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.diag
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.diag;
1: 
1: import java.io.BufferedReader;
1: import java.io.FileNotFoundException;
1: import java.io.InputStream;
1: import java.io.InputStreamReader;
1: import java.io.FileInputStream;
1: 
0: import java.util.Hashtable;
0: import java.util.Enumeration;
0: import java.util.Properties;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Types;
1: import org.apache.derby.vti.VTITemplate;
0: import org.apache.derby.iapi.reference.DB2Limit;
1: import org.apache.derby.iapi.util.StringUtil;
1: 
1: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData;
1: 
1: /**
1: 
1: 	ErrorLogReader is a virtual table interface (VTI) which contains all the statements
1: 	of "interest" in db2j.<!-- -->log or a specified file when
1: 	db2j.<!-- -->language.<!-- -->logStatementText=true.
1: 	
1: 	
1: 	<P>One use of this VTI is to determine the active transactions
1: 	and the SQL statements in those transactions at a given point in time, say
1: 	when a deadlock or lock timeout occurred.  In order to do that, you must first
1: 	find the timestamp (timestampConstant) of interest in the error log.  
1: 	The SQL to view the active transactions at a given in time is:
1: 	<PRE>SELECT vti.ts, threadid, cast(xid as int) as xid_int, cast(lccid as int) as lccid_int, logtext 
1: 		 FROM new org.apache.derby.diag.ErrorLogReader() vti, 
1: 			(VALUES timestampConstant) t(ts)
0: 		 WHERE vti.ts <= t.ts AND 
0: 				vti.ts >
1: 					(SELECT MAX(ts) IS NULL ? '2000-01-01 00:00:00.1' : MAX(ts)
1: 					 FROM new org.apache.derby.diag.ErrorLogReader() vti_i
1: 					 WHERE (logtext LIKE 'Committing%' OR
1: 							logtext LIKE 'Rolling%') AND
0: 						   vti.xid = vti_i.xid AND ts < t.ts)
1: 		 ORDER BY xid_int, vti.ts
1: 	</PRE>
1: 
1: 	<P>The ErrorLogReader virtual table has the following columns:
1: 	<UL><LI>TS varchar(26) - the timestamp of the statement.</LI>
1: 	<LI>THREADID varchar(40) - the thread name.</LI>
1: 	<LI>XID varchar(15) - the transaction ID.</LI>
1: 	<LI>LCCID varchar(15) - the connection ID.</LI>
1: 	<LI>DATABASE varchar(128) -  Database name
1: 	<LI>DRDAID  varchar(50) - nullable. DRDA ID for network server session.
1: 	<LI>LOGTEXT long varchar - text of the statement or commit or rollback.</LI>
1: 	</UL>
1: 
1:  */
1: public class ErrorLogReader extends VTITemplate
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
1: 	/*
1: 	** private 
1: 	*/
1: 	private boolean gotFile;
1: 	private InputStreamReader inputFileStreamReader;
1: 	private InputStream inputStream;
1: 	private BufferedReader bufferedReader;
1: 	private String inputFileName;
1: 
1: 	// Variables for current row
1: 	private String line;
0: 	private int gmtIndex;
1: 	private int threadIndex;
1: 	private int xidIndex;
1: 	private int lccidIndex;
1: 	private int databaseIndex;
1: 	private int drdaidIndex;
1: 
1: 
0: 	private static final String GMT_STRING = " GMT";
1: 	private static final String PARAMETERS_STRING = "Parameters:";
1: 	private static final String BEGIN_THREAD_STRING = "[";
1: 	private static final String END_THREAD_STRING = "]";
1: 	private static final String BEGIN_XID_STRING = "= ";
1: 	private static final String END_XID_STRING = ")";
1: 	private static final String BEGIN_DATABASE_STRING = "(DATABASE =";
1: 	private static final String END_DATABASE_STRING = ")";
1: 	private static final String BEGIN_DRDAID_STRING = "(DRDAID =";
1: 	private static final String END_DRDAID_STRING = ")";
1: 	private static final String BEGIN_EXECUTING_STRING = "Executing prepared";
1: 	private static final String END_EXECUTING_STRING = " :End prepared";
1: 
1: 
1: 	/**
1: 		ErrorLogReader() accesses the derby.log in
1: 		derby.system.home, if set, otherwise it looks in the current directory.
1: 		ErrorLogReader('filename') will access the specified
1: 		file name.
1: 	 */
0: 	public ErrorLogReader()
1: 	{
0: 		String home = System.getProperty("derby.system.home");
1: 
1: 		inputFileName = "derby.log";
1: 
1: 		if (home != null)
1: 		{
1: 			inputFileName = home + "/" + inputFileName;
1: 		}
1: 	}
1: 
0: 	public ErrorLogReader(String inputFileName)
1: 	{
1: 		this.inputFileName = inputFileName;
1: 	}
1: 
1: 	/**
1: 		@see java.sql.ResultSet#getMetaData
1: 	 */
1: 	public ResultSetMetaData getMetaData()
1: 	{
1: 		return metadata;
1: 	}
1: 
1: 	/**
1: 		@see java.sql.ResultSet#next
1: 		@exception SQLException If database-access error occurs.
1: 	 */
1: 	public boolean next() throws SQLException
1: 	{
1: 		if (! gotFile)
1: 		{
1: 			gotFile = true;
1: 		    try 
1: 			{
1: 		        inputFileStreamReader = new InputStreamReader(new FileInputStream(inputFileName));
1: 				bufferedReader = new BufferedReader(inputFileStreamReader, 32*1024);
1: 			} 
1: 			catch (FileNotFoundException ex) 
1: 			{
1: 				throw new SQLException(ex.getMessage());
1: 			}
1: 		}
1: 
1: 		while (true)
1: 		{
1: 			try
1: 			{
1: 				line = bufferedReader.readLine();
1: 			}
1: 			catch (java.io.IOException ioe)
1: 			{
1: 				throw new SQLException(ioe.getMessage());
1: 			}
1: 
1: 			if (line == null)
1: 			{
1: 				return false;
1: 			}
1: 
0: 			gmtIndex = line.indexOf(GMT_STRING);
1: 			threadIndex = line.indexOf(BEGIN_THREAD_STRING);
1: 			xidIndex = line.indexOf(BEGIN_XID_STRING);
1: 			lccidIndex = line.indexOf(BEGIN_XID_STRING, xidIndex + 1);
1: 			databaseIndex = line.indexOf(BEGIN_DATABASE_STRING, lccidIndex + 1);
1: 			drdaidIndex = line.indexOf(BEGIN_DRDAID_STRING, databaseIndex + 1);
1: 
1: 			// Skip parameters
1: 			if (line.indexOf(PARAMETERS_STRING) != -1)
1: 			{
1: 				continue;
1: 			}
1: 
0: 			if (gmtIndex != -1 && threadIndex != -1  && xidIndex != -1 && 
1: 				databaseIndex != -1)
1: 			{
1: 				return true;
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 		@see java.sql.ResultSet#close
1: 	 */
1: 	public void close()
1: 	{
1: 		if (bufferedReader != null)
1: 		{
1: 			try
1: 			{
1: 				bufferedReader.close();
1: 				inputFileStreamReader.close();
1: 			}
1: 			catch (java.io.IOException ioe)
1: 			{
1: 				// eat exceptions during close;
1: 			}
1: 			finally
1: 			{
1: 				bufferedReader = null;
1: 				inputFileStreamReader = null;
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 		All columns in the Db2jLogReader VTI have a of String type.
1: 		@see java.sql.ResultSet#getString
1: 		@exception SQLException If database-access error occurs.
1: 	 */
1: 	public String getString(int columnNumber)
1: 		throws SQLException
1: 	{
1: 		switch (columnNumber)
1: 		{
1: 			case 1:
0: 				return line.substring(0, gmtIndex);
1: 
1: 			case 2:
1: 				return line.substring(threadIndex + 1, line.indexOf(END_THREAD_STRING));
1: 
1: 			case 3:
1: 				return line.substring(xidIndex + 2, line.indexOf(END_XID_STRING, xidIndex));
1: 
1: 			case 4:
1: 				return line.substring(lccidIndex + 2, line.indexOf(END_XID_STRING, lccidIndex));
1: 
1: 			case 5:
1: 				return line.substring(databaseIndex + BEGIN_DATABASE_STRING.length(), line.indexOf(END_DATABASE_STRING, databaseIndex));
1: 			case 6:
1: 				return line.substring(drdaidIndex + BEGIN_DRDAID_STRING.length(), line.indexOf(END_DRDAID_STRING, drdaidIndex));
1: 			case 7:
1: 				/* Executing prepared statement is a special case as
1: 				 * it could span multiple lines
1: 				 */
0: 				String output;
1: 				if (line.indexOf(BEGIN_EXECUTING_STRING) == -1)
1: 				{
0: 					output = line.substring(line.indexOf(END_DRDAID_STRING, drdaidIndex) + 3);
1: 				}
1: 				else
1: 				{
1: 
1: 				/* We need to build string until we find the end of the text */
1: 				int endIndex = line.indexOf(END_EXECUTING_STRING, drdaidIndex);
1: 				if (endIndex == -1)
1: 				{
0: 					output = line.substring(line.indexOf(END_DRDAID_STRING, drdaidIndex) + 3);
1: 				}
1: 				else
1: 				{
0: 					output = line.substring(line.indexOf(END_XID_STRING, drdaidIndex) + 3,
0: 											endIndex);
1: 				}
1: 
1: 				while (endIndex == -1)
1: 				{
1: 					try
1: 					{
1: 						line = bufferedReader.readLine();
1: 					}
1: 					catch (java.io.IOException ioe)
1: 					{
1: 						throw new SQLException("Error reading file " + ioe);
1: 					}
1: 					endIndex = line.indexOf(END_EXECUTING_STRING);
1: 					if (endIndex == -1)
1: 					{
0: 						output = output + line;
1: 					}
1: 					else
1: 					{
0: 						output = output + line.substring(0, endIndex);
1: 					}
1: 				}
1: 				}
1: 
0: 				output = StringUtil.truncate(output, DB2Limit.DB2_VARCHAR_MAXWIDTH);
1: 
0: 				return output;
1: 
1: 			default:
1: 				return "";
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 		@see java.sql.ResultSet#wasNull
1: 	 */
1: 	public boolean wasNull()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/* MetaData
1: 	 */
1: 	
0: 	// column1: TS varchar(26) not null
1: 	// column2: THREADID varchar(40) not null
1: 	// column3: XID  varchar(15) not null
1: 	// column4: LCCID  varchar(15) not null
1: 	// column5: DATABASE varchar(128) not null
1: 	// column6: DRDAID varchar(50) nullable
1: 	// column5: LOGTEXT VARCHAR(max) not null
1: 	private static final ResultColumnDescriptor[] columnInfo = {
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("TS", Types.VARCHAR, false, 26),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("THREADID", Types.VARCHAR, false, 40),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("XID", Types.VARCHAR, false, 15),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("LCCID", Types.VARCHAR, false, 15),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("DATABASE", Types.VARCHAR, false, 128),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("DRDAID", Types.VARCHAR, true, 50),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("LOGTEXT",Types.VARCHAR, false, DB2Limit.DB2_VARCHAR_MAXWIDTH)
1: 	};
0: 	private static final ResultSetMetaData metadata = new EmbedResultSetMetaData(columnInfo);
1: 
1: }
1: 
1: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.diag
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.diag;
0: 
0: import java.io.BufferedReader;
0: import java.io.FileNotFoundException;
0: import java.io.InputStream;
0: import java.io.InputStreamReader;
0: import java.io.FileInputStream;
0: 
0: import java.util.Hashtable;
0: import java.util.Enumeration;
0: import java.util.Properties;
0: import java.sql.ResultSetMetaData;
0: import java.sql.SQLException;
0: import java.sql.Types;
0: import org.apache.derby.vti.VTITemplate;
0: import org.apache.derby.iapi.reference.DB2Limit;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData;
0: 
0: /**
0: 
0: 	ErrorLogReader is a virtual table interface (VTI) which contains all the statements
0: 	of "interest" in db2j.<!-- -->log or a specified file when
0: 	db2j.<!-- -->language.<!-- -->logStatementText=true.
0: 	
0: 	
0: 	<P>One use of this VTI is to determine the active transactions
0: 	and the SQL statements in those transactions at a given point in time, say
0: 	when a deadlock or lock timeout occurred.  In order to do that, you must first
0: 	find the timestamp (timestampConstant) of interest in the error log.  
0: 	The SQL to view the active transactions at a given in time is:
0: 	<PRE>SELECT vti.ts, threadid, cast(xid as int) as xid_int, cast(lccid as int) as lccid_int, logtext 
0: 		 FROM new org.apache.derby.diag.ErrorLogReader() vti, 
0: 			(VALUES timestampConstant) t(ts)
0: 		 WHERE vti.ts <= t.ts AND 
0: 				vti.ts >
0: 					(SELECT MAX(ts) IS NULL ? '2000-01-01 00:00:00.1' : MAX(ts)
0: 					 FROM new org.apache.derby.diag.ErrorLogReader() vti_i
0: 					 WHERE (logtext LIKE 'Committing%' OR
0: 							logtext LIKE 'Rolling%') AND
0: 						   vti.xid = vti_i.xid AND ts < t.ts)
0: 		 ORDER BY xid_int, vti.ts
0: 	</PRE>
0: 
0: 	<P>The ErrorLogReader virtual table has the following columns:
0: 	<UL><LI>TS varchar(26) - the timestamp of the statement.</LI>
0: 	<LI>THREADID varchar(40) - the thread name.</LI>
0: 	<LI>XID varchar(15) - the transaction ID.</LI>
0: 	<LI>LCCID varchar(15) - the connection ID.</LI>
0: 	<LI>DATABASE varchar(128) -  Database name
0: 	<LI>DRDAID  varchar(50) - nullable. DRDA ID for network server session.
0: 	<LI>LOGTEXT long varchar - text of the statement or commit or rollback.</LI>
0: 	</UL>
0: 
0:  */
0: public class ErrorLogReader extends VTITemplate
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0: 	/*
0: 	** private 
0: 	*/
0: 	private boolean gotFile;
0: 	private InputStreamReader inputFileStreamReader;
0: 	private InputStream inputStream;
0: 	private BufferedReader bufferedReader;
0: 	private String inputFileName;
0: 
0: 	// Variables for current row
0: 	private String line;
0: 	private int gmtIndex;
0: 	private int threadIndex;
0: 	private int xidIndex;
0: 	private int lccidIndex;
0: 	private int databaseIndex;
0: 	private int drdaidIndex;
0: 
0: 
0: 	private static final String GMT_STRING = " GMT";
0: 	private static final String PARAMETERS_STRING = "Parameters:";
0: 	private static final String BEGIN_THREAD_STRING = "[";
0: 	private static final String END_THREAD_STRING = "]";
0: 	private static final String BEGIN_XID_STRING = "= ";
0: 	private static final String END_XID_STRING = ")";
0: 	private static final String BEGIN_DATABASE_STRING = "(DATABASE =";
0: 	private static final String END_DATABASE_STRING = ")";
0: 	private static final String BEGIN_DRDAID_STRING = "(DRDAID =";
0: 	private static final String END_DRDAID_STRING = ")";
0: 	private static final String BEGIN_EXECUTING_STRING = "Executing prepared";
0: 	private static final String END_EXECUTING_STRING = " :End prepared";
0: 
0: 
0: 	/**
0: 		ErrorLogReader() accesses the derby.log in
0: 		derby.system.home, if set, otherwise it looks in the current directory.
0: 		ErrorLogReader('filename') will access the specified
0: 		file name.
0: 	 */
0: 	public ErrorLogReader()
0: 	{
0: 		String home = System.getProperty("derby.system.home");
0: 
0: 		inputFileName = "derby.log";
0: 
0: 		if (home != null)
0: 		{
0: 			inputFileName = home + "/" + inputFileName;
0: 		}
0: 	}
0: 
0: 	public ErrorLogReader(String inputFileName)
0: 	{
0: 		this.inputFileName = inputFileName;
0: 	}
0: 
0: 	/**
0: 		@see java.sql.ResultSet#getMetaData
0: 	 */
0: 	public ResultSetMetaData getMetaData()
0: 	{
0: 		return metadata;
0: 	}
0: 
0: 	/**
0: 		@see java.sql.ResultSet#next
0: 		@exception SQLException If database-access error occurs.
0: 	 */
0: 	public boolean next() throws SQLException
0: 	{
0: 		if (! gotFile)
0: 		{
0: 			gotFile = true;
0: 		    try 
0: 			{
0: 		        inputFileStreamReader = new InputStreamReader(new FileInputStream(inputFileName));
0: 				bufferedReader = new BufferedReader(inputFileStreamReader, 32*1024);
0: 			} 
0: 			catch (FileNotFoundException ex) 
0: 			{
0: 				throw new SQLException(ex.getMessage());
0: 			}
0: 		}
0: 
0: 		while (true)
0: 		{
0: 			try
0: 			{
0: 				line = bufferedReader.readLine();
0: 			}
0: 			catch (java.io.IOException ioe)
0: 			{
0: 				throw new SQLException(ioe.getMessage());
0: 			}
0: 
0: 			if (line == null)
0: 			{
0: 				return false;
0: 			}
0: 
0: 			gmtIndex = line.indexOf(GMT_STRING);
0: 			threadIndex = line.indexOf(BEGIN_THREAD_STRING);
0: 			xidIndex = line.indexOf(BEGIN_XID_STRING);
0: 			lccidIndex = line.indexOf(BEGIN_XID_STRING, xidIndex + 1);
0: 			databaseIndex = line.indexOf(BEGIN_DATABASE_STRING, lccidIndex + 1);
0: 			drdaidIndex = line.indexOf(BEGIN_DRDAID_STRING, databaseIndex + 1);
0: 
0: 			// Skip parameters
0: 			if (line.indexOf(PARAMETERS_STRING) != -1)
0: 			{
0: 				continue;
0: 			}
0: 
0: 			if (gmtIndex != -1 && threadIndex != -1  && xidIndex != -1 && 
0: 				databaseIndex != -1)
0: 			{
0: 				return true;
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 		@see java.sql.ResultSet#close
0: 	 */
0: 	public void close()
0: 	{
0: 		if (bufferedReader != null)
0: 		{
0: 			try
0: 			{
0: 				bufferedReader.close();
0: 				inputFileStreamReader.close();
0: 			}
0: 			catch (java.io.IOException ioe)
0: 			{
0: 				// eat exceptions during close;
0: 			}
0: 			finally
0: 			{
0: 				bufferedReader = null;
0: 				inputFileStreamReader = null;
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 		All columns in the Db2jLogReader VTI have a of String type.
0: 		@see java.sql.ResultSet#getString
0: 		@exception SQLException If database-access error occurs.
0: 	 */
0: 	public String getString(int columnNumber)
0: 		throws SQLException
0: 	{
0: 		switch (columnNumber)
0: 		{
0: 			case 1:
0: 				return line.substring(0, gmtIndex);
0: 
0: 			case 2:
0: 				return line.substring(threadIndex + 1, line.indexOf(END_THREAD_STRING));
0: 
0: 			case 3:
0: 				return line.substring(xidIndex + 2, line.indexOf(END_XID_STRING, xidIndex));
0: 
0: 			case 4:
0: 				return line.substring(lccidIndex + 2, line.indexOf(END_XID_STRING, lccidIndex));
0: 
0: 			case 5:
0: 				return line.substring(databaseIndex + BEGIN_DATABASE_STRING.length(), line.indexOf(END_DATABASE_STRING, databaseIndex));
0: 			case 6:
0: 				return line.substring(drdaidIndex + BEGIN_DRDAID_STRING.length(), line.indexOf(END_DRDAID_STRING, drdaidIndex));
0: 			case 7:
0: 				/* Executing prepared statement is a special case as
0: 				 * it could span multiple lines
0: 				 */
0: 				String output;
0: 				if (line.indexOf(BEGIN_EXECUTING_STRING) == -1)
0: 				{
0: 					output = line.substring(line.indexOf(END_DRDAID_STRING, drdaidIndex) + 3);
0: 				}
0: 				else
0: 				{
0: 
0: 				/* We need to build string until we find the end of the text */
0: 				int endIndex = line.indexOf(END_EXECUTING_STRING, drdaidIndex);
0: 				if (endIndex == -1)
0: 				{
0: 					output = line.substring(line.indexOf(END_DRDAID_STRING, drdaidIndex) + 3);
0: 				}
0: 				else
0: 				{
0: 					output = line.substring(line.indexOf(END_XID_STRING, drdaidIndex) + 3,
0: 											endIndex);
0: 				}
0: 
0: 				while (endIndex == -1)
0: 				{
0: 					try
0: 					{
0: 						line = bufferedReader.readLine();
0: 					}
0: 					catch (java.io.IOException ioe)
0: 					{
0: 						throw new SQLException("Error reading file " + ioe);
0: 					}
0: 					endIndex = line.indexOf(END_EXECUTING_STRING);
0: 					if (endIndex == -1)
0: 					{
0: 						output = output + line;
0: 					}
0: 					else
0: 					{
0: 						output = output + line.substring(0, endIndex);
0: 					}
0: 				}
0: 				}
0: 
0: 				output = StringUtil.truncate(output, DB2Limit.DB2_VARCHAR_MAXWIDTH);
0: 
0: 				return output;
0: 
0: 			default:
0: 				return "";
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 		@see java.sql.ResultSet#wasNull
0: 	 */
0: 	public boolean wasNull()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/* MetaData
0: 	 */
0: 	
0: 	// column1: TS varchar(26) not null
0: 	// column2: THREADID varchar(40) not null
0: 	// column3: XID  varchar(15) not null
0: 	// column4: LCCID  varchar(15) not null
0: 	// column5: DATABASE varchar(128) not null
0: 	// column6: DRDAID varchar(50) nullable
0: 	// column5: LOGTEXT VARCHAR(max) not null
0: 	private static final ResultColumnDescriptor[] columnInfo = {
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("TS", Types.VARCHAR, false, 26),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("THREADID", Types.VARCHAR, false, 40),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("XID", Types.VARCHAR, false, 15),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("LCCID", Types.VARCHAR, false, 15),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("DATABASE", Types.VARCHAR, false, 128),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("DRDAID", Types.VARCHAR, true, 50),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("LOGTEXT",Types.VARCHAR, false, DB2Limit.DB2_VARCHAR_MAXWIDTH)
0: 	};
0: 	private static final ResultSetMetaData metadata = new EmbedResultSetMetaData(columnInfo);
0: 
0: }
0: 
0: 
============================================================================