1:b2b30ec: /*
5:b2b30ec: 
1:b2b30ec:    Derby - Class org.apache.derby.impl.jdbc.LOBStreamControl
1:b2b30ec: 
1:bb0c274:    Licensed to the Apache Software Foundation (ASF) under one
1:bb0c274:    or more contributor license agreements.  See the NOTICE file
1:bb0c274:    distributed with this work for additional information
1:bb0c274:    regarding copyright ownership.  The ASF licenses this file
1:bb0c274:    to you under the Apache License, Version 2.0 (the
1:bb0c274:    "License"); you may not use this file except in compliance
1:bb0c274:    with the License.  You may obtain a copy of the License at
1:b2b30ec: 
1:bb0c274:      http://www.apache.org/licenses/LICENSE-2.0
1:b2b30ec: 
1:bb0c274:    Unless required by applicable law or agreed to in writing,
1:bb0c274:    software distributed under the License is distributed on an
1:bb0c274:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:bb0c274:    KIND, either express or implied.  See the License for the
1:bb0c274:    specific language governing permissions and limitations
1:bb0c274:    under the License.
1:b2b30ec: 
3:b2b30ec:  */
1:b2b30ec: package org.apache.derby.impl.jdbc;
1:b2b30ec: 
1:b2b30ec: import java.io.EOFException;
1:b2b30ec: import java.io.IOException;
1:b2b30ec: import java.io.InputStream;
1:b2b30ec: import java.io.OutputStream;
1:bde5241: import java.io.UTFDataFormatException;
1:b2b30ec: import java.security.AccessController;
1:ec69f5f: import java.security.PrivilegedAction;
1:b2b30ec: import java.security.PrivilegedActionException;
1:b2b30ec: import java.security.PrivilegedExceptionAction;
1:b2b30ec: import org.apache.derby.iapi.error.StandardException;
1:b2b30ec: import org.apache.derby.iapi.reference.Property;
1:b2b30ec: import org.apache.derby.iapi.reference.SQLState;
1:bde5241: import org.apache.derby.iapi.services.i18n.MessageService;
1:b2b30ec: import org.apache.derby.iapi.services.monitor.Monitor;
1:b2b30ec: import org.apache.derby.iapi.store.raw.data.DataFactory;
1:b2b30ec: import org.apache.derby.io.StorageFile;
1:b175fd2: import org.apache.derby.iapi.error.ExceptionUtil;
1:bde5241: import org.apache.derby.shared.common.reference.MessageId;
1:b2b30ec: 
3:b2b30ec: /**
1:b2b30ec:  * This class acts as a layer of blob/clob repository (in memory or file).
1:d2b4fdb:  * The max bytes of data stored in memory depends on the way this
1:d2b4fdb:  * class is created. If the class is created with initial data, the buffer
1:c2fe280:  * size is set to the size of the byte array supplied, but no larger than
1:c2fe280:  * MAX_BUF_SIZE. If no initial data is supplied, or if the initial data size
1:c2fe280:  * is less than DEFAULT_BUF_SIZE, the buffer size is set to DEFAULT_BUF_SIZE.
1:d2b4fdb:  * When write increases the data beyond this value a temporary file is created
1:d2b4fdb:  * and data is moved into that. If truncate reduces the size of the file below
1:c2fe280:  * initial buffer size, the data is moved into memory.
1:b2b30ec:  *
1:d2b4fdb:  * This class also creates InputStream and OutputStream which can be used to access
1:b2b30ec:  * blob data irrespective of if its in memory or in file.
1:b2b30ec:  */
1:b2b30ec: 
1:ec69f5f: final class LOBStreamControl {
1:2333262:     private LOBFile tmpFile;
1:b2b30ec:     private byte [] dataBytes = new byte [0];
1:b2b30ec:     private boolean isBytes = true;
1:d2b4fdb:     private final int bufferSize;
1:10e4538:     private final EmbedConnection conn;
1:e1fc783:     private long updateCount;
1:c2fe280:     private static final int DEFAULT_BUF_SIZE = 4096;
1:c2fe280:     private static final int MAX_BUF_SIZE = 32768;
1:b2b30ec: 
1:d2b4fdb:     /**
1:d2b4fdb:      * Creates an empty LOBStreamControl.
1:10e4538:      * @param conn Connection for this lob
1:d2b4fdb:      */
1:10e4538:     LOBStreamControl (EmbedConnection conn) {
1:10e4538:         this.conn = conn;
1:e1fc783:         updateCount = 0;
1:d2b4fdb:         //default buffer size
1:c2fe280:         bufferSize = DEFAULT_BUF_SIZE;
1:d2b4fdb:     }
1:d2b4fdb: 
1:d2b4fdb:     /**
1:d2b4fdb:      * Creates a LOBStreamControl and initializes with a bytes array.
1:10e4538:      * @param conn Connection for this lob
1:d2b4fdb:      * @param data initial value
1:d2b4fdb:      */
1:10e4538:     LOBStreamControl (EmbedConnection conn, byte [] data)
1:1c589af:             throws IOException, StandardException {
1:10e4538:         this.conn = conn;
1:d2b4fdb:         updateCount = 0;
1:c2fe280:         bufferSize =
1:c2fe280:             Math.min(Math.max(DEFAULT_BUF_SIZE, data.length), MAX_BUF_SIZE);
1:d2b4fdb:         write (data, 0, data.length, 0);
11:b2b30ec:     }
1:e1fc783: 
1:2333262:     private void init(byte [] b, long len)
1:1c589af:             throws IOException, StandardException {
1:56c1dc2:         Object monitor = findService(
1:ec69f5f:                 Property.DATABASE_MODULE, conn.getDBName());
1:56c1dc2:         final DataFactory df = (DataFactory) findServiceModule(
1:ec69f5f:                 monitor, DataFactory.MODULE);
3:b2b30ec:         try {
1:71c8e86:             AccessController.doPrivileged (new PrivilegedExceptionAction<Object>() {
1:ec69f5f:                 public Object run() throws IOException {
1:2420903:                     //create a temporary file
1:2fb5c8d:                     StorageFile lobFile =
1:b2b30ec:                         df.getStorageFactory().createTemporaryFile("lob", null);
1:2333262:                     if (df.databaseEncrypted()) {
1:2333262:                         tmpFile = new EncryptedLOBFile (lobFile, df);
1:ec69f5f:                     } else {
1:2333262:                         tmpFile = new LOBFile (lobFile);
1:ec69f5f:                     }
2:b2b30ec:                     return null;
1:2333262:                 }
2:b2b30ec:             });
1:b2b30ec:         }
2:b2b30ec:         catch (PrivilegedActionException pae) {
1:ec69f5f:             throw (IOException) pae.getCause();
1:b2b30ec:         }
1:ec69f5f: 
1:ec69f5f:         conn.addLobFile(tmpFile);
1:b2b30ec:         isBytes = false;
1:b2b30ec:         //now this call will write into the file
1:b2b30ec:         if (len != 0)
1:b2b30ec:             write(b, 0, (int) len, 0);
1:d2b4fdb:         dataBytes = null;
1:b2b30ec:     }
1:b2b30ec: 
1:b2b30ec:     private long updateData(byte[] bytes, int offset, int len, long pos)
1:1c589af:             throws StandardException {
1:b2b30ec:         if (dataBytes == null) {
1:b2b30ec:             if ((int) pos == 0) {
1:b2b30ec:                 dataBytes = new byte [len];
1:b2b30ec:                 System.arraycopy(bytes, offset, dataBytes, (int) pos, len);
1:b2b30ec:                 return len;
1:b2b30ec:             }
2:b2b30ec:             else {
1:b2b30ec:                 //invalid postion
1:1c589af:                 throw StandardException.newException(
1:ce40a31:                         SQLState.BLOB_POSITION_TOO_LARGE, pos);
1:b2b30ec:             }
1:b2b30ec:         }
1:b2b30ec:         else {
1:b2b30ec:             if (pos > dataBytes.length) {
1:b2b30ec:                 //invalid postion
1:1c589af:                 throw StandardException.newException(
1:ce40a31:                         SQLState.BLOB_POSITION_TOO_LARGE, pos);
1:b2b30ec:             }
1:b2b30ec:             else {
1:b2b30ec:                 if (pos + len < dataBytes.length) {
1:b2b30ec:                     System.arraycopy(bytes, offset, dataBytes, (int) pos, len);
1:b2b30ec:                 }
1:b2b30ec:                 else {
1:b2b30ec:                     byte [] tmpBytes = new byte [len + (int) pos];
1:b2b30ec:                     System.arraycopy(dataBytes, 0 , tmpBytes, 0, (int) pos);
1:b2b30ec:                     System.arraycopy(bytes, offset, tmpBytes, (int) pos, len);
1:b2b30ec:                     dataBytes = tmpBytes;
1:b2b30ec:                 }
1:b2b30ec:             }
1:b2b30ec:             return pos + len;
1:b2b30ec:         }
1:b2b30ec:     }
1:b2b30ec: 
1:2333262:     private void isValidPostion(long pos)
1:1c589af:             throws IOException, StandardException {
1:b2b30ec:         if (pos < 0)
1:1c589af:             throw StandardException.newException(
1:ce40a31:                 SQLState.BLOB_NONPOSITIVE_LENGTH, (pos + 1));
1:b2b30ec:         if (pos > Integer.MAX_VALUE)
1:1c589af:             throw StandardException.newException(
1:ce40a31:                     SQLState.BLOB_POSITION_TOO_LARGE, (pos + 1));
1:b2b30ec: 
2:b2b30ec:         if (isBytes) {
1:b2b30ec:             if (dataBytes == null) {
1:b2b30ec:                 if (pos != 0)
1:1c589af:                     throw StandardException.newException(
1:ce40a31:                             SQLState.BLOB_POSITION_TOO_LARGE, (pos + 1));
1:b2b30ec:             } else if (dataBytes.length < pos)
1:1c589af:                 throw StandardException.newException(
1:ce40a31:                         SQLState.BLOB_POSITION_TOO_LARGE, (pos + 1));
1:b2b30ec:         } else {
1:b2b30ec:             if (pos > tmpFile.length())
1:1c589af:                 throw StandardException.newException(
1:ce40a31:                         SQLState.BLOB_POSITION_TOO_LARGE, (pos + 1));
1:b2b30ec:         }
1:b2b30ec:     }
1:b2b30ec: 
1:1c589af:     private void isValidOffset(int off, int length) throws StandardException {
1:b2b30ec:         if (off < 0 || off > length)
1:1c589af:             throw StandardException.newException(
1:ce40a31:                     SQLState.BLOB_INVALID_OFFSET, off);
1:b2b30ec:     }
1:b2b30ec: 
1:bde5241:     /**
1:b2b30ec:      * Writes one byte.
1:b2b30ec:      * @param b byte
1:b2b30ec:      * @param pos
1:ec69f5f:      * @return new position
1:ec69f5f:      * @throws IOException if writing to the LOB file fails
1:ec69f5f:      * @throws StandardException if encrypting/decrypting the LOB file fails
1:b2b30ec:      */
1:2333262:     synchronized long write(int b, long pos)
1:1c589af:             throws IOException, StandardException {
3:b2b30ec:         isValidPostion(pos);
1:e1fc783:         updateCount++;
1:b2b30ec:         if (isBytes) {
1:d2b4fdb:             if (pos < bufferSize) {
1:b2b30ec:                 byte [] bytes = {(byte) b};
1:b2b30ec:                 updateData(bytes, 0, 1, pos);
1:b2b30ec:                 return pos + 1;
1:b2b30ec:             } else {
2:b2b30ec:                 init(dataBytes, pos);
1:b2b30ec:             }
1:b2b30ec:         }
1:2420903:         tmpFile.seek(pos);
2:b2b30ec:         tmpFile.write(b);
2:b2b30ec:         return tmpFile.getFilePointer();
1:b2b30ec:     }
1:b2b30ec: 
1:e1fc783:     /**
1:0c5c5aa:      * Writes {@code len} bytes from the specified byte array to the LOB.
1:0c5c5aa:      *
1:b2b30ec:      * @param b byte array
1:b2b30ec:      * @param off offset from where to read from the byte array
1:0c5c5aa:      * @param len number of bytes to be written
1:0c5c5aa:      * @param pos starting position
1:0c5c5aa:      * @return The position after the bytes have been written to the LOB.
1:0c5c5aa:      * @throws IOException if writing to the LOB fails
1:0c5c5aa:      * @throws StandardException if writing to the LOB fails
1:0c5c5aa:      * @throws IndexOutOfBoundsException if {@code len} is larger than
1:0c5c5aa:      *       {@code b.length - off}
1:b2b30ec:      */
1:b2b30ec:     synchronized long write(byte[] b, int off, int len, long pos)
1:1c589af:             throws IOException, StandardException {
1:1c589af:         isValidPostion(pos);
1:2333262:         try {
1:b2b30ec:             isValidOffset(off, b.length);
1:1c589af:         } catch (StandardException e) {
1:b2b30ec:             if (e.getSQLState().equals(
1:b2b30ec:                     ExceptionUtil.getSQLStateFromIdentifier(
1:b2b30ec:                                   SQLState.BLOB_INVALID_OFFSET)))
1:b2b30ec:                     throw new ArrayIndexOutOfBoundsException (e.getMessage());
1:5d54436:             throw e;
1:b2b30ec:         }
1:e1fc783:         updateCount++;
1:b2b30ec:         if (isBytes) {
1:d2b4fdb:             if (pos + len <= bufferSize)
1:b2b30ec:                 return updateData(b, off, len, pos);
1:b2b30ec:             else {
1:b2b30ec:                 init(dataBytes, pos);
1:b2b30ec:             }
1:b2b30ec:         }
1:2420903:         tmpFile.seek(pos);
1:b2b30ec:         tmpFile.write(b, off, len);
1:b2b30ec:         return tmpFile.getFilePointer();
1:b2b30ec:     }
1:b2b30ec: 
1:b2b30ec:     /**
1:b2b30ec:      * Reads one byte.
1:ec69f5f:      * @param pos position from where to read
1:b2b30ec:      * @return byte
1:ec69f5f:      * @throws IOException if reading the LOB file fails
1:ec69f5f:      * @throws StandardException if decrypting an encrypted LOB file fails
1:b2b30ec:      */
1:2333262:     synchronized int read(long pos)
1:1c589af:             throws IOException, StandardException {
1:b2b30ec:         isValidPostion(pos);
1:b2b30ec:         if (isBytes) {
1:b2b30ec:             if (dataBytes.length == pos)
1:b2b30ec:                 return -1;
1:b2b30ec:             return dataBytes [(int) pos] & 0xff;
1:b2b30ec:         }
5:b2b30ec:         if (tmpFile.getFilePointer() != pos)
5:b2b30ec:             tmpFile.seek(pos);
1:b2b30ec:         try {
1:b2b30ec:             return tmpFile.readByte() & 0xff;
1:b2b30ec:         }
1:b2b30ec:         catch (EOFException eof) {
1:b2b30ec:             return -1;
1:b2b30ec:         }
1:b2b30ec:     }
1:b2b30ec: 
1:b2b30ec:     private int readBytes(byte [] b, int off, int len, long pos) {
1:5d54436:         if (pos >= dataBytes.length)
1:5d54436:             return -1;
1:b2b30ec:         int lengthFromPos = dataBytes.length - (int) pos;
1:b2b30ec:         int actualLength = len > lengthFromPos ? lengthFromPos : len;
1:b2b30ec:         System.arraycopy(dataBytes, (int) pos, b, off, actualLength);
1:b2b30ec:         return actualLength;
1:b2b30ec:     }
1:b2b30ec: 
1:b2b30ec:     /**
1:b2b30ec:      * Reads bytes starting from 'position' into bytes array.
1:b2b30ec:      * starting from 'offset'
1:3e5168c:      * @param buff array into the bytes will be copied
1:b2b30ec:      * @param off offset from where the array has to be populated
1:b2b30ec:      * @param len number of bytes to read
1:ec69f5f:      * @param pos initial position before reading
1:ec69f5f:      * @return number new position
1:ec69f5f:      * @throws IOException if reading the LOB file fails
1:ec69f5f:      * @throws StandardException if decrypting an encrypted LOB file fails
1:b2b30ec:      */
1:b2b30ec:     synchronized int read(byte[] buff, int off, int len, long pos)
1:1c589af:             throws IOException, StandardException {
1:b2b30ec:         isValidPostion(pos);
1:b2b30ec:         isValidOffset(off, buff.length);
1:b2b30ec:         if (isBytes) {
1:b2b30ec:             return readBytes(buff, off, len, pos);
1:b2b30ec:         }
1:2420903:         tmpFile.seek(pos);
1:b2b30ec:         return tmpFile.read (buff, off, len);
1:b2b30ec:     }
1:b2b30ec: 
1:b2b30ec:     /**
1:b2b30ec:      * returns input stream linked with this object.
1:b2b30ec:      * @param pos initial postion
1:b2b30ec:      * @return InputStream
1:b2b30ec:      */
1:b2b30ec:     InputStream getInputStream(long pos) {
1:b2b30ec:         return new LOBInputStream(this, pos);
1:b2b30ec:     }
1:b2b30ec: 
1:b2b30ec:     /**
1:b2b30ec:      * returns output stream linked with this object
1:b2b30ec:      * @param pos initial postion
1:b2b30ec:      * @return OutputStream
1:b2b30ec:      */
1:b2b30ec:     OutputStream getOutputStream(long pos) {
1:b2b30ec:         return new LOBOutputStream(this, pos);
1:b2b30ec:     }
1:b2b30ec: 
1:b2b30ec:     /**
1:b2b30ec:      * Returns length of data.
1:b2b30ec:      * @return length
1:b2b30ec:      * @throws IOException
1:b2b30ec:      */
1:b2b30ec:     long getLength() throws IOException {
1:b2b30ec:         if (isBytes)
1:b2b30ec:             return dataBytes.length;
1:b2b30ec:         return tmpFile.length();
1:b2b30ec:     }
1:b2b30ec: 
1:b2b30ec:     /**
1:b2b30ec:      * Resets the size.
1:ec69f5f:      * @param size new size should be smaller than existing size
1:1c589af:      * @throws IOException
1:b2b30ec:      */
1:2333262:     synchronized void truncate(long size)
1:1c589af:             throws IOException, StandardException {
1:b2b30ec:         isValidPostion(size);
1:b2b30ec:         if (isBytes) {
1:b2b30ec:             byte [] tmpByte = new byte [(int) size];
1:b2b30ec:             System.arraycopy(dataBytes, 0, tmpByte, 0, (int) size);
1:27be4fc:             dataBytes = tmpByte;
1:b2b30ec:         } else {
1:d2b4fdb:             if (size < bufferSize) {
1:b2b30ec:                 dataBytes = new byte [(int) size];
1:2420903:                 read(dataBytes, 0, dataBytes.length, 0);
1:b2b30ec:                 isBytes = true;
1:2fb5c8d:                 releaseTempFile(tmpFile);
1:b2b30ec:                 tmpFile = null;
1:2333262:             } else {
1:2333262:                 tmpFile.setLength(size);
1:2333262:             }
1:2333262:         }
1:2333262:     }
1:b2b30ec: 
1:b2b30ec:     /**
1:b2b30ec:      * Copies bytes from stream to local storage.
1:e8fd686:      * <p>
1:e8fd686:      * Note that specifying the length as {@code Long.MAX_VALUE} results in
1:e8fd686:      * reading data from the stream until EOF is reached, but no length checking
1:e8fd686:      * will be performed.
1:e8fd686:      *
1:e8fd686:      * @param inStream the stream to copy from
1:e8fd686:      * @param length number of bytes to be copied, or {@code Long.MAX_VALUE} to
1:e8fd686:      *      copy everything until EOF is reached
1:ec69f5f:      * @throws IOException if reading or writing a LOB file fails
1:ec69f5f:      * @throws StandardException if encrypting or decrypting a LOB file fails
1:b2b30ec:      */
1:1c589af:     synchronized void copyData(InputStream inStream, long length)
1:1c589af:             throws IOException, StandardException {
1:d2b4fdb:         byte [] data = new byte [bufferSize];
1:b2b30ec:         long sz = 0;
1:b2b30ec:         while (sz < length) {
1:d2b4fdb:             int len = (int) Math.min (length - sz, bufferSize);
1:ba50299:             len = inStream.read(data, 0, len);
1:e8fd686:             if (len == -1) {
1:e8fd686:                 if (length != Long.MAX_VALUE) {
1:e8fd686:                     // We reached EOF before all the requested bytes are read.
1:bde5241:                     throw new EOFException(MessageService.getTextMessage(
1:bde5241:                             MessageId.STREAM_PREMATURE_EOF,
1:ce40a31:                             length, sz));
1:e8fd686:                 } else {
1:e8fd686:                     // End of data, but no length checking.
1:e8fd686:                     break;
1:e8fd686:                 }
1:e8fd686:             }
1:b2b30ec:             write(data, 0, len, sz);
1:b2b30ec:             sz += len;
1:b2b30ec:         }
1:bde5241:         // If we copied until EOF, and we read more data than the length of the
1:bde5241:         // marker, see if we have a Derby end-of-stream marker.
1:bde5241:         long curLength = getLength();
1:bde5241:         if (length == Long.MAX_VALUE && curLength > 2) {
1:e8fd686:             byte[] eos = new byte[3];
1:e8fd686:             // Read the three last bytes, marker is 0xE0 0x00 0x00.
1:e8fd686:             read(eos, 0, 3, curLength -3);
1:e8fd686:             if ((eos[0] & 0xFF) == 0xE0 && (eos[1] & 0xFF) == 0x00 &&
1:e8fd686:                     (eos[2] & 0xFF) == 0x00) {
1:e8fd686:                 // Remove Derby end-of-stream-marker.
1:e8fd686:                 truncate(curLength -3);
1:e8fd686:             }
1:e8fd686:         }
1:b2b30ec:     }
1:b2b30ec: 
1:b2b30ec:     /**
1:bde5241:      * Copies UTF-8 encoded chars from a stream to local storage.
1:bde5241:      * <p>
1:bde5241:      * Note that specifying the length as {@code Long.MAX_VALUE} results in
1:bde5241:      * reading data from the stream until EOF is reached, but no length checking
1:bde5241:      * will be performed.
1:bde5241:      *
1:bde5241:      * @param utf8Stream the stream to copy from
1:bde5241:      * @param charLength number of chars to be copied, or {@code Long.MAX_VALUE}
1:bde5241:      *      to copy everything until EOF is reached
1:bde5241:      * @return The number of characters copied.
1:bde5241:      * @throws EOFException if EOF is reached prematurely
1:bde5241:      * @throws IOException thrown on a number of error conditions
1:bde5241:      * @throws StandardException if reading, writing or truncating the
1:bde5241:      *      {@code LOBStreamControl}-object fails
1:bde5241:      * @throws UTFDataFormatException if an invalid UTF-8 encoding is detected
1:bde5241:      */
1:bde5241:     synchronized long copyUtf8Data(final InputStream utf8Stream,
1:bde5241:                                    final long charLength)
1:bde5241:             throws IOException, StandardException {
1:bde5241:         long charCount = 0; // Number of chars read
1:bde5241:         int offset = 0;     // Where to start looking for the start of a char
1:bde5241:         int read = 0;       // Number of bytes read
1:bde5241:         final byte[] buf = new byte[bufferSize];
1:bde5241:         while (charCount < charLength) {
1:bde5241:             int readNow = utf8Stream.read(buf, 0,
1:bde5241:                             (int)Math.min(buf.length, charLength - charCount));
1:bde5241:             if (readNow == -1) {
1:bde5241:                 break;
1:bde5241:             }
1:bde5241:             // Count the characters.
1:bde5241:             while (offset < readNow) {
1:bde5241:                 int c = buf[offset] & 0xFF;
1:bde5241:                 if ((c & 0x80) == 0x00) { // 8th bit not set (top bit)
1:bde5241:                     offset++;
1:bde5241:                 } else if ((c & 0x60) == 0x40) { // 7th bit set, 6th bit unset
1:bde5241:                     // Found char of two byte width.
1:bde5241:                     offset += 2;
1:bde5241:                 } else if ((c & 0x70) == 0x60) { // 7th & 6th bit set, 5th unset
1:bde5241:                     // Found char of three byte width.
1:bde5241:                     offset += 3;
1:bde5241:                 } else {
1:bde5241:                     // This shouldn't happen, as the data is coming from the
1:bde5241:                     // store and is supposed to be well-formed.
1:bde5241:                     // If it happens, fail and print some internal information.
1:bde5241:                     throw new UTFDataFormatException("Invalid UTF-8 encoding: "
1:bde5241:                             + Integer.toHexString(c) + ", charCount=" +
1:bde5241:                             charCount + ", offset=" + offset);
1:bde5241:                 }
1:bde5241:                 charCount++;
1:bde5241:             }
1:bde5241:             offset -= readNow; // Starting offset for next iteration
1:bde5241:             write(buf, 0, readNow, read);
1:bde5241:             read += readNow;
1:bde5241:         }
1:bde5241:         // See if an EOF-marker ended the stream. Don't check if we have fewer
1:bde5241:         // bytes than the marker length.
1:bde5241:         long curLength = getLength();
1:bde5241:         if (curLength > 2) {
1:bde5241:             byte[] eos = new byte[3];
1:bde5241:             // Read the three last bytes, marker is 0xE0 0x00 0x00.
1:bde5241:             read(eos, 0, 3, curLength -3);
1:bde5241:             if ((eos[0] & 0xFF) == 0xE0 && (eos[1] & 0xFF) == 0x00 &&
1:bde5241:                     (eos[2] & 0xFF) == 0x00) {
1:bde5241:                 // Remove Derby end-of-stream-marker.
1:bde5241:                 truncate(curLength -3);
1:bde5241:                 charCount--;
1:bde5241:             }
1:bde5241:         }
1:bde5241:         if (charLength != Long.MAX_VALUE && charCount != charLength) {
1:bde5241:             throw new EOFException(MessageService.getTextMessage(
1:bde5241:                     MessageId.STREAM_PREMATURE_EOF,
1:ce40a31:                     charLength, charCount));
1:bde5241:         }
1:bde5241:         return charCount;
1:bde5241:     }
1:bde5241: 
1:b2b30ec:     protected void finalize() throws Throwable {
1:b2b30ec:         free();
1:b2b30ec:     }
1:b2b30ec: 
1:ec69f5f:     private void deleteFile(final StorageFile file) {
1:71c8e86:         AccessController.doPrivileged(new PrivilegedAction<Object>() {
1:ec69f5f:             public Object run() {
1:ec69f5f:                 file.delete();
1:ec69f5f:                 return null;
1:ec69f5f:             }
1:ec69f5f:         });
1:b2b30ec:     }
1:ec69f5f: 
1:b2b30ec:     /**
1:b2b30ec:      * Invalidates all the variables and closes file handle if open.
1:ec69f5f:      * @throws IOException if closing the file fails
1:b2b30ec:      */
1:b2b30ec:     void free() throws IOException {
1:b2b30ec:         dataBytes = null;
1:b2b30ec:         if (tmpFile != null) {
1:2fb5c8d:             releaseTempFile(tmpFile);
1:ce145ef:             tmpFile = null;
1:b2b30ec:         }
1:b2b30ec:     }
1:2fb5c8d: 
1:2fb5c8d:     /**
1:2fb5c8d:      * Close and release all resources held by a temporary file. The file will
1:2fb5c8d:      * also be deleted from the file system and removed from the list of
1:2fb5c8d:      * {@code LOBFile}s in {@code EmbedConnection}.
1:2fb5c8d:      *
1:2fb5c8d:      * @param file the temporary file
1:2fb5c8d:      * @throws IOException if the file cannot be closed or deleted
1:2fb5c8d:      */
1:2fb5c8d:     private void releaseTempFile(LOBFile file) throws IOException {
1:643af3d:         // Remove the file from the list of open files *first*, then close it.
1:643af3d:         //
1:643af3d:         // Why? This code may be called from finalize(), and may end up running
1:643af3d:         // at the same time the transaction is committed or rolled back. If two
1:643af3d:         // threads call RandomAccessFile.close() at the same time, Java 5 could
1:643af3d:         // fail (see DERBY-6092). By removing it from the list before closing
1:643af3d:         // it, we make sure that EmbedConnection.clearLOBMapping() won't see
1:643af3d:         // it if we get to the file first. Conversely, if clearLOBMapping()
1:643af3d:         // gets to it first, the call to removeLobFile() will block until
1:643af3d:         // clearLOBMapping() is done, so we won't attempt to close the file
1:643af3d:         // until after clearLOBMapping() is done, rather than at the same time.
1:643af3d:         //
1:643af3d:         // Calling close() concurrently is safe on Java 6 and newer, after the
1:643af3d:         // fix for http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6322678 .
1:2fb5c8d:         conn.removeLobFile(file);
1:643af3d:         file.close();
1:2fb5c8d:         deleteFile(file.getStorageFile());
1:2fb5c8d:     }
1:b2b30ec:     
1:b2b30ec:     /**
1:e5b15ce:      * Replaces a block of bytes in the middle of the LOB with a another block
1:e5b15ce:      * of bytes, which may be of a different size.
1:e5b15ce:      * <p>
1:e5b15ce:      * The new byte array may not be be of same length as the original,
1:e5b15ce:      * thus it may result in resizing the total lob.
1:e5b15ce:      *
1:e1fc783:      * @param buf byte array which will be written inplace of old block
1:e5b15ce:      * @param stPos inclusive starting position of current block
1:e5b15ce:      * @param endPos exclusive end position of current block
1:e5b15ce:      * @return Current position after write.
1:ec69f5f:      * @throws IOException if writing to the temporary file fails
1:2333262:      * @throws StandardException
1:e1fc783:      */
1:1c589af:     synchronized long replaceBytes (byte [] buf, long stPos, long endPos)
1:1c589af:             throws IOException, StandardException {
1:e1fc783:         long length = getLength();
1:e1fc783:         if (isBytes) {
1:39244bf:             long finalLength = length - endPos + stPos + buf.length;
1:d2b4fdb:             if (finalLength > bufferSize) {
1:e4c7740:                 byte [] tmpBytes = dataBytes;
1:e4c7740:                 init (tmpBytes, stPos);
1:e1fc783:                 write (buf, 0, buf.length, getLength());
1:e1fc783:                 if (endPos < length)
1:e4c7740:                     write (tmpBytes, (int) endPos, 
1:e1fc783:                             (int) (length - endPos), getLength());
1:e1fc783:             }
1:e1fc783:             else {
1:e1fc783:                 byte [] tmpByte = new byte [(int) finalLength];
1:e1fc783:                 System.arraycopy (dataBytes, 0, tmpByte, 0, (int) stPos);
1:e1fc783:                 System.arraycopy (buf, 0, tmpByte, (int) stPos, (int) buf.length);
1:e1fc783:                 if (endPos < length)
1:e1fc783:                     System.arraycopy (dataBytes, (int) endPos, tmpByte, 
1:e1fc783:                             (int) (stPos + buf.length), (int) (length - endPos));
1:e1fc783:                 dataBytes = tmpByte;            
1:e1fc783:             }
1:e1fc783:         }
1:e1fc783:         else {
1:e1fc783:             //save over file handle and 
1:e1fc783:             //create new file with 0 size
1:e1fc783:             
1:e1fc783:             byte tmp [] = new byte [0];
1:2333262:             LOBFile oldFile = tmpFile;
1:e1fc783:             init (tmp, 0);
1:e1fc783:             byte [] tmpByte = new byte [1024];
1:e1fc783:             long sz = stPos;
1:e1fc783:             oldFile.seek(0);
1:e1fc783:             while (sz != 0) {
1:e1fc783:                 int readLen = (int) Math.min (1024, sz);                
1:e1fc783:                 int actualLength = oldFile.read (tmpByte, 0, readLen);
1:e1fc783:                 if (actualLength == -1)
1:e1fc783:                     break;
1:e1fc783:                 tmpFile.write (tmpByte, 0, actualLength);
1:e1fc783:                 sz -= actualLength;
1:e1fc783:             }
1:e1fc783:             tmpFile.write (buf);
1:e1fc783:             oldFile.seek (endPos);
1:e1fc783:             int rdLen;
1:e1fc783:             if (endPos < length) {
1:e1fc783:                 do {
1:e1fc783:                     rdLen = oldFile.read (tmpByte, 0, 1024);
1:e1fc783:                     if (rdLen == -1)
1:e1fc783:                         break;
1:e1fc783:                     tmpFile.write (tmpByte, 0, rdLen);
1:e1fc783:                 }while (true);
1:e1fc783:             }            
1:2fb5c8d:             releaseTempFile(oldFile);
1:e1fc783:         }
1:e1fc783:         updateCount++;
1:e1fc783:         return stPos + buf.length;
1:e1fc783:     }
1:e1fc783: 
1:e1fc783:     /**
1:ec69f5f:      * Returns the running sequence number to check if the lob is updated since
1:e1fc783:      * last access.
1:e5b15ce:      *
1:e5b15ce:      * @return The current update sequence number.
1:e1fc783:      */
1:e1fc783:     long getUpdateCount() {
1:e1fc783:         return updateCount;
1:e1fc783:     }
1:56c1dc2:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object findServiceModule( final Object serviceModule, final String factoryInterface)
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.findServiceModule( serviceModule, factoryInterface );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged service lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private static  Object findService( final String factoryInterface, final String serviceName )
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<Object>()
1:56c1dc2:              {
1:56c1dc2:                  public Object run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.findService( factoryInterface, serviceName );
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2:     
1:b2b30ec: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                         SQLState.BLOB_POSITION_TOO_LARGE, pos);
1:                         SQLState.BLOB_POSITION_TOO_LARGE, pos);
/////////////////////////////////////////////////////////////////////////
1:                 SQLState.BLOB_NONPOSITIVE_LENGTH, (pos + 1));
1:                     SQLState.BLOB_POSITION_TOO_LARGE, (pos + 1));
1:                             SQLState.BLOB_POSITION_TOO_LARGE, (pos + 1));
1:                         SQLState.BLOB_POSITION_TOO_LARGE, (pos + 1));
1:                         SQLState.BLOB_POSITION_TOO_LARGE, (pos + 1));
1:                     SQLState.BLOB_INVALID_OFFSET, off);
/////////////////////////////////////////////////////////////////////////
1:                             length, sz));
/////////////////////////////////////////////////////////////////////////
1:                     charLength, charCount));
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1:         Object monitor = findService(
1:         final DataFactory df = (DataFactory) findServiceModule(
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object findServiceModule( final Object serviceModule, final String factoryInterface)
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.findServiceModule( serviceModule, factoryInterface );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
1:     /**
1:      * Privileged service lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private static  Object findService( final String factoryInterface, final String serviceName )
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<Object>()
1:              {
1:                  public Object run()
1:                  {
1:                      return Monitor.findService( factoryInterface, serviceName );
1:                  }
1:              }
1:              );
1:     }
1:     
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:             AccessController.doPrivileged (new PrivilegedExceptionAction<Object>() {
/////////////////////////////////////////////////////////////////////////
1:         AccessController.doPrivileged(new PrivilegedAction<Object>() {
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:ec69f5f
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: final class LOBStreamControl {
/////////////////////////////////////////////////////////////////////////
0:         Object monitor = Monitor.findService(
1:                 Property.DATABASE_MODULE, conn.getDBName());
0:         final DataFactory df = (DataFactory) Monitor.findServiceModule(
1:                 monitor, DataFactory.MODULE);
1:                 public Object run() throws IOException {
1:                     } else {
1:                     }
1:             throw (IOException) pae.getCause();
1: 
1:         conn.addLobFile(tmpFile);
/////////////////////////////////////////////////////////////////////////
1:      * @return new position
1:      * @throws IOException if writing to the LOB file fails
1:      * @throws StandardException if encrypting/decrypting the LOB file fails
/////////////////////////////////////////////////////////////////////////
1:      * @param pos position from where to read
1:      * @throws IOException if reading the LOB file fails
1:      * @throws StandardException if decrypting an encrypted LOB file fails
/////////////////////////////////////////////////////////////////////////
1:      * @param pos initial position before reading
1:      * @return number new position
1:      * @throws IOException if reading the LOB file fails
1:      * @throws StandardException if decrypting an encrypted LOB file fails
/////////////////////////////////////////////////////////////////////////
1:      * @param size new size should be smaller than existing size
/////////////////////////////////////////////////////////////////////////
1:      * @throws IOException if reading or writing a LOB file fails
1:      * @throws StandardException if encrypting or decrypting a LOB file fails
/////////////////////////////////////////////////////////////////////////
1:     private void deleteFile(final StorageFile file) {
0:         AccessController.doPrivileged(new PrivilegedAction() {
1:             public Object run() {
1:                 file.delete();
1:                 return null;
1:             }
1:         });
1: 
1:      * @throws IOException if closing the file fails
/////////////////////////////////////////////////////////////////////////
1:      * @throws IOException if writing to the temporary file fails
/////////////////////////////////////////////////////////////////////////
1:      * Returns the running sequence number to check if the lob is updated since
commit:643af3d
/////////////////////////////////////////////////////////////////////////
1:         // Remove the file from the list of open files *first*, then close it.
1:         //
1:         // Why? This code may be called from finalize(), and may end up running
1:         // at the same time the transaction is committed or rolled back. If two
1:         // threads call RandomAccessFile.close() at the same time, Java 5 could
1:         // fail (see DERBY-6092). By removing it from the list before closing
1:         // it, we make sure that EmbedConnection.clearLOBMapping() won't see
1:         // it if we get to the file first. Conversely, if clearLOBMapping()
1:         // gets to it first, the call to removeLobFile() will block until
1:         // clearLOBMapping() is done, so we won't attempt to close the file
1:         // until after clearLOBMapping() is done, rather than at the same time.
1:         //
1:         // Calling close() concurrently is safe on Java 6 and newer, after the
1:         // fix for http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6322678 .
1:         file.close();
commit:c2fe280
/////////////////////////////////////////////////////////////////////////
1:  * size is set to the size of the byte array supplied, but no larger than
1:  * MAX_BUF_SIZE. If no initial data is supplied, or if the initial data size
1:  * is less than DEFAULT_BUF_SIZE, the buffer size is set to DEFAULT_BUF_SIZE.
1:  * initial buffer size, the data is moved into memory.
/////////////////////////////////////////////////////////////////////////
1:     private static final int DEFAULT_BUF_SIZE = 4096;
1:     private static final int MAX_BUF_SIZE = 32768;
/////////////////////////////////////////////////////////////////////////
1:         bufferSize = DEFAULT_BUF_SIZE;
/////////////////////////////////////////////////////////////////////////
1:         bufferSize =
1:             Math.min(Math.max(DEFAULT_BUF_SIZE, data.length), MAX_BUF_SIZE);
commit:2fb5c8d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     StorageFile lobFile =
/////////////////////////////////////////////////////////////////////////
1:                 releaseTempFile(tmpFile);
/////////////////////////////////////////////////////////////////////////
1:             releaseTempFile(tmpFile);
1: 
1:     /**
1:      * Close and release all resources held by a temporary file. The file will
1:      * also be deleted from the file system and removed from the list of
1:      * {@code LOBFile}s in {@code EmbedConnection}.
1:      *
1:      * @param file the temporary file
1:      * @throws IOException if the file cannot be closed or deleted
1:      */
1:     private void releaseTempFile(LOBFile file) throws IOException {
0:         file.close();
1:         conn.removeLobFile(file);
1:         deleteFile(file.getStorageFile());
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             releaseTempFile(oldFile);
commit:ff45fc9
/////////////////////////////////////////////////////////////////////////
0:             oldFile.close();
0:             deleteFile(oldStoreFile);
commit:ed0be21
/////////////////////////////////////////////////////////////////////////
0:             throw Util.newIOException(e);
/////////////////////////////////////////////////////////////////////////
0:             throw Util.newIOException(e);
commit:d2b4fdb
/////////////////////////////////////////////////////////////////////////
1:  * The max bytes of data stored in memory depends on the way this
1:  * class is created. If the class is created with initial data, the buffer
0:  * size is set to the size of the byte array supplied. If no initial data
0:  * is supplied or if the initial data size is less than DEFAULT_MAX_BUF_SIZE,
0:  * The buffer size is set to DEFAULT_MAX_BUF_SIZE.
1:  * When write increases the data beyond this value a temporary file is created
1:  * and data is moved into that. If truncate reduces the size of the file below
0:  * initial buffer size (max of DEFAULT_MAX_BUF_SIZE and initial byte array size)
0:  * the data moved into memory.
1:  * This class also creates InputStream and OutputStream which can be used to access
/////////////////////////////////////////////////////////////////////////
1:     private final int bufferSize;
0:     private static final int DEFAULT_MAX_BUF_SIZE = 4096;
1:     /**
1:      * Creates an empty LOBStreamControl.
0:      * @param dbName database name
1:      */
0:     LOBStreamControl (String dbName) {
1:         //default buffer size
0:         bufferSize = DEFAULT_MAX_BUF_SIZE;
1:     }
1: 
1:     /**
1:      * Creates a LOBStreamControl and initializes with a bytes array.
0:      * @param dbName database name
1:      * @param data initial value
1:      */
0:     LOBStreamControl (String dbName, byte [] data)
0:                 throws IOException, SQLException, StandardException {
0:         this.dbName = dbName;
1:         updateCount = 0;
0:         bufferSize = Math.max (DEFAULT_MAX_BUF_SIZE, data.length);
1:         write (data, 0, data.length, 0);
/////////////////////////////////////////////////////////////////////////
1:         dataBytes = null;
/////////////////////////////////////////////////////////////////////////
1:             if (pos < bufferSize) {
/////////////////////////////////////////////////////////////////////////
1:             if (pos + len <= bufferSize)
/////////////////////////////////////////////////////////////////////////
1:             if (size < bufferSize) {
/////////////////////////////////////////////////////////////////////////
1:         byte [] data = new byte [bufferSize];
1:             int len = (int) Math.min (length - sz, bufferSize);
/////////////////////////////////////////////////////////////////////////
1:             if (finalLength > bufferSize) {
commit:5d54436
/////////////////////////////////////////////////////////////////////////
0:             IOException ioe = new IOException (e.getMessage());
0:             ioe.initCause (e);
0:             throw ioe;
/////////////////////////////////////////////////////////////////////////
0:             if (pos < MAX_BUF_SIZE) {
/////////////////////////////////////////////////////////////////////////
1:             throw e;
0:             if (pos + len <= MAX_BUF_SIZE)
/////////////////////////////////////////////////////////////////////////
1:         if (pos >= dataBytes.length)
1:             return -1;
/////////////////////////////////////////////////////////////////////////
0:             if (size < MAX_BUF_SIZE) {
/////////////////////////////////////////////////////////////////////////
0:                 IOException ioe = new IOException (e.getMessage());
0:                 ioe.initCause (e);
0:                 throw ioe;
commit:2333262
/////////////////////////////////////////////////////////////////////////
1:     private LOBFile tmpFile;
/////////////////////////////////////////////////////////////////////////
1:     private void init(byte [] b, long len)
0:                     throws IOException, SQLException, StandardException {
/////////////////////////////////////////////////////////////////////////
1:                     if (df.databaseEncrypted()) {
1:                         tmpFile = new EncryptedLOBFile (lobFile, df);
1:                     }
0:                     else
1:                         tmpFile = new LOBFile (lobFile);
/////////////////////////////////////////////////////////////////////////
1:     private void isValidPostion(long pos)
0:                         throws SQLException, IOException {
/////////////////////////////////////////////////////////////////////////
0:      * @throws IOException, SQLException, StandardException
1:     synchronized long write(int b, long pos)
0:                 throws IOException, SQLException, StandardException {
/////////////////////////////////////////////////////////////////////////
0:      * @throws IOException, SQLException, StandardException
0:                         throws IOException, SQLException, StandardException {
/////////////////////////////////////////////////////////////////////////
0:      * @throws IOException, SQLException, StandardException
1:     synchronized int read(long pos)
0:                 throws IOException, SQLException, StandardException {
/////////////////////////////////////////////////////////////////////////
0:      * @throws IOException, SQLException, StandardException
0:     throws IOException, SQLException, StandardException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized void truncate(long size)
0:                         throws IOException, SQLException, StandardException {
/////////////////////////////////////////////////////////////////////////
1:             } else {
1:                 try {
1:                     tmpFile.setLength(size);
1:                 }
0:                 catch (StandardException se) {
0:                     Util.generateCsSQLException (se);
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
0:      * @throws IOException, SQLException, StandardException
0:             long length) throws IOException, SQLException, StandardException {
/////////////////////////////////////////////////////////////////////////
1:      * @throws StandardException
0:                          throws IOException, SQLException, StandardException {
/////////////////////////////////////////////////////////////////////////
1:             LOBFile oldFile = tmpFile;
commit:2420903
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     //create a temporary file
/////////////////////////////////////////////////////////////////////////
0:     private void isValidOffset(int off, int length) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:         tmpFile.seek(pos);
/////////////////////////////////////////////////////////////////////////
0:             if (pos + b.length < MAX_BUF_SIZE)
1:         tmpFile.seek(pos);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         tmpFile.seek(pos);
/////////////////////////////////////////////////////////////////////////
1:                 read(dataBytes, 0, dataBytes.length, 0);
commit:3e5168c
/////////////////////////////////////////////////////////////////////////
1:      * @param buff array into the bytes will be copied
/////////////////////////////////////////////////////////////////////////
0:      * @param length length to be copied
author:Lily Wei
-------------------------------------------------------------------------------
commit:39244bf
/////////////////////////////////////////////////////////////////////////
1:             long finalLength = length - endPos + stPos + buf.length;
commit:b175fd2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.ExceptionUtil;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:bde5241
/////////////////////////////////////////////////////////////////////////
1: import java.io.UTFDataFormatException;
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: import org.apache.derby.shared.common.reference.MessageId;
/////////////////////////////////////////////////////////////////////////
1:                     throw new EOFException(MessageService.getTextMessage(
1:                             MessageId.STREAM_PREMATURE_EOF,
0:                             new Long(length), new Long(sz)));
/////////////////////////////////////////////////////////////////////////
1:         // If we copied until EOF, and we read more data than the length of the
1:         // marker, see if we have a Derby end-of-stream marker.
1:         long curLength = getLength();
1:         if (length == Long.MAX_VALUE && curLength > 2) {
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Copies UTF-8 encoded chars from a stream to local storage.
1:      * <p>
1:      * Note that specifying the length as {@code Long.MAX_VALUE} results in
1:      * reading data from the stream until EOF is reached, but no length checking
1:      * will be performed.
1:      *
1:      * @param utf8Stream the stream to copy from
1:      * @param charLength number of chars to be copied, or {@code Long.MAX_VALUE}
1:      *      to copy everything until EOF is reached
1:      * @return The number of characters copied.
1:      * @throws EOFException if EOF is reached prematurely
1:      * @throws IOException thrown on a number of error conditions
1:      * @throws StandardException if reading, writing or truncating the
1:      *      {@code LOBStreamControl}-object fails
1:      * @throws UTFDataFormatException if an invalid UTF-8 encoding is detected
1:      */
1:     synchronized long copyUtf8Data(final InputStream utf8Stream,
1:                                    final long charLength)
1:             throws IOException, StandardException {
1:         long charCount = 0; // Number of chars read
1:         int offset = 0;     // Where to start looking for the start of a char
1:         int read = 0;       // Number of bytes read
1:         final byte[] buf = new byte[bufferSize];
1:         while (charCount < charLength) {
1:             int readNow = utf8Stream.read(buf, 0,
1:                             (int)Math.min(buf.length, charLength - charCount));
1:             if (readNow == -1) {
1:                 break;
1:             }
1:             // Count the characters.
1:             while (offset < readNow) {
1:                 int c = buf[offset] & 0xFF;
1:                 if ((c & 0x80) == 0x00) { // 8th bit not set (top bit)
1:                     offset++;
1:                 } else if ((c & 0x60) == 0x40) { // 7th bit set, 6th bit unset
1:                     // Found char of two byte width.
1:                     offset += 2;
1:                 } else if ((c & 0x70) == 0x60) { // 7th & 6th bit set, 5th unset
1:                     // Found char of three byte width.
1:                     offset += 3;
1:                 } else {
1:                     // This shouldn't happen, as the data is coming from the
1:                     // store and is supposed to be well-formed.
1:                     // If it happens, fail and print some internal information.
1:                     throw new UTFDataFormatException("Invalid UTF-8 encoding: "
1:                             + Integer.toHexString(c) + ", charCount=" +
1:                             charCount + ", offset=" + offset);
1:                 }
1:                 charCount++;
1:             }
1:             offset -= readNow; // Starting offset for next iteration
1:             write(buf, 0, readNow, read);
1:             read += readNow;
1:         }
1:         // See if an EOF-marker ended the stream. Don't check if we have fewer
1:         // bytes than the marker length.
1:         long curLength = getLength();
1:         if (curLength > 2) {
1:             byte[] eos = new byte[3];
1:             // Read the three last bytes, marker is 0xE0 0x00 0x00.
1:             read(eos, 0, 3, curLength -3);
1:             if ((eos[0] & 0xFF) == 0xE0 && (eos[1] & 0xFF) == 0x00 &&
1:                     (eos[2] & 0xFF) == 0x00) {
1:                 // Remove Derby end-of-stream-marker.
1:                 truncate(curLength -3);
1:                 charCount--;
1:             }
1:         }
1:         if (charLength != Long.MAX_VALUE && charCount != charLength) {
1:             throw new EOFException(MessageService.getTextMessage(
1:                     MessageId.STREAM_PREMATURE_EOF,
0:                     new Long(charLength), new Long(charCount)));
1:         }
1:         return charCount;
1:     }
1: 
commit:0c5c5aa
/////////////////////////////////////////////////////////////////////////
1:      * Writes {@code len} bytes from the specified byte array to the LOB.
1:      *
1:      * @param len number of bytes to be written
1:      * @param pos starting position
1:      * @return The position after the bytes have been written to the LOB.
1:      * @throws IOException if writing to the LOB fails
1:      * @throws StandardException if writing to the LOB fails
1:      * @throws IndexOutOfBoundsException if {@code len} is larger than
1:      *       {@code b.length - off}
commit:e8fd686
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * Note that specifying the length as {@code Long.MAX_VALUE} results in
1:      * reading data from the stream until EOF is reached, but no length checking
1:      * will be performed.
1:      *
1:      * @param inStream the stream to copy from
1:      * @param length number of bytes to be copied, or {@code Long.MAX_VALUE} to
1:      *      copy everything until EOF is reached
/////////////////////////////////////////////////////////////////////////
1:             if (len == -1) {
1:                 if (length != Long.MAX_VALUE) {
1:                     // We reached EOF before all the requested bytes are read.
0:                     throw new EOFException("Reached end-of-stream " +
0:                         "prematurely at " + sz + ", expected " + length);
1:                 } else {
1:                     // End of data, but no length checking.
1:                     break;
1:                 }
1:             }
0:         // If we copied until EOF, see if we have a Derby end-of-stream marker.
0:         if (length == Long.MAX_VALUE) {
0:             long curLength = getLength();
1:             byte[] eos = new byte[3];
1:             // Read the three last bytes, marker is 0xE0 0x00 0x00.
1:             read(eos, 0, 3, curLength -3);
1:             if ((eos[0] & 0xFF) == 0xE0 && (eos[1] & 0xFF) == 0x00 &&
1:                     (eos[2] & 0xFF) == 0x00) {
1:                 // Remove Derby end-of-stream-marker.
1:                 truncate(curLength -3);
1:             }
1:         }
commit:1c589af
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             throws IOException, StandardException {
/////////////////////////////////////////////////////////////////////////
1:             throws IOException, StandardException {
/////////////////////////////////////////////////////////////////////////
0:                 throw (StandardException)e;
/////////////////////////////////////////////////////////////////////////
1:             throws StandardException {
/////////////////////////////////////////////////////////////////////////
1:                 throw StandardException.newException(
1:                 throw StandardException.newException(
/////////////////////////////////////////////////////////////////////////
1:             throws IOException, StandardException {
1:             throw StandardException.newException(
1:             throw StandardException.newException(
1:                     throw StandardException.newException(
1:                 throw StandardException.newException(
1:                 throw StandardException.newException(
1:     private void isValidOffset(int off, int length) throws StandardException {
1:             throw StandardException.newException(
/////////////////////////////////////////////////////////////////////////
0:      * @throws IOException, StandardException
1:             throws IOException, StandardException {
/////////////////////////////////////////////////////////////////////////
0:      * @throws IOException, StandardException
1:             throws IOException, StandardException {
1:         isValidPostion(pos);
1:         } catch (StandardException e) {
/////////////////////////////////////////////////////////////////////////
0:      * @throws IOException, StandardException
1:             throws IOException, StandardException {
/////////////////////////////////////////////////////////////////////////
0:      * @throws IOException, StandardException
1:             throws IOException, StandardException {
/////////////////////////////////////////////////////////////////////////
1:      * @throws IOException
1:             throws IOException, StandardException {
/////////////////////////////////////////////////////////////////////////
0:                 tmpFile.setLength(size);
/////////////////////////////////////////////////////////////////////////
0:      * @throws IOException, StandardException
1:     synchronized void copyData(InputStream inStream, long length)
1:             throws IOException, StandardException {
/////////////////////////////////////////////////////////////////////////
1:     synchronized long replaceBytes (byte [] buf, long stPos, long endPos)
1:             throws IOException, StandardException {
commit:30f7a38
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e4c7740
/////////////////////////////////////////////////////////////////////////
1:                 byte [] tmpBytes = dataBytes;
1:                 init (tmpBytes, stPos);
1:                     write (tmpBytes, (int) endPos, 
commit:ba50299
/////////////////////////////////////////////////////////////////////////
1:             len = inStream.read(data, 0, len);
0:             if (len < 0)
0:                 throw new EOFException("Reached end-of-stream " +
0:                         "prematurely at " + sz);
commit:e5b15ce
/////////////////////////////////////////////////////////////////////////
1:      * Replaces a block of bytes in the middle of the LOB with a another block
1:      * of bytes, which may be of a different size.
1:      * <p>
1:      * The new byte array may not be be of same length as the original,
1:      * thus it may result in resizing the total lob.
1:      *
1:      * @param stPos inclusive starting position of current block
1:      * @param endPos exclusive end position of current block
1:      * @return Current position after write.
0:      * @throws IOExcepton if writing to temporary file fails
0:      * @throws SQLException
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @return The current update sequence number.
commit:bb0c274
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one
1:    or more contributor license agreements.  See the NOTICE file
1:    distributed with this work for additional information
1:    regarding copyright ownership.  The ASF licenses this file
1:    to you under the Apache License, Version 2.0 (the
1:    "License"); you may not use this file except in compliance
1:    with the License.  You may obtain a copy of the License at
1:      http://www.apache.org/licenses/LICENSE-2.0
1:    Unless required by applicable law or agreed to in writing,
1:    software distributed under the License is distributed on an
1:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:    KIND, either express or implied.  See the License for the
1:    specific language governing permissions and limitations
1:    under the License.
commit:ffb9317
/////////////////////////////////////////////////////////////////////////
commit:e1fc783
/////////////////////////////////////////////////////////////////////////
1:     private long updateCount;
1:         updateCount = 0;
/////////////////////////////////////////////////////////////////////////
1:         updateCount++;
/////////////////////////////////////////////////////////////////////////
1:         updateCount++;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Replaces bytes in the middle of the lob.The new byte array may not be 
0:      * be of same length as the original bytes, so it may result in resizing 
0:      * the total length.
1:      * @param buf byte array which will be written inplace of old block
0:      * @param stPos starting pisition of old block
0:      * @param endPos end position of old block
0:      * @return newposition new write position 
0:      * @throws IOExcepton, SQLException
1:      */
0:     synchronized long replaceBytes (byte [] buf, long stPos, long endPos) 
0:                                             throws IOException, SQLException {
1:         long length = getLength();
0:         long finalLength = length - endPos + stPos + buf.length;
1:         if (isBytes) {
0:             if (finalLength > MAX_BUF_SIZE) {
0:                 init (dataBytes, stPos);
1:                 write (buf, 0, buf.length, getLength());
1:                 if (endPos < length)
0:                     write (dataBytes, (int) endPos, 
1:                             (int) (length - endPos), getLength());
1:             }
1:             else {
1:                 byte [] tmpByte = new byte [(int) finalLength];
1:                 System.arraycopy (dataBytes, 0, tmpByte, 0, (int) stPos);
1:                 System.arraycopy (buf, 0, tmpByte, (int) stPos, (int) buf.length);
1:                 if (endPos < length)
1:                     System.arraycopy (dataBytes, (int) endPos, tmpByte, 
1:                             (int) (stPos + buf.length), (int) (length - endPos));
1:                 dataBytes = tmpByte;            
1:             }
1:         }
1:         else {
1:             //save over file handle and 
1:             //create new file with 0 size
1:             
1:             byte tmp [] = new byte [0];
0:             StorageRandomAccessFile oldFile = tmpFile;
1:             init (tmp, 0);
1:             byte [] tmpByte = new byte [1024];
1:             long sz = stPos;
1:             oldFile.seek(0);
1:             while (sz != 0) {
1:                 int readLen = (int) Math.min (1024, sz);                
1:                 int actualLength = oldFile.read (tmpByte, 0, readLen);
1:                 if (actualLength == -1)
1:                     break;
1:                 tmpFile.write (tmpByte, 0, actualLength);
1:                 sz -= actualLength;
1:             }
1:             tmpFile.write (buf);
1:             oldFile.seek (endPos);
1:             int rdLen;
1:             if (endPos < length) {
1:                 do {
1:                     rdLen = oldFile.read (tmpByte, 0, 1024);
1:                     if (rdLen == -1)
1:                         break;
1:                     tmpFile.write (tmpByte, 0, rdLen);
1:                 }while (true);
1:             }            
1:         }
1:         updateCount++;
1:         return stPos + buf.length;
1:     }
1: 
1:     /**
0:      * Returns the running secquence number to check if the lob is updated since
1:      * last access.
0:      * @return newcount
1:      */
1:     long getUpdateCount() {
1:         return updateCount;
1:     }
commit:27be4fc
/////////////////////////////////////////////////////////////////////////
1:             dataBytes = tmpByte;
commit:b2b30ec
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.jdbc.LOBStreamControl
1: 
0:    Copyright 2006 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
0:       http://www.apache.org/licenses/LICENSE-2.0
1: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.impl.jdbc;
1: 
1: import java.io.EOFException;
0: import java.io.File;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.OutputStream;
0: import java.io.RandomAccessFile;
0: import java.security.AccessControlException;
1: import java.security.AccessController;
0: import java.security.PrivilegedAction;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
0: import java.sql.SQLException;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.store.raw.data.DataFactory;
1: import org.apache.derby.io.StorageFile;
0: import org.apache.derby.io.StorageRandomAccessFile;
0: import org.apache.derby.shared.common.error.ExceptionUtil;
1: 
1: /**
1:  * This class acts as a layer of blob/clob repository (in memory or file).
0:  * The max bytes of data stored in memory is MAX_BUF_SIZE. When write
0:  * increases the data beyond this value a temporary file is created and data
0:  * is moved into that. If truncate reduces the size of the file below
0:  * MAX_BUF_SIZE the data moved into memory.
1:  *
0:  * This class also creates Input- and OutputStream which can be used to access
1:  * blob data irrespective of if its in memory or in file.
1:  */
1: 
0: class LOBStreamControl {
0:     //private RandomAccessFile tmpFile;
0:     private StorageRandomAccessFile tmpFile;
0:     private StorageFile lobFile;
1:     private byte [] dataBytes = new byte [0];
1:     private boolean isBytes = true;
0:     //keeping max 4k bytes in memory
0:     //randomly selected value
0:     private final int MAX_BUF_SIZE = 4096;
0:     private String dbName;
1: 
0:     public LOBStreamControl (String dbName) {
0:         this.dbName = dbName;
1:     }
1: 
0:     private void init(byte [] b, long len) throws IOException, SQLException {
1:         try {
0:             AccessController.doPrivileged (new PrivilegedExceptionAction() {
0:                 public Object run() throws IOException, StandardException {
0:                     Object monitor = Monitor.findService(
0:                             Property.DATABASE_MODULE, dbName);
0:                     DataFactory df =  (DataFactory) Monitor.findServiceModule(
0:                             monitor, DataFactory.MODULE);
0:                     lobFile =
1:                         df.getStorageFactory().createTemporaryFile("lob", null);
0:                     tmpFile = lobFile.getRandomAccessFile ("rw");
1:                     return null;
1:                 }
1:             });
0:             //create a temporary file
1:         }
1:         catch (PrivilegedActionException pae) {
0:             Exception e = pae.getException();
0:             if (e instanceof StandardException)
0:                 throw Util.generateCsSQLException ((StandardException) e);
0:             if (e instanceof IOException)
0:                 throw (IOException) e;
0:             if (e instanceof RuntimeException)
0:                 throw (RuntimeException) e;
1:         }
1:         isBytes = false;
1:         //now this call will write into the file
1:         if (len != 0)
1:             write(b, 0, (int) len, 0);
1:     }
1: 
1:     private long updateData(byte[] bytes, int offset, int len, long pos)
0:     throws SQLException {
1:         if (dataBytes == null) {
1:             if ((int) pos == 0) {
1:                 dataBytes = new byte [len];
1:                 System.arraycopy(bytes, offset, dataBytes, (int) pos, len);
1:                 return len;
1:             }
1:             else {
1:                 //invalid postion
0:                 throw Util.generateCsSQLException(
0:                         SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos));
1:             }
1:         }
1:         else {
1:             if (pos > dataBytes.length) {
1:                 //invalid postion
0:                 throw Util.generateCsSQLException(
0:                         SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos));
1:             }
1:             else {
1:                 if (pos + len < dataBytes.length) {
1:                     System.arraycopy(bytes, offset, dataBytes, (int) pos, len);
1:                 }
1:                 else {
1:                     byte [] tmpBytes = new byte [len + (int) pos];
1:                     System.arraycopy(dataBytes, 0 , tmpBytes, 0, (int) pos);
1:                     System.arraycopy(bytes, offset, tmpBytes, (int) pos, len);
1:                     dataBytes = tmpBytes;
1:                 }
1:             }
1:             return pos + len;
1:         }
1:     }
1: 
0:     private void isValidPostion(long pos) throws SQLException, IOException {
1:         if (pos < 0)
0:             throw Util.generateCsSQLException(
0:                     SQLState.BLOB_NONPOSITIVE_LENGTH, new Long(pos + 1));
1:         if (pos > Integer.MAX_VALUE)
0:             throw Util.generateCsSQLException(
0:                     SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos + 1));
1: 
1:         if (isBytes) {
1:             if (dataBytes == null) {
1:                 if (pos != 0)
0:                     throw Util.generateCsSQLException(
0:                             SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos + 1));
1:             } else if (dataBytes.length < pos)
0:                 throw Util.generateCsSQLException(
0:                         SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos + 1));
1:         } else {
1:             if (pos > tmpFile.length())
0:                 throw Util.generateCsSQLException(
0:                         SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos + 1));
1:         }
1:     }
1: 
0:     private void isValidOffset(int off, int length) throws SQLException, IOException {
1:         if (off < 0 || off > length)
0:             throw Util.generateCsSQLException(
0:                     SQLState.BLOB_INVALID_OFFSET, new Integer(off));
1:     }
1: 
1:     /**
1:      * Writes one byte.
1:      * @param b byte
1:      * @param pos
0:      * @return new postion
0:      * @throws IOException, SQLException
1:      */
0:     synchronized long write(int b, long pos) throws IOException, SQLException {
1:         isValidPostion(pos);
1:         if (isBytes) {
0:             if (pos + 1 < MAX_BUF_SIZE) {
1:                 byte [] bytes = {(byte) b};
1:                 updateData(bytes, 0, 1, pos);
1:                 return pos + 1;
1:             } else {
1:                 init(dataBytes, pos);
1:             }
1:         }
1:         if (tmpFile.getFilePointer() != pos)
1:             tmpFile.seek(pos);
1:         tmpFile.write(b);
1:         return tmpFile.getFilePointer();
1:     }
1: 
1:     /**
0:      * Writes part of the byte array.
1:      * @param b byte array
1:      * @param off offset from where to read from the byte array
0:      * @param len number of bytes to be copied
0:      * @param pos starting postion
0:      * @return new postion
0:      * @throws IOException, SQLException
1:      */
1:     synchronized long write(byte[] b, int off, int len, long pos)
0:     throws IOException, SQLException {
1:         try {
1:             isValidPostion(pos);
1:             isValidOffset(off, b.length);
1:         }
0:         catch (SQLException e) {
1:             if (e.getSQLState().equals(
1:                     ExceptionUtil.getSQLStateFromIdentifier(
1:                                   SQLState.BLOB_INVALID_OFFSET)))
1:                     throw new ArrayIndexOutOfBoundsException (e.getMessage());
1:         }
1:         if (isBytes) {
0:             long finalLen = (dataBytes != null) ? dataBytes.length + b.length
0:                     : b.length;
0:             if (finalLen < MAX_BUF_SIZE)
1:                 return updateData(b, off, len, pos);
1:             else {
1:                 init(dataBytes, pos);
1:             }
1:         }
1:         if (tmpFile.getFilePointer() != pos)
1:             tmpFile.seek(pos);
1:         tmpFile.write(b, off, len);
1:         return tmpFile.getFilePointer();
1:     }
1: 
1:     /**
0:      * Writes byte array starting from pos.
0:      * @param b bytes array
0:      * @param pos starting postion
0:      * @return new position
0:      * @throws IOException, SQLException
1:      */
0:     synchronized long write(byte[] b, long pos)
0:     throws IOException, SQLException {
1:         isValidPostion(pos);
1:         if (isBytes) {
0:             long len = (dataBytes != null) ? dataBytes.length + b.length
0:                     : b.length;
0:             if (len < MAX_BUF_SIZE)
0:                 return updateData(b, 0, b.length, pos);
1:             else {
1:                 init(dataBytes, pos);
1:             }
1:         }
1:         if (tmpFile.getFilePointer() != pos)
1:             tmpFile.seek(pos);
1:         tmpFile.write(b);
1:         return tmpFile.getFilePointer();
1:     }
1: 
1:     /**
1:      * Reads one byte.
0:      * @param pos postion from where to read
1:      * @return byte
0:      * @throws IOException, SQLException
1:      */
0:     synchronized int read(long pos) throws IOException, SQLException {
1:         isValidPostion(pos);
1:         if (isBytes) {
1:             if (dataBytes.length == pos)
1:                 return -1;
1:             return dataBytes [(int) pos] & 0xff;
1:         }
1:         if (tmpFile.getFilePointer() != pos)
1:             tmpFile.seek(pos);
1:         try {
1:             return tmpFile.readByte() & 0xff;
1:         }
1:         catch (EOFException eof) {
1:             return -1;
1:         }
1:     }
1: 
1:     private int readBytes(byte [] b, int off, int len, long pos) {
1:         int lengthFromPos = dataBytes.length - (int) pos;
1:         int actualLength = len > lengthFromPos ? lengthFromPos : len;
0:         byte [] result = new byte[actualLength];
1:         System.arraycopy(dataBytes, (int) pos, b, off, actualLength);
1:         return actualLength;
1:     }
1: 
1:     /**
0:      * Copies bytes into byte array starting from pos.
0:      * @param b bytes array to copy data
0:      * @param pos starting postion
0:      * @return new postion
0:      * @throws IOException, SQLException
1:      */
0:     synchronized int read(byte[] b, long pos)
0:     throws IOException, SQLException {
0:         return read (b, 0, b.length, pos);
1:     }
1: 
1:     /**
1:      * Reads bytes starting from 'position' into bytes array.
1:      * starting from 'offset'
0:      * @param b array into the bytes will be copied
1:      * @param off offset from where the array has to be populated
1:      * @param len number of bytes to read
0:      * @param pos initial postion before reading
0:      * @return number new postion
0:      * @throws IOException, SQLException
1:      */
1:     synchronized int read(byte[] buff, int off, int len, long pos)
0:     throws IOException, SQLException {
1:         isValidPostion(pos);
1:         isValidOffset(off, buff.length);
1:         if (isBytes) {
1:             return readBytes(buff, off, len, pos);
1:         }
1:         if (tmpFile.getFilePointer() != pos)
1:             tmpFile.seek(pos);
1:         return tmpFile.read (buff, off, len);
1:     }
1: 
1:     /**
1:      * returns input stream linked with this object.
1:      * @param pos initial postion
1:      * @return InputStream
1:      */
1:     InputStream getInputStream(long pos) {
1:         return new LOBInputStream(this, pos);
1:     }
1: 
1:     /**
1:      * returns output stream linked with this object
1:      * @param pos initial postion
1:      * @return OutputStream
1:      */
1:     OutputStream getOutputStream(long pos) {
1:         return new LOBOutputStream(this, pos);
1:     }
1: 
1:     /**
1:      * Returns length of data.
1:      * @return length
1:      * @throws IOException
1:      */
1:     long getLength() throws IOException {
1:         if (isBytes)
1:             return dataBytes.length;
1:         return tmpFile.length();
1:     }
1: 
1:     /**
1:      * Resets the size.
0:      * @param size new size should be smaller than exisiting size
0:      * @throws IOException, SQLException
1:      */
0:     synchronized void truncate(long size) throws IOException, SQLException {
1:         isValidPostion(size);
1:         if (isBytes) {
1:             byte [] tmpByte = new byte [(int) size];
1:             System.arraycopy(dataBytes, 0, tmpByte, 0, (int) size);
1:         } else {
0:             if (size < Integer.MAX_VALUE && size < MAX_BUF_SIZE) {
1:                 dataBytes = new byte [(int) size];
0:                 read(dataBytes, 0);
1:                 isBytes = true;
0:                 tmpFile.close();
1:                 tmpFile = null;
0:             } else
0:                 tmpFile.setLength(size);
1:         }
1:     }
1: 
1:     /**
1:      * Copies bytes from stream to local storage.
0:      * @param inStream
0:      * @param pos length to be copied
0:      * @throws IOException, SQLException
1:      */
0:     synchronized void copyData(InputStream inStream,
0:             long length) throws IOException, SQLException {
0:         byte [] data = new byte [MAX_BUF_SIZE];
1:         long sz = 0;
1:         while (sz < length) {
0:             int len = (int) (((length - sz) >= MAX_BUF_SIZE) ? MAX_BUF_SIZE
0:                     : length - sz);
0:             inStream.read(data, 0, len);
1:             write(data, 0, len, sz);
1:             sz += len;
1:         }
1:     }
1: 
1:     protected void finalize() throws Throwable {
1:         free();
1:     }
1: 
1:     /**
1:      * Invalidates all the variables and closes file handle if open.
0:      * @throws IOexception
1:      */
1:     void free() throws IOException {
1:         dataBytes = null;
1:         if (tmpFile != null) {
0:             tmpFile.close();
1:             try {
0:                 AccessController.doPrivileged (new PrivilegedExceptionAction() {
0:                     public Object run() throws IOException {
0:                         lobFile.delete();
1:                         return null;
1:                     }
1:                 });
1:             }
1:             catch (PrivilegedActionException pae) {
0:                 Exception e = pae.getException();
0:                 if (e instanceof IOException)
0:                     throw (IOException) e;
0:                 if (e instanceof RuntimeException)
0:                     throw (RuntimeException) e;
1:             }
1:         }
1:     }
1: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:10e4538
/////////////////////////////////////////////////////////////////////////
1:     private final EmbedConnection conn;
1:      * @param conn Connection for this lob
1:     LOBStreamControl (EmbedConnection conn) {
1:         this.conn = conn;
/////////////////////////////////////////////////////////////////////////
1:      * @param conn Connection for this lob
1:     LOBStreamControl (EmbedConnection conn, byte [] data)
1:         this.conn = conn;
/////////////////////////////////////////////////////////////////////////
0:                             Property.DATABASE_MODULE, conn.getDBName());
/////////////////////////////////////////////////////////////////////////
0:                     conn.addLobFile(tmpFile);
/////////////////////////////////////////////////////////////////////////
0:                 conn.removeLobFile(tmpFile);
/////////////////////////////////////////////////////////////////////////
0:             conn.removeLobFile(tmpFile);
/////////////////////////////////////////////////////////////////////////
0:             conn.removeLobFile(oldFile);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:ce145ef
/////////////////////////////////////////////////////////////////////////
0:     private void deleteFile (StorageFile file) throws IOException {
0:         try {
0:             final StorageFile sf = file;
0:             AccessController.doPrivileged(new PrivilegedExceptionAction() {
0:                 public Object run() throws IOException {
0:                     sf.delete();
0:                     return null;
0:                 }
0:             });
0:         } catch (PrivilegedActionException pae) {
0:             Exception e = pae.getException();
0:             if (e instanceof IOException)
0:                 throw (IOException) e;
0:             if (e instanceof RuntimeException)
0:                 throw (RuntimeException) e;
0:             IOException ioe = new IOException(e.getMessage());
0:             ioe.initCause(e);
0:             throw ioe;
0:         }
0:     }
/////////////////////////////////////////////////////////////////////////
0:             deleteFile(lobFile);
1:             tmpFile = null;
/////////////////////////////////////////////////////////////////////////
0:             StorageFile oldStoreFile = lobFile;
/////////////////////////////////////////////////////////////////////////
0:                 oldFile.close();
0:                 deleteFile(oldStoreFile);
============================================================================