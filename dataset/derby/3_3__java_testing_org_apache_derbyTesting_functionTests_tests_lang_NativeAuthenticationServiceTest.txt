1:5107349: /*
16:5107349: 
1:5107349:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.NativeAuthenticationServiceTest
1:5107349: 
1:5107349:    Licensed to the Apache Software Foundation (ASF) under one or more
1:5107349:    contributor license agreements.  See the NOTICE file distributed with
1:5107349:    this work for additional information regarding copyright ownership.
1:5107349:    The ASF licenses this file to you under the Apache License, Version 2.0
1:5107349:    (the "License"); you may not use this file except in compliance with
1:5107349:    the License.  You may obtain a copy of the License at
1:5107349: 
1:5107349:      http://www.apache.org/licenses/LICENSE-2.0
1:5107349: 
1:5107349:    Unless required by applicable law or agreed to in writing, software
1:5107349:    distributed under the License is distributed on an "AS IS" BASIS,
1:5107349:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:5107349:    See the License for the specific language governing permissions and
1:5107349:    limitations under the License.
1:5107349: 
1:5107349:  */
1:5107349: 
1:5107349: package org.apache.derbyTesting.functionTests.tests.lang;
1:5107349: 
1:dc9cd0f: import java.io.File;
1:4a08a15: import java.net.URL;
1:5107349: import java.sql.Connection;
1:c5b9acb: import java.sql.PreparedStatement;
1:c5b9acb: import java.sql.ResultSet;
1:5107349: import java.sql.SQLException;
1:49901a4: import java.sql.SQLWarning;
1:5107349: import java.util.Properties;
1:dc9cd0f: import javax.sql.DataSource;
1:5107349: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:92a2169: import org.apache.derbyTesting.junit.ClasspathSetup;
1:c0399dc: import org.apache.derbyTesting.junit.DatabaseChangeSetup;
1:5107349: import org.apache.derbyTesting.junit.JDBC;
1:dc9cd0f: import org.apache.derbyTesting.junit.JDBCDataSource;
1:92a2169: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:5107349: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1:92a2169: import org.apache.derbyTesting.junit.TestConfiguration;
1:fcd3d48: import org.apache.derbyTesting.junit.TimeZoneTestSetup;
1:5107349: 
1:5107349: /**
1:5107349:  * <p>
1:5107349:  * Tests for the NATIVE authentication service introduced by DERBY-866.
1:5107349:  * </p>
1:5107349:  */
1:5107349: public class NativeAuthenticationServiceTest extends GeneratedColumnsHelper
4:5107349: {
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:ae21afb:     //
1:5107349:     // CONSTANTS
1:ae21afb:     //
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:92a2169: 
1:ae21afb:     // location of credentials db
1:ae21afb:     private static  final   int FILE = 0;
1:ae21afb:     private static  final   int JAR = 1;
1:ae21afb:     private static  final   int CLASSPATH = 2;
1:ae21afb:     private static  final   int NONE = 3;
1:47f286f:     private static  final   int JAR_ENCRYPTED = 4;
1:ae21afb: 
1:ae21afb:     // settings for constructor options
1:ae21afb:     private static  final   boolean NATIVE = true;
1:ae21afb:     private static  final   boolean NO_AUTH = false;
1:ae21afb:     
1:ae21afb:     private static  final   boolean LOCAL = true;
1:ae21afb:     private static  final   boolean SYSTEM_WIDE = false;
1:ae21afb:     
1:ae21afb:     private static  final   boolean DISABLE_AUTHORIZATION = true;
1:ae21afb:     private static  final   boolean DONT_DISABLE_AUTH = false;
1:ae21afb:     
1:5107349:     // fruits are legal users. nuts are not
1:5107349:     private static  final   String  DBO = "KIWI";   
1:5107349:     private static  final   String  APPLE_USER = "APPLE";   
1:5107349:     private static  final   String  PEAR_USER = "PEAR";   
1:5ea170f:     private static  final   String  PRICKLY_PEAR_USER = "PeAr";   
1:c0399dc:     private static  final   String  ORANGE_USER = "ORANGE";   
1:dc9cd0f:     private static  final   String  BANANA_USER = "BANANA";   
1:92a2169:     private static  final   String  GRAPE_USER = "GRAPE";   
1:5ea170f:     private static  final   String  PINEAPPLE_USER = "PINEAPPLE";
1:5ea170f: 
1:5ea170f:     private static  final   String  CAMEL_CASE_DBO = "kIwI";
1:ae21afb: 
1:5107349:     private static  final   String  WALNUT_USER = "WALNUT";
1:92a2169: 
1:a3d7a74:     private static  final   String  BUILTIN_USER = "PECAN";
1:a3d7a74: 
1:5107349:     private static  final   String  CREDENTIALS_DB = "credDB";
1:5107349:     private static  final   String  SECOND_DB = "secondDB";
1:5107349:     private static  final   String  THIRD_DB = "thirdDB";
1:c0399dc:     private static  final   String  FOURTH_DB = "fourthDB";
1:49901a4:     private static  final   String  FIFTH_DB = "fifthDB";
1:dc9cd0f:     private static  final   String  SIXTH_DB = "sixthDB";
1:a3d7a74:     private static  final   String  SEVENTH_DB = "seventhDB";
1:a3d7a74:     private static  final   String  EIGHTH_DB = "eighthDB";
1:92a2169:     private static  final   String  NINTH_DB = "ninthDB";
1:ae21afb:     private static  final   String  TENTH_DB = "tenthDB";
1:ae21afb:     private static  final   String  ELEVENTH_DB = "eleventhDB";
1:3b95c63:     private static  final   String  TWELTH_DB = "twelthDB";
1:47f286f:     private static  final   String  THIRTEENTH_DB = "thirteenthDB";
1:47f286f:     private static  final   String  FOURTEENTH_DB = "fourteenthDB";
1:33605bd:     private static  final   String  FIFTEENTH_DB = "fifteenthDB";
1:92a2169: 
1:92a2169:     private static  final   String  NAST1_JAR_FILE = "nast1.jar";
1:92a2169:     private static  final   String  NAST2_JAR_FILE = "nast2.jar";
1:92a2169:     private static  final   String[]    SUPPORT_FILES_SOURCE =
1:92a2169:     {
1:92a2169:         "functionTests/tests/lang/" + NAST1_JAR_FILE,
1:92a2169:         "functionTests/tests/lang/" + NAST1_JAR_FILE,
1:35e7aba:     };
1:92a2169:     private static  final   String[]    SUPPORT_FILES_TARGET =
1:92a2169:     {
1:92a2169:         NAST1_JAR_FILE,
1:92a2169:         NAST2_JAR_FILE,
2:92a2169:     };
1:5107349: 
1:5107349:     private static  final   String  PROVIDER_PROPERTY = "derby.authentication.provider";
1:a3d7a74:     private static  final   String  REQUIRE_AUTHENTICATION_PROPERTY = "derby.connection.requireAuthentication";
1:a3d7a74:     private static  final   String  SQL_AUTHORIZATION_PROPERTY = "derby.database.sqlAuthorization";
1:45f5174:     private static  final   String  UPGRADE_TO_BETA_PROPERTY = "derby.database.allowPreReleaseUpgrade";
1:5107349: 
1:5107349:     private static  final   String  CREDENTIALS_DB_DOES_NOT_EXIST = "4251I";
1:10f4b0f:     private static  final   String  BAD_NETWORK_AUTHENTICATION = "08001";
1:5107349:     private static  final   String  INVALID_AUTHENTICATION = "08004";
1:c0399dc:     private static  final   String  DBO_ONLY_OPERATION = "4251D";
1:c0399dc:     private static  final   String  INVALID_PROVIDER_CHANGE = "XCY05";
1:c0399dc:     private static  final   String  CANT_DROP_DBO = "4251F";
1:c0399dc:     private static  final   String  NO_COLUMN_PERMISSION = "42502";
1:3b95c63:     private static  final   String  NO_EXECUTE_PERMISSION = "42504";
1:49901a4:     private static  final   String  PASSWORD_EXPIRING = "01J15";
1:65a5491:     private static  final   String  DBO_PASSWORD_EXPIRING = "01J16";
1:49901a4:     private static  final   String  BAD_PASSWORD_PROPERTY = "4251J";
1:a3d7a74:     private static  final   String  BAD_PROPERTY_CHANGE = "XCY02";
1:3b95c63:     private static  final   String  SQL_AUTHORIZATION_NOT_ON = "42Z60";
1:47f286f:     private static  final   String  CANT_BOOT_DATABASE = "XJ040";
1:c5b9acb:     private static  final   String  MISSING_USER = "XK001";
1:33605bd:     private static  final   String  BAD_USER_AUTHENTICATOR_CLASS = "XBM0M";
1:5ea170f:     private static  final   String  USER_ALREADY_EXISTS = "X0Y68";
1:c5b9acb: 
1:c5b9acb:     private static  final   String      WEAK_AUTHENTICATION = "4251G";
1:c5b9acb:     private static  final   String      HASHING_FORMAT_10_9 = "3b62";
1:c5b9acb:     private static  final   int           HEX_CHARS_PER_BYTE = 2;
1:5107349: 
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:92a2169:     //
1:5107349:     // STATE
1:92a2169:     //
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349: 
1:ae21afb:     private final   int         _credentialsDBLocation;
1:5107349:     private final   boolean _nativeAuthentication;
1:5107349:     private final   boolean _localAuthentication;
1:a3d7a74:     private final   boolean _turnOffAuthenticationAndAuthorization;
1:5107349: 
1:dc9cd0f:     private String  _credentialsDBPhysicalName;
1:dc9cd0f: 
1:c0399dc:     private DatabaseChangeSetup _fourthDBSetup;
1:49901a4:     private DatabaseChangeSetup _fifthDBSetup;
1:dc9cd0f:     private DatabaseChangeSetup _sixthDBSetup;
1:a3d7a74:     private DatabaseChangeSetup _seventhDBSetup;
1:a3d7a74:     private DatabaseChangeSetup _eighthDBSetup;
1:92a2169:     private DatabaseChangeSetup _ninthDBSetup;
1:33605bd:     private DatabaseChangeSetup _fifteenthDBSetup;
1:dc9cd0f: 
1:dc9cd0f:     private String  _derbySystemHome;
1:dc9cd0f:     private String  _fullBackupDir;
1:c0399dc: 
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:92a2169:     //
1:5107349:     // CONSTRUCTOR
1:92a2169:     //
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349: 
1:5107349:     public  NativeAuthenticationServiceTest
1:ae21afb:         (
1:ae21afb:          int            credentialsDBLocation,
1:5107349:          boolean    nativeAuthentication,
1:a3d7a74:          boolean    localAuthentication,
1:9f1b314:          boolean    turnOffAuthenticationAndAuthorization
1:5107349:          )
1:5107349:     {
1:5107349:         super( "testAll" );
1:5107349: 
1:ae21afb:         _credentialsDBLocation = credentialsDBLocation;
1:5107349:         _nativeAuthentication = nativeAuthentication;
1:5107349:         _localAuthentication = localAuthentication;
1:a3d7a74:         _turnOffAuthenticationAndAuthorization = turnOffAuthenticationAndAuthorization;
1:c0399dc:     }
1:3b95c63: 
1:3b95c63:     ///////////////////////////////////////////////////////////////////////////////////
1:3b95c63:     //
1:5107349:     // SETUP BEHAVIOR
5:5107349:     //
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:3b95c63: 
1:dc9cd0f:     public void setUp() throws Exception
1:dc9cd0f:     {
1:dc9cd0f:         super.setUp();
1:dc9cd0f:         
1:dc9cd0f:         _derbySystemHome = getSystemProperty( "derby.system.home" );
1:dc9cd0f:         _fullBackupDir = _derbySystemHome + "/backupDir";
1:dc9cd0f:     }
1:dc9cd0f: 
1:49901a4:     /**
1:49901a4:      * <p>
1:5107349:      * Return the system properties to be used in a particular test run.
1:5107349:      * </p>
1:5107349:      */
1:5107349:     private Properties  systemProperties( String physicalDatabaseName )
1:ae21afb:         throws  Exception
1:5107349:     {
1:5107349:         Properties  result = new Properties();
1:dc9cd0f:         String      authenticationProvider;
1:dc9cd0f: 
1:ae21afb:         switch ( _credentialsDBLocation )
1:ae21afb:         {
1:ae21afb:             case JAR:
1:47f286f:             case JAR_ENCRYPTED:
1:47f286f:                 _credentialsDBPhysicalName = jarDBName( _credentialsDBLocation );
1:ae21afb:                 break;
1:ae21afb: 
1:ae21afb:             case CLASSPATH:
1:ae21afb:                 _credentialsDBPhysicalName = classpathDBName();
1:ae21afb:                 break;
1:ae21afb: 
1:ae21afb:             case FILE:
1:ae21afb:             case NONE:
1:ae21afb:                 _credentialsDBPhysicalName = physicalDatabaseName;
1:ae21afb:                 break;
1:ae21afb:                 
1:ae21afb:             default:
1:ae21afb:                 throw new Exception( "Unknown location of credentials db: " + _credentialsDBLocation );
1:ae21afb:         }
1:dc9cd0f: 
1:dc9cd0f:         if ( !_nativeAuthentication )
1:dc9cd0f:         {
1:dc9cd0f:             authenticationProvider = "NONE";
1:dc9cd0f:         }
1:35e7aba:         else
1:35e7aba:         {
1:ae21afb:             authenticationProvider = "NATIVE:" + _credentialsDBPhysicalName;
1:dc9cd0f:             if ( _localAuthentication ) { authenticationProvider = authenticationProvider + ":LOCAL"; }
1:dc9cd0f:         }
1:dc9cd0f: 
1:45f5174:         result.put( UPGRADE_TO_BETA_PROPERTY, "true" );
1:5107349:         result.put( PROVIDER_PROPERTY, authenticationProvider );
1:c0399dc: 
1:a3d7a74:         //
1:a3d7a74:         // This is to verify that NATIVE authentication trumps attempts
1:a3d7a74:         // to disable these features at the system level.
1:a3d7a74:         //
1:a3d7a74:         if ( _turnOffAuthenticationAndAuthorization )
1:a3d7a74:         {
1:a3d7a74:             result.put( REQUIRE_AUTHENTICATION_PROPERTY, "false" );
1:a3d7a74:             result.put( SQL_AUTHORIZATION_PROPERTY, "false" );
1:a3d7a74:         }
1:a3d7a74: 
1:5107349:         return result;
5:5107349:     }
1:5107349: 
1:c0399dc:     /**
1:c0399dc:      * <p>
1:ae21afb:      * Return true if the credentials db is accessed via a jar or classpath subprotocol.
1:ae21afb:      * </p>
1:ae21afb:      */
1:ae21afb:     private boolean credentialsViaSubprotocol()
1:ae21afb:     {
1:ae21afb:         switch ( _credentialsDBLocation )
1:ae21afb:         {
1:ae21afb:             case JAR:
1:47f286f:             case JAR_ENCRYPTED:
1:ae21afb:             case CLASSPATH:
1:ae21afb:                 return true;
1:ae21afb: 
1:ae21afb:             default:
1:ae21afb:                 return false;
1:ae21afb:         }
1:ae21afb:     }
1:ae21afb: 
1:ae21afb:     /**
1:ae21afb:      * <p>
1:5107349:      * Construct the name of this test (useful for error messages).
1:5107349:      * </p>
1:5107349:      */
1:5107349:     private String  nameOfTest()
1:dc9cd0f:     {
1:ae21afb:         String  dbLocation = "";
1:ae21afb:         switch ( _credentialsDBLocation )
1:ae21afb:         {
1:ae21afb:             case JAR:
1:ae21afb:                 dbLocation = "JAR, ";
1:ae21afb:                 break;
1:ae21afb: 
1:47f286f:             case JAR_ENCRYPTED:
1:47f286f:                 dbLocation = "JAR_ENCRYPTED, ";
1:47f286f:                 break;
1:47f286f: 
1:ae21afb:             case CLASSPATH:
1:ae21afb:                 dbLocation = "CLASSPATH, ";
1:ae21afb:                 break;
1:ae21afb: 
1:ae21afb:             case FILE:
1:ae21afb:             case NONE:
1:ae21afb:                 dbLocation = "FILE, ";
1:ae21afb:                 break;
1:ae21afb:                 
1:ae21afb:             default:
1:ae21afb:                 dbLocation = "UNKNOWN, ";
1:ae21afb:                 break;
1:ae21afb:         }
1:ae21afb: 
1:ae21afb:         
1:5107349:         String  authType = _nativeAuthentication ?
1:5107349:             "NATIVE authentication on, " :
1:5107349:             "Authentication off, ";
1:5107349:         String  local = _localAuthentication ?
1:49901a4:             "LOCAL authentication ON, " :
1:49901a4:             "LOCAL authentication OFF, ";
1:a3d7a74:         String  authOverrides = _turnOffAuthenticationAndAuthorization ?
1:a3d7a74:             "Authentication/Authorization turned OFF, " :
1:a3d7a74:             "Authentication/Authorization DEFAULT, ";
1:49901a4:         String  embedded = isEmbedded() ?
1:49901a4:             "Embedded" :
1:49901a4:             "Client/Server";
1:49901a4: 
1:9f1b314:         return "[ " + dbLocation + authType + local + authOverrides + embedded + " ]";
1:5107349:     }
1:5107349: 
1:49901a4:     /** Return true if the test is running embedded */
1:49901a4:     public  boolean isEmbedded() { return getTestConfiguration().getJDBCClient().isEmbedded(); }
1:5107349:     
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349:     //
1:5107349:     // JUnit BEHAVIOR
1:5107349:     //
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349: 
1:5107349: 
1:5107349:     /**
1:5107349:      * Construct top level suite in this JUnit test
1:5107349:      */
1:4a08a15:     public static Test suite() throws Exception
1:5107349:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite();
1:5107349: 
1:5107349:         //
1:47f286f:         // Special version of the test which uses an encrypted database for credentials.
1:4a08a15:         // Only run on platforms where we can expect cleanup of support files
1:4a08a15:         // to succeed (DERBY-5618).
1:5107349:         //
1:4a08a15:         if (enableSubprotocolTests())
1:47f286f:         {
1:47f286f:             suite.addTest
1:47f286f:                 (
1:47f286f:                  (
1:47f286f:                   new NativeAuthenticationServiceTest
1:9f1b314:                   ( JAR_ENCRYPTED, NATIVE, LOCAL, DONT_DISABLE_AUTH )
1:47f286f:                   ).decorate( false )
1:47f286f:                  );
1:47f286f:         }
1:c0399dc:         
1:5107349:         suite.addTest( allConfigurations( false ) );
1:5107349:         if ( !JDBC.vmSupportsJSR169() ) { suite.addTest( allConfigurations( true ) ); }
1:5107349: 
1:fcd3d48:         // DERBY-5966: Run the test in the GMT time zone to avoid instabilities
1:fcd3d48:         // around transition to or from DST. Once DERBY-5974 has been fixed, it
1:fcd3d48:         // should be OK to run in the local time zone.
1:fcd3d48:         return new TimeZoneTestSetup(suite, "GMT");
1:5107349:     }
1:4a08a15: 
1:4a08a15:     /**
1:4a08a15:      * Check whether or not tests for subprotocols should be enabled
1:4a08a15:      * on this platform.
1:4a08a15:      */
1:4a08a15:     private static boolean enableSubprotocolTests() {
1:4a08a15:         // DERBY-5618: On Windows, we are not able to delete the jar files
1:4a08a15:         // used by the tests for the classpath subsubprotocol if we don't
1:4a08a15:         // close the URLClassLoader when we're done. Closing the class loader
1:4a08a15:         // can only be done on Java 7 and higher.
1:4a08a15:         //
1:4a08a15:         // Run the tests if the Java version supports URLClassLoader.close(),
1:4a08a15:         // or if we're on a non-Windows platform (where the jar files can be
1:4a08a15:         // deleted even if the class loader hasn't been closed).
1:4a08a15:         return ClasspathSetup.supportsClose() || !isWindowsPlatform();
1:5107349:     }
1:5107349: 
1:5107349:     /**
1:5107349:      * <p>
1:5107349:      * Create a suite of all test configurations.
1:5107349:      * </p>
1:5107349:      */
1:4a08a15:     private static Test allConfigurations(boolean clientServer) throws Exception
1:5107349:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite();
1:5107349: 
1:5107349:         //
1:47f286f:         // No authentication. 
1:5107349:         //
1:ae21afb:         suite.addTest
1:ae21afb:             (
1:ae21afb:              (
1:ae21afb:               new NativeAuthenticationServiceTest
1:9f1b314:               ( NONE, NO_AUTH, SYSTEM_WIDE, DONT_DISABLE_AUTH )
1:ae21afb:               ).decorate( clientServer )
1:ae21afb:              );
1:ae21afb: 
1:ae21afb:         //
1:ae21afb:         // NATIVE/LOCAL authentication with credentials in read/write dbs
1:ae21afb:         //
2:ae21afb:         suite.addTest
1:ae21afb:             (
1:ae21afb:              (
2:ae21afb:               new NativeAuthenticationServiceTest
1:9f1b314:               ( FILE, NATIVE, LOCAL, DISABLE_AUTHORIZATION )
1:ae21afb:               ).decorate( clientServer )
1:ae21afb:              );
1:ae21afb:         suite.addTest
1:ae21afb:             (
1:ae21afb:              (
1:ae21afb:               new NativeAuthenticationServiceTest
1:9f1b314:               ( FILE, NATIVE, LOCAL, DONT_DISABLE_AUTH )
1:ae21afb:               ).decorate( clientServer )
1:ae21afb:              );
1:ae21afb: 
1:ae21afb:         //
1:ae21afb:         // NATIVE system-wide authentication with credentials in read/write dbs
1:ae21afb:         //
1:ae21afb:         suite.addTest
1:ae21afb:             (
1:ae21afb:              (
1:ae21afb:               new NativeAuthenticationServiceTest
1:9f1b314:               ( FILE, NATIVE, SYSTEM_WIDE, DISABLE_AUTHORIZATION )
1:ae21afb:               ).decorate( clientServer )
1:ae21afb:              );
1:ae21afb:         suite.addTest
1:ae21afb:             (
1:ae21afb:              (
1:ae21afb:               new NativeAuthenticationServiceTest
1:9f1b314:               ( FILE, NATIVE, SYSTEM_WIDE, DONT_DISABLE_AUTH )
1:ae21afb:               ).decorate( clientServer )
1:ae21afb:              );
1:ae21afb:         
1:ae21afb:         //
1:4a08a15:         // For testing subprotocols. Only run on platforms where we can
1:4a08a15:         // expect cleanup of support files to succeed (DERBY-5618).
1:ae21afb:         //
1:4a08a15:         if (enableSubprotocolTests())
1:ae21afb:         {
1:ae21afb:             //
1:ae21afb:             // NATIVE authentication with credentials in read-only databases accessed via jar subprotocol
1:ae21afb:             //
1:ae21afb:             suite.addTest
1:ae21afb:                 (
1:ae21afb:                  (
1:ae21afb:                   new NativeAuthenticationServiceTest
1:9f1b314:                   ( JAR, NATIVE, SYSTEM_WIDE, DONT_DISABLE_AUTH )
1:ae21afb:                   ).decorate( clientServer )
1:ae21afb:                  );
1:ae21afb:             suite.addTest
1:ae21afb:                 (
1:ae21afb:                  (
1:ae21afb:                   new NativeAuthenticationServiceTest
1:9f1b314:                   ( JAR, NATIVE, LOCAL, DONT_DISABLE_AUTH )
1:ae21afb:                   ).decorate( clientServer )
1:ae21afb:                  );
1:ae21afb: 
1:ae21afb:             //
1:ae21afb:             // NATIVE authentication with credentials in read-only databases accessed via classpath subprotocol
1:ae21afb:             //
1:ae21afb:             suite.addTest
1:ae21afb:                 (
1:ae21afb:                  (
1:ae21afb:                   new NativeAuthenticationServiceTest
1:9f1b314:                   ( CLASSPATH, NATIVE, SYSTEM_WIDE, DONT_DISABLE_AUTH )
1:ae21afb:                   ).decorate( clientServer )
1:ae21afb:                  );
1:ae21afb:             suite.addTest
1:ae21afb:                 (
1:ae21afb:                  (
1:ae21afb:                   new NativeAuthenticationServiceTest
1:9f1b314:                   ( CLASSPATH, NATIVE, LOCAL, DONT_DISABLE_AUTH )
1:ae21afb:                   ).decorate( clientServer )
1:ae21afb:                  );
1:4a08a15:         }
1:5107349: 
2:5107349:         return suite;
1:92a2169:     }
1:5107349: 
1:5107349:     /**
1:5107349:      * <p>
1:5107349:      * Wrap base test with standard decorators in order to setup system
1:5107349:      * properties and allow for the creation of multiple databases with
1:5107349:      * stored properties that can't be removed at tearDown time.
1:5107349:      * </p>
1:5107349:      */
1:4a08a15:     private Test decorate(boolean clientServer) throws Exception
1:92a2169:     {
1:5107349:         String      credentialsDBPhysicalName = TestConfiguration.generateUniqueDatabaseName();
1:5107349:         
1:c0399dc:         Test        result = this;
1:92a2169: 
1:5107349:         //
1:5107349:         // Putting the clientServer decorator on the inside allows the server-side
1:5107349:         // embedded driver to be re-registered after engine shutdown. If you put
1:5107349:         // this decorator outside the SystemProperty decorator, then engine shutdown
1:5107349:         // unregisters the server-side embedded driver and it can't be found by
1:5107349:         // the next test.
1:5107349:         //
1:5107349:         if ( clientServer ) { result = TestConfiguration.clientServerDecorator( result ); }
1:5107349:         
1:5107349:         //
1:5107349:         // Turn on the property which enables NATIVE authentication. This will trigger
1:5107349:         // an engine shutdown at the end of the test. We want to shutdown the engine
1:5107349:         // before deleting the physical databases. This is because we need one of the
1:5107349:         // databases (the credentials db) in order to authenticate engine shutdown.
1:5107349:         //
1:ae21afb:         Properties  systemProperties = null;
1:ae21afb:         try {
1:ae21afb:             systemProperties = systemProperties( credentialsDBPhysicalName );
1:ae21afb:         } catch (Exception e) { printStackTrace( e ); }
1:ae21afb: 
1:ae21afb:         println( nameOfTest() );
1:ae21afb:         println( "    NativeAuthenticationServiceTest.decorate() systemProperties = " + systemProperties );
1:dc9cd0f:         result = new SystemPropertyTestSetup( result, systemProperties, true );
1:dc9cd0f:         
1:35e7aba:         // DERBY-5580: We should also shut down the engine before deleting
1:35e7aba:         // the database if we don't set any system properties.
1:dc9cd0f:         //result = new TestSetup(result) {
1:dc9cd0f:         //        protected void tearDown() {
1:dc9cd0f:         //            TestConfiguration.getCurrent().shutdownEngine();
1:dc9cd0f:         //        }
1:dc9cd0f:         //    };
1:92a2169:         
1:92a2169:         //
1:4a08a15:         // For testing subprotocols. Only run on platforms where we can
1:4a08a15:         // expect cleanup of support files to succeed (DERBY-5618).
1:92a2169:         //
1:4a08a15:         if (enableSubprotocolTests())
1:92a2169:         {
1:4a08a15:             // Add a jar file to the classpath so that we can test the classpath subprotocol.
1:4a08a15:             URL nast2Jar = SupportFilesSetup.getReadOnlyURL(NAST2_JAR_FILE);
1:4a08a15:             result = new ClasspathSetup(result, nast2Jar);
1:4a08a15: 
1:92a2169:             // Add the jar files needed for testing jar and classpath subprotocols.
1:92a2169:             result = new SupportFilesSetup( result, SUPPORT_FILES_SOURCE, null, SUPPORT_FILES_TARGET, null );
1:35e7aba:         }
1:92a2169:         
1:92a2169:         //
1:5107349:         // Register temporary databases, where the test will do its work.
1:5107349:         // We can't use the default, re-usable database because NATIVE authentication stores
1:5107349:         // persistent properties which cannot be turned off.
1:5107349:         //
1:5107349:         result = TestConfiguration.additionalDatabaseDecoratorNoShutdown
1:5107349:             ( result, CREDENTIALS_DB, credentialsDBPhysicalName );
1:5107349:         result = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, SECOND_DB );
1:5107349:         result = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, THIRD_DB );
1:c0399dc:         result = _fourthDBSetup = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, FOURTH_DB, true );
1:49901a4:         result = _fifthDBSetup = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, FIFTH_DB, true );
1:dc9cd0f:         result = _sixthDBSetup = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, SIXTH_DB, true );
1:a3d7a74:         result = _seventhDBSetup = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, SEVENTH_DB, true );
1:a3d7a74:         result = _eighthDBSetup = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, EIGHTH_DB, true );
1:92a2169:         result = _ninthDBSetup = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, NINTH_DB, true );
1:ae21afb:         result = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, TENTH_DB );
1:ae21afb:         result = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, ELEVENTH_DB );
1:3b95c63:         result = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, TWELTH_DB );
1:47f286f:         result = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, THIRTEENTH_DB );
1:47f286f:         result = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, FOURTEENTH_DB );
1:33605bd:         result = _fifteenthDBSetup = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, FIFTEENTH_DB, true );
1:c0399dc: 
1:5107349:         result = TestConfiguration.changeUserDecorator( result, DBO, getPassword( DBO ) );
1:c0399dc:         
1:5107349:         return result;
1:35e7aba:     }
1:5107349:     
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349:     //
1:5107349:     // TESTS
1:5107349:     //
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349: 
1:c0399dc:     /**
1:c0399dc:      * <p>
1:5107349:      * Entry point for tests.
1:c0399dc:      * </p>
1:c0399dc:      */
1:5107349:     public  void    testAll()   throws Exception
1:c0399dc:     {
1:5107349:         println( nameOfTest() );
1:dc9cd0f:         println( "Credentials DB physical name = " + _credentialsDBPhysicalName );
1:dc9cd0f:         println( PROVIDER_PROPERTY + " = " + getSystemProperty( PROVIDER_PROPERTY ) );
1:5107349: 
1:47f286f:         if ( _credentialsDBLocation == JAR_ENCRYPTED )
1:47f286f:         {
1:47f286f:             vetEncryptedCredentialsDB();
1:47f286f:         }
1:47f286f:         else if ( credentialsViaSubprotocol() )
1:ae21afb:         {
1:ae21afb:             vetCredentialsViaSubprotocol();
1:ae21afb:         }
1:ae21afb:         else
1:ae21afb:         {
1:ae21afb:             vetCoreBehavior();
1:5ea170f:             vetCasing();
1:ae21afb:             vetSystemWideOperations();
1:5107349: 
1:ae21afb:             if ( !_nativeAuthentication ) { vetProviderChanges(); }
1:49901a4: 
1:ae21afb:             // only run this for local authentication so that we don't have to shutdown
1:ae21afb:             // the system-wide credentials db. also only run this embedded so that we
1:ae21afb:             // don't have to deal with the problems of shutting down a database
1:ae21afb:             // across the network.
1:ae21afb:             if ( _localAuthentication && isEmbedded() ) { vetPasswordLifetime(); }
1:ae21afb:         }
1:92a2169:     }
1:5107349: 
1:5107349:     /**
1:5107349:      * <p>
1:47f286f:      * Verify behavior when credentials live in an encrypted db.
1:47f286f:      * </p>
1:47f286f:      */
1:47f286f:     private void    vetEncryptedCredentialsDB()   throws Exception
1:47f286f:     {
1:47f286f:         // can't create a database if the encrypted credentials db hasn't been booted yet
1:47f286f:         Connection  badConn = getConnection( true, true, THIRTEENTH_DB, DBO, CANT_BOOT_DATABASE );
1:47f286f:         
1:47f286f:         // now boot the encrypted credentials db
1:47f286f:         Properties  props = new Properties();
1:47f286f:         props.setProperty( "bootPassword", "clo760uds2caPe" );
1:47f286f:         Connection  dboConn = openConnection( jarDBName( _credentialsDBLocation ), DBO, false, props );
1:47f286f: 
1:47f286f:         // credentials db is booted. now we can create databases with good credentials.
1:47f286f:         Connection  grapeConn = getConnection( false, true, THIRTEENTH_DB, GRAPE_USER, null );
1:47f286f: 
1:47f286f:         // but we can't create a database with bad credentials
1:47f286f:         getConnection( true, true, FOURTEENTH_DB, WALNUT_USER, INVALID_AUTHENTICATION );
1:47f286f:     }
1:47f286f:     
1:47f286f:     /**
1:47f286f:      * <p>
1:ae21afb:      * Verify that credentials work when they are stored in a db accessed via
1:ae21afb:      * the jar or classpath subprotocols.
1:ae21afb:      * </p>
1:ae21afb:      */
1:ae21afb:     private void    vetCredentialsViaSubprotocol()   throws Exception
1:ae21afb:     {
1:ae21afb:         // create a new database
1:47f286f:         Connection  grapeConn = openConnection( TENTH_DB, GRAPE_USER, true, null );
1:ae21afb:         String[][]  legalUsers = _localAuthentication ?
1:ae21afb:             new String[][] { { GRAPE_USER } } : new String[][] {};
1:ae21afb:         assertResults
1:ae21afb:             (
1:ae21afb:              grapeConn,
1:ae21afb:              "select username from sys.sysusers order by username",
1:ae21afb:              legalUsers,
1:ae21afb:              false
1:ae21afb:              );
1:ae21afb: 
1:ae21afb:         // Databases can't be created by users who don't have credentials stored in the credentials database
1:ae21afb:         Connection  walnutConn = getConnection
1:ae21afb:             ( true, true, ELEVENTH_DB, WALNUT_USER, INVALID_AUTHENTICATION );
1:ae21afb:     }
1:ae21afb:     
1:ae21afb:     /**
1:ae21afb:      * <p>
1:49901a4:      * Verify the core behavior of NATIVE authentication.
1:5107349:      * </p>
1:5107349:      */
1:49901a4:     private void    vetCoreBehavior()   throws Exception
1:5107349:     {
1:5107349:         // can't create any database until the credentials db has been created
1:c0399dc:         Connection  secondDBConn = getConnection
1:92a2169:             ( _nativeAuthentication, true, SECOND_DB, APPLE_USER, CREDENTIALS_DB_DOES_NOT_EXIST );
1:a3d7a74: 
1:10f4b0f:         // can't create a credentials db with an empty username or password
1:10f4b0f:         if ( _nativeAuthentication ) { vetEmptyCredentials(); }
1:10f4b0f:         
1:5107349:         // create the credentials database
1:47f286f:         Connection  sysadminConn = openConnection( CREDENTIALS_DB, DBO, true, null );
1:601e027: 
1:601e027:         // null password should not generate NPE
1:601e027:         getConnection( _nativeAuthentication, true, CREDENTIALS_DB, DBO, null, INVALID_AUTHENTICATION );
1:c5b9acb: 
1:aa1dc7a:         // add the dbo as a user if she wasn't created when the database was created
1:c5b9acb:         if ( !_nativeAuthentication )
1:c5b9acb:         {
1:aa1dc7a:             // verify that only the DBO can create credentials for the DBO
1:aa1dc7a:             Connection  pineappleConn = openConnection( CREDENTIALS_DB, PINEAPPLE_USER, true, null );
1:aa1dc7a:             addUser( pineappleConn, DBO, DBO_ONLY_OPERATION );  // this should fail
1:aa1dc7a:             
1:c5b9acb:             addUser( sysadminConn, DBO );
1:c5b9acb:         }
1:5ea170f: 
1:5107349:         // add another legal user
1:5107349:         addUser( sysadminConn, APPLE_USER );
1:dc9cd0f:         addUser( sysadminConn, BANANA_USER );
1:5107349: 
1:a3d7a74:         //
1:5107349:         // Creating the credentials db should have stored the following information in it:
1:5107349:         //
1:5107349:         // 1) The DBO's credentials should have been stored in SYSUSERS.
1:5107349:         // 2) The authentication provider should have been set to NATIVE::LOCAL
1:5107349:         //
1:c5b9acb:         String[][]  legalUsers = new String[][] { { APPLE_USER }, { BANANA_USER } , { DBO } };
1:5107349:         assertResults
1:ae21afb:             (
1:5107349:              sysadminConn,
1:5107349:              "select username from sys.sysusers order by username",
1:5107349:              legalUsers,
1:5107349:              false
1:ae21afb:              );
1:c5b9acb:         String[][]  authenticationProvider = new String[][] { { "NATIVE::LOCAL" } };
1:5107349:         assertResults
1:c0399dc:             (
1:5107349:              sysadminConn,
1:5107349:              "values ( syscs_util.syscs_get_database_property( 'derby.authentication.provider' ) )",
1:5107349:              authenticationProvider,
1:5107349:              false
1:c0399dc:              );
1:c0399dc: 
1:c0399dc:         // there should be no need to explicitly set the sql authorization property
1:c0399dc:         String[][]  sqlAuthorization = new String[][] { { null } };
1:5107349:         assertResults
1:c0399dc:             (
1:5107349:              sysadminConn,
1:5107349:              "values ( syscs_util.syscs_get_database_property( 'derby.database.sqlAuthorization' ) )",
1:5107349:              sqlAuthorization,
1:5107349:              false
1:c0399dc:              );
1:c0399dc:         vetSQLAuthorizationOn();
1:5107349: 
1:5107349:         // Sanity-check that the creator of the credentials db is the DBO
1:5107349:         String[][]   dboName = new String[][] { { DBO } };
1:5107349:         assertResults
5:5107349:             (
1:5107349:              sysadminConn,
1:5107349:              "select authorizationID from sys.sysschemas where schemaName = 'SYS'",
1:5107349:              dboName,
1:5107349:              false
4:5107349:              );
1:5107349: 
1:c5b9acb:         // verify password hashing
1:c5b9acb:         if ( _localAuthentication )
1:c5b9acb:         {
1:c5b9acb:             passwordHashingTests( sysadminConn );
1:c5b9acb:         }
1:c5b9acb: 
1:5107349:         // Databases can't be created by users who don't have credentials stored in the credentials database
1:c0399dc:         Connection  thirdDBConn = getConnection
1:92a2169:             ( _nativeAuthentication, true, THIRD_DB, WALNUT_USER, INVALID_AUTHENTICATION );
1:5107349: 
1:5107349:         // Now let the other valid user create a database
1:5107349:         if ( secondDBConn == null )
1:5107349:         {
1:92a2169:             secondDBConn = getConnection( false, true, SECOND_DB, APPLE_USER, null );
1:92a2169:         }
1:5107349: 
1:5107349:         // verify that the other valid user is the dbo in the database he just created
1:5107349:         assertResults
1:5107349:             (
1:5107349:              secondDBConn,
1:5107349:              "select authorizationID from sys.sysschemas where schemaName = 'SYS'",
1:5107349:              new String[][] { { APPLE_USER } },
1:5107349:              false
1:5107349:              );
1:5107349: 
1:5107349:         // NATIVE authentication turns on SQL authorization in the second database
1:5107349:         assertResults
1:5107349:             (
1:5107349:              secondDBConn,
1:5107349:              "values ( syscs_util.syscs_get_database_property( 'derby.database.sqlAuthorization' ) )",
1:5107349:              sqlAuthorization,
1:5107349:              false
1:5107349:              );
1:5107349: 
1:5107349:         //
1:5107349:         // If LOCAL authentication was specified...
1:5107349:         //
1:5107349:         // 1) It will be turned on in the second database too.
1:5107349:         // 2) The other legal user's credentials (as the database dbo) will be stored.
1:5107349:         //
1:5107349:         authenticationProvider = _localAuthentication ? new String[][] { { "NATIVE::LOCAL" } } : new String[][] { { null } };
1:5107349:         assertResults
1:5107349:             (
1:5107349:              secondDBConn,
1:5107349:              "values ( syscs_util.syscs_get_database_property( 'derby.authentication.provider' ) )",
1:5107349:              authenticationProvider,
1:5107349:              false
1:5107349:              );
1:5107349:         legalUsers = _localAuthentication ? new String[][] { { APPLE_USER } } : new String[][] {};
1:5107349:         assertResults
1:5107349:             (
1:5107349:              secondDBConn,
1:5107349:              "select username from sys.sysusers order by username",
1:5107349:              legalUsers,
1:5107349:              false
1:5107349:              );
1:5107349: 
1:a3d7a74:         ///////////////////////////////////////////////////////////////////////////////////
1:5107349:         //
1:a3d7a74:         // You can't turn off authentication or SQL authorization when NATIVE authentication
1:a3d7a74:         // is set in the database. If NATIVE authentication is set at the system level,
1:a3d7a74:         // you can still override it with database only properties.
1:a3d7a74:         //
1:a3d7a74:         ///////////////////////////////////////////////////////////////////////////////////
1:a3d7a74: 
1:47f286f:         Connection  seventhDBOConn = openConnection( SEVENTH_DB, DBO, true, null );
1:a3d7a74: 
1:c5b9acb:         if ( _localAuthentication) { addUser( seventhDBOConn, APPLE_USER ); }
1:a3d7a74:         goodStatement( seventhDBOConn, "create table t1( a int )" );
1:a3d7a74:         goodStatement( seventhDBOConn, "insert into t1( a ) values ( 10 )" );
1:a3d7a74: 
1:a3d7a74:         // at this point, you can't even force SQL authorization off on disk
1:a3d7a74:         setDatabaseProperty
1:a3d7a74:             ( _nativeAuthentication, seventhDBOConn, "derby.database.sqlAuthorization", "false", BAD_PROPERTY_CHANGE );
1:a3d7a74: 
1:a3d7a74:         // you can change these properties, but the change will be overridden by NATIVE authentication
1:a3d7a74:         goodStatement
1:a3d7a74:             ( seventhDBOConn, "call syscs_util.syscs_set_database_property( 'derby.connection.requireAuthentication', 'false' )" );
1:a3d7a74:         goodStatement
1:a3d7a74:             ( seventhDBOConn, "call syscs_util.syscs_set_database_property( 'derby.database.propertiesOnly', 'true' )" );
1:a3d7a74: 
1:a3d7a74:         //  now bring down the database so that the new property settings take effect
1:a3d7a74:         _seventhDBSetup.getTestConfiguration().shutdownDatabase();
1:a3d7a74: 
1:a3d7a74:         // if NATIVE authentication is set in the database, then sql authorization prevents this legal user from viewing private data
1:47f286f:         Connection  seventhAppleConn = openConnection( SEVENTH_DB, APPLE_USER, true, null );
1:a3d7a74:         vetStatement( _localAuthentication, seventhAppleConn, "select * from " + DBO + ".t1", NO_COLUMN_PERMISSION );
1:a3d7a74: 
1:a3d7a74:         // if NATIVE authentication is set in the database, then authentication still prevents this user from logging in
1:a3d7a74:         Connection  seventhWalnutConn = getConnection
1:92a2169:             ( _localAuthentication, true, SEVENTH_DB, WALNUT_USER, INVALID_AUTHENTICATION );
1:a3d7a74:         
1:a3d7a74:         ///////////////////////////////////////////////////////////////////////////////////
1:a3d7a74:         //
1:a3d7a74:         // Using database only properties, you can override system-specified NATIVE
1:a3d7a74:         // authentication as long as the NATIVE authentication is not LOCAL, i.e., not set
1:a3d7a74:         // at the database level.
1:a3d7a74:         //
1:a3d7a74:         ///////////////////////////////////////////////////////////////////////////////////
1:a3d7a74: 
1:47f286f:         Connection  eighthDBOConn = openConnection( EIGHTH_DB, DBO, true, null );
1:a3d7a74: 
1:a3d7a74:         // create BUILTIN credentials and set BULTIN authentication via database only properties
1:a3d7a74:         setDatabaseProperty
1:a3d7a74:             ( _localAuthentication, eighthDBOConn, "derby.authentication.provider", "BUILTIN", INVALID_PROVIDER_CHANGE );
1:a3d7a74:         setDatabaseProperty( false, eighthDBOConn, "derby.connection.requireAuthentication", "true", null );
1:a3d7a74:         setDatabaseProperty( false, eighthDBOConn, "derby.database.propertiesOnly", "true", null );
1:a3d7a74:         addBuiltinUser( eighthDBOConn, DBO );
1:a3d7a74:         addBuiltinUser( eighthDBOConn, BUILTIN_USER );
1:a3d7a74: 
1:a3d7a74:         //  now bring down the database so that the new property settings take effect
1:a3d7a74:         _eighthDBSetup.getTestConfiguration().shutdownDatabase();
1:a3d7a74: 
1:a3d7a74:         // succeeds unless LOCAL authentication overrides database-specified BUILTIN authentication
1:a3d7a74:         Connection  builtinConn = getConnection
1:92a2169:             ( _localAuthentication, true, EIGHTH_DB, BUILTIN_USER, INVALID_AUTHENTICATION );
1:92a2169: 
1:92a2169:         ///////////////////////////////////////////////////////////////////////////////////
1:92a2169:         //
1:4a08a15:         // Vet databases accessed via subprotocols.
1:92a2169:         //
1:92a2169:         ///////////////////////////////////////////////////////////////////////////////////
1:92a2169: 
1:4a08a15:         if (enableSubprotocolTests())
1:92a2169:         {
1:92a2169:             // database accessed via jar subprotocol
1:47f286f:             vetProtocol( jarDBName( _credentialsDBLocation ) );
1:92a2169:         
1:9f1b314:             // database accessed via classpath subprotocol
1:9f1b314:             vetProtocol( classpathDBName() );
1:92a2169:         }
1:92a2169:         
1:5107349:         ///////////////////////////////////////////////////////////////////////////////////
1:92a2169:         //
1:3b95c63:         // Verify that the DBO can grant and revoke execute privilege on the NATIVE procedures.
1:3b95c63:         //
1:3b95c63:         ///////////////////////////////////////////////////////////////////////////////////
1:3b95c63: 
1:47f286f:         Connection  twelthDBOConn = openConnection( TWELTH_DB, DBO, true, null );
1:3b95c63: 
1:c5b9acb:         if ( _localAuthentication ) { addUser( twelthDBOConn, APPLE_USER ); }
1:3b95c63: 
1:47f286f:         Connection  twelthAppleConn = openConnection( TWELTH_DB, APPLE_USER, true, null );
1:3b95c63: 
1:3b95c63:         // these fail without the appropriate grant
1:c5b9acb:         if ( _localAuthentication )
1:c5b9acb:         {
1:c5b9acb:             vetStatement( _nativeAuthentication, twelthAppleConn,
1:c5b9acb:                           "call syscs_util.syscs_create_user( 'JULIUS', 'juliuspassword' )", NO_EXECUTE_PERMISSION );
1:c5b9acb:             vetStatement( _nativeAuthentication, twelthAppleConn,
1:c5b9acb:                           "call syscs_util.syscs_reset_password( 'JULIUS', 'foopassword' )", NO_EXECUTE_PERMISSION );
1:c5b9acb:             vetStatement( _nativeAuthentication, twelthAppleConn,
1:c5b9acb:                           "call syscs_util.syscs_drop_user( 'JULIUS' )", NO_EXECUTE_PERMISSION );
1:c5b9acb:         }
1:3b95c63: 
1:3b95c63:         // but you always have permission to change your own password
1:c5b9acb:         vetStatement( !_localAuthentication, twelthAppleConn,
1:c5b9acb:                       "call syscs_util.syscs_modify_password( 'foo' )", MISSING_USER );
1:3b95c63: 
1:3b95c63:         // grant execute permission and retry the test
1:3b95c63:         vetStatement
1:3b95c63:             ( !_nativeAuthentication, twelthDBOConn,
1:3b95c63:               "grant execute on procedure syscs_util.syscs_create_user to " + APPLE_USER, SQL_AUTHORIZATION_NOT_ON );
1:3b95c63:         vetStatement
1:3b95c63:             ( !_nativeAuthentication, twelthDBOConn,
1:3b95c63:               "grant execute on procedure syscs_util.syscs_reset_password to " + APPLE_USER, SQL_AUTHORIZATION_NOT_ON );
1:3b95c63:         vetStatement
1:3b95c63:             ( !_nativeAuthentication, twelthDBOConn,
1:3b95c63:               "grant execute on procedure syscs_util.syscs_drop_user to " + APPLE_USER, SQL_AUTHORIZATION_NOT_ON );
1:c5b9acb: 
1:c5b9acb:         if ( _localAuthentication )
1:c5b9acb:         {
1:c5b9acb:             goodStatement( twelthAppleConn, "call syscs_util.syscs_create_user( 'HORACE', 'horacepassword' )" );
1:c5b9acb:             goodStatement( twelthAppleConn, "call syscs_util.syscs_reset_password( 'HORACE', 'foopassword' )" );
1:c5b9acb:             goodStatement( twelthAppleConn, "call syscs_util.syscs_drop_user( 'HORACE' )" );
1:c5b9acb:         }
1:3b95c63: 
1:3b95c63:         // revoke execute permission and retry the test
1:3b95c63:         vetStatement
1:3b95c63:             ( !_nativeAuthentication, twelthDBOConn,
1:3b95c63:               "revoke execute on procedure syscs_util.syscs_create_user from " + APPLE_USER + " restrict",
1:3b95c63:               SQL_AUTHORIZATION_NOT_ON );
1:3b95c63:         vetStatement
1:3b95c63:             ( !_nativeAuthentication, twelthDBOConn,
1:3b95c63:               "revoke execute on procedure syscs_util.syscs_reset_password from " + APPLE_USER  + " restrict",
1:3b95c63:               SQL_AUTHORIZATION_NOT_ON );
1:3b95c63:         vetStatement
1:3b95c63:             ( !_nativeAuthentication, twelthDBOConn,
1:3b95c63:               "revoke execute on procedure syscs_util.syscs_drop_user from " + APPLE_USER  + " restrict",
1:3b95c63:               SQL_AUTHORIZATION_NOT_ON );
1:c5b9acb: 
1:c5b9acb:         if ( _localAuthentication )
1:c5b9acb:         {
1:c5b9acb:             vetStatement( _nativeAuthentication, twelthAppleConn,
1:c5b9acb:                           "call syscs_util.syscs_create_user( 'CORNELIA', 'corneliapassword' )", NO_EXECUTE_PERMISSION );
1:c5b9acb:             vetStatement( _nativeAuthentication, twelthAppleConn,
1:c5b9acb:                           "call syscs_util.syscs_reset_password( 'CORNELIA', 'foopassword' )", NO_EXECUTE_PERMISSION );
1:c5b9acb:             vetStatement( _nativeAuthentication, twelthAppleConn,
1:c5b9acb:                           "call syscs_util.syscs_drop_user( 'CORNELIA' )", NO_EXECUTE_PERMISSION );
1:c5b9acb:         }
1:92a2169:     }
1:47f286f:     private static  String  jarDBName( int credentialsDBLocation ) throws Exception
1:92a2169:     {
1:47f286f:         String  dbName = (credentialsDBLocation == JAR_ENCRYPTED) ? "nastEncrypted" : "nast";
1:47f286f:         
1:47f286f:         return "jar:(" + SupportFilesSetup.getReadOnlyFileName( NAST1_JAR_FILE  ) + ")" + dbName;
1:a3d7a74:     }
1:ae21afb:     private static  String  classpathDBName()   { return "classpath:nast"; }
1:10f4b0f: 
1:10f4b0f:     private void    vetEmptyCredentials()   throws Exception
1:10f4b0f:     {
1:10f4b0f:         vetEmptyCredentials( null, null );
1:10f4b0f:         vetEmptyCredentials( "", null );
1:10f4b0f:         vetEmptyCredentials( null, "" );
1:10f4b0f:         vetEmptyCredentials( "", "" );
1:10f4b0f: 
1:10f4b0f:         vetEmptyCredentials( "foo", null );
1:10f4b0f:         vetEmptyCredentials( "foo", "" );
1:10f4b0f: 
1:10f4b0f:         if ( isEmbedded() ) { vetEmptyCredentials( null, "bar" ); } // the network server fabricates a username of APP
1:10f4b0f:         vetEmptyCredentials( "", "bar" );
1:10f4b0f:     }
1:10f4b0f:     private void    vetEmptyCredentials( String user, String password ) throws Exception
1:10f4b0f:     {
1:10f4b0f:         String[]  expectedSQLStates = new String[] { INVALID_AUTHENTICATION,BAD_NETWORK_AUTHENTICATION };
1:10f4b0f:         
1:10f4b0f:         getConnection( true, true, CREDENTIALS_DB, user, password, expectedSQLStates );
1:10f4b0f:     }
1:3b95c63:     
1:a3d7a74:     private void    addBuiltinUser( Connection conn, String user )  throws Exception
1:a3d7a74:     {
1:a3d7a74:         String  key = "derby.user." + user;
1:a3d7a74:         String  value = getPassword( user );
1:a3d7a74:         
1:a3d7a74:         setDatabaseProperty( false, conn, key, value, null );
1:5107349:     }
1:a3d7a74: 
1:5107349:     /**
1:5107349:      * <p>
1:92a2169:      * Verify that databases in jar files and on the classpath can be opened
1:92a2169:      * and respect NATIVE/LOCAL settings.
1:92a2169:      * </p>
1:92a2169:      */
1:92a2169:     private void    vetProtocol( String protocolDBName ) throws Exception
1:92a2169:     {
1:92a2169:         ///////////////////////////////////////////////////////////////////////////////////
1:92a2169:         //
1:92a2169:         // Verify that regardless of any other settings, NATIVE authentication is on in the
1:92a2169:         // database stored in a jar file or accessed over the classpath
1:92a2169:         //
1:92a2169:         ///////////////////////////////////////////////////////////////////////////////////
1:92a2169: 
1:92a2169:         Connection  grapeConn = getConnection( false, false, protocolDBName, GRAPE_USER, null );
1:92a2169: 
1:92a2169:         vetStatement( true, grapeConn, "select * from " + DBO + ".t", NO_COLUMN_PERMISSION );
1:92a2169:         
1:92a2169:         getConnection( true, false, protocolDBName, WALNUT_USER, INVALID_AUTHENTICATION );
1:92a2169:     }
1:92a2169: 
1:92a2169:     /**
1:92a2169:      * <p>
1:5ea170f:      * Verify the casing behavior of user identifiers.
1:5ea170f:      * </p>
1:5ea170f:      */
1:5ea170f:     private void    vetCasing()   throws Exception
1:5ea170f:     {
1:5ea170f:         // only run this if we are using NATIVE authentication and the DBO's creds are already
1:5ea170f:         // in the credentials DB. this is just to make sure that we are in a database where
1:5ea170f:         // the DBO's creds already exist.
1:5ea170f:         if ( !_nativeAuthentication ) { return; }
1:5ea170f:         if ( _localAuthentication ) { return; }
1:5ea170f: 
1:5ea170f:         String  originalPricklyPearPassword = "prickly_pear_password";
1:5ea170f:         
1:5ea170f:         // connect to the credentials database
1:5ea170f:         Connection  dboConn = openConnection( CREDENTIALS_DB, DBO, true, null );
1:5ea170f: 
1:5ea170f:         // can't add redundant credentials for an authorization id by changing the casing
1:5ea170f:         addUser( dboConn, CAMEL_CASE_DBO, USER_ALREADY_EXISTS );
1:5ea170f: 
1:5ea170f:         // using double-quotes, however, you can create a camel-case user name
1:5ea170f:         addUser( dboConn, PEAR_USER, null );
1:5ea170f:         assertFalse( PEAR_USER.equals( PRICKLY_PEAR_USER ) );
1:5ea170f:         assertTrue( PEAR_USER.toUpperCase().equals( PRICKLY_PEAR_USER.toUpperCase() ) );
1:5ea170f:         goodStatement
1:5ea170f:             (
1:5ea170f:              dboConn,
1:5ea170f:              "call syscs_util.syscs_create_user( '\"" + PRICKLY_PEAR_USER + "\"', '" + originalPricklyPearPassword + "' )"
1:5ea170f:              );
1:5ea170f:         String[][]  legalUsers = new String[][] { { PEAR_USER }, { PRICKLY_PEAR_USER } };
1:5ea170f:         assertResults
1:5ea170f:             (
1:5ea170f:              dboConn,
1:5ea170f:              "select username from sys.sysusers where username like 'P%' order by username",
1:5ea170f:              legalUsers,
1:5ea170f:              false
1:5ea170f:              );
1:5ea170f: 
1:5ea170f:         // schema name for an unquoted user name should be upper case
1:5ea170f:         Connection  pearConn = openConnection( CREDENTIALS_DB, PEAR_USER, true, null );
1:5ea170f:         assertResults
1:5ea170f:             (
1:5ea170f:              pearConn,
1:5ea170f:              "values current schema",
1:5ea170f:              new String[][] { { PEAR_USER.toUpperCase() } },
1:5ea170f:              false
1:5ea170f:              );
1:5ea170f: 
1:5ea170f:         // schema name for a quoted user name should be camel case
1:5ea170f:         Connection  pricklyPearConn = openConnection
1:5ea170f:             ( CREDENTIALS_DB, doubleQuote( PRICKLY_PEAR_USER ), originalPricklyPearPassword, true, null );
1:5ea170f:         assertResults
1:5ea170f:             (
1:5ea170f:              pricklyPearConn,
1:5ea170f:              "values current schema",
1:5ea170f:              new String[][] { { PRICKLY_PEAR_USER } },
1:5ea170f:              false
1:5ea170f:              );
1:5ea170f: 
1:5ea170f:         //
1:5ea170f:         // Verify the casing on the USERNAME argument to the NATIVE procedures
1:5ea170f:         //
1:5ea170f: 
1:5ea170f:         // modify password
1:5ea170f:         String  rev2_password = "password_rev2";
1:5ea170f:         goodStatement
1:5ea170f:             (
1:5ea170f:              pricklyPearConn,
1:5ea170f:              "call syscs_util.syscs_modify_password( '" + rev2_password + "' )"
1:5ea170f:              );
1:5ea170f:         getConnection
1:5ea170f:             ( true, true, CREDENTIALS_DB, doubleQuote( PRICKLY_PEAR_USER ), originalPricklyPearPassword, INVALID_AUTHENTICATION );
1:5ea170f:         pricklyPearConn = openConnection
1:5ea170f:             ( CREDENTIALS_DB, doubleQuote( PRICKLY_PEAR_USER ), rev2_password, true, null );
1:5ea170f: 
1:5ea170f:         // reset password
1:5ea170f:         String rev3_password = "password_rev3";
1:5ea170f:         goodStatement
1:5ea170f:             (
1:5ea170f:              dboConn,
1:5ea170f:              "call syscs_util.syscs_reset_password( '" + doubleQuote( PRICKLY_PEAR_USER ) + "', '" + rev3_password + "' )"
1:5ea170f:              );
1:5ea170f:         getConnection
1:5ea170f:             ( true, true, CREDENTIALS_DB, doubleQuote( PRICKLY_PEAR_USER ), rev2_password, INVALID_AUTHENTICATION );
1:5ea170f:         pricklyPearConn = openConnection
1:5ea170f:             ( CREDENTIALS_DB, doubleQuote( PRICKLY_PEAR_USER ), rev3_password, true, null );
1:5ea170f: 
1:5ea170f:         // drop user
1:5ea170f:         int     userCount = countUsers( dboConn );
1:5ea170f:         goodStatement
1:5ea170f:             (
1:5ea170f:              dboConn,
1:5ea170f:              "call syscs_util.syscs_drop_user( '" + doubleQuote( PRICKLY_PEAR_USER ) + "' )"
1:5ea170f:              );
1:5ea170f:         assertEquals( userCount - 1, countUsers( dboConn ) );
1:5ea170f:         getConnection
1:5ea170f:             ( true, true, CREDENTIALS_DB, doubleQuote( PRICKLY_PEAR_USER ), rev3_password, INVALID_AUTHENTICATION );
1:5ea170f:     }
1:5ea170f:     private String  doubleQuote( String raw ) { return "\"" + raw + "\""; }
1:5ea170f:     private int countUsers( Connection conn ) throws Exception
1:5ea170f:     {
1:5ea170f:         PreparedStatement   ps = chattyPrepare( conn, "select count(*) from sys.sysusers" );
1:5ea170f:         ResultSet   rs = ps.executeQuery();
1:5ea170f: 
1:5ea170f:         rs.next();
1:5ea170f: 
1:5ea170f:         try { return rs.getInt( 1 ); }
1:5ea170f:         finally
1:5ea170f:         {
1:5ea170f:             rs.close();
1:5ea170f:             ps.close();
1:5ea170f:         }
1:5ea170f:     }
1:5ea170f: 
1:5ea170f:     /**
1:5ea170f:      * <p>
1:dc9cd0f:      * The vetCoreBehavior() method verifies credentials-checking for the
1:dc9cd0f:      * following system-wide operations:
1:dc9cd0f:      * </p>
1:dc9cd0f:      *
1:dc9cd0f:      * <ul>
1:dc9cd0f:      * <li>Database creation.</li>
1:dc9cd0f:      * <li>Engine shutdown.</li>
1:dc9cd0f:      * <li>Server shutdown. The default credentials are embedded inside the NetworkServerControl
1:dc9cd0f:      * created by NetworkServerTestSetup.</li>
1:dc9cd0f:      * </ul>
1:dc9cd0f:      *
1:dc9cd0f:      * <p>
1:dc9cd0f:      * This method verifies credentials-checking for this additional
1:dc9cd0f:      * system-wide operation:
1:dc9cd0f:      * </p>
1:dc9cd0f:      *
1:dc9cd0f:      * <ul>
1:dc9cd0f:      * <li>Database restoration.</li>
1:dc9cd0f:      * </ul>
1:dc9cd0f:      */
1:dc9cd0f:     private void    vetSystemWideOperations()   throws Exception
1:dc9cd0f:     {
1:dc9cd0f:         // create a database which we will backup and restore
1:47f286f:         Connection  dboConn = openConnection( SIXTH_DB, DBO, true, null );
1:dc9cd0f: 
1:dc9cd0f:         // add another user who can perform restores successfully
1:c5b9acb:         if ( _localAuthentication ) { addUser( dboConn, BANANA_USER ); }
1:dc9cd0f: 
1:dc9cd0f:         // add a table which we will backup and then drain. this is so that later on we can
1:dc9cd0f:         // verify that we really restored the database rather than just reconnected to the
1:dc9cd0f:         // original version.
1:dc9cd0f:         goodStatement( dboConn, "create table t( a int )" );
1:dc9cd0f:         goodStatement( dboConn, "insert into t( a ) values ( 1000 )" );
1:dc9cd0f:         if ( _nativeAuthentication)
1:dc9cd0f:         {
1:dc9cd0f:             goodStatement( dboConn, "grant select on table t to public" );
1:dc9cd0f:             goodStatement( dboConn, "grant insert on table t to public" );
1:dc9cd0f:         }
1:dc9cd0f:         goodStatement( dboConn, "call syscs_util.syscs_backup_database( '" + _fullBackupDir + "' )" );
1:dc9cd0f:         goodStatement( dboConn, "delete from t" );
1:dc9cd0f: 
1:dc9cd0f:         // this user is valid both in the system-wide credentials db and in the local db
1:dc9cd0f:         shutdownAndRestoreDB( true, BANANA_USER, null );
1:dc9cd0f: 
1:dc9cd0f:         //
1:dc9cd0f:         // If we are doing local authentication, then restoration will fail when we use
1:dc9cd0f:         // the credentials of a user who is in the system-wide SYSUSERS but not
1:dc9cd0f:         // in the SYSUSERS of the database being restored. Restoration involves two
1:dc9cd0f:         // authentication attempts: First we authenticate system-wide in order to
1:dc9cd0f:         // verify that it's ok to proceed with the restoration. After that, we attempt
1:dc9cd0f:         // to connect to the restored database. It is the authentication of the second
1:dc9cd0f:         // attempt which may fail here.
1:dc9cd0f:         //
1:dc9cd0f:         shutdownAndRestoreDB( !_localAuthentication, APPLE_USER, INVALID_AUTHENTICATION );
1:dc9cd0f:         
1:dc9cd0f:         // delete the backup directory
1:dc9cd0f:         assertDirectoryDeleted( new File( _fullBackupDir ) );
1:dc9cd0f:     }
1:dc9cd0f:     private void    shutdownAndRestoreDB( boolean shouldSucceed, String user, String expectedSQLState ) throws Exception
1:dc9cd0f:     {
1:dc9cd0f:         // shutdown the database. the restore will overwrite it.
1:dc9cd0f:         _sixthDBSetup.getTestConfiguration().shutdownDatabase();
1:dc9cd0f: 
1:dc9cd0f:         // the physical database name has some parent directories in it.
1:dc9cd0f:         // we need to strip these off because backup ignores them.
1:dc9cd0f:         String      dbName = _sixthDBSetup.physicalDatabaseName();
1:dc9cd0f:         int         slashIdx = dbName.lastIndexOf( "/" );
1:dc9cd0f:         if ( slashIdx >= 0 ) { dbName = dbName.substring( slashIdx + 1 ); }
1:dc9cd0f: 
1:dc9cd0f:         DataSource  ds = JDBCDataSource.getDataSourceLogical( SIXTH_DB );
1:dc9cd0f:         String          fullRestoreDir = _fullBackupDir + "/" + dbName;
1:dc9cd0f:         JDBCDataSource.setBeanProperty( ds, "connectionAttributes", "restoreFrom=" + fullRestoreDir );
1:dc9cd0f: 
1:dc9cd0f:         Connection  conn = null;
1:dc9cd0f: 
1:92a2169:         try {
1:dc9cd0f:             conn = ds.getConnection( user, getPassword( user ) );
1:dc9cd0f: 
1:dc9cd0f:             if ( !shouldSucceed ) { fail( tagError( "Database restoration should have failed." ) ); }
1:dc9cd0f:         }
1:dc9cd0f:         catch (SQLException se)
1:dc9cd0f:         {
1:dc9cd0f:             if ( shouldSucceed ) { fail( tagError( "Database restoration unexpectedly failed." ) );}
1:dc9cd0f:             else    { assertSQLState( expectedSQLState, se ); }
1:dc9cd0f:         }
1:dc9cd0f: 
1:dc9cd0f:         if ( conn != null )
1:dc9cd0f:         {
1:dc9cd0f:             // verify that this is the version which was backed up, not the original
1:dc9cd0f:             assertResults
1:dc9cd0f:                 (
1:dc9cd0f:                  conn,
1:dc9cd0f:                  "select a from " + DBO + ".t",
1:dc9cd0f:                  new String[][] { { "1000" } },
1:dc9cd0f:                  false
1:dc9cd0f:                  );
1:dc9cd0f: 
1:dc9cd0f:             // add another tuple to distinguish the database from later attempts
1:dc9cd0f:             // to re-initialize it from the backup
1:dc9cd0f:             goodStatement( conn, "insert into " + DBO + ".t( a ) values ( 2000 )" );
1:dc9cd0f:         }
1:dc9cd0f:     }
1:dc9cd0f:     
1:dc9cd0f:     /**
1:dc9cd0f:      * <p>
1:49901a4:      * Try changing the value of the provider property on disk.
1:c0399dc:      * These tests are run only if authentication is turned off.
1:c0399dc:      * </p>
1:c0399dc:      */
1:49901a4:     private void    vetProviderChanges()   throws Exception
1:c0399dc:     {
1:c0399dc:         // create an empty database without authentication turned on
1:c0399dc:         String          dbo = ORANGE_USER;
1:47f286f:         Connection  dboConn = openConnection( FOURTH_DB, dbo, true, null );
1:c0399dc: 
1:c0399dc:         // NATIVE authentication isn't on, so you can store oddball values for the authentication provider
1:c0399dc:         goodStatement
1:c0399dc:             ( dboConn, "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'com.acme.AcmeAuthenticator' )" );
1:c0399dc: 
1:c0399dc:         // can't turn on NATIVE authentication until you have stored credentials for the dbo
3:c0399dc:         expectExecutionError
1:c0399dc:             (
3:c0399dc:              dboConn, INVALID_PROVIDER_CHANGE,
1:c0399dc:              "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'NATIVE::LOCAL' )"
1:c0399dc:              );
1:c0399dc:  
1:c5b9acb:         // NATIVE::LOCAL is the only legal value which the authentication provider property can take on disk
1:c5b9acb:         expectExecutionError
1:c5b9acb:             (
1:c5b9acb:              dboConn, INVALID_PROVIDER_CHANGE,
1:c5b9acb:              "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'NATIVE:db:LOCAL' )"
1:c5b9acb:              );
1:c5b9acb:         expectExecutionError
1:c5b9acb:             (
1:c5b9acb:              dboConn, INVALID_PROVIDER_CHANGE,
1:c5b9acb:              "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'NATIVE:LOCAL' )"
1:c5b9acb:              );
1:c5b9acb:  
1:c0399dc:         // store credentials for the DBO
1:c0399dc:         addUser( dboConn, dbo );
1:c0399dc: 
1:c5b9acb:         addUser( dboConn, PEAR_USER );
1:c5b9acb: 
1:c0399dc:         // verify that you can't drop the dbo
1:c0399dc:         expectExecutionError
1:c0399dc:             (
1:c0399dc:              dboConn, CANT_DROP_DBO,
1:c0399dc:              "call syscs_util.syscs_drop_user( '" + dbo + "' )"
1:c0399dc:              );
1:c0399dc:         String[][]  legalUsers = new String[][] { { dbo }, { PEAR_USER } };
1:c0399dc:         assertResults
1:c0399dc:             (
1:c0399dc:              dboConn,
1:c0399dc:              "select username from sys.sysusers order by username",
1:c0399dc:              legalUsers,
1:c0399dc:              false
1:c0399dc:              );
1:c0399dc:         
1:c5b9acb:         // creating the DBO turned on NATIVE + LOCAL
1:c0399dc:         // once set, you can't unset or change it
1:c0399dc:         expectExecutionError
1:c0399dc:             (
1:c0399dc:              dboConn, INVALID_PROVIDER_CHANGE,
1:c0399dc:              "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'NATIVE::LOCAL' )"
1:c0399dc:              );
1:c0399dc:         expectExecutionError
1:c0399dc:             (
1:c0399dc:              dboConn, INVALID_PROVIDER_CHANGE,
1:c0399dc:              "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', null )"
1:c0399dc:              );
1:c0399dc:         expectExecutionError
1:c0399dc:             (
1:c0399dc:              dboConn, INVALID_PROVIDER_CHANGE,
1:c0399dc:              "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'com.acme.AcmeAuthenticator' )"
1:c0399dc:              );
1:c0399dc: 
1:c0399dc:         // verify that the authentication provider property has the value we expect
1:c0399dc:         String[][]  authenticationProvider = new String[][] { { "NATIVE::LOCAL" } };
1:c0399dc:         assertResults
1:c0399dc:             (
1:c0399dc:              dboConn,
1:c0399dc:              "values ( syscs_util.syscs_get_database_property( 'derby.authentication.provider' ) )",
1:c0399dc:              authenticationProvider,
1:c0399dc:              false
1:c0399dc:              );
1:c0399dc:         
1:c0399dc:         // create a table for a simple authorization check later on
1:c0399dc:         goodStatement( dboConn, "create table t( a int )" );
1:c0399dc: 
1:c0399dc:         // shutdown this database so that the on-disk properties will take effect on reboot
1:c0399dc:         _fourthDBSetup.getTestConfiguration().shutdownDatabase();
1:c0399dc:         
1:c0399dc:         // can't connect to the database with credentials which aren't stored in it.
1:92a2169:         Connection  appleConn = getConnection( true, true, FOURTH_DB, APPLE_USER, INVALID_AUTHENTICATION );
1:c0399dc: 
1:c0399dc:         // ...but these credentials work
1:47f286f:         Connection  pearConn = openConnection( FOURTH_DB, PEAR_USER, true, null );
1:c0399dc: 
1:c0399dc:         // should get authorization errors trying to select from a table private to the DBO
1:c0399dc:         // and from trying to view the credentials table
1:c0399dc:         expectExecutionError( pearConn, NO_COLUMN_PERMISSION, "select * from " + dbo + ".t" );
1:c0399dc:         expectCompilationError( pearConn, DBO_ONLY_OPERATION, "select username from sys.sysusers" );
1:33605bd: 
1:33605bd:         // verify a sensible error if you try to set the authentication provider
1:33605bd:         // to the missing classname NATIVE. we only check this for the embedded
1:33605bd:         // case because the network scrunches exceptions together and we lose
1:33605bd:         // the structure which allows us to look for nested SQLStates.
1:33605bd:         if ( isEmbedded() )
1:33605bd:         {
1:33605bd:             Connection  fifteenthConn = openConnection( FIFTEENTH_DB, dbo, true, null );
1:c0399dc:         
1:33605bd:             goodStatement
1:33605bd:                 ( fifteenthConn, "call syscs_util.syscs_set_database_property( 'derby.connection.requireAuthentication', 'true' )" );
1:33605bd:             goodStatement
1:33605bd:                 ( fifteenthConn, "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'NATIVE' )" );
1:33605bd:             _fifteenthDBSetup.getTestConfiguration().shutdownDatabase();
1:33605bd: 
1:33605bd:             getConnection( true, true, FIFTEENTH_DB, DBO, BAD_USER_AUTHENTICATOR_CLASS );
1:33605bd:         }
1:c0399dc:     }
1:c0399dc:     
1:5107349:     /**
1:5107349:      * <p>
1:49901a4:      * Verify that password lifetimes are checked.
1:49901a4:      * </p>
1:49901a4:      */
1:49901a4:     private void    vetPasswordLifetime()   throws Exception
1:49901a4:     {
1:49901a4:         // create another database
1:47f286f:         Connection  dboConn = openConnection( FIFTH_DB, DBO, true, null );
1:49901a4: 
1:49901a4:         // add another legal user
1:49901a4:         addUser( dboConn, APPLE_USER );
1:49901a4: 
1:49901a4:         Connection  appleConn = passwordExpiring( false, FIFTH_DB, APPLE_USER );
1:49901a4: 
1:49901a4:         // setup so that passwords are expiring after the db is rebooted.
1:49901a4:         // shutdown the database in this test so that the new property settings take effect.
1:49901a4:         goodStatement
1:49901a4:             ( dboConn, "call syscs_util.syscs_set_database_property( 'derby.authentication.native.passwordLifetimeMillis', '86400000' )" );
1:49901a4:         goodStatement
1:49901a4:             ( dboConn, "call syscs_util.syscs_set_database_property( 'derby.authentication.native.passwordLifetimeThreshold', '2.0' )" );
1:49901a4:         _fifthDBSetup.getTestConfiguration().shutdownDatabase();
1:49901a4:  
1:49901a4:         // password should be expiring
1:49901a4:         dboConn = passwordExpiring( true, FIFTH_DB, DBO );
1:49901a4:         appleConn = passwordExpiring( true, FIFTH_DB, APPLE_USER );
1:49901a4:         
1:49901a4:         // setup so that passwords have expired after we reboot the database.
1:49901a4:         // shutdown the database so that the new property settings take effect.
1:49901a4:         goodStatement
1:49901a4:             ( dboConn, "call syscs_util.syscs_set_database_property( 'derby.authentication.native.passwordLifetimeMillis', '1' )" );
1:49901a4:         _fifthDBSetup.getTestConfiguration().shutdownDatabase();
1:49901a4: 
1:49901a4:         // the DBO's password does not expire
1:47f286f:         dboConn = openConnection( FIFTH_DB, DBO, true, null );
1:49901a4: 
1:49901a4:         // but the other user's password has expired
1:92a2169:         appleConn = getConnection( true, true, FIFTH_DB, APPLE_USER, INVALID_AUTHENTICATION );
1:49901a4:         
1:49901a4:         // setup so that passwords don't expire after we reboot the database.
1:49901a4:         // shutdown the database so that the new property settings take effect.
1:49901a4:         goodStatement
1:49901a4:             ( dboConn, "call syscs_util.syscs_set_database_property( 'derby.authentication.native.passwordLifetimeMillis', '0' )" );
1:49901a4:         _fifthDBSetup.getTestConfiguration().shutdownDatabase();
1:49901a4: 
1:49901a4:         // passwords should NOT be expiring or expired
1:49901a4:         dboConn = passwordExpiring( false, FIFTH_DB, DBO );
1:49901a4:         appleConn = passwordExpiring( false, FIFTH_DB, APPLE_USER );
1:49901a4: 
1:49901a4:         // check that invalid property settings are caught
1:49901a4:         expectExecutionError
1:49901a4:             (
1:49901a4:              dboConn, BAD_PASSWORD_PROPERTY,
1:49901a4:              "call syscs_util.syscs_set_database_property( 'derby.authentication.native.passwordLifetimeMillis', 'rabbit' )"
1:49901a4:              );
1:49901a4:         expectExecutionError
1:49901a4:             (
1:49901a4:              dboConn, BAD_PASSWORD_PROPERTY,
1:49901a4:              "call syscs_util.syscs_set_database_property( 'derby.authentication.native.passwordLifetimeThreshold', '-1' )"
1:49901a4:              );
1:49901a4:     }
1:49901a4: 
1:c5b9acb:     private void    passwordHashingTests
1:c5b9acb:         ( Connection dboConnection )
1:c5b9acb:         throws Exception
1:c5b9acb:     {
1:c5b9acb:         // set a message digest algorithm in case it was unset by a previous test.
1:c5b9acb:         // a message digest algorithm must be set in order to use NATIVE authentication
1:c5b9acb:         String  originalDigestAlgorithm = getDatabaseProperty( dboConnection, "derby.authentication.builtin.algorithm" );
1:c5b9acb:         if ( originalDigestAlgorithm == null )
1:c5b9acb:         {
1:c5b9acb:             setDatabaseProperty( dboConnection, "derby.authentication.builtin.algorithm", "SHA-1" );
1:c5b9acb:         }
1:c5b9acb: 
1:c5b9acb:         String  defaultDigestAlgorithm = getDatabaseProperty( dboConnection, "derby.authentication.builtin.algorithm" );
1:c5b9acb: 
1:c5b9acb:         goodStatement( dboConnection, "call syscs_util.syscs_create_user( 'pht', 'phtpassword' )" );
1:c5b9acb: 
1:c5b9acb:         vetHashingScheme( dboConnection, "pht", HASHING_FORMAT_10_9, 16, 1000, defaultDigestAlgorithm );
1:c5b9acb: 
1:c5b9acb:         int saltLength = 5;
1:c5b9acb:         setDatabaseProperty( dboConnection, "derby.authentication.builtin.saltLength", Integer.toString( saltLength ) );
1:c5b9acb:         goodStatement( dboConnection, "call syscs_util.syscs_reset_password( 'pht', 'newsaltlength' )" );
1:c5b9acb:         vetHashingScheme( dboConnection, "pht", HASHING_FORMAT_10_9, saltLength, 1000, defaultDigestAlgorithm );
1:c5b9acb: 
1:c5b9acb:         int iterations = 10;
1:c5b9acb:         setDatabaseProperty( dboConnection, "derby.authentication.builtin.iterations", Integer.toString( iterations ) );
1:c5b9acb:         goodStatement( dboConnection, "call syscs_util.syscs_reset_password( 'pht', 'newiterations' )" );
1:c5b9acb:         vetHashingScheme( dboConnection, "pht", HASHING_FORMAT_10_9, saltLength, iterations, defaultDigestAlgorithm );
1:c5b9acb: 
1:c5b9acb:         String digestAlgorithm = "SHA-1";
1:c5b9acb:         setDatabaseProperty( dboConnection, "derby.authentication.builtin.algorithm", digestAlgorithm );
1:c5b9acb:         goodStatement( dboConnection, "call syscs_util.syscs_reset_password( 'pht', 'newiterations' )" );
1:c5b9acb:         vetHashingScheme( dboConnection, "pht", HASHING_FORMAT_10_9, saltLength, iterations, digestAlgorithm );
1:c5b9acb: 
1:c5b9acb:         setDatabaseProperty( dboConnection, "derby.authentication.builtin.algorithm", null );
1:c5b9acb:         expectExecutionError( dboConnection, WEAK_AUTHENTICATION, "call syscs_util.syscs_reset_password( 'pht', 'badalgorithm' )" );
1:c5b9acb: 
1:c5b9acb:         setDatabaseProperty( dboConnection, "derby.authentication.builtin.saltLength", null );
1:c5b9acb:         setDatabaseProperty( dboConnection, "derby.authentication.builtin.iterations", null );
1:c5b9acb:         setDatabaseProperty( dboConnection, "derby.authentication.builtin.algorithm", defaultDigestAlgorithm );
1:c5b9acb:         goodStatement( dboConnection, "call syscs_util.syscs_drop_user( 'pht' )" );
1:c5b9acb:         
1:c5b9acb:         // reset the message digest algorithm in order to not disrupt the existing tests
1:c5b9acb:         if ( originalDigestAlgorithm == null )
1:c5b9acb:         {
1:c5b9acb:             setDatabaseProperty( dboConnection, "derby.authentication.builtin.algorithm", null );
1:c5b9acb:         }
1:c5b9acb:     }
1:c5b9acb:     private void  setDatabaseProperty( Connection conn, String key, String value )
1:c5b9acb:         throws Exception
1:c5b9acb:     {
1:c5b9acb:         if ( value == null ) { value = "cast ( null as varchar( 32672 ) )"; }
1:c5b9acb:         else { value = "'" + value + "'"; }
1:c5b9acb:         String  command = "call syscs_util.syscs_set_database_property( '" + key + "', " + value + " )";
1:c5b9acb: 
1:c5b9acb:         goodStatement( conn, command );
1:c5b9acb:     }
1:c5b9acb:     private String  getDatabaseProperty( Connection conn, String key )
1:c5b9acb:         throws Exception
1:c5b9acb:     {
1:c5b9acb:         PreparedStatement   ps = chattyPrepare( conn, "values( syscs_util.syscs_get_database_property( '" + key + "' ) )" );
1:c5b9acb:         ResultSet   rs = ps.executeQuery();
1:c5b9acb: 
1:c5b9acb:         try {
1:c5b9acb:             rs.next();
1:c5b9acb:             return rs.getString( 1 );
1:c5b9acb:         }
1:c5b9acb:         finally
1:c5b9acb:         {
1:c5b9acb:             rs.close();
1:c5b9acb:             ps.close();
1:c5b9acb:         }
1:c5b9acb:     }
1:c5b9acb:     private void    vetHashingScheme
1:c5b9acb:         (
1:c5b9acb:          Connection conn,
1:c5b9acb:          String userName,
1:c5b9acb:          String expectedHashingFormat,
1:c5b9acb:          int expectedSaltLength,
1:c5b9acb:          int expectedIterations,
1:c5b9acb:          String expectedDigestAlgorithm
1:c5b9acb:          )
1:c5b9acb:         throws Exception
1:c5b9acb:     {
1:c5b9acb:         String  hashingScheme = getHashingScheme( conn,  userName );
1:c5b9acb:         int     firstColonPosition = hashingScheme.indexOf( ":" );
1:c5b9acb:         int     secondColonPosition = hashingScheme.indexOf( ":", firstColonPosition + 1 );
1:c5b9acb:         int     thirdColonPosition = hashingScheme.indexOf( ":", secondColonPosition + 1 );
1:c5b9acb: 
1:c5b9acb:         String  actualHashingFormat = hashingScheme.substring( 0, firstColonPosition );
1:c5b9acb:         String  salt = hashingScheme.substring( firstColonPosition + 1, secondColonPosition );
1:c5b9acb:         String  iterationString = hashingScheme.substring( secondColonPosition + 1, thirdColonPosition );
1:c5b9acb:         String  actualDigestAlgorithm = hashingScheme.substring( thirdColonPosition + 1 );
1:c5b9acb: 
1:c5b9acb:         int     actualSaltLength = salt.length();
1:c5b9acb:         int     actualIterations = Integer.parseInt( iterationString );
1:c5b9acb: 
1:c5b9acb:         assertEquals( expectedHashingFormat, actualHashingFormat );
1:c5b9acb:         assertEquals( expectedSaltLength * HEX_CHARS_PER_BYTE, actualSaltLength );
1:c5b9acb:         assertEquals( expectedIterations, actualIterations );
1:c5b9acb:         assertEquals( expectedDigestAlgorithm, actualDigestAlgorithm );
1:c5b9acb:     }
1:c5b9acb:     private String  getHashingScheme( Connection conn, String userName )
1:c5b9acb:         throws Exception
1:c5b9acb:     {
1:c5b9acb:         PreparedStatement   ps = conn.prepareStatement( "select userName, hashingScheme from sys.sysusers" );
1:c5b9acb:         ResultSet   rs = ps.executeQuery();
1:c5b9acb: 
1:5ea170f:         // normalize the user name
1:5ea170f:         userName = userName.toUpperCase();
1:5ea170f: 
1:c5b9acb:         try {
1:c5b9acb:             while ( rs.next() )
1:c5b9acb:             {
1:c5b9acb:                 if ( userName.equals( rs.getString( 1 )  ) ) { return rs.getString( 2 ); }
1:c5b9acb:             }
1:c5b9acb:         } finally
1:c5b9acb:         {
1:c5b9acb:             rs.close();
1:c5b9acb:             ps.close();
1:c5b9acb:         }
1:c5b9acb: 
1:c5b9acb:         fail( "Could not find credentials for " + userName );
1:c5b9acb: 
1:c5b9acb:         // never get here
1:c5b9acb:         return null;
1:c5b9acb:     }
1:c5b9acb: 
1:c0399dc:     private void    vetSQLAuthorizationOn() throws Exception
1:a3d7a74:     {
1:47f286f:         Connection  nonDBOConn = openConnection( CREDENTIALS_DB, APPLE_USER, true, null );
1:c0399dc:         String          query = "select username from sys.sysusers" ;
1:c0399dc: 
1:dc9cd0f:         try {
1:c0399dc:             chattyPrepare( nonDBOConn, query );
1:c0399dc: 
1:c0399dc:             if ( _nativeAuthentication ) { fail( "SQL Authorization not on!" ); }
1:c0399dc:         }
1:c0399dc:         catch (SQLException se)
1:49901a4:         {
1:c0399dc:             if ( _nativeAuthentication )
1:c0399dc:             {
1:c0399dc:                 assertSQLState( DBO_ONLY_OPERATION, se );
1:c0399dc:             }
1:dc9cd0f:             else
1:c0399dc:             {
1:c0399dc:                 fail( "Caught unexpected SQLException: " + se.getSQLState() + ": " + se.getMessage() );
1:c0399dc:             }
1:c0399dc:         }
1:c0399dc:     }
1:c0399dc:     
1:92a2169:     private Connection  getConnection
1:92a2169:         ( boolean shouldFail, boolean isLogicalName, String dbName, String user, String expectedSQLState )
1:5107349:         throws Exception
1:c0399dc:     {
1:601e027:         return getConnection( shouldFail, isLogicalName, dbName, user, getPassword( user ), expectedSQLState );
1:601e027:     }
1:601e027:     private Connection  getConnection
1:601e027:         ( boolean shouldFail, boolean isLogicalName, String dbName, String user, String password, String expectedSQLState )
1:601e027:         throws Exception
1:601e027:     {
1:10f4b0f:         return getConnection( shouldFail, isLogicalName, dbName, user, password, new String[] { expectedSQLState } );
1:10f4b0f:     }
1:10f4b0f:     private Connection  getConnection
1:10f4b0f:         ( boolean shouldFail, boolean isLogicalName, String dbName, String user, String password, String[] expectedSQLStates )
1:10f4b0f:         throws Exception
1:10f4b0f:     {
1:5107349:         Connection  conn = null;
1:c0399dc: 
1:10f4b0f:         reportConnectionAttempt( dbName, user, password, isLogicalName );
1:5107349: 
1:c0399dc:         try {
1:601e027:             conn = openConnection( dbName, user, password, isLogicalName, null );
1:5107349: 
1:5107349:             if ( shouldFail )   { fail( tagError( "Connection to " + dbName + " should have failed." ) ); }
1:5107349:         }
1:92a2169:         catch (Throwable t)
1:92a2169:         {
1:10f4b0f:             if ( shouldFail && (t instanceof SQLException) )
1:10f4b0f:             {
1:33605bd:                 SQLException se = (SQLException) t;
1:10f4b0f:                 StringBuffer    buffer = new StringBuffer();
1:10f4b0f: 
1:10f4b0f:                 //  ok if the sqlstate is one of the expected ones
1:10f4b0f:                 for ( int i = 0; i < expectedSQLStates.length; i++ )
1:10f4b0f:                 {
1:10f4b0f:                     String  expected = expectedSQLStates[ i ];
1:10f4b0f:                     buffer.append( " " + expected );
1:33605bd:                     if ( vetSQLState( se, expected ) ) { return null; }
1:10f4b0f:                 }
1:33605bd:                 fail( tagError( "SQLState not in expected list: " + buffer.toString() ) );
1:10f4b0f:             }
1:92a2169:             else
1:c0399dc:             {
1:92a2169:                 printStackTrace( t );
1:92a2169:                 fail( tagError( "Connection to " + dbName + " unexpectedly failed." ) );
1:92a2169:             }
1:5107349:         }
1:5107349: 
1:5107349:         return conn;
1:dc9cd0f:     }
1:33605bd:     // look for a sql state in a SQLException and its chained exceptions. returns true if found
1:33605bd:     private boolean    vetSQLState( SQLException actual, String expectedSQLState )
1:33605bd:         throws Exception
1:33605bd:     {
1:33605bd:         if ( actual == null ) { return false; }
1:33605bd: 
1:33605bd:         if ( expectedSQLState.equals( actual.getSQLState() ) ) { return true; }
1:33605bd: 
1:33605bd:         Throwable   t = actual.getCause();
1:33605bd:         if ( t instanceof SQLException )
1:33605bd:         {
1:33605bd:             if ( vetSQLState( (SQLException) t, expectedSQLState ) ) { return true; }
1:33605bd:         }
1:33605bd: 
1:33605bd:         return vetSQLState( actual.getNextException(), expectedSQLState );
1:33605bd:     }
1:5107349: 
1:49901a4:     // connect but expect a warning that the password is about to expire
1:49901a4:     private Connection  passwordExpiring( boolean expiring, String dbName, String user )
1:49901a4:         throws Exception
1:dc9cd0f:     {
1:49901a4:         Connection  conn = null;
1:49901a4: 
1:10f4b0f:         reportConnectionAttempt( dbName, user, getPassword( user ), true );
1:49901a4: 
1:65a5491:         String  expectedSQLState = DBO.equals( user ) ? DBO_PASSWORD_EXPIRING : PASSWORD_EXPIRING;
1:65a5491: 
1:47f286f:         conn = openConnection( dbName, user, true, null );
1:49901a4: 
1:49901a4:         SQLWarning  warning = conn.getWarnings();
1:49901a4: 
1:49901a4:         if ( expiring )
1:49901a4:         {
1:49901a4:             assertNotNull( tagError( "Should have seen a warning" ), warning );
1:65a5491:             assertSQLState( expectedSQLState, warning );
1:49901a4:         }
1:49901a4:         else
1:49901a4:         {
1:49901a4:             assertNull( tagError( "Should not have seen a warning" ), warning );
1:49901a4:         }
1:49901a4: 
1:49901a4: 
1:49901a4:         return conn;
1:49901a4:     }
1:10f4b0f:     private void    reportConnectionAttempt( String dbName, String user, String password, boolean isLogicalName )
1:5107349:     {
1:10f4b0f:         String  message = "User '" + user + "' with password '" + password + "' attempting to get connection to database " + dbName;
1:92a2169:         if ( isLogicalName ) { message = message + " aka " + getTestConfiguration().getPhysicalDatabaseName( dbName ) ; }
1:92a2169:         println( message );
1:5107349:     }
1:49901a4: 
1:5107349:     private void    addUser( Connection conn, String user ) throws Exception
1:5107349:     {
1:aa1dc7a:         addUser( conn, user, null );
1:aa1dc7a:     }
1:aa1dc7a: 
1:aa1dc7a:     private void    addUser( Connection conn, String user, String expectedSQLState ) throws Exception
1:aa1dc7a:     {
1:aa1dc7a:         boolean shouldFail = (expectedSQLState != null);
1:92a2169:         String  password = getPassword( user );
1:5107349:         String  statement = "call syscs_util.syscs_create_user( '" + user + "', '" + password + "' )";
1:aa1dc7a: 
1:aa1dc7a:         if ( shouldFail )
1:aa1dc7a:         {
1:aa1dc7a:             println( "Expecting " + expectedSQLState + " when executing '" + statement + "'" );
1:aa1dc7a:         }
1:5107349:         
1:aa1dc7a:         try {
1:aa1dc7a:             goodStatement( conn, statement );
1:aa1dc7a: 
1:aa1dc7a:             if ( shouldFail )   { fail( tagError( "Should not have been allowed to create user " + user ) ); }
1:aa1dc7a:         }
1:aa1dc7a:         catch (SQLException se)
1:aa1dc7a:         {
1:aa1dc7a:             if ( shouldFail )   { assertSQLState( expectedSQLState, se ); }
1:aa1dc7a:             else    { fail( tagError( "Unexpectedly failed to create user " + user ) );}
1:aa1dc7a:         }
1:5107349:     }
1:5107349: 
1:a3d7a74:     private void  setDatabaseProperty( boolean shouldFail, Connection conn, String key, String value, String expectedSQLState )
1:a3d7a74:         throws Exception
1:3b95c63:     {
1:a3d7a74:         if ( value == null ) { value = "cast ( null as varchar( 32672 ) )"; }
1:a3d7a74:         else { value = "'" + value + "'"; }
1:a3d7a74:         String  command = "call syscs_util.syscs_set_database_property( '" + key + "', " + value + " )";
1:a3d7a74: 
1:a3d7a74:         try {
1:a3d7a74:             goodStatement( conn, command );
1:a3d7a74: 
1:a3d7a74:             if ( shouldFail )   { fail( tagError( "Property setting should have failed." ) ); }
1:a3d7a74:         }
1:a3d7a74:         catch (SQLException se)
1:a3d7a74:         {
1:a3d7a74:             if ( shouldFail )   { assertSQLState( expectedSQLState, se ); }
1:a3d7a74:             else    { fail( tagError( "Property setting unexpectedly failed." ) );}
1:a3d7a74:         }
1:a3d7a74:     }
1:a3d7a74: 
1:a3d7a74:     private void  vetStatement( boolean shouldFail, Connection conn, String command, String expectedSQLState )
1:a3d7a74:         throws Exception
1:a3d7a74:     {
1:a3d7a74:         try {
1:a3d7a74:             goodStatement( conn, command );
1:a3d7a74: 
1:a3d7a74:             if ( shouldFail )   { fail( tagError( "Statement should have failed." ) ); }
1:a3d7a74:         }
1:a3d7a74:         catch (SQLException se)
1:a3d7a74:         {
1:a3d7a74:             if ( shouldFail )   { assertSQLState( expectedSQLState, se ); }
1:3b95c63:             else
1:5107349:             {
1:3b95c63:                 String  error =  "Statement unexpectedly failed. SQLState = " + se.getSQLState() + ": " + se.getMessage();
1:3b95c63:                 fail( tagError( error ) );
1:3b95c63:             }
1:a3d7a74:         }
1:a3d7a74:     }
1:a3d7a74: 
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349:     //
1:5107349:     // MINIONS
1:5107349:     //
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349: 
1:5107349:     /** Open a connection to a database using the supplied credentials */
1:47f286f:     private Connection  openConnection( String dbName, String user, boolean isLogicalName, Properties props )
1:5107349:         throws SQLException
1:5107349:     {
1:601e027:         return openConnection( dbName, user, getPassword( user ), isLogicalName, props );
1:601e027:     }
1:601e027:     private Connection  openConnection( String dbName, String user, String password, boolean isLogicalName, Properties props )
1:601e027:         throws SQLException
1:601e027:     {
1:92a2169:         if ( isLogicalName )
1:92a2169:         {
1:92a2169:             return getTestConfiguration().openConnection( dbName, user, password );
1:92a2169:         }
1:92a2169:         else
1:92a2169:         {
1:47f286f:             return getTestConfiguration().openPhysicalConnection( dbName, user, password, props );
1:92a2169:         }
1:5107349:     }
1:5107349:     
1:5107349:     /** Get the password for a user */
1:5107349:     private static  String  getPassword( String user ) { return user + "_password"; }
1:5107349: 
1:5107349:     /** Tag an error with the name of the test configuration */
1:5107349:     private String  tagError( String text ) { return nameOfTest() + ": " + text; }
1:5107349: 
1:5107349: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite();
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9f1b314
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:          boolean    turnOffAuthenticationAndAuthorization
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return "[ " + dbLocation + authType + local + authOverrides + embedded + " ]";
/////////////////////////////////////////////////////////////////////////
1:                   ( JAR_ENCRYPTED, NATIVE, LOCAL, DONT_DISABLE_AUTH )
/////////////////////////////////////////////////////////////////////////
1:               ( NONE, NO_AUTH, SYSTEM_WIDE, DONT_DISABLE_AUTH )
/////////////////////////////////////////////////////////////////////////
1:               ( FILE, NATIVE, LOCAL, DISABLE_AUTHORIZATION )
1:               ( FILE, NATIVE, LOCAL, DONT_DISABLE_AUTH )
/////////////////////////////////////////////////////////////////////////
1:               ( FILE, NATIVE, SYSTEM_WIDE, DISABLE_AUTHORIZATION )
1:               ( FILE, NATIVE, SYSTEM_WIDE, DONT_DISABLE_AUTH )
/////////////////////////////////////////////////////////////////////////
1:                   ( JAR, NATIVE, SYSTEM_WIDE, DONT_DISABLE_AUTH )
1:                   ( JAR, NATIVE, LOCAL, DONT_DISABLE_AUTH )
/////////////////////////////////////////////////////////////////////////
1:                   ( CLASSPATH, NATIVE, SYSTEM_WIDE, DONT_DISABLE_AUTH )
1:                   ( CLASSPATH, NATIVE, LOCAL, DONT_DISABLE_AUTH )
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             // database accessed via classpath subprotocol
1:             vetProtocol( classpathDBName() );
commit:4a08a15
/////////////////////////////////////////////////////////////////////////
1: import java.net.URL;
/////////////////////////////////////////////////////////////////////////
1:     public static Test suite() throws Exception
1:         // Only run on platforms where we can expect cleanup of support files
1:         // to succeed (DERBY-5618).
1:         if (enableSubprotocolTests())
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Check whether or not tests for subprotocols should be enabled
1:      * on this platform.
1:      */
1:     private static boolean enableSubprotocolTests() {
1:         // DERBY-5618: On Windows, we are not able to delete the jar files
1:         // used by the tests for the classpath subsubprotocol if we don't
1:         // close the URLClassLoader when we're done. Closing the class loader
1:         // can only be done on Java 7 and higher.
1:         //
1:         // Run the tests if the Java version supports URLClassLoader.close(),
1:         // or if we're on a non-Windows platform (where the jar files can be
1:         // deleted even if the class loader hasn't been closed).
1:         return ClasspathSetup.supportsClose() || !isWindowsPlatform();
/////////////////////////////////////////////////////////////////////////
1:     private static Test allConfigurations(boolean clientServer) throws Exception
/////////////////////////////////////////////////////////////////////////
1:         // For testing subprotocols. Only run on platforms where we can
1:         // expect cleanup of support files to succeed (DERBY-5618).
1:         if (enableSubprotocolTests())
/////////////////////////////////////////////////////////////////////////
1:         }
/////////////////////////////////////////////////////////////////////////
1:     private Test decorate(boolean clientServer) throws Exception
/////////////////////////////////////////////////////////////////////////
1:         // For testing subprotocols. Only run on platforms where we can
1:         // expect cleanup of support files to succeed (DERBY-5618).
1:         if (enableSubprotocolTests())
1:             // Add a jar file to the classpath so that we can test the classpath subprotocol.
1:             URL nast2Jar = SupportFilesSetup.getReadOnlyURL(NAST2_JAR_FILE);
1:             result = new ClasspathSetup(result, nast2Jar);
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Vet databases accessed via subprotocols.
1:         if (enableSubprotocolTests())
commit:fcd3d48
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TimeZoneTestSetup;
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-5966: Run the test in the GMT time zone to avoid instabilities
1:         // around transition to or from DST. Once DERBY-5974 has been fixed, it
1:         // should be OK to run in the local time zone.
1:         return new TimeZoneTestSetup(suite, "GMT");
commit:35e7aba
/////////////////////////////////////////////////////////////////////////
0: import junit.extensions.TestSetup;
/////////////////////////////////////////////////////////////////////////
1:         else
1:         {
1:             // DERBY-5580: We should also shut down the engine before deleting
1:             // the database if we don't set any system properties.
0:             result = new TestSetup(result) {
0:                 protected void tearDown() {
0:                     TestConfiguration.getCurrent().shutdownEngine();
1:                 }
1:             };
1:         }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:eec86ed
/////////////////////////////////////////////////////////////////////////
0:                 result = new ClasspathSetup( result, nast2Jar.toURI().toURL() );
commit:45f5174
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  UPGRADE_TO_BETA_PROPERTY = "derby.database.allowPreReleaseUpgrade";
/////////////////////////////////////////////////////////////////////////
1:         result.put( UPGRADE_TO_BETA_PROPERTY, "true" );
commit:5ea170f
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  PRICKLY_PEAR_USER = "PeAr";   
1:     private static  final   String  PINEAPPLE_USER = "PINEAPPLE";
1: 
1:     private static  final   String  CAMEL_CASE_DBO = "kIwI";
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  USER_ALREADY_EXISTS = "X0Y68";
/////////////////////////////////////////////////////////////////////////
1:             vetCasing();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Verify the casing behavior of user identifiers.
1:      * </p>
1:      */
1:     private void    vetCasing()   throws Exception
1:     {
1:         // only run this if we are using NATIVE authentication and the DBO's creds are already
1:         // in the credentials DB. this is just to make sure that we are in a database where
1:         // the DBO's creds already exist.
1:         if ( !_nativeAuthentication ) { return; }
1:         if ( _localAuthentication ) { return; }
1: 
1:         String  originalPricklyPearPassword = "prickly_pear_password";
1:         
1:         // connect to the credentials database
1:         Connection  dboConn = openConnection( CREDENTIALS_DB, DBO, true, null );
1: 
1:         // can't add redundant credentials for an authorization id by changing the casing
1:         addUser( dboConn, CAMEL_CASE_DBO, USER_ALREADY_EXISTS );
1: 
1:         // using double-quotes, however, you can create a camel-case user name
1:         addUser( dboConn, PEAR_USER, null );
1:         assertFalse( PEAR_USER.equals( PRICKLY_PEAR_USER ) );
1:         assertTrue( PEAR_USER.toUpperCase().equals( PRICKLY_PEAR_USER.toUpperCase() ) );
1:         goodStatement
1:             (
1:              dboConn,
1:              "call syscs_util.syscs_create_user( '\"" + PRICKLY_PEAR_USER + "\"', '" + originalPricklyPearPassword + "' )"
1:              );
1:         String[][]  legalUsers = new String[][] { { PEAR_USER }, { PRICKLY_PEAR_USER } };
1:         assertResults
1:             (
1:              dboConn,
1:              "select username from sys.sysusers where username like 'P%' order by username",
1:              legalUsers,
1:              false
1:              );
1: 
1:         // schema name for an unquoted user name should be upper case
1:         Connection  pearConn = openConnection( CREDENTIALS_DB, PEAR_USER, true, null );
1:         assertResults
1:             (
1:              pearConn,
1:              "values current schema",
1:              new String[][] { { PEAR_USER.toUpperCase() } },
1:              false
1:              );
1: 
1:         // schema name for a quoted user name should be camel case
1:         Connection  pricklyPearConn = openConnection
1:             ( CREDENTIALS_DB, doubleQuote( PRICKLY_PEAR_USER ), originalPricklyPearPassword, true, null );
1:         assertResults
1:             (
1:              pricklyPearConn,
1:              "values current schema",
1:              new String[][] { { PRICKLY_PEAR_USER } },
1:              false
1:              );
1: 
1:         //
1:         // Verify the casing on the USERNAME argument to the NATIVE procedures
1:         //
1: 
1:         // modify password
1:         String  rev2_password = "password_rev2";
1:         goodStatement
1:             (
1:              pricklyPearConn,
1:              "call syscs_util.syscs_modify_password( '" + rev2_password + "' )"
1:              );
1:         getConnection
1:             ( true, true, CREDENTIALS_DB, doubleQuote( PRICKLY_PEAR_USER ), originalPricklyPearPassword, INVALID_AUTHENTICATION );
1:         pricklyPearConn = openConnection
1:             ( CREDENTIALS_DB, doubleQuote( PRICKLY_PEAR_USER ), rev2_password, true, null );
1: 
1:         // reset password
1:         String rev3_password = "password_rev3";
1:         goodStatement
1:             (
1:              dboConn,
1:              "call syscs_util.syscs_reset_password( '" + doubleQuote( PRICKLY_PEAR_USER ) + "', '" + rev3_password + "' )"
1:              );
1:         getConnection
1:             ( true, true, CREDENTIALS_DB, doubleQuote( PRICKLY_PEAR_USER ), rev2_password, INVALID_AUTHENTICATION );
1:         pricklyPearConn = openConnection
1:             ( CREDENTIALS_DB, doubleQuote( PRICKLY_PEAR_USER ), rev3_password, true, null );
1: 
1:         // drop user
1:         int     userCount = countUsers( dboConn );
1:         goodStatement
1:             (
1:              dboConn,
1:              "call syscs_util.syscs_drop_user( '" + doubleQuote( PRICKLY_PEAR_USER ) + "' )"
1:              );
1:         assertEquals( userCount - 1, countUsers( dboConn ) );
1:         getConnection
1:             ( true, true, CREDENTIALS_DB, doubleQuote( PRICKLY_PEAR_USER ), rev3_password, INVALID_AUTHENTICATION );
1:     }
1:     private String  doubleQuote( String raw ) { return "\"" + raw + "\""; }
1:     private int countUsers( Connection conn ) throws Exception
1:     {
1:         PreparedStatement   ps = chattyPrepare( conn, "select count(*) from sys.sysusers" );
1:         ResultSet   rs = ps.executeQuery();
1: 
1:         rs.next();
1: 
1:         try { return rs.getInt( 1 ); }
1:         finally
1:         {
1:             rs.close();
1:             ps.close();
1:         }
1:     }
1: 
1:     /**
1:      * <p>
/////////////////////////////////////////////////////////////////////////
1:         // normalize the user name
1:         userName = userName.toUpperCase();
1: 
commit:33605bd
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  FIFTEENTH_DB = "fifteenthDB";
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  BAD_USER_AUTHENTICATOR_CLASS = "XBM0M";
/////////////////////////////////////////////////////////////////////////
1:     private DatabaseChangeSetup _fifteenthDBSetup;
/////////////////////////////////////////////////////////////////////////
1:         result = _fifteenthDBSetup = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, FIFTEENTH_DB, true );
/////////////////////////////////////////////////////////////////////////
1: 
1:         // verify a sensible error if you try to set the authentication provider
1:         // to the missing classname NATIVE. we only check this for the embedded
1:         // case because the network scrunches exceptions together and we lose
1:         // the structure which allows us to look for nested SQLStates.
1:         if ( isEmbedded() )
1:         {
1:             Connection  fifteenthConn = openConnection( FIFTEENTH_DB, dbo, true, null );
1:             goodStatement
1:                 ( fifteenthConn, "call syscs_util.syscs_set_database_property( 'derby.connection.requireAuthentication', 'true' )" );
1:             goodStatement
1:                 ( fifteenthConn, "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'NATIVE' )" );
1:             _fifteenthDBSetup.getTestConfiguration().shutdownDatabase();
1: 
1:             getConnection( true, true, FIFTEENTH_DB, DBO, BAD_USER_AUTHENTICATOR_CLASS );
1:         }
/////////////////////////////////////////////////////////////////////////
1:                 SQLException se = (SQLException) t;
/////////////////////////////////////////////////////////////////////////
1:                     if ( vetSQLState( se, expected ) ) { return null; }
1:                 fail( tagError( "SQLState not in expected list: " + buffer.toString() ) );
/////////////////////////////////////////////////////////////////////////
1:     // look for a sql state in a SQLException and its chained exceptions. returns true if found
1:     private boolean    vetSQLState( SQLException actual, String expectedSQLState )
1:         throws Exception
1:     {
1:         if ( actual == null ) { return false; }
1: 
1:         if ( expectedSQLState.equals( actual.getSQLState() ) ) { return true; }
1: 
1:         Throwable   t = actual.getCause();
1:         if ( t instanceof SQLException )
1:         {
1:             if ( vetSQLState( (SQLException) t, expectedSQLState ) ) { return true; }
1:         }
1: 
1:         return vetSQLState( actual.getNextException(), expectedSQLState );
1:     }
commit:aa1dc7a
/////////////////////////////////////////////////////////////////////////
0:     private static  final   String  PINEAPPLE_USER = "PINEAPPLE";   
/////////////////////////////////////////////////////////////////////////
1:         // add the dbo as a user if she wasn't created when the database was created
1:             // verify that only the DBO can create credentials for the DBO
1:             Connection  pineappleConn = openConnection( CREDENTIALS_DB, PINEAPPLE_USER, true, null );
1:             addUser( pineappleConn, DBO, DBO_ONLY_OPERATION );  // this should fail
1:             
/////////////////////////////////////////////////////////////////////////
1:         addUser( conn, user, null );
1:     }
1: 
1:     private void    addUser( Connection conn, String user, String expectedSQLState ) throws Exception
1:     {
1:         boolean shouldFail = (expectedSQLState != null);
1: 
1:         if ( shouldFail )
1:         {
1:             println( "Expecting " + expectedSQLState + " when executing '" + statement + "'" );
1:         }
1:         try {
1:             goodStatement( conn, statement );
1: 
1:             if ( shouldFail )   { fail( tagError( "Should not have been allowed to create user " + user ) ); }
1:         }
1:         catch (SQLException se)
1:         {
1:             if ( shouldFail )   { assertSQLState( expectedSQLState, se ); }
1:             else    { fail( tagError( "Unexpectedly failed to create user " + user ) );}
1:         }
commit:c5b9acb
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  MISSING_USER = "XK001";
1: 
1:     private static  final   String      WEAK_AUTHENTICATION = "4251G";
1:     private static  final   String      HASHING_FORMAT_10_9 = "3b62";
1:     private static  final   int           HEX_CHARS_PER_BYTE = 2;
/////////////////////////////////////////////////////////////////////////
0:         // add the dbo as a user if he wasn't created when the database was created
1:         if ( !_nativeAuthentication )
1:         {
1:             addUser( sysadminConn, DBO );
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:         String[][]  legalUsers = new String[][] { { APPLE_USER }, { BANANA_USER } , { DBO } };
/////////////////////////////////////////////////////////////////////////
1:         String[][]  authenticationProvider = new String[][] { { "NATIVE::LOCAL" } };
/////////////////////////////////////////////////////////////////////////
1:         // verify password hashing
1:         if ( _localAuthentication )
1:         {
1:             passwordHashingTests( sysadminConn );
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if ( _localAuthentication) { addUser( seventhDBOConn, APPLE_USER ); }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if ( _localAuthentication ) { addUser( twelthDBOConn, APPLE_USER ); }
1:         if ( _localAuthentication )
1:         {
1:             vetStatement( _nativeAuthentication, twelthAppleConn,
1:                           "call syscs_util.syscs_create_user( 'JULIUS', 'juliuspassword' )", NO_EXECUTE_PERMISSION );
1:             vetStatement( _nativeAuthentication, twelthAppleConn,
1:                           "call syscs_util.syscs_reset_password( 'JULIUS', 'foopassword' )", NO_EXECUTE_PERMISSION );
1:             vetStatement( _nativeAuthentication, twelthAppleConn,
1:                           "call syscs_util.syscs_drop_user( 'JULIUS' )", NO_EXECUTE_PERMISSION );
1:         }
1:         vetStatement( !_localAuthentication, twelthAppleConn,
1:                       "call syscs_util.syscs_modify_password( 'foo' )", MISSING_USER );
/////////////////////////////////////////////////////////////////////////
1: 
1:         if ( _localAuthentication )
1:         {
1:             goodStatement( twelthAppleConn, "call syscs_util.syscs_create_user( 'HORACE', 'horacepassword' )" );
1:             goodStatement( twelthAppleConn, "call syscs_util.syscs_reset_password( 'HORACE', 'foopassword' )" );
1:             goodStatement( twelthAppleConn, "call syscs_util.syscs_drop_user( 'HORACE' )" );
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:         if ( _localAuthentication )
1:         {
1:             vetStatement( _nativeAuthentication, twelthAppleConn,
1:                           "call syscs_util.syscs_create_user( 'CORNELIA', 'corneliapassword' )", NO_EXECUTE_PERMISSION );
1:             vetStatement( _nativeAuthentication, twelthAppleConn,
1:                           "call syscs_util.syscs_reset_password( 'CORNELIA', 'foopassword' )", NO_EXECUTE_PERMISSION );
1:             vetStatement( _nativeAuthentication, twelthAppleConn,
1:                           "call syscs_util.syscs_drop_user( 'CORNELIA' )", NO_EXECUTE_PERMISSION );
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if ( _localAuthentication ) { addUser( dboConn, BANANA_USER ); }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // NATIVE::LOCAL is the only legal value which the authentication provider property can take on disk
1:         expectExecutionError
1:             (
1:              dboConn, INVALID_PROVIDER_CHANGE,
1:              "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'NATIVE:db:LOCAL' )"
1:              );
1:         expectExecutionError
1:             (
1:              dboConn, INVALID_PROVIDER_CHANGE,
1:              "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'NATIVE:LOCAL' )"
1:              );
1:  
1:         addUser( dboConn, PEAR_USER );
1: 
/////////////////////////////////////////////////////////////////////////
1:         // creating the DBO turned on NATIVE + LOCAL
/////////////////////////////////////////////////////////////////////////
1:     private void    passwordHashingTests
1:         ( Connection dboConnection )
1:         throws Exception
1:     {
1:         // set a message digest algorithm in case it was unset by a previous test.
1:         // a message digest algorithm must be set in order to use NATIVE authentication
1:         String  originalDigestAlgorithm = getDatabaseProperty( dboConnection, "derby.authentication.builtin.algorithm" );
1:         if ( originalDigestAlgorithm == null )
1:         {
1:             setDatabaseProperty( dboConnection, "derby.authentication.builtin.algorithm", "SHA-1" );
1:         }
1: 
1:         String  defaultDigestAlgorithm = getDatabaseProperty( dboConnection, "derby.authentication.builtin.algorithm" );
1: 
1:         goodStatement( dboConnection, "call syscs_util.syscs_create_user( 'pht', 'phtpassword' )" );
1: 
1:         vetHashingScheme( dboConnection, "pht", HASHING_FORMAT_10_9, 16, 1000, defaultDigestAlgorithm );
1: 
1:         int saltLength = 5;
1:         setDatabaseProperty( dboConnection, "derby.authentication.builtin.saltLength", Integer.toString( saltLength ) );
1:         goodStatement( dboConnection, "call syscs_util.syscs_reset_password( 'pht', 'newsaltlength' )" );
1:         vetHashingScheme( dboConnection, "pht", HASHING_FORMAT_10_9, saltLength, 1000, defaultDigestAlgorithm );
1: 
1:         int iterations = 10;
1:         setDatabaseProperty( dboConnection, "derby.authentication.builtin.iterations", Integer.toString( iterations ) );
1:         goodStatement( dboConnection, "call syscs_util.syscs_reset_password( 'pht', 'newiterations' )" );
1:         vetHashingScheme( dboConnection, "pht", HASHING_FORMAT_10_9, saltLength, iterations, defaultDigestAlgorithm );
1: 
1:         String digestAlgorithm = "SHA-1";
1:         setDatabaseProperty( dboConnection, "derby.authentication.builtin.algorithm", digestAlgorithm );
1:         goodStatement( dboConnection, "call syscs_util.syscs_reset_password( 'pht', 'newiterations' )" );
1:         vetHashingScheme( dboConnection, "pht", HASHING_FORMAT_10_9, saltLength, iterations, digestAlgorithm );
1: 
1:         setDatabaseProperty( dboConnection, "derby.authentication.builtin.algorithm", null );
1:         expectExecutionError( dboConnection, WEAK_AUTHENTICATION, "call syscs_util.syscs_reset_password( 'pht', 'badalgorithm' )" );
1: 
1:         setDatabaseProperty( dboConnection, "derby.authentication.builtin.saltLength", null );
1:         setDatabaseProperty( dboConnection, "derby.authentication.builtin.iterations", null );
1:         setDatabaseProperty( dboConnection, "derby.authentication.builtin.algorithm", defaultDigestAlgorithm );
1:         goodStatement( dboConnection, "call syscs_util.syscs_drop_user( 'pht' )" );
1:         
1:         // reset the message digest algorithm in order to not disrupt the existing tests
1:         if ( originalDigestAlgorithm == null )
1:         {
1:             setDatabaseProperty( dboConnection, "derby.authentication.builtin.algorithm", null );
1:         }
1:     }
1:     private void  setDatabaseProperty( Connection conn, String key, String value )
1:         throws Exception
1:     {
1:         if ( value == null ) { value = "cast ( null as varchar( 32672 ) )"; }
1:         else { value = "'" + value + "'"; }
1:         String  command = "call syscs_util.syscs_set_database_property( '" + key + "', " + value + " )";
1: 
1:         goodStatement( conn, command );
1:     }
1:     private String  getDatabaseProperty( Connection conn, String key )
1:         throws Exception
1:     {
1:         PreparedStatement   ps = chattyPrepare( conn, "values( syscs_util.syscs_get_database_property( '" + key + "' ) )" );
1:         ResultSet   rs = ps.executeQuery();
1: 
1:         try {
1:             rs.next();
1:             return rs.getString( 1 );
1:         }
1:         finally
1:         {
1:             rs.close();
1:             ps.close();
1:         }
1:     }
1:     private void    vetHashingScheme
1:         (
1:          Connection conn,
1:          String userName,
1:          String expectedHashingFormat,
1:          int expectedSaltLength,
1:          int expectedIterations,
1:          String expectedDigestAlgorithm
1:          )
1:         throws Exception
1:     {
1:         String  hashingScheme = getHashingScheme( conn,  userName );
1:         int     firstColonPosition = hashingScheme.indexOf( ":" );
1:         int     secondColonPosition = hashingScheme.indexOf( ":", firstColonPosition + 1 );
1:         int     thirdColonPosition = hashingScheme.indexOf( ":", secondColonPosition + 1 );
1: 
1:         String  actualHashingFormat = hashingScheme.substring( 0, firstColonPosition );
1:         String  salt = hashingScheme.substring( firstColonPosition + 1, secondColonPosition );
1:         String  iterationString = hashingScheme.substring( secondColonPosition + 1, thirdColonPosition );
1:         String  actualDigestAlgorithm = hashingScheme.substring( thirdColonPosition + 1 );
1: 
1:         int     actualSaltLength = salt.length();
1:         int     actualIterations = Integer.parseInt( iterationString );
1: 
1:         assertEquals( expectedHashingFormat, actualHashingFormat );
1:         assertEquals( expectedSaltLength * HEX_CHARS_PER_BYTE, actualSaltLength );
1:         assertEquals( expectedIterations, actualIterations );
1:         assertEquals( expectedDigestAlgorithm, actualDigestAlgorithm );
1:     }
1:     private String  getHashingScheme( Connection conn, String userName )
1:         throws Exception
1:     {
1:         PreparedStatement   ps = conn.prepareStatement( "select userName, hashingScheme from sys.sysusers" );
1:         ResultSet   rs = ps.executeQuery();
1: 
1:         try {
1:             while ( rs.next() )
1:             {
1:                 if ( userName.equals( rs.getString( 1 )  ) ) { return rs.getString( 2 ); }
1:             }
1:         } finally
1:         {
1:             rs.close();
1:             ps.close();
1:         }
1: 
1:         fail( "Could not find credentials for " + userName );
1: 
1:         // never get here
1:         return null;
1:     }
1: 
commit:65a5491
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  DBO_PASSWORD_EXPIRING = "01J16";
/////////////////////////////////////////////////////////////////////////
1:         String  expectedSQLState = DBO.equals( user ) ? DBO_PASSWORD_EXPIRING : PASSWORD_EXPIRING;
1: 
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState( expectedSQLState, warning );
commit:10f4b0f
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  BAD_NETWORK_AUTHENTICATION = "08001";
/////////////////////////////////////////////////////////////////////////
1:         // can't create a credentials db with an empty username or password
1:         if ( _nativeAuthentication ) { vetEmptyCredentials(); }
1:         
/////////////////////////////////////////////////////////////////////////
1: 
1:     private void    vetEmptyCredentials()   throws Exception
1:     {
1:         vetEmptyCredentials( null, null );
1:         vetEmptyCredentials( "", null );
1:         vetEmptyCredentials( null, "" );
1:         vetEmptyCredentials( "", "" );
1: 
1:         vetEmptyCredentials( "foo", null );
1:         vetEmptyCredentials( "foo", "" );
1: 
1:         if ( isEmbedded() ) { vetEmptyCredentials( null, "bar" ); } // the network server fabricates a username of APP
1:         vetEmptyCredentials( "", "bar" );
1:     }
1:     private void    vetEmptyCredentials( String user, String password ) throws Exception
1:     {
1:         String[]  expectedSQLStates = new String[] { INVALID_AUTHENTICATION,BAD_NETWORK_AUTHENTICATION };
1:         
1:         getConnection( true, true, CREDENTIALS_DB, user, password, expectedSQLStates );
1:     }
/////////////////////////////////////////////////////////////////////////
1:         return getConnection( shouldFail, isLogicalName, dbName, user, password, new String[] { expectedSQLState } );
1:     }
1:     private Connection  getConnection
1:         ( boolean shouldFail, boolean isLogicalName, String dbName, String user, String password, String[] expectedSQLStates )
1:         throws Exception
1:     {
1:         reportConnectionAttempt( dbName, user, password, isLogicalName );
/////////////////////////////////////////////////////////////////////////
1:             if ( shouldFail && (t instanceof SQLException) )
1:             {
0:                 String          actualSQLState = ((SQLException) t).getSQLState();
1:                 StringBuffer    buffer = new StringBuffer();
1: 
1:                 //  ok if the sqlstate is one of the expected ones
1:                 for ( int i = 0; i < expectedSQLStates.length; i++ )
1:                 {
1:                     String  expected = expectedSQLStates[ i ];
1:                     buffer.append( " " + expected );
0:                     if ( expected.equals( actualSQLState ) ) { return null; }
1:                 }
0:                 fail( tagError( "SQLState " + actualSQLState + " not in expected list: " + buffer.toString() ) );
1:             }
/////////////////////////////////////////////////////////////////////////
1:         reportConnectionAttempt( dbName, user, getPassword( user ), true );
/////////////////////////////////////////////////////////////////////////
1:     private void    reportConnectionAttempt( String dbName, String user, String password, boolean isLogicalName )
1:         String  message = "User '" + user + "' with password '" + password + "' attempting to get connection to database " + dbName;
commit:601e027
/////////////////////////////////////////////////////////////////////////
1:         // null password should not generate NPE
1:         getConnection( _nativeAuthentication, true, CREDENTIALS_DB, DBO, null, INVALID_AUTHENTICATION );
1: 
/////////////////////////////////////////////////////////////////////////
1:         return getConnection( shouldFail, isLogicalName, dbName, user, getPassword( user ), expectedSQLState );
1:     }
1:     private Connection  getConnection
1:         ( boolean shouldFail, boolean isLogicalName, String dbName, String user, String password, String expectedSQLState )
1:         throws Exception
1:     {
1:             conn = openConnection( dbName, user, password, isLogicalName, null );
/////////////////////////////////////////////////////////////////////////
1:         return openConnection( dbName, user, getPassword( user ), isLogicalName, props );
1:     }
1:     private Connection  openConnection( String dbName, String user, String password, boolean isLogicalName, Properties props )
1:         throws SQLException
1:     {
commit:47f286f
/////////////////////////////////////////////////////////////////////////
1:     private static  final   int JAR_ENCRYPTED = 4;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  THIRTEENTH_DB = "thirteenthDB";
1:     private static  final   String  FOURTEENTH_DB = "fourteenthDB";
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  CANT_BOOT_DATABASE = "XJ040";
/////////////////////////////////////////////////////////////////////////
1:             case JAR_ENCRYPTED:
1:                 _credentialsDBPhysicalName = jarDBName( _credentialsDBLocation );
/////////////////////////////////////////////////////////////////////////
1:             case JAR_ENCRYPTED:
/////////////////////////////////////////////////////////////////////////
1:             case JAR_ENCRYPTED:
1:                 dbLocation = "JAR_ENCRYPTED, ";
1:                 break;
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Special version of the test which uses an encrypted database for credentials.
0:         // Not run on windows until DERBY-5618 is addressed.
0:         // Also not run on small devices because encryption is not supported there
0:         // by default.
0:         if ( !onWindows() && !JDBC.vmSupportsJSR169() )
1:         {
1:             suite.addTest
1:                 (
1:                  (
1:                   new NativeAuthenticationServiceTest
0:                   ( JAR_ENCRYPTED, NATIVE, LOCAL, DONT_DISABLE_AUTH, ENABLE_JAVA_SECURITY )
1:                   ).decorate( false )
1:                  );
1:         }
/////////////////////////////////////////////////////////////////////////
1:         // No authentication. 
/////////////////////////////////////////////////////////////////////////
1:         result = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, THIRTEENTH_DB );
1:         result = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, FOURTEENTH_DB );
/////////////////////////////////////////////////////////////////////////
1:         if ( _credentialsDBLocation == JAR_ENCRYPTED )
1:         {
1:             vetEncryptedCredentialsDB();
1:         }
1:         else if ( credentialsViaSubprotocol() )
/////////////////////////////////////////////////////////////////////////
1:      * Verify behavior when credentials live in an encrypted db.
1:      * </p>
1:      */
1:     private void    vetEncryptedCredentialsDB()   throws Exception
1:     {
1:         // can't create a database if the encrypted credentials db hasn't been booted yet
1:         Connection  badConn = getConnection( true, true, THIRTEENTH_DB, DBO, CANT_BOOT_DATABASE );
1:         
1:         // now boot the encrypted credentials db
1:         Properties  props = new Properties();
1:         props.setProperty( "bootPassword", "clo760uds2caPe" );
1:         Connection  dboConn = openConnection( jarDBName( _credentialsDBLocation ), DBO, false, props );
1: 
1:         // credentials db is booted. now we can create databases with good credentials.
1:         Connection  grapeConn = getConnection( false, true, THIRTEENTH_DB, GRAPE_USER, null );
1: 
1:         // but we can't create a database with bad credentials
1:         getConnection( true, true, FOURTEENTH_DB, WALNUT_USER, INVALID_AUTHENTICATION );
1:     }
1:     
1:     /**
1:      * <p>
/////////////////////////////////////////////////////////////////////////
1:         Connection  grapeConn = openConnection( TENTH_DB, GRAPE_USER, true, null );
/////////////////////////////////////////////////////////////////////////
1:         Connection  sysadminConn = openConnection( CREDENTIALS_DB, DBO, true, null );
/////////////////////////////////////////////////////////////////////////
1:         Connection  seventhDBOConn = openConnection( SEVENTH_DB, DBO, true, null );
/////////////////////////////////////////////////////////////////////////
1:         Connection  seventhAppleConn = openConnection( SEVENTH_DB, APPLE_USER, true, null );
/////////////////////////////////////////////////////////////////////////
1:         Connection  eighthDBOConn = openConnection( EIGHTH_DB, DBO, true, null );
/////////////////////////////////////////////////////////////////////////
1:             vetProtocol( jarDBName( _credentialsDBLocation ) );
/////////////////////////////////////////////////////////////////////////
1:         Connection  twelthDBOConn = openConnection( TWELTH_DB, DBO, true, null );
1:         Connection  twelthAppleConn = openConnection( TWELTH_DB, APPLE_USER, true, null );
/////////////////////////////////////////////////////////////////////////
1:     private static  String  jarDBName( int credentialsDBLocation ) throws Exception
1:         String  dbName = (credentialsDBLocation == JAR_ENCRYPTED) ? "nastEncrypted" : "nast";
1:         
1:         return "jar:(" + SupportFilesSetup.getReadOnlyFileName( NAST1_JAR_FILE  ) + ")" + dbName;
/////////////////////////////////////////////////////////////////////////
1:         Connection  dboConn = openConnection( SIXTH_DB, DBO, true, null );
/////////////////////////////////////////////////////////////////////////
1:         Connection  dboConn = openConnection( FOURTH_DB, dbo, true, null );
/////////////////////////////////////////////////////////////////////////
1:         Connection  pearConn = openConnection( FOURTH_DB, PEAR_USER, true, null );
/////////////////////////////////////////////////////////////////////////
1:         Connection  dboConn = openConnection( FIFTH_DB, DBO, true, null );
/////////////////////////////////////////////////////////////////////////
1:         dboConn = openConnection( FIFTH_DB, DBO, true, null );
/////////////////////////////////////////////////////////////////////////
1:         Connection  nonDBOConn = openConnection( CREDENTIALS_DB, APPLE_USER, true, null );
/////////////////////////////////////////////////////////////////////////
0:             conn = openConnection( dbName, user, isLogicalName, null );
/////////////////////////////////////////////////////////////////////////
1:         conn = openConnection( dbName, user, true, null );
/////////////////////////////////////////////////////////////////////////
1:     private Connection  openConnection( String dbName, String user, boolean isLogicalName, Properties props )
/////////////////////////////////////////////////////////////////////////
1:             return getTestConfiguration().openPhysicalConnection( dbName, user, password, props );
commit:3b95c63
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  TWELTH_DB = "twelthDB";
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  NO_EXECUTE_PERMISSION = "42504";
1:     private static  final   String  SQL_AUTHORIZATION_NOT_ON = "42Z60";
/////////////////////////////////////////////////////////////////////////
1:         result = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, TWELTH_DB );
/////////////////////////////////////////////////////////////////////////
1:         
1:         ///////////////////////////////////////////////////////////////////////////////////
1:         //
1:         // Verify that the DBO can grant and revoke execute privilege on the NATIVE procedures.
1:         //
1:         ///////////////////////////////////////////////////////////////////////////////////
1: 
0:         Connection  twelthDBOConn = openConnection( TWELTH_DB, DBO, true );
1: 
0:         addUser( twelthDBOConn, APPLE_USER );
1: 
0:         Connection  twelthAppleConn = openConnection( TWELTH_DB, APPLE_USER, true );
1: 
1:         // these fail without the appropriate grant
0:         vetStatement( _nativeAuthentication, twelthAppleConn,
0:                       "call syscs_util.syscs_create_user( 'JULIUS', 'juliuspassword' )", NO_EXECUTE_PERMISSION );
0:         vetStatement( _nativeAuthentication, twelthAppleConn,
0:                       "call syscs_util.syscs_reset_password( 'JULIUS', 'foopassword' )", NO_EXECUTE_PERMISSION );
0:         vetStatement( _nativeAuthentication, twelthAppleConn,
0:                       "call syscs_util.syscs_drop_user( 'JULIUS' )", NO_EXECUTE_PERMISSION );
1: 
1:         // but you always have permission to change your own password
0:         goodStatement( twelthAppleConn, "call syscs_util.syscs_modify_password( 'foo' )" );
1: 
1:         // grant execute permission and retry the test
1:         vetStatement
1:             ( !_nativeAuthentication, twelthDBOConn,
1:               "grant execute on procedure syscs_util.syscs_create_user to " + APPLE_USER, SQL_AUTHORIZATION_NOT_ON );
1:         vetStatement
1:             ( !_nativeAuthentication, twelthDBOConn,
1:               "grant execute on procedure syscs_util.syscs_reset_password to " + APPLE_USER, SQL_AUTHORIZATION_NOT_ON );
1:         vetStatement
1:             ( !_nativeAuthentication, twelthDBOConn,
1:               "grant execute on procedure syscs_util.syscs_drop_user to " + APPLE_USER, SQL_AUTHORIZATION_NOT_ON );
1:        
0:         goodStatement( twelthAppleConn, "call syscs_util.syscs_create_user( 'HORACE', 'horacepassword' )" );
0:         goodStatement( twelthAppleConn, "call syscs_util.syscs_reset_password( 'HORACE', 'foopassword' )" );
0:         goodStatement( twelthAppleConn, "call syscs_util.syscs_drop_user( 'HORACE' )" );
1: 
1:         // revoke execute permission and retry the test
1:         vetStatement
1:             ( !_nativeAuthentication, twelthDBOConn,
1:               "revoke execute on procedure syscs_util.syscs_create_user from " + APPLE_USER + " restrict",
1:               SQL_AUTHORIZATION_NOT_ON );
1:         vetStatement
1:             ( !_nativeAuthentication, twelthDBOConn,
1:               "revoke execute on procedure syscs_util.syscs_reset_password from " + APPLE_USER  + " restrict",
1:               SQL_AUTHORIZATION_NOT_ON );
1:         vetStatement
1:             ( !_nativeAuthentication, twelthDBOConn,
1:               "revoke execute on procedure syscs_util.syscs_drop_user from " + APPLE_USER  + " restrict",
1:               SQL_AUTHORIZATION_NOT_ON );
1:         
0:         vetStatement( _nativeAuthentication, twelthAppleConn,
0:                       "call syscs_util.syscs_create_user( 'CORNELIA', 'corneliapassword' )", NO_EXECUTE_PERMISSION );
0:         vetStatement( _nativeAuthentication, twelthAppleConn,
0:                       "call syscs_util.syscs_reset_password( 'CORNELIA', 'foopassword' )", NO_EXECUTE_PERMISSION );
0:         vetStatement( _nativeAuthentication, twelthAppleConn,
0:                       "call syscs_util.syscs_drop_user( 'CORNELIA' )", NO_EXECUTE_PERMISSION );
/////////////////////////////////////////////////////////////////////////
1:             else
1:             {
1:                 String  error =  "Statement unexpectedly failed. SQLState = " + se.getSQLState() + ": " + se.getMessage();
1:                 fail( tagError( error ) );
1:             }
commit:ae21afb
/////////////////////////////////////////////////////////////////////////
1:     // location of credentials db
1:     private static  final   int FILE = 0;
1:     private static  final   int JAR = 1;
1:     private static  final   int CLASSPATH = 2;
1:     private static  final   int NONE = 3;
1: 
1:     // settings for constructor options
1:     private static  final   boolean NATIVE = true;
1:     private static  final   boolean NO_AUTH = false;
1:     
1:     private static  final   boolean LOCAL = true;
1:     private static  final   boolean SYSTEM_WIDE = false;
1:     
1:     private static  final   boolean DISABLE_AUTHORIZATION = true;
1:     private static  final   boolean DONT_DISABLE_AUTH = false;
1:     
0:     private static  final   boolean DISABLE_JAVA_SECURITY = true;
0:     private static  final   boolean ENABLE_JAVA_SECURITY = false;
1:     
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  TENTH_DB = "tenthDB";
1:     private static  final   String  ELEVENTH_DB = "eleventhDB";
/////////////////////////////////////////////////////////////////////////
1:     private final   int         _credentialsDBLocation;
/////////////////////////////////////////////////////////////////////////
1:          int            credentialsDBLocation,
/////////////////////////////////////////////////////////////////////////
1:         _credentialsDBLocation = credentialsDBLocation;
/////////////////////////////////////////////////////////////////////////
1:         throws  Exception
1:         switch ( _credentialsDBLocation )
1:         {
1:             case JAR:
0:                 _credentialsDBPhysicalName = jarDBName();
1:                 break;
1: 
1:             case CLASSPATH:
1:                 _credentialsDBPhysicalName = classpathDBName();
1:                 break;
1: 
1:             case FILE:
1:             case NONE:
1:                 _credentialsDBPhysicalName = physicalDatabaseName;
1:                 break;
1:                 
1:             default:
1:                 throw new Exception( "Unknown location of credentials db: " + _credentialsDBLocation );
1:         }
/////////////////////////////////////////////////////////////////////////
1:             authenticationProvider = "NATIVE:" + _credentialsDBPhysicalName;
/////////////////////////////////////////////////////////////////////////
1:      * Return true if the credentials db is accessed via a jar or classpath subprotocol.
1:      * </p>
1:      */
1:     private boolean credentialsViaSubprotocol()
1:     {
1:         switch ( _credentialsDBLocation )
1:         {
1:             case JAR:
1:             case CLASSPATH:
1:                 return true;
1: 
1:             default:
1:                 return false;
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:         String  dbLocation = "";
1:         switch ( _credentialsDBLocation )
1:         {
1:             case JAR:
1:                 dbLocation = "JAR, ";
1:                 break;
1: 
1:             case CLASSPATH:
1:                 dbLocation = "CLASSPATH, ";
1:                 break;
1: 
1:             case FILE:
1:             case NONE:
1:                 dbLocation = "FILE, ";
1:                 break;
1:                 
1:             default:
1:                 dbLocation = "UNKNOWN, ";
1:                 break;
1:         }
1: 
1:         
/////////////////////////////////////////////////////////////////////////
0:         return "[ " + dbLocation + authType + local + authOverrides + securityManager + embedded + " ]";
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest
1:             (
1:              (
1:               new NativeAuthenticationServiceTest
0:               ( NONE, NO_AUTH, SYSTEM_WIDE, DONT_DISABLE_AUTH, DISABLE_JAVA_SECURITY )
0:               ).decorate( false )
1:              );
0:     private static  boolean onWindows()
/////////////////////////////////////////////////////////////////////////
1:         //
0:         // No authentication
1:         //
1:         suite.addTest
1:             (
1:              (
1:               new NativeAuthenticationServiceTest
0:               ( NONE, NO_AUTH, SYSTEM_WIDE, DONT_DISABLE_AUTH, ENABLE_JAVA_SECURITY )
1:               ).decorate( clientServer )
1:              );
1: 
1:         //
1:         // NATIVE/LOCAL authentication with credentials in read/write dbs
1:         //
1:         suite.addTest
1:             (
1:              (
1:               new NativeAuthenticationServiceTest
0:               ( FILE, NATIVE, LOCAL, DISABLE_AUTHORIZATION, ENABLE_JAVA_SECURITY )
1:               ).decorate( clientServer )
1:              );
1:         suite.addTest
1:             (
1:              (
1:               new NativeAuthenticationServiceTest
0:               ( FILE, NATIVE, LOCAL, DONT_DISABLE_AUTH, ENABLE_JAVA_SECURITY )
1:               ).decorate( clientServer )
1:              );
1: 
1:         //
1:         // NATIVE system-wide authentication with credentials in read/write dbs
1:         //
1:         suite.addTest
1:             (
1:              (
1:               new NativeAuthenticationServiceTest
0:               ( FILE, NATIVE, SYSTEM_WIDE, DISABLE_AUTHORIZATION, ENABLE_JAVA_SECURITY )
1:               ).decorate( clientServer )
1:              );
1:         suite.addTest
1:             (
1:              (
1:               new NativeAuthenticationServiceTest
0:               ( FILE, NATIVE, SYSTEM_WIDE, DONT_DISABLE_AUTH, ENABLE_JAVA_SECURITY )
1:               ).decorate( clientServer )
1:              );
1:         
1:         //
0:         // For testing subprotocols. Cleanup of support files is blocked by DERBY-5618.
1:         //
0:         if ( !onWindows() )
1:         {
1:             //
1:             // NATIVE authentication with credentials in read-only databases accessed via jar subprotocol
1:             //
1:             suite.addTest
1:                 (
1:                  (
1:                   new NativeAuthenticationServiceTest
0:                   ( JAR, NATIVE, SYSTEM_WIDE, DONT_DISABLE_AUTH, ENABLE_JAVA_SECURITY )
1:                   ).decorate( clientServer )
1:                  );
1:             suite.addTest
1:                 (
1:                  (
1:                   new NativeAuthenticationServiceTest
0:                   ( JAR, NATIVE, LOCAL, DONT_DISABLE_AUTH, ENABLE_JAVA_SECURITY )
1:                   ).decorate( clientServer )
1:                  );
1: 
1:             //
1:             // NATIVE authentication with credentials in read-only databases accessed via classpath subprotocol
1:             //
1:             suite.addTest
1:                 (
1:                  (
1:                   new NativeAuthenticationServiceTest
0:                   ( CLASSPATH, NATIVE, SYSTEM_WIDE, DONT_DISABLE_AUTH, DISABLE_JAVA_SECURITY )
1:                   ).decorate( clientServer )
1:                  );
1:             suite.addTest
1:                 (
1:                  (
1:                   new NativeAuthenticationServiceTest
0:                   ( CLASSPATH, NATIVE, LOCAL, DONT_DISABLE_AUTH, DISABLE_JAVA_SECURITY )
1:                   ).decorate( clientServer )
1:                  );
0:         }   // end if !onWindows()
/////////////////////////////////////////////////////////////////////////
1:         Properties  systemProperties = null;
1:         try {
1:             systemProperties = systemProperties( credentialsDBPhysicalName );
1:         } catch (Exception e) { printStackTrace( e ); }
1: 
1:         println( nameOfTest() );
1:         println( "    NativeAuthenticationServiceTest.decorate() systemProperties = " + systemProperties );
/////////////////////////////////////////////////////////////////////////
1:         result = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, TENTH_DB );
1:         result = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, ELEVENTH_DB );
/////////////////////////////////////////////////////////////////////////
0:         if ( credentialsViaSubprotocol() )
1:         {
1:             vetCredentialsViaSubprotocol();
1:         }
1:         else
1:         {
1:             vetCoreBehavior();
1:             vetSystemWideOperations();
1:             if ( !_nativeAuthentication ) { vetProviderChanges(); }
1:             // only run this for local authentication so that we don't have to shutdown
1:             // the system-wide credentials db. also only run this embedded so that we
1:             // don't have to deal with the problems of shutting down a database
1:             // across the network.
1:             if ( _localAuthentication && isEmbedded() ) { vetPasswordLifetime(); }
1:         }
1:      * Verify that credentials work when they are stored in a db accessed via
1:      * the jar or classpath subprotocols.
1:      * </p>
1:      */
1:     private void    vetCredentialsViaSubprotocol()   throws Exception
1:     {
1:         // create a new database
0:         Connection  grapeConn = openConnection( TENTH_DB, GRAPE_USER, true );
1:         String[][]  legalUsers = _localAuthentication ?
1:             new String[][] { { GRAPE_USER } } : new String[][] {};
1:         assertResults
1:             (
1:              grapeConn,
1:              "select username from sys.sysusers order by username",
1:              legalUsers,
1:              false
1:              );
1: 
1:         // Databases can't be created by users who don't have credentials stored in the credentials database
1:         Connection  walnutConn = getConnection
1:             ( true, true, ELEVENTH_DB, WALNUT_USER, INVALID_AUTHENTICATION );
1:     }
1:     
1:     /**
1:      * <p>
/////////////////////////////////////////////////////////////////////////
0:     private static  String  jarDBName() throws Exception
1:     private static  String  classpathDBName()   { return "classpath:nast"; }
commit:92a2169
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.ClasspathSetup;
0: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  GRAPE_USER = "GRAPE";   
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  NINTH_DB = "ninthDB";
1: 
1:     private static  final   String  NAST1_JAR_FILE = "nast1.jar";
1:     private static  final   String  NAST2_JAR_FILE = "nast2.jar";
1:     private static  final   String[]    SUPPORT_FILES_SOURCE =
1:     {
1:         "functionTests/tests/lang/" + NAST1_JAR_FILE,
1:         "functionTests/tests/lang/" + NAST1_JAR_FILE,
1:     };
1:     private static  final   String[]    SUPPORT_FILES_TARGET =
1:     {
1:         NAST1_JAR_FILE,
1:         NAST2_JAR_FILE,
1:     };
/////////////////////////////////////////////////////////////////////////
0:     private final   boolean _disableSecurityManager;
/////////////////////////////////////////////////////////////////////////
1:     private DatabaseChangeSetup _ninthDBSetup;
/////////////////////////////////////////////////////////////////////////
0:          boolean    turnOffAuthenticationAndAuthorization,
0:          boolean    disableSecurityManager
/////////////////////////////////////////////////////////////////////////
0:         _disableSecurityManager = disableSecurityManager;
/////////////////////////////////////////////////////////////////////////
0:         String  securityManager = _disableSecurityManager ?
0:             "SecurityManager OFF, " :
0:             "SecurityManager ON, ";
0:         return "[ " + authType + local + authOverrides + securityManager + embedded + " ]";
/////////////////////////////////////////////////////////////////////////
1:         //
0:         // Special version of the test which disables the security manager in order
0:         // to use the classpath subprotocol. We may be able to remove this special
0:         // case after DERBY-5615 is fixed.
1:         //
0:         suite.addTest( (new NativeAuthenticationServiceTest( false, false, false, true ) ).decorate( false ) );
1:         
0:     private boolean onWindows()
1:     {
0:         return getSystemProperty("os.name").startsWith("Windows");
1:     }
/////////////////////////////////////////////////////////////////////////
0:         suite.addTest( (new NativeAuthenticationServiceTest( false, false, false, false ) ).decorate( clientServer ) );
0:         suite.addTest( ( new NativeAuthenticationServiceTest( true, true, true, false ) ).decorate( clientServer ) );
0:         suite.addTest( ( new NativeAuthenticationServiceTest( true, true, false, false ) ).decorate( clientServer ) );
0:         suite.addTest( ( new NativeAuthenticationServiceTest( true, false, true, false ) ).decorate( clientServer ) );
0:         suite.addTest( ( new NativeAuthenticationServiceTest( true, false, false, false ) ).decorate( clientServer ) );
/////////////////////////////////////////////////////////////////////////
0:         if ( _disableSecurityManager ) { result = SecurityManagerSetup.noSecurityManager( result ); }
1: 
/////////////////////////////////////////////////////////////////////////
0:         // For testing subprotocols. Cleanup of support files is blocked by DERBY-5618.
1:         //
0:         if ( !onWindows() )
1:         {
1:             // Add the jar files needed for testing jar and classpath subprotocols.
1:             result = new SupportFilesSetup( result, SUPPORT_FILES_SOURCE, null, SUPPORT_FILES_TARGET, null );
1: 
1:             //
0:             // Add a jar file to the classpath so that we can test the classpath subprotocol.
1:             //
0:             File        currentDirectory = currentDirectory();
0:             File        readOnlyDirectory = new File( currentDirectory, SupportFilesSetup.EXTIN );
0:             File        nast2Jar = new File( readOnlyDirectory, NAST2_JAR_FILE );
1: 
1:             try {
0:                 result = new ClasspathSetup( result, nast2Jar.toURL() );
1:             }
0:             catch (Exception e) { printStackTrace( e ); }
1:         }
1:         
1:         //
/////////////////////////////////////////////////////////////////////////
1:         result = _ninthDBSetup = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, NINTH_DB, true );
/////////////////////////////////////////////////////////////////////////
1:             ( _nativeAuthentication, true, SECOND_DB, APPLE_USER, CREDENTIALS_DB_DOES_NOT_EXIST );
0:         Connection  sysadminConn = openConnection( CREDENTIALS_DB, DBO, true );
/////////////////////////////////////////////////////////////////////////
1:             ( _nativeAuthentication, true, THIRD_DB, WALNUT_USER, INVALID_AUTHENTICATION );
1:             secondDBConn = getConnection( false, true, SECOND_DB, APPLE_USER, null );
/////////////////////////////////////////////////////////////////////////
0:         Connection  seventhDBOConn = openConnection( SEVENTH_DB, DBO, true );
/////////////////////////////////////////////////////////////////////////
0:         Connection  seventhAppleConn = openConnection( SEVENTH_DB, APPLE_USER, true );
1:             ( _localAuthentication, true, SEVENTH_DB, WALNUT_USER, INVALID_AUTHENTICATION );
/////////////////////////////////////////////////////////////////////////
0:         Connection  eighthDBOConn = openConnection( EIGHTH_DB, DBO, true );
/////////////////////////////////////////////////////////////////////////
1:             ( _localAuthentication, true, EIGHTH_DB, BUILTIN_USER, INVALID_AUTHENTICATION );
0:             ( !_localAuthentication, true, EIGHTH_DB, APPLE_USER, INVALID_AUTHENTICATION );
1:         
1:         ///////////////////////////////////////////////////////////////////////////////////
1:         //
0:         // Vet databases accessed via subprotocols. Not run on Windows machines
0:         // because of DERBY-5618.
1:         //
1:         ///////////////////////////////////////////////////////////////////////////////////
1: 
0:         if ( !onWindows() )
1:         {
1:             // database accessed via jar subprotocol
0:             vetProtocol( jarDBName() );
1:         
1:             //
0:             // We only use the classpath subprotocol if we are not running under a security manager.
0:             // We may be able to remove that restriction after DERBY-5615 is fixed.
1:             //
0:             if ( _disableSecurityManager ) { vetProtocol( classpathDBName() ); }
1:         }
0:     private String  jarDBName() throws Exception
1:     {
0:         return "jar:(" + SupportFilesSetup.getReadOnlyFileName( NAST1_JAR_FILE  ) + ")nast";
1:     }
0:     private String  classpathDBName()   { return "classpath:nast"; }
1:     
/////////////////////////////////////////////////////////////////////////
1:      * Verify that databases in jar files and on the classpath can be opened
1:      * and respect NATIVE/LOCAL settings.
1:      * </p>
1:      */
1:     private void    vetProtocol( String protocolDBName ) throws Exception
1:     {
1:         ///////////////////////////////////////////////////////////////////////////////////
1:         //
1:         // Verify that regardless of any other settings, NATIVE authentication is on in the
1:         // database stored in a jar file or accessed over the classpath
1:         //
1:         ///////////////////////////////////////////////////////////////////////////////////
1: 
1:         Connection  grapeConn = getConnection( false, false, protocolDBName, GRAPE_USER, null );
1: 
1:         vetStatement( true, grapeConn, "select * from " + DBO + ".t", NO_COLUMN_PERMISSION );
1:         
1:         getConnection( true, false, protocolDBName, WALNUT_USER, INVALID_AUTHENTICATION );
1:     }
1: 
1:     /**
1:      * <p>
/////////////////////////////////////////////////////////////////////////
0:         Connection  dboConn = openConnection( SIXTH_DB, DBO, true );
/////////////////////////////////////////////////////////////////////////
0:         Connection  dboConn = openConnection( FOURTH_DB, dbo, true );
/////////////////////////////////////////////////////////////////////////
1:         Connection  appleConn = getConnection( true, true, FOURTH_DB, APPLE_USER, INVALID_AUTHENTICATION );
0:         Connection  pearConn = openConnection( FOURTH_DB, PEAR_USER, true );
/////////////////////////////////////////////////////////////////////////
0:         Connection  dboConn = openConnection( FIFTH_DB, DBO, true );
/////////////////////////////////////////////////////////////////////////
0:         dboConn = openConnection( FIFTH_DB, DBO, true );
1:         appleConn = getConnection( true, true, FIFTH_DB, APPLE_USER, INVALID_AUTHENTICATION );
/////////////////////////////////////////////////////////////////////////
0:         Connection  nonDBOConn = openConnection( CREDENTIALS_DB, APPLE_USER, true );
/////////////////////////////////////////////////////////////////////////
1:     private Connection  getConnection
1:         ( boolean shouldFail, boolean isLogicalName, String dbName, String user, String expectedSQLState )
0:         reportConnectionAttempt( dbName, user, isLogicalName );
0:             conn = openConnection( dbName, user, isLogicalName );
1:         catch (Throwable t)
0:             if ( shouldFail && (t instanceof SQLException) )   { assertSQLState( expectedSQLState, (SQLException) t ); }
1:             else
1:             {
1:                 printStackTrace( t );
1:                 fail( tagError( "Connection to " + dbName + " unexpectedly failed." ) );
1:             }
/////////////////////////////////////////////////////////////////////////
0:         reportConnectionAttempt( dbName, user, true );
0:         conn = openConnection( dbName, user, true );
/////////////////////////////////////////////////////////////////////////
0:     private void    reportConnectionAttempt( String dbName, String user, boolean isLogicalName )
0:         String  message = user + " attempting to get connection to database " + dbName;
1:         if ( isLogicalName ) { message = message + " aka " + getTestConfiguration().getPhysicalDatabaseName( dbName ) ; }
1:         println( message );
/////////////////////////////////////////////////////////////////////////
0:     private Connection  openConnection( String dbName, String user, boolean isLogicalName )
1:         String  password = getPassword( user );
1:         if ( isLogicalName )
1:         {
1:             return getTestConfiguration().openConnection( dbName, user, password );
1:         }
1:         else
1:         {
0:             return getTestConfiguration().openPhysicalConnection( dbName, user, password );
1:         }
commit:a3d7a74
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  BUILTIN_USER = "PECAN";
1: 
1:     private static  final   String  SEVENTH_DB = "seventhDB";
1:     private static  final   String  EIGHTH_DB = "eighthDB";
1:     private static  final   String  REQUIRE_AUTHENTICATION_PROPERTY = "derby.connection.requireAuthentication";
1:     private static  final   String  SQL_AUTHORIZATION_PROPERTY = "derby.database.sqlAuthorization";
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  BAD_PROPERTY_CHANGE = "XCY02";
/////////////////////////////////////////////////////////////////////////
1:     private final   boolean _turnOffAuthenticationAndAuthorization;
1:     private DatabaseChangeSetup _seventhDBSetup;
1:     private DatabaseChangeSetup _eighthDBSetup;
/////////////////////////////////////////////////////////////////////////
1:          boolean    localAuthentication,
0:          boolean    turnOffAuthenticationAndAuthorization
1:         _turnOffAuthenticationAndAuthorization = turnOffAuthenticationAndAuthorization;
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // This is to verify that NATIVE authentication trumps attempts
1:         // to disable these features at the system level.
1:         //
1:         if ( _turnOffAuthenticationAndAuthorization )
1:         {
1:             result.put( REQUIRE_AUTHENTICATION_PROPERTY, "false" );
1:             result.put( SQL_AUTHORIZATION_PROPERTY, "false" );
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         String  authOverrides = _turnOffAuthenticationAndAuthorization ?
1:             "Authentication/Authorization turned OFF, " :
1:             "Authentication/Authorization DEFAULT, ";
0:         return "[ " + authType + local + authOverrides + embedded + " ]";
/////////////////////////////////////////////////////////////////////////
0:         suite.addTest( (new NativeAuthenticationServiceTest( false, false, false ) ).decorate( clientServer ) );
0:         suite.addTest( ( new NativeAuthenticationServiceTest( true, true, true ) ).decorate( clientServer ) );
0:         suite.addTest( ( new NativeAuthenticationServiceTest( true, true, false ) ).decorate( clientServer ) );
0:         suite.addTest( ( new NativeAuthenticationServiceTest( true, false, true ) ).decorate( clientServer ) );
0:         suite.addTest( ( new NativeAuthenticationServiceTest( true, false, false ) ).decorate( clientServer ) );
/////////////////////////////////////////////////////////////////////////
1:         result = _seventhDBSetup = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, SEVENTH_DB, true );
1:         result = _eighthDBSetup = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, EIGHTH_DB, true );
/////////////////////////////////////////////////////////////////////////
1: 
1:         ///////////////////////////////////////////////////////////////////////////////////
1:         //
1:         // You can't turn off authentication or SQL authorization when NATIVE authentication
1:         // is set in the database. If NATIVE authentication is set at the system level,
1:         // you can still override it with database only properties.
1:         //
1:         ///////////////////////////////////////////////////////////////////////////////////
1: 
0:         Connection  seventhDBOConn = openConnection( SEVENTH_DB, DBO );
1: 
0:         addUser( seventhDBOConn, APPLE_USER );
1:         goodStatement( seventhDBOConn, "create table t1( a int )" );
1:         goodStatement( seventhDBOConn, "insert into t1( a ) values ( 10 )" );
1: 
1:         // at this point, you can't even force SQL authorization off on disk
1:         setDatabaseProperty
1:             ( _nativeAuthentication, seventhDBOConn, "derby.database.sqlAuthorization", "false", BAD_PROPERTY_CHANGE );
1: 
1:         // you can change these properties, but the change will be overridden by NATIVE authentication
1:         goodStatement
1:             ( seventhDBOConn, "call syscs_util.syscs_set_database_property( 'derby.connection.requireAuthentication', 'false' )" );
1:         goodStatement
1:             ( seventhDBOConn, "call syscs_util.syscs_set_database_property( 'derby.database.propertiesOnly', 'true' )" );
1: 
1:         //  now bring down the database so that the new property settings take effect
1:         _seventhDBSetup.getTestConfiguration().shutdownDatabase();
1: 
1:         // if NATIVE authentication is set in the database, then sql authorization prevents this legal user from viewing private data
0:         Connection  seventhAppleConn = openConnection( SEVENTH_DB, APPLE_USER );
1:         vetStatement( _localAuthentication, seventhAppleConn, "select * from " + DBO + ".t1", NO_COLUMN_PERMISSION );
1: 
1:         // if NATIVE authentication is set in the database, then authentication still prevents this user from logging in
1:         Connection  seventhWalnutConn = getConnection
0:             ( _localAuthentication, SEVENTH_DB, WALNUT_USER, INVALID_AUTHENTICATION );
1:         ///////////////////////////////////////////////////////////////////////////////////
1:         //
1:         // Using database only properties, you can override system-specified NATIVE
1:         // authentication as long as the NATIVE authentication is not LOCAL, i.e., not set
1:         // at the database level.
1:         //
1:         ///////////////////////////////////////////////////////////////////////////////////
1: 
0:         Connection  eighthDBOConn = openConnection( EIGHTH_DB, DBO );
1: 
0:         addUser( eighthDBOConn, APPLE_USER );
1: 
1:         // create BUILTIN credentials and set BULTIN authentication via database only properties
1:         setDatabaseProperty
1:             ( _localAuthentication, eighthDBOConn, "derby.authentication.provider", "BUILTIN", INVALID_PROVIDER_CHANGE );
1:         setDatabaseProperty( false, eighthDBOConn, "derby.connection.requireAuthentication", "true", null );
1:         setDatabaseProperty( false, eighthDBOConn, "derby.database.propertiesOnly", "true", null );
1:         addBuiltinUser( eighthDBOConn, DBO );
1:         addBuiltinUser( eighthDBOConn, BUILTIN_USER );
1: 
1:         //  now bring down the database so that the new property settings take effect
1:         _eighthDBSetup.getTestConfiguration().shutdownDatabase();
1: 
1:         // succeeds unless LOCAL authentication overrides database-specified BUILTIN authentication
1:         Connection  builtinConn = getConnection
0:             ( _localAuthentication, EIGHTH_DB, BUILTIN_USER, INVALID_AUTHENTICATION );
1: 
0:         // fails if we are using BUILTIN authentication because this user wasn't given BUILTIN credentials
0:         Connection  eightAppleConn = getConnection
0:             ( !_localAuthentication, EIGHTH_DB, APPLE_USER, INVALID_AUTHENTICATION );
1:     }
1:     private void    addBuiltinUser( Connection conn, String user )  throws Exception
1:     {
1:         String  key = "derby.user." + user;
1:         String  value = getPassword( user );
1:         
1:         setDatabaseProperty( false, conn, key, value, null );
/////////////////////////////////////////////////////////////////////////
1:     private void  setDatabaseProperty( boolean shouldFail, Connection conn, String key, String value, String expectedSQLState )
1:         throws Exception
1:     {
1:         if ( value == null ) { value = "cast ( null as varchar( 32672 ) )"; }
1:         else { value = "'" + value + "'"; }
1:         String  command = "call syscs_util.syscs_set_database_property( '" + key + "', " + value + " )";
1: 
1:         try {
1:             goodStatement( conn, command );
1: 
1:             if ( shouldFail )   { fail( tagError( "Property setting should have failed." ) ); }
1:         }
1:         catch (SQLException se)
1:         {
1:             if ( shouldFail )   { assertSQLState( expectedSQLState, se ); }
1:             else    { fail( tagError( "Property setting unexpectedly failed." ) );}
1:         }
1:     }
1: 
1:     private void  vetStatement( boolean shouldFail, Connection conn, String command, String expectedSQLState )
1:         throws Exception
1:     {
1:         try {
1:             goodStatement( conn, command );
1: 
1:             if ( shouldFail )   { fail( tagError( "Statement should have failed." ) ); }
1:         }
1:         catch (SQLException se)
1:         {
1:             if ( shouldFail )   { assertSQLState( expectedSQLState, se ); }
0:             else    { fail( tagError( "Statement unexpectedly failed." ) );}
1:         }
1:     }
1: 
commit:dc9cd0f
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import javax.sql.DataSource;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  BANANA_USER = "BANANA";   
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  SIXTH_DB = "sixthDB";
/////////////////////////////////////////////////////////////////////////
1:     private String  _credentialsDBPhysicalName;
1: 
1:     private DatabaseChangeSetup _sixthDBSetup;
1: 
1:     private String  _derbySystemHome;
1:     private String  _fullBackupDir;
/////////////////////////////////////////////////////////////////////////
1:     public void setUp() throws Exception
1:     {
1:         super.setUp();
1:         
1:         _derbySystemHome = getSystemProperty( "derby.system.home" );
1:         _fullBackupDir = _derbySystemHome + "/backupDir";
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         String      authenticationProvider;
1: 
0:         _credentialsDBPhysicalName = physicalDatabaseName;
1: 
1:         if ( !_nativeAuthentication )
1:         {
1:             authenticationProvider = "NONE";
1:         }
1:         else
1:         {
0:             authenticationProvider = "NATIVE:" + physicalDatabaseName;
1:             if ( _localAuthentication ) { authenticationProvider = authenticationProvider + ":LOCAL"; }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         println( "NativeAuthenticationServiceTest.decorate() systemProperties = " + systemProperties );
1:         result = new SystemPropertyTestSetup( result, systemProperties, true );
1:         
0:         // DERBY-5580: We should also shut down the engine before deleting
0:         // the database if we don't set any system properties.
1:         //result = new TestSetup(result) {
1:         //        protected void tearDown() {
1:         //            TestConfiguration.getCurrent().shutdownEngine();
1:         //        }
1:         //    };
/////////////////////////////////////////////////////////////////////////
1:         result = _sixthDBSetup = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, SIXTH_DB, true );
/////////////////////////////////////////////////////////////////////////
1:         println( "Credentials DB physical name = " + _credentialsDBPhysicalName );
1:         println( PROVIDER_PROPERTY + " = " + getSystemProperty( PROVIDER_PROPERTY ) );
0:         vetSystemWideOperations();
/////////////////////////////////////////////////////////////////////////
1:         addUser( sysadminConn, BANANA_USER );
/////////////////////////////////////////////////////////////////////////
0:         String[][]  legalUsers = _nativeAuthentication ?
0:             new String[][] { { APPLE_USER }, { BANANA_USER } , { DBO } } :
0:             new String[][] {  { APPLE_USER }, { BANANA_USER } };
/////////////////////////////////////////////////////////////////////////
1:      * The vetCoreBehavior() method verifies credentials-checking for the
1:      * following system-wide operations:
1:      * </p>
1:      *
1:      * <ul>
1:      * <li>Database creation.</li>
1:      * <li>Engine shutdown.</li>
1:      * <li>Server shutdown. The default credentials are embedded inside the NetworkServerControl
1:      * created by NetworkServerTestSetup.</li>
1:      * </ul>
1:      *
1:      * <p>
1:      * This method verifies credentials-checking for this additional
1:      * system-wide operation:
1:      * </p>
1:      *
1:      * <ul>
1:      * <li>Database restoration.</li>
1:      * </ul>
1:      */
1:     private void    vetSystemWideOperations()   throws Exception
1:     {
1:         // create a database which we will backup and restore
0:         Connection  dboConn = openConnection( SIXTH_DB, DBO );
1: 
1:         // add another user who can perform restores successfully
0:         addUser( dboConn, BANANA_USER );
1: 
1:         // add a table which we will backup and then drain. this is so that later on we can
1:         // verify that we really restored the database rather than just reconnected to the
1:         // original version.
1:         goodStatement( dboConn, "create table t( a int )" );
1:         goodStatement( dboConn, "insert into t( a ) values ( 1000 )" );
1:         if ( _nativeAuthentication)
1:         {
1:             goodStatement( dboConn, "grant select on table t to public" );
1:             goodStatement( dboConn, "grant insert on table t to public" );
1:         }
1:         goodStatement( dboConn, "call syscs_util.syscs_backup_database( '" + _fullBackupDir + "' )" );
1:         goodStatement( dboConn, "delete from t" );
1: 
1:         // this user is valid both in the system-wide credentials db and in the local db
1:         shutdownAndRestoreDB( true, BANANA_USER, null );
1: 
1:         //
1:         // If we are doing local authentication, then restoration will fail when we use
1:         // the credentials of a user who is in the system-wide SYSUSERS but not
1:         // in the SYSUSERS of the database being restored. Restoration involves two
1:         // authentication attempts: First we authenticate system-wide in order to
1:         // verify that it's ok to proceed with the restoration. After that, we attempt
1:         // to connect to the restored database. It is the authentication of the second
1:         // attempt which may fail here.
1:         //
1:         shutdownAndRestoreDB( !_localAuthentication, APPLE_USER, INVALID_AUTHENTICATION );
1:         
1:         // delete the backup directory
1:         assertDirectoryDeleted( new File( _fullBackupDir ) );
1:     }
1:     private void    shutdownAndRestoreDB( boolean shouldSucceed, String user, String expectedSQLState ) throws Exception
1:     {
1:         // shutdown the database. the restore will overwrite it.
1:         _sixthDBSetup.getTestConfiguration().shutdownDatabase();
1: 
1:         // the physical database name has some parent directories in it.
1:         // we need to strip these off because backup ignores them.
1:         String      dbName = _sixthDBSetup.physicalDatabaseName();
1:         int         slashIdx = dbName.lastIndexOf( "/" );
1:         if ( slashIdx >= 0 ) { dbName = dbName.substring( slashIdx + 1 ); }
1: 
1:         DataSource  ds = JDBCDataSource.getDataSourceLogical( SIXTH_DB );
1:         String          fullRestoreDir = _fullBackupDir + "/" + dbName;
1:         JDBCDataSource.setBeanProperty( ds, "connectionAttributes", "restoreFrom=" + fullRestoreDir );
1: 
1:         Connection  conn = null;
1: 
1:         try {
1:             conn = ds.getConnection( user, getPassword( user ) );
1: 
1:             if ( !shouldSucceed ) { fail( tagError( "Database restoration should have failed." ) ); }
1:         }
1:         catch (SQLException se)
1:         {
1:             if ( shouldSucceed ) { fail( tagError( "Database restoration unexpectedly failed." ) );}
1:             else    { assertSQLState( expectedSQLState, se ); }
1:         }
1: 
1:         if ( conn != null )
1:         {
1:             // verify that this is the version which was backed up, not the original
1:             assertResults
1:                 (
1:                  conn,
1:                  "select a from " + DBO + ".t",
1:                  new String[][] { { "1000" } },
1:                  false
1:                  );
1: 
1:             // add another tuple to distinguish the database from later attempts
1:             // to re-initialize it from the backup
1:             goodStatement( conn, "insert into " + DBO + ".t( a ) values ( 2000 )" );
1:         }
1:     }
1:     
1:     /**
1:      * <p>
/////////////////////////////////////////////////////////////////////////
0:         reportConnectionAttempt( dbName, user );
/////////////////////////////////////////////////////////////////////////
0:             else    { fail( tagError( "Connection to " + dbName + " unexpectedly failed." ) );}
/////////////////////////////////////////////////////////////////////////
0:         reportConnectionAttempt( dbName, user );
/////////////////////////////////////////////////////////////////////////
0:     private void    reportConnectionAttempt( String dbName, String user )
1:     {
0:         println
0:             ( user + " attempting to get connection to database " + dbName +
0:               " aka " + getTestConfiguration().getPhysicalDatabaseName( dbName ) );
1:     }
commit:49901a4
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLWarning;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  FIFTH_DB = "fifthDB";
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  PASSWORD_EXPIRING = "01J15";
1:     private static  final   String  BAD_PASSWORD_PROPERTY = "4251J";
/////////////////////////////////////////////////////////////////////////
1:     private DatabaseChangeSetup _fifthDBSetup;
/////////////////////////////////////////////////////////////////////////
1:             "LOCAL authentication ON, " :
1:             "LOCAL authentication OFF, ";
1:         String  embedded = isEmbedded() ?
1:             "Embedded" :
1:             "Client/Server";
0:         return "[ " + authType + local + embedded + " ]";
1: 
1:     /** Return true if the test is running embedded */
1:     public  boolean isEmbedded() { return getTestConfiguration().getJDBCClient().isEmbedded(); }
/////////////////////////////////////////////////////////////////////////
1:         result = _fifthDBSetup = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, FIFTH_DB, true );
/////////////////////////////////////////////////////////////////////////
0:         vetCoreBehavior();
0:         if ( !_nativeAuthentication ) { vetProviderChanges(); }
1: 
0:         // only run this for local authentication so that we don't have to shutdown
0:         // the system-wide credentials db. also only run this embedded so that we
0:         // don't have to deal with the problems of shutting down a database
0:         // across the network.
0:         if ( _localAuthentication && isEmbedded() ) { vetPasswordLifetime(); }
1:      * Verify the core behavior of NATIVE authentication.
1:     private void    vetCoreBehavior()   throws Exception
/////////////////////////////////////////////////////////////////////////
1:      * Try changing the value of the provider property on disk.
1:     private void    vetProviderChanges()   throws Exception
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Verify that password lifetimes are checked.
1:      * </p>
1:      */
1:     private void    vetPasswordLifetime()   throws Exception
1:     {
1:         // create another database
0:         Connection  dboConn = openConnection( FIFTH_DB, DBO );
1: 
1:         // add another legal user
1:         addUser( dboConn, APPLE_USER );
1: 
1:         Connection  appleConn = passwordExpiring( false, FIFTH_DB, APPLE_USER );
1: 
1:         // setup so that passwords are expiring after the db is rebooted.
1:         // shutdown the database in this test so that the new property settings take effect.
1:         goodStatement
1:             ( dboConn, "call syscs_util.syscs_set_database_property( 'derby.authentication.native.passwordLifetimeMillis', '86400000' )" );
1:         goodStatement
1:             ( dboConn, "call syscs_util.syscs_set_database_property( 'derby.authentication.native.passwordLifetimeThreshold', '2.0' )" );
1:         _fifthDBSetup.getTestConfiguration().shutdownDatabase();
1:  
1:         // password should be expiring
1:         dboConn = passwordExpiring( true, FIFTH_DB, DBO );
1:         appleConn = passwordExpiring( true, FIFTH_DB, APPLE_USER );
1:         
1:         // setup so that passwords have expired after we reboot the database.
1:         // shutdown the database so that the new property settings take effect.
1:         goodStatement
1:             ( dboConn, "call syscs_util.syscs_set_database_property( 'derby.authentication.native.passwordLifetimeMillis', '1' )" );
1:         _fifthDBSetup.getTestConfiguration().shutdownDatabase();
1: 
1:         // the DBO's password does not expire
0:         dboConn = openConnection( FIFTH_DB, DBO );
1: 
1:         // but the other user's password has expired
0:         appleConn = getConnection( true, FIFTH_DB, APPLE_USER, INVALID_AUTHENTICATION );
1:         
1:         // setup so that passwords don't expire after we reboot the database.
1:         // shutdown the database so that the new property settings take effect.
1:         goodStatement
1:             ( dboConn, "call syscs_util.syscs_set_database_property( 'derby.authentication.native.passwordLifetimeMillis', '0' )" );
1:         _fifthDBSetup.getTestConfiguration().shutdownDatabase();
1: 
1:         // passwords should NOT be expiring or expired
1:         dboConn = passwordExpiring( false, FIFTH_DB, DBO );
1:         appleConn = passwordExpiring( false, FIFTH_DB, APPLE_USER );
1: 
1:         // check that invalid property settings are caught
1:         expectExecutionError
1:             (
1:              dboConn, BAD_PASSWORD_PROPERTY,
1:              "call syscs_util.syscs_set_database_property( 'derby.authentication.native.passwordLifetimeMillis', 'rabbit' )"
1:              );
1:         expectExecutionError
1:             (
1:              dboConn, BAD_PASSWORD_PROPERTY,
1:              "call syscs_util.syscs_set_database_property( 'derby.authentication.native.passwordLifetimeThreshold', '-1' )"
1:              );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     // connect but expect a warning that the password is about to expire
1:     private Connection  passwordExpiring( boolean expiring, String dbName, String user )
1:         throws Exception
1:     {
1:         Connection  conn = null;
1: 
0:         println( user + " attempting to get connection to database " + dbName );
1: 
0:         conn = openConnection( dbName, user );
1: 
1:         SQLWarning  warning = conn.getWarnings();
1: 
1:         if ( expiring )
1:         {
1:             assertNotNull( tagError( "Should have seen a warning" ), warning );
0:             assertSQLState( PASSWORD_EXPIRING, warning );
1:         }
1:         else
1:         {
1:             assertNull( tagError( "Should not have seen a warning" ), warning );
1:         }
1: 
1: 
1:         return conn;
1:     }
1: 
commit:c0399dc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.DatabaseChangeSetup;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  ORANGE_USER = "ORANGE";   
1:     private static  final   String  FOURTH_DB = "fourthDB";
1:     private static  final   String  DBO_ONLY_OPERATION = "4251D";
1:     private static  final   String  INVALID_PROVIDER_CHANGE = "XCY05";
1:     private static  final   String  CANT_DROP_DBO = "4251F";
1:     private static  final   String  NO_COLUMN_PERMISSION = "42502";
/////////////////////////////////////////////////////////////////////////
1:     private DatabaseChangeSetup _fourthDBSetup;
1: 
/////////////////////////////////////////////////////////////////////////
0:         suite.addTest( (new NativeAuthenticationServiceTest( false, false ) ).decorate( clientServer ) );
0:         suite.addTest( ( new NativeAuthenticationServiceTest( true, true ) ).decorate( clientServer ) );
0:         suite.addTest( ( new NativeAuthenticationServiceTest( true, false ) ).decorate( clientServer ) );
/////////////////////////////////////////////////////////////////////////
0:     private Test    decorate( boolean clientServer )
1:         Test        result = this;
/////////////////////////////////////////////////////////////////////////
0:         Properties  systemProperties = systemProperties( credentialsDBPhysicalName );
/////////////////////////////////////////////////////////////////////////
1:         result = _fourthDBSetup = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, FOURTH_DB, true );
/////////////////////////////////////////////////////////////////////////
0:         vetForAllConfigurations();
1: 
0:         if ( !_nativeAuthentication ) { vetUnauthenticatedConfiguration(); }
1:     }
1: 
1:     /**
1:      * <p>
0:      * These tests are run for all configurations.
1:      * </p>
1:      */
0:     private void    vetForAllConfigurations()   throws Exception
1:     {
1:         Connection  secondDBConn = getConnection
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         // there should be no need to explicitly set the sql authorization property
1:         String[][]  sqlAuthorization = new String[][] { { null } };
/////////////////////////////////////////////////////////////////////////
1:         vetSQLAuthorizationOn();
/////////////////////////////////////////////////////////////////////////
1:         Connection  thirdDBConn = getConnection
0:             secondDBConn = getConnection( false, SECOND_DB, APPLE_USER, null );
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * These tests are run only if authentication is turned off.
1:      * </p>
1:      */
0:     private void    vetUnauthenticatedConfiguration()   throws Exception
1:     {
1:         // create an empty database without authentication turned on
1:         String          dbo = ORANGE_USER;
0:         Connection  dboConn = openConnection( FOURTH_DB, dbo );
1: 
0:         addUser( dboConn, PEAR_USER );
1: 
1:         // NATIVE authentication isn't on, so you can store oddball values for the authentication provider
1:         goodStatement
1:             ( dboConn, "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'com.acme.AcmeAuthenticator' )" );
1: 
1:         // can't turn on NATIVE authentication until you have stored credentials for the dbo
1:         expectExecutionError
1:             (
1:              dboConn, INVALID_PROVIDER_CHANGE,
1:              "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'NATIVE::LOCAL' )"
1:              );
1:  
1:         // store credentials for the DBO
1:         addUser( dboConn, dbo );
1: 
1:         // verify that you can't drop the dbo
1:         expectExecutionError
1:             (
1:              dboConn, CANT_DROP_DBO,
1:              "call syscs_util.syscs_drop_user( '" + dbo + "' )"
1:              );
1:         String[][]  legalUsers = new String[][] { { dbo }, { PEAR_USER } };
1:         assertResults
1:             (
1:              dboConn,
1:              "select username from sys.sysusers order by username",
1:              legalUsers,
1:              false
1:              );
1:         
0:         // NATIVE::LOCAL is the only legal value which the authentication provider property can take on disk
1:         expectExecutionError
1:             (
1:              dboConn, INVALID_PROVIDER_CHANGE,
0:              "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'NATIVE:db:LOCAL' )"
1:              );
1:         expectExecutionError
1:             (
1:              dboConn, INVALID_PROVIDER_CHANGE,
0:              "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'NATIVE:LOCAL' )"
1:              );
1:  
0:         // now turn on NATIVE + LOCAL authentication
0:         goodStatement( dboConn, "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'NATIVE::LOCAL' )" );
1: 
1:         // once set, you can't unset or change it
1:         expectExecutionError
1:             (
1:              dboConn, INVALID_PROVIDER_CHANGE,
1:              "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'NATIVE::LOCAL' )"
1:              );
1:         expectExecutionError
1:             (
1:              dboConn, INVALID_PROVIDER_CHANGE,
1:              "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', null )"
1:              );
1:         expectExecutionError
1:             (
1:              dboConn, INVALID_PROVIDER_CHANGE,
1:              "call syscs_util.syscs_set_database_property( 'derby.authentication.provider', 'com.acme.AcmeAuthenticator' )"
1:              );
1: 
1:         // verify that the authentication provider property has the value we expect
1:         String[][]  authenticationProvider = new String[][] { { "NATIVE::LOCAL" } };
1:         assertResults
1:             (
1:              dboConn,
1:              "values ( syscs_util.syscs_get_database_property( 'derby.authentication.provider' ) )",
1:              authenticationProvider,
1:              false
1:              );
1:         
1:         // create a table for a simple authorization check later on
1:         goodStatement( dboConn, "create table t( a int )" );
1: 
1:         // shutdown this database so that the on-disk properties will take effect on reboot
1:         _fourthDBSetup.getTestConfiguration().shutdownDatabase();
1:         
1:         // can't connect to the database with credentials which aren't stored in it.
0:         Connection  appleConn = getConnection( true, FOURTH_DB, APPLE_USER, INVALID_AUTHENTICATION );
1: 
1:         // ...but these credentials work
0:         Connection  pearConn = openConnection( FOURTH_DB, PEAR_USER );
1: 
1:         // should get authorization errors trying to select from a table private to the DBO
1:         // and from trying to view the credentials table
1:         expectExecutionError( pearConn, NO_COLUMN_PERMISSION, "select * from " + dbo + ".t" );
1:         expectCompilationError( pearConn, DBO_ONLY_OPERATION, "select username from sys.sysusers" );
1:         
1:     }
1:     
1:     private void    vetSQLAuthorizationOn() throws Exception
1:     {
0:         Connection  nonDBOConn = openConnection( CREDENTIALS_DB, APPLE_USER );
1:         String          query = "select username from sys.sysusers" ;
1: 
1:         try {
1:             chattyPrepare( nonDBOConn, query );
1: 
1:             if ( _nativeAuthentication ) { fail( "SQL Authorization not on!" ); }
1:         }
1:         catch (SQLException se)
1:         {
1:             if ( _nativeAuthentication )
1:             {
1:                 assertSQLState( DBO_ONLY_OPERATION, se );
1:             }
0:             else
1:             {
1:                 fail( "Caught unexpected SQLException: " + se.getSQLState() + ": " + se.getMessage() );
1:             }
1:         }
1:     }
1:     
0:     private Connection  getConnection( boolean shouldFail, String dbName, String user, String expectedSQLState )
0:         println( user + " attempting to get connection to database " + dbName );
commit:5107349
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.NativeAuthenticationServiceTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.Connection;
1: import java.sql.SQLException;
1: import java.util.Properties;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.DatabaseChangeSetup;
1: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1: 
1: /**
1:  * <p>
1:  * Tests for the NATIVE authentication service introduced by DERBY-866.
1:  * </p>
1:  */
1: public class NativeAuthenticationServiceTest extends GeneratedColumnsHelper
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     // fruits are legal users. nuts are not
1:     private static  final   String  DBO = "KIWI";   
1:     private static  final   String  APPLE_USER = "APPLE";   
1:     private static  final   String  PEAR_USER = "PEAR";   
1: 
1:     private static  final   String  WALNUT_USER = "WALNUT";
1: 
1:     private static  final   String  CREDENTIALS_DB = "credDB";
1:     private static  final   String  SECOND_DB = "secondDB";
1:     private static  final   String  THIRD_DB = "thirdDB";
1: 
1:     private static  final   String  PROVIDER_PROPERTY = "derby.authentication.provider";
1: 
1:     private static  final   String  CREDENTIALS_DB_DOES_NOT_EXIST = "4251I";
1:     private static  final   String  INVALID_AUTHENTICATION = "08004";
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private final   boolean _nativeAuthentication;
1:     private final   boolean _localAuthentication;
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     public  NativeAuthenticationServiceTest
1:         (
1:          boolean    nativeAuthentication,
0:          boolean    localAuthentication
1:          )
1:     {
1:         super( "testAll" );
1: 
1:         _nativeAuthentication = nativeAuthentication;
1:         _localAuthentication = localAuthentication;
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // SETUP BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Return the system properties to be used in a particular test run.
1:      * </p>
1:      */
1:     private Properties  systemProperties( String physicalDatabaseName )
1:     {
0:         if ( !_nativeAuthentication ) { return null; }
1: 
0:         String  authenticationProvider = "NATIVE:" + physicalDatabaseName;
0:         if ( _localAuthentication ) { authenticationProvider = authenticationProvider + ":LOCAL"; }
1: 
1:         Properties  result = new Properties();
1:         result.put( PROVIDER_PROPERTY, authenticationProvider );
1: 
1:         return result;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Construct the name of this test (useful for error messages).
1:      * </p>
1:      */
1:     private String  nameOfTest()
1:     {
1:         String  authType = _nativeAuthentication ?
1:             "NATIVE authentication on, " :
1:             "Authentication off, ";
1:         String  local = _localAuthentication ?
0:             "LOCAL authentication ON" :
0:             "LOCAL authentication OFF";
1: 
0:         return "[ " + authType + local + " ]";
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // JUnit BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Construct top level suite in this JUnit test
1:      */
0:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite();
1: 
1:         suite.addTest( allConfigurations( false ) );
1:         if ( !JDBC.vmSupportsJSR169() ) { suite.addTest( allConfigurations( true ) ); }
1: 
1:         return suite;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Create a suite of all test configurations.
1:      * </p>
1:      */
0:     private static  Test   allConfigurations( boolean clientServer )
1:     {
0:         TestSuite suite = new TestSuite();
1: 
0:         suite.addTest( decorate( new NativeAuthenticationServiceTest( false, false ), clientServer ) );
0:         suite.addTest( decorate( new NativeAuthenticationServiceTest( true, true ), clientServer ) );
0:         suite.addTest( decorate( new NativeAuthenticationServiceTest( true, false ), clientServer ) );
1: 
1:         return suite;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Wrap base test with standard decorators in order to setup system
1:      * properties and allow for the creation of multiple databases with
1:      * stored properties that can't be removed at tearDown time.
1:      * </p>
1:      */
0:     private static  Test    decorate( NativeAuthenticationServiceTest nast, boolean clientServer )
1:     {
1:         String      credentialsDBPhysicalName = TestConfiguration.generateUniqueDatabaseName();
1:         
0:         Test        result = nast;
1: 
1:         //
1:         // Putting the clientServer decorator on the inside allows the server-side
1:         // embedded driver to be re-registered after engine shutdown. If you put
1:         // this decorator outside the SystemProperty decorator, then engine shutdown
1:         // unregisters the server-side embedded driver and it can't be found by
1:         // the next test.
1:         //
1:         if ( clientServer ) { result = TestConfiguration.clientServerDecorator( result ); }
1:         
1:         //
1:         // Turn on the property which enables NATIVE authentication. This will trigger
1:         // an engine shutdown at the end of the test. We want to shutdown the engine
1:         // before deleting the physical databases. This is because we need one of the
1:         // databases (the credentials db) in order to authenticate engine shutdown.
1:         //
0:         Properties  systemProperties = nast.systemProperties( credentialsDBPhysicalName );
0:         if ( systemProperties != null )
1:         {
0:             result = new SystemPropertyTestSetup( result, systemProperties, true );
1:         }
1:         
1:         //
1:         // Register temporary databases, where the test will do its work.
1:         // We can't use the default, re-usable database because NATIVE authentication stores
1:         // persistent properties which cannot be turned off.
1:         //
1:         result = TestConfiguration.additionalDatabaseDecoratorNoShutdown
1:             ( result, CREDENTIALS_DB, credentialsDBPhysicalName );
1:         result = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, SECOND_DB );
1:         result = TestConfiguration.additionalDatabaseDecoratorNoShutdown( result, THIRD_DB );
1: 
1:         result = TestConfiguration.changeUserDecorator( result, DBO, getPassword( DBO ) );
1:         
1:         return result;
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // TESTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Entry point for tests.
1:      * </p>
1:      */
1:     public  void    testAll()   throws Exception
1:     {
1:         println( nameOfTest() );
1: 
1:         // can't create any database until the credentials db has been created
0:         Connection  secondDBConn = createDB
0:             ( _nativeAuthentication, SECOND_DB, APPLE_USER, CREDENTIALS_DB_DOES_NOT_EXIST );
1: 
1:         // create the credentials database
0:         Connection  sysadminConn = openConnection( CREDENTIALS_DB, DBO );
1: 
1:         // add another legal user
1:         addUser( sysadminConn, APPLE_USER );
1: 
1:         //
1:         // Creating the credentials db should have stored the following information in it:
1:         //
1:         // 1) The DBO's credentials should have been stored in SYSUSERS.
1:         // 2) The authentication provider should have been set to NATIVE::LOCAL
0:         // 3) SQL authorization should have been turned on.
1:         //
0:         String[][]  legalUsers = _nativeAuthentication ? new String[][] { { APPLE_USER }, { DBO } } : new String[][] {  { APPLE_USER } };
1:         assertResults
1:             (
1:              sysadminConn,
1:              "select username from sys.sysusers order by username",
1:              legalUsers,
1:              false
1:              );
0:         String[][]  authenticationProvider = _nativeAuthentication ? new String[][] { { "NATIVE::LOCAL" } } : new String[][] { { null } };
1:         assertResults
1:             (
1:              sysadminConn,
1:              "values ( syscs_util.syscs_get_database_property( 'derby.authentication.provider' ) )",
1:              authenticationProvider,
1:              false
1:              );
0:         String[][]  sqlAuthorization = _nativeAuthentication ? new String[][] { { "true" } } : new String[][] { { null } };
1:         assertResults
1:             (
1:              sysadminConn,
1:              "values ( syscs_util.syscs_get_database_property( 'derby.database.sqlAuthorization' ) )",
1:              sqlAuthorization,
1:              false
1:              );
1: 
1:         // Sanity-check that the creator of the credentials db is the DBO
1:         String[][]   dboName = new String[][] { { DBO } };
1:         assertResults
1:             (
1:              sysadminConn,
1:              "select authorizationID from sys.sysschemas where schemaName = 'SYS'",
1:              dboName,
1:              false
1:              );
1: 
1:         // Databases can't be created by users who don't have credentials stored in the credentials database
0:         Connection  thirdDBConn = createDB
0:             ( _nativeAuthentication, THIRD_DB, WALNUT_USER, INVALID_AUTHENTICATION );
1: 
1:         // Now let the other valid user create a database
1:         if ( secondDBConn == null )
1:         {
0:             secondDBConn = createDB( false, SECOND_DB, APPLE_USER, null );
1:         }
1: 
1:         // verify that the other valid user is the dbo in the database he just created
1:         assertResults
1:             (
1:              secondDBConn,
1:              "select authorizationID from sys.sysschemas where schemaName = 'SYS'",
1:              new String[][] { { APPLE_USER } },
1:              false
1:              );
1: 
1:         // NATIVE authentication turns on SQL authorization in the second database
1:         assertResults
1:             (
1:              secondDBConn,
1:              "values ( syscs_util.syscs_get_database_property( 'derby.database.sqlAuthorization' ) )",
1:              sqlAuthorization,
1:              false
1:              );
1: 
1:         //
1:         // If LOCAL authentication was specified...
1:         //
1:         // 1) It will be turned on in the second database too.
1:         // 2) The other legal user's credentials (as the database dbo) will be stored.
1:         //
1:         authenticationProvider = _localAuthentication ? new String[][] { { "NATIVE::LOCAL" } } : new String[][] { { null } };
1:         assertResults
1:             (
1:              secondDBConn,
1:              "values ( syscs_util.syscs_get_database_property( 'derby.authentication.provider' ) )",
1:              authenticationProvider,
1:              false
1:              );
1:         legalUsers = _localAuthentication ? new String[][] { { APPLE_USER } } : new String[][] {};
1:         assertResults
1:             (
1:              secondDBConn,
1:              "select username from sys.sysusers order by username",
1:              legalUsers,
1:              false
1:              );
1:         
1:     }
1: 
0:     private Connection  createDB( boolean shouldFail, String dbName, String user, String expectedSQLState )
1:         throws Exception
1:     {
1:         Connection  conn = null;
1: 
0:         println( user + " attempting to create database " + dbName );
1: 
0:         try {
0:             conn = openConnection( dbName, user );
1: 
1:             if ( shouldFail )   { fail( tagError( "Connection to " + dbName + " should have failed." ) ); }
1:         }
0:         catch (SQLException se)
1:         {
0:             if ( shouldFail )   { assertSQLState( expectedSQLState, se ); }
0:             else    { fail( tagError( "Connection to " + dbName + " unexpectedly succeeded." ) );}
1:         }
1: 
1:         return conn;
1:     }
1: 
1:     private void    addUser( Connection conn, String user ) throws Exception
1:     {
0:         String  password = getPassword( user );
1:         String  statement = "call syscs_util.syscs_create_user( '" + user + "', '" + password + "' )";
1:         
0:         goodStatement( conn, statement );
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /** Open a connection to a database using the supplied credentials */
0:     private Connection  openConnection( String logicalDBName, String user )
1:         throws SQLException
1:     {
0:         return getTestConfiguration().openConnection( logicalDBName, user, getPassword( user ) );
1:     }
1:     
1:     /** Get the password for a user */
1:     private static  String  getPassword( String user ) { return user + "_password"; }
1: 
1:     /** Tag an error with the name of the test configuration */
1:     private String  tagError( String text ) { return nameOfTest() + ": " + text; }
1: 
1: }
============================================================================