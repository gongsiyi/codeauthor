1:782dbe1: /*
7:7c52163: 
1:782dbe1:    Derby - Class org.apache.derbyTesting.functionTests.tests.memory.TriggerTests
1:7c52163: 
1:782dbe1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:782dbe1:    contributor license agreements.  See the NOTICE file distributed with
1:782dbe1:    this work for additional information regarding copyright ownership.
1:782dbe1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:782dbe1:    (the "License"); you may not use this file except in compliance with
1:782dbe1:    the License.  You may obtain a copy of the License at
1:7c52163: 
1:782dbe1:       http://www.apache.org/licenses/LICENSE-2.0
1:7c52163: 
1:782dbe1:    Unless required by applicable law or agreed to in writing, software
1:782dbe1:    distributed under the License is distributed on an "AS IS" BASIS,
1:782dbe1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:782dbe1:    See the License for the specific language governing permissions and
1:782dbe1:    limitations under the License.
1:7c52163: 
1:7c52163:  */
1:7c52163: 
1:7c52163: package org.apache.derbyTesting.functionTests.tests.memory;
1:7c52163: 
1:7c52163: import java.sql.*;
1:7c52163: import java.util.Properties;
1:7c52163: 
1:7c52163: import junit.framework.Test;
1:7c52163: 
1:7c52163: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1:7c52163: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:7c52163: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:7c52163: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1:7c52163: import org.apache.derbyTesting.junit.TestConfiguration;
1:c4728eb: import org.apache.derbyTesting.junit.JDBC;
1:7c52163: 
1:7c52163: /**
1:7c52163:  * Repro for DERBY-1482:
1:7c52163:  * Update triggers on tables with blob columns stream blobs
1:7c52163:  * into memory even when the blobs are not referenced/accessed.
1:782dbe1:  */
1:7c52163: public class TriggerTests extends BaseJDBCTestCase {
1:a6f9586: 
1:c4728eb: 	final int lobsize = 50000*1024;
1:a6f9586: 	boolean testWithLargeDataInLOB = true;
1:d9d1bc8: 	boolean isDerby1482Fixed = true;
1:c1193bf: 
1:7c52163: 	/**
1:7c52163: 	 * Insert trigger tests
1:7c52163: 	 * ****************
1:7c52163: 	 * 1)test1InsertAfterTrigger
1:7c52163: 	 * 	This test creates an AFTER INSERT trigger which inserts non-lob
2:7c52163: 	 * columns into another table.
1:7c52163: 	 * ****************
1:7c52163: 	 * 2)test1InsertAfterTriggerStoredProc
1:7c52163: 	 * 	The test case is exactly like test1InsertAfterTrigger except that the
1:7c52163: 	 * trigger action is a stored procedure call. The work done by the trigger
1:7c52163: 	 * action SQL in test1InsertAfterTrigger gets done inside the stored procedure
1:7c52163: 	 * for this test.
1:7c52163: 	 * ****************
1:7c52163: 	 * 3)test1InsertBeforeTrigger
1:7c52163: 	 * 	This test creates a BEFORE INSERT trigger which selects 
1:7c52163: 	 * columns from another table using "new" non-lob column for 
1:7c52163: 	 * join clause. 
1:7c52163: 	 * ****************
1:7c52163: 	 * 4)test1InsertBeforeTriggerStoredProc
1:7c52163: 	 * 	The test case is exactly like test1InsertBeforeTrigger except that the
1:7c52163: 	 * trigger action is a stored procedure call. The work done by the trigger
1:7c52163: 	 * action SQL in test1InsertBeforeTrigger gets done inside the stored procedure
1:7c52163: 	 * for this test.
1:7c52163: 	 * ****************
1:7c52163: 	 * Can't write stored procedure calls for trigger actions for test2
1:7c52163: 	 * because I will need to pass LOBs as parameters to the stored
1:7c52163: 	 * procedure which is not possible at this point.
1:7c52163: 	 * ****************
1:7c52163: 	 * 5)test2InsertAfterTriggerAccessLOB
1:7c52163: 	 * 	This test creates an AFTER INSERT trigger which in it's trigger action
1:7c52163: 	 * inserts lob columns from triggering table into another table. So, this
1:7c52163: 	 * test does access the LOB from the triggering table inside the trigger
1:7c52163: 	 * action. 
1:7c52163: 	 * ****************
1:7c52163: 	 * 6)test2InsertAfterTriggerUpdatedLOB
1:7c52163: 	 * 	This test creates an AFTER INSERT trigger which in it's trigger action
1:7c52163: 	 * updates a lob column from the row just inserted. So, this test does
1:7c52163: 	 * update the LOB from the triggering table inside the trigger
1:7c52163: 	 * action. 
1:7c52163: 	 * ****************
1:7c52163: 	 * 7)test2InsertBeforeTriggerAccessLOB
1:7c52163: 	 * 	This test creates a BEFORE INSERT trigger which selects "new"
1:7c52163: 	 * lob column from just inserted row. This test does access the
1:7c52163: 	 * LOB.
1:7c52163: 	 * ****************
1:7c52163: 	 * 8)test5InsertAfterTriggerNoReferencingClause
1:7c52163: 	 * 	This test creates an AFTER INSERT trigger but has not REFERENCING
1:7c52163: 	 * clause, meaning that before and after values are not available to
1:7c52163: 	 * the trigger action. 
1:7c52163: 	 * ****************
1:7c52163: 	 * 9)test5InsertBeforeTriggerNoReferencingClause
1:7c52163: 	 * 	This test creates an BEFORE INSERT trigger but has no REFERENCING
1:7c52163: 	 * clause, meaning that before and after values are not available to
1:7c52163: 	 * the trigger action.
1:7c52163: 	 * ****************
1:a6f9586: 	 * 
1:a6f9586: 	 * 
1:7c52163: 	 * 
1:7c52163: 	 * 
1:7c52163: 	 * 
1:7c52163: 	 * Delete trigger tests
1:7c52163: 	 * ****************
1:7c52163: 	 * 1)test1DeleteAfterTrigger
1:7c52163: 	 * 	This test creates an AFTER DELETE trigger which delets from another
1:7c52163: 	 * table using non-lob from the triggering table in the where clause.
1:7c52163: 	 * ****************
1:7c52163: 	 * 2)test1DeleteAfterTriggerStoredProc
1:7c52163: 	 * 	The test case is exactly like test1DeleteAfterTrigger except that the
1:7c52163: 	 * trigger action is a stored procedure call. The work done by the trigger
1:7c52163: 	 * action SQL in test1DeleteAfterTrigger gets done inside the stored procedure
1:7c52163: 	 * for this test.
1:7c52163: 	 * ****************
1:7c52163: 	 * 3)test1DeleteBeforeTrigger
1:7c52163: 	 * 	This test creates a BEFORE DELETE trigger which selects 
1:7c52163: 	 * columns from another table using "new" non-lob column for 
1:7c52163: 	 * join clause.
1:7c52163: 	 * ****************
1:7c52163: 	 * 4)test1DeleteBeforeTriggerStoredProc
1:7c52163: 	 * 	The test case is exactly like test1DeleteBeforeTrigger except that the
1:7c52163: 	 * trigger action is a stored procedure call. The work done by the trigger
1:7c52163: 	 * action SQL in test1DeleteBeforeTrigger gets done inside the stored procedure
1:7c52163: 	 * for this test.
1:7c52163: 	 * ****************
1:7c52163: 	 * Can't write stored procedure calls for trigger actions for test2
1:7c52163: 	 * because I will need to pass LOBs as parameters to the stored
1:7c52163: 	 * procedure which is not possible at this point.
1:7c52163: 	 * ****************
1:7c52163: 	 * 5)test2DeleteAfterTriggerAccessLOB
1:7c52163: 	 * 	This test creates an AFTER DELETE trigger which in it's trigger action
1:7c52163: 	 * deletes row from another table using triggering table's "new" LOB value
1:7c52163: 	 * in the join clause. So, this test does access the LOB from the 
1:7c52163: 	 * triggering table inside the trigger action.
1:7c52163: 	 * ****************
1:7c52163: 	 * ****************
1:7c52163: 	 * 6)test2DeleteBeforeTriggerAccessLOB
1:7c52163: 	 * 	This test creates a BEFORE DELETE trigger which selects "old"
1:7c52163: 	 * lob column from just deleted row. This test does access the
1:7c52163: 	 * LOB.
1:7c52163: 	 * ****************
1:7c52163: 	 * 7)test5DeleteAfterTriggerNoReferencingClause
1:7c52163: 	 * 	This test creates an AFTER DELETE trigger but has no REFERENCING
1:7c52163: 	 * clause, meaning that before and after values are not available to
1:7c52163: 	 * the trigger action.
1:7c52163: 	 * ****************
1:7c52163: 	 * 8)test5DeleteBeforeTriggerNoReferencingClause
1:7c52163: 	 * 	This test creates an BEFORE DELETE trigger but has no REFERENCING
1:7c52163: 	 * clause, meaning that before and after values are not available to
1:7c52163: 	 * the trigger action. 
1:7c52163: 	 * ****************
1:a6f9586: 	 * 
1:a6f9586: 	 * 
1:a6f9586: 	 * 
1:7c52163: 	 * 
1:7c52163: 	 * Update trigger tests
1:7c52163: 	 * ****************
1:7c52163: 	 * 1)test1UpdateAfterTrigger -
1:7c52163: 	 * 	This test creates an AFTER UPDATE trigger which is declared on a
1:7c52163: 	 * non-LOB column. The trigger action does not access the LOB column.
1:7c52163: 	 * ****************
1:7c52163: 	 * 2)test1UpdateAfterTriggerStoredProc
1:7c52163: 	 * 	The test case is exactly like test1UpdateAfterTrigger except that the
1:7c52163: 	 * trigger action is a stored procedure call. The work done by the trigger
1:7c52163: 	 * action SQL in test1UpdateAfterTrigger gets done inside the stored procedure
1:7c52163: 	 * for this test.
1:7c52163: 	 * ****************
1:7c52163: 	 * 3)test1UpdateBeforeTrigger
1:7c52163: 	 * 	This test creates a BEFORE UPDATE trigger which is declared
1:7c52163: 	 * on a non-LOB column. The trigger action selects columns from 
1:7c52163: 	 * another table using "new" non-lob column for join clause. 
1:7c52163: 	 * ****************
1:7c52163: 	 * 4)test1UpdateBeforeTriggerStoredProc
1:7c52163: 	 * 	The test case is exactly like test1UpdateBeforeTrigger except that the
1:7c52163: 	 * trigger action is a stored procedure call. The work done by the trigger
1:7c52163: 	 * action SQL in test1UpdateBeforeTrigger gets done inside the stored procedure
1:7c52163: 	 * for this test.
1:7c52163: 	 * ****************
1:7c52163: 	 * Can't write stored procedure calls for trigger actions for test2
1:7c52163: 	 * because I will need to pass LOBs as parameters to the stored
1:7c52163: 	 * procedure which is not possible at this point.
1:7c52163: 	 * ****************
1:7c52163: 	 * 5)test2UpdateAfterTriggerAccessLOB
1:7c52163: 	 * 	The after update trigger on non-LOB column but the LOB column is
1:7c52163: 	 * referenced in the trigger action. So, this test does access the LOB 
1:7c52163: 	 * from the triggering table inside the trigger action. 
1:7c52163: 	 * ****************
1:7c52163: 	 * 6)test2UpdateAfterTriggerUpdatedLOB
1:7c52163: 	 * 	This test creates an AFTER UPDATE trigger which in it's trigger action
1:7c52163: 	 * updates a lob column from the row that just got updated. So, this test 
1:7c52163: 	 * does update the LOB from the triggering table inside the trigger
1:7c52163: 	 * action. 
1:7c52163: 	 * ****************
1:7c52163: 	 * 7)test2UpdateBeforeTriggerAccessLOB
1:7c52163: 	 * 	This test creates a BEFORE UPDATE trigger which selects "new"
1:7c52163: 	 * lob column from just updated row. This test does access the
1:7c52163: 	 * LOB. 
1:7c52163: 	 * ****************
1:7c52163: 	 * 8)test3UpdateAfterTrigger
1:7c52163: 	 * 	The after update trigger is defined on LOB column but the LOB column 
1:7c52163: 	 * is not referenced in the trigger action.
1:7c52163: 	 * ****************
1:7c52163: 	 * 9)test3UpdateAfterTriggerStoredProc
1:7c52163: 	 *  The test case is exactly like test3UpdateAfterTrigger except that the
1:7c52163: 	 * trigger action is a stored procedure call. The work done by the trigger
1:7c52163: 	 * action SQL in test3UpdateAfterTrigger gets done inside the stored procedure
1:7c52163: 	 * for this test.
1:7c52163: 	 * ****************
1:7c52163: 	 * 10)test3UpdateBeforeTrigger
1:7c52163: 	 * 	This test creates a BEFORE UPDATE trigger which selects a row
1:7c52163: 	 * from another table using "new" non-LOB column from the triggering
1:7c52163: 	 * table. This test has update trigger defined on the LOB column
1:7c52163: 	 * but does not access/update that LOB column in the trigger action.
1:7c52163: 	 * ****************
1:7c52163: 	 * 11)test3UpdateBeforeTriggerStoredProc
1:7c52163: 	 * 	The test case is exactly like test3UpdateBeforeTrigger except that the
1:7c52163: 	 * trigger action is a stored procedure call. The work done by the trigger
1:7c52163: 	 * action SQL in test3UpdateBeforeTrigger gets done inside the stored procedure
1:7c52163: 	 * for this test.
1:7c52163: 	 * ****************
1:7c52163: 	 * 12)test4UpdateAfterTriggerAccessLOB
1:7c52163: 	 * 	The after update trigger on LOB column but the LOB column is referenced 
1:7c52163: 	 * in the trigger action. This is one case though where we do need to keep 
1:7c52163: 	 * before and after image since the LOB got updated and it is being used in 
1:7c52163: 	 * trigger action.
1:7c52163: 	 * ****************
1:7c52163: 	 * 13)test4UpdateAfterTriggerUpdatedLOB
1:7c52163: 	 * 	The after update trigger on LOB column which then gets updated in the
1:7c52163: 	 * trigger action. So this test updates the LOB in the trigger action
2:7c52163: 	 * and is also the cause of the update trigger to fire. 
1:7c52163: 	 * ****************
1:7c52163: 	 * 14)test4UpdateBeforeTrigger
1:7c52163: 	 * ****************
1:7c52163: 	 * 15)test5UpdateAfterTriggerNoReferencingClause
1:7c52163: 	 * 	This test creates an AFTER UPDATE trigger but has no REFERENCING
1:7c52163: 	 * clause, meaning that before and after values are not available to
1:7c52163: 	 * the trigger action. 
1:7c52163: 	 * ****************
1:a6f9586: 	 * 16)test5UpdateBeforeTriggerNoReferencingClause
1:7c52163: 	 * 	This test creates an BEFORE UPDATE trigger but has no REFERENCING
1:7c52163: 	 * clause, meaning that before and after values are not available to
1:7c52163: 	 * the trigger action. 
1:7c52163: 	 * ****************
1:a6f9586: 	 * 17)test6UpdateAfterTriggerNoTriggerColumn
1:a6f9586: 	 *  This test create an AFTER UPDATE trigger but does not identify any
1:a6f9586: 	 * trigger columns. It has REFERENCING clause. Void of trigger columns
1:a6f9586: 	 * will cause all the columns to be read into memory.
1:a6f9586: 	 * ****************
1:7c52163: 	 */
1:7c52163:     public TriggerTests(String name) {
1:7c52163:         super(name);
1:7c52163:     }
1:7c52163: 	
1:7c52163:     public static Test suite() {
1:7c52163:         Test suite = new CleanDatabaseTestSetup(TestConfiguration
1:7c52163:                 .embeddedSuite(TriggerTests.class));
1:7c52163:         Properties p = new Properties();
1:a6f9586:         // use small pageCacheSize so we don't run out of memory on the insert
1:a6f9586:         // of large LOB columns.
1:7c52163:         p.setProperty("derby.storage.pageCacheSize", "100");
1:7c52163:         return new SystemPropertyTestSetup(suite,p);
1:7c52163:     }
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * Create the basic tables and data expected by almost all the tests. If a
1:7c52163: 	 * particular test needs anything else, that test will take care of it.
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void basicSetup() throws SQLException{
1:995d3ac:         dropTable("TABLE1");
1:995d3ac:         dropTable("TABLE2");
1:995d3ac:         dropTable("TABLE3");
1:7c52163: 
1:7c52163:         Statement s = createStatement();
4:7c52163: 		try {
1:7c52163: 			s.execute("drop trigger trigger1");
4:7c52163: 		} catch (SQLException sqle) {}
1:7c52163: 
1:7c52163: 		try {
1:7c52163: 			s.execute("drop trigger trigger2");
1:7c52163: 		} catch (SQLException sqle) {}
1:7c52163: 
1:7c52163: 		//table1 is the main table on which all the testing is done and it 
1:7c52163: 		//uses table2 at times to do DMLs as part of it's trigger action.
1:7c52163: 		s.execute("create table table1 (id int, status smallint, bl blob(2G))");
1:7c52163: 		s.execute("create index i1 on table1(id)");
1:7c52163: 		//table2 is mostly used as part of the trigger action for table1
1:7c52163: 		s.execute("create table table2 (id int, updates int default 0)");
1:7c52163: 		s.execute("create index i2 on table2(id)");
1:7c52163: 		//table3 does not have lob. It is mostly used to show how things work
1:7c52163: 		//fine when they may not for table1 since table1 has LOB column.
1:7c52163: 		s.execute("create table table3 (id int, status smallint, score int)");
1:7c52163: 		s.execute("create index i3 on table3(id)");
1:7c52163: 
1:7c52163: 		//load data in table1
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 		"insert into table1 values (?, 0, ?)");
1:7c52163: 		ps.setInt(1, 1);
1:7c52163:         ps.setBinaryStream(2, new LoopingAlphabetStream(lobsize), lobsize);
1:7c52163:         ps.executeUpdate();
1:7c52163: 
1:7c52163: 		//load data in table2
1:7c52163: 		ps = prepareStatement(
1:7c52163: 			"insert into table2 (id) values (?)");
1:7c52163: 		ps.setInt(1, 1);
1:7c52163:         ps.executeUpdate();
1:7c52163: 
1:7c52163: 		//load data in table3
1:7c52163: 		ps = prepareStatement(
1:7c52163: 			"insert into table3 values (?, 0, ?)");
1:7c52163: 		ps.setInt(1, 1);
1:7c52163: 		ps.setInt(2, 2);
1:7c52163:         ps.executeUpdate();
1:7c52163: 
1:7c52163: 		commit();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * This test creates an AFTER INSERT trigger which inserts non-lob
1:a6f9586: 	 * columns into another table. The triggering INSERT does not insert
1:a6f9586: 	 * any value into LOB column
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:a6f9586: 	public void test1InsertAfterTrigger() throws SQLException{	
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
2:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 		s.execute("create trigger trigger1 AFTER INSERT on table1 referencing " +
3:7c52163: 			"new as n_row for each row " +
1:7c52163: 			"insert into table2(id, updates) values (n_row.id, -1)");
1:7c52163: 		commit();
1:a6f9586:    		runtest1InsertTriggerTest();		       	
1:7c52163: 	}
1:f246c9c: 
1:7c52163: 	/**
1:7c52163: 	 * The test case is exactly like test1InsertAfterTrigger except that the
1:7c52163: 	 * trigger action is a stored procedure call. The work done by the trigger
1:7c52163: 	 * action SQL in test1InsertAfterTrigger gets done inside the stored procedure
1:7c52163: 	 * for this test.
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test1InsertAfterTriggerStoredProc() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:c4728eb:         // JSR169 cannot run with tests with stored procedures
1:c4728eb:         // that do database access - for they require a
1:c4728eb:         // DriverManager connection to jdbc:default:connection;
1:c4728eb:         // DriverManager is not supported with JSR169.
1:c4728eb:         if (JDBC.vmSupportsJSR169()) 
1:c4728eb:         	return;
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163:         s.execute("create procedure proc_test1_InsertAfterTrigger_update_table " +
1:7c52163:         		"(p1 int) parameter style java language "+
1:7c52163:         		"java MODIFIES SQL DATA external name "+
1:a6f9586:         		"'org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.proc_test1_InsertAfterTrigger_update_table'");
1:7c52163: 		s.execute("create trigger trigger1 after INSERT on table1 referencing " +
1:7c52163: 			"new as n_row for each row " +
1:7c52163: 			"call proc_test1_InsertAfterTrigger_update_table(n_row.id)");
1:7c52163: 		commit();
1:a6f9586:    		runtest1InsertTriggerTest();		       	
1:7c52163: 	}
1:f246c9c: 
1:7c52163: 	/**
1:7c52163: 	 * The is the stored procedure which gets called by the after insert 
1:7c52163: 	 * trigger action for the test test1InsertAfterTriggerStoredProc
1:7c52163: 	 * @param p1 new value of table1.id after the row gets inserted
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public static void proc_test1_InsertAfterTrigger_update_table(int p1) throws SQLException {
1:7c52163:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:7c52163:         PreparedStatement ps = conn.prepareStatement(
1:7c52163:         		"insert into table2(id, updates) values (" + p1 + ",-1)");
1:7c52163:         ps.executeUpdate();
1:7c52163:         conn.close();
1:7c52163: 	}
1:f246c9c: 
1:7c52163: 	/**
1:7c52163: 	 * This test creates an AFTER DELETE trigger which delets from another
1:7c52163: 	 * table using non-lob from the triggering table in the where clause.
1:a6f9586: 	 * 
1:a6f9586: 	 * DELETE triggers read all the columns from the trigger table. Following
1:a6f9586: 	 * test is on a trigger table with large data in LOB columns and hence it
1:a6f9586: 	 * will run out of memory. For that reason, the test is disabled.
1:a6f9586: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test1DeleteAfterTrigger() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 		s.execute("create trigger trigger1 after DELETE on table1 referencing " +
1:7c52163: 				"old as o_row for each row " +
1:7c52163: 				"delete from table2 where id=o_row.id");
1:7c52163: 		commit();
1:7c52163: 		runDeleteTriggerTest();		       	
1:7c52163: 	}
1:f246c9c: 
1:7c52163: 	/**
1:7c52163: 	 * The test case is exactly like test1DeleteAfterTrigger except that the
1:7c52163: 	 * trigger action is a stored procedure call. The work done by the trigger
1:7c52163: 	 * action SQL in test1DeleteAfterTrigger gets done inside the stored procedure
1:7c52163: 	 * for this test.
1:a6f9586: 	 * 
1:a6f9586: 	 * DELETE triggers read all the columns from the trigger table. Following
1:a6f9586: 	 * test is on a trigger table with large data in LOB columns and hence it
1:a6f9586: 	 * will run out of memory. For that reason, the test is disabled.
1:a6f9586: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test1DeleteAfterTriggerStoredProc() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163:         s.execute("create procedure proc_test1_DeleteAfterTrigger_update_table " +
1:7c52163:         		"(p1 int) parameter style java language "+
1:7c52163:         		"java MODIFIES SQL DATA external name "+
1:a6f9586:         		"'org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.proc_test1_DeleteAfterTrigger_update_table'");
1:f246c9c: 
1:7c52163: 		s.execute("create trigger trigger1 after DELETE on table1 referencing " +
1:7c52163: 				"old as o_row for each row " +
1:7c52163: 				"call proc_test1_DeleteAfterTrigger_update_table(o_row.id)");
1:7c52163: 		commit();
1:7c52163: 		runDeleteTriggerTest();		       	
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * The is the stored procedure which gets called by the after delete 
1:7c52163: 	 * trigger action for the test test1DeleteAfterTriggerStoredProc
1:7c52163: 	 * @param p1 old value of table1.id before the row gets deleted
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public static void proc_test1_DeleteAfterTrigger_update_table(int p1) throws SQLException {
1:7c52163:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:7c52163:         PreparedStatement ps = conn.prepareStatement(
1:7c52163:         		"delete from table1 where id=" + p1);
1:7c52163:         ps.executeUpdate();
1:7c52163:         conn.close();
1:7c52163: 	}
1:7c52163: 	
1:7c52163: 	/**
1:7c52163: 	 * This test creates an AFTER UPDATE trigger which is declared on a
1:7c52163: 	 * non-LOB column. The trigger action does not access the LOB column.
1:a6f9586: 	 * 
1:7c52163: 	 * It uses 2 tables to demonstrate the problem. 
1:7c52163: 	 * table1 has a BLOB column
1:7c52163: 	 * table2 gets updated as part of AFTER UPDATE trigger of 
1:7c52163: 	 * 	non-BLOB column on table1
1:a6f9586: 	 * 
1:7c52163: 	 * table1 has an after update trigger defined on column "status" so
1:7c52163: 	 * 	that table2 will get updated as part of trigger action
1:a6f9586: 	 * 
1:7c52163: 	 * Notice that the trigger does not reference the BLOB column in 
1:7c52163: 	 * 	table1 and update that caused the trigger is not updating the 
1:7c52163: 	 * 	BLOB column
1:a6f9586: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test1UpdateAfterTrigger() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 		s.execute("create trigger trigger1 after update of status on table1 referencing " +
1:7c52163: 			"new as n_row for each row " +
1:7c52163: 			"update table2 set updates = updates + 1 where table2.id = n_row.id");
1:7c52163: 		commit();
1:7c52163: 		runtest1UpdateTrigger();
1:7c52163: 	}
1:f246c9c: 
1:7c52163: 	/**
1:7c52163: 	 * The test case is exactly like test1UpdateAfterTrigger except that the
1:7c52163: 	 * trigger action is a stored procedure call. The work done by the trigger
1:7c52163: 	 * action SQL in test1UpdateAfterTrigger gets done inside the stored procedure
1:7c52163: 	 * for this test.
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test1UpdateAfterTriggerStoredProc() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:c4728eb:         // JSR169 cannot run with tests with stored procedures
1:c4728eb:         // that do database access - for they require a
1:c4728eb:         // DriverManager connection to jdbc:default:connection;
1:c4728eb:         // DriverManager is not supported with JSR169.
1:c4728eb:         if (JDBC.vmSupportsJSR169()) 
1:c4728eb:         	return;
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163:         s.execute("create procedure proc_test1_UpdateAfterTrigger_update_table " +
1:7c52163:         		"(p1 int) parameter style java language "+
1:7c52163:         		"java MODIFIES SQL DATA external name "+
1:a6f9586:         		"'org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.proc_test1_UpdateAfterTrigger_update_table'");
1:7c52163: 
1:7c52163: 		s.execute("create trigger trigger1 after update of status on table1 REFERENCING " +
1:7c52163: 				"NEW as n_row for each row call proc_test1_UpdateAfterTrigger_update_table(n_row.id)");
1:7c52163: 		commit();
1:7c52163:    		runtest1UpdateTrigger();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * The is the stored procedure which gets called by the after update 
1:7c52163: 	 * trigger action for the test test1UpdateAfterTriggerStoredProc
1:7c52163: 	 * @param p1 new value of table1.id after the row gets updated
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public static void proc_test1_UpdateAfterTrigger_update_table(int p1) throws SQLException {
1:7c52163:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:7c52163:         PreparedStatement ps = conn.prepareStatement("update table2 "+
1:7c52163:         		"set updates = updates + 1 where table2.id = " + p1);
1:7c52163:         ps.executeUpdate();
1:7c52163:         conn.close();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * This test creates a BEFORE INSERT trigger which selects 
1:7c52163: 	 * columns from another table using "new" non-lob column for 
1:7c52163: 	 * join clause.
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test1InsertBeforeTrigger() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 		s.execute("create trigger trigger1 no cascade before INSERT on table1 referencing " +
1:7c52163: 			"new as n_row for each row " +
1:7c52163: 			"select updates from table2 where table2.id = n_row.id");
1:7c52163: 		commit();
1:a6f9586:    		runtest1InsertTriggerTest();		       	
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * The test case is exactly like test1InsertBeforeTrigger except that the
1:7c52163: 	 * trigger action is a stored procedure call. The work done by the trigger
1:7c52163: 	 * action SQL in test1InsertBeforeTrigger gets done inside the stored procedure
1:7c52163: 	 * for this test.
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test1InsertBeforeTriggerStoredProc() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:c4728eb:         // JSR169 cannot run with tests with stored procedures
1:c4728eb:         // that do database access - for they require a
1:c4728eb:         // DriverManager connection to jdbc:default:connection;
1:c4728eb:         // DriverManager is not supported with JSR169.
1:c4728eb:         if (JDBC.vmSupportsJSR169()) 
1:c4728eb:         	return;
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163:         s.execute("create procedure proc_test1_InsertBeforeTrigger_select_table " +
1:7c52163:         		"(p1 int) parameter style java language "+
1:7c52163:         		"java READS SQL DATA external name "+
1:a6f9586:         		"'org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.proc_test1_InsertBeforeTrigger_select_table'");
1:7c52163: 		s.execute("create trigger trigger1 no cascade before INSERT on table1 referencing " +
1:7c52163: 			"new as n_row for each row call proc_test1_InsertBeforeTrigger_select_table(n_row.id)");
1:7c52163: 		commit();
1:a6f9586: 		runtest1InsertTriggerTest();
1:7c52163: 	}
1:7c52163: 	
1:7c52163: 	/**
1:7c52163: 	 * The is the stored procedure which gets called by the before insert 
1:7c52163: 	 * trigger action for the test test1InsertBeforeTriggerStoredProc
1:7c52163: 	 * @param p1 new value of table1.id after the row gets inserted
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public static void proc_test1_InsertBeforeTrigger_select_table(int p1) throws SQLException {
1:7c52163:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:7c52163:         PreparedStatement ps = conn.prepareStatement("select updates from " +
1:7c52163:         		"table2 where table2.id = " + p1);
1:7c52163:         ps.executeQuery();
1:7c52163:         conn.close();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * This test creates a BEFORE DELETE trigger which selects 
1:7c52163: 	 * columns from another table using "new" non-lob column for 
1:7c52163: 	 * join clause.
1:a6f9586: 	 * 
1:a6f9586: 	 * DELETE triggers read all the columns from the trigger table. Following
1:a6f9586: 	 * test is on a trigger table with large data in LOB columns and hence it
1:a6f9586: 	 * will run out of memory. For that reason, the test is disabled.
1:a6f9586: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test1DeleteBeforeTrigger() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 		s.execute("create trigger trigger1 no cascade before DELETE on table1 referencing " +
1:7c52163: 				"old as o_row for each row " +
1:7c52163: 				"select updates from table2 where table2.id = o_row.id");
1:7c52163: 		commit();
1:7c52163:    		runDeleteTriggerTest();		       	
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * The test case is exactly like test1DeleteBeforeTrigger except that the
1:7c52163: 	 * trigger action is a stored procedure call. The work done by the trigger
1:7c52163: 	 * action SQL in test1DeleteBeforeTrigger gets done inside the stored procedure
1:7c52163: 	 * for this test.
1:a6f9586: 	 * 
1:a6f9586: 	 * DELETE triggers read all the columns from the trigger table. Following
1:a6f9586: 	 * test is on a trigger table with large data in LOB columns and hence it
1:a6f9586: 	 * will run out of memory. For that reason, the test is disabled.
1:7c52163: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test1DeleteBeforeTriggerStoredProc() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:f246c9c:        basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 
1:7c52163:         s.execute("create procedure proc_test1_DeleteBeforeTrigger_select_table " +
1:7c52163:         		"(p1 int) parameter style java language "+
1:7c52163:         		"java READS SQL DATA external name "+
1:a6f9586:         		"'org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.proc_test1_DeleteBeforeTrigger_select_table'");
1:7c52163: 
1:7c52163:         s.execute("create trigger trigger1 no cascade before DELETE on table1 referencing " +
1:7c52163: 				"old as o_row for each row call proc_test1_DeleteBeforeTrigger_select_table(o_row.id)");
1:7c52163: 		commit();
1:7c52163:    		runDeleteTriggerTest();		       	
1:7c52163: 	}
1:7c52163: 	
1:7c52163: 	/**
1:7c52163: 	 * The is the stored procedure which gets called by the before delete 
1:7c52163: 	 * trigger action for the test test1DeleteBeforeTriggerStoredProc
1:7c52163: 	 * @param p1 old value of table1.id before the row gets deleted
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public static void proc_test1_DeleteBeforeTrigger_select_table(int p1) throws SQLException {
1:7c52163:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:7c52163:         PreparedStatement ps = conn.prepareStatement("select updates from " +
1:7c52163:         		"table2 where table2.id = " + p1);
1:7c52163:         ps.executeQuery();
1:7c52163:         conn.close();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * This test creates a BEFORE UPDATE trigger which is declared
1:7c52163: 	 * on a non-LOB column. The trigger action selects columns from 
1:7c52163: 	 * another table using "new" non-lob column for join clause. 
1:7c52163: 	 * 
1:7c52163: 	 * It uses 2 tables to demonstrate the problem. 
1:7c52163: 	 * table1 has a BLOB column
1:7c52163: 	 * table2 gets updated as part of AFTER UPDATE trigger of 
1:7c52163: 	 * 	non-BLOB column on table1
1:7c52163: 	 * 
1:7c52163: 	 * table1 has a before update trigger defined on column "status" so
1:7c52163: 	 * that there will be a select done from table2 as part of trigger 
1:7c52163: 	 * action.
1:7c52163: 	 * 
1:7c52163: 	 * Notice that the trigger does not reference the BLOB column in 
1:7c52163: 	 * 	table1 and update that caused the trigger is not updating the 
1:7c52163: 	 * 	BLOB column
1:7c52163: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test1UpdateBeforeTrigger() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:f246c9c: 
1:7c52163: 		s.execute("create trigger trigger1 no cascade before update of status on table1 referencing " +
1:7c52163: 			"new as n_row for each row " +
1:7c52163: 			"select updates from table2 where table2.id = n_row.id");
1:7c52163: 		commit();
1:7c52163:    		runtest1UpdateTrigger();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * The test case is exactly like test1UpdateBeforeTrigger except that the
1:7c52163: 	 * trigger action is a stored procedure call. The work done by the trigger
1:7c52163: 	 * action SQL in test1UpdateBeforeTrigger gets done inside the stored procedure
1:7c52163: 	 * for this test.
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test1UpdateBeforeTriggerStoredProc() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:c4728eb:         // JSR169 cannot run with tests with stored procedures
1:c4728eb:         // that do database access - for they require a
1:c4728eb:         // DriverManager connection to jdbc:default:connection;
1:c4728eb:         // DriverManager is not supported with JSR169.
1:c4728eb:         if (JDBC.vmSupportsJSR169()) 
1:c4728eb:         	return;
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163:         s.execute("create procedure proc_test1_UpdateBeforeTrigger_select_table " +
1:7c52163:         		"(p1 int) parameter style java language "+
1:7c52163:         		"java READS SQL DATA external name "+
1:a6f9586:         		"'org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.proc_test1_UpdateBeforeTrigger_select_table'");
1:7c52163: 
1:7c52163: 		s.execute("create trigger trigger1 no cascade before update of status on table1 REFERENCING " +
1:7c52163: 				"NEW as n_row for each row call proc_test1_UpdateBeforeTrigger_select_table(n_row.id)");
1:7c52163: 		commit();
1:7c52163:    		runtest1UpdateTrigger();
1:7c52163: 	}
1:7c52163: 	
1:7c52163: 	/**
1:7c52163: 	 * The is the stored procedure which gets called by the before update 
1:7c52163: 	 * trigger action for the test test1UpdateBeforeTriggerStoredProc
1:7c52163: 	 * @param p1 new value of table1.id after the row gets updated
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public static void proc_test1_UpdateBeforeTrigger_select_table(int p1) throws SQLException {
1:7c52163:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:7c52163:         PreparedStatement ps = conn.prepareStatement("select updates from " +
1:7c52163:         		"table2 where table2.id = " + p1);
1:7c52163:         ps.executeQuery();
1:7c52163:         conn.close();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * This test creates an AFTER INSERT trigger which in it's trigger action
1:7c52163: 	 * inserts lob columns from triggering table into another table. So, this
1:7c52163: 	 * test does access the LOB from the triggering table inside the trigger
1:7c52163: 	 * action.
1:7c52163: 	 * 
1:a6f9586: 	 * INSERT trigger in this test is inserting large data in the LOB column
1:a6f9586: 	 * which will be used in the INSERT trigger and hence it will run out of 
1:a6f9586: 	 * memory. For that reason, the test is disabled.
1:a6f9586: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test2InsertAfterTriggerAccessLOB() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 
1:7c52163:         //The default table2 created by basicSetup does not match the 
1:7c52163:         //requirement of this test so dropping and recreating it.
2:7c52163:         s.execute("drop table table2");
1:7c52163: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1:7c52163: 
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 			"insert into table2 (id) values (?)");
1:7c52163: 		ps.setInt(1, 1);
1:7c52163:         ps.executeUpdate();
1:7c52163: 
1:7c52163: 		s.execute("create trigger trigger1 after INSERT on table1 referencing " +
1:7c52163: 				"new as n_row for each row " +
1:7c52163: 				"insert into table2(id, bl_table2) values (n_row.id, n_row.bl)");
1:7c52163: 		commit();
1:f246c9c:    		runtest2InsertTriggerTest();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * This test creates an AFTER DELETE trigger which in it's trigger action
1:7c52163: 	 * deletes row from another table using triggering table's "new" LOB value
1:7c52163: 	 * in the join clause. So, this test does access the LOB from the 
1:7c52163: 	 * triggering table inside the trigger action.
1:a6f9586: 	 * 
1:a6f9586: 	 * DELETE triggers read all the columns from the trigger table. Following
1:a6f9586: 	 * test is on a trigger table with large data in LOB columns and hence it
1:a6f9586: 	 * will run out of memory. For that reason, the test is disabled.
1:7c52163: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test2DeleteAfterTriggerAccessLOB() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163:         //The default table2 created by basicSetup does not match the 
1:7c52163:         //requirement of this test so dropping and recreating it.
1:7c52163:         s.execute("drop table table2");
1:7c52163: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1:7c52163: 
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 			"insert into table2 (id) values (?)");
1:7c52163: 		ps.setInt(1, 1);
1:7c52163:         ps.executeUpdate();
1:7c52163: 		commit();
1:7c52163: 
1:7c52163: 		s.execute("create trigger trigger1 after DELETE on table1 referencing " +
1:7c52163: 				"old as o_row for each row " +
1:7c52163: 				"delete from table2 where id = o_row.id and o_row.bl is not null");
1:7c52163: 		commit();
1:7c52163:    		runDeleteTriggerTest();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * The after update trigger on non-LOB column but the LOB column is
1:7c52163: 	 * referenced in the trigger action. So, this test does access the LOB 
1:7c52163: 	 * from the triggering table inside the trigger action. 
1:7c52163: 	 *  
1:7c52163: 	 * It uses 2 tables to demonstrate the problem. 
1:7c52163: 	 * table1 has a BLOB column
1:7c52163: 	 * table2 gets updated with LOB column from triggering table
1:7c52163: 	 * 	eventhough the UPDATE which caused the trigger to fire didn't
1:7c52163: 	 * 	update the LOB. The trigger got fired for update of non-LOB
1:7c52163: 	 * 	column on the triggering table. 
1:7c52163: 	 * 
1:7c52163: 	 * table1 has an after update trigger defined on column "status" so
1:7c52163: 	 * 	that the trigger action will update table2 with LOB value from 
1:7c52163: 	 * 	table1.
1:7c52163: 	 * 
1:7c52163: 	 * Notice that the trigger action DOES reference the BLOB column in 
1:7c52163: 	 * 	table1 but the update that caused the trigger is not updating 
1:7c52163: 	 * 	the BLOB column
1:7c52163: 	 * 
1:a6f9586: 	 * UPDATE trigger in this test is working with large data in the LOB column
1:a6f9586: 	 * inside the trigger action and hence it will run out of memory. For that 
1:a6f9586: 	 * reason, the test is disabled.
1:a6f9586: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test2UpdateAfterTriggerAccessLOB() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163:         //The default table2 created by basicSetup does not match the 
1:7c52163:         //requirement of this test so dropping and recreating it.
1:7c52163:         s.execute("drop table table2");
1:7c52163: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1:7c52163: 
1:7c52163: 		s.execute("create trigger trigger1 after update of status on table1 referencing " +
1:7c52163: 			"new as n_row for each row " +
1:7c52163: 			"update table2 set bl_table2 = n_row.bl where table2.id = n_row.id");
1:7c52163: 
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 			"insert into table2 (id) values (?)");
1:7c52163: 		ps.setInt(1, 1);
1:7c52163:         ps.executeUpdate();
1:7c52163: 		commit();
1:7c52163:    		runtest1UpdateTrigger();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * This test creates an AFTER INSERT trigger which in it's trigger action
1:7c52163: 	 * updates a lob column from the row just inserted. So, this test does
1:7c52163: 	 * update the LOB from the triggering table inside the trigger
1:7c52163: 	 * action.
1:a6f9586: 	 * 
1:a6f9586: 	 * INSERT trigger in this test is inserting large data in the LOB column
1:a6f9586: 	 * which will be used in the INSERT trigger and hence it will run out of 
1:a6f9586: 	 * memory. For that reason, the test is disabled.
1:7c52163: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test2InsertAfterTriggerUpdatedLOB() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 
1:7c52163:         //The default table1 created by basicSetup does not match the 
1:7c52163:         //requirement of this test so dropping and recreating it.
2:7c52163:         s.execute("drop table table1");
1:7c52163: 		s.execute("create table table1 (id int, status smallint, bl blob(2G), bl_null blob(2G))");
1:7c52163: 
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 			"insert into table1 values (?, 0, ?, null)");
1:7c52163: 		ps.setInt(1, 1);
1:7c52163:         ps.setBinaryStream(2, new LoopingAlphabetStream(lobsize), lobsize);
1:7c52163:         ps.executeUpdate();
1:7c52163: 
1:7c52163:         s.execute("create trigger trigger1 after INSERT on table1 referencing " +
1:7c52163: 				"new as n_row for each row " +
1:7c52163: 				"update table1 set bl_null=n_row.bl where bl_null is null");
1:7c52163: 		commit();
1:f246c9c:    		runtest2InsertTriggerTest();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * This test creates an AFTER UPDATE trigger which in it's trigger action
1:7c52163: 	 * updates a lob column from the row that just got updated. So, this test 
1:7c52163: 	 * does update the LOB from the triggering table inside the trigger
1:7c52163: 	 * action. 
1:7c52163: 	 * 
1:a6f9586: 	 * UPDATE trigger in this test is working with large data in the LOB column
1:a6f9586: 	 * inside the trigger action and hence it will run out of memory. For that 
1:a6f9586: 	 * reason, the test is disabled.
1:7c52163: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test2UpdateAfterTriggerUpdatedLOB() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 
1:7c52163:         //The default table1 created by basicSetup does not match the 
1:7c52163:         //requirement of this test so dropping and recreating it.
1:7c52163:         s.execute("drop table table1");
1:7c52163: 		s.execute("create table table1 (id int, status smallint, bl blob(2G), bl_null blob(2G))");
1:7c52163: 
1:7c52163:         s.execute("create trigger trigger1 after update of status on table1 referencing " +
1:7c52163:     			"new as n_row for each row " +
1:7c52163:     			"update table1 set bl_null=n_row.bl where bl_null is null");
1:7c52163: 
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 			"insert into table1 values (?, 0, ?, null)");
1:7c52163: 		ps.setInt(1, 1);
1:7c52163:         ps.setBinaryStream(2, new LoopingAlphabetStream(lobsize), lobsize);
1:7c52163:         ps.executeUpdate();
1:7c52163: 		commit();
1:7c52163:    		runtest1UpdateTrigger();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * This test creates a BEFORE INSERT trigger which selects "new"
1:7c52163: 	 * lob column from just inserted row. This test does access the
1:7c52163: 	 * LOB.
1:a6f9586: 	 * 
1:a6f9586: 	 * INSERT trigger in this test is inserting large data in the LOB column
1:a6f9586: 	 * which will be used in the INSERT trigger action and hence it will run  
1:a6f9586: 	 * out of memory. For that reason, the test is disabled.
1:a6f9586: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test2InsertBeforeTriggerAccessLOB() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163:         //The default table2 created by basicSetup does not match the 
1:7c52163:         //requirement of this test so dropping and recreating it.
1:7c52163:         s.execute("drop table table2");
1:7c52163: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1:7c52163: 
1:7c52163: 		s.execute("create trigger trigger1 no cascade before INSERT on table1 referencing " +
1:7c52163: 			"new as n_row for each row " +
1:7c52163: 			"values(n_row.bl)");		
1:7c52163: 		
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 			"insert into table2 (id) values (?)");
1:7c52163: 		ps.setInt(1, 1);
1:7c52163:         ps.executeUpdate();
1:7c52163: 		commit();
1:f246c9c:    		runtest2InsertTriggerTest();
1:7c52163: 	}
1:7c52163: 	
1:7c52163: 	/**
1:7c52163: 	 * This test creates a BEFORE DELETE trigger which selects "old"
1:7c52163: 	 * lob column from just deleted row. This test does access the
1:7c52163: 	 * LOB.
1:a6f9586: 	 * 
1:a6f9586: 	 * DELETE triggers read all the columns from the trigger table. Following
1:a6f9586: 	 * test is on a trigger table with large data in LOB columns and hence it
1:a6f9586: 	 * will run out of memory. For that reason, the test is disabled.
1:a6f9586: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test2DeleteBeforeTriggerAccessLOB() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 
1:7c52163:         //The default table2 created by basicSetup does not match the 
1:7c52163:         //requirement of this test so dropping and recreating it.
1:7c52163:         s.execute("drop table table2");
1:7c52163: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1:7c52163: 
1:7c52163: 		s.execute("create trigger trigger1 no cascade before DELETE on table1 referencing " +
1:7c52163: 			"old as o_row for each row " +
1:7c52163: 			"values(o_row.bl)");		
1:7c52163: 		
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 			"insert into table2 (id) values (?)");
1:7c52163: 		ps.setInt(1, 1);
1:7c52163:         ps.executeUpdate();
1:7c52163: 		commit();
1:7c52163:    		runDeleteTriggerTest();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * This test creates a BEFORE UPDATE trigger which selects "new"
1:7c52163: 	 * lob column from just updated row. This test does access the
1:7c52163: 	 * LOB. 
1:a6f9586: 	 * 
1:a6f9586: 	 * UPDATE trigger in this test is working with large data in the LOB column
1:a6f9586: 	 * inside the trigger action and hence it will run out of memory. For that 
1:a6f9586: 	 * reason, the test is disabled.
1:7c52163: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test2UpdateBeforeTriggerAccessLOB() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 
1:7c52163:         //The default table2 created by basicSetup does not match the 
1:7c52163:         //requirement of this test so dropping and recreating it.
1:7c52163:         s.execute("drop table table2");
1:7c52163: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1:7c52163: 
1:7c52163: 		s.execute("create trigger trigger1 no cascade before update of status on table1 referencing " +
1:7c52163: 			"new as n_row for each row " +
1:7c52163: 			"values(n_row.bl)");		
1:7c52163: 		
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 			"insert into table2 (id) values (?)");
1:7c52163: 		ps.setInt(1, 1);
1:7c52163:         ps.executeUpdate();
1:7c52163: 		commit();
1:7c52163:    		runtest1UpdateTrigger();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * The after update trigger is defined on LOB column but the LOB column 
1:7c52163: 	 * is not referenced in the trigger action.
1:7c52163: 	 * 
1:7c52163: 	 * It used 2 tables to demonstrate the problem.
1:7c52163: 	 * table1 has a BLOB column
1:7c52163: 	 * table2 gets updated with non-LOB column from triggering table
1:7c52163: 	 * 	eventhough the UPDATE which caused the trigger to fire updated a LOB
1:7c52163: 	 * column. The trigger got fired for update of LOB column on the triggering
1:7c52163: 	 * table.
1:7c52163: 	 * 
1:7c52163: 	 * table1 has an after update trigger defined on LOB column so that 
1:7c52163: 	 * 	the trigger action will update table2 with non-LOB value from
1:7c52163: 	 * 	table1
1:7c52163: 	 * 
1:a6f9586: 	 * UPDATE trigger is defined on LOB column with large data and hence it 
1:a6f9586: 	 * will run out of memory. For that reason, the test is disabled.
1:a6f9586: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test3UpdateAfterTrigger() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 		s.execute("create trigger trigger1 after update of bl on table1 referencing " +
1:7c52163: 				"new as n_row for each row " +
1:7c52163: 				"update table2 set updates = n_row.status where table2.id = n_row.id");
1:7c52163: 		commit();
1:7c52163:    		runtest2UpdateTrigger();
1:7c52163: 	}
1:a6f9586: 
1:7c52163: 	/**
1:7c52163: 	 * The test case is exactly like test3UpdateAfterTrigger except that the
1:7c52163: 	 * trigger action is a stored procedure call. The work done by the trigger
1:7c52163: 	 * action SQL in test3UpdateAfterTrigger gets done inside the stored procedure
1:7c52163: 	 * for this test.
1:a6f9586: 	 * 
1:a6f9586: 	 * UPDATE trigger is defined on LOB column with large data and hence it 
1:a6f9586: 	 * will run out of memory. For that reason, the test is disabled.
1:a6f9586: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test3UpdateAfterTriggerStoredProc() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 	
1:7c52163:         s.execute("create procedure proc_test3_UpdateAfterTrigger_update_table " +
1:7c52163:         		"(p1 int, p2 int) parameter style java language "+
1:7c52163:         		"java MODIFIES SQL DATA external name "+
1:a6f9586:         		"'org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.proc_test3_UpdateAfterTrigger_update_table'");
1:7c52163: 
1:7c52163: 		s.execute("create trigger trigger1 after update of bl on table1 REFERENCING " +
1:7c52163: 				"NEW as n_row for each row call proc_test3_UpdateAfterTrigger_update_table(n_row.status, n_row.id)");
1:7c52163: 		commit();
1:7c52163:    		runtest2UpdateTrigger();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * The is the stored procedure which gets called by the after delete 
1:7c52163: 	 * trigger action for the test test3UpdateAfterTriggerStoredProc
1:7c52163: 	 * @param p1 new value of table1.status after the row gets inserted
1:7c52163: 	 * @param p2 new value of table1.id after the row gets inserted
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public static void proc_test3_UpdateAfterTrigger_update_table(int p1, int p2) throws SQLException {
1:7c52163:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:7c52163:         PreparedStatement ps = conn.prepareStatement("update table2 "+
1:7c52163:         		"set updates = " + p1 + " where table2.id = " + p2);
1:7c52163:         ps.executeUpdate();
1:7c52163:         conn.close();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * This test creates a BEFORE UPDATE trigger which selects a row
1:7c52163: 	 * from another table using "new" non-LOB column from the triggering
1:7c52163: 	 * table. This test has update trigger defined on the LOB column
1:7c52163: 	 * but does not access/update that LOB column in the trigger action.
1:a6f9586: 	 * 
1:a6f9586: 	 * UPDATE trigger is defined on LOB column with large data and hence it 
1:a6f9586: 	 * will run out of memory. For that reason, the test is disabled.
1:7c52163: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test3UpdateBeforeTrigger() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 
1:7c52163: 		s.execute("create trigger trigger1 no cascade before update of bl on table1 referencing " +
1:7c52163: 				"new as n_row for each row " +
1:7c52163: 				"select updates from table2 where table2.id = n_row.id");
1:7c52163: 		commit();
1:7c52163:    		runtest2UpdateTrigger();
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * The test case is exactly like test3UpdateBeforeTrigger except that the
1:7c52163: 	 * trigger action is a stored procedure call. The work done by the trigger
1:7c52163: 	 * action SQL in test3UpdateBeforeTrigger gets done inside the stored procedure
1:7c52163: 	 * for this test.
1:7c52163: 	 * 
1:a6f9586: 	 * UPDATE trigger is defined on LOB column with large data and hence it 
1:a6f9586: 	 * will run out of memory. For that reason, the test is disabled.
1:7c52163: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test3UpdateBeforeTriggerStoredProc() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 
1:7c52163:         s.execute("create procedure proc_test3_UpdateBeforeTrigger_select_table " +
1:7c52163:         		"(p1 int) parameter style java language "+
1:7c52163:         		"java READS SQL DATA external name "+
1:a6f9586:         		"'org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.proc_test3_UpdateBeforeTrigger_select_table'");
1:7c52163: 
1:7c52163: 		s.execute("create trigger trigger1 no cascade before update of bl on table1 REFERENCING " +
1:7c52163: 				"NEW as n_row for each row call proc_test3_UpdateBeforeTrigger_select_table(n_row.id)");
1:7c52163: 		commit();
1:7c52163:    		runtest2UpdateTrigger();
1:7c52163: 	}
1:7c52163: 	
1:7c52163: 	/**
1:7c52163: 	 * The is the stored procedure which gets called by the before delete 
1:7c52163: 	 * trigger action for the test test3UpdateBeforeTriggerStoredProc
1:7c52163: 	 * @param p1 new value of table1.id after the row gets inserted
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public static void proc_test3_UpdateBeforeTrigger_select_table(int p1) throws SQLException {
1:7c52163:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:7c52163:         PreparedStatement ps = conn.prepareStatement("select updates from " +
1:7c52163:         		"table2 where table2.id = " + p1);
1:7c52163:         ps.executeQuery();
1:7c52163:         conn.close();
1:7c52163: 	}
1:7c52163: 	
1:7c52163: 	/**
1:7c52163: 	 * The after update trigger on LOB column but the LOB column is referenced 
1:7c52163: 	 * in the trigger action. This is one case though where we do need to keep 
1:7c52163: 	 * before and after image since the LOB got updated and it is being used 
1:7c52163: 	 * in trigger action. 
1:7c52163: 	 * 
1:7c52163: 	 * It used 2 tables to demonstrate the problem.
1:7c52163: 	 * table1 has a BLOB column
1:7c52163: 	 * table2 gets updated with LOB column value from triggering table,
1:7c52163: 	 * 	the same LOB which got UPDATEd and caused the trigger to fire. The 
1:7c52163: 	 * 	trigger got fired for update of LOB column on the triggering
1:7c52163: 	 * 	table.
1:a6f9586: 	 * 
1:a6f9586: 	 * UPDATE trigger is defined on LOB column with large data and hence it 
1:a6f9586: 	 * will run out of memory. For that reason, the test is disabled.
1:7c52163: 	 * 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test4UpdateAfterTriggerAccessLOB() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163: 	    Statement s = createStatement();
1:7c52163: 
1:7c52163:         //The default table2 created by basicSetup does not match the 
1:7c52163:         //requirement of this test so dropping and recreating it.
1:7c52163:         s.execute("drop table table2");
1:7c52163: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1:7c52163: 
1:7c52163: 		s.execute("create trigger trigger1 after update of bl on table1 referencing " +
1:7c52163: 			"new as n_row for each row " +
1:7c52163: 			"update table2 set bl_table2 = n_row.bl where table2.id = n_row.id");
1:7c52163: 
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 			"insert into table2 (id) values (?)");
1:7c52163: 		ps.setInt(1, 1);
1:7c52163:         ps.executeUpdate();
1:7c52163: 		commit();		
1:7c52163:    		runtest2UpdateTrigger();
1:7c52163: 	}
1:7c52163: 	
1:7c52163: 	/**
1:7c52163: 	 * The after update trigger on LOB column which then gets updated in the
1:7c52163: 	 * trigger action. So this test updates the LOB in the trigger action
1:a6f9586: 	 * and is also the cause of the update trigger to fire.
1:a6f9586: 	 * 
1:a6f9586: 	 * The UPDATE trigger access the large data in LOB column inside the 
1:a6f9586: 	 * trigger action which will cause the test to run out of memory. For
1:a6f9586: 	 * this reason, this test is disabled.
1:a6f9586: 	 *  
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */ 
1:7c52163: 	public void test4UpdateAfterTriggerUpdatedLOB() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 
1:7c52163:         //The default table1 created by basicSetup does not match the 
1:7c52163:         //requirement of this test so dropping and recreating it.
1:7c52163:         s.execute("drop table table1");
1:7c52163: 		s.execute("create table table1 (id int, status smallint, bl blob(2G), bl_null blob(2G))");
1:7c52163: 
1:7c52163:         s.execute("create trigger trigger1 after update of bl_null on table1 referencing " +
1:7c52163:     			"new as n_row for each row " +
1:7c52163:     			"update table1 set bl_null=n_row.bl where bl_null is null");
1:7c52163: 
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 			"insert into table1 values (?, 0, ?, ?)");
1:7c52163: 
1:7c52163: 		ps.setInt(1, 1);
1:7c52163:         ps.setBinaryStream(2, new LoopingAlphabetStream(lobsize), lobsize);
1:7c52163:         ps.setBinaryStream(3, new LoopingAlphabetStream(lobsize), lobsize);
1:7c52163:         ps.executeUpdate();
1:7c52163: 		commit();
1:7c52163:    		runtest3UpdateTrigger();
1:7c52163: 	}
1:7c52163: 	
1:7c52163: 	/**
1:7c52163: 	 * This test creates a BEFORE UPDATE trigger on LOB column and
1:7c52163: 	 * the trigger action selects "new" lob column from just updated 
1:7c52163: 	 * row. This test does access the LOB. 
1:a6f9586: 	 * 
1:a6f9586: 	 * The UPDATE trigger access the large data in LOB column inside the 
1:a6f9586: 	 * trigger action and it is defined on the LOB column which will cause 
1:a6f9586: 	 * the test to run out of memory. For this reason, this test is disabled.
1:a6f9586: 	 *  
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test4UpdateBeforeTrigger() throws SQLException{
1:c1193bf:         if (isDerby1482Fixed == false)
1:c1193bf:             return;
1:c1193bf: 
1:a6f9586: 		if (testWithLargeDataInLOB)
1:f246c9c: 			return;
1:f246c9c: 		
1:7c52163:         basicSetup();
1:7c52163: 	    Statement s = createStatement();
1:7c52163: 
1:7c52163:         //The default table2 created by basicSetup does not match the 
1:7c52163:         //requirement of this test so dropping and recreating it.
1:7c52163:         s.execute("drop table table2");
1:7c52163: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1:7c52163: 
1:7c52163: 		s.execute("create trigger trigger1 no cascade before update of bl on table1 referencing " +
1:7c52163: 			"new as n_row for each row " +
1:7c52163: 			"values(n_row.bl)");
1:7c52163: 
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 			"insert into table2 (id) values (?)");
1:7c52163: 		ps.setInt(1, 1);
1:7c52163:         ps.executeUpdate();
1:7c52163: 		commit();		
1:7c52163:    		runtest2UpdateTrigger();
1:7c52163: 	}
1:7c52163: 	 
1:7c52163: 	/**
1:7c52163: 	 * This test creates an AFTER INSERT trigger but has no REFERENCING
1:7c52163: 	 * clause, meaning that before and after values are not available to
1:7c52163: 	 * the trigger action.
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test5InsertAfterTriggerNoReferencingClause() throws SQLException{
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 		s.execute("create trigger trigger1 AFTER INSERT on table1 " +
1:7c52163: 			"insert into table2(id, updates) values (100, -1)");
1:7c52163: 		commit();
1:f246c9c:    		runtest1InsertTriggerTest();		       	
1:7c52163: 	}
1:7c52163: 	 
1:7c52163: 	/**
1:7c52163: 	 * This test creates an BEFORE INSERT trigger but has no REFERENCING
1:7c52163: 	 * clause, meaning that before and after values are not available to
1:7c52163: 	 * the trigger action.
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test5InsertBeforeTriggerNoReferencingClause() throws SQLException{
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 		s.execute("create trigger trigger1 NO CASCADE BEFORE INSERT on table1 " +
1:7c52163: 			"select updates from table2 where table2.id = 1");
1:7c52163: 		commit();
1:f246c9c:    		runtest1InsertTriggerTest();		       	
1:7c52163: 	}
1:7c52163: 	 
1:7c52163: 	/**
1:7c52163: 	 * This test creates an AFTER DELETE trigger but has no REFERENCING
1:7c52163: 	 * clause, meaning that before and after values are not available to
1:7c52163: 	 * the trigger action.
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test5DeleteAfterTriggerNoReferencingClause() throws SQLException{
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 		s.execute("create trigger trigger1 AFTER DELETE on table1 " +
1:7c52163: 				"delete from table2 where id=1");
1:7c52163: 		commit();
1:7c52163:    		runDeleteTriggerTest();		       	
1:7c52163: 	}
1:7c52163: 	
1:7c52163: 	/**
1:7c52163: 	 * This test creates an BEFORE DELETE trigger but has no REFERENCING
1:7c52163: 	 * clause, meaning that before and after values are not available to
1:7c52163: 	 * the trigger action. 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test5DeleteBeforeTriggerNoReferencingClause() throws SQLException{
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:7c52163: 		s.execute("create trigger trigger1 NO CASCADE BEFORE DELETE on table1 " +
1:7c52163: 				"select updates from table2 where table2.id = 1");
1:7c52163: 		commit();
1:7c52163:    		runDeleteTriggerTest();		       	
1:7c52163: 	}
1:7c52163: 
1:7c52163: 	/**
1:7c52163: 	 * This test creates an AFTER UPDATE trigger but has no REFERENCING
1:7c52163: 	 * clause, meaning that before and after values are not available to
1:7c52163: 	 * the trigger action. 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test5UpdateAfterTriggerNoReferencingClause() throws SQLException{
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:f246c9c: 		s.execute("create trigger trigger1 AFTER UPDATE of status on table1 " +
1:7c52163: 				"update table2 set updates = updates + 1 where table2.id = 1");
1:7c52163: 		commit();
1:7c52163:    		runtest1UpdateTrigger();		       	
1:7c52163: 	}
1:7c52163: 	
1:7c52163: 	/**
1:7c52163: 	 * This test creates an BEFORE UPDATE trigger but has no REFERENCING
1:7c52163: 	 * clause, meaning that before and after values are not available to
1:7c52163: 	 * the trigger action. 
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void test5UpdateBeforeTriggerNoReferencingClause() throws SQLException{
1:7c52163:         basicSetup();
1:7c52163:         Statement s = createStatement();
1:f246c9c: 		s.execute("create trigger trigger1 NO CASCADE BEFORE UPDATE of status on table1 " +
1:7c52163: 				"select updates from table2 where table2.id = 1");
1:7c52163: 		commit();
1:7c52163:    		runtest1UpdateTrigger();		       	
1:7c52163: 	}
1:f246c9c: 
1:7c52163: 	/**
1:a6f9586: 	 * This test create an AFTER UPDATE trigger but does not identify any
1:a6f9586: 	 * trigger columns. It has REFERENCING clause. Void of trigger columns
1:a6f9586: 	 * will cause all the columns to be read into memory.
1:a6f9586: 	 * 
1:a6f9586: 	 * When no trigger columns are defined for an UPDATE trigger, all the 
1:a6f9586: 	 * columns get read into memory. Since the trigger table has large data
1:a6f9586: 	 * in LOB columns, it will run out of memory. For that reason, the test 
1:a6f9586: 	 * is disabled.
1:a6f9586: 	 */
1:a6f9586: 	public void test6UpdateAfterTriggerNoTriggerColumn() throws SQLException{
1:a6f9586: 		if (testWithLargeDataInLOB)
1:a6f9586: 			return;
1:a6f9586: 		
1:a6f9586:         basicSetup();
1:a6f9586: 	    Statement s = createStatement();
1:a6f9586: 
1:a6f9586:         //The default table2 created by basicSetup does not match the 
1:a6f9586:         //requirement of this test so dropping and recreating it.
1:a6f9586:         s.execute("drop table table2");
1:a6f9586: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1:a6f9586: 		s.execute("create trigger trigger1 after update on table1 referencing " +
1:a6f9586: 				"new as n_row for each row " +
1:a6f9586: 				"update table2 set bl_table2 = n_row.bl where table2.id = n_row.id");
1:a6f9586: 
1:a6f9586: 		PreparedStatement ps = prepareStatement(
1:a6f9586: 				"insert into table2 (id) values (?)");
1:a6f9586: 		ps.setInt(1, 1);
1:a6f9586: 	    ps.executeUpdate();
1:a6f9586: 		commit();		
1:a6f9586:  		runtest2UpdateTrigger();
1:a6f9586: 	}
1:a6f9586: 
1:a6f9586: 	/**
1:7c52163: 	 * Following will do an insert into table1 which will cause insert 
1:f246c9c: 	 * trigger to fire. The insert does not involve the LOB column.
1:3b2562c: 	 *
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:f246c9c: 	public void runtest1InsertTriggerTest() throws SQLException{
1:f246c9c: 		PreparedStatement ps = prepareStatement(
1:f246c9c: 				"insert into table1(id, status) values(101, 0)");
1:f246c9c:         ps.executeUpdate();
1:f246c9c:         commit();
1:f246c9c: 	}
1:f246c9c: 	
1:f246c9c: 	/**
1:f246c9c: 	 * Following will do an insert into table1 which will cause insert 
1:f246c9c: 	 * trigger to fire. The insert involves the LOB column.
1:f246c9c: 	 *
1:f246c9c: 	 * @throws SQLException
1:f246c9c: 	 */
1:f246c9c: 	public void runtest2InsertTriggerTest() throws SQLException{
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 				"insert into table1(id, status, bl) values(101, 0, ?)");
1:7c52163:         ps.setBinaryStream(1, new LoopingAlphabetStream(lobsize), lobsize);
1:7c52163:         ps.executeUpdate();
1:7c52163:         commit();
1:7c52163: 	}
1:7c52163: 	
1:7c52163: 	/**
1:7c52163: 	 * Following will update a row in table1 which will cause update 
1:f246c9c: 	 * trigger to fire. The update does not involve the LOB column.
1:3b2562c: 	 *
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void runtest1UpdateTrigger() throws SQLException{
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 				"update table1 set status = 1 where id = 1");
1:7c52163:         ps.executeUpdate();
1:7c52163:         commit();
1:7c52163: 	}
1:7c52163: 	
1:7c52163: 	/**
1:7c52163: 	 * Following will update a row in table1 which will cause update 
1:f246c9c: 	 * trigger to fire. The update involves the LOB column.
1:3b2562c: 	 *
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void runtest2UpdateTrigger() throws SQLException{
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 				"update table1 set bl = ? where id = 1");
1:7c52163:         ps.setBinaryStream(1, new LoopingAlphabetStream(lobsize), lobsize);
1:7c52163:         ps.executeUpdate();
1:7c52163:         commit();
1:7c52163: 	}
1:7c52163: 	
1:7c52163: 	/**
1:7c52163: 	 * Following will update a row in table1 which will cause update 
1:f246c9c: 	 * trigger to fire. The update involves the LOB column.
1:3b2562c: 	 *
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void runtest3UpdateTrigger() throws SQLException{
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 				"update table1 set bl_null=null where id = 1");
1:7c52163:         ps.executeUpdate();
1:7c52163:         commit();
1:7c52163: 	}
1:7c52163: 	
1:7c52163: 	/**
1:7c52163: 	 * Following will delete a row from table1 which will cause delete 
5:7c52163: 	 * trigger to fire. 
1:3b2562c: 	 *
1:7c52163: 	 * @throws SQLException
1:7c52163: 	 */
1:7c52163: 	public void runDeleteTriggerTest() throws SQLException{
1:7c52163: 		PreparedStatement ps = prepareStatement(
1:7c52163: 				"delete from table1 where id=1");
1:7c52163:         ps.executeUpdate();
1:7c52163:         commit();
1:7c52163: 	}
1:7c52163: }
============================================================================
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:d9d1bc8
/////////////////////////////////////////////////////////////////////////
1: 	boolean isDerby1482Fixed = true;
commit:c1193bf
/////////////////////////////////////////////////////////////////////////
0: 	// DERBY-1482 has caused a regression which is being worked
0: 	// under DERBY-5121. Until DERBY-5121 is fixed, we want
0: 	// Derby to create triggers same as it is done in 10.6 and
0: 	// earlier. This in other words means that do not try to
0: 	// optimize how many columns are read from the trigger table,
0: 	// simply read all the columns from the trigger table. 
0: 	// Because of this, we need to disable the tests that were
0: 	// added as part of DERBY-1482 to check the column read
0: 	// optimization.
0: 	boolean isDerby1482Fixed = false;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (isDerby1482Fixed == false)
1:             return;
1: 
commit:c4728eb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
1: 	final int lobsize = 50000*1024;
/////////////////////////////////////////////////////////////////////////
1:         // JSR169 cannot run with tests with stored procedures
1:         // that do database access - for they require a
1:         // DriverManager connection to jdbc:default:connection;
1:         // DriverManager is not supported with JSR169.
1:         if (JDBC.vmSupportsJSR169()) 
1:         	return;
/////////////////////////////////////////////////////////////////////////
1:         // JSR169 cannot run with tests with stored procedures
1:         // that do database access - for they require a
1:         // DriverManager connection to jdbc:default:connection;
1:         // DriverManager is not supported with JSR169.
1:         if (JDBC.vmSupportsJSR169()) 
1:         	return;
/////////////////////////////////////////////////////////////////////////
1:         // JSR169 cannot run with tests with stored procedures
1:         // that do database access - for they require a
1:         // DriverManager connection to jdbc:default:connection;
1:         // DriverManager is not supported with JSR169.
1:         if (JDBC.vmSupportsJSR169()) 
1:         	return;
/////////////////////////////////////////////////////////////////////////
1:         // JSR169 cannot run with tests with stored procedures
1:         // that do database access - for they require a
1:         // DriverManager connection to jdbc:default:connection;
1:         // DriverManager is not supported with JSR169.
1:         if (JDBC.vmSupportsJSR169()) 
1:         	return;
commit:a6f9586
/////////////////////////////////////////////////////////////////////////
1: 	boolean testWithLargeDataInLOB = true;
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	 * 16)test5UpdateBeforeTriggerNoReferencingClause
1: 	 * 17)test6UpdateAfterTriggerNoTriggerColumn
1: 	 *  This test create an AFTER UPDATE trigger but does not identify any
1: 	 * trigger columns. It has REFERENCING clause. Void of trigger columns
1: 	 * will cause all the columns to be read into memory.
1: 	 * ****************
/////////////////////////////////////////////////////////////////////////
1:         // use small pageCacheSize so we don't run out of memory on the insert
1:         // of large LOB columns.
/////////////////////////////////////////////////////////////////////////
1: 	 * columns into another table. The triggering INSERT does not insert
1: 	 * any value into LOB column
1: 	public void test1InsertAfterTrigger() throws SQLException{	
1:    		runtest1InsertTriggerTest();		       	
/////////////////////////////////////////////////////////////////////////
1:         		"'org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.proc_test1_InsertAfterTrigger_update_table'");
1:    		runtest1InsertTriggerTest();		       	
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 * DELETE triggers read all the columns from the trigger table. Following
1: 	 * test is on a trigger table with large data in LOB columns and hence it
1: 	 * will run out of memory. For that reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 * DELETE triggers read all the columns from the trigger table. Following
1: 	 * test is on a trigger table with large data in LOB columns and hence it
1: 	 * will run out of memory. For that reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1:         		"'org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.proc_test1_DeleteAfterTrigger_update_table'");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         		"'org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.proc_test1_UpdateAfterTrigger_update_table'");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:    		runtest1InsertTriggerTest();		       	
/////////////////////////////////////////////////////////////////////////
1:         		"'org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.proc_test1_InsertBeforeTrigger_select_table'");
1: 		runtest1InsertTriggerTest();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 * DELETE triggers read all the columns from the trigger table. Following
1: 	 * test is on a trigger table with large data in LOB columns and hence it
1: 	 * will run out of memory. For that reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 * DELETE triggers read all the columns from the trigger table. Following
1: 	 * test is on a trigger table with large data in LOB columns and hence it
1: 	 * will run out of memory. For that reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1:         		"'org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.proc_test1_DeleteBeforeTrigger_select_table'");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         		"'org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.proc_test1_UpdateBeforeTrigger_select_table'");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 * INSERT trigger in this test is inserting large data in the LOB column
1: 	 * which will be used in the INSERT trigger and hence it will run out of 
1: 	 * memory. For that reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 * DELETE triggers read all the columns from the trigger table. Following
1: 	 * test is on a trigger table with large data in LOB columns and hence it
1: 	 * will run out of memory. For that reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1: 	 * UPDATE trigger in this test is working with large data in the LOB column
1: 	 * inside the trigger action and hence it will run out of memory. For that 
1: 	 * reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 * INSERT trigger in this test is inserting large data in the LOB column
1: 	 * which will be used in the INSERT trigger and hence it will run out of 
1: 	 * memory. For that reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 * UPDATE trigger in this test is working with large data in the LOB column
1: 	 * inside the trigger action and hence it will run out of memory. For that 
1: 	 * reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 * INSERT trigger in this test is inserting large data in the LOB column
1: 	 * which will be used in the INSERT trigger action and hence it will run  
1: 	 * out of memory. For that reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 * DELETE triggers read all the columns from the trigger table. Following
1: 	 * test is on a trigger table with large data in LOB columns and hence it
1: 	 * will run out of memory. For that reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 * UPDATE trigger in this test is working with large data in the LOB column
1: 	 * inside the trigger action and hence it will run out of memory. For that 
1: 	 * reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1: 	 * UPDATE trigger is defined on LOB column with large data and hence it 
1: 	 * will run out of memory. For that reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1: 	 * UPDATE trigger is defined on LOB column with large data and hence it 
1: 	 * will run out of memory. For that reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1:         		"'org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.proc_test3_UpdateAfterTrigger_update_table'");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 * UPDATE trigger is defined on LOB column with large data and hence it 
1: 	 * will run out of memory. For that reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 * UPDATE trigger is defined on LOB column with large data and hence it 
1: 	 * will run out of memory. For that reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1:         		"'org.apache.derbyTesting.functionTests.tests.memory.TriggerTests.proc_test3_UpdateBeforeTrigger_select_table'");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * UPDATE trigger is defined on LOB column with large data and hence it 
1: 	 * will run out of memory. For that reason, the test is disabled.
1: 	 * 
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	 * and is also the cause of the update trigger to fire.
1: 	 * 
1: 	 * The UPDATE trigger access the large data in LOB column inside the 
1: 	 * trigger action which will cause the test to run out of memory. For
1: 	 * this reason, this test is disabled.
1: 	 *  
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 * The UPDATE trigger access the large data in LOB column inside the 
1: 	 * trigger action and it is defined on the LOB column which will cause 
1: 	 * the test to run out of memory. For this reason, this test is disabled.
1: 	 *  
1: 		if (testWithLargeDataInLOB)
/////////////////////////////////////////////////////////////////////////
1: 	 * This test create an AFTER UPDATE trigger but does not identify any
1: 	 * trigger columns. It has REFERENCING clause. Void of trigger columns
1: 	 * will cause all the columns to be read into memory.
1: 	 * 
1: 	 * When no trigger columns are defined for an UPDATE trigger, all the 
1: 	 * columns get read into memory. Since the trigger table has large data
1: 	 * in LOB columns, it will run out of memory. For that reason, the test 
1: 	 * is disabled.
1: 	 */
1: 	public void test6UpdateAfterTriggerNoTriggerColumn() throws SQLException{
1: 		if (testWithLargeDataInLOB)
1: 			return;
1: 		
1:         basicSetup();
1: 	    Statement s = createStatement();
1: 
1:         //The default table2 created by basicSetup does not match the 
1:         //requirement of this test so dropping and recreating it.
1:         s.execute("drop table table2");
1: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1: 		s.execute("create trigger trigger1 after update on table1 referencing " +
1: 				"new as n_row for each row " +
1: 				"update table2 set bl_table2 = n_row.bl where table2.id = n_row.id");
1: 
1: 		PreparedStatement ps = prepareStatement(
1: 				"insert into table2 (id) values (?)");
1: 		ps.setInt(1, 1);
1: 	    ps.executeUpdate();
1: 		commit();		
1:  		runtest2UpdateTrigger();
1: 	}
1: 
1: 	/**
commit:f246c9c
/////////////////////////////////////////////////////////////////////////
0: 	boolean isDerby1482Fixed = false;
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
1:    		runtest2InsertTriggerTest();		       	
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
1:    		runtest2InsertTriggerTest();		       	
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
1:    		runtest2InsertTriggerTest();		       	
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		runtest2InsertTriggerTest();
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
1:        basicSetup();
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0:    		runtest2InsertTriggerTest();
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0:    		runtest2InsertTriggerTest();
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0:    		runtest2InsertTriggerTest();
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
1: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
0: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
0: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
0: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
0: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
0: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
0: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
0: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		if (isDerby1482Fixed == false)
0: 			return;
1: 		
/////////////////////////////////////////////////////////////////////////
1:    		runtest1InsertTriggerTest();		       	
/////////////////////////////////////////////////////////////////////////
1:    		runtest1InsertTriggerTest();		       	
/////////////////////////////////////////////////////////////////////////
1: 		s.execute("create trigger trigger1 AFTER UPDATE of status on table1 " +
/////////////////////////////////////////////////////////////////////////
1: 		s.execute("create trigger trigger1 NO CASCADE BEFORE UPDATE of status on table1 " +
1: 
1: 	 * trigger to fire. The insert does not involve the LOB column.
1: 	public void runtest1InsertTriggerTest() throws SQLException{
1: 		PreparedStatement ps = prepareStatement(
1: 				"insert into table1(id, status) values(101, 0)");
1:         ps.executeUpdate();
1:         commit();
1: 	}
1: 	
1: 	/**
1: 	 * Following will do an insert into table1 which will cause insert 
1: 	 * trigger to fire. The insert involves the LOB column.
1: 	 *
1: 	 * @throws SQLException
1: 	 */
1: 	public void runtest2InsertTriggerTest() throws SQLException{
/////////////////////////////////////////////////////////////////////////
1: 	 * trigger to fire. The update does not involve the LOB column.
/////////////////////////////////////////////////////////////////////////
1: 	 * trigger to fire. The update involves the LOB column.
/////////////////////////////////////////////////////////////////////////
1: 	 * trigger to fire. The update involves the LOB column.
/////////////////////////////////////////////////////////////////////////
commit:7c52163
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Repro for DERBY-1482:
1:  * Update triggers on tables with blob columns stream blobs
1:  * into memory even when the blobs are not referenced/accessed.
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.memory;
1: import java.sql.*;
1: import java.util.Properties;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: public class TriggerTests extends BaseJDBCTestCase {
1: 
0: 	final int lobsize = 300000*1024;
1: 	/**
1: 	 * Insert trigger tests
1: 	 * ****************
1: 	 * 1)test1InsertAfterTrigger
1: 	 * 	This test creates an AFTER INSERT trigger which inserts non-lob
1: 	 * columns into another table.
1: 	 * ****************
1: 	 * 2)test1InsertAfterTriggerStoredProc
1: 	 * 	The test case is exactly like test1InsertAfterTrigger except that the
1: 	 * trigger action is a stored procedure call. The work done by the trigger
1: 	 * action SQL in test1InsertAfterTrigger gets done inside the stored procedure
1: 	 * for this test.
1: 	 * ****************
1: 	 * 3)test1InsertBeforeTrigger
1: 	 * 	This test creates a BEFORE INSERT trigger which selects 
1: 	 * columns from another table using "new" non-lob column for 
1: 	 * join clause. 
1: 	 * ****************
1: 	 * 4)test1InsertBeforeTriggerStoredProc
1: 	 * 	The test case is exactly like test1InsertBeforeTrigger except that the
1: 	 * trigger action is a stored procedure call. The work done by the trigger
1: 	 * action SQL in test1InsertBeforeTrigger gets done inside the stored procedure
1: 	 * for this test.
1: 	 * ****************
1: 	 * Can't write stored procedure calls for trigger actions for test2
1: 	 * because I will need to pass LOBs as parameters to the stored
1: 	 * procedure which is not possible at this point.
1: 	 * ****************
1: 	 * 5)test2InsertAfterTriggerAccessLOB
1: 	 * 	This test creates an AFTER INSERT trigger which in it's trigger action
1: 	 * inserts lob columns from triggering table into another table. So, this
1: 	 * test does access the LOB from the triggering table inside the trigger
1: 	 * action. 
1: 	 * ****************
1: 	 * 6)test2InsertAfterTriggerUpdatedLOB
1: 	 * 	This test creates an AFTER INSERT trigger which in it's trigger action
1: 	 * updates a lob column from the row just inserted. So, this test does
1: 	 * update the LOB from the triggering table inside the trigger
1: 	 * action. 
1: 	 * ****************
1: 	 * 7)test2InsertBeforeTriggerAccessLOB
1: 	 * 	This test creates a BEFORE INSERT trigger which selects "new"
1: 	 * lob column from just inserted row. This test does access the
1: 	 * LOB.
1: 	 * ****************
1: 	 * 8)test5InsertAfterTriggerNoReferencingClause
1: 	 * 	This test creates an AFTER INSERT trigger but has not REFERENCING
1: 	 * clause, meaning that before and after values are not available to
1: 	 * the trigger action. 
1: 	 * ****************
1: 	 * 9)test5InsertBeforeTriggerNoReferencingClause
1: 	 * 	This test creates an BEFORE INSERT trigger but has no REFERENCING
1: 	 * clause, meaning that before and after values are not available to
1: 	 * the trigger action.
1: 	 * ****************
1: 	 * 
1: 	 * 
1: 	 * 
1: 	 * 
1: 	 * 
1: 	 * Delete trigger tests
1: 	 * ****************
1: 	 * 1)test1DeleteAfterTrigger
1: 	 * 	This test creates an AFTER DELETE trigger which delets from another
1: 	 * table using non-lob from the triggering table in the where clause.
1: 	 * ****************
1: 	 * 2)test1DeleteAfterTriggerStoredProc
1: 	 * 	The test case is exactly like test1DeleteAfterTrigger except that the
1: 	 * trigger action is a stored procedure call. The work done by the trigger
1: 	 * action SQL in test1DeleteAfterTrigger gets done inside the stored procedure
1: 	 * for this test.
1: 	 * ****************
1: 	 * 3)test1DeleteBeforeTrigger
1: 	 * 	This test creates a BEFORE DELETE trigger which selects 
1: 	 * columns from another table using "new" non-lob column for 
1: 	 * join clause.
1: 	 * ****************
1: 	 * 4)test1DeleteBeforeTriggerStoredProc
1: 	 * 	The test case is exactly like test1DeleteBeforeTrigger except that the
1: 	 * trigger action is a stored procedure call. The work done by the trigger
1: 	 * action SQL in test1DeleteBeforeTrigger gets done inside the stored procedure
1: 	 * for this test.
1: 	 * ****************
1: 	 * Can't write stored procedure calls for trigger actions for test2
1: 	 * because I will need to pass LOBs as parameters to the stored
1: 	 * procedure which is not possible at this point.
1: 	 * ****************
1: 	 * 5)test2DeleteAfterTriggerAccessLOB
1: 	 * 	This test creates an AFTER DELETE trigger which in it's trigger action
1: 	 * deletes row from another table using triggering table's "new" LOB value
1: 	 * in the join clause. So, this test does access the LOB from the 
1: 	 * triggering table inside the trigger action.
1: 	 * ****************
1: 	 * ****************
1: 	 * 6)test2DeleteBeforeTriggerAccessLOB
1: 	 * 	This test creates a BEFORE DELETE trigger which selects "old"
1: 	 * lob column from just deleted row. This test does access the
1: 	 * LOB.
1: 	 * ****************
1: 	 * 7)test5DeleteAfterTriggerNoReferencingClause
1: 	 * 	This test creates an AFTER DELETE trigger but has no REFERENCING
1: 	 * clause, meaning that before and after values are not available to
1: 	 * the trigger action.
1: 	 * ****************
1: 	 * 8)test5DeleteBeforeTriggerNoReferencingClause
1: 	 * 	This test creates an BEFORE DELETE trigger but has no REFERENCING
1: 	 * clause, meaning that before and after values are not available to
1: 	 * the trigger action. 
1: 	 * ****************
1: 	 * 
1: 	 * 
1: 	 * 
1: 	 * 
1: 	 * Update trigger tests
1: 	 * ****************
1: 	 * 1)test1UpdateAfterTrigger -
1: 	 * 	This test creates an AFTER UPDATE trigger which is declared on a
1: 	 * non-LOB column. The trigger action does not access the LOB column.
1: 	 * ****************
1: 	 * 2)test1UpdateAfterTriggerStoredProc
1: 	 * 	The test case is exactly like test1UpdateAfterTrigger except that the
1: 	 * trigger action is a stored procedure call. The work done by the trigger
1: 	 * action SQL in test1UpdateAfterTrigger gets done inside the stored procedure
1: 	 * for this test.
1: 	 * ****************
1: 	 * 3)test1UpdateBeforeTrigger
1: 	 * 	This test creates a BEFORE UPDATE trigger which is declared
1: 	 * on a non-LOB column. The trigger action selects columns from 
1: 	 * another table using "new" non-lob column for join clause. 
1: 	 * ****************
1: 	 * 4)test1UpdateBeforeTriggerStoredProc
1: 	 * 	The test case is exactly like test1UpdateBeforeTrigger except that the
1: 	 * trigger action is a stored procedure call. The work done by the trigger
1: 	 * action SQL in test1UpdateBeforeTrigger gets done inside the stored procedure
1: 	 * for this test.
1: 	 * ****************
1: 	 * Can't write stored procedure calls for trigger actions for test2
1: 	 * because I will need to pass LOBs as parameters to the stored
1: 	 * procedure which is not possible at this point.
1: 	 * ****************
1: 	 * 5)test2UpdateAfterTriggerAccessLOB
1: 	 * 	The after update trigger on non-LOB column but the LOB column is
1: 	 * referenced in the trigger action. So, this test does access the LOB 
1: 	 * from the triggering table inside the trigger action. 
1: 	 * ****************
1: 	 * 6)test2UpdateAfterTriggerUpdatedLOB
1: 	 * 	This test creates an AFTER UPDATE trigger which in it's trigger action
1: 	 * updates a lob column from the row that just got updated. So, this test 
1: 	 * does update the LOB from the triggering table inside the trigger
1: 	 * action. 
1: 	 * ****************
1: 	 * 7)test2UpdateBeforeTriggerAccessLOB
1: 	 * 	This test creates a BEFORE UPDATE trigger which selects "new"
1: 	 * lob column from just updated row. This test does access the
1: 	 * LOB. 
1: 	 * ****************
1: 	 * 8)test3UpdateAfterTrigger
1: 	 * 	The after update trigger is defined on LOB column but the LOB column 
1: 	 * is not referenced in the trigger action.
1: 	 * ****************
1: 	 * 9)test3UpdateAfterTriggerStoredProc
1: 	 *  The test case is exactly like test3UpdateAfterTrigger except that the
1: 	 * trigger action is a stored procedure call. The work done by the trigger
1: 	 * action SQL in test3UpdateAfterTrigger gets done inside the stored procedure
1: 	 * for this test.
1: 	 * ****************
1: 	 * 10)test3UpdateBeforeTrigger
1: 	 * 	This test creates a BEFORE UPDATE trigger which selects a row
1: 	 * from another table using "new" non-LOB column from the triggering
1: 	 * table. This test has update trigger defined on the LOB column
1: 	 * but does not access/update that LOB column in the trigger action.
1: 	 * ****************
1: 	 * 11)test3UpdateBeforeTriggerStoredProc
1: 	 * 	The test case is exactly like test3UpdateBeforeTrigger except that the
1: 	 * trigger action is a stored procedure call. The work done by the trigger
1: 	 * action SQL in test3UpdateBeforeTrigger gets done inside the stored procedure
1: 	 * for this test.
1: 	 * ****************
1: 	 * 12)test4UpdateAfterTriggerAccessLOB
1: 	 * 	The after update trigger on LOB column but the LOB column is referenced 
1: 	 * in the trigger action. This is one case though where we do need to keep 
1: 	 * before and after image since the LOB got updated and it is being used in 
1: 	 * trigger action.
1: 	 * ****************
1: 	 * 13)test4UpdateAfterTriggerUpdatedLOB
1: 	 * 	The after update trigger on LOB column which then gets updated in the
1: 	 * trigger action. So this test updates the LOB in the trigger action
1: 	 * and is also the cause of the update trigger to fire. 
1: 	 * ****************
1: 	 * 14)test4UpdateBeforeTrigger
1: 	 * ****************
1: 	 * 15)test5UpdateAfterTriggerNoReferencingClause
1: 	 * 	This test creates an AFTER UPDATE trigger but has no REFERENCING
1: 	 * clause, meaning that before and after values are not available to
1: 	 * the trigger action. 
1: 	 * ****************
0: 	 * 15)test5UpdateBeforeTriggerNoReferencingClause
1: 	 * 	This test creates an BEFORE UPDATE trigger but has no REFERENCING
1: 	 * clause, meaning that before and after values are not available to
1: 	 * the trigger action. 
1: 	 * ****************
1: 	 */
1:     public TriggerTests(String name) {
1:         super(name);
1:     }
1: 	
1:     public static Test suite() {
1:         Test suite = new CleanDatabaseTestSetup(TestConfiguration
1:                 .embeddedSuite(TriggerTests.class));
1:         Properties p = new Properties();
0:         // use small pageCacheSize so we don't run out of memory on the insert.
1:         p.setProperty("derby.storage.pageCacheSize", "100");
1:         return new SystemPropertyTestSetup(suite,p);
1:     }
1: 
1: 	/**
1: 	 * Create the basic tables and data expected by almost all the tests. If a
1: 	 * particular test needs anything else, that test will take care of it.
1: 	 * @throws SQLException
1: 	 */
1: 	public void basicSetup() throws SQLException{
1:         Statement s = createStatement();
1: 		try {
1: 			s.execute("drop table table1");
1: 		} catch (SQLException sqle) {}
1: 
1: 		try {
1: 			s.execute("drop table table2");
1: 		} catch (SQLException sqle) {}
1: 
1: 		try {
0: 			s.execute("drop table table3");
1: 		} catch (SQLException sqle) {}
1: 
1: 		try {
1: 			s.execute("drop trigger trigger1");
1: 		} catch (SQLException sqle) {}
1: 
1: 		try {
1: 			s.execute("drop trigger trigger2");
1: 		} catch (SQLException sqle) {}
1: 
1: 		//table1 is the main table on which all the testing is done and it 
1: 		//uses table2 at times to do DMLs as part of it's trigger action.
1: 		s.execute("create table table1 (id int, status smallint, bl blob(2G))");
1: 		s.execute("create index i1 on table1(id)");
1: 		//table2 is mostly used as part of the trigger action for table1
1: 		s.execute("create table table2 (id int, updates int default 0)");
1: 		s.execute("create index i2 on table2(id)");
1: 		//table3 does not have lob. It is mostly used to show how things work
1: 		//fine when they may not for table1 since table1 has LOB column.
1: 		s.execute("create table table3 (id int, status smallint, score int)");
1: 		s.execute("create index i3 on table3(id)");
1: 
1: 		//load data in table1
1: 		PreparedStatement ps = prepareStatement(
1: 		"insert into table1 values (?, 0, ?)");
1: 		ps.setInt(1, 1);
1:         ps.setBinaryStream(2, new LoopingAlphabetStream(lobsize), lobsize);
1:         ps.executeUpdate();
1: 
1: 		//load data in table2
1: 		ps = prepareStatement(
1: 			"insert into table2 (id) values (?)");
1: 		ps.setInt(1, 1);
1:         ps.executeUpdate();
1: 
1: 		//load data in table3
1: 		ps = prepareStatement(
1: 			"insert into table3 values (?, 0, ?)");
1: 		ps.setInt(1, 1);
1: 		ps.setInt(2, 2);
1:         ps.executeUpdate();
1: 
1: 		commit();
1: 	}
1: 
1: 	/**
1: 	 * This test creates an AFTER INSERT trigger which inserts non-lob
1: 	 * columns into another table.
1: 	 * @throws SQLException
1: 	 */
0: 	public void test1InsertAfterTrigger() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 		s.execute("create trigger trigger1 AFTER INSERT on table1 referencing " +
1: 			"new as n_row for each row " +
1: 			"insert into table2(id, updates) values (n_row.id, -1)");
1: 		commit();
0:    		runInsertTriggerTest();		       	
1: 	}
1: 
1: 	/**
1: 	 * The test case is exactly like test1InsertAfterTrigger except that the
1: 	 * trigger action is a stored procedure call. The work done by the trigger
1: 	 * action SQL in test1InsertAfterTrigger gets done inside the stored procedure
1: 	 * for this test.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test1InsertAfterTriggerStoredProc() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1:         s.execute("create procedure proc_test1_InsertAfterTrigger_update_table " +
1:         		"(p1 int) parameter style java language "+
1:         		"java MODIFIES SQL DATA external name "+
0:         		"'org.apache.derbyTesting.functionTests.tests.lang.derby1482TriggerTests.proc_test1_InsertAfterTrigger_update_table'");
1: 		s.execute("create trigger trigger1 after INSERT on table1 referencing " +
1: 			"new as n_row for each row " +
1: 			"call proc_test1_InsertAfterTrigger_update_table(n_row.id)");
1: 		commit();
0:    		runInsertTriggerTest();		       	
1: 	}
1: 
1: 	/**
1: 	 * The is the stored procedure which gets called by the after insert 
1: 	 * trigger action for the test test1InsertAfterTriggerStoredProc
1: 	 * @param p1 new value of table1.id after the row gets inserted
1: 	 * @throws SQLException
1: 	 */
1: 	public static void proc_test1_InsertAfterTrigger_update_table(int p1) throws SQLException {
0:     	System.out.println("Test1 : Inside the procedure called by the INSERT AFTER TRIGGER action");
1:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:         PreparedStatement ps = conn.prepareStatement(
1:         		"insert into table2(id, updates) values (" + p1 + ",-1)");
1:         ps.executeUpdate();
1:         conn.close();
1: 	}
1: 
1: 	/**
1: 	 * This test creates an AFTER DELETE trigger which delets from another
1: 	 * table using non-lob from the triggering table in the where clause.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test1DeleteAfterTrigger() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 		s.execute("create trigger trigger1 after DELETE on table1 referencing " +
1: 				"old as o_row for each row " +
1: 				"delete from table2 where id=o_row.id");
1: 		commit();
1: 		runDeleteTriggerTest();		       	
1: 	}
1: 
1: 	/**
1: 	 * The test case is exactly like test1DeleteAfterTrigger except that the
1: 	 * trigger action is a stored procedure call. The work done by the trigger
1: 	 * action SQL in test1DeleteAfterTrigger gets done inside the stored procedure
1: 	 * for this test.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test1DeleteAfterTriggerStoredProc() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1:         s.execute("create procedure proc_test1_DeleteAfterTrigger_update_table " +
1:         		"(p1 int) parameter style java language "+
1:         		"java MODIFIES SQL DATA external name "+
0:         		"'org.apache.derbyTesting.functionTests.tests.lang.derby1482TriggerTests.proc_test1_DeleteAfterTrigger_update_table'");
1: 
1: 		s.execute("create trigger trigger1 after DELETE on table1 referencing " +
1: 				"old as o_row for each row " +
1: 				"call proc_test1_DeleteAfterTrigger_update_table(o_row.id)");
1: 		commit();
1: 		runDeleteTriggerTest();		       	
1: 	}
1: 
1: 	/**
1: 	 * The is the stored procedure which gets called by the after delete 
1: 	 * trigger action for the test test1DeleteAfterTriggerStoredProc
1: 	 * @param p1 old value of table1.id before the row gets deleted
1: 	 * @throws SQLException
1: 	 */
1: 	public static void proc_test1_DeleteAfterTrigger_update_table(int p1) throws SQLException {
0:     	System.out.println("Test1 : Inside the procedure called by the DELETE AFTER TRIGGER action");
1:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:         PreparedStatement ps = conn.prepareStatement(
1:         		"delete from table1 where id=" + p1);
1:         ps.executeUpdate();
1:         conn.close();
1: 	}
1: 	
1: 	/**
1: 	 * This test creates an AFTER UPDATE trigger which is declared on a
1: 	 * non-LOB column. The trigger action does not access the LOB column.
1: 	 * 
1: 	 * It uses 2 tables to demonstrate the problem. 
1: 	 * table1 has a BLOB column
1: 	 * table2 gets updated as part of AFTER UPDATE trigger of 
1: 	 * 	non-BLOB column on table1
1: 	 * 
1: 	 * table1 has an after update trigger defined on column "status" so
1: 	 * 	that table2 will get updated as part of trigger action
1: 	 * 
1: 	 * Notice that the trigger does not reference the BLOB column in 
1: 	 * 	table1 and update that caused the trigger is not updating the 
1: 	 * 	BLOB column
1: 	 * 
1: 	 * @throws SQLException
1: 	 */
1: 	public void test1UpdateAfterTrigger() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 		s.execute("create trigger trigger1 after update of status on table1 referencing " +
1: 			"new as n_row for each row " +
1: 			"update table2 set updates = updates + 1 where table2.id = n_row.id");
1: 		commit();
1: 		runtest1UpdateTrigger();
1: 	}
1: 
1: 	/**
1: 	 * The test case is exactly like test1UpdateAfterTrigger except that the
1: 	 * trigger action is a stored procedure call. The work done by the trigger
1: 	 * action SQL in test1UpdateAfterTrigger gets done inside the stored procedure
1: 	 * for this test.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test1UpdateAfterTriggerStoredProc() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1:         s.execute("create procedure proc_test1_UpdateAfterTrigger_update_table " +
1:         		"(p1 int) parameter style java language "+
1:         		"java MODIFIES SQL DATA external name "+
0:         		"'org.apache.derbyTesting.functionTests.tests.lang.derby1482TriggerTests.proc_test1_UpdateAfterTrigger_update_table'");
1: 
1: 		s.execute("create trigger trigger1 after update of status on table1 REFERENCING " +
1: 				"NEW as n_row for each row call proc_test1_UpdateAfterTrigger_update_table(n_row.id)");
1: 		commit();
1:    		runtest1UpdateTrigger();
1: 	}
1: 
1: 	/**
1: 	 * The is the stored procedure which gets called by the after update 
1: 	 * trigger action for the test test1UpdateAfterTriggerStoredProc
1: 	 * @param p1 new value of table1.id after the row gets updated
1: 	 * @throws SQLException
1: 	 */
1: 	public static void proc_test1_UpdateAfterTrigger_update_table(int p1) throws SQLException {
0:     	System.out.println("Test1 : Inside the procedure called by the UPDATE AFTER TRIGGER action");
1:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:         PreparedStatement ps = conn.prepareStatement("update table2 "+
1:         		"set updates = updates + 1 where table2.id = " + p1);
1:         ps.executeUpdate();
1:         conn.close();
1: 	}
1: 
1: 	/**
1: 	 * This test creates a BEFORE INSERT trigger which selects 
1: 	 * columns from another table using "new" non-lob column for 
1: 	 * join clause.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test1InsertBeforeTrigger() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 		s.execute("create trigger trigger1 no cascade before INSERT on table1 referencing " +
1: 			"new as n_row for each row " +
1: 			"select updates from table2 where table2.id = n_row.id");
1: 		commit();
0:    		runInsertTriggerTest();		       	
1: 	}
1: 
1: 	/**
1: 	 * The test case is exactly like test1InsertBeforeTrigger except that the
1: 	 * trigger action is a stored procedure call. The work done by the trigger
1: 	 * action SQL in test1InsertBeforeTrigger gets done inside the stored procedure
1: 	 * for this test.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test1InsertBeforeTriggerStoredProc() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1:         s.execute("create procedure proc_test1_InsertBeforeTrigger_select_table " +
1:         		"(p1 int) parameter style java language "+
1:         		"java READS SQL DATA external name "+
0:         		"'org.apache.derbyTesting.functionTests.tests.lang.derby1482TriggerTests.proc_test1_InsertBeforeTrigger_select_table'");
1: 		s.execute("create trigger trigger1 no cascade before INSERT on table1 referencing " +
1: 			"new as n_row for each row call proc_test1_InsertBeforeTrigger_select_table(n_row.id)");
1: 		commit();
0: 		runInsertTriggerTest();
1: 	}
1: 	
1: 	/**
1: 	 * The is the stored procedure which gets called by the before insert 
1: 	 * trigger action for the test test1InsertBeforeTriggerStoredProc
1: 	 * @param p1 new value of table1.id after the row gets inserted
1: 	 * @throws SQLException
1: 	 */
1: 	public static void proc_test1_InsertBeforeTrigger_select_table(int p1) throws SQLException {
0:     	System.out.println("Test1 : Inside the procedure called by the INSERT BEFORE TRIGGER action");
1:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:         PreparedStatement ps = conn.prepareStatement("select updates from " +
1:         		"table2 where table2.id = " + p1);
1:         ps.executeQuery();
1:         conn.close();
1: 	}
1: 
1: 	/**
1: 	 * This test creates a BEFORE DELETE trigger which selects 
1: 	 * columns from another table using "new" non-lob column for 
1: 	 * join clause.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test1DeleteBeforeTrigger() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 		s.execute("create trigger trigger1 no cascade before DELETE on table1 referencing " +
1: 				"old as o_row for each row " +
1: 				"select updates from table2 where table2.id = o_row.id");
1: 		commit();
1:    		runDeleteTriggerTest();		       	
1: 	}
1: 
1: 	/**
1: 	 * The test case is exactly like test1DeleteBeforeTrigger except that the
1: 	 * trigger action is a stored procedure call. The work done by the trigger
1: 	 * action SQL in test1DeleteBeforeTrigger gets done inside the stored procedure
1: 	 * for this test.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test1DeleteBeforeTriggerStoredProc() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 
1:         s.execute("create procedure proc_test1_DeleteBeforeTrigger_select_table " +
1:         		"(p1 int) parameter style java language "+
1:         		"java READS SQL DATA external name "+
0:         		"'org.apache.derbyTesting.functionTests.tests.lang.derby1482TriggerTests.proc_test1_DeleteBeforeTrigger_select_table'");
1: 
1:         s.execute("create trigger trigger1 no cascade before DELETE on table1 referencing " +
1: 				"old as o_row for each row call proc_test1_DeleteBeforeTrigger_select_table(o_row.id)");
1: 		commit();
1:    		runDeleteTriggerTest();		       	
1: 	}
1: 	
1: 	/**
1: 	 * The is the stored procedure which gets called by the before delete 
1: 	 * trigger action for the test test1DeleteBeforeTriggerStoredProc
1: 	 * @param p1 old value of table1.id before the row gets deleted
1: 	 * @throws SQLException
1: 	 */
1: 	public static void proc_test1_DeleteBeforeTrigger_select_table(int p1) throws SQLException {
0:     	System.out.println("Test1 : Inside the procedure called by the DELETE BEFORE TRIGGER action");
1:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:         PreparedStatement ps = conn.prepareStatement("select updates from " +
1:         		"table2 where table2.id = " + p1);
1:         ps.executeQuery();
1:         conn.close();
1: 	}
1: 
1: 	/**
1: 	 * This test creates a BEFORE UPDATE trigger which is declared
1: 	 * on a non-LOB column. The trigger action selects columns from 
1: 	 * another table using "new" non-lob column for join clause. 
1: 	 * 
1: 	 * It uses 2 tables to demonstrate the problem. 
1: 	 * table1 has a BLOB column
1: 	 * table2 gets updated as part of AFTER UPDATE trigger of 
1: 	 * 	non-BLOB column on table1
1: 	 * 
1: 	 * table1 has a before update trigger defined on column "status" so
1: 	 * that there will be a select done from table2 as part of trigger 
1: 	 * action.
1: 	 * 
1: 	 * Notice that the trigger does not reference the BLOB column in 
1: 	 * 	table1 and update that caused the trigger is not updating the 
1: 	 * 	BLOB column
1: 	 * 
1: 	 * @throws SQLException
1: 	 */
1: 	public void test1UpdateBeforeTrigger() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 
1: 		s.execute("create trigger trigger1 no cascade before update of status on table1 referencing " +
1: 			"new as n_row for each row " +
1: 			"select updates from table2 where table2.id = n_row.id");
1: 		commit();
1:    		runtest1UpdateTrigger();
1: 	}
1: 
1: 	/**
1: 	 * The test case is exactly like test1UpdateBeforeTrigger except that the
1: 	 * trigger action is a stored procedure call. The work done by the trigger
1: 	 * action SQL in test1UpdateBeforeTrigger gets done inside the stored procedure
1: 	 * for this test.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test1UpdateBeforeTriggerStoredProc() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1:         s.execute("create procedure proc_test1_UpdateBeforeTrigger_select_table " +
1:         		"(p1 int) parameter style java language "+
1:         		"java READS SQL DATA external name "+
0:         		"'org.apache.derbyTesting.functionTests.tests.lang.derby1482TriggerTests.proc_test1_UpdateBeforeTrigger_select_table'");
1: 
1: 		s.execute("create trigger trigger1 no cascade before update of status on table1 REFERENCING " +
1: 				"NEW as n_row for each row call proc_test1_UpdateBeforeTrigger_select_table(n_row.id)");
1: 		commit();
1:    		runtest1UpdateTrigger();
1: 	}
1: 	
1: 	/**
1: 	 * The is the stored procedure which gets called by the before update 
1: 	 * trigger action for the test test1UpdateBeforeTriggerStoredProc
1: 	 * @param p1 new value of table1.id after the row gets updated
1: 	 * @throws SQLException
1: 	 */
1: 	public static void proc_test1_UpdateBeforeTrigger_select_table(int p1) throws SQLException {
0:     	System.out.println("Test1 : Inside the procedure called by the UPDATE BEFORE TRIGGER action");
1:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:         PreparedStatement ps = conn.prepareStatement("select updates from " +
1:         		"table2 where table2.id = " + p1);
1:         ps.executeQuery();
1:         conn.close();
1: 	}
1: 
1: 	/**
1: 	 * This test creates an AFTER INSERT trigger which in it's trigger action
1: 	 * inserts lob columns from triggering table into another table. So, this
1: 	 * test does access the LOB from the triggering table inside the trigger
1: 	 * action.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test2InsertAfterTriggerAccessLOB() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 
1:         //The default table2 created by basicSetup does not match the 
1:         //requirement of this test so dropping and recreating it.
1:         s.execute("drop table table2");
1: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1: 
1: 		PreparedStatement ps = prepareStatement(
1: 			"insert into table2 (id) values (?)");
1: 		ps.setInt(1, 1);
1:         ps.executeUpdate();
1: 
1: 		s.execute("create trigger trigger1 after INSERT on table1 referencing " +
1: 				"new as n_row for each row " +
1: 				"insert into table2(id, bl_table2) values (n_row.id, n_row.bl)");
1: 		commit();
0:    		runInsertTriggerTest();
1: 	}
1: 
1: 	/**
1: 	 * This test creates an AFTER DELETE trigger which in it's trigger action
1: 	 * deletes row from another table using triggering table's "new" LOB value
1: 	 * in the join clause. So, this test does access the LOB from the 
1: 	 * triggering table inside the trigger action.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test2DeleteAfterTriggerAccessLOB() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1:         //The default table2 created by basicSetup does not match the 
1:         //requirement of this test so dropping and recreating it.
1:         s.execute("drop table table2");
1: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1: 
1: 		PreparedStatement ps = prepareStatement(
1: 			"insert into table2 (id) values (?)");
1: 		ps.setInt(1, 1);
1:         ps.executeUpdate();
1: 		commit();
1: 
1: 		s.execute("create trigger trigger1 after DELETE on table1 referencing " +
1: 				"old as o_row for each row " +
1: 				"delete from table2 where id = o_row.id and o_row.bl is not null");
1: 		commit();
1:    		runDeleteTriggerTest();
1: 	}
1: 
1: 	/**
1: 	 * The after update trigger on non-LOB column but the LOB column is
1: 	 * referenced in the trigger action. So, this test does access the LOB 
1: 	 * from the triggering table inside the trigger action. 
1: 	 *  
1: 	 * It uses 2 tables to demonstrate the problem. 
1: 	 * table1 has a BLOB column
1: 	 * table2 gets updated with LOB column from triggering table
1: 	 * 	eventhough the UPDATE which caused the trigger to fire didn't
1: 	 * 	update the LOB. The trigger got fired for update of non-LOB
1: 	 * 	column on the triggering table. 
1: 	 * 
1: 	 * table1 has an after update trigger defined on column "status" so
1: 	 * 	that the trigger action will update table2 with LOB value from 
1: 	 * 	table1.
1: 	 * 
1: 	 * Notice that the trigger action DOES reference the BLOB column in 
1: 	 * 	table1 but the update that caused the trigger is not updating 
1: 	 * 	the BLOB column
1: 	 * 
1: 	 * @throws SQLException
1: 	 */
1: 	public void test2UpdateAfterTriggerAccessLOB() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1:         //The default table2 created by basicSetup does not match the 
1:         //requirement of this test so dropping and recreating it.
1:         s.execute("drop table table2");
1: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1: 
1: 		s.execute("create trigger trigger1 after update of status on table1 referencing " +
1: 			"new as n_row for each row " +
1: 			"update table2 set bl_table2 = n_row.bl where table2.id = n_row.id");
1: 
1: 		PreparedStatement ps = prepareStatement(
1: 			"insert into table2 (id) values (?)");
1: 		ps.setInt(1, 1);
1:         ps.executeUpdate();
1: 		commit();
1:    		runtest1UpdateTrigger();
1: 	}
1: 
1: 	/**
1: 	 * This test creates an AFTER INSERT trigger which in it's trigger action
1: 	 * updates a lob column from the row just inserted. So, this test does
1: 	 * update the LOB from the triggering table inside the trigger
1: 	 * action.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test2InsertAfterTriggerUpdatedLOB() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 
1:         //The default table1 created by basicSetup does not match the 
1:         //requirement of this test so dropping and recreating it.
1:         s.execute("drop table table1");
1: 		s.execute("create table table1 (id int, status smallint, bl blob(2G), bl_null blob(2G))");
1: 
1: 		PreparedStatement ps = prepareStatement(
1: 			"insert into table1 values (?, 0, ?, null)");
1: 		ps.setInt(1, 1);
1:         ps.setBinaryStream(2, new LoopingAlphabetStream(lobsize), lobsize);
1:         ps.executeUpdate();
1: 
1:         s.execute("create trigger trigger1 after INSERT on table1 referencing " +
1: 				"new as n_row for each row " +
1: 				"update table1 set bl_null=n_row.bl where bl_null is null");
1: 		commit();
0:    		runInsertTriggerTest();
1: 	}
1: 
1: 	/**
1: 	 * This test creates an AFTER UPDATE trigger which in it's trigger action
1: 	 * updates a lob column from the row that just got updated. So, this test 
1: 	 * does update the LOB from the triggering table inside the trigger
1: 	 * action. 
1: 	 * @throws SQLException
1: 	 */
1: 	public void test2UpdateAfterTriggerUpdatedLOB() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 
1:         //The default table1 created by basicSetup does not match the 
1:         //requirement of this test so dropping and recreating it.
1:         s.execute("drop table table1");
1: 		s.execute("create table table1 (id int, status smallint, bl blob(2G), bl_null blob(2G))");
1: 
1:         s.execute("create trigger trigger1 after update of status on table1 referencing " +
1:     			"new as n_row for each row " +
1:     			"update table1 set bl_null=n_row.bl where bl_null is null");
1: 
1: 		PreparedStatement ps = prepareStatement(
1: 			"insert into table1 values (?, 0, ?, null)");
1: 		ps.setInt(1, 1);
1:         ps.setBinaryStream(2, new LoopingAlphabetStream(lobsize), lobsize);
1:         ps.executeUpdate();
1: 		commit();
1:    		runtest1UpdateTrigger();
1: 	}
1: 
1: 	/**
1: 	 * This test creates a BEFORE INSERT trigger which selects "new"
1: 	 * lob column from just inserted row. This test does access the
1: 	 * LOB.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test2InsertBeforeTriggerAccessLOB() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1:         //The default table2 created by basicSetup does not match the 
1:         //requirement of this test so dropping and recreating it.
1:         s.execute("drop table table2");
1: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1: 
1: 		s.execute("create trigger trigger1 no cascade before INSERT on table1 referencing " +
1: 			"new as n_row for each row " +
1: 			"values(n_row.bl)");		
1: 		
1: 		PreparedStatement ps = prepareStatement(
1: 			"insert into table2 (id) values (?)");
1: 		ps.setInt(1, 1);
1:         ps.executeUpdate();
1: 		commit();
0:    		runInsertTriggerTest();
1: 	}
1: 	
1: 	/**
1: 	 * This test creates a BEFORE DELETE trigger which selects "old"
1: 	 * lob column from just deleted row. This test does access the
1: 	 * LOB.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test2DeleteBeforeTriggerAccessLOB() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 
1:         //The default table2 created by basicSetup does not match the 
1:         //requirement of this test so dropping and recreating it.
1:         s.execute("drop table table2");
1: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1: 
1: 		s.execute("create trigger trigger1 no cascade before DELETE on table1 referencing " +
1: 			"old as o_row for each row " +
1: 			"values(o_row.bl)");		
1: 		
1: 		PreparedStatement ps = prepareStatement(
1: 			"insert into table2 (id) values (?)");
1: 		ps.setInt(1, 1);
1:         ps.executeUpdate();
1: 		commit();
1:    		runDeleteTriggerTest();
1: 	}
1: 
1: 	/**
1: 	 * This test creates a BEFORE UPDATE trigger which selects "new"
1: 	 * lob column from just updated row. This test does access the
1: 	 * LOB. 
1: 	 * @throws SQLException
1: 	 */
1: 	public void test2UpdateBeforeTriggerAccessLOB() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 
1:         //The default table2 created by basicSetup does not match the 
1:         //requirement of this test so dropping and recreating it.
1:         s.execute("drop table table2");
1: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1: 
1: 		s.execute("create trigger trigger1 no cascade before update of status on table1 referencing " +
1: 			"new as n_row for each row " +
1: 			"values(n_row.bl)");		
1: 		
1: 		PreparedStatement ps = prepareStatement(
1: 			"insert into table2 (id) values (?)");
1: 		ps.setInt(1, 1);
1:         ps.executeUpdate();
1: 		commit();
1:    		runtest1UpdateTrigger();
1: 	}
1: 
1: 	/**
1: 	 * The after update trigger is defined on LOB column but the LOB column 
1: 	 * is not referenced in the trigger action.
1: 	 * 
1: 	 * It used 2 tables to demonstrate the problem.
1: 	 * table1 has a BLOB column
1: 	 * table2 gets updated with non-LOB column from triggering table
1: 	 * 	eventhough the UPDATE which caused the trigger to fire updated a LOB
1: 	 * column. The trigger got fired for update of LOB column on the triggering
1: 	 * table.
1: 	 * 
1: 	 * table1 has an after update trigger defined on LOB column so that 
1: 	 * 	the trigger action will update table2 with non-LOB value from
1: 	 * 	table1
1: 	 * 
1: 	 * @throws SQLException
1: 	 */
1: 	public void test3UpdateAfterTrigger() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 		s.execute("create trigger trigger1 after update of bl on table1 referencing " +
1: 				"new as n_row for each row " +
1: 				"update table2 set updates = n_row.status where table2.id = n_row.id");
1: 		commit();
1:    		runtest2UpdateTrigger();
1: 	}
1: 
1: 	/**
1: 	 * The test case is exactly like test3UpdateAfterTrigger except that the
1: 	 * trigger action is a stored procedure call. The work done by the trigger
1: 	 * action SQL in test3UpdateAfterTrigger gets done inside the stored procedure
1: 	 * for this test.
1: 	 * 
1: 	 * @throws SQLException
1: 	 */
1: 	public void test3UpdateAfterTriggerStoredProc() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 	
1:         s.execute("create procedure proc_test3_UpdateAfterTrigger_update_table " +
1:         		"(p1 int, p2 int) parameter style java language "+
1:         		"java MODIFIES SQL DATA external name "+
0:         		"'org.apache.derbyTesting.functionTests.tests.lang.derby1482TriggerTests.proc_test3_UpdateAfterTrigger_update_table'");
1: 
1: 		s.execute("create trigger trigger1 after update of bl on table1 REFERENCING " +
1: 				"NEW as n_row for each row call proc_test3_UpdateAfterTrigger_update_table(n_row.status, n_row.id)");
1: 		commit();
1:    		runtest2UpdateTrigger();
1: 	}
1: 
1: 	/**
1: 	 * The is the stored procedure which gets called by the after delete 
1: 	 * trigger action for the test test3UpdateAfterTriggerStoredProc
1: 	 * @param p1 new value of table1.status after the row gets inserted
1: 	 * @param p2 new value of table1.id after the row gets inserted
1: 	 * @throws SQLException
1: 	 */
1: 	public static void proc_test3_UpdateAfterTrigger_update_table(int p1, int p2) throws SQLException {
0:     	System.out.println("Test3 : Inside the procedure called by the UPDATE AFTER TRIGGER action");
1:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:         PreparedStatement ps = conn.prepareStatement("update table2 "+
1:         		"set updates = " + p1 + " where table2.id = " + p2);
1:         ps.executeUpdate();
1:         conn.close();
1: 	}
1: 
1: 	/**
1: 	 * This test creates a BEFORE UPDATE trigger which selects a row
1: 	 * from another table using "new" non-LOB column from the triggering
1: 	 * table. This test has update trigger defined on the LOB column
1: 	 * but does not access/update that LOB column in the trigger action.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test3UpdateBeforeTrigger() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 
1: 		s.execute("create trigger trigger1 no cascade before update of bl on table1 referencing " +
1: 				"new as n_row for each row " +
1: 				"select updates from table2 where table2.id = n_row.id");
1: 		commit();
1:    		runtest2UpdateTrigger();
1: 	}
1: 
1: 	/**
1: 	 * The test case is exactly like test3UpdateBeforeTrigger except that the
1: 	 * trigger action is a stored procedure call. The work done by the trigger
1: 	 * action SQL in test3UpdateBeforeTrigger gets done inside the stored procedure
1: 	 * for this test.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test3UpdateBeforeTriggerStoredProc() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 
1:         s.execute("create procedure proc_test3_UpdateBeforeTrigger_select_table " +
1:         		"(p1 int) parameter style java language "+
1:         		"java READS SQL DATA external name "+
0:         		"'org.apache.derbyTesting.functionTests.tests.lang.derby1482TriggerTests.proc_test3_UpdateBeforeTrigger_select_table'");
1: 
1: 		s.execute("create trigger trigger1 no cascade before update of bl on table1 REFERENCING " +
1: 				"NEW as n_row for each row call proc_test3_UpdateBeforeTrigger_select_table(n_row.id)");
1: 		commit();
1:    		runtest2UpdateTrigger();
1: 	}
1: 	
1: 	/**
1: 	 * The is the stored procedure which gets called by the before delete 
1: 	 * trigger action for the test test3UpdateBeforeTriggerStoredProc
1: 	 * @param p1 new value of table1.id after the row gets inserted
1: 	 * @throws SQLException
1: 	 */
1: 	public static void proc_test3_UpdateBeforeTrigger_select_table(int p1) throws SQLException {
0:     	System.out.println("Test3 : Inside the procedure called by the UPDATE BEFORE TRIGGER action");
1:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:         PreparedStatement ps = conn.prepareStatement("select updates from " +
1:         		"table2 where table2.id = " + p1);
1:         ps.executeQuery();
1:         conn.close();
1: 	}
1: 	
1: 	/**
1: 	 * The after update trigger on LOB column but the LOB column is referenced 
1: 	 * in the trigger action. This is one case though where we do need to keep 
1: 	 * before and after image since the LOB got updated and it is being used 
1: 	 * in trigger action. 
1: 	 * 
1: 	 * It used 2 tables to demonstrate the problem.
1: 	 * table1 has a BLOB column
1: 	 * table2 gets updated with LOB column value from triggering table,
1: 	 * 	the same LOB which got UPDATEd and caused the trigger to fire. The 
1: 	 * 	trigger got fired for update of LOB column on the triggering
1: 	 * 	table.
1: 	 * 
1: 	 * @throws SQLException
1: 	 */
1: 	public void test4UpdateAfterTriggerAccessLOB() throws SQLException{
1:         basicSetup();
1: 	    Statement s = createStatement();
1: 
1:         //The default table2 created by basicSetup does not match the 
1:         //requirement of this test so dropping and recreating it.
1:         s.execute("drop table table2");
1: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1: 
1: 		s.execute("create trigger trigger1 after update of bl on table1 referencing " +
1: 			"new as n_row for each row " +
1: 			"update table2 set bl_table2 = n_row.bl where table2.id = n_row.id");
1: 
1: 		PreparedStatement ps = prepareStatement(
1: 			"insert into table2 (id) values (?)");
1: 		ps.setInt(1, 1);
1:         ps.executeUpdate();
1: 		commit();		
1:    		runtest2UpdateTrigger();
1: 	}
1: 
1: 	/**
1: 	 * The after update trigger on LOB column which then gets updated in the
1: 	 * trigger action. So this test updates the LOB in the trigger action
1: 	 * and is also the cause of the update trigger to fire. 
1: 	 * @throws SQLException
1: 	 */ 
1: 	public void test4UpdateAfterTriggerUpdatedLOB() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 
1:         //The default table1 created by basicSetup does not match the 
1:         //requirement of this test so dropping and recreating it.
1:         s.execute("drop table table1");
1: 		s.execute("create table table1 (id int, status smallint, bl blob(2G), bl_null blob(2G))");
1: 
1:         s.execute("create trigger trigger1 after update of bl_null on table1 referencing " +
1:     			"new as n_row for each row " +
1:     			"update table1 set bl_null=n_row.bl where bl_null is null");
1: 
1: 		PreparedStatement ps = prepareStatement(
1: 			"insert into table1 values (?, 0, ?, ?)");
1: 
1: 		ps.setInt(1, 1);
1:         ps.setBinaryStream(2, new LoopingAlphabetStream(lobsize), lobsize);
1:         ps.setBinaryStream(3, new LoopingAlphabetStream(lobsize), lobsize);
1:         ps.executeUpdate();
1: 		commit();
1:    		runtest3UpdateTrigger();
1: 	}
1: 	
1: 	/**
1: 	 * This test creates a BEFORE UPDATE trigger on LOB column and
1: 	 * the trigger action selects "new" lob column from just updated 
1: 	 * row. This test does access the LOB. 
1: 	 * @throws SQLException
1: 	 */
1: 	public void test4UpdateBeforeTrigger() throws SQLException{
1:         basicSetup();
1: 	    Statement s = createStatement();
1: 
1:         //The default table2 created by basicSetup does not match the 
1:         //requirement of this test so dropping and recreating it.
1:         s.execute("drop table table2");
1: 		s.execute("create table table2 (id int, bl_table2 blob(2G))");
1: 
1: 		s.execute("create trigger trigger1 no cascade before update of bl on table1 referencing " +
1: 			"new as n_row for each row " +
1: 			"values(n_row.bl)");
1: 
1: 		PreparedStatement ps = prepareStatement(
1: 			"insert into table2 (id) values (?)");
1: 		ps.setInt(1, 1);
1:         ps.executeUpdate();
1: 		commit();		
1:    		runtest2UpdateTrigger();
1: 	}
1: 	 
1: 	/**
1: 	 * This test creates an AFTER INSERT trigger but has no REFERENCING
1: 	 * clause, meaning that before and after values are not available to
1: 	 * the trigger action.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test5InsertAfterTriggerNoReferencingClause() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 		s.execute("create trigger trigger1 AFTER INSERT on table1 " +
1: 			"insert into table2(id, updates) values (100, -1)");
1: 		commit();
0:    		runInsertTriggerTest();		       	
1: 	}
1: 	 
1: 	/**
1: 	 * This test creates an BEFORE INSERT trigger but has no REFERENCING
1: 	 * clause, meaning that before and after values are not available to
1: 	 * the trigger action.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test5InsertBeforeTriggerNoReferencingClause() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 		s.execute("create trigger trigger1 NO CASCADE BEFORE INSERT on table1 " +
1: 			"select updates from table2 where table2.id = 1");
1: 		commit();
0:    		runInsertTriggerTest();		       	
1: 	}
1: 	 
1: 	/**
1: 	 * This test creates an AFTER DELETE trigger but has no REFERENCING
1: 	 * clause, meaning that before and after values are not available to
1: 	 * the trigger action.
1: 	 * @throws SQLException
1: 	 */
1: 	public void test5DeleteAfterTriggerNoReferencingClause() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 		s.execute("create trigger trigger1 AFTER DELETE on table1 " +
1: 				"delete from table2 where id=1");
1: 		commit();
1:    		runDeleteTriggerTest();		       	
1: 	}
1: 	
1: 	/**
1: 	 * This test creates an BEFORE DELETE trigger but has no REFERENCING
1: 	 * clause, meaning that before and after values are not available to
1: 	 * the trigger action. 
1: 	 * @throws SQLException
1: 	 */
1: 	public void test5DeleteBeforeTriggerNoReferencingClause() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
1: 		s.execute("create trigger trigger1 NO CASCADE BEFORE DELETE on table1 " +
1: 				"select updates from table2 where table2.id = 1");
1: 		commit();
1:    		runDeleteTriggerTest();		       	
1: 	}
1: 
1: 	/**
1: 	 * This test creates an AFTER UPDATE trigger but has no REFERENCING
1: 	 * clause, meaning that before and after values are not available to
1: 	 * the trigger action. 
1: 	 * @throws SQLException
1: 	 */
1: 	public void test5UpdateAfterTriggerNoReferencingClause() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
0: 		s.execute("create trigger trigger1 AFTER UPDATE of status on table1 referencing " +
1: 				"new as n_row for each row " +
1: 				"update table2 set updates = updates + 1 where table2.id = 1");
1: 		commit();
1:    		runtest1UpdateTrigger();		       	
1: 	}
1: 	
1: 	/**
1: 	 * This test creates an BEFORE UPDATE trigger but has no REFERENCING
1: 	 * clause, meaning that before and after values are not available to
1: 	 * the trigger action. 
1: 	 * @throws SQLException
1: 	 */
1: 	public void test5UpdateBeforeTriggerNoReferencingClause() throws SQLException{
1:         basicSetup();
1:         Statement s = createStatement();
0: 		s.execute("create trigger trigger1 NO CASCADE BEFORE UPDATE of status on table1 referencing " +
1: 				"new as n_row for each row " +
1: 				"select updates from table2 where table2.id = 1");
1: 		commit();
1:    		runtest1UpdateTrigger();		       	
1: 	}
1: 	
1: 	/**
1: 	 * Following will do an insert into table1 which will cause insert 
1: 	 * trigger to fire. 
0: 	 * @param p1
1: 	 * @throws SQLException
1: 	 */
0: 	public void runInsertTriggerTest() throws SQLException{
0: 		System.out.println("Inserting into table1 to cause insert trigger to fire");
1: 		PreparedStatement ps = prepareStatement(
1: 				"insert into table1(id, status, bl) values(101, 0, ?)");
1:         ps.setBinaryStream(1, new LoopingAlphabetStream(lobsize), lobsize);
1:         ps.executeUpdate();
1:         commit();
1: 	}
1: 	
1: 	/**
1: 	 * Following will update a row in table1 which will cause update 
1: 	 * trigger to fire. 
0: 	 * @param p1
1: 	 * @throws SQLException
1: 	 */
1: 	public void runtest1UpdateTrigger() throws SQLException{
0: 		System.out.println("Updating table1(int) to cause update trigger to fire");
1: 		PreparedStatement ps = prepareStatement(
1: 				"update table1 set status = 1 where id = 1");
1:         ps.executeUpdate();
1:         commit();
1: 	}
1: 	
1: 	/**
1: 	 * Following will update a row in table1 which will cause update 
1: 	 * trigger to fire. 
0: 	 * @param p1
1: 	 * @throws SQLException
1: 	 */
1: 	public void runtest2UpdateTrigger() throws SQLException{
0: 		System.out.println("Updating table1(blob column1) to cause update trigger to fire");
1: 		PreparedStatement ps = prepareStatement(
1: 				"update table1 set bl = ? where id = 1");
1:         ps.setBinaryStream(1, new LoopingAlphabetStream(lobsize), lobsize);
1:         ps.executeUpdate();
1:         commit();
1: 	}
1: 	
1: 	/**
1: 	 * Following will update a row in table1 which will cause update 
1: 	 * trigger to fire. 
0: 	 * @param p1
1: 	 * @throws SQLException
1: 	 */
1: 	public void runtest3UpdateTrigger() throws SQLException{
0: 		System.out.println("Updating table1(blob column2) to cause update trigger to fire");
1: 		PreparedStatement ps = prepareStatement(
1: 				"update table1 set bl_null=null where id = 1");
1:         ps.executeUpdate();
1:         commit();
1: 	}
1: 	
1: 	/**
1: 	 * Following will delete a row from table1 which will cause delete 
1: 	 * trigger to fire. 
0: 	 * @param p1
1: 	 * @throws SQLException
1: 	 */
1: 	public void runDeleteTriggerTest() throws SQLException{
0: 		System.out.println("Deleting from table1 to cause delete trigger to fire");
1: 		PreparedStatement ps = prepareStatement(
1: 				"delete from table1 where id=1");
1:         ps.executeUpdate();
1:         commit();
1: 	}
1: }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:995d3ac
/////////////////////////////////////////////////////////////////////////
1:         dropTable("TABLE1");
1:         dropTable("TABLE2");
1:         dropTable("TABLE3");
0: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:782dbe1
/////////////////////////////////////////////////////////////////////////
1: /*
0: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.memory.TriggerTests
0: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
0: 
1:       http://www.apache.org/licenses/LICENSE-2.0
0: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
0: 
0: 
/////////////////////////////////////////////////////////////////////////
0: /**
0:  * Repro for DERBY-1482:
0:  * Update triggers on tables with blob columns stream blobs
0:  * into memory even when the blobs are not referenced/accessed.
1:  */
commit:3b2562c
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
/////////////////////////////////////////////////////////////////////////
1: 	 *
============================================================================