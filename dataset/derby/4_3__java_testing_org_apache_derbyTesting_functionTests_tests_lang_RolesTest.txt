1:305269a: /*
1:99d7d8b: 
1:ee59de8:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.RolesTest
1:99d7d8b: 
1:305269a:    Licensed to the Apache Software Foundation (ASF) under one or more
1:305269a:    contributor license agreements.  See the NOTICE file distributed with
1:305269a:    this work for additional information regarding copyright ownership.
1:305269a:    The ASF licenses this file to you under the Apache License, Version 2.0
1:305269a:    (the "License"); you may not use this file except in compliance with
1:305269a:    the License.  You may obtain a copy of the License at
47:305269a: 
1:305269a:      http://www.apache.org/licenses/LICENSE-2.0
1:305269a: 
1:305269a:    Unless required by applicable law or agreed to in writing, software
1:305269a:    distributed under the License is distributed on an "AS IS" BASIS,
1:305269a:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:305269a:    See the License for the specific language governing permissions and
1:305269a:    limitations under the License.
1:305269a: 
5:305269a:  */
1:305269a: 
1:305269a: package org.apache.derbyTesting.functionTests.tests.lang;
1:305269a: 
1:305269a: import java.sql.Connection;
1:305269a: import java.sql.PreparedStatement;
1:ee59de8: import java.sql.ResultSet;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.SQLWarning;
1:1ae02c9: import java.sql.Statement;
1:b1d3a85: import javax.sql.ConnectionPoolDataSource;
1:1ae02c9: import javax.sql.PooledConnection;
1:305269a: import junit.framework.Test;
1:305269a: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:305269a: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.J2EEDataSource;
1:6950a39: import org.apache.derbyTesting.junit.JDBC;
1:305269a: import org.apache.derbyTesting.junit.TestConfiguration;
1:305269a: 
4:305269a: /**
1:305269a:  * This JUnit tests the SQL roles feature. This feature relies on
1:305269a:  * sqlAuthorization being set. Upgrade tests are not handled here.
1:305269a:  *
1:305269a:  * The tests are run in the cross product:
1:305269a:  *
1:305269a:  *    {client/server, embedded} x
1:305269a:  *    {no sqlAuthorization/sqlAuthorization} x
1:305269a:  *    {data base owner, other user }
1:305269a:  *
1:305269a:  */
1:305269a: public class RolesTest extends BaseJDBCTestCase
7:305269a: {
1:305269a:     /* internal state */
1:305269a:     private final int _authLevel;
1:305269a:     private final String _user;
1:305269a:     private final String _userPassword;
1:305269a:     private Connection _conn;
1:305269a:     private Statement _stm;
1:305269a: 
1:305269a:     /* test execution security context: one of two below */
1:305269a:     private final static int NO_SQLAUTHORIZATION=0;
1:305269a:     private final static int SQLAUTHORIZATION=1;
1:305269a: 
1:305269a:     private final static String pwSuffix = "pwSuffix";
1:305269a: 
1:305269a:     /* SQL states */
1:305269a:     private final static String sqlAuthorizationRequired = "42Z60";
1:5990b20:     private final static String syntaxError              = "42X01";
1:5990b20:     private final static String roleDboOnly              = "4251A";
1:5990b20:     private final static String invalidRole              = "0P000";
1:5990b20:     private final static String tooLongId                = "42622";
1:5990b20:     private final static String revokeWarn               = "01007";
1:5990b20:     private final static String notIdle                  = "25001";
1:5990b20:     private final static String invalidRoleName          = "4293A";
1:c8e864b:     private final static String userException            = "38000";
1:a6c7bc7:     private final static String objectAlreadyExists      = "X0Y68";
1:9c3b91c:     private final static String invalidPUBLIC            = "4251B";
1:f900ff2:     private final static String loginFailed              = "08004";
1:fe8c4c2:     private final static String roleGrantCircularity     = "4251C";
1:44ea4f0:     private final static String idParseError             = "XCXA0";
1:305269a: 
1:5990b20:     private int MAX_IDENTIFIER_LENGTH = 128;
1:305269a:     /**
1:305269a:      * Users used by all suites when when authLevel == SQLAUTHORIZATION.
1:305269a:      * The TestConfiguration.sqlAuthorizationDecorator decorator presumes
1:305269a:      * TEST_DBO as dbo, so add it to set of valid users. It uses a fresh db
1:305269a:      * 'dbsqlauth', not 'wombat'.
1:305269a:      */
1:c8e864b:     private final static String[] users =
1:c8e864b:         {"TEST_DBO", "DonaldDuck", "\"additional\"\"user\""};
1:c8e864b: 
1:c8e864b:     private final static int
1:c8e864b:         dboIndex            = 0; // used for connections
1:c8e864b:     private final static int
1:c8e864b:         nonDboIndex         = 1; // used for connections
1:c8e864b:     private final static int
1:c8e864b:         additionaluserIndex = 2; // *not* used for connections
1:305269a: 
1:ee59de8:     private boolean isDbo()
1:ee59de8:     {
1:305269a:         return users[0].equals(this._user);
20:305269a:     }
1:fe8c4c2: 
1:b1d3a85:     /**
1:305269a:      * Create a new instance of RolesTest.
1:305269a:      *
1:305269a:      * @param name Fixture name
1:305269a:      * @param authLevel authentication level with which test is run
1:305269a:      * @param user Database user
1:305269a:      * @param userPassword Database user's password
1:99d7d8b:      */
1:99d7d8b: 
1:305269a:     public RolesTest(String name, int authLevel,
1:305269a:                      String user, String userPassword)
1:99d7d8b:     {
1:305269a:         super(name);
1:305269a:         this._authLevel = authLevel;
1:305269a:         this._user = user;
1:305269a:         this._userPassword = userPassword;
1:305269a:     }
1:99d7d8b: 
1:99d7d8b: 
1:f900ff2:     /**
1:305269a:      * Construct top level suite in this JUnit test
1:305269a:      *
1:305269a:      * @return A suite containing embedded and client suites.
1:99d7d8b:      */
1:305269a:     public static Test suite()
1:99d7d8b:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("RolesTest");
1:99d7d8b: 
1:305269a:         /* Negative syntax tests */
1:305269a:         suite.addTest(negativeSyntaxSuite("suite: negative syntax, embedded"));
1:99d7d8b: 
1:ee59de8:         suite.addTest(
1:ee59de8:             TestConfiguration.clientServerDecorator(
1:ee59de8:                 negativeSyntaxSuite("suite: negative syntax, client")));
1:ee59de8: 
1:ee59de8:         /* Positive syntax tests */
1:ee59de8:         suite.addTest(positiveSyntaxSuite("suite: positive syntax, embedded"));
1:ee59de8: 
1:ee59de8:         suite.addTest(
1:ee59de8:             TestConfiguration.clientServerDecorator(
1:ee59de8:                 positiveSyntaxSuite("suite: positive syntax, client")));
1:ee59de8: 
1:c8e864b:         /* Semantic tests */
1:ee59de8:         suite.addTest(
1:c8e864b:             semanticSuite("suite: semantic, embedded"));
1:ee59de8: 
1:305269a:         suite.addTest(
1:ee59de8:             TestConfiguration.clientServerDecorator(
1:c8e864b:                 semanticSuite("suite: semantic, client")));
1:ee59de8: 
1:305269a:         return suite;
1:305269a:     }
1:305269a: 
1:99d7d8b:     /**
1:305269a:      *
1:305269a:      * Construct suite of tests for negative syntax
1:305269a:      *
1:305269a:      * @param framework Derby framework indication
1:305269a:      * @return A suite containing the test cases for negative syntax
1:305269a:      * incarnated for the two security levels no sqlAuthorization, and
1:305269a:      * sqlAuthorization, The latter has an instance for dbo, and one
1:305269a:      * for an ordinary user, so there are in all three incarnations of
1:305269a:      * tests.
1:305269a:      */
1:305269a:     private static Test negativeSyntaxSuite(String framework)
1:ee59de8:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("roles:"+framework);
1:305269a: 
2:305269a:         /* Tests running without sql authorization set.
1:305269a:          */
1:1ae02c9:         BaseTestSuite noauthSuite = new BaseTestSuite(
1:305269a:             "suite: security level=noSqlAuthorization");
1:305269a:         noauthSuite.addTest(new RolesTest("testNegativeSyntax",
1:305269a:                                           NO_SQLAUTHORIZATION,
1:305269a:                                           null,
1:305269a:                                           null));
1:ee59de8:         suite.addTest(noauthSuite);
1:ee59de8: 
1:ee59de8:         // Tests running with sql authorization set.
1:ee59de8:         suite.addTest(wrapInAuthorization("testNegativeSyntax"));
1:305269a: 
1:305269a:         return suite;
1:305269a:     }
1:305269a: 
1:305269a: 
1:305269a:     /**
1:ee59de8:      *
1:ee59de8:      * Construct suite of tests for positive syntax (edge cases)
1:ee59de8:      *
1:ee59de8:      * @param framework Derby framework indication
1:ee59de8:      * @return A suite containing the test cases for  syntax
1:ee59de8:      * edge cases. Incarnated only for sqlAuthorization, dbo.
1:305269a:      */
1:ee59de8:     private static Test positiveSyntaxSuite(String framework)
1:ee59de8:     {
1:ee59de8:         String dbo = users[dboIndex];
1:ee59de8:         String dbopw = dbo.concat(pwSuffix);
1:ee59de8: 
1:ee59de8:         Test t = (TestConfiguration.changeUserDecorator
1:ee59de8:                   (new RolesTest("testPositiveSyntax",
1:ee59de8:                                  SQLAUTHORIZATION,
1:ee59de8:                                  dbo, dbopw),
1:ee59de8:                    dbo, dbopw));
1:ee59de8: 
1:ee59de8:         return TestConfiguration.sqlAuthorizationDecorator(
1:ee59de8:             DatabasePropertyTestSetup.builtinAuthentication(
1:ee59de8:                 t, users, pwSuffix));
1:ee59de8:     }
1:ee59de8: 
1:305269a: 
1:305269a:     /**
1:305269a:      * Test negative syntax for roles.
1:305269a:      *
1:305269a:      * @throws SQLException
1:305269a:      */
1:305269a:     public void testNegativeSyntax() throws SQLException
1:305269a:     {
1:305269a:         println("testNegativeSyntax: auth=" + this._authLevel +
1:305269a:                 " user="+getTestConfiguration().getUserName());
1:305269a: 
1:305269a:         _conn = getConnection();
1:305269a:         _stm  = _conn.createStatement();
1:ee59de8: 
1:305269a:         doStmt("create role none", // none is reserved word
1:305269a:                syntaxError, syntaxError, syntaxError);
1:305269a:         doStmt("create role current_role", // current_role is reserved word
1:305269a:                syntaxError, syntaxError, syntaxError);
1:ee59de8: 
1:5990b20:         char[] longname = new char[MAX_IDENTIFIER_LENGTH + 1];
1:5990b20:         java.util.Arrays.fill(longname, 'a');
1:5990b20:         String nameWithMoreThanMaxChars = new String(longname);
1:5990b20: 
1:5990b20:         doStmt("create role " + nameWithMoreThanMaxChars,
1:5990b20:                tooLongId, tooLongId, tooLongId);
1:5990b20:         // Check SYS-prefix ban
1:5990b20:         doStmt("create role sysrole",
1:5990b20:                sqlAuthorizationRequired, invalidRoleName, invalidRoleName);
1:5990b20:         doStmt("create role \"SYSROLE\"",
1:5990b20:                sqlAuthorizationRequired, invalidRoleName, invalidRoleName);
1:9c3b91c:         doStmt("create role public",
1:9c3b91c:                syntaxError, syntaxError, syntaxError);
1:9c3b91c:         doStmt("create role \"PUBLIC\"",
1:9c3b91c:                sqlAuthorizationRequired, invalidPUBLIC, roleDboOnly);
1:9c3b91c:         doStmt("grant \"PUBLIC\" to " + users[1],
1:9c3b91c:                sqlAuthorizationRequired, invalidPUBLIC, invalidPUBLIC);
1:9c3b91c:         doStmt("revoke \"PUBLIC\" from " + users[1],
1:9c3b91c:                sqlAuthorizationRequired, invalidPUBLIC, invalidPUBLIC);
1:ee59de8:         _stm.close();
1:ee59de8:     }
1:b1d3a85: 
1:ee59de8: 
1:ee59de8:     /**
1:ee59de8:      * Test syntax edge cases (positive)
1:ee59de8:      *
1:ee59de8:      * @throws SQLException
1:ee59de8:      */
1:ee59de8:     public void testPositiveSyntax() throws SQLException
1:ee59de8:     {
1:ee59de8:         println("testPositiveSyntax");
1:ee59de8:         String n_a     = null; // auth level not used for this test
1:ee59de8:         int    n_a_cnt = -1;   //
1:ee59de8: 
1:ee59de8:         // sanity check:
1:ee59de8:         if (!isDbo()) { throw new SQLException("test error"); }
1:ee59de8: 
1:ee59de8: 
1:ee59de8:         _conn = getConnection();
1:ee59de8:         _stm  = _conn.createStatement();
1:ee59de8: 
1:ee59de8:         // "trigger" is not reserved word, but required tweaking of grammar
1:ee59de8:         // so we add a regression test for it.
1:ee59de8:         doStmt("create role trigger", n_a, null, n_a);
1:ee59de8: 
1:ee59de8:         // "role" is not a reserved word, either:
1:ee59de8:         doStmt("create role role", n_a, null, n_a);
1:ee59de8: 
1:5990b20:         // Check that role name can be longer than present user name
1:5990b20:         // (max 30, cf.  Limits.DB2_MAX_USERID_LENGTH).
1:5990b20:         String nameWithMoreThan30Chars = ("r123456789" +
1:5990b20:                                           "0123456789" +
1:5990b20:                                           "01234567890"); // 31 long
1:5990b20:         doStmt("create role " + nameWithMoreThan30Chars,
1:5990b20:                n_a, null, n_a);
1:5990b20: 
1:5990b20:         assertSysRolesRowCount(n_a_cnt, 3, n_a_cnt);
1:ee59de8: 
1:ee59de8:         doStmt("grant trigger to foo", n_a, null, n_a);
1:ee59de8:         doStmt("grant role to foo", n_a, null, n_a);
1:ee59de8:         doStmt("revoke trigger from foo", n_a, null, n_a);
1:ee59de8:         doStmt("revoke role from foo", n_a, null, n_a);
1:ee59de8: 
1:5990b20:         doStmt("set role " + nameWithMoreThan30Chars, n_a, null, n_a);
1:5990b20: 
1:5990b20:         doStmt("create table mytab(i int)", n_a, null, n_a);
1:5990b20:         doStmt("grant select on mytab to " + nameWithMoreThan30Chars,
1:5990b20:                n_a, null, n_a);
1:5990b20:         doStmt("revoke select on mytab from " + nameWithMoreThan30Chars,
1:5990b20:                n_a, null, n_a);
1:5990b20:         doStmt("drop table mytab", n_a, null, n_a);
1:5990b20: 
1:ee59de8:         doStmt("drop role trigger", n_a, null, n_a);
1:ee59de8:         doStmt("drop role role", n_a, null, n_a);
1:5990b20:         doStmt("drop role " + nameWithMoreThan30Chars, n_a, null, n_a);
1:ee59de8: 
1:ee59de8:         assertSysRolesRowCount(n_a_cnt, 0, n_a_cnt);
1:ee59de8: 
1:ee59de8:         _stm.close();
1:305269a:     }
1:ee59de8: 
1:305269a:     /**
1:305269a:      *
1:c8e864b:      * Construct suite of semantic tests
1:305269a:      *
1:305269a:      * @param framework Derby framework indication
1:305269a:      *
1:c8e864b:      * @return A suite containing the semantic test cases incarnated only
1:305269a:      * for security level sqlAuthorization.
1:305269a:      *
1:305269a:      * It has one instance for dbo, and one for an ordinary user, so there
1:305269a:      * are in all three incarnations of tests.
1:ee59de8:      */
1:c8e864b:     private static Test semanticSuite(String framework)
1:ee59de8:     {
1:ee59de8:         /*
1:ee59de8:          * Tests running without sql authorization set.  The purpose
1:ee59de8:          * of this is just to make sure the proper errors are given.
1:305269a:          */
1:1ae02c9:         BaseTestSuite noauthSuite = new BaseTestSuite(
1:305269a:             "suite: security level=noSqlAuthorization");
1:c8e864b:         noauthSuite.addTest(new RolesTest("testSemantics",
1:305269a:                                           NO_SQLAUTHORIZATION,
1:305269a:                                           null,
1:305269a:                                           null));
1:ee59de8: 
2:305269a:         /* Tests running with sql authorization set.
2:305269a:          * First decorate with users, then with authentication +
2:305269a:          * sqlAuthorization.
1:305269a:          */
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("roles:"+framework);
1:ee59de8: 
1:ee59de8:         suite.addTest(noauthSuite);
1:c8e864b:         suite.addTest(wrapInAuthorization("testSemantics"));
1:ee59de8: 
1:305269a:         return suite;
1:305269a:     }
1:ee59de8: 
1:305269a:     /**
1:ee59de8:      * Wrap in decorators to run with data base owner and one other
1:305269a:      * valid user in sqlAuthorization mode.
1:305269a:      *
1:305269a:      * @param testName test to wrap
1:305269a:      */
1:ee59de8:     private static Test wrapInAuthorization(String testName)
1:ee59de8:     {
1:305269a:         // add decorator for different users authenticated
1:1ae02c9:         BaseTestSuite usersSuite =
1:1ae02c9:             new BaseTestSuite("suite: security level=sqlAuthorization");
1:ee59de8: 
1:c8e864b:         // First decorate with users (except "additionaluser"), then
1:c8e864b:         // with authorization decorator
1:c8e864b:         for (int userNo = 0; userNo <= users.length - 2; userNo++) {
1:305269a:             usersSuite.addTest
1:305269a:                 (TestConfiguration.changeUserDecorator
1:305269a:                  (new RolesTest(testName,
1:305269a:                                 SQLAUTHORIZATION,
1:305269a:                                 users[userNo],
1:305269a:                                 users[userNo].concat(pwSuffix)),
1:305269a:                   users[userNo],
1:305269a:                   users[userNo].concat(pwSuffix)));
1:305269a:         }
1:ee59de8: 
1:305269a:         return TestConfiguration.sqlAuthorizationDecorator(
1:305269a:             DatabasePropertyTestSetup.builtinAuthentication(
1:305269a:                 usersSuite, users, pwSuffix));
1:305269a:     }
1:ee59de8: 
1:305269a:     /**
1:c8e864b:      * Semantic tests for roles.
1:ee59de8:      * Side effect from the dbo run are needed for the nonDbo run
1:ee59de8:      * which follows (since only dbo can create and grant roles).
1:305269a:      *
1:305269a:      * @throws SQLException
1:305269a:      */
1:c8e864b:     public void testSemantics() throws SQLException
1:ee59de8:     {
1:c8e864b:         println("testSemantics: auth=" + this._authLevel +
1:305269a:                 " user="+getTestConfiguration().getUserName());
1:ee59de8: 
1:305269a:         _conn = getConnection();
1:305269a:         _stm  = _conn.createStatement();
1:ee59de8: 
1:ee59de8: 
1:ee59de8:         /*
1:ee59de8:          * CREATE ROLE
1:ee59de8:          */
1:305269a:         doStmt("create role foo",
1:ee59de8:                sqlAuthorizationRequired, null , roleDboOnly);
1:305269a:         doStmt("create role bar",
1:ee59de8:                sqlAuthorizationRequired, null , roleDboOnly);
1:09069c5:         doStmt("create role notGranted",
1:09069c5:                sqlAuthorizationRequired, null , roleDboOnly);
1:305269a:         doStmt("create role role", // role is not reserved word
1:ee59de8:                sqlAuthorizationRequired, null , roleDboOnly);
1:ee59de8:         doStmt("create role admin",
1:ee59de8:                 sqlAuthorizationRequired, null , roleDboOnly);
1:305269a:         doStmt("create role \"NONE\"", // quoted role id should work
1:ee59de8:                 sqlAuthorizationRequired, null , roleDboOnly);
1:ee59de8: 
1:a6c7bc7:         // Verify that we can't create a role which already exists
1:a6c7bc7:         doStmt("create role foo",
1:a6c7bc7:                sqlAuthorizationRequired, objectAlreadyExists, roleDboOnly);
1:a6c7bc7: 
1:c8e864b:         // Verify that we can't create a role which has the same auth
1:f900ff2:         // id as a known user (DERBY-3673).
1:c8e864b:         //
1:c8e864b:         // a) built-in user:
1:c8e864b:         doStmt("create role " + users[dboIndex], sqlAuthorizationRequired,
1:a6c7bc7:                objectAlreadyExists, roleDboOnly);
1:c8e864b: 
1:fe8c4c2:         // specified with mixed case : DonaldDuck
1:c8e864b:         doStmt("create role " + users[nonDboIndex],
1:a6c7bc7:                 sqlAuthorizationRequired, objectAlreadyExists, roleDboOnly);
1:c8e864b: 
1:c8e864b:         // delimited identifier with embedded text quote inside
1:c8e864b:         doStmt("create role " + users[additionaluserIndex],
1:a6c7bc7:                 sqlAuthorizationRequired, objectAlreadyExists, roleDboOnly);
1:c8e864b: 
1:c8e864b: 
1:c8e864b:         // b) A grant to this auth id exists (see setup), even though
1:c8e864b:         // it is not a built-in user, so the presumption is, it is a
1:c8e864b:         // user defined externally:
1:c8e864b:         doStmt("create role whoever", sqlAuthorizationRequired,
1:a6c7bc7:                objectAlreadyExists, roleDboOnly);
1:c8e864b: 
1:c8e864b:         // c) A schema exists which has an authid we did not see
1:c8e864b:         // through properties; user has been removed, but his schema
1:c8e864b:         // lingers..
1:c8e864b:         doStmt("create role schemaowner", sqlAuthorizationRequired,
1:a6c7bc7:                objectAlreadyExists, roleDboOnly);
1:ee59de8: 
1:f900ff2:         testLoginWithUsernameWhichIsARole();
1:f900ff2: 
1:ee59de8:         /*
1:ee59de8:          * GRANT <role>
1:ee59de8:          */
1:305269a:         doStmt("grant foo to authid", // authid: user or role
1:ee59de8:                sqlAuthorizationRequired, null , roleDboOnly);
1:ee59de8: 
1:ee59de8:         // this grant also grant role bar to the non-dbo user
1:ee59de8:         // so we can set it when running as non-dbo.
1:ee59de8:         doStmt("grant foo, role, bar to authid1, authid2, " +
1:ee59de8:                users[nonDboIndex],
1:ee59de8:                sqlAuthorizationRequired, null , roleDboOnly);
1:ee59de8: 
1:ee59de8:         doStmt("grant admin to authid",
2:ee59de8:                sqlAuthorizationRequired, null , invalidRole);
1:ee59de8:         doStmt("grant admin, foo to authid",
1:ee59de8:                sqlAuthorizationRequired, null , invalidRole);
1:ee59de8:         doStmt("grant admin, foo to public",
1:ee59de8:                sqlAuthorizationRequired, null , invalidRole);
1:ee59de8: 
1:ee59de8:         // These grants will no be explicitly revoked, count on drop
1:ee59de8:         // role to void them!
1:ee59de8:         doStmt("grant admin to a,b,c",
1:ee59de8:                sqlAuthorizationRequired, null , invalidRole);
1:ee59de8:         doStmt("grant foo,bar to admin",
1:ee59de8:                sqlAuthorizationRequired, null , roleDboOnly);
1:ee59de8: 
1:09069c5:         assertSysRolesRowCount(0, 24,
1:09069c5:                                // nonDbo run: foo, bar, notGranted still in
1:09069c5:                                // place, used for testing SET ROLE for non-dbo
1:09069c5:                                // user. foo granted to public, bar granted to
1:09069c5:                                // nonDbo, notGranted not granted at all, so 5!
1:09069c5:                                5);
1:ee59de8: 
1:fe8c4c2:         checkGrantCircularity();
1:ee59de8: 
1:ee59de8:         /*
1:ee59de8:          * SET ROLE
1:ee59de8:          */
1:305269a:         doStmt("set role foo",
1:ee59de8:                sqlAuthorizationRequired, null , null /* through public */);
1:32b1a74:         doStmt("set role 'FOO'",
1:ee59de8:                sqlAuthorizationRequired, null, null);
1:c8e864b: 
1:305269a:         doStmt("set role none",
1:ee59de8:                sqlAuthorizationRequired, null , null);
1:99d7d8b: 
1:305269a:         doDynamicSetRole(_conn);
1:99d7d8b: 
1:0ea31ca:         doStmt("set role 'NONE'",
1:0ea31ca:                sqlAuthorizationRequired, idParseError, idParseError);
1:0ea31ca:         doStmt("set role 'none'",
1:0ea31ca:                sqlAuthorizationRequired, idParseError, idParseError);
1:0ea31ca:         doStmt("set role '\"NONE\"'",
1:0ea31ca:                sqlAuthorizationRequired, null, invalidRole);
1:0ea31ca:         doStmt("set role ' '",
1:0ea31ca:                sqlAuthorizationRequired, idParseError, idParseError);
1:0ea31ca: 
1:0ea31ca: 
1:ee59de8:         doStmt("set role bar",
1:ee59de8:                sqlAuthorizationRequired, null , null /* direct grant */);
1:09069c5:         doStmt("set role notGranted",
1:09069c5:                sqlAuthorizationRequired, null , invalidRole /* not granted */);
1:ee59de8:         doStmt("set role role",
1:09069c5:                sqlAuthorizationRequired, null , invalidRole /* not exists */);
1:ee59de8: 
1:ee59de8:         /* Test that we cannot set role while in non-idle state */
1:ee59de8:         _conn.setAutoCommit(false);
1:ee59de8:         doStmt("select * from SYS.SYSROLES", null, null, null);
1:ee59de8:         doStmt("set role role",
1:ee59de8:                sqlAuthorizationRequired, notIdle , notIdle);
1:ee59de8:         _conn.commit();
1:ee59de8:         _conn.setAutoCommit(true);
1:99d7d8b: 
1:99d7d8b: 
1:ee59de8: 
1:ee59de8:         /*
1:ee59de8:          * CURRENT_ROLE
1:ee59de8:          */
1:99d7d8b:         ResultSet rs = doQuery("values current_role",
1:ee59de8:                                sqlAuthorizationRequired, null , null);
1:44ea4f0:         assertRoleInRs(rs, "\"ROLE\"", "\"BAR\"");
1:ee59de8: 
1:6950a39:         if (rs != null) {
1:6950a39:             rs.close();
1:6950a39:         }
1:6950a39: 
1:ee59de8:         /*
1:ee59de8:          * REVOKE role
1:ee59de8:          */
1:305269a:         doStmt("revoke foo from authid", // authid: user or role
1:ee59de8:                sqlAuthorizationRequired, null , roleDboOnly);
1:ee59de8:         doStmt("revoke foo, role, bar from authid1, authid2",
1:ee59de8:                sqlAuthorizationRequired, null , roleDboOnly);
1:ee59de8:         // revoke everything from nonDbo also, except bar
1:ee59de8:         doStmt("revoke foo, role from " + users[nonDboIndex],
1:ee59de8:                sqlAuthorizationRequired, null , roleDboOnly);
1:99d7d8b: 
1:99d7d8b: 
1:ee59de8:         doStmt("revoke admin from authid",
1:ee59de8:                sqlAuthorizationRequired, null , invalidRole);
1:ee59de8:         doStmtWithWarnings("revoke admin from authid",
1:ee59de8:                            new String[]{sqlAuthorizationRequired, null},
1:ee59de8:                            new String[]{null, revokeWarn},
1:ee59de8:                            new String[]{invalidRole, null},
1:ee59de8:                            false);
1:ee59de8:         doStmt("revoke admin, foo from authid",
1:ee59de8:                sqlAuthorizationRequired, null , invalidRole);
1:ee59de8:         // leave foo granted to public
1:ee59de8:         doStmt("revoke admin from public",
1:ee59de8:                sqlAuthorizationRequired, null , invalidRole);
1:99d7d8b: 
1:ee59de8: 
1:ee59de8: 
1:ee59de8:         /*
1:ee59de8:          * DEFAULT CURRENT_ROLE
1:ee59de8:          */
1:305269a:         doStmt("create table foo(str varchar(128) default current_role)",
1:ee59de8:                sqlAuthorizationRequired, null , null );
1:ee59de8: 
1:ee59de8:         /*
1:ee59de8:          * GRANT TABLE PERMISSION to role
1:ee59de8:          * Should get auto-dropped when role is dropped
1:ee59de8:          */
1:ee59de8:         doStmt("grant select, insert on foo to admin",
1:ee59de8:                sqlAuthorizationRequired, null , null );
1:ee59de8:         /*
1:ee59de8:          * GRANT COLUMN PERMISSION to role
1:ee59de8:          * Should get auto-dropped when role is dropped
1:ee59de8:          */
1:ee59de8:         doStmt("grant select (str), update (str) on foo to admin",
1:ee59de8:                sqlAuthorizationRequired, null , null );
1:ee59de8:         /*
1:ee59de8:          * GRANT ROUTINE PERMISSION to role
1:ee59de8:          * Should get auto-dropped when role is dropped
1:ee59de8:          */
1:ee59de8:         doStmt("create function f1() returns int" +
1:99d7d8b:                "  language java parameter style java" +
2:99d7d8b:                "  external name 'org.apache.derbyTesting." +
1:99d7d8b:                "functionTests.tests.lang.RolesTest.f1'" +
1:ee59de8:                "  no sql called on null input",
1:ee59de8:                null, null, null);
1:ee59de8:         doStmt("grant execute on function f1 to admin",
1:ee59de8:                sqlAuthorizationRequired, null , null );
1:ee59de8: 
1:ee59de8:         assertSysTablePermsRowCount(0,
1:ee59de8:                                     // role admin not dropped yet:
1:c8e864b:                                     // + grant to whoever int setup
1:c8e864b:                                     2,
1:ee59de8:                                     // role admin has been dropped, so
1:ee59de8:                                     // this run's grant to admin is de
1:c8e864b:                                     // facto to a user named admin
1:ee59de8:                                     1);
1:ee59de8: 
1:ee59de8:         assertSysColPermsRowCount(0, 2, 2);
1:ee59de8: 
1:314a19a:         assertSysRoutinePermsRowCount(11, // 11 pre-existing grants to PUBLIC
1:314a19a:                                       12,
1:314a19a:                                       12);
1:ee59de8: 
1:ee59de8:         /*
1:ee59de8:          * DROP ROLE
1:99d7d8b:          */
1:ee59de8: 
1:ee59de8:         // Dbo run: don't drop foo and bar, so they survive to next run,
1:ee59de8:         // a non-dbo can set them, otherwise drop all roles and
1:ee59de8:         // premissions.
1:ee59de8:         doStmt("drop role role",
1:ee59de8:                sqlAuthorizationRequired, null , roleDboOnly);
1:ee59de8: 
1:ee59de8:         doStmt("drop role admin",
1:ee59de8:                sqlAuthorizationRequired, null , roleDboOnly);
1:c8e864b:         assertSysTablePermsRowCount(0,
1:c8e864b:                                     // grant to whoever in setup:
1:c8e864b:                                     1,
1:ee59de8:                                     // nonDbo run: role admin has
1:ee59de8:                                     // been dropped, so this run's
1:ee59de8:                                     // grant to admin is de facto to a
1:c8e864b:                                     // user named admin
1:ee59de8:                                     1);
1:ee59de8:         assertSysColPermsRowCount(0, 0,
1:ee59de8:                                   // nonDbo run: role admin has
1:ee59de8:                                   // been dropped, so this run's grant
1:ee59de8:                                   // to admin is de facto to a user
1:ee59de8:                                   // named admin:
1:ee59de8:                                   2);
1:314a19a:         assertSysRoutinePermsRowCount(11, 11,
1:ee59de8:                                       //  nonDbo run: role admin
1:ee59de8:                                       // has been dropped, so this
1:ee59de8:                                       // run's grant to admin is de
2:ee59de8:                                       // facto to a user named admin:
1:314a19a:                                       12);
1:ee59de8: 
1:ee59de8:         doStmt("drop role \"NONE\"",
1:ee59de8:                sqlAuthorizationRequired, null , roleDboOnly);
1:ee59de8: 
1:ee59de8: 
1:ee59de8:         /*
1:ee59de8:          * REVOKE permissions for nonDbo run
1:ee59de8:          */
1:ee59de8:         doStmt("revoke select, insert on foo from admin",
1:ee59de8:                sqlAuthorizationRequired, null , null );
1:ee59de8:         doStmt("revoke select (str), update (str) on foo from admin",
1:ee59de8:                sqlAuthorizationRequired, null , null );
1:ee59de8:         doStmt("revoke execute on function f1 from admin restrict",
1:ee59de8:                sqlAuthorizationRequired, null , null );
1:ee59de8: 
1:c8e864b:         // assert (almost) blank slate
1:c8e864b:         assertSysTablePermsRowCount(0,
1:c8e864b:                                     // grant to whoever in setup:
1:c8e864b:                                     1,
1:c8e864b:                                     0);
1:ee59de8:         assertSysColPermsRowCount(0,0,0);
1:314a19a:         assertSysRoutinePermsRowCount(11,11,11);
1:ee59de8: 
1:ee59de8:         // roles foo and bar survive to nonDbo run and beyond:
1:09069c5:         assertSysRolesRowCount(0, 5, 5);
1:ee59de8: 
1:ee59de8:         _stm.close();
1:ee59de8: 
1:fb2cca3:         if (!JDBC.vmSupportsJSR169()) {
1:fb2cca3:             testCurrentRoleIsReset();
1:fb2cca3:         }
1:ee59de8:     }
1:ee59de8: 
1:ee59de8: 
1:99d7d8b:     /**
1:f900ff2:      * Create a user that has the same name as a role and try to
1:f900ff2:      * log in with it; should be denied. This will catch cases
1:f900ff2:      * where we can't check up front when roles are created,
1:f900ff2:      * e.g. external authentication, or users are added after the
1:f900ff2:      * role is created (DERBY-3681).
1:f900ff2:      * @exception Exception
1:f900ff2:      */
1:f900ff2:     private void testLoginWithUsernameWhichIsARole() throws SQLException {
1:f900ff2:         if (_authLevel == SQLAUTHORIZATION && isDbo()) {
1:f900ff2:             _stm.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY" +
1:f900ff2:                          "('derby.user.soonarole', 'whatever')");
1:f900ff2: 
1:f900ff2:             // should work, not defined as a role yet
1:f900ff2:             openDefaultConnection("soonarole","whatever").close();
1:f900ff2: 
1:f900ff2:             // remove the user so we can create a role
1:f900ff2:             _stm.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY" +
1:f900ff2:                          "('derby.user.soonarole', NULL)");
1:f900ff2:             _stm.execute("create role soonarole");
1:f900ff2: 
1:f900ff2:             // reintroduce the colliding user name now that we have a role
1:f900ff2:             _stm.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY" +
1:f900ff2:                          "('derby.user.soonarole', 'whatever')");
1:f900ff2: 
1:f900ff2:             try {
1:f900ff2:                 // should fail now
1:f900ff2:                 openDefaultConnection("soonarole","whatever").close();
1:f900ff2:                 fail("Exception expected connecting with " +
1:f900ff2:                      "user name equal to a role");
1:f900ff2:             } catch (SQLException e) {
1:f900ff2:                 assertSQLState(loginFailed, e);
1:f900ff2:             }
1:f900ff2: 
1:f900ff2:             _stm.execute("drop role soonarole");
1:f900ff2:             _stm.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY" +
1:f900ff2:                          "('derby.user.soonarole', NULL)");
1:f900ff2:         }
1:f900ff2:     }
1:f900ff2: 
1:99d7d8b: 
1:99d7d8b:     /**
1:b1d3a85:      * Verifies that the current role is reset when creating a new logical
1:b1d3a85:      * connection.
1:b1d3a85:      * <p>
1:b1d3a85:      * The test is run in a non-statement pooling configuration first,
1:b1d3a85:      * and then with statement pooling enabled if the environment supports it.
1:b1d3a85:      * <p>
1:b1d3a85:      * The test pattern is borrowed from the test case in J2EEDataSourceTest.
1:b1d3a85:      *
1:b1d3a85:      * @see org.apache.derbyTesting.functionTests.tests.jdbcapi.J2EEDataSourceTest#testSchemaIsReset
1:b1d3a85:      *
1:b1d3a85:      * @throws SQLException if something goes wrong
1:b1d3a85:      */
1:b1d3a85:     private void testCurrentRoleIsReset()
1:b1d3a85:             throws SQLException {
1:b1d3a85: 
1:b1d3a85:         if (_authLevel == SQLAUTHORIZATION && isDbo() /* once is enough */) {
1:b1d3a85:             final String user = "DonaldDuck";
1:b1d3a85:             final String passwd = user.concat(pwSuffix);
1:b1d3a85:             ConnectionPoolDataSource cpDs =
1:b1d3a85:                 J2EEDataSource.getConnectionPoolDataSource();
1:b1d3a85:             // Test without statement pooling first.
1:b1d3a85:             doTestCurrentRoleIsReset(cpDs.getPooledConnection(user, passwd),
1:b1d3a85:                                      user);
1:b1d3a85: 
1:b1d3a85:             // Try to enable statement pooling.
1:b1d3a85:             // This is currently only implemented in the client driver.
1:b1d3a85:             if (usingDerbyNetClient()) {
1:b1d3a85:                 J2EEDataSource.setBeanProperty(
1:39b3237:                     cpDs, "maxStatements",7);
1:b1d3a85:                 doTestCurrentRoleIsReset(cpDs.getPooledConnection(user, passwd),
1:b1d3a85:                                          user);
1:b1d3a85:             }
1:b1d3a85:         }
1:b1d3a85:     }
1:b1d3a85: 
1:b1d3a85:     /**
1:b1d3a85:      * Executes a test sequence to make sure the current role is reset between
1:b1d3a85:      * logical connections.
1:b1d3a85:      *
1:b1d3a85:      * @param pc pooled connection to get logical connections from
1:b1d3a85:      * @param user name of  for the connection
1:b1d3a85:      * @throws SQLException if something goes wrong...
1:b1d3a85:      */
1:b1d3a85:     private void doTestCurrentRoleIsReset(PooledConnection pc, String user)
1:b1d3a85:             throws SQLException {
1:b1d3a85: 
1:b1d3a85:         Connection con = pc.getConnection();
1:b1d3a85:         Statement stmt = con.createStatement();
1:b1d3a85:         String n_a     = null; // auth level not used for this test
1:b1d3a85: 
1:b1d3a85:         JDBC.assertCurrentSchema(con, user.toUpperCase());
1:b1d3a85: 
1:b1d3a85:         // Change the role.
1:b1d3a85:         stmt.execute("set role bar");
1:b1d3a85:         ResultSet rs = stmt.executeQuery("values current_role");
1:44ea4f0:         assertRoleInRs(rs, "\"BAR\"", n_a);
1:b1d3a85:         rs.close();
1:b1d3a85:         stmt.close();
1:b1d3a85: 
1:b1d3a85:         // Close the logical connection and get a new one and make sure the
1:b1d3a85:         // current role has been reset.
1:b1d3a85:         con.close();
1:b1d3a85:         con = pc.getConnection();
1:b1d3a85:         stmt = con.createStatement();
1:b1d3a85:         rs = stmt.executeQuery("values current_role");
1:b1d3a85:         assertRoleInRs(rs, null, n_a);
1:b1d3a85:         rs.close();
1:b1d3a85:         stmt.close();
1:b1d3a85:         con.close();
1:b1d3a85:     }
1:b1d3a85: 
1:b1d3a85: 
1:fe8c4c2:     private void checkGrantCircularity() {
1:fe8c4c2:         if (isDbo()) {
1:fe8c4c2:             // Test circularity in role grant relation given this a
1:fe8c4c2:             // priori graph:
1:fe8c4c2:             //
1:fe8c4c2:             //          s8
1:fe8c4c2:             //           |   s1<---s3
1:fe8c4c2:             //           | / |
1:fe8c4c2:             //           V/  |
1:fe8c4c2:             //          s4   |
1:fe8c4c2:             //         / |\  |
1:fe8c4c2:             //        /  V \ V
1:fe8c4c2:             //       s5  s6  s2
1:fe8c4c2:             //           |
1:fe8c4c2:             //           s7
1:fe8c4c2: 
1:fe8c4c2:             String NA = null; // we only run this as dbo
1:fe8c4c2: 
1:fe8c4c2:             for(int i=1; i <= 8; i++) {
1:fe8c4c2:                 doStmt("create role s" + i, NA, null, NA);
1:fe8c4c2:             }
1:fe8c4c2: 
1:fe8c4c2:             // This establishes the role grant graph shown above. None
1:fe8c4c2:             // of these grants should fail.
1:fe8c4c2:             doStmt("grant s1 to s2", NA, null, NA);
1:fe8c4c2:             doStmt("grant s3 to s1", NA, null, NA);
1:fe8c4c2:             doStmt("grant s1 to s4", NA, null, NA);
1:fe8c4c2:             doStmt("grant s4 to s2", NA, null, NA);
1:fe8c4c2:             doStmt("grant s4 to s6", NA, null, NA);
1:fe8c4c2:             doStmt("grant s4 to s5", NA, null, NA);
1:fe8c4c2:             doStmt("grant s6 to s7", NA, null, NA);
1:fe8c4c2:             doStmt("grant s8 to s4", NA, null, NA);
1:fe8c4c2: 
1:fe8c4c2:             // These statements all represent illegal grants in that
1:fe8c4c2:             // they would cause a circularity, so we expect all to
1:fe8c4c2:             // throw.
1:fe8c4c2:             doStmt("grant s1 to s1", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s2 to s3", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s2 to s8", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s7 to s1", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s7 to s4", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s7 to s6", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s7 to s3", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s2 to s1", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s2 to s8", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s2 to s4", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s6 to s1", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s6 to s8", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s6 to s3", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s6 to s4", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s5 to s1", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s5 to s3", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s5 to s4", NA, roleGrantCircularity, NA);
1:fe8c4c2:             doStmt("grant s5 to s8", NA, roleGrantCircularity, NA);
1:fe8c4c2: 
1:fe8c4c2:             for(int i=1; i <= 8; i++) {
1:fe8c4c2:                 doStmt("drop role s" + i, NA, null, NA);
1:fe8c4c2:             }
1:fe8c4c2:         }
1:fe8c4c2:     }
1:fe8c4c2: 
1:fe8c4c2: 
1:ee59de8:     protected void setUp() throws Exception
1:99d7d8b:     {
1:ee59de8:         super.setUp();
1:99d7d8b: 
1:ee59de8:         _stm = createStatement();
1:99d7d8b: 
1:ee59de8:         if (_authLevel == SQLAUTHORIZATION && isDbo()) {
1:99d7d8b: 
1:ee59de8:             // We need to clean away roles when we run the dbo run the
1:ee59de8:             // second time around (client/server). The reason is that
1:ee59de8:             // the dbo run has a side-effect: it leaves roles for the
1:ee59de8:             // non-dbo run to play with, and that run can't remove the
1:ee59de8:             // roles (since non-dbo can't drop roles).
1:99d7d8b:             try {
1:ee59de8:                 _stm.executeUpdate("drop role foo");
1:ee59de8:                 _stm.executeUpdate("drop role bar");
1:09069c5:                 _stm.executeUpdate("drop role notGranted");
1:ee59de8:             } catch (SQLException se) {
1:99d7d8b:             }
1:99d7d8b:         }
1:99d7d8b: 
1:99d7d8b:         try {
1:ee59de8:             _stm.executeUpdate("drop function f1");
1:ee59de8:             _stm.executeUpdate("drop table foo");
1:ee59de8:         } catch (SQLException se) {
1:99d7d8b:         }
1:99d7d8b: 
1:c8e864b:         if (_authLevel == SQLAUTHORIZATION && isDbo()) {
1:c8e864b:             // create a table grant to an (uknown) user WHOEVER.
1:c8e864b:             // This is used to test that create role detects the
1:c8e864b:             // presence of existing user ids before allowing a
1:c8e864b:             // role creation with that id.
1:c8e864b:             _stm.executeUpdate("create table t1(i int)");
1:c8e864b:             _stm.executeUpdate("grant select on t1 to whoever");
1:c8e864b: 
1:c8e864b:             // create a schema for (uknown) user SCHEMAOWNER.
1:c8e864b:             // This is used to test that create role detects the
1:c8e864b:             // presence of existing user ids before allowing a
1:c8e864b:             // role creation with that id.
1:c8e864b:             _stm.executeUpdate(
1:c8e864b:                 "create schema lingerSchema authorization schemaowner");
1:c8e864b:         }
1:c8e864b: 
1:ee59de8:         _stm.close();
1:99d7d8b:     }
1:99d7d8b: 
1:99d7d8b: 
1:ee59de8:     protected void tearDown() throws Exception
1:99d7d8b:     {
1:c8e864b:         if (_authLevel == SQLAUTHORIZATION &&  isDbo()) {
1:c8e864b:             _stm = createStatement();
1:c8e864b: 
1:c8e864b:             try {
1:c8e864b:                 _stm.executeUpdate("revoke select on t1 from whoever");
1:c8e864b:                 _stm.executeUpdate("drop table t1");
1:c8e864b:                 _stm.executeUpdate("drop schema lingerSchema restrict");
1:c8e864b:             } catch (SQLException se) {
1:c8e864b:                 System.err.println("Test error + " + se);
1:c8e864b:             }
1:c8e864b:         }
1:c8e864b: 
1:ee59de8:         if (_stm != null) {
1:ee59de8:             _stm.close();
1:ee59de8:             _stm = null;
1:99d7d8b:         }
1:99d7d8b: 
1:ee59de8:         if (_conn != null) {
1:ee59de8:             _conn = null;
1:99d7d8b:         }
1:99d7d8b: 
1:ee59de8:         super.tearDown();
1:99d7d8b:     }
1:99d7d8b: 
1:99d7d8b: 
1:ee59de8:     private void doStmt(String stmt,
1:c8e864b:                         String noAuthState,
1:c8e864b:                         String authDboState,
1:c8e864b:                         String authNotDboState)
1:ee59de8:     {
1:ee59de8:         doStmt(stmt, noAuthState, authDboState, authNotDboState, false);
1:99d7d8b:     }
1:99d7d8b: 
1:99d7d8b: 
1:ee59de8:     private ResultSet doQuery(String stmt,
2:ee59de8:                               String noAuthState,
2:ee59de8:                               String authDboState,
2:ee59de8:                               String authNotDboState)
1:ee59de8:     {
1:ee59de8:         return doStmt(stmt, noAuthState, authDboState, authNotDboState, true);
1:99d7d8b:     }
1:99d7d8b: 
1:99d7d8b: 
1:ee59de8:     private ResultSet doStmt(String stmt,
1:ee59de8:                              String noAuthState,
1:ee59de8:                              String authDboState,
1:ee59de8:                              String authNotDboState,
1:ee59de8:                              boolean query)
1:ee59de8:     {
1:ee59de8:         return doStmtWithWarnings(stmt,
1:ee59de8:                                   new String[]{noAuthState,null},
1:ee59de8:                                   new String[]{authDboState, null},
1:ee59de8:                                   new String[]{authNotDboState, null},
1:ee59de8:                                   query);
1:99d7d8b:     }
1:99d7d8b: 
1:305269a:     // Minion to analyze outcome. If state string is empty, we expect success
1:305269a:     // for that combination of authentication level and user (dbo or not).
1:ee59de8:     // State arrays: element 0: expected error, element 1: expected warning
1:ee59de8:     private ResultSet doStmtWithWarnings(String stmt,
1:ee59de8:                                          String[] noAuthState,
1:ee59de8:                                          String[] authDboState,
1:ee59de8:                                          String[] authNotDboState,
1:ee59de8:                                          boolean query)
1:ee59de8:     {
1:ee59de8:         ResultSet result = null;
1:ee59de8: 
1:99d7d8b:         try {
1:ee59de8:             if (query) {
1:ee59de8:                 result = _stm.executeQuery(stmt);
1:ee59de8:             } else {
1:ee59de8:                 _stm.execute(stmt);
1:ee59de8:             }
1:ee59de8: 
1:305269a:             if (_authLevel == NO_SQLAUTHORIZATION) {
1:ee59de8:                 if (noAuthState[0] != null) {
1:ee59de8:                     fail("exception " + noAuthState[0] + " expected: (" + stmt);
1:ee59de8:                 }
1:ee59de8:                 if (noAuthState[1] != null) {
1:ee59de8:                     SQLWarning w = _stm.getWarnings();
1:ee59de8:                     assertNotNull("Expected warning but found none", w);
1:ee59de8:                     assertSQLState(noAuthState[1], w);
1:ee59de8:                 }
1:ee59de8: 
1:305269a:             } else { // SQLAUTHORIZATION
1:305269a:                 if (isDbo()) {
1:ee59de8:                     if (authDboState[0] != null) {
1:c8e864b:                         fail("exception " + authDboState[0] + " expected: (" +
2:305269a:                              stmt);
1:ee59de8:                     }
1:ee59de8:                     if (authDboState[1] != null) {
1:ee59de8:                         SQLWarning w = _stm.getWarnings();
1:ee59de8:                         assertNotNull("Expected warning but found none", w);
1:ee59de8:                         assertSQLState(authDboState[1], w);
1:ee59de8:                     }
1:305269a:                 } else {
1:ee59de8:                     if (authNotDboState[0] != null) {
1:c8e864b:                         fail("exception " + authNotDboState[0] +
1:c8e864b:                              " expected: (" + stmt);
1:ee59de8:                     }
1:ee59de8:                     if (authNotDboState[1] != null) {
1:ee59de8:                         SQLWarning w = _stm.getWarnings();
1:ee59de8:                         assertNotNull("Expected warning but found none", w);
1:ee59de8:                         assertSQLState(authNotDboState[1], w);
1:ee59de8:                     }
1:ee59de8:                 }
1:ee59de8:             }
1:305269a:         } catch (SQLException e) {
1:305269a:             if (_authLevel == NO_SQLAUTHORIZATION) {
1:ee59de8:                 if (noAuthState[0] == null) {
1:305269a:                     fail("stmt " + stmt + " failed with exception " +
1:fe8c4c2:                          e.getSQLState(), e);
1:305269a:                 } else {
1:ee59de8:                     assertSQLState("Stmt " + stmt, noAuthState[0], e);
1:ee59de8:                 }
1:ee59de8: 
1:305269a:             } else { // SQLAUTHORIZATION
1:305269a:                 if (isDbo()) {
1:ee59de8:                     if (authDboState[0] == null) {
1:305269a:                         fail("stmt " + stmt + " failed with exception " +
1:fe8c4c2:                              e.getSQLState(), e);
1:305269a:                     } else {
1:ee59de8:                         assertSQLState("Stmt " + stmt, authDboState[0], e);
1:ee59de8:                     }
1:305269a:                 } else {
1:ee59de8:                     if (authNotDboState[0] == null) {
1:305269a:                         fail("stmt " + stmt + " failed with exception " +
1:fe8c4c2:                              e.getSQLState(), e);
1:305269a:                     } else {
1:ee59de8:                         assertSQLState("Stmt " + stmt, authNotDboState[0], e);
1:ee59de8:                     }
1:ee59de8:                 }
1:ee59de8:             }
1:305269a:         }
1:ee59de8: 
1:ee59de8:         return result;
1:305269a:     }
1:ee59de8: 
1:ee59de8: 
1:ee59de8:     private void doDynamicSetRole(Connection conn)
1:ee59de8:     {
1:305269a:         PreparedStatement pstmt = null;
1:ee59de8: 
1:99d7d8b:         try {
1:305269a:             pstmt = conn.prepareStatement("set role ?");
1:ee59de8: 
1:305269a:             if (_authLevel == NO_SQLAUTHORIZATION) {
1:305269a:                 fail("set role ? should have failed; no sqlAuthorization");
1:305269a:             }
1:305269a:         } catch (SQLException e) {
1:305269a:              if (_authLevel == NO_SQLAUTHORIZATION) {
1:305269a:                  assertSQLState(sqlAuthorizationRequired, e);
2:305269a:                  return;
1:305269a:              } else {
1:fe8c4c2:                  fail("prepare of set role ? failed:" + e, e);
1:ee59de8:              }
1:ee59de8:         }
1:ee59de8: 
1:99d7d8b:         try {
1:ee59de8:             pstmt.setString(1, "BAR");
1:305269a:             int rowcnt = pstmt.executeUpdate();
1:6950a39:             assertEquals("rowcount from set role ? not 0", rowcnt, 0);
1:305269a:         } catch (SQLException e) {
1:fe8c4c2:             fail("execute of set role ? failed: [foo]" + e, e);
1:ee59de8:         }
1:ee59de8: 
1:b8801c5:         // Test that trimming works:
1:b8801c5:         try {
1:b8801c5:             pstmt.setString(1, " BAR ");
1:b8801c5:             int rowcnt = pstmt.executeUpdate();
1:b8801c5:             assertEquals("rowcount from set role ? not 0", rowcnt, 0);
1:b8801c5:         } catch (SQLException e) {
1:b8801c5:             fail("execute of set role ? failed: [foo]" + e, e);
1:b8801c5:         }
1:b8801c5: 
1:b8801c5:         try {
1:b8801c5:             int rowcnt = conn.createStatement().executeUpdate(
1:b8801c5:                 "set role ' BAR '");
1:b8801c5:             assertEquals("rowcount from set role ? not 0", rowcnt, 0);
1:b8801c5:         } catch (SQLException e) {
1:b8801c5:             fail("execute of set role ? failed: [foo]" + e, e);
1:b8801c5:         }
1:b8801c5: 
1:ee59de8: 
1:99d7d8b:         try {
1:44ea4f0:             pstmt.setString(1, "");
1:44ea4f0:             int rowcnt = pstmt.executeUpdate();
1:44ea4f0:             fail("Expected syntax error on identifier");
1:44ea4f0:         } catch (SQLException e) {
1:64f3218:             assertSQLState(idParseError, e);
1:44ea4f0:         }
1:44ea4f0: 
1:44ea4f0:         try {
1:0ea31ca:             pstmt.setString(1, " ");
1:0ea31ca:             int rowcnt = pstmt.executeUpdate();
1:0ea31ca:             fail("Expected syntax error on identifier");
1:0ea31ca:         } catch (SQLException e) {
1:0ea31ca:             assertSQLState(idParseError, e);
1:0ea31ca:         }
1:0ea31ca: 
1:0ea31ca:         try {
1:ee59de8:             pstmt.setString(1, null);
1:305269a:             int rowcnt = pstmt.executeUpdate();
1:44ea4f0:             fail("Expected syntax error on identifier");
1:305269a:         } catch (SQLException e) {
1:64f3218:             assertSQLState(idParseError, e);
1:ee59de8:         }
1:44ea4f0: 
1:ee59de8: 
1:ee59de8:         if (isDbo()) {
1:ee59de8:             // not granted to non-dbo, so don't try..
1:ee59de8:             String n_a     = null; // auth level not used for this test
1:ee59de8: 
1:99d7d8b:             try {
1:ee59de8:                 pstmt.setString(1, "NONE");
1:ee59de8:                 int rowcnt = pstmt.executeUpdate();
1:64f3218:                 fail("NONE should not be allowed as a dynamic parameter");
1:64f3218:             } catch (SQLException e) {
1:64f3218:                 assertSQLState(idParseError, e);
1:64f3218:             }
1:64f3218: 
1:64f3218:             try {
1:0ea31ca:                 pstmt.setString(1, "none");
1:0ea31ca:                 int rowcnt = pstmt.executeUpdate();
1:0ea31ca:                 fail("NONE should not be allowed as a dynamic parameter");
1:0ea31ca:             } catch (SQLException e) {
1:0ea31ca:                 assertSQLState(idParseError, e);
1:0ea31ca:             }
1:0ea31ca: 
1:0ea31ca:             try {
1:64f3218:                 pstmt.setString(1, "\"NONE\"");
1:64f3218:                 int rowcnt = pstmt.executeUpdate();
1:6950a39:                 assertEquals("rowcount from set role ? not 0", rowcnt, 0);
1:ee59de8:                 ResultSet rs = doQuery("values current_role", n_a, null , n_a );
1:44ea4f0:                 assertRoleInRs(rs, "\"NONE\"", n_a);
1:99d7d8b:                 rs.close();
1:ee59de8:             } catch (SQLException e) {
1:64f3218:                 fail("execute of set role ? failed: [\"NONE\"] " + e, e);
1:ee59de8:             }
1:ee59de8:         }
1:ee59de8: 
1:ee59de8:         if (pstmt != null) {
2:ee59de8:             try {
1:ee59de8:                 pstmt.close();
1:ee59de8:             } catch (SQLException e) {
1:ee59de8:             }
1:ee59de8:         }
1:ee59de8:     }
1:ee59de8: 
1:ee59de8: 
1:99d7d8b:     /* Test that current role is handled correctly when inside a
1:99d7d8b:      * stored procedure.  The SQL standard requires we have an
1:6950a39:      * "authorization stack", see section 4.34.1.1 and
1:6950a39:      * 4.27.3. Initially tested here, but now moved to
1:6950a39:      * lang/SQLSessionContextTest.
1:99d7d8b:      */
1:99d7d8b: 
1:99d7d8b: 
1:99d7d8b: 
1:ee59de8:     private void assertSystableRowCount(String table,
1:ee59de8:                                         int rcNoAuth,
1:ee59de8:                                         int rcDbo,
1:ee59de8:                                         int rcMereMortal)
1:99d7d8b:         throws SQLException
1:99d7d8b:     {
1:ee59de8:         ResultSet rs = _stm.executeQuery(
1:ee59de8:                 "SELECT COUNT(*) FROM " + table);
1:ee59de8:         rs.next();
1:8e352d6:         assertEquals(table +
1:8e352d6:                      " (_authLevel == NO_SQLAUTHORIZATION) = " + (_authLevel == NO_SQLAUTHORIZATION) +
1:8e352d6:                      ", isDbo() = " + isDbo() +
1:8e352d6:                      ", row count:",
1:ee59de8:                      _authLevel == NO_SQLAUTHORIZATION ? rcNoAuth :
1:ee59de8:                      (isDbo() ? rcDbo : rcMereMortal),
1:ee59de8:                      rs.getInt(1));
1:99d7d8b:         rs.close();
1:99d7d8b:     }
1:99d7d8b: 
1:99d7d8b: 
1:ee59de8:     private void assertSysRolesRowCount(int rcNoAuth,
1:ee59de8:                                         int rcDbo,
1:ee59de8:                                         int rcMereMortal)
1:99d7d8b:         throws SQLException
1:ee59de8:     {
1:99d7d8b: 
1:ee59de8:         if (TestConfiguration.getCurrent().isVerbose()) {
1:ee59de8:             dumpSysRoles();
1:99d7d8b:         }
1:99d7d8b: 
1:ee59de8:         assertSystableRowCount("SYS.SYSROLES",
1:ee59de8:                                rcNoAuth, rcDbo, rcMereMortal);
1:99d7d8b:     }
1:99d7d8b: 
1:99d7d8b: 
1:ee59de8:     private void assertSysTablePermsRowCount(int rcNoAuth,
1:ee59de8:                                              int rcDbo,
1:ee59de8:                                              int rcMereMortal)
1:99d7d8b:         throws SQLException
1:ee59de8:     {
1:99d7d8b: 
1:ee59de8:         if (TestConfiguration.getCurrent().isVerbose()) {
1:ee59de8:             dumpSysTablePerms();
1:99d7d8b:         }
1:99d7d8b: 
1:ee59de8:         assertSystableRowCount("SYS.SYSTABLEPERMS",
1:ee59de8:                                rcNoAuth, rcDbo, rcMereMortal);
1:99d7d8b:     }
1:99d7d8b: 
1:99d7d8b: 
1:ee59de8:     private void assertSysColPermsRowCount(int rcNoAuth,
1:ee59de8:                                            int rcDbo,
1:ee59de8:                                            int rcMereMortal)
1:99d7d8b:         throws SQLException
1:ee59de8:     {
1:99d7d8b: 
1:ee59de8:         if (TestConfiguration.getCurrent().isVerbose()) {
1:ee59de8:             dumpSysColPerms();
1:99d7d8b:         }
1:99d7d8b: 
1:ee59de8:         assertSystableRowCount("SYS.SYSCOLPERMS",
1:ee59de8:                                rcNoAuth, rcDbo, rcMereMortal);
1:ee59de8:     }
1:99d7d8b: 
1:ee59de8: 
1:ee59de8:     private void assertSysRoutinePermsRowCount(int rcNoAuth,
1:ee59de8:                                                int rcDbo,
1:ee59de8:                                                int rcMereMortal)
5:ee59de8:         throws SQLException
1:ee59de8:     {
1:ee59de8: 
1:ee59de8:         if (TestConfiguration.getCurrent().isVerbose()) {
1:ee59de8:             dumpSysRoutinePerms();
1:ee59de8:         }
1:ee59de8: 
1:ee59de8:         assertSystableRowCount("SYS.SYSROUTINEPERMS",
1:ee59de8:                                rcNoAuth, rcDbo, rcMereMortal);
1:ee59de8:     }
1:ee59de8: 
1:ee59de8: 
1:ee59de8:     private void dumpSysRoles() throws SQLException
1:ee59de8:     {
1:ee59de8: 
1:ee59de8:         ResultSet rs = _stm.executeQuery
1:ee59de8:             ("SELECT * FROM SYS.SYSROLES ORDER BY ROLEID");
1:ee59de8: 
1:ee59de8:         println("SYS.SYSROLES:");
1:ee59de8: 
1:ee59de8:         while (rs.next()) {
1:6950a39:             println("uuid=" + rs.getString(1) +
1:6950a39:                     " r=" + rs.getString(2) + " -ee:" + rs.getString(3) +
1:6950a39:                     " -or:" + rs.getString(4) + " a:" + rs.getString(5) +
1:6950a39:                     " d:" + rs.getString(6));
1:ee59de8:         }
1:ee59de8: 
1:99d7d8b:         rs.close();
1:ee59de8:     }
1:ee59de8: 
1:ee59de8: 
1:ee59de8:     private void dumpSysTablePerms() throws SQLException
1:ee59de8:     {
1:ee59de8:         ResultSet rs = _stm.executeQuery
1:ee59de8:             ("SELECT * FROM SYS.SYSTABLEPERMS");
1:ee59de8: 
1:ee59de8:         println("SYS.SYSTABLEPERMS:");
1:ee59de8: 
1:ee59de8:         while (rs.next()) {
1:ee59de8:             println("id: " + rs.getString(1) +
1:ee59de8:                     " -ee:" + rs.getString(2) +
1:ee59de8:                     " -or:" + rs.getString(3) +
1:ee59de8:                     " tableid:" + rs.getString(4) +
1:ee59de8:                     " S:" + rs.getString(5) +
1:ee59de8:                     " D:" + rs.getString(6) +
1:ee59de8:                     " I:" + rs.getString(7) +
1:ee59de8:                     " U:" + rs.getString(8) +
1:ee59de8:                     " R:" + rs.getString(9) +
1:ee59de8:                     " T:" + rs.getString(10));
1:ee59de8:         }
1:ee59de8: 
1:99d7d8b:         rs.close();
1:ee59de8:     }
1:ee59de8: 
1:ee59de8: 
1:ee59de8:     private void dumpSysColPerms() throws SQLException
1:ee59de8:     {
1:ee59de8: 
1:ee59de8:         ResultSet rs = _stm.executeQuery
1:ee59de8:             ("SELECT * FROM SYS.SYSCOLPERMS");
1:ee59de8: 
1:ee59de8:         println("SYS.SYSCOLPERMS:");
1:ee59de8: 
1:ee59de8:         while (rs.next()) {
1:ee59de8:             println("id: " + rs.getString(1) +
1:ee59de8:                     " -ee:" + rs.getString(2) +
1:ee59de8:                     " -or:" + rs.getString(3) +
1:ee59de8:                     " tableid:" + rs.getString(4) +
1:ee59de8:                     " type:" + rs.getString(5) +
1:ee59de8:                     " col#:" + rs.getString(6));
1:ee59de8:         }
1:ee59de8: 
1:99d7d8b:         rs.close();
1:ee59de8:     }
1:ee59de8: 
1:ee59de8: 
1:ee59de8:     private void dumpSysRoutinePerms() throws SQLException
1:ee59de8:     {
1:ee59de8: 
1:ee59de8:         ResultSet rs = _stm.executeQuery
1:ee59de8:             ("SELECT * FROM SYS.SYSROUTINEPERMS");
1:ee59de8: 
1:ee59de8:         println("SYS.SYSROUTINEPERMS:");
1:ee59de8: 
1:ee59de8:         while (rs.next()) {
1:ee59de8:             println("id: " + rs.getString(1) +
1:ee59de8:                     " -ee:" + rs.getString(2) +
1:ee59de8:                     " -or:" + rs.getString(3) +
1:ee59de8:                     " alias:" + rs.getString(4) +
1:ee59de8:                     " grantopt:" + rs.getString(5));
1:ee59de8:         }
1:ee59de8: 
7:ee59de8:         rs.close();
1:ee59de8:     }
1:ee59de8: 
1:ee59de8: 
1:99d7d8b:     private void assertRoleInRs(ResultSet rs,
1:99d7d8b:                                 String dboRole,
1:99d7d8b:                                 String notDboRole)
1:ee59de8:         throws SQLException
1:ee59de8:     {
1:ee59de8: 
1:ee59de8:         if (_authLevel == NO_SQLAUTHORIZATION) {
1:ee59de8:             assertNull(rs);
1:ee59de8:         } else {
1:ee59de8:             if (isDbo()) {
1:6950a39:                 JDBC.assertSingleValueResultSet(rs, dboRole);
1:ee59de8:             } else {
1:6950a39:                 JDBC.assertSingleValueResultSet(rs, notDboRole);
1:ee59de8:             }
1:ee59de8:         }
1:ee59de8:     }
1:ee59de8: 
1:ee59de8:     /**
1:ee59de8:      * Utility function used to test auto-drop of grant routine
1:ee59de8:      * permission to a role
1:ee59de8:      * @return 1
1:ee59de8:      */
1:ee59de8:     public static int f1()
1:ee59de8:     {
1:99d7d8b:         return 1;
1:99d7d8b:     }
1:ee59de8: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:                     cpDs, "maxStatements",7);
commit:7fd0c6e
/////////////////////////////////////////////////////////////////////////
0:         assertSysRoutinePermsRowCount(10, // 10 pre-existing grants to PUBLIC
0:                                       11,
0:                                       11);
/////////////////////////////////////////////////////////////////////////
0:         assertSysRoutinePermsRowCount(10, 10,
0:                                       11);
/////////////////////////////////////////////////////////////////////////
0:         assertSysRoutinePermsRowCount(10,10,10);
commit:8e352d6
/////////////////////////////////////////////////////////////////////////
0:         assertSysRoutinePermsRowCount(8, // 8 pre-existing grants to PUBLIC
0:                                       9,
0:                                       9);
/////////////////////////////////////////////////////////////////////////
0:         assertSysRoutinePermsRowCount(8, 8,
0:                                       9);
/////////////////////////////////////////////////////////////////////////
0:         assertSysRoutinePermsRowCount(8,8,8);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(table +
1:                      " (_authLevel == NO_SQLAUTHORIZATION) = " + (_authLevel == NO_SQLAUTHORIZATION) +
1:                      ", isDbo() = " + isDbo() +
1:                      ", row count:",
commit:c1152a4
/////////////////////////////////////////////////////////////////////////
0:         assertSysRoutinePermsRowCount(7, // 7 pre-existing grants to PUBLIC
0:                                       8,
0:                                       8);
/////////////////////////////////////////////////////////////////////////
0:         assertSysRoutinePermsRowCount(7, 7,
0:                                       8);
/////////////////////////////////////////////////////////////////////////
0:         assertSysRoutinePermsRowCount(7,7,7);
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:314a19a
/////////////////////////////////////////////////////////////////////////
1:         assertSysRoutinePermsRowCount(11, // 11 pre-existing grants to PUBLIC
1:                                       12,
1:                                       12);
/////////////////////////////////////////////////////////////////////////
1:         assertSysRoutinePermsRowCount(11, 11,
1:                                       12);
/////////////////////////////////////////////////////////////////////////
1:         assertSysRoutinePermsRowCount(11,11,11);
commit:a6a0733
/////////////////////////////////////////////////////////////////////////
0:         assertSysRoutinePermsRowCount(9, // 9 pre-existing grants to PUBLIC
0:                                       10,
0:                                       10);
/////////////////////////////////////////////////////////////////////////
0:         assertSysRoutinePermsRowCount(9, 9,
0:                                       10);
/////////////////////////////////////////////////////////////////////////
0:         assertSysRoutinePermsRowCount(9,9,9);
commit:963d9f4
/////////////////////////////////////////////////////////////////////////
0:         assertSysRoutinePermsRowCount(6, // 5 pre-existing grants to PUBLIC
0:                                       7,
0:                                       7);
/////////////////////////////////////////////////////////////////////////
0:         assertSysRoutinePermsRowCount(6, 6,
0:                                       7);
/////////////////////////////////////////////////////////////////////////
0:         assertSysRoutinePermsRowCount(6,6,6);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: import java.sql.SQLWarning;
1: import java.sql.Statement;
1: import javax.sql.PooledConnection;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.J2EEDataSource;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("RolesTest");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("roles:"+framework);
1:         BaseTestSuite noauthSuite = new BaseTestSuite(
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite noauthSuite = new BaseTestSuite(
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("roles:"+framework);
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite usersSuite =
1:             new BaseTestSuite("suite: security level=sqlAuthorization");
commit:b8801c5
/////////////////////////////////////////////////////////////////////////
1:         // Test that trimming works:
1:         try {
1:             pstmt.setString(1, " BAR ");
1:             int rowcnt = pstmt.executeUpdate();
1:             assertEquals("rowcount from set role ? not 0", rowcnt, 0);
1:         } catch (SQLException e) {
1:             fail("execute of set role ? failed: [foo]" + e, e);
1:         }
1: 
1:         try {
1:             int rowcnt = conn.createStatement().executeUpdate(
1:                 "set role ' BAR '");
1:             assertEquals("rowcount from set role ? not 0", rowcnt, 0);
1:         } catch (SQLException e) {
1:             fail("execute of set role ? failed: [foo]" + e, e);
1:         }
1: 
commit:0ea31ca
/////////////////////////////////////////////////////////////////////////
1:         doStmt("set role 'NONE'",
1:                sqlAuthorizationRequired, idParseError, idParseError);
1:         doStmt("set role 'none'",
1:                sqlAuthorizationRequired, idParseError, idParseError);
1:         doStmt("set role '\"NONE\"'",
1:                sqlAuthorizationRequired, null, invalidRole);
1:         doStmt("set role ' '",
1:                sqlAuthorizationRequired, idParseError, idParseError);
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             pstmt.setString(1, " ");
1:             int rowcnt = pstmt.executeUpdate();
1:             fail("Expected syntax error on identifier");
1:         } catch (SQLException e) {
1:             assertSQLState(idParseError, e);
1:         }
1: 
1:         try {
/////////////////////////////////////////////////////////////////////////
1:                 pstmt.setString(1, "none");
1:                 int rowcnt = pstmt.executeUpdate();
1:                 fail("NONE should not be allowed as a dynamic parameter");
1:             } catch (SQLException e) {
1:                 assertSQLState(idParseError, e);
1:             }
1: 
1:             try {
commit:09069c5
/////////////////////////////////////////////////////////////////////////
1:         doStmt("create role notGranted",
1:                sqlAuthorizationRequired, null , roleDboOnly);
/////////////////////////////////////////////////////////////////////////
1:         assertSysRolesRowCount(0, 24,
1:                                // nonDbo run: foo, bar, notGranted still in
1:                                // place, used for testing SET ROLE for non-dbo
1:                                // user. foo granted to public, bar granted to
1:                                // nonDbo, notGranted not granted at all, so 5!
1:                                5);
/////////////////////////////////////////////////////////////////////////
1:         doStmt("set role notGranted",
1:                sqlAuthorizationRequired, null , invalidRole /* not granted */);
1:                sqlAuthorizationRequired, null , invalidRole /* not exists */);
/////////////////////////////////////////////////////////////////////////
1:         assertSysRolesRowCount(0, 5, 5);
/////////////////////////////////////////////////////////////////////////
1:                 _stm.executeUpdate("drop role notGranted");
commit:a6c7bc7
/////////////////////////////////////////////////////////////////////////
1:     private final static String objectAlreadyExists      = "X0Y68";
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we can't create a role which already exists
1:         doStmt("create role foo",
1:                sqlAuthorizationRequired, objectAlreadyExists, roleDboOnly);
1: 
1:                objectAlreadyExists, roleDboOnly);
1:                 sqlAuthorizationRequired, objectAlreadyExists, roleDboOnly);
1:                 sqlAuthorizationRequired, objectAlreadyExists, roleDboOnly);
1:                objectAlreadyExists, roleDboOnly);
1:                objectAlreadyExists, roleDboOnly);
commit:64f3218
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState(idParseError, e);
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState(idParseError, e);
/////////////////////////////////////////////////////////////////////////
1:                 fail("NONE should not be allowed as a dynamic parameter");
1:             } catch (SQLException e) {
1:                 assertSQLState(idParseError, e);
1:             }
1: 
1:             try {
1:                 pstmt.setString(1, "\"NONE\"");
1:                 int rowcnt = pstmt.executeUpdate();
1:                 fail("execute of set role ? failed: [\"NONE\"] " + e, e);
commit:fb2cca3
/////////////////////////////////////////////////////////////////////////
1:         if (!JDBC.vmSupportsJSR169()) {
1:             testCurrentRoleIsReset();
1:         }
commit:44ea4f0
/////////////////////////////////////////////////////////////////////////
1:     private final static String idParseError             = "XCXA0";
/////////////////////////////////////////////////////////////////////////
1:         assertRoleInRs(rs, "\"ROLE\"", "\"BAR\"");
/////////////////////////////////////////////////////////////////////////
1:         assertRoleInRs(rs, "\"BAR\"", n_a);
/////////////////////////////////////////////////////////////////////////
1:             pstmt.setString(1, "");
1:             int rowcnt = pstmt.executeUpdate();
1:             fail("Expected syntax error on identifier");
1:         } catch (SQLException e) {
0:             assertSQLState(idParseError ,e);
1:         }
1: 
1:         try {
1:             fail("Expected syntax error on identifier");
0:             assertSQLState(idParseError ,e);
1: 
/////////////////////////////////////////////////////////////////////////
1:                 assertRoleInRs(rs, "\"NONE\"", n_a);
commit:b1d3a85
/////////////////////////////////////////////////////////////////////////
0: import javax.sql.PooledConnection;
1: import javax.sql.ConnectionPoolDataSource;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.J2EEDataSource;
/////////////////////////////////////////////////////////////////////////
1: 
0:         testCurrentRoleIsReset();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verifies that the current role is reset when creating a new logical
1:      * connection.
1:      * <p>
1:      * The test is run in a non-statement pooling configuration first,
1:      * and then with statement pooling enabled if the environment supports it.
1:      * <p>
1:      * The test pattern is borrowed from the test case in J2EEDataSourceTest.
1:      *
1:      * @see org.apache.derbyTesting.functionTests.tests.jdbcapi.J2EEDataSourceTest#testSchemaIsReset
1:      *
1:      * @throws SQLException if something goes wrong
1:      */
1:     private void testCurrentRoleIsReset()
1:             throws SQLException {
1: 
1:         if (_authLevel == SQLAUTHORIZATION && isDbo() /* once is enough */) {
1:             final String user = "DonaldDuck";
1:             final String passwd = user.concat(pwSuffix);
1:             ConnectionPoolDataSource cpDs =
1:                 J2EEDataSource.getConnectionPoolDataSource();
1:             // Test without statement pooling first.
1:             doTestCurrentRoleIsReset(cpDs.getPooledConnection(user, passwd),
1:                                      user);
1: 
1:             // Try to enable statement pooling.
1:             // This is currently only implemented in the client driver.
1:             if (usingDerbyNetClient()) {
1:                 J2EEDataSource.setBeanProperty(
0:                     cpDs, "maxStatements",new Integer(7));
1:                 doTestCurrentRoleIsReset(cpDs.getPooledConnection(user, passwd),
1:                                          user);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Executes a test sequence to make sure the current role is reset between
1:      * logical connections.
1:      *
1:      * @param pc pooled connection to get logical connections from
1:      * @param user name of  for the connection
1:      * @throws SQLException if something goes wrong...
1:      */
1:     private void doTestCurrentRoleIsReset(PooledConnection pc, String user)
1:             throws SQLException {
1: 
1:         Connection con = pc.getConnection();
1:         Statement stmt = con.createStatement();
1:         String n_a     = null; // auth level not used for this test
1: 
1:         JDBC.assertCurrentSchema(con, user.toUpperCase());
1: 
1:         // Change the role.
1:         stmt.execute("set role bar");
1:         ResultSet rs = stmt.executeQuery("values current_role");
0:         assertRoleInRs(rs, "BAR", n_a);
1:         rs.close();
1:         stmt.close();
1: 
1:         // Close the logical connection and get a new one and make sure the
1:         // current role has been reset.
1:         con.close();
1:         con = pc.getConnection();
1:         stmt = con.createStatement();
1:         rs = stmt.executeQuery("values current_role");
1:         assertRoleInRs(rs, null, n_a);
1:         rs.close();
1:         stmt.close();
1:         con.close();
1:     }
1: 
1: 
commit:0674d16
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:fe8c4c2
/////////////////////////////////////////////////////////////////////////
1:     private final static String roleGrantCircularity     = "4251C";
/////////////////////////////////////////////////////////////////////////
1:         // specified with mixed case : DonaldDuck
/////////////////////////////////////////////////////////////////////////
1:         checkGrantCircularity();
/////////////////////////////////////////////////////////////////////////
1: 
1:     private void checkGrantCircularity() {
1:         if (isDbo()) {
1:             // Test circularity in role grant relation given this a
1:             // priori graph:
1:             //
1:             //          s8
1:             //           |   s1<---s3
1:             //           | / |
1:             //           V/  |
1:             //          s4   |
1:             //         / |\  |
1:             //        /  V \ V
1:             //       s5  s6  s2
1:             //           |
1:             //           s7
1: 
1:             String NA = null; // we only run this as dbo
1: 
1:             for(int i=1; i <= 8; i++) {
1:                 doStmt("create role s" + i, NA, null, NA);
1:             }
1: 
1:             // This establishes the role grant graph shown above. None
1:             // of these grants should fail.
1:             doStmt("grant s1 to s2", NA, null, NA);
1:             doStmt("grant s3 to s1", NA, null, NA);
1:             doStmt("grant s1 to s4", NA, null, NA);
1:             doStmt("grant s4 to s2", NA, null, NA);
1:             doStmt("grant s4 to s6", NA, null, NA);
1:             doStmt("grant s4 to s5", NA, null, NA);
1:             doStmt("grant s6 to s7", NA, null, NA);
1:             doStmt("grant s8 to s4", NA, null, NA);
1: 
1:             // These statements all represent illegal grants in that
1:             // they would cause a circularity, so we expect all to
1:             // throw.
1:             doStmt("grant s1 to s1", NA, roleGrantCircularity, NA);
1:             doStmt("grant s2 to s3", NA, roleGrantCircularity, NA);
1:             doStmt("grant s2 to s8", NA, roleGrantCircularity, NA);
1:             doStmt("grant s7 to s1", NA, roleGrantCircularity, NA);
1:             doStmt("grant s7 to s4", NA, roleGrantCircularity, NA);
1:             doStmt("grant s7 to s6", NA, roleGrantCircularity, NA);
1:             doStmt("grant s7 to s3", NA, roleGrantCircularity, NA);
1:             doStmt("grant s2 to s1", NA, roleGrantCircularity, NA);
1:             doStmt("grant s2 to s8", NA, roleGrantCircularity, NA);
1:             doStmt("grant s2 to s4", NA, roleGrantCircularity, NA);
1:             doStmt("grant s6 to s1", NA, roleGrantCircularity, NA);
1:             doStmt("grant s6 to s8", NA, roleGrantCircularity, NA);
1:             doStmt("grant s6 to s3", NA, roleGrantCircularity, NA);
1:             doStmt("grant s6 to s4", NA, roleGrantCircularity, NA);
1:             doStmt("grant s5 to s1", NA, roleGrantCircularity, NA);
1:             doStmt("grant s5 to s3", NA, roleGrantCircularity, NA);
1:             doStmt("grant s5 to s4", NA, roleGrantCircularity, NA);
1:             doStmt("grant s5 to s8", NA, roleGrantCircularity, NA);
1: 
1:             for(int i=1; i <= 8; i++) {
1:                 doStmt("drop role s" + i, NA, null, NA);
1:             }
1:         }
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                          e.getSQLState(), e);
/////////////////////////////////////////////////////////////////////////
1:                              e.getSQLState(), e);
1:                              e.getSQLState(), e);
/////////////////////////////////////////////////////////////////////////
1:                  fail("prepare of set role ? failed:" + e, e);
/////////////////////////////////////////////////////////////////////////
1:             fail("execute of set role ? failed: [foo]" + e, e);
/////////////////////////////////////////////////////////////////////////
0:             fail("execute of set role ? failed: [NONE] " + e, e);
/////////////////////////////////////////////////////////////////////////
0:                 fail("execute of set role ? failed: [NONE] " + e, e);
commit:f900ff2
/////////////////////////////////////////////////////////////////////////
1:     private final static String loginFailed              = "08004";
/////////////////////////////////////////////////////////////////////////
1:         // id as a known user (DERBY-3673).
/////////////////////////////////////////////////////////////////////////
1:         testLoginWithUsernameWhichIsARole();
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Create a user that has the same name as a role and try to
1:      * log in with it; should be denied. This will catch cases
1:      * where we can't check up front when roles are created,
1:      * e.g. external authentication, or users are added after the
1:      * role is created (DERBY-3681).
1:      * @exception Exception
1:      */
1:     private void testLoginWithUsernameWhichIsARole() throws SQLException {
1:         if (_authLevel == SQLAUTHORIZATION && isDbo()) {
1:             _stm.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY" +
1:                          "('derby.user.soonarole', 'whatever')");
1: 
1:             // should work, not defined as a role yet
1:             openDefaultConnection("soonarole","whatever").close();
1: 
1:             // remove the user so we can create a role
1:             _stm.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY" +
1:                          "('derby.user.soonarole', NULL)");
1:             _stm.execute("create role soonarole");
1: 
1:             // reintroduce the colliding user name now that we have a role
1:             _stm.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY" +
1:                          "('derby.user.soonarole', 'whatever')");
1: 
1:             try {
1:                 // should fail now
1:                 openDefaultConnection("soonarole","whatever").close();
1:                 fail("Exception expected connecting with " +
1:                      "user name equal to a role");
1:             } catch (SQLException e) {
1:                 assertSQLState(loginFailed, e);
1:             }
1: 
1:             _stm.execute("drop role soonarole");
1:             _stm.execute("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY" +
1:                          "('derby.user.soonarole', NULL)");
1:         }
1:     }
1: 
commit:c8e864b
/////////////////////////////////////////////////////////////////////////
1:     private final static String userException            = "38000";
0:     private final static String userAlreadyExists        = "X0Y68";
/////////////////////////////////////////////////////////////////////////
1:     private final static String[] users =
1:         {"TEST_DBO", "DonaldDuck", "\"additional\"\"user\""};
1: 
1:     private final static int
1:         dboIndex            = 0; // used for connections
1:     private final static int
1:         nonDboIndex         = 1; // used for connections
1:     private final static int
1:         additionaluserIndex = 2; // *not* used for connections
/////////////////////////////////////////////////////////////////////////
1:         /* Semantic tests */
1:             semanticSuite("suite: semantic, embedded"));
1:                 semanticSuite("suite: semantic, client")));
/////////////////////////////////////////////////////////////////////////
1:      * Construct suite of semantic tests
1:      * @return A suite containing the semantic test cases incarnated only
1:     private static Test semanticSuite(String framework)
/////////////////////////////////////////////////////////////////////////
1:         noauthSuite.addTest(new RolesTest("testSemantics",
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(wrapInAuthorization("testSemantics"));
/////////////////////////////////////////////////////////////////////////
1:         // First decorate with users (except "additionaluser"), then
1:         // with authorization decorator
1:         for (int userNo = 0; userNo <= users.length - 2; userNo++) {
/////////////////////////////////////////////////////////////////////////
1:      * Semantic tests for roles.
1:     public void testSemantics() throws SQLException
1:         println("testSemantics: auth=" + this._authLevel +
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we can't create a role which has the same auth
0:         // id as a known user.
1:         //
1:         // a) built-in user:
1:         doStmt("create role " + users[dboIndex], sqlAuthorizationRequired,
0:                userAlreadyExists, roleDboOnly);
1: 
0:         // specified with mixed case : DonalDuck
1:         doStmt("create role " + users[nonDboIndex],
0:                 sqlAuthorizationRequired, userAlreadyExists, roleDboOnly);
1: 
1:         // delimited identifier with embedded text quote inside
1:         doStmt("create role " + users[additionaluserIndex],
0:                 sqlAuthorizationRequired, userAlreadyExists, roleDboOnly);
1: 
1: 
1:         // b) A grant to this auth id exists (see setup), even though
1:         // it is not a built-in user, so the presumption is, it is a
1:         // user defined externally:
1:         doStmt("create role whoever", sqlAuthorizationRequired,
0:                userAlreadyExists, roleDboOnly);
1: 
1:         // c) A schema exists which has an authid we did not see
1:         // through properties; user has been removed, but his schema
1:         // lingers..
1:         doStmt("create role schemaowner", sqlAuthorizationRequired,
0:                userAlreadyExists, roleDboOnly);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                                     // + grant to whoever int setup
1:                                     2,
1:                                     // facto to a user named admin
/////////////////////////////////////////////////////////////////////////
1:         assertSysTablePermsRowCount(0,
1:                                     // grant to whoever in setup:
1:                                     1,
1:                                     // user named admin
/////////////////////////////////////////////////////////////////////////
1:         // assert (almost) blank slate
1:         assertSysTablePermsRowCount(0,
1:                                     // grant to whoever in setup:
1:                                     1,
1:                                     0);
/////////////////////////////////////////////////////////////////////////
1:         if (_authLevel == SQLAUTHORIZATION && isDbo()) {
1:             // create a table grant to an (uknown) user WHOEVER.
1:             // This is used to test that create role detects the
1:             // presence of existing user ids before allowing a
1:             // role creation with that id.
1:             _stm.executeUpdate("create table t1(i int)");
1:             _stm.executeUpdate("grant select on t1 to whoever");
1: 
1:             // create a schema for (uknown) user SCHEMAOWNER.
1:             // This is used to test that create role detects the
1:             // presence of existing user ids before allowing a
1:             // role creation with that id.
1:             _stm.executeUpdate(
1:                 "create schema lingerSchema authorization schemaowner");
1:         }
1: 
1:         if (_authLevel == SQLAUTHORIZATION &&  isDbo()) {
1:             _stm = createStatement();
1: 
1:             try {
1:                 _stm.executeUpdate("revoke select on t1 from whoever");
1:                 _stm.executeUpdate("drop table t1");
1:                 _stm.executeUpdate("drop schema lingerSchema restrict");
1:             } catch (SQLException se) {
1:                 System.err.println("Test error + " + se);
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:                         String noAuthState,
1:                         String authDboState,
1:                         String authNotDboState)
/////////////////////////////////////////////////////////////////////////
1:                         fail("exception " + authDboState[0] + " expected: (" +
/////////////////////////////////////////////////////////////////////////
1:                         fail("exception " + authNotDboState[0] +
1:                              " expected: (" + stmt);
commit:9c3b91c
/////////////////////////////////////////////////////////////////////////
1:     private final static String invalidPUBLIC            = "4251B";
/////////////////////////////////////////////////////////////////////////
1:         doStmt("create role public",
1:                syntaxError, syntaxError, syntaxError);
1:         doStmt("create role \"PUBLIC\"",
1:                sqlAuthorizationRequired, invalidPUBLIC, roleDboOnly);
1:         doStmt("grant \"PUBLIC\" to " + users[1],
1:                sqlAuthorizationRequired, invalidPUBLIC, invalidPUBLIC);
1:         doStmt("revoke \"PUBLIC\" from " + users[1],
1:                sqlAuthorizationRequired, invalidPUBLIC, invalidPUBLIC);
commit:6950a39
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
0:     private final static String userException = "38000";
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (rs != null) {
1:             rs.close();
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:             assertEquals("rowcount from set role ? not 0", rowcnt, 0);
/////////////////////////////////////////////////////////////////////////
1:             assertEquals("rowcount from set role ? not 0", rowcnt, 0);
/////////////////////////////////////////////////////////////////////////
0:                 assertEquals("rowcount from set role ? not 0", rowcnt, 0);
/////////////////////////////////////////////////////////////////////////
1:      * "authorization stack", see section 4.34.1.1 and
1:      * 4.27.3. Initially tested here, but now moved to
1:      * lang/SQLSessionContextTest.
/////////////////////////////////////////////////////////////////////////
1:             println("uuid=" + rs.getString(1) +
1:                     " r=" + rs.getString(2) + " -ee:" + rs.getString(3) +
1:                     " -or:" + rs.getString(4) + " a:" + rs.getString(5) +
1:                     " d:" + rs.getString(6));
/////////////////////////////////////////////////////////////////////////
1:                 JDBC.assertSingleValueResultSet(rs, dboRole);
1:                 JDBC.assertSingleValueResultSet(rs, notDboRole);
/////////////////////////////////////////////////////////////////////////
commit:5990b20
/////////////////////////////////////////////////////////////////////////
1:     private final static String syntaxError              = "42X01";
1:     private final static String roleDboOnly              = "4251A";
1:     private final static String invalidRole              = "0P000";
1:     private final static String tooLongId                = "42622";
1:     private final static String revokeWarn               = "01007";
1:     private final static String notIdle                  = "25001";
1:     private final static String invalidRoleName          = "4293A";
1:     private int MAX_IDENTIFIER_LENGTH = 128;
/////////////////////////////////////////////////////////////////////////
1:         char[] longname = new char[MAX_IDENTIFIER_LENGTH + 1];
1:         java.util.Arrays.fill(longname, 'a');
1:         String nameWithMoreThanMaxChars = new String(longname);
1: 
1:         doStmt("create role " + nameWithMoreThanMaxChars,
1:                tooLongId, tooLongId, tooLongId);
1:         // Check SYS-prefix ban
1:         doStmt("create role sysrole",
1:                sqlAuthorizationRequired, invalidRoleName, invalidRoleName);
1:         doStmt("create role \"SYSROLE\"",
1:                sqlAuthorizationRequired, invalidRoleName, invalidRoleName);
/////////////////////////////////////////////////////////////////////////
1:         // Check that role name can be longer than present user name
1:         // (max 30, cf.  Limits.DB2_MAX_USERID_LENGTH).
1:         String nameWithMoreThan30Chars = ("r123456789" +
1:                                           "0123456789" +
1:                                           "01234567890"); // 31 long
1:         doStmt("create role " + nameWithMoreThan30Chars,
1:                n_a, null, n_a);
1: 
1:         assertSysRolesRowCount(n_a_cnt, 3, n_a_cnt);
1:         doStmt("set role " + nameWithMoreThan30Chars, n_a, null, n_a);
1: 
1:         doStmt("create table mytab(i int)", n_a, null, n_a);
1:         doStmt("grant select on mytab to " + nameWithMoreThan30Chars,
1:                n_a, null, n_a);
1:         doStmt("revoke select on mytab from " + nameWithMoreThan30Chars,
1:                n_a, null, n_a);
1:         doStmt("drop table mytab", n_a, null, n_a);
1: 
1:         doStmt("drop role " + nameWithMoreThan30Chars, n_a, null, n_a);
commit:99d7d8b
/////////////////////////////////////////////////////////////////////////
0: import java.sql.DriverManager;
/////////////////////////////////////////////////////////////////////////
1: 
0:         doSetRoleInsideStoredProcedures("FOO");
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:         assertRoleInRs(rs, "ROLE", "BAR");
/////////////////////////////////////////////////////////////////////////
1:                "functionTests.tests.lang.RolesTest.f1'" +
/////////////////////////////////////////////////////////////////////////
0:                 assertRoleInRs(rs, "NONE", n_a);
/////////////////////////////////////////////////////////////////////////
1:     /* Test that current role is handled correctly when inside a
1:      * stored procedure.  The SQL standard requires we have an
0:      * "authorization stack", see section 4.34.1.1. This implies that
0:      * current role is popped at end of stored procedure.
0:      * We test two levels deep.
1:      */
0:     private void doSetRoleInsideStoredProcedures(String currRole)
1:             throws SQLException
1:     {
0:         if (_authLevel != NO_SQLAUTHORIZATION) {
0:             String n_a = null; // auth level not used for this test
1: 
0:             doStmt("create procedure p2(role varchar(255))" +
0:                    "  dynamic result sets 1 language java parameter style java"+
1:                    "  external name 'org.apache.derbyTesting." +
0:                    "functionTests.tests.lang.RolesTest.p2'" +
0:                    "  modifies sql data",
0:                    n_a, null, null);
0:             doStmt("create function f2(role varchar(255))" +
0:                    "  returns int language java parameter style java" +
1:                    "  external name 'org.apache.derbyTesting." +
0:                    "functionTests.tests.lang.RolesTest.f2'" +
0:                    "  reads sql data",
0:                    n_a, null, null);
0:             doStmt("call p2('" + currRole + "')",
0:                    n_a , null , null );
1: 
0:             // Dynamic result set: At what time should CURRENT_ROLE be
0:             // evaluated?  Logically at the inside, so it should be
0:             // "BAR" also when accessed on outside. I think. Anyway,
0:             // that's what's implemented: the activation of the call
0:             // is still live and holds the current role as it was
0:             // inside the nested scope even when the procedure call
0:             // has returned.
0:             ResultSet prs = _stm.getResultSet();
0:             assertRoleInRs(prs, "BAR", "BAR");
0:             prs.close();
1: 
0:             // check that role didn't get impacted by change inside p2
0:             // too 'BAR':
1:             ResultSet rs = doQuery("values current_role",
0:                                    n_a , null , null );
0:             assertRoleInRs(rs, currRole, currRole);
1:             rs.close();
1: 
0:             rs = doQuery("values f2('" + currRole + "')",
0:                          n_a , null , null );
1:             rs.close();
1: 
0:             doStmt("drop procedure p2", n_a, null, null);
0:             doStmt("drop function  f2", n_a, null, null);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void assertRoleInRs(ResultSet rs,
1:                                 String dboRole,
1:                                 String notDboRole)
/////////////////////////////////////////////////////////////////////////
0:             String actualRole = rs.getString(1);
0:                 assertTrue("role is " + actualRole + ", expected " + dboRole,
0:                            dboRole.equals(actualRole));
0:                 assertTrue("role is " + actualRole + ", expected " + notDboRole,
0:                            notDboRole.equals(actualRole));
/////////////////////////////////////////////////////////////////////////
0:     private static void assertRsSingleStringValue(ResultSet rs,
0:                                                   String expectedValue)
1:             throws SQLException
1:     {
1: 
0:         assertTrue("result set empty", rs.next());
0:         String actualValue = rs.getString(1);
1: 
0:         assertTrue("string is " + actualValue + ", expected " + expectedValue,
0:                    actualValue.equals(expectedValue));
1: 
0:         // cardinality should be 1
0:         assertFalse("result set not empty", rs.next());
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
0:      * Utility procedure used to test that current role
0:      * is stacked correctly according to dynamic scope.
1:      */
0:     public static void p2(String roleOutside, ResultSet[] rs1)
1:             throws SQLException
1:     {
0:         Connection conn1 = null;
0:         Connection conn2 = null;
1: 
1:         try {
0:             conn1 = DriverManager.getConnection("jdbc:default:connection");
0:             PreparedStatement ps =
0:                 conn1.prepareStatement("values current_role");
1: 
0:             // check that we inherit role correctly
0:             ResultSet rs = ps.executeQuery();
0:             assertRsSingleStringValue(rs, roleOutside);
1:             rs.close();
1: 
0:             // set the role to something else
0:             Statement stm = conn1.createStatement();
0:             stm.execute("set role bar");
0:             rs = ps.executeQuery();
1: 
0:             // check that role got set
0:             assertRsSingleStringValue(rs, "BAR");
1: 
0:             // another nesting level to test authorization stack even more
0:             stm.execute(
0:                 "create procedure calledNestedFromP2(role varchar(255))" +
1:                 "  language java parameter style java" +
0:                 "  external name 'org.apache.derbyTesting." +
0:                 "functionTests.tests.lang.RolesTest.calledNestedFromP2'" +
0:                 "  modifies sql data");
0:             conn1.commit(); // need to be idle
0:             stm.execute("call calledNestedFromP2('BAR')");
1: 
0:             rs = ps.executeQuery();
1: 
0:             // check that role didn't get impacted by change inside
0:             // calledNestedFromP2 too 'FOO':
0:             assertRsSingleStringValue(rs, "BAR");
0:             stm.execute("drop procedure calledNestedFromP2");
1: 
0:             // Test that the role is shared by another nested
0:             // connection also.
0:             conn2 = DriverManager.getConnection("jdbc:default:connection");
0:             PreparedStatement ps2 =
0:                 conn2.prepareStatement("values current_role");
0:             ResultSet rs2 = ps2.executeQuery();
0:             assertRsSingleStringValue(rs2, "BAR");
1: 
0:             // Pass out CURRENT_ROLE in a dynamic result set.
0:             rs = ps.executeQuery();
0:             rs1[0] = rs;
1: 
0:         } finally {
1: 
0:             if (conn1 != null) {
1:                 try {
0:                     conn1.close();
0:                 } catch (Exception e) {
1:                 }
1:             }
1: 
0:             if (conn2 != null) {
1:                 try {
0:                     conn2.close();
0:                 } catch (Exception e) {
1:                 }
1:             }
1:         }
1: 
1:     }
1: 
1:     /**
0:      * Called from p2 so we get to test with a call stack 3 levels
0:      * deep.
1:      */
0:     public static void calledNestedFromP2(String roleOutside)
1:             throws SQLException
1:     {
0:         Connection conn1 = null;
1: 
1:         try {
0:             conn1 = DriverManager.getConnection("jdbc:default:connection");
0:             PreparedStatement ps =
0:                 conn1.prepareStatement("values current_role");
1: 
0:             // check that we inherit role correctly
0:             ResultSet rs = ps.executeQuery();
0:             assertRsSingleStringValue(rs, roleOutside);
1:             rs.close();
1: 
0:             // set the role to something else
0:             Statement stm = conn1.createStatement();
0:             stm.execute("set role foo");
0:             rs = ps.executeQuery();
1: 
0:             // check that role got set
0:             assertRsSingleStringValue(rs, "FOO");
1: 
0:         } finally {
0:             if (conn1 != null) {
1:                 try {
0:                     conn1.close();
0:                 } catch (Exception e) {
1:                 }
1:             }
1:         }
1:     }
1: 
1: 
1:     /**
0:      * Utility function used to test that current role
0:      * is stacked correctly according to scope.
1:      */
0:     public static int f2(String roleOutside) throws SQLException
1:     {
0:         Connection conn1 = null;
1: 
1:         try {
0:             conn1 = DriverManager.getConnection("jdbc:default:connection");
0:             PreparedStatement ps =
0:                 conn1.prepareStatement("values current_role");
1: 
0:             // check that we inherit role correctly
0:             ResultSet rs = ps.executeQuery();
0:             assertRsSingleStringValue(rs, roleOutside);
1:             rs.close();
1: 
0:             // set the role to something else
0:             Statement stm = conn1.createStatement();
0:             stm.execute("set role bar");
0:             rs = ps.executeQuery();
1: 
0:             // check that role got set
0:             assertRsSingleStringValue(rs, "BAR");
1: 
0:         } finally {
1: 
0:             if (conn1 != null) {
1:                 try {
0:                     conn1.close();
0:                 } catch (Exception e) {
1:                 }
1:             }
1: 
1:         }
1:         return 1;
1:     }
commit:ee59de8
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.RolesTest
/////////////////////////////////////////////////////////////////////////
0: import java.sql.SQLWarning;
1: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
0:     private final static String roleDboOnly = "4251A";
0:     private final static String invalidRole = "0P000";
0:     private final static String tooLongId   = "42622";
0:     private final static String revokeWarn  = "01007";
0:     private final static String notIdle     = "25001";
/////////////////////////////////////////////////////////////////////////
0:     private final static int dboIndex        = 0;
0:     private final static int nonDboIndex = 1;
1:     private boolean isDbo()
1:     {
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(
1:             TestConfiguration.clientServerDecorator(
1:                 negativeSyntaxSuite("suite: negative syntax, client")));
1: 
1:         /* Positive syntax tests */
1:         suite.addTest(positiveSyntaxSuite("suite: positive syntax, embedded"));
1: 
1:         suite.addTest(
1:             TestConfiguration.clientServerDecorator(
1:                 positiveSyntaxSuite("suite: positive syntax, client")));
1:         suite.addTest(
1:             TestConfiguration.clientServerDecorator(
0:                 positiveSuite("suite: positive, client")));
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suite = new TestSuite("roles:"+framework);
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(noauthSuite);
1:         // Tests running with sql authorization set.
1:         suite.addTest(wrapInAuthorization("testNegativeSyntax"));
1:      *
1:      * Construct suite of tests for positive syntax (edge cases)
1:      *
1:      * @param framework Derby framework indication
1:      * @return A suite containing the test cases for  syntax
1:      * edge cases. Incarnated only for sqlAuthorization, dbo.
1:     private static Test positiveSyntaxSuite(String framework)
1:     {
1:         String dbo = users[dboIndex];
1:         String dbopw = dbo.concat(pwSuffix);
1: 
1:         Test t = (TestConfiguration.changeUserDecorator
1:                   (new RolesTest("testPositiveSyntax",
1:                                  SQLAUTHORIZATION,
1:                                  dbo, dbopw),
1:                    dbo, dbopw));
1: 
1:         return TestConfiguration.sqlAuthorizationDecorator(
1:             DatabasePropertyTestSetup.builtinAuthentication(
1:                 t, users, pwSuffix));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         String nameWithMoreThan30Chars = ("r123456789" +
0:                                           "0123456789" +
0:                                           "01234567890"); // 31 long
0:         doStmt("create role " + nameWithMoreThan30Chars,
0:                sqlAuthorizationRequired, tooLongId, tooLongId);
1: 
1:         _stm.close();
1:     }
1: 
1: 
1:     /**
1:      * Test syntax edge cases (positive)
1:      *
1:      * @throws SQLException
1:      */
1:     public void testPositiveSyntax() throws SQLException
1:     {
1:         println("testPositiveSyntax");
1:         String n_a     = null; // auth level not used for this test
1:         int    n_a_cnt = -1;   //
1: 
1:         // sanity check:
1:         if (!isDbo()) { throw new SQLException("test error"); }
1: 
1: 
1:         _conn = getConnection();
1:         _stm  = _conn.createStatement();
1: 
1:         // "trigger" is not reserved word, but required tweaking of grammar
1:         // so we add a regression test for it.
1:         doStmt("create role trigger", n_a, null, n_a);
1: 
1:         // "role" is not a reserved word, either:
1:         doStmt("create role role", n_a, null, n_a);
1: 
0:         assertSysRolesRowCount(n_a_cnt, 2, n_a_cnt);
1: 
1:         doStmt("grant trigger to foo", n_a, null, n_a);
1:         doStmt("grant role to foo", n_a, null, n_a);
1:         doStmt("revoke trigger from foo", n_a, null, n_a);
1:         doStmt("revoke role from foo", n_a, null, n_a);
1: 
1:         doStmt("drop role trigger", n_a, null, n_a);
1:         doStmt("drop role role", n_a, null, n_a);
1: 
1:         assertSysRolesRowCount(n_a_cnt, 0, n_a_cnt);
1: 
1:         _stm.close();
/////////////////////////////////////////////////////////////////////////
1:         /*
1:          * Tests running without sql authorization set.  The purpose
1:          * of this is just to make sure the proper errors are given.
/////////////////////////////////////////////////////////////////////////
1: 
1:         suite.addTest(noauthSuite);
0:         suite.addTest(wrapInAuthorization("testPositive"));
1:      * Wrap in decorators to run with data base owner and one other
1:     private static Test wrapInAuthorization(String testName)
/////////////////////////////////////////////////////////////////////////
1:      * Side effect from the dbo run are needed for the nonDbo run
1:      * which follows (since only dbo can create and grant roles).
/////////////////////////////////////////////////////////////////////////
1: 
1:         /*
1:          * CREATE ROLE
1:          */
1:                sqlAuthorizationRequired, null , roleDboOnly);
1:                sqlAuthorizationRequired, null , roleDboOnly);
1:                sqlAuthorizationRequired, null , roleDboOnly);
1:         doStmt("create role admin",
1:                 sqlAuthorizationRequired, null , roleDboOnly);
1:                 sqlAuthorizationRequired, null , roleDboOnly);
1: 
1:         /*
1:          * GRANT <role>
1:          */
1:                sqlAuthorizationRequired, null , roleDboOnly);
1:         // this grant also grant role bar to the non-dbo user
1:         // so we can set it when running as non-dbo.
1:         doStmt("grant foo, role, bar to authid1, authid2, " +
1:                users[nonDboIndex],
1:                sqlAuthorizationRequired, null , roleDboOnly);
1: 
1:         doStmt("grant admin to authid",
1:                sqlAuthorizationRequired, null , invalidRole);
1:         doStmt("grant admin, foo to authid",
1:                sqlAuthorizationRequired, null , invalidRole);
1:         doStmt("grant admin, foo to public",
1:                sqlAuthorizationRequired, null , invalidRole);
1: 
1:         // These grants will no be explicitly revoked, count on drop
1:         // role to void them!
1:         doStmt("grant admin to a,b,c",
1:                sqlAuthorizationRequired, null , invalidRole);
1:         doStmt("grant foo,bar to admin",
1:                sqlAuthorizationRequired, null , roleDboOnly);
1: 
0:         assertSysRolesRowCount(0, 23,
0:                                // nonDbo run: foo, bar still in
0:                                // place, used for testing SET ROLE for
0:                                // non-dbo user. foo granted to public,
0:                                // bar granted to nonDbo, so 4!
0:                                4);
1:         /*
1:          * SET ROLE
1:          */
1:                sqlAuthorizationRequired, null , null /* through public */);
1:                sqlAuthorizationRequired, null, null);
1:                sqlAuthorizationRequired, null , null);
1:         doStmt("set role bar",
1:                sqlAuthorizationRequired, null , null /* direct grant */);
1:         doStmt("set role role",
1:                sqlAuthorizationRequired, null , invalidRole);
1:         /* Test that we cannot set role while in non-idle state */
1:         _conn.setAutoCommit(false);
1:         doStmt("select * from SYS.SYSROLES", null, null, null);
1:         doStmt("set role role",
1:                sqlAuthorizationRequired, notIdle , notIdle);
1:         _conn.commit();
1:         _conn.setAutoCommit(true);
1:         /*
1:          * CURRENT_ROLE
1:          */
0:         ResultSet rs = doQuery("values current_role",
1:                                sqlAuthorizationRequired, null , null);
0:         assertCurrentRole(rs, "ROLE", "BAR");
1: 
1:         /*
1:          * REVOKE role
1:          */
1:                sqlAuthorizationRequired, null , roleDboOnly);
1:         doStmt("revoke foo, role, bar from authid1, authid2",
1:                sqlAuthorizationRequired, null , roleDboOnly);
1:         // revoke everything from nonDbo also, except bar
1:         doStmt("revoke foo, role from " + users[nonDboIndex],
1:                sqlAuthorizationRequired, null , roleDboOnly);
1:         doStmt("revoke admin from authid",
1:                sqlAuthorizationRequired, null , invalidRole);
1:         doStmtWithWarnings("revoke admin from authid",
1:                            new String[]{sqlAuthorizationRequired, null},
1:                            new String[]{null, revokeWarn},
1:                            new String[]{invalidRole, null},
1:                            false);
1:         doStmt("revoke admin, foo from authid",
1:                sqlAuthorizationRequired, null , invalidRole);
1:         // leave foo granted to public
1:         doStmt("revoke admin from public",
1:                sqlAuthorizationRequired, null , invalidRole);
1: 
1:         /*
1:          * DEFAULT CURRENT_ROLE
1:          */
1:                sqlAuthorizationRequired, null , null );
1: 
1:         /*
1:          * GRANT TABLE PERMISSION to role
1:          * Should get auto-dropped when role is dropped
1:          */
1:         doStmt("grant select, insert on foo to admin",
1:                sqlAuthorizationRequired, null , null );
1:         /*
1:          * GRANT COLUMN PERMISSION to role
1:          * Should get auto-dropped when role is dropped
1:          */
1:         doStmt("grant select (str), update (str) on foo to admin",
1:                sqlAuthorizationRequired, null , null );
1:         /*
1:          * GRANT ROUTINE PERMISSION to role
1:          * Should get auto-dropped when role is dropped
1:          */
1:         doStmt("create function f1() returns int" +
0:                "  language java parameter style java" +
0:                "  external name 'org.apache.derbyTesting." +
0:                "functionTests.tests.lang.RolesTest.t1'" +
1:                "  no sql called on null input",
1:                null, null, null);
1:         doStmt("grant execute on function f1 to admin",
1:                sqlAuthorizationRequired, null , null );
1: 
1:         assertSysTablePermsRowCount(0,
1:                                     // role admin not dropped yet:
0:                                     1,
1:                                     // role admin has been dropped, so
1:                                     // this run's grant to admin is de
1:                                     // facto to a user named admin:
1:                                     1);
1: 
1:         assertSysColPermsRowCount(0, 2, 2);
1: 
0:         assertSysRoutinePermsRowCount(5, // 5 pre-existing grants to PUBLIC
0:                                       6,
0:                                       6);
1: 
1:         /*
1:          * DROP ROLE
1:          */
1: 
1:         // Dbo run: don't drop foo and bar, so they survive to next run,
1:         // a non-dbo can set them, otherwise drop all roles and
1:         // premissions.
1:         doStmt("drop role role",
1:                sqlAuthorizationRequired, null , roleDboOnly);
1: 
1:         doStmt("drop role admin",
1:                sqlAuthorizationRequired, null , roleDboOnly);
0:         assertSysTablePermsRowCount(0, 0,
1:                                     // nonDbo run: role admin has
1:                                     // been dropped, so this run's
1:                                     // grant to admin is de facto to a
0:                                     // user named admin:
1:                                     1);
1:         assertSysColPermsRowCount(0, 0,
1:                                   // nonDbo run: role admin has
1:                                   // been dropped, so this run's grant
1:                                   // to admin is de facto to a user
1:                                   // named admin:
1:                                   2);
0:         assertSysRoutinePermsRowCount(5, 5,
1:                                       //  nonDbo run: role admin
1:                                       // has been dropped, so this
1:                                       // run's grant to admin is de
1:                                       // facto to a user named admin:
0:                                       6);
1: 
1:         doStmt("drop role \"NONE\"",
1:                sqlAuthorizationRequired, null , roleDboOnly);
1: 
1: 
1:         /*
1:          * REVOKE permissions for nonDbo run
1:          */
1:         doStmt("revoke select, insert on foo from admin",
1:                sqlAuthorizationRequired, null , null );
1:         doStmt("revoke select (str), update (str) on foo from admin",
1:                sqlAuthorizationRequired, null , null );
1:         doStmt("revoke execute on function f1 from admin restrict",
1:                sqlAuthorizationRequired, null , null );
1: 
0:         // assert blank slate
0:         assertSysTablePermsRowCount(0,0,0);
1:         assertSysColPermsRowCount(0,0,0);
0:         assertSysRoutinePermsRowCount(5,5,5);
1: 
1:         // roles foo and bar survive to nonDbo run and beyond:
0:         assertSysRolesRowCount(0, 4, 4);
1: 
1:         _stm.close();
1:     }
1: 
1: 
1:     protected void setUp() throws Exception
1:     {
1:         super.setUp();
1: 
1:         _stm = createStatement();
1: 
1:         if (_authLevel == SQLAUTHORIZATION && isDbo()) {
1: 
1:             // We need to clean away roles when we run the dbo run the
1:             // second time around (client/server). The reason is that
1:             // the dbo run has a side-effect: it leaves roles for the
1:             // non-dbo run to play with, and that run can't remove the
1:             // roles (since non-dbo can't drop roles).
1:             try {
1:                 _stm.executeUpdate("drop role foo");
1:                 _stm.executeUpdate("drop role bar");
1:             } catch (SQLException se) {
1:             }
1:         }
1: 
1:         try {
1:             _stm.executeUpdate("drop function f1");
1:             _stm.executeUpdate("drop table foo");
1:         } catch (SQLException se) {
1:         }
1: 
1:         _stm.close();
1:     }
1: 
1: 
1:     protected void tearDown() throws Exception
1:     {
1:         if (_stm != null) {
1:             _stm.close();
1:             _stm = null;
1:         }
1: 
1:         if (_conn != null) {
1:             _conn = null;
1:         }
1: 
1:         super.tearDown();
1:     }
1: 
1: 
1:     private void doStmt(String stmt,
1:                              String noAuthState,
1:                              String authDboState,
1:                              String authNotDboState)
1:     {
1:         doStmt(stmt, noAuthState, authDboState, authNotDboState, false);
1:     }
1: 
1: 
1:     private ResultSet doQuery(String stmt,
1:                               String noAuthState,
1:                               String authDboState,
1:                               String authNotDboState)
1:     {
1:         return doStmt(stmt, noAuthState, authDboState, authNotDboState, true);
1:     }
1: 
1: 
1:     private ResultSet doStmt(String stmt,
1:                              String noAuthState,
1:                              String authDboState,
1:                              String authNotDboState,
1:                              boolean query)
1:     {
1:         return doStmtWithWarnings(stmt,
1:                                   new String[]{noAuthState,null},
1:                                   new String[]{authDboState, null},
1:                                   new String[]{authNotDboState, null},
1:                                   query);
1:     // State arrays: element 0: expected error, element 1: expected warning
1:     private ResultSet doStmtWithWarnings(String stmt,
1:                                          String[] noAuthState,
1:                                          String[] authDboState,
1:                                          String[] authNotDboState,
1:                                          boolean query)
1:     {
1:         ResultSet result = null;
1: 
1:             if (query) {
1:                 result = _stm.executeQuery(stmt);
1:             } else {
1:                 _stm.execute(stmt);
1:             }
1: 
1:                 if (noAuthState[0] != null) {
1:                     fail("exception " + noAuthState[0] + " expected: (" + stmt);
1:                 if (noAuthState[1] != null) {
1:                     SQLWarning w = _stm.getWarnings();
1:                     assertNotNull("Expected warning but found none", w);
1:                     assertSQLState(noAuthState[1], w);
1:                 }
1: 
1:                     if (authDboState[0] != null) {
0:                         fail("exception " + noAuthState[0] + " expected: (" +
1:                     if (authDboState[1] != null) {
1:                         SQLWarning w = _stm.getWarnings();
1:                         assertNotNull("Expected warning but found none", w);
1:                         assertSQLState(authDboState[1], w);
1:                     }
1:                     if (authNotDboState[0] != null) {
0:                         fail("exception " + noAuthState[0] + " expected: (" +
1:                     if (authNotDboState[1] != null) {
1:                         SQLWarning w = _stm.getWarnings();
1:                         assertNotNull("Expected warning but found none", w);
1:                         assertSQLState(authNotDboState[1], w);
1:                     }
1:                 if (noAuthState[0] == null) {
1:                     assertSQLState("Stmt " + stmt, noAuthState[0], e);
1:                     if (authDboState[0] == null) {
1:                         assertSQLState("Stmt " + stmt, authDboState[0], e);
1:                     if (authNotDboState[0] == null) {
1:                         assertSQLState("Stmt " + stmt, authNotDboState[0], e);
1: 
1:         return result;
1:     private void doDynamicSetRole(Connection conn)
1:     {
/////////////////////////////////////////////////////////////////////////
0:                  fail("prepare of set role ? failed:" + e);
1:             pstmt.setString(1, "BAR");
0:             fail("execute of set role ? failed: [foo]" + e);
1:             pstmt.setString(1, null);
0:             fail("execute of set role ? failed: [NONE] " + e);
1:         }
1: 
1:         if (isDbo()) {
1:             // not granted to non-dbo, so don't try..
1:             String n_a     = null; // auth level not used for this test
1: 
0:             try {
1:                 pstmt.setString(1, "NONE");
1:                 int rowcnt = pstmt.executeUpdate();
0:                 assertEquals(rowcnt, 0, "rowcount from set role ? not 0");
1:                 ResultSet rs = doQuery("values current_role", n_a, null , n_a );
0:                 assertCurrentRole(rs, "NONE", n_a);
1:                 rs.close();
1:             } catch (SQLException e) {
0:                 fail("execute of set role ? failed: [NONE] " + e);
1:             }
1:         }
1: 
1:         if (pstmt != null) {
0:             try {
1:                 pstmt.close();
1:             } catch (SQLException e) {
1:             }
1:     private void assertSystableRowCount(String table,
1:                                         int rcNoAuth,
1:                                         int rcDbo,
1:                                         int rcMereMortal)
1:         throws SQLException
1:     {
1:         ResultSet rs = _stm.executeQuery(
1:                 "SELECT COUNT(*) FROM " + table);
1:         rs.next();
0:         assertEquals(table + " row count:",
1:                      _authLevel == NO_SQLAUTHORIZATION ? rcNoAuth :
1:                      (isDbo() ? rcDbo : rcMereMortal),
1:                      rs.getInt(1));
1:         rs.close();
1:     }
1: 
1: 
1:     private void assertSysRolesRowCount(int rcNoAuth,
1:                                         int rcDbo,
1:                                         int rcMereMortal)
1:         throws SQLException
1:     {
1: 
1:         if (TestConfiguration.getCurrent().isVerbose()) {
1:             dumpSysRoles();
1:         }
1: 
1:         assertSystableRowCount("SYS.SYSROLES",
1:                                rcNoAuth, rcDbo, rcMereMortal);
1:     }
1: 
1: 
1:     private void assertSysTablePermsRowCount(int rcNoAuth,
1:                                              int rcDbo,
1:                                              int rcMereMortal)
1:         throws SQLException
1:     {
1: 
1:         if (TestConfiguration.getCurrent().isVerbose()) {
1:             dumpSysTablePerms();
1:         }
1: 
1:         assertSystableRowCount("SYS.SYSTABLEPERMS",
1:                                rcNoAuth, rcDbo, rcMereMortal);
1:     }
1: 
1: 
1:     private void assertSysColPermsRowCount(int rcNoAuth,
1:                                            int rcDbo,
1:                                            int rcMereMortal)
1:         throws SQLException
1:     {
1: 
1:         if (TestConfiguration.getCurrent().isVerbose()) {
1:             dumpSysColPerms();
1:         }
1: 
1:         assertSystableRowCount("SYS.SYSCOLPERMS",
1:                                rcNoAuth, rcDbo, rcMereMortal);
1:     }
1: 
1: 
1:     private void assertSysRoutinePermsRowCount(int rcNoAuth,
1:                                                int rcDbo,
1:                                                int rcMereMortal)
1:         throws SQLException
1:     {
1: 
1:         if (TestConfiguration.getCurrent().isVerbose()) {
1:             dumpSysRoutinePerms();
1:         }
1: 
1:         assertSystableRowCount("SYS.SYSROUTINEPERMS",
1:                                rcNoAuth, rcDbo, rcMereMortal);
1:     }
1: 
1: 
1:     private void dumpSysRoles() throws SQLException
1:     {
1: 
1:         ResultSet rs = _stm.executeQuery
1:             ("SELECT * FROM SYS.SYSROLES ORDER BY ROLEID");
1: 
1:         println("SYS.SYSROLES:");
1: 
1:         while (rs.next()) {
0:             println("r=" + rs.getString(1) + " -ee:" + rs.getString(2) +
0:                     " -or:" + rs.getString(3) + " a:" + rs.getString(4) +
0:                     " d:" + rs.getString(5));
1:         }
1: 
1:         rs.close();
1:     }
1: 
1: 
1:     private void dumpSysTablePerms() throws SQLException
1:     {
1:         ResultSet rs = _stm.executeQuery
1:             ("SELECT * FROM SYS.SYSTABLEPERMS");
1: 
1:         println("SYS.SYSTABLEPERMS:");
1: 
1:         while (rs.next()) {
1:             println("id: " + rs.getString(1) +
1:                     " -ee:" + rs.getString(2) +
1:                     " -or:" + rs.getString(3) +
1:                     " tableid:" + rs.getString(4) +
1:                     " S:" + rs.getString(5) +
1:                     " D:" + rs.getString(6) +
1:                     " I:" + rs.getString(7) +
1:                     " U:" + rs.getString(8) +
1:                     " R:" + rs.getString(9) +
1:                     " T:" + rs.getString(10));
1:         }
1: 
1:         rs.close();
1:     }
1: 
1: 
1:     private void dumpSysColPerms() throws SQLException
1:     {
1: 
1:         ResultSet rs = _stm.executeQuery
1:             ("SELECT * FROM SYS.SYSCOLPERMS");
1: 
1:         println("SYS.SYSCOLPERMS:");
1: 
1:         while (rs.next()) {
1:             println("id: " + rs.getString(1) +
1:                     " -ee:" + rs.getString(2) +
1:                     " -or:" + rs.getString(3) +
1:                     " tableid:" + rs.getString(4) +
1:                     " type:" + rs.getString(5) +
1:                     " col#:" + rs.getString(6));
1:         }
1: 
1:         rs.close();
1:     }
1: 
1: 
1:     private void dumpSysRoutinePerms() throws SQLException
1:     {
1: 
1:         ResultSet rs = _stm.executeQuery
1:             ("SELECT * FROM SYS.SYSROUTINEPERMS");
1: 
1:         println("SYS.SYSROUTINEPERMS:");
1: 
1:         while (rs.next()) {
1:             println("id: " + rs.getString(1) +
1:                     " -ee:" + rs.getString(2) +
1:                     " -or:" + rs.getString(3) +
1:                     " alias:" + rs.getString(4) +
1:                     " grantopt:" + rs.getString(5));
1:         }
1: 
1:         rs.close();
1:     }
1: 
1: 
0:     private void assertCurrentRole(ResultSet rs,
0:                                    String dboRole,
0:                                    String notDboRole)
1:         throws SQLException
1:     {
1: 
1:         if (_authLevel == NO_SQLAUTHORIZATION) {
1:             assertNull(rs);
1:         } else {
0:             assertTrue("result set empty", rs.next());
1: 
1:             if (isDbo()) {
0:                 assertTrue(dboRole.equals(rs.getString(1)));
1:             } else {
0:                 assertTrue(notDboRole.equals(rs.getString(1)));
1:             }
1: 
0:             // cardinality should be 1
0:             assertFalse("result set not empty", rs.next());
1:             rs.close();
1:         }
1:     }
1: 
0:     private void assertEquals(int a, int b, String txt)
1:     {
1: 
1:     /**
1:      * Utility function used to test auto-drop of grant routine
1:      * permission to a role
1:      * @return 1
1:      */
1:     public static int f1()
1:     {
0:         return 1;
1:     }
commit:32b1a74
/////////////////////////////////////////////////////////////////////////
1:         doStmt("set role 'FOO'",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
commit:305269a
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.RolesTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import java.sql.SQLException;
1: import java.sql.Connection;
0: import java.sql.Statement;
1: import java.sql.PreparedStatement;
0: import javax.sql.DataSource;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
0: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * This JUnit tests the SQL roles feature. This feature relies on
1:  * sqlAuthorization being set. Upgrade tests are not handled here.
1:  *
1:  * The tests are run in the cross product:
1:  *
1:  *    {client/server, embedded} x
1:  *    {no sqlAuthorization/sqlAuthorization} x
1:  *    {data base owner, other user }
1:  *
1:  */
1: public class RolesTest extends BaseJDBCTestCase
1: {
1:     /* internal state */
1:     private final int _authLevel;
1:     private final String _user;
1:     private final String _userPassword;
1:     private Connection _conn;
1:     private Statement _stm;
1: 
1:     /* test execution security context: one of two below */
1:     private final static int NO_SQLAUTHORIZATION=0;
1:     private final static int SQLAUTHORIZATION=1;
1: 
1:     private final static String pwSuffix = "pwSuffix";
1: 
1:     /* SQL states */
1:     private final static String sqlAuthorizationRequired = "42Z60";
0:     private final static String syntaxError = "42X01";
0:     // temporary until feature fully implemented:
0:     private final static String notImplemented = "0A000";
1: 
1:     /**
1:      * Users used by all suites when when authLevel == SQLAUTHORIZATION.
1:      * The TestConfiguration.sqlAuthorizationDecorator decorator presumes
1:      * TEST_DBO as dbo, so add it to set of valid users. It uses a fresh db
1:      * 'dbsqlauth', not 'wombat'.
1:      */
0:     private final static String[] users = {"TEST_DBO", "DonaldDuck"};
1: 
0:     private boolean isDbo() {
1:         return users[0].equals(this._user);
1:     }
1: 
1:     /**
1:      * Create a new instance of RolesTest.
1:      *
1:      * @param name Fixture name
1:      * @param authLevel authentication level with which test is run
1:      * @param user Database user
1:      * @param userPassword Database user's password
1:      */
1: 
1:     public RolesTest(String name, int authLevel,
1:                      String user, String userPassword)
1:     {
1:         super(name);
1:         this._authLevel = authLevel;
1:         this._user = user;
1:         this._userPassword = userPassword;
1:     }
1: 
1: 
1:     /**
1:      * Construct top level suite in this JUnit test
1:      *
1:      * @return A suite containing embedded and client suites.
0:      *         Client/server suite commented out to speed up this test as
0:      *         it does not add much value given the nature of the changes
0:      *         (SQL language only).
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite("RolesTest");
1: 
1:         /* Negative syntax tests */
1:         suite.addTest(negativeSyntaxSuite("suite: negative syntax, embedded"));
1: 
0:         // suite.addTest(
0:         //     TestConfiguration.clientServerDecorator(
0:         //         negativeSyntaxSuite("suite: negative syntax, client")));
1: 
0:         /* Positive tests */
1:         suite.addTest(
0:             positiveSuite("suite: positive, embedded"));
1: 
0:         // suite.addTest(
0:         //     TestConfiguration.clientServerDecorator(
0:         //         positiveSuite("suite: positive, client")));
1: 
1:         return suite;
1:     }
1: 
1:     /**
1:      *
1:      * Construct suite of tests for negative syntax
1:      *
1:      * @param framework Derby framework indication
1:      * @return A suite containing the test cases for negative syntax
1:      * incarnated for the two security levels no sqlAuthorization, and
1:      * sqlAuthorization, The latter has an instance for dbo, and one
1:      * for an ordinary user, so there are in all three incarnations of
1:      * tests.
1:      */
1:     private static Test negativeSyntaxSuite(String framework)
1:     {
0:         Test tests[] = new Test[SQLAUTHORIZATION+1]; // one per authLevel
1: 
1:         /* Tests running without sql authorization set.
1:          */
0:         TestSuite noauthSuite = new TestSuite(
1:             "suite: security level=noSqlAuthorization");
1:         noauthSuite.addTest(new RolesTest("testNegativeSyntax",
1:                                           NO_SQLAUTHORIZATION,
1:                                           null,
1:                                           null));
0:         tests[NO_SQLAUTHORIZATION] = noauthSuite;
1: 
1:         /* Tests running with sql authorization set.
1:          * First decorate with users, then with authentication +
1:          * sqlAuthorization.
1:          */
0:         tests[SQLAUTHORIZATION] = wrapTest("testNegativeSyntax");
1: 
1: 
0:         TestSuite suite = new TestSuite("roles:"+framework);
0:         suite.addTest(tests[NO_SQLAUTHORIZATION]);
0:         suite.addTest(tests[SQLAUTHORIZATION]);
1: 
1:         return suite;
1:     }
1: 
1: 
1: 
1:     /**
0:      * Wraps the negative syntax fixture in decorators to run with
0:      * data base owner and one other valid user in sqlAuthorization
0:      * mode.
1:      */
1: 
1:     /**
1:      * Test negative syntax for roles.
1:      *
1:      * @throws SQLException
1:      */
1:     public void testNegativeSyntax() throws SQLException
1:     {
1:         println("testNegativeSyntax: auth=" + this._authLevel +
1:                 " user="+getTestConfiguration().getUserName());
1: 
1:         _conn = getConnection();
1:         _stm  = _conn.createStatement();
1: 
1:         doStmt("create role none", // none is reserved word
1:                syntaxError, syntaxError, syntaxError);
1:         doStmt("create role current_role", // current_role is reserved word
1:                syntaxError, syntaxError, syntaxError);
1:     }
1: 
1:     /**
1:      *
0:      * Construct suite of positive tests
1:      *
1:      * @param framework Derby framework indication
1:      *
0:      * @return A suite containing the positive test cases incarnated only
1:      * for security level sqlAuthorization.
1:      *
1:      * It has one instance for dbo, and one for an ordinary user, so there
1:      * are in all three incarnations of tests.
1:      */
0:     private static Test positiveSuite(String framework)
1:     {
0:         Test tests[] = new Test[SQLAUTHORIZATION+1]; // one per authLevel
1:         /* Tests running without sql authorization set.
1:          */
0:         TestSuite noauthSuite = new TestSuite(
1:             "suite: security level=noSqlAuthorization");
0:         noauthSuite.addTest(new RolesTest("testPositive",
1:                                           NO_SQLAUTHORIZATION,
1:                                           null,
1:                                           null));
0:         tests[NO_SQLAUTHORIZATION] = noauthSuite;
1:         /* Tests running with sql authorization set.
1:          * First decorate with users, then with authentication +
1:          * sqlAuthorization.
1:          */
0:         TestSuite suite = new TestSuite("roles:"+framework);
0:         tests[SQLAUTHORIZATION] = wrapTest("testPositive");
1: 
0:         suite.addTest(tests[NO_SQLAUTHORIZATION]);
0:         suite.addTest(tests[SQLAUTHORIZATION]);
1: 
1:         return suite;
1:     }
1: 
1:     /**
0:      * Wraps in decorators to run with data base owner and one other
1:      * valid user in sqlAuthorization mode.
1:      *
1:      * @param testName test to wrap
1:      */
0:     private static Test wrapTest(String testName)
1:     {
1:         // add decorator for different users authenticated
0:         TestSuite usersSuite =
0:             new TestSuite("suite: security level=sqlAuthorization");
1: 
0:         // First decorate with users, then with authorization
0:         // decorator
0:         for (int userNo = 0; userNo < users.length; userNo++) {
1:             usersSuite.addTest
1:                 (TestConfiguration.changeUserDecorator
1:                  (new RolesTest(testName,
1:                                 SQLAUTHORIZATION,
1:                                 users[userNo],
1:                                 users[userNo].concat(pwSuffix)),
1:                   users[userNo],
1:                   users[userNo].concat(pwSuffix)));
1:         }
1: 
1:         return TestConfiguration.sqlAuthorizationDecorator(
1:             DatabasePropertyTestSetup.builtinAuthentication(
1:                 usersSuite, users, pwSuffix));
1:     }
1: 
1:     /**
0:      * Positive tests for roles (well, positive for dbo at least!)
1:      *
1:      * @throws SQLException
1:      */
0:     public void testPositive() throws SQLException
1:     {
0:         println("testPositive: auth=" + this._authLevel +
1:                 " user="+getTestConfiguration().getUserName());
1: 
1:         _conn = getConnection();
1:         _stm  = _conn.createStatement();
1: 
0:         // create
1:         doStmt("create role foo",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
1:         doStmt("create role bar",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
1:         doStmt("create role role", // role is not reserved word
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
0:         doStmt("create role trigger",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
1:         doStmt("create role \"NONE\"", // quoted role id should work
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
1: 
0:         // grant
1:         doStmt("grant foo to authid", // authid: user or role
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
0:         doStmt("grant foo, role, bar to authid1, authid2, authid3",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
1: 
0:         // grant: parser look-ahead tests to discern grant role from
0:         // grant privilege
0:         doStmt("grant trigger to authid",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
0:         doStmt("grant trigger, foo to authid",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
0:         doStmt("grant trigger, foo to public",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
1: 
1: 
0:         // set
1:         doStmt("set role foo",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
1:         doStmt("set role none",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
1:         doDynamicSetRole(_conn);
1: 
0:         // revoke
1: 
1:         doStmt("revoke foo from authid", // authid: user or role
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
0:         doStmt("revoke foo, role, bar from authid1, authid2, authid3",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
1: 
0:         // revoke: parser look-ahead tests to discern revoke role from
0:         // revoke privilege
0:         doStmt("revoke trigger from authid",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
0:         doStmt("revoke trigger, foo from authid",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
0:         doStmt("revoke trigger, foo from public",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
1: 
0:         // drop
0:         doStmt("drop role foo",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
0:         doStmt("drop role role",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
0:         doStmt("drop role trigger",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
0:         doStmt("drop role \"NONE\"",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
1: 
0:         // current_role
0:         doStmt("values current_role",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
1: 
0:         // column default current_role
1:         doStmt("create table foo(str varchar(128) default current_role)",
0:                sqlAuthorizationRequired, notImplemented, notImplemented);
1:     }
1: 
1:     // Minion to analyze outcome. If state string is empty, we expect success
1:     // for that combination of authentication level and user (dbo or not).
0:     private void doStmt(String stmt,
0:                         String noAuthState,
0:                         String authDboState,
0:                         String authNotDboState) {
0:         try {
0:             _stm.execute(stmt);
1:             if (_authLevel == NO_SQLAUTHORIZATION) {
0:                 if (noAuthState != null) {
0:                     fail("exception " + noAuthState + " expected: (" + stmt);
1:                 }
1:             } else { // SQLAUTHORIZATION
1:                 if (isDbo()) {
0:                     if (authDboState != null) {
0:                         fail("exception " + noAuthState + " expected: (" +
1:                              stmt);
1:                     }
1:                 } else {
0:                     if (authNotDboState != null) {
0:                         fail("exception " + noAuthState + " expected: (" +
1:                              stmt);
1:                     }
1:                 }
1:             }
1:         } catch (SQLException e) {
1:             if (_authLevel == NO_SQLAUTHORIZATION) {
0:                 if (noAuthState == null) {
1:                     fail("stmt " + stmt + " failed with exception " +
0:                          e.getSQLState());
1:                 } else {
0:                     assertSQLState("Stmt " + stmt, noAuthState, e);
1:                 }
1: 
1:             } else { // SQLAUTHORIZATION
1:                 if (isDbo()) {
0:                     if (authDboState == null) {
1:                         fail("stmt " + stmt + " failed with exception " +
0:                              e.getSQLState());
1:                     } else {
0:                         assertSQLState("Stmt " + stmt, authDboState, e);
1:                     }
1:                 } else {
0:                     if (authNotDboState == null) {
1:                         fail("stmt " + stmt + " failed with exception " +
0:                              e.getSQLState());
1:                     } else {
0:                         assertSQLState("Stmt " + stmt, authNotDboState, e);
1:                     }
1:                 }
1:             }
1:         }
1:     }
1: 
1: 
0:     private void doDynamicSetRole(Connection conn) {
1:         PreparedStatement pstmt = null;
1: 
0:         try {
1:             pstmt = conn.prepareStatement("set role ?");
1: 
1:             if (_authLevel == NO_SQLAUTHORIZATION) {
1:                 fail("set role ? should have failed; no sqlAuthorization");
1:             }
1:         } catch (SQLException e) {
1:              if (_authLevel == NO_SQLAUTHORIZATION) {
1:                  assertSQLState(sqlAuthorizationRequired, e);
1:                  return;
1:              } else {
0:                  // fail("prepare of set role ? failed:" + e);
0:                  assertSQLState(notImplemented, e);
1:                  return;
1:              }
1:         }
1: 
0:         try {
0:             pstmt.setString(1, "foo");
1:             int rowcnt = pstmt.executeUpdate();
0:             assertEquals(rowcnt, 0, "rowcount from set role ? not 0");
1:         } catch (SQLException e) {
0:             assertSQLState(notImplemented, e);
1:         }
1: 
1: 
0:         try {
0:             pstmt.setString(1, "\"NONE\"");
1:             int rowcnt = pstmt.executeUpdate();
0:             assertEquals(rowcnt, 0, "rowcount from set role ? not 0");
1:         } catch (SQLException e) {
0:             assertSQLState(notImplemented, e);
1:         }
1:     }
1: 
1: 
0:     private void assertEquals(int a, int b, String txt) {
0:         if (a!=b) {
0:             fail(txt);
1:         }
1:     }
1: }
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:180aeb0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
0:         
0:         // JSR169 cannot run with tests with stored procedures that do
0:         // database access - for they require a DriverManager connection to
0:         // jdbc:default:connection; DriverManager is not supported with JSR169
0:         if (!JDBC.vmSupportsJSR169())
0:             doSetRoleInsideStoredProcedures("FOO");
============================================================================