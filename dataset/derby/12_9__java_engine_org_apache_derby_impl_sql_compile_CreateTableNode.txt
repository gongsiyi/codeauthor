1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.CreateTableNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:3bb140c: import java.util.Properties;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.Limits;
1:eac0369: import org.apache.derby.iapi.reference.Property;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:2a0827a: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: import org.apache.derby.iapi.services.property.PropertyUtil;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:3bb140c: import org.apache.derby.iapi.sql.conn.Authorizer;
1:1453acc: import org.apache.derby.iapi.sql.depend.ProviderList;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: import org.apache.derby.impl.sql.execute.ColumnInfo;
1:eac0369: import org.apache.derby.impl.sql.execute.CreateConstraintConstantAction;
1:eac0369: 
1:eac0369: /**
1:eac0369:  * A CreateTableNode is the root of a QueryTree that represents a CREATE TABLE or DECLARE GLOBAL TEMPORARY TABLE
1:eac0369:  * statement.
1:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:3bb140c: class CreateTableNode extends DDLStatementNode
1:eac0369: {
1:eac0369: 	private char				lockGranularity;
1:eac0369: 	private boolean				onCommitDeleteRows; //If true, on commit delete rows else on commit preserve rows of temporary table.
1:eac0369: 	private boolean				onRollbackDeleteRows; //If true, on rollback delete rows from temp table if it was logically modified in that UOW. true is the only supported value
1:eac0369: 	private Properties			properties;
1:eac0369: 	private TableElementList	tableElementList;
1:eac0369: 	protected int	tableType; //persistent table or global temporary table
1:1453acc: 	private ResultColumnList	resultColumns;
1:1453acc: 	private ResultSetNode		queryExpression;
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for a CreateTableNode for a base table
1:eac0369: 	 *
1:3bb140c:      * @param tableName The name of the new object being created (ie base table)
2:eac0369: 	 * @param tableElementList	The elements of the table: columns,
2:eac0369: 	 *				constraints, etc.
1:eac0369: 	 * @param properties		The optional list of properties associated with
1:eac0369: 	 *							the table.
1:eac0369: 	 * @param lockGranularity	The lock granularity.
1:3bb140c:      * @param cm                The context manager
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     CreateTableNode(
1:3bb140c:             TableName        tableName,
1:3bb140c:             TableElementList tableElementList,
1:3bb140c:             Properties       properties,
1:3bb140c:             char             lockGranularity,
1:3bb140c:             ContextManager   cm) throws StandardException
1:eac0369: 	{
1:3bb140c:         super(tableName, cm);
1:3bb140c:         this.tableType = TableDescriptor.BASE_TABLE_TYPE;
1:3bb140c:         this.lockGranularity = lockGranularity;
1:3bb140c:         this.implicitCreateSchema = true;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (this.lockGranularity != TableDescriptor.TABLE_LOCK_GRANULARITY &&
1:eac0369: 				this.lockGranularity != TableDescriptor.ROW_LOCK_GRANULARITY)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 				"Unexpected value for lockGranularity = " + this.lockGranularity);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:3bb140c:         this.tableElementList = tableElementList;
1:3bb140c:         this.properties = properties;
1:eac0369: 	}
1:eac0369: 
1:c9a1206: 	/**
1:3bb140c:      * Constructor for a CreateTableNode for a global temporary table
1:eac0369: 	 *
1:3bb140c:      * @param tableName The name of the new object being declared (ie
1:3bb140c:      *                  temporary table)
1:3bb140c:      * @param tableElementList  The elements of the table: columns,
1:3bb140c:      *                          constraints, etc.
1:eac0369: 	 * @param properties		The optional list of properties associated with
1:eac0369: 	 *							the table.
1:eac0369: 	 * @param onCommitDeleteRows	If true, on commit delete rows else on commit preserve rows of temporary table.
1:eac0369: 	 * @param onRollbackDeleteRows	If true, on rollback, delete rows from temp tables which were logically modified. true is the only supported value
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     CreateTableNode(
1:3bb140c:             TableName tableName,
1:3bb140c:             TableElementList tableElementList,
1:3bb140c:             Properties properties,
1:3bb140c:             boolean onCommitDeleteRows,
1:3bb140c:             boolean onRollbackDeleteRows,
1:3bb140c:             ContextManager cm)
2:eac0369: 		throws StandardException
1:eac0369: 	{
1:3bb140c:         super(tempTableSchemaNameCheck(tableName), cm);
1:3bb140c: 
1:3bb140c:         this.tableType = TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE;
1:3bb140c:         this.onCommitDeleteRows = onCommitDeleteRows;
1:3bb140c:         this.onRollbackDeleteRows = onRollbackDeleteRows;
1:3bb140c:         this.tableElementList = tableElementList;
1:3bb140c:         this.properties = properties;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (this.onRollbackDeleteRows == false)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 				"Unexpected value for onRollbackDeleteRows = " + this.onRollbackDeleteRows);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:3bb140c:      * Constructor for a CreateTableNode for a base table create from a query
1:1453acc: 	 * 
1:3bb140c:      * @param tableName         The name of the new object being created
1:1453acc: 	 * 	                        (ie base table).
1:1453acc: 	 * @param resultColumns		The optional column list.
1:1453acc: 	 * @param queryExpression	The query expression for the table.
1:3bb140c:      * @param cm                The context manager
1:eac0369: 	 */
1:3bb140c:     CreateTableNode(
1:3bb140c:             TableName tableName,
1:3bb140c:             ResultColumnList resultColumns,
1:3bb140c:             ResultSetNode queryExpression,
1:3bb140c:             ContextManager cm) throws StandardException
1:d5ef906: 	{
1:3bb140c:         super(tableName, cm);
1:3bb140c:         this.tableType = TableDescriptor.BASE_TABLE_TYPE;
1:3bb140c:         this.lockGranularity = TableDescriptor.DEFAULT_LOCK_GRANULARITY;
1:3bb140c:         this.implicitCreateSchema = true;
1:3bb140c:         this.resultColumns = resultColumns;
1:3bb140c:         this.queryExpression = queryExpression;
1:6e48cbe: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * If no schema name specified for global temporary table, SESSION is the implicit schema.
1:eac0369: 	 * Otherwise, make sure the specified schema name for global temporary table is SESSION.
1:3bb140c:      *
1:3bb140c:      * @param tableName The name of the new object being declared (ie
1:3bb140c:      *        temporary table)
1:3bb140c:      */
1:3bb140c:     private static TableName tempTableSchemaNameCheck(TableName tableName)
1:eac0369: 		throws StandardException {
1:3bb140c:         if (tableName != null)
1:eac0369: 		{
1:3bb140c:             if (tableName.getSchemaName() == null) {
1:3bb140c:                 // If no schema specified, SESSION is the implicit schema.
1:3bb140c:                 tableName.setSchemaName(SchemaDescriptor.
1:3bb140c:                     STD_DECLARED_GLOBAL_TEMPORARY_TABLES_SCHEMA_NAME);
1:3bb140c: 
1:3bb140c:             } else if (!(isSessionSchema(tableName.getSchemaName()))) {
1:3bb140c:                 throw StandardException.newException(SQLState.
1:3bb140c:                     LANG_DECLARED_GLOBAL_TEMP_TABLE_ONLY_IN_SESSION_SCHEMA);
1:3bb140c:             }
1:eac0369: 		}
1:3bb140c:         return tableName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:c9a1206: 			String tempString = "";
1:eac0369: 			if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
1:eac0369: 			{
1:eac0369: 				tempString = tempString + "onCommitDeleteRows: " + "\n" + onCommitDeleteRows + "\n";
1:eac0369: 				tempString = tempString + "onRollbackDeleteRows: " + "\n" + onRollbackDeleteRows + "\n";
1:eac0369: 			} else
1:c9a1206: 				tempString = tempString +
1:c9a1206: 					(properties != null ?
1:c9a1206: 					 "properties: " + "\n" + properties + "\n" :
1:c9a1206: 					 "") +
1:c9a1206: 					"lockGranularity: " + lockGranularity + "\n";
1:eac0369: 			return super.toString() +  tempString;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:c9a1206: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:c9a1206: 	 * how tree printing is supposed to work.
1:c9a1206: 	 * @param depth		The depth to indent the sub-nodes
1:c9a1206: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth) {
1:c9a1206: 		if (SanityManager.DEBUG) {
1:c9a1206: 			printLabel(depth, "tableElementList: ");
1:c9a1206: 			tableElementList.treePrint(depth + 1);
1:c9a1206: 		}
1:c9a1206: 	}
1:c9a1206: 
1:c9a1206: 
1:3bb140c:     String statementToString()
1:eac0369: 	{
1:eac0369: 		if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
1:eac0369: 			return "DECLARE GLOBAL TEMPORARY TABLE";
1:eac0369: 		else
1:eac0369: 			return "CREATE TABLE";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// We inherit the generate() method from DDLStatementNode.
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this CreateTableNode.  This means doing any static error checking that can be
1:eac0369: 	 * done before actually creating the base table or declaring the global temporary table.
1:eac0369: 	 * For eg, verifying that the TableElementList does not contain any duplicate column names.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:cc770d8: 	public void bindStatement() throws StandardException
1:eac0369: 	{
1:eac0369: 		DataDictionary	dataDictionary = getDataDictionary();
1:3bb140c:         int numPrimaryKeys;
1:3bb140c:         int numCheckConstraints;
1:3bb140c:         int numReferenceConstraints;
1:3bb140c:         int numUniqueConstraints;
1:3bb140c:         int numGenerationClauses;
1:eac0369: 
1:fce10ba:         SchemaDescriptor sd = getSchemaDescriptor
1:fce10ba:             ( tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE, true);
1:fce10ba: 
1:1453acc: 		if (queryExpression != null)
1:eac0369: 		{
1:3bb140c:             FromList fromList = new FromList(
1:3bb140c:                     getOptimizerFactory().doJoinOrderOptimization(),
2:eac0369: 					getContextManager());
1:eac0369: 			
1:1453acc: 			CompilerContext cc = getCompilerContext();
1:1453acc: 			ProviderList prevAPL = cc.getCurrentAuxiliaryProviderList();
1:1453acc: 			ProviderList apl = new ProviderList();
1:eac0369: 			
1:1453acc: 			try
1:1453acc: 			{
1:1453acc: 				cc.setCurrentAuxiliaryProviderList(apl);
1:1453acc: 				cc.pushCurrentPrivType(Authorizer.SELECT_PRIV);
1:eac0369: 				
1:1453acc: 				/* Bind the tables in the queryExpression */
1:1453acc: 				queryExpression =
1:1453acc: 					queryExpression.bindNonVTITables(dataDictionary, fromList);
1:1453acc: 				queryExpression = queryExpression.bindVTITables(fromList);
1:eac0369: 				
1:1453acc: 				/* Bind the expressions under the resultSet */
1:1453acc: 				queryExpression.bindExpressions(fromList);
1:eac0369: 				
1:1453acc: 				/* Bind the query expression */
1:1453acc: 				queryExpression.bindResultColumns(fromList);
1:eac0369: 				
1:1453acc: 				/* Reject any untyped nulls in the RCL */
1:1453acc: 				/* e.g. CREATE TABLE t1 (x) AS VALUES NULL WITH NO DATA */
1:1453acc: 				queryExpression.bindUntypedNullsToResultColumns(null);
1:6e48cbe: 			}
1:1453acc: 			finally
2:1453acc: 			{
1:1453acc: 				cc.popCurrentPrivType();
1:1453acc: 				cc.setCurrentAuxiliaryProviderList(prevAPL);
1:1453acc: 			}
1:eac0369: 			
1:1453acc: 			/* If there is an RCL for the table definition then copy the
1:1453acc: 			 * names to the queryExpression's RCL after verifying that
1:1453acc: 			 * they both have the same size.
1:eac0369: 			 */
1:1453acc: 			ResultColumnList qeRCL = queryExpression.getResultColumns();
1:eac0369: 			
1:1453acc: 			if (resultColumns != null)
1:1453acc: 			{
1:d5ef906: 				if (resultColumns.size() != qeRCL.visibleSize())
1:1453acc: 				{
1:1453acc: 					throw StandardException.newException(
1:1453acc: 							SQLState.LANG_TABLE_DEFINITION_R_C_L_MISMATCH,
1:1453acc: 							getFullName());
3:1453acc: 				}
1:1453acc: 				qeRCL.copyResultColumnNames(resultColumns);
1:1453acc: 			}
1:eac0369: 			
1:a9dbcce: 			int schemaCollationType = sd.getCollationType();
1:eac0369: 	    
1:1453acc: 			/* Create table element list from columns in query expression */
1:3bb140c:             tableElementList = new TableElementList(getContextManager());
1:eac0369: 			
1:e1f49ca:             for (ResultColumn rc : qeRCL)
1:1453acc: 			{
1:d5ef906: 				if (rc.isGenerated()) 
1:d25aee0: 				{
1:d25aee0: 					continue;
1:d5ef906: 				}
1:1453acc: 				/* Raise error if column name is system generated. */
1:1453acc: 				if (rc.isNameGenerated())
1:1453acc: 				{
1:1453acc: 					throw StandardException.newException(
1:1453acc: 							SQLState.LANG_TABLE_REQUIRES_COLUMN_NAMES);
1:1453acc: 				}
1:eac0369: 
1:ba1b7ec: 				DataTypeDescriptor dtd = rc.getExpression().getTypeServices();
1:d25aee0: 				if ((dtd != null) && !dtd.isUserCreatableType())
1:d25aee0: 				{
1:d25aee0: 					throw StandardException.newException(
1:d25aee0: 							SQLState.LANG_INVALID_COLUMN_TYPE_CREATE_TABLE,
1:d25aee0: 							dtd.getFullSQLTypeName(),
1:d25aee0: 							rc.getName());
1:d25aee0: 				}
1:a9dbcce: 				//DERBY-2879  CREATE TABLE AS <subquery> does not maintain the 
1:a9dbcce: 				//collation for character types. 
1:a9dbcce: 				//eg for a territory based collation database
1:a9dbcce: 				//create table t as select tablename from sys.systables with no data;
1:a9dbcce: 				//Derby at this point does not support for a table's character 
1:a9dbcce: 				//columns to have a collation different from it's schema's
1:a9dbcce: 				//collation. Which means that in a territory based database, 
1:a9dbcce: 				//the query above will cause table t's character columns to
1:a9dbcce: 				//have collation of UCS_BASIC but the containing schema of t
1:a9dbcce: 				//has collation of territory based. This is not supported and
1:a9dbcce: 				//hence we will throw an exception below for the query above in
1:a9dbcce: 				//a territory based database. 
1:197b3d3: 				if (dtd.getTypeId().isStringTypeId() && 
1:197b3d3: 						dtd.getCollationType() != schemaCollationType)
1:a9dbcce: 				{
1:a9dbcce: 					throw StandardException.newException(
1:a9dbcce: 							SQLState.LANG_CAN_NOT_CREATE_TABLE,
1:a9dbcce: 							dtd.getCollationName(),
1:5212101: 							DataTypeDescriptor.getCollationName(schemaCollationType));
1:a9dbcce: 				}
1:a9dbcce: 
1:3bb140c:                 ColumnDefinitionNode column = new ColumnDefinitionNode(
1:3bb140c:                         rc.getName(),
1:3bb140c:                         null,
1:3bb140c:                         rc.getType(),
1:3bb140c:                         null,
1:3bb140c:                         getContextManager() );
1:1453acc: 				tableElementList.addTableElement(column);
1:1453acc: 			}
1:2779125: 		} else {
1:2779125: 			//Set the collation type and collation derivation of all the 
1:2779125: 			//character type columns. Their collation type will be same as the 
1:2779125: 			//collation of the schema they belong to. Their collation 
1:2779125: 			//derivation will be "implicit". 
1:2779125: 			//Earlier we did this in makeConstantAction but that is little too 
1:2779125: 			//late (DERBY-2955)
1:2779125: 			//eg 
1:2779125: 			//CREATE TABLE STAFF9 (EMPNAME CHAR(20),
1:2779125: 			//  CONSTRAINT STAFF9_EMPNAME CHECK (EMPNAME NOT LIKE 'T%'))
1:2779125: 			//For the query above, when run in a territory based db, we need 
1:2779125: 			//to have the correct collation set in bind phase of create table 
1:2779125: 			//so that when LIKE is handled in LikeEscapeOperatorNode, we have 
1:2779125: 			//the correct collation set for EMPNAME otherwise it will throw an 
1:2779125: 			//exception for 'T%' having collation of territory based and 
1:2779125: 			//EMPNAME having the default collation of UCS_BASIC
1:2779125: 			tableElementList.setCollationTypesOnCharacterStringColumns(
1:58d069a: 				getSchemaDescriptor(
1:58d069a: 					tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE,
1:58d069a: 					true));
1:1453acc: 		}
1:6e48cbe: 
1:eac0369: 		tableElementList.validate(this, dataDictionary, (TableDescriptor) null);
1:eac0369: 
1:eac0369: 		/* Only 1012 columns allowed per table */
1:b1f84c1: 		if (tableElementList.countNumberOfColumns() > Limits.DB2_MAX_COLUMNS_IN_TABLE)
1:1453acc: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_COLUMNS_IN_TABLE_OR_VIEW,
1:eac0369: 				String.valueOf(tableElementList.countNumberOfColumns()),
1:eac0369: 				getRelativeName(),
1:b1f84c1: 				String.valueOf(Limits.DB2_MAX_COLUMNS_IN_TABLE));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		numPrimaryKeys = tableElementList.countConstraints(
1:eac0369: 								DataDictionary.PRIMARYKEY_CONSTRAINT);
1:eac0369: 
1:eac0369: 		/* Only 1 primary key allowed per table */
1:eac0369: 		if (numPrimaryKeys > 1)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_PRIMARY_KEY_CONSTRAINTS, getRelativeName());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Check the validity of all check constraints */
1:eac0369: 		numCheckConstraints = tableElementList.countConstraints(
1:eac0369: 									DataDictionary.CHECK_CONSTRAINT);
1:eac0369: 
1:eac0369: 		numReferenceConstraints = tableElementList.countConstraints(
1:eac0369: 									DataDictionary.FOREIGNKEY_CONSTRAINT);
1:eac0369: 
1:eac0369: 		numUniqueConstraints = tableElementList.countConstraints(
1:eac0369: 									DataDictionary.UNIQUE_CONSTRAINT);
1:eac0369: 
1:95a483d:         numGenerationClauses = tableElementList.countGenerationClauses();
1:95a483d: 
1:eac0369: 		//temp tables can't have primary key or check or foreign key or unique constraints defined on them
1:eac0369: 		if ((tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE) &&
1:eac0369: 			(numPrimaryKeys > 0 || numCheckConstraints > 0 || numReferenceConstraints > 0 || numUniqueConstraints > 0))
1:eac0369: 				throw StandardException.newException(SQLState.LANG_NOT_ALLOWED_FOR_DECLARED_GLOBAL_TEMP_TABLE);
1:eac0369: 
1:eac0369: 		//each of these constraints have a backing index in the back. We need to make sure that a table never has more
1:eac0369: 		//more than 32767 indexes on it and that is why this check.
1:b1f84c1: 		if ((numPrimaryKeys + numReferenceConstraints + numUniqueConstraints) > Limits.DB2_MAX_INDEXES_ON_TABLE)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_INDEXES_ON_TABLE, 
1:eac0369: 				String.valueOf(numPrimaryKeys + numReferenceConstraints + numUniqueConstraints),
1:eac0369: 				getRelativeName(),
1:b1f84c1: 				String.valueOf(Limits.DB2_MAX_INDEXES_ON_TABLE));
1:eac0369: 		}
1:eac0369: 
1:c0342de: 		if ( (numCheckConstraints > 0) || (numGenerationClauses > 0) || (numReferenceConstraints > 0) )
1:eac0369: 		{
1:95a483d: 			/* In order to check the validity of the check constraints and
1:95a483d: 			 * generation clauses
1:eac0369: 			 * we must goober up a FromList containing a single table,
1:eac0369: 			 * the table being created, with an RCL containing the
1:eac0369: 			 * new columns and their types.  This will allow us to
1:eac0369: 			 * bind the constraint definition trees against that
1:eac0369: 			 * FromList.  When doing this, we verify that there are
1:eac0369: 			 * no nodes which can return non-deterministic results.
1:eac0369: 			 */
1:95a483d: 			FromList fromList = makeFromList( null, tableElementList, true );
1:c0342de:             FormatableBitSet    generatedColumns = new FormatableBitSet();
1:eac0369: 
1:eac0369: 			/* Now that we've finally goobered stuff up, bind and validate
1:95a483d: 			 * the check constraints and generation clauses.
1:eac0369: 			 */
1:7168d7d: 			if  (numGenerationClauses > 0) { tableElementList.bindAndValidateGenerationClauses( sd, fromList, generatedColumns, null ); }
1:b8b524c: 			if  (numCheckConstraints > 0) { tableElementList.bindAndValidateCheckConstraints(fromList); }
1:c0342de:             if ( numReferenceConstraints > 0) { tableElementList.validateForeignKeysOnGenerationClauses( fromList, generatedColumns ); }
1:eac0369: 		}
1:b8b524c: 
1:b8b524c:         if ( numPrimaryKeys > 0 ) { tableElementList.validatePrimaryKeyNullability(); }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1:eac0369: 	 *
1:eac0369: 	 * @return	true if references SESSION schema tables, else false
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public boolean referencesSessionSchema()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		//If table being created/declared is in SESSION schema, then return true.
1:58d069a: 		return isSessionSchema(
1:58d069a: 			getSchemaDescriptor(
1:58d069a: 				tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE,
1:58d069a: 				true));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Create the Constant information that will drive the guts of Execution.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     public ConstantAction makeConstantAction() throws StandardException
1:eac0369: 	{
1:eac0369: 		TableElementList		coldefs = tableElementList;
1:eac0369: 
1:eac0369: 		// for each column, stuff system.column
1:eac0369: 		ColumnInfo[] colInfos = new ColumnInfo[coldefs.countNumberOfColumns()];
1:eac0369: 
1:eac0369: 	    int numConstraints = coldefs.genColumnInfos(colInfos);
1:eac0369: 
1:eac0369: 		/* If we've seen a constraint, then build a constraint list */
1:eac0369: 		CreateConstraintConstantAction[] conActions = null;
1:eac0369: 
1:58d069a: 		SchemaDescriptor sd = getSchemaDescriptor(
1:58d069a: 			tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE,
1:58d069a: 			true);
1:58d069a: 
1:58d069a: 		
1:eac0369: 		if (numConstraints > 0)
1:eac0369: 		{
1:eac0369: 			conActions =
1:eac0369:                 new CreateConstraintConstantAction[numConstraints];
1:eac0369: 
1:68db840: 			coldefs.genConstraintActions(true,
1:eac0369:                 conActions, getRelativeName(), sd, getDataDictionary());
1:eac0369: 		}
1:eac0369: 
1:eac0369:         // if the any of columns are "long" and user has not specified a
1:eac0369:         // page size, set the pagesize to 32k.
1:eac0369:         // Also in case where the approximate sum of the column sizes is
1:eac0369:         // greater than the bump threshold , bump the pagesize to 32k
1:eac0369: 
1:eac0369:         boolean table_has_long_column = false;
1:eac0369:         int approxLength = 0;
1:eac0369: 
1:eac0369:         for (int i = 0; i < colInfos.length; i++)
1:eac0369:         {
1:42544c4:             DataTypeDescriptor dts = colInfos[i].getDataType();
1:eac0369:             if (dts.getTypeId().isLongConcatableTypeId())
1:eac0369:             {
1:eac0369:                 table_has_long_column = true;
1:eac0369:                 break;
1:eac0369:             }
1:eac0369: 
1:eac0369:             approxLength += dts.getTypeId().getApproximateLengthInBytes(dts);
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (table_has_long_column || (approxLength > Property.TBL_PAGE_SIZE_BUMP_THRESHOLD))
1:eac0369:         {
1:eac0369: 			if (((properties == null) ||
1:eac0369:                  (properties.get(Property.PAGE_SIZE_PARAMETER) == null)) &&
1:eac0369:                 (PropertyUtil.getServiceProperty(
1:eac0369:                      getLanguageConnectionContext().getTransactionCompile(),
1:eac0369:                      Property.PAGE_SIZE_PARAMETER) == null))
1:eac0369:             {
1:eac0369:                 // do not override the user's choice of page size, whether it
1:eac0369:                 // is set for the whole database or just set on this statement.
1:eac0369: 
1:eac0369:                 if (properties == null)
1:eac0369:                     properties = new Properties();
1:eac0369: 
1:eac0369:                 properties.put(
1:eac0369:                     Property.PAGE_SIZE_PARAMETER,
1:eac0369:                     Property.PAGE_SIZE_DEFAULT_LONG);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 		return(
1:eac0369:             getGenericConstantActionFactory().getCreateTableConstantAction(
1:eac0369:                 sd.getSchemaName(),
1:eac0369:                 getRelativeName(),
1:eac0369:                 tableType,
1:eac0369:                 colInfos,
1:eac0369:                 conActions,
1:eac0369:                 properties,
1:eac0369:                 lockGranularity,
1:eac0369:                 onCommitDeleteRows,
1:eac0369:                 onRollbackDeleteRows));
1:eac0369: 	}
1:e126f58: 
1:e126f58: 	/**
1:e126f58: 	 * Accept the visitor for all visitable children of this node.
1:e126f58: 	 * 
1:e126f58: 	 * @param v the visitor
1:e126f58: 	 *
1:e126f58: 	 * @exception StandardException on error
1:e126f58: 	 */
1:3bb140c:     @Override
1:e126f58: 	void acceptChildren(Visitor v)
1:e126f58: 		throws StandardException
1:e126f58: 	{
1:e126f58: 		super.acceptChildren(v);
1:e126f58: 
1:e126f58: 		if (tableElementList != null)
1:e126f58: 		{
1:e126f58: 			tableElementList.accept(v);
1:e126f58: 		}
1:e126f58: 	}
1:e126f58:     
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:a9d7173
/////////////////////////////////////////////////////////////////////////
0: 			// DERBY-3043: To avoid a no-such-schema error when
0: 			// binding the check constraint, ensure that the
0: 			// table we bind against has a schema name specified.
0: 			// If it doesn't, fill in the schema name now.
0: 			//
0: 			TableName newTN = getObjectName();
0: 			if (newTN.getSchemaName() == null)
0: 				newTN.setSchemaName(getSchemaDescriptor().getSchemaName());
0: 										newTN,
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:             for (ResultColumn rc : qeRCL)
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.Limits;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.sql.conn.Authorizer;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
/////////////////////////////////////////////////////////////////////////
1: class CreateTableNode extends DDLStatementNode
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a CreateTableNode for a base table
1:      * @param tableName The name of the new object being created (ie base table)
1:      * @param cm                The context manager
1:     CreateTableNode(
1:             TableName        tableName,
1:             TableElementList tableElementList,
1:             Properties       properties,
1:             char             lockGranularity,
1:             ContextManager   cm) throws StandardException
1:         super(tableName, cm);
0:         setNodeType(C_NodeTypes.CREATE_TABLE_NODE);
1:         this.tableType = TableDescriptor.BASE_TABLE_TYPE;
1:         this.lockGranularity = lockGranularity;
1:         this.implicitCreateSchema = true;
/////////////////////////////////////////////////////////////////////////
1:         this.tableElementList = tableElementList;
1:         this.properties = properties;
1:      * Constructor for a CreateTableNode for a global temporary table
1:      * @param tableName The name of the new object being declared (ie
1:      *                  temporary table)
1:      * @param tableElementList  The elements of the table: columns,
1:      *                          constraints, etc.
/////////////////////////////////////////////////////////////////////////
1:     CreateTableNode(
1:             TableName tableName,
1:             TableElementList tableElementList,
1:             Properties properties,
1:             boolean onCommitDeleteRows,
1:             boolean onRollbackDeleteRows,
1:             ContextManager cm)
1:         super(tempTableSchemaNameCheck(tableName), cm);
0:         setNodeType(C_NodeTypes.CREATE_TABLE_NODE);
1: 
1:         this.tableType = TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE;
1:         this.onCommitDeleteRows = onCommitDeleteRows;
1:         this.onRollbackDeleteRows = onRollbackDeleteRows;
1:         this.tableElementList = tableElementList;
1:         this.properties = properties;
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a CreateTableNode for a base table create from a query
1:      * @param tableName         The name of the new object being created
1:      * @param cm                The context manager
1:     CreateTableNode(
1:             TableName tableName,
1:             ResultColumnList resultColumns,
1:             ResultSetNode queryExpression,
1:             ContextManager cm) throws StandardException
1:         super(tableName, cm);
0:         setNodeType(C_NodeTypes.CREATE_TABLE_NODE);
1:         this.tableType = TableDescriptor.BASE_TABLE_TYPE;
1:         this.lockGranularity = TableDescriptor.DEFAULT_LOCK_GRANULARITY;
1:         this.implicitCreateSchema = true;
1:         this.resultColumns = resultColumns;
1:         this.queryExpression = queryExpression;
1:      *
1:      * @param tableName The name of the new object being declared (ie
1:      *        temporary table)
1:      */
1:     private static TableName tempTableSchemaNameCheck(TableName tableName)
1:         if (tableName != null)
1:             if (tableName.getSchemaName() == null) {
1:                 // If no schema specified, SESSION is the implicit schema.
1:                 tableName.setSchemaName(SchemaDescriptor.
1:                     STD_DECLARED_GLOBAL_TEMPORARY_TABLES_SCHEMA_NAME);
1: 
1:             } else if (!(isSessionSchema(tableName.getSchemaName()))) {
1:                 throw StandardException.newException(SQLState.
1:                     LANG_DECLARED_GLOBAL_TEMP_TABLE_ONLY_IN_SESSION_SCHEMA);
1:             }
1:         return tableName;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth) {
/////////////////////////////////////////////////////////////////////////
1:     String statementToString()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:         int numPrimaryKeys;
1:         int numCheckConstraints;
1:         int numReferenceConstraints;
1:         int numUniqueConstraints;
1:         int numGenerationClauses;
1:             FromList fromList = new FromList(
1:                     getOptimizerFactory().doJoinOrderOptimization(),
/////////////////////////////////////////////////////////////////////////
1:             tableElementList = new TableElementList(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                 ColumnDefinitionNode column = new ColumnDefinitionNode(
1:                         rc.getName(),
1:                         null,
1:                         rc.getType(),
1:                         null,
1:                         getContextManager() );
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public ConstantAction makeConstantAction() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
1: 			String tempString = "";
1: 				tempString = tempString +
1: 					(properties != null ?
1: 					 "properties: " + "\n" + properties + "\n" :
1: 					 "") +
1: 					"lockGranularity: " + lockGranularity + "\n";
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 * @param depth		The depth to indent the sub-nodes
1: 	 */
0: 	public void printSubNodes(int depth) {
1: 		if (SanityManager.DEBUG) {
1: 			printLabel(depth, "tableElementList: ");
1: 			tableElementList.treePrint(depth + 1);
1: 		}
1: 	}
1: 
1: 
commit:58d069a
/////////////////////////////////////////////////////////////////////////
1: 			SchemaDescriptor sd = getSchemaDescriptor(
1: 				tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE,
1: 				true);
1: 
/////////////////////////////////////////////////////////////////////////
1: 				getSchemaDescriptor(
1: 					tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE,
1: 					true));
/////////////////////////////////////////////////////////////////////////
1: 		return isSessionSchema(
1: 			getSchemaDescriptor(
1: 				tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE,
1: 				true));
/////////////////////////////////////////////////////////////////////////
0: 		SchemaDescriptor sd = getSchemaDescriptor(
0: 			tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE,
0: 			true);
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:42544c4
/////////////////////////////////////////////////////////////////////////
1:             DataTypeDescriptor dts = colInfos[i].getDataType();
commit:5212101
/////////////////////////////////////////////////////////////////////////
1: 							DataTypeDescriptor.getCollationName(schemaCollationType));
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:2732872
/////////////////////////////////////////////////////////////////////////
0: 				ColumnDefinitionNode column = (ColumnDefinitionNode) getNodeFactory().getNode
0:                     ( C_NodeTypes.COLUMN_DEFINITION_NODE, rc.getName(), null, rc.getType(), null, getContextManager() );
commit:e126f58
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Accept the visitor for all visitable children of this node.
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	void acceptChildren(Visitor v)
1: 		throws StandardException
1: 	{
1: 		super.acceptChildren(v);
1: 
1: 		if (tableElementList != null)
1: 		{
1: 			tableElementList.accept(v);
1: 		}
1: 	}
1:     
commit:7168d7d
/////////////////////////////////////////////////////////////////////////
1: 			if  (numGenerationClauses > 0) { tableElementList.bindAndValidateGenerationClauses( sd, fromList, generatedColumns, null ); }
commit:b8b524c
/////////////////////////////////////////////////////////////////////////
1: 			if  (numCheckConstraints > 0) { tableElementList.bindAndValidateCheckConstraints(fromList); }
1: 
1:         if ( numPrimaryKeys > 0 ) { tableElementList.validatePrimaryKeyNullability(); }
commit:fce10ba
/////////////////////////////////////////////////////////////////////////
1:         SchemaDescriptor sd = getSchemaDescriptor
1:             ( tableType != TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE, true);
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			if  (numGenerationClauses > 0) { tableElementList.bindAndValidateGenerationClauses( sd, fromList, generatedColumns ); }
commit:c0342de
/////////////////////////////////////////////////////////////////////////
1: 		if ( (numCheckConstraints > 0) || (numGenerationClauses > 0) || (numReferenceConstraints > 0) )
/////////////////////////////////////////////////////////////////////////
1:             FormatableBitSet    generatedColumns = new FormatableBitSet();
0: 			if  (numGenerationClauses > 0) { tableElementList.bindAndValidateGenerationClauses(fromList, generatedColumns ); }
1:             if ( numReferenceConstraints > 0) { tableElementList.validateForeignKeysOnGenerationClauses( fromList, generatedColumns ); }
commit:2a0827a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
/////////////////////////////////////////////////////////////////////////
0: 			if  (numGenerationClauses > 0) { tableElementList.bindAndValidateGenerationClauses(fromList, new FormatableBitSet() ); }
commit:95a483d
/////////////////////////////////////////////////////////////////////////
0:         int numGenerationClauses = 0;
/////////////////////////////////////////////////////////////////////////
1:         numGenerationClauses = tableElementList.countGenerationClauses();
1: 
/////////////////////////////////////////////////////////////////////////
0: 		if ( (numCheckConstraints > 0) || (numGenerationClauses > 0) )
1: 			/* In order to check the validity of the check constraints and
1: 			 * generation clauses
/////////////////////////////////////////////////////////////////////////
1: 			FromList fromList = makeFromList( null, tableElementList, true );
1: 			 * the check constraints and generation clauses.
0: 			if  (numCheckConstraints > 0) { tableElementList.bindAndValidateCheckConstraints(fromList); }
0: 			if  (numGenerationClauses > 0) { tableElementList.bindAndValidateGenerationClauses(fromList); }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:68db840
/////////////////////////////////////////////////////////////////////////
1: 			coldefs.genConstraintActions(true,
commit:ba1b7ec
/////////////////////////////////////////////////////////////////////////
1: 				DataTypeDescriptor dtd = rc.getExpression().getTypeServices();
commit:cc770d8
/////////////////////////////////////////////////////////////////////////
1: 	public void bindStatement() throws StandardException
/////////////////////////////////////////////////////////////////////////
commit:0061383
/////////////////////////////////////////////////////////////////////////
0: public class CreateTableNode extends DDLStatementNode
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.CreateTableNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.DB2Limit;
1: 
1: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: 
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.impl.sql.execute.ColumnInfo;
1: import org.apache.derby.impl.sql.execute.CreateConstraintConstantAction;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import java.util.Properties;
1: 
1: /**
1:  * A CreateTableNode is the root of a QueryTree that represents a CREATE TABLE or DECLARE GLOBAL TEMPORARY TABLE
1:  * statement.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public class CreateTableNode extends CreateStatementNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	private char				lockGranularity;
1: 	private boolean				onCommitDeleteRows; //If true, on commit delete rows else on commit preserve rows of temporary table.
1: 	private boolean				onRollbackDeleteRows; //If true, on rollback delete rows from temp table if it was logically modified in that UOW. true is the only supported value
1: 	private Properties			properties;
1: 	private TableElementList	tableElementList;
1: 	protected int	tableType; //persistent table or global temporary table
1: 
1: 	/**
0: 	 * Initializer for a CreateTableNode for a base table
1: 	 *
0: 	 * @param objectName		The name of the new object being created (ie base table)
1: 	 * @param tableElementList	The elements of the table: columns,
1: 	 *				constraints, etc.
1: 	 * @param properties		The optional list of properties associated with
1: 	 *							the table.
1: 	 * @param lockGranularity	The lock granularity.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void init(
0: 			Object newObjectName,
0: 			Object tableElementList,
0: 			Object properties,
0: 			Object lockGranularity)
1: 		throws StandardException
1: 	{
0: 		tableType = TableDescriptor.BASE_TABLE_TYPE;
0: 		this.lockGranularity = ((Character) lockGranularity).charValue();
0: 		implicitCreateSchema = true;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (this.lockGranularity != TableDescriptor.TABLE_LOCK_GRANULARITY &&
1: 				this.lockGranularity != TableDescriptor.ROW_LOCK_GRANULARITY)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 				"Unexpected value for lockGranularity = " + this.lockGranularity);
1: 			}
1: 		}
1: 
0: 		initAndCheck(newObjectName);
0: 		this.tableElementList = (TableElementList) tableElementList;
0: 		this.properties = (Properties) properties;
1: 	}
1: 
1: 	/**
0: 	 * Initializer for a CreateTableNode for a global temporary table
1: 	 *
0: 	 * @param objectName		The name of the new object being declared (ie temporary table)
1: 	 * @param tableElementList	The elements of the table: columns,
1: 	 *				constraints, etc.
1: 	 * @param properties		The optional list of properties associated with
1: 	 *							the table.
1: 	 * @param onCommitDeleteRows	If true, on commit delete rows else on commit preserve rows of temporary table.
1: 	 * @param onRollbackDeleteRows	If true, on rollback, delete rows from temp tables which were logically modified. true is the only supported value
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void init(
0: 			Object newObjectName,
0: 			Object tableElementList,
0: 			Object properties,
0: 			Object onCommitDeleteRows,
0: 			Object onRollbackDeleteRows)
1: 		throws StandardException
1: 	{
0: 		tableType = TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE;
0: 		newObjectName = tempTableSchemaNameCheck(newObjectName);
0: 		this.onCommitDeleteRows = ((Boolean) onCommitDeleteRows).booleanValue();
0: 		this.onRollbackDeleteRows = ((Boolean) onRollbackDeleteRows).booleanValue();
0: 		initAndCheck(newObjectName);
0: 		this.tableElementList = (TableElementList) tableElementList;
0: 		this.properties = (Properties) properties;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (this.onRollbackDeleteRows == false)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 				"Unexpected value for onRollbackDeleteRows = " + this.onRollbackDeleteRows);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * If no schema name specified for global temporary table, SESSION is the implicit schema.
1: 	 * Otherwise, make sure the specified schema name for global temporary table is SESSION.
0: 	 * @param objectName		The name of the new object being declared (ie temporary table)
1: 	*/
0: 	private Object tempTableSchemaNameCheck(Object objectName)
1: 		throws StandardException {
0: 		TableName	tempTableName = (TableName) objectName;
0: 		if (tempTableName != null)
1: 		{
0: 			if (tempTableName.getSchemaName() == null)
0: 				tempTableName.setSchemaName(SchemaDescriptor.STD_DECLARED_GLOBAL_TEMPORARY_TABLES_SCHEMA_NAME); //If no schema specified, SESSION is the implicit schema.
0: 			else if (!(isSessionSchema(tempTableName.getSchemaName())))
0: 				throw StandardException.newException(SQLState.LANG_DECLARED_GLOBAL_TEMP_TABLE_ONLY_IN_SESSION_SCHEMA);
1: 		}
0: 		return(tempTableName);
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			String tempString = "tableElementList: " + "\n" + tableElementList + "\n";
1: 			if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
1: 			{
1: 				tempString = tempString + "onCommitDeleteRows: " + "\n" + onCommitDeleteRows + "\n";
1: 				tempString = tempString + "onRollbackDeleteRows: " + "\n" + onRollbackDeleteRows + "\n";
1: 			} else
0: 				tempString = tempString + "properties: " + "\n" + properties + "\n" + "lockGranularity: " + "\n" + lockGranularity + "\n";
1: 			return super.toString() +  tempString;
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
0: 	public String statementToString()
1: 	{
1: 		if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
1: 			return "DECLARE GLOBAL TEMPORARY TABLE";
1: 		else
1: 			return "CREATE TABLE";
1: 	}
1: 
1: 	// We inherit the generate() method from DDLStatementNode.
1: 
1: 	/**
1: 	 * Bind this CreateTableNode.  This means doing any static error checking that can be
1: 	 * done before actually creating the base table or declaring the global temporary table.
1: 	 * For eg, verifying that the TableElementList does not contain any duplicate column names.
1: 	 *
0: 	 * @return	The bound query tree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public QueryTreeNode bind() throws StandardException
1: 	{
1: 		DataDictionary	dataDictionary = getDataDictionary();
0: 		int numPrimaryKeys = 0;
0: 		int numCheckConstraints = 0;
0: 		int numReferenceConstraints = 0;
0: 		int numUniqueConstraints = 0;
1: 
1: 		tableElementList.validate(this, dataDictionary, (TableDescriptor) null);
1: 
1: 		/* Only 1012 columns allowed per table */
0: 		if (tableElementList.countNumberOfColumns() > DB2Limit.DB2_MAX_COLUMNS_IN_TABLE)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_COLUMNS_IN_TABLE_OR_VIEW,
1: 				String.valueOf(tableElementList.countNumberOfColumns()),
1: 				getRelativeName(),
0: 				String.valueOf(DB2Limit.DB2_MAX_COLUMNS_IN_TABLE));
1: 		}
1: 
1: 		numPrimaryKeys = tableElementList.countConstraints(
1: 								DataDictionary.PRIMARYKEY_CONSTRAINT);
1: 
1: 		/* Only 1 primary key allowed per table */
1: 		if (numPrimaryKeys > 1)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_PRIMARY_KEY_CONSTRAINTS, getRelativeName());
1: 		}
1: 
1: 		/* Check the validity of all check constraints */
1: 		numCheckConstraints = tableElementList.countConstraints(
1: 									DataDictionary.CHECK_CONSTRAINT);
1: 
1: 		numReferenceConstraints = tableElementList.countConstraints(
1: 									DataDictionary.FOREIGNKEY_CONSTRAINT);
1: 
1: 		numUniqueConstraints = tableElementList.countConstraints(
1: 									DataDictionary.UNIQUE_CONSTRAINT);
1: 
1: 		//temp tables can't have primary key or check or foreign key or unique constraints defined on them
1: 		if ((tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE) &&
1: 			(numPrimaryKeys > 0 || numCheckConstraints > 0 || numReferenceConstraints > 0 || numUniqueConstraints > 0))
1: 				throw StandardException.newException(SQLState.LANG_NOT_ALLOWED_FOR_DECLARED_GLOBAL_TEMP_TABLE);
1: 
1: 		//each of these constraints have a backing index in the back. We need to make sure that a table never has more
1: 		//more than 32767 indexes on it and that is why this check.
0: 		if ((numPrimaryKeys + numReferenceConstraints + numUniqueConstraints) > DB2Limit.DB2_MAX_INDEXES_ON_TABLE)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_INDEXES_ON_TABLE, 
1: 				String.valueOf(numPrimaryKeys + numReferenceConstraints + numUniqueConstraints),
1: 				getRelativeName(),
0: 				String.valueOf(DB2Limit.DB2_MAX_INDEXES_ON_TABLE));
1: 		}
1: 
0: 		if (numCheckConstraints > 0)
1: 		{
0: 			/* In order to check the validity of the check constraints
1: 			 * we must goober up a FromList containing a single table,
1: 			 * the table being created, with an RCL containing the
1: 			 * new columns and their types.  This will allow us to
1: 			 * bind the constraint definition trees against that
1: 			 * FromList.  When doing this, we verify that there are
1: 			 * no nodes which can return non-deterministic results.
1: 			 */
0: 			FromList fromList = (FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
1: 									getContextManager());
0: 			FromBaseTable table = (FromBaseTable)
0: 									getNodeFactory().getNode(
0: 										C_NodeTypes.FROM_BASE_TABLE,
0: 										getObjectName(),
0: 										null,
0: 										null,
0: 										null,
1: 										getContextManager());
0: 			table.setTableNumber(0);
0: 			fromList.addFromTable(table);
0: 			table.setResultColumns((ResultColumnList) getNodeFactory().getNode(
0: 												C_NodeTypes.RESULT_COLUMN_LIST,
0: 												getContextManager()));
0: 			tableElementList.appendNewColumnsToRCL(table);
1: 
1: 			/* Now that we've finally goobered stuff up, bind and validate
0: 			 * the check constraints.
1: 			 */
0: 			tableElementList.bindAndValidateCheckConstraints(fromList);
1: 		}
1: 
0: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1: 	 *
1: 	 * @return	true if references SESSION schema tables, else false
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean referencesSessionSchema()
1: 		throws StandardException
1: 	{
1: 		//If table being created/declared is in SESSION schema, then return true.
0: 		return isSessionSchema(getSchemaDescriptor());
1: 	}
1: 
1: 	/**
1: 	 * Create the Constant information that will drive the guts of Execution.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public ConstantAction	makeConstantAction() throws StandardException
1: 	{
1: 		TableElementList		coldefs = tableElementList;
1: 
1: 		// for each column, stuff system.column
1: 		ColumnInfo[] colInfos = new ColumnInfo[coldefs.countNumberOfColumns()];
1: 
1: 	    int numConstraints = coldefs.genColumnInfos(colInfos);
1: 
1: 		/* If we've seen a constraint, then build a constraint list */
1: 		CreateConstraintConstantAction[] conActions = null;
1: 
0: 		SchemaDescriptor sd = getSchemaDescriptor();
1: 
1: 		if (numConstraints > 0)
1: 		{
1: 			conActions =
1:                 new CreateConstraintConstantAction[numConstraints];
1: 
0: 			coldefs.genConstraintActions(
1:                 conActions, getRelativeName(), sd, getDataDictionary());
1: 		}
1: 
1:         // if the any of columns are "long" and user has not specified a
1:         // page size, set the pagesize to 32k.
1:         // Also in case where the approximate sum of the column sizes is
1:         // greater than the bump threshold , bump the pagesize to 32k
1: 
1:         boolean table_has_long_column = false;
1:         int approxLength = 0;
1: 
1:         for (int i = 0; i < colInfos.length; i++)
1:         {
0: 			DataTypeDescriptor dts = colInfos[i].dataType;
1:             if (dts.getTypeId().isLongConcatableTypeId())
1:             {
1:                 table_has_long_column = true;
1:                 break;
1:             }
1: 
1:             approxLength += dts.getTypeId().getApproximateLengthInBytes(dts);
1:         }
1: 
1:         if (table_has_long_column || (approxLength > Property.TBL_PAGE_SIZE_BUMP_THRESHOLD))
1:         {
1: 			if (((properties == null) ||
1:                  (properties.get(Property.PAGE_SIZE_PARAMETER) == null)) &&
1:                 (PropertyUtil.getServiceProperty(
1:                      getLanguageConnectionContext().getTransactionCompile(),
1:                      Property.PAGE_SIZE_PARAMETER) == null))
1:             {
1:                 // do not override the user's choice of page size, whether it
1:                 // is set for the whole database or just set on this statement.
1: 
1:                 if (properties == null)
1:                     properties = new Properties();
1: 
1:                 properties.put(
1:                     Property.PAGE_SIZE_PARAMETER,
1:                     Property.PAGE_SIZE_DEFAULT_LONG);
1:             }
1:         }
1: 
1: 		return(
1:             getGenericConstantActionFactory().getCreateTableConstantAction(
1:                 sd.getSchemaName(),
1:                 getRelativeName(),
1:                 tableType,
1:                 colInfos,
1:                 conActions,
1:                 properties,
1:                 lockGranularity,
1:                 onCommitDeleteRows,
1:                 onRollbackDeleteRows));
1: 	}
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:2779125
/////////////////////////////////////////////////////////////////////////
1: 		} else {
1: 			//Set the collation type and collation derivation of all the 
1: 			//character type columns. Their collation type will be same as the 
1: 			//collation of the schema they belong to. Their collation 
1: 			//derivation will be "implicit". 
1: 			//Earlier we did this in makeConstantAction but that is little too 
1: 			//late (DERBY-2955)
1: 			//eg 
1: 			//CREATE TABLE STAFF9 (EMPNAME CHAR(20),
1: 			//  CONSTRAINT STAFF9_EMPNAME CHECK (EMPNAME NOT LIKE 'T%'))
1: 			//For the query above, when run in a territory based db, we need 
1: 			//to have the correct collation set in bind phase of create table 
1: 			//so that when LIKE is handled in LikeEscapeOperatorNode, we have 
1: 			//the correct collation set for EMPNAME otherwise it will throw an 
1: 			//exception for 'T%' having collation of territory based and 
1: 			//EMPNAME having the default collation of UCS_BASIC
1: 			tableElementList.setCollationTypesOnCharacterStringColumns(
0: 					getSchemaDescriptor());
/////////////////////////////////////////////////////////////////////////
commit:197b3d3
/////////////////////////////////////////////////////////////////////////
1: 				if (dtd.getTypeId().isStringTypeId() && 
1: 						dtd.getCollationType() != schemaCollationType)
commit:a9dbcce
/////////////////////////////////////////////////////////////////////////
0: 			SchemaDescriptor sd = getSchemaDescriptor();
1: 			int schemaCollationType = sd.getCollationType();
1: 	    
/////////////////////////////////////////////////////////////////////////
1: 				//DERBY-2879  CREATE TABLE AS <subquery> does not maintain the 
1: 				//collation for character types. 
1: 				//eg for a territory based collation database
1: 				//create table t as select tablename from sys.systables with no data;
1: 				//Derby at this point does not support for a table's character 
1: 				//columns to have a collation different from it's schema's
1: 				//collation. Which means that in a territory based database, 
1: 				//the query above will cause table t's character columns to
1: 				//have collation of UCS_BASIC but the containing schema of t
1: 				//has collation of territory based. This is not supported and
1: 				//hence we will throw an exception below for the query above in
1: 				//a territory based database. 
0: 				if (dtd.getCollationType() != schemaCollationType)
1: 				{
0: 					String schemaCollationName =
0: 			        	(schemaCollationType == 
0: 			        		StringDataValue.COLLATION_TYPE_UCS_BASIC ? 
0: 			                Property.UCS_BASIC_COLLATION : 
0: 			                Property.TERRITORY_BASED_COLLATION);
1: 					throw StandardException.newException(
1: 							SQLState.LANG_CAN_NOT_CREATE_TABLE,
1: 							dtd.getCollationName(),
0: 							schemaCollationName);
1: 				}
commit:b3140c2
/////////////////////////////////////////////////////////////////////////
0:         		dts.setCollationDerivation(StringDataValue.COLLATION_DERIVATION_IMPLICIT);
commit:6e48cbe
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
1: 		
0: 		//Set the collation type and collation derivation of all the character
0: 		//type columns. Their collation type will be same as the collation of
0: 		//the schema they belong to. Theie collation derivation will be 
0: 		//"implicit".
0:         for (int i = 0; i < colInfos.length; i++) {
0:         	DataTypeDescriptor dts = colInfos[i].dataType;
0:         	if (dts.getTypeId().isStringTypeId()) {
0:         		dts.setCollationType(sd.getCollationType());
0: sqlc        		dts.setCollationDerivation(StringDataValue.COLLATION_DERIVATION_IMPLICIT);
1:         	}
1:         }
author:Army
-------------------------------------------------------------------------------
commit:d25aee0
/////////////////////////////////////////////////////////////////////////
1: 				{
1: 					continue;
/////////////////////////////////////////////////////////////////////////
0: 
0: 				DataTypeDescriptor dtd = rc.getExpressionType();
1: 				if ((dtd != null) && !dtd.isUserCreatableType())
1: 				{
1: 					throw StandardException.newException(
1: 							SQLState.LANG_INVALID_COLUMN_TYPE_CREATE_TABLE,
1: 							dtd.getFullSQLTypeName(),
1: 							rc.getName());
1: 				}
0: 
commit:d5ef906
/////////////////////////////////////////////////////////////////////////
1: 				if (resultColumns.size() != qeRCL.visibleSize())
/////////////////////////////////////////////////////////////////////////
1: 				if (rc.isGenerated()) 
1: 			        {
0: 				    continue;
1: 				}
commit:1453acc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.depend.ProviderList;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.conn.Authorizer;
/////////////////////////////////////////////////////////////////////////
1: 	private ResultColumnList	resultColumns;
1: 	private ResultSetNode		queryExpression;
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	/**
0: 	 * Initializer for a CreateTableNode for a base table create from a query
1: 	 * 
0: 	 * @param newObjectName		The name of the new object being created
1: 	 * 	                        (ie base table).
1: 	 * @param resultColumns		The optional column list.
1: 	 * @param queryExpression	The query expression for the table.
0: 	 */
0: 	public void init(
0: 			Object newObjectName,
0: 			Object resultColumns,
0: 			Object queryExpression)
0: 		throws StandardException
1: 	{
0: 		tableType = TableDescriptor.BASE_TABLE_TYPE;
0: 		lockGranularity = TableDescriptor.DEFAULT_LOCK_GRANULARITY;
0: 		implicitCreateSchema = true;
0: 		initAndCheck(newObjectName);
0: 		this.resultColumns = (ResultColumnList) resultColumns;
0: 		this.queryExpression = (ResultSetNode) queryExpression;
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 		if (queryExpression != null)
1: 		{
0: 			FromList fromList = (FromList) getNodeFactory().getNode(
0: 					C_NodeTypes.FROM_LIST,
0: 					getNodeFactory().doJoinOrderOptimization(),
0: 					getContextManager());
0: 			
1: 			CompilerContext cc = getCompilerContext();
1: 			ProviderList prevAPL = cc.getCurrentAuxiliaryProviderList();
1: 			ProviderList apl = new ProviderList();
0: 			
1: 			try
1: 			{
1: 				cc.setCurrentAuxiliaryProviderList(apl);
1: 				cc.pushCurrentPrivType(Authorizer.SELECT_PRIV);
0: 				
1: 				/* Bind the tables in the queryExpression */
1: 				queryExpression =
1: 					queryExpression.bindNonVTITables(dataDictionary, fromList);
1: 				queryExpression = queryExpression.bindVTITables(fromList);
0: 				
1: 				/* Bind the expressions under the resultSet */
1: 				queryExpression.bindExpressions(fromList);
0: 				
1: 				/* Bind the query expression */
1: 				queryExpression.bindResultColumns(fromList);
0: 				
1: 				/* Reject any untyped nulls in the RCL */
1: 				/* e.g. CREATE TABLE t1 (x) AS VALUES NULL WITH NO DATA */
1: 				queryExpression.bindUntypedNullsToResultColumns(null);
1: 			}
1: 			finally
1: 			{
1: 				cc.popCurrentPrivType();
1: 				cc.setCurrentAuxiliaryProviderList(prevAPL);
1: 			}
0: 			
1: 			/* If there is an RCL for the table definition then copy the
1: 			 * names to the queryExpression's RCL after verifying that
1: 			 * they both have the same size.
0: 			 */
1: 			ResultColumnList qeRCL = queryExpression.getResultColumns();
0: 			
1: 			if (resultColumns != null)
1: 			{
0: 				if (resultColumns.size() != qeRCL.size())
1: 				{
1: 					throw StandardException.newException(
1: 							SQLState.LANG_TABLE_DEFINITION_R_C_L_MISMATCH,
1: 							getFullName());
1: 				}
1: 				qeRCL.copyResultColumnNames(resultColumns);
1: 			}
0: 			
1: 			/* Create table element list from columns in query expression */
0: 			tableElementList = new TableElementList();
0: 			
0: 			for (int index = 0; index < qeRCL.size(); index++)
1: 			{
0: 				ResultColumn rc = (ResultColumn) qeRCL.elementAt(index);
1: 				/* Raise error if column name is system generated. */
1: 				if (rc.isNameGenerated())
1: 				{
1: 					throw StandardException.newException(
1: 							SQLState.LANG_TABLE_REQUIRES_COLUMN_NAMES);
1: 				}
0: 				ColumnDefinitionNode column = new ColumnDefinitionNode();
0: 				column.init(rc.getName(), null, rc.getType(), null);
1: 				tableElementList.addTableElement(column);
1: 			}
1: 		}
0: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
0: 	 * @param newObjectName		The name of the new object being created (ie base table)
/////////////////////////////////////////////////////////////////////////
0: 	 * @param newObjectName		The name of the new object being declared (ie temporary table)
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
1: 		if (tableElementList.countNumberOfColumns() > Limits.DB2_MAX_COLUMNS_IN_TABLE)
1: 				String.valueOf(Limits.DB2_MAX_COLUMNS_IN_TABLE));
/////////////////////////////////////////////////////////////////////////
1: 		if ((numPrimaryKeys + numReferenceConstraints + numUniqueConstraints) > Limits.DB2_MAX_INDEXES_ON_TABLE)
1: 				String.valueOf(Limits.DB2_MAX_INDEXES_ON_TABLE));
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.DB2Limit;
0: 
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.impl.sql.execute.ColumnInfo;
0: import org.apache.derby.impl.sql.execute.CreateConstraintConstantAction;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import java.util.Properties;
0: 
0: /**
0:  * A CreateTableNode is the root of a QueryTree that represents a CREATE TABLE or DECLARE GLOBAL TEMPORARY TABLE
0:  * statement.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public class CreateTableNode extends CreateStatementNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private char				lockGranularity;
0: 	private boolean				onCommitDeleteRows; //If true, on commit delete rows else on commit preserve rows of temporary table.
0: 	private boolean				onRollbackDeleteRows; //If true, on rollback delete rows from temp table if it was logically modified in that UOW. true is the only supported value
0: 	private Properties			properties;
0: 	private TableElementList	tableElementList;
0: 	protected int	tableType; //persistent table or global temporary table
0: 
0: 	/**
0: 	 * Initializer for a CreateTableNode for a base table
0: 	 *
0: 	 * @param objectName		The name of the new object being created (ie base table)
0: 	 * @param tableElementList	The elements of the table: columns,
0: 	 *				constraints, etc.
0: 	 * @param properties		The optional list of properties associated with
0: 	 *							the table.
0: 	 * @param lockGranularity	The lock granularity.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void init(
0: 			Object newObjectName,
0: 			Object tableElementList,
0: 			Object properties,
0: 			Object lockGranularity)
0: 		throws StandardException
0: 	{
0: 		tableType = TableDescriptor.BASE_TABLE_TYPE;
0: 		this.lockGranularity = ((Character) lockGranularity).charValue();
0: 		implicitCreateSchema = true;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (this.lockGranularity != TableDescriptor.TABLE_LOCK_GRANULARITY &&
0: 				this.lockGranularity != TableDescriptor.ROW_LOCK_GRANULARITY)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 				"Unexpected value for lockGranularity = " + this.lockGranularity);
0: 			}
0: 		}
0: 
0: 		initAndCheck(newObjectName);
0: 		this.tableElementList = (TableElementList) tableElementList;
0: 		this.properties = (Properties) properties;
0: 	}
0: 
0: 	/**
0: 	 * Initializer for a CreateTableNode for a global temporary table
0: 	 *
0: 	 * @param objectName		The name of the new object being declared (ie temporary table)
0: 	 * @param tableElementList	The elements of the table: columns,
0: 	 *				constraints, etc.
0: 	 * @param properties		The optional list of properties associated with
0: 	 *							the table.
0: 	 * @param onCommitDeleteRows	If true, on commit delete rows else on commit preserve rows of temporary table.
0: 	 * @param onRollbackDeleteRows	If true, on rollback, delete rows from temp tables which were logically modified. true is the only supported value
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void init(
0: 			Object newObjectName,
0: 			Object tableElementList,
0: 			Object properties,
0: 			Object onCommitDeleteRows,
0: 			Object onRollbackDeleteRows)
0: 		throws StandardException
0: 	{
0: 		tableType = TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE;
0: 		newObjectName = tempTableSchemaNameCheck(newObjectName);
0: 		this.onCommitDeleteRows = ((Boolean) onCommitDeleteRows).booleanValue();
0: 		this.onRollbackDeleteRows = ((Boolean) onRollbackDeleteRows).booleanValue();
0: 		initAndCheck(newObjectName);
0: 		this.tableElementList = (TableElementList) tableElementList;
0: 		this.properties = (Properties) properties;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (this.onRollbackDeleteRows == false)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 				"Unexpected value for onRollbackDeleteRows = " + this.onRollbackDeleteRows);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * If no schema name specified for global temporary table, SESSION is the implicit schema.
0: 	 * Otherwise, make sure the specified schema name for global temporary table is SESSION.
0: 	 * @param objectName		The name of the new object being declared (ie temporary table)
0: 	*/
0: 	private Object tempTableSchemaNameCheck(Object objectName)
0: 		throws StandardException {
0: 		TableName	tempTableName = (TableName) objectName;
0: 		if (tempTableName != null)
0: 		{
0: 			if (tempTableName.getSchemaName() == null)
0: 				tempTableName.setSchemaName(SchemaDescriptor.STD_DECLARED_GLOBAL_TEMPORARY_TABLES_SCHEMA_NAME); //If no schema specified, SESSION is the implicit schema.
0: 			else if (!(isSessionSchema(tempTableName.getSchemaName())))
0: 				throw StandardException.newException(SQLState.LANG_DECLARED_GLOBAL_TEMP_TABLE_ONLY_IN_SESSION_SCHEMA);
0: 		}
0: 		return(tempTableName);
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			String tempString = "tableElementList: " + "\n" + tableElementList + "\n";
0: 			if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
0: 			{
0: 				tempString = tempString + "onCommitDeleteRows: " + "\n" + onCommitDeleteRows + "\n";
0: 				tempString = tempString + "onRollbackDeleteRows: " + "\n" + onRollbackDeleteRows + "\n";
0: 			} else
0: 				tempString = tempString + "properties: " + "\n" + properties + "\n" + "lockGranularity: " + "\n" + lockGranularity + "\n";
0: 			return super.toString() +  tempString;
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	public String statementToString()
0: 	{
0: 		if (tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
0: 			return "DECLARE GLOBAL TEMPORARY TABLE";
0: 		else
0: 			return "CREATE TABLE";
0: 	}
0: 
0: 	// We inherit the generate() method from DDLStatementNode.
0: 
0: 	/**
0: 	 * Bind this CreateTableNode.  This means doing any static error checking that can be
0: 	 * done before actually creating the base table or declaring the global temporary table.
0: 	 * For eg, verifying that the TableElementList does not contain any duplicate column names.
0: 	 *
0: 	 * @return	The bound query tree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public QueryTreeNode bind() throws StandardException
0: 	{
0: 		DataDictionary	dataDictionary = getDataDictionary();
0: 		int numPrimaryKeys = 0;
0: 		int numCheckConstraints = 0;
0: 		int numReferenceConstraints = 0;
0: 		int numUniqueConstraints = 0;
0: 
0: 		tableElementList.validate(this, dataDictionary, (TableDescriptor) null);
0: 
0: 		/* Only 1012 columns allowed per table */
0: 		if (tableElementList.countNumberOfColumns() > DB2Limit.DB2_MAX_COLUMNS_IN_TABLE)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_COLUMNS_IN_TABLE_OR_VIEW,
0: 				String.valueOf(tableElementList.countNumberOfColumns()),
0: 				getRelativeName(),
0: 				String.valueOf(DB2Limit.DB2_MAX_COLUMNS_IN_TABLE));
0: 		}
0: 
0: 		numPrimaryKeys = tableElementList.countConstraints(
0: 								DataDictionary.PRIMARYKEY_CONSTRAINT);
0: 
0: 		/* Only 1 primary key allowed per table */
0: 		if (numPrimaryKeys > 1)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_PRIMARY_KEY_CONSTRAINTS, getRelativeName());
0: 		}
0: 
0: 		/* Check the validity of all check constraints */
0: 		numCheckConstraints = tableElementList.countConstraints(
0: 									DataDictionary.CHECK_CONSTRAINT);
0: 
0: 		numReferenceConstraints = tableElementList.countConstraints(
0: 									DataDictionary.FOREIGNKEY_CONSTRAINT);
0: 
0: 		numUniqueConstraints = tableElementList.countConstraints(
0: 									DataDictionary.UNIQUE_CONSTRAINT);
0: 
0: 		//temp tables can't have primary key or check or foreign key or unique constraints defined on them
0: 		if ((tableType == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE) &&
0: 			(numPrimaryKeys > 0 || numCheckConstraints > 0 || numReferenceConstraints > 0 || numUniqueConstraints > 0))
0: 				throw StandardException.newException(SQLState.LANG_NOT_ALLOWED_FOR_DECLARED_GLOBAL_TEMP_TABLE);
0: 
0: 		//each of these constraints have a backing index in the back. We need to make sure that a table never has more
0: 		//more than 32767 indexes on it and that is why this check.
0: 		if ((numPrimaryKeys + numReferenceConstraints + numUniqueConstraints) > DB2Limit.DB2_MAX_INDEXES_ON_TABLE)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_INDEXES_ON_TABLE, 
0: 				String.valueOf(numPrimaryKeys + numReferenceConstraints + numUniqueConstraints),
0: 				getRelativeName(),
0: 				String.valueOf(DB2Limit.DB2_MAX_INDEXES_ON_TABLE));
0: 		}
0: 
0: 		if (numCheckConstraints > 0)
0: 		{
0: 			/* In order to check the validity of the check constraints
0: 			 * we must goober up a FromList containing a single table,
0: 			 * the table being created, with an RCL containing the
0: 			 * new columns and their types.  This will allow us to
0: 			 * bind the constraint definition trees against that
0: 			 * FromList.  When doing this, we verify that there are
0: 			 * no nodes which can return non-deterministic results.
0: 			 */
0: 			FromList fromList = (FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager());
0: 			FromBaseTable table = (FromBaseTable)
0: 									getNodeFactory().getNode(
0: 										C_NodeTypes.FROM_BASE_TABLE,
0: 										getObjectName(),
0: 										null,
0: 										null,
0: 										null,
0: 										getContextManager());
0: 			table.setTableNumber(0);
0: 			fromList.addFromTable(table);
0: 			table.setResultColumns((ResultColumnList) getNodeFactory().getNode(
0: 												C_NodeTypes.RESULT_COLUMN_LIST,
0: 												getContextManager()));
0: 			tableElementList.appendNewColumnsToRCL(table);
0: 
0: 			/* Now that we've finally goobered stuff up, bind and validate
0: 			 * the check constraints.
0: 			 */
0: 			tableElementList.bindAndValidateCheckConstraints(fromList);
0: 		}
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
0: 	 *
0: 	 * @return	true if references SESSION schema tables, else false
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean referencesSessionSchema()
0: 		throws StandardException
0: 	{
0: 		//If table being created/declared is in SESSION schema, then return true.
0: 		return isSessionSchema(getSchemaDescriptor());
0: 	}
0: 
0: 	/**
0: 	 * Create the Constant information that will drive the guts of Execution.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public ConstantAction	makeConstantAction() throws StandardException
0: 	{
0: 		TableElementList		coldefs = tableElementList;
0: 
0: 		// for each column, stuff system.column
0: 		ColumnInfo[] colInfos = new ColumnInfo[coldefs.countNumberOfColumns()];
0: 
0: 	    int numConstraints = coldefs.genColumnInfos(colInfos);
0: 
0: 		/* If we've seen a constraint, then build a constraint list */
0: 		CreateConstraintConstantAction[] conActions = null;
0: 
0: 		SchemaDescriptor sd = getSchemaDescriptor();
0: 
0: 		if (numConstraints > 0)
0: 		{
0: 			conActions =
0:                 new CreateConstraintConstantAction[numConstraints];
0: 
0: 			coldefs.genConstraintActions(
0:                 conActions, getRelativeName(), sd, getDataDictionary());
0: 		}
0: 
0:         // if the any of columns are "long" and user has not specified a
0:         // page size, set the pagesize to 32k.
0:         // Also in case where the approximate sum of the column sizes is
0:         // greater than the bump threshold , bump the pagesize to 32k
0: 
0:         boolean table_has_long_column = false;
0:         int approxLength = 0;
0: 
0:         for (int i = 0; i < colInfos.length; i++)
0:         {
0: 			DataTypeDescriptor dts = colInfos[i].dataType;
0:             if (dts.getTypeId().isLongConcatableTypeId())
0:             {
0:                 table_has_long_column = true;
0:                 break;
0:             }
0: 
0:             approxLength += dts.getTypeId().getApproximateLengthInBytes(dts);
0:         }
0: 
0:         if (table_has_long_column || (approxLength > Property.TBL_PAGE_SIZE_BUMP_THRESHOLD))
0:         {
0: 			if (((properties == null) ||
0:                  (properties.get(Property.PAGE_SIZE_PARAMETER) == null)) &&
0:                 (PropertyUtil.getServiceProperty(
0:                      getLanguageConnectionContext().getTransactionCompile(),
0:                      Property.PAGE_SIZE_PARAMETER) == null))
0:             {
0:                 // do not override the user's choice of page size, whether it
0:                 // is set for the whole database or just set on this statement.
0: 
0:                 if (properties == null)
0:                     properties = new Properties();
0: 
0:                 properties.put(
0:                     Property.PAGE_SIZE_PARAMETER,
0:                     Property.PAGE_SIZE_DEFAULT_LONG);
0:             }
0:         }
0: 
0: 		return(
0:             getGenericConstantActionFactory().getCreateTableConstantAction(
0:                 sd.getSchemaName(),
0:                 getRelativeName(),
0:                 tableType,
0:                 colInfos,
0:                 conActions,
0:                 properties,
0:                 lockGranularity,
0:                 onCommitDeleteRows,
0:                 onRollbackDeleteRows));
0: 	}
0: }
============================================================================