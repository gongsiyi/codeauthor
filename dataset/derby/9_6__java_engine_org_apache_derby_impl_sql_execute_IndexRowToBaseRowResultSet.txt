2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet
1:2700e3d: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
6:eac0369:  */
38:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:7c3cc82: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1:7c3cc82: import org.apache.derby.iapi.error.StandardException;
1:7c3cc82: import org.apache.derby.iapi.reference.SQLState;
1:7c3cc82: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:7c3cc82: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:7c3cc82: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:bda7291: import org.apache.derby.iapi.sql.execute.ExecRowBuilder;
1:eac0369: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:7c3cc82: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:6853511: import org.apache.derby.impl.sql.GenericPreparedStatement;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * Takes a result set with a RowLocation as the last column, and uses the
1:eac0369:  * RowLocation to get and return a row from the given base conglomerate.
1:eac0369:  * Normally, the input result set will be a TableScanResultSet scanning an
1:eac0369:  * index conglomerate.
1:eac0369:  *
1:eac0369:  */
1:f77f36d: class IndexRowToBaseRowResultSet extends NoPutResultSetImpl
1:eac0369: 	implements CursorResultSet {
1:eac0369: 
1:eac0369:     // set in constructor and not altered during
1:eac0369:     // life of object.
1:eac0369:     public NoPutResultSet source;
1:eac0369: 	private GeneratedMethod restriction;
1:eac0369: 	public FormatableBitSet accessedHeapCols;
1:eac0369: 	//caching accessed columns (heap+index) beetle 3865
1:eac0369: 	private FormatableBitSet accessedAllCols;
1:eac0369: 	public String indexName;
1:eac0369: 	private int[] indexCols;
1:eac0369: 	private DynamicCompiledOpenConglomInfo dcoci;
1:eac0369: 	private StaticCompiledOpenConglomInfo scoci;
1:eac0369: 
1:eac0369: 	// set in open() and not changed after that
1:eac0369: 	private ConglomerateController	baseCC;
1:eac0369: 	private boolean                 closeBaseCCHere;
1:eac0369: 	private boolean					forUpdate;
1:eac0369: 	private DataValueDescriptor[]	rowArray;
1:eac0369: 
1:eac0369: 	// changed a whole bunch
1:eac0369: 	RowLocation	baseRowLocation;
1:eac0369: 
1:eac0369: 	/* Remember whether or not we have copied any
1:eac0369: 	 * columns from the source row to our row yet.
1:eac0369: 	 */
1:eac0369: 	boolean copiedFromSource;
1:eac0369: 
1:eac0369: 	/* Run time statistics variables */
1:eac0369: 	public long restrictionTime;
1:eac0369: 
1:eac0369:     //
1:1705596:     // For managing row locations which are returned for the left join
1:1705596:     // which drives the execution of the MERGE statement.
1:1705596:     //
1:1705596:     private int _baseColumnCount;
1:1705596:     private boolean _includeRowLocation;
1:1705596: 	private FormatableBitSet _heapColsWithoutRowLocation;
1:1705596: 
1:1705596:     //
1:eac0369:     // class interface
1:eac0369:     //
1:f77f36d:     IndexRowToBaseRowResultSet(
1:eac0369: 					long conglomId,
1:eac0369: 					int scociItem,
1:eac0369: 					Activation a,
1:eac0369: 					NoPutResultSet source,
1:bda7291: 					int resultRowAllocator,
1:eac0369: 					int resultSetNumber,
1:eac0369: 					String indexName,
1:eac0369: 					int heapColRefItem,
1:6853511: 					int allColRefItem,
1:6853511: 					int heapOnlyColRefItem,
1:eac0369: 					int indexColMapItem,
1:eac0369: 					GeneratedMethod restriction,
1:eac0369: 					boolean forUpdate,
1:eac0369: 					double optimizerEstimatedRowCount,
1:1705596: 					double optimizerEstimatedCost,
1:1705596: 					int baseColumnCount) 
1:eac0369: 		throws StandardException
18:eac0369: 	{
1:eac0369: 		super(a, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost);
1:6853511: 		final GenericPreparedStatement gp =
1:6853511: 			(GenericPreparedStatement)a.getPreparedStatement();
1:6853511: 
1:554386c:         scoci = (StaticCompiledOpenConglomInfo) gp.getSavedObject(scociItem);
1:eac0369: 		TransactionController tc = activation.getTransactionController();
1:eac0369: 		dcoci = tc.getDynamicCompiledConglomInfo(conglomId);
1:eac0369:         this.source = source;
1:eac0369: 		this.indexName = indexName;
1:eac0369: 		this.forUpdate = forUpdate;
1:eac0369: 		this.restriction = restriction;
1:1705596:         _baseColumnCount = baseColumnCount;
1:eac0369: 
1:eac0369: 		/* RESOLVE - once we push Qualifiers into the store we
1:eac0369: 		 * need to clear their Orderable cache on each open/reopen.
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		// retrieve the valid column list from
1:eac0369: 		// the saved objects, if it exists
1:6853511: 		if (heapColRefItem != -1) {
1:554386c:             this.accessedHeapCols =
1:554386c:                     (FormatableBitSet) gp.getSavedObject(heapColRefItem);
16:eac0369: 		}
1:6853511: 		if (allColRefItem != -1) {
1:554386c:             this.accessedAllCols =
1:554386c:                     (FormatableBitSet) gp.getSavedObject(allColRefItem);
1:eac0369: 		}
1:1705596: 
1:eac0369: 		// retrieve the array of columns coming from the index
1:6853511: 		indexCols = 
1:6853511: 			((ReferencedColumnsDescriptorImpl)
1:554386c:                 gp.getSavedObject(indexColMapItem))
1:554386c:                 .getReferencedColumnPositions();
1:6853511: 
1:eac0369: 		/* Get the result row template */
1:554386c:         ExecRow resultRow =
1:554386c:                 ((ExecRowBuilder) gp.getSavedObject(resultRowAllocator))
1:554386c:                     .build(a.getExecutionFactory());
1:2700e3d: 
1:6853511: 		// Note that getCompactRow will assign its return value to the
1:6853511: 		// variable compactRow which can be accessed through
1:6853511: 		// inheritance. Hence we need not collect the return value
1:6853511: 		// of the method.
1:49f3f24: 		getCompactRow(resultRow, accessedAllCols, false);
1:eac0369: 
1:eac0369: 		/* If there's no partial row bit map, then we want the entire
1:eac0369: 		 * row, otherwise we need to diddle with the row array so that
1:eac0369: 		 * we only get the columns coming from the heap on the fetch.
1:eac0369: 		 */
1:6853511: 		if (accessedHeapCols == null) {
1:eac0369: 			rowArray = resultRow.getRowArray();
1:eac0369: 		}
1:6853511: 		else {
1:eac0369: 			// Figure out how many columns are coming from the heap
1:eac0369: 
1:6853511: 			final DataValueDescriptor[] resultRowArray =
1:6853511: 				resultRow.getRowArray();
1:6853511: 			final FormatableBitSet heapOnly =
1:554386c:                 (FormatableBitSet) gp.getSavedObject(heapOnlyColRefItem);
1:6853511: 			final int heapOnlyLen = heapOnly.getLength();
1:eac0369: 
1:6853511: 			// Need a separate DataValueDescriptor array in this case
1:6853511: 			rowArray =
1:6853511:  				new DataValueDescriptor[heapOnlyLen];
1:6853511: 			final int minLen = Math.min(resultRowArray.length, heapOnlyLen);
1:6853511: 
1:6853511: 			// Make a copy of the relevant part of rowArray
1:6853511: 			for (int i = 0; i < minLen; ++i) {
1:6853511: 				if (resultRowArray[i] != null && heapOnly.isSet(i)) {
1:6853511: 					rowArray[i] = resultRowArray[i];
1:6853511: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:1705596:         //
1:1705596:         // The row location column may be needed by the left join which drives
1:1705596:         // the execution of the MERGE statement.
1:1705596:         //
1:1705596:         _includeRowLocation = (_baseColumnCount < accessedHeapCols.getLength());
1:1705596:         if ( _includeRowLocation )
1:1705596:         {
1:1705596:             _heapColsWithoutRowLocation = (FormatableBitSet) accessedHeapCols.clone();
1:1705596:             _heapColsWithoutRowLocation.clear( accessedHeapCols.getLength() - 1 );
1:1705596:         }
1:1705596: 
1:7008b63: 		recordConstructorTime();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// ResultSet interface (leftover from NoPutResultSet)
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * open this ResultSet.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if cursor finished.
1:eac0369:      */
1:eac0369: 	public void	openCore() throws StandardException 
1:eac0369: 	{
1:eac0369: 		boolean						lockingRequired = false;
2:eac0369: 		TransactionController		tc;
1:eac0369: 
1:eac0369: 		// REVISIT: through the direct DB API, this needs to be an
1:eac0369: 		// error, not an ASSERT; users can open twice. Only through JDBC
1:eac0369: 		// is access to open controlled and ensured valid.
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 	    	SanityManager.ASSERT( ! isOpen,
1:eac0369: 								"IndexRowToBaseRowResultSet already open");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 
1:eac0369: 		source.openCore();
1:eac0369: 
1:eac0369: 		/* Get a ConglomerateController for the base conglomerate 
1:eac0369: 		 * NOTE: We only need to acquire locks on the data pages when
1:eac0369: 		 * going through the index when we are at READ COMMITTED and
1:eac0369: 		 * the source is a BulkTableScan or HashScan.  (The underlying
1:eac0369: 		 * row will not be guaranteed to be locked.)
1:eac0369: 		 */
1:eac0369: 		if (source.requiresRelocking())
1:eac0369: 		{
1:eac0369: 			lockingRequired = true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		tc = activation.getTransactionController();
1:eac0369: 
1:eac0369: 		int openMode;
1:eac0369: 		int isolationLevel;
1:eac0369: 		
1:eac0369: 		if (forUpdate)
1:eac0369: 		{
1:eac0369: 			openMode = TransactionController.OPENMODE_FORUPDATE;
1:eac0369: 		}
4:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			openMode = 0;
1:eac0369: 		}
1:eac0369: 		isolationLevel = source.getScanIsolationLevel();
1:eac0369: 
1:eac0369: 		if (!lockingRequired)
1:eac0369: 		{
1:eac0369:             // flag indicates that lock has already been acquired by access to
1:eac0369:             // the secondary index, and need not be gotten again in the base
1:eac0369:             // table.
1:eac0369: 			openMode |= TransactionController.OPENMODE_SECONDARY_LOCKED;
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		/* Try to get the ConglomerateController from the activation
1:eac0369: 		 * first, for the case that we are part of an update or delete.
1:eac0369: 		 * If so, then the RowChangerImpl did the correct locking.
1:eac0369: 		 * If not there, then we go off and open it ourself.
1:eac0369: 		 */
1:eac0369: 		if (forUpdate)
1:eac0369: 		{
1:eac0369: 			baseCC = activation.getHeapConglomerateController();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (baseCC == null)
1:eac0369: 		{
1:eac0369: 			baseCC = 
1:eac0369: 		        tc.openCompiledConglomerate(
1:eac0369:                     activation.getResultSetHoldability(),
1:eac0369: 				    openMode,
1:eac0369: 					// consistent with FromBaseTable's updateTargetLockMode
1:eac0369: 					TransactionController.MODE_RECORD,
1:eac0369: 	                isolationLevel,
1:eac0369: 					scoci,
1:eac0369: 					dcoci);
1:eac0369: 			closeBaseCCHere = true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		isOpen = true;
1:eac0369: 		numOpens++;
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * reopen this ResultSet.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if cursor finished.
1:eac0369: 	 */
1:eac0369: 	public void	reopenCore() throws StandardException {
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(isOpen,
1:eac0369: 					"IndexRowToBaseRowResultSet already open");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 
1:eac0369: 		source.reopenCore();
1:eac0369: 
1:eac0369: 		numOpens++;
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * Return the requested values computed
1:eac0369:      * from the next row (if any) for which
1:eac0369:      * the restriction evaluates to true.
1:eac0369:      * <p>
1:eac0369:      * restriction and projection parameters
1:eac0369:      * are evaluated for each row.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
1:eac0369: 	 *
1:eac0369: 	 * @return the next row in the result
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getNextRowCore() throws StandardException {
1:2a4654b: 		if( isXplainOnlyMode() )
1:2a4654b: 			return null;
1:eac0369: 
1:eac0369: 	    ExecRow sourceRow = null;
1:eac0369: 		ExecRow retval = null;
1:eac0369: 	    boolean restrict = false;
1:eac0369: 	    DataValueDescriptor restrictBoolean;
1:eac0369: 		long	beginRT = 0;
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 	    if ( ! isOpen ) {
1:eac0369: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Loop until we get a row from the base page that qualifies or
1:eac0369: 		 * there's no more rows from the index that qualify. (If the RID
1:eac0369: 		 * returned by the index does not qualify, then we have to go back
1:eac0369: 		 * to the index to see if there is another RID to consider.)
1:eac0369: 		 */
1:eac0369: 		do 
1:eac0369: 		{
1:eac0369: 			sourceRow = source.getNextRowCore();
1:eac0369: 
1:eac0369: 			if (sourceRow != null) {
1:eac0369: 
2:eac0369: 				if (SanityManager.DEBUG) {
2:eac0369: 					SanityManager.ASSERT(
2:eac0369: 						sourceRow.getColumn(sourceRow.nColumns())
2:eac0369: 														instanceof RowLocation,
2:eac0369: 						"Last column of source row is not a RowLocation"
2:eac0369: 							);
1:eac0369: 				}
1:eac0369: 
2:eac0369: 				baseRowLocation = (RowLocation)
2:eac0369: 						sourceRow.getColumn(sourceRow.nColumns());
1:eac0369: 
2:eac0369: 				// Fetch the columns coming from the heap
2:eac0369: 				boolean row_exists = 
1:1705596:                     baseCC.fetch
1:1705596:                     (
1:1705596:                      baseRowLocation,
1:1705596:                      rowArray,
1:1705596:                      _includeRowLocation ? _heapColsWithoutRowLocation : accessedHeapCols
1:1705596:                      );
1:eac0369: 
2:eac0369:                 if (row_exists)
1:eac0369:                 {
1:eac0369: 					/* We only need to copy columns from the index row 
1:eac0369: 					 * to our result row once as we will be reusing the
1:eac0369: 					 * wrappers in that case.
1:eac0369: 					 * NOTE: When the underlying ResultSet got an 
1:eac0369: 					 * instantaneous lock (BulkTableScan or HashScan)
1:eac0369: 					 * then we will be getting all of the columns anew
1:eac0369: 					 * from the index (indexCols == null).
1:eac0369: 					 */
1:eac0369: 					if (! copiedFromSource)
1:eac0369: 					{
1:eac0369: 						copiedFromSource = true;
1:eac0369: 
2:eac0369: 						// Copy the columns coming from the index into resultRow
2:eac0369: 						for (int index = 0; index < indexCols.length; index++)
1:eac0369: 						{
2:eac0369: 							if (indexCols[index] != -1)
1:eac0369: 							{
2:eac0369: 								compactRow.setColumn(
2:eac0369: 											index + 1,
2:eac0369: 											sourceRow.getColumn(indexCols[index] + 1));
1:eac0369: 							}
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 
2:eac0369:                     setCurrentRow(compactRow);
1:eac0369: 
1:eac0369:                     restrictBoolean = (DataValueDescriptor) 
1:eac0369:                         ((restriction == null) ? 
1:eac0369:                              null : restriction.invoke(activation));
1:eac0369: 
1:eac0369:                     restrictionTime += getElapsedMillis(beginRT);
1:eac0369: 
1:eac0369:                     // if the result is null, we make it false --
1:eac0369:                     // so the row won't be returned.
1:eac0369:                     restrict = (restrictBoolean == null) ||
1:eac0369:                                 ((! restrictBoolean.isNull()) &&
1:eac0369:                                     restrictBoolean.getBoolean());
1:eac0369:                 }
1:eac0369: 
1:eac0369: 				if (! restrict || ! row_exists)
1:eac0369: 				{
1:eac0369: 					rowsFiltered++;
3:eac0369: 					clearCurrentRow();
1:eac0369: 					baseRowLocation = null;
1:eac0369: 
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
3:eac0369: 					currentRow = compactRow;
1:eac0369: 				}
1:eac0369: 
1:1705596:                 if ( _includeRowLocation )
1:1705596:                 {
1:1705596:                     currentRow.setColumn( currentRow.nColumns(), baseRowLocation );
1:1705596:                 }
1:1705596: 
1:eac0369: 				/* Update the run time statistics */
1:eac0369: 				rowsSeen++;
1:eac0369: 
1:eac0369: 				retval = currentRow;
2:eac0369: 		    } else {
1:eac0369: 				clearCurrentRow();
1:eac0369: 				baseRowLocation = null;
1:eac0369: 
1:eac0369: 				retval = null;
1:eac0369: 			}
1:eac0369: 	    } 
1:eac0369: 		while ( (sourceRow != null) && (! restrict ) );
1:eac0369: 
2:eac0369: 		nextTime += getElapsedMillis(beginTime);
1:eac0369:     	return retval;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * If the result set has been opened,
1:eac0369: 	 * close the open scan.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public void	close() throws StandardException
1:eac0369: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 	    if ( isOpen ) {
1:eac0369: 
1:eac0369: 			// we don't want to keep around a pointer to the
1:eac0369: 			// row ... so it can be thrown away.
1:eac0369: 			// REVISIT: does this need to be in a finally
1:eac0369: 			// block, to ensure that it is executed?
1:eac0369: 	    	clearCurrentRow();
1:f77f36d: 
1:eac0369: 			if (closeBaseCCHere)
1:eac0369: 			{
1:eac0369:                 // This check should only be needed in the error case where
1:eac0369:                 // we may call this close() routine as part of transaction
1:eac0369:                 // backout cleanup if any of the following routines fail.
1:eac0369:                 // If one of the subsequent statements gets an error, we
1:eac0369:                 // will try to close this result set as part of transaction
1:eac0369:                 // cleanup, and without this check we get a null pointer
1:eac0369:                 // exception because we have null'd out baseCC.
1:eac0369:               
1:eac0369:                 if (baseCC != null)
1:eac0369:                     baseCC.close();
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* Make sure to null out baseCC since
1:eac0369: 			 * we check for null baseCC after looking
1:eac0369: 			 * in the StatementContext.
1:eac0369: 			 */
1:eac0369: 			baseCC = null;
1:eac0369: 	        source.close();
1:eac0369: 
1:eac0369: 			super.close();
1:eac0369: 	    }
1:eac0369: 		else if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.DEBUG("CloseRepeatInfo","Close of IndexRowToBaseRowResultSet repeated");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		closeTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the total amount of time spent in this ResultSet
1:eac0369: 	 *
1:eac0369: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1:eac0369: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The total amount of time spent (in milliseconds).
1:eac0369: 	 */
1:eac0369: 	public long getTimeSpent(int type)
1:eac0369: 	{
1:eac0369: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1:eac0369: 
1:eac0369: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1:eac0369: 		{
1:eac0369: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return totTime;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// CursorResultSet interface
1:eac0369: 	//
1:eac0369: 	/**
1:eac0369: 	 * Return the RowLocation of the base row.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the row location of the current cursor row.
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 */
1:eac0369: 	public RowLocation getRowLocation() throws StandardException {
1:eac0369: 		return baseRowLocation;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:2700e3d: 	 * @see NoPutResultSet#positionScanAtRowLocation
1:2700e3d: 	 * 
1:2700e3d: 	 * Also remembers row location so that subsequent invocations of
1:2700e3d: 	 * getCurrentRow will not read the index row to look up the row
1:2700e3d: 	 * location base row, but reuse the saved row location.
1:2700e3d: 	 */
1:2700e3d: 	public void positionScanAtRowLocation(RowLocation rl) 
1:2700e3d: 		throws StandardException 
1:2700e3d: 	{
1:2700e3d: 		baseRowLocation = rl;
1:2700e3d: 		source.positionScanAtRowLocation(rl);
1:2700e3d: 	}
1:2700e3d: 
1:2700e3d: 	/**	 * Gets last row returned.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the last row returned.
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 */
1:eac0369: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1:eac0369: 	 * once there is such a method.  (currentRow is redundant)
1:eac0369: 	 */
1:eac0369: 	public ExecRow getCurrentRow() throws StandardException {
1:eac0369: 	    ExecRow sourceRow = null;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(isOpen,
1:eac0369: 					"IndexRowToBaseRowResultSet is expected to be open");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Nothing to do if we're not currently on a row */
1:eac0369: 		if (currentRow == null)
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:f4fc366: 		// We do not need to read the row from the index first, since we already 
1:f4fc366: 		// have the rowLocation of the current row and can read it directly from 
1:f4fc366: 		// the heap.
1:2700e3d: 		sourceRow = activation.getExecutionFactory().
1:2700e3d: 				getValueRow(indexCols.length);
1:2700e3d: 		sourceRow.setRowArray(rowArray);
1:2700e3d: 		// Fetch the columns coming from the heap
1:2700e3d: 		boolean row_exists = 
1:2700e3d: 			baseCC.fetch(
1:2700e3d: 				baseRowLocation, rowArray, (FormatableBitSet) null);
1:2700e3d: 		if (row_exists) {
1:2700e3d: 			setCurrentRow(sourceRow);
1:2700e3d: 		} else {
1:2700e3d: 			clearCurrentRow();
1:2700e3d: 		}
1:2700e3d: 		return currentRow;
1:2700e3d: 	}
1:2700e3d: 
1:eac0369: 	/**
1:eac0369: 	 * Is this ResultSet or it's source result set for update.
1:eac0369: 	 * beetle 3865: updateable cursor using index scan.  We didn't need this function
1:eac0369: 	 * before because we couldn't use index for update cursor.
1:eac0369: 	 * 
1:eac0369: 	 * @return Whether or not the result set is for update.
1:eac0369: 	 */
1:eac0369: 	public boolean isForUpdate()
1:eac0369: 	{
1:eac0369: 		return source.isForUpdate();
1:eac0369: 	}
1:eac0369: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:1705596
/////////////////////////////////////////////////////////////////////////
1:     // For managing row locations which are returned for the left join
1:     // which drives the execution of the MERGE statement.
1:     //
1:     private int _baseColumnCount;
1:     private boolean _includeRowLocation;
1: 	private FormatableBitSet _heapColsWithoutRowLocation;
1: 
1:     //
/////////////////////////////////////////////////////////////////////////
1: 					double optimizerEstimatedCost,
1: 					int baseColumnCount) 
/////////////////////////////////////////////////////////////////////////
1:         _baseColumnCount = baseColumnCount;
/////////////////////////////////////////////////////////////////////////
1: 
1:         //
1:         // The row location column may be needed by the left join which drives
1:         // the execution of the MERGE statement.
1:         //
1:         _includeRowLocation = (_baseColumnCount < accessedHeapCols.getLength());
1:         if ( _includeRowLocation )
1:         {
1:             _heapColsWithoutRowLocation = (FormatableBitSet) accessedHeapCols.clone();
1:             _heapColsWithoutRowLocation.clear( accessedHeapCols.getLength() - 1 );
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     baseCC.fetch
1:                     (
1:                      baseRowLocation,
1:                      rowArray,
1:                      _includeRowLocation ? _heapColsWithoutRowLocation : accessedHeapCols
1:                      );
/////////////////////////////////////////////////////////////////////////
1:                 if ( _includeRowLocation )
1:                 {
1:                     currentRow.setColumn( currentRow.nColumns(), baseRowLocation );
1:                 }
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:2a4654b
/////////////////////////////////////////////////////////////////////////
1: 		if( isXplainOnlyMode() )
1: 			return null;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:554386c
/////////////////////////////////////////////////////////////////////////
1:         scoci = (StaticCompiledOpenConglomInfo) gp.getSavedObject(scociItem);
/////////////////////////////////////////////////////////////////////////
1:             this.accessedHeapCols =
1:                     (FormatableBitSet) gp.getSavedObject(heapColRefItem);
1:             this.accessedAllCols =
1:                     (FormatableBitSet) gp.getSavedObject(allColRefItem);
1:                 gp.getSavedObject(indexColMapItem))
1:                 .getReferencedColumnPositions();
1:         ExecRow resultRow =
1:                 ((ExecRowBuilder) gp.getSavedObject(resultRowAllocator))
1:                     .build(a.getExecutionFactory());
/////////////////////////////////////////////////////////////////////////
1:                 (FormatableBitSet) gp.getSavedObject(heapOnlyColRefItem);
commit:bda7291
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.ExecRowBuilder;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 					int resultRowAllocator,
/////////////////////////////////////////////////////////////////////////
0:         ExecRow resultRow = ((ExecRowBuilder) saved[resultRowAllocator])
0:                                 .build(a.getExecutionFactory());
commit:91f376c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6853511
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.sql.GenericPreparedStatement;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 					int allColRefItem,
1: 					int heapOnlyColRefItem,
/////////////////////////////////////////////////////////////////////////
1: 		final GenericPreparedStatement gp =
1: 			(GenericPreparedStatement)a.getPreparedStatement();
0: 		final Object[] saved = gp.getSavedObjects();
1: 
0: 		scoci = (StaticCompiledOpenConglomInfo)saved[scociItem];
/////////////////////////////////////////////////////////////////////////
1: 		if (heapColRefItem != -1) {
0: 			this.accessedHeapCols = (FormatableBitSet)saved[heapColRefItem];
1: 		if (allColRefItem != -1) {
0: 			this.accessedAllCols = (FormatableBitSet)saved[allColRefItem];
1: 
1: 		indexCols = 
1: 			((ReferencedColumnsDescriptorImpl)
0: 			 saved[indexColMapItem]).getReferencedColumnPositions();
1: 		// Note that getCompactRow will assign its return value to the
1: 		// variable compactRow which can be accessed through
1: 		// inheritance. Hence we need not collect the return value
1: 		// of the method.
0: 		getCompactRow(resultRow, accessedAllCols, 
0: 					  (FormatableBitSet)null, false);
1: 		if (accessedHeapCols == null) {
1: 		else {
1: 			final DataValueDescriptor[] resultRowArray =
1: 				resultRow.getRowArray();
1: 			final FormatableBitSet heapOnly =
0: 				(FormatableBitSet)saved[heapOnlyColRefItem];
1: 			final int heapOnlyLen = heapOnly.getLength();
1: 			// Need a separate DataValueDescriptor array in this case
1: 			rowArray =
1:  				new DataValueDescriptor[heapOnlyLen];
1: 			final int minLen = Math.min(resultRowArray.length, heapOnlyLen);
1: 
1: 			// Make a copy of the relevant part of rowArray
1: 			for (int i = 0; i < minLen; ++i) {
1: 				if (resultRowArray[i] != null && heapOnly.isSet(i)) {
1: 					rowArray[i] = resultRowArray[i];
1: 	}
commit:2700e3d
/////////////////////////////////////////////////////////////////////////
0: 	// for scrollable insensitive updatable result sets, the rowLocation of each
0: 	// row is stored in a hash table, and used to position the scan by calling 
0: 	// the method positionScanAtRowLocation. When this method is called, the 
0: 	// baseRowLocation will be set to the value of the cached rowLocation, and
0: 	// it will not be necessary to read the row from the B-tree in order to get
0: 	// the rowLocation of the current row.
0: 	// If positionFromRowLocation is true, then baseRowLocation can be used for
0: 	// fetching the currentRow, and it is not necessary to read the rowLocation
0: 	// from the B-tree, otherwise, the rowLocation must be read from the B-tree.
0: 	private boolean positionFromRowLocation;
1: 
/////////////////////////////////////////////////////////////////////////
0: 		this.positionFromRowLocation = false;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 * @see NoPutResultSet#positionScanAtRowLocation
1: 	 * 
1: 	 * Also remembers row location so that subsequent invocations of
1: 	 * getCurrentRow will not read the index row to look up the row
1: 	 * location base row, but reuse the saved row location.
1: 	 */
1: 	public void positionScanAtRowLocation(RowLocation rl) 
1: 		throws StandardException 
1: 	{
1: 		baseRowLocation = rl;
0: 		positionFromRowLocation = true;
1: 		source.positionScanAtRowLocation(rl);
1: 	}
1: 
1: 	/**	 * Gets last row returned.
/////////////////////////////////////////////////////////////////////////
0: 		// If positionFromRowLocation is true, we can use the baseRowLocation
0: 		// directly and do not need to read the rowLocation from the b-tree
0: 		// before fetching the row.
0: 		if (positionFromRowLocation) {
1: 			sourceRow = activation.getExecutionFactory().
1: 					getValueRow(indexCols.length);
1: 			sourceRow.setRowArray(rowArray);
1: 			// Fetch the columns coming from the heap
1: 			boolean row_exists = 
1: 				baseCC.fetch(
1: 					baseRowLocation, rowArray, (FormatableBitSet) null);
1: 			if (row_exists) {
1: 				setCurrentRow(sourceRow);
1: 			} else {
1: 				clearCurrentRow();
0: 				currentRow = null;
1: 			}
1: 			return currentRow;
1: 		}
1: 		
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7c3cc82
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.impl.sql.GenericPreparedStatement;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:49f3f24
/////////////////////////////////////////////////////////////////////////
1: 		getCompactRow(resultRow, accessedAllCols, false);
commit:7008b63
/////////////////////////////////////////////////////////////////////////
1: 		recordConstructorTime();
commit:f77f36d
/////////////////////////////////////////////////////////////////////////
1: class IndexRowToBaseRowResultSet extends NoPutResultSetImpl
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     IndexRowToBaseRowResultSet(
/////////////////////////////////////////////////////////////////////////
0: 					double optimizerEstimatedCost) 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
1: 
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
1: 
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1: 
1: /**
1:  * Takes a result set with a RowLocation as the last column, and uses the
1:  * RowLocation to get and return a row from the given base conglomerate.
1:  * Normally, the input result set will be a TableScanResultSet scanning an
1:  * index conglomerate.
1:  *
0:  * @author jeff
1:  */
0: public class IndexRowToBaseRowResultSet extends NoPutResultSetImpl
1: 	implements CursorResultSet {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1:     // set in constructor and not altered during
1:     // life of object.
0: 	private long conglomId;
1:     public NoPutResultSet source;
0: 	private GeneratedMethod resultRowAllocator;
1: 	private GeneratedMethod restriction;
0:     private long baseConglomId;
0:     private GeneratedMethod closeCleanup;
1: 	public FormatableBitSet accessedHeapCols;
0: 	private FormatableBitSet accessedIndexCols;
1: 	//caching accessed columns (heap+index) beetle 3865
1: 	private FormatableBitSet accessedAllCols;
1: 	public String indexName;
1: 	private int[] indexCols;
1: 	private DynamicCompiledOpenConglomInfo dcoci;
1: 	private StaticCompiledOpenConglomInfo scoci;
1: 
1: 	// set in open() and not changed after that
1: 	private ConglomerateController	baseCC;
1: 	private boolean                 closeBaseCCHere;
0: 	private ExecRow					resultRow;
0: 	private ExecRow					compactRow;
1: 	private boolean					forUpdate;
1: 	private DataValueDescriptor[]	rowArray;
1: 
1: 	// changed a whole bunch
1: 	RowLocation	baseRowLocation;
1: 
1: 	/* Remember whether or not we have copied any
1: 	 * columns from the source row to our row yet.
1: 	 */
1: 	boolean copiedFromSource;
1: 
1: 	/* Run time statistics variables */
1: 	public long restrictionTime;
1: 
0: 	protected boolean currentRowPrescanned;
0: 	private boolean sourceIsForUpdateIndexScan;
1: 
1:     //
1:     // class interface
1:     //
0:     public IndexRowToBaseRowResultSet(
1: 					long conglomId,
1: 					int scociItem,
1: 					Activation a,
1: 					NoPutResultSet source,
0: 					GeneratedMethod resultRowAllocator,
1: 					int resultSetNumber,
1: 					String indexName,
1: 					int heapColRefItem,
0: 					int indexColRefItem,
1: 					int indexColMapItem,
1: 					GeneratedMethod restriction,
1: 					boolean forUpdate,
1: 					double optimizerEstimatedRowCount,
0: 					double optimizerEstimatedCost,
0: 					GeneratedMethod closeCleanup) 
1: 		throws StandardException
1: 	{
1: 		super(a, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost);
0:         scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
0: 						getSavedObject(scociItem));
1: 		TransactionController tc = activation.getTransactionController();
1: 		dcoci = tc.getDynamicCompiledConglomInfo(conglomId);
1:         this.source = source;
0: 		this.resultRowAllocator = resultRowAllocator;
1: 		this.indexName = indexName;
1: 		this.forUpdate = forUpdate;
1: 		this.restriction = restriction;
1: 
1: 		/* RESOLVE - once we push Qualifiers into the store we
1: 		 * need to clear their Orderable cache on each open/reopen.
1: 		 */
0:         this.closeCleanup = closeCleanup;
1: 
1: 		// retrieve the valid column list from
1: 		// the saved objects, if it exists
0: 		this.accessedHeapCols = null;
0: 		if (heapColRefItem != -1)
1: 		{
0: 			this.accessedHeapCols = (FormatableBitSet)(a.getPreparedStatement().
0: 						getSavedObject(heapColRefItem));
1: 		}
0: 		if (indexColRefItem != -1)
1: 		{
0: 			this.accessedIndexCols = (FormatableBitSet)(a.getPreparedStatement().
0: 						getSavedObject(indexColRefItem));
1: 		}
0: 		if (accessedIndexCols == null)
0: 			accessedAllCols = accessedHeapCols;
1: 		else
1: 		{
0: 			accessedAllCols = new FormatableBitSet(accessedHeapCols);
0: 			accessedAllCols.or(accessedIndexCols);
1: 		}
1: 			
1: 		// retrieve the array of columns coming from the index
0: 		indexCols = ((ReferencedColumnsDescriptorImpl) (a.getPreparedStatement().
0: 						getSavedObject(indexColMapItem))).getReferencedColumnPositions();
1: 
1: 		/* Get the result row template */
0: 		resultRow = (ExecRow) resultRowAllocator.invoke(activation);
1: 
0: 		compactRow =
0: 			getCompactRow(resultRow,
0: 							accessedHeapCols,
0: 							accessedIndexCols,
0: 							false);
1: 
1: 		/* If there's no partial row bit map, then we want the entire
1: 		 * row, otherwise we need to diddle with the row array so that
1: 		 * we only get the columns coming from the heap on the fetch.
1: 		 */
0: 		if (accessedHeapCols == null)
1: 		{
1: 			rowArray = resultRow.getRowArray();
1: 		}
1: 		else
1: 		{
1: 			// Figure out how many columns are coming from the heap
0: 			int arraySize = accessedHeapCols.getNumBitsSet();
0: 			int accessedHeapColsSize = accessedHeapCols.size();
1: 
0: 			rowArray = new DataValueDescriptor[accessedHeapColsSize];
1: 
0: 			// Now, fill in rowArray with the desired columns
0: 			int partialIndex = 0;
0: 			int numFromIndex = 0;
0: 			for (int index = 0; index < accessedHeapColsSize; index++)
1: 			{
0: 				if (accessedIndexCols != null && accessedIndexCols.get(index))
1: 				{
0: 					numFromIndex++;
0: 					continue;
1: 				}
0: 				if (accessedHeapCols.get(index))
1: 				{
0: 					rowArray[index] =
0: 						resultRow.getRowArray()[index];
0: 					partialIndex++;
1: 				}
1: 			}
1: 		}
1: 
0: 		constructorTime += getElapsedMillis(beginTime);
1:     }
1: 
1: 	//
1: 	// ResultSet interface (leftover from NoPutResultSet)
1: 	//
1: 
1: 	/**
1:      * open this ResultSet.
1: 	 *
1: 	 * @exception StandardException thrown if cursor finished.
1:      */
1: 	public void	openCore() throws StandardException 
1: 	{
1: 		boolean						lockingRequired = false;
1: 		TransactionController		tc;
1: 
1: 		// REVISIT: through the direct DB API, this needs to be an
1: 		// error, not an ASSERT; users can open twice. Only through JDBC
1: 		// is access to open controlled and ensured valid.
1: 		if (SanityManager.DEBUG)
1: 		{
1: 	    	SanityManager.ASSERT( ! isOpen,
1: 								"IndexRowToBaseRowResultSet already open");
1: 		}
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 
1: 		source.openCore();
0: 		if ((source instanceof TableScanResultSet) && 
0: 			((TableScanResultSet) source).indexCols != null)
0: 			sourceIsForUpdateIndexScan = true;
1: 
1: 		/* Get a ConglomerateController for the base conglomerate 
1: 		 * NOTE: We only need to acquire locks on the data pages when
1: 		 * going through the index when we are at READ COMMITTED and
1: 		 * the source is a BulkTableScan or HashScan.  (The underlying
1: 		 * row will not be guaranteed to be locked.)
1: 		 */
1: 		if (source.requiresRelocking())
1: 		{
1: 			lockingRequired = true;
1: 		}
1: 
1: 		tc = activation.getTransactionController();
1: 
1: 		int openMode;
1: 		int isolationLevel;
1: 		
1: 		if (forUpdate)
1: 		{
1: 			openMode = TransactionController.OPENMODE_FORUPDATE;
1: 		}
1: 		else
1: 		{
1: 			openMode = 0;
1: 		}
1: 		isolationLevel = source.getScanIsolationLevel();
1: 
1: 		if (!lockingRequired)
1: 		{
1:             // flag indicates that lock has already been acquired by access to
1:             // the secondary index, and need not be gotten again in the base
1:             // table.
1: 			openMode |= TransactionController.OPENMODE_SECONDARY_LOCKED;
1: 		}
1: 		
1: 		/* Try to get the ConglomerateController from the activation
1: 		 * first, for the case that we are part of an update or delete.
1: 		 * If so, then the RowChangerImpl did the correct locking.
1: 		 * If not there, then we go off and open it ourself.
1: 		 */
1: 		if (forUpdate)
1: 		{
1: 			baseCC = activation.getHeapConglomerateController();
1: 		}
1: 
1: 		if (baseCC == null)
1: 		{
1: 			baseCC = 
1: 		        tc.openCompiledConglomerate(
1:                     activation.getResultSetHoldability(),
1: 				    openMode,
1: 					// consistent with FromBaseTable's updateTargetLockMode
1: 					TransactionController.MODE_RECORD,
1: 	                isolationLevel,
1: 					scoci,
1: 					dcoci);
1: 			closeBaseCCHere = true;
1: 		}
1: 
1: 		isOpen = true;
1: 		numOpens++;
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1: 	 * reopen this ResultSet.
1: 	 *
1: 	 * @exception StandardException thrown if cursor finished.
1: 	 */
1: 	public void	reopenCore() throws StandardException {
1: 		TransactionController		tc;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(isOpen,
1: 					"IndexRowToBaseRowResultSet already open");
1: 		}
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 
1: 		source.reopenCore();
1: 
1: 		numOpens++;
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1:      * Return the requested values computed
1:      * from the next row (if any) for which
1:      * the restriction evaluates to true.
1:      * <p>
1:      * restriction and projection parameters
1:      * are evaluated for each row.
1: 	 *
1: 	 * @exception StandardException thrown on failure.
1: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
1: 	 *
1: 	 * @return the next row in the result
1: 	 */
1: 	public ExecRow	getNextRowCore() throws StandardException {
1: 
1: 	    ExecRow sourceRow = null;
1: 		ExecRow retval = null;
1: 	    boolean restrict = false;
1: 	    DataValueDescriptor restrictBoolean;
1: 		long	beginRT = 0;
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 	    if ( ! isOpen ) {
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
1: 		}
1: 
0: 		/* beetle 3865, updateable cursor using index.  When in-memory hash table was full, we
0: 		 * read forward and saved future row id's in a virtual-memory-like temp table.  So if
0: 		 * we have rid's saved, and we are here, it must be non-covering index.  Intercept it
0: 		 * here, so that we don't have to go to underlying index scan.  We get both heap cols
0: 		 * and index cols together here for better performance.
1: 		 */
0: 		if (sourceIsForUpdateIndexScan && ((TableScanResultSet) source).futureForUpdateRows != null)
1: 		{
0: 			currentRowPrescanned = false;
0: 			TableScanResultSet src = (TableScanResultSet) source;
1: 
0: 			if (src.futureRowResultSet == null)
1: 			{
0: 				src.futureRowResultSet = (TemporaryRowHolderResultSet) src.futureForUpdateRows.getResultSet();
0: 				src.futureRowResultSet.openCore();
1: 			}
1: 
0: 			ExecRow ridRow = src.futureRowResultSet.getNextRowCore();
1: 
0: 			currentRow = null;
1: 
0: 			if (ridRow != null)
1: 			{
0: 				/* To maximize performance, we only use virtual memory style heap, no
0: 				 * position index is ever created.  And we save and retrieve rows from the
0: 				 * in-memory part of the heap as much as possible.  We can also insert after
0: 				 * we start retrieving, the assumption is that we delete the current row right
0: 				 * after we retrieve it.
1: 				 */
0: 				src.futureRowResultSet.deleteCurrentRow();
0: 				baseRowLocation = (RowLocation) ridRow.getColumn(1);
0:                	baseCC.fetch(
0:                   	      baseRowLocation, compactRow.getRowArray(), accessedAllCols);
1: 
1: 				currentRow = compactRow;
0: 				currentRowPrescanned = true;
1: 			}
0: 			else if (src.sourceDrained)
0: 				currentRowPrescanned = true;
1: 
0: 			if (currentRowPrescanned)
1: 			{
0: 				setCurrentRow(currentRow);
1: 
1: 				nextTime += getElapsedMillis(beginTime);
0: 	 	   		return currentRow;
1: 			}
1: 		}
1: 
1: 		/* Loop until we get a row from the base page that qualifies or
1: 		 * there's no more rows from the index that qualify. (If the RID
1: 		 * returned by the index does not qualify, then we have to go back
1: 		 * to the index to see if there is another RID to consider.)
1: 		 */
1: 		do 
1: 		{
1: 			sourceRow = source.getNextRowCore();
1: 
1: 			if (sourceRow != null) {
1: 
1: 				if (SanityManager.DEBUG) {
1: 					SanityManager.ASSERT(
1: 						sourceRow.getColumn(sourceRow.nColumns())
1: 														instanceof RowLocation,
1: 						"Last column of source row is not a RowLocation"
1: 							);
1: 				}
1: 
1: 				baseRowLocation = (RowLocation)
1: 						sourceRow.getColumn(sourceRow.nColumns());
1: 
1: 				// Fetch the columns coming from the heap
1: 				boolean row_exists = 
0:                     baseCC.fetch(
0:                         baseRowLocation, rowArray, accessedHeapCols);
1: 
1:                 if (row_exists)
1:                 {
1: 					/* We only need to copy columns from the index row 
1: 					 * to our result row once as we will be reusing the
1: 					 * wrappers in that case.
1: 					 * NOTE: When the underlying ResultSet got an 
1: 					 * instantaneous lock (BulkTableScan or HashScan)
1: 					 * then we will be getting all of the columns anew
1: 					 * from the index (indexCols == null).
1: 					 */
1: 					if (! copiedFromSource)
1: 					{
1: 						copiedFromSource = true;
1: 
1: 						// Copy the columns coming from the index into resultRow
1: 						for (int index = 0; index < indexCols.length; index++)
1: 						{
1: 							if (indexCols[index] != -1)
1: 							{
1: 								compactRow.setColumn(
1: 											index + 1,
1: 											sourceRow.getColumn(indexCols[index] + 1));
1: 							}
1: 						}
1: 					}
1: 
1:                     setCurrentRow(compactRow);
1: 
1:                     restrictBoolean = (DataValueDescriptor) 
1:                         ((restriction == null) ? 
1:                              null : restriction.invoke(activation));
1: 
1:                     restrictionTime += getElapsedMillis(beginRT);
1: 
1:                     // if the result is null, we make it false --
1:                     // so the row won't be returned.
1:                     restrict = (restrictBoolean == null) ||
1:                                 ((! restrictBoolean.isNull()) &&
1:                                     restrictBoolean.getBoolean());
1:                 }
1: 
1: 				if (! restrict || ! row_exists)
1: 				{
1: 					rowsFiltered++;
1: 					clearCurrentRow();
1: 					baseRowLocation = null;
1: 
0: 					currentRow = null;
1: 				}
1: 				else
1: 				{
1: 					currentRow = compactRow;
1: 				}
1: 
1: 				/* Update the run time statistics */
1: 				rowsSeen++;
1: 
1: 				retval = currentRow;
1: 		    } else {
0: 				currentRow = null;
1: 				clearCurrentRow();
1: 				baseRowLocation = null;
1: 
1: 				retval = null;
1: 			}
1: 	    } 
1: 		while ( (sourceRow != null) && (! restrict ) );
1: 
1: 		nextTime += getElapsedMillis(beginTime);
1:     	return retval;
1: 	}
1: 
1: 	/**
1: 	 * If the result set has been opened,
1: 	 * close the open scan.
1: 	 *
1: 	 * @exception StandardException thrown on error
1: 	 */
1: 	public void	close() throws StandardException
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 	    if ( isOpen ) {
1: 
1: 			// we don't want to keep around a pointer to the
1: 			// row ... so it can be thrown away.
1: 			// REVISIT: does this need to be in a finally
1: 			// block, to ensure that it is executed?
1: 	    	clearCurrentRow();
0: 			if (closeCleanup != null) {
0: 				closeCleanup.invoke(activation); // let activation tidy up
1: 			}
0: 			currentRow = null;
1: 			if (closeBaseCCHere)
1: 			{
1:                 // This check should only be needed in the error case where
1:                 // we may call this close() routine as part of transaction
1:                 // backout cleanup if any of the following routines fail.
1:                 // If one of the subsequent statements gets an error, we
1:                 // will try to close this result set as part of transaction
1:                 // cleanup, and without this check we get a null pointer
1:                 // exception because we have null'd out baseCC.
1:               
1:                 if (baseCC != null)
1:                     baseCC.close();
1: 			}
1: 
1: 			/* Make sure to null out baseCC since
1: 			 * we check for null baseCC after looking
1: 			 * in the StatementContext.
1: 			 */
1: 			baseCC = null;
1: 	        source.close();
1: 
1: 			super.close();
1: 	    }
1: 		else if (SanityManager.DEBUG) {
1: 			SanityManager.DEBUG("CloseRepeatInfo","Close of IndexRowToBaseRowResultSet repeated");
1: 		}
1: 
1: 		closeTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1: 	 * Return the total amount of time spent in this ResultSet
1: 	 *
1: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1: 	 *
1: 	 * @return long		The total amount of time spent (in milliseconds).
1: 	 */
1: 	public long getTimeSpent(int type)
1: 	{
1: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1: 
1: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1: 		{
1: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
1: 		}
1: 		else
1: 		{
1: 			return totTime;
1: 		}
1: 	}
1: 
1: 	//
1: 	// CursorResultSet interface
1: 	//
1: 	/**
1: 	 * Return the RowLocation of the base row.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the row location of the current cursor row.
1: 	 * @exception StandardException thrown on failure.
1: 	 */
1: 	public RowLocation getRowLocation() throws StandardException {
1: 		return baseRowLocation;
1: 	}
1: 
1: 	/**
0: 	 * Gets last row returned.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the last row returned.
1: 	 * @exception StandardException thrown on failure.
1: 	 */
1: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1: 	 * once there is such a method.  (currentRow is redundant)
1: 	 */
1: 	public ExecRow getCurrentRow() throws StandardException {
1: 	    ExecRow sourceRow = null;
1: 
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(isOpen,
1: 					"IndexRowToBaseRowResultSet is expected to be open");
1: 		}
1: 
0: 		if (currentRowPrescanned)
0: 			return currentRow;
1: 
1: 		/* Nothing to do if we're not currently on a row */
1: 		if (currentRow == null)
1: 		{
1: 			return null;
1: 		}
1: 
0: 		/* Call the child result set to get it's current row.
0: 		 * If no row exists, then return null, else requalify it
0: 		 * before returning.
1: 		 */
0: 		sourceRow = ((CursorResultSet) source).getCurrentRow();
0: 		if (sourceRow != null)
1: 		{
1: 			/*
0: 			** Presumably, if the index row is still there, the RowLocation
0: 			** it contains is still valid.  This means we don't have to
0: 			** check whether the row is still there.
1: 			*/
1: 			if (SanityManager.DEBUG) {
1: 				SanityManager.ASSERT(
1: 					sourceRow.getColumn(sourceRow.nColumns())
1: 														instanceof RowLocation,
1: 					"Last column of source row is not a RowLocation"
1: 						);
1: 			}
1: 
1: 			baseRowLocation = (RowLocation)
1: 						sourceRow.getColumn(sourceRow.nColumns());
1: 
1: 			// Fetch the columns coming from the heap
1: 			boolean row_exists = 
0:                 baseCC.fetch(
0:                     baseRowLocation, rowArray, (FormatableBitSet) null);
1: 
1:             if (row_exists)
1:             {
1: 				// Copy the columns coming from the index into resultRow
1: 				for (int index = 0; index < indexCols.length; index++)
1: 				{
1: 					if (indexCols[index] != -1)
1: 					{
1: 						compactRow.setColumn(
1: 										index + 1,
1: 										sourceRow.getColumn(indexCols[index] + 1));
1: 					}
1: 				}
1: 
1:                 setCurrentRow(compactRow);
1: 
1:                 currentRow = compactRow;
1:             }
1:             else
1:             {
1:                 clearCurrentRow();
1: 
0:                 currentRow = null;
1:             }
1: 
1:         } else {
1: 			clearCurrentRow();
1: 
0: 			currentRow = null;
1: 		}
1: 		
0: 		return currentRow;
1: 	}
1: 
1: 	/**
1: 	 * Is this ResultSet or it's source result set for update.
1: 	 * beetle 3865: updateable cursor using index scan.  We didn't need this function
1: 	 * before because we couldn't use index for update cursor.
1: 	 * 
1: 	 * @return Whether or not the result set is for update.
1: 	 */
1: 	public boolean isForUpdate()
1: 	{
1: 		return source.isForUpdate();
1: 	}
1: 
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:f4fc366
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		// We do not need to read the row from the index first, since we already 
1: 		// have the rowLocation of the current row and can read it directly from 
1: 		// the heap.
0: 		sourceRow = activation.getExecutionFactory().
0: 				getValueRow(indexCols.length);
0: 		sourceRow.setRowArray(rowArray);
0: 		// Fetch the columns coming from the heap
0: 		boolean row_exists = 
0: 			baseCC.fetch(
0: 				baseRowLocation, rowArray, (FormatableBitSet) null);
0: 		if (row_exists) {
0: 			setCurrentRow(sourceRow);
0: 		} else {
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
0: 
0: /**
0:  * Takes a result set with a RowLocation as the last column, and uses the
0:  * RowLocation to get and return a row from the given base conglomerate.
0:  * Normally, the input result set will be a TableScanResultSet scanning an
0:  * index conglomerate.
0:  *
0:  * @author jeff
0:  */
0: public class IndexRowToBaseRowResultSet extends NoPutResultSetImpl
0: 	implements CursorResultSet {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0:     // set in constructor and not altered during
0:     // life of object.
0: 	private long conglomId;
0:     public NoPutResultSet source;
0: 	private GeneratedMethod resultRowAllocator;
0: 	private GeneratedMethod restriction;
0:     private long baseConglomId;
0:     private GeneratedMethod closeCleanup;
0: 	public FormatableBitSet accessedHeapCols;
0: 	private FormatableBitSet accessedIndexCols;
0: 	//caching accessed columns (heap+index) beetle 3865
0: 	private FormatableBitSet accessedAllCols;
0: 	public String indexName;
0: 	private int[] indexCols;
0: 	private DynamicCompiledOpenConglomInfo dcoci;
0: 	private StaticCompiledOpenConglomInfo scoci;
0: 
0: 	// set in open() and not changed after that
0: 	private ConglomerateController	baseCC;
0: 	private boolean                 closeBaseCCHere;
0: 	private ExecRow					resultRow;
0: 	private ExecRow					compactRow;
0: 	private boolean					forUpdate;
0: 	private DataValueDescriptor[]	rowArray;
0: 
0: 	// changed a whole bunch
0: 	RowLocation	baseRowLocation;
0: 
0: 	/* Remember whether or not we have copied any
0: 	 * columns from the source row to our row yet.
0: 	 */
0: 	boolean copiedFromSource;
0: 
0: 	/* Run time statistics variables */
0: 	public long restrictionTime;
0: 
0: 	protected boolean currentRowPrescanned;
0: 	private boolean sourceIsForUpdateIndexScan;
0: 
0:     //
0:     // class interface
0:     //
0:     public IndexRowToBaseRowResultSet(
0: 					long conglomId,
0: 					int scociItem,
0: 					Activation a,
0: 					NoPutResultSet source,
0: 					GeneratedMethod resultRowAllocator,
0: 					int resultSetNumber,
0: 					String indexName,
0: 					int heapColRefItem,
0: 					int indexColRefItem,
0: 					int indexColMapItem,
0: 					GeneratedMethod restriction,
0: 					boolean forUpdate,
0: 					double optimizerEstimatedRowCount,
0: 					double optimizerEstimatedCost,
0: 					GeneratedMethod closeCleanup) 
0: 		throws StandardException
0: 	{
0: 		super(a, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost);
0:         scoci = (StaticCompiledOpenConglomInfo)(activation.getPreparedStatement().
0: 						getSavedObject(scociItem));
0: 		TransactionController tc = activation.getTransactionController();
0: 		dcoci = tc.getDynamicCompiledConglomInfo(conglomId);
0:         this.source = source;
0: 		this.resultRowAllocator = resultRowAllocator;
0: 		this.indexName = indexName;
0: 		this.forUpdate = forUpdate;
0: 		this.restriction = restriction;
0: 
0: 		/* RESOLVE - once we push Qualifiers into the store we
0: 		 * need to clear their Orderable cache on each open/reopen.
0: 		 */
0:         this.closeCleanup = closeCleanup;
0: 
0: 		// retrieve the valid column list from
0: 		// the saved objects, if it exists
0: 		this.accessedHeapCols = null;
0: 		if (heapColRefItem != -1)
0: 		{
0: 			this.accessedHeapCols = (FormatableBitSet)(a.getPreparedStatement().
0: 						getSavedObject(heapColRefItem));
0: 		}
0: 		if (indexColRefItem != -1)
0: 		{
0: 			this.accessedIndexCols = (FormatableBitSet)(a.getPreparedStatement().
0: 						getSavedObject(indexColRefItem));
0: 		}
0: 		if (accessedIndexCols == null)
0: 			accessedAllCols = accessedHeapCols;
0: 		else
0: 		{
0: 			accessedAllCols = new FormatableBitSet(accessedHeapCols);
0: 			accessedAllCols.or(accessedIndexCols);
0: 		}
0: 			
0: 		// retrieve the array of columns coming from the index
0: 		indexCols = ((ReferencedColumnsDescriptorImpl) (a.getPreparedStatement().
0: 						getSavedObject(indexColMapItem))).getReferencedColumnPositions();
0: 
0: 		/* Get the result row template */
0: 		resultRow = (ExecRow) resultRowAllocator.invoke(activation);
0: 
0: 		compactRow =
0: 			getCompactRow(resultRow,
0: 							accessedHeapCols,
0: 							accessedIndexCols,
0: 							false);
0: 
0: 		/* If there's no partial row bit map, then we want the entire
0: 		 * row, otherwise we need to diddle with the row array so that
0: 		 * we only get the columns coming from the heap on the fetch.
0: 		 */
0: 		if (accessedHeapCols == null)
0: 		{
0: 			rowArray = resultRow.getRowArray();
0: 		}
0: 		else
0: 		{
0: 			// Figure out how many columns are coming from the heap
0: 			int arraySize = accessedHeapCols.getNumBitsSet();
0: 			int accessedHeapColsSize = accessedHeapCols.size();
0: 
0: 			rowArray = new DataValueDescriptor[accessedHeapColsSize];
0: 
0: 			// Now, fill in rowArray with the desired columns
0: 			int partialIndex = 0;
0: 			int numFromIndex = 0;
0: 			for (int index = 0; index < accessedHeapColsSize; index++)
0: 			{
0: 				if (accessedIndexCols != null && accessedIndexCols.get(index))
0: 				{
0: 					numFromIndex++;
0: 					continue;
0: 				}
0: 				if (accessedHeapCols.get(index))
0: 				{
0: 					rowArray[index] =
0: 						resultRow.getRowArray()[index];
0: 					partialIndex++;
0: 				}
0: 			}
0: 		}
0: 
0: 		constructorTime += getElapsedMillis(beginTime);
0:     }
0: 
0: 	//
0: 	// ResultSet interface (leftover from NoPutResultSet)
0: 	//
0: 
0: 	/**
0:      * open this ResultSet.
0: 	 *
0: 	 * @exception StandardException thrown if cursor finished.
0:      */
0: 	public void	openCore() throws StandardException 
0: 	{
0: 		boolean						lockingRequired = false;
0: 		TransactionController		tc;
0: 
0: 		// REVISIT: through the direct DB API, this needs to be an
0: 		// error, not an ASSERT; users can open twice. Only through JDBC
0: 		// is access to open controlled and ensured valid.
0: 		if (SanityManager.DEBUG)
0: 		{
0: 	    	SanityManager.ASSERT( ! isOpen,
0: 								"IndexRowToBaseRowResultSet already open");
0: 		}
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 
0: 		source.openCore();
0: 		if ((source instanceof TableScanResultSet) && 
0: 			((TableScanResultSet) source).indexCols != null)
0: 			sourceIsForUpdateIndexScan = true;
0: 
0: 		/* Get a ConglomerateController for the base conglomerate 
0: 		 * NOTE: We only need to acquire locks on the data pages when
0: 		 * going through the index when we are at READ COMMITTED and
0: 		 * the source is a BulkTableScan or HashScan.  (The underlying
0: 		 * row will not be guaranteed to be locked.)
0: 		 */
0: 		if (source.requiresRelocking())
0: 		{
0: 			lockingRequired = true;
0: 		}
0: 
0: 		tc = activation.getTransactionController();
0: 
0: 		int openMode;
0: 		int isolationLevel;
0: 		
0: 		if (forUpdate)
0: 		{
0: 			openMode = TransactionController.OPENMODE_FORUPDATE;
0: 		}
0: 		else
0: 		{
0: 			openMode = 0;
0: 		}
0: 		isolationLevel = source.getScanIsolationLevel();
0: 
0: 		if (!lockingRequired)
0: 		{
0:             // flag indicates that lock has already been acquired by access to
0:             // the secondary index, and need not be gotten again in the base
0:             // table.
0: 			openMode |= TransactionController.OPENMODE_SECONDARY_LOCKED;
0: 		}
0: 		
0: 		/* Try to get the ConglomerateController from the activation
0: 		 * first, for the case that we are part of an update or delete.
0: 		 * If so, then the RowChangerImpl did the correct locking.
0: 		 * If not there, then we go off and open it ourself.
0: 		 */
0: 		if (forUpdate)
0: 		{
0: 			baseCC = activation.getHeapConglomerateController();
0: 		}
0: 
0: 		if (baseCC == null)
0: 		{
0: 			baseCC = 
0: 		        tc.openCompiledConglomerate(
0:                     activation.getResultSetHoldability(),
0: 				    openMode,
0: 					// consistent with FromBaseTable's updateTargetLockMode
0: 					TransactionController.MODE_RECORD,
0: 	                isolationLevel,
0: 					scoci,
0: 					dcoci);
0: 			closeBaseCCHere = true;
0: 		}
0: 
0: 		isOpen = true;
0: 		numOpens++;
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0: 	 * reopen this ResultSet.
0: 	 *
0: 	 * @exception StandardException thrown if cursor finished.
0: 	 */
0: 	public void	reopenCore() throws StandardException {
0: 		TransactionController		tc;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(isOpen,
0: 					"IndexRowToBaseRowResultSet already open");
0: 		}
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 
0: 		source.reopenCore();
0: 
0: 		numOpens++;
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0:      * Return the requested values computed
0:      * from the next row (if any) for which
0:      * the restriction evaluates to true.
0:      * <p>
0:      * restriction and projection parameters
0:      * are evaluated for each row.
0: 	 *
0: 	 * @exception StandardException thrown on failure.
0: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
0: 	 *
0: 	 * @return the next row in the result
0: 	 */
0: 	public ExecRow	getNextRowCore() throws StandardException {
0: 
0: 	    ExecRow sourceRow = null;
0: 		ExecRow retval = null;
0: 	    boolean restrict = false;
0: 	    DataValueDescriptor restrictBoolean;
0: 		long	beginRT = 0;
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 	    if ( ! isOpen ) {
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
0: 		}
0: 
0: 		/* beetle 3865, updateable cursor using index.  When in-memory hash table was full, we
0: 		 * read forward and saved future row id's in a virtual-memory-like temp table.  So if
0: 		 * we have rid's saved, and we are here, it must be non-covering index.  Intercept it
0: 		 * here, so that we don't have to go to underlying index scan.  We get both heap cols
0: 		 * and index cols together here for better performance.
0: 		 */
0: 		if (sourceIsForUpdateIndexScan && ((TableScanResultSet) source).futureForUpdateRows != null)
0: 		{
0: 			currentRowPrescanned = false;
0: 			TableScanResultSet src = (TableScanResultSet) source;
0: 
0: 			if (src.futureRowResultSet == null)
0: 			{
0: 				src.futureRowResultSet = (TemporaryRowHolderResultSet) src.futureForUpdateRows.getResultSet();
0: 				src.futureRowResultSet.openCore();
0: 			}
0: 
0: 			ExecRow ridRow = src.futureRowResultSet.getNextRowCore();
0: 
0: 			currentRow = null;
0: 
0: 			if (ridRow != null)
0: 			{
0: 				/* To maximize performance, we only use virtual memory style heap, no
0: 				 * position index is ever created.  And we save and retrieve rows from the
0: 				 * in-memory part of the heap as much as possible.  We can also insert after
0: 				 * we start retrieving, the assumption is that we delete the current row right
0: 				 * after we retrieve it.
0: 				 */
0: 				src.futureRowResultSet.deleteCurrentRow();
0: 				baseRowLocation = (RowLocation) ridRow.getColumn(1);
0:                	baseCC.fetch(
0:                   	      baseRowLocation, compactRow.getRowArray(), accessedAllCols);
0: 
0: 				currentRow = compactRow;
0: 				currentRowPrescanned = true;
0: 			}
0: 			else if (src.sourceDrained)
0: 				currentRowPrescanned = true;
0: 
0: 			if (currentRowPrescanned)
0: 			{
0: 				setCurrentRow(currentRow);
0: 
0: 				nextTime += getElapsedMillis(beginTime);
0: 	 	   		return currentRow;
0: 			}
0: 		}
0: 
0: 		/* Loop until we get a row from the base page that qualifies or
0: 		 * there's no more rows from the index that qualify. (If the RID
0: 		 * returned by the index does not qualify, then we have to go back
0: 		 * to the index to see if there is another RID to consider.)
0: 		 */
0: 		do 
0: 		{
0: 			sourceRow = source.getNextRowCore();
0: 
0: 			if (sourceRow != null) {
0: 
0: 				if (SanityManager.DEBUG) {
0: 					SanityManager.ASSERT(
0: 						sourceRow.getColumn(sourceRow.nColumns())
0: 														instanceof RowLocation,
0: 						"Last column of source row is not a RowLocation"
0: 							);
0: 				}
0: 
0: 				baseRowLocation = (RowLocation)
0: 						sourceRow.getColumn(sourceRow.nColumns());
0: 
0: 				// Fetch the columns coming from the heap
0: 				boolean row_exists = 
0:                     baseCC.fetch(
0:                         baseRowLocation, rowArray, accessedHeapCols);
0: 
0:                 if (row_exists)
0:                 {
0: 					/* We only need to copy columns from the index row 
0: 					 * to our result row once as we will be reusing the
0: 					 * wrappers in that case.
0: 					 * NOTE: When the underlying ResultSet got an 
0: 					 * instantaneous lock (BulkTableScan or HashScan)
0: 					 * then we will be getting all of the columns anew
0: 					 * from the index (indexCols == null).
0: 					 */
0: 					if (! copiedFromSource)
0: 					{
0: 						copiedFromSource = true;
0: 
0: 						// Copy the columns coming from the index into resultRow
0: 						for (int index = 0; index < indexCols.length; index++)
0: 						{
0: 							if (indexCols[index] != -1)
0: 							{
0: 								compactRow.setColumn(
0: 											index + 1,
0: 											sourceRow.getColumn(indexCols[index] + 1));
0: 							}
0: 						}
0: 					}
0: 
0:                     setCurrentRow(compactRow);
0: 
0:                     restrictBoolean = (DataValueDescriptor) 
0:                         ((restriction == null) ? 
0:                              null : restriction.invoke(activation));
0: 
0:                     restrictionTime += getElapsedMillis(beginRT);
0: 
0:                     // if the result is null, we make it false --
0:                     // so the row won't be returned.
0:                     restrict = (restrictBoolean == null) ||
0:                                 ((! restrictBoolean.isNull()) &&
0:                                     restrictBoolean.getBoolean());
0:                 }
0: 
0: 				if (! restrict || ! row_exists)
0: 				{
0: 					rowsFiltered++;
0: 					clearCurrentRow();
0: 					baseRowLocation = null;
0: 
0: 					currentRow = null;
0: 				}
0: 				else
0: 				{
0: 					currentRow = compactRow;
0: 				}
0: 
0: 				/* Update the run time statistics */
0: 				rowsSeen++;
0: 
0: 				retval = currentRow;
0: 		    } else {
0: 				currentRow = null;
0: 				clearCurrentRow();
0: 				baseRowLocation = null;
0: 
0: 				retval = null;
0: 			}
0: 	    } 
0: 		while ( (sourceRow != null) && (! restrict ) );
0: 
0: 		nextTime += getElapsedMillis(beginTime);
0:     	return retval;
0: 	}
0: 
0: 	/**
0: 	 * If the result set has been opened,
0: 	 * close the open scan.
0: 	 *
0: 	 * @exception StandardException thrown on error
0: 	 */
0: 	public void	close() throws StandardException
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 	    if ( isOpen ) {
0: 
0: 			// we don't want to keep around a pointer to the
0: 			// row ... so it can be thrown away.
0: 			// REVISIT: does this need to be in a finally
0: 			// block, to ensure that it is executed?
0: 	    	clearCurrentRow();
0: 			if (closeCleanup != null) {
0: 				closeCleanup.invoke(activation); // let activation tidy up
0: 			}
0: 			currentRow = null;
0: 			if (closeBaseCCHere)
0: 			{
0:                 // This check should only be needed in the error case where
0:                 // we may call this close() routine as part of transaction
0:                 // backout cleanup if any of the following routines fail.
0:                 // If one of the subsequent statements gets an error, we
0:                 // will try to close this result set as part of transaction
0:                 // cleanup, and without this check we get a null pointer
0:                 // exception because we have null'd out baseCC.
0:               
0:                 if (baseCC != null)
0:                     baseCC.close();
0: 			}
0: 
0: 			/* Make sure to null out baseCC since
0: 			 * we check for null baseCC after looking
0: 			 * in the StatementContext.
0: 			 */
0: 			baseCC = null;
0: 	        source.close();
0: 
0: 			super.close();
0: 	    }
0: 		else if (SanityManager.DEBUG) {
0: 			SanityManager.DEBUG("CloseRepeatInfo","Close of IndexRowToBaseRowResultSet repeated");
0: 		}
0: 
0: 		closeTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0: 	 * Return the total amount of time spent in this ResultSet
0: 	 *
0: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
0: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
0: 	 *
0: 	 * @return long		The total amount of time spent (in milliseconds).
0: 	 */
0: 	public long getTimeSpent(int type)
0: 	{
0: 		long totTime = constructorTime + openTime + nextTime + closeTime;
0: 
0: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
0: 		{
0: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
0: 		}
0: 		else
0: 		{
0: 			return totTime;
0: 		}
0: 	}
0: 
0: 	//
0: 	// CursorResultSet interface
0: 	//
0: 	/**
0: 	 * Return the RowLocation of the base row.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the row location of the current cursor row.
0: 	 * @exception StandardException thrown on failure.
0: 	 */
0: 	public RowLocation getRowLocation() throws StandardException {
0: 		return baseRowLocation;
0: 	}
0: 
0: 	/**
0: 	 * Gets last row returned.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the last row returned.
0: 	 * @exception StandardException thrown on failure.
0: 	 */
0: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
0: 	 * once there is such a method.  (currentRow is redundant)
0: 	 */
0: 	public ExecRow getCurrentRow() throws StandardException {
0: 	    ExecRow sourceRow = null;
0: 
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(isOpen,
0: 					"IndexRowToBaseRowResultSet is expected to be open");
0: 		}
0: 
0: 		if (currentRowPrescanned)
0: 			return currentRow;
0: 
0: 		/* Nothing to do if we're not currently on a row */
0: 		if (currentRow == null)
0: 		{
0: 			return null;
0: 		}
0: 
0: 		/* Call the child result set to get it's current row.
0: 		 * If no row exists, then return null, else requalify it
0: 		 * before returning.
0: 		 */
0: 		sourceRow = ((CursorResultSet) source).getCurrentRow();
0: 		if (sourceRow != null)
0: 		{
0: 			/*
0: 			** Presumably, if the index row is still there, the RowLocation
0: 			** it contains is still valid.  This means we don't have to
0: 			** check whether the row is still there.
0: 			*/
0: 			if (SanityManager.DEBUG) {
0: 				SanityManager.ASSERT(
0: 					sourceRow.getColumn(sourceRow.nColumns())
0: 														instanceof RowLocation,
0: 					"Last column of source row is not a RowLocation"
0: 						);
0: 			}
0: 
0: 			baseRowLocation = (RowLocation)
0: 						sourceRow.getColumn(sourceRow.nColumns());
0: 
0: 			// Fetch the columns coming from the heap
0: 			boolean row_exists = 
0:                 baseCC.fetch(
0:                     baseRowLocation, rowArray, (FormatableBitSet) null);
0: 
0:             if (row_exists)
0:             {
0: 				// Copy the columns coming from the index into resultRow
0: 				for (int index = 0; index < indexCols.length; index++)
0: 				{
0: 					if (indexCols[index] != -1)
0: 					{
0: 						compactRow.setColumn(
0: 										index + 1,
0: 										sourceRow.getColumn(indexCols[index] + 1));
0: 					}
0: 				}
0: 
0:                 setCurrentRow(compactRow);
0: 
0:                 currentRow = compactRow;
0:             }
0:             else
0:             {
0:                 clearCurrentRow();
0: 
0:                 currentRow = null;
0:             }
0: 
0:         } else {
0: 			clearCurrentRow();
0: 
0: 			currentRow = null;
0: 		}
0: 		
0: 		return currentRow;
0: 	}
0: 
0: 	/**
0: 	 * Is this ResultSet or it's source result set for update.
0: 	 * beetle 3865: updateable cursor using index scan.  We didn't need this function
0: 	 * before because we couldn't use index for update cursor.
0: 	 * 
0: 	 * @return Whether or not the result set is for update.
0: 	 */
0: 	public boolean isForUpdate()
0: 	{
0: 		return source.isForUpdate();
0: 	}
0: 
0: }
============================================================================