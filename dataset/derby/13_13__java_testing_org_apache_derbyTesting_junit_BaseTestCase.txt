1:b350a56: /*
4:b350a56:  *
1:92a2169:  * Derby - Class org.apache.derbyTesting.junit.BaseTestCase
1:b350a56:  *
1:15651f5:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:15651f5:  * contributor license agreements.  See the NOTICE file distributed with
1:15651f5:  * this work for additional information regarding copyright ownership.
1:15651f5:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:15651f5:  * (the "License"); you may not use this file except in compliance with
1:15651f5:  * the License.  You may obtain a copy of the License at
1:b350a56:  *
1:b350a56:  *    http://www.apache.org/licenses/LICENSE-2.0
1:b350a56:  *
1:b350a56:  * Unless required by applicable law or agreed to in writing, 
1:b350a56:  * software distributed under the License is distributed on an 
1:b350a56:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:b350a56:  * either express or implied. See the License for the specific 
1:b350a56:  * language governing permissions and limitations under the License.
4:b350a56:  */
1:3bd1dd8: package org.apache.derbyTesting.junit;
1:59a5a70: 
1:cf8e7ff: import org.apache.derbyTesting.functionTests.harness.JavaVersionHolder;
1:d773139: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1:044179c: import junit.framework.Assert;
1:b350a56: import junit.framework.TestCase;
1:4d8deb6: import junit.framework.AssertionFailedError;
1:b85a450: 
1:db2c1c2: import java.io.BufferedInputStream;
1:d2b9c54: import java.io.File;
1:db2c1c2: import java.io.FileInputStream;
1:db2c1c2: import java.io.FileNotFoundException;
1:4c5c16b: import java.io.FilenameFilter;
1:1bb2ac5: import java.io.IOException;
1:1bb2ac5: import java.io.InputStream;
1:1bb2ac5: import java.io.Reader;
1:37952cf: import java.io.PrintStream;
1:fe7db0f: import java.io.PrintWriter;
1:482ff80: import java.io.InterruptedIOException;
1:482ff80: import java.io.RandomAccessFile;
1:8ad67d3: import java.lang.reflect.Field;
1:7d98408: import java.net.URL;
1:37952cf: import java.sql.SQLException;
1:cccb382: import java.security.AccessController;
1:db2c1c2: import java.security.PrivilegedAction;
1:044179c: import java.security.PrivilegedExceptionAction;
1:8f56d99: 
1:cccb382: import java.security.PrivilegedActionException;
1:ce62de6: import java.util.ArrayList;
3:23a4538: 
1:23a4538: 
1:dd07790: /**
1:b350a56:  * Base class for JUnit tests.
1:37952cf:  */
1:576a49f: public abstract class BaseTestCase
1:b350a56:     extends TestCase {
1:ccf708c: 
1:273ad5f:     private static final String JACOCO_AGENT_PROP = "derby.tests.jacoco.agent";
1:3b4b552: 
1:ccf708c:     protected final static String ERRORSTACKTRACEFILE = "error-stacktrace.out";
1:ccf708c:     protected final static String DEFAULT_DB_DIR      = "system";
1:ccf708c:     protected final static String DERBY_LOG           = "derby.log";
1:f5c1abd:     
1:f5c1abd:     private static int debugPort; // default 8800
1:dd07790:     /**
1:b350a56:      * No argument constructor made private to enforce naming of test cases.
1:b350a56:      * According to JUnit documentation, this constructor is provided for
1:b350a56:      * serialization, which we don't currently use.
1:cccb382:      *
1:b350a56:      * @see #BaseTestCase(String)
1:37952cf:      */
1:b350a56:     private BaseTestCase() {}
1:3b4b552: 
1:7d98408:     /**
1:b350a56:      * Create a test case with the given name.
1:b350a56:      *
1:b350a56:      * @param name name of the test case.
1:cccb382:      */
1:b350a56:     public BaseTestCase(String name) {
1:b350a56:         super(name);
1:305a23d:     }
1:dcfc481:     
1:8ad67d3:     /**
1:7d98408:      * Run the test and force installation of a security
1:7d98408:      * manager with the default test policy file.
1:7d98408:      * Individual tests can run without a security
1:7d98408:      * manager or with a different policy file using
1:7d98408:      * the decorators obtained from SecurityManagerSetup.
1:7d98408:      * <BR>
1:7d98408:      * Method is final to ensure security manager is
1:7d98408:      * enabled by default. Tests should not need to
1:d2b9c54:      * override runTest, instead use test methods
1:7d98408:      * setUp, tearDown methods and decorators.
1:23a4538:      */
1:f8fd911:     public void runBare() throws Throwable {
1:3450bb7:         TestConfiguration config = getTestConfiguration();
1:3450bb7:         boolean trace = config.doTrace();
1:68e06ac:         boolean stopAfterFirstFail = config.stopAfterFirstFail();
1:8cd67f5:         long startTime = 0;
1:8cd67f5:         if ( trace )
1:514ee1d:         {
1:8cd67f5:             startTime = System.currentTimeMillis();
1:8cd67f5:             out.println();
1:3983707:             String  junitClassName = this.getClass().getName();
1:3983707:             junitClassName=Utilities.formatTestClassNames(junitClassName);
1:3983707:             out.print(traceClientType());
1:3983707:             out.print(junitClassName+"."+getName() + " ");
1:b2dc02c:         }
1:514ee1d: 
1:59a5a70:         // install a default security manager if one has not already been
1:59a5a70:         // installed
1:59a5a70:         if ( System.getSecurityManager() == null )
1:514ee1d:         {
1:3450bb7:             if (config.defaultSecurityManagerSetup())
1:59a5a70:             {
1:b85a450:                 assertSecurityManager();
1:59a5a70:             }
1:59a5a70:         }
1:f6df184: 
1:8cd67f5:         try {
1:8cd67f5:             super.runBare();   
1:6756142:         }
1:fe7db0f:         // To log the exception to file, copy the derby.log file and copy
1:fe7db0f:         // the database of the failed test.
1:02c8976:         catch (Throwable running) {
1:fe7db0f:             PrintWriter stackOut = null;
1:b85a450:             try{
1:d773139:                 String failPath = PrivilegedFileOpsForTests.getAbsolutePath(getFailureFolder());
1:fe7db0f:                 // Write the stack trace of the error/failure to file.
1:fe7db0f:                 stackOut = new PrintWriter(
1:fe7db0f:                         PrivilegedFileOpsForTests.getFileOutputStream(
1:ccf708c:                             new File(failPath, ERRORSTACKTRACEFILE), true));
1:fe7db0f:                 stackOut.println("[Error/failure logged at " +
1:fe7db0f:                         new java.util.Date() + "]");
1:fe7db0f:                 running.printStackTrace(stackOut);
1:fe7db0f:                 stackOut.println(); // Add an extra blank line.
1:fe7db0f:                 // Copy the derby.log file.
1:ccf708c:                 File origLog = new File(DEFAULT_DB_DIR, DERBY_LOG);
1:ccf708c:                 File newLog = new File(failPath, DERBY_LOG);
1:d773139:                 PrivilegedFileOpsForTests.copy(origLog, newLog);
1:ccf120c:                 // Copy some other likely files, the rolling log files
1:ccf120c:                 // These might occur if the tests are run with 
1:ccf120c:                 // derby.stream.error.style=rollingFile
1:ccf120c:                 for (int i=0; i < 10; i++) {
1:ccf120c:                     String logName = "derby-" + i + ".log";
1:ccf120c:                     File origRolLog = new File(DEFAULT_DB_DIR, logName);
1:ccf120c:                     File newRolLog = new File(failPath, logName);
1:ccf120c:                     PrivilegedFileOpsForTests.copy(origRolLog, newRolLog);
1:8cd67f5:                 }
1:fe7db0f:                 // Copy the database.
1:d773139:                 String dbName = TestConfiguration.getCurrent().getDefaultDatabaseName();
1:ccf708c:                 File dbDir = new File(DEFAULT_DB_DIR, dbName );
1:d773139:                 File newDbDir = new File(failPath, dbName);
1:d773139:                 PrivilegedFileOpsForTests.copy(dbDir,newDbDir);
1:8cd67f5:            }
1:d773139:             catch (IOException ioe) {
1:d773139:                 // We need to throw the original exception so if there
1:fe7db0f:                 // is an exception saving the db or derby.log we will print it
1:fe7db0f:                 // and additionally try to log it to file.
1:d773139:                 BaseTestCase.printStackTrace(ioe);
1:fe7db0f:                 if (stackOut != null) {
1:fe7db0f:                     stackOut.println("Copying derby.log or database failed:");
1:fe7db0f:                     ioe.printStackTrace(stackOut);
1:fe7db0f:                     stackOut.println();
1:ccf120c:                 }
1:b85a450:             }
1:d773139:             finally {
1:fe7db0f:                 if (stackOut != null) {
1:fe7db0f:                     stackOut.close();
1:b85a450:                 }
1:68e06ac:                 if (stopAfterFirstFail) {
1:68e06ac:                     // if run with -Dderby.tests.stopAfterFirstFail=true
1:68e06ac:                     // exit after reporting failure. Useful for debugging
1:68e06ac:                     // cascading failures or errors that lead to hang.
1:68e06ac:                     running.printStackTrace(out);
1:68e06ac:                     System.exit(1);
1:b85a450:                 }
1:63c65ac:                 else
1:b85a450:                     throw running;
1:02c8976:             }
1:02c8976:         }
1:8cd67f5:         finally{
1:8cd67f5:             if ( trace )
1:59a5a70:             {
1:8cd67f5:                 long timeUsed = System.currentTimeMillis() - startTime;
1:1e0eabf:                 out.print("used " + timeUsed + " ms ");
1:8cd67f5:             }
1:8cd67f5:         }
1:68e06ac:     }
1:c939828: 
1:8badf99:     /**
1:dd07790:      * Return the current configuration for the test.
1:f23a20f:      */
1:dd07790:     public final TestConfiguration getTestConfiguration()
1:8cd67f5:     {
1:e0104e8:     	return TestConfiguration.getCurrent();
1:d773139:     }
1:b2dc02c:     
1:177992f:     /**
1:d2b9c54:      * Get the folder where a test leaves any information
1:d2b9c54:      * about its failure.
1:d2b9c54:      * @return Folder to use.
1:d2b9c54:      * @see TestConfiguration#getFailureFolder(TestCase)
1:73122ce:      */
1:d2b9c54:     public final File getFailureFolder() {
1:d2b9c54:         return getTestConfiguration().getFailureFolder(this);
1:273ad5f:     }
1:63c65ac:     
1:044179c:     /**
1:37952cf:      * Print alarm string
1:37952cf:      * @param text String to print
1:d2b9c54:      */
1:37952cf:     public static void alarm(final String text) {
1:37952cf:         out.println("ALARM: " + text);
1:273ad5f:     }
1:02c8976: 
1:8f56d99:     /**
1:37952cf:      * Print debug string.
1:37952cf:      * @param text String to print
1:dd07790:      */
1:37952cf:     public static void println(final String text) {
1:e0104e8:         if (TestConfiguration.getCurrent().isVerbose()) {
1:37952cf:             out.println("DEBUG: " + text);
1:2520683:             out.flush();
1:273ad5f:         }
1:afe4dfd:     }
1:02c8976: 
1:f23a20f:     /**
1:daa4827:      * Print trace string.
1:daa4827:      * @param text String to print
1:daa4827:      */
1:daa4827:     public static void traceit(final String text) {
1:daa4827:         if (TestConfiguration.getCurrent().doTrace()) {
1:daa4827:             out.println(text);
1:daa4827:         }
1:daa4827:     }
1:daa4827: 
1:daa4827:     /**
1:37952cf:      * Print debug string.
1:37952cf:      * @param t Throwable object to print stack trace from
1:7d98408:      */
1:37952cf:     public static void printStackTrace(Throwable t) 
1:8cd67f5:     {
1:37952cf:         while ( t!= null) {
1:37952cf:             t.printStackTrace(out);
1:4aef9b0:             out.flush();
1:044179c:             
1:37952cf:             if (t instanceof SQLException)  {
1:37952cf:                 t = ((SQLException) t).getNextException();
1:3983707:             } else {
1:b85a450:                 break;
1:02c8976:             }
1:a0f4b68:         }
1:afe4dfd:     }
1:02c8976: 
1:37952cf:     private final static PrintStream out = System.out;
1:c393694: 
1:c393694:     /**
1:c393694:      * Change the value of {@code System.out}.
1:c393694:      *
1:c393694:      * @param out the new stream
1:c393694:      */
1:aba4ea1:     protected static void setSystemOut(final PrintStream out) {
1:c393694:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:c393694:             public Void run() {
1:c393694:                 System.setOut(out);
1:c393694:                 return null;
1:c393694:             }
1:c393694:         });
1:c393694:     }
1:c393694: 
1:c393694:     /**
1:c393694:      * Change the value of {@code System.err}.
1:c393694:      *
1:c393694:      * @param err the new stream
1:c393694:      */
1:aba4ea1:     protected static void setSystemErr(final PrintStream err) {
1:c393694:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:c393694:             public Void run() {
1:c393694:                 System.setErr(err);
1:c393694:                 return null;
1:c393694:             }
1:c393694:         });
1:c393694:     }
1:c393694: 
1:63c65ac:     /**
1:cccb382:      * Set system property
1:3b4b552:      *
1:cccb382:      * @param name name of the property
1:cccb382:      * @param value value of the property
1:37952cf:      */
1:cccb382:     protected static void setSystemProperty(final String name, 
1:cccb382: 					    final String value)
1:044179c:     {
1:2510115:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:2510115:             public Void run() {
1:2510115:                 System.setProperty(name, value);
1:2510115:                 return null;
1:2510115:             }
1:2510115:         });
1:afe4dfd:     }
1:2510115: 
1:273ad5f:     /**
1:7d98408:      * Remove system property
1:7d98408:      *
1:7d98408:      * @param name name of the property
1:7d98408:      */
1:5107349:     public static void removeSystemProperty(final String name)
1:044179c: 	{
1:2510115:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:2510115:             public Void run() {
1:2510115:                 System.getProperties().remove(name);
1:2510115:                 return null;
1:2510115:             }
1:2510115:         });
1:2510115:     }
1:2510115: 
1:056eff7:     /**
1:177992f:      * Get system property.
1:177992f:      *
1:177992f:      * @param name name of the property
1:177992f:      */
1:177992f:     protected static String getSystemProperty(final String name)
1:8f56d99: 	{
1:2510115:         return AccessController.doPrivileged(new PrivilegedAction<String>() {
1:2510115:             public String run() {
1:2510115:                 return System.getProperty(name);
1:2510115:             }
1:2510115:         });
1:177992f:     }
1:177992f:     
1:4c5c16b:     /**
1:4c5c16b:      * Get files in a directory which contain certain prefix
1:4c5c16b:      * 
1:4c5c16b:      * @param dir
1:4c5c16b:      *        The directory we are checking for files with certain prefix
1:4c5c16b:      * @param prefix
1:4c5c16b:      *        The prefix pattern we are interested.
1:7b17fca:      * @return The list indicates files with certain prefix.
1:4c5c16b:      */
1:4c5c16b:     protected static String[] getFilesWith(final File dir, String prefix) {
1:2510115:         return AccessController.doPrivileged(new PrivilegedAction<String[]>() {
1:2510115:                     public String[] run() {
1:4c5c16b:                         //create a FilenameFilter and override its accept-method to file
1:4c5c16b:                         //files start with "javacore"*
1:4c5c16b:                         FilenameFilter filefilter = new FilenameFilter() {
1:4c5c16b:                             public boolean accept(File dir, String name) {
1:4c5c16b:                                 //if the file has prefix javacore return true, else false
1:4c5c16b:                                 return name.startsWith("javacore");
1:177992f:                             }
1:4c5c16b:                         };
1:4c5c16b:                         return dir.list(filefilter);
1:afe4dfd:                     }
1:b85a450:                 });
1:3983707:     }
1:177992f:     
1:4c5c16b:     /**
1:7d98408:      * Obtain the URL for a test resource, e.g. a policy
1:7d98408:      * file or a SQL script.
1:7d98408:      * @param name Resource name, typically - org.apache.derbyTesing.something
1:7d98408:      * @return URL to the resource, null if it does not exist.
1:7d98408:      */
1:7d98408:     protected static URL getTestResource(final String name)
1:4c5c16b: 	{
1:2510115:         return AccessController.doPrivileged(new PrivilegedAction<URL>() {
1:2510115:             public URL run() {
1:2510115:                 return BaseTestCase.class.getClassLoader().getResource(name);
1:2510115:             }
1:2510115:         });
1:2510115:     }
1:177992f:   
1:26ed4f9:     /**
1:dd07790:      * Open the URL for a a test resource, e.g. a policy
1:dd07790:      * file or a SQL script.
1:dd07790:      * @param url URL obtained from getTestResource
1:dd07790:      * @return An open stream
1:dd07790:     */
1:dd07790:     protected static InputStream openTestResource(final URL url)
1:dd07790:         throws PrivilegedActionException
1:26ed4f9:     {
1:2510115:         return AccessController.doPrivileged(
1:2510115:                 new PrivilegedExceptionAction<InputStream>() {
1:2510115:             public InputStream run() throws IOException {
1:2510115:                 return url.openStream();
1:2510115:             }
1:2510115:         });
1:3983707:     }
1:177992f:     
1:d2b9c54:     /**
1:7d98408:      * Assert a security manager is installed.
1:7d98408:      *
1:7d98408:      */
1:7d98408:     public static void assertSecurityManager()
1:26ed4f9:     {
1:7d98408:     	assertNotNull("No SecurityManager installed",
1:7d98408:     			System.getSecurityManager());
3:73122ce:     }
1:1bb2ac5: 
1:1bb2ac5:     /**
1:1bb2ac5:      * Compare the contents of two streams.
1:1bb2ac5:      * The streams are closed after they are exhausted.
1:1bb2ac5:      *
1:1bb2ac5:      * @param is1 the first stream
1:1bb2ac5:      * @param is2 the second stream
1:1bb2ac5:      * @throws IOException if reading from the streams fail
1:1bb2ac5:      * @throws AssertionFailedError if the stream contents are not equal
1:1bb2ac5:      */
1:1bb2ac5:     public static void assertEquals(InputStream is1, InputStream is2)
1:1bb2ac5:             throws IOException {
1:1bb2ac5:         if (is1 == null || is2 == null) {
1:1bb2ac5:             assertNull("InputStream is2 is null, is1 is not", is1);
1:1bb2ac5:             assertNull("InputStream is1 is null, is2 is not", is2);
1:1bb2ac5:             return;
1:1bb2ac5:         }
1:1bb2ac5:         long index = 0;
1:1bb2ac5:         int b1 = is1.read();
1:1bb2ac5:         int b2 = is2.read();
1:1bb2ac5:         do {
1:1bb2ac5:             // Avoid string concatenation for every byte in the stream.
1:1bb2ac5:             if (b1 != b2) {
1:1bb2ac5:                 assertEquals("Streams differ at index " + index, b1, b2);
1:1bb2ac5:             }
1:1bb2ac5:             index++;
1:1bb2ac5:             b1 = is1.read();
1:1bb2ac5:             b2 = is2.read();
1:1bb2ac5:         } while (b1 != -1 || b2 != -1);
1:1bb2ac5:         is1.close();
1:1bb2ac5:         is2.close();
1:1bb2ac5:     }
1:1bb2ac5: 
1:1bb2ac5:     /**
1:1bb2ac5:      * Compare the contents of two readers.
1:1bb2ac5:      * The readers are closed after they are exhausted.
1:1bb2ac5:      *
1:1bb2ac5:      * @param r1 the first reader
1:1bb2ac5:      * @param r2 the second reader
1:1bb2ac5:      * @throws IOException if reading from the streams fail
1:1bb2ac5:      * @throws AssertionFailedError if the reader contents are not equal
1:1bb2ac5:      */
1:1bb2ac5:     public static void assertEquals(Reader r1, Reader r2)
1:1bb2ac5:             throws IOException {
1:1bb2ac5:         long index = 0;
1:1bb2ac5:         if (r1 == null || r2 == null) {
1:1bb2ac5:             assertNull("Reader r2 is null, r1 is not", r1);
1:1bb2ac5:             assertNull("Reader r1 is null, r2 is not", r2);
1:1bb2ac5:             return;
1:1bb2ac5:         }
1:1bb2ac5:         int c1 = r1.read();
1:1bb2ac5:         int c2 = r2.read();
1:1bb2ac5:         do {
1:1bb2ac5:             // Avoid string concatenation for every char in the stream.
1:1bb2ac5:             if (c1 != c2) {
1:1bb2ac5:                 assertEquals("Streams differ at index " + index, c1, c2);
1:1bb2ac5:             }
1:1bb2ac5:             index++;
1:1bb2ac5:             c1 = r1.read();
1:1bb2ac5:             c2 = r2.read();
1:1bb2ac5:         } while (c1 != -1 || c2 != -1);
1:1bb2ac5:         r1.close();
1:1bb2ac5:         r2.close();
1:1bb2ac5:     }
1:b2c1772: 
1:b2c1772:     /**
1:b2c1772:      * Assert that the detailed messages of the 2 passed-in Throwable's are
1:b2c1772:      * equal (rather than '=='), as well as their class types.
1:b2c1772:      *
1:b2c1772:      * @param t1 first throwable to compare
1:b2c1772:      * @param t2 second throwable to compare
1:b2c1772:      */
1:b2c1772:     public static void assertThrowableEquals(Throwable t1,
1:b2c1772:                                              Throwable t2) {
1:b2c1772:         // Ensure non-null throwable's are being passed.
1:b2c1772:         assertNotNull(
1:b2c1772:             "Passed-in throwable t1 cannot be null to assert detailed message",
1:b2c1772:             t1);
1:b2c1772:         assertNotNull(
1:b2c1772:             "Passed-in throwable t2 cannot be null to assert detailed message",
1:b2c1772:             t2);
1:b2c1772: 
1:b2c1772:         // Now verify that the passed-in throwable are of the same type
1:b2c1772:         assertEquals("Throwable class types are different",
1:b2c1772:                      t1.getClass().getName(), t2.getClass().getName());
1:b2c1772: 
1:b2c1772:         // Here we finally check that the detailed message of both
1:b2c1772:         // throwable's is the same
1:b2c1772:         assertEquals("Detailed messages of the throwable's are different",
1:b2c1772:                      t1.getMessage(), t2.getMessage());
1:b2c1772:     }
1:63c65ac:     
1:7d98408:     /**
1:0b0a105:      * <p>
1:6b23802:      * Assert the equivalence of two byte arrays.
1:6b23802:      * </p>
1:6b23802:      */
1:6b23802:     public  static  void    assertEquals( byte[] expected, byte[] actual )
1:6b23802:     {
1:6b23802:         if ( assertSameNullness( expected, actual ) ) { return; }
1:6b23802:         
1:6b23802:         assertEquals( expected.length, actual.length );
1:6b23802:         for ( int i = 0; i < expected.length; i++ )
1:6b23802:         {
1:6b23802:             assertEquals( Integer.toString( i ), expected[ i ], actual[ i ] );
1:6b23802:         }
1:6b23802:     }
1:6b23802: 
1:6b23802:     /**
1:6b23802:      * Assert that two objects are either both null or neither null.
1:6b23802:      * Returns true if they are null.
1:6b23802:      */
1:6b23802:     public  static  boolean assertSameNullness( Object expected, Object actual )
1:6b23802:     {
1:6b23802:         if ( expected ==  null )
1:6b23802:         {
1:6b23802:             assertNull( actual );
1:6b23802:             return true;
1:6b23802:         }
1:6b23802:         else
1:6b23802:         {
1:6b23802:             assertNotNull( actual );
1:6b23802:             return false;
1:6b23802:         }
1:6b23802:     }
1:6b23802: 
1:6b23802:     /**
1:6b23802:      * <p>
1:0b0a105:      * Assert the equivalence of two int arrays.
1:0b0a105:      * </p>
1:0b0a105:      */
1:0b0a105:     public  static  void    assertEquals( int[] expected, int[] actual )
1:0b0a105:     {
1:6b23802:         if ( assertSameNullness( expected, actual ) ) { return; }
1:6b23802:         
1:0b0a105:         assertEquals( expected.length, actual.length );
1:0b0a105:         for ( int i = 0; i < expected.length; i++ )
1:0b0a105:         {
1:0b0a105:             assertEquals( Integer.toString( i ), expected[ i ], actual[ i ] );
1:0b0a105:         }
1:0b0a105:     }
1:0b0a105: 
1:0b0a105:     /**
1:0b0a105:      * <p>
1:0b0a105:      * Assert the equivalence of two long arrays.
1:0b0a105:      * </p>
1:0b0a105:      */
1:0b0a105:     public  static  void    assertEquals( long[] expected, long[] actual )
1:0b0a105:     {
1:6b23802:         if ( assertSameNullness( expected, actual ) ) { return; }
1:6b23802:         
1:0b0a105:         assertEquals( expected.length, actual.length );
1:0b0a105:         for ( int i = 0; i < expected.length; i++ )
1:0b0a105:         {
1:0b0a105:             assertEquals( Integer.toString( i ), expected[ i ], actual[ i ] );
1:0b0a105:         }
1:0b0a105:     }
1:0b0a105: 
1:0b0a105:     /**
1:db2c1c2:      * Assert that two files in the filesystem are identical.
1:db2c1c2:      * 
1:db2c1c2:      * @param file1 the first file to compare
1:db2c1c2:      * @param file2 the second file to compare
1:db2c1c2:      */
1:db2c1c2: 	public static void assertEquals(final File file1, final File file2) {
1:7d98408: 		AccessController.doPrivileged
1:2510115:         (new PrivilegedAction<Void>() {
1:2510115:         	public Void run() {
1:d96e3aa:         		try {
1:db2c1c2: 					InputStream f1 = new BufferedInputStream(new FileInputStream(file1));
1:db2c1c2: 					InputStream f2 = new BufferedInputStream(new FileInputStream(file2));
1:3b4b552: 
1:db2c1c2: 					assertEquals(f1, f2);
1:db2c1c2: 				} catch (FileNotFoundException e) {
1:db2c1c2: 					fail("FileNotFoundException in assertEquals(File,File): " + e.getMessage());
1:db2c1c2: 					e.printStackTrace();
1:db2c1c2: 				} catch (IOException e) {
1:db2c1c2: 					fail("IOException in assertEquals(File, File): " + e.getMessage());
1:db2c1c2: 					e.printStackTrace();
1:a0f4b68: 				}
1:b85a450: 				return null;
1:a0f4b68:         	}
1:02c8976:         });
1:a0f4b68: 	}
1:3b4b552:     
1:7d98408: 	/**
1:63c65ac: 	 * Execute command using 'java' executable and verify that it completes
1:63c65ac: 	 * with expected results
1:63c65ac: 	 * @param expectedString String to compare the resulting output with. May be
1:63c65ac: 	 *     null if the output is not expected to be of interest.
1:63c65ac: 	 * @param cmd array of java arguments for command
1:63c65ac: 	 * @param expectedExitValue expected return value from the command
1:63c65ac: 	 * @throws InterruptedException
1:63c65ac: 	 * @throws IOException
1:63c65ac: 	 */
1:d9857c0: 	public static void assertExecJavaCmdAsExpected(String[] expectedString,
1:63c65ac: 	        String[] cmd, int expectedExitValue) throws InterruptedException,
1:63c65ac: 	        IOException {
1:63c65ac: 
1:63c65ac: 	    Process pr = execJavaCmd(cmd);
1:63c65ac: 	    String output = readProcessOutput(pr);
1:63c65ac: 	    int exitValue = pr.exitValue();
1:8f56d99: 	    String expectedStrings = "";
1:8f56d99: 	    for (int i = 0; i < expectedString.length; i++) 
1:8f56d99: 	        expectedStrings += "\t[" +i + "]" + expectedString[i] +  "\n";
1:da92693: 	    Assert.assertEquals("expectedExitValue:" + expectedExitValue +
1:da92693: 	            " does not match exitValue:" + exitValue +"\n" +
1:8f56d99: 	            "expected output strings:\n" + expectedStrings + 
1:da92693: 	            " actual output:" + output,
1:da92693: 	            expectedExitValue, exitValue);
1:63c65ac: 	    if (expectedString != null) {
1:63c65ac: 	        for (int i = 0; i < expectedString.length; i++) {
1:fe374c1: 	            assertTrue("Could not find expectedString:" +
1:281d7e6: 	                    expectedString[i] + " in output:" + output,
1:fe374c1: 	                    output.indexOf(expectedString[i]) >= 0);
1:63c65ac: 	        }
1:63c65ac: 	    }
1:63c65ac: 	}
1:63c65ac: 
1:63c65ac:     /**
1:dff2bf5:      * Same as {@link #execJavaCmd( String, String, String[], File, boolean )}
1:8ad67d3:      * but with {@code addClassPath == true}.
1:8ad67d3:      */
1:8ad67d3:     public static Process execJavaCmd(
1:8ad67d3:         String jvm, String cp, String[] cmd, final File dir)
1:8ad67d3:             throws IOException {
1:8ad67d3:         return execJavaCmd(jvm, cp, cmd, dir, true);
1:8ad67d3:     }
1:3919c52: 
1:3b4b552: 	/**
1:63c65ac: 	 * Execute a java command and return the process.
1:63c65ac: 	 * The caller should decide what to do with the process, if anything,
1:63c65ac: 	 * typical activities would be to do a pr.waitFor, or to
1:63c65ac: 	 * get a getInputStream or getErrorStream
1:63c65ac: 	 * Note, that for verifying the output of a Java process, there is
1:63c65ac: 	 * assertExecJavaCmdAsExpected
1:63c65ac: 	 * 
1:e437bc3:      * @param jvm the path to the java executable, or {@code null} to use
1:e437bc3:      *            the default executable returned by
1:e437bc3:      *            {@link #getJavaExecutableName()}
1:e437bc3:      * @param cp  the classpath for the spawned process, or {@code null} to
1:e437bc3:      *            inherit the classpath from the parent process
1:63c65ac: 	 * @param cmd array of java arguments for command
1:f0951ab:      * @param dir working directory for the sub-process, or {@code null} to
1:f0951ab:      *            run in the same directory as the main test process
1:8ad67d3:      * @param addClassPath if {@code true},add classpath
1:63c65ac: 	 * @return the process that was started
1:63c65ac: 	 * @throws IOException
1:63c65ac: 	 */
1:e437bc3:     public static Process execJavaCmd(
1:8ad67d3:         String jvm, String cp, String[] cmd, final File dir, boolean addClassPath)
1:f0951ab:             throws IOException {
1:63c65ac: 
1:3919c52:         // Is this an invocation of a jar file with java -jar ...?
1:3919c52:         final boolean isJarInvocation = cmd.length > 0 && cmd[0].equals("-jar");
1:3919c52: 
1:2510115: 	    ArrayList<String> cmdlist = new ArrayList<String>();
1:e437bc3:         cmdlist.add(jvm == null ? getJavaExecutableName() : jvm);
1:ce62de6: 	    if (isJ9Platform())
1:510d4fb: 	    {
1:ce62de6: 	        cmdlist.add("-jcl:foun11");
1:510d4fb:             // also add the setting for emma.active so any tests
1:510d4fb:             // that fork will work correctly. See DERBY-5558.
1:510d4fb:             String emmaactive=getSystemProperty("emma.active");
1:305a23d:             if (emmaactive != null) {
1:510d4fb:                 cmdlist.add("-Demma.active=" + emmaactive);            
1:510d4fb:             }
1:305a23d:             // Do the same for jacoco.active, see DERBY-6079.
1:305a23d:             String jacocoactive = getSystemProperty("jacoco.active");
1:305a23d:             if (jacocoactive != null) {
1:305a23d:                 cmdlist.add("-Djacoco.active=" + jacocoactive);
1:63c65ac:             }
1:b85a450: 	    }
1:b2dc02c: 
1:b2dc02c:         if (isCVM()) {
1:b2dc02c:             // DERBY-5642: The default maximum heap size on CVM is very low.
1:b2dc02c:             // Increase it to prevent OOME in the forked process.
1:b2dc02c:             cmdlist.add("-Xmx32M");
1:b2dc02c:         }
1:b2dc02c: 
1:b9e0e74:         if (runsWithEmma()) {
1:b9e0e74:             // DERBY-5801: If many processes write to the same file, it may
1:b9e0e74:             // end up corrupted. Let each process have its own file to which
1:b9e0e74:             // it writes coverage data.
1:b9e0e74:             cmdlist.add("-Demma.coverage.out.file=" + getEmmaOutFile());
1:9902875: 
1:9902875:             // DERBY-5810: Make sure that emma.jar is included on the
1:9902875:             // classpath of the sub-process. (Only needed if a specific
1:9902875:             // classpath has been specified. Otherwise, the sub-process
1:9902875:             // inherits the classpath from the parent process, which
1:9902875:             // already includes emma.jar.)
1:9902875:             if (cp != null) {
1:9902875:                 cp += File.pathSeparator + getEmmaJar().getPath();
1:9902875:             }
1:3919c52: 
1:3919c52:             // DERBY-5821: When starting a sub-process with java -jar, the
1:3919c52:             // classpath argument will be ignored, so we cannot add emma.jar
1:3919c52:             // that way. Add it to the boot classpath instead.
1:3919c52:             if (isJarInvocation) {
1:3919c52:                 cmdlist.add("-Xbootclasspath/a:" + getEmmaJar().getPath());
1:3919c52:             }
1:b9e0e74:         }
1:b9e0e74: 
1:273ad5f:         if (runsWithJaCoCo()) {
1:273ad5f:             // Property (http://www.eclemma.org/jacoco/trunk/doc/agent.html):
1:273ad5f:             // -javaagent:[yourpath/]jacocoagent.jar=[opt1]=[val1],[opt2]=[val2]
1:273ad5f:             String agent = getSystemProperty(JACOCO_AGENT_PROP);
1:273ad5f:             cmdlist.add(agent + (agent.endsWith("=") ? "": ",") +
1:273ad5f:                     "destfile=" + getJaCoCoOutFile());
1:3be8464:             cmdlist.add("-Djacoco.active=");
1:b85a450:         }
1:63c65ac: 
1:f5c1abd:         if (isSunJVM() && Boolean.valueOf(
1:f5c1abd:                     getSystemProperty("derby.test.debugSubprocesses")).
1:f5c1abd:                 booleanValue()) {
1:f5c1abd:             setupForDebuggerAttach(cmdlist);
1:f5c1abd:         }
1:f5c1abd:         
1:3919c52:         if (isJarInvocation) {
1:3919c52:             // If -jar is specified, the Java command will ignore the user's
1:3919c52:             // classpath, so don't set it. Fail if an explicit classpath has
1:3919c52:             // been set in addition to -jar, as that's probably a mistake in
1:3919c52:             // the calling code.
1:3919c52:             assertNull("Both -jar and classpath specified", cp);
1:8ad67d3:         } else if (addClassPath) {
1:3919c52:             cmdlist.add("-classpath");
1:3919c52:             cmdlist.add(cp == null ? getSystemProperty("java.class.path") : cp);
1:3919c52:         }
1:e437bc3: 
1:ce62de6: 	    for (int i =0; i < cmd.length;i++) {
1:ce62de6: 	        cmdlist.add(cmd[i]);
1:02c8976: 	    }
1:ce62de6: 	    final String[] command = (String[]) cmdlist.toArray(cmd);
1:5311158: 	    println("execute java command:");
1:5311158: 	    for (int i = 0; i < command.length; i++) {
1:5311158: 	        println("command[" + i + "]" + command[i]);
1:02c8976: 	    }
1:63c65ac: 	    try {
1:2510115:             return AccessController.doPrivileged(
1:2510115:                     new PrivilegedExceptionAction<Process>() {
1:2510115:                 public Process run() throws IOException {
1:2510115:                     return Runtime.getRuntime().exec(
1:f0951ab:                             command, (String[]) null, dir);
1:02c8976: 	            }
1:63c65ac: 	        });
1:63c65ac: 	    } catch (PrivilegedActionException pe) {
1:d9857c0:             throw (IOException) pe.getException();
1:63c65ac: 	    }
1:63c65ac: 	}
1:63c65ac: 
1:044179c:     /**
1:f0951ab:      * Execute a java command and return the process. The process will run
1:f0951ab:      * in the same directory as the main test process. This method is a
1:e437bc3:      * shorthand for {@code execJavaCmd(null, null, cmd, null)}.
1:f0951ab:      */
1:f0951ab:     public static Process execJavaCmd(String[] cmd) throws IOException {
1:e437bc3:         return execJavaCmd(null, null, cmd, null);
1:f0951ab:     }
1:f0951ab: 
1:f0951ab:     /**
1:8badf99:      * Return the executable name for spawning java commands.
1:8badf99:      * This will be <path to j9>/j9  for j9 jvms.
1:8badf99:      * @return full path to java executable.
1:8badf99:      */
1:8badf99:     public static final String getJavaExecutableName() {
1:8badf99:         String vmname = getSystemProperty("com.ibm.oti.vm.exe");
1:8badf99: 
1:8badf99:         if (vmname == null) {
1:8badf99:             vmname = getSystemProperty("java.vm.name");
1:8badf99: 
1:8badf99:             // Sun phoneME
1:8badf99:             if ("CVM".equals(vmname)) {
1:8badf99:                 vmname = getSystemProperty("java.home") +
1:8badf99:                     File.separator + "bin" +
1:8badf99:                     File.separator + "cvm";
1:8badf99:             } else {
1:8badf99:                 vmname = getSystemProperty("java.home") +
1:8badf99:                     File.separator + "bin" +
1:8badf99:                     File.separator + "java";
1:514ee1d:             }
1:514ee1d:         }
1:514ee1d: 
1:8badf99:         return vmname;
1:8badf99:     }
1:8badf99: 
1:8badf99:     /**
1:92a2169:      * <p>
1:92a2169:      * Return the current directory.
1:92a2169:      * </p>
1:92a2169:      */
1:92a2169:     public  static  File    currentDirectory()
1:92a2169:     {
1:92a2169:         return new File( getSystemProperty( "user.dir" ) );
1:92a2169:     }
1:92a2169: 
1:92a2169:     /**
1:8badf99:      * @return true if this is a j9 VM
1:8badf99:      */
1:8badf99:     public static final boolean isJ9Platform() {
1:8badf99:         return getSystemProperty("com.ibm.oti.vm.exe") != null;
1:8badf99:     }
1:8badf99: 
1:30efca7:     public static final boolean isSunJVM() {
1:28358ab:         String vendor = getSystemProperty("java.vendor");
1:28358ab:         return "Sun Microsystems Inc.".equals(vendor) ||
1:28358ab:                 "Oracle Corporation".equals(vendor);
1:8badf99:     }
1:482ff80: 
1:482ff80:     /**
1:b2dc02c:      * Check if this is a CVM-based VM (like phoneME or Oracle Java ME
1:b2dc02c:      * Embedded Client).
1:b2dc02c:      */
1:b2dc02c:     public static boolean isCVM() {
1:b2dc02c:         return "CVM".equals(getSystemProperty("java.vm.name"));
1:8badf99:     }
1:482ff80: 
1:b2dc02c:     /**
1:dc5f56a:      * Check if the VM is phoneME.
1:dc5f56a:      *
1:dc5f56a:      * @return true if it is phoneME
1:dc5f56a:      */
1:dc5f56a:     public static boolean isPhoneME() {
1:b2dc02c:         return isCVM() &&
1:dc5f56a:                 getSystemProperty("java.vm.version").startsWith("phoneme");
1:dc5f56a:     }
1:dc5f56a: 
1:dc5f56a:     /**
1:23a4538:      * Determine if there is a platform match with os.name.
1:23a4538:      * This method uses an exact equals. Other methods might be useful
1:23a4538:      * later for starts with.
1:23a4538:      * 
1:23a4538:      * @param osName value we want to check against the system property
1:23a4538:      *      os.name
1:23a4538:      * @return return true if osName is an exact match for osName
1:044179c:      */
1:63c65ac:     
1:23a4538:     public static final boolean isPlatform(String osName)  {
1:63c65ac: 
1:23a4538:         return getSystemProperty("os.name").equals(osName);
1:044179c:     }
1:63c65ac: 
1:23a4538:     /**
1:056eff7:      * Determine if platform is a Windows variant.
1:056eff7:      * <p>
1:056eff7:      * Return true if platform is a windows platform.  Just looks for
1:056eff7:      * os.name starting with "Windows".  The os.name property
1:056eff7:      * can have at least the following values (there are probably more):
1:056eff7:      *
1:056eff7:      * AIX
1:056eff7:      * Digital Unix
1:056eff7:      * FreeBSD
1:056eff7:      * HP UX
1:056eff7:      * Irix
1:056eff7:      * Linux
1:056eff7:      * Mac OS
1:056eff7:      * Mac OS X
1:056eff7:      * MPE/iX
1:056eff7:      * Netware 4.11
1:056eff7:      * OS/2
1:0a16899:      * SunOS
1:056eff7:      * Windows 2000
1:056eff7:      * Windows 95
1:056eff7:      * Windows 98
1:056eff7:      * Windows NT
1:056eff7:      * Windows Vista
1:056eff7:      * Windows XP
1:056eff7:      * <p>
1:056eff7:      *
1:056eff7:      * @return true if running on a Windows platform.
1:056eff7:      **/
1:056eff7:     public static final boolean isWindowsPlatform() {
1:056eff7:         return getSystemProperty("os.name").startsWith("Windows");
1:044179c:     }
1:044179c:     
1:7d98408:     /**
1:23a4538:      * Check if this is java 5
1:23a4538:      * @return true if java.version system property starts with 1.5
1:3b4b552:      */
1:23a4538:     public static final boolean isJava5() {
1:23a4538:         return getSystemProperty("java.version").startsWith("1.5");
1:84e1fb3:     }
1:84e1fb3: 
1:1856e58:     public static final boolean isJava7() {
1:1856e58:         return getSystemProperty("java.version").startsWith("1.7");
1:b54918e:     }
1:b54918e: 
1:dcfc481:     public static final boolean runsWithEmma() {
1:dcfc481:         return getSystemProperty("java.class.path").indexOf("emma.jar") != -1;
1:dcfc481:     }
1:dcfc481: 
1:273ad5f:     public static boolean runsWithJaCoCo() {
1:1e0c703:         return SecurityManagerSetup.jacocoEnabled;
1:044179c:     }
1:dcfc481: 
1:b9e0e74:     /**
1:273ad5f:      * Counter used to produce unique file names based on process count.
1:273ad5f:      *
1:273ad5f:      * @see #getEmmaOutFile()
1:273ad5f:      * @see #getJaCoCoOutFile()
1:b9e0e74:      */
1:273ad5f:     private static int spawnedCount = 0;
1:b9e0e74: 
1:b9e0e74:     /**
1:b9e0e74:      * Get a unique file object that can be used by sub-processes to store
1:273ad5f:      * JaCoCo code coverage data. Each separate sub-process should have its
1:273ad5f:      * own file in order to prevent corruption of the coverage data.
1:273ad5f:      *
1:273ad5f:      * @return a file to which a sub-process can write code coverage data
1:23a4538:      */
1:273ad5f:     private static synchronized File getJaCoCoOutFile() {
1:273ad5f:         return new File(currentDirectory(),
1:273ad5f:                 "jacoco.exec." + (++spawnedCount));
1:044179c:     }
1:044179c: 
1:23a4538:     /**
1:273ad5f:      * Get a unique file object that can be used by sub-processes to store
1:b9e0e74:      * EMMA code coverage data. Each separate sub-process should have its
1:b9e0e74:      * own file in order to prevent corruption of the coverage data.
1:b9e0e74:      *
1:b9e0e74:      * @return a file to which a sub-process can write code coverage data
1:b9e0e74:      */
1:b9e0e74:     private static synchronized File getEmmaOutFile() {
1:b9e0e74:         return new File(currentDirectory(),
1:273ad5f:                 "coverage-" + (++spawnedCount) + ".ec");
1:b9e0e74:     }
1:044179c: 
1:db2c1c2:     /**
1:9902875:      * Get a URL pointing to {@code emma.jar}, if the tests are running
1:9902875:      * with EMMA code coverage. The method returns {@code null} if the
1:9902875:      * tests are not running with EMMA.
1:9902875:      */
1:9902875:     public static URL getEmmaJar() {
1:9902875:         return SecurityManagerSetup.getURL("com.vladium.emma.EMMAException");
1:9902875:     }
1:9902875: 
1:9902875:     /**
1:73122ce:      * Returns the major version of the class specification version supported
1:73122ce:      * by the running JVM.
1:73122ce:      * <ul>
1:73122ce:      *  <li>48 = Java 1.4</li>
1:73122ce:      *  <li>49 = Java 1.5</li>
1:73122ce:      *  <li>50 = Java 1.6</li>
1:73122ce:      *  <li>51 = Java 1.7</li>
1:73122ce:      * </ul>
1:73122ce:      *
1:73122ce:      * @return Major version of class version specification, i.e. 49 for 49.0,
1:73122ce:      *      or -1 if the version can't be obtained for some reason.
1:273ad5f:      */
1:73122ce:     public static int getClassVersionMajor() {
1:73122ce:         String tmp = getSystemProperty("java.class.version");
1:73122ce:         if (tmp == null) {
1:73122ce:             println("VM doesn't have property java.class.version");
1:73122ce:             return -1;
1:044179c:         }
1:73122ce:         // Is String.split safe to use by now?
1:73122ce:         int dot = tmp.indexOf('.');
1:73122ce:         int major = -1;
1:044179c:         try {
1:73122ce:             major = Integer.parseInt(tmp.substring(0, dot));
1:73122ce:         } catch (NumberFormatException nfe) {
1:73122ce:             // Ignore, return -1.
1:044179c:         }
1:73122ce:         return major;
1:044179c:     }
1:044179c: 
1:73122ce:     /**
1:482ff80:      * Check if we have old style (before Sun Java 1.7) Solaris interruptible
1:dbed020:      * IO. On Sun Java 1.5 &gt;= update 22 and Sun Java 1.6 this can be disabled
1:482ff80:      * with Java option {@code -XX:-UseVMInterruptibleIO}. On Sun Java 1.7 it
1:482ff80:      * is by default disabled.
1:482ff80:      *
1:482ff80:      * @return true if we have old style interruptible IO
1:482ff80:      */
1:391d4a6:     public static final boolean hasInterruptibleIO() {
1:482ff80: 
1:482ff80:         boolean interruptibleIO = false;
1:482ff80: 
1:482ff80:         try {
1:482ff80:             AccessController.doPrivileged(
1:2510115:                 new PrivilegedExceptionAction<Void>() {
1:2510115:                     public Void run() throws
1:482ff80:                         IOException, InterruptedIOException {
1:482ff80: 
1:482ff80:                         TestConfiguration curr = TestConfiguration.getCurrent();
1:482ff80: 
1:482ff80:                         String sysHome = getSystemProperty("derby.system.home");
1:482ff80: 
1:391d4a6:                         StringBuffer arbitraryRAFFileNameB = new StringBuffer();
1:482ff80: 
1:391d4a6:                         arbitraryRAFFileNameB.append(sysHome);
1:391d4a6:                         arbitraryRAFFileNameB.append(File.separatorChar);
1:391d4a6:                         arbitraryRAFFileNameB.append("derby.log");
1:391d4a6: 
1:391d4a6:                         String arbitraryRAFFileName =
1:391d4a6:                             arbitraryRAFFileNameB.toString();
1:391d4a6:                         // Create if it does not exist:
1:391d4a6:                         new File(sysHome).mkdirs(); // e.g. "system"
1:391d4a6:                         new File(arbitraryRAFFileName).createNewFile();
1:482ff80: 
1:482ff80:                         RandomAccessFile f = new RandomAccessFile(
1:391d4a6:                             arbitraryRAFFileName, "r");
1:482ff80: 
1:482ff80:                         try {
1:482ff80:                             Thread.currentThread().interrupt();
1:482ff80:                             f.read();
1:482ff80:                         } finally {
1:482ff80:                             Thread.interrupted(); // clear flag
1:482ff80:                             f.close();
1:482ff80:                         }
1:482ff80: 
1:482ff80:                         return null;
1:482ff80:                     }});
1:482ff80:         } catch (PrivilegedActionException e) {
1:482ff80:             if (e.getCause() instanceof InterruptedIOException) {
1:482ff80:                 interruptibleIO = true;
1:482ff80:             } else {
1:391d4a6:                 // Better to assume nothing when the test fails. Then, tests
1:391d4a6:                 // will not be skipped and we would not miss that something is
1:391d4a6:                 // amiss.
1:391d4a6:                 println("Could not test for interruptible IO," +
1:391d4a6:                         " so assuming we don't have it: " + e);
1:391d4a6:                 e.getCause().printStackTrace();
1:391d4a6:                 return false;
1:482ff80:             }
1:482ff80:         }
1:482ff80: 
1:482ff80:         return interruptibleIO;
1:482ff80:     }
1:482ff80: 
1:482ff80: 
1:e5a97fe:     public static final boolean isIBMJVM() {
1:e5a97fe:         return ("IBM Corporation".equals(
1:30efca7:                 getSystemProperty("java.vendor")));
1:044179c:     }
1:482ff80: 
1:37952cf:     /**
1:63c65ac:      * Reads output from a process and returns it as a string.
1:d96e3aa:      * <p>
1:63c65ac:      * This will block until the process terminates.
1:63c65ac:      * 
1:63c65ac:      * @param pr a running process
1:d96e3aa:      * @return Output of the process, both STDOUT and STDERR.
1:d96e3aa:      * @throws InterruptedException if interrupted while waiting for the
1:d96e3aa:      *      subprocess or one of the output collector threads to terminate
1:b350a56:      */
1:d96e3aa:     public static String readProcessOutput(Process pr)
1:d96e3aa:             throws InterruptedException {
1:d96e3aa:         SpawnedProcess wrapper = new SpawnedProcess(pr, "readProcessOutput");
1:d96e3aa:         wrapper.suppressOutputOnComplete();
1:63c65ac:         try {
1:04846d1:             wrapper.complete();
1:d96e3aa:         } catch (IOException ioe) {
1:d96e3aa:             fail("process completion method failed", ioe);
1:63c65ac:         }
1:0a0a6c2:         String output = "<STDOUT>" + wrapper.getFullServerOutput() +
1:d96e3aa:                 "<END STDOUT>\n";
1:d96e3aa:         output += "<STDERR>" + wrapper.getFullServerError() +
1:d96e3aa:                 "<END STDERR>\n";
1:63c65ac:         return output;
1:63c65ac:     }
1:63c65ac: 
1:37952cf:     /**
1:a0f4b68:      * Deletes the specified directory and all its files and subdirectories.
1:a0f4b68:      * <p>
1:a0f4b68:      * This method will attempt to delete all the files inside the root
1:a0f4b68:      * directory, even if one of the delete operations fails.
1:a0f4b68:      * <p>
1:a0f4b68:      * After having tried to delete all files once, any remaining files will be
1:a0f4b68:      * attempted deleted again after a pause. This is repeated, resulting
1:a0f4b68:      * in multiple failed delete attempts for any single file before the method
1:a0f4b68:      * gives up and raises a failure.
1:a0f4b68:      * <p>
1:a0f4b68:      * The approach above will mask any slowness involved in releasing file
1:a0f4b68:      * handles, but should fail if a file handle actually isn't released on a
1:a0f4b68:      * system that doesn't allow deletes on files with open handles (i.e.
1:a0f4b68:      * Windows). It will also mask slowness caused by the JVM, the file system,
1:a0f4b68:      * or the operation system.
1:a0f4b68:      *
1:a0f4b68:      * @param dir the root to start deleting from (root will also be deleted)
1:a0f4b68:      */
1:a0f4b68:     public static void assertDirectoryDeleted(File dir) {
1:a0f4b68:         File[] fl = null;
1:a0f4b68:         int attempts = 0;
1:a0f4b68:         while (attempts < 4) {
1:a0f4b68:             try {
1:a0f4b68:                 Thread.sleep(attempts * 2000);
1:a0f4b68:             } catch (InterruptedException ie) {
1:a0f4b68:                 // Ignore
1:63c65ac:             }
1:a0f4b68:             try {
1:a0f4b68:                 fl = PrivilegedFileOpsForTests.persistentRecursiveDelete(dir);
1:a0f4b68:                 attempts++;
1:a0f4b68:             } catch (FileNotFoundException fnfe) {
1:a0f4b68:                 if (attempts == 0) {
1:a0f4b68:                     fail("directory doesn't exist: " +
1:a0f4b68:                             PrivilegedFileOpsForTests.getAbsolutePath(dir));
1:a0f4b68:                 } else  {
1:a0f4b68:                     // In the previous iteration we saw remaining files, but
1:a0f4b68:                     // now the root directory is gone. Not what we expected...
1:a0f4b68:                     System.out.println("<assertDirectoryDeleted> root " +
1:a0f4b68:                             "directory unexpectedly gone - delayed, " +
1:a0f4b68:                             "external or concurrent delete?");
1:a0f4b68:                     return;
1:63c65ac:                 }
1:1856e58:             }
1:a0f4b68:             if (fl.length == 0) {
1:a0f4b68:                 return;
1:3919c52:             } else {
1:a0f4b68:                 // Print the list of remaining files to stdout for debugging.
1:a0f4b68:                 StringBuffer sb = new StringBuffer();
1:a0f4b68:                 sb.append("<assertDirectoryDeleted> attempt ").append(attempts).
1:a0f4b68:                     append(" left ").append(fl.length).
1:a0f4b68:                     append(" files/dirs behind:");
1:a0f4b68:                 for (int i = 0; i < fl.length; i++) {
1:a0f4b68:                     sb.append(' ').append(i).append('=').append(fl[i]);
1:ce62de6:                 }
1:a0f4b68:                 System.out.println(sb);
1:3b4b552:             }
1:3b4b552:         }
1:a0f4b68:         // If we failed to delete some of the files, list them and obtain some
1:a0f4b68:         // information about each file.
1:a0f4b68:         StringBuffer sb = new StringBuffer();
1:a0f4b68:         for (int i = 0; i < fl.length; i++) {
1:a0f4b68:             File f = fl[i];
1:a0f4b68:             sb.append(PrivilegedFileOpsForTests.getAbsolutePath(f)).append(' ').
1:a0f4b68:                 append(PrivilegedFileOpsForTests.getFileInfo(f)).append(", ");
1:5311158:         }
1:a0f4b68:         sb.deleteCharAt(sb.length() - 1).deleteCharAt(sb.length() - 1);
1:a0f4b68:         fail("Failed to delete " + fl.length + " files (root=" +
1:a0f4b68:                 PrivilegedFileOpsForTests.getAbsolutePath(dir) + "): " +
1:a0f4b68:                 sb.toString());
1:23a4538:     }
1:63c65ac: 
1:a0f4b68:     /**
1:26ed4f9:      * Remove the directory and its contents.
1:26ed4f9:      * @param path Path of the directory
1:26ed4f9:      */
1:26ed4f9:     public static void removeDirectory(String path)
1:63c65ac:     {
1:26ed4f9:         DropDatabaseSetup.removeDirectory(path);
1:23a4538:     }
1:26ed4f9:     /**
1:26ed4f9:      * Remove the directory and its contents.
1:89e7a26:      * @param dir File of the directory
1:26ed4f9:      */
1:26ed4f9:     public static void removeDirectory(File dir)
1:044179c:     {
1:26ed4f9:         DropDatabaseSetup.removeDirectory(dir);
1:30efca7:     }
1:4d8deb6:  
1:4d8deb6:     /**
1:4c5c16b:      * Remove all the files in the list
1:4c5c16b:      * @param list the list contains all the files
1:4c5c16b:      */
1:4c5c16b:     public static void removeFiles(String[] list)
1:044179c:     {
1:4c5c16b:         DropDatabaseSetup.removeFiles(list);
1:f23a20f:     }
1:37952cf:     /**
1:4d8deb6:      * Fail; attaching an exception for more detail on cause.
1:4d8deb6:      *
1:4d8deb6:      * @param msg message explaining the failure
1:035abcc:      * @param t the cause of the failure
1:4d8deb6:      *
1:4d8deb6:      * @exception AssertionFailedError
1:4d8deb6:      */
1:035abcc:     public static void fail(String msg, Throwable t)
1:4d8deb6:             throws AssertionFailedError {
1:c939828:         throw newAssertionFailedError(msg, t);
1:4d8deb6:     }
1:4d8deb6: 
1:c939828:     /**
1:c939828:      * Create a new AssertionFailedError linked to another Throwable.
1:c939828:      *
1:c939828:      * @param message message explaining the failure
1:c939828:      * @param cause the cause of the failure
1:c939828:      * @return an AssertionFailedError
1:c939828:      */
1:c939828:     public static AssertionFailedError newAssertionFailedError(
1:c939828:             String message, Throwable cause) {
1:c939828:         AssertionFailedError e = new AssertionFailedError(message);
1:c939828:         e.initCause(cause);
1:c939828:         return e;
1:c939828:     }
1:c939828: 
1:cccb382:     /**
1:8f56d99:      * assert a method from an executing test
1:8f56d99:      * 
1:8f56d99:      * @param testLaunchMethod
1:8f56d99:      *            complete pathname of the method to be executed
1:8f56d99:      * @throws Exception
1:8f56d99:      */
1:8f56d99:     public static void assertLaunchedJUnitTestMethod(String testLaunchMethod)
1:8f56d99:             throws Exception 
1:044179c:     {
1:8f56d99:         String[] cmd = new String[] { "junit.textui.TestRunner", "-m",
1:8f56d99:         testLaunchMethod };
1:8f56d99:         assertExecJavaCmdAsExpected(new String[] { "OK (1 test)" }, cmd, 0);
1:8f56d99:     }
1:4ee7918:     
1:4ee7918:     /**
1:4ee7918:      * assert a method from an executing test
1:4ee7918:      *
1:4ee7918:      * @param testLaunchMethod
1:4ee7918:      *            complete pathname of the method to be executed
1:4ee7918:      * @param databaseName
1:4ee7918:      *            name of the database to be used
1:4ee7918:      * @throws Exception
1:4ee7918:      */
1:4ee7918:     public static void assertLaunchedJUnitTestMethod(String testLaunchMethod,
1:4ee7918:             String databaseName)
1:4ee7918:             throws Exception 
1:4ee7918:     {
1:4ee7918:         String[] cmd = new String[] { 
1:4ee7918:                 "-Dderby.tests.defaultDatabaseName=" + databaseName, 
1:4ee7918:                 "junit.textui.TestRunner", "-m", testLaunchMethod };
1:4ee7918:         assertExecJavaCmdAsExpected(new String[] { "OK (1 test)" }, cmd, 0);
1:4ee7918:     }
1:63c65ac: 
1:afe4dfd:     /** Returns once the system timer has advanced at least one tick. */
1:afe4dfd:     public static void sleepAtLeastOneTick() {
1:afe4dfd:         long currentTime = System.currentTimeMillis(); 
1:afe4dfd:         while (System.currentTimeMillis() == currentTime) {
1:afe4dfd:             sleep(1);
1:305a23d:         }
1:a0f4b68:     }
1:044179c: 
1:cf8e7ff:     /** Return true if the JVM is at least at the indicated rev level */
1:cf8e7ff:     public static boolean vmAtLeast( int major, int minor )
1:cf8e7ff:     {
1:cf8e7ff:         String version = AccessController.doPrivileged
1:cf8e7ff:             (new PrivilegedAction<String>(){
1:cf8e7ff:                 public String run(){
1:cf8e7ff:                     return System.getProperty( "java.version" );
1:cf8e7ff:                 }
1:cf8e7ff:             }
1:cf8e7ff:                 );
1:cf8e7ff:                    
1:cf8e7ff:         JavaVersionHolder jvh =  new JavaVersionHolder( version );
1:cf8e7ff: 
1:cf8e7ff:         return jvh.atLeast( major, minor );
1:cf8e7ff:     }
1:cf8e7ff: 
1:afe4dfd:     /** Makes the current thread sleep up to {@code ms} milliseconds. */
1:afe4dfd:     public static void sleep(long ms) {
1:afe4dfd:         try {
1:afe4dfd:             Thread.sleep(ms);
1:afe4dfd:         } catch (InterruptedException ie) {
1:afe4dfd:             // For now we just print a warning if we are interrupted.
1:afe4dfd:             alarm("sleep interrupted");
1:177992f:         }
1:a0f4b68:     }
1:044179c: 
1:3983707:     private static String traceClientType() {
1:3983707:        if (TestConfiguration.getCurrent().getJDBCClient().isEmbedded()) {
1:3983707:             return "(emb)";
1:a0f4b68:         } else {
1:3983707:             return "(net)";
1:a0f4b68:         }
1:a0f4b68:     }
1:f5c1abd:     
1:2510115:     private static void setupForDebuggerAttach(ArrayList<String> cmdlist) {
1:f5c1abd:         if (debugPort == 0) {
1:f5c1abd:             // lazy initialization
1:f5c1abd:             String dbp = getSystemProperty("derby.test.debugPortBase");
1:f5c1abd:             debugPort = 8800; // default
1:f5c1abd:             if (dbp != null) {
1:f5c1abd:                 try {
1:f5c1abd:                     debugPort = Integer.parseInt(dbp);
1:f5c1abd:                 } catch (NumberFormatException e) {
1:f5c1abd:                     // never mind
1:f5c1abd:                 }
1:f5c1abd:             }
1:f5c1abd:         }
1:f5c1abd:         
1:f5c1abd:         char suspend = 'y'; // default
1:f5c1abd:         String susp = getSystemProperty("derby.test.debugSuspend");
1:f5c1abd:         if (susp != null && "n".equals(susp.toLowerCase())) {
1:f5c1abd:             suspend = 'n';
1:f5c1abd:         }
1:f5c1abd:         
1:f5c1abd:         cmdlist.add("-Xdebug");
1:f5c1abd:         cmdlist.add("-Xrunjdwp:transport=dt_socket,address=" + (debugPort++) +
1:f5c1abd:                 ",server=y,suspend=" + suspend);
1:f5c1abd:     }
1:b350a56: } // End class BaseTestCase
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * IO. On Sun Java 1.5 &gt;= update 22 and Sun Java 1.6 this can be disabled
commit:cf8e7ff
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.harness.JavaVersionHolder;
/////////////////////////////////////////////////////////////////////////
1:     /** Return true if the JVM is at least at the indicated rev level */
1:     public static boolean vmAtLeast( int major, int minor )
1:     {
1:         String version = AccessController.doPrivileged
1:             (new PrivilegedAction<String>(){
1:                 public String run(){
1:                     return System.getProperty( "java.version" );
1:                 }
1:             }
1:                 );
1:                    
1:         JavaVersionHolder jvh =  new JavaVersionHolder( version );
1: 
1:         return jvh.atLeast( major, minor );
1:     }
1: 
commit:dff2bf5
/////////////////////////////////////////////////////////////////////////
1:      * Same as {@link #execJavaCmd( String, String, String[], File, boolean )}
commit:84e1fb3
/////////////////////////////////////////////////////////////////////////
0:     public static final boolean isJava6() {
0:         return getSystemProperty("java.version").startsWith("1.6");
1:     }
1:    
commit:6b23802
/////////////////////////////////////////////////////////////////////////
1:      * Assert the equivalence of two byte arrays.
1:      * </p>
1:      */
1:     public  static  void    assertEquals( byte[] expected, byte[] actual )
1:     {
1:         if ( assertSameNullness( expected, actual ) ) { return; }
1:         
1:         assertEquals( expected.length, actual.length );
1:         for ( int i = 0; i < expected.length; i++ )
1:         {
1:             assertEquals( Integer.toString( i ), expected[ i ], actual[ i ] );
1:         }
1:     }
1: 
1:     /**
1:      * Assert that two objects are either both null or neither null.
1:      * Returns true if they are null.
1:      */
1:     public  static  boolean assertSameNullness( Object expected, Object actual )
1:     {
1:         if ( expected ==  null )
1:         {
1:             assertNull( actual );
1:             return true;
1:         }
1:         else
1:         {
1:             assertNotNull( actual );
1:             return false;
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:         if ( assertSameNullness( expected, actual ) ) { return; }
1:         
/////////////////////////////////////////////////////////////////////////
1:         if ( assertSameNullness( expected, actual ) ) { return; }
1:         
commit:2520683
/////////////////////////////////////////////////////////////////////////
1:             out.flush();
commit:b54918e
/////////////////////////////////////////////////////////////////////////
0:     public static final boolean isJava8() {
0:         return getSystemProperty("java.version").startsWith("1.8");
1:     }
1: 
commit:0b0a105
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * Assert the equivalence of two int arrays.
1:      * </p>
1:      */
1:     public  static  void    assertEquals( int[] expected, int[] actual )
1:     {
1:         assertEquals( expected.length, actual.length );
1:         for ( int i = 0; i < expected.length; i++ )
1:         {
1:             assertEquals( Integer.toString( i ), expected[ i ], actual[ i ] );
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Assert the equivalence of two long arrays.
1:      * </p>
1:      */
1:     public  static  void    assertEquals( long[] expected, long[] actual )
1:     {
1:         assertEquals( expected.length, actual.length );
1:         for ( int i = 0; i < expected.length; i++ )
1:         {
1:             assertEquals( Integer.toString( i ), expected[ i ], actual[ i ] );
1:         }
1:     }
1: 
1:     /**
commit:92a2169
/////////////////////////////////////////////////////////////////////////
1:  * Derby - Class org.apache.derbyTesting.junit.BaseTestCase
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * Return the current directory.
1:      * </p>
1:      */
1:     public  static  File    currentDirectory()
1:     {
1:         return new File( getSystemProperty( "user.dir" ) );
1:     }
1: 
1:     /**
commit:5107349
/////////////////////////////////////////////////////////////////////////
1:     public static void removeSystemProperty(final String name)
commit:d00ad46
/////////////////////////////////////////////////////////////////////////
commit:d135e39
/////////////////////////////////////////////////////////////////////////
0:         if ( vmname.indexOf( " " ) >= 0 )
commit:514ee1d
/////////////////////////////////////////////////////////////////////////
1: 
0:         // derby-5490. workaround problem if executable name contains spaces
0:         if ( vmname.contains( " " ) )
1:         {
0:             if ( getSystemProperty( "os.name" ).equals( "Mac OS X" ) )
1:             {
0:                 vmname = "java";
1:             }
1:         }
1:         
commit:daa4827
/////////////////////////////////////////////////////////////////////////
1:      * Print trace string.
1:      * @param text String to print
1:      */
1:     public static void traceit(final String text) {
1:         if (TestConfiguration.getCurrent().doTrace()) {
1:             out.println(text);
1:         }
1:     }
1: 
1:     /**
commit:4aef9b0
/////////////////////////////////////////////////////////////////////////
1:             out.flush();
commit:59a5a70
/////////////////////////////////////////////////////////////////////////
1: 
1:         // install a default security manager if one has not already been
1:         // installed
1:         if ( System.getSecurityManager() == null )
1:         {
0:             if (getTestConfiguration().defaultSecurityManagerSetup())
1:             {
1:             }
1:         }
commit:1bb2ac5
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: import java.io.IOException;
1: import java.io.Reader;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Compare the contents of two streams.
1:      * The streams are closed after they are exhausted.
1:      *
1:      * @param is1 the first stream
1:      * @param is2 the second stream
1:      * @throws IOException if reading from the streams fail
1:      * @throws AssertionFailedError if the stream contents are not equal
1:      */
1:     public static void assertEquals(InputStream is1, InputStream is2)
1:             throws IOException {
1:         if (is1 == null || is2 == null) {
1:             assertNull("InputStream is2 is null, is1 is not", is1);
1:             assertNull("InputStream is1 is null, is2 is not", is2);
1:             return;
1:         }
1:         long index = 0;
1:         int b1 = is1.read();
1:         int b2 = is2.read();
1:         do {
1:             // Avoid string concatenation for every byte in the stream.
1:             if (b1 != b2) {
1:                 assertEquals("Streams differ at index " + index, b1, b2);
1:             }
1:             index++;
1:             b1 = is1.read();
1:             b2 = is2.read();
1:         } while (b1 != -1 || b2 != -1);
1:         is1.close();
1:         is2.close();
1:     }
1: 
1:     /**
1:      * Compare the contents of two readers.
1:      * The readers are closed after they are exhausted.
1:      *
1:      * @param r1 the first reader
1:      * @param r2 the second reader
1:      * @throws IOException if reading from the streams fail
1:      * @throws AssertionFailedError if the reader contents are not equal
1:      */
1:     public static void assertEquals(Reader r1, Reader r2)
1:             throws IOException {
1:         long index = 0;
1:         if (r1 == null || r2 == null) {
1:             assertNull("Reader r2 is null, r1 is not", r1);
1:             assertNull("Reader r1 is null, r2 is not", r2);
1:             return;
1:         }
1:         int c1 = r1.read();
1:         int c2 = r2.read();
1:         do {
1:             // Avoid string concatenation for every char in the stream.
1:             if (c1 != c2) {
1:                 assertEquals("Streams differ at index " + index, c1, c2);
1:             }
1:             index++;
1:             c1 = r1.read();
1:             c2 = r2.read();
1:         } while (c1 != -1 || c2 != -1);
1:         r1.close();
1:         r2.close();
1:     }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:8ad67d3
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Field;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Same as {@link #execJavaCmd(
0:      * String jvm, String cp, String[] cmd, final File dir, boolean addClassPath)}
1:      * but with {@code addClassPath == true}.
1:      */
1:     public static Process execJavaCmd(
1:         String jvm, String cp, String[] cmd, final File dir)
1:             throws IOException {
1:         return execJavaCmd(jvm, cp, cmd, dir, true);
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * @param addClassPath if {@code true},add classpath
1:         String jvm, String cp, String[] cmd, final File dir, boolean addClassPath)
/////////////////////////////////////////////////////////////////////////
1:         } else if (addClassPath) {
commit:f5c1abd
/////////////////////////////////////////////////////////////////////////
1:     
1:     private static int debugPort; // default 8800
/////////////////////////////////////////////////////////////////////////
1:         if (isSunJVM() && Boolean.valueOf(
1:                     getSystemProperty("derby.test.debugSubprocesses")).
1:                 booleanValue()) {
1:             setupForDebuggerAttach(cmdlist);
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:     
0:     private static void setupForDebuggerAttach(ArrayList cmdlist) {
1:         if (debugPort == 0) {
1:             // lazy initialization
1:             String dbp = getSystemProperty("derby.test.debugPortBase");
1:             debugPort = 8800; // default
1:             if (dbp != null) {
1:                 try {
1:                     debugPort = Integer.parseInt(dbp);
1:                 } catch (NumberFormatException e) {
1:                     // never mind
1:                 }
1:             }
1:         }
1:         
1:         char suspend = 'y'; // default
1:         String susp = getSystemProperty("derby.test.debugSuspend");
1:         if (susp != null && "n".equals(susp.toLowerCase())) {
1:             suspend = 'n';
1:         }
1:         
1:         cmdlist.add("-Xdebug");
1:         cmdlist.add("-Xrunjdwp:transport=dt_socket,address=" + (debugPort++) +
1:                 ",server=y,suspend=" + suspend);
1:     }
commit:dcfc481
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static final boolean runsWithEmma() {
1:         return getSystemProperty("java.class.path").indexOf("emma.jar") != -1;
1:     }
1: 
1: 
commit:391d4a6
/////////////////////////////////////////////////////////////////////////
1:     public static final boolean hasInterruptibleIO() {
/////////////////////////////////////////////////////////////////////////
1:                         StringBuffer arbitraryRAFFileNameB = new StringBuffer();
1:                         arbitraryRAFFileNameB.append(sysHome);
1:                         arbitraryRAFFileNameB.append(File.separatorChar);
1:                         arbitraryRAFFileNameB.append("derby.log");
1: 
1:                         String arbitraryRAFFileName =
1:                             arbitraryRAFFileNameB.toString();
1:                         // Create if it does not exist:
1:                         new File(sysHome).mkdirs(); // e.g. "system"
1:                         new File(arbitraryRAFFileName).createNewFile();
1:                             arbitraryRAFFileName, "r");
/////////////////////////////////////////////////////////////////////////
1:                 // Better to assume nothing when the test fails. Then, tests
1:                 // will not be skipped and we would not miss that something is
1:                 // amiss.
1:                 println("Could not test for interruptible IO," +
1:                         " so assuming we don't have it: " + e);
1:                 e.getCause().printStackTrace();
1:                 return false;
commit:482ff80
/////////////////////////////////////////////////////////////////////////
1: import java.io.InterruptedIOException;
1: import java.io.RandomAccessFile;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Check if we have old style (before Sun Java 1.7) Solaris interruptible
0:      * IO. On Sun Java 1.5 >= update 22 and Sun Java 1.6 this can be disabled
1:      * with Java option {@code -XX:-UseVMInterruptibleIO}. On Sun Java 1.7 it
1:      * is by default disabled.
1:      *
1:      * @return true if we have old style interruptible IO
1:      */
0:     public static final boolean hasInterruptibleIO()
0:             throws Exception {
1: 
1: 
1:         boolean interruptibleIO = false;
1: 
1:         try {
1:             AccessController.doPrivileged(
0:                 new PrivilegedExceptionAction() {
0:                     public Object run() throws
1:                         IOException, InterruptedIOException {
1: 
1:                         TestConfiguration curr = TestConfiguration.getCurrent();
1: 
1:                         String sysHome = getSystemProperty("derby.system.home");
1: 
0:                         StringBuffer arbitraryRAFFileName = new StringBuffer();
1: 
0:                         arbitraryRAFFileName.append(sysHome);
0:                         arbitraryRAFFileName.append(File.separatorChar);
0:                         arbitraryRAFFileName.append("derby.log");
1: 
1:                         RandomAccessFile f = new RandomAccessFile(
0:                             arbitraryRAFFileName.toString(), "r");
1: 
1:                         try {
1:                             Thread.currentThread().interrupt();
1:                             f.read();
1:                         } finally {
1:                             Thread.interrupted(); // clear flag
1:                             f.close();
1:                         }
1: 
1:                         return null;
1:                     }});
1:         } catch (PrivilegedActionException e) {
1:             if (e.getCause() instanceof InterruptedIOException) {
1:                 interruptibleIO = true;
1:             } else {
0:                 throw e;
1:             }
1: 
1:         }
1: 
1:         return interruptibleIO;
1:     }
1: 
1: 
commit:8badf99
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return the executable name for spawning java commands.
1:      * This will be <path to j9>/j9  for j9 jvms.
1:      * @return full path to java executable.
1:      */
1:     public static final String getJavaExecutableName() {
1:         String vmname = getSystemProperty("com.ibm.oti.vm.exe");
1: 
1:         if (vmname == null) {
1:             vmname = getSystemProperty("java.vm.name");
1: 
1:             // Sun phoneME
1:             if ("CVM".equals(vmname)) {
1:                 vmname = getSystemProperty("java.home") +
1:                     File.separator + "bin" +
1:                     File.separator + "cvm";
1:             } else {
1:                 vmname = getSystemProperty("java.home") +
1:                     File.separator + "bin" +
1:                     File.separator + "java";
1:             }
1:         }
1:         return vmname;
1:     }
1: 
1:     /**
1:      * @return true if this is a j9 VM
1:      */
1:     public static final boolean isJ9Platform() {
1:         return getSystemProperty("com.ibm.oti.vm.exe") != null;
1:     }
1: 
commit:ccf708c
/////////////////////////////////////////////////////////////////////////
1: 
1:     protected final static String ERRORSTACKTRACEFILE = "error-stacktrace.out";
1:     protected final static String DEFAULT_DB_DIR      = "system";
1:     protected final static String DERBY_LOG           = "derby.log";
/////////////////////////////////////////////////////////////////////////
1:                             new File(failPath, ERRORSTACKTRACEFILE), true));
1:                 File origLog = new File(DEFAULT_DB_DIR, DERBY_LOG);
1:                 File newLog = new File(failPath, DERBY_LOG);
1:                 File dbDir = new File(DEFAULT_DB_DIR, dbName );
commit:4d8deb6
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.AssertionFailedError;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Fail; attaching an exception for more detail on cause.
1:      *
1:      * @param msg message explaining the failure
0:      * @param e exception related to the cause
1:      *
1:      * @exception AssertionFailedError
1:      */
0:     public static void fail(String msg, Exception e)
1:             throws AssertionFailedError {
1: 
0:         AssertionFailedError ae = new AssertionFailedError(msg);
0:         ae.initCause(e);
0:         throw ae;
1:     }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3be8464
/////////////////////////////////////////////////////////////////////////
1:             cmdlist.add("-Djacoco.active=");
commit:f6df184
/////////////////////////////////////////////////////////////////////////
1: 
commit:c939828
/////////////////////////////////////////////////////////////////////////
1:         throw newAssertionFailedError(msg, t);
1: 
1:     /**
1:      * Create a new AssertionFailedError linked to another Throwable.
1:      *
1:      * @param message message explaining the failure
1:      * @param cause the cause of the failure
1:      * @return an AssertionFailedError
1:      */
1:     public static AssertionFailedError newAssertionFailedError(
1:             String message, Throwable cause) {
1:         AssertionFailedError e = new AssertionFailedError(message);
1:         e.initCause(cause);
1:         return e;
1:     }
1: 
commit:aba4ea1
/////////////////////////////////////////////////////////////////////////
1:     protected static void setSystemOut(final PrintStream out) {
/////////////////////////////////////////////////////////////////////////
1:     protected static void setSystemErr(final PrintStream err) {
commit:85038ef
/////////////////////////////////////////////////////////////////////////
commit:c393694
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Change the value of {@code System.out}.
1:      *
1:      * @param out the new stream
1:      */
0:     protected void setSystemOut(final PrintStream out) {
1:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:             public Void run() {
1:                 System.setOut(out);
1:                 return null;
1:             }
1:         });
1:     }
1: 
1:     /**
1:      * Change the value of {@code System.err}.
1:      *
1:      * @param err the new stream
1:      */
0:     protected void setSystemErr(final PrintStream err) {
1:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:             public Void run() {
1:                 System.setErr(err);
1:                 return null;
1:             }
1:         });
1:     }
1: 
commit:2510115
/////////////////////////////////////////////////////////////////////////
1:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:             public Void run() {
1:                 System.setProperty(name, value);
1:                 return null;
1:             }
1:         });
1: 
/////////////////////////////////////////////////////////////////////////
1:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:             public Void run() {
1:                 System.getProperties().remove(name);
1:                 return null;
1:             }
1:         });
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged(new PrivilegedAction<String>() {
1:             public String run() {
1:                 return System.getProperty(name);
1:             }
1:         });
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged(new PrivilegedAction<String[]>() {
1:                     public String[] run() {
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged(new PrivilegedAction<URL>() {
1:             public URL run() {
1:                 return BaseTestCase.class.getClassLoader().getResource(name);
1:             }
1:         });
1:     }
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged(
1:                 new PrivilegedExceptionAction<InputStream>() {
1:             public InputStream run() throws IOException {
1:                 return url.openStream();
1:             }
1:         });
/////////////////////////////////////////////////////////////////////////
1:         (new PrivilegedAction<Void>() {
1:         	public Void run() {
/////////////////////////////////////////////////////////////////////////
1: 	    ArrayList<String> cmdlist = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1:             return AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<Process>() {
1:                 public Process run() throws IOException {
1:                     return Runtime.getRuntime().exec(
/////////////////////////////////////////////////////////////////////////
1:                 new PrivilegedExceptionAction<Void>() {
1:                     public Void run() throws
/////////////////////////////////////////////////////////////////////////
1:     private static void setupForDebuggerAttach(ArrayList<String> cmdlist) {
commit:3919c52
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Is this an invocation of a jar file with java -jar ...?
1:         final boolean isJarInvocation = cmd.length > 0 && cmd[0].equals("-jar");
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:             // DERBY-5821: When starting a sub-process with java -jar, the
1:             // classpath argument will be ignored, so we cannot add emma.jar
1:             // that way. Add it to the boot classpath instead.
1:             if (isJarInvocation) {
1:                 cmdlist.add("-Xbootclasspath/a:" + getEmmaJar().getPath());
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (isJarInvocation) {
1:             // If -jar is specified, the Java command will ignore the user's
1:             // classpath, so don't set it. Fail if an explicit classpath has
1:             // been set in addition to -jar, as that's probably a mistake in
1:             // the calling code.
1:             assertNull("Both -jar and classpath specified", cp);
1:         } else {
1:             cmdlist.add("-classpath");
1:             cmdlist.add(cp == null ? getSystemProperty("java.class.path") : cp);
1:         }
commit:9902875
/////////////////////////////////////////////////////////////////////////
1: 
1:             // DERBY-5810: Make sure that emma.jar is included on the
1:             // classpath of the sub-process. (Only needed if a specific
1:             // classpath has been specified. Otherwise, the sub-process
1:             // inherits the classpath from the parent process, which
1:             // already includes emma.jar.)
1:             if (cp != null) {
1:                 cp += File.pathSeparator + getEmmaJar().getPath();
1:             }
/////////////////////////////////////////////////////////////////////////
1:      * Get a URL pointing to {@code emma.jar}, if the tests are running
1:      * with EMMA code coverage. The method returns {@code null} if the
1:      * tests are not running with EMMA.
1:      */
1:     public static URL getEmmaJar() {
1:         return SecurityManagerSetup.getURL("com.vladium.emma.EMMAException");
1:     }
1: 
1:     /**
commit:e437bc3
/////////////////////////////////////////////////////////////////////////
1:      * @param jvm the path to the java executable, or {@code null} to use
1:      *            the default executable returned by
1:      *            {@link #getJavaExecutableName()}
1:      * @param cp  the classpath for the spawned process, or {@code null} to
1:      *            inherit the classpath from the parent process
1:     public static Process execJavaCmd(
0:         String jvm, String cp, String[] cmd, final File dir)
1:         cmdlist.add(jvm == null ? getJavaExecutableName() : jvm);
/////////////////////////////////////////////////////////////////////////
0:         cmdlist.add(cp == null ? getSystemProperty("java.class.path") : cp);
1: 
/////////////////////////////////////////////////////////////////////////
1:      * shorthand for {@code execJavaCmd(null, null, cmd, null)}.
1:         return execJavaCmd(null, null, cmd, null);
commit:b9e0e74
/////////////////////////////////////////////////////////////////////////
1:         if (runsWithEmma()) {
1:             // DERBY-5801: If many processes write to the same file, it may
1:             // end up corrupted. Let each process have its own file to which
1:             // it writes coverage data.
1:             cmdlist.add("-Demma.coverage.out.file=" + getEmmaOutFile());
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Counter used by {@link #getEmmaOutFile()} to produce unique file names.
1:      */
0:     private static int emmaCount = 0;
1: 
1:     /**
1:      * Get a unique file object that can be used by sub-processes to store
1:      * EMMA code coverage data. Each separate sub-process should have its
1:      * own file in order to prevent corruption of the coverage data.
1:      *
1:      * @return a file to which a sub-process can write code coverage data
1:      */
1:     private static synchronized File getEmmaOutFile() {
1:         return new File(currentDirectory(),
0:                 "coverage-" + (++emmaCount) + ".ec");
1:     }
commit:f0951ab
/////////////////////////////////////////////////////////////////////////
1:      * @param dir working directory for the sub-process, or {@code null} to
1:      *            run in the same directory as the main test process
0: 	public static Process execJavaCmd(String[] cmd, final File dir)
1:             throws IOException {
/////////////////////////////////////////////////////////////////////////
0: 	        return (Process) AccessController
0: 	                result = Runtime.getRuntime().exec(
1:                             command, (String[]) null, dir);
1:      * Execute a java command and return the process. The process will run
1:      * in the same directory as the main test process. This method is a
0:      * shorthand for {@code execJavaCmd(cmd, null)}.
1:      */
1:     public static Process execJavaCmd(String[] cmd) throws IOException {
0:         return execJavaCmd(cmd, null);
1:     }
1: 
1:     /**
commit:b2dc02c
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (isCVM()) {
1:             // DERBY-5642: The default maximum heap size on CVM is very low.
1:             // Increase it to prevent OOME in the forked process.
1:             cmdlist.add("-Xmx32M");
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Check if this is a CVM-based VM (like phoneME or Oracle Java ME
1:      * Embedded Client).
1:      */
1:     public static boolean isCVM() {
1:         return "CVM".equals(getSystemProperty("java.vm.name"));
1:     }
1: 
1:     /**
1:         return isCVM() &&
commit:0a16899
/////////////////////////////////////////////////////////////////////////
1:      * SunOS
commit:dc5f56a
/////////////////////////////////////////////////////////////////////////
1:      * Check if the VM is phoneME.
1:      *
1:      * @return true if it is phoneME
1:      */
1:     public static boolean isPhoneME() {
0:         return getSystemProperty("java.vm.name").equals("CVM") &&
1:                 getSystemProperty("java.vm.version").startsWith("phoneme");
1:     }
1: 
1:     /**
commit:28358ab
/////////////////////////////////////////////////////////////////////////
1:         String vendor = getSystemProperty("java.vendor");
1:         return "Sun Microsystems Inc.".equals(vendor) ||
1:                 "Oracle Corporation".equals(vendor);
commit:035abcc
/////////////////////////////////////////////////////////////////////////
1:      * @param t the cause of the failure
1:     public static void fail(String msg, Throwable t)
0:         ae.initCause(t);
commit:33c9248
/////////////////////////////////////////////////////////////////////////
0:            int charsRead;
0:            while ((charsRead = inStream.read(ca, 0, ca.length)) != -1)
0:                output = output + new String(ca, 0, charsRead);
commit:6756142
/////////////////////////////////////////////////////////////////////////
0:            fail("Exception accessing inputstream from javacommand", e);
/////////////////////////////////////////////////////////////////////////
0:                if (output.indexOf(expectedString[i]) == -1) {
0:                    fail("Didn't find expected string: " + expectedString[i] +
0:                         "\nFull output from the command:\n" + output);
1:                }
commit:8cd67f5
/////////////////////////////////////////////////////////////////////////
0:         boolean trace = TestConfiguration.getCurrent().doTrace();
1:         long startTime = 0;
1:         if ( trace )
1:         {
1:             startTime = System.currentTimeMillis();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             super.runBare();   
1:         }
1:         finally{
1:             if ( trace )
1:             {
1:                 long timeUsed = System.currentTimeMillis() - startTime;
1:                 out.println();
0:                 out.print(getName() + " used " + timeUsed + " ms ");
1:             }
1:         }
commit:b2c1772
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Assert that the detailed messages of the 2 passed-in Throwable's are
1:      * equal (rather than '=='), as well as their class types.
1:      *
1:      * @param t1 first throwable to compare
1:      * @param t2 second throwable to compare
1:      */
1:     public static void assertThrowableEquals(Throwable t1,
1:                                              Throwable t2) {
1:         // Ensure non-null throwable's are being passed.
1:         assertNotNull(
1:             "Passed-in throwable t1 cannot be null to assert detailed message",
1:             t1);
1:         assertNotNull(
1:             "Passed-in throwable t2 cannot be null to assert detailed message",
1:             t2);
1: 
1:         // Now verify that the passed-in throwable are of the same type
1:         assertEquals("Throwable class types are different",
1:                      t1.getClass().getName(), t2.getClass().getName());
1: 
1:         // Here we finally check that the detailed message of both
1:         // throwable's is the same
1:         assertEquals("Detailed messages of the throwable's are different",
1:                      t1.getMessage(), t2.getMessage());
1:     }
commit:177992f
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get system property.
1:      *
1:      * @param name name of the property
1:      */
1:     protected static String getSystemProperty(final String name)
0: 	throws PrivilegedActionException {
1: 
0: 	return (String )AccessController.doPrivileged
0: 	    (new java.security.PrivilegedAction(){
1: 
0: 		    public Object run(){
0: 			return System.getProperty(name);
1: 
1: 		    }
1: 
1: 		}
0: 	     );
1:     }
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:ccf120c
/////////////////////////////////////////////////////////////////////////
1:                 // Copy some other likely files, the rolling log files
1:                 // These might occur if the tests are run with 
1:                 // derby.stream.error.style=rollingFile
1:                 for (int i=0; i < 10; i++) {
1:                     String logName = "derby-" + i + ".log";
1:                     File origRolLog = new File(DEFAULT_DB_DIR, logName);
1:                     File newRolLog = new File(failPath, logName);
1:                     PrivilegedFileOpsForTests.copy(origRolLog, newRolLog);
1:                 }
commit:4ee7918
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * assert a method from an executing test
1:      *
1:      * @param testLaunchMethod
1:      *            complete pathname of the method to be executed
1:      * @param databaseName
1:      *            name of the database to be used
1:      * @throws Exception
1:      */
1:     public static void assertLaunchedJUnitTestMethod(String testLaunchMethod,
1:             String databaseName)
1:             throws Exception 
1:     {
1:         String[] cmd = new String[] { 
1:                 "-Dderby.tests.defaultDatabaseName=" + databaseName, 
1:                 "junit.textui.TestRunner", "-m", testLaunchMethod };
1:         assertExecJavaCmdAsExpected(new String[] { "OK (1 test)" }, cmd, 0);
1:     }
commit:510d4fb
/////////////////////////////////////////////////////////////////////////
1: 	    {
1:             // also add the setting for emma.active so any tests
1:             // that fork will work correctly. See DERBY-5558.
1:             String emmaactive=getSystemProperty("emma.active");
0:             if (emmaactive != null)
1:                 cmdlist.add("-Demma.active=" + emmaactive);            
1: 	    }
commit:281d7e6
/////////////////////////////////////////////////////////////////////////
1: 	                    expectedString[i] + " in output:" + output,
commit:d9857c0
/////////////////////////////////////////////////////////////////////////
1: 	public static void assertExecJavaCmdAsExpected(String[] expectedString,
/////////////////////////////////////////////////////////////////////////
0: 	public static Process execJavaCmd(String[] cmd) throws IOException {
/////////////////////////////////////////////////////////////////////////
1:             throw (IOException) pe.getException();
/////////////////////////////////////////////////////////////////////////
0:    public static String readProcessOutput(Process pr) throws InterruptedException {
commit:63c65ac
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Execute command using 'java' executable and verify that it completes
1: 	 * with expected results
1: 	 * @param expectedString String to compare the resulting output with. May be
1: 	 *     null if the output is not expected to be of interest.
1: 	 * @param cmd array of java arguments for command
1: 	 * @param expectedExitValue expected return value from the command
1: 	 * @throws InterruptedException
1: 	 * @throws IOException
1: 	 */
0: 	public void assertExecJavaCmdAsExpected(String[] expectedString,
1: 	        String[] cmd, int expectedExitValue) throws InterruptedException,
1: 	        IOException {
1: 
1: 	    Process pr = execJavaCmd(cmd);
1: 	    String output = readProcessOutput(pr);
1: 	    int exitValue = pr.exitValue();
1: 
0: 	    Assert.assertEquals(expectedExitValue, exitValue);
1: 	    if (expectedString != null) {
1: 	        for (int i = 0; i < expectedString.length; i++) {
0: 	            assertFalse(output.indexOf(expectedString[i]) < 0);
1: 	        }
1: 	    }
1: 	}
1: 
1: 
1: 	/**
1: 	 * Execute a java command and return the process.
1: 	 * The caller should decide what to do with the process, if anything,
1: 	 * typical activities would be to do a pr.waitFor, or to
1: 	 * get a getInputStream or getErrorStream
1: 	 * Note, that for verifying the output of a Java process, there is
1: 	 * assertExecJavaCmdAsExpected
1: 	 * 
1: 	 * @param cmd array of java arguments for command
1: 	 * @return the process that was started
1: 	 * @throws IOException
1: 	 */
0: 	public Process execJavaCmd(String[] cmd) throws IOException {
0: 	    int totalSize = 3 + cmd.length;
0: 	    String[] tcmd = new String[totalSize];
0: 	    tcmd[0] = "java";
0: 	    tcmd[1] = "-classpath";
0: 	    tcmd[2] = BaseTestCase.getSystemProperty("java.class.path");
1: 
0: 	    System.arraycopy(cmd, 0, tcmd, 3, cmd.length);
1: 
0: 	    final String[] command = tcmd;
1: 
0: 	    Process pr = null;
1: 	    try {
0: 	        pr = (Process) AccessController
0: 	        .doPrivileged(new PrivilegedExceptionAction() {
0: 	            public Object run() throws IOException {
0: 	                Process result = null;
0: 	                result = Runtime.getRuntime().exec(command);
0: 	                return result;
1: 	            }
1: 	        });
1: 	    } catch (PrivilegedActionException pe) {
0: 	        Exception e = pe.getException();
0: 	        if (e instanceof IOException)
0: 	            throw (IOException) e;
1: 	        else
0: 	            throw (SecurityException) e;
1: 	    }
0: 	    return pr;
1: 	}
1:    
1:     * Reads output from a process and returns it as a string.
1:     * This will block until the process terminates.
1:     * 
1:     * @param pr a running process
0:     * @return output of the process
0:    public String readProcessOutput(Process pr) throws InterruptedException {
0: 		InputStream is = pr.getInputStream();
0: 		if (is == null) {
0: 			fail("Unexpectedly receiving no text from the process");
1: 		}
1: 
0: 		String output = "";
1: 		try {
0: 		    char[] ca = new char[1024];
0: 		    // Create an InputStreamReader with default encoding; we're hoping
0: 		    // this to be en. If not, we may not match the expected string.
0: 		    InputStreamReader inStream;
0: 		    inStream = new InputStreamReader(is);
1: 
0: 		    // keep reading from the stream until all done
0: 		    int charsRead;
0: 		    while ((charsRead = inStream.read(ca, 0, ca.length)) != -1)
1: 		    {
0: 		        output = output + new String(ca, 0, charsRead);
1: 		    }
0: 		} catch (Exception e) {
0: 		    fail("Exception accessing inputstream from process", e);
1: 		}
1: 
0: 		// wait until the process exits
0: 		pr.waitFor();
1: 		
1: 		return output;
1: 	}
1:    
commit:b85a450
/////////////////////////////////////////////////////////////////////////
1:                 assertSecurityManager();
1: 
1:             try{
0:                 AccessController.doPrivileged(new PrivilegedExceptionAction() {
0:                     public Object run() throws SQLException, FileNotFoundException,
0:                     IOException {
0:                         File origLogDir = new File("system", "derby.log");
0:                         if (origLogDir.exists()) {
0:                             File failDir = getFailureFolder();
0:                             InputStream in = new FileInputStream(origLogDir);
0:                             OutputStream out = new FileOutputStream(new File(failDir,
0:                             "derby.log"));
0:                             byte[] buf = new byte[32 * 1024];
0:                             for (;;) {
0:                                 int read = in.read(buf);
0:                                 if (read == -1)
1:                                     break;
0:                                 out.write(buf, 0, read);
1:                             }
0:                             in.close();
0:                             out.close();
1:                         }
1:                         return null;
1:                     }
1:                 });
1:             }
0:             finally{        		
1:                 throw running;
1:             }
commit:02c8976
/////////////////////////////////////////////////////////////////////////
0: import java.io.FileOutputStream;
0: import java.io.OutputStream;
/////////////////////////////////////////////////////////////////////////
0:         //To save the derby.log of failed tests. 
1:         catch (Throwable running) {
0:         	try{
0:         		AccessController.doPrivileged(new PrivilegedExceptionAction() {
0:         			public Object run() throws SQLException, FileNotFoundException,
0:         			IOException {
1: 
0:         				File origLogDir = new File("system", "derby.log");
0:         				if (origLogDir.exists()) {
0:         					File failDir = getFailureFolder();
0:         					InputStream in = new FileInputStream(origLogDir);
0:         					OutputStream out = new FileOutputStream(new File(failDir,
0:         					"derby.log"));
0:         					byte[] buf = new byte[32 * 1024];
1: 
0:         					for (;;) {
0:         						int read = in.read(buf);
0:         						if (read == -1)
0:         							break;
0:         						out.write(buf, 0, read);
1:         					}
0:         					in.close();
0:         					out.close();
1:         				}
1: 
0:         				return null;
1:         			}
1:         		});
1:         	}
0:         	finally{        		
0:         			throw running;
1:         	}
1:         }
commit:044179c
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.Assert;
/////////////////////////////////////////////////////////////////////////
0: import java.io.InputStreamReader;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1:    /**
0:     * Execute command using 'java' executable and verify that it completes
0:     * with expected results
0:     * @param expectedString String to compare the resulting output with. May be
0:     *     null if the output is not expected to be of interest.
0:     * @param cmd array of java arguments for command
0:     * @param expectedExitValue expected return value from the command
0:     * @throws InterruptedException
0:     * @throws IOException
1:     */
0:    public void  assertExecJavaCmdAsExpected(
0:            String[] expectedString, String[] cmd, int expectedExitValue)
0:    throws InterruptedException, IOException {
1:        
0:        int totalSize = 3 + cmd.length;
0:        String[] tcmd = new String[totalSize];
0:        tcmd[0] = "java";
0:        tcmd[1] = "-classpath";
0:        tcmd[2] = BaseTestCase.getSystemProperty("java.class.path");
1:                
0:        System.arraycopy(cmd, 0, tcmd, 3, cmd.length);
1:        
0:        final String[] command = tcmd;
0:        Process pr = null;
1:        try {
0:            pr = (Process) AccessController
0:                .doPrivileged(new PrivilegedExceptionAction() {
0:                    public Object run() throws IOException {
0:                        Process result = null;
0:                            result = Runtime.getRuntime().exec(command);
0:                        return result;
1:                    }
0:                });
0:        } catch (PrivilegedActionException pe) {
0:            Exception e = pe.getException();
0:            if (e instanceof IOException)
0:                throw (IOException) e;
0:            else
0:                throw (SecurityException) e;
1:        }
0:        InputStream is = pr.getInputStream();
0:        if ( is == null )
1:        {
0:            fail("Unexpectedly receiving no text from the java command");
1:        }
1:        
0:        String output = "";
0:        try
1:        {
0:            char[] ca = new char[1024];
0:            // Create an InputStreamReader with default encoding; we're hoping
0:            // this to be en. If not, we may not match the expected string.
0:            InputStreamReader inStream;
0:                inStream = new InputStreamReader(is);
0:            // keep reading from the stream until all done
0:            while ((inStream.read(ca, 0, ca.length)) != -1)
1:            {
0:                output = output + new String(ca).trim();
1:            }
0:        } catch (Exception e) {
0:            fail("Exception accessing inputstream from javacommand");
1:        }
1:        
0:        // wait until the process exits
0:        pr.waitFor();
1:        
0:        Assert.assertEquals(expectedExitValue, pr.exitValue());
0:        if (expectedString != null)
1:        {
0:            for (int i=0 ; i<expectedString.length ; i++)
1:            {
0:                assertFalse(output.indexOf(expectedString[i]) < 0);
1:            }
1:        }
1:    }
1:     
1:     /**
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:68e06ac
/////////////////////////////////////////////////////////////////////////
1:         boolean stopAfterFirstFail = config.stopAfterFirstFail();
/////////////////////////////////////////////////////////////////////////
1:                 if (stopAfterFirstFail) {
1:                     // if run with -Dderby.tests.stopAfterFirstFail=true
1:                     // exit after reporting failure. Useful for debugging
1:                     // cascading failures or errors that lead to hang.
1:                     running.printStackTrace(out);
1:                     System.exit(1);
1:                 }
0:                 else
0:                     throw running;
commit:1856e58
/////////////////////////////////////////////////////////////////////////
1:     public static final boolean isJava7() {
1:         return getSystemProperty("java.version").startsWith("1.7");
1:     }
commit:ce62de6
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
0: 	    ArrayList cmdlist = new ArrayList();
0: 	    cmdlist.add(getJavaExecutableName());
1: 	    if (isJ9Platform())
1: 	        cmdlist.add("-jcl:foun11");
0: 	    cmdlist.add("-classpath");
0: 	    cmdlist.add(getSystemProperty("java.class.path"));
1: 	    for (int i =0; i < cmd.length;i++) {
1: 	        cmdlist.add(cmd[i]);
1: 	    }
1: 	    final String[] command = (String[]) cmdlist.toArray(cmd);
commit:3b4b552
/////////////////////////////////////////////////////////////////////////
0:     * @return output of the process, both STDOUT and STDERR
0: 		InputStream es = pr.getErrorStream();
0: 		      output += "<STDOUT> " + inputStreamToString(is) + "<END STDOUT>\n";
0: 		      output += "<STDERR>" + inputStreamToString(es) + "<END STDERR>\n";
1: 		
/////////////////////////////////////////////////////////////////////////
0:      * Read contents of an input stream to a String
1:      * 
0:      * @param is
0:      * @return String with input stream contents
0:      * @throws IOException
1:      */
0:     private static String inputStreamToString(InputStream is) throws IOException {
1: 
0:         String isout = "";
0:         char[] ca = new char[1024];
0:         // Create an InputStreamReader with default encoding; we're hoping
0:         // this to be en.
0:         InputStreamReader inStream;
0:         inStream = new InputStreamReader(is);
1: 
0:         // keep reading from the stream until all done
0:         int charsRead;
0:         while ((charsRead = inStream.read(ca, 0, ca.length)) != -1) {
0:             isout = isout + new String(ca, 0, charsRead);
1:         }
0:         return isout;
1:     }
1:    
1:     /**
commit:8f56d99
/////////////////////////////////////////////////////////////////////////
1: 	    String expectedStrings = "";
1: 	    for (int i = 0; i < expectedString.length; i++) 
1: 	        expectedStrings += "\t[" +i + "]" + expectedString[i] +  "\n";
1: 	            "expected output strings:\n" + expectedStrings + 
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * assert a method from an executing test
1:      * 
1:      * @param testLaunchMethod
1:      *            complete pathname of the method to be executed
1:      * @throws Exception
1:      */
1:     public static void assertLaunchedJUnitTestMethod(String testLaunchMethod)
1:             throws Exception 
1:     {
1:         String[] cmd = new String[] { "junit.textui.TestRunner", "-m",
1:         testLaunchMethod };
1:         assertExecJavaCmdAsExpected(new String[] { "OK (1 test)" }, cmd, 0);
1:     }
commit:5311158
/////////////////////////////////////////////////////////////////////////
1: 	    println("execute java command:");
1: 	    for (int i = 0; i < command.length; i++) {
1: 	        println("command[" + i + "]" + command[i]);
1: 	    }
commit:fe374c1
/////////////////////////////////////////////////////////////////////////
1: 	            assertTrue("Could not find expectedString:" +
0: 	                    expectedString + " in output:" + output,
1: 	                    output.indexOf(expectedString[i]) >= 0);
commit:da92693
/////////////////////////////////////////////////////////////////////////
1: 	    Assert.assertEquals("expectedExitValue:" + expectedExitValue +
1: 	            " does not match exitValue:" + exitValue +"\n" +
0: 	            "expected output:" + expectedString + 
1: 	            " actual output:" + output,
1: 	            expectedExitValue, exitValue);
commit:23a4538
/////////////////////////////////////////////////////////////////////////
1:      * Determine if there is a platform match with os.name.
1:      * This method uses an exact equals. Other methods might be useful
1:      * later for starts with.
1:      * 
1:      * @param osName value we want to check against the system property
1:      *      os.name
1:      * @return return true if osName is an exact match for osName
1:      */
1:     
1:     public static final boolean isPlatform(String osName)  {
1: 
1:         return getSystemProperty("os.name").equals(osName);
1:     }
1:     
1:     /**
1:      * Check if this is java 5
1:      * @return true if java.version system property starts with 1.5
1:      */
1:     public static final boolean isJava5() {
1:         return getSystemProperty("java.version").startsWith("1.5");
1:     }
1:    
1:     /**
commit:30efca7
/////////////////////////////////////////////////////////////////////////
1:     public static final boolean isSunJVM() {
0:         return ("Sun Microsystems Inc.".equals(
1:                 getSystemProperty("java.vendor")));
1:     }
0:     
commit:4be9dce
/////////////////////////////////////////////////////////////////////////
0: 	    tcmd[0] = getJavaExecutableName();
commit:d773139
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
/////////////////////////////////////////////////////////////////////////
0:         //To save the derby.log  and database of failed tests.
1:                 String failPath = PrivilegedFileOpsForTests.getAbsolutePath(getFailureFolder());
0:                 File origLog = new File("system", "derby.log");
0:                 File newLog = new File(failPath, "derby.log");
1:                 PrivilegedFileOpsForTests.copy(origLog, newLog);
1:                 String dbName = TestConfiguration.getCurrent().getDefaultDatabaseName();
0:                 File dbDir = new File("system", dbName );                        
1:                 File newDbDir = new File(failPath, dbName);
1:                 PrivilegedFileOpsForTests.copy(dbDir,newDbDir);
1:            }
1:             catch (IOException ioe) {
1:                 // We need to throw the original exception so if there
0:                 // is an exception saving the db or derby.log we will just
0:                 // print it.
1:                 BaseTestCase.printStackTrace(ioe);
1:             finally {
commit:f23a20f
/////////////////////////////////////////////////////////////////////////
0: 
1: 	/**
0:          * Return the executable name for spawning java commands.
0:          * This will be <path to j9>/j9  for j9 jvms.
0: 	 * @return full path to java executable.
1:          */
0:          public static final String getJavaExecutableName() {
0:              String vmname = getSystemProperty("com.ibm.oti.vm.exe");
0:              if (vmname == null)
0:                  vmname = getSystemProperty("java.home") + File.separator + "bin" +
0:                  File.separator +"java";
0:              return vmname;
1:          }
0:           
commit:1e0eabf
/////////////////////////////////////////////////////////////////////////
0:             out.println();
0:             out.print(getName() + " ");
/////////////////////////////////////////////////////////////////////////
1:                 out.print("used " + timeUsed + " ms ");
commit:89e7a26
/////////////////////////////////////////////////////////////////////////
1:      * @param dir File of the directory
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:305a23d
/////////////////////////////////////////////////////////////////////////
1:             if (emmaactive != null) {
1:             }
1:             // Do the same for jacoco.active, see DERBY-6079.
1:             String jacocoactive = getSystemProperty("jacoco.active");
1:             if (jacocoactive != null) {
1:                 cmdlist.add("-Djacoco.active=" + jacocoactive);
1:             }
commit:1e0c703
/////////////////////////////////////////////////////////////////////////
1:         return SecurityManagerSetup.jacocoEnabled;
commit:a0f4b68
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1:      * Deletes the specified directory and all its files and subdirectories.
1:      * <p>
1:      * This method will attempt to delete all the files inside the root
1:      * directory, even if one of the delete operations fails.
1:      * <p>
1:      * After having tried to delete all files once, any remaining files will be
1:      * attempted deleted again after a pause. This is repeated, resulting
1:      * in multiple failed delete attempts for any single file before the method
1:      * gives up and raises a failure.
1:      * <p>
1:      * The approach above will mask any slowness involved in releasing file
1:      * handles, but should fail if a file handle actually isn't released on a
1:      * system that doesn't allow deletes on files with open handles (i.e.
1:      * Windows). It will also mask slowness caused by the JVM, the file system,
1:      * or the operation system.
1:      *
1:      * @param dir the root to start deleting from (root will also be deleted)
1:      */
1:     public static void assertDirectoryDeleted(File dir) {
1:         File[] fl = null;
1:         int attempts = 0;
1:         while (attempts < 4) {
1:             try {
1:                 Thread.sleep(attempts * 2000);
1:             } catch (InterruptedException ie) {
1:                 // Ignore
1:             }
1:             try {
1:                 fl = PrivilegedFileOpsForTests.persistentRecursiveDelete(dir);
1:                 attempts++;
1:             } catch (FileNotFoundException fnfe) {
1:                 if (attempts == 0) {
1:                     fail("directory doesn't exist: " +
1:                             PrivilegedFileOpsForTests.getAbsolutePath(dir));
1:                 } else  {
1:                     // In the previous iteration we saw remaining files, but
1:                     // now the root directory is gone. Not what we expected...
1:                     System.out.println("<assertDirectoryDeleted> root " +
1:                             "directory unexpectedly gone - delayed, " +
1:                             "external or concurrent delete?");
1:                     return;
1:                 }
1:             }
1:             if (fl.length == 0) {
1:                 return;
1:             } else {
1:                 // Print the list of remaining files to stdout for debugging.
1:                 StringBuffer sb = new StringBuffer();
1:                 sb.append("<assertDirectoryDeleted> attempt ").append(attempts).
1:                     append(" left ").append(fl.length).
1:                     append(" files/dirs behind:");
1:                 for (int i = 0; i < fl.length; i++) {
1:                     sb.append(' ').append(i).append('=').append(fl[i]);
1:                 }
1:                 System.out.println(sb);
1:             }
1:         }
1:         // If we failed to delete some of the files, list them and obtain some
1:         // information about each file.
1:         StringBuffer sb = new StringBuffer();
1:         for (int i = 0; i < fl.length; i++) {
1:             File f = fl[i];
1:             sb.append(PrivilegedFileOpsForTests.getAbsolutePath(f)).append(' ').
1:                 append(PrivilegedFileOpsForTests.getFileInfo(f)).append(", ");
1:         }
1:         sb.deleteCharAt(sb.length() - 1).deleteCharAt(sb.length() - 1);
1:         fail("Failed to delete " + fl.length + " files (root=" +
1:                 PrivilegedFileOpsForTests.getAbsolutePath(dir) + "): " +
1:                 sb.toString());
1:     }
0: 
1:     /**
commit:273ad5f
/////////////////////////////////////////////////////////////////////////
1:     private static final String JACOCO_AGENT_PROP = "derby.tests.jacoco.agent";
0: 
/////////////////////////////////////////////////////////////////////////
1:         if (runsWithJaCoCo()) {
1:             // Property (http://www.eclemma.org/jacoco/trunk/doc/agent.html):
1:             // -javaagent:[yourpath/]jacocoagent.jar=[opt1]=[val1],[opt2]=[val2]
1:             String agent = getSystemProperty(JACOCO_AGENT_PROP);
1:             cmdlist.add(agent + (agent.endsWith("=") ? "": ",") +
1:                     "destfile=" + getJaCoCoOutFile());
1:         }
0: 
/////////////////////////////////////////////////////////////////////////
1:     public static boolean runsWithJaCoCo() {
0:         String agentProp = getSystemProperty(JACOCO_AGENT_PROP);
0:         // Additional logic due to the use of a dummy property in build.xml
0:         return agentProp != null && agentProp.startsWith("-javaagent");
1:     }
0: 
1:      * Counter used to produce unique file names based on process count.
1:      *
1:      * @see #getEmmaOutFile()
1:      * @see #getJaCoCoOutFile()
1:     private static int spawnedCount = 0;
0: 
1:     /**
1:      * Get a unique file object that can be used by sub-processes to store
1:      * JaCoCo code coverage data. Each separate sub-process should have its
1:      * own file in order to prevent corruption of the coverage data.
1:      *
1:      * @return a file to which a sub-process can write code coverage data
1:      */
1:     private static synchronized File getJaCoCoOutFile() {
1:         return new File(currentDirectory(),
1:                 "jacoco.exec." + (++spawnedCount));
1:     }
/////////////////////////////////////////////////////////////////////////
1:                 "coverage-" + (++spawnedCount) + ".ec");
commit:afe4dfd
/////////////////////////////////////////////////////////////////////////
1:     /** Returns once the system timer has advanced at least one tick. */
1:     public static void sleepAtLeastOneTick() {
1:         long currentTime = System.currentTimeMillis(); 
1:         while (System.currentTimeMillis() == currentTime) {
1:             sleep(1);
1:         }
1:     }
0: 
1:     /** Makes the current thread sleep up to {@code ms} milliseconds. */
1:     public static void sleep(long ms) {
1:         try {
1:             Thread.sleep(ms);
1:         } catch (InterruptedException ie) {
1:             // For now we just print a warning if we are interrupted.
1:             alarm("sleep interrupted");
1:         }
1:     }
0: 
commit:0a0a6c2
/////////////////////////////////////////////////////////////////////////
1:         String output = "<STDOUT>" + wrapper.getFullServerOutput() +
commit:04846d1
/////////////////////////////////////////////////////////////////////////
1:             wrapper.complete();
commit:d96e3aa
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:      * Reads output from a process and returns it as a string.
1:      * <p>
0:      * This will block until the process terminates.
0:      * @param pr a running process
1:      * @return Output of the process, both STDOUT and STDERR.
1:      * @throws InterruptedException if interrupted while waiting for the
1:      *      subprocess or one of the output collector threads to terminate
1:     public static String readProcessOutput(Process pr)
1:             throws InterruptedException {
1:         SpawnedProcess wrapper = new SpawnedProcess(pr, "readProcessOutput");
1:         wrapper.suppressOutputOnComplete();
1:         try {
0:             wrapper.complete(false);
1:         } catch (IOException ioe) {
1:             fail("process completion method failed", ioe);
0:         String output = "<STDOUT> " + wrapper.getFullServerOutput() +
1:                 "<END STDOUT>\n";
1:         output += "<STDERR>" + wrapper.getFullServerError() +
1:                 "<END STDERR>\n";
0:         return output;
0: 
commit:3983707
/////////////////////////////////////////////////////////////////////////
1:             String  junitClassName = this.getClass().getName();
1:             junitClassName=Utilities.formatTestClassNames(junitClassName);
1:             out.print(traceClientType());
1:             out.print(junitClassName+"."+getName() + " ");
/////////////////////////////////////////////////////////////////////////
0: 
1:     private static String traceClientType() {
1:        if (TestConfiguration.getCurrent().getJDBCClient().isEmbedded()) {
1:             return "(emb)";
1:         } else {
1:             return "(net)";
1:         }
1:     }
commit:73122ce
/////////////////////////////////////////////////////////////////////////
1:      * Returns the major version of the class specification version supported
1:      * by the running JVM.
1:      * <ul>
1:      *  <li>48 = Java 1.4</li>
1:      *  <li>49 = Java 1.5</li>
1:      *  <li>50 = Java 1.6</li>
1:      *  <li>51 = Java 1.7</li>
1:      * </ul>
1:      *
1:      * @return Major version of class version specification, i.e. 49 for 49.0,
1:      *      or -1 if the version can't be obtained for some reason.
1:      */
1:     public static int getClassVersionMajor() {
1:         String tmp = getSystemProperty("java.class.version");
1:         if (tmp == null) {
1:             println("VM doesn't have property java.class.version");
1:             return -1;
1:         }
1:         // Is String.split safe to use by now?
1:         int dot = tmp.indexOf('.');
1:         int major = -1;
0:         try {
1:             major = Integer.parseInt(tmp.substring(0, dot));
1:         } catch (NumberFormatException nfe) {
1:             // Ignore, return -1.
1:         }
1:         return major;
1:     }
0: 
1:     /**
commit:fe7db0f
/////////////////////////////////////////////////////////////////////////
1: import java.io.PrintWriter;
/////////////////////////////////////////////////////////////////////////
1:         // To log the exception to file, copy the derby.log file and copy
1:         // the database of the failed test.
1:             PrintWriter stackOut = null;
1:                 // Write the stack trace of the error/failure to file.
1:                 stackOut = new PrintWriter(
1:                         PrivilegedFileOpsForTests.getFileOutputStream(
0:                             new File(failPath, "error-stacktrace.out"), true));
1:                 stackOut.println("[Error/failure logged at " +
1:                         new java.util.Date() + "]");
1:                 running.printStackTrace(stackOut);
1:                 stackOut.println(); // Add an extra blank line.
1:                 // Copy the derby.log file.
1:                 // Copy the database.
/////////////////////////////////////////////////////////////////////////
1:                 // is an exception saving the db or derby.log we will print it
1:                 // and additionally try to log it to file.
1:                 if (stackOut != null) {
1:                     stackOut.println("Copying derby.log or database failed:");
1:                     ioe.printStackTrace(stackOut);
1:                     stackOut.println();
0:                 }
1:                 if (stackOut != null) {
1:                     stackOut.close();
0:                 }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:056eff7
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * Determine if platform is a Windows variant.
1:      * <p>
1:      * Return true if platform is a windows platform.  Just looks for
1:      * os.name starting with "Windows".  The os.name property
1:      * can have at least the following values (there are probably more):
1:      *
1:      * AIX
1:      * Digital Unix
1:      * FreeBSD
1:      * HP UX
1:      * Irix
1:      * Linux
1:      * Mac OS
1:      * Mac OS X
1:      * MPE/iX
1:      * Netware 4.11
1:      * OS/2
0:      * Solaris
1:      * Windows 2000
1:      * Windows 95
1:      * Windows 98
1:      * Windows NT
1:      * Windows Vista
1:      * Windows XP
1:      * <p>
1:      *
1:      * @return true if running on a Windows platform.
1:      **/
1:     public static final boolean isWindowsPlatform() {
1:         return getSystemProperty("os.name").startsWith("Windows");
0:     }
author:Lily Wei
-------------------------------------------------------------------------------
commit:7b17fca
/////////////////////////////////////////////////////////////////////////
1:      * @return The list indicates files with certain prefix.
commit:4c5c16b
/////////////////////////////////////////////////////////////////////////
1: import java.io.FilenameFilter;
/////////////////////////////////////////////////////////////////////////
1:      * Get files in a directory which contain certain prefix
1:      * 
1:      * @param dir
1:      *        The directory we are checking for files with certain prefix
1:      * @param prefix
1:      *        The prefix pattern we are interested.
0:      * @retrun String[] The list indicates files with certain prefix.
1:      */
1:     protected static String[] getFilesWith(final File dir, String prefix) {
0:         return (String[]) AccessController
0:                 .doPrivileged(new java.security.PrivilegedAction() {
0:                     public Object run() {
1:                         //create a FilenameFilter and override its accept-method to file
1:                         //files start with "javacore"*
1:                         FilenameFilter filefilter = new FilenameFilter() {
1:                             public boolean accept(File dir, String name) {
1:                                 //if the file has prefix javacore return true, else false
1:                                 return name.startsWith("javacore");
0:                             }
1:                         };
1:                         return dir.list(filefilter);
0:                     }
0:                 });
0:     }
0:     
1:     /**
/////////////////////////////////////////////////////////////////////////
0:  
1:     /**
1:      * Remove all the files in the list
1:      * @param list the list contains all the files
1:      */
1:     public static void removeFiles(String[] list)
1:     {
1:         DropDatabaseSetup.removeFiles(list);
0:     }
author:Tiago Aurlio Rodrigues Espinha
-------------------------------------------------------------------------------
commit:e5a97fe
/////////////////////////////////////////////////////////////////////////
1:     public static final boolean isIBMJVM() {
1:         return ("IBM Corporation".equals(
0:                 getSystemProperty("java.vendor")));
0:     }
0:     
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:3450bb7
/////////////////////////////////////////////////////////////////////////
1:         TestConfiguration config = getTestConfiguration();
1:         boolean trace = config.doTrace();
/////////////////////////////////////////////////////////////////////////
1:             if (config.defaultSecurityManagerSetup())
commit:26ed4f9
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * Remove the directory and its contents.
1:      * @param path Path of the directory
1:      */
1:     public static void removeDirectory(String path)
1:     {
1:         DropDatabaseSetup.removeDirectory(path);
0:     }
1:     /**
1:      * Remove the directory and its contents.
0:      * @param fir File of the directory
1:      */
1:     public static void removeDirectory(File dir)
1:     {
1:         DropDatabaseSetup.removeDirectory(dir);
0:     }
commit:f8fd911
/////////////////////////////////////////////////////////////////////////
1:     public void runBare() throws Throwable {
commit:aabeeee
/////////////////////////////////////////////////////////////////////////
0:     {
/////////////////////////////////////////////////////////////////////////
0: 	{
/////////////////////////////////////////////////////////////////////////
0: 	{
/////////////////////////////////////////////////////////////////////////
0: 	{
commit:18facd4
/////////////////////////////////////////////////////////////////////////
0:     	if (getTestConfiguration().defaultSecurityManagerSetup())
0:     		assertSecurityManager();
commit:d2b9c54
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
/////////////////////////////////////////////////////////////////////////
1:      * override runTest, instead use test methods
0:     	 
0:     	super.runBare();   
/////////////////////////////////////////////////////////////////////////
1:      * Get the folder where a test leaves any information
1:      * about its failure.
1:      * @return Folder to use.
1:      * @see TestConfiguration#getFailureFolder(TestCase)
1:      */
1:     public final File getFailureFolder() {
1:         return getTestConfiguration().getFailureFolder(this);
0:     }
0:     
1:     /**
commit:e0104e8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     	return TestConfiguration.getCurrent();
/////////////////////////////////////////////////////////////////////////
1:         if (TestConfiguration.getCurrent().isVerbose()) {
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derbyTesting.junit;
/////////////////////////////////////////////////////////////////////////
0: 
commit:dd07790
/////////////////////////////////////////////////////////////////////////
0: 
0: import java.io.InputStream;
/////////////////////////////////////////////////////////////////////////
0:         // still not ready for prime time
0:     	//if (getTestConfiguration().defaultSecurityManagerSetup())
0:     	//	assertSecurityManager();
0:     	
0: 
1:     /**
1:      * Return the current configuration for the test.
1:      */
1:     public final TestConfiguration getTestConfiguration()
0:     {
0:     	return CONFIG;
0:     }
/////////////////////////////////////////////////////////////////////////
0:   
1:     /**
1:      * Open the URL for a a test resource, e.g. a policy
1:      * file or a SQL script.
1:      * @param url URL obtained from getTestResource
1:      * @return An open stream
1:     */
1:     protected static InputStream openTestResource(final URL url)
1:         throws PrivilegedActionException
0:     {
0:     	return (InputStream)AccessController.doPrivileged
0: 	    (new java.security.PrivilegedExceptionAction(){
0: 
0: 		    public Object run() throws IOException{
0: 			return url.openStream();
0: 
0: 		    }
0: 
0: 		}
0: 	     );    	
0:     }
commit:7d98408
/////////////////////////////////////////////////////////////////////////
1: import java.net.URL;
/////////////////////////////////////////////////////////////////////////
1:      * Run the test and force installation of a security
1:      * manager with the default test policy file.
1:      * Individual tests can run without a security
1:      * manager or with a different policy file using
1:      * the decorators obtained from SecurityManagerSetup.
1:      * <BR>
1:      * Method is final to ensure security manager is
1:      * enabled by default. Tests should not need to
0:      * ovveride runTest, instead use test methods
1:      * setUp, tearDown methods and decorators.
1:      */
0:     public final void runBare() throws Throwable {
0:     	// Not ready for prime time!
0:     	// SecurityManagerSetup.installSecurityManager();
0:     	super.runBare();
0:     }
0:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Remove system property
1:      *
1:      * @param name name of the property
1:      */
0:     protected static void removeSystemProperty(final String name)
0: 	throws PrivilegedActionException {
0: 	
1: 	AccessController.doPrivileged
0: 	    (new java.security.PrivilegedAction(){
0: 		    
0: 		    public Object run(){
0: 			System.getProperties().remove(name);
0: 			return null;
0: 			
0: 		    }
0: 		    
0: 		}
0: 	     );
0: 	
0:     }    
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Obtain the URL for a test resource, e.g. a policy
1:      * file or a SQL script.
1:      * @param name Resource name, typically - org.apache.derbyTesing.something
1:      * @return URL to the resource, null if it does not exist.
0:      * @throws PrivilegedActionException
1:      */
1:     protected static URL getTestResource(final String name)
0: 	throws PrivilegedActionException {
0: 
0: 	return (URL)AccessController.doPrivileged
0: 	    (new java.security.PrivilegedAction(){
0: 
0: 		    public Object run(){
0: 			return BaseTestCase.class.getClassLoader().
0: 			    getResource(name);
0: 
0: 		    }
0: 
0: 		}
0: 	     );
0:     }  
0:     
1:     /**
1:      * Assert a security manager is installed.
1:      *
1:      */
1:     public static void assertSecurityManager()
0:     {
1:     	assertNotNull("No SecurityManager installed",
1:     			System.getSecurityManager());
0:     }
0:     
commit:576a49f
/////////////////////////////////////////////////////////////////////////
1: public abstract class BaseTestCase
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:db2c1c2
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedInputStream;
1: import java.io.FileInputStream;
1: import java.io.FileNotFoundException;
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
0:     
1:     /**
1:      * Assert that two files in the filesystem are identical.
1:      * 
1:      * @param file1 the first file to compare
1:      * @param file2 the second file to compare
1:      */
1: 	public static void assertEquals(final File file1, final File file2) {
0: 		AccessController.doPrivileged
0:         (new PrivilegedAction() {
0:         	public Object run() {
0:         		try {
1: 					InputStream f1 = new BufferedInputStream(new FileInputStream(file1));
1: 					InputStream f2 = new BufferedInputStream(new FileInputStream(file2));
0: 
1: 					assertEquals(f1, f2);
1: 				} catch (FileNotFoundException e) {
1: 					fail("FileNotFoundException in assertEquals(File,File): " + e.getMessage());
1: 					e.printStackTrace();
1: 				} catch (IOException e) {
1: 					fail("IOException in assertEquals(File, File): " + e.getMessage());
1: 					e.printStackTrace();
0: 				}
0: 				return null;
0:         	}
0:         });
0: 	}
commit:15651f5
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
commit:37952cf
/////////////////////////////////////////////////////////////////////////
1: import java.io.PrintStream;
1: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Print alarm string
1:      * @param text String to print
1:      */
1:     public static void alarm(final String text) {
1:         out.println("ALARM: " + text);
0:     }
0: 
1:     /**
1:      * Print debug string.
1:      * @param text String to print
1:      */
1:     public static void println(final String text) {
0:         if (CONFIG.isVerbose()) {
1:             out.println("DEBUG: " + text);
0:         }
0:     }
0: 
1:     /**
1:      * Print debug string.
1:      * @param t Throwable object to print stack trace from
1:      */
1:     public static void printStackTrace(Throwable t) 
0:     {
1:         while ( t!= null) {
1:             t.printStackTrace(out);
0:             
1:             if (t instanceof SQLException)  {
1:                 t = ((SQLException) t).getNextException();
0:             } else {
0:                 break;
0:             }
0:         }
0:     }
0: 
1:     private final static PrintStream out = System.out;
0:     
author:Tomohito Nakayama
-------------------------------------------------------------------------------
commit:cccb382
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
0: 
1: import java.security.PrivilegedActionException;
0: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Set system property
1:      *
1:      * @param name name of the property
1:      * @param value value of the property
1:      */
1:     protected static void setSystemProperty(final String name, 
1: 					    final String value)
0: 	throws PrivilegedActionException {
0: 	
0: 	AccessController.doPrivileged
0: 	    (new java.security.PrivilegedAction(){
0: 		    
0: 		    public Object run(){
0: 			System.setProperty( name, value);
0: 			return null;
0: 			
0: 		    }
0: 		    
0: 		}
0: 	     );
0: 	
0:     }
0:     
0:     
author:David Van Couvering
-------------------------------------------------------------------------------
commit:b350a56
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
0:  * Derby - Class BaseTestCase
1:  *
0:  * Copyright 2006 The Apache Software Foundation or its 
0:  * licensors, as applicable.
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License");
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
1:  */
0: package org.apache.derbyTesting.functionTests.util;
0: 
1: import junit.framework.TestCase;
0: 
0: /**
1:  * Base class for JUnit tests.
1:  */
0: public class BaseTestCase
1:     extends TestCase {
0: 
0:     /**
0:      * Configuration for the test case.
0:      * The configuration is created based on system properties.
1:      *
0:      * @see TestConfiguration
1:      */
0:     public static final TestConfiguration CONFIG = 
0:         TestConfiguration.DERBY_TEST_CONFIG;
0:     
0:     /**
1:      * No argument constructor made private to enforce naming of test cases.
1:      * According to JUnit documentation, this constructor is provided for
1:      * serialization, which we don't currently use.
1:      *
1:      * @see #BaseTestCase(String)
1:      */
1:     private BaseTestCase() {}
0: 
0:     /**
1:      * Create a test case with the given name.
1:      *
1:      * @param name name of the test case.
1:      */
1:     public BaseTestCase(String name) {
1:         super(name);
0:     }
0:     
1: } // End class BaseTestCase
============================================================================