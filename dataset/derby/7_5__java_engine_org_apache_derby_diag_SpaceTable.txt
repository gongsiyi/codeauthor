1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.diag.SpaceTable
1:345de35: 
1:2f36947:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2f36947:    contributor license agreements.  See the NOTICE file distributed with
1:2f36947:    this work for additional information regarding copyright ownership.
1:2f36947:    The ASF licenses this file to You under the Apache License, Version 2.0
1:2f36947:    (the "License"); you may not use this file except in compliance with
1:2f36947:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
3:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.diag;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.SpaceInfo;
1:eac0369: import org.apache.derby.iapi.error.PublicAPI;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1:eac0369: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData;
1:eac0369: 
1:eac0369: import java.sql.ResultSetMetaData;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.Types;
1:eac0369: import org.apache.derby.vti.VTITemplate;
1:eac0369: import org.apache.derby.vti.VTICosting;
1:eac0369: import org.apache.derby.vti.VTIEnvironment;
1:eac0369: 
2:eac0369: /**
1:eac0369: 	SpaceTable is a virtual table that shows the space usage of a particular
1:eac0369:     table and its indexes.
1:eac0369: 	
1:eac0369: 	This virtual table can be invoked by calling it
1:eac0369: 	directly, and supplying the schema name and table name as arguments.
1:d3417fc:     <PRE> SELECT * FROM TABLE(SYSCS_DIAG.SPACE_TABLE('MYSCHEMA', 'MYTABLE')) T;  </PRE>
1:eac0369:     If the schema name is not supplied, the default schema is used.
1:d3417fc:     <PRE> SELECT * FROM TABLE(SYSCS_DIAG.SPACE_TABLE('MYTABLE')) T; </PRE>
1:eac0369:     <P>
1:eac0369:     NOTE: Both the schema name and the table name must be any expression that evaluates to a
1:eac0369:     string data type. If you created a schema or table name as a non-delimited identifier,
1:eac0369:     you must present their names in all upper case.
1:eac0369: 
1:eac0369: 
1:eac0369: 	<P>The SpaceTable virtual table can be used to estimate whether space
1:eac0369:     might be saved by compressing a table and its indexes.
1:eac0369: 
1:eac0369: 	<P>The SpaceTable virtual table has the following columns:
1:eac0369: 	<UL>
1:eac0369: 	<LI>CONGLOMERATENAME varchar(128) - nullable.  The name of the conglomerate,
1:eac0369:     which is either the table name or the index name. (Unlike the 
1:eac0369:     SYSCONGLOMERATES column of the same name, table ID's do not appear 
1:eac0369:     here).</LI>
1:eac0369: 	<LI>ISINDEX SMALLINT - not nullable.  Is not zero if the conglomerate is an 
1:eac0369:     index, 0 otherwise.</LI>
1:eac0369: 	<LI>NUMALLOCATEDPAGES bigint - not nullable.  The number of pages actively
1:eac0369:     linked into the table.  The total number of pages in the file is the
1:eac0369:     sum of NUMALLOCATEDPAGES + NUMFREEPAGES.</LI>
1:eac0369: 	<LI>NUMFREEPAGES bigint - not nullable. The number of free pages that 
1:eac0369:     belong to the table.  When a new page is to be linked into the table the
1:eac0369:     system will move a page from the NUMFREEPAGES list to the NUMALLOCATEDPAGES
1:eac0369:     list.  The total number of pages in the file is the sum of 
1:eac0369:     NUMALLOCATEDPAGES + NUMFREEPAGES.</LI>
1:eac0369: 	<LI>NUMUNFILLEDPAGES bigint - not nullable.  The number of unfilled pages 
1:eac0369:     that belong to the table. Unfilled pages are allocated pages that are not 
1:eac0369:     completely full. Note that the number of unfilled pages is an estimate and 
1:eac0369:     is not exact. Running the same query twice can give different results on 
1:eac0369:     this column. </LI>
1:eac0369: 	<LI>PAGESIZE integer - not nullable.  The size of the page in bytes for 
1:eac0369:     that conglomerate.
1:eac0369: 	</LI>
1:eac0369: 	<LI>ESTIMSPACESAVING bigint - not nullable.  The estimated space which 
1:eac0369:     could possibly be saved by compressing the conglomerate, in bytes.</LI>
1:01c7acb: 	<LI>TABLEID char(36) - not nullable.  The UUID of the table.</LI>
1:eac0369: 	</UL>
1:eac0369: 
1:eac0369: 
1:eac0369:     <P>
1:eac0369:     To get space information on all schemas and tables, use a query such as
1:eac0369:     <PRE>
1:eac0369:     select v.*
1:eac0369:     from SYS.SYSSCHEMAS s,
1:eac0369:          SYS.SYSTABLES t,
1:d3417fc:          TABLE(SYSCS_DIAG.SPACE_TABLE(SCHEMANAME, TABLENAME)) v
1:eac0369:     where s.SCHEMAID = t.SCHEMAID;
1:eac0369:     </PRE>
1:eac0369: */
1:4dede3b: public class SpaceTable extends VTITemplate implements VTICosting {
1:eac0369: 
1:eac0369: 	private ConglomInfo[] conglomTable;
1:eac0369: 	boolean initialized;
1:eac0369: 	int currentRow;
1:eac0369: 	private boolean wasNull;
1:eac0369:     private String schemaName;
1:eac0369:     private String tableName;
1:eac0369:     private SpaceInfo spaceInfo;
1:eac0369:     private TransactionController tc;
1:eac0369: 
1:271e7dd:     public  SpaceTable() {}
1:eac0369: 
1:eac0369:     public SpaceTable(String schemaName, String tableName)
1:eac0369:     {
1:eac0369:         this.schemaName = schemaName;
1:eac0369:         this.tableName = tableName;
1:eac0369:     }
1:eac0369: 
1:eac0369:     public SpaceTable(String tableName)
1:eac0369:     {
1:eac0369:         this.tableName = tableName;
1:eac0369:     }
1:eac0369: 
1:eac0369:     private void getConglomInfo(LanguageConnectionContext lcc)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         DataDictionary dd = lcc.getDataDictionary();
1:eac0369: 		
1:eac0369: 		if (schemaName == null)
1:271e7dd: 		{ schemaName = lcc.getCurrentSchemaName(); }
1:eac0369: 
1:271e7dd:         ConglomerateDescriptor[] cds;
1:271e7dd: 
1:271e7dd:         if ( tableName != null )
1:eac0369:         {
1:271e7dd:             // if schemaName is null, it gets the default schema
1:271e7dd:             SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, tc, true);
1:271e7dd:             TableDescriptor td = dd.getTableDescriptor(tableName,sd, tc);
1:271e7dd:             if (td == null)  // table does not exist
1:271e7dd:             {
1:271e7dd:                 conglomTable = new ConglomInfo[0];   // make empty conglom table
1:271e7dd:                 return;
1:271e7dd:             }
1:271e7dd:             cds = td.getConglomerateDescriptors();
1:eac0369:         }
1:271e7dd:         else // 0-arg constructor, no table name, get all conglomerates
1:271e7dd:         {
1:271e7dd:             cds = dd.getConglomerateDescriptors( null );
1:271e7dd:         }
1:271e7dd:         
1:eac0369:         // initialize spaceTable
1:eac0369:         conglomTable = new ConglomInfo[cds.length];
1:eac0369:         for (int i = 0; i < cds.length; i++)
1:01c7acb:         {
1:271e7dd:             String  conglomerateName;
1:271e7dd: 
1:271e7dd:             if ( cds[i].isIndex() ) { conglomerateName = cds[i].getConglomerateName(); }
1:271e7dd:             else if ( tableName != null ) { conglomerateName = tableName; }
1:271e7dd:             else
1:271e7dd:             {
1:271e7dd:                 // 0-arg constructor. need to ask data dictionary for name of table
1:271e7dd:                 conglomerateName = dd.getTableDescriptor( cds[i].getTableID() ).getName();
1:271e7dd:             }
1:271e7dd:             
1:01c7acb:             conglomTable[i] = new ConglomInfo
1:01c7acb:                 (
1:01c7acb:                  cds[i].getTableID().toString(),
1:01c7acb:                  cds[i].getConglomerateNumber(),
1:271e7dd:                  conglomerateName,
1:01c7acb:                  cds[i].isIndex()
1:01c7acb:                  );
1:01c7acb:         }
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     private void getSpaceInfo(int index)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:             ConglomerateController cc = tc.openConglomerate(
1:eac0369:                 conglomTable[index].getConglomId(),
1:eac0369:                 false,
1:eac0369:                 0,            // not for update
1:eac0369:                 TransactionController.MODE_RECORD,
1:eac0369:                 TransactionController.ISOLATION_READ_COMMITTED
1:eac0369:                 );
1:eac0369:             spaceInfo = cc.getSpaceInfo();
1:eac0369:             cc.close();
1:eac0369:             cc = null;
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#getMetaData
1:eac0369: 	 */
1:eac0369: 	public ResultSetMetaData getMetaData()
1:eac0369: 	{
1:eac0369: 		return metadata;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#next
1:eac0369: 		@exception SQLException if no transaction context can be found
1:eac0369: 	 */
1:eac0369: 	public boolean next() throws SQLException
1:eac0369: 	{
1:eac0369:         try
1:eac0369:         {
1:eac0369:      		if (!initialized)
1:eac0369:     		{
1:eac0369: 				LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
1:eac0369:                 tc = lcc.getTransactionExecute();
1:0978789:                getConglomInfo(lcc);
1:0978789:                 
1:eac0369: 			    initialized = true;
1:eac0369: 			    currentRow = -1;
1:eac0369: 		    }
1:eac0369: 		    if (conglomTable == null)
1:eac0369: 		    	return false;
1:eac0369:             currentRow++;
1:eac0369:             if (currentRow >= conglomTable.length)
1:eac0369:                 return false;
1:eac0369:             spaceInfo = null;
1:eac0369:             getSpaceInfo(currentRow);
1:eac0369:             return true;
1:eac0369:         }
1:eac0369:         catch (StandardException se)
1:eac0369:         {
1:eac0369:             throw PublicAPI.wrapStandardException(se);
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#close
1:eac0369: 	 */
1:eac0369: 	public void close()
1:eac0369: 	{
1:eac0369: 		conglomTable = null;
1:eac0369:         spaceInfo = null;
1:eac0369:         tc = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#getString
1:eac0369: 	 */
1:eac0369: 	public String getString(int columnNumber)
1:eac0369: 	{
1:eac0369: 		ConglomInfo conglomInfo = conglomTable[currentRow];
1:01c7acb:         String          str = null;
1:01c7acb:         
1:01c7acb: 		switch( columnNumber )
1:01c7acb: 		{
1:01c7acb: 		    case 1:
1:01c7acb: 			    str = conglomInfo.getConglomName();
1:01c7acb:                 break;
1:01c7acb:     		case 8:
1:01c7acb: 			    str = conglomInfo.getTableID();
1:01c7acb:                 break;
1:01c7acb: 		    default:
1:01c7acb: 			    break;
1:01c7acb: 		}
1:eac0369:    		wasNull = (str == null);
1:eac0369: 		return str;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:     @see java.sql.ResultSet#getLong
1:eac0369:     */
1:eac0369:     public long getLong(int columnNumber)
1:eac0369: 	{
1:eac0369:         long longval;
1:eac0369:         ConglomInfo conglomInfo = conglomTable[currentRow];
1:eac0369: 		switch(columnNumber)
1:eac0369: 		{
1:eac0369: 		    case 3:
1:eac0369: 			    longval = spaceInfo.getNumAllocatedPages();
1:eac0369:                 break;
1:eac0369:     		case 4:
1:eac0369: 			    longval = spaceInfo.getNumFreePages();
1:eac0369:                 break;
1:eac0369:     		case 5:
1:eac0369: 			    longval = spaceInfo.getNumUnfilledPages();
1:eac0369:                 break;
1:eac0369:     		case 7:
1:eac0369:                 int psize = spaceInfo.getPageSize();
1:eac0369: 			    longval = (spaceInfo.getNumFreePages() * psize);
1:eac0369:                 // unfilled page estimate is not reproducible/too unstable
1:eac0369:                 // + ((spaceInfo.getNumUnfilledPages() * psize) / 2);
1:eac0369:                 break;
1:eac0369: 		    default:
1:eac0369: 			    longval = -1;
1:eac0369: 		}
1:eac0369: 		wasNull = false;
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:             if (longval < 0)
1:eac0369:                 SanityManager.THROWASSERT("SpaceTable column number " + columnNumber +
1:eac0369:                     " has a negative value at row " + currentRow);
1:eac0369: 		return longval;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:     @see java.sql.ResultSet#getShort
1:eac0369:     */
1:eac0369:     public short getShort(int columnNumber)
1:eac0369: 	{
1:eac0369:         ConglomInfo conglomInfo = conglomTable[currentRow];
1:eac0369: 		wasNull = false;
1:eac0369: 		return (short) (conglomInfo.getIsIndex() ? 1 : 0);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:     @see java.sql.ResultSet#getInt
1:eac0369:     */
1:eac0369:     public int getInt(int columnNumber)
1:eac0369: 	{
1:eac0369: 		return spaceInfo.getPageSize();
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see java.sql.ResultSet#wasNull
1:eac0369: 	 */
1:eac0369: 	public boolean wasNull()
1:eac0369: 	{
1:eac0369: 		return wasNull;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**  VTI costing interface */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see VTICosting#getEstimatedRowCount
1:eac0369: 	 */
1:eac0369: 	public double getEstimatedRowCount(VTIEnvironment vtiEnvironment)
1:eac0369: 	{
1:eac0369: 		return VTICosting.defaultEstimatedRowCount;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see VTICosting#getEstimatedCostPerInstantiation
1:eac0369: 	 */
1:eac0369: 	public double getEstimatedCostPerInstantiation(VTIEnvironment vtiEnvironment)
1:eac0369: 	{
1:eac0369: 		return VTICosting.defaultEstimatedCost;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@return true
1:eac0369: 		@see VTICosting#supportsMultipleInstantiations
1:eac0369: 	 */
1:eac0369: 	public boolean supportsMultipleInstantiations(VTIEnvironment vtiEnvironment)
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Metadata
1:eac0369: 	*/
1:eac0369: 	private static final ResultColumnDescriptor[] columnInfo = {
1:eac0369: 
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("CONGLOMERATENAME",  Types.VARCHAR, true, 128),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("ISINDEX",           Types.SMALLINT, false),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("NUMALLOCATEDPAGES", Types.BIGINT, false),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("NUMFREEPAGES",      Types.BIGINT, false),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("NUMUNFILLEDPAGES",  Types.BIGINT, false),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("PAGESIZE",          Types.INTEGER, false),
1:eac0369: 		EmbedResultSetMetaData.getResultColumnDescriptor("ESTIMSPACESAVING",  Types.BIGINT, false),
1:01c7acb: 		EmbedResultSetMetaData.getResultColumnDescriptor("TABLEID",  Types.CHAR, false, 36),
1:eac0369: 	};
1:eac0369: 	
1:8514aa2:     private static final ResultSetMetaData metadata =
1:8514aa2:         new EmbedResultSetMetaData(columnInfo);
1:eac0369: 
1:eac0369: }
1:eac0369: 
1:eac0369: class ConglomInfo
1:eac0369: {
1:01c7acb:     private String  tableID;
1:eac0369:     private long conglomId;
1:eac0369:     private String conglomName;
1:eac0369:     private boolean isIndex;
1:eac0369: 
1:01c7acb:     public ConglomInfo(String tableID, long conglomId, String conglomName, boolean isIndex)
1:eac0369:     {
1:01c7acb:         this.tableID = tableID;
1:eac0369:         this.conglomId = conglomId;
1:eac0369:         this.conglomName = conglomName;
1:eac0369:         this.isIndex = isIndex;
1:eac0369:     }
1:eac0369: 
1:01c7acb:     public String getTableID()  { return tableID; }
1:01c7acb: 
1:eac0369:     public long getConglomId()
1:eac0369:     {
1:eac0369:         return conglomId;
1:eac0369:     }
1:eac0369: 
1:eac0369:     public String getConglomName()
1:eac0369:     {
1:eac0369:         return conglomName;
1:eac0369:     }
1:eac0369: 
1:eac0369:     public boolean getIsIndex()
1:eac0369:     {
1:eac0369:         return isIndex;
1:eac0369:     }
1:eac0369: }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8514aa2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static final ResultSetMetaData metadata =
1:         new EmbedResultSetMetaData(columnInfo);
commit:d3417fc
/////////////////////////////////////////////////////////////////////////
1:     <PRE> SELECT * FROM TABLE(SYSCS_DIAG.SPACE_TABLE('MYSCHEMA', 'MYTABLE')) T;  </PRE>
1:     <PRE> SELECT * FROM TABLE(SYSCS_DIAG.SPACE_TABLE('MYTABLE')) T; </PRE>
/////////////////////////////////////////////////////////////////////////
1:          TABLE(SYSCS_DIAG.SPACE_TABLE(SCHEMANAME, TABLENAME)) v
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:5570eb0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData40;
/////////////////////////////////////////////////////////////////////////
0: 	private static final ResultSetMetaData metadata = new EmbedResultSetMetaData40(columnInfo);
commit:271e7dd
/////////////////////////////////////////////////////////////////////////
1:     public  SpaceTable() {}
/////////////////////////////////////////////////////////////////////////
1: 		{ schemaName = lcc.getCurrentSchemaName(); }
1:         ConglomerateDescriptor[] cds;
1: 
1:         if ( tableName != null )
1:             // if schemaName is null, it gets the default schema
1:             SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, tc, true);
1:             TableDescriptor td = dd.getTableDescriptor(tableName,sd, tc);
1:             if (td == null)  // table does not exist
1:             {
1:                 conglomTable = new ConglomInfo[0];   // make empty conglom table
1:                 return;
1:             }
1:             cds = td.getConglomerateDescriptors();
1:         else // 0-arg constructor, no table name, get all conglomerates
1:         {
1:             cds = dd.getConglomerateDescriptors( null );
1:         }
1:         
1:             String  conglomerateName;
1: 
1:             if ( cds[i].isIndex() ) { conglomerateName = cds[i].getConglomerateName(); }
1:             else if ( tableName != null ) { conglomerateName = tableName; }
1:             else
1:             {
1:                 // 0-arg constructor. need to ask data dictionary for name of table
1:                 conglomerateName = dd.getTableDescriptor( cds[i].getTableID() ).getName();
1:             }
1:             
1:                  conglomerateName,
commit:01c7acb
/////////////////////////////////////////////////////////////////////////
1: 	<LI>TABLEID char(36) - not nullable.  The UUID of the table.</LI>
/////////////////////////////////////////////////////////////////////////
1:         {
1:             conglomTable[i] = new ConglomInfo
1:                 (
1:                  cds[i].getTableID().toString(),
1:                  cds[i].getConglomerateNumber(),
0:                  cds[i].isIndex() ? cds[i].getConglomerateName() : tableName,
1:                  cds[i].isIndex()
1:                  );
1:         }
/////////////////////////////////////////////////////////////////////////
1:         String          str = null;
1:         
1: 		switch( columnNumber )
1: 		{
1: 		    case 1:
1: 			    str = conglomInfo.getConglomName();
1:                 break;
1:     		case 8:
1: 			    str = conglomInfo.getTableID();
1:                 break;
1: 		    default:
1: 			    break;
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("TABLEID",  Types.CHAR, false, 36),
/////////////////////////////////////////////////////////////////////////
1:     private String  tableID;
1:     public ConglomInfo(String tableID, long conglomId, String conglomName, boolean isIndex)
1:         this.tableID = tableID;
1:     public String getTableID()  { return tableID; }
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:0978789
/////////////////////////////////////////////////////////////////////////
0:         SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, tc, true);
0:         TableDescriptor td = dd.getTableDescriptor(tableName,sd, tc);
/////////////////////////////////////////////////////////////////////////
1:                getConglomInfo(lcc);
1:                 
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.diag.SpaceTable
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:4dede3b
/////////////////////////////////////////////////////////////////////////
1: public class SpaceTable extends VTITemplate implements VTICosting {
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.diag
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.diag;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.store.access.AccessFactory;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.SpaceInfo;
1: import org.apache.derby.iapi.error.PublicAPI;
1: 
1: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData;
1: 
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Types;
1: import org.apache.derby.vti.VTITemplate;
1: import org.apache.derby.vti.VTICosting;
1: import org.apache.derby.vti.VTIEnvironment;
1: 
1: /**
1: 	SpaceTable is a virtual table that shows the space usage of a particular
1:     table and its indexes.
1: 	
1: 	This virtual table can be invoked by calling it
1: 	directly, and supplying the schema name and table name as arguments.
0: 	<PRE> select * from new org.apache.derby.diag.SpaceTable('MYSCHEMA','MYTABLE') t; </PRE>
1:     If the schema name is not supplied, the default schema is used.
0:     <PRE> select * from new org.apache.derby.diag.SpaceTable('MYTABLE') t; </PRE>
0:     Alternatively, the table can be invoked through the system alias SpaceTable
0:     <PRE> select * from new SPACETABLE('MYTABLE') t; </PRE>
1:     <P>
1:     NOTE: Both the schema name and the table name must be any expression that evaluates to a
1:     string data type. If you created a schema or table name as a non-delimited identifier,
1:     you must present their names in all upper case.
1: 
1: 
1: 	<P>The SpaceTable virtual table can be used to estimate whether space
1:     might be saved by compressing a table and its indexes.
1: 
1: 	<P>The SpaceTable virtual table has the following columns:
1: 	<UL>
1: 	<LI>CONGLOMERATENAME varchar(128) - nullable.  The name of the conglomerate,
1:     which is either the table name or the index name. (Unlike the 
1:     SYSCONGLOMERATES column of the same name, table ID's do not appear 
1:     here).</LI>
1: 	<LI>ISINDEX SMALLINT - not nullable.  Is not zero if the conglomerate is an 
1:     index, 0 otherwise.</LI>
1: 	<LI>NUMALLOCATEDPAGES bigint - not nullable.  The number of pages actively
1:     linked into the table.  The total number of pages in the file is the
1:     sum of NUMALLOCATEDPAGES + NUMFREEPAGES.</LI>
1: 	<LI>NUMFREEPAGES bigint - not nullable. The number of free pages that 
1:     belong to the table.  When a new page is to be linked into the table the
1:     system will move a page from the NUMFREEPAGES list to the NUMALLOCATEDPAGES
1:     list.  The total number of pages in the file is the sum of 
1:     NUMALLOCATEDPAGES + NUMFREEPAGES.</LI>
1: 	<LI>NUMUNFILLEDPAGES bigint - not nullable.  The number of unfilled pages 
1:     that belong to the table. Unfilled pages are allocated pages that are not 
1:     completely full. Note that the number of unfilled pages is an estimate and 
1:     is not exact. Running the same query twice can give different results on 
1:     this column. </LI>
1: 	<LI>PAGESIZE integer - not nullable.  The size of the page in bytes for 
1:     that conglomerate.
1: 	</LI>
1: 	<LI>ESTIMSPACESAVING bigint - not nullable.  The estimated space which 
1:     could possibly be saved by compressing the conglomerate, in bytes.</LI>
1: 	</UL>
1: 
1: 
1:     <P>
1:     To get space information on all schemas and tables, use a query such as
1:     <PRE>
1:     select v.*
1:     from SYS.SYSSCHEMAS s,
1:          SYS.SYSTABLES t,
0:          new org.apache.derby.diag.SpaceTable(SCHEMANAME,TABLENAME) v
1:     where s.SCHEMAID = t.SCHEMAID;
1:     </PRE>
1: */
0: public class SpaceTable extends VTITemplate implements VTICosting { 
1: 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
1: 
1: 	private ConglomInfo[] conglomTable;
1: 	boolean initialized;
1: 	int currentRow;
1: 	private boolean wasNull;
1:     private String schemaName;
1:     private String tableName;
1:     private SpaceInfo spaceInfo;
1:     private TransactionController tc;
1: 
1: 
1:     public SpaceTable(String schemaName, String tableName)
1:     {
1:         this.schemaName = schemaName;
1:         this.tableName = tableName;
1:     }
1: 
1:     public SpaceTable(String tableName)
1:     {
1:         this.tableName = tableName;
1:     }
1: 
1:     private void getConglomInfo(LanguageConnectionContext lcc)
1:         throws StandardException
1:     {
1:         DataDictionary dd = lcc.getDataDictionary();
1: 		
1: 		if (schemaName == null)
0: 			schemaName = lcc.getCurrentSchemaName();
1: 
0:         // if schemaName is null, it gets the default schema
0:         SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, lcc.getTransactionExecute(), true);
0:         TableDescriptor td = dd.getTableDescriptor(tableName,sd);
0:         if (td == null)  // table does not exist
1:         {
0:             conglomTable = new ConglomInfo[0];   // make empty conglom table
0:             return;
1:         }
0:         ConglomerateDescriptor[] cds = td.getConglomerateDescriptors();
1:         // initialize spaceTable
1:         conglomTable = new ConglomInfo[cds.length];
1:         for (int i = 0; i < cds.length; i++)
0:             conglomTable[i] = new ConglomInfo(
0:                 cds[i].getConglomerateNumber(),
0:                 cds[i].isIndex() ? cds[i].getConglomerateName() : tableName,
0:                 cds[i].isIndex());
1:     }
1: 
1: 
1:     private void getSpaceInfo(int index)
1:         throws StandardException
1:     {
1:             ConglomerateController cc = tc.openConglomerate(
1:                 conglomTable[index].getConglomId(),
1:                 false,
1:                 0,            // not for update
1:                 TransactionController.MODE_RECORD,
1:                 TransactionController.ISOLATION_READ_COMMITTED
1:                 );
1:             spaceInfo = cc.getSpaceInfo();
1:             cc.close();
1:             cc = null;
1:     }
1: 
1: 
1: 	/**
1: 		@see java.sql.ResultSet#getMetaData
1: 	 */
1: 	public ResultSetMetaData getMetaData()
1: 	{
1: 		return metadata;
1: 	}
1: 
1: 	/**
1: 		@see java.sql.ResultSet#next
1: 		@exception SQLException if no transaction context can be found
1: 	 */
1: 	public boolean next() throws SQLException
1: 	{
1:         try
1:         {
1:      		if (!initialized)
1:     		{
1: 				LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
0:                getConglomInfo(lcc);
1:                 tc = lcc.getTransactionExecute();
1: 			    initialized = true;
1: 			    currentRow = -1;
1: 		    }
1: 		    if (conglomTable == null)
1: 		    	return false;
1:             currentRow++;
1:             if (currentRow >= conglomTable.length)
1:                 return false;
1:             spaceInfo = null;
1:             getSpaceInfo(currentRow);
1:             return true;
1:         }
1:         catch (StandardException se)
1:         {
1:             throw PublicAPI.wrapStandardException(se);
1:         }
1:     }
1: 
1: 
1: 	/**
1: 		@see java.sql.ResultSet#close
1: 	 */
1: 	public void close()
1: 	{
1: 		conglomTable = null;
1:         spaceInfo = null;
1:         tc = null;
1: 	}
1: 
1: 	/**
1: 		@see java.sql.ResultSet#getString
1: 	 */
1: 	public String getString(int columnNumber)
1: 	{
1: 		ConglomInfo conglomInfo = conglomTable[currentRow];
0: 		String str = conglomInfo.getConglomName();
1:    		wasNull = (str == null);
1: 		return str;
1: 	}
1: 
1:     /**
1:     @see java.sql.ResultSet#getLong
1:     */
1:     public long getLong(int columnNumber)
1: 	{
1:         long longval;
1:         ConglomInfo conglomInfo = conglomTable[currentRow];
1: 		switch(columnNumber)
1: 		{
1: 		    case 3:
1: 			    longval = spaceInfo.getNumAllocatedPages();
1:                 break;
1:     		case 4:
1: 			    longval = spaceInfo.getNumFreePages();
1:                 break;
1:     		case 5:
1: 			    longval = spaceInfo.getNumUnfilledPages();
1:                 break;
1:     		case 7:
1:                 int psize = spaceInfo.getPageSize();
1: 			    longval = (spaceInfo.getNumFreePages() * psize);
1:                 // unfilled page estimate is not reproducible/too unstable
1:                 // + ((spaceInfo.getNumUnfilledPages() * psize) / 2);
1:                 break;
1: 		    default:
1: 			    longval = -1;
1: 		}
1: 		wasNull = false;
1:         if (SanityManager.DEBUG)
1:             if (longval < 0)
1:                 SanityManager.THROWASSERT("SpaceTable column number " + columnNumber +
1:                     " has a negative value at row " + currentRow);
1: 		return longval;
1:     }
1: 
1:     /**
1:     @see java.sql.ResultSet#getShort
1:     */
1:     public short getShort(int columnNumber)
1: 	{
1:         ConglomInfo conglomInfo = conglomTable[currentRow];
1: 		wasNull = false;
1: 		return (short) (conglomInfo.getIsIndex() ? 1 : 0);
1:     }
1: 
1: 
1:     /**
1:     @see java.sql.ResultSet#getInt
1:     */
1:     public int getInt(int columnNumber)
1: 	{
1: 		return spaceInfo.getPageSize();
1:     }
1: 
1: 
1: 	/**
1: 		@see java.sql.ResultSet#wasNull
1: 	 */
1: 	public boolean wasNull()
1: 	{
1: 		return wasNull;
1: 	}
1: 
1: 
1: 	/**  VTI costing interface */
1: 
1: 	/**
1: 		@see VTICosting#getEstimatedRowCount
1: 	 */
1: 	public double getEstimatedRowCount(VTIEnvironment vtiEnvironment)
1: 	{
1: 		return VTICosting.defaultEstimatedRowCount;
1: 	}
1: 
1: 	/**
1: 		@see VTICosting#getEstimatedCostPerInstantiation
1: 	 */
1: 	public double getEstimatedCostPerInstantiation(VTIEnvironment vtiEnvironment)
1: 	{
1: 		return VTICosting.defaultEstimatedCost;
1: 	}
1: 
1: 	/**
1: 		@return true
1: 		@see VTICosting#supportsMultipleInstantiations
1: 	 */
1: 	public boolean supportsMultipleInstantiations(VTIEnvironment vtiEnvironment)
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/*
1: 	** Metadata
1: 	*/
1: 	private static final ResultColumnDescriptor[] columnInfo = {
1: 
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("CONGLOMERATENAME",  Types.VARCHAR, true, 128),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("ISINDEX",           Types.SMALLINT, false),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("NUMALLOCATEDPAGES", Types.BIGINT, false),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("NUMFREEPAGES",      Types.BIGINT, false),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("NUMUNFILLEDPAGES",  Types.BIGINT, false),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("PAGESIZE",          Types.INTEGER, false),
1: 		EmbedResultSetMetaData.getResultColumnDescriptor("ESTIMSPACESAVING",  Types.BIGINT, false),
1: 	};
1: 	
0: 	private static final ResultSetMetaData metadata = new EmbedResultSetMetaData(columnInfo);
1: 
1: }
1: 
1: class ConglomInfo
1: {
1:     private long conglomId;
1:     private String conglomName;
1:     private boolean isIndex;
1: 
0:     public ConglomInfo(long conglomId, String conglomName, boolean isIndex)
1:     {
1:         this.conglomId = conglomId;
1:         this.conglomName = conglomName;
1:         this.isIndex = isIndex;
1:     }
1: 
1:     public long getConglomId()
1:     {
1:         return conglomId;
1:     }
1: 
1:     public String getConglomName()
1:     {
1:         return conglomName;
1:     }
1: 
1:     public boolean getIsIndex()
1:     {
1:         return isIndex;
1:     }
1: }
1: 
1: 
1: 
1: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:2f36947
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.diag
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.diag;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.store.access.AccessFactory;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.SpaceInfo;
0: import org.apache.derby.iapi.error.PublicAPI;
0: 
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.impl.jdbc.EmbedResultSetMetaData;
0: 
0: import java.sql.ResultSetMetaData;
0: import java.sql.SQLException;
0: import java.sql.Types;
0: import org.apache.derby.vti.VTITemplate;
0: import org.apache.derby.vti.VTICosting;
0: import org.apache.derby.vti.VTIEnvironment;
0: 
0: /**
0: 	SpaceTable is a virtual table that shows the space usage of a particular
0:     table and its indexes.
0: 	
0: 	This virtual table can be invoked by calling it
0: 	directly, and supplying the schema name and table name as arguments.
0: 	<PRE> select * from new org.apache.derby.diag.SpaceTable('MYSCHEMA','MYTABLE') t; </PRE>
0:     If the schema name is not supplied, the default schema is used.
0:     <PRE> select * from new org.apache.derby.diag.SpaceTable('MYTABLE') t; </PRE>
0:     Alternatively, the table can be invoked through the system alias SpaceTable
0:     <PRE> select * from new SPACETABLE('MYTABLE') t; </PRE>
0:     <P>
0:     NOTE: Both the schema name and the table name must be any expression that evaluates to a
0:     string data type. If you created a schema or table name as a non-delimited identifier,
0:     you must present their names in all upper case.
0: 
0: 
0: 	<P>The SpaceTable virtual table can be used to estimate whether space
0:     might be saved by compressing a table and its indexes.
0: 
0: 	<P>The SpaceTable virtual table has the following columns:
0: 	<UL>
0: 	<LI>CONGLOMERATENAME varchar(128) - nullable.  The name of the conglomerate,
0:     which is either the table name or the index name. (Unlike the 
0:     SYSCONGLOMERATES column of the same name, table ID's do not appear 
0:     here).</LI>
0: 	<LI>ISINDEX SMALLINT - not nullable.  Is not zero if the conglomerate is an 
0:     index, 0 otherwise.</LI>
0: 	<LI>NUMALLOCATEDPAGES bigint - not nullable.  The number of pages actively
0:     linked into the table.  The total number of pages in the file is the
0:     sum of NUMALLOCATEDPAGES + NUMFREEPAGES.</LI>
0: 	<LI>NUMFREEPAGES bigint - not nullable. The number of free pages that 
0:     belong to the table.  When a new page is to be linked into the table the
0:     system will move a page from the NUMFREEPAGES list to the NUMALLOCATEDPAGES
0:     list.  The total number of pages in the file is the sum of 
0:     NUMALLOCATEDPAGES + NUMFREEPAGES.</LI>
0: 	<LI>NUMUNFILLEDPAGES bigint - not nullable.  The number of unfilled pages 
0:     that belong to the table. Unfilled pages are allocated pages that are not 
0:     completely full. Note that the number of unfilled pages is an estimate and 
0:     is not exact. Running the same query twice can give different results on 
0:     this column. </LI>
0: 	<LI>PAGESIZE integer - not nullable.  The size of the page in bytes for 
0:     that conglomerate.
0: 	</LI>
0: 	<LI>ESTIMSPACESAVING bigint - not nullable.  The estimated space which 
0:     could possibly be saved by compressing the conglomerate, in bytes.</LI>
0: 	</UL>
0: 
0: 
0:     <P>
0:     To get space information on all schemas and tables, use a query such as
0:     <PRE>
0:     select v.*
0:     from SYS.SYSSCHEMAS s,
0:          SYS.SYSTABLES t,
0:          new org.apache.derby.diag.SpaceTable(SCHEMANAME,TABLENAME) v
0:     where s.SCHEMAID = t.SCHEMAID;
0:     </PRE>
0: */
0: public class SpaceTable extends VTITemplate implements VTICosting { 
0: 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0: 
0: 	private ConglomInfo[] conglomTable;
0: 	boolean initialized;
0: 	int currentRow;
0: 	private boolean wasNull;
0:     private String schemaName;
0:     private String tableName;
0:     private SpaceInfo spaceInfo;
0:     private TransactionController tc;
0: 
0: 
0:     public SpaceTable(String schemaName, String tableName)
0:     {
0:         this.schemaName = schemaName;
0:         this.tableName = tableName;
0:     }
0: 
0:     public SpaceTable(String tableName)
0:     {
0:         this.tableName = tableName;
0:     }
0: 
0:     private void getConglomInfo(LanguageConnectionContext lcc)
0:         throws StandardException
0:     {
0:         DataDictionary dd = lcc.getDataDictionary();
0: 		
0: 		if (schemaName == null)
0: 			schemaName = lcc.getCurrentSchemaName();
0: 
0:         // if schemaName is null, it gets the default schema
0:         SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, lcc.getTransactionExecute(), true);
0:         TableDescriptor td = dd.getTableDescriptor(tableName,sd);
0:         if (td == null)  // table does not exist
0:         {
0:             conglomTable = new ConglomInfo[0];   // make empty conglom table
0:             return;
0:         }
0:         ConglomerateDescriptor[] cds = td.getConglomerateDescriptors();
0:         // initialize spaceTable
0:         conglomTable = new ConglomInfo[cds.length];
0:         for (int i = 0; i < cds.length; i++)
0:             conglomTable[i] = new ConglomInfo(
0:                 cds[i].getConglomerateNumber(),
0:                 cds[i].isIndex() ? cds[i].getConglomerateName() : tableName,
0:                 cds[i].isIndex());
0:     }
0: 
0: 
0:     private void getSpaceInfo(int index)
0:         throws StandardException
0:     {
0:             ConglomerateController cc = tc.openConglomerate(
0:                 conglomTable[index].getConglomId(),
0:                 false,
0:                 0,            // not for update
0:                 TransactionController.MODE_RECORD,
0:                 TransactionController.ISOLATION_READ_COMMITTED
0:                 );
0:             spaceInfo = cc.getSpaceInfo();
0:             cc.close();
0:             cc = null;
0:     }
0: 
0: 
0: 	/**
0: 		@see java.sql.ResultSet#getMetaData
0: 	 */
0: 	public ResultSetMetaData getMetaData()
0: 	{
0: 		return metadata;
0: 	}
0: 
0: 	/**
0: 		@see java.sql.ResultSet#next
0: 		@exception SQLException if no transaction context can be found
0: 	 */
0: 	public boolean next() throws SQLException
0: 	{
0:         try
0:         {
0:      		if (!initialized)
0:     		{
0: 				LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();
0:                getConglomInfo(lcc);
0:                 tc = lcc.getTransactionExecute();
0: 			    initialized = true;
0: 			    currentRow = -1;
0: 		    }
0: 		    if (conglomTable == null)
0: 		    	return false;
0:             currentRow++;
0:             if (currentRow >= conglomTable.length)
0:                 return false;
0:             spaceInfo = null;
0:             getSpaceInfo(currentRow);
0:             return true;
0:         }
0:         catch (StandardException se)
0:         {
0:             throw PublicAPI.wrapStandardException(se);
0:         }
0:     }
0: 
0: 
0: 	/**
0: 		@see java.sql.ResultSet#close
0: 	 */
0: 	public void close()
0: 	{
0: 		conglomTable = null;
0:         spaceInfo = null;
0:         tc = null;
0: 	}
0: 
0: 	/**
0: 		@see java.sql.ResultSet#getString
0: 	 */
0: 	public String getString(int columnNumber)
0: 	{
0: 		ConglomInfo conglomInfo = conglomTable[currentRow];
0: 		String str = conglomInfo.getConglomName();
0:    		wasNull = (str == null);
0: 		return str;
0: 	}
0: 
0:     /**
0:     @see java.sql.ResultSet#getLong
0:     */
0:     public long getLong(int columnNumber)
0: 	{
0:         long longval;
0:         ConglomInfo conglomInfo = conglomTable[currentRow];
0: 		switch(columnNumber)
0: 		{
0: 		    case 3:
0: 			    longval = spaceInfo.getNumAllocatedPages();
0:                 break;
0:     		case 4:
0: 			    longval = spaceInfo.getNumFreePages();
0:                 break;
0:     		case 5:
0: 			    longval = spaceInfo.getNumUnfilledPages();
0:                 break;
0:     		case 7:
0:                 int psize = spaceInfo.getPageSize();
0: 			    longval = (spaceInfo.getNumFreePages() * psize);
0:                 // unfilled page estimate is not reproducible/too unstable
0:                 // + ((spaceInfo.getNumUnfilledPages() * psize) / 2);
0:                 break;
0: 		    default:
0: 			    longval = -1;
0: 		}
0: 		wasNull = false;
0:         if (SanityManager.DEBUG)
0:             if (longval < 0)
0:                 SanityManager.THROWASSERT("SpaceTable column number " + columnNumber +
0:                     " has a negative value at row " + currentRow);
0: 		return longval;
0:     }
0: 
0:     /**
0:     @see java.sql.ResultSet#getShort
0:     */
0:     public short getShort(int columnNumber)
0: 	{
0:         ConglomInfo conglomInfo = conglomTable[currentRow];
0: 		wasNull = false;
0: 		return (short) (conglomInfo.getIsIndex() ? 1 : 0);
0:     }
0: 
0: 
0:     /**
0:     @see java.sql.ResultSet#getInt
0:     */
0:     public int getInt(int columnNumber)
0: 	{
0: 		return spaceInfo.getPageSize();
0:     }
0: 
0: 
0: 	/**
0: 		@see java.sql.ResultSet#wasNull
0: 	 */
0: 	public boolean wasNull()
0: 	{
0: 		return wasNull;
0: 	}
0: 
0: 
0: 	/**  VTI costing interface */
0: 
0: 	/**
0: 		@see VTICosting#getEstimatedRowCount
0: 	 */
0: 	public double getEstimatedRowCount(VTIEnvironment vtiEnvironment)
0: 	{
0: 		return VTICosting.defaultEstimatedRowCount;
0: 	}
0: 
0: 	/**
0: 		@see VTICosting#getEstimatedCostPerInstantiation
0: 	 */
0: 	public double getEstimatedCostPerInstantiation(VTIEnvironment vtiEnvironment)
0: 	{
0: 		return VTICosting.defaultEstimatedCost;
0: 	}
0: 
0: 	/**
0: 		@return true
0: 		@see VTICosting#supportsMultipleInstantiations
0: 	 */
0: 	public boolean supportsMultipleInstantiations(VTIEnvironment vtiEnvironment)
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/*
0: 	** Metadata
0: 	*/
0: 	private static final ResultColumnDescriptor[] columnInfo = {
0: 
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("CONGLOMERATENAME",  Types.VARCHAR, true, 128),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("ISINDEX",           Types.SMALLINT, false),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("NUMALLOCATEDPAGES", Types.BIGINT, false),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("NUMFREEPAGES",      Types.BIGINT, false),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("NUMUNFILLEDPAGES",  Types.BIGINT, false),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("PAGESIZE",          Types.INTEGER, false),
0: 		EmbedResultSetMetaData.getResultColumnDescriptor("ESTIMSPACESAVING",  Types.BIGINT, false),
0: 	};
0: 	
0: 	private static final ResultSetMetaData metadata = new EmbedResultSetMetaData(columnInfo);
0: 
0: }
0: 
0: class ConglomInfo
0: {
0:     private long conglomId;
0:     private String conglomName;
0:     private boolean isIndex;
0: 
0:     public ConglomInfo(long conglomId, String conglomName, boolean isIndex)
0:     {
0:         this.conglomId = conglomId;
0:         this.conglomName = conglomName;
0:         this.isIndex = isIndex;
0:     }
0: 
0:     public long getConglomId()
0:     {
0:         return conglomId;
0:     }
0: 
0:     public String getConglomName()
0:     {
0:         return conglomName;
0:     }
0: 
0:     public boolean getIsIndex()
0:     {
0:         return isIndex;
0:     }
0: }
0: 
0: 
0: 
0: 
============================================================================