1:b7730e4: /*
6:b7730e4: 
1:b7730e4:    Derby - Class org.apache.derby.iapi.sql.dictionary.StatementColumnPermission
1:b7730e4: 
1:2e658c2:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2e658c2:    contributor license agreements.  See the NOTICE file distributed with
1:2e658c2:    this work for additional information regarding copyright ownership.
1:2e658c2:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2e658c2:    (the "License"); you may not use this file except in compliance with
1:2e658c2:    the License.  You may obtain a copy of the License at
1:b7730e4: 
1:b7730e4: 	  http://www.apache.org/licenses/LICENSE-2.0
1:b7730e4: 
1:b7730e4:    Unless required by applicable law or agreed to in writing, software
1:b7730e4:    distributed under the License is distributed on an "AS IS" BASIS,
1:b7730e4:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b7730e4:    See the License for the specific language governing permissions and
1:b7730e4:    limitations under the License.
1:b7730e4: 
1:b7730e4:  */
1:b7730e4: 
1:b7730e4: package org.apache.derby.iapi.sql.dictionary;
1:b7730e4: 
1:b7730e4: import org.apache.derby.iapi.error.StandardException;
1:b7730e4: import org.apache.derby.catalog.UUID;
1:b7730e4: import org.apache.derby.iapi.sql.conn.Authorizer;
1:b7730e4: import org.apache.derby.iapi.reference.SQLState;
1:b7730e4: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eb8b3a2: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:12988c7: import org.apache.derby.iapi.sql.Activation;
1:eb38311: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1:e4caed2: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:e4caed2: import org.apache.derby.iapi.services.context.ContextManager;
1:b7730e4: 
1:b7730e4: /**
1:c45f5b1:  * This class describes a column permission used (required) by a statement.
1:b7730e4:  */
1:b7730e4: 
1:b7730e4: public class StatementColumnPermission extends StatementTablePermission
2:b7730e4: {
1:b7730e4: 	private FormatableBitSet columns;
1:c45f5b1: 
1:c45f5b1: 	/**
1:c45f5b1: 	 * Constructor for StatementColumnPermission. Creates an instance of column permission requested
1:c45f5b1: 	 * for the given access.
1:c45f5b1: 	 * 
1:c45f5b1: 	 * @param tableUUID	UUID of the table
1:c45f5b1: 	 * @param privType	Access privilege requested
1:c45f5b1: 	 * @param columns	List of columns
1:c45f5b1: 	 *
1:c45f5b1: 	 */
1:c45f5b1: 	public StatementColumnPermission(UUID tableUUID, int privType, FormatableBitSet columns)
1:b7730e4: 	{
1:b7730e4: 		super( tableUUID, privType);
1:b7730e4: 		this.columns = columns;
3:b7730e4: 	}
1:12988c7: 
1:c45f5b1: 	/**
1:c45f5b1: 	 * Return list of columns that need access
1:12988c7: 	 *
1:c45f5b1: 	 * @return	FormatableBitSet of columns
1:c45f5b1: 	 */
1:b7730e4: 	public FormatableBitSet getColumns()
1:b7730e4: 	{
1:b7730e4: 		return columns;
1:b7730e4: 	}
1:b7730e4: 
1:c45f5b1: 	/**
1:c45f5b1: 	 * Method to check if another instance of column access descriptor matches this.
1:c45f5b1: 	 * Used to ensure only one access descriptor for a table/columns of given privilege is created.
1:c45f5b1: 	 *
1:c45f5b1: 	 * @param obj	Another instance of StatementPermission
1:c45f5b1: 	 *
1:c45f5b1: 	 * @return	true if match
1:c45f5b1: 	 */
1:b7730e4: 	public boolean equals( Object obj)
1:b7730e4: 	{
1:b7730e4: 		if( obj instanceof StatementColumnPermission)
1:b7730e4: 		{
1:b7730e4: 			StatementColumnPermission other = (StatementColumnPermission) obj;
1:b7730e4: 			if( ! columns.equals( other.columns))
1:b7730e4: 				return false;
1:b7730e4: 			return super.equals( obj);
1:b7730e4: 		}
1:b7730e4: 		return false;
1:b7730e4: 	}
1:b7730e4: 	
1:b7730e4: 	/**
1:eb8b3a2: 	 * @see StatementPermission#check
1:b7730e4: 	 */
1:eb8b3a2: 	public void check( LanguageConnectionContext lcc,
1:12988c7: 					   boolean forGrant,
1:12988c7: 					   Activation activation)
1:b7730e4: 		throws StandardException
1:b7730e4: 	{
1:eb8b3a2: 		DataDictionary dd = lcc.getDataDictionary();
1:eb38311: 		ExecPreparedStatement ps = activation.getPreparedStatement();
1:eb8b3a2: 
1:9f60172:         if (hasPermissionOnTable(lcc, activation, forGrant, ps)) {
1:b7730e4: 			return;
1:12988c7: 		}
1:12988c7: 
1:9f60172:         String currentUserId = lcc.getCurrentUserId(activation);
1:9f60172: 
1:b7730e4: 		FormatableBitSet permittedColumns = null;
1:b7730e4: 		if( ! forGrant)
1:b7730e4: 		{
1:b7730e4: 			permittedColumns = addPermittedColumns( dd,
1:b7730e4: 													false /* non-grantable permissions */,
1:b7730e4: 													Authorizer.PUBLIC_AUTHORIZATION_ID,
1:b7730e4: 													permittedColumns);
1:b7730e4: 			permittedColumns = addPermittedColumns( dd,
1:b7730e4: 													false /* non-grantable permissions */,
1:9f60172:                                                     currentUserId,
1:b7730e4: 													permittedColumns);
1:b7730e4: 		}
1:b7730e4: 		permittedColumns = addPermittedColumns( dd,
1:b7730e4: 												true /* grantable permissions */,
1:b7730e4: 												Authorizer.PUBLIC_AUTHORIZATION_ID,
1:b7730e4: 												permittedColumns);
1:b7730e4: 		permittedColumns = addPermittedColumns( dd,
1:b7730e4: 												true /* grantable permissions */,
1:9f60172:                                                 currentUserId,
1:b7730e4: 												permittedColumns);
1:46df255: 		
1:46df255: 		//DERBY-4191
1:46df255: 		//If we are looking for select privilege on ANY column,
1:46df255: 		//then we can quit as soon as we find some column with select
1:46df255: 		//privilege. This is needed for queries like
1:46df255: 		//select count(*) from t1
1:46df255: 		//select count(1) from t1
1:46df255: 		//select 1 from t1
1:46df255: 		//select t1.c1 from t1, t2
1:46df255: 		if (privType == Authorizer.MIN_SELECT_PRIV && permittedColumns != null)
1:46df255: 			return;
1:46df255: 
1:12988c7: 		FormatableBitSet unresolvedColumns = (FormatableBitSet)columns.clone();
1:12988c7: 
1:eb38311: 		for (int i = unresolvedColumns.anySetBit();
1:12988c7: 			 i >= 0;
1:12988c7: 			 i = unresolvedColumns.anySetBit(i)) {
1:12988c7: 
1:eb38311: 			if (permittedColumns != null && permittedColumns.get(i)) {
1:12988c7: 				// column i (zero-based here) accounted for:
1:12988c7: 				unresolvedColumns.clear(i);
1:12988c7: 			}
1:12988c7: 		}
1:12988c7: 
1:12988c7: 		if (unresolvedColumns.anySetBit() < 0) {
1:12988c7: 			// all ok
1:12988c7: 			return;
1:12988c7: 		}
1:12988c7: 
1:12988c7: 		// If columns are still unauthorized, look to role closure for
1:12988c7: 		// resolution.
1:12988c7: 		String role = lcc.getCurrentRoleId(activation);
1:12988c7: 		RoleGrantDescriptor rd = null;
1:12988c7: 
1:12988c7: 		if (role != null) {
1:12988c7: 			// Check that role is still granted to current user or
1:12988c7: 			// to PUBLIC: A revoked role which is current for this
1:12988c7: 			// session, is lazily set to none when it is attempted
1:12988c7: 			// used.
1:12988c7: 			String dbo = dd.getAuthorizationDatabaseOwner();
1:9f60172:             rd = dd.getRoleGrantDescriptor(role, currentUserId, dbo);
1:12988c7: 
1:12988c7: 			if (rd == null) {
1:12988c7: 				rd = dd.getRoleGrantDescriptor
1:12988c7: 					(role,
1:12988c7: 					 Authorizer.PUBLIC_AUTHORIZATION_ID,
1:12988c7: 					 dbo);
1:12988c7: 			}
1:12988c7: 
1:12988c7: 			if (rd == null) {
1:12988c7: 				// we have lost the right to set this role, so we can't
1:12988c7: 				// make use of any permission granted to it or its ancestors.
1:12988c7: 				lcc.setCurrentRole(activation, null);
1:12988c7: 			} else {
1:12988c7: 				// The current role is OK, so we can make use of
1:12988c7: 				// any permission granted to it.
1:eb38311: 				//
1:12988c7: 				// Look at the current role and, if necessary, the transitive
1:12988c7: 				// closure of roles granted to current role to see if
1:12988c7: 				// permission has been granted to any of the applicable roles.
1:12988c7: 
1:12988c7: 				RoleClosureIterator rci =
1:12988c7: 					dd.createRoleClosureIterator
1:12988c7: 					(activation.getTransactionController(),
1:12988c7: 					 role, true /* inverse relation*/);
1:12988c7: 
1:12988c7: 				String r;
1:12988c7: 
1:12988c7: 				while (unresolvedColumns.anySetBit() >= 0 &&
1:12988c7: 					   (r = rci.next()) != null ) {
1:46df255: 					//The user does not have needed privilege directly 
1:46df255: 					//granted to it, so let's see if he has that privilege
1:46df255: 					//available to him/her through his roles.
1:46df255: 					permittedColumns = tryRole(lcc, dd,	forGrant, r);
1:46df255: 					//DERBY-4191
1:46df255: 					//If we are looking for select privilege on ANY column,
1:46df255: 					//then we can quit as soon as we find some column with select
1:46df255: 					//privilege through this role. This is needed for queries like
1:46df255: 					//select count(*) from t1
1:46df255: 					//select count(1) from t1
1:46df255: 					//select 1 from t1
1:46df255: 					//select t1.c1 from t1, t2
1:46df255: 					if (privType == Authorizer.MIN_SELECT_PRIV && permittedColumns != null) {
1:46df255: 						DependencyManager dm = dd.getDependencyManager();
1:46df255: 						RoleGrantDescriptor rgd =
1:46df255: 							dd.getRoleDefinitionDescriptor(role);
1:46df255: 						ContextManager cm = lcc.getContextManager();
1:12988c7: 
1:46df255: 						dm.addDependency(ps, rgd, cm);
1:46df255: 						dm.addDependency(activation, rgd, cm);
1:46df255: 						return;
1:12988c7: 					}
1:12988c7: 
1:46df255: 					//Use the privileges obtained through the role to satisfy
1:46df255: 					//the column level privileges we need. If all the remaining
1:46df255: 					//column level privileges are satisfied through this role,
1:46df255: 					//we will quit out of this while loop
1:12988c7: 					for(int i = unresolvedColumns.anySetBit();
1:12988c7: 						i >= 0;
1:12988c7: 						i = unresolvedColumns.anySetBit(i)) {
1:12988c7: 
1:12988c7: 						if(permittedColumns != null && permittedColumns.get(i)) {
1:12988c7: 							unresolvedColumns.clear(i);
1:12988c7: 						}
1:12988c7: 					}
1:46df255: 				}
1:46df255: 			}
1:46df255: 		}
1:12988c7: 		TableDescriptor td = getTableDescriptor(dd);
1:46df255: 		//if we are still here, then that means that we didn't find any select
1:46df255: 		//privilege on the table or any column in the table
1:46df255: 		if (privType == Authorizer.MIN_SELECT_PRIV)
1:46df255: 			throw StandardException.newException( forGrant ? SQLState.AUTH_NO_TABLE_PERMISSION_FOR_GRANT
1:46df255: 					  : SQLState.AUTH_NO_TABLE_PERMISSION,
1:9f60172:                       currentUserId,
1:46df255: 					  getPrivName(),
1:46df255: 					  td.getSchemaName(),
1:46df255: 					  td.getName());
1:12988c7: 
1:12988c7: 		int remains = unresolvedColumns.anySetBit();
1:12988c7: 
1:12988c7: 		if (remains >= 0) {
1:b7730e4: 			// No permission on this column.
1:12988c7: 			ColumnDescriptor cd = td.getColumnDescriptor(remains + 1);
1:12988c7: 
1:12988c7: 			if(cd == null) {
1:12988c7: 				throw StandardException.newException(
1:12988c7: 					SQLState.AUTH_INTERNAL_BAD_UUID, "column");
1:eb38311: 			} else {
1:12988c7: 				throw StandardException.newException(
1:12988c7: 					(forGrant
1:12988c7: 					 ? SQLState.AUTH_NO_COLUMN_PERMISSION_FOR_GRANT
1:12988c7: 					 : SQLState.AUTH_NO_COLUMN_PERMISSION),
1:9f60172:                     currentUserId,
1:12988c7: 					getPrivName(),
1:12988c7: 					cd.getColumnName(),
1:12988c7: 					td.getSchemaName(),
1:12988c7: 					td.getName());
1:12988c7: 			}
1:12988c7: 		} else {
1:eb38311: 			// We found and successfully applied a role to resolve the
1:e4caed2: 			// (remaining) required permissions.
1:eb38311: 			//
1:e4caed2: 			// Also add a dependency on the role (qua provider), so
1:e4caed2: 			// that if role is no longer available to the current
1:e4caed2: 			// user (e.g. grant is revoked, role is dropped,
1:e4caed2: 			// another role has been set), we are able to
1:e4caed2: 			// invalidate the ps or activation (the latter is used
1:e4caed2: 			// if the current role changes).
1:e4caed2: 			DependencyManager dm = dd.getDependencyManager();
1:e4caed2: 			RoleGrantDescriptor rgd =
1:e4caed2: 				dd.getRoleDefinitionDescriptor(role);
1:e4caed2: 			ContextManager cm = lcc.getContextManager();
1:e4caed2: 
1:e4caed2: 			dm.addDependency(ps, rgd, cm);
1:e4caed2: 			dm.addDependency(activation, rgd, cm);
1:b7730e4: 		}
1:eb38311: 
1:b7730e4: 	} // end of check
1:46df255: 
1:b7730e4: 	/**
1:b7730e4: 	 * Add one user's set of permitted columns to a list of permitted columns.
1:b7730e4: 	 */
1:b7730e4: 	private FormatableBitSet addPermittedColumns( DataDictionary dd,
1:b7730e4: 												  boolean forGrant,
2:b7730e4: 												  String authorizationId,
1:b7730e4: 												  FormatableBitSet permittedColumns)
1:b7730e4: 		throws StandardException
1:b7730e4: 	{
1:b7730e4: 		if( permittedColumns != null && permittedColumns.getNumBitsSet() == permittedColumns.size())
1:b7730e4: 			return permittedColumns;
1:b7730e4: 		ColPermsDescriptor perms = dd.getColumnPermissions( tableUUID, privType, false, authorizationId);
1:b7730e4: 		if( perms != null)
1:b7730e4: 		{
1:b7730e4: 			if( permittedColumns == null)
1:b7730e4: 				return perms.getColumns();
1:b7730e4: 			permittedColumns.or( perms.getColumns());
1:2d2e717: 		}
1:b7730e4: 		return permittedColumns;
1:b7730e4: 	} // end of addPermittedColumns
1:2d2e717: 
1:2d2e717: 	/**
1:2d2e717: 	 * @see StatementPermission#getPermissionDescriptor
1:2d2e717: 	 */
1:2d2e717: 	public PermissionsDescriptor getPermissionDescriptor(String authid, DataDictionary dd)
1:2d2e717: 	throws StandardException
1:2d2e717: 	{
1:2d2e717: 		//If table permission found for authorizationid, then simply return that
1:2d2e717: 		if (oneAuthHasPermissionOnTable( dd, authid, false))
1:2d2e717: 			return dd.getTablePermissions(tableUUID, authid);
1:2d2e717: 		//If table permission found for PUBLIC, then simply return that
1:2d2e717: 		if (oneAuthHasPermissionOnTable( dd, Authorizer.PUBLIC_AUTHORIZATION_ID, false))
1:2d2e717: 			return dd.getTablePermissions(tableUUID, Authorizer.PUBLIC_AUTHORIZATION_ID);
1:2d2e717: 		
1:2d2e717: 		//If table level permission not found, then we have to find permissions 
1:2d2e717: 		//at column level. Look for column level permission for the passed 
1:2d2e717: 		//authorizer. If found any of the required column level permissions,
1:2d2e717: 		//return the permission descriptor for it.
1:2d2e717: 		ColPermsDescriptor colsPermsDesc = dd.getColumnPermissions(tableUUID, privType, false, authid);
1:2d2e717: 		if( colsPermsDesc != null)
1:2d2e717: 		{
1:2d2e717: 			if( colsPermsDesc.getColumns() != null){
1:2d2e717: 				FormatableBitSet permittedColumns = colsPermsDesc.getColumns();
1:2d2e717: 				for( int i = columns.anySetBit(); i >= 0; i = columns.anySetBit( i))
1:2d2e717: 				{
1:2d2e717: 					if(permittedColumns.get(i))
1:2d2e717: 						return colsPermsDesc;
1:2d2e717: 				}
1:2d2e717: 			}
1:2d2e717: 		}
1:2d2e717: 		return null;
1:2d2e717: 	}
1:2d2e717: 	
1:2d2e717: 	/**
1:2d2e717: 	 * This method gets called in execution phase after it is established that 
1:2d2e717: 	 * all the required privileges exist for the given sql. This method gets 
1:2d2e717: 	 * called by create view/trigger/constraint to record their dependency on 
1:2d2e717: 	 * various privileges.
1:2d2e717: 	 * Special code is required to track column level privileges.
1:2d2e717: 	 * It is possible that some column level privileges are available to the
1:2d2e717: 	 * passed authorizer id but the rest required column level privileges
1:2d2e717: 	 * are available at PUBLIC level. In this method, we check if all the
1:2d2e717: 	 * required column level privileges are found for the passed authorizer.
1:2d2e717: 	 * If yes, then simply return null, indicating that no dependency is 
1:2d2e717: 	 * required at PUBLIC level, because all the required privileges were found
1:2d2e717: 	 * at the user level. But if some column level privileges are not
1:2d2e717: 	 * available at user level, then they have to exist at the PUBLIC
1:2d2e717: 	 * level when this method gets called.  
1:2d2e717: 	 */
1:2d2e717: 	public PermissionsDescriptor getPUBLIClevelColPermsDescriptor(String authid, DataDictionary dd)
1:2d2e717: 	throws StandardException
1:2d2e717: 	{
1:2d2e717: 		ColPermsDescriptor colsPermsDesc = dd.getColumnPermissions(tableUUID, privType, false, authid);
1:2d2e717: 		FormatableBitSet permittedColumns = colsPermsDesc.getColumns();
1:2d2e717: 		boolean allColumnsCoveredByUserLevelPrivilege = true;
1:2d2e717: 		for( int i = columns.anySetBit(); i >= 0 && allColumnsCoveredByUserLevelPrivilege; i = columns.anySetBit( i))
1:2d2e717: 		{
1:2d2e717: 			if(permittedColumns.get(i))
1:2d2e717: 				continue;
1:2d2e717: 			else
1:2d2e717: 				allColumnsCoveredByUserLevelPrivilege = false;
1:2d2e717: 		}
1:2d2e717: 		if (allColumnsCoveredByUserLevelPrivilege)
1:2d2e717: 			return null;
1:2d2e717: 		else
1:2d2e717: 			return (dd.getColumnPermissions(tableUUID, privType, false, Authorizer.PUBLIC_AUTHORIZATION_ID));	
1:12988c7: 	}
1:12988c7: 
1:12988c7: 	/**
1:eb38311: 	 * Returns false if the current role is necessary to cover
1:eb38311: 	 * the necessary permission(s).
1:eb38311: 	 * @param authid authentication id of the current user
1:eb38311: 	 * @param dd data dictionary
1:eb38311: 	 *
1:eb38311: 	 * @return false if the current role is required
1:eb38311: 	 */
1:eb38311: 	public boolean allColumnsCoveredByUserOrPUBLIC(String authid,
1:eb38311: 												   DataDictionary dd)
1:eb38311: 			throws StandardException {
1:eb38311: 
1:eb38311: 		ColPermsDescriptor colsPermsDesc =
1:eb38311: 			dd.getColumnPermissions(tableUUID, privType, false, authid);
1:eb38311: 		FormatableBitSet permittedColumns = colsPermsDesc.getColumns();
1:eb38311: 		FormatableBitSet unresolvedColumns = (FormatableBitSet)columns.clone();
1:eb38311: 		boolean result = true;
1:eb38311: 
1:eb38311: 		if (permittedColumns != null) { // else none at user level
1:eb38311: 			for(int i = unresolvedColumns.anySetBit();
1:eb38311: 				i >= 0;
1:eb38311: 				i = unresolvedColumns.anySetBit(i)) {
1:eb38311: 
1:eb38311: 				if(permittedColumns.get(i)) {
1:eb38311: 					unresolvedColumns.clear(i);
1:eb38311: 				}
1:eb38311: 			}
1:eb38311: 		}
1:eb38311: 
1:eb38311: 
1:eb38311: 		if (unresolvedColumns.anySetBit() >= 0) {
1:eb38311: 			colsPermsDesc =
1:eb38311: 				dd.getColumnPermissions(
1:eb38311: 					tableUUID, privType, false,
1:eb38311: 					Authorizer.PUBLIC_AUTHORIZATION_ID);
1:eb38311: 			permittedColumns = colsPermsDesc.getColumns();
1:eb38311: 
1:eb38311: 			if (permittedColumns != null) { // else none at public level
1:eb38311: 				for(int i = unresolvedColumns.anySetBit();
1:eb38311: 					i >= 0;
1:eb38311: 					i = unresolvedColumns.anySetBit(i)) {
1:eb38311: 
1:eb38311: 					if(permittedColumns.get(i)) {
1:eb38311: 						unresolvedColumns.clear(i);
1:eb38311: 					}
1:eb38311: 				}
1:eb38311: 			}
1:eb38311: 
1:eb38311: 			if (unresolvedColumns.anySetBit() >= 0) {
1:eb38311: 				// even after trying all grants to user and public there
1:eb38311: 				// are unresolved columns so role must have been used.
1:eb38311: 				result = false;
1:eb38311: 			}
1:eb38311: 		}
1:eb38311: 
1:eb38311: 		return result;
1:eb38311: 	}
1:eb38311: 
1:eb38311: 
1:eb38311: 	/**
1:46df255: 	 * Try to use the supplied role r to see what column privileges are we 
1:46df255: 	 * entitled to. 
1:c45f5b1: 	 *
1:12988c7: 	 * @param lcc language connection context
1:12988c7: 	 * @param dd  data dictionary
1:12988c7: 	 * @param forGrant true of a GRANTable permission is sought
1:12988c7: 	 * @param r the role to inspect to see if it can supply the required
1:12988c7: 	 *          privileges
1:46df255: 	 * return the set of columns on which we have privileges through this role
1:12988c7: 	 */
1:12988c7: 	private FormatableBitSet tryRole(LanguageConnectionContext lcc,
1:12988c7: 									 DataDictionary dd,
1:12988c7: 									 boolean forGrant,
1:46df255: 									 String r)
1:12988c7: 			throws StandardException {
1:12988c7: 
1:12988c7: 		FormatableBitSet permittedColumns = null;
1:12988c7: 
1:12988c7: 		if (! forGrant) {
1:12988c7: 			// This is a weaker permission than GRANTable, so only applicable
1:12988c7: 			// if grantable is not required.
1:12988c7: 			permittedColumns = addPermittedColumns(dd, false, r, null);
1:12988c7: 		}
1:12988c7: 
1:12988c7: 		// if grantable is given, applicable in both cases, so use union
1:12988c7: 		permittedColumns = addPermittedColumns(dd, true, r, permittedColumns);
1:46df255: 		return permittedColumns;
1:12988c7: 	}
1:12988c7: 
1:12988c7: 
1:12988c7: 	public String toString()
1:12988c7: 	{
1:12988c7: 		return "StatementColumnPermission: " + getPrivName() + " " +
1:12988c7: 			tableUUID + " columns: " + columns;
1:12988c7: 	}
1:12988c7: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:9f60172
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (hasPermissionOnTable(lcc, activation, forGrant, ps)) {
1:         String currentUserId = lcc.getCurrentUserId(activation);
1: 
/////////////////////////////////////////////////////////////////////////
1:                                                     currentUserId,
/////////////////////////////////////////////////////////////////////////
1:                                                 currentUserId,
/////////////////////////////////////////////////////////////////////////
1:             rd = dd.getRoleGrantDescriptor(role, currentUserId, dbo);
/////////////////////////////////////////////////////////////////////////
1:                       currentUserId,
/////////////////////////////////////////////////////////////////////////
1:                     currentUserId,
commit:e4caed2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: import org.apache.derby.iapi.services.context.ContextManager;
/////////////////////////////////////////////////////////////////////////
1: 			// (remaining) required permissions.
1: 			// Also add a dependency on the role (qua provider), so
1: 			// that if role is no longer available to the current
1: 			// user (e.g. grant is revoked, role is dropped,
1: 			// another role has been set), we are able to
1: 			// invalidate the ps or activation (the latter is used
1: 			// if the current role changes).
1: 			DependencyManager dm = dd.getDependencyManager();
1: 			RoleGrantDescriptor rgd =
1: 				dd.getRoleDefinitionDescriptor(role);
1: 			ContextManager cm = lcc.getContextManager();
1: 
1: 			dm.addDependency(ps, rgd, cm);
1: 			dm.addDependency(activation, rgd, cm);
commit:eb38311
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
/////////////////////////////////////////////////////////////////////////
1: 		ExecPreparedStatement ps = activation.getPreparedStatement();
0: 									 authorizationId, forGrant, ps)) {
/////////////////////////////////////////////////////////////////////////
1: 		for (int i = unresolvedColumns.anySetBit();
1: 			if (permittedColumns != null && permittedColumns.get(i)) {
/////////////////////////////////////////////////////////////////////////
1: 		} else {
1: 			// We found and successfully applied a role to resolve the
0: 			// remaining required permissions.
1: 			//
0: 			// So add a dependency on the role (qua provider), so that
0: 			// if role is no longer available to the current user
0: 			// (e.g. grant to user is revoked, role is dropped,
0: 			// another role has been set), or it is impacted by
0: 			// revoked permissions or other roles granted to it, we
0: 			// are able to invalidate the the ps.
1: 			//
0: 			// FIXME: Rather invalidate Activation so other
0: 			// sessions sharing the same ps are not impacted!!
0: 			dd.getDependencyManager().
0: 				addDependency(ps, dd.getRoleDefinitionDescriptor(role),
0: 							  lcc.getContextManager());
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 * Returns false if the current role is necessary to cover
1: 	 * the necessary permission(s).
1: 	 * @param authid authentication id of the current user
1: 	 * @param dd data dictionary
1: 	 *
1: 	 * @return false if the current role is required
1: 	 */
1: 	public boolean allColumnsCoveredByUserOrPUBLIC(String authid,
1: 												   DataDictionary dd)
1: 			throws StandardException {
1: 
1: 		ColPermsDescriptor colsPermsDesc =
1: 			dd.getColumnPermissions(tableUUID, privType, false, authid);
1: 		FormatableBitSet permittedColumns = colsPermsDesc.getColumns();
1: 		FormatableBitSet unresolvedColumns = (FormatableBitSet)columns.clone();
1: 		boolean result = true;
1: 
1: 		if (permittedColumns != null) { // else none at user level
1: 			for(int i = unresolvedColumns.anySetBit();
1: 				i >= 0;
1: 				i = unresolvedColumns.anySetBit(i)) {
1: 
1: 				if(permittedColumns.get(i)) {
1: 					unresolvedColumns.clear(i);
1: 				}
1: 			}
1: 		}
1: 
1: 
1: 		if (unresolvedColumns.anySetBit() >= 0) {
1: 			colsPermsDesc =
1: 				dd.getColumnPermissions(
1: 					tableUUID, privType, false,
1: 					Authorizer.PUBLIC_AUTHORIZATION_ID);
1: 			permittedColumns = colsPermsDesc.getColumns();
1: 
1: 			if (permittedColumns != null) { // else none at public level
1: 				for(int i = unresolvedColumns.anySetBit();
1: 					i >= 0;
1: 					i = unresolvedColumns.anySetBit(i)) {
1: 
1: 					if(permittedColumns.get(i)) {
1: 						unresolvedColumns.clear(i);
1: 					}
1: 				}
1: 			}
1: 
1: 			if (unresolvedColumns.anySetBit() >= 0) {
1: 				// even after trying all grants to user and public there
1: 				// are unresolved columns so role must have been used.
1: 				result = false;
1: 			}
1: 		}
1: 
1: 		return result;
1: 	}
1: 
1: 
1: 	/**
commit:12988c7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.Activation;
/////////////////////////////////////////////////////////////////////////
1: 					   boolean forGrant,
1: 					   Activation activation)
0: 		if (hasPermissionOnTable(lcc, activation,
0: 									 authorizationId, forGrant)) {
1: 		}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		FormatableBitSet unresolvedColumns = (FormatableBitSet)columns.clone();
1: 
0: 		for( int i = unresolvedColumns.anySetBit();
1: 			 i >= 0;
1: 			 i = unresolvedColumns.anySetBit(i)) {
1: 
0: 			if( permittedColumns != null && permittedColumns.get(i)) {
1: 				// column i (zero-based here) accounted for:
1: 				unresolvedColumns.clear(i);
1: 			}
1: 		}
1: 
1: 		if (unresolvedColumns.anySetBit() < 0) {
1: 			// all ok
1: 			return;
1: 		}
1: 
1: 		// If columns are still unauthorized, look to role closure for
1: 		// resolution.
1: 		String role = lcc.getCurrentRoleId(activation);
1: 		RoleGrantDescriptor rd = null;
1: 
1: 		if (role != null) {
1: 			// Check that role is still granted to current user or
1: 			// to PUBLIC: A revoked role which is current for this
1: 			// session, is lazily set to none when it is attempted
1: 			// used.
1: 			String dbo = dd.getAuthorizationDatabaseOwner();
0: 			rd = dd.getRoleGrantDescriptor(role, authorizationId, dbo);
1: 
1: 			if (rd == null) {
1: 				rd = dd.getRoleGrantDescriptor
1: 					(role,
1: 					 Authorizer.PUBLIC_AUTHORIZATION_ID,
1: 					 dbo);
1: 			}
1: 
1: 			if (rd == null) {
1: 				// we have lost the right to set this role, so we can't
1: 				// make use of any permission granted to it or its ancestors.
1: 				lcc.setCurrentRole(activation, null);
1: 			} else {
1: 				// The current role is OK, so we can make use of
1: 				// any permission granted to it.
0: 				//
1: 				// Look at the current role and, if necessary, the transitive
1: 				// closure of roles granted to current role to see if
1: 				// permission has been granted to any of the applicable roles.
1: 
1: 				RoleClosureIterator rci =
1: 					dd.createRoleClosureIterator
1: 					(activation.getTransactionController(),
1: 					 role, true /* inverse relation*/);
1: 
1: 				String r;
1: 
1: 				while (unresolvedColumns.anySetBit() >= 0 &&
1: 					   (r = rci.next()) != null ) {
1: 
0: 					unresolvedColumns = tryRole(lcc, dd, forGrant,
0: 												r, unresolvedColumns);
1: 				}
1: 			}
1: 		}
1: 
1: 		int remains = unresolvedColumns.anySetBit();
1: 
1: 		if (remains >= 0) {
1: 			TableDescriptor td = getTableDescriptor(dd);
1: 			ColumnDescriptor cd = td.getColumnDescriptor(remains + 1);
1: 
1: 			if(cd == null) {
1: 				throw StandardException.newException(
1: 					SQLState.AUTH_INTERNAL_BAD_UUID, "column");
1: 			} else {
1: 				throw StandardException.newException(
1: 					(forGrant
1: 					 ? SQLState.AUTH_NO_COLUMN_PERMISSION_FOR_GRANT
1: 					 : SQLState.AUTH_NO_COLUMN_PERMISSION),
0: 					authorizationId,
1: 					getPrivName(),
1: 					cd.getColumnName(),
1: 					td.getSchemaName(),
1: 					td.getName());
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	 * Given the set of yet unresolved column permissions, try to use
0: 	 * the supplied role r to resolve them. After this is done, return
0: 	 * the set of columns still unresolved. If the role is used for
0: 	 * anything, record a dependency.
1: 	 *
1: 	 * @param lcc language connection context
1: 	 * @param dd  data dictionary
1: 	 * @param forGrant true of a GRANTable permission is sought
1: 	 * @param r the role to inspect to see if it can supply the required
1: 	 *          privileges
0: 	 * @param unresolvedColumns the set of columns yet unaccounted for
1: 	 */
1: 	private FormatableBitSet tryRole(LanguageConnectionContext lcc,
1: 									 DataDictionary dd,
1: 									 boolean forGrant,
0: 									 String r,
0: 									 FormatableBitSet unresolvedColumns)
1: 			throws StandardException {
1: 
1: 		FormatableBitSet permittedColumns = null;
1: 
1: 		if (! forGrant) {
1: 			// This is a weaker permission than GRANTable, so only applicable
1: 			// if grantable is not required.
1: 			permittedColumns = addPermittedColumns(dd, false, r, null);
1: 		}
1: 
1: 		// if grantable is given, applicable in both cases, so use union
1: 		permittedColumns = addPermittedColumns(dd, true, r, permittedColumns);
1: 
1: 		for(int i = unresolvedColumns.anySetBit();
1: 			i >= 0;
1: 			i = unresolvedColumns.anySetBit(i)) {
1: 
1: 			if(permittedColumns != null && permittedColumns.get(i)) {
1: 				unresolvedColumns.clear(i);
1: 			}
1: 		}
1: 
0: 		return unresolvedColumns;
1: 	}
1: 
1: 
1: 	public String toString()
1: 	{
1: 		return "StatementColumnPermission: " + getPrivName() + " " +
1: 			tableUUID + " columns: " + columns;
1: 	}
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:46df255
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		//DERBY-4191
1: 		//If we are looking for select privilege on ANY column,
1: 		//then we can quit as soon as we find some column with select
1: 		//privilege. This is needed for queries like
1: 		//select count(*) from t1
1: 		//select count(1) from t1
1: 		//select 1 from t1
1: 		//select t1.c1 from t1, t2
1: 		if (privType == Authorizer.MIN_SELECT_PRIV && permittedColumns != null)
1: 			return;
/////////////////////////////////////////////////////////////////////////
1: 					//The user does not have needed privilege directly 
1: 					//granted to it, so let's see if he has that privilege
1: 					//available to him/her through his roles.
1: 					permittedColumns = tryRole(lcc, dd,	forGrant, r);
1: 					//DERBY-4191
1: 					//If we are looking for select privilege on ANY column,
1: 					//then we can quit as soon as we find some column with select
1: 					//privilege through this role. This is needed for queries like
1: 					//select count(*) from t1
1: 					//select count(1) from t1
1: 					//select 1 from t1
1: 					//select t1.c1 from t1, t2
1: 					if (privType == Authorizer.MIN_SELECT_PRIV && permittedColumns != null) {
1: 						DependencyManager dm = dd.getDependencyManager();
1: 						RoleGrantDescriptor rgd =
1: 							dd.getRoleDefinitionDescriptor(role);
1: 						ContextManager cm = lcc.getContextManager();
1: 						dm.addDependency(ps, rgd, cm);
1: 						dm.addDependency(activation, rgd, cm);
1: 						return;
1: 					}
1: 
1: 					//Use the privileges obtained through the role to satisfy
1: 					//the column level privileges we need. If all the remaining
1: 					//column level privileges are satisfied through this role,
1: 					//we will quit out of this while loop
0: 					for(int i = unresolvedColumns.anySetBit();
0: 						i >= 0;
0: 						i = unresolvedColumns.anySetBit(i)) {
1: 
0: 						if(permittedColumns != null && permittedColumns.get(i)) {
0: 							unresolvedColumns.clear(i);
1: 						}
1: 					}
0: 		TableDescriptor td = getTableDescriptor(dd);
1: 		//if we are still here, then that means that we didn't find any select
1: 		//privilege on the table or any column in the table
1: 		if (privType == Authorizer.MIN_SELECT_PRIV)
1: 			throw StandardException.newException( forGrant ? SQLState.AUTH_NO_TABLE_PERMISSION_FOR_GRANT
1: 					  : SQLState.AUTH_NO_TABLE_PERMISSION,
0: 					  authorizationId,
1: 					  getPrivName(),
1: 					  td.getSchemaName(),
1: 					  td.getName());
/////////////////////////////////////////////////////////////////////////
1: 	 * Try to use the supplied role r to see what column privileges are we 
1: 	 * entitled to. 
1: 	 * return the set of columns on which we have privileges through this role
1: 									 String r)
/////////////////////////////////////////////////////////////////////////
1: 		return permittedColumns;
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2e658c2
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * @see StatementPermission#getPermissionDescriptor
1: 	 */
1: 	public PermissionsDescriptor getPermissionDescriptor(String authid, DataDictionary dd)
1: 	throws StandardException
1: 	{
1: 		//If table permission found for authorizationid, then simply return that
1: 		if (oneAuthHasPermissionOnTable( dd, authid, false))
1: 			return dd.getTablePermissions(tableUUID, authid);
1: 		//If table permission found for PUBLIC, then simply return that
1: 		if (oneAuthHasPermissionOnTable( dd, Authorizer.PUBLIC_AUTHORIZATION_ID, false))
1: 			return dd.getTablePermissions(tableUUID, Authorizer.PUBLIC_AUTHORIZATION_ID);
1: 		
1: 		//If table level permission not found, then we have to find permissions 
1: 		//at column level. Look for column level permission for the passed 
1: 		//authorizer. If found any of the required column level permissions,
1: 		//return the permission descriptor for it.
1: 		ColPermsDescriptor colsPermsDesc = dd.getColumnPermissions(tableUUID, privType, false, authid);
1: 		if( colsPermsDesc != null)
1: 		{
1: 			if( colsPermsDesc.getColumns() != null){
1: 				FormatableBitSet permittedColumns = colsPermsDesc.getColumns();
1: 				for( int i = columns.anySetBit(); i >= 0; i = columns.anySetBit( i))
1: 				{
1: 					if(permittedColumns.get(i))
1: 						return colsPermsDesc;
1: 				}
1: 			}
1: 		}
1: 		return null;
1: 	}
1: 	
1: 	/**
1: 	 * This method gets called in execution phase after it is established that 
1: 	 * all the required privileges exist for the given sql. This method gets 
1: 	 * called by create view/trigger/constraint to record their dependency on 
1: 	 * various privileges.
1: 	 * Special code is required to track column level privileges.
1: 	 * It is possible that some column level privileges are available to the
1: 	 * passed authorizer id but the rest required column level privileges
1: 	 * are available at PUBLIC level. In this method, we check if all the
1: 	 * required column level privileges are found for the passed authorizer.
1: 	 * If yes, then simply return null, indicating that no dependency is 
1: 	 * required at PUBLIC level, because all the required privileges were found
1: 	 * at the user level. But if some column level privileges are not
1: 	 * available at user level, then they have to exist at the PUBLIC
1: 	 * level when this method gets called.  
1: 	 */
1: 	public PermissionsDescriptor getPUBLIClevelColPermsDescriptor(String authid, DataDictionary dd)
1: 	throws StandardException
1: 	{
1: 		ColPermsDescriptor colsPermsDesc = dd.getColumnPermissions(tableUUID, privType, false, authid);
1: 		FormatableBitSet permittedColumns = colsPermsDesc.getColumns();
1: 		boolean allColumnsCoveredByUserLevelPrivilege = true;
1: 		for( int i = columns.anySetBit(); i >= 0 && allColumnsCoveredByUserLevelPrivilege; i = columns.anySetBit( i))
1: 		{
1: 			if(permittedColumns.get(i))
1: 				continue;
1: 			else
1: 				allColumnsCoveredByUserLevelPrivilege = false;
1: 		}
1: 		if (allColumnsCoveredByUserLevelPrivilege)
1: 			return null;
1: 		else
1: 			return (dd.getColumnPermissions(tableUUID, privType, false, Authorizer.PUBLIC_AUTHORIZATION_ID));	
1: 	}
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:eb8b3a2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
/////////////////////////////////////////////////////////////////////////
1: 	 * @see StatementPermission#check
1: 	public void check( LanguageConnectionContext lcc,
1: 		DataDictionary dd = lcc.getDataDictionary();
1: 
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
1:  * This class describes a column permission used (required) by a statement.
1: 	/**
1: 	 * Constructor for StatementColumnPermission. Creates an instance of column permission requested
1: 	 * for the given access.
1: 	 * 
1: 	 * @param tableUUID	UUID of the table
1: 	 * @param privType	Access privilege requested
1: 	 * @param columns	List of columns
1: 	 *
1: 	 */
1: 	public StatementColumnPermission(UUID tableUUID, int privType, FormatableBitSet columns)
1: 	/**
1: 	 * Return list of columns that need access
1: 	 *
1: 	 * @return	FormatableBitSet of columns
1: 	 */
1: 	/**
1: 	 * Method to check if another instance of column access descriptor matches this.
1: 	 * Used to ensure only one access descriptor for a table/columns of given privilege is created.
1: 	 *
1: 	 * @param obj	Another instance of StatementPermission
1: 	 *
1: 	 * @return	true if match
1: 	 */
/////////////////////////////////////////////////////////////////////////
0: 	public void check(TransactionController tc,
/////////////////////////////////////////////////////////////////////////
1: 
commit:b7730e4
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.iapi.sql.dictionary.StatementColumnPermission
1: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1: 	  http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.dictionary;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.sql.conn.Authorizer;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: /**
0:  * This class describes a columnpermission used (required) by a statement.
1:  */
1: 
1: public class StatementColumnPermission extends StatementTablePermission
1: {
1: 	private FormatableBitSet columns;
1: 
0: 	public StatementColumnPermission( UUID tableUUID, int privType, FormatableBitSet columns)
1: 	{
1: 		super( tableUUID, privType);
1: 		this.columns = columns;
1: 	}
1: 
1: 	public FormatableBitSet getColumns()
1: 	{
1: 		return columns;
1: 	}
1: 
1: 	public boolean equals( Object obj)
1: 	{
1: 		if( obj instanceof StatementColumnPermission)
1: 		{
1: 			StatementColumnPermission other = (StatementColumnPermission) obj;
1: 			if( ! columns.equals( other.columns))
1: 				return false;
1: 			return super.equals( obj);
1: 		}
1: 		return false;
1: 	}
1: 	
1: 	/**
0: 	 * @param tc the TransactionController
0: 	 * @param dd A DataDictionary
0: 	 * @param authorizationId A user
0: 	 * @param forGrant
0: 	 *
0: 	 * @exception StandardException if the permission has not been granted
1: 	 */
0: 	public void check( TransactionController tc,
0: 					   DataDictionary dd,
1: 					   String authorizationId,
0: 					   boolean forGrant)
1: 		throws StandardException
1: 	{
0: 		if( hasPermissionOnTable(dd, authorizationId, forGrant))
1: 			return;
1: 		FormatableBitSet permittedColumns = null;
0: 		FormatableBitSet grantablePermittedColumns = null;
0: 		FormatableBitSet publicPermittedColumns = null;
0: 		FormatableBitSet publicPrantablePermittedColumns = null;
1: 		if( ! forGrant)
1: 		{
1: 			permittedColumns = addPermittedColumns( dd,
1: 													false /* non-grantable permissions */,
1: 													Authorizer.PUBLIC_AUTHORIZATION_ID,
1: 													permittedColumns);
1: 			permittedColumns = addPermittedColumns( dd,
1: 													false /* non-grantable permissions */,
0: 													authorizationId,
1: 													permittedColumns);
1: 		}
1: 		permittedColumns = addPermittedColumns( dd,
1: 												true /* grantable permissions */,
1: 												Authorizer.PUBLIC_AUTHORIZATION_ID,
1: 												permittedColumns);
1: 		permittedColumns = addPermittedColumns( dd,
1: 												true /* grantable permissions */,
0: 												authorizationId,
1: 												permittedColumns);
1: 												
0: 		for( int i = columns.anySetBit(); i >= 0; i = columns.anySetBit( i))
1: 		{
0: 			if( permittedColumns != null && permittedColumns.get(i))
0: 				continue;
1: 			// No permission on this column.
0: 			TableDescriptor td = getTableDescriptor( dd);
0: 			ColumnDescriptor cd = td.getColumnDescriptor( i + 1);
0: 			if( cd == null)
0: 				throw StandardException.newException( SQLState.AUTH_INTERNAL_BAD_UUID, "column");
0: 			throw StandardException.newException( forGrant ? SQLState.AUTH_NO_COLUMN_PERMISSION_FOR_GRANT
0: 												  : SQLState.AUTH_NO_COLUMN_PERMISSION,
0: 												  authorizationId,
0: 												  getPrivName(),
0: 												  cd.getColumnName(),
0: 												  td.getSchemaName(),
0: 												  td.getName());
1: 		}
1: 	} // end of check
1: 
1: 	/**
1: 	 * Add one user's set of permitted columns to a list of permitted columns.
1: 	 */
1: 	private FormatableBitSet addPermittedColumns( DataDictionary dd,
1: 												  boolean forGrant,
1: 												  String authorizationId,
1: 												  FormatableBitSet permittedColumns)
1: 		throws StandardException
1: 	{
1: 		if( permittedColumns != null && permittedColumns.getNumBitsSet() == permittedColumns.size())
1: 			return permittedColumns;
1: 		ColPermsDescriptor perms = dd.getColumnPermissions( tableUUID, privType, false, authorizationId);
1: 		if( perms != null)
1: 		{
1: 			if( permittedColumns == null)
1: 				return perms.getColumns();
1: 			permittedColumns.or( perms.getColumns());
1: 		}
1: 		return permittedColumns;
1: 	} // end of addPermittedColumns
1: }
============================================================================