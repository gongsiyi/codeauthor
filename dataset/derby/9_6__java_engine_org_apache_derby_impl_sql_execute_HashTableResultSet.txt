1:eac0369: /*
5:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.HashTableResultSet
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.Storable;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.conn.StatementContext;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:eac0369: import org.apache.derby.iapi.store.access.RowSource;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1:eac0369: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
1:eac0369: import org.apache.derby.iapi.services.io.FormatableIntHolder;
1:eac0369: import org.apache.derby.iapi.store.access.KeyHasher;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1:eac0369: 
1:bd34a3a: import java.util.List;
1:eac0369: import java.util.Properties;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * Builds a hash table on the underlying result set tree.
1:eac0369:  *
1:eac0369:  */
1:f77f36d: class HashTableResultSet extends NoPutResultSetImpl
1:eac0369: 	implements CursorResultSet 
1:eac0369: {
1:eac0369: 	/* Run time statistics variables */
1:eac0369: 	public long restrictionTime;
1:eac0369: 	public long projectionTime;
1:eac0369: 	public int  hashtableSize;
1:eac0369: 	public Properties scanProperties;
1:eac0369: 
1:eac0369:     // set in constructor and not altered during
1:eac0369:     // life of object.
1:eac0369:     public NoPutResultSet source;
1:eac0369:     public GeneratedMethod singleTableRestriction;
1:eac0369: 	public Qualifier[][] nextQualifiers;
1:eac0369:     private GeneratedMethod projection;
1:eac0369: 	private int[]			projectMapping;
1:eac0369: 	private boolean runTimeStatsOn;
1:eac0369: 	private ExecRow			mappedResultRow;
1:eac0369: 	public boolean reuseResult;
1:eac0369: 	public int[]			keyColumns;
1:eac0369: 	private boolean			removeDuplicates;
1:eac0369: 	private long			maxInMemoryRowCount;
1:eac0369:     private	int				initialCapacity;
1:eac0369:     private	float			loadFactor;
1:eac0369: 	private boolean			skipNullKeyColumns;
1:eac0369: 
1:eac0369: 	// Variable for managing next() logic on hash entry
1:eac0369: 	private boolean		firstNext = true;
1:eac0369: 	private int			numFetchedOnNext;
1:eac0369: 	private int			entryVectorSize;
1:bd34a3a: 	private List		entryVector;
1:eac0369: 
1:eac0369: 	private boolean hashTableBuilt;
1:eac0369: 	private boolean firstIntoHashtable = true;
1:eac0369: 
1:eac0369: 	private ExecRow nextCandidate;
1:eac0369: 	private ExecRow projRow;
1:eac0369: 
1:eac0369: 	private BackingStoreHashtable ht;
1:eac0369: 
1:eac0369:     //
1:eac0369:     // class interface
1:eac0369:     //
1:f77f36d:     HashTableResultSet(NoPutResultSet s,
1:eac0369: 					Activation a,
1:eac0369: 					GeneratedMethod str,
1:eac0369: 					Qualifier[][] nextQualifiers,
1:eac0369: 					GeneratedMethod p,
1:eac0369: 					int resultSetNumber,
1:eac0369: 					int mapRefItem,
1:eac0369: 					boolean reuseResult,
1:eac0369: 					int keyColItem,
1:eac0369: 					boolean removeDuplicates,
1:eac0369: 					long maxInMemoryRowCount,
1:eac0369: 					int	initialCapacity,
1:eac0369: 					float loadFactor,
1:eac0369: 					boolean skipNullKeyColumns,
1:eac0369: 				    double optimizerEstimatedRowCount,
1:f77f36d: 					double optimizerEstimatedCost) 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		super(a, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost);
1:eac0369:         source = s;
1:eac0369: 		// source expected to be non-null, mystery stress test bug
1:eac0369: 		// - sometimes get NullPointerException in openCore().
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(source != null,
1:eac0369: 				"HTRS(), source expected to be non-null");
2:eac0369: 		}
1:eac0369:         singleTableRestriction = str;
1:eac0369: 		this.nextQualifiers = nextQualifiers;
1:eac0369:         projection = p;
1:eac0369: 		projectMapping = ((ReferencedColumnsDescriptorImpl) a.getPreparedStatement().getSavedObject(mapRefItem)).getReferencedColumnPositions();
1:eac0369: 		FormatableArrayHolder fah = (FormatableArrayHolder) a.getPreparedStatement().getSavedObject(keyColItem);
1:473d692:         FormatableIntHolder[] fihArray = fah.getArray(FormatableIntHolder[].class);
1:eac0369: 		keyColumns = new int[fihArray.length];
1:eac0369: 		for (int index = 0; index < fihArray.length; index++)
1:eac0369: 		{
1:eac0369: 			keyColumns[index] = fihArray[index].getInt();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		this.reuseResult = reuseResult;
1:eac0369: 		this.removeDuplicates = removeDuplicates;
1:eac0369: 		this.maxInMemoryRowCount = maxInMemoryRowCount;
1:eac0369: 		this.initialCapacity = initialCapacity;
1:eac0369: 		this.loadFactor = loadFactor;
1:eac0369: 		this.skipNullKeyColumns = skipNullKeyColumns;
1:eac0369: 
1:eac0369: 		// Allocate a result row if all of the columns are mapped from the source
1:eac0369: 		if (projection == null)
1:eac0369: 		{
1:eac0369: 			mappedResultRow = activation.getExecutionFactory().getValueRow(projectMapping.length);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Remember whether or not RunTimeStatistics is on */
1:eac0369: 		runTimeStatsOn = getLanguageConnectionContext().getRunTimeStatisticsMode();
1:7008b63: 		
1:7008b63: 		recordConstructorTime();
1:eac0369:     }
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// NoPutResultSet interface 
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * open a scan on the table. scan parameters are evaluated
1:eac0369:      * at each open, so there is probably some way of altering
1:eac0369:      * their values...
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if cursor finished.
1:eac0369:      */
1:eac0369: 	public void	openCore() throws StandardException 
1:eac0369: 	{
1:eac0369: 	    TransactionController tc;
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 
1:eac0369: 		// source expected to be non-null, mystery stress test bug
1:eac0369: 		// - sometimes get NullPointerException in openCore().
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(source != null,
1:eac0369: 				"HTRS().openCore(), source expected to be non-null");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// REVISIT: through the direct DB API, this needs to be an
1:eac0369: 		// error, not an ASSERT; users can open twice. Only through JDBC
1:eac0369: 		// is access to open controlled and ensured valid.
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		    SanityManager.ASSERT( ! isOpen, "HashTableResultSet already open");
1:eac0369: 
1:eac0369:         // Get the current transaction controller
1:eac0369:         tc = activation.getTransactionController();
1:eac0369: 
1:eac0369: 		if (! hashTableBuilt)
1:eac0369: 		{
1:eac0369: 	        source.openCore();
1:eac0369: 
1:eac0369: 			/* Create and populate the hash table.  We pass
1:eac0369: 			 * ourself in as the row source.  This allows us
1:eac0369: 			 * to apply the single table predicates to the
1:eac0369: 			 * rows coming from our child as we build the
1:eac0369: 			 * hash table.
1:eac0369: 			 */
1:eac0369: 			ht = new BackingStoreHashtable(tc,
1:eac0369: 										   this,
1:eac0369: 										   keyColumns,
1:eac0369: 										   removeDuplicates,
1:eac0369: 										   (int) optimizerEstimatedRowCount,
1:eac0369: 										   maxInMemoryRowCount,
1:eac0369: 										   (int) initialCapacity,
1:eac0369: 										   loadFactor,
1:b223f72: 										   skipNullKeyColumns,
1:b223f72:                                            false /* Not kept after a commit */);
1:eac0369: 
1:eac0369: 			if (runTimeStatsOn)
1:eac0369: 			{
1:eac0369: 				hashtableSize = ht.size();
1:eac0369: 
1:eac0369: 				if (scanProperties == null)
1:eac0369: 				{
1:eac0369: 					scanProperties = new Properties();
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				try
1:eac0369: 				{
1:eac0369: 					if (ht != null)
1:eac0369: 					{
1:eac0369:                         ht.getAllRuntimeStats(scanProperties);
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				catch(StandardException se)
1:eac0369: 				{
1:eac0369: 					// ignore
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			isOpen = true;
1:eac0369: 			hashTableBuilt = true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		resetProbeVariables();
1:eac0369: 
1:eac0369: 		numOpens++;
1:eac0369: 
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * reopen a scan on the table. scan parameters are evaluated
1:eac0369:      * at each open, so there is probably some way of altering
1:eac0369:      * their values...
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if cursor finished.
1:eac0369:      */
1:eac0369: 	public void	reopenCore() throws StandardException 
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(isOpen,
1:eac0369: 					"HashTableResultSet already open");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 
1:eac0369: 		resetProbeVariables();
1:eac0369: 
1:eac0369: 		numOpens++;
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void resetProbeVariables() throws StandardException
1:eac0369: 	{
1:eac0369: 		firstNext = true;
1:eac0369: 		numFetchedOnNext = 0;
1:eac0369: 		entryVector = null;
1:eac0369: 		entryVectorSize = 0;
1:eac0369: 
1:eac0369: 		if (nextQualifiers != null)
1:eac0369: 		{
1:eac0369: 			clearOrderableCache(nextQualifiers);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * Return the requested values computed
1:eac0369:      * from the next row (if any) for which
1:eac0369:      * the restriction evaluates to true.
1:eac0369:      * <p>
1:eac0369:      * restriction and projection parameters
1:eac0369:      * are evaluated for each row.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
1:eac0369: 	 *
1:eac0369: 	 * @return the next row in the result
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getNextRowCore() throws StandardException {
1:2a4654b: 		if( isXplainOnlyMode() )
1:2a4654b: 			return null;
1:2a4654b: 
1:eac0369: 	    ExecRow result = null;
1:eac0369: 		DataValueDescriptor[] columns = null;
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 	    if ( isOpen )
1:eac0369: 	    {
1:eac0369: 			/* We use a do/while loop to ensure that we continue down
1:eac0369: 			 * the duplicate chain, if one exists, until we find a
1:eac0369: 			 * row that matches on all probe predicates (or the
1:eac0369: 			 * duplicate chain is exhausted.)
1:eac0369: 			 */
1:eac0369: 			do 
1:eac0369: 			{
1:eac0369: 				if (firstNext)
1:eac0369: 				{			  
1:eac0369: 					firstNext = false;
1:eac0369: 
1:eac0369: 					/* Hash key could be either a single column or multiple 
1:eac0369:                      * columns.  If a single column, then it is the datavalue 
1:eac0369:                      * wrapper, otherwise it is a KeyHasher.
1:eac0369: 					 */
1:eac0369: 					Object hashEntry;
1:eac0369: 					if (keyColumns.length == 1)
1:eac0369: 					{
1:eac0369: 						hashEntry = ht.get(nextQualifiers[0][0].getOrderable());
1:eac0369: 					}
1:eac0369: 					else
1:eac0369: 					{
1:eac0369: 						KeyHasher mh = 
1:eac0369:                             new KeyHasher(keyColumns.length);
1:eac0369: 
1:eac0369: 						for (int index = 0; index < keyColumns.length; index++)
1:eac0369: 						{
1:eac0369:                             // RESOLVE (mikem) - will need to change when we
1:eac0369:                             // support OR's in qualifiers.
1:eac0369: 							mh.setObject(
1:eac0369:                                 index, nextQualifiers[0][index].getOrderable());
1:eac0369: 						}
1:eac0369: 						hashEntry = ht.get(mh);
1:eac0369: 					}
1:eac0369: 
1:bd34a3a: 					if (hashEntry instanceof List)
1:eac0369: 					{
1:bd34a3a: 						entryVector = (List) hashEntry;
1:eac0369: 						entryVectorSize = entryVector.size();
1:eac0369: 						columns = 
1:bd34a3a:                             (DataValueDescriptor[]) entryVector.get(0);
1:eac0369: 					}
1:eac0369: 					else
1:eac0369: 					{
1:eac0369: 						entryVector = null;
1:eac0369: 						entryVectorSize = 0;
1:eac0369: 						columns = (DataValueDescriptor[]) hashEntry;
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				else if (numFetchedOnNext < entryVectorSize)
1:eac0369: 				{
1:bd34a3a: 					// We are walking a list and there are more rows left.
1:eac0369: 					columns = (DataValueDescriptor[]) 
1:bd34a3a:                         entryVector.get(numFetchedOnNext);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				if (columns != null)
1:eac0369: 				{
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 					{
1:eac0369: 						// Columns is really a Storable[]
1:eac0369: 						for (int i = 0; i < columns.length; i++)
1:eac0369: 						{
1:00db860:                            if (! (columns[i] instanceof Storable))
1:eac0369: 							{
1:eac0369: 								SanityManager.THROWASSERT(
1:eac0369: 								"columns[" + i + "] expected to be Storable, not " +
1:eac0369: 								columns[i].getClass().getName());
1:eac0369: 							}
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					// See if the entry satisfies all of the other qualifiers
1:eac0369: 					boolean qualifies = true;
1:eac0369: 
1:eac0369: 					/* We've already "evaluated" the 1st keyColumns qualifiers 
1:eac0369:                      * when we probed into the hash table, but we need to 
1:eac0369:                      * evaluate them again here because of the behavior of 
1:eac0369:                      * NULLs.  NULLs are treated as equal when building and 
1:eac0369:                      * probing the hash table so that we only get a single 
1:eac0369:                      * entry.  However, NULL does not equal NULL, so the 
1:eac0369:                      * compare() method below will eliminate any row that
1:eac0369: 					 * has a key column containing a NULL.
1:eac0369: 					 */
1:eac0369: 
1:eac0369:                     // RESOLVE (mikem) will have to change when qualifiers 
1:eac0369:                     // support OR's.
1:eac0369: 
1:eac0369:                     if (SanityManager.DEBUG)
1:eac0369:                     {
1:eac0369:                         // we don't support 2 d qualifiers yet.
1:eac0369:                         SanityManager.ASSERT(nextQualifiers.length == 1);
1:eac0369:                     }
1:eac0369: 					for (int index = 0; index < nextQualifiers[0].length; index++)
1:eac0369: 					{
1:eac0369:                         Qualifier q = nextQualifiers[0][index];
1:eac0369: 
1:eac0369: 						qualifies = 
1:eac0369:                             columns[q.getColumnId()].compare(
1:eac0369:                                 q.getOperator(),
1:eac0369:                                 q.getOrderable(),
1:eac0369:                                 q.getOrderedNulls(),
1:eac0369:                                 q.getUnknownRV());
1:eac0369: 
1:eac0369: 						if (q.negateCompareResult()) 
1:eac0369: 						{ 
1:eac0369: 							qualifies = !(qualifies);
1:eac0369: 						} 
1:eac0369: 
1:eac0369: 						// Stop if any predicate fails
1:eac0369: 						if (! qualifies)
1:eac0369: 						{
1:eac0369: 							break;
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					if (qualifies)
1:eac0369: 					{
1:eac0369: 
1:eac0369: 						for (int index = 0; index < columns.length; index++)
1:eac0369: 						{
1:eac0369: 							nextCandidate.setColumn(index + 1, columns[index]);
1:eac0369: 						}
1:eac0369: 
1:eac0369: 						result = doProjection(nextCandidate);
1:eac0369: 					}
1:eac0369: 					else
1:eac0369: 					{
1:eac0369: 						result = null;
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					numFetchedOnNext++;
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					result = null;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			while (result == null && numFetchedOnNext < entryVectorSize);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		setCurrentRow(result);
1:eac0369: 
1:eac0369: 		nextTime += getElapsedMillis(beginTime);
1:eac0369: 
1:eac0369: 		if (runTimeStatsOn)
1:eac0369: 		{
1:eac0369: 			if (! isTopResultSet)
1:eac0369: 			{
1:eac0369: 				/* This is simply for RunTimeStats */
1:eac0369: 				/* We first need to get the subquery tracking array via the StatementContext */
1:eac0369: 				StatementContext sc = activation.getLanguageConnectionContext().getStatementContext();
1:eac0369: 				subqueryTrackingArray = sc.getSubqueryTrackingArray();
1:eac0369: 			}
1:eac0369: 			nextTime += getElapsedMillis(beginTime);
1:eac0369: 		}
1:eac0369:     	return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the total amount of time spent in this ResultSet
1:eac0369: 	 *
1:eac0369: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1:eac0369: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The total amount of time spent (in milliseconds).
1:eac0369: 	 */
1:eac0369: 	public long getTimeSpent(int type)
1:eac0369: 	{
1:eac0369: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1:eac0369: 
1:eac0369: 		if (type == CURRENT_RESULTSET_ONLY)
1:eac0369: 		{
1:eac0369: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return totTime;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// ResultSet interface
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * If the result set has been opened,
1:eac0369: 	 * close the open scan.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public void	close() throws StandardException
1:eac0369: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 	    if ( isOpen ) {
1:eac0369: 
1:eac0369: 			// we don't want to keep around a pointer to the
1:eac0369: 			// row ... so it can be thrown away.
1:eac0369: 			// REVISIT: does this need to be in a finally
1:eac0369: 			// block, to ensure that it is executed?
1:eac0369: 	    	clearCurrentRow();
1:f77f36d: 
1:eac0369: 	        source.close();
1:eac0369: 
1:eac0369: 			super.close();
1:eac0369: 
1:eac0369: 			if (hashTableBuilt)
1:eac0369: 			{
1:eac0369: 				// close the hash table, eating any exception
1:eac0369: 				ht.close();
1:eac0369: 				ht = null;
1:eac0369: 				hashTableBuilt = false;
1:eac0369: 			}
1:eac0369: 	    }
1:eac0369: 		else
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.DEBUG("CloseRepeatInfo","Close of ProjectRestrictResultSet repeated");
1:eac0369: 
1:eac0369: 		closeTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// CursorResultSet interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets information from its source. We might want
1:eac0369: 	 * to have this take a CursorResultSet in its constructor some day,
1:eac0369: 	 * instead of doing a cast here?
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the row location of the current cursor row.
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 */
1:eac0369: 	public RowLocation getRowLocation() throws StandardException {
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(source instanceof CursorResultSet, "source not instance of CursorResultSet");
1:eac0369: 		return ( (CursorResultSet)source ).getRowLocation();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets last row returned.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the last row returned.
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 */
1:eac0369: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1:eac0369: 	 * once there is such a method.  (currentRow is redundant)
1:eac0369: 	 */
1:eac0369: 	public ExecRow getCurrentRow() throws StandardException {
1:eac0369: 	    ExecRow candidateRow = null;
1:eac0369: 	    ExecRow result = null;
1:eac0369: 	    boolean restrict = false;
1:eac0369: 	    DataValueDescriptor restrictBoolean;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isOpen, "PRRS is expected to be open");
1:eac0369: 
1:eac0369: 		/* Nothing to do if we're not currently on a row */
1:eac0369: 		if (currentRow == null)
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Call the child result set to get it's current row.
1:eac0369: 		 * If no row exists, then return null, else requalify it
1:eac0369: 		 * before returning.
1:eac0369: 		 */
1:eac0369: 		candidateRow = ((CursorResultSet) source).getCurrentRow();
1:eac0369: 		if (candidateRow != null) {
1:eac0369: 			setCurrentRow(candidateRow);
1:eac0369: 				/* If restriction is null, then all rows qualify */
1:eac0369:             restrictBoolean = (DataValueDescriptor) 
1:eac0369: 					((singleTableRestriction == null) ? null : singleTableRestriction.invoke(activation));
1:eac0369: 
1:eac0369:             // if the result is null, we make it false --
1:eac0369: 			// so the row won't be returned.
1:eac0369:             restrict = (restrictBoolean == null) ||
1:eac0369: 						((! restrictBoolean.isNull()) &&
1:eac0369: 							restrictBoolean.getBoolean());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	    if (candidateRow != null && restrict) 
1:eac0369: 		{
1:eac0369: 			result = doProjection(candidateRow);
1:eac0369:         }
1:eac0369: 
2:eac0369: 		currentRow = result;
1:eac0369: 		/* Clear the current row, if null */
1:eac0369: 		if (result == null) {
1:eac0369: 			clearCurrentRow();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return currentRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do the projection against the source row.  Use reflection
1:eac0369: 	 * where necessary, otherwise get the source column into our
1:eac0369: 	 * result row.
1:eac0369: 	 *
1:eac0369: 	 * @param sourceRow		The source row.
1:eac0369: 	 *
1:eac0369: 	 * @return		The result of the projection
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 */
1:eac0369: 	private ExecRow doProjection(ExecRow sourceRow)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		// No need to use reflection if reusing the result
1:eac0369: 		if (reuseResult && projRow != null)
1:eac0369: 		{
1:eac0369: 			return projRow;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		ExecRow result;
1:eac0369: 
1:eac0369: 		// Use reflection to do as much of projection as required
1:eac0369: 		if (projection != null)
1:eac0369: 		{
1:eac0369: 	        result = (ExecRow) projection.invoke(activation);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			result = mappedResultRow;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Copy any mapped columns from the source
1:eac0369: 		for (int index = 0; index < projectMapping.length; index++)
1:eac0369: 		{
1:eac0369: 			if (projectMapping[index] != -1)
1:eac0369: 			{
1:eac0369: 				result.setColumn(index + 1, sourceRow.getColumn(projectMapping[index]));
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* We need to reSet the current row after doing the projection */
1:eac0369: 		setCurrentRow(result);
1:eac0369: 
1:eac0369: 		/* Remember the result if reusing it */
1:eac0369: 		if (reuseResult)
1:eac0369: 		{
1:eac0369: 			projRow = result;
1:eac0369: 		}
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// RowSource interface
1:eac0369: 		
1:eac0369: 	/** 
1:eac0369: 	 * @see RowSource#getNextRowFromRowSource
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public DataValueDescriptor[] getNextRowFromRowSource()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ExecRow execRow = source.getNextRowCore();
1:eac0369: 
1:eac0369: 		/* Use the single table predicates, if any,
1:eac0369: 		 * to filter out rows while populating the
1:eac0369: 		 * hash table.
1:eac0369: 		 */
1:eac0369:  		while (execRow != null)
1:eac0369: 		{
1:eac0369: 		    boolean restrict = false;
1:eac0369: 		    DataValueDescriptor restrictBoolean;
1:eac0369: 
1:eac0369: 			rowsSeen++;
1:eac0369: 
1:eac0369: 			/* If restriction is null, then all rows qualify */
1:eac0369:             restrictBoolean = (DataValueDescriptor) 
1:eac0369: 					((singleTableRestriction == null) ? null : singleTableRestriction.invoke(activation));
1:eac0369: 
1:eac0369:             // if the result is null, we make it false --
1:eac0369: 			// so the row won't be returned.
1:eac0369:             restrict = (restrictBoolean == null) ||
1:eac0369: 						((! restrictBoolean.isNull()) &&
1:eac0369: 							restrictBoolean.getBoolean());
1:eac0369: 			if (!restrict)
1:eac0369: 			{
1:eac0369: 				execRow = source.getNextRowCore();
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (targetResultSet != null)
1:eac0369: 			{
1:eac0369: 				/* Let the target preprocess the row.  For now, this
1:eac0369: 				 * means doing an in place clone on any indexed columns
1:eac0369: 				 * to optimize cloning and so that we don't try to drain
1:eac0369: 				 * a stream multiple times.  This is where we also
1:eac0369: 				 * enforce any check constraints.
1:eac0369: 				 */
1:eac0369: 				clonedExecRow = targetResultSet.preprocessSourceRow(execRow);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 
1:eac0369: 			/* Get a single ExecRow of the same size
1:eac0369: 			 * on the way in so that we have a row
1:eac0369: 			 * to use on the way out.
1:eac0369: 			 */
1:eac0369: 			if (firstIntoHashtable)
1:eac0369: 			{
1:eac0369: 				nextCandidate = activation.getExecutionFactory().getValueRow(execRow.nColumns());
1:eac0369: 				firstIntoHashtable = false;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return execRow.getRowArray();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this ResultSet or it's source result set for update
1:eac0369: 	 * 
1:eac0369: 	 * @return Whether or not the result set is for update.
1:eac0369: 	 */
1:eac0369: 	public boolean isForUpdate()
1:eac0369: 	{
1:eac0369: 		if (source == null) 
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 		return source.isForUpdate();
1:eac0369: 	}
1:eac0369: 
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:2a4654b
/////////////////////////////////////////////////////////////////////////
1: 		if( isXplainOnlyMode() )
1: 			return null;
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:473d692
/////////////////////////////////////////////////////////////////////////
1:         FormatableIntHolder[] fihArray = fah.getArray(FormatableIntHolder[].class);
commit:bd34a3a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1: 	private List		entryVector;
/////////////////////////////////////////////////////////////////////////
1: 					if (hashEntry instanceof List)
1: 						entryVector = (List) hashEntry;
1:                             (DataValueDescriptor[]) entryVector.get(0);
/////////////////////////////////////////////////////////////////////////
1: 					// We are walking a list and there are more rows left.
1:                         entryVector.get(numFetchedOnNext);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:00db860
/////////////////////////////////////////////////////////////////////////
1:                            if (! (columns[i] instanceof Storable))
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4e784bb
/////////////////////////////////////////////////////////////////////////
commit:7008b63
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		recordConstructorTime();
commit:f77f36d
/////////////////////////////////////////////////////////////////////////
1: class HashTableResultSet extends NoPutResultSetImpl
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     HashTableResultSet(NoPutResultSet s,
/////////////////////////////////////////////////////////////////////////
1: 					double optimizerEstimatedCost) 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.HashTableResultSet
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
1: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.services.io.Storable;
1: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.conn.StatementContext;
1: 
1: 
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.RowSource;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
1: import org.apache.derby.iapi.services.io.FormatableIntHolder;
1: import org.apache.derby.iapi.store.access.KeyHasher;
1: 
1: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1: 
1: import java.util.Properties;
0: import java.util.Vector;
1: 
1: /**
1:  * Builds a hash table on the underlying result set tree.
1:  *
0:  * @author jerry
1:  */
0: public class HashTableResultSet extends NoPutResultSetImpl
1: 	implements CursorResultSet 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	/* Run time statistics variables */
1: 	public long restrictionTime;
1: 	public long projectionTime;
1: 	public int  hashtableSize;
1: 	public Properties scanProperties;
1: 
1:     // set in constructor and not altered during
1:     // life of object.
1:     public NoPutResultSet source;
1:     public GeneratedMethod singleTableRestriction;
1: 	public Qualifier[][] nextQualifiers;
1:     private GeneratedMethod projection;
1: 	private int[]			projectMapping;
0:     private GeneratedMethod closeCleanup;
1: 	private boolean runTimeStatsOn;
1: 	private ExecRow			mappedResultRow;
1: 	public boolean reuseResult;
1: 	public int[]			keyColumns;
1: 	private boolean			removeDuplicates;
1: 	private long			maxInMemoryRowCount;
1:     private	int				initialCapacity;
1:     private	float			loadFactor;
1: 	private boolean			skipNullKeyColumns;
1: 
1: 	// Variable for managing next() logic on hash entry
1: 	private boolean		firstNext = true;
1: 	private int			numFetchedOnNext;
1: 	private int			entryVectorSize;
0: 	private Vector		entryVector;
1: 
1: 	private boolean hashTableBuilt;
1: 	private boolean firstIntoHashtable = true;
1: 
1: 	private ExecRow nextCandidate;
1: 	private ExecRow projRow;
1: 
1: 	private BackingStoreHashtable ht;
1: 
1:     //
1:     // class interface
1:     //
0:     public HashTableResultSet(NoPutResultSet s,
1: 					Activation a,
1: 					GeneratedMethod str,
1: 					Qualifier[][] nextQualifiers,
1: 					GeneratedMethod p,
1: 					int resultSetNumber,
1: 					int mapRefItem,
1: 					boolean reuseResult,
1: 					int keyColItem,
1: 					boolean removeDuplicates,
1: 					long maxInMemoryRowCount,
1: 					int	initialCapacity,
1: 					float loadFactor,
1: 					boolean skipNullKeyColumns,
1: 				    double optimizerEstimatedRowCount,
0: 					double optimizerEstimatedCost,
0: 					GeneratedMethod c) 
1: 		throws StandardException
1: 	{
1: 		super(a, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost);
1:         source = s;
1: 		// source expected to be non-null, mystery stress test bug
1: 		// - sometimes get NullPointerException in openCore().
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(source != null,
1: 				"HTRS(), source expected to be non-null");
1: 		}
1:         singleTableRestriction = str;
1: 		this.nextQualifiers = nextQualifiers;
1:         projection = p;
1: 		projectMapping = ((ReferencedColumnsDescriptorImpl) a.getPreparedStatement().getSavedObject(mapRefItem)).getReferencedColumnPositions();
1: 		FormatableArrayHolder fah = (FormatableArrayHolder) a.getPreparedStatement().getSavedObject(keyColItem);
0: 		FormatableIntHolder[] fihArray = (FormatableIntHolder[]) fah.getArray(FormatableIntHolder.class);
1: 		keyColumns = new int[fihArray.length];
1: 		for (int index = 0; index < fihArray.length; index++)
1: 		{
1: 			keyColumns[index] = fihArray[index].getInt();
1: 		}
1: 
1: 		this.reuseResult = reuseResult;
1: 		this.removeDuplicates = removeDuplicates;
1: 		this.maxInMemoryRowCount = maxInMemoryRowCount;
1: 		this.initialCapacity = initialCapacity;
1: 		this.loadFactor = loadFactor;
1: 		this.skipNullKeyColumns = skipNullKeyColumns;
0:         closeCleanup = c;
1: 
1: 		// Allocate a result row if all of the columns are mapped from the source
1: 		if (projection == null)
1: 		{
1: 			mappedResultRow = activation.getExecutionFactory().getValueRow(projectMapping.length);
1: 		}
0: 		constructorTime += getElapsedMillis(beginTime);
1: 
1: 		/* Remember whether or not RunTimeStatistics is on */
1: 		runTimeStatsOn = getLanguageConnectionContext().getRunTimeStatisticsMode();
1:     }
1: 
1: 	//
1: 	// NoPutResultSet interface 
1: 	//
1: 
1: 	/**
1:      * open a scan on the table. scan parameters are evaluated
1:      * at each open, so there is probably some way of altering
1:      * their values...
1: 	 *
1: 	 * @exception StandardException thrown if cursor finished.
1:      */
1: 	public void	openCore() throws StandardException 
1: 	{
1: 	    TransactionController tc;
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 
1: 		// source expected to be non-null, mystery stress test bug
1: 		// - sometimes get NullPointerException in openCore().
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(source != null,
1: 				"HTRS().openCore(), source expected to be non-null");
1: 		}
1: 
1: 		// REVISIT: through the direct DB API, this needs to be an
1: 		// error, not an ASSERT; users can open twice. Only through JDBC
1: 		// is access to open controlled and ensured valid.
1: 		if (SanityManager.DEBUG)
1: 		    SanityManager.ASSERT( ! isOpen, "HashTableResultSet already open");
1: 
1:         // Get the current transaction controller
1:         tc = activation.getTransactionController();
1: 
1: 		if (! hashTableBuilt)
1: 		{
1: 	        source.openCore();
1: 
1: 			/* Create and populate the hash table.  We pass
1: 			 * ourself in as the row source.  This allows us
1: 			 * to apply the single table predicates to the
1: 			 * rows coming from our child as we build the
1: 			 * hash table.
1: 			 */
1: 			ht = new BackingStoreHashtable(tc,
1: 										   this,
1: 										   keyColumns,
1: 										   removeDuplicates,
1: 										   (int) optimizerEstimatedRowCount,
1: 										   maxInMemoryRowCount,
1: 										   (int) initialCapacity,
1: 										   loadFactor,
0: 										   skipNullKeyColumns);
1: 
1: 			if (runTimeStatsOn)
1: 			{
1: 				hashtableSize = ht.size();
1: 
1: 				if (scanProperties == null)
1: 				{
1: 					scanProperties = new Properties();
1: 				}
1: 
1: 				try
1: 				{
1: 					if (ht != null)
1: 					{
1:                         ht.getAllRuntimeStats(scanProperties);
1: 					}
1: 				}
1: 				catch(StandardException se)
1: 				{
1: 					// ignore
1: 				}
1: 			}
1: 
1: 			isOpen = true;
1: 			hashTableBuilt = true;
1: 		}
1: 
1: 		resetProbeVariables();
1: 
1: 		numOpens++;
1: 
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1:      * reopen a scan on the table. scan parameters are evaluated
1:      * at each open, so there is probably some way of altering
1:      * their values...
1: 	 *
1: 	 * @exception StandardException thrown if cursor finished.
1:      */
1: 	public void	reopenCore() throws StandardException 
1: 	{
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(isOpen,
1: 					"HashTableResultSet already open");
1: 		}
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 
1: 		resetProbeVariables();
1: 
1: 		numOpens++;
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	private void resetProbeVariables() throws StandardException
1: 	{
1: 		firstNext = true;
1: 		numFetchedOnNext = 0;
1: 		entryVector = null;
1: 		entryVectorSize = 0;
1: 
1: 		if (nextQualifiers != null)
1: 		{
1: 			clearOrderableCache(nextQualifiers);
1: 		}
1: 	}
1: 
1: 	/**
1:      * Return the requested values computed
1:      * from the next row (if any) for which
1:      * the restriction evaluates to true.
1:      * <p>
1:      * restriction and projection parameters
1:      * are evaluated for each row.
1: 	 *
1: 	 * @exception StandardException thrown on failure.
1: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
1: 	 *
1: 	 * @return the next row in the result
1: 	 */
1: 	public ExecRow	getNextRowCore() throws StandardException {
1: 	    ExecRow result = null;
1: 		DataValueDescriptor[] columns = null;
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 	    if ( isOpen )
1: 	    {
1: 			/* We use a do/while loop to ensure that we continue down
1: 			 * the duplicate chain, if one exists, until we find a
1: 			 * row that matches on all probe predicates (or the
1: 			 * duplicate chain is exhausted.)
1: 			 */
1: 			do 
1: 			{
1: 				if (firstNext)
1: 				{			  
1: 					firstNext = false;
1: 
1: 					/* Hash key could be either a single column or multiple 
1:                      * columns.  If a single column, then it is the datavalue 
1:                      * wrapper, otherwise it is a KeyHasher.
1: 					 */
1: 					Object hashEntry;
1: 					if (keyColumns.length == 1)
1: 					{
1: 						hashEntry = ht.get(nextQualifiers[0][0].getOrderable());
1: 					}
1: 					else
1: 					{
1: 						KeyHasher mh = 
1:                             new KeyHasher(keyColumns.length);
1: 
1: 						for (int index = 0; index < keyColumns.length; index++)
1: 						{
1:                             // RESOLVE (mikem) - will need to change when we
1:                             // support OR's in qualifiers.
1: 							mh.setObject(
1:                                 index, nextQualifiers[0][index].getOrderable());
1: 						}
1: 						hashEntry = ht.get(mh);
1: 					}
1: 
0: 					if (hashEntry instanceof Vector)
1: 					{
0: 						entryVector = (Vector) hashEntry;
1: 						entryVectorSize = entryVector.size();
1: 						columns = 
0:                             (DataValueDescriptor[]) entryVector.firstElement();
1: 					}
1: 					else
1: 					{
1: 						entryVector = null;
1: 						entryVectorSize = 0;
1: 						columns = (DataValueDescriptor[]) hashEntry;
1: 					}
1: 				}
1: 				else if (numFetchedOnNext < entryVectorSize)
1: 				{
0: 					/* We walking a Vector and there's 
0: 					 * more rows left in the vector.
1: 					 */
1: 					columns = (DataValueDescriptor[]) 
0:                         entryVector.elementAt(numFetchedOnNext);
1: 				}
1: 
1: 				if (columns != null)
1: 				{
1: 					if (SanityManager.DEBUG)
1: 					{
1: 						// Columns is really a Storable[]
1: 						for (int i = 0; i < columns.length; i++)
1: 						{
0: 							if (! (columns[0] instanceof Storable))
1: 							{
1: 								SanityManager.THROWASSERT(
1: 								"columns[" + i + "] expected to be Storable, not " +
1: 								columns[i].getClass().getName());
1: 							}
1: 						}
1: 					}
1: 
1: 					// See if the entry satisfies all of the other qualifiers
1: 					boolean qualifies = true;
1: 
1: 					/* We've already "evaluated" the 1st keyColumns qualifiers 
1:                      * when we probed into the hash table, but we need to 
1:                      * evaluate them again here because of the behavior of 
1:                      * NULLs.  NULLs are treated as equal when building and 
1:                      * probing the hash table so that we only get a single 
1:                      * entry.  However, NULL does not equal NULL, so the 
1:                      * compare() method below will eliminate any row that
1: 					 * has a key column containing a NULL.
1: 					 */
1: 
1:                     // RESOLVE (mikem) will have to change when qualifiers 
1:                     // support OR's.
1: 
1:                     if (SanityManager.DEBUG)
1:                     {
1:                         // we don't support 2 d qualifiers yet.
1:                         SanityManager.ASSERT(nextQualifiers.length == 1);
1:                     }
1: 					for (int index = 0; index < nextQualifiers[0].length; index++)
1: 					{
1:                         Qualifier q = nextQualifiers[0][index];
1: 
1: 						qualifies = 
1:                             columns[q.getColumnId()].compare(
1:                                 q.getOperator(),
1:                                 q.getOrderable(),
1:                                 q.getOrderedNulls(),
1:                                 q.getUnknownRV());
1: 
1: 						if (q.negateCompareResult()) 
1: 						{ 
1: 							qualifies = !(qualifies);
1: 						} 
1: 
1: 						// Stop if any predicate fails
1: 						if (! qualifies)
1: 						{
1: 							break;
1: 						}
1: 					}
1: 
1: 					if (qualifies)
1: 					{
1: 
1: 						for (int index = 0; index < columns.length; index++)
1: 						{
1: 							nextCandidate.setColumn(index + 1, columns[index]);
1: 						}
1: 
1: 						result = doProjection(nextCandidate);
1: 					}
1: 					else
1: 					{
1: 						result = null;
1: 					}
1: 
1: 					numFetchedOnNext++;
1: 				}
1: 				else
1: 				{
1: 					result = null;
1: 				}
1: 			}
1: 			while (result == null && numFetchedOnNext < entryVectorSize);
1: 		}
1: 
1: 		currentRow = result;
1: 		setCurrentRow(result);
1: 
1: 		nextTime += getElapsedMillis(beginTime);
1: 
1: 		if (runTimeStatsOn)
1: 		{
1: 			if (! isTopResultSet)
1: 			{
1: 				/* This is simply for RunTimeStats */
1: 				/* We first need to get the subquery tracking array via the StatementContext */
1: 				StatementContext sc = activation.getLanguageConnectionContext().getStatementContext();
1: 				subqueryTrackingArray = sc.getSubqueryTrackingArray();
1: 			}
1: 			nextTime += getElapsedMillis(beginTime);
1: 		}
1:     	return result;
1: 	}
1: 
1: 	/**
1: 	 * Return the total amount of time spent in this ResultSet
1: 	 *
1: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1: 	 *
1: 	 * @return long		The total amount of time spent (in milliseconds).
1: 	 */
1: 	public long getTimeSpent(int type)
1: 	{
1: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1: 
1: 		if (type == CURRENT_RESULTSET_ONLY)
1: 		{
1: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
1: 		}
1: 		else
1: 		{
1: 			return totTime;
1: 		}
1: 	}
1: 
1: 	// ResultSet interface
1: 
1: 	/**
1: 	 * If the result set has been opened,
1: 	 * close the open scan.
1: 	 *
1: 	 * @exception StandardException thrown on error
1: 	 */
1: 	public void	close() throws StandardException
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 	    if ( isOpen ) {
1: 
1: 			// we don't want to keep around a pointer to the
1: 			// row ... so it can be thrown away.
1: 			// REVISIT: does this need to be in a finally
1: 			// block, to ensure that it is executed?
1: 	    	clearCurrentRow();
0: 			if (closeCleanup != null) {
0: 				closeCleanup.invoke(activation); // let activation tidy up
1: 			}
0: 			currentRow = null;
1: 	        source.close();
1: 
1: 			super.close();
1: 
1: 			if (hashTableBuilt)
1: 			{
1: 				// close the hash table, eating any exception
1: 				ht.close();
1: 				ht = null;
1: 				hashTableBuilt = false;
1: 			}
1: 	    }
1: 		else
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.DEBUG("CloseRepeatInfo","Close of ProjectRestrictResultSet repeated");
1: 
1: 		closeTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	//
1: 	// CursorResultSet interface
1: 	//
1: 
1: 	/**
1: 	 * Gets information from its source. We might want
1: 	 * to have this take a CursorResultSet in its constructor some day,
1: 	 * instead of doing a cast here?
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the row location of the current cursor row.
1: 	 * @exception StandardException thrown on failure.
1: 	 */
1: 	public RowLocation getRowLocation() throws StandardException {
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(source instanceof CursorResultSet, "source not instance of CursorResultSet");
1: 		return ( (CursorResultSet)source ).getRowLocation();
1: 	}
1: 
1: 	/**
1: 	 * Gets last row returned.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the last row returned.
1: 	 * @exception StandardException thrown on failure.
1: 	 */
1: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1: 	 * once there is such a method.  (currentRow is redundant)
1: 	 */
1: 	public ExecRow getCurrentRow() throws StandardException {
1: 	    ExecRow candidateRow = null;
1: 	    ExecRow result = null;
1: 	    boolean restrict = false;
1: 	    DataValueDescriptor restrictBoolean;
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isOpen, "PRRS is expected to be open");
1: 
1: 		/* Nothing to do if we're not currently on a row */
1: 		if (currentRow == null)
1: 		{
1: 			return null;
1: 		}
1: 
1: 		/* Call the child result set to get it's current row.
1: 		 * If no row exists, then return null, else requalify it
1: 		 * before returning.
1: 		 */
1: 		candidateRow = ((CursorResultSet) source).getCurrentRow();
1: 		if (candidateRow != null) {
1: 			setCurrentRow(candidateRow);
1: 				/* If restriction is null, then all rows qualify */
1:             restrictBoolean = (DataValueDescriptor) 
1: 					((singleTableRestriction == null) ? null : singleTableRestriction.invoke(activation));
1: 
1:             // if the result is null, we make it false --
1: 			// so the row won't be returned.
1:             restrict = (restrictBoolean == null) ||
1: 						((! restrictBoolean.isNull()) &&
1: 							restrictBoolean.getBoolean());
1: 		}
1: 
1: 	    if (candidateRow != null && restrict) 
1: 		{
1: 			result = doProjection(candidateRow);
1:         }
1: 
1: 		currentRow = result;
1: 		/* Clear the current row, if null */
1: 		if (result == null) {
1: 			clearCurrentRow();
1: 		}
1: 
1: 		return currentRow;
1: 	}
1: 
1: 	/**
1: 	 * Do the projection against the source row.  Use reflection
1: 	 * where necessary, otherwise get the source column into our
1: 	 * result row.
1: 	 *
1: 	 * @param sourceRow		The source row.
1: 	 *
1: 	 * @return		The result of the projection
1: 	 *
1: 	 * @exception StandardException thrown on failure.
1: 	 */
1: 	private ExecRow doProjection(ExecRow sourceRow)
1: 		throws StandardException
1: 	{
1: 		// No need to use reflection if reusing the result
1: 		if (reuseResult && projRow != null)
1: 		{
1: 			return projRow;
1: 		}
1: 
1: 		ExecRow result;
1: 
1: 		// Use reflection to do as much of projection as required
1: 		if (projection != null)
1: 		{
1: 	        result = (ExecRow) projection.invoke(activation);
1: 		}
1: 		else
1: 		{
1: 			result = mappedResultRow;
1: 		}
1: 
1: 		// Copy any mapped columns from the source
1: 		for (int index = 0; index < projectMapping.length; index++)
1: 		{
1: 			if (projectMapping[index] != -1)
1: 			{
1: 				result.setColumn(index + 1, sourceRow.getColumn(projectMapping[index]));
1: 			}
1: 		}
1: 
1: 		/* We need to reSet the current row after doing the projection */
1: 		setCurrentRow(result);
1: 
1: 		/* Remember the result if reusing it */
1: 		if (reuseResult)
1: 		{
1: 			projRow = result;
1: 		}
1: 		return result;
1: 	}
1: 
1: 	// RowSource interface
1: 		
1: 	/** 
1: 	 * @see RowSource#getNextRowFromRowSource
1: 	 * @exception StandardException on error
1: 	 */
1: 	public DataValueDescriptor[] getNextRowFromRowSource()
1: 		throws StandardException
1: 	{
1: 		ExecRow execRow = source.getNextRowCore();
1: 
1: 		/* Use the single table predicates, if any,
1: 		 * to filter out rows while populating the
1: 		 * hash table.
1: 		 */
1:  		while (execRow != null)
1: 		{
1: 		    boolean restrict = false;
1: 		    DataValueDescriptor restrictBoolean;
1: 
1: 			rowsSeen++;
1: 
1: 			/* If restriction is null, then all rows qualify */
1:             restrictBoolean = (DataValueDescriptor) 
1: 					((singleTableRestriction == null) ? null : singleTableRestriction.invoke(activation));
1: 
1:             // if the result is null, we make it false --
1: 			// so the row won't be returned.
1:             restrict = (restrictBoolean == null) ||
1: 						((! restrictBoolean.isNull()) &&
1: 							restrictBoolean.getBoolean());
1: 			if (!restrict)
1: 			{
1: 				execRow = source.getNextRowCore();
1: 				continue;
1: 			}
1: 
1: 			if (targetResultSet != null)
1: 			{
1: 				/* Let the target preprocess the row.  For now, this
1: 				 * means doing an in place clone on any indexed columns
1: 				 * to optimize cloning and so that we don't try to drain
1: 				 * a stream multiple times.  This is where we also
1: 				 * enforce any check constraints.
1: 				 */
1: 				clonedExecRow = targetResultSet.preprocessSourceRow(execRow);
1: 			}
1: 
1: 
1: 			/* Get a single ExecRow of the same size
1: 			 * on the way in so that we have a row
1: 			 * to use on the way out.
1: 			 */
1: 			if (firstIntoHashtable)
1: 			{
1: 				nextCandidate = activation.getExecutionFactory().getValueRow(execRow.nColumns());
1: 				firstIntoHashtable = false;
1: 			}
1: 
1: 			return execRow.getRowArray();
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Is this ResultSet or it's source result set for update
1: 	 * 
1: 	 * @return Whether or not the result set is for update.
1: 	 */
1: 	public boolean isForUpdate()
1: 	{
1: 		if (source == null) 
1: 		{
1: 			return false;
1: 		}
1: 		return source.isForUpdate();
1: 	}
1: 
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b223f72
/////////////////////////////////////////////////////////////////////////
1: 										   skipNullKeyColumns,
1:                                            false /* Not kept after a commit */);
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.Storable;
0: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
0: 
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowSource;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
0: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
0: import org.apache.derby.iapi.services.io.FormatableIntHolder;
0: import org.apache.derby.iapi.store.access.KeyHasher;
0: 
0: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
0: 
0: import java.util.Properties;
0: import java.util.Vector;
0: 
0: /**
0:  * Builds a hash table on the underlying result set tree.
0:  *
0:  * @author jerry
0:  */
0: public class HashTableResultSet extends NoPutResultSetImpl
0: 	implements CursorResultSet 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	/* Run time statistics variables */
0: 	public long restrictionTime;
0: 	public long projectionTime;
0: 	public int  hashtableSize;
0: 	public Properties scanProperties;
0: 
0:     // set in constructor and not altered during
0:     // life of object.
0:     public NoPutResultSet source;
0:     public GeneratedMethod singleTableRestriction;
0: 	public Qualifier[][] nextQualifiers;
0:     private GeneratedMethod projection;
0: 	private int[]			projectMapping;
0:     private GeneratedMethod closeCleanup;
0: 	private boolean runTimeStatsOn;
0: 	private ExecRow			mappedResultRow;
0: 	public boolean reuseResult;
0: 	public int[]			keyColumns;
0: 	private boolean			removeDuplicates;
0: 	private long			maxInMemoryRowCount;
0:     private	int				initialCapacity;
0:     private	float			loadFactor;
0: 	private boolean			skipNullKeyColumns;
0: 
0: 	// Variable for managing next() logic on hash entry
0: 	private boolean		firstNext = true;
0: 	private int			numFetchedOnNext;
0: 	private int			entryVectorSize;
0: 	private Vector		entryVector;
0: 
0: 	private boolean hashTableBuilt;
0: 	private boolean firstIntoHashtable = true;
0: 
0: 	private ExecRow nextCandidate;
0: 	private ExecRow projRow;
0: 
0: 	private BackingStoreHashtable ht;
0: 
0:     //
0:     // class interface
0:     //
0:     public HashTableResultSet(NoPutResultSet s,
0: 					Activation a,
0: 					GeneratedMethod str,
0: 					Qualifier[][] nextQualifiers,
0: 					GeneratedMethod p,
0: 					int resultSetNumber,
0: 					int mapRefItem,
0: 					boolean reuseResult,
0: 					int keyColItem,
0: 					boolean removeDuplicates,
0: 					long maxInMemoryRowCount,
0: 					int	initialCapacity,
0: 					float loadFactor,
0: 					boolean skipNullKeyColumns,
0: 				    double optimizerEstimatedRowCount,
0: 					double optimizerEstimatedCost,
0: 					GeneratedMethod c) 
0: 		throws StandardException
0: 	{
0: 		super(a, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost);
0:         source = s;
0: 		// source expected to be non-null, mystery stress test bug
0: 		// - sometimes get NullPointerException in openCore().
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(source != null,
0: 				"HTRS(), source expected to be non-null");
0: 		}
0:         singleTableRestriction = str;
0: 		this.nextQualifiers = nextQualifiers;
0:         projection = p;
0: 		projectMapping = ((ReferencedColumnsDescriptorImpl) a.getPreparedStatement().getSavedObject(mapRefItem)).getReferencedColumnPositions();
0: 		FormatableArrayHolder fah = (FormatableArrayHolder) a.getPreparedStatement().getSavedObject(keyColItem);
0: 		FormatableIntHolder[] fihArray = (FormatableIntHolder[]) fah.getArray(FormatableIntHolder.class);
0: 		keyColumns = new int[fihArray.length];
0: 		for (int index = 0; index < fihArray.length; index++)
0: 		{
0: 			keyColumns[index] = fihArray[index].getInt();
0: 		}
0: 
0: 		this.reuseResult = reuseResult;
0: 		this.removeDuplicates = removeDuplicates;
0: 		this.maxInMemoryRowCount = maxInMemoryRowCount;
0: 		this.initialCapacity = initialCapacity;
0: 		this.loadFactor = loadFactor;
0: 		this.skipNullKeyColumns = skipNullKeyColumns;
0:         closeCleanup = c;
0: 
0: 		// Allocate a result row if all of the columns are mapped from the source
0: 		if (projection == null)
0: 		{
0: 			mappedResultRow = activation.getExecutionFactory().getValueRow(projectMapping.length);
0: 		}
0: 		constructorTime += getElapsedMillis(beginTime);
0: 
0: 		/* Remember whether or not RunTimeStatistics is on */
0: 		runTimeStatsOn = getLanguageConnectionContext().getRunTimeStatisticsMode();
0:     }
0: 
0: 	//
0: 	// NoPutResultSet interface 
0: 	//
0: 
0: 	/**
0:      * open a scan on the table. scan parameters are evaluated
0:      * at each open, so there is probably some way of altering
0:      * their values...
0: 	 *
0: 	 * @exception StandardException thrown if cursor finished.
0:      */
0: 	public void	openCore() throws StandardException 
0: 	{
0: 	    TransactionController tc;
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 
0: 		// source expected to be non-null, mystery stress test bug
0: 		// - sometimes get NullPointerException in openCore().
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(source != null,
0: 				"HTRS().openCore(), source expected to be non-null");
0: 		}
0: 
0: 		// REVISIT: through the direct DB API, this needs to be an
0: 		// error, not an ASSERT; users can open twice. Only through JDBC
0: 		// is access to open controlled and ensured valid.
0: 		if (SanityManager.DEBUG)
0: 		    SanityManager.ASSERT( ! isOpen, "HashTableResultSet already open");
0: 
0:         // Get the current transaction controller
0:         tc = activation.getTransactionController();
0: 
0: 		if (! hashTableBuilt)
0: 		{
0: 	        source.openCore();
0: 
0: 			/* Create and populate the hash table.  We pass
0: 			 * ourself in as the row source.  This allows us
0: 			 * to apply the single table predicates to the
0: 			 * rows coming from our child as we build the
0: 			 * hash table.
0: 			 */
0: 			ht = new BackingStoreHashtable(tc,
0: 										   this,
0: 										   keyColumns,
0: 										   removeDuplicates,
0: 										   (int) optimizerEstimatedRowCount,
0: 										   maxInMemoryRowCount,
0: 										   (int) initialCapacity,
0: 										   loadFactor,
0: 										   skipNullKeyColumns);
0: 
0: 			if (runTimeStatsOn)
0: 			{
0: 				hashtableSize = ht.size();
0: 
0: 				if (scanProperties == null)
0: 				{
0: 					scanProperties = new Properties();
0: 				}
0: 
0: 				try
0: 				{
0: 					if (ht != null)
0: 					{
0:                         ht.getAllRuntimeStats(scanProperties);
0: 					}
0: 				}
0: 				catch(StandardException se)
0: 				{
0: 					// ignore
0: 				}
0: 			}
0: 
0: 			isOpen = true;
0: 			hashTableBuilt = true;
0: 		}
0: 
0: 		resetProbeVariables();
0: 
0: 		numOpens++;
0: 
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0:      * reopen a scan on the table. scan parameters are evaluated
0:      * at each open, so there is probably some way of altering
0:      * their values...
0: 	 *
0: 	 * @exception StandardException thrown if cursor finished.
0:      */
0: 	public void	reopenCore() throws StandardException 
0: 	{
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(isOpen,
0: 					"HashTableResultSet already open");
0: 		}
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 
0: 		resetProbeVariables();
0: 
0: 		numOpens++;
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	private void resetProbeVariables() throws StandardException
0: 	{
0: 		firstNext = true;
0: 		numFetchedOnNext = 0;
0: 		entryVector = null;
0: 		entryVectorSize = 0;
0: 
0: 		if (nextQualifiers != null)
0: 		{
0: 			clearOrderableCache(nextQualifiers);
0: 		}
0: 	}
0: 
0: 	/**
0:      * Return the requested values computed
0:      * from the next row (if any) for which
0:      * the restriction evaluates to true.
0:      * <p>
0:      * restriction and projection parameters
0:      * are evaluated for each row.
0: 	 *
0: 	 * @exception StandardException thrown on failure.
0: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
0: 	 *
0: 	 * @return the next row in the result
0: 	 */
0: 	public ExecRow	getNextRowCore() throws StandardException {
0: 	    ExecRow result = null;
0: 		DataValueDescriptor[] columns = null;
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 	    if ( isOpen )
0: 	    {
0: 			/* We use a do/while loop to ensure that we continue down
0: 			 * the duplicate chain, if one exists, until we find a
0: 			 * row that matches on all probe predicates (or the
0: 			 * duplicate chain is exhausted.)
0: 			 */
0: 			do 
0: 			{
0: 				if (firstNext)
0: 				{			  
0: 					firstNext = false;
0: 
0: 					/* Hash key could be either a single column or multiple 
0:                      * columns.  If a single column, then it is the datavalue 
0:                      * wrapper, otherwise it is a KeyHasher.
0: 					 */
0: 					Object hashEntry;
0: 					if (keyColumns.length == 1)
0: 					{
0: 						hashEntry = ht.get(nextQualifiers[0][0].getOrderable());
0: 					}
0: 					else
0: 					{
0: 						KeyHasher mh = 
0:                             new KeyHasher(keyColumns.length);
0: 
0: 						for (int index = 0; index < keyColumns.length; index++)
0: 						{
0:                             // RESOLVE (mikem) - will need to change when we
0:                             // support OR's in qualifiers.
0: 							mh.setObject(
0:                                 index, nextQualifiers[0][index].getOrderable());
0: 						}
0: 						hashEntry = ht.get(mh);
0: 					}
0: 
0: 					if (hashEntry instanceof Vector)
0: 					{
0: 						entryVector = (Vector) hashEntry;
0: 						entryVectorSize = entryVector.size();
0: 						columns = 
0:                             (DataValueDescriptor[]) entryVector.firstElement();
0: 					}
0: 					else
0: 					{
0: 						entryVector = null;
0: 						entryVectorSize = 0;
0: 						columns = (DataValueDescriptor[]) hashEntry;
0: 					}
0: 				}
0: 				else if (numFetchedOnNext < entryVectorSize)
0: 				{
0: 					/* We walking a Vector and there's 
0: 					 * more rows left in the vector.
0: 					 */
0: 					columns = (DataValueDescriptor[]) 
0:                         entryVector.elementAt(numFetchedOnNext);
0: 				}
0: 
0: 				if (columns != null)
0: 				{
0: 					if (SanityManager.DEBUG)
0: 					{
0: 						// Columns is really a Storable[]
0: 						for (int i = 0; i < columns.length; i++)
0: 						{
0: 							if (! (columns[0] instanceof Storable))
0: 							{
0: 								SanityManager.THROWASSERT(
0: 								"columns[" + i + "] expected to be Storable, not " +
0: 								columns[i].getClass().getName());
0: 							}
0: 						}
0: 					}
0: 
0: 					// See if the entry satisfies all of the other qualifiers
0: 					boolean qualifies = true;
0: 
0: 					/* We've already "evaluated" the 1st keyColumns qualifiers 
0:                      * when we probed into the hash table, but we need to 
0:                      * evaluate them again here because of the behavior of 
0:                      * NULLs.  NULLs are treated as equal when building and 
0:                      * probing the hash table so that we only get a single 
0:                      * entry.  However, NULL does not equal NULL, so the 
0:                      * compare() method below will eliminate any row that
0: 					 * has a key column containing a NULL.
0: 					 */
0: 
0:                     // RESOLVE (mikem) will have to change when qualifiers 
0:                     // support OR's.
0: 
0:                     if (SanityManager.DEBUG)
0:                     {
0:                         // we don't support 2 d qualifiers yet.
0:                         SanityManager.ASSERT(nextQualifiers.length == 1);
0:                     }
0: 					for (int index = 0; index < nextQualifiers[0].length; index++)
0: 					{
0:                         Qualifier q = nextQualifiers[0][index];
0: 
0: 						qualifies = 
0:                             columns[q.getColumnId()].compare(
0:                                 q.getOperator(),
0:                                 q.getOrderable(),
0:                                 q.getOrderedNulls(),
0:                                 q.getUnknownRV());
0: 
0: 						if (q.negateCompareResult()) 
0: 						{ 
0: 							qualifies = !(qualifies);
0: 						} 
0: 
0: 						// Stop if any predicate fails
0: 						if (! qualifies)
0: 						{
0: 							break;
0: 						}
0: 					}
0: 
0: 					if (qualifies)
0: 					{
0: 
0: 						for (int index = 0; index < columns.length; index++)
0: 						{
0: 							nextCandidate.setColumn(index + 1, columns[index]);
0: 						}
0: 
0: 						result = doProjection(nextCandidate);
0: 					}
0: 					else
0: 					{
0: 						result = null;
0: 					}
0: 
0: 					numFetchedOnNext++;
0: 				}
0: 				else
0: 				{
0: 					result = null;
0: 				}
0: 			}
0: 			while (result == null && numFetchedOnNext < entryVectorSize);
0: 		}
0: 
0: 		currentRow = result;
0: 		setCurrentRow(result);
0: 
0: 		nextTime += getElapsedMillis(beginTime);
0: 
0: 		if (runTimeStatsOn)
0: 		{
0: 			if (! isTopResultSet)
0: 			{
0: 				/* This is simply for RunTimeStats */
0: 				/* We first need to get the subquery tracking array via the StatementContext */
0: 				StatementContext sc = activation.getLanguageConnectionContext().getStatementContext();
0: 				subqueryTrackingArray = sc.getSubqueryTrackingArray();
0: 			}
0: 			nextTime += getElapsedMillis(beginTime);
0: 		}
0:     	return result;
0: 	}
0: 
0: 	/**
0: 	 * Return the total amount of time spent in this ResultSet
0: 	 *
0: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
0: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
0: 	 *
0: 	 * @return long		The total amount of time spent (in milliseconds).
0: 	 */
0: 	public long getTimeSpent(int type)
0: 	{
0: 		long totTime = constructorTime + openTime + nextTime + closeTime;
0: 
0: 		if (type == CURRENT_RESULTSET_ONLY)
0: 		{
0: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
0: 		}
0: 		else
0: 		{
0: 			return totTime;
0: 		}
0: 	}
0: 
0: 	// ResultSet interface
0: 
0: 	/**
0: 	 * If the result set has been opened,
0: 	 * close the open scan.
0: 	 *
0: 	 * @exception StandardException thrown on error
0: 	 */
0: 	public void	close() throws StandardException
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 	    if ( isOpen ) {
0: 
0: 			// we don't want to keep around a pointer to the
0: 			// row ... so it can be thrown away.
0: 			// REVISIT: does this need to be in a finally
0: 			// block, to ensure that it is executed?
0: 	    	clearCurrentRow();
0: 			if (closeCleanup != null) {
0: 				closeCleanup.invoke(activation); // let activation tidy up
0: 			}
0: 			currentRow = null;
0: 	        source.close();
0: 
0: 			super.close();
0: 
0: 			if (hashTableBuilt)
0: 			{
0: 				// close the hash table, eating any exception
0: 				ht.close();
0: 				ht = null;
0: 				hashTableBuilt = false;
0: 			}
0: 	    }
0: 		else
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.DEBUG("CloseRepeatInfo","Close of ProjectRestrictResultSet repeated");
0: 
0: 		closeTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	//
0: 	// CursorResultSet interface
0: 	//
0: 
0: 	/**
0: 	 * Gets information from its source. We might want
0: 	 * to have this take a CursorResultSet in its constructor some day,
0: 	 * instead of doing a cast here?
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the row location of the current cursor row.
0: 	 * @exception StandardException thrown on failure.
0: 	 */
0: 	public RowLocation getRowLocation() throws StandardException {
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(source instanceof CursorResultSet, "source not instance of CursorResultSet");
0: 		return ( (CursorResultSet)source ).getRowLocation();
0: 	}
0: 
0: 	/**
0: 	 * Gets last row returned.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the last row returned.
0: 	 * @exception StandardException thrown on failure.
0: 	 */
0: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
0: 	 * once there is such a method.  (currentRow is redundant)
0: 	 */
0: 	public ExecRow getCurrentRow() throws StandardException {
0: 	    ExecRow candidateRow = null;
0: 	    ExecRow result = null;
0: 	    boolean restrict = false;
0: 	    DataValueDescriptor restrictBoolean;
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isOpen, "PRRS is expected to be open");
0: 
0: 		/* Nothing to do if we're not currently on a row */
0: 		if (currentRow == null)
0: 		{
0: 			return null;
0: 		}
0: 
0: 		/* Call the child result set to get it's current row.
0: 		 * If no row exists, then return null, else requalify it
0: 		 * before returning.
0: 		 */
0: 		candidateRow = ((CursorResultSet) source).getCurrentRow();
0: 		if (candidateRow != null) {
0: 			setCurrentRow(candidateRow);
0: 				/* If restriction is null, then all rows qualify */
0:             restrictBoolean = (DataValueDescriptor) 
0: 					((singleTableRestriction == null) ? null : singleTableRestriction.invoke(activation));
0: 
0:             // if the result is null, we make it false --
0: 			// so the row won't be returned.
0:             restrict = (restrictBoolean == null) ||
0: 						((! restrictBoolean.isNull()) &&
0: 							restrictBoolean.getBoolean());
0: 		}
0: 
0: 	    if (candidateRow != null && restrict) 
0: 		{
0: 			result = doProjection(candidateRow);
0:         }
0: 
0: 		currentRow = result;
0: 		/* Clear the current row, if null */
0: 		if (result == null) {
0: 			clearCurrentRow();
0: 		}
0: 
0: 		return currentRow;
0: 	}
0: 
0: 	/**
0: 	 * Do the projection against the source row.  Use reflection
0: 	 * where necessary, otherwise get the source column into our
0: 	 * result row.
0: 	 *
0: 	 * @param sourceRow		The source row.
0: 	 *
0: 	 * @return		The result of the projection
0: 	 *
0: 	 * @exception StandardException thrown on failure.
0: 	 */
0: 	private ExecRow doProjection(ExecRow sourceRow)
0: 		throws StandardException
0: 	{
0: 		// No need to use reflection if reusing the result
0: 		if (reuseResult && projRow != null)
0: 		{
0: 			return projRow;
0: 		}
0: 
0: 		ExecRow result;
0: 
0: 		// Use reflection to do as much of projection as required
0: 		if (projection != null)
0: 		{
0: 	        result = (ExecRow) projection.invoke(activation);
0: 		}
0: 		else
0: 		{
0: 			result = mappedResultRow;
0: 		}
0: 
0: 		// Copy any mapped columns from the source
0: 		for (int index = 0; index < projectMapping.length; index++)
0: 		{
0: 			if (projectMapping[index] != -1)
0: 			{
0: 				result.setColumn(index + 1, sourceRow.getColumn(projectMapping[index]));
0: 			}
0: 		}
0: 
0: 		/* We need to reSet the current row after doing the projection */
0: 		setCurrentRow(result);
0: 
0: 		/* Remember the result if reusing it */
0: 		if (reuseResult)
0: 		{
0: 			projRow = result;
0: 		}
0: 		return result;
0: 	}
0: 
0: 	// RowSource interface
0: 		
0: 	/** 
0: 	 * @see RowSource#getNextRowFromRowSource
0: 	 * @exception StandardException on error
0: 	 */
0: 	public DataValueDescriptor[] getNextRowFromRowSource()
0: 		throws StandardException
0: 	{
0: 		ExecRow execRow = source.getNextRowCore();
0: 
0: 		/* Use the single table predicates, if any,
0: 		 * to filter out rows while populating the
0: 		 * hash table.
0: 		 */
0:  		while (execRow != null)
0: 		{
0: 		    boolean restrict = false;
0: 		    DataValueDescriptor restrictBoolean;
0: 
0: 			rowsSeen++;
0: 
0: 			/* If restriction is null, then all rows qualify */
0:             restrictBoolean = (DataValueDescriptor) 
0: 					((singleTableRestriction == null) ? null : singleTableRestriction.invoke(activation));
0: 
0:             // if the result is null, we make it false --
0: 			// so the row won't be returned.
0:             restrict = (restrictBoolean == null) ||
0: 						((! restrictBoolean.isNull()) &&
0: 							restrictBoolean.getBoolean());
0: 			if (!restrict)
0: 			{
0: 				execRow = source.getNextRowCore();
0: 				continue;
0: 			}
0: 
0: 			if (targetResultSet != null)
0: 			{
0: 				/* Let the target preprocess the row.  For now, this
0: 				 * means doing an in place clone on any indexed columns
0: 				 * to optimize cloning and so that we don't try to drain
0: 				 * a stream multiple times.  This is where we also
0: 				 * enforce any check constraints.
0: 				 */
0: 				clonedExecRow = targetResultSet.preprocessSourceRow(execRow);
0: 			}
0: 
0: 
0: 			/* Get a single ExecRow of the same size
0: 			 * on the way in so that we have a row
0: 			 * to use on the way out.
0: 			 */
0: 			if (firstIntoHashtable)
0: 			{
0: 				nextCandidate = activation.getExecutionFactory().getValueRow(execRow.nColumns());
0: 				firstIntoHashtable = false;
0: 			}
0: 
0: 			return execRow.getRowArray();
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Is this ResultSet or it's source result set for update
0: 	 * 
0: 	 * @return Whether or not the result set is for update.
0: 	 */
0: 	public boolean isForUpdate()
0: 	{
0: 		if (source == null) 
0: 		{
0: 			return false;
0: 		}
0: 		return source.isForUpdate();
0: 	}
0: 
0: }
============================================================================