1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.JavaValueNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
20:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:3bb140c: import java.lang.reflect.Modifier;
1:3bb140c: import java.util.List;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.services.compiler.LocalField;
1:eac0369: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:eac0369: import org.apache.derby.iapi.services.loader.ClassInspector;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.JSQLType;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
3:eac0369: /**
1:eac0369:  * This abstract node class represents a data value in the Java domain.
1:eac0369:  */
1:eac0369: 
1:894b205: abstract class JavaValueNode extends QueryTreeNode
2:eac0369: {
1:eac0369: 	private boolean	mustCastToPrimitive;
1:eac0369: 
1:eac0369: 	protected boolean forCallStatement;
1:eac0369: 	private boolean valueReturnedToSQLDomain;
1:eac0369: 	private boolean returnValueDiscarded;
1:eac0369: 
1:eac0369: 	protected	JSQLType	jsqlType;
1:eac0369: 
1:eac0369: 	/* Name of field holding receiver value, if any */
1:eac0369: 	private LocalField receiverField;
1:eac0369: 
1:72abc72:         // * Collation type of schema where method is defined. 
1:72abc72: 	private int collationType;
1:72abc72: 
1:3bb140c:     JavaValueNode(ContextManager cm) {
1:3bb140c:         super(cm);
1:3bb140c:     }
1:3bb140c: 
1:30fa79b:     /**
1:30fa79b:      * Get the resolved data type of this node. May be overridden by descendants.
1:30fa79b:      */
1:9f2ed7d:     DataTypeDescriptor getDataType() throws StandardException
1:30fa79b:     {
1:30fa79b:         return DataTypeDescriptor.getSQLDataTypeDescriptor( getJavaTypeName()) ;
1:30fa79b:     }
1:30fa79b: 
1:9f2ed7d:     final boolean isPrimitiveType() throws StandardException
1:eac0369: 	{
1:eac0369: 		JSQLType	myType = getJSQLType();
1:eac0369: 		
1:eac0369: 		if ( myType == null ) { return false; }
1:eac0369: 		else { return ( myType.getCategory() == JSQLType.JAVA_PRIMITIVE ); }
2:eac0369: 	}
1:eac0369: 
1:9f2ed7d:     String getJavaTypeName() throws StandardException
1:eac0369: 	{
1:eac0369: 		JSQLType	myType = getJSQLType();
1:eac0369: 
1:eac0369: 		if ( myType == null ) { return ""; }
1:eac0369: 
1:eac0369: 		switch( myType.getCategory() )
1:eac0369: 		{
1:eac0369: 		    case JSQLType.JAVA_CLASS: return myType.getJavaClassName();
1:eac0369: 
1:23ecfcf: 		    case JSQLType.JAVA_PRIMITIVE: return JSQLType.getPrimitiveName( myType.getPrimitiveKind() );
1:eac0369: 
1:eac0369: 		    default:
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{ SanityManager.THROWASSERT( "Inappropriate JSQLType: " + myType ); }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return "";
1:eac0369: 	}
1:eac0369: 
1:9f2ed7d:     final void setJavaTypeName(String javaTypeName)
1:eac0369: 	{
1:eac0369: 		jsqlType = new JSQLType( javaTypeName );
1:eac0369: 	}
1:eac0369: 
1:9f2ed7d:     String getPrimitiveTypeName()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		JSQLType	myType = getJSQLType();
1:eac0369: 
1:eac0369: 		if ( myType == null ) { return ""; }
1:eac0369: 
1:eac0369: 		switch( myType.getCategory() )
1:eac0369: 		{
1:23ecfcf: 		    case JSQLType.JAVA_PRIMITIVE: return JSQLType.getPrimitiveName( myType.getPrimitiveKind() );
1:eac0369: 
1:eac0369: 		    default:
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{ SanityManager.THROWASSERT( "Inappropriate JSQLType: " + myType ); }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return "";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Toggles whether the code generator should add a cast to extract a primitive
1:eac0369: 	  *	value from an object.
5:eac0369: 	  *
1:eac0369: 	  *	@param	booleanValue	true if we want the code generator to add a cast
1:eac0369: 	  *							false otherwise
1:eac0369: 	  */
1:9f2ed7d:     final void castToPrimitive(boolean booleanValue)
1:eac0369: 	{
1:eac0369: 		mustCastToPrimitive = booleanValue;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Reports whether the code generator should add a cast to extract a primitive
1:eac0369: 	  *	value from an object.
1:eac0369: 	  *
1:eac0369: 	  *	@return	true if we want the code generator to add a cast
1:eac0369: 	  *				false otherwise
1:eac0369: 	  */
1:9f2ed7d:     final boolean mustCastToPrimitive() { return mustCastToPrimitive; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Get the JSQLType that corresponds to this node. Could be a SQLTYPE,
1:eac0369: 	  *	a Java primitive, or a Java class.
1:eac0369: 	  *
1:eac0369: 	  *	@return	the corresponding JSQLType
1:eac0369: 	  *
1:eac0369: 	  */
1:9f2ed7d:     JSQLType getJSQLType() throws StandardException {
1:9f2ed7d:         return jsqlType;
1:9f2ed7d:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Map a JSQLType to a compilation type id.
1:eac0369: 	  *
1:eac0369: 	  *	@param	jsqlType	the universal type to map
1:eac0369: 	  *
1:eac0369: 	  *	@return	the corresponding compilation type id
1:eac0369: 	  *
1:eac0369: 	  */
1:9f2ed7d:     static TypeId mapToTypeID(JSQLType jsqlType)
1:2a5922a:         throws StandardException
1:eac0369: 	{
1:eac0369: 		DataTypeDescriptor	dts = jsqlType.getSQLType();
1:eac0369: 
1:eac0369: 		if ( dts == null ) { return null; }
1:eac0369: 
1:eac0369: 		return dts.getTypeId();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark this node as being for a CALL Statement.
1:eac0369: 	 * (void methods are only okay for CALL Statements)
1:eac0369: 	 */
1:9f2ed7d:     final void markForCallStatement()
1:eac0369: 	{
1:eac0369: 		forCallStatement = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ValueNode#remapColumnReferencesToExpressions
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:9f2ed7d:     abstract JavaValueNode remapColumnReferencesToExpressions()
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ValueNode#categorize
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:9f2ed7d:     abstract boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ValueNode#bindExpression
1:eac0369: 	 *
1:eac0369: 	 * @return the new node, usually this
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:71c8e86:     abstract JavaValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
1:eac0369: 							throws StandardException;
1:eac0369: 	/**
1:eac0369: 	 * @see ValueNode#preprocess
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:9f2ed7d:     abstract void preprocess(int numTables,
1:eac0369: 									FromList outerFromList,
1:eac0369: 									SubqueryList outerSubqueryList,
1:eac0369: 									PredicateList outerPredicateList)
1:eac0369: 							throws StandardException;
1:eac0369: 
1:eac0369: 	/** @see ValueNode#getConstantValueAsObject 
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	Object getConstantValueAsObject()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do the code generation for this node.  Call the more general
1:eac0369: 	 * routine that generates expressions.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ActivationClassBuilder for the class being built
1:eac0369: 	 * @param mb the method  the expression will go into
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     @Override
1:8fe3166:     final   void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:eac0369: 		generateExpression( acb, mb );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the expression that evaluates to the receiver. This is
1:eac0369: 	 * for the case where a java expression is being returned to the SQL
1:eac0369: 	 * domain, and we need to check whether the receiver is null (if so,
1:eac0369: 	 * the SQL value should be set to null, and this Java expression
1:eac0369: 	 * not evaluated). Instance method calls and field references have
1:eac0369: 	 * receivers, while class method calls and calls to constructors do
1:eac0369: 	 * not. If this Java expression does not have a receiver, this method
1:eac0369: 	 * returns null.
1:eac0369: 	 *
1:eac0369: 	 * The implementation of this method should only generate the receiver
1:eac0369: 	 * once and cache it in a field. This is because there will be two
1:eac0369: 	 * references to the receiver, and we want to evaluate it only once.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class being built
1:eac0369: 	 * @param mb the method  the expression will go into
1:eac0369: 	 *
1:eac0369: 	 * @return		True if has compiled receiver.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:9f2ed7d:     boolean generateReceiver(ExpressionClassBuilder acb,
2:eac0369: 													MethodBuilder mb)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the variant type for the underlying expression.
1:eac0369: 	 * The variant type can be:
1:eac0369: 	 *		VARIANT				- variant within a scan
1:eac0369: 	 *							  (method calls and non-static field access)
1:eac0369: 	 *		SCAN_INVARIANT		- invariant within a scan
1:eac0369: 	 *							  (column references from outer tables)
1:eac0369: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1:eac0369: 	 *							  (constant expressions)
1:eac0369: 	 *
1:eac0369: 	 * @return	The variant type for the underlying expression.
1:eac0369: 	 */
1:9f2ed7d:     int getOrderableVariantType() throws StandardException
1:eac0369: 	{
1:eac0369: 		// The default is VARIANT
1:eac0369: 		return Qualifier.VARIANT;
1:eac0369: 		//return Qualifier.SCAN_INVARIANT;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * General logic shared by Core compilation and by the Replication Filter
1:eac0369: 	 * compiler. Every child of ValueNode must implement one of these methods.
1:eac0369: 	 *
1:6b50965: 	 * @param acb	The ExpressionClassBuilder for the class being built
1:eac0369: 	 * @param mb the method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:9f2ed7d:     abstract void generateExpression(
1:eac0369: 											ExpressionClassBuilder acb,
1:eac0369: 											MethodBuilder mb)
1:eac0369: 									throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the expression that evaluates to the receiver. This is
1:eac0369: 	 * for the case where a java expression is being returned to the SQL
1:eac0369: 	 * domain, and we need to check whether the receiver is null (if so,
1:eac0369: 	 * the SQL value should be set to null, and this Java expression
1:eac0369: 	 * not evaluated). Instance method calls and field references have
1:eac0369: 	 * receivers, while class method calls and calls to constructors do
1:eac0369: 	 * not. If this Java expression does not have a receiver, this method
1:eac0369: 	 * returns null.
1:eac0369: 	 *
1:eac0369: 	 * This also covers the case where a java expression is being returned
1:eac0369: 	 * to the Java domain. In this case, we need to check whether the
1:eac0369: 	 * receiver is null only if the value returned by the Java expression
1:eac0369: 	 * is an object (not a primitive type). We don't want to generate the
1:eac0369: 	 * expression here if we are returning a primitive type to the Java
1:eac0369: 	 * domain, because there's no point in checking whether the receiver
1:eac0369: 	 * is null in this case (we can't make the expression return a null
1:eac0369: 	 * value).
1:eac0369: 	 *
1:eac0369: 	 * Only generate the receiver once and cache it in a field. This is
1:eac0369: 	 * because there will be two references to the receiver, and we want
1:eac0369: 	 * to evaluate it only once.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ActivationClassBuilder for the class being built
1:eac0369: 	 * @param mb the method the expression will go into
1:eac0369: 	 * @param receiver	The query tree form of the receiver expression
1:eac0369: 	 *
1:eac0369: 	 * @return		The compiled receiver, if any.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:9f2ed7d:     final boolean generateReceiver(ExpressionClassBuilder acb,
1:eac0369: 											MethodBuilder mb,
1:eac0369: 											JavaValueNode receiver)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Don't generate the expression now if it returns a primitive
1:eac0369: 		** type to the Java domain.
1:eac0369: 		*/
1:eac0369: 		if ( (! valueReturnedToSQLDomain()) &&
1:56a7b39: 				ClassInspector.primitiveType(getJavaTypeName()))
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Generate the following:
1:eac0369: 		**
1:eac0369: 		** <receiver class> <field name>;
1:eac0369: 		** <field name> = <receiver>;
1:eac0369: 		**
1:eac0369: 		** for non-static calls.
1:eac0369: 		*/
1:eac0369: 
1:eac0369: 		String receiverClassName = receiver.getJavaTypeName();
1:eac0369: 		receiverField =
1:eac0369: 				acb.newFieldDeclaration(Modifier.PRIVATE, receiverClassName);
1:eac0369: 
1:eac0369: 		receiver.generateExpression(acb, mb);
1:eac0369: 		mb.putField(receiverField);
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get an expression that has the value of the receiver. If a field
1:eac0369: 	 * holding the receiver value was already generated, use that.  If not,
1:eac0369: 	 * generate the receiver value.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1:eac0369: 	 * @param mb the method  the expression will go into
1:eac0369: 	 * @param receiver	The query tree form of the receiver expression
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:9f2ed7d:     final void getReceiverExpression(ExpressionClassBuilder acb,
1:eac0369: 									MethodBuilder mb,
1:eac0369: 									JavaValueNode receiver)
1:eac0369: 										throws StandardException
1:eac0369: 	{
1:eac0369: 		if (receiverField != null)
1:eac0369: 		{
1:eac0369: 			mb.getField(receiverField);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			receiver.generateExpression(acb, mb);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** Inform this node that it returns its value to the SQL domain */
1:9f2ed7d:     void returnValueToSQLDomain()
1:eac0369: 	{
1:eac0369: 		valueReturnedToSQLDomain = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** Tell whether this node returns its value to the SQL domain */
1:9f2ed7d:     boolean valueReturnedToSQLDomain()
1:eac0369: 	{
1:eac0369: 		return valueReturnedToSQLDomain;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** Tell this node that nothing is done with the returned value */
1:9f2ed7d:     void markReturnValueDiscarded()
1:eac0369: 	{
1:eac0369: 		returnValueDiscarded = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** Tell whether the return value from this node is discarded */
1:9f2ed7d:     boolean returnValueDiscarded()
1:eac0369: 	{
1:eac0369: 		return returnValueDiscarded;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Check the reliability type of this java value.
1:eac0369: 
1:eac0369: 	    @exception StandardException		Thrown on error
1:eac0369: 
1:eac0369: 		@see org.apache.derby.iapi.sql.compile.CompilerContext
1:eac0369: 	*/
1:9f2ed7d:     void checkReliability(ValueNode sqlNode) throws StandardException {
1:eac0369:         sqlNode.checkReliability( 
1:eac0369:                 CompilerContext.FUNCTION_CALL_ILLEGAL,
1:eac0369:                 SQLState.LANG_JAVA_METHOD_CALL_OR_FIELD_REF
1:eac0369:                 );
1:eac0369: 	}
1:72abc72: 
1:72abc72:     /**
1:72abc72:      * @return collationType as set by setCollationType
1:72abc72:      */
1:9f2ed7d:     int getCollationType() {
1:72abc72:         return collationType;
1:72abc72:     }
1:72abc72:     
1:72abc72:     /**
1:72abc72:      * Set the collation type.
1:72abc72:      * This will be used to determine the collation type for 
1:72abc72:      * the SQLToJavaValueNode.
1:72abc72:      * 
1:72abc72:      * @param type one of <code>StringDataValue.COLLATION_TYPE_UCS_BASIC </code> or
1:72abc72:      *                    <code>StringDataValue.COLLATION_TYPE_TERRITORY_BASED </code>  
1:72abc72:      */
1:9f2ed7d:     void setCollationType(int type) {
1:72abc72:         collationType = type;
1:72abc72:     }
1:72abc72:     
1:72abc72:     
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Modifier;
1: import java.util.List;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.JSQLType;
1: import org.apache.derby.iapi.types.TypeId;
/////////////////////////////////////////////////////////////////////////
1:     JavaValueNode(ContextManager cm) {
1:         super(cm);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:     abstract JavaValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
commit:c8603c4
/////////////////////////////////////////////////////////////////////////
0: 	public	static  TypeId	mapToTypeID( JSQLType jsqlType )
commit:30fa79b
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the resolved data type of this node. May be overridden by descendants.
1:      */
0:     public DataTypeDescriptor getDataType() throws StandardException
1:     {
1:         return DataTypeDescriptor.getSQLDataTypeDescriptor( getJavaTypeName()) ;
1:     }
1: 
commit:2a5922a
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
1:     DataTypeDescriptor getDataType() throws StandardException
1:     final boolean isPrimitiveType() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     String getJavaTypeName() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     final void setJavaTypeName(String javaTypeName)
1:     String getPrimitiveTypeName()
/////////////////////////////////////////////////////////////////////////
1:     final void castToPrimitive(boolean booleanValue)
/////////////////////////////////////////////////////////////////////////
1:     final boolean mustCastToPrimitive() { return mustCastToPrimitive; }
/////////////////////////////////////////////////////////////////////////
1:     JSQLType getJSQLType() throws StandardException {
1:         return jsqlType;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     static TypeId mapToTypeID(JSQLType jsqlType)
/////////////////////////////////////////////////////////////////////////
1:     final void markForCallStatement()
/////////////////////////////////////////////////////////////////////////
1:     abstract JavaValueNode remapColumnReferencesToExpressions()
/////////////////////////////////////////////////////////////////////////
1:     abstract boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
/////////////////////////////////////////////////////////////////////////
1:     abstract void preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     boolean generateReceiver(ExpressionClassBuilder acb,
/////////////////////////////////////////////////////////////////////////
1:     int getOrderableVariantType() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     abstract void generateExpression(
/////////////////////////////////////////////////////////////////////////
1:     final boolean generateReceiver(ExpressionClassBuilder acb,
/////////////////////////////////////////////////////////////////////////
1:     final void getReceiverExpression(ExpressionClassBuilder acb,
/////////////////////////////////////////////////////////////////////////
1:     void returnValueToSQLDomain()
1:     boolean valueReturnedToSQLDomain()
1:     void markReturnValueDiscarded()
1:     boolean returnValueDiscarded()
/////////////////////////////////////////////////////////////////////////
1:     void checkReliability(ValueNode sqlNode) throws StandardException {
/////////////////////////////////////////////////////////////////////////
1:     int getCollationType() {
/////////////////////////////////////////////////////////////////////////
1:     void setCollationType(int type) {
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     final   void generate(ActivationClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
0:     abstract JavaValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List aggregates)
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 							List aggregateVector)
commit:23ecfcf
/////////////////////////////////////////////////////////////////////////
1: 		    case JSQLType.JAVA_PRIMITIVE: return JSQLType.getPrimitiveName( myType.getPrimitiveKind() );
/////////////////////////////////////////////////////////////////////////
1: 		    case JSQLType.JAVA_PRIMITIVE: return JSQLType.getPrimitiveName( myType.getPrimitiveKind() );
author:Lily Wei
-------------------------------------------------------------------------------
commit:56a7b39
/////////////////////////////////////////////////////////////////////////
1: 				ClassInspector.primitiveType(getJavaTypeName()))
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:72abc72
/////////////////////////////////////////////////////////////////////////
1:         // * Collation type of schema where method is defined. 
1: 	private int collationType;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @return collationType as set by setCollationType
1:      */
0:     public int getCollationType() {
1:         return collationType;
1:     }
1:     
1:     /**
1:      * Set the collation type.
1:      * This will be used to determine the collation type for 
1:      * the SQLToJavaValueNode.
1:      * 
1:      * @param type one of <code>StringDataValue.COLLATION_TYPE_UCS_BASIC </code> or
1:      *                    <code>StringDataValue.COLLATION_TYPE_TERRITORY_BASED </code>  
1:      */
0:     public void setCollationType(int type) {
1:         collationType = type;
1:     }
1:     
1:     
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4493d69
/////////////////////////////////////////////////////////////////////////
commit:894b205
/////////////////////////////////////////////////////////////////////////
1: abstract class JavaValueNode extends QueryTreeNode
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.JavaValueNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
0: import org.apache.derby.iapi.types.JSQLType;
1: 
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
1: 
1: import org.apache.derby.iapi.services.loader.ClassInspector;
1: 
1: import org.apache.derby.iapi.store.access.Qualifier;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import java.lang.reflect.Modifier;
1: 
0: import java.util.Vector;
1: 
1: /**
1:  * This abstract node class represents a data value in the Java domain.
1:  */
1: 
0: public abstract class JavaValueNode extends QueryTreeNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	private boolean	mustCastToPrimitive;
1: 
1: 	protected boolean forCallStatement;
0: 	private int clause = ValueNode.IN_UNKNOWN_CLAUSE;
1: 	private boolean valueReturnedToSQLDomain;
1: 	private boolean returnValueDiscarded;
1: 
1: 	protected	JSQLType	jsqlType;
1: 
1: 	/* Name of field holding receiver value, if any */
1: 	private LocalField receiverField;
1: 
0: 	public boolean isPrimitiveType()
1: 	{
1: 		JSQLType	myType = getJSQLType();
1: 		
1: 		if ( myType == null ) { return false; }
1: 		else { return ( myType.getCategory() == JSQLType.JAVA_PRIMITIVE ); }
1: 	}
1: 
0: 	public String getJavaTypeName()
1: 	{
1: 		JSQLType	myType = getJSQLType();
1: 
1: 		if ( myType == null ) { return ""; }
1: 
1: 		switch( myType.getCategory() )
1: 		{
1: 		    case JSQLType.JAVA_CLASS: return myType.getJavaClassName();
1: 
0: 		    case JSQLType.JAVA_PRIMITIVE: return JSQLType.primitiveNames[ myType.getPrimitiveKind() ];
1: 
1: 		    default:
1: 
1: 				if (SanityManager.DEBUG)
1: 				{ SanityManager.THROWASSERT( "Inappropriate JSQLType: " + myType ); }
1: 		}
1: 
1: 		return "";
1: 	}
1: 
0: 	public void setJavaTypeName(String javaTypeName)
1: 	{
1: 		jsqlType = new JSQLType( javaTypeName );
1: 	}
1: 
0: 	public String getPrimitiveTypeName()
1: 		throws StandardException
1: 	{
1: 		JSQLType	myType = getJSQLType();
1: 
1: 		if ( myType == null ) { return ""; }
1: 
1: 		switch( myType.getCategory() )
1: 		{
0: 		    case JSQLType.JAVA_PRIMITIVE: return JSQLType.primitiveNames[ myType.getPrimitiveKind() ];
1: 
1: 		    default:
1: 
1: 				if (SanityManager.DEBUG)
1: 				{ SanityManager.THROWASSERT( "Inappropriate JSQLType: " + myType ); }
1: 		}
1: 
1: 		return "";
1: 	}
1: 
1: 	/**
1: 	  *	Toggles whether the code generator should add a cast to extract a primitive
1: 	  *	value from an object.
1: 	  *
1: 	  *	@param	booleanValue	true if we want the code generator to add a cast
1: 	  *							false otherwise
1: 	  */
0: 	public void castToPrimitive(boolean booleanValue)
1: 	{
1: 		mustCastToPrimitive = booleanValue;
1: 	}
1: 
1: 	/**
1: 	  *	Reports whether the code generator should add a cast to extract a primitive
1: 	  *	value from an object.
1: 	  *
1: 	  *	@return	true if we want the code generator to add a cast
1: 	  *				false otherwise
1: 	  */
0: 	public	boolean	mustCastToPrimitive() { return mustCastToPrimitive; }
1: 
1: 	/**
1: 	  *	Get the JSQLType that corresponds to this node. Could be a SQLTYPE,
1: 	  *	a Java primitive, or a Java class.
1: 	  *
1: 	  *	@return	the corresponding JSQLType
1: 	  *
1: 	  */
0: 	public	JSQLType	getJSQLType
0: 	(
0:     )
0: 	{ return jsqlType; }
1: 
1: 
1: 	/**
1: 	  *	Map a JSQLType to a compilation type id.
1: 	  *
1: 	  *	@param	jsqlType	the universal type to map
1: 	  *
1: 	  *	@return	the corresponding compilation type id
1: 	  *
1: 	  */
0: 	public	TypeId	mapToTypeID( JSQLType jsqlType )
1: 	{
1: 		DataTypeDescriptor	dts = jsqlType.getSQLType();
1: 
1: 		if ( dts == null ) { return null; }
1: 
1: 		return dts.getTypeId();
1: 	}
1: 
1: 	/**
0: 	 * Set the clause that this node appears in.
1: 	 *
0: 	 * @param clause	The clause that this node appears in.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setClause(int clause)
1: 	{
0: 		clause = clause;
1: 	}
1: 
1: 	/**
1: 	 * Mark this node as being for a CALL Statement.
1: 	 * (void methods are only okay for CALL Statements)
1: 	 */
0: 	public void markForCallStatement()
1: 	{
1: 		forCallStatement = true;
1: 	}
1: 
1: 	/**
1: 	 * @see ValueNode#remapColumnReferencesToExpressions
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	abstract public JavaValueNode remapColumnReferencesToExpressions()
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * @see ValueNode#categorize
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	abstract public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * @see ValueNode#bindExpression
1: 	 *
1: 	 * @return the new node, usually this
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	abstract JavaValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 							Vector aggregateVector) 
1: 							throws StandardException;
1: 	/**
1: 	 * @see ValueNode#preprocess
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	abstract public void preprocess(int numTables,
1: 									FromList outerFromList,
1: 									SubqueryList outerSubqueryList,
1: 									PredicateList outerPredicateList)
1: 							throws StandardException;
1: 
1: 	/** @see ValueNode#getConstantValueAsObject 
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	Object getConstantValueAsObject()
1: 		throws StandardException
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Do the code generation for this node.  Call the more general
1: 	 * routine that generates expressions.
1: 	 *
1: 	 * @param acb	The ActivationClassBuilder for the class being built
1: 	 * @param mb the method  the expression will go into
1: 	 *
0: 	 * @return		The compiled Expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	protected final	void generate(ActivationClassBuilder acb,
1: 										MethodBuilder mb)
1: 									throws StandardException
1: 	{
1: 		generateExpression( acb, mb );
1: 	}
1: 
1: 	/**
1: 	 * Generate the expression that evaluates to the receiver. This is
1: 	 * for the case where a java expression is being returned to the SQL
1: 	 * domain, and we need to check whether the receiver is null (if so,
1: 	 * the SQL value should be set to null, and this Java expression
1: 	 * not evaluated). Instance method calls and field references have
1: 	 * receivers, while class method calls and calls to constructors do
1: 	 * not. If this Java expression does not have a receiver, this method
1: 	 * returns null.
1: 	 *
1: 	 * The implementation of this method should only generate the receiver
1: 	 * once and cache it in a field. This is because there will be two
1: 	 * references to the receiver, and we want to evaluate it only once.
1: 	 *
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb the method  the expression will go into
1: 	 *
1: 	 * @return		True if has compiled receiver.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	protected boolean generateReceiver(ExpressionClassBuilder acb,
1: 													MethodBuilder mb)
1: 									throws StandardException
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Return the variant type for the underlying expression.
1: 	 * The variant type can be:
1: 	 *		VARIANT				- variant within a scan
1: 	 *							  (method calls and non-static field access)
1: 	 *		SCAN_INVARIANT		- invariant within a scan
1: 	 *							  (column references from outer tables)
1: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1: 	 *							  (constant expressions)
1: 	 *
1: 	 * @return	The variant type for the underlying expression.
1: 	 */
0: 	protected int getOrderableVariantType() throws StandardException
1: 	{
1: 		// The default is VARIANT
1: 		return Qualifier.VARIANT;
1: 		//return Qualifier.SCAN_INVARIANT;
1: 	}
1: 
1: 	/**
1: 	 * General logic shared by Core compilation and by the Replication Filter
1: 	 * compiler. Every child of ValueNode must implement one of these methods.
1: 	 *
0: 	 * @param ecb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb the method the expression will go into
1: 	 *
0: 	 * @return		The compiled Expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	protected abstract  void generateExpression(
1: 											ExpressionClassBuilder acb,
1: 											MethodBuilder mb)
1: 									throws StandardException;
1: 
1: 	/**
1: 	 * Generate the expression that evaluates to the receiver. This is
1: 	 * for the case where a java expression is being returned to the SQL
1: 	 * domain, and we need to check whether the receiver is null (if so,
1: 	 * the SQL value should be set to null, and this Java expression
1: 	 * not evaluated). Instance method calls and field references have
1: 	 * receivers, while class method calls and calls to constructors do
1: 	 * not. If this Java expression does not have a receiver, this method
1: 	 * returns null.
1: 	 *
1: 	 * This also covers the case where a java expression is being returned
1: 	 * to the Java domain. In this case, we need to check whether the
1: 	 * receiver is null only if the value returned by the Java expression
1: 	 * is an object (not a primitive type). We don't want to generate the
1: 	 * expression here if we are returning a primitive type to the Java
1: 	 * domain, because there's no point in checking whether the receiver
1: 	 * is null in this case (we can't make the expression return a null
1: 	 * value).
1: 	 *
1: 	 * Only generate the receiver once and cache it in a field. This is
1: 	 * because there will be two references to the receiver, and we want
1: 	 * to evaluate it only once.
1: 	 *
1: 	 *
1: 	 * @param acb	The ActivationClassBuilder for the class being built
1: 	 * @param mb the method the expression will go into
1: 	 * @param receiver	The query tree form of the receiver expression
1: 	 *
1: 	 * @return		The compiled receiver, if any.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	protected final boolean generateReceiver(ExpressionClassBuilder acb,
1: 											MethodBuilder mb,
1: 											JavaValueNode receiver)
1: 									throws StandardException
1: 	{
0: 		ClassInspector classInspector = getClassFactory().getClassInspector();
1: 
1: 		/*
1: 		** Don't generate the expression now if it returns a primitive
1: 		** type to the Java domain.
1: 		*/
1: 		if ( (! valueReturnedToSQLDomain()) &&
0: 				classInspector.primitiveType(getJavaTypeName()))
1: 		{
1: 			return false;
1: 		}
1: 
1: 		/*
1: 		** Generate the following:
1: 		**
1: 		** <receiver class> <field name>;
1: 		** <field name> = <receiver>;
1: 		**
1: 		** for non-static calls.
1: 		*/
1: 
1: 		String receiverClassName = receiver.getJavaTypeName();
1: 		receiverField =
1: 				acb.newFieldDeclaration(Modifier.PRIVATE, receiverClassName);
1: 
1: 		receiver.generateExpression(acb, mb);
1: 		mb.putField(receiverField);
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Get an expression that has the value of the receiver. If a field
1: 	 * holding the receiver value was already generated, use that.  If not,
1: 	 * generate the receiver value.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb the method  the expression will go into
1: 	 * @param receiver	The query tree form of the receiver expression
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	protected final void getReceiverExpression(ExpressionClassBuilder acb,
1: 									MethodBuilder mb,
1: 									JavaValueNode receiver)
1: 										throws StandardException
1: 	{
1: 		if (receiverField != null)
1: 		{
1: 			mb.getField(receiverField);
1: 		}
1: 		else
1: 		{
1: 			receiver.generateExpression(acb, mb);
1: 		}
1: 	}
1: 
1: 	/** Inform this node that it returns its value to the SQL domain */
0: 	protected void returnValueToSQLDomain()
1: 	{
1: 		valueReturnedToSQLDomain = true;
1: 	}
1: 
1: 	/** Tell whether this node returns its value to the SQL domain */
0: 	protected boolean valueReturnedToSQLDomain()
1: 	{
1: 		return valueReturnedToSQLDomain;
1: 	}
1: 
1: 	/** Tell this node that nothing is done with the returned value */
0: 	protected void markReturnValueDiscarded()
1: 	{
1: 		returnValueDiscarded = true;
1: 	}
1: 
1: 	/** Tell whether the return value from this node is discarded */
0: 	protected boolean returnValueDiscarded()
1: 	{
1: 		return returnValueDiscarded;
1: 	}
1: 
1: 	/**
1: 		Check the reliability type of this java value.
1: 
1: 	    @exception StandardException		Thrown on error
1: 
1: 		@see org.apache.derby.iapi.sql.compile.CompilerContext
1: 	*/
0: 	public void checkReliability(ValueNode sqlNode) throws StandardException {
1:         sqlNode.checkReliability( 
1:                 CompilerContext.FUNCTION_CALL_ILLEGAL,
1:                 SQLState.LANG_JAVA_METHOD_CALL_OR_FIELD_REF
1:                 );
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param acb	The ExpressionClassBuilder for the class being built
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
0: 	public boolean isPrimitiveType() throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 	public String getJavaTypeName() throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 	public	JSQLType	getJSQLType() throws StandardException
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import org.apache.derby.iapi.types.JSQLType;
0: 
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: 
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import java.lang.reflect.Modifier;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * This abstract node class represents a data value in the Java domain.
0:  */
0: 
0: public abstract class JavaValueNode extends QueryTreeNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private boolean	mustCastToPrimitive;
0: 
0: 	protected boolean forCallStatement;
0: 	private int clause = ValueNode.IN_UNKNOWN_CLAUSE;
0: 	private boolean valueReturnedToSQLDomain;
0: 	private boolean returnValueDiscarded;
0: 
0: 	protected	JSQLType	jsqlType;
0: 
0: 	/* Name of field holding receiver value, if any */
0: 	private LocalField receiverField;
0: 
0: 	public boolean isPrimitiveType()
0: 	{
0: 		JSQLType	myType = getJSQLType();
0: 		
0: 		if ( myType == null ) { return false; }
0: 		else { return ( myType.getCategory() == JSQLType.JAVA_PRIMITIVE ); }
0: 	}
0: 
0: 	public String getJavaTypeName()
0: 	{
0: 		JSQLType	myType = getJSQLType();
0: 
0: 		if ( myType == null ) { return ""; }
0: 
0: 		switch( myType.getCategory() )
0: 		{
0: 		    case JSQLType.JAVA_CLASS: return myType.getJavaClassName();
0: 
0: 		    case JSQLType.JAVA_PRIMITIVE: return JSQLType.primitiveNames[ myType.getPrimitiveKind() ];
0: 
0: 		    default:
0: 
0: 				if (SanityManager.DEBUG)
0: 				{ SanityManager.THROWASSERT( "Inappropriate JSQLType: " + myType ); }
0: 		}
0: 
0: 		return "";
0: 	}
0: 
0: 	public void setJavaTypeName(String javaTypeName)
0: 	{
0: 		jsqlType = new JSQLType( javaTypeName );
0: 	}
0: 
0: 	public String getPrimitiveTypeName()
0: 		throws StandardException
0: 	{
0: 		JSQLType	myType = getJSQLType();
0: 
0: 		if ( myType == null ) { return ""; }
0: 
0: 		switch( myType.getCategory() )
0: 		{
0: 		    case JSQLType.JAVA_PRIMITIVE: return JSQLType.primitiveNames[ myType.getPrimitiveKind() ];
0: 
0: 		    default:
0: 
0: 				if (SanityManager.DEBUG)
0: 				{ SanityManager.THROWASSERT( "Inappropriate JSQLType: " + myType ); }
0: 		}
0: 
0: 		return "";
0: 	}
0: 
0: 	/**
0: 	  *	Toggles whether the code generator should add a cast to extract a primitive
0: 	  *	value from an object.
0: 	  *
0: 	  *	@param	booleanValue	true if we want the code generator to add a cast
0: 	  *							false otherwise
0: 	  */
0: 	public void castToPrimitive(boolean booleanValue)
0: 	{
0: 		mustCastToPrimitive = booleanValue;
0: 	}
0: 
0: 	/**
0: 	  *	Reports whether the code generator should add a cast to extract a primitive
0: 	  *	value from an object.
0: 	  *
0: 	  *	@return	true if we want the code generator to add a cast
0: 	  *				false otherwise
0: 	  */
0: 	public	boolean	mustCastToPrimitive() { return mustCastToPrimitive; }
0: 
0: 	/**
0: 	  *	Get the JSQLType that corresponds to this node. Could be a SQLTYPE,
0: 	  *	a Java primitive, or a Java class.
0: 	  *
0: 	  *	@return	the corresponding JSQLType
0: 	  *
0: 	  */
0: 	public	JSQLType	getJSQLType
0: 	(
0:     )
0: 	{ return jsqlType; }
0: 
0: 
0: 	/**
0: 	  *	Map a JSQLType to a compilation type id.
0: 	  *
0: 	  *	@param	jsqlType	the universal type to map
0: 	  *
0: 	  *	@return	the corresponding compilation type id
0: 	  *
0: 	  */
0: 	public	TypeId	mapToTypeID( JSQLType jsqlType )
0: 	{
0: 		DataTypeDescriptor	dts = jsqlType.getSQLType();
0: 
0: 		if ( dts == null ) { return null; }
0: 
0: 		return dts.getTypeId();
0: 	}
0: 
0: 	/**
0: 	 * Set the clause that this node appears in.
0: 	 *
0: 	 * @param clause	The clause that this node appears in.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setClause(int clause)
0: 	{
0: 		clause = clause;
0: 	}
0: 
0: 	/**
0: 	 * Mark this node as being for a CALL Statement.
0: 	 * (void methods are only okay for CALL Statements)
0: 	 */
0: 	public void markForCallStatement()
0: 	{
0: 		forCallStatement = true;
0: 	}
0: 
0: 	/**
0: 	 * @see ValueNode#remapColumnReferencesToExpressions
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	abstract public JavaValueNode remapColumnReferencesToExpressions()
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * @see ValueNode#categorize
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	abstract public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * @see ValueNode#bindExpression
0: 	 *
0: 	 * @return the new node, usually this
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	abstract JavaValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 							Vector aggregateVector) 
0: 							throws StandardException;
0: 	/**
0: 	 * @see ValueNode#preprocess
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	abstract public void preprocess(int numTables,
0: 									FromList outerFromList,
0: 									SubqueryList outerSubqueryList,
0: 									PredicateList outerPredicateList)
0: 							throws StandardException;
0: 
0: 	/** @see ValueNode#getConstantValueAsObject 
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	Object getConstantValueAsObject()
0: 		throws StandardException
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Do the code generation for this node.  Call the more general
0: 	 * routine that generates expressions.
0: 	 *
0: 	 * @param acb	The ActivationClassBuilder for the class being built
0: 	 * @param mb the method  the expression will go into
0: 	 *
0: 	 * @return		The compiled Expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	protected final	void generate(ActivationClassBuilder acb,
0: 										MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		generateExpression( acb, mb );
0: 	}
0: 
0: 	/**
0: 	 * Generate the expression that evaluates to the receiver. This is
0: 	 * for the case where a java expression is being returned to the SQL
0: 	 * domain, and we need to check whether the receiver is null (if so,
0: 	 * the SQL value should be set to null, and this Java expression
0: 	 * not evaluated). Instance method calls and field references have
0: 	 * receivers, while class method calls and calls to constructors do
0: 	 * not. If this Java expression does not have a receiver, this method
0: 	 * returns null.
0: 	 *
0: 	 * The implementation of this method should only generate the receiver
0: 	 * once and cache it in a field. This is because there will be two
0: 	 * references to the receiver, and we want to evaluate it only once.
0: 	 *
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb the method  the expression will go into
0: 	 *
0: 	 * @return		True if has compiled receiver.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected boolean generateReceiver(ExpressionClassBuilder acb,
0: 													MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Return the variant type for the underlying expression.
0: 	 * The variant type can be:
0: 	 *		VARIANT				- variant within a scan
0: 	 *							  (method calls and non-static field access)
0: 	 *		SCAN_INVARIANT		- invariant within a scan
0: 	 *							  (column references from outer tables)
0: 	 *		QUERY_INVARIANT		- invariant within the life of a query
0: 	 *							  (constant expressions)
0: 	 *
0: 	 * @return	The variant type for the underlying expression.
0: 	 */
0: 	protected int getOrderableVariantType() throws StandardException
0: 	{
0: 		// The default is VARIANT
0: 		return Qualifier.VARIANT;
0: 		//return Qualifier.SCAN_INVARIANT;
0: 	}
0: 
0: 	/**
0: 	 * General logic shared by Core compilation and by the Replication Filter
0: 	 * compiler. Every child of ValueNode must implement one of these methods.
0: 	 *
0: 	 * @param ecb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb the method the expression will go into
0: 	 *
0: 	 * @return		The compiled Expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	protected abstract  void generateExpression(
0: 											ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 									throws StandardException;
0: 
0: 	/**
0: 	 * Generate the expression that evaluates to the receiver. This is
0: 	 * for the case where a java expression is being returned to the SQL
0: 	 * domain, and we need to check whether the receiver is null (if so,
0: 	 * the SQL value should be set to null, and this Java expression
0: 	 * not evaluated). Instance method calls and field references have
0: 	 * receivers, while class method calls and calls to constructors do
0: 	 * not. If this Java expression does not have a receiver, this method
0: 	 * returns null.
0: 	 *
0: 	 * This also covers the case where a java expression is being returned
0: 	 * to the Java domain. In this case, we need to check whether the
0: 	 * receiver is null only if the value returned by the Java expression
0: 	 * is an object (not a primitive type). We don't want to generate the
0: 	 * expression here if we are returning a primitive type to the Java
0: 	 * domain, because there's no point in checking whether the receiver
0: 	 * is null in this case (we can't make the expression return a null
0: 	 * value).
0: 	 *
0: 	 * Only generate the receiver once and cache it in a field. This is
0: 	 * because there will be two references to the receiver, and we want
0: 	 * to evaluate it only once.
0: 	 *
0: 	 *
0: 	 * @param acb	The ActivationClassBuilder for the class being built
0: 	 * @param mb the method the expression will go into
0: 	 * @param receiver	The query tree form of the receiver expression
0: 	 *
0: 	 * @return		The compiled receiver, if any.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected final boolean generateReceiver(ExpressionClassBuilder acb,
0: 											MethodBuilder mb,
0: 											JavaValueNode receiver)
0: 									throws StandardException
0: 	{
0: 		ClassInspector classInspector = getClassFactory().getClassInspector();
0: 
0: 		/*
0: 		** Don't generate the expression now if it returns a primitive
0: 		** type to the Java domain.
0: 		*/
0: 		if ( (! valueReturnedToSQLDomain()) &&
0: 				classInspector.primitiveType(getJavaTypeName()))
0: 		{
0: 			return false;
0: 		}
0: 
0: 		/*
0: 		** Generate the following:
0: 		**
0: 		** <receiver class> <field name>;
0: 		** <field name> = <receiver>;
0: 		**
0: 		** for non-static calls.
0: 		*/
0: 
0: 		String receiverClassName = receiver.getJavaTypeName();
0: 		receiverField =
0: 				acb.newFieldDeclaration(Modifier.PRIVATE, receiverClassName);
0: 
0: 		receiver.generateExpression(acb, mb);
0: 		mb.putField(receiverField);
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Get an expression that has the value of the receiver. If a field
0: 	 * holding the receiver value was already generated, use that.  If not,
0: 	 * generate the receiver value.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb the method  the expression will go into
0: 	 * @param receiver	The query tree form of the receiver expression
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected final void getReceiverExpression(ExpressionClassBuilder acb,
0: 									MethodBuilder mb,
0: 									JavaValueNode receiver)
0: 										throws StandardException
0: 	{
0: 		if (receiverField != null)
0: 		{
0: 			mb.getField(receiverField);
0: 		}
0: 		else
0: 		{
0: 			receiver.generateExpression(acb, mb);
0: 		}
0: 	}
0: 
0: 	/** Inform this node that it returns its value to the SQL domain */
0: 	protected void returnValueToSQLDomain()
0: 	{
0: 		valueReturnedToSQLDomain = true;
0: 	}
0: 
0: 	/** Tell whether this node returns its value to the SQL domain */
0: 	protected boolean valueReturnedToSQLDomain()
0: 	{
0: 		return valueReturnedToSQLDomain;
0: 	}
0: 
0: 	/** Tell this node that nothing is done with the returned value */
0: 	protected void markReturnValueDiscarded()
0: 	{
0: 		returnValueDiscarded = true;
0: 	}
0: 
0: 	/** Tell whether the return value from this node is discarded */
0: 	protected boolean returnValueDiscarded()
0: 	{
0: 		return returnValueDiscarded;
0: 	}
0: 
0: 	/**
0: 		Check the reliability type of this java value.
0: 
0: 	    @exception StandardException		Thrown on error
0: 
0: 		@see org.apache.derby.iapi.sql.compile.CompilerContext
0: 	*/
0: 	public void checkReliability(ValueNode sqlNode) throws StandardException {
0:         sqlNode.checkReliability( 
0:                 CompilerContext.FUNCTION_CALL_ILLEGAL,
0:                 SQLState.LANG_JAVA_METHOD_CALL_OR_FIELD_REF
0:                 );
0: 	}
0: }
============================================================================