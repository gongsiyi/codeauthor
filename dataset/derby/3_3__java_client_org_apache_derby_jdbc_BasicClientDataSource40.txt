1:4e0e1f1: /*
4:4e0e1f1: 
1:38667d9:    Derby - Class org.apache.derby.jdbc.BasicClientDataSource40
1:4e0e1f1: 
1:4e0e1f1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:4e0e1f1:    contributor license agreements.  See the NOTICE file distributed with
1:4e0e1f1:    this work for additional information regarding copyright ownership.
1:4e0e1f1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:4e0e1f1:    (the "License"); you may not use this file except in compliance with
1:4e0e1f1:    the License.  You may obtain a copy of the License at
1:4e0e1f1: 
1:4e0e1f1:       http://www.apache.org/licenses/LICENSE-2.0
1:4e0e1f1: 
1:4e0e1f1:    Unless required by applicable law or agreed to in writing, software
1:4e0e1f1:    distributed under the License is distributed on an "AS IS" BASIS,
1:4e0e1f1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:4e0e1f1:    See the License for the specific language governing permissions and
1:4e0e1f1:    limitations under the License.
1:4e0e1f1: 
1:4e0e1f1:  */
1:4e0e1f1: 
1:4e0e1f1: package org.apache.derby.jdbc;
1:4e0e1f1: 
1:6ac5160: import java.io.BufferedOutputStream;
1:7863d83: import java.io.File;
1:6ac5160: import java.io.FileOutputStream;
1:6ac5160: import java.io.IOException;
1:7863d83: import java.io.PrintWriter;
1:7863d83: import java.io.Serializable;
1:7863d83: import java.lang.reflect.InvocationTargetException;
1:7863d83: import java.lang.reflect.Method;
1:7863d83: import java.lang.reflect.Modifier;
1:7863d83: import java.security.AccessController;
1:6ac5160: import java.security.PrivilegedActionException;
1:6ac5160: import java.security.PrivilegedExceptionAction;
1:7863d83: import java.security.PrivilegedAction;
1:7863d83: import java.sql.Connection;
1:7863d83: import java.sql.SQLException;
1:7863d83: import java.sql.SQLFeatureNotSupportedException;
1:7863d83: import java.util.Locale;
1:7863d83: import java.util.NoSuchElementException;
1:7863d83: import java.util.Properties;
1:7863d83: import java.util.StringTokenizer;
1:7863d83: import java.util.logging.Logger;
1:4e0e1f1: import javax.sql.DataSource;
1:7863d83: import javax.sql.PooledConnection;
1:7863d83: import javax.sql.XAConnection;
1:7863d83: import org.apache.derby.client.am.ClientMessageId;
1:7863d83: import org.apache.derby.client.am.EncryptionManager;
1:7863d83: import org.apache.derby.client.am.LogWriter;
1:7863d83: import org.apache.derby.client.am.SQLExceptionFactory;
1:7863d83: import org.apache.derby.client.am.SqlException;
1:7863d83: import org.apache.derby.client.net.NetConfiguration;
1:7863d83: import org.apache.derby.client.net.NetLogWriter;
1:7863d83: import org.apache.derby.shared.common.error.ExceptionUtil;
1:7863d83: import org.apache.derby.shared.common.reference.Attribute;
1:7863d83: import org.apache.derby.shared.common.reference.SQLState;
1:4e0e1f1: 
1:4e0e1f1: /**
1:7863d83:  * This data source is suitable for client/server use of Derby,
1:2913612:  * running on Java 8 Compact Profile 2 or higher.
1:2913612:  * <p/>
1:04fc939:  * BasicClientDataSource40 is similar to ClientDataSource except it
1:4e0e1f1:  * can not be used with JNDI, i.e. it does not implement
1:4e0e1f1:  * {@code javax.naming.Referenceable}.
1:b004dff:  * <p/>
1:b004dff:  *  * The standard attributes provided are, cf. e.g. table
1:b004dff:  * 9.1 in the JDBC 4.2 specification.
1:b004dff:  * <ul>
1:b004dff:  *   <li>databaseName</li>
1:b004dff:  *   <li>dataSourceName</li>
1:b004dff:  *   <li>description</li>
1:b004dff:  *   <li>password</li>
1:b004dff:  *   <li>user</li>
1:b004dff:  * </ul>
1:b004dff:  * These standard attributes are not supported:
1:b004dff:  * <ul>
1:b004dff:  *   <li>networkProtocol</li>
1:b004dff:  *   <li>roleName</li>
1:b004dff:  * </ul>
1:b004dff:  * The Derby client driver also supports these attributes:
1:b004dff:  * <ul>
1:b004dff:  *   <li>loginTimeout</li> @see javax.sql.CommonDataSource set/get
1:b004dff:  *   <li>logWriter</li> @see javax.sql.CommonDataSource set/get
1:b004dff:  *   <li>createDatabase</li>
1:b004dff:  *   <li>connectionAttributes</li>
1:b004dff:  *   <li>shutdownDatabase</li>
1:b004dff:  *   <li>attributesAsPassword</li>
1:b004dff:  *   <li>retrieveMessageText</li>
1:b004dff:  *   <li>securityMechanism</li>
1:b004dff:  *   <li>traceDirectory</li>
1:b004dff:  *   <li>traceFile</li>
1:b004dff:  *   <li>traceFileAppend</li>
1:b004dff:  *   <li>traceLevel<li>
1:b004dff:  * </ul>
1:4e0e1f1:  */
1:7863d83: @SuppressWarnings("ResultOfObjectAllocationIgnored")
1:7863d83: public class BasicClientDataSource40 
1:7863d83:     implements DataSource, ClientDataSourceInterface, Serializable {
1:4e0e1f1: 
1:4e0e1f1:     private final static long serialVersionUID = 1894299584216955554L;
1:4e0e1f1:     public final static String className__ =
1:38667d9:             "org.apache.derby.jdbc.BasicClientDataSource40";
1:4e0e1f1: 
1:7863d83:     // ---------------------------- traceLevel -------------------------------
1:7863d83:     //
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * The client server protocol can be traced. The constants below define the
1:7863d83:      * tracing level, cf. the documentation section "Network Client Tracing" in
1:7863d83:      * the "Derby Server and Administration Guide". Cf. the connection
1:7863d83:      * attribute (or data source bean property) {@code traceLevel}.
1:7863d83:      *
1:7863d83:      * <pre>
1:7863d83:      * TRACE_NONE	
1:7863d83:      * TRACE_CONNECTION_CALLS	
1:7863d83:      * TRACE_STATEMENT_CALLS	
1:7863d83:      * TRACE_RESULT_SET_CALLS	
1:7863d83:      * TRACE _DRIVER_CONFIGURATION	
1:7863d83:      * TRACE_CONNECTS	
1:7863d83:      * TRACE_PROTOCOL_FLOWS	
1:7863d83:      * TRACE _RESULT_SET_META_DATA	
1:7863d83:      * TRACE _PARAMETER_META_DATA	
1:7863d83:      * TRACE_DIAGNOSTICS	
1:7863d83:      * TRACE_XA_CALLS	
1:7863d83:      * TRACE_ALL	
1:7863d83:      * </pre>
1:7863d83:      */
1:7863d83:     public final static int TRACE_NONE = 0x0;
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #TRACE_NONE}.
1:7863d83:      */
1:7863d83:     public final static int TRACE_CONNECTION_CALLS = 0x1;
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #TRACE_NONE}.
1:7863d83:      */
1:7863d83:     public final static int TRACE_STATEMENT_CALLS = 0x2;
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #TRACE_NONE}.
1:7863d83:      */
1:7863d83:     public final static int TRACE_RESULT_SET_CALLS = 0x4;
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #TRACE_NONE}.
1:7863d83:      */
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #TRACE_NONE}.
1:7863d83:      */
1:7863d83:     public final static int TRACE_DRIVER_CONFIGURATION = 0x10;
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #TRACE_NONE}.
1:7863d83:      */
1:7863d83:     public final static int TRACE_CONNECTS = 0x20;
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #TRACE_NONE}.
1:7863d83:      */
1:7863d83:     public final static int TRACE_PROTOCOL_FLOWS = 0x40;
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #TRACE_NONE}.
1:7863d83:      */
1:7863d83:     public final static int TRACE_RESULT_SET_META_DATA = 0x80;
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #TRACE_NONE}.
1:7863d83:      */
1:7863d83:     public final static int TRACE_PARAMETER_META_DATA = 0x100;
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #TRACE_NONE}.
1:7863d83:      */
1:7863d83:     public final static int TRACE_DIAGNOSTICS = 0x200;
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #TRACE_NONE}.
1:7863d83:      */
1:7863d83:     public final static int TRACE_XA_CALLS = 0x800;
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #TRACE_NONE}.
1:7863d83:      */
1:7863d83:     public final static int TRACE_ALL = 0xFFFFFFFF;
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #TRACE_NONE}.
1:7863d83:      */
1:7863d83:     public final static int propertyDefault_traceLevel = TRACE_ALL;
1:7863d83: 
1:7863d83:     static
1:7863d83:     {
1:7863d83:         try {
1:7863d83:             // The EncryptionManager class will instantiate objects of the
1:7863d83:             // required security algorithms that are needed for EUSRIDPWD An
1:7863d83:             // exception will be thrown if support is not available in the JCE
1:7863d83:             // implementation in the JVM in which the client is loaded.
1:7863d83:             new EncryptionManager(null);
1:7863d83:         } catch(Exception e) {
1:7863d83:             // if an exception is thrown, ignore exception.
1:7863d83:         }
1:7863d83: 
1:7863d83:     }
1:7863d83: 
1:b004dff:     /**
1:4e0e1f1:      * Creates a simple DERBY data source with default property values
1:4e0e1f1:      * for a non-pooling, non-distributed environment.  No particular
1:4e0e1f1:      * DatabaseName or other properties are associated with the data
1:4e0e1f1:      * source.
1:4e0e1f1:      * <p/>
1:4e0e1f1:      * Every Java Bean should provide a constructor with no arguments
1:4e0e1f1:      * since many beanboxes attempt to instantiate a bean by invoking
1:4e0e1f1:      * its no-argument constructor.
1:7863d83:      */
1:38667d9:     public BasicClientDataSource40() {
1:4e0e1f1:         super();
1:4e0e1f1:     }
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * The source security mechanism to use when connecting to a client data
1:7863d83:      * source.
1:7863d83:      * <p/>
1:7863d83:      * Security mechanism options are:
1:7863d83:      * <ul>
1:7863d83:      *   <li> USER_ONLY_SECURITY
1:7863d83:      *   <li> CLEAR_TEXT_PASSWORD_SECURITY
1:7863d83:      *   <li> ENCRYPTED_PASSWORD_SECURITY
1:7863d83:      *   <li> ENCRYPTED_USER_AND_PASSWORD_SECURITY - both password and
1:7863d83:      *        user are encrypted
1:7863d83:      *   <li> STRONG_PASSWORD_SUBSTITUTE_SECURITY
1:7863d83:      * </ul> The default security mechanism is USER_ONLY SECURITY
1:7863d83:      * <p/>
1:7863d83:      * If the application specifies a security mechanism then it will be the
1:7863d83:      * only one attempted. If the specified security mechanism is not
1:7863d83:      * supported by the conversation then an exception will be thrown and
1:7863d83:      * there will be no additional retries.
1:7863d83:      * <p/>
1:7863d83:      * Both user and password need to be set for all security mechanism except
1:7863d83:      * USER_ONLY_SECURITY.
1:7863d83:      */
1:7863d83:     public final static short USER_ONLY_SECURITY =
1:7863d83:         ClientDataSourceInterface.USER_ONLY_SECURITY;
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #USER_ONLY_SECURITY}
1:7863d83:      */
1:7863d83:     public final static short CLEAR_TEXT_PASSWORD_SECURITY =
1:7863d83:         ClientDataSourceInterface.CLEAR_TEXT_PASSWORD_SECURITY;
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #USER_ONLY_SECURITY}
1:7863d83:      */
1:7863d83:     public final static short ENCRYPTED_PASSWORD_SECURITY =
1:7863d83:         ClientDataSourceInterface.ENCRYPTED_PASSWORD_SECURITY;
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #USER_ONLY_SECURITY}
1:7863d83:      */
1:7863d83:     public final static short ENCRYPTED_USER_AND_PASSWORD_SECURITY =
1:7863d83:         ClientDataSourceInterface.ENCRYPTED_USER_AND_PASSWORD_SECURITY;
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * See documentation at {@link #USER_ONLY_SECURITY}
1:7863d83:      */
1:7863d83:     public final static short STRONG_PASSWORD_SUBSTITUTE_SECURITY =
1:7863d83:         ClientDataSourceInterface.STRONG_PASSWORD_SUBSTITUTE_SECURITY;
1:7863d83: 
1:7863d83:     // The loginTimeout jdbc 2 data source property is not supported as a jdbc
1:7863d83:     // 1 connection property, because loginTimeout is set by the jdbc 1 api
1:7863d83:     // via java.sql.DriverManager.setLoginTimeout().  The databaseName,
1:7863d83:     // serverName, and portNumber data source properties are also not
1:7863d83:     // supported as connection properties because they are extracted from the
1:7863d83:     // jdbc 1 database url passed on the connection request.  However, all
1:7863d83:     // other data source properties should probably also be supported as
1:7863d83:     // connection properties.
1:7863d83: 
1:b004dff:     // ---------------------------- loginTimeout ------------------------------
11:7863d83:     //
1:7863d83:     // was serialized in 1.0 release
1:7863d83:     /**
1:7863d83:      * The time in seconds to wait for a connection request on this data
1:7863d83:      * source. The default value of zero indicates that either the system time
1:7863d83:      * out be used or no timeout limit.
1:7863d83:      *
1:b004dff:      * @serial
1:b004dff:      */
1:7863d83:     private int loginTimeout;
1:7863d83: 
1:7863d83:     public synchronized void setLoginTimeout(int seconds) {
1:7863d83:         this.loginTimeout = seconds;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public int getLoginTimeout() {
1:7863d83:         return this.loginTimeout;
1:7863d83:     }
1:7863d83: 
1:7863d83:     // ---------------------------- logWriter --------------------------------
1:7863d83:     //
1:7863d83:     /**
1:7863d83:      * The log writer is declared transient, and is not serialized or stored
1:7863d83:      * under JNDI.
1:7863d83:      *
1:7863d83:      * @see #traceLevel
1:7863d83:      */
1:7863d83:     private transient PrintWriter logWriter;
1:7863d83: 
1:7863d83:     public synchronized void setLogWriter(PrintWriter logWriter) {
1:7863d83:         this.logWriter = logWriter;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public PrintWriter getLogWriter() {
1:7863d83:         return this.logWriter;
1:7863d83:     }
1:7863d83: 
1:7863d83:     // ---------------------------- databaseName ------------------------------
1:7863d83:     //
1:b004dff:     
1:b004dff:     /**
1:b004dff:      * Stores the relational database name, RDBNAME.
1:b004dff:      * The length of the database name may be limited to 18 bytes
1:b004dff:      * and therefore may throw an SQLException.
1:b004dff:      * @serial
1:b004dff:      */
1:7863d83:     private String databaseName;
1:7863d83: 
1:7863d83:     // databaseName is not permitted in a properties object
1:7863d83: 
1:7863d83: 
1:7863d83:     // ---------------------------- description ------------------------------
1:b004dff:     
1:b004dff:     /**
1:b004dff:      * A description of this data source.
1:b004dff:      * @serial
1:b004dff:      */
1:7863d83:     private String description;
1:7863d83: 
1:7863d83:     // ---------------------------- dataSourceName ----------------------------
1:7863d83:     //
1:b004dff:     
1:b004dff:     /**
1:b004dff:      * A data source name;
1:b004dff:      * used to name an underlying XADataSource,
1:b004dff:      * or ConnectionPoolDataSource when pooling of connections is done.
1:b004dff:      * @serial
1:b004dff:      */
1:7863d83:     private String dataSourceName;
1:7863d83: 
1:7863d83:     // ---------------------------- portNumber --------------------------------
1:b004dff: 
1:b004dff:     /**
1:b004dff:      * @serial
1:b004dff:      */
1:7863d83:     private int portNumber = propertyDefault_portNumber;
1:7863d83: 
1:7863d83:     // ---------------------------- serverName --------------------------------
1:b004dff:     
1:b004dff:     /**
1:b004dff:      * @serial 
1:b004dff:      */
1:b004dff:     private String serverName = propertyDefault_serverName; // Derby-410 fix.
1:7863d83: 
1:7863d83:     // serverName is not permitted in a properties object
1:7863d83: 
1:7863d83:     //---------------------- client SSL ----------------
1:7863d83: 
1:7863d83:     /** The constant indicating that SSL encryption won't be used. */
1:7863d83:     public final static int SSL_OFF = 0;
1:7863d83:     private final static String SSL_OFF_STR = "off";
1:7863d83:     /** The constant indicating that SSL encryption will be used. */
1:7863d83:     public final static int SSL_BASIC = 1;
1:7863d83:     private final static String SSL_BASIC_STR = "basic";
1:7863d83:     /**
1:7863d83:      * The constant indicating that SSL encryption with peer authentication
1:7863d83:      * will be used.
1:7863d83:      */
1:7863d83:     public final static int SSL_PEER_AUTHENTICATION = 2;
1:7863d83:     private final static String SSL_PEER_AUTHENTICATION_STR =
1:7863d83:             "peerAuthentication";
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Parses the string and returns the corresponding constant for the SSL
1:7863d83:      * mode denoted.
1:7863d83:      * <p>
1:7863d83:      * Valid values are <tt>off</tt>, <tt>basic</tt> and
1:7863d83:      * <tt>peerAuthentication</tt>.
1:7863d83:      *
1:7863d83:      * @param s string denoting the SSL mode
1:7863d83:      * @return A constant indicating the SSL mode denoted by the string. If the
1:7863d83:      *      string is {@code null}, {@link #SSL_OFF} is returned.
1:7863d83:      * @throws SqlException if the string has an invalid value
1:7863d83:      */
1:7863d83:     public static int getSSLModeFromString(String s)
1:7863d83:         throws SqlException
1:7863d83:     {
1:7863d83: 
1:7863d83:         if (s != null){
1:7863d83:             if (s.equalsIgnoreCase(SSL_OFF_STR)) {
1:7863d83:                 return SSL_OFF;
1:7863d83:             } else if (s.equalsIgnoreCase(SSL_BASIC_STR)) {
1:7863d83:                 return SSL_BASIC;
1:7863d83:             } else if (s.equalsIgnoreCase(SSL_PEER_AUTHENTICATION_STR)) {
1:7863d83:                 return SSL_PEER_AUTHENTICATION;
1:7863d83:             } else {
1:7863d83:                 throw new SqlException(null,
1:7863d83:                         new ClientMessageId(SQLState.INVALID_ATTRIBUTE),
1:7863d83:                         Attribute.SSL_ATTR, s, SSL_OFF_STR + ", " +
1:7863d83:                         SSL_BASIC_STR + ", " + SSL_PEER_AUTHENTICATION_STR);
1:7863d83:             }
1:7863d83:         } else {
1:7863d83:             // Default
1:7863d83:             return SSL_OFF;
1:7863d83:         }
1:7863d83:     }
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Returns the SSL mode specified by the property object.
1:7863d83:      *
1:7863d83:      * @param properties data source properties
1:7863d83:      * @return A constant indicating the SSL mode to use. Defaults to
1:7863d83:      *      {@link #SSL_OFF} if the SSL attribute isn't specified.
1:7863d83:      * @throws SqlException if an invalid value for the SSL mode is specified
1:7863d83:      *      in the property object
1:7863d83:      */
1:7863d83:     public static int getClientSSLMode(Properties properties)
1:7863d83:         throws SqlException
1:7863d83:     {
1:7863d83:         return
1:7863d83:             getSSLModeFromString(properties.getProperty(Attribute.SSL_ATTR));
1:7863d83:     }
1:7863d83: 
1:7863d83:     // ---------------------------- user -----------------------------------
1:7863d83:     //
1:b004dff:     
1:b004dff:     /**
1:b004dff:      * This property can be overwritten by specifing the
1:b004dff:      * username parameter on the DataSource.getConnection() method
1:b004dff:      * call.  If user is specified, then password must also be
1:b004dff:      * specified, either in the data source object or provided on
1:b004dff:      * the DataSource.getConnection() call.
1:b004dff:      *
1:b004dff:      * Each data source implementation subclass will maintain it's own
1:b004dff:      * <code>password</code> property.  This password property may or may not
1:b004dff:      * be declared transient, and therefore may be serialized to a file in
1:b004dff:      * clear-text, care must taken by the user to prevent security breaches.
1:b004dff:      * Derby-406 fix
1:b004dff:      * 
1:b004dff:      * @serial
1:b004dff:      */
1:7863d83:     private String user = propertyDefault_user;
1:7863d83: 
1:7863d83:     public static String getUser(Properties properties) {
1:7863d83:         String userString = properties.getProperty(Attribute.USERNAME_ATTR);
1:7863d83:         return parseString(userString, propertyDefault_user);
1:7863d83:     }
1:7863d83: 
1:7863d83:     // ---------------------------- securityMechanism -------------------------
1:7863d83:     //
1:7863d83:     // The source security mechanism to use when connecting to this data
1:7863d83:     // source.
1:7863d83:     // <p>
1:7863d83:     // Security mechanism options are:
1:7863d83:     // <ul>
1:7863d83:     // <li> USER_ONLY_SECURITY
1:7863d83:     // <li> CLEAR_TEXT_PASSWORD_SECURITY
1:7863d83:     // <li> ENCRYPTED_PASSWORD_SECURITY
1:7863d83:     // <li> ENCRYPTED_USER_AND_PASSWORD_SECURITY - both password and
1:7863d83:     //      user are encrypted
1:7863d83:     // <li> STRONG_PASSWORD_SUBSTITUTE_SECURITY
1:7863d83:     // </ul>
1:7863d83:     // The default security mechanism is USER_ONLY_SECURITY.
1:7863d83:     // <p>
1:7863d83:     // If the application specifies a security
1:7863d83:     // mechanism then it will be the only one attempted.
1:7863d83:     // If the specified security mechanism is not supported by the
1:7863d83:     // conversation then an exception will be thrown and there will be no
1:7863d83:     // additional retries.
1:7863d83:     // <p>
1:7863d83:     // This property is currently only available for the DNC driver.
1:7863d83:     // <p>
1:7863d83:     // Both user and password need to be set for all security mechanism except
1:7863d83:     // USER_ONLY_SECURITY When using USER_ONLY_SECURITY, only the user
1:7863d83:     // property needs to be specified.
1:7863d83:     //
1:7863d83: 
1:7863d83:     // constant to indicate that the security mechanism has not been
1:7863d83:     // explicitly set, either on connection request when using DriverManager
1:7863d83:     // or on the Client DataSource object
1:7863d83:     private final static short SECMEC_HAS_NOT_EXPLICITLY_SET = 0;
1:7863d83: 
1:b004dff:     /**
1:b004dff:      * Security Mechanism can be specified explicitly either when obtaining a
1:b004dff:      * connection via a DriverManager or via Datasource.
1:b004dff:      * Via DriverManager, securityMechanism can be set on the connection
1:b004dff:      * request using the 'securityMechanism' attribute.
1:b004dff:      * Via DataSource, securityMechanism can be set by calling
1:b004dff:      * setSecurityMechanism() on the ClientDataSource
1:b004dff:      * If the security mechanism is not explicitly set as mentioned above, in
1:b004dff:      * that case the Client will try to upgrade the security mechanism to a
1:b004dff:      * more secure one, if possible.
1:b004dff:      * See {@link #getUpgradedSecurityMechanism}.
1:b004dff:      * Therefore, need to keep track if the securityMechanism has been
1:b004dff:      * explicitly set.
1:b004dff:      *
1:b004dff:      * @serial
1:b004dff:      */
1:7863d83:     private short securityMechanism = SECMEC_HAS_NOT_EXPLICITLY_SET;
1:7863d83: 
1:7863d83: 
1:7863d83: 
1:7863d83:     // We use the NET layer constants to avoid a mapping for the NET driver.
1:b004dff:     
1:7863d83:     /**
1:7863d83:      * Return security mechanism if it is set, else upgrade the security
1:7863d83:      * mechanism if possible and return the upgraded security mechanism
1:7863d83:      * @param properties Look in the properties if securityMechanism is set
1:7863d83:      *        or not
1:7863d83:      * if set, return this security mechanism
1:7863d83:      * @return security mechanism
1:7863d83:      */
1:7863d83:     public static short getSecurityMechanism(Properties properties) {
1:7863d83:         short secmec;
1:7863d83:         String securityMechanismString =
1:7863d83:             properties.getProperty(Attribute.CLIENT_SECURITY_MECHANISM);
1:7863d83: 
1:7863d83:         if ( securityMechanismString != null )
1:7863d83:         {
1:7863d83:             // security mechanism has been set, do not override, but instead
1:7863d83:             // return the security mechanism that has been set (DERBY-962)
1:7863d83:             secmec = Short.parseShort(securityMechanismString);
1:7863d83:         }
1:7863d83:         else
1:7863d83:         {
1:7863d83:             // if securityMechanismString is null, this means that security
1:7863d83:             // mechanism has not been set explicitly and not available in
1:7863d83:             // properties. Hence, do an upgrade of security mechanism if
1:7863d83:             // possible The logic for upgrade of security mechanism uses
1:7863d83:             // information about if password is available or not, so pass this
1:7863d83:             // information also.
1:7863d83:             String passwordString =
1:7863d83:                 properties.getProperty(Attribute.PASSWORD_ATTR);
1:7863d83:             secmec = getUpgradedSecurityMechanism(passwordString);
1:7863d83:         }
1:7863d83:         return secmec;
1:7863d83:     }
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * This method has logic to upgrade security mechanism to a better (more
1:7863d83:      * secure) one if it is possible. Currently derby server only has support
1:7863d83:      * for USRIDPWD, USRIDONL, EUSRIDPWD and USRSSBPWD (10.2+) - this method
1:7863d83:      * only considers these possibilities. USRIDPWD, EUSRIDPWD and USRSSBPWD
1:7863d83:      * require a password, USRIDONL is the only security mechanism which does
1:7863d83:      * not require password.
1:7863d83:      * 1. if password is not available, then security mechanism possible is
1:7863d83:      * USRIDONL
1:7863d83:      * 2. if password is available,then USRIDPWD is returned.
1:7863d83:      *
1:7863d83:      * @param password password argument
1:7863d83:      * @return upgraded security mechanism if possible
1:7863d83:      */
1:7863d83:     private static short getUpgradedSecurityMechanism(String password) {
1:7863d83:         // if password is null, in that case the only acceptable security
1:7863d83:         // mechanism is USRIDONL, which is the default security mechanism.
1:7863d83:         if ( password == null ) {
1:7863d83:             return propertyDefault_securityMechanism;
1:7863d83:         }
1:7863d83: 
1:7863d83:         // when we have support for more security mechanisms on server
1:7863d83:         // and client, we should update this upgrade logic to pick
1:7863d83:         // secure security mechanisms before trying out the USRIDPWD
1:7863d83: 
1:7863d83:         /*
1:7863d83:         // -----------------------
1:7863d83:         // PLEASE NOTE:
1:7863d83:         // When DERBY-1517, DERBY-1755 is fixed, there might be a way to use
1:7863d83:         // EUSRIDPWD when both client and server vm's have support for
1:7863d83:         // it. Hence the below if statement is commented out.
1:7863d83:       if (SUPPORTS_EUSRIDPWD)
1:7863d83:             return (short)NetConfiguration.SECMEC_EUSRIDPWD;
1:7863d83:         else
1:7863d83:             // IMPORTANT NOTE:
1:7863d83:             // --------------
1:7863d83:             // If DERBY-1517 can be fixed, we should default to
1:7863d83:             // SECMEC_USRSSBPWD (strong password substitute).
1:7863d83:             // Until then, connecting with a 10.2+ client to
1:7863d83:             // a derby server < 10.2, and hence does not support
1:7863d83:             // SECMEC_USRSSBPWD as a SECMEC, will cause a DRDA protocol
1:7863d83:             // exception, as described in DERBY-926).
1:7863d83:             //
1:7863d83:             // return (short)NetConfiguration.SECMEC_USRSSBPWD;
1:7863d83:          // ----------------------
1:7863d83:          */
1:7863d83:          return (short)NetConfiguration.SECMEC_USRIDPWD;
1:7863d83: 
1:7863d83:     }
1:7863d83: 
1:7863d83:     // ---------------------------- getServerMessageTextOnGetMessage ---------
1:b004dff: 
1:b004dff:     /**
1:b004dff:      * @serial
1:b004dff:      */
1:7863d83:     private boolean retrieveMessageText = propertyDefault_retrieveMessageText;
1:7863d83: 
1:7863d83:     public static boolean getRetrieveMessageText(Properties properties) {
1:7863d83:         String retrieveMessageTextString =
1:7863d83:             properties.getProperty(Attribute.CLIENT_RETIEVE_MESSAGE_TEXT);
1:7863d83:         return parseBoolean(
1:7863d83:             retrieveMessageTextString, propertyDefault_retrieveMessageText);
1:7863d83:     }
1:7863d83: 
1:7863d83:     // ---------------------------- traceFile ---------------------------------
1:b004dff: 
1:b004dff:     /**
1:b004dff:      * @serial
1:b004dff:      */
1:7863d83:     private String traceFile;
1:7863d83: 
1:7863d83:     static String getTraceFile(Properties properties) {
1:7863d83:         return properties.getProperty(Attribute.CLIENT_TRACE_FILE);
1:7863d83:     }
1:7863d83: 
1:7863d83:     // ---------------------------- traceDirectory ----------------------------
1:7863d83:     // For the suffix of the trace file when traceDirectory is enabled.
1:7863d83:     private transient int traceFileSuffixIndex_ = 0;
1:b004dff: 
1:b004dff:     /**
1:b004dff:      * @serial
1:b004dff:      */
1:7863d83:     private String traceDirectory;
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Check if derby.client.traceDirectory is provided as a JVM property.
1:7863d83:      * If yes, then we use that value. If not, then we look for traceDirectory
1:7863d83:      * in the the properties parameter.
1:7863d83:      *
1:7863d83:      * @param properties jdbc url properties
1:7863d83:      * @return value of traceDirectory property
1:7863d83:      */
1:7863d83:     static String getTraceDirectory(Properties properties) {
1:7863d83:         String traceDirectoryString;
1:7863d83: 
1:7863d83:         traceDirectoryString  =
1:7863d83:             readSystemProperty(
1:7863d83:                 Attribute.CLIENT_JVM_PROPERTY_PREFIX +
1:7863d83:                 Attribute.CLIENT_TRACE_DIRECTORY);
1:7863d83: 
1:7863d83:         if (traceDirectoryString == null  && properties != null) {
1:7863d83:             return properties.getProperty(Attribute.CLIENT_TRACE_DIRECTORY);
1:7863d83:         } else {
1:7863d83:             return traceDirectoryString;
1:7863d83:         }
1:7863d83:     }
1:7863d83: 
1:7863d83: 
1:7863d83:     /**
1:e5b33f3:      * Read the value of the passed system property. If we are running under
1:e5b33f3:      * the Java security manager and permission to read the property is 
1:e5b33f3:      * missing,a null is returned, and no diagnostic is given (DERBY-6620).
1:e5b33f3:      * 
1:7863d83:      * @param key name of the system property
1:7863d83:      * @return value of the system property, null if there is no
1:7863d83:      *         permission to read the property
1:7863d83:      */
1:7863d83:     private static String readSystemProperty(final String key) {
1:7863d83:         return AccessController.doPrivileged(new PrivilegedAction<String>() {
1:7863d83:                 public String run() {
1:7863d83:                     try {
1:7863d83:                         return System.getProperty(key);
1:7863d83:                     } catch (SecurityException se) {
1:7863d83:                         // We do not want the connection to fail if the user
1:7863d83:                         // does not have permission to read the property, so
1:7863d83:                         // if a security exception occurs, just return null
1:7863d83:                         // and continue with the connection.
1:e5b33f3:                         // See also the discussion in DERBY-6620 on why we do
1:e5b33f3:                         // not write a warning message on the console here.
1:7863d83:                         return null;
1:7863d83:                     }
1:7863d83:                 }
1:7863d83:             }
1:7863d83:             );
1:7863d83:     }
1:7863d83: 
1:7863d83:     // ---------------------------- traceFileAppend ---------------------------
1:b004dff: 
1:b004dff:     /**
1:b004dff:      * @serial
1:b004dff:      */
1:7863d83:     private boolean traceFileAppend = propertyDefault_traceFileAppend;
1:7863d83: 
1:7863d83:     static boolean getTraceFileAppend(Properties properties) {
1:7863d83:         String traceFileAppendString =
1:7863d83:             properties.getProperty(Attribute.CLIENT_TRACE_APPEND);
1:7863d83:         return parseBoolean(
1:7863d83:             traceFileAppendString, propertyDefault_traceFileAppend);
1:7863d83:     }
1:7863d83: 
1:7863d83:     // ---------------------------- password ----------------------------------
1:7863d83:     //
1:7863d83:     // The password property is defined in subclasses, but the method
1:7863d83:     // getPassword (java.util.Properties properties) is in this class to
1:7863d83:     // eliminate dependencies on j2ee for connections that go thru the driver
1:7863d83:     // manager.
1:7863d83: 
1:7863d83:     public static String getPassword(Properties properties) {
1:7863d83:         return properties.getProperty("password");
1:7863d83:     }
1:7863d83: 
1:b004dff:     /**
1:b004dff:      * @serial
1:b004dff:      */
1:7863d83:     private String password;
1:7863d83: 
1:7863d83:     synchronized public void setPassword(String password) {
1:7863d83:         this.password = password;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public String getPassword() {
1:7863d83:         return password;
1:7863d83:     }
1:7863d83: 
1:7863d83: 
1:7863d83:     // ----------------------supplemental methods------------------------------
1:7863d83: 
1:7863d83: 
1:7863d83:     //---------------------- helper methods -----------------------------------
1:7863d83: 
1:7863d83:     // The java.io.PrintWriter overrides the traceFile setting.
1:7863d83:     // If neither traceFile nor jdbc logWriter are set, then null is returned.
1:7863d83:     // logWriterInUseSuffix used only for trace directories to indicate whether
1:7863d83:     // log writer is use is from xads, cpds, sds, ds, driver, config, reset.
1:7863d83:     private LogWriter computeDncLogWriterForNewConnection(
1:7863d83:         String logWriterInUseSuffix) throws SqlException {
1:7863d83: 
1:7863d83:         return computeDncLogWriterForNewConnection(
1:7863d83:             logWriter,
1:7863d83:             traceDirectory,
1:7863d83:             traceFile,
1:7863d83:             traceFileAppend,
1:7863d83:             traceLevel,
1:7863d83:             logWriterInUseSuffix,
1:7863d83:             traceFileSuffixIndex_++);
1:7863d83:     }
1:7863d83: 
1:7863d83:     // Called on for connection requests.  The java.io.PrintWriter overrides
1:7863d83:     // the traceFile setting.  If neither traceFile, nor logWriter, nor
1:7863d83:     // traceDirectory are set, then null is returned.
1:7863d83:     static LogWriter computeDncLogWriterForNewConnection(
1:7863d83:         PrintWriter logWriter,
1:7863d83:         String traceDirectory,
1:7863d83:         String traceFile,
1:7863d83:         boolean traceFileAppend,
1:7863d83:         int traceLevel,
1:7863d83:         String logWriterInUseSuffix,
1:7863d83:         int traceFileSuffixIndex) throws SqlException {
1:7863d83: 
1:7863d83:         // compute regular dnc log writer if there is any
1:7863d83:         LogWriter dncLogWriter = computeDncLogWriter(
1:7863d83:             logWriter,
1:7863d83:             traceDirectory,
1:7863d83:             traceFile,
1:7863d83:             traceFileAppend,
1:7863d83:             logWriterInUseSuffix,
1:7863d83:             traceFileSuffixIndex,
1:7863d83:             traceLevel);
1:7863d83: 
1:7863d83:         return dncLogWriter;
1:7863d83:     }
1:7863d83: 
1:7863d83:     // Compute a DNC log writer before a connection is created.
1:7863d83:     private static LogWriter computeDncLogWriter(
1:7863d83:         PrintWriter logWriter,
1:7863d83:         String traceDirectory,
1:7863d83:         String traceFile,
1:7863d83:         boolean traceFileAppend,
1:7863d83:         String logWriterInUseSuffix,
1:7863d83:         int traceFileSuffixIndex,
1:7863d83:         int traceLevel) throws SqlException {
1:7863d83: 
1:7863d83:         // Otherwise, the trace file will still be created even TRACE_NONE.
1:7863d83:         if (traceLevel == TRACE_NONE) {
1:7863d83:             return null;
1:7863d83:         }
1:7863d83: 
1:7863d83:         PrintWriter printWriter = computePrintWriter(
1:7863d83:             logWriter,
1:7863d83:             traceDirectory,
1:7863d83:             traceFile,
1:7863d83:             traceFileAppend,
1:7863d83:             logWriterInUseSuffix,
1:7863d83:             traceFileSuffixIndex);
1:7863d83: 
1:7863d83:         if (printWriter == null) {
1:7863d83:             return null;
1:7863d83:         }
1:7863d83: 
1:7863d83:         LogWriter dncLogWriter = new NetLogWriter(printWriter, traceLevel);
1:7863d83:         if (printWriter != logWriter &&
1:7863d83:                 (traceDirectory != null || traceFile != null))
1:7863d83:         // When printWriter is an internal trace file and
1:7863d83:         // traceDirectory is not null, each connection has
1:7863d83:         // its own trace file and the trace file is not cached,
1:7863d83:         // so we can close it when DNC log writer is closed.
1:7863d83:         {
1:7863d83:             dncLogWriter.printWriterNeedsToBeClosed_ = true;
1:7863d83:         }
1:7863d83:         return dncLogWriter;
1:7863d83:     }
1:7863d83: 
1:7863d83:     // This method handles all the override semantics.  The logWriter
1:7863d83:     // overrides the traceFile, and traceDirectory settings.  If neither
1:7863d83:     // traceFile, nor logWriter, nor traceDirectory are set, then null is
1:7863d83:     // returned.
1:7863d83:     private static PrintWriter computePrintWriter(
1:7863d83:         PrintWriter logWriter,
1:7863d83:         String traceDirectory,
1:7863d83:         String traceFile,
1:7863d83:         boolean traceFileAppend,
1:7863d83:         String logWriterInUseSuffix,
1:7863d83:         int traceFileSuffixIndex) throws SqlException {
1:7863d83: 
1:7863d83:         if (logWriter != null)  // java.io.PrintWriter is specified
1:7863d83:         {
1:7863d83:             return logWriter;
1:7863d83:         } else { // check trace file setting.
1:7863d83:             if (traceDirectory != null) {
1:7863d83:                 String fileName;
1:7863d83:                 if (traceFile == null) {
1:7863d83:                     fileName = traceDirectory + File.separator +
1:7863d83:                         logWriterInUseSuffix + "_" + traceFileSuffixIndex;
1:7863d83:                 } else {
1:7863d83:                     fileName = traceDirectory + File.separator +
1:7863d83:                         traceFile + logWriterInUseSuffix + "_" +
1:7863d83:                         traceFileSuffixIndex;
1:7863d83:                 }
1:6ac5160:                 return getPrintWriter(
1:7863d83:                     fileName, true); // no file append and not enable caching.
1:7863d83:             } else if (traceFile != null) {
1:6ac5160:                 return getPrintWriter(traceFile, traceFileAppend);
1:7863d83:             }
1:7863d83:         }
1:7863d83:         return null;
1:7863d83:     }
1:7863d83: 
1:6ac5160:     private static PrintWriter getPrintWriter(
1:6ac5160:             final String fileName,
1:6ac5160:             final boolean fileAppend) throws SqlException {
1:7863d83: 
1:6ac5160:         PrintWriter printWriter = null;
1:6ac5160:         //Using an anonymous class to deal with the PrintWriter because the  
1:6ac5160:         //method java.security.AccessController.doPrivileged requires an 
1:6ac5160:         //instance of a class(which implements 
1:6ac5160:         //java.security.PrivilegedExceptionAction). Since getPrintWriter method
1:6ac5160:         //is static, we can't simply pass "this" to doPrivileged method and 
1:6ac5160:         //have LogWriter implement PrivilegedExceptionAction.
1:6ac5160:         //To get around the static nature of method getPrintWriter, have an
1:6ac5160:         //anonymous class implement PrivilegedExceptionAction. That class will 
1:6ac5160:         //do the work related to PrintWriter in it's run method and return 
1:6ac5160:         //PrintWriter object.
1:6ac5160:         try {
1:6ac5160:             printWriter = AccessController.doPrivileged(
1:6ac5160:                 new PrivilegedExceptionAction<PrintWriter>(){
1:6ac5160:                     public PrintWriter run() throws IOException {
1:6ac5160:                         String fileCanonicalPath =
1:6ac5160:                             new File(fileName).getCanonicalPath();
1:6ac5160:                         return new PrintWriter(
1:6ac5160:                                 new BufferedOutputStream(
1:6ac5160:                                         new FileOutputStream(
1:6ac5160:                                                 fileCanonicalPath, fileAppend), 4096), true);
1:4e0e1f1:                         }
1:6ac5160:                     });
1:6ac5160:         } catch (PrivilegedActionException pae) {
1:6ac5160:             throw new SqlException(null, 
1:6ac5160:                 new ClientMessageId(SQLState.UNABLE_TO_OPEN_FILE),
1:6ac5160:                 new Object[] { fileName, pae.getMessage() },
1:6ac5160:                 pae);
2:6ac5160:         }
1:6ac5160:         return printWriter;
1:6ac5160:     }
1:4e0e1f1:     
1:7863d83:     private static boolean parseBoolean(
1:7863d83:         String boolString, boolean defaultBool) {
1:7863d83: 
1:7863d83:         if (boolString != null) {
1:7863d83:             return (boolString.equalsIgnoreCase("true") ||
1:7863d83:                     boolString.equalsIgnoreCase("yes"));
1:7863d83:         }
1:7863d83:         return defaultBool;
1:7863d83:     }
1:7863d83: 
1:7863d83:     private static String parseString(String string, String defaultString) {
1:7863d83:         if (string != null) {
1:7863d83:             return string;
1:7863d83:         }
1:7863d83:         return defaultString;
1:7863d83:     }
1:7863d83: 
1:7863d83:     private static int parseInt(String intString, int defaultInt) {
1:7863d83:         if (intString != null) {
1:7863d83:             return Integer.parseInt(intString);
1:7863d83:         }
1:7863d83:         return defaultInt;
1:7863d83:     }
1:7863d83: 
1:7863d83:     // tokenize "property=value;property=value..." and returns new properties
1:7863d83:     //object This method is used both by ClientDriver to parse the url and
1:7863d83:     //ClientDataSource.setConnectionAttributes
1:7863d83:     static Properties tokenizeAttributes(
1:7863d83:         String attributeString, Properties properties) throws SqlException {
1:7863d83: 
1:7863d83:         Properties augmentedProperties;
1:7863d83: 
1:7863d83:         if (attributeString == null) {
1:7863d83:             return properties;
1:7863d83:         }
1:7863d83: 
1:7863d83:         if (properties != null) {
1:7863d83:             augmentedProperties = (Properties) properties.clone();
1:7863d83:         } else {
1:7863d83:             augmentedProperties = new Properties();
1:7863d83:         }
1:7863d83:         try {
1:7863d83:             StringTokenizer attrTokenizer =
1:7863d83:                 new StringTokenizer(attributeString, ";");
1:7863d83: 
1:7863d83:             while (attrTokenizer.hasMoreTokens()) {
1:7863d83:                 String v = attrTokenizer.nextToken();
1:7863d83: 
1:7863d83:                 int eqPos = v.indexOf('=');
1:7863d83:                 if (eqPos == -1) {
1:7863d83:                     throw new SqlException(null,
1:7863d83:                         new ClientMessageId(SQLState.INVALID_ATTRIBUTE_SYNTAX),
1:7863d83:                         attributeString);
1:7863d83:                 }
1:7863d83: 
1:7863d83:                 augmentedProperties.setProperty(
1:7863d83:                     (v.substring(0, eqPos)).trim(),
1:7863d83:                     (v.substring(eqPos + 1)).trim());
1:7863d83:             }
1:7863d83:         } catch (NoSuchElementException e) {
1:7863d83:             // A null log writer is passed, because jdbc 1 sqlexceptions are
1:7863d83:             // automatically traced
1:7863d83:             throw new SqlException(null,
1:7863d83:                 new ClientMessageId(SQLState.INVALID_ATTRIBUTE_SYNTAX),
1:7863d83:                 e, attributeString);
1:7863d83:         }
1:7863d83:         checkBoolean(augmentedProperties,
1:7863d83:                      Attribute.CLIENT_RETIEVE_MESSAGE_TEXT);
1:7863d83:         return augmentedProperties;
1:7863d83: 
1:7863d83:     }
1:7863d83: 
1:7863d83:     private static void checkBoolean(Properties set, String attribute)
1:7863d83:             throws SqlException {
1:7863d83: 
1:7863d83:         final String[] booleanChoices = {"true", "false"};
1:7863d83:         checkEnumeration(set, attribute, booleanChoices);
1:7863d83:     }
1:7863d83: 
1:7863d83: 
1:7863d83:     private static void checkEnumeration(
1:7863d83:         Properties set,
1:7863d83:         String attribute,
1:7863d83:         String[] choices) throws SqlException {
1:7863d83: 
1:7863d83:         String value = set.getProperty(attribute);
1:7863d83:         if (value == null) {
1:7863d83:             return;
1:7863d83:         }
1:7863d83: 
1:7863d83:         for (int i = 0; i < choices.length; i++) {
1:7863d83:             if (value.toUpperCase(Locale.ENGLISH).equals(
1:7863d83:                         choices[i].toUpperCase(Locale.ENGLISH))) {
1:7863d83:                 return;
1:7863d83:             }
1:7863d83:         }
1:7863d83: 
1:7863d83: // The attribute value is invalid. Construct a string giving the choices for
1:7863d83: // display in the error message.
1:7863d83:         String choicesStr = "{";
1:7863d83:         for (int i = 0; i < choices.length; i++) {
1:7863d83:             if (i > 0) {
1:7863d83:                 choicesStr += "|";
1:7863d83:             }
1:7863d83:             choicesStr += choices[i];
1:7863d83:         }
1:7863d83: 
1:7863d83:         throw new SqlException(null,
1:7863d83:             new ClientMessageId(SQLState.INVALID_ATTRIBUTE),
1:7863d83:             attribute, value, choicesStr);
1:7863d83:     }
1:7863d83: 
1:7863d83:     /*
1:7863d83:      * Properties to be seen by Bean - access thru reflection.
1:7863d83:      */
1:7863d83: 
1:b004dff:     // -- Standard JDBC DataSource Properties
1:7863d83: 
1:7863d83:     public synchronized void setDatabaseName(String databaseName) {
1:7863d83:         this.databaseName = databaseName;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public String getDatabaseName() {
1:7863d83:         return this.databaseName;
1:7863d83:     }
1:7863d83: 
1:7863d83: 
1:7863d83:     public synchronized void setDataSourceName(String dataSourceName) {
1:7863d83:         this.dataSourceName = dataSourceName;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public String getDataSourceName() {
1:7863d83:         return this.dataSourceName;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public synchronized void setDescription(String description) {
1:7863d83:         this.description = description;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public String getDescription() {
1:7863d83:         return this.description;
1:7863d83:     }
1:7863d83: 
1:7863d83: 
1:7863d83:     public synchronized void setPortNumber(int portNumber) {
1:7863d83:         this.portNumber = portNumber;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public int getPortNumber() {
1:7863d83:         return this.portNumber;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public synchronized void setServerName(String serverName) {
1:7863d83:         this.serverName = serverName;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public String getServerName() {
1:7863d83:         return this.serverName;
1:7863d83:     }
1:7863d83: 
1:7863d83: 
1:7863d83:     public synchronized void setUser(String user) {
1:7863d83:         this.user = user;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public String getUser() {
1:7863d83:         return this.user;
1:7863d83:     }
1:7863d83: 
1:7863d83:     synchronized public void setRetrieveMessageText(
1:7863d83:         boolean retrieveMessageText) {
1:7863d83: 
1:7863d83:         this.retrieveMessageText = retrieveMessageText;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public boolean getRetrieveMessageText() {
1:7863d83:         return this.retrieveMessageText;
1:7863d83:     }
1:7863d83: 
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Sets the security mechanism.
1:7863d83:      * @param securityMechanism to set
1:7863d83:      */
1:7863d83:     synchronized public void setSecurityMechanism(short securityMechanism) {
1:7863d83:         this.securityMechanism = securityMechanism;
1:7863d83:     }
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Return the security mechanism.
1:7863d83:      * If security mechanism has not been set explicitly on datasource,
1:7863d83:      * then upgrade the security mechanism to a more secure one if possible.
1:7863d83:      * @see #getUpgradedSecurityMechanism(String)
1:7863d83:      * @return the security mechanism
1:7863d83:      */
1:7863d83:     public short getSecurityMechanism() {
1:7863d83:         return getSecurityMechanism(getPassword());
1:7863d83:     }
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Return the security mechanism for this datasource object.
1:7863d83:      * If security mechanism has not been set explicitly on datasource,
1:7863d83:      * then upgrade the security mechanism to a more secure one if possible.
1:7863d83:      * @param password  password of user
1:7863d83:      * @see #getUpgradedSecurityMechanism(String)
1:7863d83:      * @return the security mechanism
1:7863d83:      */
1:7863d83:     public short getSecurityMechanism(String password) {
1:7863d83: 
1:7863d83:         // if security mechanism has not been set explicitly on
1:7863d83:         // datasource, then upgrade the security mechanism if possible
1:7863d83:         // DERBY-962
1:7863d83:         if ( securityMechanism == SECMEC_HAS_NOT_EXPLICITLY_SET ) {
1:7863d83:             return getUpgradedSecurityMechanism(password);
1:7863d83:         }
1:7863d83: 
1:7863d83:         return securityMechanism;
1:7863d83:     }
1:7863d83: 
1:7863d83:     // ----------------------- ssl
1:7863d83: 
1:b004dff:     /**
1:b004dff:      * @serial
1:b004dff:      */
1:7863d83:     private int sslMode;
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Specifies the SSL encryption mode to use.
1:7863d83:      * <p>
1:7863d83:      * Valid values are <tt>off</tt>, <tt>basic</tt> and
1:7863d83:      * <tt>peerAuthentication</tt>.
1:7863d83:      *
1:7863d83:      * @param mode the SSL mode to use (<tt>off</tt>, <tt>basic</tt> or
1:7863d83:      *      <tt>peerAuthentication</tt>)
1:7863d83:      * @throws SqlException if the specified mode is invalid
1:7863d83:      */
1:7863d83:     public void setSsl(String mode)
1:7863d83:         throws SqlException
1:7863d83:     {
1:7863d83:         sslMode = getSSLModeFromString(mode);
1:7863d83:     }
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Returns the SSL encryption mode specified for the data source.
1:7863d83:      *
1:7863d83:      * @return <tt>off</tt>, <tt>basic</tt> or <tt>peerAuthentication</tt>.
1:7863d83:      */
1:7863d83:     public String getSsl() {
1:7863d83:         switch(sslMode) {
1:7863d83:         case SSL_OFF:
1:7863d83:         default:
1:7863d83:             return SSL_OFF_STR;
1:7863d83:         case SSL_BASIC:
1:7863d83:             return SSL_BASIC_STR;
1:7863d83:         case SSL_PEER_AUTHENTICATION:
1:7863d83:             return SSL_PEER_AUTHENTICATION_STR;
1:7863d83:         }
1:7863d83:     }
1:7863d83: 
1:7863d83:     // ----------------------- set/getCreate/ShutdownDatabase -----------------
1:7863d83:     /**
1:7863d83:      * Set to true if the database should be created.
1:b004dff:      * @serial
1:7863d83:      */
1:7863d83:     private boolean createDatabase;
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Set to true if the database should be shutdown.
1:b004dff:      * @serial
1:7863d83:      */
1:7863d83:     private boolean shutdownDatabase;
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Set this property to create a new database.  If this property is not
1:7863d83:      * set, the database (identified by databaseName) is assumed to be already
1:7863d83:      * existing.
1:7863d83:      * @param create if set to the string "create", this data source will try
1:7863d83:      *               to create a new database of databaseName, or boot the
1:7863d83:      *               database if one by that name already exists.
1:7863d83:      *
1:7863d83:      */
1:7863d83:     public void setCreateDatabase(String create) {
1:7863d83:         if (create != null && create.equalsIgnoreCase("create")) {
1:7863d83:             this.createDatabase = true;
1:7863d83:         } else { // reset
1:7863d83:             this.createDatabase = false;
1:7863d83:         }
1:7863d83:     }
1:7863d83: 
1:7863d83:     /** @return "create" if create is set, or null if not
1:7863d83:      */
1:7863d83:     public String getCreateDatabase() {
1:7863d83:         String createstr=null;
1:7863d83:         if (createDatabase) {
1:7863d83:             createstr="create";
1:7863d83:         }
1:7863d83:         return createstr;
1:7863d83:     }
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Set this property if one wishes to shutdown the database identified by
1:7863d83:      * databaseName.
1:7863d83:      * @param shutdown if set to the string "shutdown", this data source will
1:7863d83:      *                 shutdown the database if it is running.
1:7863d83:      *
1:7863d83:      */
1:7863d83:     public void setShutdownDatabase(String shutdown) {
1:7863d83:         if (shutdown != null && shutdown.equalsIgnoreCase("shutdown")) {
1:7863d83:             this.shutdownDatabase = true;
1:7863d83:         } else { // reset
1:7863d83:             this.shutdownDatabase = false;
1:7863d83:         }
1:7863d83:     }
1:7863d83: 
1:7863d83:     /** @return "shutdown" if shutdown is set, or null if not
1:7863d83:      */
1:7863d83:     public String getShutdownDatabase() {
1:7863d83:         String shutdownstr=null;
1:7863d83:         if (shutdownDatabase)
1:7863d83:         {
1:7863d83:             shutdownstr = "shutdown";
1:7863d83:         }
1:7863d83:         return shutdownstr;
1:7863d83:     }
1:7863d83: 
1:b004dff:     /**
1:b004dff:      * @serial
1:b004dff:      */
1:7863d83:     private String connectionAttributes = null;
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Set this property to pass in more Derby specific connection URL
1:7863d83:      * attributes.
1:7863d83:      * <BR>
1:7863d83:      * Any attributes that can be set using a property of this DataSource
1:7863d83:      * implementation (e.g user, password) should not be set in
1:7863d83:      * connectionAttributes. Conflicting settings in connectionAttributes and
1:7863d83:      * properties of the DataSource will lead to unexpected behaviour.
1:7863d83:      *
1:7863d83:      * @param prop set to the list of Derby connection attributes separated by
1:7863d83:      *    semi-colons.  E.g., to specify an encryption bootPassword
1:7863d83:      *    of "x8hhk2adf", and set upgrade to true, do the following:
1:7863d83:      * <br>
1:7863d83:      * {@code
1:7863d83:      *  ds.setConnectionAttributes("bootPassword=x8hhk2adf;upgrade=true");}
1:7863d83:      *
1:7863d83:      * See Derby documentation for complete list.
1:7863d83:      */
1:7863d83:     public void setConnectionAttributes(String prop) {
1:7863d83:         connectionAttributes = prop;
1:7863d83:     }
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * @return Derby specific connection URL attributes
1:7863d83:      */
1:7863d83:     public String getConnectionAttributes() {
1:7863d83:         return connectionAttributes;
1:7863d83:     }
1:7863d83: 
1:7863d83: 
1:4e0e1f1:     /**
1:7863d83:      * @serial
1:4e0e1f1:      */
1:7863d83:     private int traceLevel = propertyDefault_traceLevel;
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Check if derby.client.traceLevel is provided as a JVM property.
1:7863d83:      * If yes, then we use that value. If not, then we look for traceLevel
1:7863d83:      * in the the properties parameter.
1:7863d83:      *
1:7863d83:      * @param properties jdbc url properties
1:7863d83:      * @return value of traceLevel property
1:7863d83:      */
1:7863d83:     static int getTraceLevel(Properties properties) {
1:7863d83:         String traceLevelString;
1:7863d83:         traceLevelString  =
1:7863d83:             readSystemProperty(Attribute.CLIENT_JVM_PROPERTY_PREFIX +
1:7863d83:                                Attribute.CLIENT_TRACE_LEVEL);
1:7863d83:         if (traceLevelString == null  && properties != null) {
1:7863d83:             traceLevelString =
1:7863d83:                 properties.getProperty(Attribute.CLIENT_TRACE_LEVEL);
1:7863d83:         }
1:7863d83:         if (traceLevelString != null ) {
1:7863d83:             return parseInt(traceLevelString, propertyDefault_traceLevel);
1:7863d83:         } else {
1:7863d83:             return propertyDefault_traceLevel;
1:7863d83:         }
1:7863d83:     }
1:7863d83: 
1:7863d83:     synchronized public void setTraceLevel(int traceLevel) {
1:7863d83:         this.traceLevel = traceLevel;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public int getTraceLevel() {
1:7863d83:         return this.traceLevel;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public synchronized void setTraceFile(String traceFile) {
1:7863d83:         this.traceFile = traceFile;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public String getTraceFile() {
1:7863d83:         return this.traceFile;
1:7863d83:     }
1:7863d83: 
1:7863d83: 
1:7863d83:     public synchronized void setTraceDirectory(String traceDirectory) {
1:7863d83:         this.traceDirectory = traceDirectory;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public String getTraceDirectory() {
1:7863d83:         return this.traceDirectory;
1:7863d83:     }
1:7863d83: 
1:7863d83:     synchronized public void setTraceFileAppend(boolean traceFileAppend) {
1:7863d83:         this.traceFileAppend = traceFileAppend;
1:7863d83:     }
1:7863d83: 
1:7863d83:     public boolean getTraceFileAppend() {
1:7863d83:         return this.traceFileAppend;
1:7863d83:     }
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Returns the maximum number of JDBC prepared statements a connection is
1:7863d83:      * allowed to cache.
1:7863d83:      * <p>
1:7863d83:      * A basic data source will always return zero. If statement caching is
1:7863d83:      * required, use a {@link javax.sql.ConnectionPoolDataSource}.
1:7863d83:      * <p>
1:7863d83:      * This method is used internally by Derby to determine if statement
1:7863d83:      * pooling is to be enabled or not.
1:7863d83:      * Not part of public API, so not present in
1:7863d83:      * {@link org.apache.derby.jdbc.ClientDataSourceInterface}.
1:7863d83:      *
1:7863d83:      * @return Maximum number of statements to cache, or <code>0</code> if
1:7863d83:      *      caching is disabled (default).
1:7863d83:      */
1:7863d83:     public int maxStatementsToPool() {
1:7863d83:         return 0;
1:7863d83:     }
1:7863d83: 
1:7863d83:     // --- private helper methods
1:7863d83: 
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * The dataSource keeps individual fields for the values that are relevant
1:7863d83:      * to the client. These need to be updated when set connection attributes
1:7863d83:      * is called.
1:7863d83:      */
1:7863d83:     private void updateDataSourceValues(Properties prop)
1:7863d83:         throws SqlException
1:7863d83:     {
1:7863d83:         // DERBY-5553. System properties derby.client.traceDirectory
1:7863d83:         // and derby.client.traceLevel do not work for ClientXADataSource
1:7863d83:         // or ClientConnectionPoolDataSource
1:7863d83:         // Trace level and trace directory will be read from system
1:7863d83:         // properties if they are not specified in the Properties
1:7863d83:         // argument, so we check for them first to avoid getting cut
1:7863d83:         // off by the (prop == null) check below.
1:7863d83:         String traceDir = getTraceDirectory(prop);
1:7863d83:         if (traceDir != null) {
1:7863d83:             setTraceDirectory(traceDir);
1:7863d83:         }
1:7863d83:         
1:7863d83:         int traceLevel = getTraceLevel(prop);
1:7863d83:         if (traceLevel != propertyDefault_traceLevel) {
1:7863d83:             setTraceLevel(traceLevel);
1:7863d83:         }
1:7863d83:         if (prop == null) {
1:7863d83:             return;
1:7863d83:         }
1:7863d83: 
1:7863d83:         if (prop.containsKey(Attribute.USERNAME_ATTR)) {
1:7863d83:             setUser(getUser(prop));
1:7863d83:         }
1:7863d83:         if (prop.containsKey(Attribute.CLIENT_SECURITY_MECHANISM)) {
1:7863d83:             setSecurityMechanism(getSecurityMechanism(prop));
1:7863d83:         }
1:7863d83:         if (prop.containsKey(Attribute.CLIENT_TRACE_FILE)) {
1:7863d83:             setTraceFile(getTraceFile(prop));
1:7863d83:         }
1:7863d83:         if (prop.containsKey(Attribute.CLIENT_TRACE_APPEND)) {
1:7863d83:             setTraceFileAppend(getTraceFileAppend(prop));
1:7863d83:         }
1:7863d83:         if (prop.containsKey(Attribute.CLIENT_RETIEVE_MESSAGE_TEXT)) {
1:7863d83:             setRetrieveMessageText(getRetrieveMessageText(prop));
1:7863d83:         }
1:7863d83:         if (prop.containsKey(Attribute.SSL_ATTR)) {
1:7863d83:             sslMode = getClientSSLMode(prop);
1:7863d83:         }
1:7863d83:     }
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Handles common error situations that can happen when trying to
1:7863d83:      * obtain a physical connection to the server, and which require special
1:7863d83:      * handling.
1:7863d83:      * <p>
1:7863d83:      * If this method returns normally, the exception wasn't handled and should
1:7863d83:      * be handled elsewhere or be re-thrown.
1:7863d83:      *
1:7863d83:      * @param logWriter log writer, may be {@code null}
1:7863d83:      * @param sqle exception to handle
1:7863d83:      * @throws SQLException handled exception (if any)
1:7863d83:      */
1:7863d83:     private void handleConnectionException(LogWriter logWriter,
1:7863d83:                                                    SqlException sqle)
1:7863d83:             throws SQLException {
1:7863d83:         // See DERBY-4070
1:7863d83:         if (sqle.getSQLState().equals(
1:7863d83:                 ExceptionUtil.getSQLStateFromIdentifier(
1:7863d83:                     SQLState.INVALID_ATTRIBUTE_SYNTAX))) {
1:7863d83:             // Wrap this in SQLState.MALFORMED_URL exception to be
1:7863d83:             // consistent with the embedded driver.
1:7863d83:             throw new SqlException(logWriter,
1:7863d83:                     new ClientMessageId(SQLState.MALFORMED_URL),
1:7863d83:                     sqle, constructUrl()).getSQLException();
1:7863d83: 
1:7863d83:         }
1:7863d83:     }
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Constructs the JDBC connection URL from the state of the data source.
1:7863d83:      *
1:7863d83:      * @return The JDBC connection URL.
1:7863d83:      */
1:7863d83:     private String constructUrl() {
1:7863d83:         StringBuilder sb = new StringBuilder(64);
1:7863d83:         // To support subSubProtocols, the protocol addition below must be
1:7863d83:         // changed.
1:7863d83:         sb.append(Attribute.DNC_PROTOCOL);
1:7863d83:         sb.append(serverName);
1:7863d83:         sb.append(':');
1:7863d83:         sb.append(portNumber);
1:7863d83:         sb.append('/');
1:7863d83:         sb.append(databaseName);
1:7863d83:         if (connectionAttributes != null) {
1:7863d83:             sb.append(';');
1:7863d83:             sb.append(connectionAttributes);
1:7863d83:         }
1:7863d83:         return sb.toString();
1:7863d83:     }
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Attempt to establish a database connection in a non-pooling,
1:7863d83:      * non-distributed environment.
1:7863d83:      *
1:7863d83:      * @return a Connection to the database
1:7863d83:      *
1:7863d83:      * @throws java.sql.SQLException if a database-access error occurs.
1:7863d83:      */
1:7863d83:     public Connection getConnection() throws SQLException {
1:7863d83:         LogWriter dncLogWriter = null;
1:7863d83:         try {
1:7863d83:             updateDataSourceValues(
1:7863d83:                     tokenizeAttributes(getConnectionAttributes(), null));
1:7863d83:             dncLogWriter = computeDncLogWriterForNewConnection("_sds");
1:7863d83:             return getConnectionX(dncLogWriter, getUser(), getPassword());
1:7863d83:         } catch (SqlException se) {
1:7863d83:             // The method below may throw an exception.
1:7863d83:             handleConnectionException(dncLogWriter, se);
1:7863d83:             // If the exception wasn't handled so far, re-throw it.
1:7863d83:             throw se.getSQLException();
1:7863d83:         }
1:7863d83:     }
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Attempt to establish a database connection in a non-pooling,
1:7863d83:      * non-distributed environment.
1:7863d83:      *
1:7863d83:      * @param user the database user on whose behalf the Connection is being
1:7863d83:      *        made
1:7863d83:      * @param password the user's password
1:7863d83:      *
1:7863d83:      * @return a Connection to the database
1:7863d83:      *
1:7863d83:      * @throws java.sql.SQLException if a database-access error occurs.
1:7863d83:      */
1:7863d83:     public Connection getConnection(String user, String password)
1:7863d83:             throws SQLException {
1:7863d83:         // Jdbc 2 connections will write driver trace info on a
1:7863d83:         // datasource-wide basis using the jdbc 2 data source log writer.
1:7863d83:         // This log writer may be narrowed to the connection-level
1:7863d83:         // This log writer will be passed to the agent constructor.
1:7863d83: 
1:7863d83:         LogWriter dncLogWriter = null;
1:7863d83:         try
1:7863d83:         {
1:7863d83:             updateDataSourceValues(
1:7863d83:                     tokenizeAttributes(getConnectionAttributes(), null));
1:7863d83:             dncLogWriter = computeDncLogWriterForNewConnection("_sds");
1:7863d83:             return getConnectionX(dncLogWriter, user, password);
1:7863d83:         }
1:7863d83:         catch(SqlException se)
1:7863d83:         {
1:7863d83:             // The method below may throw an exception.
1:7863d83:             handleConnectionException(dncLogWriter, se);
1:7863d83:             // If the exception wasn't handled so far, re-throw it.
1:7863d83:             throw se.getSQLException();
1:7863d83:         }
1:7863d83: 
1:7863d83:     }
1:7863d83: 
1:7863d83:     private Connection getConnectionX(LogWriter dncLogWriter,
1:7863d83:                                       String user, String password)
1:7863d83:             throws SqlException {
1:7863d83:         return ClientDriver.getFactory().newNetConnection(
1:7863d83:                 dncLogWriter, user, password, this, -1, false);
1:7863d83: 
1:7863d83:     }
1:7863d83: 
1:7863d83:     // JDBC 4.0 java.sql.Wrapper interface methods
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Check whether this instance wraps an object that implements the
1:7863d83:      * interface specified by {@code iface}.
1:7863d83:      *
1:7863d83:      * @param iface a class defining an interface
1:7863d83:      * @return {@code true} if this instance implements {@code iface}, or
1:7863d83:      * {@code false} otherwise
1:7863d83:      * @throws SQLException if an error occurs while determining if this
1:7863d83:      * instance implements {@code iface}
1:7863d83:      */
1:7863d83:     public boolean isWrapperFor(Class<?> iface) throws SQLException {
1:7863d83:         return iface.isInstance(this);
1:7863d83:     }
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Returns {@code this} if this class implements the specified interface.
1:7863d83:      *
1:7863d83:      * @param  iface a class defining an interface
1:7863d83:      * @return an object that implements the interface
1:7863d83:      * @throws SQLException if no object is found that implements the
1:7863d83:      * interface
1:7863d83:      */
1:7863d83:     public <T> T unwrap(Class<T> iface) throws SQLException {
1:7863d83:         try {
1:7863d83:             return iface.cast(this);
1:7863d83:         } catch (ClassCastException cce) {
1:7863d83:             throw new SqlException(null,
1:7863d83:                     new ClientMessageId(SQLState.UNABLE_TO_UNWRAP),
1:7863d83:                     iface).getSQLException();
1:7863d83:         }
1:7863d83:     }
1:7863d83: 
1:7863d83:     ////////////////////////////////////////////////////////////////////
1:7863d83:     //
1:7863d83:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:7863d83:     //
1:7863d83:     ////////////////////////////////////////////////////////////////////
1:7863d83: 
1:7863d83:     public Logger getParentLogger()
1:7863d83:             throws SQLFeatureNotSupportedException {
1:7863d83:         throw SQLExceptionFactory.notImplemented("getParentLogger");
1:7863d83:     }
1:7863d83: 
1:7863d83:     // Helper methods
1:7863d83: 
1:7863d83:     protected final PooledConnection getPooledConnectionMinion()
1:7863d83:             throws SQLException {
1:7863d83:         LogWriter dncLogWriter = null;
1:7863d83: 
1:7863d83:         try {
1:7863d83:             updateDataSourceValues(
1:7863d83:                     tokenizeAttributes(getConnectionAttributes(), null));
1:7863d83:             dncLogWriter = computeDncLogWriterForNewConnection("_cpds");
1:7863d83: 
1:7863d83:             if (dncLogWriter != null) {
1:7863d83:                 dncLogWriter.traceEntry(this, "getPooledConnection");
1:7863d83:             }
1:7863d83: 
1:7863d83:             PooledConnection pooledConnection = getPooledConnectionX(
1:7863d83:                     dncLogWriter, this, getUser(), getPassword());
1:7863d83: 
1:7863d83:             if (dncLogWriter != null) {
1:7863d83:                 dncLogWriter.traceExit(
1:7863d83:                         this, "getPooledConnection", pooledConnection);
1:7863d83:             }
1:7863d83: 
1:7863d83:             return pooledConnection;
1:7863d83:         }
1:7863d83:         catch (SqlException se) {
1:7863d83:             // The method below may throw an exception.
1:7863d83:             handleConnectionException(dncLogWriter, se);
1:7863d83:             // If the exception wasn't handled so far, re-throw it.
1:7863d83:             throw se.getSQLException();
1:7863d83:         }
1:7863d83:     }
1:7863d83: 
1:7863d83:     protected final PooledConnection getPooledConnectionMinion(
1:7863d83:             String user, String password) throws SQLException {
1:7863d83: 
1:7863d83:         LogWriter dncLogWriter = null;
1:7863d83: 
1:7863d83:         try {
1:7863d83:             updateDataSourceValues(
1:7863d83:                     tokenizeAttributes(getConnectionAttributes(), null));
1:7863d83:             dncLogWriter = computeDncLogWriterForNewConnection("_cpds");
1:7863d83: 
1:7863d83:             if (dncLogWriter != null) {
1:7863d83:                 dncLogWriter.traceEntry(
1:7863d83:                         this, "getPooledConnection", user, "<escaped>");
1:7863d83:             }
1:7863d83: 
1:7863d83:             PooledConnection pooledConnection = getPooledConnectionX(
1:7863d83:                     dncLogWriter, this, user, password);
1:7863d83: 
1:7863d83:             if (dncLogWriter != null) {
1:7863d83:                 dncLogWriter.traceExit(
1:7863d83:                         this, "getPooledConnection", pooledConnection);
1:7863d83:             }
1:7863d83: 
1:7863d83:             return pooledConnection;
1:7863d83: 
1:7863d83:         } catch (SqlException se) {
1:7863d83:             // The method below may throw an exception.
1:7863d83:             handleConnectionException(dncLogWriter, se);
1:7863d83:             // If the exception wasn't handled so far, re-throw it.
1:7863d83:             throw se.getSQLException();
1:7863d83:         }
1:7863d83:     }
1:7863d83: 
1:7863d83:     // Minion method that establishes the initial physical connection
1:7863d83:     // using DS properties instead of CPDS properties.
1:7863d83:     private static PooledConnection getPooledConnectionX(
1:7863d83:             LogWriter dncLogWriter,
1:7863d83:             BasicClientDataSource40 ds,
1:7863d83:             String user,
1:7863d83:             String password) throws SQLException {
1:7863d83: 
1:7863d83:             return ClientDriver.getFactory().newClientPooledConnection(ds,
1:7863d83:                     dncLogWriter, user, password);
1:7863d83:     }
1:7863d83: 
1:7863d83:     protected final XAConnection getXAConnectionMinion() throws SQLException {
1:7863d83:         LogWriter dncLogWriter = null;
1:7863d83:         try {
1:7863d83:             updateDataSourceValues(
1:7863d83:                     tokenizeAttributes(getConnectionAttributes(), null));
1:7863d83:             dncLogWriter = computeDncLogWriterForNewConnection("_xads");
1:7863d83:             return getXAConnectionX(
1:7863d83:                     dncLogWriter, this, getUser(), getPassword());
1:7863d83:         } catch (SqlException se) {
1:7863d83:             // The method below may throw an exception.
1:7863d83:             handleConnectionException(dncLogWriter, se);
1:7863d83:             // If the exception wasn't handled so far, re-throw it.
1:7863d83:             throw se.getSQLException();
1:7863d83:         }
1:7863d83:     }
1:7863d83: 
1:7863d83:     protected final XAConnection getXAConnectionMinion(
1:7863d83:             String user, String password) throws SQLException {
1:7863d83: 
1:7863d83:         LogWriter dncLogWriter = null;
1:7863d83:         try
1:7863d83:         {
1:7863d83:             updateDataSourceValues(
1:7863d83:                     tokenizeAttributes(getConnectionAttributes(), null));
1:7863d83:             dncLogWriter = computeDncLogWriterForNewConnection("_xads");
1:7863d83:             return getXAConnectionX(dncLogWriter, this, user, password);
1:7863d83:         }
1:7863d83:         catch ( SqlException se )
1:7863d83:         {
1:7863d83:             // The method below may throw an exception.
1:7863d83:             handleConnectionException(dncLogWriter, se);
1:7863d83:             // If the exception wasn't handled so far, re-throw it.
1:7863d83:             throw se.getSQLException();
1:7863d83:         }
1:7863d83:     }
1:7863d83: 
1:7863d83:     /**
1:7863d83:      * Method that establishes the initial physical connection
1:7863d83:      * using DS properties instead of CPDS properties.
1:7863d83:      */
1:7863d83:     private static XAConnection getXAConnectionX(LogWriter dncLogWriter,
1:7863d83:         BasicClientDataSource40 ds, String user, String password)
1:7863d83:         throws SQLException
1:7863d83:     {
1:7863d83:         return ClientDriver.getFactory().newClientXAConnection(ds,
1:7863d83:                 dncLogWriter, user, password);
1:7863d83:     }
1:7863d83: 
1:7863d83:     public static Properties getProperties(BasicClientDataSource40 ths) {
1:7863d83:         Properties properties = new Properties();
1:7863d83: 
1:7863d83:         // Look for all the getXXX methods in the class that take no arguments.
1:7863d83:         Method[] methods = ths.getClass().getMethods();
1:7863d83: 
1:7863d83:         for (int i = 0; i < methods.length; i++) {
1:7863d83: 
1:7863d83:             Method m = methods[i];
1:7863d83: 
1:7863d83:             // only look for simple getter methods.
1:7863d83:             if (m.getParameterTypes().length != 0) {
1:7863d83:                 continue;
1:7863d83:             }
1:7863d83: 
1:7863d83:             // only non-static methods
1:7863d83:             if (Modifier.isStatic(m.getModifiers())) {
1:7863d83:                 continue;
1:7863d83:             }
1:7863d83: 
1:7863d83:             // Only getXXX methods
1:7863d83:             String methodName = m.getName();
1:7863d83:             if ((methodName.length() < 5) || !methodName.startsWith("get")) {
1:7863d83:                 continue;
1:7863d83:             }
1:7863d83: 
1:7863d83:             Class returnType = m.getReturnType();
1:7863d83: 
1:7863d83:             if (Integer.TYPE.equals(returnType)
1:7863d83:                     || Short.TYPE.equals(returnType)
1:7863d83:                     || String.class.equals(returnType)
1:7863d83:                     || Boolean.TYPE.equals(returnType)) {
1:7863d83: 
1:7863d83:                 // E.g. "getSomeProperty"
1:7863d83:                 //          s                 to lower case (3,4)
1:7863d83:                 //           omeProperty      use as is (4->)
1:7863d83:                 String propertyName = methodName.substring(3, 4).toLowerCase(
1:7863d83:                         Locale.ENGLISH).concat(
1:7863d83:                         methodName.substring(4));
1:7863d83: 
1:7863d83:                 try {
1:7863d83:                     Object ov = m.invoke(ths, (Object[])null);
1:7863d83:                     // Need to check if property value is null, otherwise
1:7863d83:                     // "null" string gets stored.
1:7863d83:                     if (ov != null) {
1:7863d83:                         properties.setProperty(propertyName, ov.toString());
1:7863d83:                     }
1:7863d83:                 } catch (IllegalAccessException iae) {
1:7863d83:                 } catch (InvocationTargetException ite) {
1:7863d83:                 }
1:7863d83: 
1:7863d83:             }
1:7863d83:         }
1:7863d83: 
1:7863d83:         return properties;
1:7863d83:     }
1:4e0e1f1: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:e5b33f3
/////////////////////////////////////////////////////////////////////////
1:      * Read the value of the passed system property. If we are running under
1:      * the Java security manager and permission to read the property is 
1:      * missing,a null is returned, and no diagnostic is given (DERBY-6620).
1:      * 
/////////////////////////////////////////////////////////////////////////
1:                         // See also the discussion in DERBY-6620 on why we do
1:                         // not write a warning message on the console here.
commit:b004dff
/////////////////////////////////////////////////////////////////////////
1:  * <p/>
1:  *  * The standard attributes provided are, cf. e.g. table
1:  * 9.1 in the JDBC 4.2 specification.
1:  * <ul>
1:  *   <li>databaseName</li>
1:  *   <li>dataSourceName</li>
1:  *   <li>description</li>
1:  *   <li>password</li>
1:  *   <li>user</li>
1:  * </ul>
1:  * These standard attributes are not supported:
1:  * <ul>
1:  *   <li>networkProtocol</li>
1:  *   <li>roleName</li>
1:  * </ul>
1:  * The Derby client driver also supports these attributes:
1:  * <ul>
1:  *   <li>loginTimeout</li> @see javax.sql.CommonDataSource set/get
1:  *   <li>logWriter</li> @see javax.sql.CommonDataSource set/get
1:  *   <li>createDatabase</li>
1:  *   <li>connectionAttributes</li>
1:  *   <li>shutdownDatabase</li>
1:  *   <li>attributesAsPassword</li>
1:  *   <li>retrieveMessageText</li>
1:  *   <li>securityMechanism</li>
1:  *   <li>traceDirectory</li>
1:  *   <li>traceFile</li>
1:  *   <li>traceFileAppend</li>
1:  *   <li>traceLevel<li>
1:  * </ul>
/////////////////////////////////////////////////////////////////////////
1:     // ---------------------------- loginTimeout ------------------------------
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Stores the relational database name, RDBNAME.
1:      * The length of the database name may be limited to 18 bytes
1:      * and therefore may throw an SQLException.
1:      * @serial
1:      */
1:     
1:     /**
1:      * A description of this data source.
1:      * @serial
1:      */
1:     
1:     /**
1:      * A data source name;
1:      * used to name an underlying XADataSource,
1:      * or ConnectionPoolDataSource when pooling of connections is done.
1:      * @serial
1:      */
1: 
1:     /**
1:      * @serial
1:      */
1:     
1:     /**
1:      * @serial 
1:      */
1:     private String serverName = propertyDefault_serverName; // Derby-410 fix.
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * This property can be overwritten by specifing the
1:      * username parameter on the DataSource.getConnection() method
1:      * call.  If user is specified, then password must also be
1:      * specified, either in the data source object or provided on
1:      * the DataSource.getConnection() call.
1:      *
1:      * Each data source implementation subclass will maintain it's own
1:      * <code>password</code> property.  This password property may or may not
1:      * be declared transient, and therefore may be serialized to a file in
1:      * clear-text, care must taken by the user to prevent security breaches.
1:      * Derby-406 fix
1:      * 
1:      * @serial
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Security Mechanism can be specified explicitly either when obtaining a
1:      * connection via a DriverManager or via Datasource.
1:      * Via DriverManager, securityMechanism can be set on the connection
1:      * request using the 'securityMechanism' attribute.
1:      * Via DataSource, securityMechanism can be set by calling
1:      * setSecurityMechanism() on the ClientDataSource
1:      * If the security mechanism is not explicitly set as mentioned above, in
1:      * that case the Client will try to upgrade the security mechanism to a
1:      * more secure one, if possible.
1:      * See {@link #getUpgradedSecurityMechanism}.
1:      * Therefore, need to keep track if the securityMechanism has been
1:      * explicitly set.
1:      *
1:      * @serial
1:      */
1:     
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @serial
1:      */
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @serial
1:      */
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @serial
1:      */
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @serial
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @serial
1:      */
/////////////////////////////////////////////////////////////////////////
1:     // -- Standard JDBC DataSource Properties
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @serial
1:      */
/////////////////////////////////////////////////////////////////////////
1:      * @serial
1:      * @serial
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @serial
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @serial
1:      */
commit:7863d83
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
1: import java.io.PrintWriter;
1: import java.io.Serializable;
1: import java.lang.reflect.InvocationTargetException;
1: import java.lang.reflect.Method;
1: import java.lang.reflect.Modifier;
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import java.sql.Connection;
1: import java.sql.SQLException;
1: import java.sql.SQLFeatureNotSupportedException;
1: import java.util.Locale;
1: import java.util.NoSuchElementException;
1: import java.util.Properties;
1: import java.util.StringTokenizer;
1: import java.util.logging.Logger;
1: import javax.sql.PooledConnection;
1: import javax.sql.XAConnection;
1: import org.apache.derby.client.am.ClientMessageId;
1: import org.apache.derby.client.am.EncryptionManager;
1: import org.apache.derby.client.am.LogWriter;
1: import org.apache.derby.client.am.SQLExceptionFactory;
1: import org.apache.derby.client.am.SqlException;
1: import org.apache.derby.client.net.NetConfiguration;
1: import org.apache.derby.client.net.NetLogWriter;
1: import org.apache.derby.shared.common.error.ExceptionUtil;
1: import org.apache.derby.shared.common.reference.Attribute;
1: import org.apache.derby.shared.common.reference.SQLState;
1:  * This data source is suitable for client/server use of Derby,
1: @SuppressWarnings("ResultOfObjectAllocationIgnored")
1: public class BasicClientDataSource40 
1:     implements DataSource, ClientDataSourceInterface, Serializable {
1:     // ---------------------------- traceLevel -------------------------------
1:     //
1: 
1:     /**
1:      * The client server protocol can be traced. The constants below define the
1:      * tracing level, cf. the documentation section "Network Client Tracing" in
1:      * the "Derby Server and Administration Guide". Cf. the connection
1:      * attribute (or data source bean property) {@code traceLevel}.
1:      *
1:      * <pre>
1:      * TRACE_NONE	
1:      * TRACE_CONNECTION_CALLS	
1:      * TRACE_STATEMENT_CALLS	
1:      * TRACE_RESULT_SET_CALLS	
1:      * TRACE _DRIVER_CONFIGURATION	
1:      * TRACE_CONNECTS	
1:      * TRACE_PROTOCOL_FLOWS	
1:      * TRACE _RESULT_SET_META_DATA	
1:      * TRACE _PARAMETER_META_DATA	
1:      * TRACE_DIAGNOSTICS	
1:      * TRACE_XA_CALLS	
1:      * TRACE_ALL	
1:      * </pre>
1:      */
1:     public final static int TRACE_NONE = 0x0;
1:     /**
1:      * See documentation at {@link #TRACE_NONE}.
1:      */
1:     public final static int TRACE_CONNECTION_CALLS = 0x1;
1:     /**
1:      * See documentation at {@link #TRACE_NONE}.
1:      */
1:     public final static int TRACE_STATEMENT_CALLS = 0x2;
1:     /**
1:      * See documentation at {@link #TRACE_NONE}.
1:      */
1:     public final static int TRACE_RESULT_SET_CALLS = 0x4;
1:     /**
1:      * See documentation at {@link #TRACE_NONE}.
1:      */
1:     /**
1:      * See documentation at {@link #TRACE_NONE}.
1:      */
1:     public final static int TRACE_DRIVER_CONFIGURATION = 0x10;
1:     /**
1:      * See documentation at {@link #TRACE_NONE}.
1:      */
1:     public final static int TRACE_CONNECTS = 0x20;
1:     /**
1:      * See documentation at {@link #TRACE_NONE}.
1:      */
1:     public final static int TRACE_PROTOCOL_FLOWS = 0x40;
1:     /**
1:      * See documentation at {@link #TRACE_NONE}.
1:      */
1:     public final static int TRACE_RESULT_SET_META_DATA = 0x80;
1:     /**
1:      * See documentation at {@link #TRACE_NONE}.
1:      */
1:     public final static int TRACE_PARAMETER_META_DATA = 0x100;
1:     /**
1:      * See documentation at {@link #TRACE_NONE}.
1:      */
1:     public final static int TRACE_DIAGNOSTICS = 0x200;
1:     /**
1:      * See documentation at {@link #TRACE_NONE}.
1:      */
1:     public final static int TRACE_XA_CALLS = 0x800;
1:     /**
1:      * See documentation at {@link #TRACE_NONE}.
1:      */
1:     public final static int TRACE_ALL = 0xFFFFFFFF;
1:     /**
1:      * See documentation at {@link #TRACE_NONE}.
1:      */
1:     public final static int propertyDefault_traceLevel = TRACE_ALL;
1: 
1:     static
1:     {
1:         try {
1:             // The EncryptionManager class will instantiate objects of the
1:             // required security algorithms that are needed for EUSRIDPWD An
1:             // exception will be thrown if support is not available in the JCE
1:             // implementation in the JVM in which the client is loaded.
1:             new EncryptionManager(null);
1:         } catch(Exception e) {
1:             // if an exception is thrown, ignore exception.
1:         }
1: 
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * The source security mechanism to use when connecting to a client data
1:      * source.
1:      * <p/>
1:      * Security mechanism options are:
1:      * <ul>
1:      *   <li> USER_ONLY_SECURITY
1:      *   <li> CLEAR_TEXT_PASSWORD_SECURITY
1:      *   <li> ENCRYPTED_PASSWORD_SECURITY
1:      *   <li> ENCRYPTED_USER_AND_PASSWORD_SECURITY - both password and
1:      *        user are encrypted
1:      *   <li> STRONG_PASSWORD_SUBSTITUTE_SECURITY
1:      * </ul> The default security mechanism is USER_ONLY SECURITY
1:      * <p/>
1:      * If the application specifies a security mechanism then it will be the
1:      * only one attempted. If the specified security mechanism is not
1:      * supported by the conversation then an exception will be thrown and
1:      * there will be no additional retries.
1:      * <p/>
1:      * Both user and password need to be set for all security mechanism except
1:      * USER_ONLY_SECURITY.
1:      */
1:     public final static short USER_ONLY_SECURITY =
1:         ClientDataSourceInterface.USER_ONLY_SECURITY;
1: 
1:     /**
1:      * See documentation at {@link #USER_ONLY_SECURITY}
1:      */
1:     public final static short CLEAR_TEXT_PASSWORD_SECURITY =
1:         ClientDataSourceInterface.CLEAR_TEXT_PASSWORD_SECURITY;
1: 
1:     /**
1:      * See documentation at {@link #USER_ONLY_SECURITY}
1:      */
1:     public final static short ENCRYPTED_PASSWORD_SECURITY =
1:         ClientDataSourceInterface.ENCRYPTED_PASSWORD_SECURITY;
1: 
1:     /**
1:      * See documentation at {@link #USER_ONLY_SECURITY}
1:      */
1:     public final static short ENCRYPTED_USER_AND_PASSWORD_SECURITY =
1:         ClientDataSourceInterface.ENCRYPTED_USER_AND_PASSWORD_SECURITY;
1: 
1:     /**
1:      * See documentation at {@link #USER_ONLY_SECURITY}
1:      */
1:     public final static short STRONG_PASSWORD_SUBSTITUTE_SECURITY =
1:         ClientDataSourceInterface.STRONG_PASSWORD_SUBSTITUTE_SECURITY;
1: 
1:     // The loginTimeout jdbc 2 data source property is not supported as a jdbc
1:     // 1 connection property, because loginTimeout is set by the jdbc 1 api
1:     // via java.sql.DriverManager.setLoginTimeout().  The databaseName,
1:     // serverName, and portNumber data source properties are also not
1:     // supported as connection properties because they are extracted from the
1:     // jdbc 1 database url passed on the connection request.  However, all
1:     // other data source properties should probably also be supported as
1:     // connection properties.
1: 
0:         // ---------------------------- loginTimeout ------------------------------
1:     //
1:     // was serialized in 1.0 release
1:     /**
1:      * The time in seconds to wait for a connection request on this data
1:      * source. The default value of zero indicates that either the system time
1:      * out be used or no timeout limit.
1:      *
1:      * @serial
1:      */
1:     private int loginTimeout;
1: 
1:     public synchronized void setLoginTimeout(int seconds) {
1:         this.loginTimeout = seconds;
1:     }
1: 
1:     public int getLoginTimeout() {
1:         return this.loginTimeout;
1:     }
1: 
1:     // ---------------------------- logWriter --------------------------------
1:     //
1:     /**
1:      * The log writer is declared transient, and is not serialized or stored
1:      * under JNDI.
1:      *
1:      * @see #traceLevel
1:      */
1:     private transient PrintWriter logWriter;
1: 
1:     public synchronized void setLogWriter(PrintWriter logWriter) {
1:         this.logWriter = logWriter;
1:     }
1: 
1:     public PrintWriter getLogWriter() {
1:         return this.logWriter;
1:     }
1: 
1:     // ---------------------------- databaseName ------------------------------
1:     //
0:     // Stores the relational database name, RDBNAME.
0:     // The length of the database name may be limited to 18 bytes
0:     // and therefore may throw an SQLException.
1:     //
1:     //
1:     private String databaseName;
1: 
1:     // databaseName is not permitted in a properties object
1: 
1: 
1:     // ---------------------------- description ------------------------------
0:     // A description of this data source.
1:     private String description;
1: 
1:     // ---------------------------- dataSourceName ----------------------------
1:     //
0:     // A data source name;
0:     // used to name an underlying XADataSource,
0:     // or ConnectionPoolDataSource when pooling of connections is done.
1:     //
1:     private String dataSourceName;
1: 
1:     // ---------------------------- portNumber --------------------------------
1:     //
1:     private int portNumber = propertyDefault_portNumber;
1: 
1:     // ---------------------------- serverName --------------------------------
1:     //
0:     // Derby-410 fix.
0:     private String serverName = propertyDefault_serverName;
1: 
1:     // serverName is not permitted in a properties object
1: 
1:     //---------------------- client SSL ----------------
1: 
1:     /** The constant indicating that SSL encryption won't be used. */
1:     public final static int SSL_OFF = 0;
1:     private final static String SSL_OFF_STR = "off";
1:     /** The constant indicating that SSL encryption will be used. */
1:     public final static int SSL_BASIC = 1;
1:     private final static String SSL_BASIC_STR = "basic";
1:     /**
1:      * The constant indicating that SSL encryption with peer authentication
1:      * will be used.
1:      */
1:     public final static int SSL_PEER_AUTHENTICATION = 2;
1:     private final static String SSL_PEER_AUTHENTICATION_STR =
1:             "peerAuthentication";
1: 
1:     /**
1:      * Parses the string and returns the corresponding constant for the SSL
1:      * mode denoted.
1:      * <p>
1:      * Valid values are <tt>off</tt>, <tt>basic</tt> and
1:      * <tt>peerAuthentication</tt>.
1:      *
1:      * @param s string denoting the SSL mode
1:      * @return A constant indicating the SSL mode denoted by the string. If the
1:      *      string is {@code null}, {@link #SSL_OFF} is returned.
1:      * @throws SqlException if the string has an invalid value
1:      */
1:     public static int getSSLModeFromString(String s)
1:         throws SqlException
1:     {
1: 
1:         if (s != null){
1:             if (s.equalsIgnoreCase(SSL_OFF_STR)) {
1:                 return SSL_OFF;
1:             } else if (s.equalsIgnoreCase(SSL_BASIC_STR)) {
1:                 return SSL_BASIC;
1:             } else if (s.equalsIgnoreCase(SSL_PEER_AUTHENTICATION_STR)) {
1:                 return SSL_PEER_AUTHENTICATION;
1:             } else {
1:                 throw new SqlException(null,
1:                         new ClientMessageId(SQLState.INVALID_ATTRIBUTE),
1:                         Attribute.SSL_ATTR, s, SSL_OFF_STR + ", " +
1:                         SSL_BASIC_STR + ", " + SSL_PEER_AUTHENTICATION_STR);
1:             }
1:         } else {
1:             // Default
1:             return SSL_OFF;
1:         }
1:     }
1: 
1:     /**
1:      * Returns the SSL mode specified by the property object.
1:      *
1:      * @param properties data source properties
1:      * @return A constant indicating the SSL mode to use. Defaults to
1:      *      {@link #SSL_OFF} if the SSL attribute isn't specified.
1:      * @throws SqlException if an invalid value for the SSL mode is specified
1:      *      in the property object
1:      */
1:     public static int getClientSSLMode(Properties properties)
1:         throws SqlException
1:     {
1:         return
1:             getSSLModeFromString(properties.getProperty(Attribute.SSL_ATTR));
1:     }
1: 
1:     // ---------------------------- user -----------------------------------
1:     //
0:     // This property can be overwritten by specifing the
0:     // username parameter on the DataSource.getConnection() method
0:     // call.  If user is specified, then password must also be
0:     // specified, either in the data source object or provided on
0:     // the DataSource.getConnection() call.
1:     //
0:     // Each data source implementation subclass will maintain it's own
0:     // <code>password</code> property.  This password property may or may not
0:     // be declared transient, and therefore may be serialized to a file in
0:     // clear-text, care must taken by the user to prevent security breaches.
0:     // Derby-406 fix
1:     private String user = propertyDefault_user;
1: 
1:     public static String getUser(Properties properties) {
1:         String userString = properties.getProperty(Attribute.USERNAME_ATTR);
1:         return parseString(userString, propertyDefault_user);
1:     }
1: 
1:     // ---------------------------- securityMechanism -------------------------
1:     //
1:     // The source security mechanism to use when connecting to this data
1:     // source.
1:     // <p>
1:     // Security mechanism options are:
1:     // <ul>
1:     // <li> USER_ONLY_SECURITY
1:     // <li> CLEAR_TEXT_PASSWORD_SECURITY
1:     // <li> ENCRYPTED_PASSWORD_SECURITY
1:     // <li> ENCRYPTED_USER_AND_PASSWORD_SECURITY - both password and
1:     //      user are encrypted
1:     // <li> STRONG_PASSWORD_SUBSTITUTE_SECURITY
1:     // </ul>
1:     // The default security mechanism is USER_ONLY_SECURITY.
1:     // <p>
1:     // If the application specifies a security
1:     // mechanism then it will be the only one attempted.
1:     // If the specified security mechanism is not supported by the
1:     // conversation then an exception will be thrown and there will be no
1:     // additional retries.
1:     // <p>
1:     // This property is currently only available for the DNC driver.
1:     // <p>
1:     // Both user and password need to be set for all security mechanism except
1:     // USER_ONLY_SECURITY When using USER_ONLY_SECURITY, only the user
1:     // property needs to be specified.
1:     //
1: 
1:     // constant to indicate that the security mechanism has not been
1:     // explicitly set, either on connection request when using DriverManager
1:     // or on the Client DataSource object
1:     private final static short SECMEC_HAS_NOT_EXPLICITLY_SET = 0;
1: 
0:     // Security Mechanism can be specified explicitly either when obtaining a
0:     // connection via a DriverManager or via Datasource.
0:     // Via DriverManager, securityMechanism can be set on the connection
0:     // request using the 'securityMechanism' attribute.
0:     // Via DataSource, securityMechanism can be set by calling
0:     // setSecurityMechanism() on the ClientDataSource
0:     // If the security mechanism is not explicitly set as mentioned above, in
0:     // that case the Client will try to upgrade the security mechanism to a
0:     // more secure one, if possible.
0:     // @see #getUpgradedSecurityMechanism
0:     // Therefore, need to keep track if the securityMechanism has been
0:     // explicitly set
1:     private short securityMechanism = SECMEC_HAS_NOT_EXPLICITLY_SET;
1: 
1: 
1: 
1:     // We use the NET layer constants to avoid a mapping for the NET driver.
1:     /**
1:      * Return security mechanism if it is set, else upgrade the security
1:      * mechanism if possible and return the upgraded security mechanism
1:      * @param properties Look in the properties if securityMechanism is set
1:      *        or not
1:      * if set, return this security mechanism
1:      * @return security mechanism
1:      */
1:     public static short getSecurityMechanism(Properties properties) {
1:         short secmec;
1:         String securityMechanismString =
1:             properties.getProperty(Attribute.CLIENT_SECURITY_MECHANISM);
1: 
1:         if ( securityMechanismString != null )
1:         {
1:             // security mechanism has been set, do not override, but instead
1:             // return the security mechanism that has been set (DERBY-962)
1:             secmec = Short.parseShort(securityMechanismString);
1:         }
1:         else
1:         {
1:             // if securityMechanismString is null, this means that security
1:             // mechanism has not been set explicitly and not available in
1:             // properties. Hence, do an upgrade of security mechanism if
1:             // possible The logic for upgrade of security mechanism uses
1:             // information about if password is available or not, so pass this
1:             // information also.
1:             String passwordString =
1:                 properties.getProperty(Attribute.PASSWORD_ATTR);
1:             secmec = getUpgradedSecurityMechanism(passwordString);
1:         }
1:         return secmec;
1:     }
1: 
1:     /**
1:      * This method has logic to upgrade security mechanism to a better (more
1:      * secure) one if it is possible. Currently derby server only has support
1:      * for USRIDPWD, USRIDONL, EUSRIDPWD and USRSSBPWD (10.2+) - this method
1:      * only considers these possibilities. USRIDPWD, EUSRIDPWD and USRSSBPWD
1:      * require a password, USRIDONL is the only security mechanism which does
1:      * not require password.
1:      * 1. if password is not available, then security mechanism possible is
1:      * USRIDONL
1:      * 2. if password is available,then USRIDPWD is returned.
1:      *
1:      * @param password password argument
1:      * @return upgraded security mechanism if possible
1:      */
1:     private static short getUpgradedSecurityMechanism(String password) {
1:         // if password is null, in that case the only acceptable security
1:         // mechanism is USRIDONL, which is the default security mechanism.
1:         if ( password == null ) {
1:             return propertyDefault_securityMechanism;
1:         }
1: 
1:         // when we have support for more security mechanisms on server
1:         // and client, we should update this upgrade logic to pick
1:         // secure security mechanisms before trying out the USRIDPWD
1: 
1:         /*
1:         // -----------------------
1:         // PLEASE NOTE:
1:         // When DERBY-1517, DERBY-1755 is fixed, there might be a way to use
1:         // EUSRIDPWD when both client and server vm's have support for
1:         // it. Hence the below if statement is commented out.
1:       if (SUPPORTS_EUSRIDPWD)
1:             return (short)NetConfiguration.SECMEC_EUSRIDPWD;
1:         else
1:             // IMPORTANT NOTE:
1:             // --------------
1:             // If DERBY-1517 can be fixed, we should default to
1:             // SECMEC_USRSSBPWD (strong password substitute).
1:             // Until then, connecting with a 10.2+ client to
1:             // a derby server < 10.2, and hence does not support
1:             // SECMEC_USRSSBPWD as a SECMEC, will cause a DRDA protocol
1:             // exception, as described in DERBY-926).
1:             //
1:             // return (short)NetConfiguration.SECMEC_USRSSBPWD;
1:          // ----------------------
1:          */
1:          return (short)NetConfiguration.SECMEC_USRIDPWD;
1: 
1:     }
1: 
1:     // ---------------------------- getServerMessageTextOnGetMessage ---------
1:     //
1:     private boolean retrieveMessageText = propertyDefault_retrieveMessageText;
1: 
1:     public static boolean getRetrieveMessageText(Properties properties) {
1:         String retrieveMessageTextString =
1:             properties.getProperty(Attribute.CLIENT_RETIEVE_MESSAGE_TEXT);
1:         return parseBoolean(
1:             retrieveMessageTextString, propertyDefault_retrieveMessageText);
1:     }
1: 
1:     // ---------------------------- traceFile ---------------------------------
1:     //
1:     private String traceFile;
1: 
1:     static String getTraceFile(Properties properties) {
1:         return properties.getProperty(Attribute.CLIENT_TRACE_FILE);
1:     }
1: 
1:     // ---------------------------- traceDirectory ----------------------------
1:     // For the suffix of the trace file when traceDirectory is enabled.
1:     private transient int traceFileSuffixIndex_ = 0;
1:     //
1:     private String traceDirectory;
1: 
1:     /**
1:      * Check if derby.client.traceDirectory is provided as a JVM property.
1:      * If yes, then we use that value. If not, then we look for traceDirectory
1:      * in the the properties parameter.
1:      *
1:      * @param properties jdbc url properties
1:      * @return value of traceDirectory property
1:      */
1:     static String getTraceDirectory(Properties properties) {
1:         String traceDirectoryString;
1: 
1:         traceDirectoryString  =
1:             readSystemProperty(
1:                 Attribute.CLIENT_JVM_PROPERTY_PREFIX +
1:                 Attribute.CLIENT_TRACE_DIRECTORY);
1: 
1:         if (traceDirectoryString == null  && properties != null) {
1:             return properties.getProperty(Attribute.CLIENT_TRACE_DIRECTORY);
1:         } else {
1:             return traceDirectoryString;
1:         }
1:     }
1: 
1: 
1:     /**
0:      * Read the value of the passed system property.
1:      * @param key name of the system property
1:      * @return value of the system property, null if there is no
1:      *         permission to read the property
1:      */
1:     private static String readSystemProperty(final String key) {
1:         return AccessController.doPrivileged(new PrivilegedAction<String>() {
1:                 public String run() {
1:                     try {
1:                         return System.getProperty(key);
1:                     } catch (SecurityException se) {
1:                         // We do not want the connection to fail if the user
1:                         // does not have permission to read the property, so
1:                         // if a security exception occurs, just return null
1:                         // and continue with the connection.
1:                         return null;
1:                     }
1:                 }
1:             }
1:             );
1:     }
1: 
1:     // ---------------------------- traceFileAppend ---------------------------
1:     //
1:     private boolean traceFileAppend = propertyDefault_traceFileAppend;
1: 
1:     static boolean getTraceFileAppend(Properties properties) {
1:         String traceFileAppendString =
1:             properties.getProperty(Attribute.CLIENT_TRACE_APPEND);
1:         return parseBoolean(
1:             traceFileAppendString, propertyDefault_traceFileAppend);
1:     }
1: 
1:     // ---------------------------- password ----------------------------------
1:     //
1:     // The password property is defined in subclasses, but the method
1:     // getPassword (java.util.Properties properties) is in this class to
1:     // eliminate dependencies on j2ee for connections that go thru the driver
1:     // manager.
1: 
1:     public static String getPassword(Properties properties) {
1:         return properties.getProperty("password");
1:     }
1: 
1:     private String password;
1: 
1:     synchronized public void setPassword(String password) {
1:         this.password = password;
1:     }
1: 
1:     public String getPassword() {
1:         return password;
1:     }
1: 
1: 
1:     // ----------------------supplemental methods------------------------------
1: 
1: 
1:     //---------------------- helper methods -----------------------------------
1: 
1:     // The java.io.PrintWriter overrides the traceFile setting.
1:     // If neither traceFile nor jdbc logWriter are set, then null is returned.
1:     // logWriterInUseSuffix used only for trace directories to indicate whether
1:     // log writer is use is from xads, cpds, sds, ds, driver, config, reset.
1:     private LogWriter computeDncLogWriterForNewConnection(
1:         String logWriterInUseSuffix) throws SqlException {
1: 
1:         return computeDncLogWriterForNewConnection(
1:             logWriter,
1:             traceDirectory,
1:             traceFile,
1:             traceFileAppend,
1:             traceLevel,
1:             logWriterInUseSuffix,
1:             traceFileSuffixIndex_++);
1:     }
1: 
1:     // Called on for connection requests.  The java.io.PrintWriter overrides
1:     // the traceFile setting.  If neither traceFile, nor logWriter, nor
1:     // traceDirectory are set, then null is returned.
1:     static LogWriter computeDncLogWriterForNewConnection(
1:         PrintWriter logWriter,
1:         String traceDirectory,
1:         String traceFile,
1:         boolean traceFileAppend,
1:         int traceLevel,
1:         String logWriterInUseSuffix,
1:         int traceFileSuffixIndex) throws SqlException {
1: 
1:         // compute regular dnc log writer if there is any
1:         LogWriter dncLogWriter = computeDncLogWriter(
1:             logWriter,
1:             traceDirectory,
1:             traceFile,
1:             traceFileAppend,
1:             logWriterInUseSuffix,
1:             traceFileSuffixIndex,
1:             traceLevel);
1: 
1:         return dncLogWriter;
1:     }
1: 
1:     // Compute a DNC log writer before a connection is created.
1:     private static LogWriter computeDncLogWriter(
1:         PrintWriter logWriter,
1:         String traceDirectory,
1:         String traceFile,
1:         boolean traceFileAppend,
1:         String logWriterInUseSuffix,
1:         int traceFileSuffixIndex,
1:         int traceLevel) throws SqlException {
1: 
1:         // Otherwise, the trace file will still be created even TRACE_NONE.
1:         if (traceLevel == TRACE_NONE) {
1:             return null;
1:         }
1: 
1:         PrintWriter printWriter = computePrintWriter(
1:             logWriter,
1:             traceDirectory,
1:             traceFile,
1:             traceFileAppend,
1:             logWriterInUseSuffix,
1:             traceFileSuffixIndex);
1: 
1:         if (printWriter == null) {
1:             return null;
1:         }
1: 
1:         LogWriter dncLogWriter = new NetLogWriter(printWriter, traceLevel);
1:         if (printWriter != logWriter &&
1:                 (traceDirectory != null || traceFile != null))
1:         // When printWriter is an internal trace file and
1:         // traceDirectory is not null, each connection has
1:         // its own trace file and the trace file is not cached,
1:         // so we can close it when DNC log writer is closed.
1:         {
1:             dncLogWriter.printWriterNeedsToBeClosed_ = true;
1:         }
1:         return dncLogWriter;
1:     }
1: 
1:     // This method handles all the override semantics.  The logWriter
1:     // overrides the traceFile, and traceDirectory settings.  If neither
1:     // traceFile, nor logWriter, nor traceDirectory are set, then null is
1:     // returned.
1:     private static PrintWriter computePrintWriter(
1:         PrintWriter logWriter,
1:         String traceDirectory,
1:         String traceFile,
1:         boolean traceFileAppend,
1:         String logWriterInUseSuffix,
1:         int traceFileSuffixIndex) throws SqlException {
1: 
1:         if (logWriter != null)  // java.io.PrintWriter is specified
1:         {
1:             return logWriter;
1:         } else { // check trace file setting.
1:             if (traceDirectory != null) {
1:                 String fileName;
1:                 if (traceFile == null) {
1:                     fileName = traceDirectory + File.separator +
1:                         logWriterInUseSuffix + "_" + traceFileSuffixIndex;
1:                 } else {
1:                     fileName = traceDirectory + File.separator +
1:                         traceFile + logWriterInUseSuffix + "_" +
1:                         traceFileSuffixIndex;
1:                 }
0:                 return LogWriter.getPrintWriter(
1:                     fileName, true); // no file append and not enable caching.
1:             } else if (traceFile != null) {
0:                 return LogWriter.getPrintWriter(traceFile, traceFileAppend);
1:             }
1:         }
1:         return null;
1:     }
1: 
1:     private static boolean parseBoolean(
1:         String boolString, boolean defaultBool) {
1: 
1:         if (boolString != null) {
1:             return (boolString.equalsIgnoreCase("true") ||
1:                     boolString.equalsIgnoreCase("yes"));
1:         }
1:         return defaultBool;
1:     }
1: 
1:     private static String parseString(String string, String defaultString) {
1:         if (string != null) {
1:             return string;
1:         }
1:         return defaultString;
1:     }
1: 
1:     private static int parseInt(String intString, int defaultInt) {
1:         if (intString != null) {
1:             return Integer.parseInt(intString);
1:         }
1:         return defaultInt;
1:     }
1: 
1:     // tokenize "property=value;property=value..." and returns new properties
1:     //object This method is used both by ClientDriver to parse the url and
1:     //ClientDataSource.setConnectionAttributes
1:     static Properties tokenizeAttributes(
1:         String attributeString, Properties properties) throws SqlException {
1: 
1:         Properties augmentedProperties;
1: 
1:         if (attributeString == null) {
1:             return properties;
1:         }
1: 
1:         if (properties != null) {
1:             augmentedProperties = (Properties) properties.clone();
1:         } else {
1:             augmentedProperties = new Properties();
1:         }
1:         try {
1:             StringTokenizer attrTokenizer =
1:                 new StringTokenizer(attributeString, ";");
1: 
1:             while (attrTokenizer.hasMoreTokens()) {
1:                 String v = attrTokenizer.nextToken();
1: 
1:                 int eqPos = v.indexOf('=');
1:                 if (eqPos == -1) {
1:                     throw new SqlException(null,
1:                         new ClientMessageId(SQLState.INVALID_ATTRIBUTE_SYNTAX),
1:                         attributeString);
1:                 }
1: 
1:                 augmentedProperties.setProperty(
1:                     (v.substring(0, eqPos)).trim(),
1:                     (v.substring(eqPos + 1)).trim());
1:             }
1:         } catch (NoSuchElementException e) {
1:             // A null log writer is passed, because jdbc 1 sqlexceptions are
1:             // automatically traced
1:             throw new SqlException(null,
1:                 new ClientMessageId(SQLState.INVALID_ATTRIBUTE_SYNTAX),
1:                 e, attributeString);
1:         }
1:         checkBoolean(augmentedProperties,
1:                      Attribute.CLIENT_RETIEVE_MESSAGE_TEXT);
1:         return augmentedProperties;
1: 
1:     }
1: 
1:     private static void checkBoolean(Properties set, String attribute)
1:             throws SqlException {
1: 
1:         final String[] booleanChoices = {"true", "false"};
1:         checkEnumeration(set, attribute, booleanChoices);
1:     }
1: 
1: 
1:     private static void checkEnumeration(
1:         Properties set,
1:         String attribute,
1:         String[] choices) throws SqlException {
1: 
1:         String value = set.getProperty(attribute);
1:         if (value == null) {
1:             return;
1:         }
1: 
1:         for (int i = 0; i < choices.length; i++) {
1:             if (value.toUpperCase(Locale.ENGLISH).equals(
1:                         choices[i].toUpperCase(Locale.ENGLISH))) {
1:                 return;
1:             }
1:         }
1: 
1: // The attribute value is invalid. Construct a string giving the choices for
1: // display in the error message.
1:         String choicesStr = "{";
1:         for (int i = 0; i < choices.length; i++) {
1:             if (i > 0) {
1:                 choicesStr += "|";
1:             }
1:             choicesStr += choices[i];
1:         }
1: 
1:         throw new SqlException(null,
1:             new ClientMessageId(SQLState.INVALID_ATTRIBUTE),
1:             attribute, value, choicesStr);
1:     }
1: 
1:     /*
1:      * Properties to be seen by Bean - access thru reflection.
1:      */
1: 
0:     // -- Stardard JDBC DataSource Properties
1: 
1:     public synchronized void setDatabaseName(String databaseName) {
1:         this.databaseName = databaseName;
1:     }
1: 
1:     public String getDatabaseName() {
1:         return this.databaseName;
1:     }
1: 
1: 
1:     public synchronized void setDataSourceName(String dataSourceName) {
1:         this.dataSourceName = dataSourceName;
1:     }
1: 
1:     public String getDataSourceName() {
1:         return this.dataSourceName;
1:     }
1: 
1:     public synchronized void setDescription(String description) {
1:         this.description = description;
1:     }
1: 
1:     public String getDescription() {
1:         return this.description;
1:     }
1: 
1: 
1:     public synchronized void setPortNumber(int portNumber) {
1:         this.portNumber = portNumber;
1:     }
1: 
1:     public int getPortNumber() {
1:         return this.portNumber;
1:     }
1: 
1:     public synchronized void setServerName(String serverName) {
1:         this.serverName = serverName;
1:     }
1: 
1:     public String getServerName() {
1:         return this.serverName;
1:     }
1: 
1: 
1:     public synchronized void setUser(String user) {
1:         this.user = user;
1:     }
1: 
1:     public String getUser() {
1:         return this.user;
1:     }
1: 
1:     synchronized public void setRetrieveMessageText(
1:         boolean retrieveMessageText) {
1: 
1:         this.retrieveMessageText = retrieveMessageText;
1:     }
1: 
1:     public boolean getRetrieveMessageText() {
1:         return this.retrieveMessageText;
1:     }
1: 
1: 
1:     /**
1:      * Sets the security mechanism.
1:      * @param securityMechanism to set
1:      */
1:     synchronized public void setSecurityMechanism(short securityMechanism) {
1:         this.securityMechanism = securityMechanism;
1:     }
1: 
1:     /**
1:      * Return the security mechanism.
1:      * If security mechanism has not been set explicitly on datasource,
1:      * then upgrade the security mechanism to a more secure one if possible.
1:      * @see #getUpgradedSecurityMechanism(String)
1:      * @return the security mechanism
1:      */
1:     public short getSecurityMechanism() {
1:         return getSecurityMechanism(getPassword());
1:     }
1: 
1:     /**
1:      * Return the security mechanism for this datasource object.
1:      * If security mechanism has not been set explicitly on datasource,
1:      * then upgrade the security mechanism to a more secure one if possible.
1:      * @param password  password of user
1:      * @see #getUpgradedSecurityMechanism(String)
1:      * @return the security mechanism
1:      */
1:     public short getSecurityMechanism(String password) {
1: 
1:         // if security mechanism has not been set explicitly on
1:         // datasource, then upgrade the security mechanism if possible
1:         // DERBY-962
1:         if ( securityMechanism == SECMEC_HAS_NOT_EXPLICITLY_SET ) {
1:             return getUpgradedSecurityMechanism(password);
1:         }
1: 
1:         return securityMechanism;
1:     }
1: 
1:     // ----------------------- ssl
1: 
1:     private int sslMode;
1: 
1:     /**
1:      * Specifies the SSL encryption mode to use.
1:      * <p>
1:      * Valid values are <tt>off</tt>, <tt>basic</tt> and
1:      * <tt>peerAuthentication</tt>.
1:      *
1:      * @param mode the SSL mode to use (<tt>off</tt>, <tt>basic</tt> or
1:      *      <tt>peerAuthentication</tt>)
1:      * @throws SqlException if the specified mode is invalid
1:      */
1:     public void setSsl(String mode)
1:         throws SqlException
1:     {
1:         sslMode = getSSLModeFromString(mode);
1:     }
1: 
1:     /**
1:      * Returns the SSL encryption mode specified for the data source.
1:      *
1:      * @return <tt>off</tt>, <tt>basic</tt> or <tt>peerAuthentication</tt>.
1:      */
1:     public String getSsl() {
1:         switch(sslMode) {
1:         case SSL_OFF:
1:         default:
1:             return SSL_OFF_STR;
1:         case SSL_BASIC:
1:             return SSL_BASIC_STR;
1:         case SSL_PEER_AUTHENTICATION:
1:             return SSL_PEER_AUTHENTICATION_STR;
1:         }
1:     }
1: 
1:     // ----------------------- set/getCreate/ShutdownDatabase -----------------
1:     /**
1:      * Set to true if the database should be created.
1:      */
1:     private boolean createDatabase;
1: 
1:     /**
1:      * Set to true if the database should be shutdown.
1:      */
1:     private boolean shutdownDatabase;
1: 
1:     /**
1:      * Set this property to create a new database.  If this property is not
1:      * set, the database (identified by databaseName) is assumed to be already
1:      * existing.
1:      * @param create if set to the string "create", this data source will try
1:      *               to create a new database of databaseName, or boot the
1:      *               database if one by that name already exists.
1:      *
1:      */
1:     public void setCreateDatabase(String create) {
1:         if (create != null && create.equalsIgnoreCase("create")) {
1:             this.createDatabase = true;
1:         } else { // reset
1:             this.createDatabase = false;
1:         }
1:     }
1: 
1:     /** @return "create" if create is set, or null if not
1:      */
1:     public String getCreateDatabase() {
1:         String createstr=null;
1:         if (createDatabase) {
1:             createstr="create";
1:         }
1:         return createstr;
1:     }
1: 
1:     /**
1:      * Set this property if one wishes to shutdown the database identified by
1:      * databaseName.
1:      * @param shutdown if set to the string "shutdown", this data source will
1:      *                 shutdown the database if it is running.
1:      *
1:      */
1:     public void setShutdownDatabase(String shutdown) {
1:         if (shutdown != null && shutdown.equalsIgnoreCase("shutdown")) {
1:             this.shutdownDatabase = true;
1:         } else { // reset
1:             this.shutdownDatabase = false;
1:         }
1:     }
1: 
1:     /** @return "shutdown" if shutdown is set, or null if not
1:      */
1:     public String getShutdownDatabase() {
1:         String shutdownstr=null;
1:         if (shutdownDatabase)
1:         {
1:             shutdownstr = "shutdown";
1:         }
1:         return shutdownstr;
1:     }
1: 
1:     private String connectionAttributes = null;
1: 
1:     /**
1:      * Set this property to pass in more Derby specific connection URL
1:      * attributes.
1:      * <BR>
1:      * Any attributes that can be set using a property of this DataSource
1:      * implementation (e.g user, password) should not be set in
1:      * connectionAttributes. Conflicting settings in connectionAttributes and
1:      * properties of the DataSource will lead to unexpected behaviour.
1:      *
1:      * @param prop set to the list of Derby connection attributes separated by
1:      *    semi-colons.  E.g., to specify an encryption bootPassword
1:      *    of "x8hhk2adf", and set upgrade to true, do the following:
1:      * <br>
1:      * {@code
1:      *  ds.setConnectionAttributes("bootPassword=x8hhk2adf;upgrade=true");}
1:      *
1:      * See Derby documentation for complete list.
1:      */
1:     public void setConnectionAttributes(String prop) {
1:         connectionAttributes = prop;
1:     }
1: 
1:     /**
1:      * @return Derby specific connection URL attributes
1:      */
1:     public String getConnectionAttributes() {
1:         return connectionAttributes;
1:     }
1: 
1: 
1: 
1:     private int traceLevel = propertyDefault_traceLevel;
1: 
1:     /**
1:      * Check if derby.client.traceLevel is provided as a JVM property.
1:      * If yes, then we use that value. If not, then we look for traceLevel
1:      * in the the properties parameter.
1:      *
1:      * @param properties jdbc url properties
1:      * @return value of traceLevel property
1:      */
1:     static int getTraceLevel(Properties properties) {
1:         String traceLevelString;
1:         traceLevelString  =
1:             readSystemProperty(Attribute.CLIENT_JVM_PROPERTY_PREFIX +
1:                                Attribute.CLIENT_TRACE_LEVEL);
1:         if (traceLevelString == null  && properties != null) {
1:             traceLevelString =
1:                 properties.getProperty(Attribute.CLIENT_TRACE_LEVEL);
1:         }
1:         if (traceLevelString != null ) {
1:             return parseInt(traceLevelString, propertyDefault_traceLevel);
1:         } else {
1:             return propertyDefault_traceLevel;
1:         }
1:     }
1: 
1:     synchronized public void setTraceLevel(int traceLevel) {
1:         this.traceLevel = traceLevel;
1:     }
1: 
1:     public int getTraceLevel() {
1:         return this.traceLevel;
1:     }
1: 
1:     public synchronized void setTraceFile(String traceFile) {
1:         this.traceFile = traceFile;
1:     }
1: 
1:     public String getTraceFile() {
1:         return this.traceFile;
1:     }
1: 
1: 
1:     public synchronized void setTraceDirectory(String traceDirectory) {
1:         this.traceDirectory = traceDirectory;
1:     }
1: 
1:     public String getTraceDirectory() {
1:         return this.traceDirectory;
1:     }
1: 
1:     synchronized public void setTraceFileAppend(boolean traceFileAppend) {
1:         this.traceFileAppend = traceFileAppend;
1:     }
1: 
1:     public boolean getTraceFileAppend() {
1:         return this.traceFileAppend;
1:     }
1: 
1:     /**
1:      * Returns the maximum number of JDBC prepared statements a connection is
1:      * allowed to cache.
1:      * <p>
1:      * A basic data source will always return zero. If statement caching is
1:      * required, use a {@link javax.sql.ConnectionPoolDataSource}.
1:      * <p>
1:      * This method is used internally by Derby to determine if statement
1:      * pooling is to be enabled or not.
1:      * Not part of public API, so not present in
1:      * {@link org.apache.derby.jdbc.ClientDataSourceInterface}.
1:      *
1:      * @return Maximum number of statements to cache, or <code>0</code> if
1:      *      caching is disabled (default).
1:      */
1:     public int maxStatementsToPool() {
1:         return 0;
1:     }
1: 
1:     // --- private helper methods
1: 
1: 
1:     /**
1:      * The dataSource keeps individual fields for the values that are relevant
1:      * to the client. These need to be updated when set connection attributes
1:      * is called.
1:      */
1:     private void updateDataSourceValues(Properties prop)
1:         throws SqlException
1:     {
1:         // DERBY-5553. System properties derby.client.traceDirectory
1:         // and derby.client.traceLevel do not work for ClientXADataSource
1:         // or ClientConnectionPoolDataSource
1:         // Trace level and trace directory will be read from system
1:         // properties if they are not specified in the Properties
1:         // argument, so we check for them first to avoid getting cut
1:         // off by the (prop == null) check below.
1:         String traceDir = getTraceDirectory(prop);
1:         if (traceDir != null) {
1:             setTraceDirectory(traceDir);
1:         }
1:         
1:         int traceLevel = getTraceLevel(prop);
1:         if (traceLevel != propertyDefault_traceLevel) {
1:             setTraceLevel(traceLevel);
1:         }
1:         if (prop == null) {
1:             return;
1:         }
1: 
1:         if (prop.containsKey(Attribute.USERNAME_ATTR)) {
1:             setUser(getUser(prop));
1:         }
1:         if (prop.containsKey(Attribute.CLIENT_SECURITY_MECHANISM)) {
1:             setSecurityMechanism(getSecurityMechanism(prop));
1:         }
1:         if (prop.containsKey(Attribute.CLIENT_TRACE_FILE)) {
1:             setTraceFile(getTraceFile(prop));
1:         }
1:         if (prop.containsKey(Attribute.CLIENT_TRACE_APPEND)) {
1:             setTraceFileAppend(getTraceFileAppend(prop));
1:         }
1:         if (prop.containsKey(Attribute.CLIENT_RETIEVE_MESSAGE_TEXT)) {
1:             setRetrieveMessageText(getRetrieveMessageText(prop));
1:         }
1:         if (prop.containsKey(Attribute.SSL_ATTR)) {
1:             sslMode = getClientSSLMode(prop);
1:         }
1:     }
1: 
1:     /**
1:      * Handles common error situations that can happen when trying to
1:      * obtain a physical connection to the server, and which require special
1:      * handling.
1:      * <p>
1:      * If this method returns normally, the exception wasn't handled and should
1:      * be handled elsewhere or be re-thrown.
1:      *
1:      * @param logWriter log writer, may be {@code null}
1:      * @param sqle exception to handle
1:      * @throws SQLException handled exception (if any)
1:      */
1:     private void handleConnectionException(LogWriter logWriter,
1:                                                    SqlException sqle)
1:             throws SQLException {
1:         // See DERBY-4070
1:         if (sqle.getSQLState().equals(
1:                 ExceptionUtil.getSQLStateFromIdentifier(
1:                     SQLState.INVALID_ATTRIBUTE_SYNTAX))) {
1:             // Wrap this in SQLState.MALFORMED_URL exception to be
1:             // consistent with the embedded driver.
1:             throw new SqlException(logWriter,
1:                     new ClientMessageId(SQLState.MALFORMED_URL),
1:                     sqle, constructUrl()).getSQLException();
1: 
1:         }
1:     }
1: 
1:     /**
1:      * Constructs the JDBC connection URL from the state of the data source.
1:      *
1:      * @return The JDBC connection URL.
1:      */
1:     private String constructUrl() {
1:         StringBuilder sb = new StringBuilder(64);
1:         // To support subSubProtocols, the protocol addition below must be
1:         // changed.
1:         sb.append(Attribute.DNC_PROTOCOL);
1:         sb.append(serverName);
1:         sb.append(':');
1:         sb.append(portNumber);
1:         sb.append('/');
1:         sb.append(databaseName);
1:         if (connectionAttributes != null) {
1:             sb.append(';');
1:             sb.append(connectionAttributes);
1:         }
1:         return sb.toString();
1:     }
1: 
1:     /**
1:      * Attempt to establish a database connection in a non-pooling,
1:      * non-distributed environment.
1:      *
1:      * @return a Connection to the database
1:      *
1:      * @throws java.sql.SQLException if a database-access error occurs.
1:      */
1:     public Connection getConnection() throws SQLException {
1:         LogWriter dncLogWriter = null;
1:         try {
1:             updateDataSourceValues(
1:                     tokenizeAttributes(getConnectionAttributes(), null));
1:             dncLogWriter = computeDncLogWriterForNewConnection("_sds");
1:             return getConnectionX(dncLogWriter, getUser(), getPassword());
1:         } catch (SqlException se) {
1:             // The method below may throw an exception.
1:             handleConnectionException(dncLogWriter, se);
1:             // If the exception wasn't handled so far, re-throw it.
1:             throw se.getSQLException();
1:         }
1:     }
1: 
1:     /**
1:      * Attempt to establish a database connection in a non-pooling,
1:      * non-distributed environment.
1:      *
1:      * @param user the database user on whose behalf the Connection is being
1:      *        made
1:      * @param password the user's password
1:      *
1:      * @return a Connection to the database
1:      *
1:      * @throws java.sql.SQLException if a database-access error occurs.
1:      */
1:     public Connection getConnection(String user, String password)
1:             throws SQLException {
1:         // Jdbc 2 connections will write driver trace info on a
1:         // datasource-wide basis using the jdbc 2 data source log writer.
1:         // This log writer may be narrowed to the connection-level
1:         // This log writer will be passed to the agent constructor.
1: 
1:         LogWriter dncLogWriter = null;
1:         try
1:         {
1:             updateDataSourceValues(
1:                     tokenizeAttributes(getConnectionAttributes(), null));
1:             dncLogWriter = computeDncLogWriterForNewConnection("_sds");
1:             return getConnectionX(dncLogWriter, user, password);
1:         }
1:         catch(SqlException se)
1:         {
1:             // The method below may throw an exception.
1:             handleConnectionException(dncLogWriter, se);
1:             // If the exception wasn't handled so far, re-throw it.
1:             throw se.getSQLException();
1:         }
1: 
1:     }
1: 
1:     private Connection getConnectionX(LogWriter dncLogWriter,
1:                                       String user, String password)
1:             throws SqlException {
1:         return ClientDriver.getFactory().newNetConnection(
1:                 dncLogWriter, user, password, this, -1, false);
1: 
1:     }
1: 
1:     // JDBC 4.0 java.sql.Wrapper interface methods
1: 
1:     /**
1:      * Check whether this instance wraps an object that implements the
1:      * interface specified by {@code iface}.
1:      *
1:      * @param iface a class defining an interface
1:      * @return {@code true} if this instance implements {@code iface}, or
1:      * {@code false} otherwise
1:      * @throws SQLException if an error occurs while determining if this
1:      * instance implements {@code iface}
1:      */
1:     public boolean isWrapperFor(Class<?> iface) throws SQLException {
1:         return iface.isInstance(this);
1:     }
1: 
1:     /**
1:      * Returns {@code this} if this class implements the specified interface.
1:      *
1:      * @param  iface a class defining an interface
1:      * @return an object that implements the interface
1:      * @throws SQLException if no object is found that implements the
1:      * interface
1:      */
1:     public <T> T unwrap(Class<T> iface) throws SQLException {
1:         try {
1:             return iface.cast(this);
1:         } catch (ClassCastException cce) {
1:             throw new SqlException(null,
1:                     new ClientMessageId(SQLState.UNABLE_TO_UNWRAP),
1:                     iface).getSQLException();
1:         }
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////
1:     //
1:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:     //
1:     ////////////////////////////////////////////////////////////////////
1: 
1:     public Logger getParentLogger()
1:             throws SQLFeatureNotSupportedException {
1:         throw SQLExceptionFactory.notImplemented("getParentLogger");
1:     }
1: 
1:     // Helper methods
1: 
1:     protected final PooledConnection getPooledConnectionMinion()
1:             throws SQLException {
1:         LogWriter dncLogWriter = null;
1: 
1:         try {
1:             updateDataSourceValues(
1:                     tokenizeAttributes(getConnectionAttributes(), null));
1:             dncLogWriter = computeDncLogWriterForNewConnection("_cpds");
1: 
1:             if (dncLogWriter != null) {
1:                 dncLogWriter.traceEntry(this, "getPooledConnection");
1:             }
1: 
1:             PooledConnection pooledConnection = getPooledConnectionX(
1:                     dncLogWriter, this, getUser(), getPassword());
1: 
1:             if (dncLogWriter != null) {
1:                 dncLogWriter.traceExit(
1:                         this, "getPooledConnection", pooledConnection);
1:             }
1: 
1:             return pooledConnection;
1:         }
1:         catch (SqlException se) {
1:             // The method below may throw an exception.
1:             handleConnectionException(dncLogWriter, se);
1:             // If the exception wasn't handled so far, re-throw it.
1:             throw se.getSQLException();
1:         }
1:     }
1: 
1:     protected final PooledConnection getPooledConnectionMinion(
1:             String user, String password) throws SQLException {
1: 
1:         LogWriter dncLogWriter = null;
1: 
1:         try {
1:             updateDataSourceValues(
1:                     tokenizeAttributes(getConnectionAttributes(), null));
1:             dncLogWriter = computeDncLogWriterForNewConnection("_cpds");
1: 
1:             if (dncLogWriter != null) {
1:                 dncLogWriter.traceEntry(
1:                         this, "getPooledConnection", user, "<escaped>");
1:             }
1: 
1:             PooledConnection pooledConnection = getPooledConnectionX(
1:                     dncLogWriter, this, user, password);
1: 
1:             if (dncLogWriter != null) {
1:                 dncLogWriter.traceExit(
1:                         this, "getPooledConnection", pooledConnection);
1:             }
1: 
1:             return pooledConnection;
1: 
1:         } catch (SqlException se) {
1:             // The method below may throw an exception.
1:             handleConnectionException(dncLogWriter, se);
1:             // If the exception wasn't handled so far, re-throw it.
1:             throw se.getSQLException();
1:         }
1:     }
1: 
1:     // Minion method that establishes the initial physical connection
1:     // using DS properties instead of CPDS properties.
1:     private static PooledConnection getPooledConnectionX(
1:             LogWriter dncLogWriter,
1:             BasicClientDataSource40 ds,
1:             String user,
1:             String password) throws SQLException {
1: 
1:             return ClientDriver.getFactory().newClientPooledConnection(ds,
1:                     dncLogWriter, user, password);
1:     }
1: 
1:     protected final XAConnection getXAConnectionMinion() throws SQLException {
1:         LogWriter dncLogWriter = null;
1:         try {
1:             updateDataSourceValues(
1:                     tokenizeAttributes(getConnectionAttributes(), null));
1:             dncLogWriter = computeDncLogWriterForNewConnection("_xads");
1:             return getXAConnectionX(
1:                     dncLogWriter, this, getUser(), getPassword());
1:         } catch (SqlException se) {
1:             // The method below may throw an exception.
1:             handleConnectionException(dncLogWriter, se);
1:             // If the exception wasn't handled so far, re-throw it.
1:             throw se.getSQLException();
1:         }
1:     }
1: 
1:     protected final XAConnection getXAConnectionMinion(
1:             String user, String password) throws SQLException {
1: 
1:         LogWriter dncLogWriter = null;
1:         try
1:         {
1:             updateDataSourceValues(
1:                     tokenizeAttributes(getConnectionAttributes(), null));
1:             dncLogWriter = computeDncLogWriterForNewConnection("_xads");
1:             return getXAConnectionX(dncLogWriter, this, user, password);
1:         }
1:         catch ( SqlException se )
1:         {
1:             // The method below may throw an exception.
1:             handleConnectionException(dncLogWriter, se);
1:             // If the exception wasn't handled so far, re-throw it.
1:             throw se.getSQLException();
1:         }
1:     }
1: 
1:     /**
1:      * Method that establishes the initial physical connection
1:      * using DS properties instead of CPDS properties.
1:      */
1:     private static XAConnection getXAConnectionX(LogWriter dncLogWriter,
1:         BasicClientDataSource40 ds, String user, String password)
1:         throws SQLException
1:     {
1:         return ClientDriver.getFactory().newClientXAConnection(ds,
1:                 dncLogWriter, user, password);
1:     }
1: 
1:     public static Properties getProperties(BasicClientDataSource40 ths) {
1:         Properties properties = new Properties();
1: 
1:         // Look for all the getXXX methods in the class that take no arguments.
1:         Method[] methods = ths.getClass().getMethods();
1: 
1:         for (int i = 0; i < methods.length; i++) {
1: 
1:             Method m = methods[i];
1: 
1:             // only look for simple getter methods.
1:             if (m.getParameterTypes().length != 0) {
1:                 continue;
1:             }
1: 
1:             // only non-static methods
1:             if (Modifier.isStatic(m.getModifiers())) {
1:                 continue;
1:             }
1: 
1:             // Only getXXX methods
1:             String methodName = m.getName();
1:             if ((methodName.length() < 5) || !methodName.startsWith("get")) {
1:                 continue;
1:             }
1: 
1:             Class returnType = m.getReturnType();
1: 
1:             if (Integer.TYPE.equals(returnType)
1:                     || Short.TYPE.equals(returnType)
1:                     || String.class.equals(returnType)
1:                     || Boolean.TYPE.equals(returnType)) {
1: 
1:                 // E.g. "getSomeProperty"
1:                 //          s                 to lower case (3,4)
1:                 //           omeProperty      use as is (4->)
1:                 String propertyName = methodName.substring(3, 4).toLowerCase(
1:                         Locale.ENGLISH).concat(
1:                         methodName.substring(4));
1: 
1:                 try {
1:                     Object ov = m.invoke(ths, (Object[])null);
1:                     // Need to check if property value is null, otherwise
1:                     // "null" string gets stored.
1:                     if (ov != null) {
1:                         properties.setProperty(propertyName, ov.toString());
1:                     }
1:                 } catch (IllegalAccessException iae) {
1:                 } catch (InvocationTargetException ite) {
1:                 }
1: 
1:             }
1:         }
1: 
1:         return properties;
1:     }
commit:2913612
/////////////////////////////////////////////////////////////////////////
0:  * This datasource is suitable for client/server use of Derby,
1:  * running on Java 8 Compact Profile 2 or higher.
1:  * <p/>
commit:38667d9
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.jdbc.BasicClientDataSource40
/////////////////////////////////////////////////////////////////////////
0:  * BasicClientDataSource40 is similar to ClientDataSource40 except it
0: public class BasicClientDataSource40
1:             "org.apache.derby.jdbc.BasicClientDataSource40";
/////////////////////////////////////////////////////////////////////////
1:     public BasicClientDataSource40() {
commit:4e0e1f1
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Derby - Class org.apache.derby.jdbc.NonJNDIClientDataSource40
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.jdbc;
1: 
0: import java.sql.SQLFeatureNotSupportedException;
0: import java.util.logging.Logger;
1: import javax.sql.DataSource;
0: import org.apache.derby.client.am.ClientMessageId;
0: import org.apache.derby.client.am.SqlException;
0: import org.apache.derby.shared.common.reference.SQLState;
1: 
1: /**
0:  * NonJNDIClientDataSource40 is similar to ClientDataSource40 except it
1:  * can not be used with JNDI, i.e. it does not implement
1:  * {@code javax.naming.Referenceable}.
1:  */
0: public class NonJNDIClientDataSource40
0:     extends ClientBaseDataSourceRoot implements DataSource {
1: 
1:     private final static long serialVersionUID = 1894299584216955554L;
1:     public final static String className__ =
0:             "org.apache.derby.jdbc.NonJNDIClientDataSource40";
1: 
1:     /**
1:      * Creates a simple DERBY data source with default property values
1:      * for a non-pooling, non-distributed environment.  No particular
1:      * DatabaseName or other properties are associated with the data
1:      * source.
1:      * <p/>
1:      * Every Java Bean should provide a constructor with no arguments
1:      * since many beanboxes attempt to instantiate a bean by invoking
1:      * its no-argument constructor.
1:      */
0:     public NonJNDIClientDataSource40() {
1:         super();
1:     }
1: 
1: 
0:     ////////////////////////////////////////////////////////////////////
0:     //
0:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
0:     //
0:     ////////////////////////////////////////////////////////////////////
1: 
0:     public  Logger getParentLogger() throws SQLFeatureNotSupportedException {
0:         SqlException e = new SqlException(
0:                 null,
0:                 new ClientMessageId(SQLState.NOT_IMPLEMENTED),
0:                 "getParentLogger");
1: 
0:         throw (SQLFeatureNotSupportedException)e.getSQLException();
1:     }
1: }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:6ac5160
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedOutputStream;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1:                 return getPrintWriter(
1:                 return getPrintWriter(traceFile, traceFileAppend);
1:     private static PrintWriter getPrintWriter(
1:             final String fileName,
1:             final boolean fileAppend) throws SqlException {
0: 
1:         PrintWriter printWriter = null;
1:         //Using an anonymous class to deal with the PrintWriter because the  
1:         //method java.security.AccessController.doPrivileged requires an 
1:         //instance of a class(which implements 
1:         //java.security.PrivilegedExceptionAction). Since getPrintWriter method
1:         //is static, we can't simply pass "this" to doPrivileged method and 
1:         //have LogWriter implement PrivilegedExceptionAction.
1:         //To get around the static nature of method getPrintWriter, have an
1:         //anonymous class implement PrivilegedExceptionAction. That class will 
1:         //do the work related to PrintWriter in it's run method and return 
1:         //PrintWriter object.
1:         try {
1:             printWriter = AccessController.doPrivileged(
1:                 new PrivilegedExceptionAction<PrintWriter>(){
1:                     public PrintWriter run() throws IOException {
1:                         String fileCanonicalPath =
1:                             new File(fileName).getCanonicalPath();
1:                         return new PrintWriter(
1:                                 new BufferedOutputStream(
1:                                         new FileOutputStream(
1:                                                 fileCanonicalPath, fileAppend), 4096), true);
1:                         }
1:                     });
1:         } catch (PrivilegedActionException pae) {
1:             throw new SqlException(null, 
1:                 new ClientMessageId(SQLState.UNABLE_TO_OPEN_FILE),
1:                 new Object[] { fileName, pae.getMessage() },
1:                 pae);
1:         }
1:         return printWriter;
1:     }
0:     
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:04fc939
/////////////////////////////////////////////////////////////////////////
1:  * BasicClientDataSource40 is similar to ClientDataSource except it
/////////////////////////////////////////////////////////////////////////
============================================================================