1:f53b02e: /*
1:f53b02e:  *
1:f53b02e:  * Derby - Class LobStreamsTest
1:f53b02e:  *
1:f53b02e:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:f53b02e:  * contributor license agreements.  See the NOTICE file distributed with
1:f53b02e:  * this work for additional information regarding copyright ownership.
1:f53b02e:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:f53b02e:  * (the "License"); you may not use this file except in compliance with
1:f53b02e:  * the License.  You may obtain a copy of the License at
1:f53b02e:  *
1:f53b02e:  *    http://www.apache.org/licenses/LICENSE-2.0
1:f53b02e:  *
1:f53b02e:  * Unless required by applicable law or agreed to in writing,
1:f53b02e:  * software distributed under the License is distributed on an
1:f53b02e:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:f53b02e:  * either express or implied. See the License for the specific
1:f53b02e:  * language governing permissions and limitations under the License.
1:f53b02e:  */
1:f53b02e: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
9:f53b02e: 
1:e1fc783: import java.io.IOException;
1:f53b02e: import java.io.InputStream;
1:f53b02e: import java.io.OutputStream;
1:f53b02e: import java.io.Reader;
1:f53b02e: import java.io.Writer;
1:f53b02e: import java.sql.Blob;
1:f53b02e: import java.sql.Clob;
1:f53b02e: import java.sql.PreparedStatement;
1:f53b02e: import java.sql.ResultSet;
1:b61d634: import java.sql.SQLException;
1:f53b02e: import java.sql.Statement;
1:f53b02e: import junit.framework.Test;
1:b61d634: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:f53b02e: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1:f53b02e: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:2333262: import org.apache.derbyTesting.junit.Decorator;
1:63616cc: import org.apache.derbyTesting.junit.JDBC;
1:eba07fc: import org.apache.derbyTesting.junit.TestConfiguration;
1:f53b02e: 
1:f53b02e: public class LobStreamsTest extends BaseJDBCTestCase {
1:f53b02e: 
1:f53b02e:     int[] streamSize = new int[2];
1:f53b02e:     private final String unicodeTestString =
1:f53b02e:             "This is a test string containing a few non-ascii characters:\n " +
1:f53b02e:             "\u00E6\u00F8\u00E5 and \u00C6\u00D8\u00C5 are used in " +
1:f53b02e:             "norwegian: 'Bl\u00E5b\u00E6rsyltet\u00F8y' means 'blueberry jam'" +
1:f53b02e:             ", and tastes great on pancakes. =)";
1:f53b02e: 
1:f53b02e:     {
1:f53b02e:         streamSize[0] =  300000;
1:f53b02e:         streamSize[1] =  10000;
3:f53b02e:     }
1:f53b02e: 
1:f53b02e:     /** Creates a new instance of LobStreamsTest */
1:f53b02e:     public LobStreamsTest(String name) {
1:f53b02e:         super(name);
1:f53b02e:     }
1:f53b02e: 
1:f53b02e:     /**
1:f53b02e:      * Set up the connection to the database.
1:f53b02e:      */
1:f53b02e:     public void setUp() throws Exception {
1:eba07fc:         getConnection().setAutoCommit(false);
1:f53b02e: 
1:eba07fc:         Statement stmt1 = createStatement();
1:f53b02e:         stmt1.execute("create table testBlobX1 (" +
1:f53b02e:                 "a integer, " +
1:f53b02e:                 "b blob(300K), " +
1:f53b02e:                 "c clob(300K))");
1:f53b02e:         stmt1.close();
1:f53b02e: 
1:f53b02e:         byte[] b2 = new byte[1];
1:f53b02e:         b2[0] = (byte)64;
1:f53b02e:         String c2 = "c";
1:eba07fc:         PreparedStatement stmt2 = prepareStatement(
1:f53b02e:                 "INSERT INTO testBlobX1(a, b, c) " +
1:f53b02e:                 "VALUES (?, ?, ?)");
1:f53b02e:         stmt2.setInt(1, 1);
1:f53b02e:         stmt2.setBytes(2,  b2);
1:f53b02e:         stmt2.setString(3,  c2);
1:f53b02e:         stmt2.execute();
1:f53b02e:         stmt2.close();
1:41c47be:     }
1:41c47be: 
1:f53b02e:     /**
1:b61d634:      * Originally tested that the usage pattern {@code rs.getBlob().method()}
1:b61d634:      * didn't cause the underlying source stream to be closed too early. This
1:b61d634:      * behavior was forbidden, the test now checks that an exception is thrown.
1:b61d634:      * <p>
1:b61d634:      * Test description: Select from a BLOB column, access the BLOB using the
1:b61d634:      * pattern rs.getBlob(1).blobMethod() (note that we do not keep a reference
1:b61d634:      * to the Blob-object), provoke/invoke GC and finalization, and finally try
1:b61d634:      * to access the same BLOB again (through a different/another call to
1:b61d634:      * rs.getBlob(1)).
1:b61d634:      * <p>
1:b61d634:      * Note that the BLOB must be of a certain size (i.e. multiple pages), such
1:b61d634:      * that it is stored/accessed as a stream in store.
1:b61d634:      * <p>
1:b61d634:      * See DERBY-3844 and DERBY-4440.
1:b61d634:      *
1:b61d634:      * @throws Exception if something goes wrong
1:b61d634:      */
1:b61d634:     public void testGettingBlobTwice()
1:b61d634:             throws Exception {
1:b61d634:         setAutoCommit(false);
1:b61d634:         // We need a Blob represented as a stream in store.
1:b61d634:         int length = 71*1024+7;
1:b61d634:         PreparedStatement ps =
1:b61d634:                 prepareStatement("insert into testBlobX1(a,b) values (?,?)");
1:b61d634:         ps.setInt(1, 2);
1:b61d634:         ps.setBinaryStream(2, new LoopingAlphabetStream(length), length);
1:b61d634:         ps.executeUpdate();
1:b61d634:         ps.close();
1:b61d634: 
1:b61d634:         // Get a result set with the Blob.
1:b61d634:         ps = prepareStatement("select b from testBlobX1 where a = ?");
1:b61d634:         ps.setInt(1, 2);
1:b61d634:         ResultSet rs = ps.executeQuery();
1:b61d634:         assertTrue(rs.next());
1:b61d634:         Blob b = rs.getBlob(1);
1:b61d634:         try {
1:b61d634:             // Get the length, but don't keep a reference to the Blob.
1:b61d634:             assertEquals(length, rs.getBlob(1).length());
1:b61d634:             fail("Getting the Blob the second time should have failed");
1:b61d634:         } catch (SQLException sqle) {
1:b61d634:             assertSQLState("XCL18", sqle);
1:b61d634:         }
1:b61d634: 
1:b61d634:         // Increase the likelyhood of getting the finalizer run.
1:b61d634:         // Create some junk to fill up the heap, hopefully not JIT'ed away...
1:b61d634:         int size = 10*1024; // 10 K
1:b61d634:         byte[] bytes = null;
1:b61d634:         for (int i=0; i < 50; i++) {
1:b61d634:             bytes = new byte[size *(i +1)];
1:b61d634:         }
1:b61d634:         // For good measure...
1:b61d634:         System.gc();
1:b61d634:         System.runFinalization();
1:b61d634:         try {
1:b61d634:             Thread.sleep(100L);
1:b61d634:         } catch (InterruptedException ie) {
1:b61d634:             // No need to reset the interrupted flag here in the test.
1:b61d634:         }
1:b61d634: 
1:b61d634:         // This will fail if the finalizer caused the source stream to be
1:b61d634:         // closed and the source page to be unlatched.
1:b61d634:         InputStream is = b.getBinaryStream();
1:b61d634:         while (is.read() != -1) {
1:b61d634:             // Keep on reading...
1:b61d634:         }
1:b61d634:         assertNotNull(bytes);
1:b61d634:     }
1:b61d634: 
1:b61d634:     /**
1:b61d634:      * Tests that accessing the same Clob multiple times on a row results in
1:b61d634:      * an exception being thrown.
1:b61d634:      *
1:b61d634:      * @throws Exception if something goes wrong
1:b61d634:      */
1:b61d634:     public void testGettingClobTwice()
1:b61d634:             throws SQLException {
1:b61d634:         // We need a few Clobs.
1:b61d634:         int length = 71*1024+7;
1:b61d634:         PreparedStatement ps =
1:b61d634:                 prepareStatement("insert into testBlobX1(a,c) values (?,?)");
1:b61d634:         ps.setInt(1, 3);
1:b61d634:         ps.setCharacterStream(2, new LoopingAlphabetReader(length), length);
1:b61d634:         ps.executeUpdate();
1:b61d634:         ps.setInt(1, 4);
1:b61d634:         ps.setString(2, "short clob");
1:b61d634:         ps.executeUpdate();
1:b61d634:         ps.close();
1:b61d634: 
1:b61d634:         // Get a result set with the Clobs.
1:b61d634:         final int clobCount = 2;
1:b61d634:         int count = 0;
1:b61d634:         ps = prepareStatement(
1:b61d634:                 "select c from testBlobX1 where a >= ? and a <= ?");
1:b61d634:         ps.setInt(1, 3);
1:b61d634:         ps.setInt(2, 4);
1:b61d634:         ResultSet rs = ps.executeQuery();
1:b61d634:         assertTrue(rs.next());
1:b61d634:         do {
1:b61d634:             count++;
1:b61d634:             // First get a Clob.
1:b61d634:             Clob c = rs.getClob(1);
1:b61d634:             // Get a second Clob, which should fail.
1:b61d634:             try {
1:b61d634:                 rs.getClob(1);
1:b61d634:                 fail("Getting the Clob the second time should have failed");
1:b61d634:             } catch (SQLException sqle) {
1:b61d634:                 assertSQLState("XCL18", sqle);
1:b61d634:             }
1:b61d634:             // Finally try to access the column as a stream.
1:b61d634:             try {
1:b61d634:                 rs.getCharacterStream(1);
1:b61d634:                 fail("Getting the Clob the third time should have failed");
1:b61d634:             } catch (SQLException sqle) {
1:b61d634:                 assertSQLState("XCL18", sqle);
1:b61d634:             }
1:b61d634:         } while (rs.next());
1:b61d634:         rs.close();
1:b61d634:         assertEquals(clobCount, count);
1:b61d634:     }
1:b61d634: 
1:b61d634:     /**
1:f53b02e:      * Tests the BlobOutputStream.write(byte  b[], int off, int len) method
1:f53b02e:      **/
1:f53b02e:     public void testBlobWrite3Param() throws Exception {
1:f53b02e:         InputStream streamIn = new LoopingAlphabetStream(streamSize[0]);
1:f53b02e:         assertTrue("FAIL -- file not found", streamIn != null);
1:f53b02e: 
1:eba07fc:         PreparedStatement stmt3 = prepareStatement(
1:f53b02e:             "SELECT b FROM testBlobX1 WHERE a = 1");
1:f53b02e:         ResultSet rs3 = stmt3.executeQuery();
1:f53b02e:         rs3.next();
1:f53b02e:         Blob blob = rs3.getBlob(1);
1:f53b02e: 
1:f53b02e:         assertTrue ("FAIL -- blob is NULL", (blob != null));
1:f53b02e: 
1:f53b02e:         int count = 0;
1:f53b02e:         byte[] buffer = new byte[1024];
1:f53b02e:         OutputStream outstream = blob.setBinaryStream(1L);
1:f53b02e:         while ((count = streamIn.read(buffer)) != -1) {
1:f53b02e:             outstream.write(buffer, 0, count);
1:f53b02e:         }
1:f53b02e:         outstream.close();
1:f53b02e:         streamIn.close();
1:f53b02e: 
1:eba07fc:         PreparedStatement stmt4 = prepareStatement(
1:f53b02e:             "UPDATE testBlobX1 SET b = ? WHERE a = 1");
1:f53b02e:         stmt4.setBlob(1,  blob);
1:f53b02e:         stmt4.executeUpdate();
1:f53b02e:         stmt4.close();
1:f53b02e:         rs3.close();
1:f53b02e: 
1:f53b02e:         rs3 = stmt3.executeQuery();
1:f53b02e:         assertTrue("FAIL -- blob not found", rs3.next());
1:f53b02e: 
1:b61d634:         blob = rs3.getBlob(1);
1:b61d634:         long new_length = blob.length();
1:f53b02e:         assertEquals("FAIL -- wrong blob length;",
1:f53b02e:                 streamSize[0], new_length);
1:f53b02e: 
1:f53b02e:         // Check contents ...
1:f53b02e:         InputStream fStream = new LoopingAlphabetStream(streamSize[0]);
1:b61d634:         InputStream lStream = blob.getBinaryStream();
1:f53b02e:         assertTrue("FAIL - Blob and file contents do not match",
1:f53b02e:                 compareLob2File(fStream, lStream));
1:f53b02e: 
1:f53b02e:         fStream.close();
1:f53b02e:         lStream.close();
1:f53b02e:         rs3.close();
1:f53b02e:         stmt3.close();
1:f53b02e:     }
1:f53b02e: 
1:f53b02e:     /**
1:f53b02e:      * Tests the BlobOutputStream.write(int b) method
1:f53b02e:      **/
1:f53b02e:     public void testBlobWrite1Param() throws Exception {
1:f53b02e:         InputStream streamIn = new LoopingAlphabetStream(streamSize[1]);
1:f53b02e: 
1:eba07fc:         PreparedStatement stmt3 = prepareStatement(
1:f53b02e:             "SELECT b FROM testBlobX1 WHERE a = 1");
1:f53b02e:         ResultSet rs3 = stmt3.executeQuery();
1:f53b02e:         rs3.next();
1:f53b02e:         Blob blob = rs3.getBlob(1);
1:f53b02e: 
1:f53b02e:         assertTrue("FAIL -- blob is NULL", blob != null);
1:f53b02e: 
1:f53b02e:         int buffer;
1:f53b02e:         OutputStream outstream = blob.setBinaryStream(1L);
1:f53b02e:         while ((buffer = streamIn.read()) != -1) {
1:f53b02e:             outstream.write(buffer);
1:f53b02e:         }
1:f53b02e:         outstream.close();
1:f53b02e:         streamIn.close();
1:f53b02e: 
1:eba07fc:         PreparedStatement stmt4 = prepareStatement(
1:f53b02e:             "UPDATE testBlobX1 SET b = ? WHERE a = 1");
1:f53b02e:         stmt4.setBlob(1,  blob);
1:f53b02e:         stmt4.executeUpdate();
1:f53b02e:         stmt4.close();
1:f53b02e: 
1:f53b02e:         rs3.close();
1:f53b02e:         rs3 = stmt3.executeQuery();
1:f53b02e: 
1:f53b02e:         assertTrue("FAIL -- blob not found", rs3.next());
1:f53b02e: 
1:b61d634:         blob = rs3.getBlob(1);
1:b61d634:         long new_length = blob.length();
1:f53b02e:         assertEquals("FAIL -- wrong blob length", streamSize[1], new_length);
1:f53b02e: 
1:f53b02e:         // Check contents ...
1:f53b02e:         InputStream fStream = new LoopingAlphabetStream(streamSize[1]);
1:b61d634:         InputStream lStream = blob.getBinaryStream();
1:f53b02e:         assertTrue("FAIL - Blob and file contents do not match",
1:f53b02e:                 compareLob2File(fStream, lStream));
1:f53b02e: 
1:f53b02e:         fStream.close();
1:f53b02e:         lStream.close();
1:f53b02e:         rs3.close();
1:f53b02e:         stmt3.close();
1:f53b02e:     }
1:f53b02e: 
1:f53b02e:     /**
1:f53b02e:      * Tests the ClobOutputStream.write(int b) method
1:f53b02e:      **/
1:f53b02e:     public void testClobAsciiWrite1Param() throws Exception
1:f53b02e:     {
1:f53b02e:         InputStream streamIn = new LoopingAlphabetStream(streamSize[1]);
1:f53b02e: 
1:eba07fc:         PreparedStatement stmt3 = prepareStatement(
1:f53b02e:             "SELECT c FROM testBlobX1 WHERE a = 1");
1:f53b02e:         ResultSet rs3 = stmt3.executeQuery();
1:f53b02e:         rs3.next();
1:f53b02e:         Clob clob = rs3.getClob(1);
1:f53b02e: 
1:f53b02e:         assertTrue("FAIL -- clob is NULL", clob != null);
1:f53b02e:         int buffer;
1:f53b02e:         OutputStream outstream = clob.setAsciiStream(1L);
1:f53b02e:         while ((buffer = streamIn.read()) != -1) {
1:f53b02e:             outstream.write(buffer);
1:f53b02e:         }
1:f53b02e:         outstream.close();
1:f53b02e:         streamIn.close();
1:f53b02e: 
1:eba07fc:         PreparedStatement stmt4 = prepareStatement(
1:f53b02e:             "UPDATE testBlobX1 SET c = ? WHERE a = 1");
1:f53b02e:         stmt4.setClob(1,  clob);
1:f53b02e:         stmt4.executeUpdate();
1:f53b02e:         stmt4.close();
1:f53b02e: 
1:f53b02e:         rs3.close();
1:f53b02e:         rs3 = stmt3.executeQuery();
1:f53b02e:         assertTrue("FAIL -- clob not found", rs3.next());
1:b61d634: 
1:b61d634:         clob = rs3.getClob(1);
1:b61d634:         long new_length = clob.length();
1:f53b02e:         assertEquals("FAIL -- wrong clob length", streamSize[1], new_length);
1:b61d634: 
1:f53b02e:         // Check contents ...
1:f53b02e:         InputStream fStream = new LoopingAlphabetStream(streamSize[1]);
1:b61d634:         InputStream lStream = clob.getAsciiStream();
1:f53b02e:         assertTrue("FAIL - Clob and file contents do not match", compareLob2File(fStream, lStream));
1:f53b02e:         fStream.close();
1:f53b02e:         lStream.close();
1:f53b02e:         rs3.close();
1:f53b02e:         stmt3.close();
1:f53b02e:     }
1:b61d634: 
1:f53b02e:     /**
1:f53b02e:      * Tests the ClobOutputStream.write(byte  b[], int off, int len) method
1:f53b02e:      **/
1:f53b02e:     public void testClobAsciiWrite3Param() throws Exception {
1:f53b02e:         InputStream streamIn = new LoopingAlphabetStream(streamSize[0]);
1:f53b02e:         assertTrue("FAIL -- file not found", streamIn != null);
1:f53b02e: 
1:eba07fc:         PreparedStatement stmt3 = prepareStatement(
1:f53b02e:             "SELECT c FROM testBlobX1 WHERE a = 1");
1:f53b02e:         ResultSet rs3 = stmt3.executeQuery();
1:f53b02e:         rs3.next();
1:f53b02e:         Clob clob = rs3.getClob(1);
1:f53b02e: 
1:f53b02e:         assertTrue("FAIL -- clob is NULL", clob != null);
1:f53b02e: 
1:f53b02e:         int count = 0;
1:f53b02e:         byte[] buffer = new byte[1024];
1:f53b02e:         OutputStream outstream = clob.setAsciiStream(1L);
1:f53b02e:         while ((count = streamIn.read(buffer)) != -1) {
1:f53b02e:             outstream.write(buffer, 0, count);
1:f53b02e:         }
1:f53b02e:         outstream.close();
1:f53b02e:         streamIn.close();
1:f53b02e: 
1:eba07fc:         PreparedStatement stmt4 = prepareStatement(
1:f53b02e:             "UPDATE testBlobX1 SET c = ? WHERE a = 1");
1:f53b02e:         stmt4.setClob(1,  clob);
1:f53b02e:         stmt4.executeUpdate();
1:f53b02e:         stmt4.close();
1:f53b02e: 
1:f53b02e:         rs3.close();
1:f53b02e:         rs3 = stmt3.executeQuery();
1:f53b02e: 
1:f53b02e:         assertTrue("FAIL -- clob not found", rs3.next());
1:f53b02e: 
1:b61d634:         clob = rs3.getClob(1);
1:b61d634:         long new_length = clob.length();
1:f53b02e:         assertEquals("FAIL -- wrong clob length",
1:f53b02e:                 streamSize[0], new_length);
1:f53b02e:         // Check contents ...
1:f53b02e:         InputStream fStream = new LoopingAlphabetStream(streamSize[0]);
1:b61d634:         InputStream lStream = clob.getAsciiStream();
1:f53b02e:         assertTrue("FAIL - Clob and file contents do not match",
1:f53b02e:                 compareLob2File(fStream, lStream));
1:f53b02e: 
1:f53b02e:         fStream.close();
1:f53b02e:         lStream.close();
1:f53b02e:         rs3.close();
1:f53b02e:         stmt3.close();
1:f53b02e:     }
1:f53b02e: 
1:f53b02e:     /**
1:f53b02e:      * Tests the ClobWriter.write(char cbuf[], int off, int len) method
1:f53b02e:      **/
1:f53b02e:     public void testClobCharacterWrite3ParamChar() throws Exception
1:f53b02e:     {
1:f53b02e:         char[] testdata = unicodeTestString.toCharArray();
1:f53b02e: 
1:eba07fc:         PreparedStatement stmt3 = prepareStatement(
1:f53b02e:             "SELECT c FROM testBlobX1 WHERE a = 1");
1:f53b02e:         ResultSet rs3 = stmt3.executeQuery();
1:f53b02e:         rs3.next();
1:f53b02e:         Clob clob = rs3.getClob(1);
1:f53b02e:         assertTrue("FAIL -- clob is NULL", clob != null);
1:f53b02e:         Writer clobWriter = clob.setCharacterStream(1L);
1:f53b02e:         clobWriter.write(testdata, 0, testdata.length);
1:f53b02e:         clobWriter.close();
1:f53b02e: 
1:eba07fc:         PreparedStatement stmt4 = prepareStatement(
1:f53b02e:             "UPDATE testBlobX1 SET c = ? WHERE a = 1");
1:f53b02e:         stmt4.setClob(1,  clob);
1:f53b02e:         stmt4.executeUpdate();
1:f53b02e:         stmt4.close();
1:f53b02e: 
1:f53b02e:         rs3.close();
1:f53b02e:         rs3 = stmt3.executeQuery();
1:f53b02e: 
1:f53b02e:         assertTrue("FAIL -- clob not found", rs3.next());
1:b61d634:         clob = rs3.getClob(1);
1:b61d634:         long new_length = clob.length();
1:f53b02e:         assertEquals("FAIL -- wrong clob length",
1:f53b02e:                 testdata.length, new_length);
1:f53b02e: 
1:f53b02e:         // Check contents ...
1:b61d634:         Reader lStream = clob.getCharacterStream();
1:f53b02e:         assertTrue("FAIL - Clob and buffer contents do not match",
1:f53b02e:                 compareClobReader2CharArray(testdata, lStream));
1:f53b02e: 
1:f53b02e:         lStream.close();
1:f53b02e:         rs3.close();
1:f53b02e:         stmt3.close();
1:f53b02e:     }
1:f53b02e: 
1:f53b02e:     /**
1:f53b02e:      * Tests the ClobWriter.write(String str, int off, int len) method
1:f53b02e:      **/
1:f53b02e:     public void testClobCharacterWrite3ParamString() throws Exception
1:f53b02e:     {
1:eba07fc:         PreparedStatement stmt3 = prepareStatement(
1:f53b02e:             "SELECT c FROM testBlobX1 WHERE a = 1");
1:f53b02e:         ResultSet rs3 = stmt3.executeQuery();
1:f53b02e:         rs3.next();
1:f53b02e:         Clob clob = rs3.getClob(1);
1:f53b02e:         assertTrue("FAIL -- clob is NULL", clob != null);
1:f53b02e:         Writer clobWriter = clob.setCharacterStream(1L);
1:f53b02e:         clobWriter.write(unicodeTestString, 0, unicodeTestString.length());
1:f53b02e:         clobWriter.close();
1:f53b02e: 
1:eba07fc:         PreparedStatement stmt4 = prepareStatement(
1:f53b02e:             "UPDATE testBlobX1 SET c = ? WHERE a = 1");
1:f53b02e:         stmt4.setClob(1,  clob);
1:f53b02e:         stmt4.executeUpdate();
1:f53b02e:         stmt4.close();
1:f53b02e: 
1:f53b02e:         rs3.close();
1:f53b02e:         rs3 = stmt3.executeQuery();
1:f53b02e:         assertTrue("FAIL -- clob not found", rs3.next());
1:f53b02e: 
1:b61d634:         clob = rs3.getClob(1);
1:b61d634:         long new_length = clob.length();
1:f53b02e:         assertEquals("FAIL -- wrong clob length", unicodeTestString.length(), new_length);
1:f53b02e: 
1:f53b02e:         // Check contents ...
1:b61d634:         Reader lStream = clob.getCharacterStream();
1:f53b02e:         assertTrue("FAIL - Clob and buffer contents do not match",
1:f53b02e:                 compareClobReader2CharArray(
1:f53b02e:                     unicodeTestString.toCharArray(),
1:f53b02e:                     lStream));
1:f53b02e: 
1:f53b02e:         lStream.close();
1:f53b02e:         rs3.close();
1:f53b02e:         stmt3.close();
1:f53b02e:     }
1:f53b02e: 
1:f53b02e:     /**
1:f53b02e:      * Tests the ClobWriter.write(String str) method
1:f53b02e:      **/
1:f53b02e:     public void testClobCharacterWrite1ParamString() throws Exception
1:f53b02e:     {
1:eba07fc:         PreparedStatement stmt3 = prepareStatement(
1:f53b02e:             "SELECT c FROM testBlobX1 WHERE a = 1");
1:f53b02e:         ResultSet rs3 = stmt3.executeQuery();
1:f53b02e:         rs3.next();
1:f53b02e:         Clob clob = rs3.getClob(1);
1:f53b02e:         assertTrue("FAIL -- clob is NULL", clob != null);
1:f53b02e:         Writer clobWriter = clob.setCharacterStream(1L);
1:f53b02e:         clobWriter.write(unicodeTestString);
1:f53b02e:         clobWriter.close();
1:f53b02e: 
1:eba07fc:         PreparedStatement stmt4 = prepareStatement(
1:f53b02e:             "UPDATE testBlobX1 SET c = ? WHERE a = 1");
1:f53b02e:         stmt4.setClob(1,  clob);
1:f53b02e:         stmt4.executeUpdate();
1:f53b02e:         stmt4.close();
1:f53b02e: 
1:f53b02e:         rs3.close();
1:f53b02e:         rs3 = stmt3.executeQuery();
1:f53b02e:         assertTrue("FAIL -- clob not found", rs3.next());
1:f53b02e: 
1:b61d634:         clob = rs3.getClob(1);
1:b61d634:         long new_length = clob.length();
1:f53b02e:         assertEquals("FAIL -- wrong clob length", unicodeTestString.length(), new_length);
1:f53b02e: 
1:f53b02e:         // Check contents ...
1:b61d634:         Reader lStream = clob.getCharacterStream();
1:f53b02e:         assertTrue("FAIL - Clob and buffer contents do not match",
1:f53b02e:                 compareClobReader2CharArray(
1:f53b02e:                     unicodeTestString.toCharArray(),
1:f53b02e:                     lStream));
1:f53b02e: 
1:f53b02e:         lStream.close();
1:f53b02e:         rs3.close();
1:f53b02e:         stmt3.close();
1:f53b02e:     }
1:f53b02e: 
1:f53b02e:     /**
1:f53b02e:      * Tests the ClobWriter.write(int c) method
1:f53b02e:      **/
1:f53b02e:     public void testClobCharacterWrite1Char() throws Exception
1:f53b02e:     {
1:f53b02e:         char testchar = 'a';
1:f53b02e: 
1:eba07fc:         PreparedStatement stmt3 = prepareStatement(
1:f53b02e:             "SELECT c FROM testBlobX1 WHERE a = 1");
1:f53b02e:         ResultSet rs3 = stmt3.executeQuery();
1:f53b02e:         rs3.next();
1:f53b02e:         Clob clob = rs3.getClob(1);
1:f53b02e: 
1:f53b02e:         assertTrue ("FAIL -- clob is NULL", clob != null);
1:f53b02e:         Writer clobWriter = clob.setCharacterStream(1L);
1:f53b02e:         clobWriter.write(testchar);
1:f53b02e:         clobWriter.close();
1:f53b02e: 
1:eba07fc:         PreparedStatement stmt4 = prepareStatement(
1:f53b02e:             "UPDATE testBlobX1 SET c = ? WHERE a = 1");
1:f53b02e:         stmt4.setClob(1,  clob);
1:f53b02e:         stmt4.executeUpdate();
1:f53b02e:         stmt4.close();
1:f53b02e: 
1:f53b02e:         rs3.close();
1:f53b02e:         rs3 = stmt3.executeQuery();
1:f53b02e:         assertTrue("FAIL -- clob not found", rs3.next());
1:f53b02e: 
1:b61d634:         clob = rs3.getClob(1);
1:b61d634:         long new_length = clob.length();
1:f53b02e:         assertEquals("FAIL -- wrong clob length", 1, new_length);
1:f53b02e:         // Check contents ...
1:b61d634:         Reader lStream = clob.getCharacterStream();
1:f53b02e:         char clobchar = (char) lStream.read();
1:f53b02e:         assertEquals("FAIL - fetched Clob and original contents do " +
1:f53b02e:                 "not match", testchar, clobchar);
1:f53b02e: 
1:f53b02e:         lStream.close();
1:f53b02e:         rs3.close();
1:f53b02e:         stmt3.close();
1:f53b02e:     }
1:f53b02e: 
1:eba07fc:     /**
1:eba07fc:      * Run with DerbyNetClient only.
1:9eec1fa:      * Embedded Clob/Blob.setXXXStream() methods are not implemented.
1:eba07fc:      */
1:f53b02e:     public static Test suite() {
1:f53b02e:                 
1:1ae02c9:         BaseTestSuite ts  = new BaseTestSuite ("LobStreamsTest");
1:2333262:         ts.addTest(TestConfiguration.defaultSuite (LobStreamsTest.class));
1:63616cc:         // JSR169 does not have support for encryption
1:63616cc:         if (JDBC.vmSupportsJDBC3()) {
1:1ae02c9:             BaseTestSuite encSuite =
1:1ae02c9:                 new BaseTestSuite ("LobStreamsTest:encrypted");
1:63616cc:             encSuite.addTestSuite (LobStreamsTest.class);
1:63616cc:             ts.addTest(Decorator.encryptedDatabase (encSuite));
1:63616cc:         }
1:2333262:         return ts;
1:f53b02e:     }
1:e1fc783:     //method to ensure that buffer is filled if there is any data in stream
1:e1fc783:     private int readBytesFromStream (byte [] b, InputStream is) 
1:e1fc783:                                                           throws IOException {
1:e1fc783:         int read = 0;
1:e1fc783:         while (read < b.length) {
1:e1fc783:             int ret = is.read (b, read, b.length - read);
1:e1fc783:             if (ret < 0) {
1:e1fc783:                 if (read == 0) {
1:e1fc783:                     return ret;
1:e1fc783:                 }
1:e1fc783:                 else {
1:e1fc783:                     break;
1:e1fc783:                 }
1:e1fc783:             }
1:e1fc783:             read += ret;
1:e1fc783:         }
1:e1fc783:         return read;
1:e1fc783:     }
1:f53b02e: 
1:f53b02e:     private boolean compareLob2File(
1:f53b02e:             InputStream fStream,
1:f53b02e:             InputStream lStream) throws Exception
1:f53b02e:     {
1:f53b02e:         byte[] fByte = new byte[1024];
1:f53b02e:         byte[] lByte = new byte[1024];
1:f53b02e:         int lLength = 0, fLength = 0;
1:f53b02e:         String fString, lString;
1:f53b02e: 
1:f53b02e:         do {
1:e1fc783:             fLength = readBytesFromStream (fByte, fStream);
1:e1fc783:             lLength = readBytesFromStream (lByte, lStream);
1:f53b02e:             if (!java.util.Arrays.equals(fByte, lByte))
1:f53b02e:                 return false;
1:f53b02e:         } while (fLength > 0 && lLength > 0);
1:f53b02e: 
1:f53b02e:         fStream.close();
1:f53b02e:         lStream.close();
1:f53b02e: 
1:f53b02e:         return true;
1:f53b02e:     }
1:f53b02e: 
1:f53b02e:     private boolean compareClobReader2CharArray(
1:f53b02e:             char[] cArray,
1:f53b02e:             Reader charReader) throws Exception
1:f53b02e:     {
1:f53b02e:         char[] clobChars = new char[cArray.length];
1:f53b02e: 
1:f53b02e:         int readChars = 0;
1:f53b02e:         int totalCharsRead = 0;
1:f53b02e: 
1:f53b02e:         do {
1:f53b02e:             readChars = charReader.read(clobChars, totalCharsRead, cArray.length - totalCharsRead);
1:f53b02e:             if (readChars != -1)
1:f53b02e:                 totalCharsRead += readChars;
1:f53b02e:         } while (readChars != -1 && totalCharsRead < cArray.length);
1:f53b02e:         charReader.close();
1:f53b02e:         if (!java.util.Arrays.equals(cArray, clobChars))
1:f53b02e:             return false;
1:f53b02e: 
1:f53b02e:         return true;
1:f53b02e:     }
1:f53b02e: 
1:f53b02e: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite ts  = new BaseTestSuite ("LobStreamsTest");
1:             BaseTestSuite encSuite =
1:                 new BaseTestSuite ("LobStreamsTest:encrypted");
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b61d634
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
/////////////////////////////////////////////////////////////////////////
1:      * Originally tested that the usage pattern {@code rs.getBlob().method()}
1:      * didn't cause the underlying source stream to be closed too early. This
1:      * behavior was forbidden, the test now checks that an exception is thrown.
1:      * <p>
1:      * Test description: Select from a BLOB column, access the BLOB using the
1:      * pattern rs.getBlob(1).blobMethod() (note that we do not keep a reference
1:      * to the Blob-object), provoke/invoke GC and finalization, and finally try
1:      * to access the same BLOB again (through a different/another call to
1:      * rs.getBlob(1)).
1:      * <p>
1:      * Note that the BLOB must be of a certain size (i.e. multiple pages), such
1:      * that it is stored/accessed as a stream in store.
1:      * <p>
1:      * See DERBY-3844 and DERBY-4440.
1:      *
1:      * @throws Exception if something goes wrong
1:      */
1:     public void testGettingBlobTwice()
1:             throws Exception {
1:         setAutoCommit(false);
1:         // We need a Blob represented as a stream in store.
1:         int length = 71*1024+7;
1:         PreparedStatement ps =
1:                 prepareStatement("insert into testBlobX1(a,b) values (?,?)");
1:         ps.setInt(1, 2);
1:         ps.setBinaryStream(2, new LoopingAlphabetStream(length), length);
1:         ps.executeUpdate();
1:         ps.close();
1: 
1:         // Get a result set with the Blob.
1:         ps = prepareStatement("select b from testBlobX1 where a = ?");
1:         ps.setInt(1, 2);
1:         ResultSet rs = ps.executeQuery();
1:         assertTrue(rs.next());
1:         Blob b = rs.getBlob(1);
1:         try {
1:             // Get the length, but don't keep a reference to the Blob.
1:             assertEquals(length, rs.getBlob(1).length());
1:             fail("Getting the Blob the second time should have failed");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XCL18", sqle);
1:         }
1: 
1:         // Increase the likelyhood of getting the finalizer run.
1:         // Create some junk to fill up the heap, hopefully not JIT'ed away...
1:         int size = 10*1024; // 10 K
1:         byte[] bytes = null;
1:         for (int i=0; i < 50; i++) {
1:             bytes = new byte[size *(i +1)];
1:         }
1:         // For good measure...
1:         System.gc();
1:         System.runFinalization();
1:         try {
1:             Thread.sleep(100L);
1:         } catch (InterruptedException ie) {
1:             // No need to reset the interrupted flag here in the test.
1:         }
1: 
1:         // This will fail if the finalizer caused the source stream to be
1:         // closed and the source page to be unlatched.
1:         InputStream is = b.getBinaryStream();
1:         while (is.read() != -1) {
1:             // Keep on reading...
1:         }
1:         assertNotNull(bytes);
1:     }
1: 
1:     /**
1:      * Tests that accessing the same Clob multiple times on a row results in
1:      * an exception being thrown.
1:      *
1:      * @throws Exception if something goes wrong
1:      */
1:     public void testGettingClobTwice()
1:             throws SQLException {
1:         // We need a few Clobs.
1:         int length = 71*1024+7;
1:         PreparedStatement ps =
1:                 prepareStatement("insert into testBlobX1(a,c) values (?,?)");
1:         ps.setInt(1, 3);
1:         ps.setCharacterStream(2, new LoopingAlphabetReader(length), length);
1:         ps.executeUpdate();
1:         ps.setInt(1, 4);
1:         ps.setString(2, "short clob");
1:         ps.executeUpdate();
1:         ps.close();
1: 
1:         // Get a result set with the Clobs.
1:         final int clobCount = 2;
1:         int count = 0;
1:         ps = prepareStatement(
1:                 "select c from testBlobX1 where a >= ? and a <= ?");
1:         ps.setInt(1, 3);
1:         ps.setInt(2, 4);
1:         ResultSet rs = ps.executeQuery();
1:         assertTrue(rs.next());
1:         do {
1:             count++;
1:             // First get a Clob.
1:             Clob c = rs.getClob(1);
1:             // Get a second Clob, which should fail.
1:             try {
1:                 rs.getClob(1);
1:                 fail("Getting the Clob the second time should have failed");
1:             } catch (SQLException sqle) {
1:                 assertSQLState("XCL18", sqle);
1:             }
1:             // Finally try to access the column as a stream.
1:             try {
1:                 rs.getCharacterStream(1);
1:                 fail("Getting the Clob the third time should have failed");
1:             } catch (SQLException sqle) {
1:                 assertSQLState("XCL18", sqle);
1:             }
1:         } while (rs.next());
1:         rs.close();
1:         assertEquals(clobCount, count);
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         blob = rs3.getBlob(1);
1:         long new_length = blob.length();
1:         InputStream lStream = blob.getBinaryStream();
/////////////////////////////////////////////////////////////////////////
1:         blob = rs3.getBlob(1);
1:         long new_length = blob.length();
1:         InputStream lStream = blob.getBinaryStream();
/////////////////////////////////////////////////////////////////////////
1:         clob = rs3.getClob(1);
1:         long new_length = clob.length();
1:         InputStream lStream = clob.getAsciiStream();
/////////////////////////////////////////////////////////////////////////
1:         clob = rs3.getClob(1);
1:         long new_length = clob.length();
1:         InputStream lStream = clob.getAsciiStream();
/////////////////////////////////////////////////////////////////////////
1:         clob = rs3.getClob(1);
1:         long new_length = clob.length();
1:         Reader lStream = clob.getCharacterStream();
/////////////////////////////////////////////////////////////////////////
1: 
1:         clob = rs3.getClob(1);
1:         long new_length = clob.length();
1:         Reader lStream = clob.getCharacterStream();
/////////////////////////////////////////////////////////////////////////
1: 
1:         clob = rs3.getClob(1);
1:         long new_length = clob.length();
1:         Reader lStream = clob.getCharacterStream();
/////////////////////////////////////////////////////////////////////////
1: 
1:         clob = rs3.getClob(1);
1:         long new_length = clob.length();
1:         Reader lStream = clob.getCharacterStream();
commit:e1fc783
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0:         return TestConfiguration.defaultSuite (LobStreamsTest.class);
1:     //method to ensure that buffer is filled if there is any data in stream
1:     private int readBytesFromStream (byte [] b, InputStream is) 
1:                                                           throws IOException {
1:         int read = 0;
1:         while (read < b.length) {
1:             int ret = is.read (b, read, b.length - read);
1:             if (ret < 0) {
1:                 if (read == 0) {
1:                     return ret;
1:                 }
1:                 else {
1:                     break;
1:                 }
1:             }
1:             read += ret;
1:         }
1:         return read;
1:     }
/////////////////////////////////////////////////////////////////////////
1:             fLength = readBytesFromStream (fByte, fStream);
1:             lLength = readBytesFromStream (lByte, lStream);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:63616cc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1:         // JSR169 does not have support for encryption
1:         if (JDBC.vmSupportsJDBC3()) {
0:             TestSuite encSuite = new TestSuite ("LobStreamsTest:encrypted");
1:             encSuite.addTestSuite (LobStreamsTest.class);
1:             ts.addTest(Decorator.encryptedDatabase (encSuite));
1:         }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:2333262
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.Decorator;
/////////////////////////////////////////////////////////////////////////
0:         TestSuite ts  = new TestSuite ("LobStreamsTest");
1:         ts.addTest(TestConfiguration.defaultSuite (LobStreamsTest.class));
0:         TestSuite encSuite = new TestSuite ("LobStreamsTest:encrypted");
0:         encSuite.addTestSuite (LobStreamsTest.class);
0:         ts.addTest(Decorator.encryptedDatabase (encSuite));
1:         return ts;
commit:9eec1fa
/////////////////////////////////////////////////////////////////////////
1:      * Embedded Clob/Blob.setXXXStream() methods are not implemented.
commit:41c47be
/////////////////////////////////////////////////////////////////////////
0:     protected void tearDown() throws Exception {
0:         super.tearDown();
0:         con = null;
1:     }
1: 
commit:f53b02e
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class LobStreamsTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:  * either express or implied. See the License for the specific
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: import java.io.Reader;
1: import java.io.Writer;
1: 
1: import java.sql.Blob;
1: import java.sql.Clob;
0: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: 
1: public class LobStreamsTest extends BaseJDBCTestCase {
1: 
1:     int[] streamSize = new int[2];
1:     private final String unicodeTestString =
1:             "This is a test string containing a few non-ascii characters:\n " +
1:             "\u00E6\u00F8\u00E5 and \u00C6\u00D8\u00C5 are used in " +
1:             "norwegian: 'Bl\u00E5b\u00E6rsyltet\u00F8y' means 'blueberry jam'" +
1:             ", and tastes great on pancakes. =)";
1: 
1:     {
1:         streamSize[0] =  300000;
1:         streamSize[1] =  10000;
1:     }
1: 
0:     private Connection con = null;
1: 
1: 
1:     /** Creates a new instance of LobStreamsTest */
1:     public LobStreamsTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Set up the connection to the database.
1:      */
1:     public void setUp() throws Exception {
0:         con = getConnection();
0:         con.setAutoCommit(false);
1: 
0:         Statement stmt1 = con.createStatement();
1:         stmt1.execute("create table testBlobX1 (" +
1:                 "a integer, " +
1:                 "b blob(300K), " +
1:                 "c clob(300K))");
1:         stmt1.close();
1: 
1:         byte[] b2 = new byte[1];
1:         b2[0] = (byte)64;
1:         String c2 = "c";
0:         PreparedStatement stmt2 = con.prepareStatement(
1:                 "INSERT INTO testBlobX1(a, b, c) " +
1:                 "VALUES (?, ?, ?)");
1:         stmt2.setInt(1, 1);
1:         stmt2.setBytes(2,  b2);
1:         stmt2.setString(3,  c2);
1:         stmt2.execute();
1:         stmt2.close();
1:     }
1: 
1:     /**
1:      * Tests the BlobOutputStream.write(byte  b[], int off, int len) method
1:      **/
1:     public void testBlobWrite3Param() throws Exception {
1:         InputStream streamIn = new LoopingAlphabetStream(streamSize[0]);
1:         assertTrue("FAIL -- file not found", streamIn != null);
1: 
0:         PreparedStatement stmt3 = con.prepareStatement(
1:             "SELECT b FROM testBlobX1 WHERE a = 1");
1:         ResultSet rs3 = stmt3.executeQuery();
1:         rs3.next();
1:         Blob blob = rs3.getBlob(1);
1: 
1:         assertTrue ("FAIL -- blob is NULL", (blob != null));
1: 
1:         int count = 0;
1:         byte[] buffer = new byte[1024];
1:         OutputStream outstream = blob.setBinaryStream(1L);
1:         while ((count = streamIn.read(buffer)) != -1) {
1:             outstream.write(buffer, 0, count);
1:         }
1:         outstream.close();
1:         streamIn.close();
1: 
0:         PreparedStatement stmt4 = con.prepareStatement(
1:             "UPDATE testBlobX1 SET b = ? WHERE a = 1");
1:         stmt4.setBlob(1,  blob);
1:         stmt4.executeUpdate();
1:         stmt4.close();
1:         rs3.close();
1: 
1:         rs3 = stmt3.executeQuery();
1:         assertTrue("FAIL -- blob not found", rs3.next());
1: 
0:         long new_length = rs3.getBlob(1).length();
1:         assertEquals("FAIL -- wrong blob length;",
1:                 streamSize[0], new_length);
1: 
1:         // Check contents ...
1:         InputStream fStream = new LoopingAlphabetStream(streamSize[0]);
0:         InputStream lStream = rs3.getBlob(1).getBinaryStream();
1:         assertTrue("FAIL - Blob and file contents do not match",
1:                 compareLob2File(fStream, lStream));
1: 
1:         fStream.close();
1:         lStream.close();
1:         rs3.close();
1:         stmt3.close();
1:     }
1: 
1:     /**
1:      * Tests the BlobOutputStream.write(int b) method
1:      **/
1:     public void testBlobWrite1Param() throws Exception {
1:         InputStream streamIn = new LoopingAlphabetStream(streamSize[1]);
1: 
0:         PreparedStatement stmt3 = con.prepareStatement(
1:             "SELECT b FROM testBlobX1 WHERE a = 1");
1:         ResultSet rs3 = stmt3.executeQuery();
1:         rs3.next();
1:         Blob blob = rs3.getBlob(1);
1: 
1:         assertTrue("FAIL -- blob is NULL", blob != null);
1: 
1:         int buffer;
1:         OutputStream outstream = blob.setBinaryStream(1L);
1:         while ((buffer = streamIn.read()) != -1) {
1:             outstream.write(buffer);
1:         }
1:         outstream.close();
1:         streamIn.close();
1: 
0:         PreparedStatement stmt4 = con.prepareStatement(
1:             "UPDATE testBlobX1 SET b = ? WHERE a = 1");
1:         stmt4.setBlob(1,  blob);
1:         stmt4.executeUpdate();
1:         stmt4.close();
1: 
1:         rs3.close();
1:         rs3 = stmt3.executeQuery();
1: 
1:         assertTrue("FAIL -- blob not found", rs3.next());
1: 
0:         long new_length = rs3.getBlob(1).length();
1:         assertEquals("FAIL -- wrong blob length", streamSize[1], new_length);
1: 
1:         // Check contents ...
1:         InputStream fStream = new LoopingAlphabetStream(streamSize[1]);
0:         InputStream lStream = rs3.getBlob(1).getBinaryStream();
1:         assertTrue("FAIL - Blob and file contents do not match",
1:                 compareLob2File(fStream, lStream));
1: 
1:         fStream.close();
1:         lStream.close();
1:         rs3.close();
1:         stmt3.close();
1:     }
1: 
1:     /**
1:      * Tests the ClobOutputStream.write(int b) method
1:      **/
1:     public void testClobAsciiWrite1Param() throws Exception
1:     {
1:         InputStream streamIn = new LoopingAlphabetStream(streamSize[1]);
1: 
0:         PreparedStatement stmt3 = con.prepareStatement(
1:             "SELECT c FROM testBlobX1 WHERE a = 1");
1:         ResultSet rs3 = stmt3.executeQuery();
1:         rs3.next();
1:         Clob clob = rs3.getClob(1);
1: 
1:         assertTrue("FAIL -- clob is NULL", clob != null);
1:         int buffer;
1:         OutputStream outstream = clob.setAsciiStream(1L);
1:         while ((buffer = streamIn.read()) != -1) {
1:             outstream.write(buffer);
1:         }
1:         outstream.close();
1:         streamIn.close();
1: 
0:         PreparedStatement stmt4 = con.prepareStatement(
1:             "UPDATE testBlobX1 SET c = ? WHERE a = 1");
1:         stmt4.setClob(1,  clob);
1:         stmt4.executeUpdate();
1:         stmt4.close();
1: 
1:         rs3.close();
1:         rs3 = stmt3.executeQuery();
1:         assertTrue("FAIL -- clob not found", rs3.next());
1: 
0:         long new_length = rs3.getClob(1).length();
1:         assertEquals("FAIL -- wrong clob length", streamSize[1], new_length);
1: 
1:         // Check contents ...
1:         InputStream fStream = new LoopingAlphabetStream(streamSize[1]);
0:         InputStream lStream = rs3.getClob(1).getAsciiStream();
1:         assertTrue("FAIL - Clob and file contents do not match", compareLob2File(fStream, lStream));
1:         fStream.close();
1:         lStream.close();
1:         rs3.close();
1:         stmt3.close();
1:     }
1: 
1:     /**
1:      * Tests the ClobOutputStream.write(byte  b[], int off, int len) method
1:      **/
1:     public void testClobAsciiWrite3Param() throws Exception {
1:         InputStream streamIn = new LoopingAlphabetStream(streamSize[0]);
1:         assertTrue("FAIL -- file not found", streamIn != null);
1: 
0:         PreparedStatement stmt3 = con.prepareStatement(
1:             "SELECT c FROM testBlobX1 WHERE a = 1");
1:         ResultSet rs3 = stmt3.executeQuery();
1:         rs3.next();
1:         Clob clob = rs3.getClob(1);
1: 
1:         assertTrue("FAIL -- clob is NULL", clob != null);
1: 
1:         int count = 0;
1:         byte[] buffer = new byte[1024];
1:         OutputStream outstream = clob.setAsciiStream(1L);
1:         while ((count = streamIn.read(buffer)) != -1) {
1:             outstream.write(buffer, 0, count);
1:         }
1:         outstream.close();
1:         streamIn.close();
1: 
0:         PreparedStatement stmt4 = con.prepareStatement(
1:             "UPDATE testBlobX1 SET c = ? WHERE a = 1");
1:         stmt4.setClob(1,  clob);
1:         stmt4.executeUpdate();
1:         stmt4.close();
1: 
1:         rs3.close();
1:         rs3 = stmt3.executeQuery();
1: 
1:         assertTrue("FAIL -- clob not found", rs3.next());
1: 
0:         long new_length = rs3.getClob(1).length();
1:         assertEquals("FAIL -- wrong clob length",
1:                 streamSize[0], new_length);
1:         // Check contents ...
1:         InputStream fStream = new LoopingAlphabetStream(streamSize[0]);
0:         InputStream lStream = rs3.getClob(1).getAsciiStream();
1:         assertTrue("FAIL - Clob and file contents do not match",
1:                 compareLob2File(fStream, lStream));
1: 
1:         fStream.close();
1:         lStream.close();
1:         rs3.close();
1:         stmt3.close();
1:     }
1: 
1:     /**
1:      * Tests the ClobWriter.write(char cbuf[], int off, int len) method
1:      **/
1:     public void testClobCharacterWrite3ParamChar() throws Exception
1:     {
1:         char[] testdata = unicodeTestString.toCharArray();
1: 
0:         PreparedStatement stmt3 = con.prepareStatement(
1:             "SELECT c FROM testBlobX1 WHERE a = 1");
1:         ResultSet rs3 = stmt3.executeQuery();
1:         rs3.next();
1:         Clob clob = rs3.getClob(1);
1:         assertTrue("FAIL -- clob is NULL", clob != null);
1:         Writer clobWriter = clob.setCharacterStream(1L);
1:         clobWriter.write(testdata, 0, testdata.length);
1:         clobWriter.close();
1: 
0:         PreparedStatement stmt4 = con.prepareStatement(
1:             "UPDATE testBlobX1 SET c = ? WHERE a = 1");
1:         stmt4.setClob(1,  clob);
1:         stmt4.executeUpdate();
1:         stmt4.close();
1: 
1:         rs3.close();
1:         rs3 = stmt3.executeQuery();
1: 
1:         assertTrue("FAIL -- clob not found", rs3.next());
0:         long new_length = rs3.getClob(1).length();
1:         assertEquals("FAIL -- wrong clob length",
1:                 testdata.length, new_length);
1: 
1:         // Check contents ...
0:         Reader lStream = rs3.getClob(1).getCharacterStream();
1:         assertTrue("FAIL - Clob and buffer contents do not match",
1:                 compareClobReader2CharArray(testdata, lStream));
1: 
1:         lStream.close();
1:         rs3.close();
1:         stmt3.close();
1:     }
1: 
1:     /**
1:      * Tests the ClobWriter.write(String str, int off, int len) method
1:      **/
1:     public void testClobCharacterWrite3ParamString() throws Exception
1:     {
0:         PreparedStatement stmt3 = con.prepareStatement(
1:             "SELECT c FROM testBlobX1 WHERE a = 1");
1:         ResultSet rs3 = stmt3.executeQuery();
1:         rs3.next();
1:         Clob clob = rs3.getClob(1);
1:         assertTrue("FAIL -- clob is NULL", clob != null);
1:         Writer clobWriter = clob.setCharacterStream(1L);
1:         clobWriter.write(unicodeTestString, 0, unicodeTestString.length());
1:         clobWriter.close();
1: 
0:         PreparedStatement stmt4 = con.prepareStatement(
1:             "UPDATE testBlobX1 SET c = ? WHERE a = 1");
1:         stmt4.setClob(1,  clob);
1:         stmt4.executeUpdate();
1:         stmt4.close();
1: 
1:         rs3.close();
1:         rs3 = stmt3.executeQuery();
1:         assertTrue("FAIL -- clob not found", rs3.next());
0:         long new_length = rs3.getClob(1).length();
1:         assertEquals("FAIL -- wrong clob length", unicodeTestString.length(), new_length);
1: 
1:         // Check contents ...
0:         Reader lStream = rs3.getClob(1).getCharacterStream();
1:         assertTrue("FAIL - Clob and buffer contents do not match",
1:                 compareClobReader2CharArray(
1:                     unicodeTestString.toCharArray(),
1:                     lStream));
1: 
1:         lStream.close();
1:         rs3.close();
1:         stmt3.close();
1:     }
1: 
1:     /**
1:      * Tests the ClobWriter.write(String str) method
1:      **/
1:     public void testClobCharacterWrite1ParamString() throws Exception
1:     {
0:         PreparedStatement stmt3 = con.prepareStatement(
1:             "SELECT c FROM testBlobX1 WHERE a = 1");
1:         ResultSet rs3 = stmt3.executeQuery();
1:         rs3.next();
1:         Clob clob = rs3.getClob(1);
1:         assertTrue("FAIL -- clob is NULL", clob != null);
1:         Writer clobWriter = clob.setCharacterStream(1L);
1:         clobWriter.write(unicodeTestString);
1:         clobWriter.close();
1: 
0:         PreparedStatement stmt4 = con.prepareStatement(
1:             "UPDATE testBlobX1 SET c = ? WHERE a = 1");
1:         stmt4.setClob(1,  clob);
1:         stmt4.executeUpdate();
1:         stmt4.close();
1: 
1:         rs3.close();
1:         rs3 = stmt3.executeQuery();
1:         assertTrue("FAIL -- clob not found", rs3.next());
0:         long new_length = rs3.getClob(1).length();
1:         assertEquals("FAIL -- wrong clob length", unicodeTestString.length(), new_length);
1: 
1:         // Check contents ...
0:         Reader lStream = rs3.getClob(1).getCharacterStream();
1:         assertTrue("FAIL - Clob and buffer contents do not match",
1:                 compareClobReader2CharArray(
1:                     unicodeTestString.toCharArray(),
1:                     lStream));
1: 
1:         lStream.close();
1:         rs3.close();
1:         stmt3.close();
1:     }
1: 
1:     /**
1:      * Tests the ClobWriter.write(int c) method
1:      **/
1:     public void testClobCharacterWrite1Char() throws Exception
1:     {
1:         char testchar = 'a';
1: 
0:         PreparedStatement stmt3 = con.prepareStatement(
1:             "SELECT c FROM testBlobX1 WHERE a = 1");
1:         ResultSet rs3 = stmt3.executeQuery();
1:         rs3.next();
1:         Clob clob = rs3.getClob(1);
1: 
1:         assertTrue ("FAIL -- clob is NULL", clob != null);
1:         Writer clobWriter = clob.setCharacterStream(1L);
1:         clobWriter.write(testchar);
1:         clobWriter.close();
1: 
0:         PreparedStatement stmt4 = con.prepareStatement(
1:             "UPDATE testBlobX1 SET c = ? WHERE a = 1");
1:         stmt4.setClob(1,  clob);
1:         stmt4.executeUpdate();
1:         stmt4.close();
1: 
1:         rs3.close();
1:         rs3 = stmt3.executeQuery();
1:         assertTrue("FAIL -- clob not found", rs3.next());
0:         long new_length = rs3.getClob(1).length();
0:         Clob fish = rs3.getClob(1);
1:         assertEquals("FAIL -- wrong clob length", 1, new_length);
1:         // Check contents ...
0:         Reader lStream = rs3.getClob(1).getCharacterStream();
1:         char clobchar = (char) lStream.read();
1:         assertEquals("FAIL - fetched Clob and original contents do " +
1:                 "not match", testchar, clobchar);
1: 
1:         lStream.close();
1:         rs3.close();
1:         stmt3.close();
1:     }
1: 
1:     public static Test suite() {
0:         final TestSuite suite = new TestSuite();
1: 
0:         // Run with DerbyNetClient only
0:         if (usingDerbyNetClient()) {
0:             suite.addTest(new LobStreamsTest("testBlobWrite1Param"));
0:             suite.addTest(new LobStreamsTest("testBlobWrite3Param"));
0:             suite.addTest(new LobStreamsTest("testClobAsciiWrite1Param"));
0:             suite.addTest(new LobStreamsTest("testClobAsciiWrite3Param"));
0:             suite.addTest(new
0:                     LobStreamsTest("testClobCharacterWrite1Char"));
0:             suite.addTest(new
0:                     LobStreamsTest("testClobCharacterWrite1ParamString"));
0:             suite.addTest(new
0:                     LobStreamsTest("testClobCharacterWrite3ParamChar"));
0:             suite.addTest(new
0:                     LobStreamsTest("testClobCharacterWrite3ParamString"));
1:         }
1: 
0:         return suite;
1:     }
1: 
1: 
1:     private boolean compareLob2File(
1:             InputStream fStream,
1:             InputStream lStream) throws Exception
1:     {
1:         byte[] fByte = new byte[1024];
1:         byte[] lByte = new byte[1024];
1:         int lLength = 0, fLength = 0;
1:         String fString, lString;
1: 
1:         do {
0:             fLength = fStream.read(fByte, 0, 1024);
0:             lLength = lStream.read(lByte, 0, 1024);
1:             if (!java.util.Arrays.equals(fByte, lByte))
1:                 return false;
1:         } while (fLength > 0 && lLength > 0);
1: 
1:         fStream.close();
1:         lStream.close();
1: 
1:         return true;
1:     }
1: 
1:     private boolean compareClobReader2CharArray(
1:             char[] cArray,
1:             Reader charReader) throws Exception
1:     {
1:         char[] clobChars = new char[cArray.length];
1: 
1:         int readChars = 0;
1:         int totalCharsRead = 0;
1: 
1:         do {
1:             readChars = charReader.read(clobChars, totalCharsRead, cArray.length - totalCharsRead);
1:             if (readChars != -1)
1:                 totalCharsRead += readChars;
1:         } while (readChars != -1 && totalCharsRead < cArray.length);
1:         charReader.close();
1:         if (!java.util.Arrays.equals(cArray, clobChars))
1:             return false;
1: 
1:         return true;
1:     }
1: 
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:e60f8a6
/////////////////////////////////////////////////////////////////////////
0:      * Embedded Clob/Blob.setXXXStream() methods are not implmented.
commit:eba07fc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         getConnection().setAutoCommit(false);
1:         Statement stmt1 = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt2 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt3 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt4 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt3 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt4 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt3 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt4 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt3 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt4 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt3 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt4 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt3 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt4 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt3 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt4 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt3 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement stmt4 = prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Run with DerbyNetClient only.
0:      * @return
1:      */
0:                 
0:         return TestConfiguration.clientServerSuite(LobStreamsTest.class);
============================================================================