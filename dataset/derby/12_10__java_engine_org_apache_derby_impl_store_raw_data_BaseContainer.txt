1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.data.BaseContainer
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
5:eac0369: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.raw.data;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:3c1f634: import org.apache.derby.iapi.services.locks.CompatibilitySpace;
1:eac0369: import org.apache.derby.iapi.services.locks.Lockable;
1:eac0369: import org.apache.derby.iapi.services.locks.Latch;
1:eac0369: import org.apache.derby.iapi.services.locks.C_LockFactory;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.store.access.SpaceInfo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.Page;
1:eac0369: import org.apache.derby.iapi.store.raw.PageKey;
1:eac0369: import org.apache.derby.iapi.store.raw.PageTimeStamp;
1:eac0369: import org.apache.derby.iapi.store.raw.RecordHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.Transaction;
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerKey;
1:eac0369: import org.apache.derby.iapi.store.raw.data.RawContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.log.LogInstant;
1:eac0369: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.util.ByteArray;
1:eac0369: 
1:eac0369: import java.util.Properties;
1:eac0369: import java.util.Hashtable;
1:eac0369: 
1:ae71c74: /**
1:eac0369: 	BaseContainer is an abstract class that provides the locking bahaviour
1:eac0369: 	for an object representing an active container, that is the actual
1:eac0369: 	storage container, not the ContainerHandle interface. This class is designed
1:eac0369: 	so that it can change the container it represents to avoid creating
1:eac0369: 	a new object for every container.
1:eac0369: 	<P>
1:eac0369: 	This object implements lockable to provide an object to lock while a page is being
1:eac0369: 	allocated.
1:eac0369: 	<BR> MT - Mutable - mutable identity : 
1:25f99f5: */
1:7a92d1f: abstract class BaseContainer implements Lockable {
1:eac0369: 
3:eac0369: 	/**
1:eac0369: 		Identity of the container.
1:eac0369: 
1:eac0369: 		<BR> MT - Mutable
1:eac0369: 	*/
1:eac0369: 	protected ContainerKey identity;
1:eac0369: 
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 		Dropped state of the container.
1:eac0369: 
1:eac0369: 		<BR> MT - mutable : single thread required. Either the container must be exclusive
1:eac0369: 		locked by this thread, or the container must have no identity (ie. it is being created
1:eac0369: 		or opened).
1:eac0369: 	*/
1:eac0369: 	protected boolean	isDropped;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:01a4f9b: 		Committed Drop state of the container.  If a post commit action
1:eac0369: 		determined that the drop container operation is committed, the whole
1:eac0369: 		container may be removed and space reclaimed.
1:eac0369: 
1:eac0369: 		<BR> MT - mutable : single thread required. Either the container must be exclusive
1:eac0369: 		locked by this thread, or the container must have no identity (ie. it is being created
1:eac0369: 		or opened).
1:eac0369: 	*/
1:eac0369: 	protected boolean isCommittedDrop;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Is reusable recordId.  By default, record Ids are not reusable when a
1:eac0369: 		page is reused.  However, under special circumstances, clients to raw
1:eac0369: 		store may decide that record Ids may be reused after the page is
1:eac0369: 		reused.   When this flag is set, pages that are reused will have its
1:eac0369: 		next recordId set to RecordHandle.FIRST_RECORD_ID
1:eac0369: 	*/
1:eac0369: 	protected boolean isReusableRecordId = false;
1:eac0369: 
1:7a92d1f: 	BaseContainer() {
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** portions of Cacheable interface, interface is actually implemented by
1:eac0369: 	** sub-class. This section also contains methods related to this interface.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	protected void fillInIdentity(ContainerKey key) {
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(identity == null || (identity == key));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		identity = key;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void clearIdentity() {
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(identity != null);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		identity = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Object getIdentity() {
1:eac0369: 		return identity;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods from Lockable, just require a single exclusive locker
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public void lockEvent(Latch lockInfo) {
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(identity != null);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public boolean requestCompatible(Object requestedQualifier, Object grantedQualifier) {
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(identity != null);
1:eac0369: 		}
1:eac0369: 		return false;
1:eac0369: 	}
1:25f99f5: 
1:eac0369: 	public boolean lockerAlwaysCompatible() {
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(identity != null);
1:eac0369: 		}
1:eac0369: 		return false;
1:eac0369: 	}
1:25f99f5: 
1:eac0369: 	public void unlockEvent(Latch lockInfo) {
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(identity != null);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Implementation specific methods
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:bbc927c: 		Release free space to the OS.
1:bbc927c: 		<P>
1:bbc927c:         As is possible release any free space to the operating system.  This
1:bbc927c:         will usually mean releasing any free pages located at the end of the
1:bbc927c:         file using the java truncate() interface.
1:bbc927c: 
1:94f158a: 		@exception StandardException	Standard Derby error policy
1:bbc927c: 	*/
1:bbc927c: 	public void compressContainer(BaseContainerHandle handle)
1:bbc927c:         throws StandardException
1:bbc927c:     {
1:bbc927c: 		RawTransaction ntt = handle.getTransaction().startNestedTopTransaction();
1:bbc927c: 
1:bbc927c: 		int mode = handle.getMode(); 
1:bbc927c: 
1:bbc927c: 		if (SanityManager.DEBUG)
1:bbc927c: 		{
1:bbc927c: 			SanityManager.ASSERT((mode & ContainerHandle.MODE_FORUPDATE) ==
1:bbc927c: 								 ContainerHandle.MODE_FORUPDATE, 
1:bbc927c: 								 "addPage handle not for update");
1:bbc927c: 		}
1:bbc927c: 
1:bbc927c: 		// if we are not in the same transaction as the one which created the
1:bbc927c: 		// container and the container may have logged some operation already, 
1:bbc927c: 		// then we need to log allocation regardless of whether user changes
1:bbc927c: 		// are logged.  Otherwise, the database will be corrupted if it
1:bbc927c: 		// crashed. 
1:bbc927c: 		if ((mode & ContainerHandle.MODE_CREATE_UNLOGGED) == 0 &&
1:bbc927c: 			(mode & ContainerHandle.MODE_UNLOGGED) ==
1:bbc927c: 						ContainerHandle.MODE_UNLOGGED) 
1:bbc927c: 			mode &= ~ContainerHandle.MODE_UNLOGGED;
1:bbc927c: 
1:bbc927c: 		// make a handle which is tied to the ntt, not to the user transaction 
1:bbc927c:         // this handle is tied to.  The container is already locked by the 
1:bbc927c:         // user transaction, open it nolock
1:bbc927c: 		BaseContainerHandle allocHandle = (BaseContainerHandle)
1:bbc927c:             ntt.openContainer(identity, (LockingPolicy)null, mode);
1:bbc927c: 
1:bbc927c: 		if (allocHandle == null)
1:bbc927c:         {
1:bbc927c: 			throw StandardException.newException(
1:bbc927c:                     SQLState.DATA_ALLOC_NTT_CANT_OPEN, 
1:ce40a31:                     getSegmentId(), 
1:ce40a31:                     getContainerId());
1:bbc927c:         }
1:bbc927c: 
1:3c1f634: 		CompatibilitySpace cs = ntt.getCompatibilitySpace();
1:bbc927c: 		// Latch this container, the commit will release the latch
1:bbc927c: 		ntt.getLockFactory().lockObject(
1:3c1f634:                 cs, ntt, this, null, C_LockFactory.WAIT_FOREVER);
1:bbc927c: 
1:bbc927c: 		try
1:bbc927c: 		{
1:d376440:             incrementReusableRecordIdSequenceNumber();						
1:bbc927c:             compressContainer(ntt, allocHandle);
1:bbc927c: 		}
1:bbc927c: 		finally
1:bbc927c: 		{
1:bd54198:             ntt.commit();
1:06dbbcf: 
1:bbc927c: 			ntt.close();
1:bbc927c: 		}
1:bbc927c:     }
1:bbc927c: 
1:bbc927c: 	/**
1:d376440: 	 * Get the reusable RecordId sequence number for the
1:d376440: 	 * container. This sequence number should be incremented every time
1:d376440: 	 * there is an operation which may cause RecorIds to be reused.
1:d376440: 	 * This method can be used by clients to check if a RecordId they 
1:d376440: 	 * obtained is still guaranteed to be valid.
1:d376440: 	 * If the sequence number has changed, the RecordId may have been
1:d376440: 	 * reused for another row.
1:d376440: 	 * @return sequence number for reusable RecordId
1:d376440: 	 */
1:d376440: 	public abstract long getReusableRecordIdSequenceNumber();
1:d376440: 
1:d376440: 	/**
1:d376440: 	 * Increment the reusable RecordId sequence number.
1:d376440: 	 */
1:d376440: 	protected abstract void incrementReusableRecordIdSequenceNumber();
1:d376440: 	
1:d376440: 
1:d376440: 	/**
1:eac0369: 		Add a page to this container.
1:eac0369: 
1:eac0369: 		<BR> MT - thread aware - 
1:eac0369: 
1:eac0369: 		The add page operation involves 2 transactions, one is the user
1:eac0369: 		transaction (the transaction which owns the passed in handle), the
1:eac0369: 		other one is a NestedTopTransaction created by this BaseContainer.
1:eac0369: 
1:eac0369: 		The nestedTopTransaction is used by the underlying container to change
1:eac0369: 		high contention structures, such as link list anchor or bit map pages.
1:eac0369: 		The nestedTopTransaction commits or aborts before this routine returns.
1:eac0369: 
1:eac0369: 		The user transaction is used to latch the newly created page.
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	public Page addPage(BaseContainerHandle handle, boolean isOverflow) throws StandardException {
1:eac0369: 		
1:eac0369: 		RawTransaction ntt = handle.getTransaction().startNestedTopTransaction();
1:eac0369: 
1:eac0369: 		int mode = handle.getMode(); 
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT((mode & ContainerHandle.MODE_FORUPDATE) ==
1:eac0369: 								 ContainerHandle.MODE_FORUPDATE, 
1:eac0369: 								 "addPage handle not for update");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// if we are not in the same transaction as the one which created the
1:eac0369: 		// container and the container may have logged some operation already, 
1:eac0369: 		// then we need to log allocation regardless of whether user changes
1:eac0369: 		// are logged.  Otherwise, the database will be corrupted if it
1:eac0369: 		// crashed. 
1:eac0369: 		if ((mode & ContainerHandle.MODE_CREATE_UNLOGGED) == 0 &&
1:eac0369: 			(mode & ContainerHandle.MODE_UNLOGGED) ==
1:eac0369: 						ContainerHandle.MODE_UNLOGGED) 
1:eac0369: 			mode &= ~ContainerHandle.MODE_UNLOGGED;
1:eac0369: 
1:eac0369: 		// make a handle which is tied to the ntt, not to the user transaction this
1:eac0369: 		// handle is tied to.  The container is already locked by the user transaction,
1:eac0369: 		// open it nolock
1:eac0369: 		BaseContainerHandle allocHandle = (BaseContainerHandle)ntt.openContainer
1:eac0369: 			(identity, (LockingPolicy)null, mode);
1:eac0369: 
1:eac0369: 		if (allocHandle == null)
1:eac0369:         {
1:eac0369: 			throw StandardException.newException(
1:eac0369:                     SQLState.DATA_ALLOC_NTT_CANT_OPEN, 
1:ce40a31:                     getSegmentId(), 
1:ce40a31:                     getContainerId());
1:eac0369:         }
1:eac0369: 
1:eac0369: 		// Latch this container, the commit will release the latch
1:3c1f634: 		CompatibilitySpace cs = ntt.getCompatibilitySpace();
1:eac0369: 		ntt.getLockFactory().lockObject(
1:3c1f634:                 cs, ntt, this, null, C_LockFactory.WAIT_FOREVER);
1:eac0369: 
1:eac0369: 		BasePage newPage = null;
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			newPage = newPage(handle, ntt, allocHandle, isOverflow);
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			if (newPage != null)
1:eac0369:             {
1:eac0369:                 // it is ok to commit without syncing, as it is ok if this
1:eac0369:                 // transaction never makes it to the db, if no subsequent
1:eac0369:                 // log record makes it to the log.  If any subsequent log
1:eac0369:                 // record is sync'd then this transaction will be sync'd
1:eac0369:                 // as well.
1:bbc927c: 				ntt.commitNoSync(Transaction.RELEASE_LOCKS);
1:eac0369:             }
1:eac0369: 			else
1:eac0369:             {      
1:eac0369: 				ntt.abort();
1:eac0369:             }
1:eac0369: 			ntt.close();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(newPage.isLatched());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (!this.identity.equals(newPage.getPageId().getContainerId())) {
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG) {
1:eac0369: 				SanityManager.THROWASSERT("BaseContainer.addPage(), just got a new page from a different container"
1:eac0369: 					+ "\n this.identity = " + this.identity
1:eac0369: 					+ "\n newPage.getPageId().getContainerId() = " + newPage.getPageId().getContainerId()
1:eac0369: 					+ "\n handle is: " + handle
1:eac0369: 					+ "\n allocHandle is: " + allocHandle
1:eac0369: 					+ "\n this container is: " + this);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			throw StandardException.newException(
1:eac0369:                     SQLState.DATA_DIFFERENT_CONTAINER,
1:eac0369:                     this.identity, newPage.getPageId().getContainerId());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return newPage;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Request the system properties associated with a container.
1:eac0369:      * <p>
1:eac0369:      * Request the value of properties that are associated with a container.  
1:eac0369:      * The following properties can be requested:
1:eac0369:      *     derby.storage.pageSize 
1:eac0369:      *     derby.storage.pageReservedSpace
1:eac0369:      *     derby.storage.minimumRecordSize
1:eac0369:      * <p>
1:eac0369:      * To get the value of a particular property add it to the property list,
1:eac0369:      * and on return the value of the property will be set to it's current 
1:eac0369:      * value.  For example:
1:ae71c74:      *
1:eac0369:      * get_prop(BaseContainer base)
1:eac0369:      * {
1:eac0369:      *     Properties prop = new Properties();
1:eac0369:      *     prop.put("derby.storage.pageSize", "");
1:eac0369:      *     base.getContainerProperties(prop);
1:eac0369:      *
1:eac0369:      *     System.out.println(
1:eac0369:      *         "container's page size = " + 
1:eac0369:      *         prop.getProperty("derby.storage.pageSize");
1:eac0369:      * }
1:eac0369:      *
1:eac0369:      * @param prop   Property list to fill in.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public abstract void getContainerProperties(Properties prop)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Remove a page from this container.  The page will be unlatched by this
1:eac0369: 		routine before it returns.
1:eac0369: 
1:eac0369: 		Unlike addPage, this method done as part of the user transaction.  
1:eac0369: 		The removed page is not usable by anyone until the user transaction 
1:eac0369:         comits.
1:eac0369: 		If the user transaction rolls back, the removed page is un-removed.
1:eac0369: 
1:eac0369: 		<BR> MT - thread aware -
1:eac0369: 
1:eac0369: 		@param handle the container handle that has opened the container and latched the page
1:eac0369: 		@param page the latched page that is to be deallocated
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected void removePage(BaseContainerHandle handle, BasePage page) 
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(page.isLatched(), "page is not latched");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// get dealloc lock nowait on the page to be deallocated
1:eac0369: 			// this lock is held until this transaction commits.
1:eac0369: 			// then gc can free this page
1:eac0369: 			RecordHandle deallocLock = 
1:eac0369: 				page.makeRecordHandle(RecordHandle.DEALLOCATE_PROTECTION_HANDLE);
1:eac0369: 
1:eac0369: 			// don't get deallocLock wait because caller have a page latched
1:eac0369: 			if (!getDeallocLock(handle, deallocLock, 
1:eac0369: 								false /* no wait */,
1:eac0369: 								false /* not zeroDuration */))
1:eac0369:             {
1:eac0369: 				throw StandardException.newException(
1:eac0369:                         SQLState.DATA_CANNOT_GET_DEALLOC_LOCK, 
1:eac0369:                         page.getIdentity());
1:eac0369:             }
1:eac0369: 
1:eac0369: 			deallocatePage(handle, page);
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			if (page != null)
1:eac0369: 				page.unlatch();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the special dealloc lock on the page - the lock is gotten by the
1:eac0369: 		transaction that owns the container handle
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected boolean getDeallocLock(BaseContainerHandle handle, 
1:eac0369: 									 RecordHandle deallocLock, 
1:eac0369: 									 boolean wait,
1:eac0369: 									 boolean zeroDuration)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		// get deallocate lock on page so that the GC won't attempt to 
1:eac0369: 		// free and re-allocate it until the transaction commits
1:eac0369: 		RawTransaction tran = handle.getTransaction();
1:eac0369: 
1:eac0369: 		LockingPolicy lp = 
1:eac0369:             tran.newLockingPolicy(
1:eac0369:                 LockingPolicy.MODE_RECORD,
1:eac0369:                 TransactionController.ISOLATION_REPEATABLE_READ, 
1:eac0369:                 true); // striterOK
1:eac0369: 		
1:eac0369: 		PageKey pkey = new PageKey(identity, deallocLock.getPageNumber());
1:eac0369: 		if (lp != null)
1:eac0369:         {
1:eac0369: 			if (zeroDuration)
1:eac0369: 				return lp.zeroDurationLockRecordForWrite(
1:eac0369:                         tran, deallocLock, false, wait); 
1:eac0369: 			else
1:eac0369: 				return lp.lockRecordForWrite(tran, deallocLock, false, wait);
1:eac0369:         }
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(
1:eac0369:                     SQLState.DATA_CANNOT_GET_DEALLOC_LOCK, pkey);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get an allocation page and latch it.
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected Page getAllocPage(BaseContainerHandle handle, long pageNumber, boolean wait)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		return latchPage(handle, getAllocPage(pageNumber), wait);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get any page and latch it .
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected Page getAnyPage(BaseContainerHandle handle, long pageNumber, boolean wait)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		return latchPage(handle, getAnyPage(handle, pageNumber), wait);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the first valid page. Result is latched.
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected Page getFirstPage(BaseContainerHandle handle) throws StandardException
1:eac0369: 	{
1:eac0369: 		return getFirstHeadPage(handle, true /* wait */);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the next valid page and latch it
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected Page getNextPage(BaseContainerHandle handle, long pageNumber)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		return getNextHeadPage(handle, pageNumber, true /* wait */);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 		utility to latch a page
1:eac0369: 	*/
1:eac0369: 	protected BasePage latchPage(BaseContainerHandle handle, BasePage foundPage, boolean wait)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (foundPage != null) {
1:eac0369: 			 if (wait) {
1:eac0369: 				foundPage.setExclusive(handle);
1:eac0369: 			 } else {
1:eac0369: 				 if (!foundPage.setExclusiveNoWait(handle))
1:eac0369: 				 {
1:eac0369: 					 // sub-class will release page from the cache if required.
1:eac0369: 					 return null;
1:eac0369: 				 }
1:eac0369: 			 }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT((foundPage == null) || foundPage.isLatched());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return foundPage;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Lock the container and mark the container as in-use by this container handle.
1:eac0369: 
1:eac0369: 		@param droppedOK if true, use this container even if it is dropped.,
1:eac0369: 		@return true if the container can be used, false if it has been dropped
1:eac0369: 		since the lock was requested and droppedOK is not true.
1:eac0369: 
1:eac0369: 		@exception StandardException I cannot be opened for update.
1:eac0369: 	*/
1:eac0369: 	protected boolean use(BaseContainerHandle handle, boolean forUpdate,
1:eac0369: 						  boolean droppedOK) 
1:eac0369: 		throws StandardException {
1:eac0369: 
1:eac0369: 		// see if the container can be updated
1:eac0369: 		if (forUpdate && !canUpdate())
1:eac0369:         {
1:eac0369: 			throw StandardException.newException(
1:eac0369:                     SQLState.DATA_CONTAINER_READ_ONLY);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		// if the container is dropped, cannot see if unless droppedOK is set
1:eac0369: 		if (!droppedOK && (getDroppedState() || getCommittedDropState())) {
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Discontinue use of this container. Note that the unlockContainer
1:eac0369: 		call made from this method may not release any locks. The container
1:eac0369: 		lock may be held until the end of the transaction.
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	protected void letGo(BaseContainerHandle handle) {
1:eac0369: 
1:eac0369: 		RawTransaction t = handle.getTransaction();
1:eac0369: 
1:eac0369: 		handle.getLockingPolicy().unlockContainer(t, handle);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected boolean getDroppedState() {
1:eac0369: 		return isDropped;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected boolean getCommittedDropState()
1:eac0369: 	{
1:eac0369: 		return isCommittedDrop;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	protected boolean isReusableRecordId()
1:eac0369: 	{
1:eac0369: 		return isReusableRecordId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int getContainerStatus()
1:eac0369: 	{
1:eac0369: 		if (getCommittedDropState())
1:eac0369: 			return RawContainerHandle.COMMITTED_DROP;
1:eac0369: 
1:eac0369: 		if (getDroppedState())
1:eac0369: 			return RawContainerHandle.DROPPED;
1:eac0369: 
1:eac0369: 		return RawContainerHandle.NORMAL;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public long getContainerId() {
1:eac0369: 		return identity.getContainerId();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public long getSegmentId() {
1:eac0369: 		return identity.getSegmentId();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	//public int getPageSize() {
1:eac0369: 	//	return pageSize();
1:eac0369: 	//}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	**	Methods that need to be provided by a sub-class.
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Get information about space used by the container.
1:eac0369:     **/
1:eac0369:     protected abstract SpaceInfo getSpaceInfo(BaseContainerHandle handle)
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Can the container be updated.
1:eac0369: 
1:eac0369: 		@return true if the container can be updated, false otherwise.
1:eac0369: 	*/
1:eac0369: 	protected abstract boolean canUpdate();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		The container is about to be modified.
1:eac0369: 		Loggable actions use this to make sure the container gets cleaned if a
1:eac0369: 		checkpoint is taken after any log record is sent to the log stream but
1:eac0369: 		before the container is actually dirtied.
1:eac0369: 	 */
1:eac0369: 	protected abstract void preDirty(boolean preDirtyOn);
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return a BasePage that represents the given page number in this container.
1:eac0369:         The resulting page is latched.
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected abstract BasePage getPage(BaseContainerHandle handle, long pageNumber,
1:eac0369:         boolean wait) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return a BasePage that represents the given alloc page number in this container.
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected abstract BasePage getAllocPage(long pageNumber) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return a BasePage that represents any page - alloc page, valid page, free page,
1:eac0369: 		dealloced page etc.  The only requirement is that the page is initialized...
1:eac0369: 
1:94f158a: 		@exception StandardException Derby Standard error policy
1:eac0369: 	*/
1:eac0369: 	protected abstract BasePage getAnyPage(BaseContainerHandle handle, long pageNumber)
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:f57b07d:     /**
1:f57b07d:      * ReCreate a page for rollforward recovery.  
1:f57b07d:      * <p>
1:f57b07d:      * During redo recovery it is possible for the system to try to redo
1:f57b07d:      * the creation of a page (ie. going from non-existence to version 0).
1:f57b07d:      * It first trys to read the page from disk, but a few different types
1:f57b07d:      * of errors can occur:
1:f57b07d:      *     o the page does not exist at all on disk, this can happen during
1:f57b07d:      *       rollforward recovery applied to a backup where the file was
1:f57b07d:      *       copied and the page was added to the file during the time frame
1:f57b07d:      *       of the backup but after the physical file was copied.
1:f57b07d:      *     o space in the file exists, but it was never initalized.  This
1:f57b07d:      *       can happen if you happen to crash at just the right moment during
1:f57b07d:      *       the allocation process.  Also
1:f57b07d:      *       on some OS's it is possible to read from a part of the file that
1:f57b07d:      *       was not ever written - resulting in garbage from the store's 
1:f57b07d:      *       point of view (often the result is all 0's).  
1:f57b07d:      *
1:f57b07d:      * All these errors are easy to recover from as the system can easily 
1:f57b07d:      * create a version 0 from scratch and write it to disk.
1:f57b07d:      *
1:f57b07d:      * Because the system does not sync allocation of data pages, it is also
1:f57b07d:      * possible at this point that whlie writing the version 0 to disk to 
1:f57b07d:      * create it we may encounter an out of disk space error (caught in this
1:f57b07d:      * routine as a StandardException from the create() call.  We can't 
1:f57b07d:      * recovery from this without help from outside, so the caught exception
1:f57b07d:      * is nested and a new exception thrown which the recovery system will
1:f57b07d:      * output to the user asking them to check their disk for space/errors.
1:f57b07d:      *
1:f57b07d:      * The arguments passed in need to be sufficient for the page cache to 
1:f57b07d:      * materialize a brand new page and write it to disk.  
1:f57b07d:      *
1:f57b07d: 	 * @exception  StandardException  Standard exception policy.
1:f57b07d:      **/
1:eac0369: 	protected abstract BasePage
1:f57b07d: 	reCreatePageForRedoRecovery(
1:f57b07d:     BaseContainerHandle handle,
1:f57b07d:     int pageFormat,
1:f57b07d:     long pageNumber,
1:f57b07d:     long pageOffset)
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Log all information on the container creation necessary to recreate teh
1:eac0369: 		container during a load tran.
1:eac0369: 
1:94f158a: 		@exception StandardException Derby Standard error policy
1:eac0369: 	 */
1:eac0369: 	 protected abstract ByteArray logCreateContainerInfo()
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get only a valid, non-overflow page.  If page number is either invalid
1:eac0369: 		or overflow, returns null
1:eac0369: 
1:94f158a: 		@exception StandardException Derby Standard error policy
1:eac0369: 	 */
1:eac0369: 	protected abstract BasePage getHeadPage(BaseContainerHandle handle,
1:eac0369:         long pagenumber, boolean wait) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the first page in the container.
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected abstract BasePage getFirstHeadPage(BaseContainerHandle handle,
1:eac0369:         boolean wait) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the next page in the container.
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected abstract BasePage getNextHeadPage(BaseContainerHandle handle,
1:eac0369:         long pageNumber, boolean wait) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a potentially suitable page for insert and latch it.
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	protected abstract BasePage getPageForInsert(BaseContainerHandle handle,
1:eac0369: 												 int flag)
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:bbc927c: 	protected abstract BasePage getPageForCompress(
1:bbc927c:     BaseContainerHandle handle,
1:bbc927c:     int                 flag,
1:bbc927c:     long                pageno)
1:bbc927c: 		 throws StandardException;
1:bbc927c: 
1:06dbbcf: 	protected abstract void truncatePages(long lastValidPagenum)
1:06dbbcf:         throws StandardException;
1:bbc927c: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Create a new page in the container.
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected abstract BasePage newPage(BaseContainerHandle userhandle,
1:eac0369: 										RawTransaction t,
1:eac0369: 										BaseContainerHandle allocHandle,
1:eac0369: 										boolean isOverflow) throws StandardException;
1:eac0369: 
1:bbc927c: 	protected abstract void compressContainer(
1:bbc927c:     RawTransaction      t,
1:bbc927c:     BaseContainerHandle allocHandle)
1:bbc927c:         throws StandardException;
1:bbc927c: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Deallocate a page from the container.
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected abstract void deallocatePage(BaseContainerHandle userhandle,
1:eac0369: 										   BasePage page) throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	protected void truncate(BaseContainerHandle handle) throws StandardException {
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.THROWASSERT("truncate not supported");
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Mark the container as drop or not drop depending on the input value.
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	protected abstract void dropContainer(LogInstant instant, boolean drop);
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Remove the container and reclaim its space.  Once executed, this
1:eac0369: 		operation cannot be undone - as opposed to dropContainer which only
1:eac0369: 		marks the container as dropped and can be rolled back.
1:eac0369: 		<BR><B> This operation should only be called by post commit clean up </B>
1:eac0369: 
1:eac0369: 		@param leaveStub if true, leave a stub.  If false, remove everything
1:eac0369: 		@see org.apache.derby.iapi.store.raw.data.RawContainerHandle#removeContainer
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected abstract void removeContainer(LogInstant instant, boolean leaveStub) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the logged container version.
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected abstract long getContainerVersion() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Flush all outstanding changes in this container to persistent storage.
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	protected abstract void flushAll() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		The container will be grown vastly, prepare for it.
1:eac0369: 	*/
1:eac0369: 	protected abstract void prepareForBulkLoad(BaseContainerHandle handle,
1:eac0369: 											   int numPage);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		The container will have no pre-allocate threshold, i.e., if the
1:eac0369: 		implementation supports it, page preallocation will happen
1:eac0369: 		the next time a new page is allocated.
1:eac0369: 	*/
1:eac0369: 	protected abstract void clearPreallocThreshold();
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 		Cost estimates
1:eac0369: 	*/
1:eac0369: 	/**
1:eac0369: 		@see ContainerHandle#getEstimatedRowCount
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	public abstract long getEstimatedRowCount(int flag) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ContainerHandle#setEstimatedRowCount
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	public abstract void setEstimatedRowCount(long count, int flag) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see ContainerHandle#getEstimatedPageCount
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	public abstract long getEstimatedPageCount(BaseContainerHandle handle, int flag) throws StandardException;
1:eac0369: 
1:25f99f5: 	/**
1:bf643fd:      * Backup the container to the specified path.
1:bf643fd:      * 
1:ae71c74:      * @param handle the container handle.
1:be3e2aa:      * @param backupContainerPath  location of the backup container. 
1:bf643fd:      * @exception StandardException Standard Derby error policy 
1:bf643fd:      */
1:25f99f5: 	protected abstract void  backupContainer(BaseContainerHandle handle, 
1:25f99f5: 											 String backupContainerPath) throws StandardException ;
1:ae71c74: 
1:ae71c74: 
1:eac0369:     /**
1:89a6625:      * Creates encrypted or decrypted version of the container.
1:eac0369:      *
1:89a6625:      * @param handle the container handle
1:89a6625:      * @param newFilePath file to store the new version of the container
1:89a6625:      * @param doEncrypt tells whether to encrypt or decrypt
1:ae71c74:      * @exception StandardException Standard Derby error policy 
1:ae71c74:      */
1:89a6625:     protected abstract void encryptOrDecryptContainer(
1:89a6625:                                              BaseContainerHandle handle,
1:89a6625:                                              String newFilePath,
1:89a6625:                                              boolean doEncrypt)
1:89a6625:             throws StandardException;
1:25f99f5: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods to be used by sub-classes.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set the container's dropped state
1:eac0369: 	*/
1:eac0369: 	protected void setDroppedState(boolean isDropped) {
1:eac0369: 		this.isDropped = isDropped;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected void setCommittedDropState(boolean isCommittedDrop)
1:eac0369: 	{
1:eac0369: 		this.isCommittedDrop = isCommittedDrop;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	protected void setReusableRecordIdState(boolean isReusableRecordId)
1:eac0369: 	{
1:eac0369: 		this.isReusableRecordId = isReusableRecordId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//protected void setPageSize(int pageSize) {
1:eac0369: 	//	identity.setPageSize(pageSize);
1:eac0369: 	//}
1:eac0369: 
1:eac0369: 	// Not interested in participating in the diagnostic virtual lock table.
1:eac0369: 	public boolean lockAttributes(int flag, Hashtable attributes)
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	
1:eac0369: 
1:eac0369: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                     getSegmentId(), 
1:                     getContainerId());
/////////////////////////////////////////////////////////////////////////
1:                     getSegmentId(), 
1:                     getContainerId());
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:89a6625
/////////////////////////////////////////////////////////////////////////
1:      * Creates encrypted or decrypted version of the container.
1:      * @param handle the container handle
1:      * @param newFilePath file to store the new version of the container
1:      * @param doEncrypt tells whether to encrypt or decrypt
1:     protected abstract void encryptOrDecryptContainer(
1:                                              BaseContainerHandle handle,
1:                                              String newFilePath,
1:                                              boolean doEncrypt)
1:             throws StandardException;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:01a4f9b
/////////////////////////////////////////////////////////////////////////
1: 		Committed Drop state of the container.  If a post commit action
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Derby Standard error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Derby Standard error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Derby Standard error policy
1: 		@exception StandardException Standard Derby error policy
1: 		@exception StandardException Standard Derby error policy
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
1: 		@exception StandardException Standard Derby error policy
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
1: 		@exception StandardException Standard Derby error policy
1: 		@exception StandardException Standard Derby error policy
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3c1f634
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.locks.CompatibilitySpace;
/////////////////////////////////////////////////////////////////////////
1: 		CompatibilitySpace cs = ntt.getCompatibilitySpace();
1:                 cs, ntt, this, null, C_LockFactory.WAIT_FOREVER);
/////////////////////////////////////////////////////////////////////////
1: 		CompatibilitySpace cs = ntt.getCompatibilitySpace();
1:                 cs, ntt, this, null, C_LockFactory.WAIT_FOREVER);
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:ae71c74
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Create encrypted version of the  container with the 
0:      * user specified encryption properties. 
1:      *
1:      * @param handle the container handle.
0:      * @param newFilePath file to store the new encrypted version of the container
1:      * @exception StandardException Standard Derby error policy 
1:      */
0: 	protected abstract void  encryptContainer(BaseContainerHandle handle, 
0:                                               String newFilePath) 
0:         throws StandardException ;
1: 
1: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:d376440
/////////////////////////////////////////////////////////////////////////
1:             incrementReusableRecordIdSequenceNumber();						
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the reusable RecordId sequence number for the
1: 	 * container. This sequence number should be incremented every time
1: 	 * there is an operation which may cause RecorIds to be reused.
1: 	 * This method can be used by clients to check if a RecordId they 
1: 	 * obtained is still guaranteed to be valid.
1: 	 * If the sequence number has changed, the RecordId may have been
1: 	 * reused for another row.
1: 	 * @return sequence number for reusable RecordId
1: 	 */
1: 	public abstract long getReusableRecordIdSequenceNumber();
1: 
1: 	/**
1: 	 * Increment the reusable RecordId sequence number.
1: 	 */
1: 	protected abstract void incrementReusableRecordIdSequenceNumber();
1: 	
1: 
1: 	/**
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:f57b07d
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * ReCreate a page for rollforward recovery.  
1:      * <p>
1:      * During redo recovery it is possible for the system to try to redo
1:      * the creation of a page (ie. going from non-existence to version 0).
1:      * It first trys to read the page from disk, but a few different types
1:      * of errors can occur:
1:      *     o the page does not exist at all on disk, this can happen during
1:      *       rollforward recovery applied to a backup where the file was
1:      *       copied and the page was added to the file during the time frame
1:      *       of the backup but after the physical file was copied.
1:      *     o space in the file exists, but it was never initalized.  This
1:      *       can happen if you happen to crash at just the right moment during
1:      *       the allocation process.  Also
1:      *       on some OS's it is possible to read from a part of the file that
1:      *       was not ever written - resulting in garbage from the store's 
1:      *       point of view (often the result is all 0's).  
1:      *
1:      * All these errors are easy to recover from as the system can easily 
1:      * create a version 0 from scratch and write it to disk.
1:      *
1:      * Because the system does not sync allocation of data pages, it is also
1:      * possible at this point that whlie writing the version 0 to disk to 
1:      * create it we may encounter an out of disk space error (caught in this
1:      * routine as a StandardException from the create() call.  We can't 
1:      * recovery from this without help from outside, so the caught exception
1:      * is nested and a new exception thrown which the recovery system will
1:      * output to the user asking them to check their disk for space/errors.
1:      *
1:      * The arguments passed in need to be sufficient for the page cache to 
1:      * materialize a brand new page and write it to disk.  
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	reCreatePageForRedoRecovery(
1:     BaseContainerHandle handle,
1:     int pageFormat,
1:     long pageNumber,
1:     long pageOffset)
commit:be3e2aa
/////////////////////////////////////////////////////////////////////////
1:      * @param backupContainerPath  location of the backup container. 
commit:bf643fd
/////////////////////////////////////////////////////////////////////////
1:      * Backup the container to the specified path.
1:      * 
0:      * @param handle the container handle.
0:      * @param backupConatainerPath  location of the backup container. 
1:      * @exception StandardException Standard Derby error policy 
1:      */
commit:25f99f5
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	   Backup the container to the specified path.
0: 	   @exception StandardException	Standard Cloudscape error policy
1: 	*/
1: 	protected abstract void  backupContainer(BaseContainerHandle handle, 
1: 											 String backupContainerPath) throws StandardException ;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	
1: 
commit:bd54198
/////////////////////////////////////////////////////////////////////////
1:             ntt.commit();
commit:06dbbcf
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 	protected abstract void truncatePages(long lastValidPagenum)
1:         throws StandardException;
commit:bbc927c
/////////////////////////////////////////////////////////////////////////
1: 		Release free space to the OS.
1: 		<P>
1:         As is possible release any free space to the operating system.  This
1:         will usually mean releasing any free pages located at the end of the
1:         file using the java truncate() interface.
1: 
0: 		@exception StandardException	Standard Cloudscape error policy
1: 	*/
1: 	public void compressContainer(BaseContainerHandle handle)
1:         throws StandardException
1:     {
1: 		RawTransaction ntt = handle.getTransaction().startNestedTopTransaction();
1: 
1: 		int mode = handle.getMode(); 
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT((mode & ContainerHandle.MODE_FORUPDATE) ==
1: 								 ContainerHandle.MODE_FORUPDATE, 
1: 								 "addPage handle not for update");
1: 		}
1: 
1: 		// if we are not in the same transaction as the one which created the
1: 		// container and the container may have logged some operation already, 
1: 		// then we need to log allocation regardless of whether user changes
1: 		// are logged.  Otherwise, the database will be corrupted if it
1: 		// crashed. 
1: 		if ((mode & ContainerHandle.MODE_CREATE_UNLOGGED) == 0 &&
1: 			(mode & ContainerHandle.MODE_UNLOGGED) ==
1: 						ContainerHandle.MODE_UNLOGGED) 
1: 			mode &= ~ContainerHandle.MODE_UNLOGGED;
1: 
1: 		// make a handle which is tied to the ntt, not to the user transaction 
1:         // this handle is tied to.  The container is already locked by the 
1:         // user transaction, open it nolock
1: 		BaseContainerHandle allocHandle = (BaseContainerHandle)
1:             ntt.openContainer(identity, (LockingPolicy)null, mode);
1: 
1: 		if (allocHandle == null)
1:         {
1: 			throw StandardException.newException(
1:                     SQLState.DATA_ALLOC_NTT_CANT_OPEN, 
0:                     new Long(getSegmentId()), 
0:                     new Long(getContainerId()));
1:         }
1: 
1: 		// Latch this container, the commit will release the latch
1: 		ntt.getLockFactory().lockObject(
0:                 ntt, ntt, this, null, C_LockFactory.WAIT_FOREVER);
1: 
1: 		try
1: 		{
1:             compressContainer(ntt, allocHandle);
1: 		}
1: 		finally
1: 		{
1:             ntt.commitNoSync(Transaction.RELEASE_LOCKS);
1: 			ntt.close();
1: 		}
1:     }
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	protected abstract BasePage getPageForCompress(
1:     BaseContainerHandle handle,
1:     int                 flag,
1:     long                pageno)
1: 		 throws StandardException;
1: 
0: 	protected abstract void truncatePages(long lastValidPagenum);
1: 
/////////////////////////////////////////////////////////////////////////
1: 	protected abstract void compressContainer(
1:     RawTransaction      t,
1:     BaseContainerHandle allocHandle)
1:         throws StandardException;
1: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7a92d1f
/////////////////////////////////////////////////////////////////////////
1: abstract class BaseContainer implements Lockable {
/////////////////////////////////////////////////////////////////////////
1: 	BaseContainer() {
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.data.BaseContainer
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:c6ad534
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.data;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.locks.Lockable;
1: import org.apache.derby.iapi.services.locks.Latch;
1: import org.apache.derby.iapi.services.locks.C_LockFactory;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.store.access.SpaceInfo;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
1: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.PageKey;
1: import org.apache.derby.iapi.store.raw.PageTimeStamp;
1: import org.apache.derby.iapi.store.raw.RecordHandle;
1: import org.apache.derby.iapi.store.raw.Transaction;
1: import org.apache.derby.iapi.store.raw.ContainerKey;
1: import org.apache.derby.iapi.store.raw.data.RawContainerHandle;
1: import org.apache.derby.iapi.store.raw.log.LogInstant;
1: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
1: 
1: import org.apache.derby.iapi.util.ByteArray;
1: 
1: import java.util.Properties;
1: import java.util.Hashtable;
1: 
1: /**
1: 	BaseContainer is an abstract class that provides the locking bahaviour
1: 	for an object representing an active container, that is the actual
1: 	storage container, not the ContainerHandle interface. This class is designed
1: 	so that it can change the container it represents to avoid creating
1: 	a new object for every container.
1: 	<P>
1: 	This object implements lockable to provide an object to lock while a page is being
1: 	allocated.
1: 	<BR> MT - Mutable - mutable identity : 
1: */
0: public abstract class BaseContainer implements Lockable {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/**
1: 		Identity of the container.
1: 
1: 		<BR> MT - Mutable
1: 	*/
1: 	protected ContainerKey identity;
1: 
1: 	
1: 	/**
1: 		Dropped state of the container.
1: 
1: 		<BR> MT - mutable : single thread required. Either the container must be exclusive
1: 		locked by this thread, or the container must have no identity (ie. it is being created
1: 		or opened).
1: 	*/
1: 	protected boolean	isDropped;
1: 
1: 
1: 	/**
0: 		Committed Drop state of the container.  If a post comit action
1: 		determined that the drop container operation is committed, the whole
1: 		container may be removed and space reclaimed.
1: 
1: 		<BR> MT - mutable : single thread required. Either the container must be exclusive
1: 		locked by this thread, or the container must have no identity (ie. it is being created
1: 		or opened).
1: 	*/
1: 	protected boolean isCommittedDrop;
1: 
1: 
1: 	/**
1: 		Is reusable recordId.  By default, record Ids are not reusable when a
1: 		page is reused.  However, under special circumstances, clients to raw
1: 		store may decide that record Ids may be reused after the page is
1: 		reused.   When this flag is set, pages that are reused will have its
1: 		next recordId set to RecordHandle.FIRST_RECORD_ID
1: 	*/
1: 	protected boolean isReusableRecordId = false;
1: 
0: 	protected BaseContainer() {
1: 	}
1: 
1: 	/*
1: 	** portions of Cacheable interface, interface is actually implemented by
1: 	** sub-class. This section also contains methods related to this interface.
1: 	*/
1: 
1: 	protected void fillInIdentity(ContainerKey key) {
1: 
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(identity == null || (identity == key));
1: 		}
1: 
1: 		identity = key;
1: 	}
1: 
1: 	public void clearIdentity() {
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(identity != null);
1: 		}
1: 
1: 		identity = null;
1: 	}
1: 
1: 	public Object getIdentity() {
1: 		return identity;
1: 	}
1: 
1: 	/*
1: 	** Methods from Lockable, just require a single exclusive locker
1: 	*/
1: 
1: 	public void lockEvent(Latch lockInfo) {
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(identity != null);
1: 		}
1: 	}
1: 
1: 	public boolean requestCompatible(Object requestedQualifier, Object grantedQualifier) {
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(identity != null);
1: 		}
1: 		return false;
1: 	}
1: 
1: 	public boolean lockerAlwaysCompatible() {
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(identity != null);
1: 		}
1: 		return false;
1: 	}
1: 
1: 	public void unlockEvent(Latch lockInfo) {
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(identity != null);
1: 		}
1: 	}
1: 
1: 	/*
1: 	** Implementation specific methods
1: 	*/
1: 
1: 
1: 	/**
1: 		Add a page to this container.
1: 
1: 		<BR> MT - thread aware - 
1: 
1: 		The add page operation involves 2 transactions, one is the user
1: 		transaction (the transaction which owns the passed in handle), the
1: 		other one is a NestedTopTransaction created by this BaseContainer.
1: 
1: 		The nestedTopTransaction is used by the underlying container to change
1: 		high contention structures, such as link list anchor or bit map pages.
1: 		The nestedTopTransaction commits or aborts before this routine returns.
1: 
1: 		The user transaction is used to latch the newly created page.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	public Page addPage(BaseContainerHandle handle, boolean isOverflow) throws StandardException {
1: 		
1: 		RawTransaction ntt = handle.getTransaction().startNestedTopTransaction();
1: 
1: 		int mode = handle.getMode(); 
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT((mode & ContainerHandle.MODE_FORUPDATE) ==
1: 								 ContainerHandle.MODE_FORUPDATE, 
1: 								 "addPage handle not for update");
1: 		}
1: 
1: 		// if we are not in the same transaction as the one which created the
1: 		// container and the container may have logged some operation already, 
1: 		// then we need to log allocation regardless of whether user changes
1: 		// are logged.  Otherwise, the database will be corrupted if it
1: 		// crashed. 
1: 		if ((mode & ContainerHandle.MODE_CREATE_UNLOGGED) == 0 &&
1: 			(mode & ContainerHandle.MODE_UNLOGGED) ==
1: 						ContainerHandle.MODE_UNLOGGED) 
1: 			mode &= ~ContainerHandle.MODE_UNLOGGED;
1: 
1: 		// make a handle which is tied to the ntt, not to the user transaction this
1: 		// handle is tied to.  The container is already locked by the user transaction,
1: 		// open it nolock
1: 		BaseContainerHandle allocHandle = (BaseContainerHandle)ntt.openContainer
1: 			(identity, (LockingPolicy)null, mode);
1: 
1: 		if (allocHandle == null)
1:         {
1: 			throw StandardException.newException(
1:                     SQLState.DATA_ALLOC_NTT_CANT_OPEN, 
0:                     new Long(getSegmentId()), 
0:                     new Long(getContainerId()));
1:         }
1: 
1: 		// Latch this container, the commit will release the latch
1: 		ntt.getLockFactory().lockObject(
0:                 ntt, ntt, this, null, C_LockFactory.WAIT_FOREVER);
1: 
1: 		BasePage newPage = null;
1: 		try
1: 		{
1: 			newPage = newPage(handle, ntt, allocHandle, isOverflow);
1: 		}
1: 		finally
1: 		{
1: 			if (newPage != null)
1:             {
1:                 // it is ok to commit without syncing, as it is ok if this
1:                 // transaction never makes it to the db, if no subsequent
1:                 // log record makes it to the log.  If any subsequent log
1:                 // record is sync'd then this transaction will be sync'd
1:                 // as well.
0: 				ntt.commitNoSync(Transaction.RELEASE_LOCKS);
1:             }
1: 			else
1:             {      
1: 				ntt.abort();
1:             }
1: 			ntt.close();
1: 		}
1: 
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(newPage.isLatched());
1: 		}
1: 
1: 		if (!this.identity.equals(newPage.getPageId().getContainerId())) {
1: 
1: 			if (SanityManager.DEBUG) {
1: 				SanityManager.THROWASSERT("BaseContainer.addPage(), just got a new page from a different container"
1: 					+ "\n this.identity = " + this.identity
1: 					+ "\n newPage.getPageId().getContainerId() = " + newPage.getPageId().getContainerId()
1: 					+ "\n handle is: " + handle
1: 					+ "\n allocHandle is: " + allocHandle
1: 					+ "\n this container is: " + this);
1: 			}
1: 
1: 			throw StandardException.newException(
1:                     SQLState.DATA_DIFFERENT_CONTAINER,
1:                     this.identity, newPage.getPageId().getContainerId());
1: 		}
1: 
1: 		return newPage;
1: 	}
1: 
1:     /**
1:      * Request the system properties associated with a container.
1:      * <p>
1:      * Request the value of properties that are associated with a container.  
1:      * The following properties can be requested:
1:      *     derby.storage.pageSize 
1:      *     derby.storage.pageReservedSpace
1:      *     derby.storage.minimumRecordSize
1:      * <p>
1:      * To get the value of a particular property add it to the property list,
1:      * and on return the value of the property will be set to it's current 
1:      * value.  For example:
1:      *
1:      * get_prop(BaseContainer base)
1:      * {
1:      *     Properties prop = new Properties();
1:      *     prop.put("derby.storage.pageSize", "");
1:      *     base.getContainerProperties(prop);
1:      *
1:      *     System.out.println(
1:      *         "container's page size = " + 
1:      *         prop.getProperty("derby.storage.pageSize");
1:      * }
1:      *
1:      * @param prop   Property list to fill in.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public abstract void getContainerProperties(Properties prop)
1: 		throws StandardException;
1: 
1: 	/**
1: 		Remove a page from this container.  The page will be unlatched by this
1: 		routine before it returns.
1: 
1: 		Unlike addPage, this method done as part of the user transaction.  
1: 		The removed page is not usable by anyone until the user transaction 
1:         comits.
1: 		If the user transaction rolls back, the removed page is un-removed.
1: 
1: 		<BR> MT - thread aware -
1: 
1: 		@param handle the container handle that has opened the container and latched the page
1: 		@param page the latched page that is to be deallocated
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected void removePage(BaseContainerHandle handle, BasePage page) 
1: 		 throws StandardException
1: 	{
1: 		try
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(page.isLatched(), "page is not latched");
1: 			}
1: 
1: 			// get dealloc lock nowait on the page to be deallocated
1: 			// this lock is held until this transaction commits.
1: 			// then gc can free this page
1: 			RecordHandle deallocLock = 
1: 				page.makeRecordHandle(RecordHandle.DEALLOCATE_PROTECTION_HANDLE);
1: 
1: 			// don't get deallocLock wait because caller have a page latched
1: 			if (!getDeallocLock(handle, deallocLock, 
1: 								false /* no wait */,
1: 								false /* not zeroDuration */))
1:             {
1: 				throw StandardException.newException(
1:                         SQLState.DATA_CANNOT_GET_DEALLOC_LOCK, 
1:                         page.getIdentity());
1:             }
1: 
1: 			deallocatePage(handle, page);
1: 		}
1: 		finally
1: 		{
1: 			if (page != null)
1: 				page.unlatch();
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 		Get the special dealloc lock on the page - the lock is gotten by the
1: 		transaction that owns the container handle
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected boolean getDeallocLock(BaseContainerHandle handle, 
1: 									 RecordHandle deallocLock, 
1: 									 boolean wait,
1: 									 boolean zeroDuration)
1: 		 throws StandardException
1: 	{
1: 		// get deallocate lock on page so that the GC won't attempt to 
1: 		// free and re-allocate it until the transaction commits
1: 		RawTransaction tran = handle.getTransaction();
1: 
1: 		LockingPolicy lp = 
1:             tran.newLockingPolicy(
1:                 LockingPolicy.MODE_RECORD,
1:                 TransactionController.ISOLATION_REPEATABLE_READ, 
1:                 true); // striterOK
1: 		
1: 		PageKey pkey = new PageKey(identity, deallocLock.getPageNumber());
1: 		if (lp != null)
1:         {
1: 			if (zeroDuration)
1: 				return lp.zeroDurationLockRecordForWrite(
1:                         tran, deallocLock, false, wait); 
1: 			else
1: 				return lp.lockRecordForWrite(tran, deallocLock, false, wait);
1:         }
1: 		else
1: 		{
1: 			throw StandardException.newException(
1:                     SQLState.DATA_CANNOT_GET_DEALLOC_LOCK, pkey);
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 		Get an allocation page and latch it.
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected Page getAllocPage(BaseContainerHandle handle, long pageNumber, boolean wait)
1: 		 throws StandardException
1: 	{
1: 		return latchPage(handle, getAllocPage(pageNumber), wait);
1: 	}
1: 
1: 	/**
1: 		Get any page and latch it .
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected Page getAnyPage(BaseContainerHandle handle, long pageNumber, boolean wait)
1: 		 throws StandardException
1: 	{
1: 		return latchPage(handle, getAnyPage(handle, pageNumber), wait);
1: 	}
1: 
1: 
1: 	/**
1: 		Get the first valid page. Result is latched.
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected Page getFirstPage(BaseContainerHandle handle) throws StandardException
1: 	{
1: 		return getFirstHeadPage(handle, true /* wait */);
1: 	}
1: 
1: 	/**
1: 		Get the next valid page and latch it
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected Page getNextPage(BaseContainerHandle handle, long pageNumber)
1:         throws StandardException
1: 	{
1: 		return getNextHeadPage(handle, pageNumber, true /* wait */);
1: 	}
1: 
1: 	/*
1: 		utility to latch a page
1: 	*/
1: 	protected BasePage latchPage(BaseContainerHandle handle, BasePage foundPage, boolean wait)
1: 		 throws StandardException
1: 	{
1: 		if (foundPage != null) {
1: 			 if (wait) {
1: 				foundPage.setExclusive(handle);
1: 			 } else {
1: 				 if (!foundPage.setExclusiveNoWait(handle))
1: 				 {
1: 					 // sub-class will release page from the cache if required.
1: 					 return null;
1: 				 }
1: 			 }
1: 		}
1: 
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT((foundPage == null) || foundPage.isLatched());
1: 		}
1: 
1: 		return foundPage;
1: 
1: 	}
1: 
1: 
1: 	/**
1: 		Lock the container and mark the container as in-use by this container handle.
1: 
1: 		@param droppedOK if true, use this container even if it is dropped.,
1: 		@return true if the container can be used, false if it has been dropped
1: 		since the lock was requested and droppedOK is not true.
1: 
1: 		@exception StandardException I cannot be opened for update.
1: 	*/
1: 	protected boolean use(BaseContainerHandle handle, boolean forUpdate,
1: 						  boolean droppedOK) 
1: 		throws StandardException {
1: 
1: 		// see if the container can be updated
1: 		if (forUpdate && !canUpdate())
1:         {
1: 			throw StandardException.newException(
1:                     SQLState.DATA_CONTAINER_READ_ONLY);
1:         }
1: 
1: 		// if the container is dropped, cannot see if unless droppedOK is set
1: 		if (!droppedOK && (getDroppedState() || getCommittedDropState())) {
1: 			return false;
1: 		}
1: 
1: 		return true;
1: 	}
1: 
1: 	/**
1: 		Discontinue use of this container. Note that the unlockContainer
1: 		call made from this method may not release any locks. The container
1: 		lock may be held until the end of the transaction.
1: 
1: 	*/
1: 	protected void letGo(BaseContainerHandle handle) {
1: 
1: 		RawTransaction t = handle.getTransaction();
1: 
1: 		handle.getLockingPolicy().unlockContainer(t, handle);
1: 	}
1: 
1: 	protected boolean getDroppedState() {
1: 		return isDropped;
1: 	}
1: 
1: 	protected boolean getCommittedDropState()
1: 	{
1: 		return isCommittedDrop;
1: 	}
1: 
1: 
1: 	protected boolean isReusableRecordId()
1: 	{
1: 		return isReusableRecordId;
1: 	}
1: 
1: 	public int getContainerStatus()
1: 	{
1: 		if (getCommittedDropState())
1: 			return RawContainerHandle.COMMITTED_DROP;
1: 
1: 		if (getDroppedState())
1: 			return RawContainerHandle.DROPPED;
1: 
1: 		return RawContainerHandle.NORMAL;
1: 	}
1: 
1: 	public long getContainerId() {
1: 		return identity.getContainerId();
1: 	}
1: 
1: 	public long getSegmentId() {
1: 		return identity.getSegmentId();
1: 	}
1: 
1: 
1: 	//public int getPageSize() {
1: 	//	return pageSize();
1: 	//}
1: 
1: 	/*
1: 	**	Methods that need to be provided by a sub-class.
1: 	*/
1: 
1:     /**
1:     Get information about space used by the container.
1:     **/
1:     protected abstract SpaceInfo getSpaceInfo(BaseContainerHandle handle)
1:         throws StandardException;
1: 
1: 	/**
1: 		Can the container be updated.
1: 
1: 		@return true if the container can be updated, false otherwise.
1: 	*/
1: 	protected abstract boolean canUpdate();
1: 
1: 	/**
1: 		The container is about to be modified.
1: 		Loggable actions use this to make sure the container gets cleaned if a
1: 		checkpoint is taken after any log record is sent to the log stream but
1: 		before the container is actually dirtied.
1: 	 */
1: 	protected abstract void preDirty(boolean preDirtyOn);
1: 
1: 
1: 	/**
1: 		Return a BasePage that represents the given page number in this container.
1:         The resulting page is latched.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected abstract BasePage getPage(BaseContainerHandle handle, long pageNumber,
1:         boolean wait) throws StandardException;
1: 
1: 	/**
1: 		Return a BasePage that represents the given alloc page number in this container.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected abstract BasePage getAllocPage(long pageNumber) throws StandardException;
1: 
1: 	/**
1: 		Return a BasePage that represents any page - alloc page, valid page, free page,
1: 		dealloced page etc.  The only requirement is that the page is initialized...
1: 
0: 		@exception StandardException Cloudscape Standard error policy
1: 	*/
1: 	protected abstract BasePage getAnyPage(BaseContainerHandle handle, long pageNumber)
1: 		 throws StandardException;
1: 
1: 	/**
0: 		ReCreate a page for load tran.  The argument passed in need to be
0: 		sufficient for the page cache to materialize a brand new page and write
0: 		it to disk.  The reason why this method is necessary is because we
0: 		first create the page, write it to disk, and then log the init page log
0: 		record to make sure there are enough space on disk.  During load tran,
0: 		the page creation part is missing.
1: 
0: 		<p>Load tran will do no preallocation.
1: 
0: 		<p>Only called during recovery redo.
1: 
0: 		@exception StandardException Cloudscape Standard error policy
1: 	 */
1: 	protected abstract BasePage
0: 	reCreatePageForLoadTran(BaseContainerHandle handle,
0: 							int pageFormat,
0: 							long pageNumber,
0: 							long pageOffset)
1: 		 throws StandardException;
1: 
1: 	/**
1: 		Log all information on the container creation necessary to recreate teh
1: 		container during a load tran.
1: 
0: 		@exception StandardException Cloudscape Standard error policy
1: 	 */
1: 	 protected abstract ByteArray logCreateContainerInfo()
1: 		 throws StandardException;
1: 
1: 
1: 	/**
1: 		Get only a valid, non-overflow page.  If page number is either invalid
1: 		or overflow, returns null
1: 
0: 		@exception StandardException Cloudscape Standard error policy
1: 	 */
1: 	protected abstract BasePage getHeadPage(BaseContainerHandle handle,
1:         long pagenumber, boolean wait) throws StandardException;
1: 
1: 	/**
1: 		Get the first page in the container.
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected abstract BasePage getFirstHeadPage(BaseContainerHandle handle,
1:         boolean wait) throws StandardException;
1: 
1: 	/**
1: 		Get the next page in the container.
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected abstract BasePage getNextHeadPage(BaseContainerHandle handle,
1:         long pageNumber, boolean wait) throws StandardException;
1: 
1: 	/**
1: 		Get a potentially suitable page for insert and latch it.
0: 		@exception StandardException Standard Cloudscape error policy
1: 	 */
1: 	protected abstract BasePage getPageForInsert(BaseContainerHandle handle,
1: 												 int flag)
1: 		 throws StandardException;
1: 
1: 
1: 	/**
1: 		Create a new page in the container.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected abstract BasePage newPage(BaseContainerHandle userhandle,
1: 										RawTransaction t,
1: 										BaseContainerHandle allocHandle,
1: 										boolean isOverflow) throws StandardException;
1: 
1: 
1: 	/**
1: 		Deallocate a page from the container.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected abstract void deallocatePage(BaseContainerHandle userhandle,
1: 										   BasePage page) throws StandardException;
1: 
1: 
1: 	protected void truncate(BaseContainerHandle handle) throws StandardException {
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.THROWASSERT("truncate not supported");
1: 		}
1: 	}
1: 
1: 	/**
1: 		Mark the container as drop or not drop depending on the input value.
1: 
1: 	*/
1: 	protected abstract void dropContainer(LogInstant instant, boolean drop);
1: 
1: 
1: 	/**
1: 		Remove the container and reclaim its space.  Once executed, this
1: 		operation cannot be undone - as opposed to dropContainer which only
1: 		marks the container as dropped and can be rolled back.
1: 		<BR><B> This operation should only be called by post commit clean up </B>
1: 
1: 		@param leaveStub if true, leave a stub.  If false, remove everything
1: 		@see org.apache.derby.iapi.store.raw.data.RawContainerHandle#removeContainer
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected abstract void removeContainer(LogInstant instant, boolean leaveStub) throws StandardException;
1: 
1: 	/**
1: 		Get the logged container version.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected abstract long getContainerVersion() throws StandardException;
1: 
1: 	/**
1: 		Flush all outstanding changes in this container to persistent storage.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	protected abstract void flushAll() throws StandardException;
1: 
1: 	/**
1: 		The container will be grown vastly, prepare for it.
1: 	*/
1: 	protected abstract void prepareForBulkLoad(BaseContainerHandle handle,
1: 											   int numPage);
1: 
1: 	/**
1: 		The container will have no pre-allocate threshold, i.e., if the
1: 		implementation supports it, page preallocation will happen
1: 		the next time a new page is allocated.
1: 	*/
1: 	protected abstract void clearPreallocThreshold();
1: 
1: 	/*
1: 		Cost estimates
1: 	*/
1: 	/**
1: 		@see ContainerHandle#getEstimatedRowCount
0: 		@exception StandardException Standard Cloudscape error policy
1: 	 */
1: 	public abstract long getEstimatedRowCount(int flag) throws StandardException;
1: 
1: 	/**
1: 		@see ContainerHandle#setEstimatedRowCount
0: 		@exception StandardException Standard Cloudscape error policy
1: 	 */
1: 	public abstract void setEstimatedRowCount(long count, int flag) throws StandardException;
1: 
1: 	/**
1: 		@see ContainerHandle#getEstimatedPageCount
0: 		@exception StandardException Standard Cloudscape error policy
1: 	 */
1: 	public abstract long getEstimatedPageCount(BaseContainerHandle handle, int flag) throws StandardException;
1: 
1: 
1: 	/*
1: 	** Methods to be used by sub-classes.
1: 	*/
1: 
1: 	/**
1: 		Set the container's dropped state
1: 	*/
1: 	protected void setDroppedState(boolean isDropped) {
1: 		this.isDropped = isDropped;
1: 	}
1: 
1: 	protected void setCommittedDropState(boolean isCommittedDrop)
1: 	{
1: 		this.isCommittedDrop = isCommittedDrop;
1: 	}
1: 
1: 
1: 	protected void setReusableRecordIdState(boolean isReusableRecordId)
1: 	{
1: 		this.isReusableRecordId = isReusableRecordId;
1: 	}
1: 
1: 	//protected void setPageSize(int pageSize) {
1: 	//	identity.setPageSize(pageSize);
1: 	//}
1: 
1: 	// Not interested in participating in the diagnostic virtual lock table.
1: 	public boolean lockAttributes(int flag, Hashtable attributes)
1: 	{
1: 		return false;
1: 	}
1: 
1: }
1: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.data;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.locks.Lockable;
0: import org.apache.derby.iapi.services.locks.Latch;
0: import org.apache.derby.iapi.services.locks.C_LockFactory;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.access.SpaceInfo;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.PageKey;
0: import org.apache.derby.iapi.store.raw.PageTimeStamp;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: import org.apache.derby.iapi.store.raw.ContainerKey;
0: import org.apache.derby.iapi.store.raw.data.RawContainerHandle;
0: import org.apache.derby.iapi.store.raw.log.LogInstant;
0: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
0: 
0: import org.apache.derby.iapi.util.ByteArray;
0: 
0: import java.util.Properties;
0: import java.util.Hashtable;
0: 
0: /**
0: 	BaseContainer is an abstract class that provides the locking bahaviour
0: 	for an object representing an active container, that is the actual
0: 	storage container, not the ContainerHandle interface. This class is designed
0: 	so that it can change the container it represents to avoid creating
0: 	a new object for every container.
0: 	<P>
0: 	This object implements lockable to provide an object to lock while a page is being
0: 	allocated.
0: 	<BR> MT - Mutable - mutable identity : 
0: */
0: public abstract class BaseContainer implements Lockable {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/**
0: 		Identity of the container.
0: 
0: 		<BR> MT - Mutable
0: 	*/
0: 	protected ContainerKey identity;
0: 
0: 	
0: 	/**
0: 		Dropped state of the container.
0: 
0: 		<BR> MT - mutable : single thread required. Either the container must be exclusive
0: 		locked by this thread, or the container must have no identity (ie. it is being created
0: 		or opened).
0: 	*/
0: 	protected boolean	isDropped;
0: 
0: 
0: 	/**
0: 		Committed Drop state of the container.  If a post comit action
0: 		determined that the drop container operation is committed, the whole
0: 		container may be removed and space reclaimed.
0: 
0: 		<BR> MT - mutable : single thread required. Either the container must be exclusive
0: 		locked by this thread, or the container must have no identity (ie. it is being created
0: 		or opened).
0: 	*/
0: 	protected boolean isCommittedDrop;
0: 
0: 
0: 	/**
0: 		Is reusable recordId.  By default, record Ids are not reusable when a
0: 		page is reused.  However, under special circumstances, clients to raw
0: 		store may decide that record Ids may be reused after the page is
0: 		reused.   When this flag is set, pages that are reused will have its
0: 		next recordId set to RecordHandle.FIRST_RECORD_ID
0: 	*/
0: 	protected boolean isReusableRecordId = false;
0: 
0: 	protected BaseContainer() {
0: 	}
0: 
0: 	/*
0: 	** portions of Cacheable interface, interface is actually implemented by
0: 	** sub-class. This section also contains methods related to this interface.
0: 	*/
0: 
0: 	protected void fillInIdentity(ContainerKey key) {
0: 
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(identity == null || (identity == key));
0: 		}
0: 
0: 		identity = key;
0: 	}
0: 
0: 	public void clearIdentity() {
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(identity != null);
0: 		}
0: 
0: 		identity = null;
0: 	}
0: 
0: 	public Object getIdentity() {
0: 		return identity;
0: 	}
0: 
0: 	/*
0: 	** Methods from Lockable, just require a single exclusive locker
0: 	*/
0: 
0: 	public void lockEvent(Latch lockInfo) {
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(identity != null);
0: 		}
0: 	}
0: 
0: 	public boolean requestCompatible(Object requestedQualifier, Object grantedQualifier) {
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(identity != null);
0: 		}
0: 		return false;
0: 	}
0: 
0: 	public boolean lockerAlwaysCompatible() {
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(identity != null);
0: 		}
0: 		return false;
0: 	}
0: 
0: 	public void unlockEvent(Latch lockInfo) {
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(identity != null);
0: 		}
0: 	}
0: 
0: 	/*
0: 	** Implementation specific methods
0: 	*/
0: 
0: 
0: 	/**
0: 		Add a page to this container.
0: 
0: 		<BR> MT - thread aware - 
0: 
0: 		The add page operation involves 2 transactions, one is the user
0: 		transaction (the transaction which owns the passed in handle), the
0: 		other one is a NestedTopTransaction created by this BaseContainer.
0: 
0: 		The nestedTopTransaction is used by the underlying container to change
0: 		high contention structures, such as link list anchor or bit map pages.
0: 		The nestedTopTransaction commits or aborts before this routine returns.
0: 
0: 		The user transaction is used to latch the newly created page.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	public Page addPage(BaseContainerHandle handle, boolean isOverflow) throws StandardException {
0: 		
0: 		RawTransaction ntt = handle.getTransaction().startNestedTopTransaction();
0: 
0: 		int mode = handle.getMode(); 
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT((mode & ContainerHandle.MODE_FORUPDATE) ==
0: 								 ContainerHandle.MODE_FORUPDATE, 
0: 								 "addPage handle not for update");
0: 		}
0: 
0: 		// if we are not in the same transaction as the one which created the
0: 		// container and the container may have logged some operation already, 
0: 		// then we need to log allocation regardless of whether user changes
0: 		// are logged.  Otherwise, the database will be corrupted if it
0: 		// crashed. 
0: 		if ((mode & ContainerHandle.MODE_CREATE_UNLOGGED) == 0 &&
0: 			(mode & ContainerHandle.MODE_UNLOGGED) ==
0: 						ContainerHandle.MODE_UNLOGGED) 
0: 			mode &= ~ContainerHandle.MODE_UNLOGGED;
0: 
0: 		// make a handle which is tied to the ntt, not to the user transaction this
0: 		// handle is tied to.  The container is already locked by the user transaction,
0: 		// open it nolock
0: 		BaseContainerHandle allocHandle = (BaseContainerHandle)ntt.openContainer
0: 			(identity, (LockingPolicy)null, mode);
0: 
0: 		if (allocHandle == null)
0:         {
0: 			throw StandardException.newException(
0:                     SQLState.DATA_ALLOC_NTT_CANT_OPEN, 
0:                     new Long(getSegmentId()), 
0:                     new Long(getContainerId()));
0:         }
0: 
0: 		// Latch this container, the commit will release the latch
0: 		ntt.getLockFactory().lockObject(
0:                 ntt, ntt, this, null, C_LockFactory.WAIT_FOREVER);
0: 
0: 		BasePage newPage = null;
0: 		try
0: 		{
0: 			newPage = newPage(handle, ntt, allocHandle, isOverflow);
0: 		}
0: 		finally
0: 		{
0: 			if (newPage != null)
0:             {
0:                 // it is ok to commit without syncing, as it is ok if this
0:                 // transaction never makes it to the db, if no subsequent
0:                 // log record makes it to the log.  If any subsequent log
0:                 // record is sync'd then this transaction will be sync'd
0:                 // as well.
0: 				ntt.commitNoSync(Transaction.RELEASE_LOCKS);
0:             }
0: 			else
0:             {      
0: 				ntt.abort();
0:             }
0: 			ntt.close();
0: 		}
0: 
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(newPage.isLatched());
0: 		}
0: 
0: 		if (!this.identity.equals(newPage.getPageId().getContainerId())) {
0: 
0: 			if (SanityManager.DEBUG) {
0: 				SanityManager.THROWASSERT("BaseContainer.addPage(), just got a new page from a different container"
0: 					+ "\n this.identity = " + this.identity
0: 					+ "\n newPage.getPageId().getContainerId() = " + newPage.getPageId().getContainerId()
0: 					+ "\n handle is: " + handle
0: 					+ "\n allocHandle is: " + allocHandle
0: 					+ "\n this container is: " + this);
0: 			}
0: 
0: 			throw StandardException.newException(
0:                     SQLState.DATA_DIFFERENT_CONTAINER,
0:                     this.identity, newPage.getPageId().getContainerId());
0: 		}
0: 
0: 		return newPage;
0: 	}
0: 
0:     /**
0:      * Request the system properties associated with a container.
0:      * <p>
0:      * Request the value of properties that are associated with a container.  
0:      * The following properties can be requested:
0:      *     derby.storage.pageSize 
0:      *     derby.storage.pageReservedSpace
0:      *     derby.storage.minimumRecordSize
0:      * <p>
0:      * To get the value of a particular property add it to the property list,
0:      * and on return the value of the property will be set to it's current 
0:      * value.  For example:
0:      *
0:      * get_prop(BaseContainer base)
0:      * {
0:      *     Properties prop = new Properties();
0:      *     prop.put("derby.storage.pageSize", "");
0:      *     base.getContainerProperties(prop);
0:      *
0:      *     System.out.println(
0:      *         "container's page size = " + 
0:      *         prop.getProperty("derby.storage.pageSize");
0:      * }
0:      *
0:      * @param prop   Property list to fill in.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public abstract void getContainerProperties(Properties prop)
0: 		throws StandardException;
0: 
0: 	/**
0: 		Remove a page from this container.  The page will be unlatched by this
0: 		routine before it returns.
0: 
0: 		Unlike addPage, this method done as part of the user transaction.  
0: 		The removed page is not usable by anyone until the user transaction 
0:         comits.
0: 		If the user transaction rolls back, the removed page is un-removed.
0: 
0: 		<BR> MT - thread aware -
0: 
0: 		@param handle the container handle that has opened the container and latched the page
0: 		@param page the latched page that is to be deallocated
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected void removePage(BaseContainerHandle handle, BasePage page) 
0: 		 throws StandardException
0: 	{
0: 		try
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(page.isLatched(), "page is not latched");
0: 			}
0: 
0: 			// get dealloc lock nowait on the page to be deallocated
0: 			// this lock is held until this transaction commits.
0: 			// then gc can free this page
0: 			RecordHandle deallocLock = 
0: 				page.makeRecordHandle(RecordHandle.DEALLOCATE_PROTECTION_HANDLE);
0: 
0: 			// don't get deallocLock wait because caller have a page latched
0: 			if (!getDeallocLock(handle, deallocLock, 
0: 								false /* no wait */,
0: 								false /* not zeroDuration */))
0:             {
0: 				throw StandardException.newException(
0:                         SQLState.DATA_CANNOT_GET_DEALLOC_LOCK, 
0:                         page.getIdentity());
0:             }
0: 
0: 			deallocatePage(handle, page);
0: 		}
0: 		finally
0: 		{
0: 			if (page != null)
0: 				page.unlatch();
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 		Get the special dealloc lock on the page - the lock is gotten by the
0: 		transaction that owns the container handle
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected boolean getDeallocLock(BaseContainerHandle handle, 
0: 									 RecordHandle deallocLock, 
0: 									 boolean wait,
0: 									 boolean zeroDuration)
0: 		 throws StandardException
0: 	{
0: 		// get deallocate lock on page so that the GC won't attempt to 
0: 		// free and re-allocate it until the transaction commits
0: 		RawTransaction tran = handle.getTransaction();
0: 
0: 		LockingPolicy lp = 
0:             tran.newLockingPolicy(
0:                 LockingPolicy.MODE_RECORD,
0:                 TransactionController.ISOLATION_REPEATABLE_READ, 
0:                 true); // striterOK
0: 		
0: 		PageKey pkey = new PageKey(identity, deallocLock.getPageNumber());
0: 		if (lp != null)
0:         {
0: 			if (zeroDuration)
0: 				return lp.zeroDurationLockRecordForWrite(
0:                         tran, deallocLock, false, wait); 
0: 			else
0: 				return lp.lockRecordForWrite(tran, deallocLock, false, wait);
0:         }
0: 		else
0: 		{
0: 			throw StandardException.newException(
0:                     SQLState.DATA_CANNOT_GET_DEALLOC_LOCK, pkey);
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 		Get an allocation page and latch it.
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected Page getAllocPage(BaseContainerHandle handle, long pageNumber, boolean wait)
0: 		 throws StandardException
0: 	{
0: 		return latchPage(handle, getAllocPage(pageNumber), wait);
0: 	}
0: 
0: 	/**
0: 		Get any page and latch it .
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected Page getAnyPage(BaseContainerHandle handle, long pageNumber, boolean wait)
0: 		 throws StandardException
0: 	{
0: 		return latchPage(handle, getAnyPage(handle, pageNumber), wait);
0: 	}
0: 
0: 
0: 	/**
0: 		Get the first valid page. Result is latched.
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected Page getFirstPage(BaseContainerHandle handle) throws StandardException
0: 	{
0: 		return getFirstHeadPage(handle, true /* wait */);
0: 	}
0: 
0: 	/**
0: 		Get the next valid page and latch it
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected Page getNextPage(BaseContainerHandle handle, long pageNumber)
0:         throws StandardException
0: 	{
0: 		return getNextHeadPage(handle, pageNumber, true /* wait */);
0: 	}
0: 
0: 	/*
0: 		utility to latch a page
0: 	*/
0: 	protected BasePage latchPage(BaseContainerHandle handle, BasePage foundPage, boolean wait)
0: 		 throws StandardException
0: 	{
0: 		if (foundPage != null) {
0: 			 if (wait) {
0: 				foundPage.setExclusive(handle);
0: 			 } else {
0: 				 if (!foundPage.setExclusiveNoWait(handle))
0: 				 {
0: 					 // sub-class will release page from the cache if required.
0: 					 return null;
0: 				 }
0: 			 }
0: 		}
0: 
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT((foundPage == null) || foundPage.isLatched());
0: 		}
0: 
0: 		return foundPage;
0: 
0: 	}
0: 
0: 
0: 	/**
0: 		Lock the container and mark the container as in-use by this container handle.
0: 
0: 		@param droppedOK if true, use this container even if it is dropped.,
0: 		@return true if the container can be used, false if it has been dropped
0: 		since the lock was requested and droppedOK is not true.
0: 
0: 		@exception StandardException I cannot be opened for update.
0: 	*/
0: 	protected boolean use(BaseContainerHandle handle, boolean forUpdate,
0: 						  boolean droppedOK) 
0: 		throws StandardException {
0: 
0: 		// see if the container can be updated
0: 		if (forUpdate && !canUpdate())
0:         {
0: 			throw StandardException.newException(
0:                     SQLState.DATA_CONTAINER_READ_ONLY);
0:         }
0: 
0: 		// if the container is dropped, cannot see if unless droppedOK is set
0: 		if (!droppedOK && (getDroppedState() || getCommittedDropState())) {
0: 			return false;
0: 		}
0: 
0: 		return true;
0: 	}
0: 
0: 	/**
0: 		Discontinue use of this container. Note that the unlockContainer
0: 		call made from this method may not release any locks. The container
0: 		lock may be held until the end of the transaction.
0: 
0: 	*/
0: 	protected void letGo(BaseContainerHandle handle) {
0: 
0: 		RawTransaction t = handle.getTransaction();
0: 
0: 		handle.getLockingPolicy().unlockContainer(t, handle);
0: 	}
0: 
0: 	protected boolean getDroppedState() {
0: 		return isDropped;
0: 	}
0: 
0: 	protected boolean getCommittedDropState()
0: 	{
0: 		return isCommittedDrop;
0: 	}
0: 
0: 
0: 	protected boolean isReusableRecordId()
0: 	{
0: 		return isReusableRecordId;
0: 	}
0: 
0: 	public int getContainerStatus()
0: 	{
0: 		if (getCommittedDropState())
0: 			return RawContainerHandle.COMMITTED_DROP;
0: 
0: 		if (getDroppedState())
0: 			return RawContainerHandle.DROPPED;
0: 
0: 		return RawContainerHandle.NORMAL;
0: 	}
0: 
0: 	public long getContainerId() {
0: 		return identity.getContainerId();
0: 	}
0: 
0: 	public long getSegmentId() {
0: 		return identity.getSegmentId();
0: 	}
0: 
0: 
0: 	//public int getPageSize() {
0: 	//	return pageSize();
0: 	//}
0: 
0: 	/*
0: 	**	Methods that need to be provided by a sub-class.
0: 	*/
0: 
0:     /**
0:     Get information about space used by the container.
0:     **/
0:     protected abstract SpaceInfo getSpaceInfo(BaseContainerHandle handle)
0:         throws StandardException;
0: 
0: 	/**
0: 		Can the container be updated.
0: 
0: 		@return true if the container can be updated, false otherwise.
0: 	*/
0: 	protected abstract boolean canUpdate();
0: 
0: 	/**
0: 		The container is about to be modified.
0: 		Loggable actions use this to make sure the container gets cleaned if a
0: 		checkpoint is taken after any log record is sent to the log stream but
0: 		before the container is actually dirtied.
0: 	 */
0: 	protected abstract void preDirty(boolean preDirtyOn);
0: 
0: 
0: 	/**
0: 		Return a BasePage that represents the given page number in this container.
0:         The resulting page is latched.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected abstract BasePage getPage(BaseContainerHandle handle, long pageNumber,
0:         boolean wait) throws StandardException;
0: 
0: 	/**
0: 		Return a BasePage that represents the given alloc page number in this container.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected abstract BasePage getAllocPage(long pageNumber) throws StandardException;
0: 
0: 	/**
0: 		Return a BasePage that represents any page - alloc page, valid page, free page,
0: 		dealloced page etc.  The only requirement is that the page is initialized...
0: 
0: 		@exception StandardException Cloudscape Standard error policy
0: 	*/
0: 	protected abstract BasePage getAnyPage(BaseContainerHandle handle, long pageNumber)
0: 		 throws StandardException;
0: 
0: 	/**
0: 		ReCreate a page for load tran.  The argument passed in need to be
0: 		sufficient for the page cache to materialize a brand new page and write
0: 		it to disk.  The reason why this method is necessary is because we
0: 		first create the page, write it to disk, and then log the init page log
0: 		record to make sure there are enough space on disk.  During load tran,
0: 		the page creation part is missing.
0: 
0: 		<p>Load tran will do no preallocation.
0: 
0: 		<p>Only called during recovery redo.
0: 
0: 		@exception StandardException Cloudscape Standard error policy
0: 	 */
0: 	protected abstract BasePage
0: 	reCreatePageForLoadTran(BaseContainerHandle handle,
0: 							int pageFormat,
0: 							long pageNumber,
0: 							long pageOffset)
0: 		 throws StandardException;
0: 
0: 	/**
0: 		Log all information on the container creation necessary to recreate teh
0: 		container during a load tran.
0: 
0: 		@exception StandardException Cloudscape Standard error policy
0: 	 */
0: 	 protected abstract ByteArray logCreateContainerInfo()
0: 		 throws StandardException;
0: 
0: 
0: 	/**
0: 		Get only a valid, non-overflow page.  If page number is either invalid
0: 		or overflow, returns null
0: 
0: 		@exception StandardException Cloudscape Standard error policy
0: 	 */
0: 	protected abstract BasePage getHeadPage(BaseContainerHandle handle,
0:         long pagenumber, boolean wait) throws StandardException;
0: 
0: 	/**
0: 		Get the first page in the container.
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected abstract BasePage getFirstHeadPage(BaseContainerHandle handle,
0:         boolean wait) throws StandardException;
0: 
0: 	/**
0: 		Get the next page in the container.
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected abstract BasePage getNextHeadPage(BaseContainerHandle handle,
0:         long pageNumber, boolean wait) throws StandardException;
0: 
0: 	/**
0: 		Get a potentially suitable page for insert and latch it.
0: 		@exception StandardException Standard Cloudscape error policy
0: 	 */
0: 	protected abstract BasePage getPageForInsert(BaseContainerHandle handle,
0: 												 int flag)
0: 		 throws StandardException;
0: 
0: 
0: 	/**
0: 		Create a new page in the container.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected abstract BasePage newPage(BaseContainerHandle userhandle,
0: 										RawTransaction t,
0: 										BaseContainerHandle allocHandle,
0: 										boolean isOverflow) throws StandardException;
0: 
0: 
0: 	/**
0: 		Deallocate a page from the container.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected abstract void deallocatePage(BaseContainerHandle userhandle,
0: 										   BasePage page) throws StandardException;
0: 
0: 
0: 	protected void truncate(BaseContainerHandle handle) throws StandardException {
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.THROWASSERT("truncate not supported");
0: 		}
0: 	}
0: 
0: 	/**
0: 		Mark the container as drop or not drop depending on the input value.
0: 
0: 	*/
0: 	protected abstract void dropContainer(LogInstant instant, boolean drop);
0: 
0: 
0: 	/**
0: 		Remove the container and reclaim its space.  Once executed, this
0: 		operation cannot be undone - as opposed to dropContainer which only
0: 		marks the container as dropped and can be rolled back.
0: 		<BR><B> This operation should only be called by post commit clean up </B>
0: 
0: 		@param leaveStub if true, leave a stub.  If false, remove everything
0: 		@see org.apache.derby.iapi.store.raw.data.RawContainerHandle#removeContainer
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected abstract void removeContainer(LogInstant instant, boolean leaveStub) throws StandardException;
0: 
0: 	/**
0: 		Get the logged container version.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected abstract long getContainerVersion() throws StandardException;
0: 
0: 	/**
0: 		Flush all outstanding changes in this container to persistent storage.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	protected abstract void flushAll() throws StandardException;
0: 
0: 	/**
0: 		The container will be grown vastly, prepare for it.
0: 	*/
0: 	protected abstract void prepareForBulkLoad(BaseContainerHandle handle,
0: 											   int numPage);
0: 
0: 	/**
0: 		The container will have no pre-allocate threshold, i.e., if the
0: 		implementation supports it, page preallocation will happen
0: 		the next time a new page is allocated.
0: 	*/
0: 	protected abstract void clearPreallocThreshold();
0: 
0: 	/*
0: 		Cost estimates
0: 	*/
0: 	/**
0: 		@see ContainerHandle#getEstimatedRowCount
0: 		@exception StandardException Standard Cloudscape error policy
0: 	 */
0: 	public abstract long getEstimatedRowCount(int flag) throws StandardException;
0: 
0: 	/**
0: 		@see ContainerHandle#setEstimatedRowCount
0: 		@exception StandardException Standard Cloudscape error policy
0: 	 */
0: 	public abstract void setEstimatedRowCount(long count, int flag) throws StandardException;
0: 
0: 	/**
0: 		@see ContainerHandle#getEstimatedPageCount
0: 		@exception StandardException Standard Cloudscape error policy
0: 	 */
0: 	public abstract long getEstimatedPageCount(BaseContainerHandle handle, int flag) throws StandardException;
0: 
0: 
0: 	/*
0: 	** Methods to be used by sub-classes.
0: 	*/
0: 
0: 	/**
0: 		Set the container's dropped state
0: 	*/
0: 	protected void setDroppedState(boolean isDropped) {
0: 		this.isDropped = isDropped;
0: 	}
0: 
0: 	protected void setCommittedDropState(boolean isCommittedDrop)
0: 	{
0: 		this.isCommittedDrop = isCommittedDrop;
0: 	}
0: 
0: 
0: 	protected void setReusableRecordIdState(boolean isReusableRecordId)
0: 	{
0: 		this.isReusableRecordId = isReusableRecordId;
0: 	}
0: 
0: 	//protected void setPageSize(int pageSize) {
0: 	//	identity.setPageSize(pageSize);
0: 	//}
0: 
0: 	// Not interested in participating in the diagnostic virtual lock table.
0: 	public boolean lockAttributes(int flag, Hashtable attributes)
0: 	{
0: 		return false;
0: 	}
0: 
0: }
0: 
============================================================================