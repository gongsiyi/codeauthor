1:973b326: /*
7:973b326: 
1:973b326: Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.Derby2017LayerATest
1:ed6bf51: 
1:973b326: Licensed to the Apache Software Foundation (ASF) under one or more
1:973b326: contributor license agreements.  See the NOTICE file distributed with
1:973b326: this work for additional information regarding copyright ownership.
1:973b326: The ASF licenses this file to You under the Apache License, Version 2.0
1:973b326: (the "License"); you may not use this file except in compliance with
1:973b326: the License.  You may obtain a copy of the License at
1:973b326: 
1:973b326: http://www.apache.org/licenses/LICENSE-2.0
1:973b326: 
1:973b326: Unless required by applicable law or agreed to in writing, software
1:973b326: distributed under the License is distributed on an "AS IS" BASIS,
1:973b326: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:973b326: See the License for the specific language governing permissions and
1:973b326: limitations under the License.
1:973b326: 
1:973b326:  */
1:973b326: 
1:973b326: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:973b326: 
1:ed6bf51: import java.io.ByteArrayInputStream;
1:973b326: import java.io.IOException;
1:ed6bf51: import java.io.InputStream;
1:973b326: import java.io.Reader;
1:973b326: import java.io.StringReader;
1:ed6bf51: import java.io.UnsupportedEncodingException;
1:ed6bf51: import java.math.BigInteger;
1:973b326: import java.sql.PreparedStatement;
1:973b326: import java.sql.ResultSet;
1:973b326: import java.sql.SQLException;
1:973b326: import java.sql.Statement;
1:ed6bf51: import java.util.Arrays;
1:1ae02c9: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:ed6bf51: 
1:973b326: /**
1:973b326:  * Tests that inserts with streams whose lengths differs from the the length
1:973b326:  * specified don't insert data into the database when they shouldn't.
2:973b326:  * <p>
1:973b326:  * The test uses various combinations of auto-commit and rollback.
1:973b326:  */
1:973b326: public class Derby2017LayerATest
1:973b326:         extends BaseJDBCTestCase {
1:973b326: 
1:ed6bf51:     /** The encoding used when generating a byte array from a string. */
1:ed6bf51:     public static final String UTF8 = "UTF-8";
1:ed6bf51: 
1:973b326:     public Derby2017LayerATest(String name) {
1:973b326:         super(name);
1:973b326:     }
1:973b326: 
1:973b326:     /**
1:973b326:      * Returns a suite running most of the tests with both the client driver
1:973b326:      * and the embedded driver, and some of the tests only with the client
1:973b326:      * driver.
1:973b326:      *
1:973b326:      * @return A suite of tests.
1:973b326:      */
1:973b326:     public static Test suite() {
1:1ae02c9:         BaseTestSuite ts = new BaseTestSuite();
1:973b326:         ts.addTest(
1:973b326:                 TestConfiguration.defaultSuite(Derby2017LayerATest.class));
1:973b326:         // Run the tests below with the client driver only.
1:1ae02c9:         BaseTestSuite clientSuite = new BaseTestSuite("Client only tests");
1:973b326:         clientSuite.addTest(new Derby2017LayerATest(
1:ed6bf51:                 "cs_FailedStreamInsertCharBufferBoundaries"));
1:973b326:         clientSuite.addTest(new Derby2017LayerATest(
1:ed6bf51:                 "cs_StreamInsertCharBufferBoundary"));
1:973b326:         ts.addTest(TestConfiguration.clientServerDecorator(clientSuite));
1:973b326: 
1:973b326:         return ts;
1:973b326:     }
1:973b326: 
1:973b326:     /**
1:973b326:      * Tests inserts around some selected buffer boundaries. This test verifies
1:973b326:      * that the client and server can sucessfully insert values of various
1:973b326:      * lengths. It will work also before the fix for DERBY-2017, but will fail
1:973b326:      * if an incorrect fix is applied.
1:973b326:      */
1:ed6bf51:     public void cs_StreamInsertCharBufferBoundary()
1:973b326:             throws IOException, SQLException {
1:973b326:         rollback();
1:973b326:         Statement stmt = createStatement();
1:973b326:         try {
1:973b326:             stmt.executeUpdate("create table t2017_len (len int, c clob)");
1:973b326:         } catch (SQLException sqle) {
1:973b326:             assertSQLState("X0Y32", sqle);
1:973b326:             stmt.executeUpdate("delete from t2017_len");
1:973b326:         }
1:973b326:         commit();
1:973b326:         setAutoCommit(false);
1:973b326: 
1:973b326:         // Note that when using layer A streaming the data is converted to
1:973b326:         // UTF-16 on the wire.
1:973b326:         PreparedStatement ps =
1:973b326:                 prepareStatement("insert into t2017_len values (?,?)");
1:973b326:         // Test small values.
1:973b326:         for (int i=0; i < 512; i++) {
1:973b326:             ps.setInt(1, i);
1:973b326:             ps.setCharacterStream(2, new LoopingAlphabetReader(i), i);
1:973b326:             ps.executeUpdate();
1:973b326:         }
1:973b326:         commit();
1:973b326: 
1:973b326:         // Test values at the buffer boundary. Assumes UTF-16 and a ~32 KB
1:973b326:         // transmit buffer.
1:973b326:         for (int i=16000; i < 18000; i++) {
1:973b326:             ps.setInt(1, i);
1:973b326:             ps.setCharacterStream(2, new LoopingAlphabetReader(i), i);
1:973b326:             ps.executeUpdate();
1:973b326:             // Commit periodically.
1:973b326:             if (i % 1000 == 0) {
1:973b326:                 commit();
1:973b326:             }
1:973b326:         }
1:973b326:         commit();
1:973b326: 
1:973b326:         for (int i=32500; i < 33000; i++) {
1:973b326:             ps.setInt(1, i);
1:973b326:             ps.setCharacterStream(2, new LoopingAlphabetReader(i), i);
1:973b326:             ps.executeUpdate();
1:973b326:         }
1:973b326:         commit();
1:973b326: 
1:973b326:         // Verify the data, basically making sure the status flag isn't
1:973b326:         // included as part of the user data.
1:973b326:         ResultSet rs = stmt.executeQuery("select len, c from t2017_len");
1:973b326:         int rows = 0;
1:973b326:         while (rs.next()) {
1:973b326:             rows++;
1:973b326:             assertEquals(new LoopingAlphabetReader(rs.getInt(1)),
1:973b326:                          rs.getCharacterStream(2));
1:973b326:         }
1:973b326:     }
1:973b326: 
1:973b326:     /**
1:973b326:      * Runs some failing inserts around buffer boundaries.
1:973b326:      */
1:ed6bf51:     public void cs_FailedStreamInsertCharBufferBoundaries()
1:973b326:             throws IOException, SQLException {
1:973b326:         int[] INSERT;
1:973b326:         for (int i=0; i < 1024; i++) {
1:973b326:             INSERT = new int[] {
1:973b326:                 8*1000+i,
1:973b326:                 16*1000+i,
1:973b326:                 32*1000+i,
1:973b326:                 16*1000+i, // This will fail (forced length mismatch)
1:973b326:                 32*1000+i, // This will fail (forced length mismatch)
1:973b326:                 48*1000+i,
1:973b326:                 0+i,
1:973b326:             };
1:973b326:             // We test only one combination of auto-commit and rollback here.
1:ed6bf51:             doInsertTest(INSERT, false, false);
1:973b326:         }
1:973b326:     }
1:973b326: 
1:ed6bf51:     public void testFailedStreamInsertCharLong()
1:973b326:             throws IOException, SQLException {
1:973b326:         int[] INSERT = new int[] {
1:973b326:             10*1024+1,
1:973b326:             89*1024+3,
1:973b326:             32*1024,
1:973b326:             64*1024, // This will fail (forced length mismatch)
1:973b326:             99*1024, // This will fail (forced length mismatch)
1:973b326:             1,
1:973b326:             197*1024,
1:973b326:         };
1:973b326:         doInsertTest(INSERT, false, false);
1:973b326:         doInsertTest(INSERT, false, true);
2:973b326:         doInsertTest(INSERT, true, false);
1:973b326:         doInsertTest(INSERT, true, true);
1:973b326:     }
1:973b326: 
1:973b326:     /**
1:973b326:      * Inserts data by reading from streams, where two of these will thrown
1:973b326:      * an {@code IOException}. Data from these streams should not be committed.
1:973b326:      */
1:ed6bf51:     public void testFailedStreamInsertCharIOException()
1:973b326:             throws IOException, SQLException {
1:973b326:         String[] INSERT = new String[] {
1:973b326:                 "row 1", "row 2", "row 3",
1:973b326:                 "IGNORE", "IGNORE",
1:973b326:                 "row 6", "row 7"
1:973b326:             };
1:973b326:         String[][] MASTER = new String[][] {
1:973b326:                 {"row 1"}, {"row 2"}, {"row 3"},
1:973b326:                 {"row 6"}, {"row 7"}
1:973b326:             };
1:973b326: 
1:973b326:         rollback();
1:973b326:         Statement stmt = createStatement();
1:973b326:         try {
1:973b326:             stmt.executeUpdate("create table t2017 (c clob)");
1:973b326:         } catch (SQLException sqle) {
1:973b326:             assertSQLState("X0Y32", sqle);
1:973b326:             stmt.executeUpdate("delete from t2017");
1:973b326:         }
1:973b326:         commit();
1:973b326: 
1:973b326:         setAutoCommit(true);
1:973b326:         PreparedStatement ps = prepareStatement("insert into t2017 values (?)");
1:973b326:         // Insert the 3 first rows.
1:973b326:         for (int i=0; i < 3; i++) {
1:973b326:             ps.setString(1, INSERT[i]);
1:973b326:             assertEquals(1, ps.executeUpdate());
1:973b326:         }
1:973b326: 
1:973b326:         // Insert the 4th and 5th row with a stream that throws an IOException.
1:973b326:         // Partial data shouldn't be inserted into the database.
1:973b326: 
1:973b326:         Reader r4 = new FailingReader(518, 500);
1:973b326:         ps.setCharacterStream(1, r4, 518);
1:973b326:         try {
1:973b326:             ps.executeUpdate();
1:973b326:             fail("Insert should have failed");
1:973b326:         } catch (SQLException sqle) {
1:973b326:             // TODO: Check when exception handling has been settled.
1:973b326:             // The states are different between client and embedded.
1:973b326:             //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:973b326:         }
1:973b326: 
1:973b326:         Reader r5 = new FailingReader(67*1024, 42*1024);
1:973b326:         ps.setCharacterStream(1, r5, 67*1024);
1:973b326:         try {
1:973b326:             ps.executeUpdate();
1:973b326:             fail("Insert should have failed");
1:973b326:         } catch (SQLException sqle) {
1:973b326:             // TODO: Check when exception handling has been settled.
1:973b326:             // The states are different between client and embedded.
1:973b326:             //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:973b326:         }
1:973b326: 
1:973b326:         // The errors above should have statement severity. Insert the last two
1:973b326:         // rows.
1:973b326:         for (int i=5; i < INSERT.length; i++) {
1:973b326:             ps.setString(1, INSERT[i]);
1:973b326:             assertEquals(1, ps.executeUpdate());
1:973b326:         }
1:973b326: 
1:973b326:         // Select data in the table, compare to MASTER
1:973b326:         ResultSet rs = stmt.executeQuery("select * from t2017");
1:973b326:         JDBC.assertFullResultSet(rs, MASTER);
1:973b326:     }
1:973b326: 
1:ed6bf51:     public void testFailedStreamInsertChar()
1:973b326:             throws IOException, SQLException {
1:973b326:         String[] INSERT = new String[] {
1:973b326:                 "This is row 1",
1:973b326:                 "This is row 2",
1:973b326:                 "This is row 3",
1:973b326:                 "This is row 4, a bit too long",
1:973b326:                 "This is row 5, a bit too short",
1:973b326:                 "This is row 6",
1:973b326:                 "This is row 7",
1:973b326:             };
1:973b326:         String[][] MASTER = new String[][] {
1:973b326:                 {"This is row 1"},
1:973b326:                 {"This is row 2"},
1:973b326:                 {"This is row 3"},
1:973b326:                 //{"This is row 4, a bit too long"},
1:973b326:                 //{"This is row 5, a bit too short"},
1:973b326:                 {"This is row 6"},
1:973b326:                 {"This is row 7"},
1:973b326:             };
1:973b326: 
1:973b326:         doInsertTest(INSERT, MASTER, false, false);
1:973b326:     }
1:973b326: 
1:ed6bf51:     public void testFailedStreamInsertCharAutoCommit()
1:973b326:             throws IOException, SQLException {
1:973b326:         String[] INSERT = new String[] {
1:973b326:                 "This is row 1",
1:973b326:                 "This is row 2",
1:973b326:                 "This is row 3",
1:973b326:                 "This is row 4, a bit too long",
1:973b326:                 "This is row 5, a bit too short",
1:973b326:                 "This is row 6",
1:973b326:                 "This is row 7",
1:973b326:             };
1:973b326:         String[][] MASTER = new String[][] {
1:973b326:                 {"This is row 1"},
1:973b326:                 {"This is row 2"},
1:973b326:                 {"This is row 3"},
1:973b326:                 //{"This is row 4, a bit too long"},
1:973b326:                 //{"This is row 5, a bit too short"},
1:973b326:                 {"This is row 6"},
1:973b326:                 {"This is row 7"},
1:973b326:             };
1:973b326:         doInsertTest(INSERT, MASTER, true, false);
1:973b326:     }
1:973b326: 
1:ed6bf51:     public void testFailedStreamInsertCharRollbackOnError()
1:973b326:             throws IOException, SQLException {
1:973b326:         String[] INSERT = new String[] {
1:973b326:                 "This is row 1",
1:973b326:                 "This is row 2",
1:973b326:                 "This is row 3",
1:973b326:                 "This is row 4, a bit too long",
1:973b326:                 "This is row 5, a bit too short",
1:973b326:                 "This is row 6",
1:973b326:                 "This is row 7",
1:973b326:             };
1:973b326:         String[][] MASTER = new String[][] {
1:973b326:                 //{"This is row 1"},
1:973b326:                 //{"This is row 2"},
1:973b326:                 //{"This is row 3"},
1:973b326:                 //{"This is row 4, a bit too long"},
1:973b326:                 //{"This is row 5, a bit too short"},
1:973b326:                 {"This is row 6"},
1:973b326:                 {"This is row 7"},
1:973b326:             };
1:973b326:         doInsertTest(INSERT, MASTER, false, true);
1:973b326:     }
1:973b326: 
1:ed6bf51:     public void testFailedStreamInsertCharAutoCommitRollbackOnError()
1:973b326:             throws IOException, SQLException {
1:973b326:         String[] INSERT = new String[] {
1:973b326:                 "This is row 1",
1:973b326:                 "This is row 2",
1:973b326:                 "This is row 3",
1:973b326:                 "This is row 4, a bit too long",
1:973b326:                 "This is row 5, a bit too short",
1:973b326:                 "This is row 6",
1:973b326:                 "This is row 7",
1:973b326:             };
1:973b326:         String[][] MASTER = new String[][] {
1:973b326:                 {"This is row 1"},
1:973b326:                 {"This is row 2"},
1:973b326:                 {"This is row 3"},
1:973b326:                 //{"This is row 4, a bit too long"},
1:973b326:                 //{"This is row 5, a bit too short"},
1:973b326:                 {"This is row 6"},
1:973b326:                 {"This is row 7"},
1:973b326:             };
1:973b326:         doInsertTest(INSERT, MASTER, true, true);
1:973b326:     }
1:973b326: 
1:ed6bf51:     public void testFailedStreamInsertBinary()
1:ed6bf51:             throws IOException, SQLException {
1:ed6bf51:         byte[][] INSERT = generateDefaultInsert();
1:ed6bf51:         String[][] MASTER = generateMaster(INSERT, new int[] {3, 4});
1:ed6bf51:         doInsertTest(INSERT, MASTER, false, false);
1:ed6bf51:     }
1:ed6bf51: 
1:ed6bf51:     public void testFailedStreamInsertBinaryAutoCommit()
1:ed6bf51:             throws IOException, SQLException {
1:ed6bf51:         byte[][] INSERT = generateDefaultInsert();
1:ed6bf51:         String[][] MASTER = generateMaster(INSERT, new int[] {3, 4});
1:ed6bf51:         doInsertTest(INSERT, MASTER, true, false);
1:ed6bf51:     }
1:ed6bf51: 
1:ed6bf51:     public void testFailedStreamInsertBinaryRollbackOnError()
1:ed6bf51:             throws IOException, SQLException {
1:ed6bf51:         byte[][] INSERT = generateDefaultInsert();
1:ed6bf51:         String[][] MASTER = generateMaster(INSERT, new int[] {0, 1, 2, 3, 4});
1:ed6bf51:         doInsertTest(INSERT, MASTER, false, true);
1:ed6bf51:     }
1:ed6bf51: 
1:ed6bf51:     public void testFailedStreamInsertBinaryAutoCommitRollbackOnError()
1:ed6bf51:             throws IOException, SQLException {
1:ed6bf51:         byte[][] INSERT = generateDefaultInsert();
1:ed6bf51:         String[][] MASTER = generateMaster(INSERT, new int[] {3, 4});
1:ed6bf51:         doInsertTest(INSERT, MASTER, true, true);
1:ed6bf51:     }
1:ed6bf51: 
1:973b326:     /**
1:ed6bf51:      * Performs the base test cycle; insert 3 valid rows, try to insert 2
1:ed6bf51:      * invalid rows, insert 2 valid rows.
1:ed6bf51:      * <p>
1:ed6bf51:      * The outcome depends on whether auto-commit is on, and whether a rollback
1:ed6bf51:      * is issued when an insert fails.
1:ed6bf51:      *
1:ed6bf51:      * @param INSERT the data to insert
1:ed6bf51:      * @param MASTER the expected outcome
1:ed6bf51:      * @param autoCommit the auto-commit state to use
1:ed6bf51:      * @param rollbackOnError whether or not to issue a rollback if an insert
1:ed6bf51:      *      fails
1:ed6bf51:      *
1:ed6bf51:      * @throws IOException if something goes wrong
1:ed6bf51:      * @throws SQLException if something goes wrong
1:ed6bf51:      */
1:973b326:     private void doInsertTest(String[] INSERT, String[][] MASTER,
1:973b326:                               boolean autoCommit, boolean rollbackOnError)
1:973b326:             throws IOException, SQLException {
1:973b326:         // A few sanity checks.
1:973b326:         assertEquals("Expects 7 rows", 7, INSERT.length);
1:973b326:         assertTrue(MASTER.length < INSERT.length);
1:973b326: 
1:973b326:         rollback();
1:973b326:         Statement stmt = createStatement();
1:973b326:         try {
1:973b326:             stmt.executeUpdate("create table t2017 (c clob)");
1:973b326:         } catch (SQLException sqle) {
1:973b326:             assertSQLState("X0Y32", sqle);
1:973b326:             stmt.executeUpdate("delete from t2017");
1:ed6bf51:         }
1:973b326:         commit();
1:973b326: 
1:973b326:         setAutoCommit(autoCommit);
1:973b326:         PreparedStatement ps = prepareStatement("insert into t2017 values (?)");
1:973b326:         // Insert the 3 first rows.
1:973b326:         for (int i=0; i < 3; i++) {
1:973b326:             ps.setString(1, INSERT[i]);
1:973b326:             assertEquals(1, ps.executeUpdate());
1:973b326:         }
1:973b326: 
1:973b326:         // Insert the 4th row with a stream that's longer than the specified
1:973b326:         // length, then the 5th row that's shorter. Both should fail, and the
1:973b326:         // data shouldn't be inserted into the database.
1:973b326: 
1:973b326:         Reader r4 = new StringReader(INSERT[3]);
1:973b326:         ps.setCharacterStream(1, r4, INSERT[3].length() - 5);
1:973b326:         try {
1:973b326:             ps.executeUpdate();
1:973b326:             fail("Insert should have failed, stream too long");
1:973b326:         } catch (SQLException sqle) {
1:973b326:             // The states are different between client and embedded.
1:973b326:             assertSQLState(usingEmbedded() ? "XSDA4" : "XN015", sqle);
1:973b326:             if (rollbackOnError) {
1:973b326:                 rollback();
1:973b326:             }
1:973b326:         }
1:973b326: 
1:973b326:         Reader r5 = new StringReader(INSERT[4]);
1:973b326:         ps.setCharacterStream(1, r5, INSERT[4].length() + 5);
1:973b326:         try {
1:973b326:             ps.executeUpdate();
1:973b326:             fail("Insert should have failed, stream too short");
1:973b326:         } catch (SQLException sqle) {
1:973b326:             // The states are different between client and embedded.
1:973b326:             assertSQLState(usingEmbedded() ? "XSDA4" : "XN017", sqle);
1:973b326:             if (rollbackOnError) {
1:973b326:                 rollback();
1:973b326:             }
1:973b326:         }
1:973b326: 
1:973b326:         // The errors above should have statement severity. Insert the last
1:973b326:         // two rows and make sure the transaction commits.
1:973b326:         for (int i=5; i < INSERT.length; i++) {
1:973b326:             ps.setString(1, INSERT[i]);
1:973b326:             assertEquals(1, ps.executeUpdate());
1:973b326:         }
1:973b326: 
1:973b326:         if (!autoCommit) {
1:973b326:             commit();
1:973b326:         }
1:973b326: 
1:973b326:         // Select data in the table, compare to MASTER
1:973b326:         ResultSet rs = stmt.executeQuery("select * from t2017");
1:973b326:         JDBC.assertFullResultSet(rs, MASTER);
1:973b326:     }
1:973b326: 
1:973b326:     /**
1:973b326:      * Performs the base test cycle; insert 3 valid rows, try to insert 2
1:973b326:      * invalid rows, insert 2 valid rows.
1:973b326:      * <p>
1:973b326:      * The outcome depends on whether auto-commit is on, and whether a rollback
1:973b326:      * is issued when an insert fails.
1:973b326:      *
1:973b326:      * @param INSERT the data to insert
1:973b326:      * @param autoCommit the auto-commit state to use
1:973b326:      * @param rollbackOnError whether or not to issue a rollback if an insert
1:973b326:      *      fails
1:973b326:      *
1:973b326:      * @throws IOException if something goes wrong
1:973b326:      * @throws SQLException if something goes wrong
1:973b326:      */
1:973b326:     private void doInsertTest(int[] INSERT,
1:973b326:                               boolean autoCommit, boolean rollbackOnError)
1:973b326:             throws IOException, SQLException {
1:973b326:         // A few sanity checks.
1:973b326:         assertEquals("Expects 7 rows", 7, INSERT.length);
1:973b326: 
1:973b326:         rollback();
1:973b326:         Statement stmt = createStatement();
1:973b326:         try {
1:973b326:             stmt.executeUpdate("create table t2017_id (id int unique, c clob)");
1:973b326:         } catch (SQLException sqle) {
1:973b326:             assertSQLState("X0Y32", sqle);
1:973b326:             stmt.executeUpdate("delete from t2017_id");
1:973b326:         }
1:973b326:         commit();
1:973b326: 
1:973b326:         setAutoCommit(autoCommit);
1:973b326:         PreparedStatement ps =
1:973b326:                 prepareStatement("insert into t2017_id values (?, ?)");
1:973b326:         // Insert the 3 first rows (id is 1-based).
1:973b326:         for (int i=0; i < 3; i++) {
1:973b326:             ps.setInt(1, i+1);
1:973b326:             int length = INSERT[i];
1:973b326:             ps.setCharacterStream(2, new LoopingAlphabetReader(length), length);
1:973b326:             assertEquals(1, ps.executeUpdate());
1:973b326:         }
1:973b326: 
1:973b326:         // Insert the 4th row with a stream that's longer than the specified
1:973b326:         // length, then the 5th row that's shorter. Both should fail, and the
1:973b326:         // data shouldn't be inserted into the database.
1:973b326: 
1:973b326:         Reader r4 = new LoopingAlphabetReader(INSERT[3]);
1:973b326:         ps.setInt(1, 4);
1:973b326:         ps.setCharacterStream(2, r4, INSERT[3] - 5);
1:973b326:         try {
1:973b326:             ps.executeUpdate();
1:973b326:             fail("Insert should have failed, stream too long");
1:973b326:         } catch (SQLException sqle) {
1:973b326:             // The states are different between client and embedded.
1:973b326:             assertSQLState(usingEmbedded() ? "XSDA4" : "XN015", sqle);
1:973b326:             if (rollbackOnError) {
1:973b326:                 rollback();
1:973b326:             }
1:973b326:         }
1:973b326: 
1:973b326:         Reader r5 = new LoopingAlphabetReader(INSERT[4]);
1:973b326:         ps.setInt(1, 5);
1:973b326:         ps.setCharacterStream(2, r5, INSERT[4] + 5);
1:973b326:         try {
1:973b326:             ps.executeUpdate();
1:973b326:             fail("Insert should have failed, stream too short");
1:973b326:         } catch (SQLException sqle) {
1:973b326:             // The states are different between client and embedded.
1:973b326:             assertSQLState(usingEmbedded() ? "XSDA4" : "XN017", sqle);
1:973b326:             if (rollbackOnError) {
1:973b326:                 rollback();
1:973b326:             }
1:973b326:         }
1:973b326: 
1:973b326:         // The errors above should have statement severity. Insert the last
1:973b326:         // two rows and make sure the transaction commits.
1:973b326:         for (int i=5; i < INSERT.length; i++) {
1:973b326:             ps.setInt(1, i+1);
1:973b326:             int length = INSERT[i];
1:973b326:             ps.setCharacterStream(2, new LoopingAlphabetReader(length), length);
1:973b326:             assertEquals(1, ps.executeUpdate());
1:973b326:         }
1:973b326: 
1:973b326:         if (!autoCommit) {
1:973b326:             commit();
1:973b326:         }
1:973b326: 
1:973b326:         // Make sure we have the expected number of rows.
1:973b326:         ResultSet rs = stmt.executeQuery("select count(*) from t2017_id");
1:973b326:         rs.next();
1:973b326:         assertEquals((rollbackOnError && !autoCommit ? 2 : 5), rs.getInt(1));
1:973b326: 
1:973b326:         // Select data in the table, compare to what we expect.
1:973b326:         rs = stmt.executeQuery( "select * from t2017_id order by id asc");
1:973b326:         // Check rows 1-4 if rollback on error is false.
1:973b326:         if (autoCommit || !rollbackOnError) {
1:973b326:             for (int i=0; i < 3; i++) {
1:973b326:                 rs.next();
1:973b326:                 int id = rs.getInt(1);
1:973b326:                 assertTrue(id - 1 == i);
1:973b326:                 assertEquals(new LoopingAlphabetReader(INSERT[i]),
1:973b326:                              rs.getCharacterStream(2));
1:973b326:             }
1:973b326:         }
1:973b326:         // Check rows 6 and 7.
1:973b326:         for (int i=5; i < 7; i++) {
1:973b326:             rs.next();
1:973b326:             int id = rs.getInt(1);
1:973b326:             assertTrue(id - 1 == i);
1:973b326:             assertEquals(new LoopingAlphabetReader(INSERT[i]),
1:973b326:                          rs.getCharacterStream(2));
1:973b326:         }
1:973b326:         assertFalse(rs.next());
1:973b326:         rs.close();
1:973b326:     }
1:973b326: 
1:973b326:     /**
1:973b326:      * Performs the base test cycle; insert 3 valid rows, try to insert 2
1:973b326:      * invalid rows, insert 2 valid rows.
1:973b326:      * <p>
1:973b326:      * The outcome depends on whether auto-commit is on, and whether a rollback
1:973b326:      * is issued when an insert fails.
1:973b326:      *
1:973b326:      * @param INSERT the data to insert
2:973b326:      * @param MASTER the expected outcome
1:973b326:      * @param autoCommit the auto-commit state to use
1:973b326:      * @param rollbackOnError whether or not to issue a rollback if an insert
1:973b326:      *      fails
1:973b326:      *
1:973b326:      * @throws IOException if something goes wrong
1:973b326:      * @throws SQLException if something goes wrong
1:973b326:      */
1:ed6bf51:     private void doInsertTest(byte[][] INSERT, String[][] MASTER,
1:ed6bf51:                               boolean autoCommit, boolean rollbackOnError)
1:ed6bf51:             throws IOException, SQLException {
1:ed6bf51:         // A few sanity checks.
1:ed6bf51:         assertEquals("Expects 7 rows", 7, INSERT.length);
1:ed6bf51:         assertTrue(MASTER.length < INSERT.length);
1:ed6bf51: 
1:ed6bf51:         rollback();
1:ed6bf51:         Statement stmt = createStatement();
1:ed6bf51:         try {
1:ed6bf51:             stmt.executeUpdate("create table t2017_binary (b blob)");
1:ed6bf51:         } catch (SQLException sqle) {
1:ed6bf51:             assertSQLState("X0Y32", sqle);
1:ed6bf51:             stmt.executeUpdate("delete from t2017_binary");
1:ed6bf51:         }
1:ed6bf51:         commit();
1:ed6bf51: 
1:ed6bf51:         setAutoCommit(autoCommit);
1:ed6bf51:         PreparedStatement ps = prepareStatement(
1:ed6bf51:                 "insert into t2017_binary values (?)");
1:ed6bf51:         // Insert the 3 first rows.
1:ed6bf51:         for (int i=0; i < 3; i++) {
1:ed6bf51:             ps.setBytes(1, INSERT[i]);
1:ed6bf51:             assertEquals(1, ps.executeUpdate());
1:ed6bf51:         }
1:ed6bf51: 
1:ed6bf51:         // Insert the 4th row with a stream that's longer than the specified
1:ed6bf51:         // length, then the 5th row that's shorter. Both should fail, and the
1:ed6bf51:         // data shouldn't be inserted into the database.
1:ed6bf51: 
1:ed6bf51:         InputStream r4 = new ByteArrayInputStream(INSERT[3]);
1:ed6bf51:         ps.setBinaryStream(1, r4, INSERT[3].length - 5);
1:ed6bf51:         try {
1:ed6bf51:             ps.executeUpdate();
1:ed6bf51:             fail("Insert should have failed, stream too long");
1:ed6bf51:         } catch (SQLException sqle) {
1:ed6bf51:             // The states are different between client and embedded.
1:ed6bf51:             assertSQLState(usingEmbedded() ? "XSDA4" : "XN015", sqle);
1:ed6bf51:             if (rollbackOnError) {
1:ed6bf51:                 rollback();
1:ed6bf51:             }
1:ed6bf51:         }
1:ed6bf51: 
1:ed6bf51:         InputStream r5 = new ByteArrayInputStream(INSERT[4]);
1:ed6bf51:         ps.setBinaryStream(1, r5, INSERT[4].length + 5);
1:ed6bf51:         try {
1:ed6bf51:             ps.executeUpdate();
1:ed6bf51:             fail("Insert should have failed, stream too short");
1:ed6bf51:         } catch (SQLException sqle) {
1:ed6bf51:             // The states are different between client and embedded.
1:ed6bf51:             assertSQLState(usingEmbedded() ? "XSDA4" : "XN017", sqle);
1:ed6bf51:             if (rollbackOnError) {
1:ed6bf51:                 rollback();
1:ed6bf51:             }
1:ed6bf51:         }
1:ed6bf51: 
1:ed6bf51:         // The errors above should have statement severity. Insert the last
1:ed6bf51:         // two rows and make sure the transaction commits.
1:ed6bf51:         for (int i=5; i < INSERT.length; i++) {
1:ed6bf51:             ps.setBytes(1, INSERT[i]);
1:ed6bf51:             assertEquals(1, ps.executeUpdate());
1:ed6bf51:         }
1:ed6bf51: 
1:ed6bf51:         if (!autoCommit) {
1:ed6bf51:             commit();
1:973b326:         }
1:ed6bf51: 
1:ed6bf51:         // Select data in the table, compare to MASTER
1:ed6bf51:         ResultSet rs = stmt.executeQuery("select * from t2017_binary");
1:ed6bf51:         JDBC.assertFullResultSet(rs, MASTER);
1:ed6bf51:     }
1:ed6bf51: 
1:ed6bf51:     /**
1:973b326:      * WARNING: This reader is not a general purpose reader!!!
1:973b326:      * <p>
1:973b326:      * Reader thrown an exception when a certain amount of characters has been
1:973b326:      * returned (or is about to be returned).
1:973b326:      */
1:973b326:     public static class FailingReader
1:973b326:             extends Reader {
1:973b326: 
1:973b326:         private final LoopingAlphabetReader in;
1:973b326:         private final long failAtPos;
1:973b326:         private long pos;
1:973b326: 
1:973b326:         /**
1:973b326:          * Creates a new failing reader.
1:973b326:          *
1:973b326:          * @param length the total length of the source
1:973b326:          * @param failAtPos the position to fail at (specifying zero or a
1:973b326:          *      negative value causes an exception on the first read request)
1:973b326:          */
1:973b326:         public FailingReader(long length, long failAtPos) {
1:973b326:             this.failAtPos = failAtPos;
1:973b326:             this.in = new LoopingAlphabetReader(length);
1:973b326:         }
1:973b326: 
1:973b326:         public int read()
1:973b326:                 throws IOException {
1:973b326:             // If we failed once, just keep failing on subsequent requests.
1:973b326:             pos++;
1:973b326:             int ret = in.read();
1:973b326:             if (pos >= failAtPos) {
1:973b326:                 throw new IOException("forced exception");
1:973b326:             }
1:973b326:             return ret;
1:973b326:         }
1:973b326: 
1:973b326:         public int read(char[] cbuf, int off, int len)
1:973b326:                 throws IOException {
1:973b326:             // If we failed once, just keep failing on subsequent requests.
1:973b326:             // Try to return some valid data before failing.
1:973b326:             if (pos == 0 && failAtPos > 1) {
1:973b326:                 len = (int)Math.min(failAtPos -1, len);
1:973b326:             }
1:973b326:             int ret = in.read(cbuf, off, len);
1:973b326:             if (ret != -1) {
1:973b326:                 pos += ret;
1:973b326:             }
1:973b326:             if (pos >= failAtPos) {
1:973b326:                 throw new IOException("forced exception");
1:973b326:             }
1:973b326:             return ret;
1:973b326:         }
1:973b326: 
1:973b326:         public void close() {
1:973b326:             in.close();
1:973b326:         }
1:973b326:     }
1:ed6bf51: 
1:ed6bf51:     /**
1:ed6bf51:      * Helper method returning the default bytes used for testing binary data.
1:ed6bf51:      *
1:ed6bf51:      * @return A byte array with byte arrays ("rows").
1:ed6bf51:      */
1:ed6bf51:     public static byte[][] generateDefaultInsert() {
1:ed6bf51:         try {
1:ed6bf51:             byte[][] INSERT = new byte[][] {
1:ed6bf51:                 "This is row 1".getBytes(UTF8),
1:ed6bf51:                 "This is row 2".getBytes(UTF8),
1:ed6bf51:                 "This is row 3".getBytes(UTF8),
1:ed6bf51:                 "This is row 4, a bit too long".getBytes(UTF8),
1:ed6bf51:                 "This is row 5, a bit too short".getBytes(UTF8),
1:ed6bf51:                 "This is row 6".getBytes(UTF8),
1:ed6bf51:                 "This is row 7".getBytes(UTF8),
1:ed6bf51:             };
1:ed6bf51:             return INSERT;
1:ed6bf51:         } catch (UnsupportedEncodingException uuee) {
1:ed6bf51:             // Just return null, should never happen if UTF-8 is used.
1:ed6bf51:             return null;
1:ed6bf51:         }
1:ed6bf51:     }
1:ed6bf51: 
1:ed6bf51:     /**
1:ed6bf51:      * Helper method returning a string array with the expected values from the
1:ed6bf51:      * database (based on the values inserted).
1:ed6bf51:      * <p>
1:ed6bf51:      * The purpose of this method is to convert from byte[] to String (as
1:ed6bf51:      * done by {@code ResultSet.getString()} when invoked on a column with
1:ed6bf51:      * binary data).
1:ed6bf51:      *
1:ed6bf51:      * @param insert the data inserted
1:ed6bf51:      * @param excludes the rows that is expected to fail, will be ignored
1:ed6bf51:      * @return A string array with expected strings.
1:ed6bf51:      */
1:ed6bf51:     public static String[][] generateMaster(byte[][] insert, int[] excludes) {
1:ed6bf51:         Arrays.sort(excludes);
1:ed6bf51:         int exIx = 0;
1:ed6bf51:         String[][] res = new String[insert.length - excludes.length][];
1:ed6bf51:         int resIx = 0;
1:ed6bf51:         for (int i=0; i < insert.length; i++) {
1:ed6bf51:             if (i == excludes[exIx]) {
1:ed6bf51:                 if (exIx < excludes.length -1) {
1:ed6bf51:                     exIx++;
1:ed6bf51:                 }
1:ed6bf51:                 continue;
1:ed6bf51:             }
1:ed6bf51:             String str = new BigInteger(1, insert[i]).toString(16);
1:ed6bf51:             // Pad if there are missing nulls.
1:ed6bf51:             while (str.length() < insert[i].length *2) {
1:ed6bf51:                 str = "0" + str;
1:ed6bf51:             }
1:ed6bf51:             res[resIx++] = new String[] {str};
1:ed6bf51:         }
1:ed6bf51:         return res;
1:ed6bf51:     }
1:973b326: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.Test;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite ts = new BaseTestSuite();
1:         BaseTestSuite clientSuite = new BaseTestSuite("Client only tests");
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:ed6bf51
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayInputStream;
1: import java.io.InputStream;
1: import java.io.UnsupportedEncodingException;
1: 
1: import java.math.BigInteger;
1: import java.util.Arrays;
1: 
1:     /** The encoding used when generating a byte array from a string. */
1:     public static final String UTF8 = "UTF-8";
1: 
/////////////////////////////////////////////////////////////////////////
1:                 "cs_FailedStreamInsertCharBufferBoundaries"));
1:                 "cs_StreamInsertCharBufferBoundary"));
/////////////////////////////////////////////////////////////////////////
1:     public void cs_StreamInsertCharBufferBoundary()
/////////////////////////////////////////////////////////////////////////
1:     public void cs_FailedStreamInsertCharBufferBoundaries()
/////////////////////////////////////////////////////////////////////////
1:             doInsertTest(INSERT, false, false);
1:     public void testFailedStreamInsertCharLong()
/////////////////////////////////////////////////////////////////////////
1:     public void testFailedStreamInsertCharIOException()
/////////////////////////////////////////////////////////////////////////
1:     public void testFailedStreamInsertChar()
/////////////////////////////////////////////////////////////////////////
1:     public void testFailedStreamInsertCharAutoCommit()
/////////////////////////////////////////////////////////////////////////
1:     public void testFailedStreamInsertCharRollbackOnError()
/////////////////////////////////////////////////////////////////////////
1:     public void testFailedStreamInsertCharAutoCommitRollbackOnError()
/////////////////////////////////////////////////////////////////////////
1:     public void testFailedStreamInsertBinary()
1:             throws IOException, SQLException {
1:         byte[][] INSERT = generateDefaultInsert();
1:         String[][] MASTER = generateMaster(INSERT, new int[] {3, 4});
1:         doInsertTest(INSERT, MASTER, false, false);
1:     }
1: 
1:     public void testFailedStreamInsertBinaryAutoCommit()
1:             throws IOException, SQLException {
1:         byte[][] INSERT = generateDefaultInsert();
1:         String[][] MASTER = generateMaster(INSERT, new int[] {3, 4});
1:         doInsertTest(INSERT, MASTER, true, false);
1:     }
1: 
1:     public void testFailedStreamInsertBinaryRollbackOnError()
1:             throws IOException, SQLException {
1:         byte[][] INSERT = generateDefaultInsert();
1:         String[][] MASTER = generateMaster(INSERT, new int[] {0, 1, 2, 3, 4});
1:         doInsertTest(INSERT, MASTER, false, true);
1:     }
1: 
1:     public void testFailedStreamInsertBinaryAutoCommitRollbackOnError()
1:             throws IOException, SQLException {
1:         byte[][] INSERT = generateDefaultInsert();
1:         String[][] MASTER = generateMaster(INSERT, new int[] {3, 4});
1:         doInsertTest(INSERT, MASTER, true, true);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Performs the base test cycle; insert 3 valid rows, try to insert 2
1:      * invalid rows, insert 2 valid rows.
1:      * <p>
1:      * The outcome depends on whether auto-commit is on, and whether a rollback
1:      * is issued when an insert fails.
1:      *
1:      * @param INSERT the data to insert
1:      * @param MASTER the expected outcome
1:      * @param autoCommit the auto-commit state to use
1:      * @param rollbackOnError whether or not to issue a rollback if an insert
1:      *      fails
1:      *
1:      * @throws IOException if something goes wrong
1:      * @throws SQLException if something goes wrong
1:      */
1:     private void doInsertTest(byte[][] INSERT, String[][] MASTER,
1:                               boolean autoCommit, boolean rollbackOnError)
1:             throws IOException, SQLException {
1:         // A few sanity checks.
1:         assertEquals("Expects 7 rows", 7, INSERT.length);
1:         assertTrue(MASTER.length < INSERT.length);
1: 
1:         rollback();
1:         Statement stmt = createStatement();
1:         try {
1:             stmt.executeUpdate("create table t2017_binary (b blob)");
1:         } catch (SQLException sqle) {
1:             assertSQLState("X0Y32", sqle);
1:             stmt.executeUpdate("delete from t2017_binary");
1:         }
1:         commit();
1: 
1:         setAutoCommit(autoCommit);
1:         PreparedStatement ps = prepareStatement(
1:                 "insert into t2017_binary values (?)");
1:         // Insert the 3 first rows.
1:         for (int i=0; i < 3; i++) {
1:             ps.setBytes(1, INSERT[i]);
1:             assertEquals(1, ps.executeUpdate());
1:         }
1: 
1:         // Insert the 4th row with a stream that's longer than the specified
1:         // length, then the 5th row that's shorter. Both should fail, and the
1:         // data shouldn't be inserted into the database.
1: 
1:         InputStream r4 = new ByteArrayInputStream(INSERT[3]);
1:         ps.setBinaryStream(1, r4, INSERT[3].length - 5);
1:         try {
1:             ps.executeUpdate();
1:             fail("Insert should have failed, stream too long");
1:         } catch (SQLException sqle) {
1:             // The states are different between client and embedded.
1:             assertSQLState(usingEmbedded() ? "XSDA4" : "XN015", sqle);
1:             if (rollbackOnError) {
1:                 rollback();
1:             }
1:         }
1: 
1:         InputStream r5 = new ByteArrayInputStream(INSERT[4]);
1:         ps.setBinaryStream(1, r5, INSERT[4].length + 5);
1:         try {
1:             ps.executeUpdate();
1:             fail("Insert should have failed, stream too short");
1:         } catch (SQLException sqle) {
1:             // The states are different between client and embedded.
1:             assertSQLState(usingEmbedded() ? "XSDA4" : "XN017", sqle);
1:             if (rollbackOnError) {
1:                 rollback();
1:             }
1:         }
1: 
1:         // The errors above should have statement severity. Insert the last
1:         // two rows and make sure the transaction commits.
1:         for (int i=5; i < INSERT.length; i++) {
1:             ps.setBytes(1, INSERT[i]);
1:             assertEquals(1, ps.executeUpdate());
1:         }
1: 
1:         if (!autoCommit) {
1:             commit();
1:         }
1: 
1:         // Select data in the table, compare to MASTER
1:         ResultSet rs = stmt.executeQuery("select * from t2017_binary");
1:         JDBC.assertFullResultSet(rs, MASTER);
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Helper method returning the default bytes used for testing binary data.
1:      *
1:      * @return A byte array with byte arrays ("rows").
1:      */
1:     public static byte[][] generateDefaultInsert() {
1:         try {
1:             byte[][] INSERT = new byte[][] {
1:                 "This is row 1".getBytes(UTF8),
1:                 "This is row 2".getBytes(UTF8),
1:                 "This is row 3".getBytes(UTF8),
1:                 "This is row 4, a bit too long".getBytes(UTF8),
1:                 "This is row 5, a bit too short".getBytes(UTF8),
1:                 "This is row 6".getBytes(UTF8),
1:                 "This is row 7".getBytes(UTF8),
1:             };
1:             return INSERT;
1:         } catch (UnsupportedEncodingException uuee) {
1:             // Just return null, should never happen if UTF-8 is used.
1:             return null;
1:         }
1:     }
1: 
1:     /**
1:      * Helper method returning a string array with the expected values from the
1:      * database (based on the values inserted).
1:      * <p>
1:      * The purpose of this method is to convert from byte[] to String (as
1:      * done by {@code ResultSet.getString()} when invoked on a column with
1:      * binary data).
1:      *
1:      * @param insert the data inserted
1:      * @param excludes the rows that is expected to fail, will be ignored
1:      * @return A string array with expected strings.
1:      */
1:     public static String[][] generateMaster(byte[][] insert, int[] excludes) {
1:         Arrays.sort(excludes);
1:         int exIx = 0;
1:         String[][] res = new String[insert.length - excludes.length][];
1:         int resIx = 0;
1:         for (int i=0; i < insert.length; i++) {
1:             if (i == excludes[exIx]) {
1:                 if (exIx < excludes.length -1) {
1:                     exIx++;
1:                 }
1:                 continue;
1:             }
1:             String str = new BigInteger(1, insert[i]).toString(16);
1:             // Pad if there are missing nulls.
1:             while (str.length() < insert[i].length *2) {
1:                 str = "0" + str;
1:             }
1:             res[resIx++] = new String[] {str};
1:         }
1:         return res;
1:     }
commit:d1806d0
/////////////////////////////////////////////////////////////////////////
commit:973b326
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.Derby2017LayerATest
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1: http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
0: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1: 
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: import java.io.IOException;
1: import java.io.Reader;
1: import java.io.StringReader;
1: 
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: /**
1:  * Tests that inserts with streams whose lengths differs from the the length
1:  * specified don't insert data into the database when they shouldn't.
1:  * <p>
1:  * The test uses various combinations of auto-commit and rollback.
1:  * <p>
0:  * TODO: Enable this test as part of the JDBCAPI suite when DERBY-2017 is fixed.
1:  */
1: public class Derby2017LayerATest
1:         extends BaseJDBCTestCase {
1: 
1:     public Derby2017LayerATest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Returns a suite running most of the tests with both the client driver
1:      * and the embedded driver, and some of the tests only with the client
1:      * driver.
1:      *
1:      * @return A suite of tests.
1:      */
1:     public static Test suite() {
0:         TestSuite ts = new TestSuite();
1:         ts.addTest(
1:                 TestConfiguration.defaultSuite(Derby2017LayerATest.class));
1:         // Run the tests below with the client driver only.
0:         TestSuite clientSuite = new TestSuite("Client only tests");
1:         clientSuite.addTest(new Derby2017LayerATest(
0:                 "cs_FailedStreamInsertBufferBoundaries"));
1:         clientSuite.addTest(new Derby2017LayerATest(
0:                 "cs_StreamInsertBufferBoundary"));
1:         ts.addTest(TestConfiguration.clientServerDecorator(clientSuite));
1: 
1:         return ts;
1:     }
1: 
1:     /**
1:      * Tests inserts around some selected buffer boundaries. This test verifies
1:      * that the client and server can sucessfully insert values of various
1:      * lengths. It will work also before the fix for DERBY-2017, but will fail
1:      * if an incorrect fix is applied.
1:      */
0:     public void cs_StreamInsertBufferBoundary()
1:             throws IOException, SQLException {
1:         rollback();
1:         Statement stmt = createStatement();
1:         try {
1:             stmt.executeUpdate("create table t2017_len (len int, c clob)");
1:         } catch (SQLException sqle) {
1:             assertSQLState("X0Y32", sqle);
1:             stmt.executeUpdate("delete from t2017_len");
1:         }
1:         commit();
1:         setAutoCommit(false);
1: 
1:         // Note that when using layer A streaming the data is converted to
1:         // UTF-16 on the wire.
1:         PreparedStatement ps =
1:                 prepareStatement("insert into t2017_len values (?,?)");
1:         // Test small values.
1:         for (int i=0; i < 512; i++) {
1:             ps.setInt(1, i);
1:             ps.setCharacterStream(2, new LoopingAlphabetReader(i), i);
1:             ps.executeUpdate();
1:         }
1:         commit();
1: 
1:         // Test values at the buffer boundary. Assumes UTF-16 and a ~32 KB
1:         // transmit buffer.
1:         for (int i=16000; i < 18000; i++) {
1:             ps.setInt(1, i);
1:             ps.setCharacterStream(2, new LoopingAlphabetReader(i), i);
1:             ps.executeUpdate();
1:             // Commit periodically.
1:             if (i % 1000 == 0) {
1:                 commit();
1:             }
1:         }
1:         commit();
1: 
1:         for (int i=32500; i < 33000; i++) {
1:             ps.setInt(1, i);
1:             ps.setCharacterStream(2, new LoopingAlphabetReader(i), i);
1:             ps.executeUpdate();
1:         }
1:         commit();
1: 
1:         // Verify the data, basically making sure the status flag isn't
1:         // included as part of the user data.
1:         ResultSet rs = stmt.executeQuery("select len, c from t2017_len");
1:         int rows = 0;
1:         while (rs.next()) {
1:             rows++;
1:             assertEquals(new LoopingAlphabetReader(rs.getInt(1)),
1:                          rs.getCharacterStream(2));
1:         }
1:     }
1: 
1:     /**
1:      * Runs some failing inserts around buffer boundaries.
1:      */
0:     public void cs_FailedStreamInsertBufferBoundaries()
1:             throws IOException, SQLException {
1:         int[] INSERT;
1:         for (int i=0; i < 1024; i++) {
1:             INSERT = new int[] {
1:                 8*1000+i,
1:                 16*1000+i,
1:                 32*1000+i,
1:                 16*1000+i, // This will fail (forced length mismatch)
1:                 32*1000+i, // This will fail (forced length mismatch)
1:                 48*1000+i,
1:                 0+i,
1:             };
1:             // We test only one combination of auto-commit and rollback here.
1:             doInsertTest(INSERT, true, false);
1:         }
1:     }
1: 
0:     public void testFailedStreamInsertLong()
1:             throws IOException, SQLException {
1:         int[] INSERT = new int[] {
1:             10*1024+1,
1:             89*1024+3,
1:             32*1024,
1:             64*1024, // This will fail (forced length mismatch)
1:             99*1024, // This will fail (forced length mismatch)
1:             1,
1:             197*1024,
1:         };
1:         doInsertTest(INSERT, false, false);
1:         doInsertTest(INSERT, false, true);
1:         doInsertTest(INSERT, true, false);
1:         doInsertTest(INSERT, true, true);
1:     }
1: 
1:     /**
1:      * Inserts data by reading from streams, where two of these will thrown
1:      * an {@code IOException}. Data from these streams should not be committed.
1:      */
0:     public void testFailedStreamInsertIOException()
1:             throws IOException, SQLException {
1:         String[] INSERT = new String[] {
1:                 "row 1", "row 2", "row 3",
1:                 "IGNORE", "IGNORE",
1:                 "row 6", "row 7"
1:             };
1:         String[][] MASTER = new String[][] {
1:                 {"row 1"}, {"row 2"}, {"row 3"},
1:                 {"row 6"}, {"row 7"}
1:             };
1: 
1:         rollback();
1:         Statement stmt = createStatement();
1:         try {
1:             stmt.executeUpdate("create table t2017 (c clob)");
1:         } catch (SQLException sqle) {
1:             assertSQLState("X0Y32", sqle);
1:             stmt.executeUpdate("delete from t2017");
1:         }
1:         commit();
1: 
1:         setAutoCommit(true);
1:         PreparedStatement ps = prepareStatement("insert into t2017 values (?)");
1:         // Insert the 3 first rows.
1:         for (int i=0; i < 3; i++) {
1:             ps.setString(1, INSERT[i]);
1:             assertEquals(1, ps.executeUpdate());
1:         }
1: 
1:         // Insert the 4th and 5th row with a stream that throws an IOException.
1:         // Partial data shouldn't be inserted into the database.
1: 
1:         Reader r4 = new FailingReader(518, 500);
1:         ps.setCharacterStream(1, r4, 518);
1:         try {
1:             ps.executeUpdate();
1:             fail("Insert should have failed");
1:         } catch (SQLException sqle) {
1:             // TODO: Check when exception handling has been settled.
1:             // The states are different between client and embedded.
1:             //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:         }
1: 
1:         Reader r5 = new FailingReader(67*1024, 42*1024);
1:         ps.setCharacterStream(1, r5, 67*1024);
1:         try {
1:             ps.executeUpdate();
1:             fail("Insert should have failed");
1:         } catch (SQLException sqle) {
1:             // TODO: Check when exception handling has been settled.
1:             // The states are different between client and embedded.
1:             //assertSQLState(usingEmbedded() ? "XSDA4" : "XJ001", sqle);
1:         }
1: 
1:         // The errors above should have statement severity. Insert the last two
1:         // rows.
1:         for (int i=5; i < INSERT.length; i++) {
1:             ps.setString(1, INSERT[i]);
1:             assertEquals(1, ps.executeUpdate());
1:         }
1: 
1:         // Select data in the table, compare to MASTER
1:         ResultSet rs = stmt.executeQuery("select * from t2017");
1:         JDBC.assertFullResultSet(rs, MASTER);
1:     }
1: 
0:     public void testFailedStreamInsert()
1:             throws IOException, SQLException {
1:         String[] INSERT = new String[] {
1:                 "This is row 1",
1:                 "This is row 2",
1:                 "This is row 3",
1:                 "This is row 4, a bit too long",
1:                 "This is row 5, a bit too short",
1:                 "This is row 6",
1:                 "This is row 7",
1:             };
1:         String[][] MASTER = new String[][] {
1:                 {"This is row 1"},
1:                 {"This is row 2"},
1:                 {"This is row 3"},
1:                 //{"This is row 4, a bit too long"},
1:                 //{"This is row 5, a bit too short"},
1:                 {"This is row 6"},
1:                 {"This is row 7"},
1:             };
1: 
1:         doInsertTest(INSERT, MASTER, false, false);
1:     }
1: 
0:     public void testFailedStreamInsertAutoCommit()
1:             throws IOException, SQLException {
1:         String[] INSERT = new String[] {
1:                 "This is row 1",
1:                 "This is row 2",
1:                 "This is row 3",
1:                 "This is row 4, a bit too long",
1:                 "This is row 5, a bit too short",
1:                 "This is row 6",
1:                 "This is row 7",
1:             };
1:         String[][] MASTER = new String[][] {
1:                 {"This is row 1"},
1:                 {"This is row 2"},
1:                 {"This is row 3"},
1:                 //{"This is row 4, a bit too long"},
1:                 //{"This is row 5, a bit too short"},
1:                 {"This is row 6"},
1:                 {"This is row 7"},
1:             };
1:         doInsertTest(INSERT, MASTER, true, false);
1:     }
1: 
0:     public void testFailedStreamInsertRollbackOnError()
1:             throws IOException, SQLException {
1:         String[] INSERT = new String[] {
1:                 "This is row 1",
1:                 "This is row 2",
1:                 "This is row 3",
1:                 "This is row 4, a bit too long",
1:                 "This is row 5, a bit too short",
1:                 "This is row 6",
1:                 "This is row 7",
1:             };
1:         String[][] MASTER = new String[][] {
1:                 //{"This is row 1"},
1:                 //{"This is row 2"},
1:                 //{"This is row 3"},
1:                 //{"This is row 4, a bit too long"},
1:                 //{"This is row 5, a bit too short"},
1:                 {"This is row 6"},
1:                 {"This is row 7"},
1:             };
1:         doInsertTest(INSERT, MASTER, false, true);
1:     }
1: 
0:     public void testFailedStreamInsertAutoCommitRollbackOnError()
1:             throws IOException, SQLException {
1:         String[] INSERT = new String[] {
1:                 "This is row 1",
1:                 "This is row 2",
1:                 "This is row 3",
1:                 "This is row 4, a bit too long",
1:                 "This is row 5, a bit too short",
1:                 "This is row 6",
1:                 "This is row 7",
1:             };
1:         String[][] MASTER = new String[][] {
1:                 {"This is row 1"},
1:                 {"This is row 2"},
1:                 {"This is row 3"},
1:                 //{"This is row 4, a bit too long"},
1:                 //{"This is row 5, a bit too short"},
1:                 {"This is row 6"},
1:                 {"This is row 7"},
1:             };
1:         doInsertTest(INSERT, MASTER, true, true);
1:     }
1: 
1:     /**
1:      * Performs the base test cycle; insert 3 valid rows, try to insert 2
1:      * invalid rows, insert 2 valid rows.
1:      * <p>
1:      * The outcome depends on whether auto-commit is on, and whether a rollback
1:      * is issued when an insert fails.
1:      *
1:      * @param INSERT the data to insert
1:      * @param MASTER the expected outcome
1:      * @param autoCommit the auto-commit state to use
1:      * @param rollbackOnError whether or not to issue a rollback if an insert
1:      *      fails
1:      *
1:      * @throws IOException if something goes wrong
1:      * @throws SQLException if something goes wrong
1:      */
1:     private void doInsertTest(String[] INSERT, String[][] MASTER,
1:                               boolean autoCommit, boolean rollbackOnError)
1:             throws IOException, SQLException {
1:         // A few sanity checks.
1:         assertEquals("Expects 7 rows", 7, INSERT.length);
1:         assertTrue(MASTER.length < INSERT.length);
1: 
1:         rollback();
1:         Statement stmt = createStatement();
1:         try {
1:             stmt.executeUpdate("create table t2017 (c clob)");
1:         } catch (SQLException sqle) {
1:             assertSQLState("X0Y32", sqle);
1:             stmt.executeUpdate("delete from t2017");
1:         }
1:         commit();
1: 
1:         setAutoCommit(autoCommit);
1:         PreparedStatement ps = prepareStatement("insert into t2017 values (?)");
1:         // Insert the 3 first rows.
1:         for (int i=0; i < 3; i++) {
1:             ps.setString(1, INSERT[i]);
1:             assertEquals(1, ps.executeUpdate());
1:         }
1: 
1:         // Insert the 4th row with a stream that's longer than the specified
1:         // length, then the 5th row that's shorter. Both should fail, and the
1:         // data shouldn't be inserted into the database.
1: 
1:         Reader r4 = new StringReader(INSERT[3]);
1:         ps.setCharacterStream(1, r4, INSERT[3].length() - 5);
1:         try {
1:             ps.executeUpdate();
1:             fail("Insert should have failed, stream too long");
1:         } catch (SQLException sqle) {
1:             // The states are different between client and embedded.
1:             assertSQLState(usingEmbedded() ? "XSDA4" : "XN015", sqle);
1:             if (rollbackOnError) {
1:                 rollback();
1:             }
1:         }
1: 
1:         Reader r5 = new StringReader(INSERT[4]);
1:         ps.setCharacterStream(1, r5, INSERT[4].length() + 5);
1:         try {
1:             ps.executeUpdate();
1:             fail("Insert should have failed, stream too short");
1:         } catch (SQLException sqle) {
1:             // The states are different between client and embedded.
1:             assertSQLState(usingEmbedded() ? "XSDA4" : "XN017", sqle);
1:             if (rollbackOnError) {
1:                 rollback();
1:             }
1:         }
1: 
1:         // The errors above should have statement severity. Insert the last
1:         // two rows and make sure the transaction commits.
1:         for (int i=5; i < INSERT.length; i++) {
1:             ps.setString(1, INSERT[i]);
1:             assertEquals(1, ps.executeUpdate());
1:         }
1: 
1:         if (!autoCommit) {
1:             commit();
1:         }
1: 
1:         // Select data in the table, compare to MASTER
1:         ResultSet rs = stmt.executeQuery("select * from t2017");
1:         JDBC.assertFullResultSet(rs, MASTER);
1:     }
1: 
1:     /**
1:      * Performs the base test cycle; insert 3 valid rows, try to insert 2
1:      * invalid rows, insert 2 valid rows.
1:      * <p>
1:      * The outcome depends on whether auto-commit is on, and whether a rollback
1:      * is issued when an insert fails.
1:      *
1:      * @param INSERT the data to insert
1:      * @param MASTER the expected outcome
1:      * @param autoCommit the auto-commit state to use
1:      * @param rollbackOnError whether or not to issue a rollback if an insert
1:      *      fails
1:      *
1:      * @throws IOException if something goes wrong
1:      * @throws SQLException if something goes wrong
1:      */
1:     private void doInsertTest(int[] INSERT,
1:                               boolean autoCommit, boolean rollbackOnError)
1:             throws IOException, SQLException {
1:         // A few sanity checks.
1:         assertEquals("Expects 7 rows", 7, INSERT.length);
1: 
1:         rollback();
1:         Statement stmt = createStatement();
1:         try {
1:             stmt.executeUpdate("create table t2017_id (id int unique, c clob)");
1:         } catch (SQLException sqle) {
1:             assertSQLState("X0Y32", sqle);
1:             stmt.executeUpdate("delete from t2017_id");
1:         }
1:         commit();
1: 
1:         setAutoCommit(autoCommit);
1:         PreparedStatement ps =
1:                 prepareStatement("insert into t2017_id values (?, ?)");
1:         // Insert the 3 first rows (id is 1-based).
1:         for (int i=0; i < 3; i++) {
1:             ps.setInt(1, i+1);
1:             int length = INSERT[i];
1:             ps.setCharacterStream(2, new LoopingAlphabetReader(length), length);
1:             assertEquals(1, ps.executeUpdate());
1:         }
1: 
1:         // Insert the 4th row with a stream that's longer than the specified
1:         // length, then the 5th row that's shorter. Both should fail, and the
1:         // data shouldn't be inserted into the database.
1: 
1:         Reader r4 = new LoopingAlphabetReader(INSERT[3]);
1:         ps.setInt(1, 4);
1:         ps.setCharacterStream(2, r4, INSERT[3] - 5);
1:         try {
1:             ps.executeUpdate();
1:             fail("Insert should have failed, stream too long");
1:         } catch (SQLException sqle) {
1:             // The states are different between client and embedded.
1:             assertSQLState(usingEmbedded() ? "XSDA4" : "XN015", sqle);
1:             if (rollbackOnError) {
1:                 rollback();
1:             }
1:         }
1: 
1:         Reader r5 = new LoopingAlphabetReader(INSERT[4]);
1:         ps.setInt(1, 5);
1:         ps.setCharacterStream(2, r5, INSERT[4] + 5);
1:         try {
1:             ps.executeUpdate();
1:             fail("Insert should have failed, stream too short");
1:         } catch (SQLException sqle) {
1:             // The states are different between client and embedded.
1:             assertSQLState(usingEmbedded() ? "XSDA4" : "XN017", sqle);
1:             if (rollbackOnError) {
1:                 rollback();
1:             }
1:         }
1: 
1:         // The errors above should have statement severity. Insert the last
1:         // two rows and make sure the transaction commits.
1:         for (int i=5; i < INSERT.length; i++) {
1:             ps.setInt(1, i+1);
1:             int length = INSERT[i];
1:             ps.setCharacterStream(2, new LoopingAlphabetReader(length), length);
1:             assertEquals(1, ps.executeUpdate());
1:         }
1: 
1:         if (!autoCommit) {
1:             commit();
1:         }
1: 
1:         // Make sure we have the expected number of rows.
1:         ResultSet rs = stmt.executeQuery("select count(*) from t2017_id");
1:         rs.next();
1:         assertEquals((rollbackOnError && !autoCommit ? 2 : 5), rs.getInt(1));
1: 
1:         // Select data in the table, compare to what we expect.
1:         rs = stmt.executeQuery( "select * from t2017_id order by id asc");
1:         // Check rows 1-4 if rollback on error is false.
1:         if (autoCommit || !rollbackOnError) {
1:             for (int i=0; i < 3; i++) {
1:                 rs.next();
1:                 int id = rs.getInt(1);
1:                 assertTrue(id - 1 == i);
1:                 assertEquals(new LoopingAlphabetReader(INSERT[i]),
1:                              rs.getCharacterStream(2));
1:             }
1:         }
1:         // Check rows 6 and 7.
1:         for (int i=5; i < 7; i++) {
1:             rs.next();
1:             int id = rs.getInt(1);
1:             assertTrue(id - 1 == i);
1:             assertEquals(new LoopingAlphabetReader(INSERT[i]),
1:                          rs.getCharacterStream(2));
1:         }
1:         assertFalse(rs.next());
1:         rs.close();
1:     }
1: 
1:     /**
1:      * WARNING: This reader is not a general purpose reader!!!
1:      * <p>
1:      * Reader thrown an exception when a certain amount of characters has been
1:      * returned (or is about to be returned).
1:      */
1:     public static class FailingReader
1:             extends Reader {
1: 
1:         private final LoopingAlphabetReader in;
1:         private final long failAtPos;
1:         private long pos;
1: 
1:         /**
1:          * Creates a new failing reader.
1:          *
1:          * @param length the total length of the source
1:          * @param failAtPos the position to fail at (specifying zero or a
1:          *      negative value causes an exception on the first read request)
1:          */
1:         public FailingReader(long length, long failAtPos) {
1:             this.failAtPos = failAtPos;
1:             this.in = new LoopingAlphabetReader(length);
1:         }
1: 
1:         public int read()
1:                 throws IOException {
1:             // If we failed once, just keep failing on subsequent requests.
1:             pos++;
1:             int ret = in.read();
1:             if (pos >= failAtPos) {
1:                 throw new IOException("forced exception");
1:             }
1:             return ret;
1:         }
1: 
1:         public int read(char[] cbuf, int off, int len)
1:                 throws IOException {
1:             // If we failed once, just keep failing on subsequent requests.
1:             // Try to return some valid data before failing.
1:             if (pos == 0 && failAtPos > 1) {
1:                 len = (int)Math.min(failAtPos -1, len);
1:             }
1:             int ret = in.read(cbuf, off, len);
1:             if (ret != -1) {
1:                 pos += ret;
1:             }
1:             if (pos >= failAtPos) {
1:                 throw new IOException("forced exception");
1:             }
1:             return ret;
1:         }
1: 
1:         public void close() {
1:             in.close();
1:         }
1:     }
1: }
============================================================================