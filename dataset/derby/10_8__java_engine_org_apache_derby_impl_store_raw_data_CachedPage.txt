4:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.data.CachedPage
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
44:eac0369: 
11:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.raw.data;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.log.LogInstant;
1:eac0369: import org.apache.derby.iapi.store.raw.PageKey;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.cache.Cacheable;
1:eac0369: import org.apache.derby.iapi.services.cache.CacheManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatIdUtil;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.error.ExceptionSeverity;
1:5d97422: 
1:5d97422: import org.apache.derby.iapi.util.InterruptStatus;
1:5d97422: 
1:eac0369: import java.io.IOException;
1:eac0369: 
9:eac0369: /**
1:eac0369: 	A base page that is cached.
1:eac0369: 
1:eac0369: 	Since there are multiple page formats, use this abstract class to implement
1:eac0369: 	cacheable interface.
1:eac0369: 
1:eac0369: */
1:eac0369: 
1:eac0369: public abstract class CachedPage extends BasePage implements Cacheable
8:eac0369: {
1:676d633: 	protected boolean   alreadyReadPage;    // true when page read by another 
1:676d633:                                             // class
1:676d633: 
1:676d633: 	protected byte[]    pageData;		    // the actual page data - this is
1:eac0369: 											// the 'buffer' in the buffer cache
1:eac0369: 
1:eac0369: 	// The isDirty flag indicates if the pageData or pageHeader has been
1:eac0369: 	// modified.  The preDirty flag indicates that the pageData or the
1:eac0369: 	// pageHeader is about to be modified.  The reason for these 2 flags
1:eac0369: 	// instead of just one is to accomodate checkpoint.  After a clean
1:eac0369: 	// (latched) page sends a log record to the log stream but before that page
1:eac0369: 	// is dirtied by the log operation, a checkpoint could be taken.  If so,
1:eac0369: 	// then the redoLWM will be after the log record but, without preDirty, the
1:eac0369: 	// cache cleaning will not have waited for the change.  So the preDirty bit
1:eac0369: 	// is to stop the cache cleaning from skipping over this (latched) page
1:eac0369: 	// even though it has not really been modified yet.  
1:eac0369: 
1:676d633: 	protected boolean		isDirty;		// must be set to true whenever the
1:676d633:                                             // pageData array is touched 
1:676d633:                                             // directly or indirectly.
1:eac0369: 
1:eac0369: 	protected boolean		preDirty;		// set to true if the page is clean
1:676d633: 								            // and the pageData array is about 
1:676d633:                                             // to be touched directly or 
1:676d633:                                             // indirectly.
1:eac0369: 
1:eac0369: 
1:676d633: 	protected int		initialRowCount;    // keep a running count of rows for
1:676d633: 										    // estimated row count.
1:eac0369: 
1:eac0369: 	private long 		containerRowCount;	// the number of rows in the
1:eac0369: 											// container when this page is read
1:eac0369: 											// from disk 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** These fields are immutable and can be used by the subclasses directly.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		The page cache I live in.
1:eac0369: 
1:eac0369: 		<BR> MT - Immutable
1:eac0369: 	*/
1:eac0369: 	protected CacheManager		pageCache;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		The container cache my container lives in.
1:eac0369: 
1:eac0369: 		<BR> MT - Immutable
1:eac0369: 	*/
1:eac0369: 	protected CacheManager		containerCache;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		My factory class.
1:eac0369: 
1:eac0369: 		<BR> MT - Immutable - 
1:eac0369: 	*/
1:eac0369: 	protected BaseDataFileFactory		dataFactory;  // my factory class.
1:eac0369: 
1:eac0369: 
1:eac0369: 	protected static final int PAGE_FORMAT_ID_SIZE = 4;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * the page need to be written and synced to disk 
1:eac0369: 	 */
1:eac0369: 	public static final int WRITE_SYNC = 1;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * the page need to be write to disk but not synced
1:eac0369: 	 */
1:eac0369: 	public static final int WRITE_NO_SYNC = 2;
1:eac0369: 
1:eac0369: 	public CachedPage()
1:eac0369: 	{
1:eac0369: 		super();
10:eac0369: 	}
1:25f99f5: 
1:676d633: 	public final void setFactory(BaseDataFileFactory factory) 
1:676d633:     {
1:676d633: 		dataFactory     = factory;
1:676d633: 		pageCache       = factory.getPageCache();
1:676d633: 		containerCache  = factory.getContainerCache();
1:eac0369: 	}
1:eac0369: 
1:676d633: 	/**
1:20bc69f:         Initialize a CachedPage.
1:20bc69f:         <p>
1:20bc69f: 		Initialize the object, ie. perform work normally perfomed in 
1:20bc69f:         constructor.  Called by setIdentity() and createIdentity().
1:25f99f5: 	*/
1:eac0369: 	protected void initialize()
1:eac0369: 	{
1:eac0369: 		super.initialize();
1:676d633: 		isDirty             = false;
1:676d633: 		preDirty            = false;
1:676d633: 		initialRowCount     = 0;
1:676d633: 		containerRowCount   = 0;
1:eac0369: 	}
1:eac0369: 
1:25f99f5: 	/*
1:eac0369: 	** Methods of Cacheable
1:eac0369: 	*/
1:eac0369: 
1:676d633:     /**
1:676d633:      * Find the container and then read the page from that container.
1:676d633:      * <p>
1:676d633:      * This is the way new pages enter the page cache.
1:676d633:      * <p>
1:676d633:      *
1:676d633: 	 * @return always true, higher levels have already checked the page number 
1:676d633:      *         is valid for an open.
1:676d633:      *
1:94f158a:      * @exception StandardException Standard Derby policy.
1:676d633:      *
1:676d633:      * @see Cacheable#setIdentity
1:676d633:      **/
1:676d633: 	public Cacheable setIdentity(Object key) 
1:676d633:         throws StandardException 
1:676d633:     {
1:676d633: 		if (SanityManager.DEBUG) 
1:676d633:         {
1:eac0369: 			SanityManager.ASSERT(key instanceof PageKey);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		initialize();
1:eac0369: 
1:eac0369: 		PageKey newIdentity = (PageKey) key;
1:eac0369: 
1:eac0369: 		FileContainer myContainer = 
1:676d633:             (FileContainer) containerCache.find(newIdentity.getContainerId());
1:676d633: 
3:eac0369: 		setContainerRowCount(myContainer.getEstimatedRowCount(0));
1:eac0369: 
2:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			if (!alreadyReadPage)
1:676d633:             {
1:676d633:                 // Fill in the pageData array by reading bytes from disk.
1:676d633: 				readPage(myContainer, newIdentity);	
1:676d633:             }
2:eac0369: 			else
1:676d633:             {
1:676d633:                 // pageData array already filled
1:eac0369: 				alreadyReadPage = false;
1:676d633:             }
1:eac0369: 
1:eac0369: 			// if the formatID on disk is not the same as this page instance's
1:eac0369: 			// format id, instantiate the real page object
1:eac0369: 			int fmtId = getTypeFormatId();
1:eac0369: 
1:eac0369: 			int onPageFormatId = FormatIdUtil.readFormatIdInteger(pageData);
1:eac0369: 			if (fmtId != onPageFormatId)
1:eac0369: 			{
1:676d633: 				return changeInstanceTo(
1:676d633:                             onPageFormatId, newIdentity).setIdentity(key);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// this is the correct page instance
1:eac0369: 			initFromData(myContainer, newIdentity);
1:eac0369: 		}
2:eac0369: 		finally
1:eac0369: 		{
2:eac0369: 			containerCache.release(myContainer);
2:eac0369: 			myContainer = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		fillInIdentity(newIdentity);
1:eac0369: 
2:eac0369: 		initialRowCount = 0;
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:676d633:     /**
1:676d633:      * Find the container and then create the page in that container.
1:676d633:      * <p>
1:676d633:      * This is the process of creating a new page in a container, in that
1:676d633:      * case no need to read the page from disk - just need to initialize it
1:676d633:      * in the cache.
1:676d633:      * <p>
1:676d633:      *
1:676d633: 	 * @return new page, higher levels have already checked the page number is 
1:676d633:      *         valid for an open.
1:676d633:      *
1:676d633:      * @param key               Which page is this?
1:676d633:      * @param createParameter   details needed to create page like size, 
1:676d633:      *                          format id, ...
1:676d633:      *
1:676d633: 	 * @exception  StandardException  Standard exception policy.
1:676d633:      *
1:676d633:      * @see Cacheable#createIdentity
1:676d633:      **/
1:676d633: 	public Cacheable createIdentity(
1:676d633:     Object  key, 
1:676d633:     Object  createParameter) 
1:676d633:         throws StandardException 
1:676d633:     {
1:eac0369: 
1:676d633: 		if (SanityManager.DEBUG) 
1:676d633:         {
1:eac0369: 			SanityManager.ASSERT(key instanceof PageKey);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		initialize();
1:eac0369: 
1:eac0369: 		PageKey newIdentity = (PageKey) key;
1:eac0369: 
1:1dbc0b8: 		PageCreationArgs createArgs = (PageCreationArgs) createParameter;
1:1dbc0b8:         int formatId = createArgs.formatId;
1:eac0369: 
1:1dbc0b8: 		if (formatId == -1)
1:eac0369:         {
3:eac0369: 			throw StandardException.newException(
1:a204074:                     SQLState.DATA_UNKNOWN_PAGE_FORMAT_2, 
1:a204074:                     newIdentity,
1:a204074:                     org.apache.derby.iapi.util.StringUtil.hexDump(pageData));
1:eac0369:         }
1:eac0369: 
1:676d633: 		// createArgs[0] contains the integer form of the formatId 
1:eac0369: 		// if it is not the same as this instance's formatId, instantiate the
1:eac0369: 		// real page object
1:1dbc0b8: 		if (formatId != getTypeFormatId())
1:eac0369: 		{
1:676d633: 			return(
1:1dbc0b8:                 changeInstanceTo(formatId, newIdentity).createIdentity(
1:676d633:                         key, createParameter));
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		// this is the correct page instance
1:eac0369: 		initializeHeaders(5);
1:eac0369: 		createPage(newIdentity, createArgs);
1:eac0369: 
1:eac0369: 		fillInIdentity(newIdentity);
1:eac0369: 
1:eac0369: 		initialRowCount = 0;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		 * if we need to grow the container and the page has not been
1:676d633: 		 * preallocated, writing page before the log is written so that we
1:eac0369: 		 * know if there is an IO error - like running out of disk space - then
1:eac0369: 		 * we don't write out the log record, because if we do, it may fail
1:eac0369: 		 * after the log goes to disk and then the database may not be
1:eac0369: 		 * recoverable. 
1:676d633: 		 *
1:eac0369: 		 * WRITE_SYNC is used when we create the page without first
1:eac0369: 		 *	preallocating it 
1:eac0369: 		 * WRITE_NO_SYNC is used when we are preallocating the page - there
1:eac0369: 		 *	will be a SYNC call after all the pages are preallocated
1:eac0369: 		 * 0 means creating a page that has already been preallocated.
1:eac0369: 		 */
1:1dbc0b8:         int syncFlag = createArgs.syncFlag;
1:1dbc0b8: 		if ((syncFlag & WRITE_SYNC) != 0 ||
1:1dbc0b8: 			(syncFlag & WRITE_NO_SYNC) != 0)
1:1dbc0b8: 			writePage(newIdentity, (syncFlag & WRITE_SYNC) != 0);
1:eac0369: 
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
1:eac0369: 			{
1:1dbc0b8: 				String sync =
1:1dbc0b8:                     ((syncFlag & WRITE_SYNC) != 0)     ? "Write_Sync" :
1:1dbc0b8: 					(((syncFlag & WRITE_NO_SYNC) != 0) ? "Write_NO_Sync" :
1:676d633: 					                                          "No_write");
1:676d633: 
1:676d633: 				SanityManager.DEBUG(
1:676d633:                     FileContainer.SPACE_TRACE,
1:1dbc0b8:                     "creating new page " + newIdentity + " with " + sync);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:676d633:     /**
1:676d633:      * Convert this page to requested type, as defined by input format id.
1:676d633:      * <p>
1:676d633:      * The current cache entry is a different format id than the requested
1:676d633:      * type, change it.  This object is instantiated to the wrong subtype of 
1:676d633:      * cachedPage, this routine will create an object with the correct subtype,
1:676d633:      * and transfer all pertinent information from this to the new correct 
1:676d633:      * object.
1:676d633:      * <p>
1:676d633:      *
1:676d633: 	 * @return The new object created with the input fid and transfered info.
1:676d633:      *
1:676d633:      * @param fid          The format id of the new page.
1:676d633:      * @param newIdentity  The key of the new page.
1:676d633:      *
1:676d633: 	 * @exception  StandardException  Standard exception policy.
1:676d633:      **/
1:eac0369: 	private CachedPage changeInstanceTo(int fid, PageKey newIdentity)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		CachedPage realPage;
1:a204074: 
1:eac0369: 		try 
1:eac0369:         {
1:eac0369: 			realPage = 
1:eac0369:                 (CachedPage) Monitor.newInstanceFromIdentifier(fid);
1:eac0369: 
1:eac0369: 		} 
1:eac0369:         catch (StandardException se) 
1:eac0369:         {
1:eac0369:             if (se.getSeverity() > ExceptionSeverity.STATEMENT_SEVERITY)
1:eac0369:             {
2:eac0369:                 throw se;
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 throw StandardException.newException(
1:a204074:                     SQLState.DATA_UNKNOWN_PAGE_FORMAT_2, 
1:a204074:                     newIdentity,
1:a204074:                     org.apache.derby.iapi.util.StringUtil.hexDump(pageData));
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		realPage.setFactory(dataFactory);
1:eac0369: 
1:eac0369: 		// avoid creating the data buffer if possible, transfer it to the new 
1:eac0369:         // page if this is the first time the page buffer is used, then 
1:eac0369:         // createPage will create the page array with the correct page size
1:676d633: 		if (this.pageData != null) 
1:676d633:         {
1:eac0369: 			realPage.alreadyReadPage = true;
1:eac0369: 			realPage.usePageBuffer(this.pageData);
1:eac0369: 		}
1:eac0369: 
1:676d633:         // RESOLVE (12/15/06) - the following code is commented out, but
1:676d633:         // not sure why.
1:676d633: 
1:eac0369: 		// this page should not be used any more, null out all its content and
1:eac0369: 		// wait for GC to clean it up  
1:eac0369: 
1:676d633: 		//destroyPage();// let this subtype have a chance to get rid of stuff
1:eac0369: 		//this.pageData = null;	// this instance no longer own the data array
1:eac0369: 		//this.pageCache = null;
1:eac0369: 		//this.dataFactory = null;
1:eac0369: 		//this.containerCache = null;
1:eac0369: 
1:eac0369: 		return realPage;
1:eac0369: 	}
1:eac0369: 
1:676d633:     /**
1:676d633:      * Is the page dirty?
1:676d633:      * <p>
1:676d633:      * The isDirty flag indicates if the pageData or pageHeader has been
1:676d633:      * modified.  The preDirty flag indicates that the pageData or the
1:676d633:      * pageHeader is about to be modified.  The reason for these 2 flags
1:676d633:      * instead of just one is to accomodate checkpoint.  After a clean
1:676d633:      * (latched) page sends a log record to the log stream but before that page
1:676d633:      * is dirtied by the log operation, a checkpoint could be taken.  If so,
1:676d633:      * then the redoLWM will be after the log record but, without preDirty, the
1:676d633:      * cache cleaning will not have waited for the change.  So the preDirty bit
1:676d633:      * is to stop the cache cleaning from skipping over this (latched) page
1:676d633:      * even though it has not really been modified yet.  
1:676d633:      *
1:676d633: 	 * @return true if the page is dirty.
1:676d633:      *
1:676d633:      * @see Cacheable#isDirty
1:676d633:      **/
1:676d633: 	public boolean isDirty() 
1:676d633:     {
1:676d633: 		synchronized (this) 
1:676d633:         {
1:eac0369: 			return isDirty || preDirty;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:676d633:     /**
1:676d633:      * Has the page or its header been modified.
1:676d633:      * <p>
1:676d633:      * See comment on class header on meaning of isDirty and preDirty bits.
1:676d633:      * <p>
1:676d633:      *
1:676d633: 	 * @return true if changes have actually been made to the page in memory.
1:676d633:      **/
1:676d633: 	public boolean isActuallyDirty() 
1:676d633:     {
1:676d633: 		synchronized (this) 
1:676d633:         {
1:eac0369: 			return isDirty;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:676d633:     /**
1:676d633:      * Set state to indicate the page or its header is about to be modified.
1:676d633:      * <p>
1:676d633:      * See comment on class header on meaning of isDirty and preDirty bits.
1:676d633:      **/
1:eac0369: 	public void preDirty()
1:676d633: 	{
1:676d633: 		synchronized (this) 
1:eac0369:         {
1:eac0369: 			if (!isDirty)
1:eac0369: 				preDirty = true;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:676d633:     /**
1:676d633:      * Set state to indicate the page or its header has been modified.
1:676d633:      * <p>
1:676d633:      * See comment on class header on meaning of isDirty and preDirty bits.
1:676d633:      * <p>
1:676d633:      **/
1:676d633: 	protected void setDirty() 
1:676d633:     {
1:676d633: 		synchronized (this) 
1:676d633:         {
1:676d633: 			isDirty  = true;
1:676d633: 			preDirty = false;
1:676d633: 		}
1:676d633: 	}
1:676d633: 
1:676d633:     /**
1:676d633:      * exclusive latch on page is being released.
1:676d633:      * <p>
1:676d633:      * The only work done in CachedPage is to update the row count on the
1:676d633:      * container if it is too out of sync.
1:676d633:      **/
1:eac0369: 	protected void releaseExclusive()
1:eac0369: 	{
1:676d633: 		// look at dirty bit without latching, the updating of the row
1:676d633:         // count is just an optimization so does not need the latch.
1:676d633:         //
1:eac0369: 		// if this page actually has > 1/8 rows of the entire container, then
1:676d633: 		// consider updating the row count if it is different.
1:676d633:         //
1:676d633:         // No need to special case allocation pages because it has recordCount 
1:676d633:         // of zero, thus the if clause will never be true for an allocation 
1:676d633:         // page.
1:eac0369: 		if (isDirty && !isOverflowPage() &&
1:eac0369: 			(containerRowCount / 8) < recordCount())
1:eac0369: 		{
2:eac0369: 			int currentRowCount = internalNonDeletedRecordCount();	
1:676d633: 			int delta           = currentRowCount-initialRowCount;
1:676d633: 			int posDelta        = delta > 0 ? delta : (-delta);
1:676d633: 
1:eac0369: 			if ((containerRowCount/8) < posDelta)
1:eac0369: 			{
1:676d633: 				// This pages delta row count represents a significant change
1:676d633:                 // with respect to current container row count so update 
1:676d633:                 // container row count
1:eac0369: 				FileContainer myContainer = null;
1:eac0369: 
1:eac0369: 				try
1:eac0369: 				{
1:676d633: 					myContainer = (FileContainer) 
1:676d633:                         containerCache.find(identity.getContainerId());
1:676d633: 
1:676d633: 					if (myContainer != null)
1:eac0369: 					{
1:eac0369: 						myContainer.updateEstimatedRowCount(delta);
1:676d633: 						setContainerRowCount(
1:676d633:                                 myContainer.getEstimatedRowCount(0));
1:676d633: 
2:eac0369: 						initialRowCount = currentRowCount;
1:676d633: 
1:eac0369: 						// since I have the container, might as well update the
1:eac0369: 						// unfilled information
1:676d633: 						myContainer.trackUnfilledPage(
1:676d633:                             identity.getPageNumber(), unfilled());
1:676d633: 					}
1:eac0369: 				}
1:676d633: 				catch (StandardException se)
1:eac0369: 				{
1:676d633: 					// do nothing, not sure what could fail but this update
1:676d633:                     // is just an optimization so no need to throw error.
1:eac0369: 				}
1:eac0369: 				finally
1:eac0369: 				{
2:eac0369: 					if (myContainer != null)
1:eac0369: 						containerCache.release(myContainer);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		super.releaseExclusive();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:676d633:     /**
1:eac0369:      * Write the page to disk.
1:676d633:      * <p>
1:eac0369:      * MP - In a simple world we would just not allow clean until it held the
1:eac0369:      *      latch on the page.  But in order to fit into the cache system, we 
1:eac0369:      *      don't have enough state around to just make clean() latch the page 
1:eac0369:      *      while doing the I/O - but we still need someway to insure that no
1:eac0369:      *      changes happen to the page while the I/O is taking place.  
1:eac0369:      *      Also someday it would be fine to allow reads of this page
1:eac0369:      *      while the I/O was taking place.  
2:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Error writing the page.
1:eac0369:      *
1:eac0369:      * @see Cacheable#clean
1:eac0369:      **/
1:676d633: 	public void clean(boolean remove) throws StandardException 
1:676d633:     {
1:eac0369: 
1:eac0369: 		// must wait for the page to be unlatched
1:676d633: 		synchronized (this) 
1:676d633:         {
1:eac0369: 			if (!isDirty())
1:eac0369: 				return;
1:eac0369: 
1:eac0369: 			// is someone else cleaning it
1:676d633: 			while (inClean) 
1:676d633:             {
1:676d633: 				try 
1:676d633:                 {
2:eac0369: 					wait();
1:676d633: 				} 
1:676d633:                 catch (InterruptedException ie) 
1:676d633:                 {
1:5d97422:                     InterruptStatus.setInterrupted();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:676d633:             // page is not "inClean" by other thread at this point.
1:676d633: 
1:eac0369: 			if (!isDirty())
1:eac0369: 				return;
1:eac0369: 
1:eac0369: 			inClean = true;
1:eac0369: 
1:eac0369: 			// If page is in LATCHED state (as opposed to UNLATCH or PRELATCH)
1:eac0369:             // wait for the page to move to UNLATCHED state.  See Comments in
1:eac0369:             // Generic/BasePage.java describing the interaction of inClean,
1:eac0369:             // (owner != null), and preLatch.
1:eac0369: 			while ((owner != null) && !preLatch) 
1:676d633:             {
1:676d633: 				try 
1:eac0369:                 { 
1:676d633:                     wait();
1:676d633: 				} 
1:676d633:                 catch (InterruptedException ie) 
1:eac0369: 				{
1:5d97422:                     InterruptStatus.setInterrupted();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// The page is now effectively latched by the cleaner.
1:eac0369: 			// We only want to clean the page if the page is actually dirtied,
1:eac0369: 			// not when it is just pre-dirtied.
1:676d633: 			if (!isActuallyDirty()) 
1:676d633:             {
1:676d633:                 // the person who latched it gives up the
1:676d633:                 // latch without really dirtying the page
1:676d633: 				preDirty = false; 
1:676d633: 				inClean  = false;
1:eac0369: 				notifyAll();
1:eac0369: 				return;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:676d633: 		try
1:eac0369: 		{
1:eac0369: 			writePage(getPageId(), false);
1:eac0369: 		}
2:eac0369: 		catch(StandardException se)
1:eac0369: 		{
1:676d633:             // If we get an error while trying to write a page, current
1:676d633:             // recovery system requires that entire DB is shutdown.  Then
1:676d633:             // when system is rebooted we will run redo recovery which 
1:676d633:             // if it does not encounter disk errors will guarantee to recover
1:676d633:             // to a transaction consistent state.  If this write is a 
1:676d633:             // persistent device problem, redo recovery will likely fail
1:676d633:             // attempting to the same I/O.  Mark corrupt will stop all further
1:676d633:             // writes of data and log by the system.
1:eac0369: 			throw dataFactory.markCorrupt(se);
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:676d633: 			// if there is something wrong in writing out the page, 
1:676d633:             // do not leave it inClean state or it will block the next cleaner 
1:676d633:             // forever
1:eac0369: 
1:676d633: 			synchronized (this) 
1:676d633:             {
3:eac0369: 				inClean = false;
1:eac0369: 				notifyAll();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:676d633: 	public void clearIdentity() 
1:676d633:     {
1:eac0369: 		alreadyReadPage = false;
1:eac0369: 		super.clearIdentity();
1:eac0369: 	}
1:eac0369: 
1:676d633:     /**
1:676d633:      * read the page from disk into this CachedPage object.
1:676d633:      * <p>
1:676d633:      * A page is read in from disk into the pageData array of this object,
1:676d633:      * and then put in the cache.
1:676d633:      * <p>
1:676d633:      *
1:676d633:      * @param myContainer the container to read the page from.
1:676d633:      * @param newIdentity indentity (ie. page number) of the page to read
1:676d633:      *
1:676d633: 	 * @exception  StandardException  Standard exception policy.
1:676d633:      **/
1:676d633: 	private void readPage(
1:676d633:     FileContainer   myContainer, 
1:676d633:     PageKey         newIdentity) 
1:676d633:         throws StandardException 
1:eac0369: 	{
1:eac0369: 		int pagesize = myContainer.getPageSize();
1:676d633: 
1:676d633:         // we will reuse the existing page array if it is same size, the
1:676d633:         // cache does support caching various sized pages.
1:eac0369: 		setPageArray(pagesize);
1:eac0369: 
1:676d633: 		for (int io_retry_count = 0;;)
1:676d633:         {
1:676d633: 			try 
1:676d633:             {
1:eac0369: 				myContainer.readPage(newIdentity.getPageNumber(), pageData);
1:eac0369: 				break;
1:676d633: 			} 
1:676d633:             catch (IOException ioe) 
1:676d633:             {
1:676d633: 				io_retry_count++;	
1:eac0369: 								
1:676d633: 				// Retrying read I/O's has been found to be successful sometimes
1:676d633:                 // in completing the read without having to fail the calling
1:676d633:                 // query, and in some cases avoiding complete db shutdown.
1:676d633:                 // Some situations are:
1:676d633:                 //     spurious interrupts being sent to thread by clients.
1:676d633:                 //     unreliable hardware like a network mounted file system.
1:676d633:                 //
1:676d633:                 // The only option other than retrying is to fail the I/O 
1:676d633:                 // immediately and throwing an error, thus performance cost
1:676d633:                 // not really a consideration.
1:676d633:                 //
1:676d633:                 // The retry max of 4 is arbitrary, but has been enough that
1:676d633:                 // not many read I/O errors have been reported.
1:676d633: 				if (io_retry_count > 4)
1:676d633:                 {
1:eac0369: 					// page cannot be physically read
1:eac0369: 	
1:eac0369: 					StandardException se = 
1:676d633: 						StandardException.newException(
1:eac0369: 								   SQLState.FILE_READ_PAGE_EXCEPTION, 
1:ce40a31: 								   ioe, newIdentity, pagesize);
1:eac0369: 
1:eac0369: 						
1:676d633: 				    if (dataFactory.getLogFactory().inRFR())
1:676d633:                     {
1:676d633:                         //if in rollforward recovery, it is possible that this 
1:676d633:                         //page actually does not exist on the disk yet because
1:676d633:                         //the log record we are proccessing now is actually 
1:676d633:                         //creating the page, we will recreate the page if we 
1:676d633:                         //are in rollforward recovery, so just throw the 
1:676d633:                         //exception.
1:676d633:                         throw se;
1:676d633:                     }
1:676d633:                     else
1:676d633:                     {
1:676d633:                         if (SanityManager.DEBUG)
1:676d633:                         {
1:676d633:                             // by shutting down system in debug mode, maybe
1:676d633:                             // we can catch root cause of the interrupt.
1:eac0369:                             throw dataFactory.markCorrupt(se);
1:676d633:                         }
1:676d633:                         else
1:676d633:                         {
1:676d633:                             // No need to shut down runtime database on read
1:676d633:                             // error in delivered system, throwing exception 
1:676d633:                             // should be enough.  Thrown exception has nested
1:676d633:                             // IO exception which is root cause of error.
1:676d633:                             throw se;
1:676d633:                         }
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:676d633:      * write the page from this CachedPage object to disk.
1:eac0369:      * <p>
1:eac0369:      *
1:6b50965:      * @param identity indentity (ie. page number) of the page to read
1:676d633:      * @param syncMe      does the write of this single page have to be sync'd?
1:676d633:      *
1:676d633: 	 * @exception  StandardException  Standard exception policy.
1:676d633:      **/
1:676d633: 	private void writePage(
1:676d633:     PageKey identity, 
1:676d633:     boolean syncMe) 
1:eac0369: 		 throws StandardException 
1:eac0369: 	{
1:eac0369: 
1:676d633:         // make subclass write the page format
1:676d633: 		writeFormatId(identity); 
1:eac0369: 
1:676d633:         // let subclass have a chance to write any cached data to page data 
1:676d633:         // array
1:676d633: 		writePage(identity);	 
1:eac0369: 
1:eac0369: 		// force WAL - and check to see if database is corrupt or is frozen.
1:eac0369: 		// last log Instant may be null if the page is being forced
1:eac0369: 		// to disk on a createPage (which violates the WAL protocol actually).
1:eac0369: 		// See FileContainer.newPage
1:eac0369: 		LogInstant flushLogTo = getLastLogInstant();
1:eac0369: 		dataFactory.flush(flushLogTo);
1:eac0369: 
1:676d633: 		if (flushLogTo != null) 
1:676d633:         {					
1:eac0369: 			clearLastLogInstant();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		// find the container and file access object
1:676d633: 		FileContainer myContainer = 
1:676d633:             (FileContainer) containerCache.find(identity.getContainerId());
1:eac0369: 
1:90daaab: 		if (myContainer == null)
1:676d633: 		{
1:90daaab: 			StandardException nested =
1:90daaab: 				StandardException.newException(
1:90daaab: 					SQLState.DATA_CONTAINER_VANISHED,
1:90daaab: 					identity.getContainerId());
1:eac0369: 			throw dataFactory.markCorrupt(
1:90daaab: 				StandardException.newException(
1:90daaab: 					SQLState.FILE_WRITE_PAGE_EXCEPTION, nested,
1:90daaab: 					identity));
1:90daaab: 		}
1:90daaab: 
1:90daaab: 		try
1:90daaab: 		{
1:90daaab: 			myContainer.writePage(
1:90daaab: 				identity.getPageNumber(), pageData, syncMe);
1:90daaab: 
1:90daaab: 			//
1:90daaab: 			// Do some in memory unlogged bookkeeping tasks while we have
1:90daaab: 			// the container.
1:90daaab: 			//
1:90daaab: 
1:90daaab: 			if (!isOverflowPage() && isDirty())
1:90daaab: 			{
1:90daaab: 
1:90daaab: 				// let the container knows whether this page is a not
1:90daaab: 				// filled, non-overflow page
1:90daaab: 				myContainer.trackUnfilledPage(
1:90daaab: 					identity.getPageNumber(), unfilled());
1:90daaab: 
1:90daaab: 				// if this is not an overflow page, see if the page's row
1:90daaab: 				// count has changed since it come into the cache.
1:90daaab: 				//
1:90daaab: 				// if the page is not invalid, row count is 0.	Otherwise,
1:90daaab: 				// count non-deleted records on page.
1:90daaab: 				//
1:90daaab: 				// Cannot call nonDeletedRecordCount because the page is
1:90daaab: 				// unlatched now even though nobody is changing it
1:90daaab: 				int currentRowCount = internalNonDeletedRecordCount();
1:90daaab: 
1:90daaab: 				if (currentRowCount != initialRowCount)
1:90daaab: 				{
1:90daaab: 					myContainer.updateEstimatedRowCount(
1:90daaab: 						currentRowCount - initialRowCount);
1:90daaab: 
1:90daaab: 					setContainerRowCount(
1:90daaab: 						myContainer.getEstimatedRowCount(0));
1:90daaab: 
1:90daaab: 					initialRowCount = currentRowCount;
1:90daaab: 				}
1:90daaab: 			}
1:90daaab: 
1:90daaab: 		}
1:90daaab: 		catch (IOException ioe)
1:90daaab: 		{
1:90daaab: 			// page cannot be written
1:90daaab: 			throw StandardException.newException(
1:90daaab: 				SQLState.FILE_WRITE_PAGE_EXCEPTION,
1:90daaab: 				ioe, identity);
1:90daaab: 		}
1:90daaab: 		finally
1:90daaab: 		{
1:90daaab: 			containerCache.release(myContainer);
1:90daaab: 			myContainer = null;
1:eac0369: 		}
1:eac0369: 
1:676d633: 		synchronized (this) 
1:676d633:         {
1:676d633:             // change page state to not dirty after the successful write
1:676d633: 			isDirty     = false;
1:676d633: 			preDirty    = false;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setContainerRowCount(long rowCount)
1:676d633: 	{
1:eac0369: 		containerRowCount = rowCount;
1:eac0369: 	}
1:eac0369: 
1:9d0dd8f: 	/**
1:eac0369: 	** if the page size is different from the page buffer, then make a
1:eac0369: 	** new page buffer and make subclass use the new page buffer
1:eac0369: 	*/
1:c225964: 	protected void setPageArray(int pageSize)
1:eac0369: 	{
1:676d633: 		if ((pageData == null) || (pageData.length != pageSize)) 
1:676d633:         {
1:9d0dd8f:             // Give a chance for garbage collection to free
1:9d0dd8f:             // the old array before the new array is allocated.
1:9d0dd8f:             // Just in case memory is low.
1:c225964:             pageData = null; 
1:eac0369: 			pageData = new byte[pageSize];
1:eac0369: 		}
1:a390adb: 
1:a390adb:         // Always call usePageBuffer(), even when we reuse the buffer, so that
1:a390adb:         // totalSpace and friends are recalculated (DERBY-3116).
1:a390adb:         usePageBuffer(pageData);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:676d633: 	 * Returns the page data array used to write on disk version.
1:676d633:      *
1:676d633:      * <p>
1:25f99f5: 	 * returns the page data array, that is actually written to the disk,
1:676d633: 	 * when the page is cleaned from the page cache.  Takes care of flushing
1:676d633:      * in-memory information to the array (like page header and format id info).
1:676d633:      * <p>
1:676d633:      *
1:676d633: 	 * @return The array of bytes that is the on disk version of page.
1:676d633:      *
1:676d633: 	 * @exception  StandardException  Standard exception policy.
1:676d633:      **/
1:25f99f5: 	protected byte[] getPageArray() throws StandardException 
1:25f99f5: 	{
1:676d633:         // make subclass write the page format
1:676d633: 		writeFormatId(identity); 
1:676d633: 
1:676d633:         // let subclass have a chance to write any cached
1:676d633:         // data to page data array
1:676d633: 		writePage(identity);	
1:676d633: 
1:25f99f5: 		return pageData;
1:25f99f5: 	}
1:25f99f5: 
1:eac0369: 	/* methods for subclass of cached page */
1:eac0369: 
1:eac0369: 	// use a new pageData buffer, initialize in memory structure that depend on
1:eac0369: 	// the pageData's size.  The actual disk data may not have not been read in
1:eac0369: 	// yet so don't look at the content of the buffer
1:eac0369: 	protected abstract void usePageBuffer(byte[] buffer);
1:eac0369: 
1:eac0369: 
1:eac0369: 	// initialize in memory structure using the read in buffer in pageData
1:676d633: 	protected abstract void initFromData(FileContainer container, PageKey id) 
1:676d633:         throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	// create the page
1:1dbc0b8: 	protected abstract void createPage(PageKey id, PageCreationArgs args)
1:676d633:         throws StandardException;
1:eac0369: 
1:eac0369: 	// page is about to be written, write everything to pageData array
1:eac0369: 	protected abstract void writePage(PageKey id) throws StandardException;		
1:eac0369: 
1:eac0369: 	// write out the formatId to the pageData
1:676d633: 	protected abstract void writeFormatId(PageKey identity) 
1:676d633:         throws StandardException;
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1: 								   ioe, newIdentity, pagesize);
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:5d97422
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.derby.iapi.util.InterruptStatus;
1: 
/////////////////////////////////////////////////////////////////////////
1:                     InterruptStatus.setInterrupted();
/////////////////////////////////////////////////////////////////////////
1:                     InterruptStatus.setInterrupted();
commit:90daaab
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		if (myContainer == null)
1: 			StandardException nested =
1: 				StandardException.newException(
1: 					SQLState.DATA_CONTAINER_VANISHED,
1: 					identity.getContainerId());
1: 				StandardException.newException(
1: 					SQLState.FILE_WRITE_PAGE_EXCEPTION, nested,
1: 					identity));
1: 		}
1: 
1: 		try
1: 		{
1: 			myContainer.writePage(
1: 				identity.getPageNumber(), pageData, syncMe);
1: 
1: 			//
1: 			// Do some in memory unlogged bookkeeping tasks while we have
1: 			// the container.
1: 			//
1: 
1: 			if (!isOverflowPage() && isDirty())
1: 			{
1: 
1: 				// let the container knows whether this page is a not
1: 				// filled, non-overflow page
1: 				myContainer.trackUnfilledPage(
1: 					identity.getPageNumber(), unfilled());
1: 
1: 				// if this is not an overflow page, see if the page's row
1: 				// count has changed since it come into the cache.
1: 				//
1: 				// if the page is not invalid, row count is 0.	Otherwise,
1: 				// count non-deleted records on page.
1: 				//
1: 				// Cannot call nonDeletedRecordCount because the page is
1: 				// unlatched now even though nobody is changing it
1: 				int currentRowCount = internalNonDeletedRecordCount();
1: 
1: 				if (currentRowCount != initialRowCount)
1: 				{
1: 					myContainer.updateEstimatedRowCount(
1: 						currentRowCount - initialRowCount);
1: 
1: 					setContainerRowCount(
1: 						myContainer.getEstimatedRowCount(0));
1: 
1: 					initialRowCount = currentRowCount;
1: 				}
1: 			}
1: 
1: 		}
1: 		catch (IOException ioe)
1: 		{
1: 			// page cannot be written
1: 			throw StandardException.newException(
1: 				SQLState.FILE_WRITE_PAGE_EXCEPTION,
1: 				ioe, identity);
1: 		}
1: 		finally
1: 		{
1: 			containerCache.release(myContainer);
1: 			myContainer = null;
commit:ba778a7
/////////////////////////////////////////////////////////////////////////
0:                     ioe, identity);
/////////////////////////////////////////////////////////////////////////
0:                     identity));
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:a204074
/////////////////////////////////////////////////////////////////////////
1:                     SQLState.DATA_UNKNOWN_PAGE_FORMAT_2, 
1:                     newIdentity,
1:                     org.apache.derby.iapi.util.StringUtil.hexDump(pageData));
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                     SQLState.DATA_UNKNOWN_PAGE_FORMAT_2, 
1:                     newIdentity,
1:                     org.apache.derby.iapi.util.StringUtil.hexDump(pageData));
commit:676d633
/////////////////////////////////////////////////////////////////////////
1: 	protected boolean   alreadyReadPage;    // true when page read by another 
1:                                             // class
1: 	protected byte[]    pageData;		    // the actual page data - this is
/////////////////////////////////////////////////////////////////////////
1: 	protected boolean		isDirty;		// must be set to true whenever the
1:                                             // pageData array is touched 
1:                                             // directly or indirectly.
1: 								            // and the pageData array is about 
1:                                             // to be touched directly or 
1:                                             // indirectly.
1: 	protected int		initialRowCount;    // keep a running count of rows for
1: 										    // estimated row count.
/////////////////////////////////////////////////////////////////////////
1: 	public final void setFactory(BaseDataFileFactory factory) 
1:     {
1: 		dataFactory     = factory;
1: 		pageCache       = factory.getPageCache();
1: 		containerCache  = factory.getContainerCache();
/////////////////////////////////////////////////////////////////////////
1: 		isDirty             = false;
1: 		preDirty            = false;
1: 		initialRowCount     = 0;
1: 		containerRowCount   = 0;
1:     /**
1:      * Find the container and then read the page from that container.
1:      * <p>
1:      * This is the way new pages enter the page cache.
1:      * <p>
1:      *
1: 	 * @return always true, higher levels have already checked the page number 
1:      *         is valid for an open.
1:      *
0:      * @exception StandardException Standard Cloudscape policy.
1:      *
1:      * @see Cacheable#setIdentity
1:      **/
1: 	public Cacheable setIdentity(Object key) 
1:         throws StandardException 
1:     {
1: 		if (SanityManager.DEBUG) 
1:         {
/////////////////////////////////////////////////////////////////////////
1:             (FileContainer) containerCache.find(newIdentity.getContainerId());
1: 
1:             {
1:                 // Fill in the pageData array by reading bytes from disk.
1: 				readPage(myContainer, newIdentity);	
1:             }
1:             {
1:                 // pageData array already filled
1:             }
/////////////////////////////////////////////////////////////////////////
1: 				return changeInstanceTo(
1:                             onPageFormatId, newIdentity).setIdentity(key);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Find the container and then create the page in that container.
1:      * <p>
1:      * This is the process of creating a new page in a container, in that
1:      * case no need to read the page from disk - just need to initialize it
1:      * in the cache.
1:      * <p>
1:      *
1: 	 * @return new page, higher levels have already checked the page number is 
1:      *         valid for an open.
1:      *
1:      * @param key               Which page is this?
1:      * @param createParameter   details needed to create page like size, 
1:      *                          format id, ...
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
1:      * @see Cacheable#createIdentity
1:      **/
1: 	public Cacheable createIdentity(
1:     Object  key, 
1:     Object  createParameter) 
1:         throws StandardException 
1:     {
1: 		if (SanityManager.DEBUG) 
1:         {
/////////////////////////////////////////////////////////////////////////
1: 		// createArgs[0] contains the integer form of the formatId 
1: 			return(
0:                 changeInstanceTo(createArgs[0], newIdentity).createIdentity(
1:                         key, createParameter));
/////////////////////////////////////////////////////////////////////////
1: 		 * preallocated, writing page before the log is written so that we
/////////////////////////////////////////////////////////////////////////
0: 				String syncFlag = 
0:                     ((createArgs[1] & WRITE_SYNC) != 0)     ? "Write_Sync" :
1: 					                                          "No_write");
1: 
1: 				SanityManager.DEBUG(
1:                     FileContainer.SPACE_TRACE,
0:                     "creating new page " + newIdentity + " with " + syncFlag);
1:     /**
1:      * Convert this page to requested type, as defined by input format id.
1:      * <p>
1:      * The current cache entry is a different format id than the requested
1:      * type, change it.  This object is instantiated to the wrong subtype of 
1:      * cachedPage, this routine will create an object with the correct subtype,
1:      * and transfer all pertinent information from this to the new correct 
1:      * object.
1:      * <p>
1:      *
1: 	 * @return The new object created with the input fid and transfered info.
1:      *
1:      * @param fid          The format id of the new page.
1:      * @param newIdentity  The key of the new page.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
/////////////////////////////////////////////////////////////////////////
1: 		if (this.pageData != null) 
1:         {
1:         // RESOLVE (12/15/06) - the following code is commented out, but
1:         // not sure why.
1: 
1: 		//destroyPage();// let this subtype have a chance to get rid of stuff
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Is the page dirty?
1:      * <p>
1:      * The isDirty flag indicates if the pageData or pageHeader has been
1:      * modified.  The preDirty flag indicates that the pageData or the
1:      * pageHeader is about to be modified.  The reason for these 2 flags
1:      * instead of just one is to accomodate checkpoint.  After a clean
1:      * (latched) page sends a log record to the log stream but before that page
1:      * is dirtied by the log operation, a checkpoint could be taken.  If so,
1:      * then the redoLWM will be after the log record but, without preDirty, the
1:      * cache cleaning will not have waited for the change.  So the preDirty bit
1:      * is to stop the cache cleaning from skipping over this (latched) page
1:      * even though it has not really been modified yet.  
1:      *
1: 	 * @return true if the page is dirty.
1:      *
1:      * @see Cacheable#isDirty
1:      **/
1: 	public boolean isDirty() 
1:     {
1: 		synchronized (this) 
1:         {
1:     /**
1:      * Has the page or its header been modified.
1:      * <p>
1:      * See comment on class header on meaning of isDirty and preDirty bits.
1:      * <p>
1:      *
1: 	 * @return true if changes have actually been made to the page in memory.
1:      **/
1: 	public boolean isActuallyDirty() 
1:     {
1: 		synchronized (this) 
1:         {
1:     /**
1:      * Set state to indicate the page or its header is about to be modified.
1:      * <p>
1:      * See comment on class header on meaning of isDirty and preDirty bits.
1:      **/
1: 		synchronized (this) 
1:         {
1:     /**
1:      * Set state to indicate the page or its header has been modified.
1:      * <p>
1:      * See comment on class header on meaning of isDirty and preDirty bits.
1:      * <p>
1:      **/
1: 	protected void setDirty() 
1:     {
1: 		synchronized (this) 
1:         {
1: 			isDirty  = true;
1: 			preDirty = false;
1: 		}
1: 	}
1: 
1:     /**
1:      * exclusive latch on page is being released.
1:      * <p>
1:      * The only work done in CachedPage is to update the row count on the
1:      * container if it is too out of sync.
1:      **/
1: 		// look at dirty bit without latching, the updating of the row
1:         // count is just an optimization so does not need the latch.
1:         //
1: 		// consider updating the row count if it is different.
1:         //
1:         // No need to special case allocation pages because it has recordCount 
1:         // of zero, thus the if clause will never be true for an allocation 
1:         // page.
1: 			int delta           = currentRowCount-initialRowCount;
1: 			int posDelta        = delta > 0 ? delta : (-delta);
1: 
1: 				// This pages delta row count represents a significant change
1:                 // with respect to current container row count so update 
1:                 // container row count
1: 					myContainer = (FileContainer) 
1:                         containerCache.find(identity.getContainerId());
1: 
1: 						setContainerRowCount(
1:                                 myContainer.getEstimatedRowCount(0));
1: 
1: 						myContainer.trackUnfilledPage(
1:                             identity.getPageNumber(), unfilled());
1: 				catch (StandardException se)
1: 					// do nothing, not sure what could fail but this update
1:                     // is just an optimization so no need to throw error.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	public void clean(boolean remove) throws StandardException 
1:     {
1: 		synchronized (this) 
1:         {
1: 			while (inClean) 
1:             {
1: 				try 
1:                 {
1: 				} 
1:                 catch (InterruptedException ie) 
1:                 {
1:             // page is not "inClean" by other thread at this point.
1: 
/////////////////////////////////////////////////////////////////////////
1: 				try 
1:                 { 
1:                     wait();
1: 				} 
1:                 catch (InterruptedException ie) 
/////////////////////////////////////////////////////////////////////////
1: 			if (!isActuallyDirty()) 
1:             {
1:                 // the person who latched it gives up the
1:                 // latch without really dirtying the page
1: 				preDirty = false; 
1: 				inClean  = false;
/////////////////////////////////////////////////////////////////////////
1:             // If we get an error while trying to write a page, current
1:             // recovery system requires that entire DB is shutdown.  Then
1:             // when system is rebooted we will run redo recovery which 
1:             // if it does not encounter disk errors will guarantee to recover
1:             // to a transaction consistent state.  If this write is a 
1:             // persistent device problem, redo recovery will likely fail
1:             // attempting to the same I/O.  Mark corrupt will stop all further
1:             // writes of data and log by the system.
1: 			// if there is something wrong in writing out the page, 
1:             // do not leave it inClean state or it will block the next cleaner 
1:             // forever
1: 			synchronized (this) 
1:             {
1: 	public void clearIdentity() 
1:     {
1:     /**
1:      * read the page from disk into this CachedPage object.
1:      * <p>
1:      * A page is read in from disk into the pageData array of this object,
1:      * and then put in the cache.
1:      * <p>
1:      *
1:      * @param myContainer the container to read the page from.
1:      * @param newIdentity indentity (ie. page number) of the page to read
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	private void readPage(
1:     FileContainer   myContainer, 
1:     PageKey         newIdentity) 
1:         throws StandardException 
1: 
1:         // we will reuse the existing page array if it is same size, the
1:         // cache does support caching various sized pages.
1: 		for (int io_retry_count = 0;;)
1:         {
1: 			try 
1:             {
1: 			} 
1:             catch (IOException ioe) 
1:             {
1: 				io_retry_count++;	
1: 				// Retrying read I/O's has been found to be successful sometimes
1:                 // in completing the read without having to fail the calling
1:                 // query, and in some cases avoiding complete db shutdown.
1:                 // Some situations are:
1:                 //     spurious interrupts being sent to thread by clients.
1:                 //     unreliable hardware like a network mounted file system.
1:                 //
1:                 // The only option other than retrying is to fail the I/O 
1:                 // immediately and throwing an error, thus performance cost
1:                 // not really a consideration.
1:                 //
1:                 // The retry max of 4 is arbitrary, but has been enough that
1:                 // not many read I/O errors have been reported.
1: 				if (io_retry_count > 4)
1:                 {
/////////////////////////////////////////////////////////////////////////
1: 				    if (dataFactory.getLogFactory().inRFR())
1:                         //if in rollforward recovery, it is possible that this 
1:                         //page actually does not exist on the disk yet because
1:                         //the log record we are proccessing now is actually 
1:                         //creating the page, we will recreate the page if we 
1:                         //are in rollforward recovery, so just throw the 
1:                         //exception.
1:                         throw se;
1:                     }
1:                     else
1:                     {
1:                         if (SanityManager.DEBUG)
1:                         {
1:                             // by shutting down system in debug mode, maybe
1:                             // we can catch root cause of the interrupt.
1:                         }
1:                         else
1:                         {
1:                             // No need to shut down runtime database on read
1:                             // error in delivered system, throwing exception 
1:                             // should be enough.  Thrown exception has nested
1:                             // IO exception which is root cause of error.
1:                             throw se;
1:                         }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * write the page from this CachedPage object to disk.
1:      * <p>
1:      *
0:      * @param newIdentity indentity (ie. page number) of the page to read
1:      * @param syncMe      does the write of this single page have to be sync'd?
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	private void writePage(
1:     PageKey identity, 
1:     boolean syncMe) 
1:         // make subclass write the page format
1: 		writeFormatId(identity); 
1:         // let subclass have a chance to write any cached data to page data 
1:         // array
1: 		writePage(identity);	 
/////////////////////////////////////////////////////////////////////////
1: 		if (flushLogTo != null) 
1:         {					
1: 		FileContainer myContainer = 
1:             (FileContainer) containerCache.find(identity.getContainerId());
1: 		if (myContainer != null) 
1:         {
1: 			try 
1:             {
0: 				myContainer.writePage(
0:                     identity.getPageNumber(), pageData, syncMe);
/////////////////////////////////////////////////////////////////////////
0: 					// let the container knows whether this page is a not 
0:                     // filled, non-overflow page
0: 					myContainer.trackUnfilledPage(
0:                         identity.getPageNumber(), unfilled());
/////////////////////////////////////////////////////////////////////////
0: 						myContainer.updateEstimatedRowCount(
0:                             currentRowCount - initialRowCount);
1: 
0: 						setContainerRowCount(
0:                             myContainer.getEstimatedRowCount(0));
1: 
1: 			} 
0:             catch (IOException ioe) 
1:             {
/////////////////////////////////////////////////////////////////////////
0: 			StandardException nested = 
1:                 StandardException.newException(
0:                     SQLState.DATA_CONTAINER_VANISHED, 
0:                     identity.getContainerId());
1: 		synchronized (this) 
1:         {
1:             // change page state to not dirty after the successful write
1: 			isDirty     = false;
1: 			preDirty    = false;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		if ((pageData == null) || (pageData.length != pageSize)) 
1:         {
/////////////////////////////////////////////////////////////////////////
1:     /**
1: 	 * Returns the page data array used to write on disk version.
1:      *
1:      * <p>
1: 	 * when the page is cleaned from the page cache.  Takes care of flushing
1:      * in-memory information to the array (like page header and format id info).
1:      * <p>
1:      *
1: 	 * @return The array of bytes that is the on disk version of page.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:         // make subclass write the page format
1: 		writeFormatId(identity); 
1: 
1:         // let subclass have a chance to write any cached
1:         // data to page data array
1: 		writePage(identity);	
1: 
/////////////////////////////////////////////////////////////////////////
1: 	protected abstract void initFromData(FileContainer container, PageKey id) 
1:         throws StandardException;
0: 	protected abstract void createPage(PageKey id, int[] args) 
1:         throws StandardException;
1: 	protected abstract void writeFormatId(PageKey identity) 
1:         throws StandardException;
commit:25f99f5
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/*
1: 	 * returns the page data array, that is actually written to the disk,
0: 	 * when the page is cleaned from the page cache.
1: 	 */
1: 	protected byte[] getPageArray() throws StandardException 
1: 	{
0: 		writeFormatId(identity); // make subclass write the page format
0: 		writePage(identity);	// let subclass have a chance to write any cached
0: 								// data to page data array
1: 		return pageData;
1: 	}
1: 
commit:20bc69f
/////////////////////////////////////////////////////////////////////////
1:         Initialize a CachedPage.
1:         <p>
1: 		Initialize the object, ie. perform work normally perfomed in 
1:         constructor.  Called by setIdentity() and createIdentity().
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a390adb
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Always call usePageBuffer(), even when we reuse the buffer, so that
1:         // totalSpace and friends are recalculated (DERBY-3116).
1:         usePageBuffer(pageData);
commit:1dbc0b8
/////////////////////////////////////////////////////////////////////////
1: 		PageCreationArgs createArgs = (PageCreationArgs) createParameter;
1:         int formatId = createArgs.formatId;
1: 		if (formatId == -1)
/////////////////////////////////////////////////////////////////////////
1: 		if (formatId != getTypeFormatId())
1:                 changeInstanceTo(formatId, newIdentity).createIdentity(
/////////////////////////////////////////////////////////////////////////
1:         int syncFlag = createArgs.syncFlag;
1: 		if ((syncFlag & WRITE_SYNC) != 0 ||
1: 			(syncFlag & WRITE_NO_SYNC) != 0)
1: 			writePage(newIdentity, (syncFlag & WRITE_SYNC) != 0);
1: 				String sync =
1:                     ((syncFlag & WRITE_SYNC) != 0)     ? "Write_Sync" :
1: 					(((syncFlag & WRITE_NO_SYNC) != 0) ? "Write_NO_Sync" :
1:                     "creating new page " + newIdentity + " with " + sync);
/////////////////////////////////////////////////////////////////////////
1: 	protected abstract void createPage(PageKey id, PageCreationArgs args)
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException Standard Derby policy.
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9d0dd8f
/////////////////////////////////////////////////////////////////////////
1: 	/**
1:             // Give a chance for garbage collection to free
1:             // the old array before the new array is allocated.
1:             // Just in case memory is low.
commit:c225964
/////////////////////////////////////////////////////////////////////////
1: 	protected void setPageArray(int pageSize)
0:             // Give a chance for gc to release the old buffer
1:             pageData = null; 
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.data.CachedPage
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:c6ad534
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.data;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.impl.store.raw.data.BasePage;
1: 
1: import org.apache.derby.iapi.store.raw.log.LogInstant;
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.PageKey;
1: 
1: import org.apache.derby.iapi.services.cache.Cacheable;
1: import org.apache.derby.iapi.services.cache.CacheManager;
0: import org.apache.derby.iapi.services.context.ContextService;
1: 
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.error.ExceptionSeverity;
1: import java.io.IOException;
1: 
1: /**
1: 	A base page that is cached.
1: 
1: 	Since there are multiple page formats, use this abstract class to implement
1: 	cacheable interface.
1: 
1: 
1: */
1: 
1: public abstract class CachedPage extends BasePage implements Cacheable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	protected boolean		alreadyReadPage;	// set to true when the page was read by another class
1: 
0: 	protected byte[]		pageData;		// the actual page data - this is
1: 											// the 'buffer' in the buffer cache
1: 
1: 	// The isDirty flag indicates if the pageData or pageHeader has been
1: 	// modified.  The preDirty flag indicates that the pageData or the
1: 	// pageHeader is about to be modified.  The reason for these 2 flags
1: 	// instead of just one is to accomodate checkpoint.  After a clean
1: 	// (latched) page sends a log record to the log stream but before that page
1: 	// is dirtied by the log operation, a checkpoint could be taken.  If so,
1: 	// then the redoLWM will be after the log record but, without preDirty, the
1: 	// cache cleaning will not have waited for the change.  So the preDirty bit
1: 	// is to stop the cache cleaning from skipping over this (latched) page
1: 	// even though it has not really been modified yet.  
1: 
0: 	protected boolean		isDirty;		// must be set to true
0: 								// whenever the pageData array is touched directly
0: 								// or indirectly.
1: 
1: 	protected boolean		preDirty;		// set to true if the page is clean
0: 								// and the pageData array is about to be
0: 								// touched directly or indirectly.
1: 
1: 
0: 	protected int		initialRowCount; // keep a running count of rows for
0: 										 // estimated row count.
1: 
1: 	private long 		containerRowCount;	// the number of rows in the
1: 											// container when this page is read
1: 											// from disk 
1: 
1: 	/*
1: 	** These fields are immutable and can be used by the subclasses directly.
1: 	*/
1: 
1: 	/**
1: 		The page cache I live in.
1: 
1: 		<BR> MT - Immutable
1: 	*/
1: 	protected CacheManager		pageCache;
1: 
1: 	/**
1: 		The container cache my container lives in.
1: 
1: 		<BR> MT - Immutable
1: 	*/
1: 	protected CacheManager		containerCache;
1: 
1: 	/**
1: 		My factory class.
1: 
1: 		<BR> MT - Immutable - 
1: 	*/
1: 	protected BaseDataFileFactory		dataFactory;  // my factory class.
1: 
1: 
1: 	protected static final int PAGE_FORMAT_ID_SIZE = 4;
1: 
1: 	/*
1: 	 * the page need to be written and synced to disk 
1: 	 */
1: 	public static final int WRITE_SYNC = 1;
1: 
1: 	/*
1: 	 * the page need to be write to disk but not synced
1: 	 */
1: 	public static final int WRITE_NO_SYNC = 2;
1: 
1: 	public CachedPage()
1: 	{
1: 		super();
1: 	}
1: 
0: 	public final void setFactory(BaseDataFileFactory factory) {
0: 		dataFactory = factory;
0: 		pageCache = factory.getPageCache();
0: 		containerCache = factory.getContainerCache();
1: 	}
1: 
1: 	/**
0: 		Initialize the object, ie. perform work normally perfomed in constructor.
0: 		Called by setIdentity() and createIdentity().
1: 	*/
1: 	protected void initialize()
1: 	{
1: 		super.initialize();
0: 		isDirty = false;
0: 		preDirty = false;
1: 		initialRowCount = 0;
0: 		containerRowCount = 0;
1: 	}
1: 
1: 	/*
1: 	** Methods of Cacheable
1: 	*/
1: 
1: 	/**
0: 		Find the container and then read the page from that container.
1: 
0: 		@return always true, higher levels have already checked the page number is
0: 		valid for an open.
1: 
0: 		@exception StandardException Standard Cloudscape policy.
1: 
0: 		@see Cacheable#setIdentity
1: 	*/
0: 	public Cacheable setIdentity(Object key) throws StandardException {
1: 
0: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(key instanceof PageKey);
1: 		}
1: 
1: 		initialize();
1: 
1: 		PageKey newIdentity = (PageKey) key;
1: 
1: 		FileContainer myContainer = 
0: 				(FileContainer) containerCache.find(newIdentity.getContainerId());
1: 		setContainerRowCount(myContainer.getEstimatedRowCount(0));
1: 
1: 		try
1: 		{
1: 			if (!alreadyReadPage)
0: 				readPage(myContainer, newIdentity);	// read in the pageData array from disk
1: 			else
1: 				alreadyReadPage = false;
1: 
1: 			// if the formatID on disk is not the same as this page instance's
1: 			// format id, instantiate the real page object
1: 			int fmtId = getTypeFormatId();
1: 
1: 			int onPageFormatId = FormatIdUtil.readFormatIdInteger(pageData);
1: 			if (fmtId != onPageFormatId)
1: 			{
0: 				return changeInstanceTo(onPageFormatId, newIdentity).setIdentity(key);
1: 			}
1: 
1: 			// this is the correct page instance
1: 			initFromData(myContainer, newIdentity);
1: 		}
1: 		finally
1: 		{
1: 			containerCache.release(myContainer);
1: 			myContainer = null;
1: 		}
1: 
1: 		fillInIdentity(newIdentity);
1: 
1: 		initialRowCount = 0;
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
0: 		Find the container and then create the page in that container.
1: 
0: 		@return new page, higher levels have already checked the page number is
0: 		valid for an open.
1: 
0: 		@exception StandardException Standard Cloudscape policy.
1: 
0: 		@see Cacheable#createIdentity
1: 	*/
0: 	public Cacheable createIdentity(Object key, Object createParameter) throws StandardException {
1: 
0: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(key instanceof PageKey);
1: 		}
1: 
1: 		initialize();
1: 
1: 		PageKey newIdentity = (PageKey) key;
1: 
0: 		int[] createArgs = (int[]) createParameter;
1: 
0: 		if (createArgs[0] == -1)
1:         {
1: 			throw StandardException.newException(
0:                     SQLState.DATA_UNKNOWN_PAGE_FORMAT, newIdentity);
1:         }
1: 
0: 		// createArgs[0] contains the interger form of the formatId 
1: 		// if it is not the same as this instance's formatId, instantiate the
1: 		// real page object
0: 		if (createArgs[0] != getTypeFormatId())
1: 		{
0: 			return changeInstanceTo(createArgs[0], newIdentity).createIdentity(key, createParameter);
1: 		}
1: 		
1: 		// this is the correct page instance
1: 		initializeHeaders(5);
1: 		createPage(newIdentity, createArgs);
1: 
1: 		fillInIdentity(newIdentity);
1: 
1: 		initialRowCount = 0;
1: 
1: 		/*
1: 		 * if we need to grow the container and the page has not been
0: 		 * preallocated , writing page before the log is written so that we
1: 		 * know if there is an IO error - like running out of disk space - then
1: 		 * we don't write out the log record, because if we do, it may fail
1: 		 * after the log goes to disk and then the database may not be
1: 		 * recoverable. 
1: 		 *
1: 		 * WRITE_SYNC is used when we create the page without first
1: 		 *	preallocating it 
1: 		 * WRITE_NO_SYNC is used when we are preallocating the page - there
1: 		 *	will be a SYNC call after all the pages are preallocated
1: 		 * 0 means creating a page that has already been preallocated.
1: 		 */
0: 		if ((createArgs[1] & WRITE_SYNC) != 0 ||
0: 			(createArgs[1] & WRITE_NO_SYNC) != 0)
0: 			writePage(newIdentity, (createArgs[1] & WRITE_SYNC) != 0);
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
1: 			{
0: 				String syncFlag = ((createArgs[1] & WRITE_SYNC) != 0) ? "Write_Sync" :
0: 					(((createArgs[1] & WRITE_NO_SYNC) != 0) ? "Write_NO_Sync" : 
0: 					 "No_write");
0: 				SanityManager.DEBUG(FileContainer.SPACE_TRACE,
0: 									"creating new page " + newIdentity + 
0: 									" with " + syncFlag);
1: 			}
1: 		}
1: 
1: 		return this;
1: 	}
1: 
1: 	/*
0: 	 * this object is instantiated to the wrong subtype of cachedPage, 
0: 	 * this routine will create an object with the correct subtype, transfer all 
0: 	 * pertinent information from this to the new correct object.
1: 	 */
1: 	private CachedPage changeInstanceTo(int fid, PageKey newIdentity)
1: 		 throws StandardException
1: 	{
1: 		CachedPage realPage;
1: 		try 
1:         {
1: 			realPage = 
1:                 (CachedPage) Monitor.newInstanceFromIdentifier(fid);
1: 
1: 		} 
1:         catch (StandardException se) 
1:         {
1:             if (se.getSeverity() > ExceptionSeverity.STATEMENT_SEVERITY)
1:             {
1:                 throw se;
1:             }
1:             else
1:             {
1:                 throw StandardException.newException(
0:                     SQLState.DATA_UNKNOWN_PAGE_FORMAT, se, newIdentity);
1:             }
1: 		}
1: 
1: 		realPage.setFactory(dataFactory);
1: 
1: 		// avoid creating the data buffer if possible, transfer it to the new 
1:         // page if this is the first time the page buffer is used, then 
1:         // createPage will create the page array with the correct page size
0: 		if (this.pageData != null) {
1: 			realPage.alreadyReadPage = true;
1: 			realPage.usePageBuffer(this.pageData);
1: 		}
1: 
1: 		// this page should not be used any more, null out all its content and
1: 		// wait for GC to clean it up  
1: 
0: 		//destroyPage();	// let this subtype have a chance to get rid of stuff
1: 		//this.pageData = null;	// this instance no longer own the data array
1: 		//this.pageCache = null;
1: 		//this.dataFactory = null;
1: 		//this.containerCache = null;
1: 
1: 		return realPage;
1: 	}
1: 
1: 	/**
0: 		Has the page or its header been modified or about to be modified.
0: 		See comment on class header on meaning of isDirty and preDirty bits.
1: 
0: 		@see Cacheable#isDirty
1: 	*/
0: 	public boolean isDirty() {
1: 
0: 		synchronized (this) {
1: 			return isDirty || preDirty;
1: 		}
1: 	}
1: 
1: 	/**
0: 		Has the page or its header been modified.
0: 		See comment on class header on meaning of isDirty and preDirty bits.
1: 	*/
0: 	public boolean isActuallyDirty() {
1: 
0: 		synchronized (this) {
1: 			return isDirty;
1: 		}
1: 		
1: 	}
1: 
1: 	/**
0: 		The page or its header is about to be modified.
0: 		See comment on class header on meaning of isDirty and preDirty bits.
1: 	*/
1: 	public void preDirty()
1: 	{
0: 		synchronized (this) {
1: 			if (!isDirty)
1: 				preDirty = true;
1: 		}
1: 	}
1: 
1: 	/**
0: 		Ensure that container row count is updated if it is too out of sync
1: 	 */
1: 	protected void releaseExclusive()
1: 	{
0: 		// look at dirty bit without latching
1: 		// if this page actually has > 1/8 rows of the entire container, then
0: 		// consider updating the row count if it is different
0: 		// Since allocation page has recordCount of zero, the if clause will
0: 		// never be true for an allocation page.
1: 		if (isDirty && !isOverflowPage() &&
1: 			(containerRowCount / 8) < recordCount())
1: 		{
1: 			int currentRowCount = internalNonDeletedRecordCount();	
0: 			int delta = currentRowCount-initialRowCount;
0: 			int posDelta = delta > 0 ? delta : (-delta);
1: 			if ((containerRowCount/8) < posDelta)
1: 			{
0: 				// we are actually doing quite a bit of change, 
0: 				// update container row count
1: 				FileContainer myContainer = null;
1: 
1: 				try
1: 				{
0: 					myContainer = (FileContainer) containerCache.find(identity.getContainerId());
1: 					if (myContainer != null)
1: 					{
1: 						myContainer.updateEstimatedRowCount(delta);
1: 						setContainerRowCount(myContainer.getEstimatedRowCount(0));
1: 						initialRowCount = currentRowCount;
1: 
1: 						// since I have the container, might as well update the
1: 						// unfilled information
0: 						myContainer.trackUnfilledPage(identity.getPageNumber(),
0: 													  unfilled());
1: 					}
1: 				}
1: 				catch(StandardException se)
1: 				{
0: 					// do nothing
1: 				}
1: 				finally
1: 				{
1: 					if (myContainer != null)
1: 						containerCache.release(myContainer);
1: 				}
1: 
1: 			}
1: 		}
1: 
1: 		super.releaseExclusive();
1: 	}
1: 
0: 	protected void setDirty() {
0: 		synchronized (this) {
0: 			isDirty = true;
0: 			preDirty = false;
1: 		}
1: 	}
1: 
1: 
1: 	/**
0: 		Write the page to disk.
1: 
0: 		@exception StandardException  Error writing the page,
1: 
0: 		@see Cacheable#clean
1: 	*/
1: 
1:     /**
1:      * Write the page to disk.
1:      * <p>
1:      * MP - In a simple world we would just not allow clean until it held the
1:      *      latch on the page.  But in order to fit into the cache system, we 
1:      *      don't have enough state around to just make clean() latch the page 
1:      *      while doing the I/O - but we still need someway to insure that no
1:      *      changes happen to the page while the I/O is taking place.  
1:      *      Also someday it would be fine to allow reads of this page
1:      *      while the I/O was taking place.  
1:      *
0:      *      So first 
1:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
1:      *
1: 	 * @exception  StandardException  Error writing the page.
1:      *
1:      * @see Cacheable#clean
1:      **/
0: 	public void clean(boolean remove) throws StandardException {
1: 
1: 		// must wait for the page to be unlatched
0: 		synchronized (this) {
1: 
1: 			if (!isDirty())
1: 				return;
1: 
1: 			// is someone else cleaning it
0: 			while (inClean) {
0: 				try {
1: 					wait();
0: 				} catch (InterruptedException ie) {
0: 					throw StandardException.interrupt(ie);
1: 				}
1: 			}
1: 
1: 			if (!isDirty())
1: 				return;
1: 
1: 			inClean = true;
1: 
1: 			// If page is in LATCHED state (as opposed to UNLATCH or PRELATCH)
1:             // wait for the page to move to UNLATCHED state.  See Comments in
1:             // Generic/BasePage.java describing the interaction of inClean,
1:             // (owner != null), and preLatch.
1: 			while ((owner != null) && !preLatch) 
1:             {
0: 				try {
1: 						wait();
0: 				} catch (InterruptedException ie) 
1: 				{
1: 					inClean = false;
0: 					throw StandardException.interrupt(ie);
1: 				}
1: 			}
1: 
1: 			// The page is now effectively latched by the cleaner.
1: 			// We only want to clean the page if the page is actually dirtied,
1: 			// not when it is just pre-dirtied.
0: 			if (!isActuallyDirty()) {
0: 				preDirty = false; // the person who latched it gives up the
0: 								  // latch without really dirtying the page
1: 				inClean = false;
1: 				notifyAll();
1: 				return;
1: 			}
1: 		}
1: 
1: 		try
1: 		{
1: 			writePage(getPageId(), false);
1: 		}
1: 		catch(StandardException se)
1: 		{
1: 			throw dataFactory.markCorrupt(se);
1: 		}
1: 		finally
1: 		{
0: 			// if there is something wrong in writing out the page, do not leave
0: 			// it inClean state or it will block the next cleaner forever
1: 
0: 			synchronized (this) {
1: 
1: 				inClean = false;
1: 				notifyAll();
1: 			}
1: 		}
1: 	}
1: 
0: 	public void clearIdentity() {
1: 		alreadyReadPage = false;
1: 		super.clearIdentity();
1: 	}
1: 
0: 	private void readPage(FileContainer myContainer, PageKey newIdentity) throws StandardException 
1: 	{
1: 		int pagesize = myContainer.getPageSize();
1: 		setPageArray(pagesize);
1: 
0: 		for(int i=0;;){
0: 			try {
1: 
1: 				myContainer.readPage(newIdentity.getPageNumber(), pageData);
1: 				break;
1: 
0: 			} catch (IOException ioe) {
0: 				i++;	
1: 
1: 								
0: 				// we try to read four times because there might have been
0: 				// thread interrupts when we tried to read the data.
0: 				if(i>4){
1: 			
1: 					// page cannot be physically read
1: 	
1: 					StandardException se = 
0: 						StandardException.newException(
1: 								   SQLState.FILE_READ_PAGE_EXCEPTION, 
0: 								   ioe, newIdentity, new Integer(pagesize));
1: 
0: 					//if we are in rollforward recovery, it is possible that
0: 					//this page actually does not exist on the disk yet because
0: 					//the log record we are proccessing now is actually create page,
0: 					//we will recreate the page if we are in rollforward
0: 					//recovery, so just throw the exception.
1: 						
0: 				   if(dataFactory.getLogFactory().inRFR())
1: 					   throw se;
1: 
1: 					if (SanityManager.DEBUG)
1:                     {
1:                             throw dataFactory.markCorrupt(se);
1: 					}
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 
0: 	private void writePage(PageKey identity, boolean syncMe) 
1: 		 throws StandardException 
1: 	{
1: 
0: 		writeFormatId(identity); // make subclass write the page format
1: 
0: 		writePage(identity);	// let subclass have a chance to write any cached
0: 								// data to page data array
1: 
1: 		// force WAL - and check to see if database is corrupt or is frozen.
1: 		// last log Instant may be null if the page is being forced
1: 		// to disk on a createPage (which violates the WAL protocol actually).
1: 		// See FileContainer.newPage
1: 		LogInstant flushLogTo = getLastLogInstant();
1: 		dataFactory.flush(flushLogTo);
1: 
0: 		if (flushLogTo != null) {					
1: 			clearLastLogInstant();
1: 		}
1: 
1: 
1: 		// find the container and file access object
0: 		FileContainer myContainer = (FileContainer) containerCache.find(identity.getContainerId());
1: 
0: 		if (myContainer != null) {
0: 			try {
1: 
0: 				myContainer.writePage(identity.getPageNumber(), pageData, syncMe);
1: 
0: 				//
0: 				// Do some in memory unlogged bookkeeping tasks while we have
0: 				// the container. 
0: 				//
1: 
0: 				if (!isOverflowPage() && isDirty())
1: 				{
1: 
0: 					// let the container knows whether this page is a not filled,
0: 					// non-overflow page
0: 					myContainer.trackUnfilledPage(identity.getPageNumber(),
0: 												  unfilled());
1: 
0: 					// if this is not an overflow page, see if the page's row
0: 					// count has changed since it come into the cache.
0: 					//
0: 					// if the page is not invalid, row count is 0.  Otherwise,
0: 					// count non-deleted records on page.
0: 					//
0: 					// Cannot call nonDeletedRecordCount because the page is
0: 					// unlatched now even though nobody is changing it
1: 					int currentRowCount = internalNonDeletedRecordCount();
1: 
0: 					if (currentRowCount != initialRowCount)
1: 					{
0: 						myContainer.updateEstimatedRowCount(currentRowCount-initialRowCount);
1: 						setContainerRowCount(myContainer.getEstimatedRowCount(0));
1: 						initialRowCount = currentRowCount;
1: 					}
1: 				}
1: 
0: 			} catch (IOException ioe) {
0: 				// page cannot be written
1: 				throw StandardException.newException(
0:                     SQLState.FILE_WRITE_PAGE_EXCEPTION, 
0:                     ioe, identity, new Integer(myContainer.getPageSize()));
1: 			}
1: 			finally
1: 			{
1: 				containerCache.release(myContainer);
1: 				myContainer = null;
1: 			}
1: 		} 
1: 		else
1: 		{
0: 			StandardException nested = StandardException.newException(SQLState.DATA_CONTAINER_VANISHED, identity.getContainerId());
1: 			throw dataFactory.markCorrupt(
0:                 StandardException.newException(
0:                     SQLState.FILE_WRITE_PAGE_EXCEPTION, nested, 
0:                     identity, new Integer(myContainer.getPageSize())));
1: 		}
1: 
0: 		synchronized (this) {
0: 			isDirty = false;
0: 			preDirty = false;
1: 		}
1: 
1: 	}
1: 
1: 	public void setContainerRowCount(long rowCount)
1: 	{
1: 		containerRowCount = rowCount;
1: 	}
1: 
1: 
1: 
1: 	/*
1: 	** if the page size is different from the page buffer, then make a
1: 	** new page buffer and make subclass use the new page buffer
1: 	*/
1: 
0: 	protected void setPageArray(int pageSize) throws StandardException
1: 	{
0: 		if ((pageData == null) || (pageData.length != pageSize)) {
1: 			pageData = new byte[pageSize];
1: 
0: 			if (pageData == null || pageData.length != pageSize)
1:             {
1: 				throw StandardException.newException(
0:                         SQLState.DATA_OBJECT_ALLOCATION_FAILED, "PAGE");
1:             }
1: 				
0: 			usePageBuffer(pageData);
1: 		}
1: 	}
1: 
1: 	/* methods for subclass of cached page */
1: 
1: 	// use a new pageData buffer, initialize in memory structure that depend on
1: 	// the pageData's size.  The actual disk data may not have not been read in
1: 	// yet so don't look at the content of the buffer
1: 	protected abstract void usePageBuffer(byte[] buffer);
1: 
1: 
1: 	// initialize in memory structure using the read in buffer in pageData
0: 	protected abstract void initFromData(FileContainer container, PageKey id) throws StandardException;
1: 
1: 
1: 	// create the page
0: 	protected abstract void createPage(PageKey id, int[] args) throws StandardException;
1: 
1: 	// page is about to be written, write everything to pageData array
1: 	protected abstract void writePage(PageKey id) throws StandardException;		
1: 
1: 	// write out the formatId to the pageData
0: 	protected abstract void writeFormatId(PageKey identity) throws StandardException;
1: 
1: 
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param identity indentity (ie. page number) of the page to read
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.data;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.impl.store.raw.data.BasePage;
0: 
0: import org.apache.derby.iapi.store.raw.log.LogInstant;
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.PageKey;
0: 
0: import org.apache.derby.iapi.services.cache.Cacheable;
0: import org.apache.derby.iapi.services.cache.CacheManager;
0: import org.apache.derby.iapi.services.context.ContextService;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: import java.io.IOException;
0: 
0: /**
0: 	A base page that is cached.
0: 
0: 	Since there are multiple page formats, use this abstract class to implement
0: 	cacheable interface.
0: 
0: 
0: */
0: 
0: public abstract class CachedPage extends BasePage implements Cacheable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	protected boolean		alreadyReadPage;	// set to true when the page was read by another class
0: 
0: 	protected byte[]		pageData;		// the actual page data - this is
0: 											// the 'buffer' in the buffer cache
0: 
0: 	// The isDirty flag indicates if the pageData or pageHeader has been
0: 	// modified.  The preDirty flag indicates that the pageData or the
0: 	// pageHeader is about to be modified.  The reason for these 2 flags
0: 	// instead of just one is to accomodate checkpoint.  After a clean
0: 	// (latched) page sends a log record to the log stream but before that page
0: 	// is dirtied by the log operation, a checkpoint could be taken.  If so,
0: 	// then the redoLWM will be after the log record but, without preDirty, the
0: 	// cache cleaning will not have waited for the change.  So the preDirty bit
0: 	// is to stop the cache cleaning from skipping over this (latched) page
0: 	// even though it has not really been modified yet.  
0: 
0: 	protected boolean		isDirty;		// must be set to true
0: 								// whenever the pageData array is touched directly
0: 								// or indirectly.
0: 
0: 	protected boolean		preDirty;		// set to true if the page is clean
0: 								// and the pageData array is about to be
0: 								// touched directly or indirectly.
0: 
0: 
0: 	protected int		initialRowCount; // keep a running count of rows for
0: 										 // estimated row count.
0: 
0: 	private long 		containerRowCount;	// the number of rows in the
0: 											// container when this page is read
0: 											// from disk 
0: 
0: 	/*
0: 	** These fields are immutable and can be used by the subclasses directly.
0: 	*/
0: 
0: 	/**
0: 		The page cache I live in.
0: 
0: 		<BR> MT - Immutable
0: 	*/
0: 	protected CacheManager		pageCache;
0: 
0: 	/**
0: 		The container cache my container lives in.
0: 
0: 		<BR> MT - Immutable
0: 	*/
0: 	protected CacheManager		containerCache;
0: 
0: 	/**
0: 		My factory class.
0: 
0: 		<BR> MT - Immutable - 
0: 	*/
0: 	protected BaseDataFileFactory		dataFactory;  // my factory class.
0: 
0: 
0: 	protected static final int PAGE_FORMAT_ID_SIZE = 4;
0: 
0: 	/*
0: 	 * the page need to be written and synced to disk 
0: 	 */
0: 	public static final int WRITE_SYNC = 1;
0: 
0: 	/*
0: 	 * the page need to be write to disk but not synced
0: 	 */
0: 	public static final int WRITE_NO_SYNC = 2;
0: 
0: 	public CachedPage()
0: 	{
0: 		super();
0: 	}
0: 
0: 	public final void setFactory(BaseDataFileFactory factory) {
0: 		dataFactory = factory;
0: 		pageCache = factory.getPageCache();
0: 		containerCache = factory.getContainerCache();
0: 	}
0: 
0: 	/**
0: 		Initialize the object, ie. perform work normally perfomed in constructor.
0: 		Called by setIdentity() and createIdentity().
0: 	*/
0: 	protected void initialize()
0: 	{
0: 		super.initialize();
0: 		isDirty = false;
0: 		preDirty = false;
0: 		initialRowCount = 0;
0: 		containerRowCount = 0;
0: 	}
0: 
0: 	/*
0: 	** Methods of Cacheable
0: 	*/
0: 
0: 	/**
0: 		Find the container and then read the page from that container.
0: 
0: 		@return always true, higher levels have already checked the page number is
0: 		valid for an open.
0: 
0: 		@exception StandardException Standard Cloudscape policy.
0: 
0: 		@see Cacheable#setIdentity
0: 	*/
0: 	public Cacheable setIdentity(Object key) throws StandardException {
0: 
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(key instanceof PageKey);
0: 		}
0: 
0: 		initialize();
0: 
0: 		PageKey newIdentity = (PageKey) key;
0: 
0: 		FileContainer myContainer = 
0: 				(FileContainer) containerCache.find(newIdentity.getContainerId());
0: 		setContainerRowCount(myContainer.getEstimatedRowCount(0));
0: 
0: 		try
0: 		{
0: 			if (!alreadyReadPage)
0: 				readPage(myContainer, newIdentity);	// read in the pageData array from disk
0: 			else
0: 				alreadyReadPage = false;
0: 
0: 			// if the formatID on disk is not the same as this page instance's
0: 			// format id, instantiate the real page object
0: 			int fmtId = getTypeFormatId();
0: 
0: 			int onPageFormatId = FormatIdUtil.readFormatIdInteger(pageData);
0: 			if (fmtId != onPageFormatId)
0: 			{
0: 				return changeInstanceTo(onPageFormatId, newIdentity).setIdentity(key);
0: 			}
0: 
0: 			// this is the correct page instance
0: 			initFromData(myContainer, newIdentity);
0: 		}
0: 		finally
0: 		{
0: 			containerCache.release(myContainer);
0: 			myContainer = null;
0: 		}
0: 
0: 		fillInIdentity(newIdentity);
0: 
0: 		initialRowCount = 0;
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 		Find the container and then create the page in that container.
0: 
0: 		@return new page, higher levels have already checked the page number is
0: 		valid for an open.
0: 
0: 		@exception StandardException Standard Cloudscape policy.
0: 
0: 		@see Cacheable#createIdentity
0: 	*/
0: 	public Cacheable createIdentity(Object key, Object createParameter) throws StandardException {
0: 
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(key instanceof PageKey);
0: 		}
0: 
0: 		initialize();
0: 
0: 		PageKey newIdentity = (PageKey) key;
0: 
0: 		int[] createArgs = (int[]) createParameter;
0: 
0: 		if (createArgs[0] == -1)
0:         {
0: 			throw StandardException.newException(
0:                     SQLState.DATA_UNKNOWN_PAGE_FORMAT, newIdentity);
0:         }
0: 
0: 		// createArgs[0] contains the interger form of the formatId 
0: 		// if it is not the same as this instance's formatId, instantiate the
0: 		// real page object
0: 		if (createArgs[0] != getTypeFormatId())
0: 		{
0: 			return changeInstanceTo(createArgs[0], newIdentity).createIdentity(key, createParameter);
0: 		}
0: 		
0: 		// this is the correct page instance
0: 		initializeHeaders(5);
0: 		createPage(newIdentity, createArgs);
0: 
0: 		fillInIdentity(newIdentity);
0: 
0: 		initialRowCount = 0;
0: 
0: 		/*
0: 		 * if we need to grow the container and the page has not been
0: 		 * preallocated , writing page before the log is written so that we
0: 		 * know if there is an IO error - like running out of disk space - then
0: 		 * we don't write out the log record, because if we do, it may fail
0: 		 * after the log goes to disk and then the database may not be
0: 		 * recoverable. 
0: 		 *
0: 		 * WRITE_SYNC is used when we create the page without first
0: 		 *	preallocating it 
0: 		 * WRITE_NO_SYNC is used when we are preallocating the page - there
0: 		 *	will be a SYNC call after all the pages are preallocated
0: 		 * 0 means creating a page that has already been preallocated.
0: 		 */
0: 		if ((createArgs[1] & WRITE_SYNC) != 0 ||
0: 			(createArgs[1] & WRITE_NO_SYNC) != 0)
0: 			writePage(newIdentity, (createArgs[1] & WRITE_SYNC) != 0);
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
0: 			{
0: 				String syncFlag = ((createArgs[1] & WRITE_SYNC) != 0) ? "Write_Sync" :
0: 					(((createArgs[1] & WRITE_NO_SYNC) != 0) ? "Write_NO_Sync" : 
0: 					 "No_write");
0: 				SanityManager.DEBUG(FileContainer.SPACE_TRACE,
0: 									"creating new page " + newIdentity + 
0: 									" with " + syncFlag);
0: 			}
0: 		}
0: 
0: 		return this;
0: 	}
0: 
0: 	/*
0: 	 * this object is instantiated to the wrong subtype of cachedPage, 
0: 	 * this routine will create an object with the correct subtype, transfer all 
0: 	 * pertinent information from this to the new correct object.
0: 	 */
0: 	private CachedPage changeInstanceTo(int fid, PageKey newIdentity)
0: 		 throws StandardException
0: 	{
0: 		CachedPage realPage;
0: 		try 
0:         {
0: 			realPage = 
0:                 (CachedPage) Monitor.newInstanceFromIdentifier(fid);
0: 
0: 		} 
0:         catch (StandardException se) 
0:         {
0:             if (se.getSeverity() > ExceptionSeverity.STATEMENT_SEVERITY)
0:             {
0:                 throw se;
0:             }
0:             else
0:             {
0:                 throw StandardException.newException(
0:                     SQLState.DATA_UNKNOWN_PAGE_FORMAT, se, newIdentity);
0:             }
0: 		}
0: 
0: 		realPage.setFactory(dataFactory);
0: 
0: 		// avoid creating the data buffer if possible, transfer it to the new 
0:         // page if this is the first time the page buffer is used, then 
0:         // createPage will create the page array with the correct page size
0: 		if (this.pageData != null) {
0: 			realPage.alreadyReadPage = true;
0: 			realPage.usePageBuffer(this.pageData);
0: 		}
0: 
0: 		// this page should not be used any more, null out all its content and
0: 		// wait for GC to clean it up  
0: 
0: 		//destroyPage();	// let this subtype have a chance to get rid of stuff
0: 		//this.pageData = null;	// this instance no longer own the data array
0: 		//this.pageCache = null;
0: 		//this.dataFactory = null;
0: 		//this.containerCache = null;
0: 
0: 		return realPage;
0: 	}
0: 
0: 	/**
0: 		Has the page or its header been modified or about to be modified.
0: 		See comment on class header on meaning of isDirty and preDirty bits.
0: 
0: 		@see Cacheable#isDirty
0: 	*/
0: 	public boolean isDirty() {
0: 
0: 		synchronized (this) {
0: 			return isDirty || preDirty;
0: 		}
0: 	}
0: 
0: 	/**
0: 		Has the page or its header been modified.
0: 		See comment on class header on meaning of isDirty and preDirty bits.
0: 	*/
0: 	public boolean isActuallyDirty() {
0: 
0: 		synchronized (this) {
0: 			return isDirty;
0: 		}
0: 		
0: 	}
0: 
0: 	/**
0: 		The page or its header is about to be modified.
0: 		See comment on class header on meaning of isDirty and preDirty bits.
0: 	*/
0: 	public void preDirty()
0: 	{
0: 		synchronized (this) {
0: 			if (!isDirty)
0: 				preDirty = true;
0: 		}
0: 	}
0: 
0: 	/**
0: 		Ensure that container row count is updated if it is too out of sync
0: 	 */
0: 	protected void releaseExclusive()
0: 	{
0: 		// look at dirty bit without latching
0: 		// if this page actually has > 1/8 rows of the entire container, then
0: 		// consider updating the row count if it is different
0: 		// Since allocation page has recordCount of zero, the if clause will
0: 		// never be true for an allocation page.
0: 		if (isDirty && !isOverflowPage() &&
0: 			(containerRowCount / 8) < recordCount())
0: 		{
0: 			int currentRowCount = internalNonDeletedRecordCount();	
0: 			int delta = currentRowCount-initialRowCount;
0: 			int posDelta = delta > 0 ? delta : (-delta);
0: 			if ((containerRowCount/8) < posDelta)
0: 			{
0: 				// we are actually doing quite a bit of change, 
0: 				// update container row count
0: 				FileContainer myContainer = null;
0: 
0: 				try
0: 				{
0: 					myContainer = (FileContainer) containerCache.find(identity.getContainerId());
0: 					if (myContainer != null)
0: 					{
0: 						myContainer.updateEstimatedRowCount(delta);
0: 						setContainerRowCount(myContainer.getEstimatedRowCount(0));
0: 						initialRowCount = currentRowCount;
0: 
0: 						// since I have the container, might as well update the
0: 						// unfilled information
0: 						myContainer.trackUnfilledPage(identity.getPageNumber(),
0: 													  unfilled());
0: 					}
0: 				}
0: 				catch(StandardException se)
0: 				{
0: 					// do nothing
0: 				}
0: 				finally
0: 				{
0: 					if (myContainer != null)
0: 						containerCache.release(myContainer);
0: 				}
0: 
0: 			}
0: 		}
0: 
0: 		super.releaseExclusive();
0: 	}
0: 
0: 	protected void setDirty() {
0: 		synchronized (this) {
0: 			isDirty = true;
0: 			preDirty = false;
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 		Write the page to disk.
0: 
0: 		@exception StandardException  Error writing the page,
0: 
0: 		@see Cacheable#clean
0: 	*/
0: 
0:     /**
0:      * Write the page to disk.
0:      * <p>
0:      * MP - In a simple world we would just not allow clean until it held the
0:      *      latch on the page.  But in order to fit into the cache system, we 
0:      *      don't have enough state around to just make clean() latch the page 
0:      *      while doing the I/O - but we still need someway to insure that no
0:      *      changes happen to the page while the I/O is taking place.  
0:      *      Also someday it would be fine to allow reads of this page
0:      *      while the I/O was taking place.  
0:      *
0:      *      So first 
0:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
0:      *
0: 	 * @exception  StandardException  Error writing the page.
0:      *
0:      * @see Cacheable#clean
0:      **/
0: 	public void clean(boolean remove) throws StandardException {
0: 
0: 		// must wait for the page to be unlatched
0: 		synchronized (this) {
0: 
0: 			if (!isDirty())
0: 				return;
0: 
0: 			// is someone else cleaning it
0: 			while (inClean) {
0: 				try {
0: 					wait();
0: 				} catch (InterruptedException ie) {
0: 					throw StandardException.interrupt(ie);
0: 				}
0: 			}
0: 
0: 			if (!isDirty())
0: 				return;
0: 
0: 			inClean = true;
0: 
0: 			// If page is in LATCHED state (as opposed to UNLATCH or PRELATCH)
0:             // wait for the page to move to UNLATCHED state.  See Comments in
0:             // Generic/BasePage.java describing the interaction of inClean,
0:             // (owner != null), and preLatch.
0: 			while ((owner != null) && !preLatch) 
0:             {
0: 				try {
0: 						wait();
0: 				} catch (InterruptedException ie) 
0: 				{
0: 					inClean = false;
0: 					throw StandardException.interrupt(ie);
0: 				}
0: 			}
0: 
0: 			// The page is now effectively latched by the cleaner.
0: 			// We only want to clean the page if the page is actually dirtied,
0: 			// not when it is just pre-dirtied.
0: 			if (!isActuallyDirty()) {
0: 				preDirty = false; // the person who latched it gives up the
0: 								  // latch without really dirtying the page
0: 				inClean = false;
0: 				notifyAll();
0: 				return;
0: 			}
0: 		}
0: 
0: 		try
0: 		{
0: 			writePage(getPageId(), false);
0: 		}
0: 		catch(StandardException se)
0: 		{
0: 			throw dataFactory.markCorrupt(se);
0: 		}
0: 		finally
0: 		{
0: 			// if there is something wrong in writing out the page, do not leave
0: 			// it inClean state or it will block the next cleaner forever
0: 
0: 			synchronized (this) {
0: 
0: 				inClean = false;
0: 				notifyAll();
0: 			}
0: 		}
0: 	}
0: 
0: 	public void clearIdentity() {
0: 		alreadyReadPage = false;
0: 		super.clearIdentity();
0: 	}
0: 
0: 	private void readPage(FileContainer myContainer, PageKey newIdentity) throws StandardException 
0: 	{
0: 		int pagesize = myContainer.getPageSize();
0: 		setPageArray(pagesize);
0: 
0: 		for(int i=0;;){
0: 			try {
0: 
0: 				myContainer.readPage(newIdentity.getPageNumber(), pageData);
0: 				break;
0: 
0: 			} catch (IOException ioe) {
0: 				i++;	
0: 
0: 								
0: 				// we try to read four times because there might have been
0: 				// thread interrupts when we tried to read the data.
0: 				if(i>4){
0: 			
0: 					// page cannot be physically read
0: 	
0: 					StandardException se = 
0: 						StandardException.newException(
0: 								   SQLState.FILE_READ_PAGE_EXCEPTION, 
0: 								   ioe, newIdentity, new Integer(pagesize));
0: 
0: 					//if we are in rollforward recovery, it is possible that
0: 					//this page actually does not exist on the disk yet because
0: 					//the log record we are proccessing now is actually create page,
0: 					//we will recreate the page if we are in rollforward
0: 					//recovery, so just throw the exception.
0: 						
0: 				   if(dataFactory.getLogFactory().inRFR())
0: 					   throw se;
0: 
0: 					if (SanityManager.DEBUG)
0:                     {
0:                             throw dataFactory.markCorrupt(se);
0: 					}
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 
0: 	private void writePage(PageKey identity, boolean syncMe) 
0: 		 throws StandardException 
0: 	{
0: 
0: 		writeFormatId(identity); // make subclass write the page format
0: 
0: 		writePage(identity);	// let subclass have a chance to write any cached
0: 								// data to page data array
0: 
0: 		// force WAL - and check to see if database is corrupt or is frozen.
0: 		// last log Instant may be null if the page is being forced
0: 		// to disk on a createPage (which violates the WAL protocol actually).
0: 		// See FileContainer.newPage
0: 		LogInstant flushLogTo = getLastLogInstant();
0: 		dataFactory.flush(flushLogTo);
0: 
0: 		if (flushLogTo != null) {					
0: 			clearLastLogInstant();
0: 		}
0: 
0: 
0: 		// find the container and file access object
0: 		FileContainer myContainer = (FileContainer) containerCache.find(identity.getContainerId());
0: 
0: 		if (myContainer != null) {
0: 			try {
0: 
0: 				myContainer.writePage(identity.getPageNumber(), pageData, syncMe);
0: 
0: 				//
0: 				// Do some in memory unlogged bookkeeping tasks while we have
0: 				// the container. 
0: 				//
0: 
0: 				if (!isOverflowPage() && isDirty())
0: 				{
0: 
0: 					// let the container knows whether this page is a not filled,
0: 					// non-overflow page
0: 					myContainer.trackUnfilledPage(identity.getPageNumber(),
0: 												  unfilled());
0: 
0: 					// if this is not an overflow page, see if the page's row
0: 					// count has changed since it come into the cache.
0: 					//
0: 					// if the page is not invalid, row count is 0.  Otherwise,
0: 					// count non-deleted records on page.
0: 					//
0: 					// Cannot call nonDeletedRecordCount because the page is
0: 					// unlatched now even though nobody is changing it
0: 					int currentRowCount = internalNonDeletedRecordCount();
0: 
0: 					if (currentRowCount != initialRowCount)
0: 					{
0: 						myContainer.updateEstimatedRowCount(currentRowCount-initialRowCount);
0: 						setContainerRowCount(myContainer.getEstimatedRowCount(0));
0: 						initialRowCount = currentRowCount;
0: 					}
0: 				}
0: 
0: 			} catch (IOException ioe) {
0: 				// page cannot be written
0: 				throw StandardException.newException(
0:                     SQLState.FILE_WRITE_PAGE_EXCEPTION, 
0:                     ioe, identity, new Integer(myContainer.getPageSize()));
0: 			}
0: 			finally
0: 			{
0: 				containerCache.release(myContainer);
0: 				myContainer = null;
0: 			}
0: 		} 
0: 		else
0: 		{
0: 			StandardException nested = StandardException.newException(SQLState.DATA_CONTAINER_VANISHED, identity.getContainerId());
0: 			throw dataFactory.markCorrupt(
0:                 StandardException.newException(
0:                     SQLState.FILE_WRITE_PAGE_EXCEPTION, nested, 
0:                     identity, new Integer(myContainer.getPageSize())));
0: 		}
0: 
0: 		synchronized (this) {
0: 			isDirty = false;
0: 			preDirty = false;
0: 		}
0: 
0: 	}
0: 
0: 	public void setContainerRowCount(long rowCount)
0: 	{
0: 		containerRowCount = rowCount;
0: 	}
0: 
0: 
0: 
0: 	/*
0: 	** if the page size is different from the page buffer, then make a
0: 	** new page buffer and make subclass use the new page buffer
0: 	*/
0: 
0: 	protected void setPageArray(int pageSize) throws StandardException
0: 	{
0: 		if ((pageData == null) || (pageData.length != pageSize)) {
0: 			pageData = new byte[pageSize];
0: 
0: 			if (pageData == null || pageData.length != pageSize)
0:             {
0: 				throw StandardException.newException(
0:                         SQLState.DATA_OBJECT_ALLOCATION_FAILED, "PAGE");
0:             }
0: 				
0: 			usePageBuffer(pageData);
0: 		}
0: 	}
0: 
0: 	/* methods for subclass of cached page */
0: 
0: 	// use a new pageData buffer, initialize in memory structure that depend on
0: 	// the pageData's size.  The actual disk data may not have not been read in
0: 	// yet so don't look at the content of the buffer
0: 	protected abstract void usePageBuffer(byte[] buffer);
0: 
0: 
0: 	// initialize in memory structure using the read in buffer in pageData
0: 	protected abstract void initFromData(FileContainer container, PageKey id) throws StandardException;
0: 
0: 
0: 	// create the page
0: 	protected abstract void createPage(PageKey id, int[] args) throws StandardException;
0: 
0: 	// page is about to be written, write everything to pageData array
0: 	protected abstract void writePage(PageKey id) throws StandardException;		
0: 
0: 	// write out the formatId to the pageData
0: 	protected abstract void writeFormatId(PageKey identity) throws StandardException;
0: 
0: 
0: }
============================================================================