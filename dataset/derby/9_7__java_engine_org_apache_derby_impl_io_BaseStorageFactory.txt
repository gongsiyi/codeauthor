1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.io.BaseStorageFactory
1:345de35: 
1:2724c48:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2724c48:    contributor license agreements.  See the NOTICE file distributed with
1:2724c48:    this work for additional information regarding copyright ownership.
1:2724c48:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2724c48:    (the "License"); you may not use this file except in compliance with
1:2724c48:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
3:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.io;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.data.DataFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.io.StorageFactory;
1:eac0369: import org.apache.derby.io.StorageFile;
1:eac0369: 
1:eac0369: import java.io.File;
1:eac0369: import java.io.IOException;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * This class provides a base for implementations of the StorageFactory interface. It is used by the
1:eac0369:  * database engine to access persistent data and transaction logs under the directory (default) subsubprotocol.
1:eac0369:  */
1:eac0369: 
1:eac0369: abstract class BaseStorageFactory implements StorageFactory
1:eac0369: {
1:eac0369: 
1:eac0369:     String home;
1:eac0369:     protected StorageFile tempDir;
1:eac0369:     protected String tempDirPath;
1:eac0369:     protected String dataDirectory;
1:eac0369:     protected String separatedDataDirectory; // dataDirectory + separator
1:eac0369:     protected String uniqueName;
1:eac0369:     protected String canonicalName;
1:eac0369:     private static final String TEMP_DIR_PREFIX = "derbytmp_";
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Most of the initialization is done in the init method.
1:eac0369:      */
1:eac0369:     BaseStorageFactory()
1:eac0369:     {}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Classes implementing the StorageFactory interface must have a null
1:eac0369:      * constructor.  This method is called when the database is booted up to
1:eac0369:      * initialize the class. It should perform all actions necessary to start the
1:eac0369:      * basic storage, such as creating a temporary file directory.
1:eac0369:      *
1:eac0369:      * The init method will be called once, before any other method is called, and will not
1:eac0369:      * be called again.
1:eac0369:      *
1:eac0369:      * @param home The name of the directory containing the database. It comes from the system.home system property.
1:eac0369:      *             It may be null. A storage factory may decide to ignore this parameter. (For instance the classpath
1:eac0369:      *             storage factory ignores it.
1:eac0369:      * @param databaseName The name of the database (directory). All relative pathnames are relative to this directory.
1:eac0369:      *                     If null then the storage factory will only be used to deal with the directory containing
1:eac0369:      *                     the databases.
1:eac0369:      * @param tempDirName The name of the temporary file directory set in properties. If null then a default
1:eac0369:      *                    directory should be used. Each database should get a separate temporary file
1:eac0369:      *                    directory within this one to avoid collisions.
1:eac0369:      * @param uniqueName A unique name that can be used to create the temporary file directory for this database.
1:eac0369:      *
1:eac0369:      * @exception IOException on an error (unexpected).
1:eac0369:      */
1:eac0369:     public void init( String home, String databaseName, String tempDirName, String uniqueName)
1:eac0369:         throws IOException
1:eac0369:     {
1:eac0369:         if( databaseName != null)
1:eac0369:         {
1:eac0369:             dataDirectory = databaseName;
1:eac0369:             separatedDataDirectory = databaseName + getSeparator();
2:eac0369:         }
1:eac0369:         this.home = home;
1:eac0369:         this.uniqueName = uniqueName;
1:eac0369:         tempDirPath = tempDirName;
1:eac0369:         doInit();
1:eac0369:     } // end of init
1:eac0369: 
1:eac0369:     abstract void doInit() throws IOException;
1:eac0369:     
1:eac0369:     public void shutdown()
1:eac0369:     {
1:eac0369:     }
1:eac0369:     
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the canonical name of the database. This is a name that uniquely identifies it. It is system dependent.
1:eac0369:      *
1:eac0369:      * The normal, disk based implementation uses method java.io.File.getCanonicalPath on the directory holding the
1:eac0369:      * database to construct the canonical name.
1:eac0369:      *
1:eac0369:      * @return the canonical name
1:eac0369:      *
1:eac0369:      * @exception IOException if an IO error occurred during the construction of the name.
1:eac0369:      */
1:eac0369:     public String getCanonicalName() throws IOException
1:eac0369:     {
1:eac0369:         return canonicalName;
1:eac0369:     }
1:eac0369:     
1:eac0369:     /**
1:0e00e5e:      * Set the canonicalName. May need adjustment due to DERBY-5096
1:0e00e5e:      * 
1:0e00e5e:      * @param name uniquely identifiable name for this database
1:0e00e5e:      */
1:0e00e5e:     public void setCanonicalName(String name) {
1:0e00e5e:        canonicalName = name;
1:0e00e5e:     }
1:0e00e5e:     
1:0e00e5e:     /**
1:eac0369:      * Construct a StorageFile from a path name.
1:eac0369:      *
1:eac0369:      * @param path The path name of the file
1:eac0369:      *
1:eac0369:      * @return A corresponding StorageFile object
1:eac0369:      */
1:eac0369:     public StorageFile newStorageFile( String path)
1:eac0369:     {
1:eac0369:         if( path != null && tempDirPath != null && path.startsWith( tempDirPath))
1:eac0369:             return new DirFile( path);
1:eac0369:         return newPersistentFile( path);
1:eac0369:     }
1:eac0369:     
1:eac0369:     /**
1:eac0369:      * Construct a StorageFile from a directory and file name.
1:eac0369:      *
1:eac0369:      * @param directoryName The directory part of the path name.
1:eac0369:      * @param fileName The name of the file within the directory.
1:eac0369:      *
1:eac0369:      * @return A corresponding StorageFile object
1:eac0369:      */
1:eac0369:     public StorageFile newStorageFile( String directoryName, String fileName)
1:eac0369:     {
1:eac0369:         if( directoryName == null)
1:eac0369:             return newStorageFile( fileName);
1:eac0369:         else if( tempDirPath != null && directoryName.startsWith( tempDirPath))
1:eac0369:             return new DirFile(directoryName, fileName);
1:eac0369:         else
1:eac0369:             return newPersistentFile( directoryName, fileName);
1:eac0369:     }
1:eac0369:     
1:eac0369:     /**
1:eac0369:      * Construct a StorageFile from a directory and file name.
1:eac0369:      *
1:eac0369:      * @param directoryName The directory part of the path name.
1:eac0369:      * @param fileName The name of the file within the directory.
1:eac0369:      *
1:eac0369:      * @return A corresponding StorageFile object
1:eac0369:      */
1:eac0369:     public StorageFile newStorageFile( StorageFile directoryName, String fileName)
1:eac0369:     {
1:eac0369:         if( directoryName == null)
1:eac0369:             return newStorageFile( fileName);
1:eac0369:         if( fileName == null)
1:eac0369:             return directoryName;
1:eac0369:         else if (tempDirPath != null && directoryName.getPath().startsWith(tempDirPath))
1:eac0369:             return new DirFile( (DirFile) directoryName, fileName);
1:eac0369:         return newPersistentFile( directoryName, fileName);
1:eac0369:     }
1:eac0369:     
1:eac0369:     /**
1:eac0369:      * Construct a persistent StorageFile from a path name.
1:eac0369:      *
1:eac0369:      * @param path The path name of the file. Guaranteed not to be in the temporary file directory. If null
1:eac0369:      *             then the database directory should be returned.
1:eac0369:      *
1:eac0369:      * @return A corresponding StorageFile object
1:eac0369:      */
1:eac0369:     abstract StorageFile newPersistentFile( String path);
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Construct a persistent StorageFile from a directory and path name.
1:eac0369:      *
1:6b50965:      * @param directoryName The path name of the directory. Guaranteed not to be in the temporary file directory.
1:eac0369:      *                  Guaranteed not to be null
1:eac0369:      * @param fileName The name of the file within the directory. Guaranteed not to be null.
1:eac0369:      *
1:eac0369:      * @return A corresponding StorageFile object
1:eac0369:      */
1:eac0369:     abstract StorageFile newPersistentFile( String directoryName, String fileName);
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Construct a persistent StorageFile from a directory and path name.
1:eac0369:      *
1:6b50965:      * @param directoryName The path name of the directory. Guaranteed not to be to be null. Guaranteed to be
1:eac0369:      *                  created by a call to one of the newPersistentFile methods.
1:eac0369:      * @param fileName The name of the file within the directory. Guaranteed not to be null.
1:eac0369:      *
1:eac0369:      * @return A corresponding StorageFile object
1:eac0369:      */
1:eac0369:     abstract StorageFile newPersistentFile( StorageFile directoryName, String fileName);
1:eac0369:     
1:eac0369:     /**
1:eac0369:      * Get the pathname separator character used by the StorageFile implementation.
1:eac0369:      *
1:eac0369:      * @return the pathname separator character. (Normally '/' or '\').
1:eac0369:      */
1:eac0369:     public char getSeparator()
1:eac0369:     {
1:eac0369:         // Temp files are always java.io.File's and use its separator.
1:eac0369:         return File.separatorChar;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the abstract name of the directory that holds temporary files.
1:eac0369:      *
1:eac0369:      * @return a directory name
1:eac0369:      */
1:eac0369:     public StorageFile getTempDir()
1:eac0369:     {
1:eac0369:         return tempDir;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * This method is used to determine whether the storage is fast (RAM based) or slow (disk based).
1:eac0369:      * It may be used by the database engine to determine the default size of the page cache.
1:eac0369:      *
1:eac0369:      * @return <b>true</b> if the storage is fast, <b>false</b> if it is slow.
1:eac0369:      */
1:eac0369:     public boolean isFast()
1:eac0369:     {
1:eac0369:         return false;
1:eac0369:     }
1:eac0369: 
1:eac0369:     public boolean isReadOnlyDatabase()
1:eac0369:     {
1:eac0369:         return true;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Determine whether the storage supports random access. If random access is not supported then
1:eac0369:      * it will only be accessed using InputStreams and OutputStreams (if the database is writable).
1:eac0369:      *
1:eac0369:      * @return <b>true</b> if the storage supports random access, <b>false</b> if it is writable.
1:eac0369:      */
1:eac0369:     public boolean supportsRandomAccess()
1:eac0369:     {
1:eac0369:         return false;
1:eac0369:     }
1:eac0369: 
1:eac0369:     void createTempDir() throws java.io.IOException
1:eac0369:     {
1:eac0369:         if( uniqueName == null)
1:eac0369:             return;
1:eac0369: 
1:eac0369:         if( tempDirPath != null)
1:eac0369:             tempDir = new DirFile( tempDirPath, TEMP_DIR_PREFIX.concat(uniqueName));
1:eac0369:         else if( isReadOnlyDatabase())
1:eac0369:             tempDir = new DirFile( readOnlyTempRoot(), TEMP_DIR_PREFIX.concat(uniqueName));
1:eac0369:         else
1:eac0369:             tempDir = new DirFile( canonicalName, DataFactory.TEMP_SEGMENT_NAME);
1:eac0369:             
1:eac0369:         // blow away any temporary directory
1:eac0369:         tempDir.deleteAll();
1:eac0369: 
1:eac0369:         tempDir.mkdirs();
1:dc43cf8:         tempDir.limitAccessToOwner();
1:eac0369:         tempDirPath = tempDir.getPath();
1:eac0369:     } // end of createTempDir
1:eac0369: 
1:eac0369: 	private String readOnlyTempRoot() throws java.io.IOException
1:eac0369:     {
1:eac0369: 		// return the system temp dir by creating a temp file
1:eac0369: 		// and finding its parent.
1:eac0369: 		File temp = File.createTempFile("derby", "tmp");
1:eac0369: 		String parent = temp.getParent();
1:eac0369: 		temp.delete();
1:eac0369: 		return parent;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     public int getStorageFactoryVersion()
1:eac0369:     {
1:eac0369:         return StorageFactory.VERSION_NUMBER;
1:eac0369:     }
1:b2b30ec: 
1:b2b30ec:     /**
1:b2b30ec:      * Create and returns a temporary file in temporary file system of database.
1:5d54436:      * @param prefix String to prefix the random name generator.
1:5d54436:      * @param suffix String to suffix the random name generator.
1:b2b30ec:      * @return StorageFile
1:b2b30ec:      */
1:b2b30ec:     public StorageFile createTemporaryFile (String prefix, String suffix)
1:b2b30ec:                                                             throws IOException {
1:5d54436:         File tmpFile = File.createTempFile (prefix, suffix,
1:5d54436:                 new File (getTempDir().getPath()));
1:5d54436:         return newStorageFile (getTempDir(), tmpFile.getName());
1:b2b30ec:     }
1:b2b30ec: }
============================================================================
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:0e00e5e
/////////////////////////////////////////////////////////////////////////
1:      * Set the canonicalName. May need adjustment due to DERBY-5096
1:      * 
1:      * @param name uniquely identifiable name for this database
1:      */
1:     public void setCanonicalName(String name) {
1:        canonicalName = name;
1:     }
1:     
1:     /**
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:dc43cf8
/////////////////////////////////////////////////////////////////////////
1:         tempDir.limitAccessToOwner();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5d54436
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param prefix String to prefix the random name generator.
1:      * @param suffix String to suffix the random name generator.
1:         File tmpFile = File.createTempFile (prefix, suffix,
1:                 new File (getTempDir().getPath()));
1:         return newStorageFile (getTempDir(), tmpFile.getName());
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b2b30ec
/////////////////////////////////////////////////////////////////////////
0:     private int counter = 0;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Create and returns a temporary file in temporary file system of database.
0:      * @param prefix String to prefix the random name generator. It can be null
0:      * @param suffix String to suffix the random name generator. ".tmp" will be
0:      *               used if null.
1:      * @return StorageFile
1:      */
1:     public StorageFile createTemporaryFile (String prefix, String suffix)
1:                                                             throws IOException {
0:         StorageFile tmpDir = getTempDir();
0:         if (prefix == null)
0:             prefix = "tmp";
0:         if (suffix == null)
0:             suffix = ".tmp";
0:         StorageFile tmpFile = null;
0:         synchronized (tmpDir) {
0:             do {
0:                 String fileName = prefix + Integer.toString (counter++)
0:                             + suffix;
0:                 tmpFile = newStorageFile (tmpDir, fileName);
0:             } while (tmpFile.exists());
0:             tmpFile.createNewFile();
1:         }
0:         return tmpFile;
1:     }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:2724c48
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param directoryName The path name of the directory. Guaranteed not to be in the temporary file directory.
/////////////////////////////////////////////////////////////////////////
1:      * @param directoryName The path name of the directory. Guaranteed not to be to be null. Guaranteed to be
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.io.BaseStorageFactory
1: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.io
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.io;
1: 
1: import org.apache.derby.iapi.store.raw.data.DataFactory;
1: 
1: import org.apache.derby.io.StorageFactory;
1: import org.apache.derby.io.StorageFile;
1: 
1: import java.io.File;
1: import java.io.IOException;
1: 
1: /**
1:  * This class provides a base for implementations of the StorageFactory interface. It is used by the
1:  * database engine to access persistent data and transaction logs under the directory (default) subsubprotocol.
1:  */
1: 
1: abstract class BaseStorageFactory implements StorageFactory
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
1: 
1:     String home;
1:     protected StorageFile tempDir;
1:     protected String tempDirPath;
1:     protected String dataDirectory;
1:     protected String separatedDataDirectory; // dataDirectory + separator
1:     protected String uniqueName;
1:     protected String canonicalName;
1:     private static final String TEMP_DIR_PREFIX = "derbytmp_";
1: 
1:     /**
1:      * Most of the initialization is done in the init method.
1:      */
1:     BaseStorageFactory()
1:     {}
1: 
1:     /**
1:      * Classes implementing the StorageFactory interface must have a null
1:      * constructor.  This method is called when the database is booted up to
1:      * initialize the class. It should perform all actions necessary to start the
1:      * basic storage, such as creating a temporary file directory.
1:      *
1:      * The init method will be called once, before any other method is called, and will not
1:      * be called again.
1:      *
1:      * @param home The name of the directory containing the database. It comes from the system.home system property.
1:      *             It may be null. A storage factory may decide to ignore this parameter. (For instance the classpath
1:      *             storage factory ignores it.
1:      * @param databaseName The name of the database (directory). All relative pathnames are relative to this directory.
1:      *                     If null then the storage factory will only be used to deal with the directory containing
1:      *                     the databases.
0:      * @param create If true then the database is being created.
1:      * @param tempDirName The name of the temporary file directory set in properties. If null then a default
1:      *                    directory should be used. Each database should get a separate temporary file
1:      *                    directory within this one to avoid collisions.
1:      * @param uniqueName A unique name that can be used to create the temporary file directory for this database.
1:      *
1:      * @exception IOException on an error (unexpected).
1:      */
1:     public void init( String home, String databaseName, String tempDirName, String uniqueName)
1:         throws IOException
1:     {
1:         if( databaseName != null)
1:         {
1:             dataDirectory = databaseName;
1:             separatedDataDirectory = databaseName + getSeparator();
1:         }
1:         this.home = home;
1:         this.uniqueName = uniqueName;
1:         tempDirPath = tempDirName;
1:         doInit();
1:     } // end of init
1: 
1:     abstract void doInit() throws IOException;
1:     
1:     public void shutdown()
1:     {
1:     }
1:     
1: 
1:     /**
1:      * Get the canonical name of the database. This is a name that uniquely identifies it. It is system dependent.
1:      *
1:      * The normal, disk based implementation uses method java.io.File.getCanonicalPath on the directory holding the
1:      * database to construct the canonical name.
1:      *
1:      * @return the canonical name
1:      *
1:      * @exception IOException if an IO error occurred during the construction of the name.
1:      */
1:     public String getCanonicalName() throws IOException
1:     {
1:         return canonicalName;
1:     }
1:     
1:     /**
1:      * Construct a StorageFile from a path name.
1:      *
1:      * @param path The path name of the file
1:      *
1:      * @return A corresponding StorageFile object
1:      */
1:     public StorageFile newStorageFile( String path)
1:     {
1:         if( path != null && tempDirPath != null && path.startsWith( tempDirPath))
1:             return new DirFile( path);
1:         return newPersistentFile( path);
1:     }
1:     
1:     /**
1:      * Construct a StorageFile from a directory and file name.
1:      *
1:      * @param directoryName The directory part of the path name.
1:      * @param fileName The name of the file within the directory.
1:      *
1:      * @return A corresponding StorageFile object
1:      */
1:     public StorageFile newStorageFile( String directoryName, String fileName)
1:     {
1:         if( directoryName == null)
1:             return newStorageFile( fileName);
1:         else if( tempDirPath != null && directoryName.startsWith( tempDirPath))
1:             return new DirFile(directoryName, fileName);
1:         else
1:             return newPersistentFile( directoryName, fileName);
1:     }
1:     
1:     /**
1:      * Construct a StorageFile from a directory and file name.
1:      *
1:      * @param directoryName The directory part of the path name.
1:      * @param fileName The name of the file within the directory.
1:      *
1:      * @return A corresponding StorageFile object
1:      */
1:     public StorageFile newStorageFile( StorageFile directoryName, String fileName)
1:     {
1:         if( directoryName == null)
1:             return newStorageFile( fileName);
1:         if( fileName == null)
1:             return directoryName;
1:         else if (tempDirPath != null && directoryName.getPath().startsWith(tempDirPath))
1:             return new DirFile( (DirFile) directoryName, fileName);
1:         return newPersistentFile( directoryName, fileName);
1:     }
1:     
1:     /**
1:      * Construct a persistent StorageFile from a path name.
1:      *
1:      * @param path The path name of the file. Guaranteed not to be in the temporary file directory. If null
1:      *             then the database directory should be returned.
1:      *
1:      * @return A corresponding StorageFile object
1:      */
1:     abstract StorageFile newPersistentFile( String path);
1: 
1:     /**
1:      * Construct a persistent StorageFile from a directory and path name.
1:      *
0:      * @param directory The path name of the directory. Guaranteed not to be in the temporary file directory.
1:      *                  Guaranteed not to be null
1:      * @param fileName The name of the file within the directory. Guaranteed not to be null.
1:      *
1:      * @return A corresponding StorageFile object
1:      */
1:     abstract StorageFile newPersistentFile( String directoryName, String fileName);
1: 
1:     /**
1:      * Construct a persistent StorageFile from a directory and path name.
1:      *
0:      * @param directory The path name of the directory. Guaranteed not to be to be null. Guaranteed to be
1:      *                  created by a call to one of the newPersistentFile methods.
1:      * @param fileName The name of the file within the directory. Guaranteed not to be null.
1:      *
1:      * @return A corresponding StorageFile object
1:      */
1:     abstract StorageFile newPersistentFile( StorageFile directoryName, String fileName);
1:     
1:     /**
1:      * Get the pathname separator character used by the StorageFile implementation.
1:      *
1:      * @return the pathname separator character. (Normally '/' or '\').
1:      */
1:     public char getSeparator()
1:     {
1:         // Temp files are always java.io.File's and use its separator.
1:         return File.separatorChar;
1:     }
1: 
1:     /**
1:      * Get the abstract name of the directory that holds temporary files.
1:      *
1:      * @return a directory name
1:      */
1:     public StorageFile getTempDir()
1:     {
1:         return tempDir;
1:     }
1: 
1:     /**
1:      * This method is used to determine whether the storage is fast (RAM based) or slow (disk based).
1:      * It may be used by the database engine to determine the default size of the page cache.
1:      *
1:      * @return <b>true</b> if the storage is fast, <b>false</b> if it is slow.
1:      */
1:     public boolean isFast()
1:     {
1:         return false;
1:     }
1: 
1:     public boolean isReadOnlyDatabase()
1:     {
1:         return true;
1:     }
1: 
1:     /**
1:      * Determine whether the storage supports random access. If random access is not supported then
1:      * it will only be accessed using InputStreams and OutputStreams (if the database is writable).
1:      *
1:      * @return <b>true</b> if the storage supports random access, <b>false</b> if it is writable.
1:      */
1:     public boolean supportsRandomAccess()
1:     {
1:         return false;
1:     }
1: 
1:     void createTempDir() throws java.io.IOException
1:     {
1:         if( uniqueName == null)
1:             return;
1: 
1:         if( tempDirPath != null)
1:             tempDir = new DirFile( tempDirPath, TEMP_DIR_PREFIX.concat(uniqueName));
1:         else if( isReadOnlyDatabase())
1:             tempDir = new DirFile( readOnlyTempRoot(), TEMP_DIR_PREFIX.concat(uniqueName));
1:         else
1:             tempDir = new DirFile( canonicalName, DataFactory.TEMP_SEGMENT_NAME);
1:             
1:         // blow away any temporary directory
1:         tempDir.deleteAll();
1: 
1:         tempDir.mkdirs();
1:         tempDirPath = tempDir.getPath();
1:     } // end of createTempDir
1: 
1: 	private String readOnlyTempRoot() throws java.io.IOException
1:     {
1: 		// return the system temp dir by creating a temp file
1: 		// and finding its parent.
1: 		File temp = File.createTempFile("derby", "tmp");
1: 		String parent = temp.getParent();
1: 		temp.delete();
1: 
1: 		return parent;
1: 	}
1: 
1:     public int getStorageFactoryVersion()
1:     {
1:         return StorageFactory.VERSION_NUMBER;
1:     }
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.io
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.io;
0: 
0: import org.apache.derby.iapi.store.raw.data.DataFactory;
0: 
0: import org.apache.derby.io.StorageFactory;
0: import org.apache.derby.io.StorageFile;
0: 
0: import java.io.File;
0: import java.io.IOException;
0: 
0: /**
0:  * This class provides a base for implementations of the StorageFactory interface. It is used by the
0:  * database engine to access persistent data and transaction logs under the directory (default) subsubprotocol.
0:  */
0: 
0: abstract class BaseStorageFactory implements StorageFactory
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
0: 
0:     String home;
0:     protected StorageFile tempDir;
0:     protected String tempDirPath;
0:     protected String dataDirectory;
0:     protected String separatedDataDirectory; // dataDirectory + separator
0:     protected String uniqueName;
0:     protected String canonicalName;
0:     private static final String TEMP_DIR_PREFIX = "derbytmp_";
0: 
0:     /**
0:      * Most of the initialization is done in the init method.
0:      */
0:     BaseStorageFactory()
0:     {}
0: 
0:     /**
0:      * Classes implementing the StorageFactory interface must have a null
0:      * constructor.  This method is called when the database is booted up to
0:      * initialize the class. It should perform all actions necessary to start the
0:      * basic storage, such as creating a temporary file directory.
0:      *
0:      * The init method will be called once, before any other method is called, and will not
0:      * be called again.
0:      *
0:      * @param home The name of the directory containing the database. It comes from the system.home system property.
0:      *             It may be null. A storage factory may decide to ignore this parameter. (For instance the classpath
0:      *             storage factory ignores it.
0:      * @param databaseName The name of the database (directory). All relative pathnames are relative to this directory.
0:      *                     If null then the storage factory will only be used to deal with the directory containing
0:      *                     the databases.
0:      * @param create If true then the database is being created.
0:      * @param tempDirName The name of the temporary file directory set in properties. If null then a default
0:      *                    directory should be used. Each database should get a separate temporary file
0:      *                    directory within this one to avoid collisions.
0:      * @param uniqueName A unique name that can be used to create the temporary file directory for this database.
0:      *
0:      * @exception IOException on an error (unexpected).
0:      */
0:     public void init( String home, String databaseName, String tempDirName, String uniqueName)
0:         throws IOException
0:     {
0:         if( databaseName != null)
0:         {
0:             dataDirectory = databaseName;
0:             separatedDataDirectory = databaseName + getSeparator();
0:         }
0:         this.home = home;
0:         this.uniqueName = uniqueName;
0:         tempDirPath = tempDirName;
0:         doInit();
0:     } // end of init
0: 
0:     abstract void doInit() throws IOException;
0:     
0:     public void shutdown()
0:     {
0:     }
0:     
0: 
0:     /**
0:      * Get the canonical name of the database. This is a name that uniquely identifies it. It is system dependent.
0:      *
0:      * The normal, disk based implementation uses method java.io.File.getCanonicalPath on the directory holding the
0:      * database to construct the canonical name.
0:      *
0:      * @return the canonical name
0:      *
0:      * @exception IOException if an IO error occurred during the construction of the name.
0:      */
0:     public String getCanonicalName() throws IOException
0:     {
0:         return canonicalName;
0:     }
0:     
0:     /**
0:      * Construct a StorageFile from a path name.
0:      *
0:      * @param path The path name of the file
0:      *
0:      * @return A corresponding StorageFile object
0:      */
0:     public StorageFile newStorageFile( String path)
0:     {
0:         if( path != null && tempDirPath != null && path.startsWith( tempDirPath))
0:             return new DirFile( path);
0:         return newPersistentFile( path);
0:     }
0:     
0:     /**
0:      * Construct a StorageFile from a directory and file name.
0:      *
0:      * @param directoryName The directory part of the path name.
0:      * @param fileName The name of the file within the directory.
0:      *
0:      * @return A corresponding StorageFile object
0:      */
0:     public StorageFile newStorageFile( String directoryName, String fileName)
0:     {
0:         if( directoryName == null)
0:             return newStorageFile( fileName);
0:         else if( tempDirPath != null && directoryName.startsWith( tempDirPath))
0:             return new DirFile(directoryName, fileName);
0:         else
0:             return newPersistentFile( directoryName, fileName);
0:     }
0:     
0:     /**
0:      * Construct a StorageFile from a directory and file name.
0:      *
0:      * @param directoryName The directory part of the path name.
0:      * @param fileName The name of the file within the directory.
0:      *
0:      * @return A corresponding StorageFile object
0:      */
0:     public StorageFile newStorageFile( StorageFile directoryName, String fileName)
0:     {
0:         if( directoryName == null)
0:             return newStorageFile( fileName);
0:         if( fileName == null)
0:             return directoryName;
0:         else if (tempDirPath != null && directoryName.getPath().startsWith(tempDirPath))
0:             return new DirFile( (DirFile) directoryName, fileName);
0:         return newPersistentFile( directoryName, fileName);
0:     }
0:     
0:     /**
0:      * Construct a persistent StorageFile from a path name.
0:      *
0:      * @param path The path name of the file. Guaranteed not to be in the temporary file directory. If null
0:      *             then the database directory should be returned.
0:      *
0:      * @return A corresponding StorageFile object
0:      */
0:     abstract StorageFile newPersistentFile( String path);
0: 
0:     /**
0:      * Construct a persistent StorageFile from a directory and path name.
0:      *
0:      * @param directory The path name of the directory. Guaranteed not to be in the temporary file directory.
0:      *                  Guaranteed not to be null
0:      * @param fileName The name of the file within the directory. Guaranteed not to be null.
0:      *
0:      * @return A corresponding StorageFile object
0:      */
0:     abstract StorageFile newPersistentFile( String directoryName, String fileName);
0: 
0:     /**
0:      * Construct a persistent StorageFile from a directory and path name.
0:      *
0:      * @param directory The path name of the directory. Guaranteed not to be to be null. Guaranteed to be
0:      *                  created by a call to one of the newPersistentFile methods.
0:      * @param fileName The name of the file within the directory. Guaranteed not to be null.
0:      *
0:      * @return A corresponding StorageFile object
0:      */
0:     abstract StorageFile newPersistentFile( StorageFile directoryName, String fileName);
0:     
0:     /**
0:      * Get the pathname separator character used by the StorageFile implementation.
0:      *
0:      * @return the pathname separator character. (Normally '/' or '\').
0:      */
0:     public char getSeparator()
0:     {
0:         // Temp files are always java.io.File's and use its separator.
0:         return File.separatorChar;
0:     }
0: 
0:     /**
0:      * Get the abstract name of the directory that holds temporary files.
0:      *
0:      * @return a directory name
0:      */
0:     public StorageFile getTempDir()
0:     {
0:         return tempDir;
0:     }
0: 
0:     /**
0:      * This method is used to determine whether the storage is fast (RAM based) or slow (disk based).
0:      * It may be used by the database engine to determine the default size of the page cache.
0:      *
0:      * @return <b>true</b> if the storage is fast, <b>false</b> if it is slow.
0:      */
0:     public boolean isFast()
0:     {
0:         return false;
0:     }
0: 
0:     public boolean isReadOnlyDatabase()
0:     {
0:         return true;
0:     }
0: 
0:     /**
0:      * Determine whether the storage supports random access. If random access is not supported then
0:      * it will only be accessed using InputStreams and OutputStreams (if the database is writable).
0:      *
0:      * @return <b>true</b> if the storage supports random access, <b>false</b> if it is writable.
0:      */
0:     public boolean supportsRandomAccess()
0:     {
0:         return false;
0:     }
0: 
0:     void createTempDir() throws java.io.IOException
0:     {
0:         if( uniqueName == null)
0:             return;
0: 
0:         if( tempDirPath != null)
0:             tempDir = new DirFile( tempDirPath, TEMP_DIR_PREFIX.concat(uniqueName));
0:         else if( isReadOnlyDatabase())
0:             tempDir = new DirFile( readOnlyTempRoot(), TEMP_DIR_PREFIX.concat(uniqueName));
0:         else
0:             tempDir = new DirFile( canonicalName, DataFactory.TEMP_SEGMENT_NAME);
0:             
0:         // blow away any temporary directory
0:         tempDir.deleteAll();
0: 
0:         tempDir.mkdirs();
0:         tempDirPath = tempDir.getPath();
0:     } // end of createTempDir
0: 
0: 	private String readOnlyTempRoot() throws java.io.IOException
0:     {
0: 		// return the system temp dir by creating a temp file
0: 		// and finding its parent.
0: 		File temp = File.createTempFile("derby", "tmp");
0: 		String parent = temp.getParent();
0: 		temp.delete();
0: 
0: 		return parent;
0: 	}
0: 
0:     public int getStorageFactoryVersion()
0:     {
0:         return StorageFactory.VERSION_NUMBER;
0:     }
0: }
============================================================================