1:33776ff: /*
1:01c7f83: 
1:33776ff:    Derby - Class org.apache.derby.jdbc.ClientDriver
1:a36fdb7: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
5:70f7692: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:70f7692: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:70f7692: 
1:82d721f: */
1:70f7692: 
1:33776ff: package org.apache.derby.jdbc;
1:82d721f: 
1:69e3d06: import java.sql.Connection;
1:69e3d06: import java.sql.Driver;
1:69e3d06: import java.sql.DriverManager;
1:69e3d06: import java.sql.DriverPropertyInfo;
1:82d721f: import java.util.Enumeration;
1:82d721f: import java.util.Properties;
1:d506170: import java.sql.SQLException;
1:9a0cdf1: import java.sql.SQLFeatureNotSupportedException;
1:69e3d06: import java.util.NoSuchElementException;
1:69e3d06: import java.util.StringTokenizer;
1:9a0cdf1: import java.util.logging.Logger;
1:33776ff: import org.apache.derby.client.am.Configuration;
1:33776ff: import org.apache.derby.client.am.SqlException;
1:70f7692: import org.apache.derby.client.am.Utils;
1:33776ff: import org.apache.derby.client.am.Version;
1:cbd0ff1: import org.apache.derby.client.am.ClientJDBCObjectFactory;
1:2dcbe06: import org.apache.derby.client.am.ClientMessageId;
1:b13b17c: import org.apache.derby.client.am.LogWriter;
1:cbd0ff1: import org.apache.derby.client.net.ClientJDBCObjectFactoryImpl;
1:b13b17c: import org.apache.derby.client.net.NetConnection;
1:ceb72fe: import org.apache.derby.shared.common.reference.Attribute;
1:2dcbe06: import org.apache.derby.shared.common.reference.SQLState;
1:6dba60c: import org.apache.derby.shared.common.reference.MessageId;
1:70f7692: 
1:2913612: /**
1:2913612:  * The client JDBC driver (type 4) for Derby.
1:2913612:  */
1:69e3d06: public class ClientDriver implements Driver {
1:70f7692:     private transient int traceFileSuffixIndex_ = 0;
1:70f7692: 
1:70f7692:     private final static int DERBY_REMOTE_PROTOCOL = 1;
1:cbd0ff1:     
1:cbd0ff1:     private static ClientJDBCObjectFactory factoryObject = null;
1:70f7692: 
1:d506170:     static private SQLException exceptionsOnLoadDriver__ = null;
1:70f7692:     // Keep track of the registere driver so that we can deregister it if we're a stored proc.
1:70f7692:     static private ClientDriver registeredDriver__ = null;
1:70f7692: 
1:09869c6:     static
1:09869c6:     {
1:9a0cdf1:         registerMe(new ClientDriver());
1:6eb29f6:     }
1:01c7f83: 
1:09869c6:     protected static void   registerMe( ClientDriver me )
1:9a0cdf1:     {
1:70f7692:         // The Configuration static clause should execute before the following line does.
1:508f8f6:         SqlException ole = Configuration.getExceptionOnLoadResources();
1:cbd0ff1:         
1:508f8f6:         if (ole != null) {
1:508f8f6:             SQLException e = ole.getSQLException();
1:70f7692:             exceptionsOnLoadDriver__ =
1:508f8f6:                 Utils.accumulateSQLException(e, exceptionsOnLoadDriver__);
7:70f7692:         }
1:508f8f6:         
1:09869c6:         try {
1:09869c6:             registeredDriver__ = me;
1:69e3d06:             DriverManager.registerDriver(registeredDriver__);
1:69e3d06:         } catch (SQLException e) {
1:70f7692:             // A null log writer is passed, because jdbc 1 sql exceptions are automatically traced
1:70f7692:             exceptionsOnLoadDriver__ =
1:2dcbe06:                     new SqlException(null, 
1:2dcbe06:                         new ClientMessageId(SQLState.JDBC_DRIVER_REGISTER)).getSQLException();
1:70f7692:             exceptionsOnLoadDriver__.setNextException(e);
1:70f7692:         }
1:70f7692:     }
1:508f8f6: 
1:70f7692:     public ClientDriver() {
1:70f7692:     }
1:d506170: 
1:69e3d06:     public Connection connect(String url,
1:69e3d06:                               Properties properties) throws SQLException {
1:b13b17c:         NetConnection conn;
1:70f7692:         
1:01c7f83:         checkURLNotNull( url );
1:01c7f83: 
1:cbd0ff1:         try {    
1:d506170:             if (exceptionsOnLoadDriver__ != null) {
1:d506170:                 throw exceptionsOnLoadDriver__;
1:70f7692:             }
1:01c7f83: 
1:d506170:             if (properties == null) {
1:69e3d06:                 properties = new Properties();
1:d506170:             }
1:d506170: 
1:69e3d06:             StringTokenizer urlTokenizer =
1:69e3d06:                     new StringTokenizer(url, "/:= \t\n\r\f", true);
1:d506170: 
1:d506170:             int protocol = tokenizeProtocol(url, urlTokenizer);
1:d506170:             if (protocol == 0) {
1:d506170:                 return null; // unrecognized database URL prefix.
1:d506170:             }
1:d506170: 
1:d506170:             String slashOrNull = null;
1:d506170:             if (protocol == DERBY_REMOTE_PROTOCOL) {
1:d506170:                 try {
1:d506170:                     slashOrNull = urlTokenizer.nextToken(":/");
1:69e3d06:                 } catch (NoSuchElementException e) {
1:d506170:                     // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
1:2dcbe06:                     throw new SqlException(null, 
1:2dcbe06:                         new ClientMessageId(SQLState.MALFORMED_URL),
1:e1a79c3:                         e, url);
1:d506170:                 }
1:d506170:             }
1:d506170:             String server = tokenizeServerName(urlTokenizer, url);    // "/server"
1:d506170:             int port = tokenizeOptionalPortNumber(urlTokenizer, url); // "[:port]/"
1:d506170:             if (port == 0) {
1:7863d83:                 port = BasicClientDataSource40.propertyDefault_portNumber;
1:d506170:             }
1:d506170: 
1:82d721f:             // database is the database name and attributes.  This will be
1:d506170:             // sent to network server as the databaseName
1:d506170:             String database = tokenizeDatabase(urlTokenizer, url); // "database"
1:69e3d06:             Properties augmentedProperties =
1:69e3d06:                 tokenizeURLProperties(url, properties);
1:82d721f:             database = appendDatabaseAttributes(database,augmentedProperties);
1:d506170: 
1:d506170:             int traceLevel;
1:d506170:             try {
1:8269b78:                 traceLevel =
1:7863d83:                     BasicClientDataSource40.getTraceLevel(augmentedProperties);
1:69e3d06:             } catch (NumberFormatException e) {
1:d506170:                 // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
1:2dcbe06:                 throw new SqlException(null, 
1:2dcbe06:                     new ClientMessageId(SQLState.TRACELEVEL_FORMAT_INVALID), e);
1:d506170:             }
1:d506170: 
1:d506170:             // Jdbc 1 connections will write driver trace info on a
1:d506170:             // driver-wide basis using the jdbc 1 driver manager log writer.
1:d506170:             // This log writer may be narrowed to the connection-level
1:d506170:             // This log writer will be passed to the agent constructor.
1:b13b17c:             LogWriter dncLogWriter =
1:7863d83:                 BasicClientDataSource40.computeDncLogWriterForNewConnection(
1:69e3d06:                     DriverManager.getLogWriter(),
1:7863d83:                     BasicClientDataSource40.getTraceDirectory(
1:8269b78:                         augmentedProperties),
1:7863d83:                     BasicClientDataSource40.getTraceFile(
1:8269b78:                         augmentedProperties),
1:7863d83:                     BasicClientDataSource40.getTraceFileAppend(
1:8269b78:                         augmentedProperties),
1:8269b78:                     traceLevel,
1:8269b78:                     "_driver",
1:8269b78:                     traceFileSuffixIndex_++);
1:cbd0ff1:             
1:cbd0ff1:             
1:b13b17c:             conn = (NetConnection)getFactory().
1:6372907:                     newNetConnection(dncLogWriter,
1:69e3d06:                     DriverManager.getLoginTimeout(),
1:cbd0ff1:                     server,
1:cbd0ff1:                     port,
1:cbd0ff1:                     database,
1:cbd0ff1:                     augmentedProperties);
1:cbd0ff1:         } catch(SqlException se) {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:cbd0ff1:         
1:cbd0ff1:         if(conn.isConnectionNull())
1:cbd0ff1:             return null;
1:cbd0ff1:         
1:cbd0ff1:         return conn;
1:70f7692:     }
1:a36fdb7: 
1:cbd0ff1:     /**
1:82d721f:      * Append attributes to the database name except for user/password 
1:6bc2e25:      * which are sent as part of the protocol, and SSL which is used 
1:6bc2e25:      * locally in the client.
1:82d721f:      * Other attributes will  be sent to the server with the database name
1:82d721f:      * Assumes augmentedProperties is not null
1:82d721f:      * 
1:6eb29f6:      * @param database - Short database name
1:6eb29f6:      * @param augmentedProperties - Set of properties to append as attributes
1:6eb29f6:      * @return databaseName + attributes (e.g. mydb;create=true) 
1:6eb29f6:      */
1:6eb29f6:     private String appendDatabaseAttributes(String database, Properties augmentedProperties) {
1:6eb29f6:     
1:6eb29f6:         StringBuffer longDatabase = new StringBuffer(database);
1:efd17a1:         for (Enumeration keys = augmentedProperties.propertyNames();
1:efd17a1:              keys.hasMoreElements() ;)
1:01c7f83:         {
1:6eb29f6:             String key = (String) keys.nextElement();
1:6eb29f6:             if (key.equals(Attribute.USERNAME_ATTR) || 
1:6bc2e25:                 key.equals(Attribute.PASSWORD_ATTR) ||
1:6bc2e25:                 key.equals(Attribute.SSL_ATTR))
1:6eb29f6:                 continue;
1:6eb29f6:             longDatabase.append(";" + key + "=" + augmentedProperties.getProperty(key));
1:6eb29f6:         }
1:6eb29f6:         return longDatabase.toString();
1:6eb29f6:     }
1:82d721f: 
1:69e3d06:     public boolean acceptsURL(String url) throws SQLException {
1:82d721f: 
1:01c7f83:         checkURLNotNull( url );
1:d506170:         
1:d506170:         try
1:6eb29f6:         {
1:69e3d06:             StringTokenizer urlTokenizer =
1:69e3d06:                     new StringTokenizer(url, "/:=; \t\n\r\f", true);
1:d506170:             int protocol = tokenizeProtocol(url, urlTokenizer);
1:d506170:             return protocol != 0;
1:82d721f:         }
1:d506170:         catch ( SqlException se )
1:6eb29f6:         {
1:d506170:             throw se.getSQLException();
1:82d721f:         }
1:d506170:     }
1:69e3d06:     private void    checkURLNotNull( String url ) throws SQLException
1:6eb29f6:     {
1:01c7f83:         if ( url == null )
1:01c7f83:         {
1:01c7f83:             throw (new SqlException
1:01c7f83:                 (
1:01c7f83:                  null, 
1:01c7f83:                  new ClientMessageId( SQLState.MALFORMED_URL), "null"
1:01c7f83:                  )).getSQLException();
1:01c7f83:         }
1:01c7f83:     }
1:d506170: 
1:69e3d06:     public DriverPropertyInfo[] getPropertyInfo(
1:69e3d06:             String url,
1:69e3d06:             Properties properties) throws SQLException {
1:69e3d06: 
1:69e3d06:         DriverPropertyInfo driverPropertyInfo[] = new DriverPropertyInfo[2];
1:d506170: 
1:70f7692:         // If there are no properties set already,
1:70f7692:         // then create a dummy properties just to make the calls go thru.
2:70f7692:         if (properties == null) {
1:69e3d06:             properties = new Properties();
1:70f7692:         }
1:70f7692: 
1:70f7692:         driverPropertyInfo[0] =
1:69e3d06:             new DriverPropertyInfo(
1:8269b78:                 Attribute.USERNAME_ATTR,
1:8269b78:                 properties.getProperty(
1:8269b78:                     Attribute.USERNAME_ATTR,
1:7863d83:                     BasicClientDataSource40.propertyDefault_user));
1:70f7692: 
1:70f7692:         driverPropertyInfo[1] =
1:69e3d06:                 new DriverPropertyInfo(Attribute.PASSWORD_ATTR,
1:ceb72fe:                         properties.getProperty(Attribute.PASSWORD_ATTR));
1:70f7692: 
1:70f7692:         driverPropertyInfo[0].description =
1:6dba60c:             SqlException.getMessageUtil().getTextMessage(
1:6dba60c:                 MessageId.CONN_USERNAME_DESCRIPTION);
1:70f7692:         driverPropertyInfo[1].description =
1:6dba60c:             SqlException.getMessageUtil().getTextMessage(
1:6dba60c:                 MessageId.CONN_PASSWORD_DESCRIPTION);
1:70f7692: 
1:70f7692:         driverPropertyInfo[0].required = true;
1:70f7692:         driverPropertyInfo[1].required = false; // depending on the security mechanism
1:70f7692: 
1:70f7692:         return driverPropertyInfo;
1:70f7692:     }
1:70f7692: 
1:70f7692:     public int getMajorVersion() {
1:70f7692:         return Version.getMajorVersion();
1:70f7692:     }
1:70f7692: 
1:70f7692:     public int getMinorVersion() {
1:70f7692:         return Version.getMinorVersion();
1:70f7692:     }
1:70f7692: 
1:70f7692:     public boolean jdbcCompliant() {
1:70f7692:         return Configuration.jdbcCompliant;
1:70f7692:     }
1:9a0cdf1: 
1:9a0cdf1:     ////////////////////////////////////////////////////////////////////
1:09869c6:     //
1:9a0cdf1:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:09869c6:     //
1:9a0cdf1:     ////////////////////////////////////////////////////////////////////
1:09869c6: 
1:9a0cdf1:     public  Logger getParentLogger()
1:9a0cdf1:         throws SQLFeatureNotSupportedException
1:09869c6:     {
1:9a0cdf1:         getFactory();
1:9a0cdf1:         throw (SQLFeatureNotSupportedException)
1:9a0cdf1:             (
1:9a0cdf1:              new SqlException( null, new ClientMessageId(SQLState.NOT_IMPLEMENTED), "getParentLogger" )
1:9a0cdf1:              ).getSQLException();
1:09869c6:     }
1:9a0cdf1: 
1:70f7692:     // ----------------helper methods---------------------------------------------
1:70f7692: 
1:70f7692:     // Tokenize one of the following:
1:70f7692:     //  "jdbc:derby:"
1:70f7692:     // and return 0 if the protcol is unrecognized
1:70f7692:     // return DERBY_PROTOCOL for "jdbc:derby"
1:69e3d06:     private static int tokenizeProtocol(
1:69e3d06:             String url,
1:69e3d06:             StringTokenizer urlTokenizer) throws SqlException {
1:69e3d06: 
1:70f7692:         // Is this condition necessary, StringTokenizer constructor may do this for us
1:70f7692:         if (url == null) {
1:70f7692:             return 0;
1:09869c6:         }
1:70f7692: 
1:70f7692:         if (urlTokenizer == null) {
1:70f7692:             return 0;
1:09869c6:         }
1:70f7692: 
4:70f7692:         try {
1:70f7692:             String jdbc = urlTokenizer.nextToken(":");
1:70f7692:             if (!jdbc.equals("jdbc")) {
1:70f7692:                 return 0;
1:9a0cdf1:             }
1:70f7692:             if (!urlTokenizer.nextToken(":").equals(":")) {
1:70f7692:                 return 0; // Skip over the first colon in jdbc:derby:
1:70f7692:             }
1:70f7692:             String dbname = urlTokenizer.nextToken(":");
1:70f7692:             int protocol = 0;
1:70f7692:             if (dbname.equals("derby") && (url.indexOf("derby://") != -1)) {
1:70f7692:                 // For Derby AS need to check for // since jdbc:derby: is also the
1:70f7692:                 // embedded prefix
1:70f7692:                 protocol = DERBY_REMOTE_PROTOCOL;
1:70f7692:             } else {
1:70f7692:                 return 0;
1:70f7692:             }
1:70f7692: 
1:70f7692:             if (!urlTokenizer.nextToken(":").equals(":")) {
1:70f7692:                 return 0; // Skip over the second colon in jdbc:derby:
1:70f7692:             }
1:70f7692: 
1:70f7692:             return protocol;
1:69e3d06:         } catch (NoSuchElementException e) {
1:70f7692:             return 0;
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // tokenize "/server" from URL jdbc:derby://server:port/
1:70f7692:     // returns server name
1:69e3d06:     private static String tokenizeServerName(StringTokenizer urlTokenizer,
1:70f7692:                                              String url) throws SqlException {
1:70f7692:         try {
1:70f7692:             if (!urlTokenizer.nextToken("/").equals("/"))
3:70f7692:             // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
1:09869c6:             {
1:2dcbe06:                 throw new SqlException(null, 
1:2dcbe06:                     new ClientMessageId(SQLState.MALFORMED_URL), url);
1:70f7692:             }
1:70f7692:             return urlTokenizer.nextToken("/:");
1:69e3d06:         } catch (NoSuchElementException e) {
1:70f7692:             // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
1:2dcbe06:                 throw new SqlException(null, 
1:2dcbe06:                     new ClientMessageId(SQLState.MALFORMED_URL), url);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // tokenize "[:portNumber]/" from URL jdbc:derby://server[:port]/
1:70f7692:     // returns the portNumber or zero if portNumber is not specified.
1:69e3d06:     private static int tokenizeOptionalPortNumber(StringTokenizer urlTokenizer,
1:70f7692:                                                   String url) throws SqlException {
1:70f7692:         try {
1:70f7692:             String firstToken = urlTokenizer.nextToken(":/");
1:70f7692:             if (firstToken.equals(":")) {
1:70f7692:                 String port = urlTokenizer.nextToken("/");
1:70f7692:                 if (!urlTokenizer.nextToken("/").equals("/")) {
1:70f7692:                     // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
1:2dcbe06:                     throw new SqlException(null, 
1:2dcbe06:                         new ClientMessageId(SQLState.MALFORMED_URL), url);
1:70f7692:                 }
1:70f7692:                 return Integer.parseInt(port);
1:70f7692:             } else if (firstToken.equals("/")) {
1:70f7692:                 return 0;
1:70f7692:             } else {
1:70f7692:                 // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
1:2dcbe06:                 throw new SqlException(null, 
1:2dcbe06:                     new ClientMessageId(SQLState.MALFORMED_URL), url);
1:70f7692:             }
1:69e3d06:         } catch (NoSuchElementException e) {
1:70f7692:             // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
1:2dcbe06:             throw new SqlException(null, 
1:e1a79c3:                 new ClientMessageId(SQLState.MALFORMED_URL), e, url);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:82d721f:     //return database name
1:69e3d06:     private static String tokenizeDatabase(StringTokenizer urlTokenizer,
1:70f7692:                                            String url) throws SqlException {
1:70f7692:         try {
1:6eb29f6:             // DERBY-618 - database name can contain spaces in the path
1:41c14e5:             String databaseName = urlTokenizer.nextToken("\t\n\r\f;");
1:70f7692:             return databaseName;
1:69e3d06:         } catch (NoSuchElementException e) {
1:70f7692:             // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
1:2dcbe06:             throw new SqlException(null, 
1:e1a79c3:                 new ClientMessageId(SQLState.MALFORMED_URL), e, url);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     private static Properties tokenizeURLProperties(String url,
1:69e3d06:                                                     Properties properties)
1:70f7692:             throws SqlException {
1:70f7692:         String attributeString = null;
1:70f7692:         int attributeIndex = -1;
1:70f7692: 
1:70f7692:         if ((url != null) &&
1:70f7692:                 ((attributeIndex = url.indexOf(";")) != -1)) {
1:70f7692:             attributeString = url.substring(attributeIndex);
1:70f7692:         }
1:8269b78: 
1:7863d83:         return BasicClientDataSource40.tokenizeAttributes(
1:8269b78:             attributeString, properties);
1:70f7692:     }
1:70f7692:     
1:82d721f:     /**
1:cbd0ff1:      *This method returns an Implementation
1:cbd0ff1:      *of ClientJDBCObjectFactory depending on
1:cbd0ff1:      *VM under use
1:cbd0ff1:      *Currently it returns either
1:cbd0ff1:      *ClientJDBCObjectFactoryImpl
1:cbd0ff1:      *(or)
1:9a0cdf1:      *ClientJDBCObjectFactoryImpl42
1:cbd0ff1:      */
1:cbd0ff1:     
1:cbd0ff1:     public static ClientJDBCObjectFactory getFactory() {
1:0326967:         // System.err.println("factoryObject="+factoryObject);
1:0326967: 
1:cbd0ff1:         if(factoryObject!=null)
1:cbd0ff1:             return factoryObject;
1:b54918e:         if (Configuration.supportsJDBC42()) {
1:b54918e:             factoryObject = createJDBC42FactoryImpl();
1:cbd0ff1:         } else {
1:cbd0ff1:             factoryObject = createDefaultFactoryImpl();
1:cbd0ff1:         }
1:cbd0ff1:         return factoryObject;
1:cbd0ff1:     }
1:cbd0ff1:     
1:cbd0ff1:     /**
1:cbd0ff1:      *Returns an instance of the ClientJDBCObjectFactoryImpl class
1:cbd0ff1:      */
1:cbd0ff1:     private static ClientJDBCObjectFactory createDefaultFactoryImpl() {
1:cbd0ff1:         return  new ClientJDBCObjectFactoryImpl();
1:cbd0ff1:     }
1:cbd0ff1:     
1:cbd0ff1:     /**
1:cbd0ff1:      *Returns an instance of the ClientJDBCObjectFactoryImpl40 class
1:cbd0ff1:      *If a ClassNotFoundException occurs then it returns an
1:cbd0ff1:      *instance of ClientJDBCObjectFactoryImpl
1:cbd0ff1:      *
1:cbd0ff1:      *If a future version of JDBC comes then
1:cbd0ff1:      *a similar method would be added say createJDBCXXFactoryImpl
1:cbd0ff1:      *in which if  the class is not found then it would
1:cbd0ff1:      *return the lower version thus having a sort of cascading effect
1:cbd0ff1:      *until it gets a valid instance
1:cbd0ff1:      */
1:cbd0ff1:     
1:cbd0ff1:     private static ClientJDBCObjectFactory createJDBC40FactoryImpl() {
1:cbd0ff1:         final String factoryName =
1:cbd0ff1:                 "org.apache.derby.client.net.ClientJDBCObjectFactoryImpl40";
1:cbd0ff1:         try {
1:4469400:             Class<?> clazz = Class.forName(factoryName);
1:4469400:             return (ClientJDBCObjectFactory) clazz.getConstructor().newInstance();
1:cbd0ff1:         } catch (ClassNotFoundException cnfe) {
1:cbd0ff1:             return createDefaultFactoryImpl();
1:cbd0ff1:         } catch (InstantiationException ie) {
1:cbd0ff1:             return createDefaultFactoryImpl();
1:cbd0ff1:         } catch (IllegalAccessException iae) {
1:cbd0ff1:             return createDefaultFactoryImpl();
1:4469400:         } catch (NoSuchMethodException iae) {
1:4469400:             return createDefaultFactoryImpl();
1:4469400:         } catch (java.lang.reflect.InvocationTargetException iae) {
1:4469400:             return createDefaultFactoryImpl();
1:cbd0ff1:         }
1:cbd0ff1:     }
1:b54918e: 
1:b54918e:     /**
1:b54918e:      *Returns an instance of the ClientJDBCObjectFactoryImpl42 class
1:b54918e:      *If a ClassNotFoundException occurs then it returns an
1:b54918e:      *instance of the most refined ClientJDBCObjectFactoryImpl possible
1:b54918e:      *
1:b54918e:      *If a future version of JDBC comes then
1:b54918e:      *a similar method would be added say createJDBCXXFactoryImpl
1:b54918e:      *in which if  the class is not found then it would
1:b54918e:      *return the lower version thus having a sort of cascading effect
1:b54918e:      *until it gets a valid instance
1:b54918e:      */
1:b54918e:     
1:b54918e:     private static ClientJDBCObjectFactory createJDBC42FactoryImpl() {
1:b54918e:         final String factoryName =
1:b54918e:                 "org.apache.derby.client.net.ClientJDBCObjectFactoryImpl42";
1:b54918e:         try {
1:4469400:             Class<?> clazz = Class.forName(factoryName);
1:4469400:             return (ClientJDBCObjectFactory) clazz.getConstructor().newInstance();
1:b54918e:         } catch (ClassNotFoundException cnfe) {
1:b54918e:             return createJDBC40FactoryImpl();
1:b54918e:         } catch (InstantiationException ie) {
1:4469400:             return createJDBC40FactoryImpl();
1:b54918e:         } catch (IllegalAccessException iae) {
1:4469400:             return createJDBC40FactoryImpl();
1:4469400:         } catch (NoSuchMethodException iae) {
1:b54918e:             return createJDBC40FactoryImpl();
1:4469400:         } catch (java.lang.reflect.InvocationTargetException iae) {
1:b54918e:             return createJDBC40FactoryImpl();
1:b54918e:         }
1:b54918e:     }
1:b54918e: 
1:70f7692: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:             Class<?> clazz = Class.forName(factoryName);
1:             return (ClientJDBCObjectFactory) clazz.getConstructor().newInstance();
1:         } catch (NoSuchMethodException iae) {
1:             return createDefaultFactoryImpl();
1:         } catch (java.lang.reflect.InvocationTargetException iae) {
1:             return createDefaultFactoryImpl();
/////////////////////////////////////////////////////////////////////////
1:             Class<?> clazz = Class.forName(factoryName);
1:             return (ClientJDBCObjectFactory) clazz.getConstructor().newInstance();
1:         } catch (NoSuchMethodException iae) {
1:             return createJDBC40FactoryImpl();
1:         } catch (java.lang.reflect.InvocationTargetException iae) {
1:             return createJDBC40FactoryImpl();
commit:01c7f83
/////////////////////////////////////////////////////////////////////////
1:         
1:         checkURLNotNull( url );
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         checkURLNotNull( url );
1:         
/////////////////////////////////////////////////////////////////////////
0:     private void    checkURLNotNull( String url ) throws java.sql.SQLException
1:     {
1:         if ( url == null )
1:         {
1:             throw (new SqlException
1:                 (
1:                  null, 
1:                  new ClientMessageId( SQLState.MALFORMED_URL), "null"
1:                  )).getSQLException();
1:         }
1:     }
commit:b54918e
/////////////////////////////////////////////////////////////////////////
1:         if (Configuration.supportsJDBC42()) {
1:             factoryObject = createJDBC42FactoryImpl();
0:         } else if (Configuration.supportsJDBC40()) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      *Returns an instance of the ClientJDBCObjectFactoryImpl42 class
1:      *If a ClassNotFoundException occurs then it returns an
1:      *instance of the most refined ClientJDBCObjectFactoryImpl possible
1:      *
1:      *If a future version of JDBC comes then
1:      *a similar method would be added say createJDBCXXFactoryImpl
1:      *in which if  the class is not found then it would
1:      *return the lower version thus having a sort of cascading effect
1:      *until it gets a valid instance
1:      */
1:     
1:     private static ClientJDBCObjectFactory createJDBC42FactoryImpl() {
1:         final String factoryName =
1:                 "org.apache.derby.client.net.ClientJDBCObjectFactoryImpl42";
1:         try {
0:             return (ClientJDBCObjectFactory)
0:             Class.forName(factoryName).newInstance();
1:         } catch (ClassNotFoundException cnfe) {
1:             return createJDBC40FactoryImpl();
1:         } catch (InstantiationException ie) {
1:             return createJDBC40FactoryImpl();
1:         } catch (IllegalAccessException iae) {
1:             return createJDBC40FactoryImpl();
1:         }
1:     }
1: 
commit:09869c6
/////////////////////////////////////////////////////////////////////////
1: 	static
1: 	{
1:         try {
1:             //
0:             // We'd rather load this slightly more capable driver.
0:             // But if the vm level doesn't support it, then we fall
0:             // back on the JDBC3 level driver.
1:             //
0:             Class.forName( "org.apache.derby.jdbc.ClientDriver40" );
1:         }
0:         catch (Throwable e)
1:         {
0:             registerMe( new ClientDriver() );
1:         }
1: 	}
1: 
1: 	protected static void   registerMe( ClientDriver me )
1: 	{
/////////////////////////////////////////////////////////////////////////
1:             registeredDriver__ = me;
commit:cbd0ff1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.ClientJDBCObjectFactory;
1: import org.apache.derby.client.net.ClientJDBCObjectFactoryImpl;
/////////////////////////////////////////////////////////////////////////
1:     
1:     private static ClientJDBCObjectFactory factoryObject = null;
/////////////////////////////////////////////////////////////////////////
0:         org.apache.derby.client.net.NetConnection conn;
1:         try {    
/////////////////////////////////////////////////////////////////////////
1:             
1:             
0:             conn = (org.apache.derby.client.net.NetConnection)getFactory().
0:                     newNetConnection((org.apache.derby.client.net.NetLogWriter) 
0:                     dncLogWriter,
0:                     java.sql.DriverManager.getLoginTimeout(),
1:                     server,
1:                     port,
1:                     database,
1:                     augmentedProperties);
1:         } catch(SqlException se) {
1:         
1:         if(conn.isConnectionNull())
1:             return null;
1:         
1:         return conn;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      *This method returns an Implementation
1:      *of ClientJDBCObjectFactory depending on
1:      *VM under use
1:      *Currently it returns either
1:      *ClientJDBCObjectFactoryImpl
1:      *(or)
0:      *ClientJDBCObjectFactoryImpl40
1:      */
1:     
1:     public static ClientJDBCObjectFactory getFactory() {
1:         if(factoryObject!=null)
1:             return factoryObject;
0:         if(Configuration.supportsJDBC40()) {
0:             factoryObject = createJDBC40FactoryImpl();
1:         } else {
1:             factoryObject = createDefaultFactoryImpl();
1:         }
1:         return factoryObject;
1:     }
1:     
1:     /**
1:      *Returns an instance of the ClientJDBCObjectFactoryImpl class
1:      */
1:     private static ClientJDBCObjectFactory createDefaultFactoryImpl() {
1:         return  new ClientJDBCObjectFactoryImpl();
1:     }
1:     
1:     /**
1:      *Returns an instance of the ClientJDBCObjectFactoryImpl40 class
1:      *If a ClassNotFoundException occurs then it returns an
1:      *instance of ClientJDBCObjectFactoryImpl
1:      *
1:      *If a future version of JDBC comes then
1:      *a similar method would be added say createJDBCXXFactoryImpl
1:      *in which if  the class is not found then it would
1:      *return the lower version thus having a sort of cascading effect
1:      *until it gets a valid instance
1:      */
1:     
1:     private static ClientJDBCObjectFactory createJDBC40FactoryImpl() {
1:         final String factoryName =
1:                 "org.apache.derby.client.net.ClientJDBCObjectFactoryImpl40";
1:         try {
0:             return (ClientJDBCObjectFactory)
0:             Class.forName(factoryName).newInstance();
1:         } catch (ClassNotFoundException cnfe) {
1:             return createDefaultFactoryImpl();
1:         } catch (InstantiationException ie) {
1:             return createDefaultFactoryImpl();
1:         } catch (IllegalAccessException iae) {
1:             return createDefaultFactoryImpl();
1:         }
1:     }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:7863d83
/////////////////////////////////////////////////////////////////////////
1:                 port = BasicClientDataSource40.propertyDefault_portNumber;
/////////////////////////////////////////////////////////////////////////
1:                     BasicClientDataSource40.getTraceLevel(augmentedProperties);
/////////////////////////////////////////////////////////////////////////
1:                 BasicClientDataSource40.computeDncLogWriterForNewConnection(
1:                     BasicClientDataSource40.getTraceDirectory(
1:                     BasicClientDataSource40.getTraceFile(
1:                     BasicClientDataSource40.getTraceFileAppend(
/////////////////////////////////////////////////////////////////////////
1:                     BasicClientDataSource40.propertyDefault_user));
/////////////////////////////////////////////////////////////////////////
1:         return BasicClientDataSource40.tokenizeAttributes(
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:         // System.err.println("factoryObject="+factoryObject);
1: 
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
1: import java.sql.Driver;
1: import java.sql.DriverManager;
1: import java.sql.DriverPropertyInfo;
1: import java.util.NoSuchElementException;
1: import java.util.StringTokenizer;
/////////////////////////////////////////////////////////////////////////
1: public class ClientDriver implements Driver {
/////////////////////////////////////////////////////////////////////////
1:             DriverManager.registerDriver(registeredDriver__);
1:         } catch (SQLException e) {
/////////////////////////////////////////////////////////////////////////
1:     public Connection connect(String url,
1:                               Properties properties) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                 properties = new Properties();
1:             StringTokenizer urlTokenizer =
1:                     new StringTokenizer(url, "/:= \t\n\r\f", true);
/////////////////////////////////////////////////////////////////////////
1:                 } catch (NoSuchElementException e) {
/////////////////////////////////////////////////////////////////////////
1:             Properties augmentedProperties =
1:                 tokenizeURLProperties(url, properties);
1:             } catch (NumberFormatException e) {
/////////////////////////////////////////////////////////////////////////
1:                     DriverManager.getLogWriter(),
/////////////////////////////////////////////////////////////////////////
0:                     newNetConnection((NetLogWriter)dncLogWriter,
1:                     DriverManager.getLoginTimeout(),
/////////////////////////////////////////////////////////////////////////
1:     public boolean acceptsURL(String url) throws SQLException {
1:             StringTokenizer urlTokenizer =
1:                     new StringTokenizer(url, "/:=; \t\n\r\f", true);
/////////////////////////////////////////////////////////////////////////
1:     private void    checkURLNotNull( String url ) throws SQLException
/////////////////////////////////////////////////////////////////////////
1:     public DriverPropertyInfo[] getPropertyInfo(
1:             String url,
1:             Properties properties) throws SQLException {
1: 
1:         DriverPropertyInfo driverPropertyInfo[] = new DriverPropertyInfo[2];
1:             properties = new Properties();
1:             new DriverPropertyInfo(
1:                 new DriverPropertyInfo(Attribute.PASSWORD_ATTR,
/////////////////////////////////////////////////////////////////////////
1:     private static int tokenizeProtocol(
1:             String url,
1:             StringTokenizer urlTokenizer) throws SqlException {
1: 
/////////////////////////////////////////////////////////////////////////
1:         } catch (NoSuchElementException e) {
1:     private static String tokenizeServerName(StringTokenizer urlTokenizer,
/////////////////////////////////////////////////////////////////////////
1:         } catch (NoSuchElementException e) {
/////////////////////////////////////////////////////////////////////////
1:     private static int tokenizeOptionalPortNumber(StringTokenizer urlTokenizer,
/////////////////////////////////////////////////////////////////////////
1:         } catch (NoSuchElementException e) {
/////////////////////////////////////////////////////////////////////////
1:     private static String tokenizeDatabase(StringTokenizer urlTokenizer,
1:         } catch (NoSuchElementException e) {
1:     private static Properties tokenizeURLProperties(String url,
1:                                                     Properties properties)
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.LogWriter;
1: import org.apache.derby.client.net.NetConnection;
0: import org.apache.derby.client.net.NetLogWriter;
/////////////////////////////////////////////////////////////////////////
1:         NetConnection conn;
/////////////////////////////////////////////////////////////////////////
1:             LogWriter dncLogWriter =
/////////////////////////////////////////////////////////////////////////
1:             conn = (NetConnection)getFactory().
0:                     newNetConnection((NetLogWriter)
commit:508f8f6
/////////////////////////////////////////////////////////////////////////
1:         SqlException ole = Configuration.getExceptionOnLoadResources();
1:         
1:         if (ole != null) {
1:             SQLException e = ole.getSQLException();
1:                 Utils.accumulateSQLException(e, exceptionsOnLoadDriver__);
1:         
commit:2913612
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * The client JDBC driver (type 4) for Derby.
1:  */
commit:8269b78
/////////////////////////////////////////////////////////////////////////
0:                 port = ClientBaseDataSourceRoot.propertyDefault_portNumber;
/////////////////////////////////////////////////////////////////////////
1:                 traceLevel =
0:                     ClientBaseDataSourceRoot.getTraceLevel(augmentedProperties);
/////////////////////////////////////////////////////////////////////////
0:                 ClientBaseDataSourceRoot.computeDncLogWriterForNewConnection(
0:                     java.sql.DriverManager.getLogWriter(),
0:                     ClientBaseDataSourceRoot.getTraceDirectory(
1:                         augmentedProperties),
0:                     ClientBaseDataSourceRoot.getTraceFile(
1:                         augmentedProperties),
0:                     ClientBaseDataSourceRoot.getTraceFileAppend(
1:                         augmentedProperties),
1:                     traceLevel,
1:                     "_driver",
1:                     traceFileSuffixIndex_++);
/////////////////////////////////////////////////////////////////////////
0:             new java.sql.DriverPropertyInfo(
1:                 Attribute.USERNAME_ATTR,
1:                 properties.getProperty(
1:                     Attribute.USERNAME_ATTR,
0:                     ClientBaseDataSourceRoot.propertyDefault_user));
/////////////////////////////////////////////////////////////////////////
1: 
0:         return ClientBaseDataSourceRoot.tokenizeAttributes(
1:             attributeString, properties);
/////////////////////////////////////////////////////////////////////////
0:         if (Configuration.supportsJDBC40()) {
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:6372907
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     newNetConnection(dncLogWriter,
commit:e1a79c3
/////////////////////////////////////////////////////////////////////////
1:                         e, url);
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.MALFORMED_URL), e, url);
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.MALFORMED_URL), e, url);
commit:9a0cdf1
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLFeatureNotSupportedException;
1: import java.util.logging.Logger;
/////////////////////////////////////////////////////////////////////////
1:         registerMe(new ClientDriver());
/////////////////////////////////////////////////////////////////////////
1:     ////////////////////////////////////////////////////////////////////
0:     //
1:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
0:     //
1:     ////////////////////////////////////////////////////////////////////
1: 
1:     public  Logger getParentLogger()
1:         throws SQLFeatureNotSupportedException
1:     {
1:         getFactory();
1:         throw (SQLFeatureNotSupportedException)
1:             (
1:              new SqlException( null, new ClientMessageId(SQLState.NOT_IMPLEMENTED), "getParentLogger" )
1:              ).getSQLException();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      *ClientJDBCObjectFactoryImpl42
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:efd17a1
/////////////////////////////////////////////////////////////////////////
1: 		for (Enumeration keys = augmentedProperties.propertyNames();
1: 			 keys.hasMoreElements() ;)
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6eb29f6
/////////////////////////////////////////////////////////////////////////
0:     static
1:     {
/////////////////////////////////////////////////////////////////////////
1:     }
0:     protected static void   registerMe( ClientDriver me )
1:     {
/////////////////////////////////////////////////////////////////////////
1:      * @param database - Short database name
1:      * @param augmentedProperties - Set of properties to append as attributes
1:      * @return databaseName + attributes (e.g. mydb;create=true) 
1:      */
1:     private String appendDatabaseAttributes(String database, Properties augmentedProperties) {
1:     
1:         StringBuffer longDatabase = new StringBuffer(database);
0:         for (Enumeration keys = augmentedProperties.propertyNames();
0:              keys.hasMoreElements() ;)
1:         {
1:             String key = (String) keys.nextElement();
1:             if (key.equals(Attribute.USERNAME_ATTR) || 
1:                 continue;
1:             longDatabase.append(";" + key + "=" + augmentedProperties.getProperty(key));
1:         }
1:         return longDatabase.toString();
1:     }
0:     public boolean acceptsURL(String url) throws java.sql.SQLException {
/////////////////////////////////////////////////////////////////////////
1:             // DERBY-618 - database name can contain spaces in the path
commit:41c14e5
/////////////////////////////////////////////////////////////////////////
0:         	// DERBY-618 - database name can contain spaces in the path
1:             String databaseName = urlTokenizer.nextToken("\t\n\r\f;");
commit:a36fdb7
/////////////////////////////////////////////////////////////////////////
1:         
0:         if(conn.isConnectionNull())
0:         	return null;
1:         
commit:82d721f
/////////////////////////////////////////////////////////////////////////
1: import java.util.Enumeration;
1: import java.util.Properties;
1: 
/////////////////////////////////////////////////////////////////////////
1:         // database is the database name and attributes.  This will be
1:         database = appendDatabaseAttributes(database,augmentedProperties);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Append attributes to the database name except for user/password 
0:      * which are sent as part of the protocol.
1:      * Other attributes will  be sent to the server with the database name
1:      * Assumes augmentedProperties is not null
1:      * 
0: 	 * @param database - Short database name
0: 	 * @param augmentedProperties - Set of properties to append as attributes
0: 	 * @return databaseName + attributes (e.g. mydb;create=true) 
1: 	 */
0: 	private String appendDatabaseAttributes(String database, Properties augmentedProperties) {
1: 	
0: 		StringBuffer longDatabase = new StringBuffer(database);
0: 		for (Enumeration keys = augmentedProperties.keys(); keys.hasMoreElements() ;)
0: 		{
0: 			String key = (String) keys.nextElement();
0: 			if (key.equals(ClientDataSource.propertyKey_user) || 
0: 				key.equals(ClientDataSource.propertyKey_password))
0: 				continue;
0: 			longDatabase.append(";" + key + "=" + augmentedProperties.getProperty(key));
1: 		}
0: 		return longDatabase.toString();
1: 	}
1: 
0: 	public boolean acceptsURL(String url) throws java.sql.SQLException {
0:         java.util.StringTokenizer urlTokenizer = 
0:         		new java.util.StringTokenizer(url, "/:=; \t\n\r\f", true);
/////////////////////////////////////////////////////////////////////////
1:     //return database name
0:             String databaseName = urlTokenizer.nextToken(" \t\n\r\f;");
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:6bc2e25
/////////////////////////////////////////////////////////////////////////
1:      * which are sent as part of the protocol, and SSL which is used 
1:      * locally in the client.
/////////////////////////////////////////////////////////////////////////
1:                 key.equals(Attribute.PASSWORD_ATTR) ||
1:                 key.equals(Attribute.SSL_ATTR))
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6dba60c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.MessageId;
/////////////////////////////////////////////////////////////////////////
1:             SqlException.getMessageUtil().getTextMessage(
1:                 MessageId.CONN_USERNAME_DESCRIPTION);
1:             SqlException.getMessageUtil().getTextMessage(
1:                 MessageId.CONN_PASSWORD_DESCRIPTION);
commit:2dcbe06
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.ClientMessageId;
1: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:                     new SqlException(null, 
1:                         new ClientMessageId(SQLState.JDBC_DRIVER_REGISTER)).getSQLException();
/////////////////////////////////////////////////////////////////////////
1:                     throw new SqlException(null, 
1:                         new ClientMessageId(SQLState.MALFORMED_URL),
0:                         url, e);
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(null, 
1:                     new ClientMessageId(SQLState.TRACELEVEL_FORMAT_INVALID), e);
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(null, 
1:                     new ClientMessageId(SQLState.MALFORMED_URL), url);
1:                 throw new SqlException(null, 
1:                     new ClientMessageId(SQLState.MALFORMED_URL), url);
/////////////////////////////////////////////////////////////////////////
1:                     throw new SqlException(null, 
1:                         new ClientMessageId(SQLState.MALFORMED_URL), url);
1:                 throw new SqlException(null, 
1:                     new ClientMessageId(SQLState.MALFORMED_URL), url);
1:             throw new SqlException(null, 
0:                 new ClientMessageId(SQLState.MALFORMED_URL), url, e);
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(null, 
0:                 new ClientMessageId(SQLState.MALFORMED_URL), url, e);
commit:d506170
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
1:     static private SQLException exceptionsOnLoadDriver__ = null;
/////////////////////////////////////////////////////////////////////////
0:                     Utils.accumulateSQLException(
0:                             Configuration.exceptionsOnLoadResources.getSQLException(),
/////////////////////////////////////////////////////////////////////////
0:                     new SqlException(null, "Error occurred while trying to register Dnc driver with JDBC 1 Driver Manager").getSQLException();
/////////////////////////////////////////////////////////////////////////
1:         try
0:         {
1:             if (exceptionsOnLoadDriver__ != null) {
1:                 throw exceptionsOnLoadDriver__;
1: 
1:             if (properties == null) {
0:                 properties = new java.util.Properties();
1:             }
1: 
0:             java.util.StringTokenizer urlTokenizer =
0:                     new java.util.StringTokenizer(url, "/:= \t\n\r\f", true);
1: 
1:             int protocol = tokenizeProtocol(url, urlTokenizer);
1:             if (protocol == 0) {
1:                 return null; // unrecognized database URL prefix.
1:             }
1: 
1:             String slashOrNull = null;
1:             if (protocol == DERBY_REMOTE_PROTOCOL) {
1:                 try {
1:                     slashOrNull = urlTokenizer.nextToken(":/");
0:                 } catch (java.util.NoSuchElementException e) {
1:                     // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:                     throw new SqlException(null, e, "Invalid database url syntax: " + url);
1:                 }
1:             }
1:             String server = tokenizeServerName(urlTokenizer, url);    // "/server"
1:             int port = tokenizeOptionalPortNumber(urlTokenizer, url); // "[:port]/"
1:             if (port == 0) {
0:                 port = ClientDataSource.propertyDefault_portNumber;
1:             }
1: 
0:             // database is the database name and attributes.  This will be
1:             // sent to network server as the databaseName
1:             String database = tokenizeDatabase(urlTokenizer, url); // "database"
0:             java.util.Properties augmentedProperties = tokenizeURLProperties(url, properties);
0:             database = appendDatabaseAttributes(database,augmentedProperties);
1: 
1:             int traceLevel;
1:             try {
0:                 traceLevel = ClientDataSource.getTraceLevel(augmentedProperties);
0:             } catch (java.lang.NumberFormatException e) {
1:                 // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:                 throw new SqlException(null, e, "trouble reading traceLevel connection property");
1:             }
1: 
1:             // Jdbc 1 connections will write driver trace info on a
1:             // driver-wide basis using the jdbc 1 driver manager log writer.
1:             // This log writer may be narrowed to the connection-level
1:             // This log writer will be passed to the agent constructor.
0:             org.apache.derby.client.am.LogWriter dncLogWriter =
0:                     ClientDataSource.computeDncLogWriterForNewConnection(java.sql.DriverManager.getLogWriter(),
0:                             ClientDataSource.getTraceDirectory(augmentedProperties),
0:                             ClientDataSource.getTraceFile(augmentedProperties),
0:                             ClientDataSource.getTraceFileAppend(augmentedProperties),
0:                             traceLevel,
0:                             "_driver",
0:                             traceFileSuffixIndex_++);
1: 
0:             org.apache.derby.client.net.NetConnection conn =
0:                     new org.apache.derby.client.net.NetConnection((org.apache.derby.client.net.NetLogWriter) dncLogWriter,
0:                             java.sql.DriverManager.getLoginTimeout(),
0:                             server,
0:                             port,
0:                             database,
0:                             augmentedProperties);
1: 
0:             if(conn.isConnectionNull())
0:                 return null;
1: 
0:             return conn;
1:         catch ( SqlException se )
0:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:         try
0:         {
0:             java.util.StringTokenizer urlTokenizer = 
0:                     new java.util.StringTokenizer(url, "/:=; \t\n\r\f", true);
1:             int protocol = tokenizeProtocol(url, urlTokenizer);
1:             return protocol != 0;
1:         }
0:         catch ( SqlException se )
0:         {
1:             throw se.getSQLException();
1:         }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ceb72fe
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.Attribute;
/////////////////////////////////////////////////////////////////////////
0: 			if (key.equals(Attribute.USERNAME_ATTR) || 
0: 				key.equals(Attribute.PASSWORD_ATTR))
/////////////////////////////////////////////////////////////////////////
0:                 new java.sql.DriverPropertyInfo(Attribute.USERNAME_ATTR,
0:                         properties.getProperty(Attribute.USERNAME_ATTR, ClientDataSource.propertyDefault_user));
0:                 new java.sql.DriverPropertyInfo(Attribute.PASSWORD_ATTR,
1:                         properties.getProperty(Attribute.PASSWORD_ATTR));
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.client.am.ResourceUtilities;
1: import org.apache.derby.client.am.Utils;
0: import org.apache.derby.client.resources.ResourceKeys;
0: public class ClientDriver implements java.sql.Driver {
1:     private transient int traceFileSuffixIndex_ = 0;
1:     private final static int DERBY_REMOTE_PROTOCOL = 1;
0:     static private SqlException exceptionsOnLoadDriver__ = null;
1:     // Keep track of the registere driver so that we can deregister it if we're a stored proc.
1:     static private ClientDriver registeredDriver__ = null;
0:     static {
0:         // This may possibly hit the race-condition bug of java 1.1.
1:         // The Configuration static clause should execute before the following line does.
0:         if (Configuration.exceptionsOnLoadResources != null) {
1:             exceptionsOnLoadDriver__ =
0:                     Utils.accumulateSQLException(Configuration.exceptionsOnLoadResources,
0:                             exceptionsOnLoadDriver__);
1:         try {
0:             registeredDriver__ = new ClientDriver();
0:             java.sql.DriverManager.registerDriver(registeredDriver__);
0:         } catch (java.sql.SQLException e) {
1:             // A null log writer is passed, because jdbc 1 sql exceptions are automatically traced
1:             exceptionsOnLoadDriver__ =
0:                     new SqlException(null, "Error occurred while trying to register Dnc driver with JDBC 1 Driver Manager");
1:             exceptionsOnLoadDriver__.setNextException(e);
1:         }
1:     public ClientDriver() {
0:     public java.sql.Connection connect(String url,
0:                                        java.util.Properties properties) throws java.sql.SQLException {
0:         if (exceptionsOnLoadDriver__ != null) {
0:             throw exceptionsOnLoadDriver__;
1:         }
1: 
1:         if (properties == null) {
0:             properties = new java.util.Properties();
1:         }
1: 
0:         java.util.StringTokenizer urlTokenizer =
0:                 new java.util.StringTokenizer(url, "/:= \t\n\r\f", true);
1: 
0:         int protocol = tokenizeProtocol(url, urlTokenizer);
0:         if (protocol == 0) {
0:             return null; // unrecognized database URL prefix.
1:         }
1: 
0:         String slashOrNull = null;
0:         if (protocol == DERBY_REMOTE_PROTOCOL) {
1:             try {
0:                 slashOrNull = urlTokenizer.nextToken(":/");
0:             } catch (java.util.NoSuchElementException e) {
1:                 // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:                 throw new SqlException(null, e, "Invalid database url syntax: " + url);
1:             }
1:         }
0:         String server = tokenizeServerName(urlTokenizer, url);    // "/server"
0:         int port = tokenizeOptionalPortNumber(urlTokenizer, url); // "[:port]/"
0:         if (port == 0) {
0:             port = ClientDataSource.propertyDefault_portNumber;
1:         }
1: 
0:         // longDatabase is the databaseName and attributes.  This will be
0:         // sent to network server as the databaseName
0:         String database = tokenizeDatabase(urlTokenizer, url); // "database"
0:         java.util.Properties augmentedProperties = tokenizeURLProperties(url, properties);
1: 
1: 
0:         int traceLevel;
1:         try {
0:             traceLevel = ClientDataSource.getTraceLevel(augmentedProperties);
0:         } catch (java.lang.NumberFormatException e) {
1:             // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:             throw new SqlException(null, e, "trouble reading traceLevel connection property");
1:         }
1: 
0:         // Jdbc 1 connections will write driver trace info on a
0:         // driver-wide basis using the jdbc 1 driver manager log writer.
0:         // This log writer may be narrowed to the connection-level
0:         // This log writer will be passed to the agent constructor.
0:         org.apache.derby.client.am.LogWriter dncLogWriter =
0:                 ClientDataSource.computeDncLogWriterForNewConnection(java.sql.DriverManager.getLogWriter(),
0:                         ClientDataSource.getTraceDirectory(augmentedProperties),
0:                         ClientDataSource.getTraceFile(augmentedProperties),
0:                         ClientDataSource.getTraceFileAppend(augmentedProperties),
0:                         traceLevel,
0:                         "_driver",
0:                         traceFileSuffixIndex_++);
1: 
0:         org.apache.derby.client.net.NetConnection conn =
0:                 new org.apache.derby.client.net.NetConnection((org.apache.derby.client.net.NetLogWriter) dncLogWriter,
0:                         java.sql.DriverManager.getLoginTimeout(),
0:                         server,
0:                         port,
0:                         database,
0:                         augmentedProperties);
0:         return conn;
1:     }
1: 
0:     public boolean acceptsURL(String url) throws java.sql.SQLException {
0:         java.util.StringTokenizer urlTokenizer = new java.util.StringTokenizer(url, "/:=; \t\n\r\f", true);
0:         int protocol = tokenizeProtocol(url, urlTokenizer);
0:         return protocol != 0;
1:     }
1: 
0:     public java.sql.DriverPropertyInfo[] getPropertyInfo(String url,
0:                                                          java.util.Properties properties) throws java.sql.SQLException {
0:         java.sql.DriverPropertyInfo driverPropertyInfo[] = new java.sql.DriverPropertyInfo[2];
1: 
1:         // If there are no properties set already,
1:         // then create a dummy properties just to make the calls go thru.
1:         if (properties == null) {
0:             properties = new java.util.Properties();
1:         }
1: 
1:         driverPropertyInfo[0] =
0:                 new java.sql.DriverPropertyInfo(ClientDataSource.propertyKey_user,
0:                         properties.getProperty(ClientDataSource.propertyKey_user, ClientDataSource.propertyDefault_user));
1: 
1:         driverPropertyInfo[1] =
0:                 new java.sql.DriverPropertyInfo(ClientDataSource.propertyKey_password,
0:                         properties.getProperty(ClientDataSource.propertyKey_password));
1: 
1:         driverPropertyInfo[0].description =
0:                 ResourceUtilities.getResource(ResourceKeys.propertyDescription__user);
1:         driverPropertyInfo[1].description =
0:                 ResourceUtilities.getResource(ResourceKeys.propertyDescription__password);
1: 
1:         driverPropertyInfo[0].required = true;
1:         driverPropertyInfo[1].required = false; // depending on the security mechanism
1: 
1:         return driverPropertyInfo;
1:     }
1: 
1:     public int getMajorVersion() {
1:         return Version.getMajorVersion();
1:     }
1: 
1:     public int getMinorVersion() {
1:         return Version.getMinorVersion();
1:     }
1: 
1:     public boolean jdbcCompliant() {
1:         return Configuration.jdbcCompliant;
1:     }
1: 
1:     // ----------------helper methods---------------------------------------------
1: 
1:     // Tokenize one of the following:
1:     //  "jdbc:derby:"
1:     // and return 0 if the protcol is unrecognized
1:     // return DERBY_PROTOCOL for "jdbc:derby"
0:     private static int tokenizeProtocol(String url, java.util.StringTokenizer urlTokenizer) throws SqlException {
1:         // Is this condition necessary, StringTokenizer constructor may do this for us
1:         if (url == null) {
1:             return 0;
1:         }
1: 
1:         if (urlTokenizer == null) {
1:             return 0;
1:         }
1: 
1:         try {
1:             String jdbc = urlTokenizer.nextToken(":");
1:             if (!jdbc.equals("jdbc")) {
1:                 return 0;
1:             }
1:             if (!urlTokenizer.nextToken(":").equals(":")) {
1:                 return 0; // Skip over the first colon in jdbc:derby:
1:             }
1:             String dbname = urlTokenizer.nextToken(":");
1:             int protocol = 0;
1:             if (dbname.equals("derby") && (url.indexOf("derby://") != -1)) {
1:                 // For Derby AS need to check for // since jdbc:derby: is also the
1:                 // embedded prefix
1:                 protocol = DERBY_REMOTE_PROTOCOL;
1:             } else {
1:                 return 0;
1:             }
1: 
1:             if (!urlTokenizer.nextToken(":").equals(":")) {
1:                 return 0; // Skip over the second colon in jdbc:derby:
1:             }
1: 
1:             return protocol;
0:         } catch (java.util.NoSuchElementException e) {
1:             return 0;
1:         }
1:     }
1: 
1:     // tokenize "/server" from URL jdbc:derby://server:port/
1:     // returns server name
0:     private static String tokenizeServerName(java.util.StringTokenizer urlTokenizer,
1:                                              String url) throws SqlException {
1:         try {
1:             if (!urlTokenizer.nextToken("/").equals("/"))
1:             // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:             {
0:                 throw new SqlException(null, "Invalid database url syntax: " + url);
1:             }
1:             return urlTokenizer.nextToken("/:");
0:         } catch (java.util.NoSuchElementException e) {
1:             // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:             throw new SqlException(null, e, "Invalid database url syntax: " + url);
1:         }
1:     }
1: 
1:     // tokenize "[:portNumber]/" from URL jdbc:derby://server[:port]/
1:     // returns the portNumber or zero if portNumber is not specified.
0:     private static int tokenizeOptionalPortNumber(java.util.StringTokenizer urlTokenizer,
1:                                                   String url) throws SqlException {
1:         try {
1:             String firstToken = urlTokenizer.nextToken(":/");
1:             if (firstToken.equals(":")) {
1:                 String port = urlTokenizer.nextToken("/");
1:                 if (!urlTokenizer.nextToken("/").equals("/")) {
1:                     // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:                     throw new SqlException(null, "Invalid database url syntax: " + url);
1:                 }
1:                 return Integer.parseInt(port);
1:             } else if (firstToken.equals("/")) {
1:                 return 0;
1:             } else {
1:                 // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:                 throw new SqlException(null, "Invalid database url syntax: " + url);
1:             }
0:         } catch (java.util.NoSuchElementException e) {
1:             // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:             throw new SqlException(null, e, "Invalid database url syntax: " + url);
1:         }
1:     }
1: 
0:     //return database name and attributes
0:     private static String tokenizeDatabase(java.util.StringTokenizer urlTokenizer,
1:                                            String url) throws SqlException {
1:         try {
0:             String databaseName = urlTokenizer.nextToken(" \t\n\r\f");
1:             return databaseName;
0:         } catch (java.util.NoSuchElementException e) {
1:             // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:             throw new SqlException(null, e, "Invalid database url syntax: " + url);
1:         }
1:     }
1: 
0:     private static java.util.Properties tokenizeURLProperties(String url,
0:                                                               java.util.Properties properties)
1:             throws SqlException {
1:         String attributeString = null;
1:         int attributeIndex = -1;
1: 
1:         if ((url != null) &&
1:                 ((attributeIndex = url.indexOf(";")) != -1)) {
1:             attributeString = url.substring(attributeIndex);
1:         }
0:         return ClientDataSource.tokenizeAttributes(attributeString, properties);
1:     }
1: 
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
0: 
1:    Derby - Class org.apache.derby.jdbc.ClientDriver
0: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
1:       http://www.apache.org/licenses/LICENSE-2.0
0: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
0: 
0: */
0: 
1: package org.apache.derby.jdbc;
0: 
0: import org.apache.derby.client.resources.ResourceKeys;
0: import org.apache.derby.client.am.ResourceUtilities;
0: import org.apache.derby.client.am.Utils;
1: import org.apache.derby.client.am.Configuration;
1: import org.apache.derby.client.am.SqlException;
1: import org.apache.derby.client.am.Version;
0: 
0: 
0: public class ClientDriver implements java.sql.Driver
0: {
0:   private transient int traceFileSuffixIndex_ = 0;
0: 
0:   private final static int DERBY_REMOTE_PROTOCOL = 1;
0: 
0:   static private SqlException exceptionsOnLoadDriver__ = null;
0:   // Keep track of the registere driver so that we can deregister it if we're a stored proc.
0:   static private ClientDriver registeredDriver__ = null;
0: 
0:   static {
0:     // This may possibly hit the race-condition bug of java 1.1.
0:     // The Configuration static clause should execute before the following line does.
0:     if (Configuration.exceptionsOnLoadResources != null) {
0:       exceptionsOnLoadDriver__ =
0:         Utils.accumulateSQLException (Configuration.exceptionsOnLoadResources,
0:                                       exceptionsOnLoadDriver__);
0:     }
0:     try {
0:       registeredDriver__ = new ClientDriver();
0:       java.sql.DriverManager.registerDriver (registeredDriver__);
0:     }
0:     catch (java.sql.SQLException e) {
0:       // A null log writer is passed, because jdbc 1 sql exceptions are automatically traced
0:       exceptionsOnLoadDriver__ =
0:         new SqlException (null, "Error occurred while trying to register Dnc driver with JDBC 1 Driver Manager");
0:       exceptionsOnLoadDriver__.setNextException (e);
0:     }
0:   }
0: 
0:   public ClientDriver() {}
0: 
0:   public java.sql.Connection connect (String url,
0:                                       java.util.Properties properties) throws java.sql.SQLException
0:   {
0:     if (exceptionsOnLoadDriver__ != null) throw exceptionsOnLoadDriver__;
0: 
0:     if (properties == null) properties = new java.util.Properties();
0: 
0:     java.util.StringTokenizer urlTokenizer =
0:       new java.util.StringTokenizer (url, "/:= \t\n\r\f", true);
0: 
0:     int protocol = tokenizeProtocol (url, urlTokenizer);
0:     if (protocol == 0) return null; // unrecognized database URL prefix.
0: 
0:     String slashOrNull = null;
0:     if (protocol == DERBY_REMOTE_PROTOCOL) {
0:       try {
0:         slashOrNull = urlTokenizer.nextToken (":/");
0:       }
0:       catch (java.util.NoSuchElementException e) {
0:         // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:         throw new SqlException (null, e, "Invalid database url syntax: " + url);
0:       }
0:     }
0:       String server = tokenizeServerName (urlTokenizer, url);    // "/server"
0:       int port = tokenizeOptionalPortNumber (urlTokenizer, url); // "[:port]/"
0:       if (port == 0)
0:           port = ClientDataSource.propertyDefault_portNumber;
0: 
0: 	  // longDatabase is the databaseName and attributes.  This will be 
0: 	  // sent to network server as the databaseName
0:       String database = tokenizeDatabase (urlTokenizer, url); // "database"
0: 	 java.util.Properties  augmentedProperties = tokenizeURLProperties (url, properties);
0: 
0: 	 
0:       int traceLevel;
0:       try {
0:         traceLevel = ClientDataSource.getTraceLevel (augmentedProperties);
0:       }
0:       catch (java.lang.NumberFormatException e) {
0:         // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:         throw new SqlException (null, e, "trouble reading traceLevel connection property");
0:       }
0: 
0:       // Jdbc 1 connections will write driver trace info on a
0:       // driver-wide basis using the jdbc 1 driver manager log writer.
0:       // This log writer may be narrowed to the connection-level
0:       // This log writer will be passed to the agent constructor.
0:       org.apache.derby.client.am.LogWriter dncLogWriter =
0:         ClientDataSource.computeDncLogWriterForNewConnection (
0:           java.sql.DriverManager.getLogWriter(),
0:           ClientDataSource.getTraceDirectory (augmentedProperties),
0:           ClientDataSource.getTraceFile (augmentedProperties),
0:           ClientDataSource.getTraceFileAppend (augmentedProperties),
0:           traceLevel,
0:           "_driver",
0:           traceFileSuffixIndex_++);
0: 
0:       org.apache.derby.client.net.NetConnection conn =
0:         new org.apache.derby.client.net.NetConnection (
0:           (org.apache.derby.client.net.NetLogWriter) dncLogWriter,
0:           java.sql.DriverManager.getLoginTimeout(),
0:           server,
0:           port,
0:           database,
0:           augmentedProperties);
0:       return conn;
0:   }
0: 
0:   public boolean acceptsURL (String url) throws java.sql.SQLException
0:   {
0:     java.util.StringTokenizer urlTokenizer = new java.util.StringTokenizer (url, "/:=; \t\n\r\f", true);
0:     int protocol = tokenizeProtocol (url, urlTokenizer);
0:     return protocol != 0;
0:   }
0: 
0:   public java.sql.DriverPropertyInfo[] getPropertyInfo (String url,
0:                                                         java.util.Properties properties) throws java.sql.SQLException
0:   {
0:     java.sql.DriverPropertyInfo driverPropertyInfo[] = new java.sql.DriverPropertyInfo[2];
0: 
0:     // If there are no properties set already,
0:     // then create a dummy properties just to make the calls go thru.
0:     if (properties == null)
0:       properties = new java.util.Properties ();
0: 
0:     driverPropertyInfo[0] =
0:       new java.sql.DriverPropertyInfo (ClientDataSource.propertyKey_user,
0:                                        properties.getProperty (ClientDataSource.propertyKey_user,ClientDataSource.propertyDefault_user));
0: 
0:     driverPropertyInfo[1] =
0:       new java.sql.DriverPropertyInfo (ClientDataSource.propertyKey_password,
0:                                        properties.getProperty (ClientDataSource.propertyKey_password));
0: 
0:     driverPropertyInfo[0].description =
0:       ResourceUtilities.getResource (ResourceKeys.propertyDescription__user);
0:     driverPropertyInfo[1].description =
0:       ResourceUtilities.getResource (ResourceKeys.propertyDescription__password);
0: 
0:     driverPropertyInfo[0].required = true;
0:     driverPropertyInfo[1].required = false; // depending on the security mechanism
0: 
0:     return driverPropertyInfo;
0:   }
0: 
0:   public int getMajorVersion()
0:   {
0:     return Version.getMajorVersion();
0:   }
0: 
0:   public int getMinorVersion()
0:   {
0:     return Version.getMinorVersion();
0:   }
0: 
0:   public boolean jdbcCompliant()
0:   {
0:     return Configuration.jdbcCompliant;
0:   }
0: 
0:   // ----------------helper methods---------------------------------------------
0: 
0:   // Tokenize one of the following:
0:   //  "jdbc:derby:"
0:   // and return 0 if the protcol is unrecognized
0:   // return DERBY_PROTOCOL for "jdbc:derby"
0:   private static int tokenizeProtocol (String url, java.util.StringTokenizer urlTokenizer) throws SqlException
0:   {
0:     // Is this condition necessary, StringTokenizer constructor may do this for us
0:     if (url == null) return 0;
0: 
0:     if (urlTokenizer == null) return 0;
0: 
0:     try {
0:       String jdbc = urlTokenizer.nextToken (":");
0:       if (!jdbc.equals ("jdbc")) return 0;
0:       if (!urlTokenizer.nextToken (":").equals (":"))
0:         return 0; // Skip over the first colon in jdbc:derby:
0:       String dbname = urlTokenizer.nextToken (":");
0:       int protocol = 0;
0:       if (dbname.equals("derby") && (url.indexOf("derby://") != -1)){
0: 		  // For Derby AS need to check for // since jdbc:derby: is also the
0: 		  // embedded prefix
0: 		protocol = DERBY_REMOTE_PROTOCOL;
0:       }
0:       else
0:          return 0;
0: 
0:       if (!urlTokenizer.nextToken (":").equals (":") )
0:         return 0; // Skip over the second colon in jdbc:derby:
0: 
0:       return protocol;
0:     }
0:     catch (java.util.NoSuchElementException e) {
0:       return 0;
0:     }
0:   }
0: 
0:   // tokenize "/server" from URL jdbc:derby://server:port/
0:   // returns server name
0:   private static String tokenizeServerName (java.util.StringTokenizer urlTokenizer,
0:                                                    String url) throws SqlException
0:   {
0:     try {
0:       if (!urlTokenizer.nextToken("/").equals ("/"))
0:         // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:         throw new SqlException (null, "Invalid database url syntax: " + url);
0:       return urlTokenizer.nextToken ("/:");
0:     }
0:     catch (java.util.NoSuchElementException e) {
0:       // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:       throw new SqlException (null, e, "Invalid database url syntax: " + url);
0:     }
0:   }
0: 
0:   // tokenize "[:portNumber]/" from URL jdbc:derby://server[:port]/
0:   // returns the portNumber or zero if portNumber is not specified.
0:   private static int tokenizeOptionalPortNumber (java.util.StringTokenizer urlTokenizer,
0:                                                    String url) throws SqlException
0:   {
0:     try {
0:       String firstToken = urlTokenizer.nextToken(":/");
0:       if (firstToken.equals (":")) {
0:         String port = urlTokenizer.nextToken ("/");
0:         if (!urlTokenizer.nextToken ("/").equals ("/")) {
0:           // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:           throw new SqlException (null, "Invalid database url syntax: " + url);
0:         }
0:         return Integer.parseInt (port);
0:       }
0:       else if (firstToken.equals ("/")) {
0:         return 0;
0:       }
0:       else {
0:         // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:         throw new SqlException (null, "Invalid database url syntax: " + url);
0:       }
0:     }
0:     catch (java.util.NoSuchElementException e) {
0:       // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:       throw new SqlException (null, e, "Invalid database url syntax: " + url);
0:     }
0:   }
0: 
0:   //return database name and attributes
0:   private static String tokenizeDatabase (java.util.StringTokenizer urlTokenizer,
0:                                           String url) throws SqlException
0:   {
0:     try {
0:       String databaseName = urlTokenizer.nextToken (" \t\n\r\f");
0:       return databaseName;
0:     }
0:     catch (java.util.NoSuchElementException e) {
0:       // A null log writer is passed, because jdbc 1 sqlexceptions are automatically traced
0:       throw new SqlException (null, e, "Invalid database url syntax: " + url);
0:     }
0:   }
0: 
0:   private static java.util.Properties tokenizeURLProperties (String url,
0:                                                java.util.Properties properties)
0: 	  throws SqlException
0: 	{
0: 		String attributeString = null;
0: 		int attributeIndex = -1;
0: 		
0: 		if ((url != null) && 
0: 			((attributeIndex = url.indexOf(";")) != -1))
0: 			attributeString = url.substring(attributeIndex);
0: 		return ClientDataSource.tokenizeAttributes(attributeString, properties);
0: 	}
0:  
0: 
0: }
0: 
0: 
0: 
============================================================================