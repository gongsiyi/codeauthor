1:b64ccfc: /*
1:ee7f668:  
1:b64ccfc:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.ConnectionTest
19:b64ccfc:  
1:6e3dbab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6e3dbab:    contributor license agreements.  See the NOTICE file distributed with
1:6e3dbab:    this work for additional information regarding copyright ownership.
1:6e3dbab:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6e3dbab:    (the "License"); you may not use this file except in compliance with
1:6e3dbab:    the License.  You may obtain a copy of the License at
1:b64ccfc:  
1:b64ccfc:       http://www.apache.org/licenses/LICENSE-2.0
1:b64ccfc:  
1:b64ccfc:    Unless required by applicable law or agreed to in writing, software
1:b64ccfc:    distributed under the License is distributed on an "AS IS" BASIS,
1:b64ccfc:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b64ccfc:    See the License for the specific language governing permissions and
1:b64ccfc:    limitations under the License.
1:b64ccfc:  
12:b64ccfc:  */
1:b64ccfc: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:b64ccfc: 
1:1ae02c9: import java.sql.Blob;
1:1ae02c9: import java.sql.ClientInfoStatus;
1:1ae02c9: import java.sql.Clob;
1:1ae02c9: import java.sql.Connection;
1:1ae02c9: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.ResultSet;
1:1ae02c9: import java.sql.SQLClientInfoException;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.SQLFeatureNotSupportedException;
1:1ae02c9: import java.sql.Statement;
1:2add32c: import java.util.ArrayList;
1:c85d465: import java.util.HashMap;
1:91a8a21: import java.util.List;
1:2add32c: import java.util.Map;
1:b64ccfc: import java.util.Properties;
1:1ae02c9: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:b64ccfc: 
1:8846963: /**
1:b64ccfc:  * Tests for the JDBC 4.0 specific methods in the connection object(s).
1:94057f1:  * 
1:94057f1:  * Which connection implementation is tested, depends on what connection
1:94057f1:  * object the <code>BaseJDBCTestCase.getConnection()</code>-method returns.
1:94057f1:  * Currently, the property <code>derbyTesting.xa.single</code> can be set to
1:94057f1:  * <code>true</code> to test the XA connection object, which happens to be the
1:94057f1:  * same as the one used for poooled connections.
1:94057f1:  * The connection returned also depends on which framework is being used.
1:b64ccfc:  */
1:b64ccfc: public class ConnectionTest
1:b64ccfc:     extends BaseJDBCTestCase {
1:b64ccfc: 
12:b64ccfc:     /**
3:b64ccfc:      * Create a test with the given name.
1:97cf694:      * 
3:b64ccfc:      * @param name name of the test.
1:b64ccfc:      */
1:b64ccfc:     public ConnectionTest(String name) {
3:b64ccfc:         super(name);
18:b64ccfc:     }
1:2add32c:    
1:b64ccfc:     //------------------------- T E S T  M E T H O D S ------------------------
1:b64ccfc:     
1:1861dba:     /**
1:8846963:      *
1:8846963:      * Tests the Embedded implementation for the createBlob method. The Embedded
1:8846963:      * server does'nt currently have the set methods implemented. Hence the 
1:8846963:      * create methods cannot be tested by inserting data into the empty LOB 
1:8846963:      * object. Here we do a simple test of checking that the length of the 
1:8846963:      * LOB object is 0.
1:8846963:      *
1:8846963:      * @throws SQLException upon failure in the createBlob or the length 
1:8846963:      *         methods.
1:8846963:      *
1:8846963:      */
1:8846963:     public void embeddedCreateBlob()
6:b64ccfc:         throws SQLException {
1:03a99e2:             Blob blob = getConnection().createBlob();
1:8846963:             //Check if the blob is empty
1:8846963:             if(blob.length() > 0)
1:8846963:                 fail("The new Blob should not have more than zero bytes " +
1:8846963:                         "contained in it");
1:b64ccfc:     }
1:b64ccfc:     
1:8846963:     /**
1:8846963:      *
1:8846963:      * Tests the Embedded implementation for the createClob method. The Embedded
1:8846963:      * server does'nt currently have the set methods implemented. Hence the 
1:8846963:      * create methods cannot be tested by inserting data into the empty LOB 
1:8846963:      * object. Here we do a simple test of checking that the length of the 
1:8846963:      * LOB object is 0.
1:8846963:      *
1:8846963:      * @throws SQLException upon failure in the createClob or the length 
1:8846963:      *         methods.
1:8846963:      *
1:8846963:      */
1:8846963:     public void embeddedCreateClob()
1:b64ccfc:         throws SQLException {
1:03a99e2:             Clob clob = getConnection().createClob();
1:8846963:             //check if the Clob is empty
1:8846963:             if(clob.length() > 0)
1:8846963:                 fail("The new Clob should not have a length of greater than " +
1:8846963:                         "zero");
1:b64ccfc:     }
1:b64ccfc: 
1:97cf694:     public void testCreateArrayNotImplemented()
1:97cf694:         throws SQLException {
1:2add32c:         try {
1:03a99e2:             getConnection().createArrayOf(null, null);
1:7c3b39d:             fail("createArrayOf(String,Object[]) should not be implemented");
1:97cf694:         } catch (SQLFeatureNotSupportedException sfnse) {
1:97cf694:             // Do nothing, we are fine
1:97cf694:         }
1:97cf694:     }
1:97cf694: 
1:b64ccfc:     public void testCreateNClobNotImplemented()
1:b64ccfc:         throws SQLException {
1:97cf694:         try {
1:03a99e2:             getConnection().createNClob();
1:b64ccfc:             fail("createNClob() should not be implemented");
6:b64ccfc:         } catch (SQLFeatureNotSupportedException sfnse) {
6:b64ccfc:             // Do nothing, we are fine
1:b64ccfc:         }
1:b64ccfc:     }
1:b64ccfc: 
1:b64ccfc:     public void testCreateSQLXMLNotImplemented()
1:b64ccfc:         throws SQLException {
6:b64ccfc:         try {
1:03a99e2:             getConnection().createSQLXML();
1:b64ccfc:             fail("createSQLXML() should not be implemented");
1:b64ccfc:         } catch (SQLFeatureNotSupportedException sfnse) {
1:b64ccfc:             // Do nothing, we are fine
1:b64ccfc:         }
1:b64ccfc:     }
1:b64ccfc: 
1:97cf694:     public void testCreateStructNotImplemented()
1:97cf694:         throws SQLException {
1:97cf694:         try {
1:03a99e2:             getConnection().createStruct(null, null);
1:97cf694:             fail("createStruct(String,Object[]) should not be implemented");
1:97cf694:         } catch (SQLFeatureNotSupportedException sfnse) {
1:97cf694:             // Do nothing, we are fine
1:97cf694:         }
1:97cf694:     }
1:97cf694:     
1:7bac3b3:     public void testGetClientInfo()
1:b64ccfc:         throws SQLException {
1:7bac3b3:         assertTrue("getClientInfo() must return an empty Properties object", 
1:03a99e2:                    getConnection().getClientInfo().isEmpty());
1:b64ccfc:     }
1:b64ccfc:     
1:7bac3b3:     public void testGetClientInfoString()
1:b64ccfc:         throws SQLException {
1:7bac3b3:         assertNull("getClientInfo(null) must return null",
1:03a99e2:                    getConnection().getClientInfo(null));
1:7bac3b3:         assertNull("getClientInfo(\"someProperty\") must return null",
1:03a99e2:                    getConnection().getClientInfo("someProperty"));
1:b64ccfc:     }
1:b64ccfc: 
1:b64ccfc:     /**
1:75194ba:      * Tests that <code>isValid</code> is implemented and returns true
1:75194ba:      * for the connection. This test is very limited but is tested
1:75194ba:      * for all connection types. A more complete test of isValid is
1:ad188f4:      * found in the ConnectionMethodsTest.java test that is run for
1:94057f1:      * embedded and network client connections.
1:75194ba:      */
1:75194ba:     public void testIsValidImplemented() throws SQLException {
1:75194ba:         // Test with an infinite (0) timeout
1:03a99e2:         assertTrue(getConnection().isValid(0));
1:75194ba: 
1:ea6232d:         // Test with a large timeout. We expect
1:ea6232d:         // to complete and succeed much sooner.
1:ea6232d:         // see DERBY-5912
1:ea6232d:         assertTrue(getConnection().isValid(200));
1:75194ba: 
1:75194ba:         // Test with an illegal timeout
1:75194ba:         try {
1:03a99e2:             getConnection().isValid(-1);
1:75194ba:         } catch (SQLException sqle) {
1:75194ba:             assertSQLState("Incorrect SQL state when calling isValid(-1)",
1:75194ba:                            "XJ081", sqle);
1:75194ba:         }
1:75194ba:     }
1:ad188f4:     
1:ad188f4:     /**
1:ad188f4:      * Tests that <code>isValid</code> times out when expected.
1:ad188f4:      * This test will need a modification to the source code;
1:ad188f4:      * activate the commented out Thread.sleep(2000) (2 seconds) in 
1:ad188f4:      * DRDAConnThread.ProcessCommands, case CodePoint.OPNQRY
1:ad188f4:      * To activate the test, remove the extra 'x' before building
1:ad188f4:      */
1:ad188f4:     public void xtestIsValidWithTimeout() throws SQLException {
1:ad188f4:         // isValid(timeoutvalue) is a no-op in Embedded
1:ad188f4:         if (usingEmbedded()) {
1:ad188f4:             return;
1:ad188f4:         }
1:ad188f4:         // Test with a large timeout, see DERBY-5912.
1:ad188f4:         boolean convalid=true;
1:ad188f4:         Connection conn=getConnection();
1:ad188f4: 
1:ad188f4:         // with a longer time out, the isValid call should not
1:ad188f4:         // time out when the sleep is shorter.
1:ad188f4:         convalid=conn.isValid(200);
1:ad188f4:         assertTrue(convalid);
1:ad188f4: 
1:ad188f4:         // setting the timeout to 1 should timeout if the sleep
1:ad188f4:         // is 2 seconds.
1:ad188f4:         convalid=conn.isValid(1);
1:ad188f4:         assertFalse(convalid);
1:ad188f4: 
1:ad188f4:         // rollback should work even though isvalid timed out...
1:ad188f4:         // But there's a bug in that the connection becomes invalid and
1:ad188f4:         // it is not getting re-established, see DERBY-5919. 
1:ad188f4:         // Catch the exception saying No current Connection and swallow.
1:ad188f4:         try {
1:ad188f4:             conn.rollback();
1:ad188f4:             //conn.close();
1:ad188f4:         } catch (Exception e) {
1:ad188f4:             //println("exception: " + e.getStackTrace());
1:ad188f4:         }
1:ad188f4:     }
1:75194ba: 
1:75194ba:     /**
1:1861dba:      * Tests that <code>getTypeMap()</code> returns an empty map when
1:1861dba:      * no type map has been installed.
1:1861dba:      * @exception SQLException if an error occurs
1:1861dba:      */
1:1861dba:     public void testGetTypeMapReturnsEmptyMap() throws SQLException {
1:03a99e2:         assertTrue(getConnection().getTypeMap().isEmpty());
1:1861dba:     }
1:1861dba:     
1:2add32c:     /**
1:2add32c:      * Tests that <code>getTypeMap()</code> returns the input map
1:2add32c:      * @exception SQLException if an error occurs
1:2add32c:      */
1:91a8a21:     public void testGetTypeMapReturnsAsExpected() throws SQLException {
1:2add32c:         Statement s = getConnection().createStatement();
1:2add32c:         int ret;
1:2add32c:         try {
1:2add32c:             ret = s.executeUpdate("DROP TABLE T1");
1:2add32c:             ret = s.executeUpdate("DROP TYPE JAVA_UTIL_LIST RESTRICT");
1:2add32c:         } catch (Exception e) {}
1:2add32c:         
1:2add32c:         ret = s.executeUpdate("CREATE TYPE JAVA_UTIL_LIST " +
1:2add32c:                               "EXTERNAL NAME 'java.util.List'" +
1:2add32c:                               "LANGUAGE JAVA");
1:2add32c: 
1:2add32c:         s.execute("CREATE TABLE T1 (A1 JAVA_UTIL_LIST)");
1:2add32c:         
1:2add32c:         PreparedStatement ps = getConnection().prepareStatement(
1:2add32c:                 "INSERT INTO T1(A1) VALUES (?)");
1:2add32c:         
1:91a8a21:         ArrayList<String> lst = new ArrayList<String>();
1:2add32c:         lst.add("First element");
1:2add32c:         lst.add("Second element");
1:2add32c:         
1:2add32c:         ps.setObject(1, lst);
1:2add32c:         ps.execute();     
1:2add32c:         
1:2add32c:         Map<String, Class<?>> map = getConnection().getTypeMap();
1:c85d465:         try {
1:c85d465:             map.put("JAVA_UTIL_LIST", List.class);
1:c85d465:             fail("returned map should be immutable");
1:c85d465:         } catch (UnsupportedOperationException uoe) {
1:c85d465:             // Ignore expected exception
1:c85d465:         }
1:036a7e5:         
1:036a7e5:         //Pass empty Map to setTypeMap(). It won't raise any erros because
1:036a7e5:         //the method does nothing when the Map is empty.
1:036a7e5:         java.util.Map<String,Class<?>> emptyMap = new java.util.HashMap<String,Class<?>>();
1:036a7e5:         getConnection().setTypeMap(emptyMap);
1:c85d465: 
1:c85d465:         // Create a non-empty map to test setTypeMap(). setTypeMap() raises
1:c85d465:         // a feature not supported exception if the map isn't empty.
1:c85d465:         map = new HashMap<String, Class<?>>();
1:91a8a21:         map.put("JAVA_UTIL_LIST", List.class);
1:2add32c:         
1:2add32c:         try {
1:2add32c:             getConnection().setTypeMap(map);
1:2add32c:             fail( "Should raise an Unimplemented Feature exception." );
1:2add32c:         }
1:2add32c:         catch (SQLException se)
1:2add32c:         {
1:2add32c:             assertEquals( SQLFeatureNotSupportedException.class.getName(), se.getClass().getName() );
1:2add32c:         }
1:2add32c:         
1:2add32c:         ResultSet rs = s.executeQuery("select * from T1");
1:2add32c:         assertTrue(rs.next());
1:2add32c:         for (int i = 1; i <= rs.getMetaData().getColumnCount(); i++) {
1:2add32c:             Object o = rs.getObject(i);
1:2add32c:             assertEquals(lst, o);
1:2add32c:             //System.out.print(o + "(Type " + o.getClass().getName() + " )");
1:2add32c:         }
1:2add32c:         s.executeUpdate("DROP TABLE T1");
1:2add32c:         s.executeUpdate("DROP TYPE JAVA_UTIL_LIST RESTRICT");
1:2add32c:         s.close();
1:2add32c:         ps.close();
1:2add32c:     }
1:b64ccfc: 
1:b64ccfc:     public void testIsWrapperReturnsFalse()
1:b64ccfc:         throws SQLException {
1:03a99e2:         assertFalse(getConnection().isWrapperFor(ResultSet.class));
1:2add32c:     }
1:b64ccfc: 
1:b64ccfc:     public void testIsWrapperReturnsTrue()
1:b64ccfc:         throws SQLException {
1:03a99e2:         assertTrue(getConnection().isWrapperFor(Connection.class));
1:b64ccfc:     }
1:b64ccfc: 
1:7bac3b3:     public void testSetClientInfoProperties()
1:b64ccfc:         throws SQLException {
1:03a99e2:         getConnection().setClientInfo(null);
1:7bac3b3:         Properties p = new Properties();
1:03a99e2:         getConnection().setClientInfo(p);
1:7bac3b3: 
1:7bac3b3:         p.setProperty("prop1", "val1");
1:7bac3b3:         p.setProperty("prop2", "val2");
1:b64ccfc:         try {
1:03a99e2:             getConnection().setClientInfo(p);
1:7bac3b3:             fail("setClientInfo(String,String) should throw "+
1:7c3b39d:                  "SQLClientInfoException");
1:7c3b39d:         } catch (SQLClientInfoException cie) {
1:7bac3b3:             assertSQLState("SQLStates must match", "XCY02", cie);
1:7bac3b3:             assertTrue("Setting property 'prop1' must fail with "+
2:7bac3b3:                        "REASON_UNKNOWN_PROPERTY",
2:7bac3b3:                        cie.getFailedProperties().
1:7c3b39d:                        get("prop1").
1:7c3b39d:                        equals(ClientInfoStatus.REASON_UNKNOWN_PROPERTY));
1:7c3b39d:              assertTrue("Setting property 'prop2' must fail with "+
1:7c3b39d:                         "REASON_UNKNOWN_PROPERTY",
1:7c3b39d:                         cie.getFailedProperties().
1:7c3b39d:                         get("prop2").
1:7c3b39d:                         equals(ClientInfoStatus.REASON_UNKNOWN_PROPERTY));
1:b64ccfc:         }
1:b64ccfc:     }
1:b64ccfc: 
1:7bac3b3:     public void testSetClientInfoString()
1:b64ccfc:         throws SQLException {
1:03a99e2:         getConnection().setClientInfo(null, null);
1:7bac3b3: 
1:7bac3b3:         try {
1:03a99e2:             getConnection().setClientInfo("foo", null);
1:7bac3b3:             fail("setClientInfo(String, null) should throw "+
1:7bac3b3:                  "NullPointerException");
1:7bac3b3:         } catch (NullPointerException npe) {}
1:7bac3b3: 
1:b64ccfc:         try {
1:03a99e2:             getConnection().setClientInfo("name", "value");
1:7bac3b3:             fail("setClientInfo(String,String) should throw "+
1:7c3b39d:                  "SQLClientInfoException");
1:7c3b39d:         } catch (SQLClientInfoException cie) {
1:7bac3b3:             assertSQLState("SQLState must match 'unsupported'",
1:7bac3b3:                            "XCY02", cie);
1:7bac3b3:             assertTrue("Setting property 'name' must fail with "+
1:7bac3b3:                        "REASON_UNKNOWN_PROPERTY",
1:7bac3b3:                        cie.getFailedProperties().
1:7c3b39d:                        get("name").
1:7c3b39d:                        equals(ClientInfoStatus.REASON_UNKNOWN_PROPERTY));
1:b64ccfc:         }
1:b64ccfc:     }
1:b64ccfc:     
1:b64ccfc:     public void testUnwrapValid()
1:b64ccfc:         throws SQLException {
1:03a99e2:         Connection unwrappedCon = getConnection().unwrap(Connection.class);
1:03a99e2:         assertSame("Unwrap returned wrong object.", getConnection(), unwrappedCon);
1:b64ccfc:     }
1:b64ccfc: 
1:b64ccfc:     public void testUnwrapInvalid()
1:b64ccfc:         throws SQLException {
1:b64ccfc:         try {
1:03a99e2:             ResultSet unwrappedRs = getConnection().unwrap(ResultSet.class);
1:b64ccfc:             fail("unwrap should have thrown an exception");
1:b64ccfc:         } catch (SQLException sqle) {
1:b64ccfc:             assertSQLState("Incorrect SQL state when unable to unwrap",
1:b64ccfc:                            SQLStateConstants.UNABLE_TO_UNWRAP,
1:b64ccfc:                            sqle);
1:b64ccfc:         }
1:b64ccfc:     }
1:b64ccfc:         
1:b64ccfc:     //------------------ E N D  O F  T E S T  M E T H O D S -------------------
1:b64ccfc: 
1:b64ccfc:     /**
1:b64ccfc:      * Create suite containing client-only tests.
1:b64ccfc:      */
1:1ae02c9:     private static BaseTestSuite clientSuite(String name) {
1:1ae02c9:         BaseTestSuite clientSuite = new BaseTestSuite(name);
1:b64ccfc:         return clientSuite; 
1:b64ccfc:     }
1:b64ccfc:     
1:b64ccfc:     /**
1:b64ccfc:      * Create suite containing embedded-only tests.
1:b64ccfc:      */
1:1ae02c9:     private static BaseTestSuite embeddedSuite(String name) {
1:1ae02c9:         BaseTestSuite embeddedSuite = new BaseTestSuite(name);
1:b64ccfc:         embeddedSuite.addTest(new ConnectionTest(
1:8846963:                     "embeddedCreateBlob"));
1:b64ccfc:         embeddedSuite.addTest(new ConnectionTest(
1:8846963:                     "embeddedCreateClob"));
1:b64ccfc:         return embeddedSuite;
1:b64ccfc:     }
1:b64ccfc:     
1:b64ccfc:     /**
1:94057f1:      * Create a test suite containing tests for a JDB connection.
1:97cf694:      *  In addition, separate suites for embedded- and client-only are added
1:94057f1:      *  when appropriate.
1:b64ccfc:      */
1:b64ccfc:     public static Test suite() {
1:1ae02c9:         BaseTestSuite connSuite = new BaseTestSuite("ConnectionTest suite");
1:ec5ae26: 
1:1ae02c9:         BaseTestSuite embedded = new BaseTestSuite("ConnectionTest:embedded");
1:ec5ae26:         embedded.addTestSuite(ConnectionTest.class);
1:ec5ae26:         embedded.addTest(embeddedSuite("ConnectionTest:embedded-only"));
1:ec5ae26:         connSuite.addTest(embedded);
1:ec5ae26:         
1:ee7f668:         // repeat the embedded tests obtaining a connection from
1:ee7f668:         // an XA data source.
1:1ae02c9:         embedded = new BaseTestSuite("ConnectionTest:embedded XADataSource");
1:ee7f668:         embedded.addTestSuite(ConnectionTest.class);
1:ee7f668:         embedded.addTest(embeddedSuite("ConnectionTest:embedded-only XADataSource"));
1:ee7f668:         connSuite.addTest(TestConfiguration.connectionXADecorator(embedded));
1:ee7f668:         
1:b64ccfc: 
1:1ae02c9:         BaseTestSuite client = new BaseTestSuite("ConnectionTest:client");
1:ec5ae26:         client.addTestSuite(ConnectionTest.class);
1:ec5ae26:         client.addTest(clientSuite("ConnectionTest:client-only"));
1:ec5ae26:         connSuite.addTest(TestConfiguration.clientServerDecorator(client));
1:ec5ae26: 
1:ee7f668:         // repeat the client tests obtaining a connection from
1:ee7f668:         // an XA data source.
1:1ae02c9:         client = new BaseTestSuite("ConnectionTest:client XADataSource");
1:ee7f668:         client.addTestSuite(ConnectionTest.class);
1:ee7f668:         client.addTest(clientSuite("ConnectionTest:client-only XADataSource"));
1:ee7f668:         connSuite.addTest(
1:ee7f668:                 TestConfiguration.clientServerDecorator(
1:ee7f668:                         TestConfiguration.connectionXADecorator(client)));
1:ee7f668: 
1:94057f1:         return connSuite;
1:b64ccfc:     }
1:b64ccfc:     
1:b64ccfc: } // End class BaseJDBCTestCase
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Blob;
1: import java.sql.ClientInfoStatus;
1: import java.sql.Clob;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLClientInfoException;
1: import java.sql.SQLException;
1: import java.sql.SQLFeatureNotSupportedException;
1: import java.sql.Statement;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:     private static BaseTestSuite clientSuite(String name) {
1:         BaseTestSuite clientSuite = new BaseTestSuite(name);
1:     private static BaseTestSuite embeddedSuite(String name) {
1:         BaseTestSuite embeddedSuite = new BaseTestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite connSuite = new BaseTestSuite("ConnectionTest suite");
1:         BaseTestSuite embedded = new BaseTestSuite("ConnectionTest:embedded");
1:         embedded = new BaseTestSuite("ConnectionTest:embedded XADataSource");
1:         BaseTestSuite client = new BaseTestSuite("ConnectionTest:client");
1:         client = new BaseTestSuite("ConnectionTest:client XADataSource");
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:ad188f4
/////////////////////////////////////////////////////////////////////////
1:      * found in the ConnectionMethodsTest.java test that is run for
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Tests that <code>isValid</code> times out when expected.
1:      * This test will need a modification to the source code;
1:      * activate the commented out Thread.sleep(2000) (2 seconds) in 
1:      * DRDAConnThread.ProcessCommands, case CodePoint.OPNQRY
1:      * To activate the test, remove the extra 'x' before building
1:      */
1:     public void xtestIsValidWithTimeout() throws SQLException {
1:         // isValid(timeoutvalue) is a no-op in Embedded
1:         if (usingEmbedded()) {
1:             return;
1:         }
1:         // Test with a large timeout, see DERBY-5912.
1:         boolean convalid=true;
1:         Connection conn=getConnection();
1: 
1:         // with a longer time out, the isValid call should not
1:         // time out when the sleep is shorter.
1:         convalid=conn.isValid(200);
1:         assertTrue(convalid);
1: 
1:         // setting the timeout to 1 should timeout if the sleep
1:         // is 2 seconds.
1:         convalid=conn.isValid(1);
1:         assertFalse(convalid);
1: 
1:         // rollback should work even though isvalid timed out...
1:         // But there's a bug in that the connection becomes invalid and
1:         // it is not getting re-established, see DERBY-5919. 
1:         // Catch the exception saying No current Connection and swallow.
1:         try {
1:             conn.rollback();
1:             //conn.close();
1:         } catch (Exception e) {
1:             //println("exception: " + e.getStackTrace());
1:         }
1:     }
commit:ea6232d
/////////////////////////////////////////////////////////////////////////
1:         // Test with a large timeout. We expect
1:         // to complete and succeed much sooner.
1:         // see DERBY-5912
1:         assertTrue(getConnection().isValid(200));
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:036a7e5
/////////////////////////////////////////////////////////////////////////
1:         
1:         //Pass empty Map to setTypeMap(). It won't raise any erros because
1:         //the method does nothing when the Map is empty.
1:         java.util.Map<String,Class<?>> emptyMap = new java.util.HashMap<String,Class<?>>();
1:         getConnection().setTypeMap(emptyMap);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c85d465
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             map.put("JAVA_UTIL_LIST", List.class);
1:             fail("returned map should be immutable");
1:         } catch (UnsupportedOperationException uoe) {
1:             // Ignore expected exception
1:         }
1: 
1:         // Create a non-empty map to test setTypeMap(). setTypeMap() raises
1:         // a feature not supported exception if the map isn't empty.
1:         map = new HashMap<String, Class<?>>();
commit:91a8a21
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     public void testGetTypeMapReturnsAsExpected() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<String> lst = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1:         map.put("JAVA_UTIL_LIST", List.class);
commit:ec5ae26
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
0:         TestSuite connSuite = new TestSuite("ConnectionTest suite");
1: 
0:         TestSuite embedded = new TestSuite("ConnectionTest:embedded");
1:         embedded.addTestSuite(ConnectionTest.class);
1:         embedded.addTest(embeddedSuite("ConnectionTest:embedded-only"));
1:         connSuite.addTest(embedded);
1: 
0:         TestSuite client = new TestSuite("ConnectionTest:client");
1:         client.addTestSuite(ConnectionTest.class);
1:         client.addTest(clientSuite("ConnectionTest:client-only"));
1:         connSuite.addTest(TestConfiguration.clientServerDecorator(client));
1: 
commit:74a105d
/////////////////////////////////////////////////////////////////////////
0:         assertSame("Unwrap returned wrong object.", con, unwrappedCon);
commit:57efc3c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.TestDataSourceFactory;
/////////////////////////////////////////////////////////////////////////
0:             ConnectionPoolDataSource cpDataSource = TestDataSourceFactory.getConnectionPoolDataSource();
/////////////////////////////////////////////////////////////////////////
0:             con = TestDataSourceFactory.getXADataSource().getXAConnection().getConnection();
commit:1861dba
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tests that <code>getTypeMap()</code> returns an empty map when
1:      * no type map has been installed.
1:      * @exception SQLException if an error occurs
1:      */
1:     public void testGetTypeMapReturnsEmptyMap() throws SQLException {
0:         assertTrue(con.getTypeMap().isEmpty());
1:     }
1: 
author:Lily Wei
-------------------------------------------------------------------------------
commit:2add32c
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Tests that <code>getTypeMap()</code> returns the input map
1:      * @exception SQLException if an error occurs
1:      */
0:     public void testGetTypeMapReturnsasExcepted() throws SQLException {
1:         Statement s = getConnection().createStatement();
1:         int ret;
1:         try {
1:             ret = s.executeUpdate("DROP TABLE T1");
1:             ret = s.executeUpdate("DROP TYPE JAVA_UTIL_LIST RESTRICT");
1:         } catch (Exception e) {}
1:         
1:         ret = s.executeUpdate("CREATE TYPE JAVA_UTIL_LIST " +
1:                               "EXTERNAL NAME 'java.util.List'" +
1:                               "LANGUAGE JAVA");
1: 
1:         s.execute("CREATE TABLE T1 (A1 JAVA_UTIL_LIST)");
1:         
1:         PreparedStatement ps = getConnection().prepareStatement(
1:                 "INSERT INTO T1(A1) VALUES (?)");
1:         
0:         ArrayList lst = new ArrayList();
1:         lst.add("First element");
1:         lst.add("Second element");
1:         
1:         ps.setObject(1, lst);
1:         ps.execute();     
1:         
1:         Map<String, Class<?>> map = getConnection().getTypeMap();
1:         try {
0:              map.put("JAVA_UTIL_LIST", Class.forName("java.util.List"));
0:         } catch (ClassNotFoundException se) {
0:             se.printStackTrace();
0:             println("map.put has exception");
1:         }
1:         
1:         try {
1:             getConnection().setTypeMap(map);
1:             fail( "Should raise an Unimplemented Feature exception." );
1:         }
1:         catch (SQLException se)
1:         {
1:             assertEquals( SQLFeatureNotSupportedException.class.getName(), se.getClass().getName() );
1:         }
1:         
1:         ResultSet rs = s.executeQuery("select * from T1");
1:         assertTrue(rs.next());
1:         for (int i = 1; i <= rs.getMetaData().getColumnCount(); i++) {
1:             Object o = rs.getObject(i);
1:             assertEquals(lst, o);
1:             //System.out.print(o + "(Type " + o.getClass().getName() + " )");
1:         }
1:         s.executeUpdate("DROP TABLE T1");
1:         s.executeUpdate("DROP TYPE JAVA_UTIL_LIST RESTRICT");
1:         s.close();
1:         ps.close();
1:     }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ee7f668
/////////////////////////////////////////////////////////////////////////
1:         
1:         // repeat the embedded tests obtaining a connection from
1:         // an XA data source.
0:         embedded = new TestSuite("ConnectionTest:embedded XADataSource");
1:         embedded.addTestSuite(ConnectionTest.class);
1:         embedded.addTest(embeddedSuite("ConnectionTest:embedded-only XADataSource"));
1:         connSuite.addTest(TestConfiguration.connectionXADecorator(embedded));
1:         
1:         // repeat the client tests obtaining a connection from
1:         // an XA data source.
0:         client = new TestSuite("ConnectionTest:client XADataSource");
1:         client.addTestSuite(ConnectionTest.class);
1:         client.addTest(clientSuite("ConnectionTest:client-only XADataSource"));
1:         connSuite.addTest(
1:                 TestConfiguration.clientServerDecorator(
1:                         TestConfiguration.connectionXADecorator(client)));
1: 
commit:8ed08b2
/////////////////////////////////////////////////////////////////////////
commit:03a99e2
/////////////////////////////////////////////////////////////////////////
1:             Blob blob = getConnection().createBlob();
/////////////////////////////////////////////////////////////////////////
1:             Clob clob = getConnection().createClob();
/////////////////////////////////////////////////////////////////////////
1:             getConnection().createArrayOf(null, null);
/////////////////////////////////////////////////////////////////////////
1:             getConnection().createNClob();
/////////////////////////////////////////////////////////////////////////
0:         getConnection().createQueryObject(TestQuery.class);
0:         getConnection().createQueryObject(TestQuery.class, getConnection());
1:             getConnection().createSQLXML();
/////////////////////////////////////////////////////////////////////////
1:             getConnection().createStruct(null, null);
/////////////////////////////////////////////////////////////////////////
1:                    getConnection().getClientInfo().isEmpty());
1:                    getConnection().getClientInfo(null));
1:                    getConnection().getClientInfo("someProperty"));
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(getConnection().isValid(0));
0:         assertTrue(getConnection().isValid(1));
1:             getConnection().isValid(-1);
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(getConnection().getTypeMap().isEmpty());
1:         assertFalse(getConnection().isWrapperFor(ResultSet.class));
1:         assertTrue(getConnection().isWrapperFor(Connection.class));
1:         getConnection().setClientInfo(null);
1:         getConnection().setClientInfo(p);
1:             getConnection().setClientInfo(p);
/////////////////////////////////////////////////////////////////////////
1:         getConnection().setClientInfo(null, null);
1:             getConnection().setClientInfo("foo", null);
1:             getConnection().setClientInfo("name", "value");
/////////////////////////////////////////////////////////////////////////
1:         Connection unwrappedCon = getConnection().unwrap(Connection.class);
1:         assertSame("Unwrap returned wrong object.", getConnection(), unwrappedCon);
1:             ResultSet unwrappedRs = getConnection().unwrap(ResultSet.class);
commit:13e9e78
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             Blob blob = getXConnection().createBlob();
/////////////////////////////////////////////////////////////////////////
0:             Clob clob = getXConnection().createClob();
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().createArrayOf(null, null);
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().createNClob();
/////////////////////////////////////////////////////////////////////////
0:         getXConnection().createQueryObject(TestQuery.class);
0:         getXConnection().createQueryObject(TestQuery.class, getXConnection());
0:             getXConnection().createSQLXML();
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().createStruct(null, null);
/////////////////////////////////////////////////////////////////////////
0:                    getXConnection().getClientInfo().isEmpty());
0:                    getXConnection().getClientInfo(null));
0:                    getXConnection().getClientInfo("someProperty"));
/////////////////////////////////////////////////////////////////////////
0:         assertTrue(getXConnection().isValid(0));
0:         assertTrue(getXConnection().isValid(1));
0:             getXConnection().isValid(-1);
/////////////////////////////////////////////////////////////////////////
0:         assertTrue(getXConnection().getTypeMap().isEmpty());
0:         assertFalse(getXConnection().isWrapperFor(ResultSet.class));
0:         assertTrue(getXConnection().isWrapperFor(Connection.class));
0:         getXConnection().setClientInfo(null);
0:         getXConnection().setClientInfo(p);
0:             getXConnection().setClientInfo(p);
/////////////////////////////////////////////////////////////////////////
0:         getXConnection().setClientInfo(null, null);
0:             getXConnection().setClientInfo("foo", null);
0:             getXConnection().setClientInfo("name", "value");
/////////////////////////////////////////////////////////////////////////
0:         Connection unwrappedCon = getXConnection().unwrap(Connection.class);
0:         assertSame("Unwrap returned wrong object.", getXConnection(), unwrappedCon);
0:             ResultSet unwrappedRs = getXConnection().unwrap(ResultSet.class);
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:d6e7d39
/////////////////////////////////////////////////////////////////////////
commit:6e3dbab
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:8a44c0f
/////////////////////////////////////////////////////////////////////////
0:         con.createQueryObject(TestQuery.class, con);
commit:7c3b39d
/////////////////////////////////////////////////////////////////////////
0:             con.createArrayOf(null, null);
1:             fail("createArrayOf(String,Object[]) should not be implemented");
/////////////////////////////////////////////////////////////////////////
1:                  "SQLClientInfoException");
1:         } catch (SQLClientInfoException cie) {
1:                        get("prop1").
1:                        equals(ClientInfoStatus.REASON_UNKNOWN_PROPERTY));
1:              assertTrue("Setting property 'prop2' must fail with "+
1:                         "REASON_UNKNOWN_PROPERTY",
1:                         cie.getFailedProperties().
1:                         get("prop2").
1:                         equals(ClientInfoStatus.REASON_UNKNOWN_PROPERTY));
/////////////////////////////////////////////////////////////////////////
1:                  "SQLClientInfoException");
1:         } catch (SQLClientInfoException cie) {
1:                        get("name").
1:                        equals(ClientInfoStatus.REASON_UNKNOWN_PROPERTY));
commit:94057f1
/////////////////////////////////////////////////////////////////////////
1:  * 
1:  * Which connection implementation is tested, depends on what connection
1:  * object the <code>BaseJDBCTestCase.getConnection()</code>-method returns.
1:  * Currently, the property <code>derbyTesting.xa.single</code> can be set to
1:  * <code>true</code> to test the XA connection object, which happens to be the
1:  * same as the one used for poooled connections.
1:  * The connection returned also depends on which framework is being used.
/////////////////////////////////////////////////////////////////////////
0:      * Obtain a connection that the tests can use.
/////////////////////////////////////////////////////////////////////////
0:      * [TODO] Write a better test when some (believed to be) JDK bugs have
0:      *        been resolved. Currently fails during query execution with 
0:      *        JDK 1.6.0_b85 because of some security manager problems. May be 
0:      *        fixed in a couple of beta releases.
/////////////////////////////////////////////////////////////////////////
1:      * embedded and network client connections.
/////////////////////////////////////////////////////////////////////////
0:     private static TestSuite clientSuite(String name) {
0:         TestSuite clientSuite = new TestSuite(name);
0:     private static TestSuite embeddedSuite(String name) {
0:         TestSuite embeddedSuite = new TestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:      * Create a test suite containing tests for a JDB connection.
1:      *  when appropriate.
0:         TestSuite connSuite = 
0:             connSuite.addTest(
0:                     clientSuite("ConnectionTest client-only suite"));
0:             connSuite.addTest(
0:                     embeddedSuite("ConnectionTest embedded-only suite"));
1:         return connSuite;
commit:7bac3b3
/////////////////////////////////////////////////////////////////////////
1:     public void testGetClientInfo()
1:         assertTrue("getClientInfo() must return an empty Properties object", 
0:                    con.getClientInfo().isEmpty());
1:     public void testGetClientInfoString()
1:         assertNull("getClientInfo(null) must return null",
0:                    con.getClientInfo(null));
1:         assertNull("getClientInfo(\"someProperty\") must return null",
0:                    con.getClientInfo("someProperty"));
/////////////////////////////////////////////////////////////////////////
1:     public void testSetClientInfoProperties()
0:         con.setClientInfo(null);
1:         Properties p = new Properties();
0:         con.setClientInfo(p);
1: 
1:         p.setProperty("prop1", "val1");
1:         p.setProperty("prop2", "val2");
0:             con.setClientInfo(p);
1:             fail("setClientInfo(String,String) should throw "+
0:                  "ClientInfoException");
1:             assertSQLState("SQLStates must match", "XCY02", cie);
1:             assertTrue("Setting property 'prop1' must fail with "+
1:                        "REASON_UNKNOWN_PROPERTY",
1:                        cie.getFailedProperties().
0:                        getProperty("prop1").
0:                        equals(""+ClientInfoException.REASON_UNKNOWN_PROPERTY));
0:             assertTrue("Setting property 'prop2' must fail with "+
1:                        "REASON_UNKNOWN_PROPERTY",
1:                        cie.getFailedProperties().
0:                        getProperty("prop2").
0:                        equals(""+ClientInfoException.REASON_UNKNOWN_PROPERTY));
1:     public void testSetClientInfoString()
0:         con.setClientInfo(null, null);
1: 
1:         try {
0:             con.setClientInfo("foo", null);
1:             fail("setClientInfo(String, null) should throw "+
1:                  "NullPointerException");
1:         } catch (NullPointerException npe) {}
1: 
1:             fail("setClientInfo(String,String) should throw "+
0:                  "ClientInfoException");
0:         } catch (ClientInfoException cie) {
1:             assertSQLState("SQLState must match 'unsupported'",
1:                            "XCY02", cie);
1:             assertTrue("Setting property 'name' must fail with "+
1:                        "REASON_UNKNOWN_PROPERTY",
1:                        cie.getFailedProperties().
0:                        getProperty("name").
0:                        equals(""+ClientInfoException.REASON_UNKNOWN_PROPERTY));
commit:8846963
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      *
1:      * Tests the Embedded implementation for the createBlob method. The Embedded
1:      * server does'nt currently have the set methods implemented. Hence the 
1:      * create methods cannot be tested by inserting data into the empty LOB 
1:      * object. Here we do a simple test of checking that the length of the 
1:      * LOB object is 0.
1:      *
1:      * @throws SQLException upon failure in the createBlob or the length 
1:      *         methods.
1:      *
1:      */
1:     public void embeddedCreateBlob()
0:             Blob blob = con.createBlob();
1:             //Check if the blob is empty
1:             if(blob.length() > 0)
1:                 fail("The new Blob should not have more than zero bytes " +
1:                         "contained in it");
1:     /**
1:      *
1:      * Tests the Embedded implementation for the createClob method. The Embedded
1:      * server does'nt currently have the set methods implemented. Hence the 
1:      * create methods cannot be tested by inserting data into the empty LOB 
1:      * object. Here we do a simple test of checking that the length of the 
1:      * LOB object is 0.
1:      *
1:      * @throws SQLException upon failure in the createClob or the length 
1:      *         methods.
1:      *
1:      */
1:     public void embeddedCreateClob()
0:             Clob clob = con.createClob();
1:             //check if the Clob is empty
1:             if(clob.length() > 0)
1:                 fail("The new Clob should not have a length of greater than " +
1:                         "zero");
/////////////////////////////////////////////////////////////////////////
1:                     "embeddedCreateBlob"));
1:                     "embeddedCreateClob"));
commit:75194ba
/////////////////////////////////////////////////////////////////////////
1:      * Tests that <code>isValid</code> is implemented and returns true
1:      * for the connection. This test is very limited but is tested
1:      * for all connection types. A more complete test of isValid is
0:      * found in the TestConnectionMethods.java test that is run for
0:      * for embedded and network client connections.
1:      */
1:     public void testIsValidImplemented() throws SQLException {
1:         // Test with an infinite (0) timeout
0:         assertTrue(con.isValid(0));
1: 
0:         // Test with a 1 second timeout
0:         assertTrue(con.isValid(1));
1: 
1:         // Test with an illegal timeout
1:         try {
0:             con.isValid(-1);
1:         } catch (SQLException sqle) {
1:             assertSQLState("Incorrect SQL state when calling isValid(-1)",
1:                            "XJ081", sqle);
1:         }
1:     }
1: 
1:     /**
commit:97cf694
/////////////////////////////////////////////////////////////////////////
1:     public void testCreateArrayNotImplemented()
1:         throws SQLException {
1:         try {
0:             con.createArray(null, null);
0:             fail("createArray(String,Object[]) should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // Do nothing, we are fine
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void testCreateStructNotImplemented()
1:         throws SQLException {
1:         try {
0:             con.createStruct(null, null);
1:             fail("createStruct(String,Object[]) should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // Do nothing, we are fine
1:         }
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
0:      * Three subsuites are created:
0:      * <ol><li>ConnectionTest suite</li>
0:      *     <li>PooledConnectionTest suite</li>
0:      *     <li>XAConnectionTest suite</li>
0:      *  </ol>
1:      *
1:      *  In addition, separate suites for embedded- and client-only are added
0:      *  to the subsuites when appropriate.
commit:b64ccfc
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.ConnectionTest
1:  
0:    Copyright 2006 The Apache Software Foundation or its licensors, as applicable.
1:  
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1:  
1:       http://www.apache.org/licenses/LICENSE-2.0
1:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1:  
1:  */
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1: 
0: import junit.framework.*;
1: 
0: import org.apache.derbyTesting.functionTests.util.BaseJDBCTestCase;
0: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
1: 
0: import java.io.FileInputStream;
0: import java.io.FileNotFoundException;
0: import java.io.IOException;
0: import java.io.OutputStream;
0: import java.sql.*;
1: import java.util.Properties;
0: import javax.sql.*;
1: 
1: /**
1:  * Tests for the JDBC 4.0 specific methods in the connection object(s).
0:  *
0:  * This class defines all test methods in <code>ConnectionTest</code>, and 
0:  * overrides <code>setUp</code> in subclasses to run these tests with different
0:  * types of connection objects. To see what connection types are tested, look
0:  * at the <code>suite</code> method.
0:  *
0:  * In addition, the <code>getName</code> method is overridden in the subclasses
0:  * to be able to see with what connection type the tests fail/run with.
1:  */
1: public class ConnectionTest
1:     extends BaseJDBCTestCase {
1: 
1:     /** 
0:      * Default connection used by the tests. 
0:      * The setup of the connection can be overridden in the <code>setUp</code> 
0:      * method in the subclasses.
1:      */
0:     protected Connection con = null;
1: 
1:     /**
1:      * Create a test with the given name.
0:      * 
1:      * @param name name of the test.
1:      */
1:     public ConnectionTest(String name) {
1:         super(name);
1:     }
1:     
1:     /**
0:      * Obtain a "regular" connection that the tests can use.
1:      */
0:     public void setUp() 
1:         throws SQLException {
0:         con = getConnection(); 
1:     }
1: 
0:     public void tearDown() 
1:         throws SQLException {
0:         if (con != null && !con.isClosed()) {
0:             con.rollback();
0:             con.close();
1:         }
0:         con = null;
1:     }
1:    
1:     //------------------------- T E S T  M E T H O D S ------------------------
1:     
0:     public void embeddedCreateBlobNotImplemented()
1:         throws SQLException {
1:         try {
0:             con.createBlob();
0:             fail("createBlob() should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // Do nothing, we are fine
1:         }
1:     }
1:     
0:     public void embeddedCreateClobNotImplemented()
1:         throws SQLException {
1:         try {
0:             con.createClob();
0:             fail("createClob() should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // Do nothing, we are fine
1:         }
1:     }
1: 
1:     public void testCreateNClobNotImplemented()
1:         throws SQLException {
1:         try {
0:             con.createNClob();
1:             fail("createNClob() should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // Do nothing, we are fine
1:         }
1:     }
1: 
1:     /**
0:      * Simply test that the method is implemented.
0:      * If the method actually does what is should, is not yet tested
0:      * (there are missing implementations).
1:      */
0:     public void testCreateQueryObjectIsImplemented()
1:         throws SQLException {
0:         con.createQueryObject(TestQuery.class);
1:     }
1: 
1:     public void testCreateSQLXMLNotImplemented()
1:         throws SQLException {
1:         try {
0:             con.createSQLXML();
1:             fail("createSQLXML() should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // Do nothing, we are fine
1:         }
1:     }
1: 
0:     public void testGetClientInfoNotImplemented()
1:         throws SQLException {
1:         try {
0:             con.getClientInfo();
0:             fail("getClientInfo() should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // Do nothing, we are fine
1:         }
1:     }
1:     
0:     public void testGetClientInfoStringNotImplemented()
1:         throws SQLException {
1:         try {
0:             con.getClientInfo(null);
0:             fail("getClientInfo(String) should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // Do nothing, we are fine
1:         }
1:     }
1: 
1:     public void testIsWrapperReturnsFalse()
1:         throws SQLException {
0:         assertFalse(con.isWrapperFor(ResultSet.class));
1:     }
1: 
1:     public void testIsWrapperReturnsTrue()
1:         throws SQLException {
0:         assertTrue(con.isWrapperFor(Connection.class));
1:     }
1: 
0:     public void testSetClientInfoPropertiesNotImplemented()
1:         throws SQLException {
1:         try {
0:             con.setClientInfo(new Properties());
0:             fail("setClientInfo(Properties) should not be implemented");
0:         } catch (ClientInfoException cie) {
0:             assertSQLState("Invalid SQL state for unimplemented method",
0:                            "0A000", // Can this be added to SQLStateConstants?
0:                            cie); 
1:         }
1:     }
1: 
0:     public void testSetClientInfoStringNotImplemented()
1:         throws SQLException {
1:         try {
0:             con.setClientInfo("name", "value");
0:             fail("setClientInfo(String,String) should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // Do nothing, we are fine
1:         }
1:     }
1:     
1:     public void testUnwrapValid()
1:         throws SQLException {
0:         Connection unwrappedCon = con.unwrap(Connection.class);
1:     }
1: 
1:     public void testUnwrapInvalid()
1:         throws SQLException {
1:         try {
0:             ResultSet unwrappedRs = con.unwrap(ResultSet.class);
1:             fail("unwrap should have thrown an exception");
1:         } catch (SQLException sqle) {
1:             assertSQLState("Incorrect SQL state when unable to unwrap",
1:                            SQLStateConstants.UNABLE_TO_UNWRAP,
1:                            sqle);
1:         }
1:     }
1:         
1:     //------------------ E N D  O F  T E S T  M E T H O D S -------------------
1: 
1:     /**
1:      * Create suite containing client-only tests.
1:      */
0:     private static TestSuite clientSuite() {
0:         TestSuite clientSuite = new TestSuite();
1:         return clientSuite; 
1:     }
1:     
1:     /**
1:      * Create suite containing embedded-only tests.
1:      */
0:     private static TestSuite embeddedSuite() {
0:         TestSuite embeddedSuite = new TestSuite();
1:         embeddedSuite.addTest(new ConnectionTest(
0:                     "embeddedCreateBlobNotImplemented"));
1:         embeddedSuite.addTest(new ConnectionTest(
0:                     "embeddedCreateClobNotImplemented"));
1:         return embeddedSuite;
1:     }
1:     
1:     /**
0:      * Create a test suite containing tests for various connection types.
1:      */
1:     public static Test suite() {
0:         TestSuite topSuite = new TestSuite("ConnectionTest top suite");
0:         // Add suite for "regular" Connection tests.
0:         TestSuite baseConnSuite = 
0:             new TestSuite(ConnectionTest.class, "ConnectionTest suite");
0:         // Add suite for PooledConnection tests.
0:         TestSuite pooledConnSuite =
0:             new TestSuite(PooledConnectionTest.class,
0:                           "PooledConnectionTest suite");
0:         // Add suite for XAConnection tests.
0:         TestSuite xaConnSuite =
0:             new TestSuite(XAConnectionTest.class, "XAConnectionTest suite");
1:         
0:         // Add client only tests
0:         // NOTE: JCC is excluded
0:         if (usingDerbyNetClient()) {
0:             TestSuite clientSuite = clientSuite();
0:             clientSuite.setName("ConnectionTest client-only suite");
0:             baseConnSuite.addTest(clientSuite);
0:             clientSuite = clientSuite();
0:             clientSuite.setName("PooledConnectionTest client-only suite");
0:             pooledConnSuite.addTest(clientSuite);
0:             clientSuite = clientSuite();
0:             clientSuite.setName("XAConnectionTest client-only suite");
0:             xaConnSuite.addTest(clientSuite);
1:         }
0:         // Add embedded only tests
0:         if (usingEmbedded()) {
0:             TestSuite embeddedSuite = embeddedSuite();
0:             embeddedSuite.setName("ConnectionTest embedded-only suite");
0:             baseConnSuite.addTest(embeddedSuite);
0:             embeddedSuite = embeddedSuite();
0:             embeddedSuite.setName("PooledConnectionTest embedded-only suite");
0:             pooledConnSuite.addTest(embeddedSuite);
0:             embeddedSuite = embeddedSuite();
0:             embeddedSuite.setName("XAConnectionTest embedded-only suite");
0:             xaConnSuite.addTest(embeddedSuite);
1:         }
0:         topSuite.addTest(baseConnSuite);
0:         topSuite.addTest(pooledConnSuite);
0:         topSuite.addTest(xaConnSuite);
0:         return topSuite;
1:     }
1:     
1:     /**
0:      * Tests for the real connection in a <code>PooledConnection</code>.
0:      *
0:      * This class subclasses <code>ConnectionTest</code>, and runs the test-
0:      * methods implemented there. By doing this, we don't have to duplicate
0:      * the test code. We only run the tests with a different type of 
0:      * connection.
1:      */
0:     public static class PooledConnectionTest 
0:         extends ConnectionTest {
1: 
1:         /**
1:          * Create a test with the given name.
0:          * 
1:          * @param name name of the test.
1:          */
0:         public PooledConnectionTest(String name) {
1:             super(name);
1:         }
1: 
1:         /**
0:          * Return name of the test, with "_POOLED" appended.
0:          * Must override this method to be able to separate which connection
0:          * the failure happened with, since the test methods are all in the
0:          * superclass.
0:          *
0:          * @return the name of the test method in <code>ConnectionTest</code>,
0:          *      appended with the string "_POOLED".
1:          */
0:         public String getName() {
0:             return super.getName() + "_POOLED";
1:         }
1: 
1:         /**
0:          * Obtain a connection to test through 
0:          * <code>ConnectionPoolDatasource</code> and 
0:          * <code>PooledConnection</code>.
0:          * Currently, the connection obtained will be either a 
0:          * <code>LogicalConnection<code> or a <code>BrokeredConnection</code>,
0:          * depending on whether we run in embedded or client mode.
1:          */
0:         public void setUp()
1:             throws SQLException {
0:             //The ConnectionPoolDataSource object
0:             //used to get a PooledConnection object
0:             ConnectionPoolDataSource cpDataSource = getConnectionPoolDataSource();
0:             PooledConnection pConn = cpDataSource.getPooledConnection();
0:             //doing a getConnection() returns a Connection object
0:             //that internally contains a BrokeredConnection40 object
0:             //this is then used to check the wrapper object
0:             con = pConn.getConnection();
1:         }
1:         
0:     } // End class PooledConnectionTest
1: 
1:     /**
0:      * Tests for the real connection in <code>XAConnection</code>.
0:      *
0:      * This class subclasses <code>ConnectionTest</code>, and runs the test-
0:      * methods implemented there. By doing this, we don't have to duplicate
0:      * the test code. We only run the tests with a different type of 
0:      * connection.
1:      */
0:     public static class XAConnectionTest
0:         extends ConnectionTest {
1: 
1:         /**
1:          * Create a test with the given name.
0:          * 
1:          * @param name name of the test.
1:          */
0:         public XAConnectionTest(String name) {
1:             super(name);
1:         }
1: 
1:         /**
0:          * Return name of the test, with "_XA" appended.
0:          * Must override this method to be able to separate which connection
0:          * the failure happened with, since the test methods are all in the
0:          * superclass.
0:          *
0:          * @return the name of the test method in <code>ConnectionTest</code>,
0:          *      appended with the string "_XA".
1:          */
0:         public String getName() {
0:             return super.getName() + "_XA";
1:         }
1: 
1:         /**
0:          * Obtain a connection to test through <code>XADataSource</code> and 
0:          * <code>XAConnection</code>.
0:          * Currently, the connection obtained will be either a 
0:          * <code>LogicalConnection<code> or a <code>BrokeredConnection</code>,
0:          * depending on whether we run in embedded or client mode.
1:          */
0:         public void setUp()
1:             throws SQLException {
0:             // Use a XADataSource to obtain a XAConnection object, and
0:             // finally a "real" connection.
0:             con = getXADataSource().getXAConnection().getConnection();
1:         }
1:         
0:     } // End class XAConnectionTest
1:     
1: } // End class BaseJDBCTestCase
============================================================================