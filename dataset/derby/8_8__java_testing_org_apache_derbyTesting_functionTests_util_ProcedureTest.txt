1:67614ad: /*
1:67614ad: 
1:f68f62f:    Derby - Class org.apache.derbyTesting.functionTests.util.ProcedureTest
1:67614ad: 
1:15651f5:    Licensed to the Apache Software Foundation (ASF) under one or more
1:15651f5:    contributor license agreements.  See the NOTICE file distributed with
1:15651f5:    this work for additional information regarding copyright ownership.
1:15651f5:    The ASF licenses this file to You under the Apache License, Version 2.0
1:15651f5:    (the "License"); you may not use this file except in compliance with
1:15651f5:    the License.  You may obtain a copy of the License at
1:67614ad: 
1:f68f62f:       http://www.apache.org/licenses/LICENSE-2.0
7:698f7a2: 
1:f68f62f:    Unless required by applicable law or agreed to in writing, software
1:f68f62f:    distributed under the License is distributed on an "AS IS" BASIS,
1:f68f62f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f68f62f:    See the License for the specific language governing permissions and
1:f68f62f:    limitations under the License.
1:698f7a2: 
1:67614ad:  */
1:67614ad: 
1:67614ad: package org.apache.derbyTesting.functionTests.util;
1:67614ad: 
1:67614ad: import org.apache.derbyTesting.functionTests.util.Formatters;
1:67614ad: 
1:67614ad: import java.sql.*;
1:67614ad: import java.math.BigDecimal;
1:67614ad: /**
1:67614ad: 	Java procedures for the procedure.sql test.
1:67614ad: */
1:ecd2625: public abstract class ProcedureTest extends SimpleProcedureTest implements ResultSet {
1:67614ad: 
1:67614ad: 	public static void zeroArg() {
1:67614ad: 		System.out.println("zeroArg() called");
2:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void insertRow(int p1) throws SQLException {
1:67614ad: 		insertRow(p1, "int");
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void insertRow(int p1, String p2) throws SQLException {
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 		PreparedStatement ps = conn.prepareStatement("insert into t1 values (?, ?)");
1:67614ad: 		ps.setInt(1, p1);
1:67614ad: 		ps.setString(2, p2);
11:67614ad: 		ps.executeUpdate();
1:67614ad: 		ps.close();
1:67614ad: 		conn.close();
1:67614ad: 	}
1:974609a: 	
1:698f7a2: 	public static void updateRow(int p1) throws SQLException {
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:698f7a2: 		PreparedStatement ps = conn.prepareStatement("update t1 set i=i+?");
1:698f7a2: 		ps.setInt(1, p1);
1:67614ad: 		ps.executeUpdate();
1:67614ad: 		ps.close();
1:67614ad: 		conn.close();
1:67614ad: 	}
1:37a2f5e: 
1:698f7a2: 	public static void deleteRow(int p1) throws SQLException {
1:698f7a2: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:698f7a2: 		PreparedStatement ps = conn.prepareStatement("delete from t1 where i=?");
1:698f7a2: 		ps.setInt(1, p1);
1:67614ad: 		ps.executeUpdate();
1:67614ad: 		ps.close();
1:698f7a2: 		conn.close();
1:67614ad: 	}
1:67614ad: 	
1:698f7a2: 	public static void alterTable() throws SQLException {
1:698f7a2: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:698f7a2: 		PreparedStatement ps = conn.prepareStatement("alter table t1 add column test integer");
1:698f7a2: 		ps.execute();
1:67614ad: 		ps.close();
1:698f7a2: 		conn.close();
1:67614ad: 	}
1:67614ad: 	
1:698f7a2: 	public static void dropTable() throws SQLException {
1:698f7a2: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:698f7a2: 		PreparedStatement ps = conn.prepareStatement("drop table t1");
1:698f7a2: 		ps.execute();
1:67614ad: 		ps.close();
1:698f7a2: 		conn.close();
1:67614ad: 	}		
1:67614ad: 	
1:698f7a2: 	public static void createIndex() throws SQLException {
1:698f7a2: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:698f7a2: 		PreparedStatement ps = conn.prepareStatement("create index ix on t1(i,b)");
1:698f7a2: 		ps.execute();
4:698f7a2: 		ps.close();
1:698f7a2: 		conn.close();
1:67614ad: 	}
1:67614ad: 	
1:698f7a2: 	public static void dropIndex() throws SQLException {
1:698f7a2: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:698f7a2: 		PreparedStatement ps = conn.prepareStatement("drop index ix");
1:698f7a2: 		ps.execute();
1:698f7a2: 		ps.close();
1:698f7a2: 		conn.close();
1:67614ad: 	}
1:67614ad: 	
1:698f7a2: 	public static void createTrigger() throws SQLException {
1:698f7a2: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:698f7a2: 		PreparedStatement ps = conn.prepareStatement("create trigger test_trig" +
1:5e4e33b: 				" AFTER delete on t1 for each STATEMENT insert into" +
1:698f7a2: 				" t1 values(20, 'twenty')");
1:698f7a2: 		ps.execute();
1:698f7a2: 		ps.close();
1:698f7a2: 		conn.close();
1:67614ad: 	}
1:67614ad: 	
1:698f7a2: 	public static void dropTrigger() throws SQLException {
1:698f7a2: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:698f7a2: 		PreparedStatement ps = conn.prepareStatement("drop trigger test_trig");
1:698f7a2: 		ps.execute();
1:698f7a2: 		ps.close();
1:698f7a2: 		conn.close();
1:67614ad: 	}
1:67614ad: 	
1:2d2e717: 	public static int selectFromSpecificSchema(int p1) throws SQLException {
1:698f7a2: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:2d2e717: 		PreparedStatement ps = conn.prepareStatement("select * from mamta1.t12RoutineTest");
1:2d2e717: 		ps.executeQuery();
1:698f7a2: 		ps.close();
1:698f7a2: 		conn.close();
1:2d2e717: 		return (1);
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	private static void insertInBig(Connection conn, String A, String B, String C, String D) throws SQLException {
1:67614ad: 		PreparedStatement ps = conn.prepareStatement("insert into big values (?, ?, ?, ?)");
1:67614ad: 		ps.setString(1, A);
1:67614ad: 		ps.setString(2, B);
1:67614ad: 		ps.setString(3, C);
1:67614ad: 		ps.setString(4, D);
1:67614ad: 		ps.executeUpdate();
1:67614ad: 		ps.close();
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void bigTestData(int i) throws SQLException {
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 		switch (i)
1:67614ad: 		{
1:67614ad: 			case 1:
1:67614ad: 				String largeStringA10000 = new String(Formatters.repeatChar("a",10000));
1:67614ad: 				String largeStringB10000 = new String(Formatters.repeatChar("b",10000));
1:67614ad: 				String largeStringC10000 = new String(Formatters.repeatChar("c",10000));
1:67614ad: 				String largeStringD10000 = new String(Formatters.repeatChar("d",10000));
1:67614ad: 				insertInBig(conn, largeStringA10000, largeStringB10000, largeStringC10000, largeStringD10000);
1:67614ad: 				break;
1:67614ad: 			case 2:
1:67614ad: 				largeStringA10000 = new String(Formatters.repeatChar("e",10000));
1:67614ad: 				largeStringB10000 = new String(Formatters.repeatChar("f",10000));
1:67614ad: 				largeStringC10000 = new String(Formatters.repeatChar("g",10000));
1:67614ad: 				largeStringD10000 = new String(Formatters.repeatChar("h",10000));
1:67614ad: 				insertInBig(conn, largeStringA10000, largeStringB10000, largeStringC10000, largeStringD10000);
1:67614ad: 				break;
1:67614ad: 			case 3:
1:67614ad: 				largeStringA10000 = new String(Formatters.repeatChar("i",10000));
1:67614ad: 				largeStringB10000 = new String(Formatters.repeatChar("j",10000));
1:67614ad: 				largeStringC10000 = new String(Formatters.repeatChar("k",10000));
1:67614ad: 				largeStringD10000 = new String(Formatters.repeatChar("l",10000));
1:67614ad: 				insertInBig(conn, largeStringA10000, largeStringB10000, largeStringC10000, largeStringD10000);
1:67614ad: 				break;
1:67614ad: 			case 4:
1:67614ad: 				largeStringA10000 = new String(Formatters.repeatChar("m",10000));
1:67614ad: 				largeStringB10000 = new String(Formatters.repeatChar("n",10000));
1:67614ad: 				largeStringC10000 = new String(Formatters.repeatChar("o",10000));
1:67614ad: 				largeStringD10000 = new String(Formatters.repeatChar("p",10000));
1:67614ad: 				insertInBig(conn, largeStringA10000, largeStringB10000, largeStringC10000, largeStringD10000);
1:67614ad: 				break;
1:67614ad: 			case 5:
1:67614ad: 				String largeStringA30000 = new String(Formatters.repeatChar("a",30000));
1:67614ad: 				String largeStringB2752 = new String(Formatters.repeatChar("b",2752));
1:67614ad: 				PreparedStatement ps = conn.prepareStatement("insert into big values (?, ?)");
1:67614ad: 				ps.setString(1, largeStringA30000);
1:67614ad: 				ps.setString(2, largeStringB2752);
1:67614ad: 				ps.executeUpdate();
1:67614ad: 				ps.close();
1:67614ad: 				break;
1:67614ad: 			case 6:
1:67614ad: 				largeStringA30000 = new String(Formatters.repeatChar("a",30000));
1:67614ad: 				String largeStringB2750 = new String(Formatters.repeatChar("b",2750));
1:67614ad: 				ps = conn.prepareStatement("insert into big values (?, ?)");
1:67614ad: 				ps.setString(1, largeStringA30000);
1:67614ad: 				ps.setString(2, largeStringB2750);
1:67614ad: 				ps.executeUpdate();
1:67614ad: 				ps.close();
1:67614ad: 				break;
1:67614ad: 			case 7:
1:67614ad: 				String largeStringA40000 = new String(Formatters.repeatChar("a",40000));
1:67614ad: 				ps = conn.prepareStatement("insert into big values (?)");
1:67614ad: 				ps.setString(1, largeStringA40000);
1:67614ad: 				ps.executeUpdate();
1:67614ad: 				ps.close();
1:67614ad: 				break;
1:67614ad: 			case 8:
1:67614ad: 				largeStringA40000 = new String(Formatters.repeatChar("a",40000));
1:67614ad: 				String largeStringB40000 = new String(Formatters.repeatChar("b",40000));
1:67614ad: 				String largeStringC40000 = new String(Formatters.repeatChar("c",40000));
1:67614ad: 				ps = conn.prepareStatement("insert into big values (?, ?, ?)");
1:67614ad: 				ps.setString(1, largeStringA40000);
1:67614ad: 				ps.setString(2, largeStringB40000);
1:67614ad: 				ps.setString(3, largeStringC40000);
1:67614ad: 				ps.executeUpdate();
1:67614ad: 				largeStringA40000 = new String(Formatters.repeatChar("d",40000));
1:67614ad: 				largeStringB40000 = new String(Formatters.repeatChar("e",40000));
1:67614ad: 				largeStringC40000 = new String(Formatters.repeatChar("f",40000));
1:67614ad: 				ps.setString(1, largeStringA40000);
1:67614ad: 				ps.setString(2, largeStringB40000);
1:67614ad: 				ps.setString(3, largeStringC40000);
1:67614ad: 				ps.executeUpdate();
1:67614ad: 				ps.close();
1:67614ad: 				break;
1:41f1df9: 			case 9:
1:41f1df9: 				String lStringA32672 = new String(Formatters.repeatChar("a",32672));
1:41f1df9: 				String lStringB32672 = new String(Formatters.repeatChar("b",32672));
1:41f1df9: 				String lStringC32672 = new String(Formatters.repeatChar("c",32672));
1:41f1df9: 				String lStringD32672 = new String(Formatters.repeatChar("d",32672));
1:41f1df9: 				insertInBig(conn, lStringA32672, lStringB32672, lStringC32672, lStringD32672);
8:f68f62f: 				break;
1:67614ad: 		}
1:67614ad: 		conn.close();
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	//public static void selectRows_coll(int p1, java.util.Collection rs) throws SQLException {
1:67614ad: 
1:67614ad: 	//	ResultSet[] d1 = new ResultSet[1];
1:67614ad: 	//	selectRows(p1, d1);
1:67614ad: 	//	rs.add(d1[0]);
1:67614ad: 	//}
1:67614ad: 
1:67614ad: 	public static void selectRows(int p1, ResultSet[] data) throws SQLException {
1:67614ad: 
1:67614ad: 		System.out.println("selectRows - 1 arg - 1 rs");
1:67614ad: 
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 		PreparedStatement ps = conn.prepareStatement("select * from t1 where i = ?");
1:67614ad: 		ps.setInt(1, p1);
1:67614ad: 		data[0] = ps.executeQuery();
1:67614ad: 		conn.close();
1:67614ad: 	}
1:67614ad: 	public static void selectRows(int p1, int p2, ResultSet[] data1, ResultSet[] data2) throws SQLException {
1:67614ad: 
1:67614ad: 		System.out.println("selectRows - 2 arg - 2 rs");
1:67614ad: 
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 		PreparedStatement ps = conn.prepareStatement("select * from t1 where i = ?");
1:67614ad: 		ps.setInt(1, p1);
1:67614ad: 		data1[0] = ps.executeQuery();
1:67614ad: 
1:67614ad: 		ps = conn.prepareStatement("select * from t1 where i >= ?");
1:67614ad: 		ps.setInt(1, p2);
1:67614ad: 		data2[0] = ps.executeQuery();
1:67614ad: 
1:67614ad: 		if (p2 == 99)
1:67614ad: 			data2[0].close();
1:67614ad: 
1:67614ad: 		// return no results
1:67614ad: 		if (p2 == 199) {
1:fe17005: 			data1[0].close();
1:67614ad: 			data1[0] = null;
1:f68f62f: 			data2[0].close();
1:67614ad: 			data2[0] = null;
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		// swap results
1:67614ad: 		if (p2 == 299) {
1:67614ad: 			ResultSet rs = data1[0];
1:67614ad: 			data1[0] = data2[0];
1:67614ad: 			data2[0] = rs;
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		conn.close();
1:67614ad: 	}
1:67614ad: 
1:5e88312: 	// select all rows from a table
1:5e88312: 	public static void selectRows(String table, ResultSet[] rs)
1:5e88312: 		throws SQLException
1:5e88312: 	{
1:5e88312: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:5e88312: 		Statement stmt = conn.createStatement();
1:5e88312: 		rs[0] = stmt.executeQuery("SELECT * FROM " + table);
1:5e88312: 		conn.close();
1:5e88312: 	}
1:5e88312: 
1:67614ad: 	public static void fivejp(ResultSet[] data1, ResultSet[] data2, ResultSet[] data3, ResultSet[] data4, ResultSet[] data5) throws SQLException {
1:67614ad: 
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 
1:67614ad: 		PreparedStatement ps1 = conn.prepareStatement("select * from MRS.FIVERS where i > ?");
1:67614ad: 		ps1.setInt(1, 1);
1:67614ad: 		data1[0] = ps1.executeQuery();
1:67614ad: 
1:67614ad: 		PreparedStatement ps2 = conn.prepareStatement("select * from MRS.FIVERS  where i > ?");
1:67614ad: 		ps2.setInt(1, 2);
1:67614ad: 		data2[0] = ps2.executeQuery();
1:67614ad: 
1:67614ad: 		PreparedStatement ps3 = conn.prepareStatement("select * from MRS.FIVERS  where i > ?");
1:67614ad: 		ps3.setInt(1, 3);
1:67614ad: 		data3[0] = ps3.executeQuery();
1:67614ad: 
1:67614ad: 		PreparedStatement ps4 = conn.prepareStatement("select * from MRS.FIVERS  where i > ?");
1:67614ad: 		ps4.setInt(1, 4);
1:67614ad: 		data4[0] = ps4.executeQuery();
1:67614ad: 
1:67614ad: 		PreparedStatement ps5 = conn.prepareStatement("select * from MRS.FIVERS  where i > ?");
1:67614ad: 		ps5.setInt(1, 5);
1:67614ad: 		data5[0] = ps5.executeQuery();
1:67614ad: 
1:67614ad: 		conn.close();
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void parameter1(int a, String b, String c, java.sql.ResultSet[] rs) throws SQLException {
1:67614ad: 
1:67614ad: 		System.out.print("PT1 a=" + a);
1:67614ad: 		if (b == null)
1:67614ad: 			System.out.println(" b = null");
1:67614ad: 		else
1:67614ad: 			System.out.print(" b=<"+b+">("+b.length()+")");
1:67614ad: 		if (c == null)
1:67614ad: 			System.out.println(" c = null");
1:67614ad: 		else
1:67614ad: 			System.out.print(" c=<"+c+">("+c.length()+")");
1:67614ad: 
1:67614ad: 		System.out.println("");
1:67614ad: 
1:67614ad: 
1:67614ad: 
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 		PreparedStatement ps = conn.prepareStatement("insert into PT1 values (?, ?, ?)");
1:67614ad: 		ps.setInt(1, a);
1:67614ad: 		ps.setString(2, b);
1:67614ad: 		ps.setString(3, c);
1:67614ad: 		ps.executeUpdate();
1:67614ad: 		ps.close();
1:67614ad: 		ps = conn.prepareStatement("select a,b, length(b), c, length(c) from PT1 where a = ?");
1:67614ad: 		ps.setInt(1, a);
1:67614ad: 		rs[0] = ps.executeQuery();
1:67614ad: 		conn.close();
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void parameter2(int a, java.math.BigDecimal b, java.math.BigDecimal c, java.sql.ResultSet[] rs) throws SQLException {
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 		PreparedStatement ps = conn.prepareStatement("insert into PT1 values (?, ?, ?)");
1:67614ad: 		ps.setInt(1, a);
1:67614ad: 		ps.setString(2, b.toString());
1:67614ad: 		ps.setString(3, c.toString());
1:67614ad: 		ps.executeUpdate();
1:67614ad: 		ps.close();
1:67614ad: 		ps = conn.prepareStatement("select a,b,c from PT1 where a = ?");
1:67614ad: 		ps.setInt(1, a);
1:67614ad: 		rs[0] = ps.executeQuery();
1:67614ad: 		conn.close();
1:67614ad: 	}
1:67614ad: 
1:67614ad: 
1:67614ad: 	public static void outparams1(int[] p1, int p2) {
1:67614ad: 
1:67614ad: 		p1[0] = p2 * 2;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	// Test for CLOB being returned.
1:67614ad: 	public static void clobselect (ResultSet[] results, 
1:67614ad: 								   ResultSet[] results1,
1:67614ad: 								   ResultSet[] results2
1:67614ad: 								   )
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad:         Connection conn = DriverManager.getConnection(
1:67614ad: 			"jdbc:default:connection");
1:67614ad: 		PreparedStatement st = conn.prepareStatement("select * from lobCheckOne");
1:67614ad: 		results[0] = st.executeQuery();
1:67614ad: 		// Just some regular data
1:67614ad: 		PreparedStatement st1 = conn.prepareStatement("select count(*) from lobCheckOne");
1:67614ad: 		results1[0] = st1.executeQuery();
1:67614ad: 		// Now more Clobs
1:67614ad: 		PreparedStatement st2 = conn.prepareStatement("select * from lobCheckOne");
1:67614ad: 		results2[0] = st2.executeQuery();
1:67614ad: 		conn.close();
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	// Test for BLOB being returned.
1:67614ad: 	public static void blobselect (ResultSet[] results)
1:67614ad: 		throws Exception
1:67614ad: 	{
1:67614ad: 
1:67614ad:         Connection conn = DriverManager.getConnection(
1:67614ad: 			"jdbc:default:connection");
1:67614ad: 		PreparedStatement st = conn.prepareStatement("select * from lobCheckTwo");
1:67614ad: 		results[0] = st.executeQuery();
1:67614ad: 		conn.close();
1:67614ad: 		return;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void inoutparams2(int[] p1, int p2) {
1:67614ad: 
1:67614ad: 		p1[0] = p1[0] + (p2 * 2);
1:67614ad: 	}
1:67614ad: 	public static void inoutparams3(String[] p1, int p2) {
1:67614ad: 
1:67614ad: 		if (p1[0] == null)
1:67614ad: 			System.out.println("p1 is NULL");
1:67614ad: 		else
1:67614ad: 			System.out.println("p1= >" + p1[0] + "< length " + p1[0].length());
1:67614ad: 		
1:67614ad: 		if (p2 == 8)
1:67614ad: 			p1[0] = "nad";
1:67614ad: 		else if (p2 == 9)
1:67614ad: 			p1[0] = null;
1:67614ad: 		else if (p2 == 10)
1:67614ad: 			p1[0] = "abcdefghijklmnopqrstuvwzyz";
1:67614ad: 	}
1:67614ad: 	public static void inoutparams4(java.math.BigDecimal[] p1, String p2) {
1:67614ad: 		if (p2 == null)
1:67614ad: 			p1[0] = null;
1:67614ad: 		else {
1:67614ad: 			if (p1[0] == null)
1:67614ad: 				p1[0] = new BigDecimal(p2).add(new BigDecimal("17"));
1:67614ad: 			else
1:67614ad: 				p1[0] = new BigDecimal(p2).add(p1[0]);
1:67614ad: 		}
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void ambigious1(int p1, String p2, ResultSet[] data1, ResultSet[] data2) {}
1:67614ad: 	public static void ambigious1(int p1, String p2, ResultSet[] data1) {}
1:67614ad: 
1:67614ad: 
1:f52a50f: 	public static void ambigious2(int p1, Integer p2) {
1:f52a50f:         System.out.println("ambigious2(int,Integer) called");
1:f52a50f:     };
1:f52a50f: 	public static void ambigious2(Integer p1, int p2) {
1:f52a50f:         System.out.println("ambigious2(Integer,int) called");
1:f52a50f:     };
1:67614ad: 
1:67614ad: 	public static void missingDynamicParameter(int p1)  {}
1:67614ad: 	public static void missingDynamicParameter(int p1, Object p2)  {}
1:67614ad: 
1:67614ad: 	public static void badDynamicParameter(int p1, ProcedureTest[] data) {}
1:67614ad: 
1:67614ad: 	public static void zeroArgDynamicResult(ResultSet[] data1, ResultSet[] data2, ResultSet[] data3, ResultSet[] data4) {
1:67614ad: 		System.out.println("zeroArgDynamicResult called");
1:67614ad: 	}
1:67614ad: 
1:67614ad: 
1:67614ad: 	public static void sqlControl(String[] e1, String[] e2, String[] e3, String[] e4, String[] e5, String[] e6, String[] e7)
1:67614ad: 		throws SQLException {
1:67614ad: 
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 
1:67614ad: 		Statement s = conn.createStatement();
1:67614ad: 
1:67614ad: 		executeStatement(s, "CREATE TABLE SQLCONTROL_DDL (I INT)", e1);
1:67614ad: 		executeStatement(s, "ALTER TABLE SQLC.SQLCONTROL_DML ADD COLUMN B INT DEFAULT NULL", e2);
1:67614ad: 
1:67614ad: 		executeStatement(s, "INSERT INTO SQLC.SQLCONTROL_DML(I) VALUES (1)", e3);
1:67614ad: 		executeStatement(s, "UPDATE SQLC.SQLCONTROL_DML SET I = I + 11", e4);
1:67614ad: 		executeStatement(s, "SELECT * FROM SQLC.SQLCONTROL_DML", e5);
1:67614ad: 		executeStatement(s, "DELETE FROM SQLC.SQLCONTROL_DML", e6);
1:67614ad: 
1:67614ad: 		executeStatement(s, "DROP TABLE SQLC.SQLCONTROL_DML", e7);
1:67614ad: 
1:67614ad: 		conn.close();
1:67614ad: 
1:67614ad: 	}
1:67614ad: 	public static void sqlControl2(String[] e1, String[] e2, String[] e3, String[] e4, String[] e5, String[] e6, String[] e7)
1:67614ad: 		throws SQLException {
1:67614ad: 
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 
1:67614ad: 		Statement s = conn.createStatement();
1:67614ad: 
1:67614ad: 		executeStatement(s, "CREATE VIEW SQLCONTROL_VIEW AS SELECT * FROM SQLC.SQLCONTROL_DML", e1);
1:67614ad: 		executeStatement(s, "DROP VIEW SQLCONTROL_VIEW", e2);
1:67614ad: 
1:67614ad: 		executeStatement(s, "LOCK TABLE SQLC.SQLCONTROL_DML IN EXCLUSIVE MODE", e3);
1:67614ad: 		executeStatement(s, "VALUES 1,2,3", e4);
1:67614ad: 		executeStatement(s, "SET SCHEMA SQLC", e5);
1:67614ad: 		executeStatement(s, "CREATE SCHEMA SQLC_M", e6);
1:67614ad: 		executeStatement(s, "DROP SCHEMA SQLC_M RESTRICT", e7);
1:67614ad: 
1:67614ad: 		conn.close();
1:67614ad: 
1:67614ad: 	}
1:67614ad: 	public static void sqlControl3(String[] e1, String[] e2, String[] e3, String[] e4, String[] e5, String[] e6, String[] e7)
1:67614ad: 		throws SQLException {
1:67614ad: 
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 
1:67614ad: 		Statement s = conn.createStatement();
1:67614ad: 
1:67614ad: 		e1[0] = "IBM CS FEATURE";
1:67614ad: 		e2[0] = "IBM CS FEATURE";
1:67614ad: 
1:67614ad: 		executeStatement(s, "SET ISOLATION CS", e3);
1:67614ad: 		executeStatement(s, "SET RUNTIMESTATISTICS OFF", e4);
1:67614ad: 		executeStatement(s, "SET STATISTICS TIMING OFF", e5);
1:67614ad: 		executeStatement(s, "VALUES 1", e6);
1:67614ad: 
1:67614ad: 		executeStatement(s, "VALUES 1", e7);
1:67614ad: 
1:67614ad: 		conn.close();
1:67614ad: 
1:67614ad: 	}
1:67614ad: 	public static void sqlControl4(int sqlc, String[] e1, String[] e2, String[] e3, String[] e4, String[] e5, String[] e6, String[] e7, String[] e8)
1:67614ad: 		throws SQLException {
1:67614ad: 
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 
1:67614ad: 		Statement s = conn.createStatement();
1:67614ad: 
1:67614ad: 		String sql = "CALL SQLC.SQLCONTROL2_"+sqlc+" (?, ?, ?, ?, ?, ?, ?) ";
1:67614ad: 
1:67614ad: 		e1[0] = sql;
1:67614ad: 
1:67614ad: 		CallableStatement cs1 = conn.prepareCall(sql);
1:67614ad: 		try {
1:67614ad: 			for (int rop = 1; rop <= 7; rop++) {
1:67614ad: 				cs1.registerOutParameter(rop, Types.VARCHAR);
1:67614ad: 			}
1:67614ad: 			cs1.execute();
1:67614ad: 
1:67614ad: 			e2[0] = cs1.getString(1);
1:67614ad: 			e3[0] = cs1.getString(2);
1:67614ad: 			e4[0] = cs1.getString(3);
1:67614ad: 			e5[0] = cs1.getString(4);
1:67614ad: 			e6[0] = cs1.getString(5);
1:67614ad: 			e7[0] = cs1.getString(6);
1:67614ad: 			e8[0] = cs1.getString(7);
1:67614ad: 		} catch (SQLException sqle) {
1:67614ad: 			StringBuffer sb = new StringBuffer(128);
1:67614ad: 			sb.append("STATE");
1:67614ad: 			do {
1:67614ad: 				sb.append("-");
1:67614ad: 				String ss = sqle.getSQLState();
1:67614ad: 				if (ss == null)
1:67614ad: 					ss= "?????";
1:67614ad: 				sb.append(ss);
1:67614ad: 				sqle = sqle.getNextException();
1:67614ad: 			} while (sqle != null);
1:67614ad: 			e2[0] = sb.toString();
1:67614ad: 		}
1:67614ad: 
1:67614ad: 		cs1.close();
1:67614ad: 
1:67614ad: 		conn.close();
1:67614ad: 
1:67614ad: 	}
1:67614ad: 	private static void executeStatement(Statement s, String sql, String[] result) {
1:67614ad: 
1:67614ad: 		StringBuffer sb = new StringBuffer(128);
1:67614ad: 
1:67614ad: 		int len = sql.length();
1:67614ad: 		if (len > 15)
1:67614ad: 			len = 15;
1:67614ad: 
1:67614ad: 		sb.append(sql.substring(0, len));
1:67614ad: 		try {
1:67614ad: 			if (s.execute(sql)) {
1:67614ad: 				ResultSet rs = s.getResultSet();
1:67614ad: 				while (rs.next())
1:67614ad: 					sb.append("- ROW(" + rs.getString(1) + ")");
1:67614ad: 				rs.close();
1:67614ad: 			} else {
1:67614ad: 				sb.append("-UPDATE " + s.getUpdateCount());
1:67614ad: 			}
1:67614ad: 
1:67614ad: 			sb.append("-EXECUTE OK");
1:67614ad: 
1:67614ad: 		} catch (SQLException sqle) {
1:67614ad: 
1:67614ad: 			
1:67614ad: 			do {
1:67614ad: 				sb.append("-");
1:67614ad: 				String ss = sqle.getSQLState();
1:67614ad: 				if (ss == null)
1:67614ad: 					ss= "?????";
1:67614ad: 				sb.append(ss);
1:67614ad: 				sqle = sqle.getNextException();
1:67614ad: 			} while (sqle != null);
1:67614ad: 
1:67614ad: 			
1:67614ad: 		}
1:67614ad: 		result[0] = sb.toString();
1:67614ad: 	}
1:67614ad: 
1:67614ad: 
1:67614ad: 	public static void oBOOLEAN(Boolean in, Boolean[] inout, Boolean[] out) throws SQLException {
1:67614ad: 
1:67614ad: 		if (out[0] != null)
1:67614ad: 			throw new SQLException ("oBOOLEAN expected out[] to be null");
1:67614ad: 
1:67614ad: 		out[0] = in;
1:67614ad: 		if (in == null)
1:67614ad: 			inout[0] = null;
1:67614ad: 		else
1:39b3237: 			inout[0] = inout[0].booleanValue() && in.booleanValue();
1:67614ad: 
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static void pBOOLEAN(boolean in, boolean[] inout, boolean[] out) throws SQLException {
1:67614ad: 
1:67614ad: 		if (out[0] != false)
1:67614ad: 			throw new SQLException ("pBOOLEAN expected out[] to be null");
1:67614ad: 
1:67614ad: 		out[0] = in;
1:67614ad: 		inout[0] =inout[0] && in;
1:67614ad: 
1:67614ad: 	}
1:67614ad: 	public static void oALLINT(Integer in, Integer[] inout, Integer[] out) throws SQLException {
1:67614ad: 
1:67614ad: 		if (out[0] != null)
1:67614ad: 			throw new SQLException ("oALLINT expected out[] to be null");
1:67614ad: 
1:67614ad: 		out[0] = in;
1:67614ad: 		if (in == null)
1:67614ad: 			;//inout[0] = null;
1:67614ad: 		else if (inout[0] == null)
1:39b3237: 			inout[0] = 3 * in.intValue();
1:67614ad: 		else
1:39b3237: 			inout[0] = inout[0].intValue() + in.intValue();
1:67614ad: 	}
1:67614ad: 	public static void pTINYINT(byte in, byte[] inout, byte[] out) throws SQLException {
1:67614ad: 
1:67614ad: 		out[0] = in;
1:67614ad: 		inout[0] += in;
1:67614ad: 	}
1:67614ad: 	public static void pSMALLINT(short in, short[] inout, short[] out) throws SQLException {
1:67614ad: 
1:67614ad: 		out[0] = in;
1:67614ad: 		inout[0] += in;
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	/*
1:67614ad: 	** Procedures for testing literals passed to procedures as IN parameters
1:67614ad: 	*/
1:67614ad: 
1:67614ad: 	public static void literalTest(int p1, String[] p2) {
1:67614ad: 		p2[0] = ">" + Integer.toString(p1) + "<";
1:67614ad: 	}
1:67614ad: 	public static void literalTest(long p1, String[] p2) {
1:67614ad: 		p2[0] = ">" + Long.toString(p1) + "<";
1:67614ad: 	}
1:67614ad: 	public static void literalTest(float p1, String[] p2) {
1:67614ad: 		p2[0] = ">" + Float.toString(p1) + "<";
1:67614ad: 	}
1:67614ad: 	public static void literalTest(double p1, String[] p2) {
1:67614ad: 		p2[0] = ">" + Double.toString(p1) + "<";
1:67614ad: 	}
1:67614ad: 	public static void literalTest(BigDecimal p1, String[] p2) {
1:67614ad: 		String s = p1 == null ? "NULL" : p1.toString();
1:67614ad: 		p2[0] = ">" + s + "<";
1:67614ad: 	}
1:67614ad: 	public static void literalTest(String p1, String[] p2) {
1:67614ad: 		String s = p1 == null ? "NULL" : p1.toString();
1:67614ad: 		p2[0] = ">" + s + "<";
1:67614ad: 	}
1:67614ad: 	public static void literalTest(java.sql.Date p1, String[] p2) {
1:67614ad: 		String s = p1 == null ? "NULL" : p1.toString();
1:67614ad: 		p2[0] = ">" + s + "<";
1:67614ad: 	}
1:67614ad: 	public static void literalTest(java.sql.Time p1, String[] p2) {
1:67614ad: 		String s = p1 == null ? "NULL" : p1.toString();
1:67614ad: 		p2[0] = ">" + s + "<";
1:67614ad: 	}
1:67614ad: 	public static void literalTest(java.sql.Timestamp p1, String[] p2) {
1:67614ad: 
1:67614ad: 		String s = p1 == null ? "NULL" : p1.toString();
1:67614ad: 		p2[0] = ">" + s + "<";
1:67614ad: 	}
1:67614ad: 
1:67614ad: 
1:67614ad: 	/*
1:ecd2625: 	** Procedure which uses BigDecimal - for parameter mapping testing.
1:67614ad: 	*/
1:67614ad: 
1:67614ad: 	public static void pmap(BigDecimal in, BigDecimal[] inout, BigDecimal[] out) {
1:67614ad: 		inout[0] = inout[0].add(new BigDecimal(2.3));
1:67614ad: 		out[0] = new BigDecimal(84.1);
1:67614ad: 	}
1:67614ad: 
1:67614ad: 	public static int countRows(String schema, String table) throws SQLException
1:67614ad: 	{
1:67614ad: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:67614ad: 		Statement s = conn.createStatement();
1:67614ad: 		ResultSet rs = s.executeQuery("SELECT COUNT(*) FROM " + schema + "." + table);
1:67614ad: 		rs.next();
1:67614ad: 		int count = rs.getInt(1);
1:67614ad: 		rs.close();
1:67614ad: 		s.close();
1:67614ad: 		conn.close();
1:67614ad: 		return count;
1:67614ad: 	}
1:67614ad:     
1:67614ad:     /**
1:3292941:      * Procedure installed to test multiple ResultSets in the lang/procedure.java
1:3292941:      * test class. 
1:3292941:      * 
1:3292941:      * @param p1 Number parameter for the first ResultSet
1:3292941:      * @param p2 Number parameter for the second ResultSet 
1:3292941:      * @param data1 The first ResultSet to be returned.
1:3292941:      * @param data2 The Second ResultSet to be returned
1:3292941:      * @throws SQLException
1:67614ad:      */
1:3292941:      public static void multiResult(int p1, int p2, ResultSet[] data1, ResultSet[] data2) 
4:f68f62f:         throws SQLException {
1:67614ad: 
1:2d2e717:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:3292941:         PreparedStatement ps = conn.prepareStatement("select * from AutoCommitTable where num = ?");
3:f68f62f:         ps.setInt(1, p1);
1:f68f62f:         data1[0] = ps.executeQuery();
1:67614ad: 
1:3292941:         ps = conn.prepareStatement("select * from AutoCommitTable where num = ?");
1:f68f62f:         ps.setInt(1, p2);
1:f68f62f:         data2[0] = ps.executeQuery();
1:67614ad: 
1:2d2e717:         conn.close();
1:67614ad:      }
1:67614ad: 
1:974609a:      // Procedure used by the test for bug JIRA-491. The client side part
1:974609a:      // of this test is in lang/procedure.java
1:974609a: 
1:974609a: 	public static void BIG_COL_491 (int i, ResultSet [] rs1, ResultSet [] rs2)
1:974609a: 		throws SQLException
1:974609a: 	{
1:974609a: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:974609a: 		Statement st1 = conn.createStatement();
1:974609a: 		rs1[0] = st1.executeQuery(
1:974609a: 			"select int1, varchar32k from jira491 where int1 < " + i + " order by 1");
1:974609a: 
1:974609a: 		Statement st2 = conn.createStatement();
1:974609a: 		rs2[0] = st2.executeQuery(
1:974609a: 			"select int1, varchar32k from jira491 where int1 > " + i + " order by 1");
1:974609a: 	}
1:974609a: 
1:974609a:     // Procedure used by the test for bug JIRA-492. The client side part of
1:974609a:     // this test is in lang/procedure.java
1:974609a: 
1:974609a: 	public static void LOTS_O_COLS_492(ResultSet [] rs)
1:974609a:         throws SQLException
1:974609a:     {
1:974609a: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:974609a: 		Statement st1 = conn.createStatement();
1:974609a: 
1:974609a: 		StringBuffer query = new StringBuffer("SELECT ");
1:974609a:         for (int i = 0; i < 100; i++)
1:974609a:         {
1:974609a:             int cno = 1000 + (i * 10);
1:974609a:             if (i > 0) query.append(", ");
1:974609a:             query.append("id AS col").append(cno).append(", nsi as col").
1:974609a:                 append(cno+1).append(", ni AS col").append(cno+2).
1:974609a:                 append(", nbi AS col").append(cno+3).append(", nd AS col").
1:974609a:                 append(cno+4).append(", nr AS col").append(cno+5).
1:974609a:                 append(", ndo AS col").append(cno+6).append(" ");
1:974609a:         }
1:974609a: 		query.append("FROM jira492 a WHERE a.id = 0");
1:974609a: 
1:974609a: 		rs[0] = st1.executeQuery(query.toString());
1:974609a: 	}
1:fec62a7: 
1:fec62a7: 	public static void grantSelect() throws SQLException
1:fec62a7: 	{
1:fec62a7: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:fec62a7: 		PreparedStatement ps = conn.prepareStatement("grant select on t1 to user2");
1:fec62a7: 		ps.execute();
1:fec62a7: 		ps.close();
1:fec62a7: 		conn.close();
1:fec62a7: 	}
1:fec62a7: 
1:fec62a7: 	public static void revokeSelect() throws SQLException
1:fec62a7: 	{
1:fec62a7: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:fec62a7: 		PreparedStatement ps = conn.prepareStatement("revoke select on t1 from user2");
1:fec62a7: 		ps.execute();
1:fec62a7: 		ps.close();
1:fec62a7: 		conn.close();
1:fec62a7: 	}
1:67614ad:     
1:37a2f5e:     public static void noname(int p1, String p2) {
1:37a2f5e:         System.out.println("noname(int,String) called");
1:37a2f5e:     }
1:5d3287e:     
1:5d3287e:     public static void noname2(Timestamp p1, String p2) {
1:5d3287e:         System.out.println("noname(Timestamp,String) called");
1:5d3287e:     }
1:67614ad: }
1:67614ad: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1: 			inout[0] = inout[0].booleanValue() && in.booleanValue();
/////////////////////////////////////////////////////////////////////////
1: 			inout[0] = 3 * in.intValue();
1: 			inout[0] = inout[0].intValue() + in.intValue();
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:5e4e33b
/////////////////////////////////////////////////////////////////////////
1: 				" AFTER delete on t1 for each STATEMENT insert into" +
commit:5e88312
/////////////////////////////////////////////////////////////////////////
1: 	// select all rows from a table
1: 	public static void selectRows(String table, ResultSet[] rs)
1: 		throws SQLException
1: 	{
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		Statement stmt = conn.createStatement();
1: 		rs[0] = stmt.executeQuery("SELECT * FROM " + table);
1: 		conn.close();
1: 	}
1: 
commit:974609a
/////////////////////////////////////////////////////////////////////////
1: 
1:      // Procedure used by the test for bug JIRA-491. The client side part
1:      // of this test is in lang/procedure.java
1: 
1: 	public static void BIG_COL_491 (int i, ResultSet [] rs1, ResultSet [] rs2)
1: 		throws SQLException
1: 	{
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		Statement st1 = conn.createStatement();
1: 		rs1[0] = st1.executeQuery(
1: 			"select int1, varchar32k from jira491 where int1 < " + i + " order by 1");
1: 
1: 		Statement st2 = conn.createStatement();
1: 		rs2[0] = st2.executeQuery(
1: 			"select int1, varchar32k from jira491 where int1 > " + i + " order by 1");
1: 	}
1: 
1:     // Procedure used by the test for bug JIRA-492. The client side part of
1:     // this test is in lang/procedure.java
1: 
1: 	public static void LOTS_O_COLS_492(ResultSet [] rs)
1:         throws SQLException
1:     {
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		Statement st1 = conn.createStatement();
1: 
1: 		StringBuffer query = new StringBuffer("SELECT ");
1:         for (int i = 0; i < 100; i++)
1:         {
1:             int cno = 1000 + (i * 10);
1:             if (i > 0) query.append(", ");
1:             query.append("id AS col").append(cno).append(", nsi as col").
1:                 append(cno+1).append(", ni AS col").append(cno+2).
1:                 append(", nbi AS col").append(cno+3).append(", nd AS col").
1:                 append(cno+4).append(", nr AS col").append(cno+5).
1:                 append(", ndo AS col").append(cno+6).append(" ");
1:         }
1: 		query.append("FROM jira492 a WHERE a.id = 0");
1: 
1: 		rs[0] = st1.executeQuery(query.toString());
1: 	}
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:5d3287e
/////////////////////////////////////////////////////////////////////////
1:     
1:     public static void noname2(Timestamp p1, String p2) {
1:         System.out.println("noname(Timestamp,String) called");
1:     }
commit:37a2f5e
/////////////////////////////////////////////////////////////////////////
1:     
1:     public static void noname(int p1, String p2) {
1:         System.out.println("noname(int,String) called");
1:     }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:fec62a7
/////////////////////////////////////////////////////////////////////////
1: 
1: 	public static void grantSelect() throws SQLException
1: 	{
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		PreparedStatement ps = conn.prepareStatement("grant select on t1 to user2");
1: 		ps.execute();
1: 		ps.close();
1: 		conn.close();
1: 	}
1: 
1: 	public static void revokeSelect() throws SQLException
1: 	{
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		PreparedStatement ps = conn.prepareStatement("revoke select on t1 from user2");
1: 		ps.execute();
1: 		ps.close();
1: 		conn.close();
1: 	}
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:15651f5
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:67614ad
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyTesting.functionTests.util
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.util;
1: 
1: import org.apache.derbyTesting.functionTests.util.Formatters;
1: 
1: import java.sql.*;
1: import java.math.BigDecimal;
1: /**
1: 	Java procedures for the procedure.sql test.
1: */
0: public abstract class ProcedureTest implements ResultSet {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
1: 
1: 	public static void zeroArg() {
1: 		System.out.println("zeroArg() called");
1: 	}
1: 
1: 	public static void insertRow(int p1) throws SQLException {
1: 		insertRow(p1, "int");
1: 	}
1: 
1: 	public static void insertRow(int p1, String p2) throws SQLException {
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		PreparedStatement ps = conn.prepareStatement("insert into t1 values (?, ?)");
1: 		ps.setInt(1, p1);
1: 		ps.setString(2, p2);
1: 		ps.executeUpdate();
1: 		ps.close();
1: 		conn.close();
1: 	}
1: 
0: 	public static void maxMemPerTabTest() throws SQLException {
0: /*		StringBuffer sbA = new StringBuffer(20000);
0: 		for (int i = 0; i < 20000; i++)
0: 			sbA.append('a');
0: 		String largeStringA20000 = new String(sbA);
0:     largeStringA20000.substring(0,2000);
1: 
0: 		StringBuffer sbB = new StringBuffer(20000);
0: 		for (int i = 0; i < 20000; i++)
0: 			sbB.append('b');
0: 		String largeStringB20000 = new String(sbB);
0: 		String largeStringB2000 = largeStringB20000.substring(0,2000);
1: 
0: 		StringBuffer sbC = new StringBuffer(20000);
0: 		for (int i = 0; i < 20000; i++)
0: 			sbC.append('b');
0: 		String largeStringC20000 = new String(sbC);
0: 		String largeStringC2000 = largeStringC20000.substring(0,2000);
1: 
0: 		StringBuffer sbD = new StringBuffer(20000);
0: 		for (int i = 0; i < 20000; i++)
0: 			sbD.append('b');
0: 		String largeStringD20000 = new String(sbD);
0: 		String largeStringD2000 = largeStringD20000.substring(0,2000); */
1: 
0: 		String largeStringA20000 = new String(Formatters.repeatChar("a",20000));
0: 		String largeStringA2000 = new String(Formatters.repeatChar("a",2000));
0: 		String largeStringB20000 = new String(Formatters.repeatChar("b",20000));
0: 		String largeStringB2000 = new String(Formatters.repeatChar("b",2000));
0: 		String largeStringC20000 = new String(Formatters.repeatChar("c",20000));
0: 		String largeStringC2000 = new String(Formatters.repeatChar("c",2000));
0: 		String largeStringD20000 = new String(Formatters.repeatChar("d",20000));
0: 		String largeStringD2000 = new String(Formatters.repeatChar("d",2000));
1: 
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		PreparedStatement ps = conn.prepareStatement("insert into tab1 values (?, ?)");
0: 		ps.setInt(1, 1);
0: 		ps.setString(2, largeStringA20000);
1: 		ps.executeUpdate();
0: 		ps.setInt(1, 2);
0: 		ps.setString(2, largeStringB20000);
1: 		ps.executeUpdate();
0: 		ps.setInt(1, 3);
0: 		ps.setString(2, largeStringC20000);
1: 		ps.executeUpdate();
1: 		ps.close();
0: 		ps = conn.prepareStatement("insert into tab2 values (?, ?)");
0: 		ps.setInt(1, 1);
0: 		ps.setString(2, largeStringA20000);
1: 		ps.executeUpdate();
0: 		ps.setInt(1, 2);
0: 		ps.setString(2, largeStringC20000);
1: 		ps.executeUpdate();
0: 		ps.setInt(1, 3);
0: 		ps.setString(2, largeStringD20000);
1: 		ps.executeUpdate();
1: 		ps.close();
0: 		ps = conn.prepareStatement("insert into tab3 values (?, ?)");
0: 		ps.setInt(1, 1);
0: 		ps.setString(2, largeStringA2000);
1: 		ps.executeUpdate();
0: 		ps.setInt(1, 2);
0: 		ps.setString(2, largeStringB2000);
1: 		ps.executeUpdate();
0: 		ps.setInt(1, 3);
0: 		ps.setString(2, largeStringC2000);
1: 		ps.executeUpdate();
1: 		ps.close();
0: 		ps = conn.prepareStatement("insert into tab4 values (?, ?)");
0: 		ps.setInt(1, 1);
0: 		ps.setString(2, largeStringA2000);
1: 		ps.executeUpdate();
0: 		ps.setInt(1, 2);
0: 		ps.setString(2, largeStringC2000);
1: 		ps.executeUpdate();
0: 		ps.setInt(1, 3);
0: 		ps.setString(2, largeStringD2000);
1: 		ps.executeUpdate();
1: 		ps.close();
1: 		conn.close();
1: 	}
1: 
1: 	private static void insertInBig(Connection conn, String A, String B, String C, String D) throws SQLException {
1: 		PreparedStatement ps = conn.prepareStatement("insert into big values (?, ?, ?, ?)");
1: 		ps.setString(1, A);
1: 		ps.setString(2, B);
1: 		ps.setString(3, C);
1: 		ps.setString(4, D);
1: 		ps.executeUpdate();
1: 		ps.close();
1: 	}
1: 
1: 	public static void bigTestData(int i) throws SQLException {
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		switch (i)
1: 		{
1: 			case 1:
1: 				String largeStringA10000 = new String(Formatters.repeatChar("a",10000));
1: 				String largeStringB10000 = new String(Formatters.repeatChar("b",10000));
1: 				String largeStringC10000 = new String(Formatters.repeatChar("c",10000));
1: 				String largeStringD10000 = new String(Formatters.repeatChar("d",10000));
1: 				insertInBig(conn, largeStringA10000, largeStringB10000, largeStringC10000, largeStringD10000);
1: 				break;
1: 			case 2:
1: 				largeStringA10000 = new String(Formatters.repeatChar("e",10000));
1: 				largeStringB10000 = new String(Formatters.repeatChar("f",10000));
1: 				largeStringC10000 = new String(Formatters.repeatChar("g",10000));
1: 				largeStringD10000 = new String(Formatters.repeatChar("h",10000));
1: 				insertInBig(conn, largeStringA10000, largeStringB10000, largeStringC10000, largeStringD10000);
1: 				break;
1: 			case 3:
1: 				largeStringA10000 = new String(Formatters.repeatChar("i",10000));
1: 				largeStringB10000 = new String(Formatters.repeatChar("j",10000));
1: 				largeStringC10000 = new String(Formatters.repeatChar("k",10000));
1: 				largeStringD10000 = new String(Formatters.repeatChar("l",10000));
1: 				insertInBig(conn, largeStringA10000, largeStringB10000, largeStringC10000, largeStringD10000);
1: 				break;
1: 			case 4:
1: 				largeStringA10000 = new String(Formatters.repeatChar("m",10000));
1: 				largeStringB10000 = new String(Formatters.repeatChar("n",10000));
1: 				largeStringC10000 = new String(Formatters.repeatChar("o",10000));
1: 				largeStringD10000 = new String(Formatters.repeatChar("p",10000));
1: 				insertInBig(conn, largeStringA10000, largeStringB10000, largeStringC10000, largeStringD10000);
1: 				break;
1: 			case 5:
1: 				String largeStringA30000 = new String(Formatters.repeatChar("a",30000));
1: 				String largeStringB2752 = new String(Formatters.repeatChar("b",2752));
1: 				PreparedStatement ps = conn.prepareStatement("insert into big values (?, ?)");
1: 				ps.setString(1, largeStringA30000);
1: 				ps.setString(2, largeStringB2752);
1: 				ps.executeUpdate();
1: 				ps.close();
1: 				break;
1: 			case 6:
1: 				largeStringA30000 = new String(Formatters.repeatChar("a",30000));
1: 				String largeStringB2750 = new String(Formatters.repeatChar("b",2750));
1: 				ps = conn.prepareStatement("insert into big values (?, ?)");
1: 				ps.setString(1, largeStringA30000);
1: 				ps.setString(2, largeStringB2750);
1: 				ps.executeUpdate();
1: 				ps.close();
1: 				break;
1: 			case 7:
1: 				String largeStringA40000 = new String(Formatters.repeatChar("a",40000));
1: 				ps = conn.prepareStatement("insert into big values (?)");
1: 				ps.setString(1, largeStringA40000);
1: 				ps.executeUpdate();
1: 				ps.close();
1: 				break;
1: 			case 8:
1: 				largeStringA40000 = new String(Formatters.repeatChar("a",40000));
1: 				String largeStringB40000 = new String(Formatters.repeatChar("b",40000));
1: 				String largeStringC40000 = new String(Formatters.repeatChar("c",40000));
1: 				ps = conn.prepareStatement("insert into big values (?, ?, ?)");
1: 				ps.setString(1, largeStringA40000);
1: 				ps.setString(2, largeStringB40000);
1: 				ps.setString(3, largeStringC40000);
1: 				ps.executeUpdate();
1: 				largeStringA40000 = new String(Formatters.repeatChar("d",40000));
1: 				largeStringB40000 = new String(Formatters.repeatChar("e",40000));
1: 				largeStringC40000 = new String(Formatters.repeatChar("f",40000));
1: 				ps.setString(1, largeStringA40000);
1: 				ps.setString(2, largeStringB40000);
1: 				ps.setString(3, largeStringC40000);
1: 				ps.executeUpdate();
1: 				ps.close();
1: 				break;
1: 		}
1: 		conn.close();
1: 	}
1: 
1: 	//public static void selectRows_coll(int p1, java.util.Collection rs) throws SQLException {
1: 
1: 	//	ResultSet[] d1 = new ResultSet[1];
1: 	//	selectRows(p1, d1);
1: 	//	rs.add(d1[0]);
1: 	//}
1: 
1: 	public static void selectRows(int p1, ResultSet[] data) throws SQLException {
1: 
1: 		System.out.println("selectRows - 1 arg - 1 rs");
1: 
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		PreparedStatement ps = conn.prepareStatement("select * from t1 where i = ?");
1: 		ps.setInt(1, p1);
1: 		data[0] = ps.executeQuery();
1: 		conn.close();
1: 	}
1: 	public static void selectRows(int p1, int p2, ResultSet[] data1, ResultSet[] data2) throws SQLException {
1: 
1: 		System.out.println("selectRows - 2 arg - 2 rs");
1: 
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		PreparedStatement ps = conn.prepareStatement("select * from t1 where i = ?");
1: 		ps.setInt(1, p1);
1: 		data1[0] = ps.executeQuery();
1: 
1: 		ps = conn.prepareStatement("select * from t1 where i >= ?");
1: 		ps.setInt(1, p2);
1: 		data2[0] = ps.executeQuery();
1: 
1: 		if (p2 == 99)
1: 			data2[0].close();
1: 
1: 		// return no results
1: 		if (p2 == 199) {
1: 			data1[0] = null;
1: 			data2[0] = null;
1: 		}
1: 
1: 		// swap results
1: 		if (p2 == 299) {
1: 			ResultSet rs = data1[0];
1: 			data1[0] = data2[0];
1: 			data2[0] = rs;
1: 		}
1: 
1: 		conn.close();
1: 	}
1: 
1: 	public static void fivejp(ResultSet[] data1, ResultSet[] data2, ResultSet[] data3, ResultSet[] data4, ResultSet[] data5) throws SQLException {
1: 
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 
1: 		PreparedStatement ps1 = conn.prepareStatement("select * from MRS.FIVERS where i > ?");
1: 		ps1.setInt(1, 1);
1: 		data1[0] = ps1.executeQuery();
1: 
1: 		PreparedStatement ps2 = conn.prepareStatement("select * from MRS.FIVERS  where i > ?");
1: 		ps2.setInt(1, 2);
1: 		data2[0] = ps2.executeQuery();
1: 
1: 		PreparedStatement ps3 = conn.prepareStatement("select * from MRS.FIVERS  where i > ?");
1: 		ps3.setInt(1, 3);
1: 		data3[0] = ps3.executeQuery();
1: 
1: 		PreparedStatement ps4 = conn.prepareStatement("select * from MRS.FIVERS  where i > ?");
1: 		ps4.setInt(1, 4);
1: 		data4[0] = ps4.executeQuery();
1: 
1: 		PreparedStatement ps5 = conn.prepareStatement("select * from MRS.FIVERS  where i > ?");
1: 		ps5.setInt(1, 5);
1: 		data5[0] = ps5.executeQuery();
1: 
1: 		conn.close();
1: 	}
1: 
1: 	public static void parameter1(int a, String b, String c, java.sql.ResultSet[] rs) throws SQLException {
1: 
1: 		System.out.print("PT1 a=" + a);
1: 		if (b == null)
1: 			System.out.println(" b = null");
1: 		else
1: 			System.out.print(" b=<"+b+">("+b.length()+")");
1: 		if (c == null)
1: 			System.out.println(" c = null");
1: 		else
1: 			System.out.print(" c=<"+c+">("+c.length()+")");
1: 
1: 		System.out.println("");
1: 
1: 
1: 
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		PreparedStatement ps = conn.prepareStatement("insert into PT1 values (?, ?, ?)");
1: 		ps.setInt(1, a);
1: 		ps.setString(2, b);
1: 		ps.setString(3, c);
1: 		ps.executeUpdate();
1: 		ps.close();
1: 		ps = conn.prepareStatement("select a,b, length(b), c, length(c) from PT1 where a = ?");
1: 		ps.setInt(1, a);
1: 		rs[0] = ps.executeQuery();
1: 		conn.close();
1: 	}
1: 
1: 	public static void parameter2(int a, java.math.BigDecimal b, java.math.BigDecimal c, java.sql.ResultSet[] rs) throws SQLException {
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		PreparedStatement ps = conn.prepareStatement("insert into PT1 values (?, ?, ?)");
1: 		ps.setInt(1, a);
1: 		ps.setString(2, b.toString());
1: 		ps.setString(3, c.toString());
1: 		ps.executeUpdate();
1: 		ps.close();
1: 		ps = conn.prepareStatement("select a,b,c from PT1 where a = ?");
1: 		ps.setInt(1, a);
1: 		rs[0] = ps.executeQuery();
1: 		conn.close();
1: 	}
1: 
1: 
1: 	public static void outparams1(int[] p1, int p2) {
1: 
1: 		p1[0] = p2 * 2;
1: 	}
1: 
1: 	// Test for CLOB being returned.
1: 	public static void clobselect (ResultSet[] results, 
1: 								   ResultSet[] results1,
1: 								   ResultSet[] results2
1: 								   )
1: 		throws Exception
1: 	{
1: 
1:         Connection conn = DriverManager.getConnection(
1: 			"jdbc:default:connection");
1: 		PreparedStatement st = conn.prepareStatement("select * from lobCheckOne");
1: 		results[0] = st.executeQuery();
1: 		// Just some regular data
1: 		PreparedStatement st1 = conn.prepareStatement("select count(*) from lobCheckOne");
1: 		results1[0] = st1.executeQuery();
1: 		// Now more Clobs
1: 		PreparedStatement st2 = conn.prepareStatement("select * from lobCheckOne");
1: 		results2[0] = st2.executeQuery();
1: 		conn.close();
1: 		return;
1: 
1: 	}
1: 
1: 	// Test for BLOB being returned.
1: 	public static void blobselect (ResultSet[] results)
1: 		throws Exception
1: 	{
1: 
1:         Connection conn = DriverManager.getConnection(
1: 			"jdbc:default:connection");
1: 		PreparedStatement st = conn.prepareStatement("select * from lobCheckTwo");
1: 		results[0] = st.executeQuery();
1: 		conn.close();
1: 		return;
1: 
1: 	}
1: 
1: 	public static void inoutparams2(int[] p1, int p2) {
1: 
1: 		p1[0] = p1[0] + (p2 * 2);
1: 	}
1: 	public static void inoutparams3(String[] p1, int p2) {
1: 
1: 		if (p1[0] == null)
1: 			System.out.println("p1 is NULL");
1: 		else
1: 			System.out.println("p1= >" + p1[0] + "< length " + p1[0].length());
1: 		
1: 		if (p2 == 8)
1: 			p1[0] = "nad";
1: 		else if (p2 == 9)
1: 			p1[0] = null;
1: 		else if (p2 == 10)
1: 			p1[0] = "abcdefghijklmnopqrstuvwzyz";
1: 	}
1: 	public static void inoutparams4(java.math.BigDecimal[] p1, String p2) {
1: 		if (p2 == null)
1: 			p1[0] = null;
1: 		else {
1: 			if (p1[0] == null)
1: 				p1[0] = new BigDecimal(p2).add(new BigDecimal("17"));
1: 			else
1: 				p1[0] = new BigDecimal(p2).add(p1[0]);
1: 		}
1: 	}
1: 
1: 	public static void ambigious1(int p1, String p2, ResultSet[] data1, ResultSet[] data2) {}
1: 	public static void ambigious1(int p1, String p2, ResultSet[] data1) {}
1: 
1: 
0: 	public static void ambigious2(int p1, Integer p2) {};
0: 	public static void ambigious2(Integer p1, int p2) {};
1: 
1: 	public static void missingDynamicParameter(int p1)  {}
1: 	public static void missingDynamicParameter(int p1, Object p2)  {}
1: 
1: 	public static void badDynamicParameter(int p1, ProcedureTest[] data) {}
1: 
1: 	public static void zeroArgDynamicResult(ResultSet[] data1, ResultSet[] data2, ResultSet[] data3, ResultSet[] data4) {
1: 		System.out.println("zeroArgDynamicResult called");
1: 	}
1: 
1: 
1: 	public static void sqlControl(String[] e1, String[] e2, String[] e3, String[] e4, String[] e5, String[] e6, String[] e7)
1: 		throws SQLException {
1: 
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 
1: 		Statement s = conn.createStatement();
1: 
1: 		executeStatement(s, "CREATE TABLE SQLCONTROL_DDL (I INT)", e1);
1: 		executeStatement(s, "ALTER TABLE SQLC.SQLCONTROL_DML ADD COLUMN B INT DEFAULT NULL", e2);
1: 
1: 		executeStatement(s, "INSERT INTO SQLC.SQLCONTROL_DML(I) VALUES (1)", e3);
1: 		executeStatement(s, "UPDATE SQLC.SQLCONTROL_DML SET I = I + 11", e4);
1: 		executeStatement(s, "SELECT * FROM SQLC.SQLCONTROL_DML", e5);
1: 		executeStatement(s, "DELETE FROM SQLC.SQLCONTROL_DML", e6);
1: 
1: 		executeStatement(s, "DROP TABLE SQLC.SQLCONTROL_DML", e7);
1: 
1: 		conn.close();
1: 
1: 	}
1: 	public static void sqlControl2(String[] e1, String[] e2, String[] e3, String[] e4, String[] e5, String[] e6, String[] e7)
1: 		throws SQLException {
1: 
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 
1: 		Statement s = conn.createStatement();
1: 
1: 		executeStatement(s, "CREATE VIEW SQLCONTROL_VIEW AS SELECT * FROM SQLC.SQLCONTROL_DML", e1);
1: 		executeStatement(s, "DROP VIEW SQLCONTROL_VIEW", e2);
1: 
1: 		executeStatement(s, "LOCK TABLE SQLC.SQLCONTROL_DML IN EXCLUSIVE MODE", e3);
1: 		executeStatement(s, "VALUES 1,2,3", e4);
1: 		executeStatement(s, "SET SCHEMA SQLC", e5);
1: 		executeStatement(s, "CREATE SCHEMA SQLC_M", e6);
1: 		executeStatement(s, "DROP SCHEMA SQLC_M RESTRICT", e7);
1: 
1: 		conn.close();
1: 
1: 	}
1: 	public static void sqlControl3(String[] e1, String[] e2, String[] e3, String[] e4, String[] e5, String[] e6, String[] e7)
1: 		throws SQLException {
1: 
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 
1: 		Statement s = conn.createStatement();
1: 
1: 		e1[0] = "IBM CS FEATURE";
1: 		e2[0] = "IBM CS FEATURE";
1: 
1: 		executeStatement(s, "SET ISOLATION CS", e3);
1: 		executeStatement(s, "SET RUNTIMESTATISTICS OFF", e4);
1: 		executeStatement(s, "SET STATISTICS TIMING OFF", e5);
1: 		executeStatement(s, "VALUES 1", e6);
1: 
1: 		executeStatement(s, "VALUES 1", e7);
1: 
1: 		conn.close();
1: 
1: 	}
1: 	public static void sqlControl4(int sqlc, String[] e1, String[] e2, String[] e3, String[] e4, String[] e5, String[] e6, String[] e7, String[] e8)
1: 		throws SQLException {
1: 
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 
1: 		Statement s = conn.createStatement();
1: 
1: 		String sql = "CALL SQLC.SQLCONTROL2_"+sqlc+" (?, ?, ?, ?, ?, ?, ?) ";
1: 
1: 		e1[0] = sql;
1: 
1: 		CallableStatement cs1 = conn.prepareCall(sql);
1: 		try {
1: 			for (int rop = 1; rop <= 7; rop++) {
1: 				cs1.registerOutParameter(rop, Types.VARCHAR);
1: 			}
1: 			cs1.execute();
1: 
1: 			e2[0] = cs1.getString(1);
1: 			e3[0] = cs1.getString(2);
1: 			e4[0] = cs1.getString(3);
1: 			e5[0] = cs1.getString(4);
1: 			e6[0] = cs1.getString(5);
1: 			e7[0] = cs1.getString(6);
1: 			e8[0] = cs1.getString(7);
1: 		} catch (SQLException sqle) {
1: 			StringBuffer sb = new StringBuffer(128);
1: 			sb.append("STATE");
1: 			do {
1: 				sb.append("-");
1: 				String ss = sqle.getSQLState();
1: 				if (ss == null)
1: 					ss= "?????";
1: 				sb.append(ss);
1: 				sqle = sqle.getNextException();
1: 			} while (sqle != null);
1: 			e2[0] = sb.toString();
1: 		}
1: 
1: 		cs1.close();
1: 
1: 		conn.close();
1: 
1: 	}
1: 	private static void executeStatement(Statement s, String sql, String[] result) {
1: 
1: 		StringBuffer sb = new StringBuffer(128);
1: 
1: 		int len = sql.length();
1: 		if (len > 15)
1: 			len = 15;
1: 
1: 		sb.append(sql.substring(0, len));
1: 		try {
1: 			if (s.execute(sql)) {
1: 				ResultSet rs = s.getResultSet();
1: 				while (rs.next())
1: 					sb.append("- ROW(" + rs.getString(1) + ")");
1: 				rs.close();
1: 			} else {
1: 				sb.append("-UPDATE " + s.getUpdateCount());
1: 			}
1: 
1: 			sb.append("-EXECUTE OK");
1: 
1: 		} catch (SQLException sqle) {
1: 
1: 			
1: 			do {
1: 				sb.append("-");
1: 				String ss = sqle.getSQLState();
1: 				if (ss == null)
1: 					ss= "?????";
1: 				sb.append(ss);
1: 				sqle = sqle.getNextException();
1: 			} while (sqle != null);
1: 
1: 			
1: 		}
1: 		result[0] = sb.toString();
1: 	}
1: 
1: 
1: 	public static void oBOOLEAN(Boolean in, Boolean[] inout, Boolean[] out) throws SQLException {
1: 
1: 		if (out[0] != null)
1: 			throw new SQLException ("oBOOLEAN expected out[] to be null");
1: 
1: 		out[0] = in;
1: 		if (in == null)
1: 			inout[0] = null;
1: 		else
0: 			inout[0] = new Boolean(inout[0].booleanValue() && in.booleanValue());
1: 
1: 	}
1: 
1: 	public static void pBOOLEAN(boolean in, boolean[] inout, boolean[] out) throws SQLException {
1: 
1: 		if (out[0] != false)
1: 			throw new SQLException ("pBOOLEAN expected out[] to be null");
1: 
1: 		out[0] = in;
1: 		inout[0] =inout[0] && in;
1: 
1: 	}
1: 	public static void oALLINT(Integer in, Integer[] inout, Integer[] out) throws SQLException {
1: 
1: 		if (out[0] != null)
1: 			throw new SQLException ("oALLINT expected out[] to be null");
1: 
1: 		out[0] = in;
1: 		if (in == null)
1: 			;//inout[0] = null;
1: 		else if (inout[0] == null)
0: 			inout[0] = new Integer(3 * in.intValue());
1: 		else
0: 			inout[0] = new Integer(inout[0].intValue() + in.intValue());
1: 	}
1: 	public static void pTINYINT(byte in, byte[] inout, byte[] out) throws SQLException {
1: 
1: 		out[0] = in;
1: 		inout[0] += in;
1: 	}
1: 	public static void pSMALLINT(short in, short[] inout, short[] out) throws SQLException {
1: 
1: 		out[0] = in;
1: 		inout[0] += in;
1: 	}
1: 
1: 	/*
1: 	** Procedures for testing literals passed to procedures as IN parameters
1: 	*/
1: 
1: 	public static void literalTest(int p1, String[] p2) {
1: 		p2[0] = ">" + Integer.toString(p1) + "<";
1: 	}
1: 	public static void literalTest(long p1, String[] p2) {
1: 		p2[0] = ">" + Long.toString(p1) + "<";
1: 	}
1: 	public static void literalTest(float p1, String[] p2) {
1: 		p2[0] = ">" + Float.toString(p1) + "<";
1: 	}
1: 	public static void literalTest(double p1, String[] p2) {
1: 		p2[0] = ">" + Double.toString(p1) + "<";
1: 	}
1: 	public static void literalTest(BigDecimal p1, String[] p2) {
1: 		String s = p1 == null ? "NULL" : p1.toString();
1: 		p2[0] = ">" + s + "<";
1: 	}
1: 	public static void literalTest(String p1, String[] p2) {
1: 		String s = p1 == null ? "NULL" : p1.toString();
1: 		p2[0] = ">" + s + "<";
1: 	}
1: 	public static void literalTest(java.sql.Date p1, String[] p2) {
1: 		String s = p1 == null ? "NULL" : p1.toString();
1: 		p2[0] = ">" + s + "<";
1: 	}
1: 	public static void literalTest(java.sql.Time p1, String[] p2) {
1: 		String s = p1 == null ? "NULL" : p1.toString();
1: 		p2[0] = ">" + s + "<";
1: 	}
1: 	public static void literalTest(java.sql.Timestamp p1, String[] p2) {
1: 
1: 		String s = p1 == null ? "NULL" : p1.toString();
1: 		p2[0] = ">" + s + "<";
1: 	}
1: 
1: 
1: 	/*
0: 	** Procedures for parameter mapping testing.
1: 	*/
1: 
0: 	public static void pmap(short in, short[] inout, short[] out) {
1: 
0: 		inout[0] += 6;
0: 		out[0] = 77;
1: 	}
0: 	public static void pmap(int in, int[] inout, int[] out) {
0: 		inout[0] += 9;
0: 		out[0] = 88;
1: 
1: 	}
0: 	public static void pmap(long in, long[] inout, long[] out) {
0: 		inout[0] += 8;
0: 		out[0] = 99;
1: 	}
0: 	public static void pmap(float in, float[] inout, float[] out) {
0: 		inout[0] += 9.9f;
0: 		out[0] = 88.8f;
1: 	}
0: 	public static void pmap(double in, double[] inout, double[] out) {
0: 		inout[0] += 3.9;
0: 		out[0] = 66.8;
1: 	}
1: 	public static void pmap(BigDecimal in, BigDecimal[] inout, BigDecimal[] out) {
1: 		inout[0] = inout[0].add(new BigDecimal(2.3));
1: 		out[0] = new BigDecimal(84.1);
1: 	}
0: 	public static void pmap(byte[] in, byte[][] inout, byte[][] out) {
1: 
0: 		inout[0][2] = 0x56;
0: 		out[0] = new byte[4];
0: 		out[0][0] = (byte) 0x09;
0: 		out[0][1] = (byte) 0xfe;
0: 		out[0][2] = (byte) 0xed;
0: 		out[0][3] = (byte) 0x02;
1: 
1: 	}
0: 	public static void pmap(Date in, Date[] inout, Date[] out) {
1: 
0: 		inout[0] = java.sql.Date.valueOf("2004-03-08");
0: 		out[0] = java.sql.Date.valueOf("2005-03-08");
1: 
1: 	}
0: 	public static void pmap(Time in, Time[] inout, Time[] out) {
0: 		inout[0] = java.sql.Time.valueOf("19:44:42");
0: 		out[0] = java.sql.Time.valueOf("20:44:42");
1: 	}
0: 	public static void pmap(Timestamp in, Timestamp[] inout, Timestamp[] out) {
1: 
0: 		inout[0] = java.sql.Timestamp.valueOf("2004-03-12 21:14:24.938222433");
0: 		out[0] = java.sql.Timestamp.valueOf("2004-04-12 04:25:26.462983731");
1: 	}
0: 	public static void pmap(String in, String[] inout, String[] out) {
0: 		inout[0] = inout[0].trim().concat("P2-PMAP");
0: 		out[0] = "P3-PMAP";
1: 	}
1: 
1: 
1: 	public static int countRows(String schema, String table) throws SQLException
1: 	{
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		Statement s = conn.createStatement();
1: 		ResultSet rs = s.executeQuery("SELECT COUNT(*) FROM " + schema + "." + table);
1: 		rs.next();
1: 		int count = rs.getInt(1);
1: 		rs.close();
1: 		s.close();
1: 		conn.close();
1: 		return count;
1: 	}
1: }
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:698f7a2
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	public static void updateRow(int p1) throws SQLException {
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		PreparedStatement ps = conn.prepareStatement("update t1 set i=i+?");
1: 		ps.setInt(1, p1);
0: 		ps.executeUpdate();
1: 		ps.close();
1: 		conn.close();
0: 	}
1: 	public static void deleteRow(int p1) throws SQLException {
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		PreparedStatement ps = conn.prepareStatement("delete from t1 where i=?");
1: 		ps.setInt(1, p1);
0: 		ps.executeUpdate();
1: 		ps.close();
1: 		conn.close();
0: 	}
1: 	
1: 	public static void alterTable() throws SQLException {
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		PreparedStatement ps = conn.prepareStatement("alter table t1 add column test integer");
1: 		ps.execute();
1: 		ps.close();
1: 		conn.close();
0: 	}
1: 	
1: 	public static void dropTable() throws SQLException {
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		PreparedStatement ps = conn.prepareStatement("drop table t1");
1: 		ps.execute();
1: 		ps.close();
1: 		conn.close();
0: 	}		
1: 	
1: 	public static void createIndex() throws SQLException {
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		PreparedStatement ps = conn.prepareStatement("create index ix on t1(i,b)");
1: 		ps.execute();
1: 		ps.close();
1: 		conn.close();
0: 	}
1: 	
1: 	public static void dropIndex() throws SQLException {
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		PreparedStatement ps = conn.prepareStatement("drop index ix");
1: 		ps.execute();
1: 		ps.close();
1: 		conn.close();
0: 	}
1: 	
1: 	public static void createTrigger() throws SQLException {
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		PreparedStatement ps = conn.prepareStatement("create trigger test_trig" +
0: 				" AFTER delete on t1 for each STATEMENT mode db2sql insert into" +
1: 				" t1 values(20, 'twenty')");
1: 		ps.execute();
1: 		ps.close();
1: 		conn.close();
0: 	}
1: 	
1: 	public static void dropTrigger() throws SQLException {
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		PreparedStatement ps = conn.prepareStatement("drop trigger test_trig");
1: 		ps.execute();
1: 		ps.close();
1: 		conn.close();
0: 	}
1: 	
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
1: 	public static int selectFromSpecificSchema(int p1) throws SQLException {
1: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
1: 		PreparedStatement ps = conn.prepareStatement("select * from mamta1.t12RoutineTest");
1: 		ps.executeQuery();
0: 		ps.close();
1: 		conn.close();
1: 		return (1);
0: 	}
0: 
commit:f52a50f
/////////////////////////////////////////////////////////////////////////
1: 	public static void ambigious2(int p1, Integer p2) {
1:         System.out.println("ambigious2(int,Integer) called");
1:     };
1: 	public static void ambigious2(Integer p1, int p2) {
1:         System.out.println("ambigious2(Integer,int) called");
1:     };
commit:f68f62f
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
1:    Derby - Class org.apache.derbyTesting.functionTests.util.ProcedureTest
0: 
0:    Copyright 2003, 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
1:       http://www.apache.org/licenses/LICENSE-2.0
0: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
0: 
0:  */
0: 
0: package org.apache.derbyTesting.functionTests.util;
0: 
0: import org.apache.derbyTesting.functionTests.util.Formatters;
0: 
0: import java.sql.*;
0: import java.math.BigDecimal;
0: /**
0: 	Java procedures for the procedure.sql test.
0: */
0: public abstract class ProcedureTest implements ResultSet {
0: 
0: 	public static void zeroArg() {
0: 		System.out.println("zeroArg() called");
0: 	}
0: 
0: 	public static void insertRow(int p1) throws SQLException {
0: 		insertRow(p1, "int");
0: 	}
0: 
0: 	public static void insertRow(int p1, String p2) throws SQLException {
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		PreparedStatement ps = conn.prepareStatement("insert into t1 values (?, ?)");
1: 		ps.setInt(1, p1);
0: 		ps.setString(2, p2);
0: 		ps.executeUpdate();
0: 		ps.close();
0: 		conn.close();
0: 	}
0: 
0: 	public static void maxMemPerTabTest() throws SQLException {
0: /*		StringBuffer sbA = new StringBuffer(20000);
0: 		for (int i = 0; i < 20000; i++)
0: 			sbA.append('a');
0: 		String largeStringA20000 = new String(sbA);
0:     largeStringA20000.substring(0,2000);
0: 
0: 		StringBuffer sbB = new StringBuffer(20000);
0: 		for (int i = 0; i < 20000; i++)
0: 			sbB.append('b');
0: 		String largeStringB20000 = new String(sbB);
0: 		String largeStringB2000 = largeStringB20000.substring(0,2000);
0: 
0: 		StringBuffer sbC = new StringBuffer(20000);
0: 		for (int i = 0; i < 20000; i++)
0: 			sbC.append('b');
0: 		String largeStringC20000 = new String(sbC);
0: 		String largeStringC2000 = largeStringC20000.substring(0,2000);
0: 
0: 		StringBuffer sbD = new StringBuffer(20000);
0: 		for (int i = 0; i < 20000; i++)
0: 			sbD.append('b');
0: 		String largeStringD20000 = new String(sbD);
0: 		String largeStringD2000 = largeStringD20000.substring(0,2000); */
0: 
0: 		String largeStringA20000 = new String(Formatters.repeatChar("a",20000));
0: 		String largeStringA2000 = new String(Formatters.repeatChar("a",2000));
0: 		String largeStringB20000 = new String(Formatters.repeatChar("b",20000));
0: 		String largeStringB2000 = new String(Formatters.repeatChar("b",2000));
0: 		String largeStringC20000 = new String(Formatters.repeatChar("c",20000));
0: 		String largeStringC2000 = new String(Formatters.repeatChar("c",2000));
0: 		String largeStringD20000 = new String(Formatters.repeatChar("d",20000));
0: 		String largeStringD2000 = new String(Formatters.repeatChar("d",2000));
0: 
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		PreparedStatement ps = conn.prepareStatement("insert into tab1 values (?, ?)");
0: 		ps.setInt(1, 1);
0: 		ps.setString(2, largeStringA20000);
0: 		ps.executeUpdate();
0: 		ps.setInt(1, 2);
0: 		ps.setString(2, largeStringB20000);
0: 		ps.executeUpdate();
0: 		ps.setInt(1, 3);
0: 		ps.setString(2, largeStringC20000);
0: 		ps.executeUpdate();
0: 		ps.close();
0: 		ps = conn.prepareStatement("insert into tab2 values (?, ?)");
0: 		ps.setInt(1, 1);
0: 		ps.setString(2, largeStringA20000);
0: 		ps.executeUpdate();
0: 		ps.setInt(1, 2);
0: 		ps.setString(2, largeStringC20000);
0: 		ps.executeUpdate();
0: 		ps.setInt(1, 3);
0: 		ps.setString(2, largeStringD20000);
0: 		ps.executeUpdate();
0: 		ps.close();
0: 		ps = conn.prepareStatement("insert into tab3 values (?, ?)");
0: 		ps.setInt(1, 1);
0: 		ps.setString(2, largeStringA2000);
0: 		ps.executeUpdate();
0: 		ps.setInt(1, 2);
0: 		ps.setString(2, largeStringB2000);
0: 		ps.executeUpdate();
0: 		ps.setInt(1, 3);
0: 		ps.setString(2, largeStringC2000);
0: 		ps.executeUpdate();
0: 		ps.close();
0: 		ps = conn.prepareStatement("insert into tab4 values (?, ?)");
0: 		ps.setInt(1, 1);
0: 		ps.setString(2, largeStringA2000);
0: 		ps.executeUpdate();
0: 		ps.setInt(1, 2);
0: 		ps.setString(2, largeStringC2000);
0: 		ps.executeUpdate();
0: 		ps.setInt(1, 3);
0: 		ps.setString(2, largeStringD2000);
0: 		ps.executeUpdate();
0: 		ps.close();
0: 		conn.close();
0: 	}
0: 
0: 	private static void insertInBig(Connection conn, String A, String B, String C, String D) throws SQLException {
0: 		PreparedStatement ps = conn.prepareStatement("insert into big values (?, ?, ?, ?)");
0: 		ps.setString(1, A);
0: 		ps.setString(2, B);
0: 		ps.setString(3, C);
0: 		ps.setString(4, D);
0: 		ps.executeUpdate();
0: 		ps.close();
0: 	}
0: 
0: 	public static void bigTestData(int i) throws SQLException {
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		switch (i)
0: 		{
0: 			case 1:
0: 				String largeStringA10000 = new String(Formatters.repeatChar("a",10000));
0: 				String largeStringB10000 = new String(Formatters.repeatChar("b",10000));
0: 				String largeStringC10000 = new String(Formatters.repeatChar("c",10000));
0: 				String largeStringD10000 = new String(Formatters.repeatChar("d",10000));
0: 				insertInBig(conn, largeStringA10000, largeStringB10000, largeStringC10000, largeStringD10000);
1: 				break;
0: 			case 2:
0: 				largeStringA10000 = new String(Formatters.repeatChar("e",10000));
0: 				largeStringB10000 = new String(Formatters.repeatChar("f",10000));
0: 				largeStringC10000 = new String(Formatters.repeatChar("g",10000));
0: 				largeStringD10000 = new String(Formatters.repeatChar("h",10000));
0: 				insertInBig(conn, largeStringA10000, largeStringB10000, largeStringC10000, largeStringD10000);
1: 				break;
0: 			case 3:
0: 				largeStringA10000 = new String(Formatters.repeatChar("i",10000));
0: 				largeStringB10000 = new String(Formatters.repeatChar("j",10000));
0: 				largeStringC10000 = new String(Formatters.repeatChar("k",10000));
0: 				largeStringD10000 = new String(Formatters.repeatChar("l",10000));
0: 				insertInBig(conn, largeStringA10000, largeStringB10000, largeStringC10000, largeStringD10000);
1: 				break;
0: 			case 4:
0: 				largeStringA10000 = new String(Formatters.repeatChar("m",10000));
0: 				largeStringB10000 = new String(Formatters.repeatChar("n",10000));
0: 				largeStringC10000 = new String(Formatters.repeatChar("o",10000));
0: 				largeStringD10000 = new String(Formatters.repeatChar("p",10000));
0: 				insertInBig(conn, largeStringA10000, largeStringB10000, largeStringC10000, largeStringD10000);
1: 				break;
0: 			case 5:
0: 				String largeStringA30000 = new String(Formatters.repeatChar("a",30000));
0: 				String largeStringB2752 = new String(Formatters.repeatChar("b",2752));
0: 				PreparedStatement ps = conn.prepareStatement("insert into big values (?, ?)");
0: 				ps.setString(1, largeStringA30000);
0: 				ps.setString(2, largeStringB2752);
0: 				ps.executeUpdate();
0: 				ps.close();
1: 				break;
0: 			case 6:
0: 				largeStringA30000 = new String(Formatters.repeatChar("a",30000));
0: 				String largeStringB2750 = new String(Formatters.repeatChar("b",2750));
0: 				ps = conn.prepareStatement("insert into big values (?, ?)");
0: 				ps.setString(1, largeStringA30000);
0: 				ps.setString(2, largeStringB2750);
0: 				ps.executeUpdate();
0: 				ps.close();
1: 				break;
0: 			case 7:
0: 				String largeStringA40000 = new String(Formatters.repeatChar("a",40000));
0: 				ps = conn.prepareStatement("insert into big values (?)");
0: 				ps.setString(1, largeStringA40000);
0: 				ps.executeUpdate();
0: 				ps.close();
1: 				break;
0: 			case 8:
0: 				largeStringA40000 = new String(Formatters.repeatChar("a",40000));
0: 				String largeStringB40000 = new String(Formatters.repeatChar("b",40000));
0: 				String largeStringC40000 = new String(Formatters.repeatChar("c",40000));
0: 				ps = conn.prepareStatement("insert into big values (?, ?, ?)");
0: 				ps.setString(1, largeStringA40000);
0: 				ps.setString(2, largeStringB40000);
0: 				ps.setString(3, largeStringC40000);
0: 				ps.executeUpdate();
0: 				largeStringA40000 = new String(Formatters.repeatChar("d",40000));
0: 				largeStringB40000 = new String(Formatters.repeatChar("e",40000));
0: 				largeStringC40000 = new String(Formatters.repeatChar("f",40000));
0: 				ps.setString(1, largeStringA40000);
0: 				ps.setString(2, largeStringB40000);
0: 				ps.setString(3, largeStringC40000);
0: 				ps.executeUpdate();
0: 				ps.close();
1: 				break;
0: 		}
0: 		conn.close();
0: 	}
0: 
0: 	//public static void selectRows_coll(int p1, java.util.Collection rs) throws SQLException {
0: 
0: 	//	ResultSet[] d1 = new ResultSet[1];
0: 	//	selectRows(p1, d1);
0: 	//	rs.add(d1[0]);
0: 	//}
0: 
0: 	public static void selectRows(int p1, ResultSet[] data) throws SQLException {
0: 
0: 		System.out.println("selectRows - 1 arg - 1 rs");
0: 
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		PreparedStatement ps = conn.prepareStatement("select * from t1 where i = ?");
1: 		ps.setInt(1, p1);
0: 		data[0] = ps.executeQuery();
0: 		conn.close();
0: 	}
0: 	public static void selectRows(int p1, int p2, ResultSet[] data1, ResultSet[] data2) throws SQLException {
0: 
0: 		System.out.println("selectRows - 2 arg - 2 rs");
0: 
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		PreparedStatement ps = conn.prepareStatement("select * from t1 where i = ?");
1: 		ps.setInt(1, p1);
1: 		data1[0] = ps.executeQuery();
0: 
0: 		ps = conn.prepareStatement("select * from t1 where i >= ?");
1: 		ps.setInt(1, p2);
1: 		data2[0] = ps.executeQuery();
0: 
0: 		if (p2 == 99)
1: 			data2[0].close();
0: 
0: 		// return no results
0: 		if (p2 == 199) {
0: 			data1[0] = null;
0: 			data2[0] = null;
0: 		}
0: 
0: 		// swap results
0: 		if (p2 == 299) {
0: 			ResultSet rs = data1[0];
0: 			data1[0] = data2[0];
0: 			data2[0] = rs;
0: 		}
0: 
0: 		conn.close();
0: 	}
0: 
0: 	public static void fivejp(ResultSet[] data1, ResultSet[] data2, ResultSet[] data3, ResultSet[] data4, ResultSet[] data5) throws SQLException {
0: 
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 
0: 		PreparedStatement ps1 = conn.prepareStatement("select * from MRS.FIVERS where i > ?");
0: 		ps1.setInt(1, 1);
0: 		data1[0] = ps1.executeQuery();
0: 
0: 		PreparedStatement ps2 = conn.prepareStatement("select * from MRS.FIVERS  where i > ?");
0: 		ps2.setInt(1, 2);
0: 		data2[0] = ps2.executeQuery();
0: 
0: 		PreparedStatement ps3 = conn.prepareStatement("select * from MRS.FIVERS  where i > ?");
0: 		ps3.setInt(1, 3);
0: 		data3[0] = ps3.executeQuery();
0: 
0: 		PreparedStatement ps4 = conn.prepareStatement("select * from MRS.FIVERS  where i > ?");
0: 		ps4.setInt(1, 4);
0: 		data4[0] = ps4.executeQuery();
0: 
0: 		PreparedStatement ps5 = conn.prepareStatement("select * from MRS.FIVERS  where i > ?");
0: 		ps5.setInt(1, 5);
0: 		data5[0] = ps5.executeQuery();
0: 
0: 		conn.close();
0: 	}
0: 
0: 	public static void parameter1(int a, String b, String c, java.sql.ResultSet[] rs) throws SQLException {
0: 
0: 		System.out.print("PT1 a=" + a);
0: 		if (b == null)
0: 			System.out.println(" b = null");
0: 		else
0: 			System.out.print(" b=<"+b+">("+b.length()+")");
0: 		if (c == null)
0: 			System.out.println(" c = null");
0: 		else
0: 			System.out.print(" c=<"+c+">("+c.length()+")");
0: 
0: 		System.out.println("");
0: 
0: 
0: 
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		PreparedStatement ps = conn.prepareStatement("insert into PT1 values (?, ?, ?)");
0: 		ps.setInt(1, a);
0: 		ps.setString(2, b);
0: 		ps.setString(3, c);
0: 		ps.executeUpdate();
0: 		ps.close();
0: 		ps = conn.prepareStatement("select a,b, length(b), c, length(c) from PT1 where a = ?");
0: 		ps.setInt(1, a);
0: 		rs[0] = ps.executeQuery();
0: 		conn.close();
0: 	}
0: 
0: 	public static void parameter2(int a, java.math.BigDecimal b, java.math.BigDecimal c, java.sql.ResultSet[] rs) throws SQLException {
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		PreparedStatement ps = conn.prepareStatement("insert into PT1 values (?, ?, ?)");
0: 		ps.setInt(1, a);
0: 		ps.setString(2, b.toString());
0: 		ps.setString(3, c.toString());
0: 		ps.executeUpdate();
0: 		ps.close();
0: 		ps = conn.prepareStatement("select a,b,c from PT1 where a = ?");
0: 		ps.setInt(1, a);
0: 		rs[0] = ps.executeQuery();
0: 		conn.close();
0: 	}
0: 
0: 
0: 	public static void outparams1(int[] p1, int p2) {
0: 
0: 		p1[0] = p2 * 2;
0: 	}
0: 
0: 	// Test for CLOB being returned.
0: 	public static void clobselect (ResultSet[] results, 
0: 								   ResultSet[] results1,
0: 								   ResultSet[] results2
0: 								   )
0: 		throws Exception
0: 	{
0: 
0:         Connection conn = DriverManager.getConnection(
0: 			"jdbc:default:connection");
0: 		PreparedStatement st = conn.prepareStatement("select * from lobCheckOne");
0: 		results[0] = st.executeQuery();
0: 		// Just some regular data
0: 		PreparedStatement st1 = conn.prepareStatement("select count(*) from lobCheckOne");
0: 		results1[0] = st1.executeQuery();
0: 		// Now more Clobs
0: 		PreparedStatement st2 = conn.prepareStatement("select * from lobCheckOne");
0: 		results2[0] = st2.executeQuery();
0: 		conn.close();
0: 		return;
0: 
0: 	}
0: 
0: 	// Test for BLOB being returned.
0: 	public static void blobselect (ResultSet[] results)
0: 		throws Exception
0: 	{
0: 
0:         Connection conn = DriverManager.getConnection(
0: 			"jdbc:default:connection");
0: 		PreparedStatement st = conn.prepareStatement("select * from lobCheckTwo");
0: 		results[0] = st.executeQuery();
0: 		conn.close();
0: 		return;
0: 
0: 	}
0: 
0: 	public static void inoutparams2(int[] p1, int p2) {
0: 
0: 		p1[0] = p1[0] + (p2 * 2);
0: 	}
0: 	public static void inoutparams3(String[] p1, int p2) {
0: 
0: 		if (p1[0] == null)
0: 			System.out.println("p1 is NULL");
0: 		else
0: 			System.out.println("p1= >" + p1[0] + "< length " + p1[0].length());
0: 		
0: 		if (p2 == 8)
0: 			p1[0] = "nad";
0: 		else if (p2 == 9)
0: 			p1[0] = null;
0: 		else if (p2 == 10)
0: 			p1[0] = "abcdefghijklmnopqrstuvwzyz";
0: 	}
0: 	public static void inoutparams4(java.math.BigDecimal[] p1, String p2) {
0: 		if (p2 == null)
0: 			p1[0] = null;
0: 		else {
0: 			if (p1[0] == null)
0: 				p1[0] = new BigDecimal(p2).add(new BigDecimal("17"));
0: 			else
0: 				p1[0] = new BigDecimal(p2).add(p1[0]);
0: 		}
0: 	}
0: 
0: 	public static void ambigious1(int p1, String p2, ResultSet[] data1, ResultSet[] data2) {}
0: 	public static void ambigious1(int p1, String p2, ResultSet[] data1) {}
0: 
0: 
0: 	public static void ambigious2(int p1, Integer p2) {};
0: 	public static void ambigious2(Integer p1, int p2) {};
0: 
0: 	public static void missingDynamicParameter(int p1)  {}
0: 	public static void missingDynamicParameter(int p1, Object p2)  {}
0: 
0: 	public static void badDynamicParameter(int p1, ProcedureTest[] data) {}
0: 
0: 	public static void zeroArgDynamicResult(ResultSet[] data1, ResultSet[] data2, ResultSet[] data3, ResultSet[] data4) {
0: 		System.out.println("zeroArgDynamicResult called");
0: 	}
0: 
0: 
0: 	public static void sqlControl(String[] e1, String[] e2, String[] e3, String[] e4, String[] e5, String[] e6, String[] e7)
1: 		throws SQLException {
0: 
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 
0: 		Statement s = conn.createStatement();
0: 
0: 		executeStatement(s, "CREATE TABLE SQLCONTROL_DDL (I INT)", e1);
0: 		executeStatement(s, "ALTER TABLE SQLC.SQLCONTROL_DML ADD COLUMN B INT DEFAULT NULL", e2);
0: 
0: 		executeStatement(s, "INSERT INTO SQLC.SQLCONTROL_DML(I) VALUES (1)", e3);
0: 		executeStatement(s, "UPDATE SQLC.SQLCONTROL_DML SET I = I + 11", e4);
0: 		executeStatement(s, "SELECT * FROM SQLC.SQLCONTROL_DML", e5);
0: 		executeStatement(s, "DELETE FROM SQLC.SQLCONTROL_DML", e6);
0: 
0: 		executeStatement(s, "DROP TABLE SQLC.SQLCONTROL_DML", e7);
0: 
0: 		conn.close();
0: 
0: 	}
0: 	public static void sqlControl2(String[] e1, String[] e2, String[] e3, String[] e4, String[] e5, String[] e6, String[] e7)
1: 		throws SQLException {
0: 
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 
0: 		Statement s = conn.createStatement();
0: 
0: 		executeStatement(s, "CREATE VIEW SQLCONTROL_VIEW AS SELECT * FROM SQLC.SQLCONTROL_DML", e1);
0: 		executeStatement(s, "DROP VIEW SQLCONTROL_VIEW", e2);
0: 
0: 		executeStatement(s, "LOCK TABLE SQLC.SQLCONTROL_DML IN EXCLUSIVE MODE", e3);
0: 		executeStatement(s, "VALUES 1,2,3", e4);
0: 		executeStatement(s, "SET SCHEMA SQLC", e5);
0: 		executeStatement(s, "CREATE SCHEMA SQLC_M", e6);
0: 		executeStatement(s, "DROP SCHEMA SQLC_M RESTRICT", e7);
0: 
0: 		conn.close();
0: 
0: 	}
0: 	public static void sqlControl3(String[] e1, String[] e2, String[] e3, String[] e4, String[] e5, String[] e6, String[] e7)
1: 		throws SQLException {
0: 
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 
0: 		Statement s = conn.createStatement();
0: 
0: 		e1[0] = "IBM CS FEATURE";
0: 		e2[0] = "IBM CS FEATURE";
0: 
0: 		executeStatement(s, "SET ISOLATION CS", e3);
0: 		executeStatement(s, "SET RUNTIMESTATISTICS OFF", e4);
0: 		executeStatement(s, "SET STATISTICS TIMING OFF", e5);
0: 		executeStatement(s, "VALUES 1", e6);
0: 
0: 		executeStatement(s, "VALUES 1", e7);
0: 
0: 		conn.close();
0: 
0: 	}
0: 	public static void sqlControl4(int sqlc, String[] e1, String[] e2, String[] e3, String[] e4, String[] e5, String[] e6, String[] e7, String[] e8)
1: 		throws SQLException {
0: 
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 
0: 		Statement s = conn.createStatement();
0: 
0: 		String sql = "CALL SQLC.SQLCONTROL2_"+sqlc+" (?, ?, ?, ?, ?, ?, ?) ";
0: 
0: 		e1[0] = sql;
0: 
0: 		CallableStatement cs1 = conn.prepareCall(sql);
0: 		try {
0: 			for (int rop = 1; rop <= 7; rop++) {
0: 				cs1.registerOutParameter(rop, Types.VARCHAR);
0: 			}
0: 			cs1.execute();
0: 
0: 			e2[0] = cs1.getString(1);
0: 			e3[0] = cs1.getString(2);
0: 			e4[0] = cs1.getString(3);
0: 			e5[0] = cs1.getString(4);
0: 			e6[0] = cs1.getString(5);
0: 			e7[0] = cs1.getString(6);
0: 			e8[0] = cs1.getString(7);
0: 		} catch (SQLException sqle) {
0: 			StringBuffer sb = new StringBuffer(128);
0: 			sb.append("STATE");
0: 			do {
0: 				sb.append("-");
0: 				String ss = sqle.getSQLState();
0: 				if (ss == null)
0: 					ss= "?????";
0: 				sb.append(ss);
0: 				sqle = sqle.getNextException();
0: 			} while (sqle != null);
0: 			e2[0] = sb.toString();
0: 		}
0: 
0: 		cs1.close();
0: 
0: 		conn.close();
0: 
0: 	}
0: 	private static void executeStatement(Statement s, String sql, String[] result) {
0: 
0: 		StringBuffer sb = new StringBuffer(128);
0: 
0: 		int len = sql.length();
0: 		if (len > 15)
0: 			len = 15;
0: 
0: 		sb.append(sql.substring(0, len));
0: 		try {
0: 			if (s.execute(sql)) {
0: 				ResultSet rs = s.getResultSet();
0: 				while (rs.next())
0: 					sb.append("- ROW(" + rs.getString(1) + ")");
0: 				rs.close();
0: 			} else {
0: 				sb.append("-UPDATE " + s.getUpdateCount());
0: 			}
0: 
0: 			sb.append("-EXECUTE OK");
0: 
0: 		} catch (SQLException sqle) {
0: 
0: 			
0: 			do {
0: 				sb.append("-");
0: 				String ss = sqle.getSQLState();
0: 				if (ss == null)
0: 					ss= "?????";
0: 				sb.append(ss);
0: 				sqle = sqle.getNextException();
0: 			} while (sqle != null);
0: 
0: 			
0: 		}
0: 		result[0] = sb.toString();
0: 	}
0: 
0: 
0: 	public static void oBOOLEAN(Boolean in, Boolean[] inout, Boolean[] out) throws SQLException {
0: 
0: 		if (out[0] != null)
0: 			throw new SQLException ("oBOOLEAN expected out[] to be null");
0: 
0: 		out[0] = in;
0: 		if (in == null)
0: 			inout[0] = null;
0: 		else
0: 			inout[0] = new Boolean(inout[0].booleanValue() && in.booleanValue());
0: 
0: 	}
0: 
0: 	public static void pBOOLEAN(boolean in, boolean[] inout, boolean[] out) throws SQLException {
0: 
0: 		if (out[0] != false)
0: 			throw new SQLException ("pBOOLEAN expected out[] to be null");
0: 
0: 		out[0] = in;
0: 		inout[0] =inout[0] && in;
0: 
0: 	}
0: 	public static void oALLINT(Integer in, Integer[] inout, Integer[] out) throws SQLException {
0: 
0: 		if (out[0] != null)
0: 			throw new SQLException ("oALLINT expected out[] to be null");
0: 
0: 		out[0] = in;
0: 		if (in == null)
0: 			;//inout[0] = null;
0: 		else if (inout[0] == null)
0: 			inout[0] = new Integer(3 * in.intValue());
0: 		else
0: 			inout[0] = new Integer(inout[0].intValue() + in.intValue());
0: 	}
0: 	public static void pTINYINT(byte in, byte[] inout, byte[] out) throws SQLException {
0: 
0: 		out[0] = in;
0: 		inout[0] += in;
0: 	}
0: 	public static void pSMALLINT(short in, short[] inout, short[] out) throws SQLException {
0: 
0: 		out[0] = in;
0: 		inout[0] += in;
0: 	}
0: 
0: 	/*
0: 	** Procedures for testing literals passed to procedures as IN parameters
0: 	*/
0: 
0: 	public static void literalTest(int p1, String[] p2) {
0: 		p2[0] = ">" + Integer.toString(p1) + "<";
0: 	}
0: 	public static void literalTest(long p1, String[] p2) {
0: 		p2[0] = ">" + Long.toString(p1) + "<";
0: 	}
0: 	public static void literalTest(float p1, String[] p2) {
0: 		p2[0] = ">" + Float.toString(p1) + "<";
0: 	}
0: 	public static void literalTest(double p1, String[] p2) {
0: 		p2[0] = ">" + Double.toString(p1) + "<";
0: 	}
0: 	public static void literalTest(BigDecimal p1, String[] p2) {
0: 		String s = p1 == null ? "NULL" : p1.toString();
0: 		p2[0] = ">" + s + "<";
0: 	}
0: 	public static void literalTest(String p1, String[] p2) {
0: 		String s = p1 == null ? "NULL" : p1.toString();
0: 		p2[0] = ">" + s + "<";
0: 	}
0: 	public static void literalTest(java.sql.Date p1, String[] p2) {
0: 		String s = p1 == null ? "NULL" : p1.toString();
0: 		p2[0] = ">" + s + "<";
0: 	}
0: 	public static void literalTest(java.sql.Time p1, String[] p2) {
0: 		String s = p1 == null ? "NULL" : p1.toString();
0: 		p2[0] = ">" + s + "<";
0: 	}
0: 	public static void literalTest(java.sql.Timestamp p1, String[] p2) {
0: 
0: 		String s = p1 == null ? "NULL" : p1.toString();
0: 		p2[0] = ">" + s + "<";
0: 	}
0: 
0: 
0: 	/*
0: 	** Procedures for parameter mapping testing.
0: 	*/
0: 
0: 	public static void pmap(short in, short[] inout, short[] out) {
0: 
0: 		inout[0] += 6;
0: 		out[0] = 77;
0: 	}
0: 	public static void pmap(int in, int[] inout, int[] out) {
0: 		inout[0] += 9;
0: 		out[0] = 88;
0: 
0: 	}
0: 	public static void pmap(long in, long[] inout, long[] out) {
0: 		inout[0] += 8;
0: 		out[0] = 99;
0: 	}
0: 	public static void pmap(float in, float[] inout, float[] out) {
0: 		inout[0] += 9.9f;
0: 		out[0] = 88.8f;
0: 	}
0: 	public static void pmap(double in, double[] inout, double[] out) {
0: 		inout[0] += 3.9;
0: 		out[0] = 66.8;
0: 	}
0: 	public static void pmap(BigDecimal in, BigDecimal[] inout, BigDecimal[] out) {
0: 		inout[0] = inout[0].add(new BigDecimal(2.3));
0: 		out[0] = new BigDecimal(84.1);
0: 	}
0: 	public static void pmap(byte[] in, byte[][] inout, byte[][] out) {
0: 
0: 		inout[0][2] = 0x56;
0: 		out[0] = new byte[4];
0: 		out[0][0] = (byte) 0x09;
0: 		out[0][1] = (byte) 0xfe;
0: 		out[0][2] = (byte) 0xed;
0: 		out[0][3] = (byte) 0x02;
0: 
0: 	}
0: 	public static void pmap(Date in, Date[] inout, Date[] out) {
0: 
0: 		inout[0] = java.sql.Date.valueOf("2004-03-08");
0: 		out[0] = java.sql.Date.valueOf("2005-03-08");
0: 
0: 	}
0: 	public static void pmap(Time in, Time[] inout, Time[] out) {
0: 		inout[0] = java.sql.Time.valueOf("19:44:42");
0: 		out[0] = java.sql.Time.valueOf("20:44:42");
0: 	}
0: 	public static void pmap(Timestamp in, Timestamp[] inout, Timestamp[] out) {
0: 
0: 		inout[0] = java.sql.Timestamp.valueOf("2004-03-12 21:14:24.938222433");
0: 		out[0] = java.sql.Timestamp.valueOf("2004-04-12 04:25:26.462983731");
0: 	}
0: 	public static void pmap(String in, String[] inout, String[] out) {
0: 		inout[0] = inout[0].trim().concat("P2-PMAP");
0: 		out[0] = "P3-PMAP";
0: 	}
0: 
0: 
0: 	public static int countRows(String schema, String table) throws SQLException
0: 	{
0: 		Connection conn = DriverManager.getConnection("jdbc:default:connection");
0: 		Statement s = conn.createStatement();
0: 		ResultSet rs = s.executeQuery("SELECT COUNT(*) FROM " + schema + "." + table);
0: 		rs.next();
0: 		int count = rs.getInt(1);
0: 		rs.close();
0: 		s.close();
0: 		conn.close();
0: 		return count;
0: 	}
0: }
0: 
commit:c1c71ef
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class org.apache.derbyTesting.functionTests.util.ProcedureTest
0: 
0:    Copyright 2003, 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
commit:cb1ca12
/////////////////////////////////////////////////////////////////////////
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:fe17005
/////////////////////////////////////////////////////////////////////////
1: 			data1[0].close();
0: 			data2[0].close();
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:ecd2625
/////////////////////////////////////////////////////////////////////////
1: public abstract class ProcedureTest extends SimpleProcedureTest implements ResultSet {
/////////////////////////////////////////////////////////////////////////
1: 	** Procedure which uses BigDecimal - for parameter mapping testing.
commit:88e3d5f
/////////////////////////////////////////////////////////////////////////
commit:41f1df9
/////////////////////////////////////////////////////////////////////////
1: 			case 9:
1: 				String lStringA32672 = new String(Formatters.repeatChar("a",32672));
1: 				String lStringB32672 = new String(Formatters.repeatChar("b",32672));
1: 				String lStringC32672 = new String(Formatters.repeatChar("c",32672));
1: 				String lStringD32672 = new String(Formatters.repeatChar("d",32672));
1: 				insertInBig(conn, lStringA32672, lStringB32672, lStringC32672, lStringD32672);
0: 				break;
commit:3292941
/////////////////////////////////////////////////////////////////////////
0:     
0:     /**
1:      * Procedure installed to test multiple ResultSets in the lang/procedure.java
1:      * test class. 
1:      * 
1:      * @param p1 Number parameter for the first ResultSet
1:      * @param p2 Number parameter for the second ResultSet 
1:      * @param data1 The first ResultSet to be returned.
1:      * @param data2 The Second ResultSet to be returned
1:      * @throws SQLException
0:      */
1:      public static void multiResult(int p1, int p2, ResultSet[] data1, ResultSet[] data2) 
0:         throws SQLException {
0: 
0:         Connection conn = DriverManager.getConnection("jdbc:default:connection");
1:         PreparedStatement ps = conn.prepareStatement("select * from AutoCommitTable where num = ?");
0:         ps.setInt(1, p1);
0:         data1[0] = ps.executeQuery();
0: 
1:         ps = conn.prepareStatement("select * from AutoCommitTable where num = ?");
0:         ps.setInt(1, p2);
0:         data2[0] = ps.executeQuery();
0: 
0:         conn.close();
0:      }
============================================================================