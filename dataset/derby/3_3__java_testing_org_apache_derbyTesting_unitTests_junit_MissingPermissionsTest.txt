1:55720b3: /*
5:55720b3: 
1:55720b3:    Derby - Class org.apache.derbyTesting.unitTests.junit.MissingPermissionsTest
1:55720b3: 
1:55720b3:    Licensed to the Apache Software Foundation (ASF) under one or more
1:55720b3:    contributor license agreements.  See the NOTICE file distributed with
1:55720b3:    this work for additional information regarding copyright ownership.
1:55720b3:    The ASF licenses this file to You under the Apache License, Version 2.0
1:55720b3:    (the "License"); you may not use this file except in compliance with
1:55720b3:    the License.  You may obtain a copy of the License at
1:55720b3: 
1:55720b3:       http://www.apache.org/licenses/LICENSE-2.0
1:55720b3: 
1:55720b3:    Unless required by applicable law or agreed to in writing, software
1:55720b3:    distributed under the License is distributed on an "AS IS" BASIS,
1:55720b3:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:55720b3:    See the License for the specific language governing permissions and
1:55720b3:    limitations under the License.
1:55720b3: 
1:55720b3: */
1:55720b3: 
1:55720b3: package org.apache.derbyTesting.unitTests.junit;
1:55720b3: 
1:55720b3: import java.io.BufferedReader;
1:55720b3: import java.io.FileNotFoundException;
1:55720b3: import java.io.FileReader;
1:55720b3: import java.io.IOException;
1:a2ecbd3: import java.security.AccessControlException;
1:55720b3: import java.security.AccessController;
1:a2ecbd3: import java.security.PrivilegedAction;
1:55720b3: import java.security.PrivilegedActionException;
1:55720b3: import java.security.PrivilegedExceptionAction;
1:55720b3: import java.sql.Connection;
1:55720b3: import java.sql.SQLException;
1:55720b3: import java.util.ArrayList;
1:55720b3: import java.util.List;
1:55720b3: import java.util.Properties;
1:f6df184: import java.util.regex.Pattern;
1:55720b3: import junit.framework.Test;
1:55720b3: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:55720b3: import org.apache.derbyTesting.junit.BaseTestSuite;
1:55720b3: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:55720b3: import org.apache.derbyTesting.junit.SpawnedProcess;
1:55720b3: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:55720b3: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1:55720b3: import org.apache.derbyTesting.junit.TestConfiguration;
1:55720b3: 
1:55720b3: /**
1:55720b3:  * Test behavior when permissions are missing for:
1:55720b3:  * <ul>
1:55720b3:  *   <li>reading of system properties, see DERBY-6617</li>
1:55720b3:  *   <li>read, write access to create derby.system.home, see DERBY-6617</li>
1:55720b3:  * </ul>
1:55720b3:  * Note: requires English locale because the test asserts on localized
1:55720b3:  * strings.
1:55720b3:  */
1:55720b3: public class MissingPermissionsTest extends BaseJDBCTestCase {
1:55720b3: 
1:55720b3:     private final static String AUTH_MSG =
1:55720b3:             "derby.connection.requireAuthentication";
1:55720b3: 
1:55720b3:     private final static String SYSTEM_HOME = "derby.system.home";
1:55720b3: 
1:55720b3:     private final static String resourcePrefix = "unitTests/junit/";
1:55720b3:     private final static String testPrefix =
1:55720b3:             "org/apache/derbyTesting/" + resourcePrefix;
1:55720b3: 
1:55720b3:     private final static String OK_POLICY =
1:55720b3:             "MissingPermissionsTest.policy";
1:55720b3:     private final static String OK_POLICY_T =
1:55720b3:             testPrefix + OK_POLICY;
1:a2ecbd3:     private final static String OK_POLICY_R =
1:a2ecbd3:             resourcePrefix + OK_POLICY;
1:55720b3: 
1:55720b3:     private final static String POLICY_MINUS_PROPERTYPERMISSION =
1:55720b3:             "MissingPermissionsTest1.policy";
1:55720b3: 
1:55720b3:     private final static String POLICY_MINUS_PROPERTYPERMISSION_T =
1:55720b3:             testPrefix + POLICY_MINUS_PROPERTYPERMISSION;
1:55720b3: 
1:55720b3:     private final static String POLICY_MINUS_FILEPERMISSION =
1:55720b3:             "MissingPermissionsTest2.policy";
1:55720b3: 
1:55720b3:     private final static String POLICY_MINUS_FILEPERMISSION_T =
1:55720b3:             testPrefix + POLICY_MINUS_FILEPERMISSION;
1:55720b3: 
1:55720b3:     private final static String POLICY_MINUS_FILEPERMISSION_R =
1:55720b3:             resourcePrefix + POLICY_MINUS_FILEPERMISSION;
1:55720b3: 
1:55720b3:     private final int KIND_EXPECT_ERROR_MSG_PRESENT = 0;
1:55720b3:     private final int KIND_EXPECT_ERROR_MSG_ABSENT = 1;
1:55720b3: 
1:a2ecbd3:     /**
1:a2ecbd3:      * Used for running #testModifyThreadGroup
1:a2ecbd3:      */
1:a2ecbd3:     private static boolean inSubProcess = false;
1:a2ecbd3: 
1:55720b3:     public MissingPermissionsTest(String name) {
1:55720b3:         super(name);
4:55720b3:     }
1:55720b3: 
1:55720b3: 
1:55720b3:     private static Test makeTest(String fixture, String policy) {
1:55720b3:         Test t =  new MissingPermissionsTest(fixture);
1:55720b3:         t = new SecurityManagerSetup(t, policy);
1:55720b3:         final Properties props = new Properties();
1:55720b3:         props.setProperty("derby.connection.requireAuthentication", "true");
1:55720b3:         props.setProperty("derby.database.sqlAuthorization", "true");
1:55720b3:         props.setProperty("derby.authentication.provider", "BUILTIN");
1:55720b3:         props.setProperty("derby.user.APP", "APPPW");
1:55720b3: 
1:55720b3:         t = new SystemPropertyTestSetup(t, props, true);
1:55720b3:         t = TestConfiguration.changeUserDecorator(t, "APP", "APPPW");
1:55720b3:         t = TestConfiguration.singleUseDatabaseDecorator(t);
1:55720b3:         return t;
1:55720b3:     }
1:55720b3: 
1:55720b3:     public static Test suite() {
1:a2ecbd3:         inSubProcess = Boolean.getBoolean("inSubProcess");
1:a2ecbd3: 
1:55720b3:         final BaseTestSuite suite =
1:55720b3:                 new BaseTestSuite("SystemPrivilegesPermissionTest");
1:55720b3: 
1:a2ecbd3:         if (!inSubProcess && !TestConfiguration.loadingFromJars()) {
1:a2ecbd3:             // This test only works with jar files. Only check at top
1:a2ecbd3:             // level
1:f6df184:             return suite;
1:55720b3:         }
1:55720b3: 
1:a2ecbd3:         if (!inSubProcess) {
1:a2ecbd3:             suite.addTest(
1:a2ecbd3:                     new SupportFilesSetup(
1:a2ecbd3:                             makeTest("testMissingFilePermission",
1:a2ecbd3:                                     POLICY_MINUS_FILEPERMISSION_T),
1:a2ecbd3:                             new String[] {
1:a2ecbd3:                                 POLICY_MINUS_FILEPERMISSION_R}));
1:55720b3: 
1:a2ecbd3:             suite.addTest(makeTest("testPresentPropertiesPermission",
1:a2ecbd3:                     OK_POLICY_T));
1:55720b3: 
1:a2ecbd3:             suite.addTest(makeTest("testMissingPropertiesPermission",
1:a2ecbd3:                     POLICY_MINUS_PROPERTYPERMISSION_T));
1:a2ecbd3:         }
1:55720b3: 
1:a2ecbd3:         // This test runs in both the top process and a subprocess since it has
1:a2ecbd3:         // two parts:
1:a2ecbd3:         suite.addTest(new SupportFilesSetup(makeTest("testModifyThreadGroup",
1:a2ecbd3:                 OK_POLICY_T),
1:a2ecbd3:                 new String[] {OK_POLICY_R}));
1:55720b3:         return suite;
1:55720b3:     }
1:55720b3: 
1:55720b3:     /**
1:55720b3:      * This test is run with a policy that does not lack permission to read
1:55720b3:      * properties for derby.jar. This should leave no related error messages on
1:55720b3:      * derby.log.
1:55720b3:      *
1:55720b3:      * @throws SQLException
1:55720b3:      * @throws IOException
1:55720b3:      * @throws PrivilegedActionException
1:55720b3:      */
1:55720b3:     public void testPresentPropertiesPermission()
1:55720b3:             throws SQLException, IOException, PrivilegedActionException {
1:55720b3: 
1:55720b3:         // With credentials we are OK
1:55720b3:         openDefaultConnection("APP", "APPPW").close();
1:55720b3: 
1:55720b3:         Connection c = null;
1:55720b3: 
1:55720b3:         // With wrong credentials we are not OK
1:55720b3:         try {
1:55720b3:             c = openDefaultConnection("Donald", "Duck");
1:55720b3:             fail();
1:55720b3:         } catch(SQLException e) {
1:55720b3:             assertSQLState("08004", e);
1:55720b3:         } finally {
1:55720b3:             if (c != null) {
1:55720b3:                 c.close();
1:55720b3:             }
1:55720b3:         }
1:55720b3:         verifyMessagesInDerbyLog(KIND_EXPECT_ERROR_MSG_ABSENT);
1:55720b3:     }
1:55720b3: 
1:55720b3:     /**
1:55720b3:      * This test is run with a policy that lacks permission to read properties
1:55720b3:      * for derby.jar. This should lead to error messages on derby.log.
1:55720b3:      *
1:55720b3:      * @throws SQLException
1:55720b3:      * @throws IOException
1:55720b3:      * @throws PrivilegedActionException
1:55720b3:      */
1:55720b3:     public void testMissingPropertiesPermission()
1:55720b3:             throws SQLException, IOException, PrivilegedActionException {
1:55720b3:         // With credentials we are OK
1:55720b3:         openDefaultConnection("APP", "APPPW").close();
1:55720b3: 
1:55720b3:         // But also with wrong ones, all seems OK...
1:55720b3:         openDefaultConnection("Donald", "Duck").close();
1:55720b3: 
1:55720b3:         // Check that we see the error messages expected in derby.log
1:55720b3:         verifyMessagesInDerbyLog(KIND_EXPECT_ERROR_MSG_PRESENT);
1:55720b3:     }
1:55720b3: 
1:55720b3:     /**
1:55720b3:      * This test is run with a policy that lacks permission for derby.jar to
1:55720b3:      * create a db directory for derby.  In this scenario we expect the boot to
1:55720b3:      * fail, and an error message to be printed to the console, so we try to
1:55720b3:      * get it by forking a sub-process. See {@code FileMonitor#PBinitialize}
1:55720b3:      * when it gets a {@code SecurityException} following attempt to do "{@code
1:55720b3:      * home.mkdir(s)}".
1:55720b3:      * <p/>
1:55720b3:      * Note that the policy used with this text fixture also doubles as the
1:55720b3:      * one used by the subprocess to demonstrate the lack of permission.
1:55720b3:      *
1:55720b3:      * @throws SQLException
1:55720b3:      * @throws IOException
1:55720b3:      * @throws PrivilegedActionException
1:55720b3:      * @throws ClassNotFoundException
1:55720b3:      * @throws java.lang.InterruptedException
1:55720b3:      */
1:55720b3:     public void testMissingFilePermission() throws SQLException,
1:55720b3:             IOException,
1:55720b3:             PrivilegedActionException,
1:55720b3:             ClassNotFoundException,
1:55720b3:             InterruptedException {
1:55720b3: 
1:55720b3:         // Collect the set of needed arguments to the java command
1:55720b3:         // The command runs ij with a security manager whose policy
1:55720b3:         // lacks the permissions to create derby.system.home.
1:55720b3:         final List<String> args = new ArrayList<String>();
1:55720b3:         args.add("-Djava.security.manager");
1:ec4eb07:         args.add("-Djava.security.policy=extin/MissingPermissionsTest2.policy");
1:ec4eb07:         args.add("-DderbyTesting.codejar="
1:ec4eb07:                     + getSystemProperty("derbyTesting.codejar"));
1:ec4eb07:         args.add("-DderbyTesting.testjar="
1:ec4eb07:                     + getSystemProperty("derbyTesting.testjar"));
1:f6df184:         args.add("-DderbyTesting.junit="
1:f6df184:                     + getSystemProperty("derbyTesting.junit"));
1:f6df184:         String antjunit = getSystemProperty("derbyTesting.antjunit");
1:f6df184:         if (antjunit != null) {
1:f6df184:             // This property is only available when the test is started
1:f6df184:             // by Ant's JUnit task.
1:f6df184:             args.add("-DderbyTesting.antjunit=" + antjunit);
1:55720b3:         }
1:55720b3:         args.add("-Dderby.system.home=system/nested");
1:55720b3:         args.add("-Dij.connection.test=jdbc:derby:wombat;create=true");
1:55720b3:         args.add("org.apache.derby.tools.ij");
1:55720b3:         final String[] argArray = args.toArray(new String[0]);
1:55720b3: 
1:55720b3:         final Process p = execJavaCmd(argArray);
1:55720b3:         SpawnedProcess spawned = new SpawnedProcess(p, "MPT");
1:55720b3:         spawned.suppressOutputOnComplete(); // we want to read it ourselves
1:55720b3: 
1:f6df184:         // The started process is an interactive ij session that will wait
1:f6df184:         // for user input. Close stdin of the process so that it stops
1:f6df184:         // waiting and exits.
1:f6df184:         p.getOutputStream().close();
1:55720b3: 
1:f6df184:         final int exitCode = spawned.complete(120000L); // 2 minutes
1:55720b3: 
1:55720b3:         assertTrue(
1:55720b3:             spawned.getFailMessage("subprocess run failed: "), exitCode == 0);
1:55720b3: 
1:f6df184:         // The actual message may vary. On Java 6, the names are not quoted,
1:f6df184:         // whereas newer versions double-quote them. On Windows, the directory
1:5e5e3c3:         // separator is different. Also, different JVM vendors capitalize
1:5e5e3c3:         // the "access denied" message differently.
1:5e5e3c3:         //
1:5e5e3c3:         // Use a regular expression that matches all known variants.
1:55720b3:         final String expectedMessageOnConsole =
1:f6df184:             "(?s).*The file or directory system.nested could not be created " +
2:84e1fb3:             "due to a security exception: " +
1:5e5e3c3:             "java\\.security\\.AccessControlException: [Aa]ccess denied " +
1:5e5e3c3:             "\\(\"?java\\.io\\.FilePermission\"? \"?system.nested\"? " +
1:f6df184:             "\"?write\"?\\).*";
1:55720b3: 
1:55720b3:         final String output = spawned.getFullServerOutput(); // ignore
1:55720b3:         final String err    = spawned.getFullServerError();
1:55720b3: 
1:f6df184:         assertTrue(err, err.matches(expectedMessageOnConsole));
1:55720b3:     }
1:55720b3: 
1:f6df184:     /**
1:f6df184:      * Make a regex that matches a warning for missing property permission.
1:f6df184:      * @param property the property for which read permission is missing
1:f6df184:      * @return a pattern that matches the expected warning
1:f6df184:      */
1:55720b3:     private String makeMessage(String property) {
1:f6df184:         // A variable part in the message is whether or not the names are
1:f6df184:         // double-quoted. In Java 6 they are not. In newer versions they are.
1:5e5e3c3:         // Another variable part is that the captitalization of "access denied"
1:5e5e3c3:         // varies depending on the JVM vendor.
1:55720b3:         final StringBuilder sb = new StringBuilder();
1:f6df184:         sb.append("(?s).*WARNING: the property ");
1:f6df184:         sb.append(Pattern.quote(property));
1:55720b3:         sb.append(" could not be read due to a security exception: ");
1:5e5e3c3:         sb.append("java\\.security\\.AccessControlException: [Aa]ccess denied \\(");
1:f6df184:         sb.append("\"?java\\.util\\.PropertyPermission\"? \"?");
1:f6df184:         sb.append(Pattern.quote(property));
1:f6df184:         sb.append("\"? \"?read\"?.*");
1:55720b3:         return sb.toString();
1:84e1fb3:     }
1:84e1fb3: 
1:84e1fb3: 
1:55720b3:     private void verifyMessagesInDerbyLog(int kind) throws
1:55720b3:             FileNotFoundException,
1:55720b3:             IOException,
1:55720b3:             PrivilegedActionException {
1:55720b3: 
1:55720b3:         String derbyLog = null;
1:55720b3: 
1:55720b3:         if (kind == KIND_EXPECT_ERROR_MSG_PRESENT) {
1:55720b3:             // In this case we didn't have permission to read derby.system.home
1:55720b3:             // so expect derby.log to be at CWD.
1:55720b3:             derbyLog = "derby.log";
1:55720b3:         } else if (kind == KIND_EXPECT_ERROR_MSG_ABSENT) {
1:55720b3:             derbyLog = "system/derby.log";
1:55720b3:         }
1:55720b3: 
1:55720b3:         final BufferedReader dl = getReader(derbyLog);
1:55720b3:         final StringBuilder log = new StringBuilder();
1:55720b3: 
1:55720b3:         try {
1:55720b3:             for (String line = dl.readLine(); line != null; line = dl.readLine()) {
1:55720b3:                 log.append(line);
1:55720b3:                 log.append('\n');
1:55720b3:             }
1:55720b3: 
1:f6df184:             String logString = log.toString();
1:55720b3:             if (kind == KIND_EXPECT_ERROR_MSG_PRESENT) {
1:55720b3:                 // We should see SecurityException when reading security
1:55720b3:                 // related properties in FileMonitor#PBgetJVMProperty
1:f6df184:                 assertTrue(logString, logString.matches(makeMessage(AUTH_MSG)));
1:55720b3: 
1:55720b3:                 // We should see SecurityException when reading
1:55720b3:                 // derby.system.home in FileMonitor#PBinitialize
1:f6df184:                 assertTrue(logString,
1:f6df184:                            logString.matches(makeMessage(SYSTEM_HOME)));
1:55720b3:             } else if (kind == KIND_EXPECT_ERROR_MSG_ABSENT) {
1:f6df184:                 assertFalse(logString,
1:f6df184:                             logString.matches(makeMessage(AUTH_MSG)));
1:f6df184:                 assertFalse(logString,
1:f6df184:                             logString.matches(makeMessage(SYSTEM_HOME)));
1:55720b3:             }
1:55720b3:         } finally {
1:55720b3:             dl.close();
1:55720b3:         }
1:55720b3:     }
1:55720b3: 
1:55720b3:     private static BufferedReader getReader(final String file)
1:55720b3:             throws PrivilegedActionException {
1:55720b3: 
2:55720b3:         return AccessController.doPrivileged(
1:55720b3:                 new PrivilegedExceptionAction<BufferedReader>() {
2:55720b3:             @Override
1:55720b3:             public BufferedReader run() throws FileNotFoundException {
1:55720b3:                 return new BufferedReader(new FileReader(file));
2:55720b3:             }});
1:55720b3:     }
1:a2ecbd3: 
1:a2ecbd3: 
1:a2ecbd3:     public void testModifyThreadGroup() throws Throwable {
1:a2ecbd3:         if (!inSubProcess) {
1:a2ecbd3:             // Set up run of this test in a sub process, so we can catch its
1:a2ecbd3:             // standard err/standard out.
1:a2ecbd3:             final List<String> args = new ArrayList<String>();
1:a2ecbd3:             args.add("-DinSubProcess=true");
1:a2ecbd3:             args.add("-Djava.security.manager");
1:a2ecbd3:             args.add(
1:a2ecbd3:                 "-Djava.security.policy=extin/MissingPermissionsTest.policy");
1:a2ecbd3:             args.add("-DderbyTesting.codejar="
1:a2ecbd3:                     + getSystemProperty("derbyTesting.codejar"));
1:a2ecbd3:             args.add("-DderbyTesting.testjar="
1:a2ecbd3:                     + getSystemProperty("derbyTesting.testjar"));
1:a2ecbd3:             args.add("-DderbyTesting.junit="
1:a2ecbd3:                     + getSystemProperty("derbyTesting.junit"));
1:a2ecbd3:             String antjunit = getSystemProperty("derbyTesting.antjunit");
1:a2ecbd3:             if (antjunit != null) {
1:a2ecbd3:                 // This property is only available when the test is started
1:a2ecbd3:                 // by Ant's JUnit task.
1:a2ecbd3:                 args.add("-DderbyTesting.antjunit=" + antjunit);
1:a2ecbd3:             }
1:a2ecbd3:             args.add("-Dderby.system.home=system/nested_tMTG");
1:a2ecbd3:             args.add("-Dderby.system.durability=" +
1:a2ecbd3:                      getSystemProperty("derby.system.durability"));
1:a2ecbd3:             args.add("-Dderby.tests.trace=" +
1:a2ecbd3:                      getSystemProperty("derby.tests.trace"));
1:a2ecbd3:             args.add("-Dderby.system.debug=" +
1:a2ecbd3:                      getSystemProperty("derby.tests.debug"));
1:a2ecbd3:             args.add("junit.textui.TestRunner");
1:a2ecbd3:             args.add(this.getClass().getName());
1:a2ecbd3: 
1:a2ecbd3:             final String[] argArray = args.toArray(new String[0]);
1:a2ecbd3:             final Process p = execJavaCmd(argArray);
1:a2ecbd3:             SpawnedProcess spawned = new SpawnedProcess(p, "MPT");
1:a2ecbd3:             spawned.suppressOutputOnComplete(); // we want to read it ourselves
1:a2ecbd3: 
1:a2ecbd3:             // The started process is an interactive ij session that will wait
1:a2ecbd3:             // for user input. Close stdin of the process so that it stops
1:a2ecbd3:             // waiting and exits.
1:a2ecbd3:             p.getOutputStream().close();
1:a2ecbd3: 
1:a2ecbd3:             final int exitCode = spawned.complete(120000L); // 2 minutes
1:a2ecbd3: 
1:a2ecbd3:             assertTrue(spawned.getFailMessage("subprocess run failed: "),
1:4469400:                     exitCode == 1);
1:a2ecbd3: 
1:a2ecbd3:             final String expectedMessageOnConsole =
1:a2ecbd3:                     "WARNING: could not do ThreadGroup#setDaemon on Derby " +
1:a2ecbd3:                     "daemons due to a security exception";
1:a2ecbd3: 
1:a2ecbd3:             final String output = spawned.getFullServerOutput(); // ignore
1:a2ecbd3:             final String err    = spawned.getFullServerError();
1:a2ecbd3: 
1:a2ecbd3:             assertTrue(err, err.contains(expectedMessageOnConsole));
1:a2ecbd3: 
1:a2ecbd3:             // Print sub process' output if this test specifies any such
1:a2ecbd3:             if (Boolean.parseBoolean(
1:a2ecbd3:                         getSystemProperty("derby.tests.trace")) ||
1:a2ecbd3:                 Boolean.parseBoolean(
1:a2ecbd3:                     getSystemProperty("derby.tests.debug"))) {
1:a2ecbd3: 
1:a2ecbd3:                 System.out.println("\n[ (subprocess) " +
1:a2ecbd3:                         output.replace("\n", "\n  (subprocess) ") + "]\n");
1:a2ecbd3:             }
1:a2ecbd3: 
1:a2ecbd3:         } else {
1:a2ecbd3:             final SystemThreadRun mst = new SystemThreadRun(this);
1:a2ecbd3: 
1:a2ecbd3:             Thread t = AccessController.doPrivileged(
1:a2ecbd3:                 new PrivilegedAction<Thread>() {
1:a2ecbd3:                     @Override
1:a2ecbd3:                     public Thread run() {
1:a2ecbd3:                         return new Thread(
1:a2ecbd3:                             Thread.currentThread().getThreadGroup().getParent(),
1:a2ecbd3:                             mst);
1:a2ecbd3:                     }});
1:a2ecbd3: 
1:a2ecbd3: 
1:a2ecbd3:             t.start();
1:a2ecbd3:             t.join();
1:a2ecbd3: 
1:a2ecbd3:             // The boot will fail since operation that require
1:a2ecbd3:             // modifyThreadGroup lead to boot failure. So the fact that the
1:a2ecbd3:             // same permission is missing in FileMonitor#createDaemonGroup
1:a2ecbd3:             // isn't an issue: it will not go undetected. It fails at this line
1:a2ecbd3:             // in BaseMonitor#runWithState:
1:a2ecbd3:             //
1:a2ecbd3:             //  timerFactory = (TimerFactory)Monitor.startSystemModule(
1:a2ecbd3:             //         "org.apache.derby.iapi.services.timer.TimerFactory");
1:a2ecbd3:             //
1:a2ecbd3:             // and the AccessControlException isn't caught and percolates all
1:a2ecbd3:             // the way out.
1:a2ecbd3:             assertTrue(mst.f instanceof AccessControlException);
1:a2ecbd3: 
1:a2ecbd3:             // This patch also fixes the fact that previously, the monitor in such
1:a2ecbd3:             // an event, thought it was already initialized so subsequent boot
1:a2ecbd3:             // attempt (from a non-system thread) would also fail. We now clean up,
1:a2ecbd3:             // so a boot here should work.
1:a2ecbd3:             openDefaultConnection("APP", "APPPW").close();
1:a2ecbd3:         }
1:a2ecbd3:     }
1:a2ecbd3: 
1:a2ecbd3:     private class SystemThreadRun implements Runnable {
1:a2ecbd3:         public Throwable f;
1:a2ecbd3:         private final BaseJDBCTestCase test;
1:a2ecbd3: 
1:a2ecbd3:         public SystemThreadRun(BaseJDBCTestCase test) {
1:a2ecbd3:             super();
1:a2ecbd3:             this.test = test;
1:a2ecbd3:         }
1:a2ecbd3: 
1:a2ecbd3:         @SuppressWarnings({"BroadCatchBlock", "TooBroadCatch"})
1:a2ecbd3:         @Override
1:a2ecbd3:         public void run() {
1:a2ecbd3:             try {
1:a2ecbd3:                 assertEquals(
1:a2ecbd3:                     Thread.currentThread().getThreadGroup().getName(),
1:a2ecbd3:                     "system");
1:a2ecbd3:                 // Expect this to fail with AccessControlException
1:a2ecbd3:                 test.openDefaultConnection("APP", "APPPW").close();
1:a2ecbd3:                 fail();
1:a2ecbd3:             } catch (Throwable e) {
1:a2ecbd3:                 this.f = e;
1:a2ecbd3:             }
1:a2ecbd3:         }
1:a2ecbd3:     }
1:55720b3: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:                     exitCode == 1);
commit:84e1fb3
/////////////////////////////////////////////////////////////////////////
0:         final String expectedMessageOnConsole = isJava6() ?
0:             "The file or directory system/nested could not be created " +
1:             "due to a security exception: " +
0:             "java.security.AccessControlException: access denied " +
0:             "(java.io.FilePermission system/nested write)."
0:             :
0:             "The file or directory system/nested could not be created " +
1:             "due to a security exception: " +
0:             "java.security.AccessControlException: access denied " +
0:             "(\"java.io.FilePermission\" \"system/nested\" \"write\").";
0:         assertTrue( err, err.contains( expectedMessageOnConsole ) );
/////////////////////////////////////////////////////////////////////////
0:         sb.append("java.security.AccessControlException: access denied (");
0:         sb.append( doubleQuoteIfNotJava6( "java.util.PropertyPermission" ) );
0:         sb.append(" ");
0:         sb.append( doubleQuoteIfNotJava6( property ) );
0:         sb.append(" ");
0:         sb.append( doubleQuoteIfNotJava6( "read" ) );
0:     private String  doubleQuoteIfNotJava6( String text )
0:     {
0:         if ( isJava6() ) { return text; }
0:         else { return "\"" + text + "\""; }
1:     }
1:     
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:a2ecbd3
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessControlException;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1:     private final static String OK_POLICY_R =
1:             resourcePrefix + OK_POLICY;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Used for running #testModifyThreadGroup
1:      */
1:     private static boolean inSubProcess = false;
1: 
/////////////////////////////////////////////////////////////////////////
1:         inSubProcess = Boolean.getBoolean("inSubProcess");
1: 
1:         if (!inSubProcess && !TestConfiguration.loadingFromJars()) {
1:             // This test only works with jar files. Only check at top
1:             // level
1:         if (!inSubProcess) {
1:             suite.addTest(
1:                     new SupportFilesSetup(
1:                             makeTest("testMissingFilePermission",
1:                                     POLICY_MINUS_FILEPERMISSION_T),
1:                             new String[] {
1:                                 POLICY_MINUS_FILEPERMISSION_R}));
1:             suite.addTest(makeTest("testPresentPropertiesPermission",
1:                     OK_POLICY_T));
1:             suite.addTest(makeTest("testMissingPropertiesPermission",
1:                     POLICY_MINUS_PROPERTYPERMISSION_T));
1:         }
1:         // This test runs in both the top process and a subprocess since it has
1:         // two parts:
1:         suite.addTest(new SupportFilesSetup(makeTest("testModifyThreadGroup",
1:                 OK_POLICY_T),
1:                 new String[] {OK_POLICY_R}));
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     public void testModifyThreadGroup() throws Throwable {
1:         if (!inSubProcess) {
1:             // Set up run of this test in a sub process, so we can catch its
1:             // standard err/standard out.
1:             final List<String> args = new ArrayList<String>();
1:             args.add("-DinSubProcess=true");
1:             args.add("-Djava.security.manager");
1:             args.add(
1:                 "-Djava.security.policy=extin/MissingPermissionsTest.policy");
1:             args.add("-DderbyTesting.codejar="
1:                     + getSystemProperty("derbyTesting.codejar"));
1:             args.add("-DderbyTesting.testjar="
1:                     + getSystemProperty("derbyTesting.testjar"));
1:             args.add("-DderbyTesting.junit="
1:                     + getSystemProperty("derbyTesting.junit"));
1:             String antjunit = getSystemProperty("derbyTesting.antjunit");
1:             if (antjunit != null) {
1:                 // This property is only available when the test is started
1:                 // by Ant's JUnit task.
1:                 args.add("-DderbyTesting.antjunit=" + antjunit);
1:             }
1:             args.add("-Dderby.system.home=system/nested_tMTG");
1:             args.add("-Dderby.system.durability=" +
1:                      getSystemProperty("derby.system.durability"));
1:             args.add("-Dderby.tests.trace=" +
1:                      getSystemProperty("derby.tests.trace"));
1:             args.add("-Dderby.system.debug=" +
1:                      getSystemProperty("derby.tests.debug"));
1:             args.add("junit.textui.TestRunner");
1:             args.add(this.getClass().getName());
1: 
1:             final String[] argArray = args.toArray(new String[0]);
1:             final Process p = execJavaCmd(argArray);
1:             SpawnedProcess spawned = new SpawnedProcess(p, "MPT");
1:             spawned.suppressOutputOnComplete(); // we want to read it ourselves
1: 
1:             // The started process is an interactive ij session that will wait
1:             // for user input. Close stdin of the process so that it stops
1:             // waiting and exits.
1:             p.getOutputStream().close();
1: 
1:             final int exitCode = spawned.complete(120000L); // 2 minutes
1: 
1:             assertTrue(spawned.getFailMessage("subprocess run failed: "),
0:                     exitCode == 0);
1: 
1:             final String expectedMessageOnConsole =
1:                     "WARNING: could not do ThreadGroup#setDaemon on Derby " +
1:                     "daemons due to a security exception";
1: 
1:             final String output = spawned.getFullServerOutput(); // ignore
1:             final String err    = spawned.getFullServerError();
1: 
1:             assertTrue(err, err.contains(expectedMessageOnConsole));
1: 
1:             // Print sub process' output if this test specifies any such
1:             if (Boolean.parseBoolean(
1:                         getSystemProperty("derby.tests.trace")) ||
1:                 Boolean.parseBoolean(
1:                     getSystemProperty("derby.tests.debug"))) {
1: 
1:                 System.out.println("\n[ (subprocess) " +
1:                         output.replace("\n", "\n  (subprocess) ") + "]\n");
1:             }
1: 
1:         } else {
1:             final SystemThreadRun mst = new SystemThreadRun(this);
1: 
1:             Thread t = AccessController.doPrivileged(
1:                 new PrivilegedAction<Thread>() {
1:                     @Override
1:                     public Thread run() {
1:                         return new Thread(
1:                             Thread.currentThread().getThreadGroup().getParent(),
1:                             mst);
1:                     }});
1: 
1: 
1:             t.start();
1:             t.join();
1: 
1:             // The boot will fail since operation that require
1:             // modifyThreadGroup lead to boot failure. So the fact that the
1:             // same permission is missing in FileMonitor#createDaemonGroup
1:             // isn't an issue: it will not go undetected. It fails at this line
1:             // in BaseMonitor#runWithState:
1:             //
1:             //  timerFactory = (TimerFactory)Monitor.startSystemModule(
1:             //         "org.apache.derby.iapi.services.timer.TimerFactory");
1:             //
1:             // and the AccessControlException isn't caught and percolates all
1:             // the way out.
1:             assertTrue(mst.f instanceof AccessControlException);
1: 
1:             // This patch also fixes the fact that previously, the monitor in such
1:             // an event, thought it was already initialized so subsequent boot
1:             // attempt (from a non-system thread) would also fail. We now clean up,
1:             // so a boot here should work.
1:             openDefaultConnection("APP", "APPPW").close();
1:         }
1:     }
1: 
1:     private class SystemThreadRun implements Runnable {
1:         public Throwable f;
1:         private final BaseJDBCTestCase test;
1: 
1:         public SystemThreadRun(BaseJDBCTestCase test) {
1:             super();
1:             this.test = test;
1:         }
1: 
1:         @SuppressWarnings({"BroadCatchBlock", "TooBroadCatch"})
1:         @Override
1:         public void run() {
1:             try {
1:                 assertEquals(
1:                     Thread.currentThread().getThreadGroup().getName(),
1:                     "system");
1:                 // Expect this to fail with AccessControlException
1:                 test.openDefaultConnection("APP", "APPPW").close();
1:                 fail();
1:             } catch (Throwable e) {
1:                 this.f = e;
1:             }
1:         }
1:     }
commit:55720b3
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.unitTests.junit.MissingPermissionsTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derbyTesting.unitTests.junit;
1: 
1: import java.io.BufferedReader;
0: import java.io.File;
1: import java.io.FileNotFoundException;
1: import java.io.FileReader;
1: import java.io.IOException;
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
1: import java.sql.Connection;
1: import java.sql.SQLException;
1: import java.util.ArrayList;
1: import java.util.List;
1: import java.util.Properties;
0: import static junit.framework.Assert.assertTrue;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1: import org.apache.derbyTesting.junit.SpawnedProcess;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Test behavior when permissions are missing for:
1:  * <ul>
1:  *   <li>reading of system properties, see DERBY-6617</li>
1:  *   <li>read, write access to create derby.system.home, see DERBY-6617</li>
1:  * </ul>
1:  * Note: requires English locale because the test asserts on localized
1:  * strings.
1:  */
1: public class MissingPermissionsTest extends BaseJDBCTestCase {
1: 
1:     private final static String AUTH_MSG =
1:             "derby.connection.requireAuthentication";
1: 
1:     private final static String SYSTEM_HOME = "derby.system.home";
1: 
1:     private final static String resourcePrefix = "unitTests/junit/";
1:     private final static String testPrefix =
1:             "org/apache/derbyTesting/" + resourcePrefix;
1: 
1:     private final static String OK_POLICY =
1:             "MissingPermissionsTest.policy";
1:     private final static String OK_POLICY_T =
1:             testPrefix + OK_POLICY;
1: 
1:     private final static String POLICY_MINUS_PROPERTYPERMISSION =
1:             "MissingPermissionsTest1.policy";
1: 
1:     private final static String POLICY_MINUS_PROPERTYPERMISSION_T =
1:             testPrefix + POLICY_MINUS_PROPERTYPERMISSION;
1: 
1:     private final static String POLICY_MINUS_FILEPERMISSION =
1:             "MissingPermissionsTest2.policy";
1: 
1:     private final static String POLICY_MINUS_FILEPERMISSION_T =
1:             testPrefix + POLICY_MINUS_FILEPERMISSION;
1: 
1:     private final static String POLICY_MINUS_FILEPERMISSION_R =
1:             resourcePrefix + POLICY_MINUS_FILEPERMISSION;
1: 
1:     private final int KIND_EXPECT_ERROR_MSG_PRESENT = 0;
1:     private final int KIND_EXPECT_ERROR_MSG_ABSENT = 1;
1: 
1:     public MissingPermissionsTest(String name) {
1:         super(name);
1:     }
1: 
1: 
1:     private static Test makeTest(String fixture, String policy) {
1:         Test t =  new MissingPermissionsTest(fixture);
1:         t = new SecurityManagerSetup(t, policy);
1:         final Properties props = new Properties();
1:         props.setProperty("derby.connection.requireAuthentication", "true");
1:         props.setProperty("derby.database.sqlAuthorization", "true");
1:         props.setProperty("derby.authentication.provider", "BUILTIN");
1:         props.setProperty("derby.user.APP", "APPPW");
1: 
1:         t = new SystemPropertyTestSetup(t, props, true);
1:         t = TestConfiguration.changeUserDecorator(t, "APP", "APPPW");
1:         t = TestConfiguration.singleUseDatabaseDecorator(t);
1:         return t;
1:     }
1: 
1:     public static Test suite() {
1:         final BaseTestSuite suite =
1:                 new BaseTestSuite("SystemPrivilegesPermissionTest");
1: 
0:         suite.addTest(
0:                 new SupportFilesSetup(
0:                         makeTest("testMissingFilePermission",
0:                                 POLICY_MINUS_FILEPERMISSION_T),
0:                         new String[] {
0:                             POLICY_MINUS_FILEPERMISSION_R}));
1: 
0:         suite.addTest(makeTest("testPresentPropertiesPermission",
0:                 OK_POLICY_T));
1: 
0:         suite.addTest(makeTest("testMissingPropertiesPermission",
0:                 POLICY_MINUS_PROPERTYPERMISSION_T));
1: 
1:         return suite;
1:     }
1: 
1:     /**
1:      * This test is run with a policy that does not lack permission to read
1:      * properties for derby.jar. This should leave no related error messages on
1:      * derby.log.
1:      *
1:      * @throws SQLException
1:      * @throws IOException
1:      * @throws PrivilegedActionException
1:      */
1:     public void testPresentPropertiesPermission()
1:             throws SQLException, IOException, PrivilegedActionException {
1: 
1:         // With credentials we are OK
1:         openDefaultConnection("APP", "APPPW").close();
1: 
1:         Connection c = null;
1: 
1:         // With wrong credentials we are not OK
1:         try {
1:             c = openDefaultConnection("Donald", "Duck");
1:             fail();
1:         } catch(SQLException e) {
1:             assertSQLState("08004", e);
1:         } finally {
1:             if (c != null) {
1:                 c.close();
1:             }
1:         }
1:         verifyMessagesInDerbyLog(KIND_EXPECT_ERROR_MSG_ABSENT);
1:     }
1: 
1:     /**
1:      * This test is run with a policy that lacks permission to read properties
1:      * for derby.jar. This should lead to error messages on derby.log.
1:      *
1:      * @throws SQLException
1:      * @throws IOException
1:      * @throws PrivilegedActionException
1:      */
1:     public void testMissingPropertiesPermission()
1:             throws SQLException, IOException, PrivilegedActionException {
1:         // With credentials we are OK
1:         openDefaultConnection("APP", "APPPW").close();
1: 
1:         // But also with wrong ones, all seems OK...
1:         openDefaultConnection("Donald", "Duck").close();
1: 
1:         // Check that we see the error messages expected in derby.log
1:         verifyMessagesInDerbyLog(KIND_EXPECT_ERROR_MSG_PRESENT);
1:     }
1: 
1:     /**
1:      * This test is run with a policy that lacks permission for derby.jar to
1:      * create a db directory for derby.  In this scenario we expect the boot to
1:      * fail, and an error message to be printed to the console, so we try to
1:      * get it by forking a sub-process. See {@code FileMonitor#PBinitialize}
1:      * when it gets a {@code SecurityException} following attempt to do "{@code
1:      * home.mkdir(s)}".
1:      * <p/>
1:      * Note that the policy used with this text fixture also doubles as the
1:      * one used by the subprocess to demonstrate the lack of permission.
1:      *
1:      * @throws SQLException
1:      * @throws IOException
1:      * @throws PrivilegedActionException
1:      * @throws ClassNotFoundException
1:      * @throws java.lang.InterruptedException
1:      */
1:     public void testMissingFilePermission() throws SQLException,
1:             IOException,
1:             PrivilegedActionException,
1:             ClassNotFoundException,
1:             InterruptedException {
1: 
1:         // Collect the set of needed arguments to the java command
1:         // The command runs ij with a security manager whose policy
1:         // lacks the permissions to create derby.system.home.
1:         final List<String> args = new ArrayList<String>();
0:         final String codeJarUrl = "file:" + getDerbyJarPath();
1:         args.add("-Djava.security.manager");
0:         args.add("-Djava.security.policy==extin/MissingPermissionsTest2.policy");
0:         args.add("-DderbyTesting.codejar=" + codeJarUrl);
1:         args.add("-Dderby.system.home=system/nested");
1:         args.add("-Dij.connection.test=jdbc:derby:wombat;create=true");
0:         args.add("-classpath");
0:         args.add(getClassPath());
1:         args.add("org.apache.derby.tools.ij");
1:         final String[] argArray = args.toArray(new String[0]);
1: 
1:         final Process p = execJavaCmd(argArray);
1:         SpawnedProcess spawned = new SpawnedProcess(p, "MPT");
1:         spawned.suppressOutputOnComplete(); // we want to read it ourselves
1: 
0:         final int exitCode = spawned.complete(3000); // 3 seconds
1: 
1:         assertTrue(
1:             spawned.getFailMessage("subprocess run failed: "), exitCode == 0);
1: 
1:         final String expectedMessageOnConsole =
0:                 "The file or directory system/nested could not be created " +
0:                 "due to a security exception: " +
0:                 "java.security.AccessControlException: access denied " +
0:                 "(\"java.io.FilePermission\" \"system/nested\" \"write\").";
1: 
1:         final String output = spawned.getFullServerOutput(); // ignore
1:         final String err    = spawned.getFullServerError();
1: 
0:         assertTrue(err.contains(expectedMessageOnConsole));
1:     }
1: 
1:     private String makeMessage(String property) {
1:         final StringBuilder sb = new StringBuilder();
0:         sb.append("WARNING: the property ");
0:         sb.append(property);
1:         sb.append(" could not be read due to a security exception: ");
0:         sb.append("java.security.AccessControlException: access denied (\"");
0:         sb.append("java.util.PropertyPermission\" ");
0:         sb.append("\"");
0:         sb.append(property);
0:         sb.append("\" \"read\")");
1:         return sb.toString();
1:     }
1: 
1: 
1:     private void verifyMessagesInDerbyLog(int kind) throws
1:             FileNotFoundException,
1:             IOException,
1:             PrivilegedActionException {
1: 
1:         String derbyLog = null;
1: 
1:         if (kind == KIND_EXPECT_ERROR_MSG_PRESENT) {
1:             // In this case we didn't have permission to read derby.system.home
1:             // so expect derby.log to be at CWD.
1:             derbyLog = "derby.log";
1:         } else if (kind == KIND_EXPECT_ERROR_MSG_ABSENT) {
1:             derbyLog = "system/derby.log";
1:         }
1: 
1:         final BufferedReader dl = getReader(derbyLog);
1:         final StringBuilder log = new StringBuilder();
1: 
1:         try {
1:             for (String line = dl.readLine(); line != null; line = dl.readLine()) {
1:                 log.append(line);
1:                 log.append('\n');
1:             }
1: 
1:             if (kind == KIND_EXPECT_ERROR_MSG_PRESENT) {
1:                 // We should see SecurityException when reading security
1:                 // related properties in FileMonitor#PBgetJVMProperty
0:                 assertTrue(log.toString().contains(makeMessage(AUTH_MSG)));
1: 
1:                 // We should see SecurityException when reading
1:                 // derby.system.home in FileMonitor#PBinitialize
0:                 assertTrue(log.toString().contains(makeMessage(SYSTEM_HOME)));
1:             } else if (kind == KIND_EXPECT_ERROR_MSG_ABSENT) {
0:                 assertFalse(log.toString().contains(makeMessage(AUTH_MSG)));
0:                 assertFalse(log.toString().contains(makeMessage(SYSTEM_HOME)));
1:             }
1:         } finally {
1:             dl.close();
1:         }
1:     }
1: 
1:     private static BufferedReader getReader(final String file)
1:             throws PrivilegedActionException {
1: 
1:         return AccessController.doPrivileged(
1:                 new PrivilegedExceptionAction<BufferedReader>() {
1:             @Override
1:             public BufferedReader run() throws FileNotFoundException {
1:                 return new BufferedReader(new FileReader(file));
1:             }});
1:     }
1: 
1: 
0:     private static String getClassPath() throws PrivilegedActionException {
1:         return AccessController.doPrivileged(
0:                 new PrivilegedExceptionAction<String>() {
1:             @Override
0:             public String run() {
0:                 return System.getProperty("java.class.path");
1:             }});
1:     }
1: 
0:     private static String getDerbyJarPath() throws PrivilegedActionException {
0:         final String classpath = getClassPath();
0:         final String[] classpathEntries = classpath.split(File.pathSeparator);
1: 
0:         for (String s: classpathEntries) {
0:             int i = s.indexOf("derby.jar");
0:             if (i >= 0) {
0:                 return s.substring(0, i);
1:             }
1:         }
0:         return null;
1:     }
1: }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5e5e3c3
/////////////////////////////////////////////////////////////////////////
1:         // separator is different. Also, different JVM vendors capitalize
1:         // the "access denied" message differently.
1:         //
1:         // Use a regular expression that matches all known variants.
1:             "java\\.security\\.AccessControlException: [Aa]ccess denied " +
1:             "\\(\"?java\\.io\\.FilePermission\"? \"?system.nested\"? " +
/////////////////////////////////////////////////////////////////////////
1:         // Another variable part is that the captitalization of "access denied"
1:         // varies depending on the JVM vendor.
1:         sb.append("java\\.security\\.AccessControlException: [Aa]ccess denied \\(");
commit:f6df184
/////////////////////////////////////////////////////////////////////////
1: import java.util.regex.Pattern;
/////////////////////////////////////////////////////////////////////////
0:         if (!TestConfiguration.loadingFromJars()) {
0:             // This test only works with jar files.
1:             return suite;
0:         }
0: 
/////////////////////////////////////////////////////////////////////////
1:         args.add("-DderbyTesting.junit="
1:                     + getSystemProperty("derbyTesting.junit"));
1:         String antjunit = getSystemProperty("derbyTesting.antjunit");
1:         if (antjunit != null) {
1:             // This property is only available when the test is started
1:             // by Ant's JUnit task.
1:             args.add("-DderbyTesting.antjunit=" + antjunit);
0:         }
/////////////////////////////////////////////////////////////////////////
1:         // The started process is an interactive ij session that will wait
1:         // for user input. Close stdin of the process so that it stops
1:         // waiting and exits.
1:         p.getOutputStream().close();
0: 
1:         final int exitCode = spawned.complete(120000L); // 2 minutes
1:         // The actual message may vary. On Java 6, the names are not quoted,
1:         // whereas newer versions double-quote them. On Windows, the directory
0:         // separator is different. Use a regular expression that matches any
0:         // variant.
0:         final String expectedMessageOnConsole =
1:             "(?s).*The file or directory system.nested could not be created " +
0:             "\\(\"?java.io.FilePermission\"? \"?system.nested\"? " +
1:             "\"?write\"?\\).*";
1:         assertTrue(err, err.matches(expectedMessageOnConsole));
1:     /**
1:      * Make a regex that matches a warning for missing property permission.
1:      * @param property the property for which read permission is missing
1:      * @return a pattern that matches the expected warning
1:      */
1:         // A variable part in the message is whether or not the names are
1:         // double-quoted. In Java 6 they are not. In newer versions they are.
1:         sb.append("(?s).*WARNING: the property ");
1:         sb.append(Pattern.quote(property));
0:         sb.append("java\\.security\\.AccessControlException: access denied \\(");
1:         sb.append("\"?java\\.util\\.PropertyPermission\"? \"?");
1:         sb.append(Pattern.quote(property));
1:         sb.append("\"? \"?read\"?.*");
/////////////////////////////////////////////////////////////////////////
1:             String logString = log.toString();
1:                 assertTrue(logString, logString.matches(makeMessage(AUTH_MSG)));
1:                 assertTrue(logString,
1:                            logString.matches(makeMessage(SYSTEM_HOME)));
1:                 assertFalse(logString,
1:                             logString.matches(makeMessage(AUTH_MSG)));
1:                 assertFalse(logString,
1:                             logString.matches(makeMessage(SYSTEM_HOME)));
commit:ec4eb07
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         args.add("-Djava.security.policy=extin/MissingPermissionsTest2.policy");
1:         args.add("-DderbyTesting.codejar="
1:                     + getSystemProperty("derbyTesting.codejar"));
1:         args.add("-DderbyTesting.testjar="
1:                     + getSystemProperty("derbyTesting.testjar"));
0:         args.add("-DderbyTesting.antjunit="
0:                     + getSystemProperty("derbyTesting.antjunit"));
/////////////////////////////////////////////////////////////////////////
============================================================================