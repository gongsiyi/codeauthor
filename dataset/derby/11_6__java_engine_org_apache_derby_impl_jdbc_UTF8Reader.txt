4:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.jdbc.UTF8Reader
1:345de35: 
1:88a3cb9:    Licensed to the Apache Software Foundation (ASF) under one or more
1:88a3cb9:    contributor license agreements.  See the NOTICE file distributed with
1:88a3cb9:    this work for additional information regarding copyright ownership.
1:88a3cb9:    The ASF licenses this file to you under the Apache License, Version 2.0
1:88a3cb9:    (the "License"); you may not use this file except in compliance with
1:88a3cb9:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
18:eac0369: 
1:48152c2:  */
1:48152c2: 
1:eac0369: package org.apache.derby.impl.jdbc;
1:eac0369: 
1:1315d5e: import java.io.BufferedInputStream;
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.Reader;
1:eac0369: import java.io.IOException;
1:eac0369: import java.io.UTFDataFormatException;
1:eac0369: import java.io.EOFException;
1:eac0369: import java.sql.SQLException;
1:eac0369: 
1:f839f5e: import org.apache.derby.iapi.error.StandardException;
1:910b77f: import org.apache.derby.iapi.jdbc.CharacterStreamDescriptor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:910b77f: import org.apache.derby.iapi.types.PositionedStream;
1:f839f5e: 
1:48152c2: /**
1:48152c2:  * Class for reading characters from streams encoded in the modified UTF-8
1:48152c2:  * format.
2:48152c2:  * <p>
1:48152c2:  * Note that we often operate on a special Derby stream.
1:48152c2:  * A Derby stream is possibly different from a "normal" stream in two ways;
1:48152c2:  * an encoded length is inserted at the head of the stream, and if the encoded
1:48152c2:  * length is <code>0</code> a Derby-specific end of stream marker is appended
1:48152c2:  * to the data.
1:48152c2:  * <p>
1:48152c2:  * If the underlying stream is capable of repositioning itself on request,
1:48152c2:  * this class supports multiple readers on the same source stream in such a way
1:48152c2:  * that the various readers do not interfere with each other (except for
1:48152c2:  * serializing access). Each reader instance will have its own pointer into the
1:48152c2:  * stream, and request that the stream repositions itself before calling
1:48152c2:  * read/skip on the stream.
1:48152c2:  *
1:48152c2:  * @see PositionedStoreStream
1:48152c2:  */
1:eac0369: public final class UTF8Reader extends Reader
1:ebb8b8b: {
1:2dce4ab:     private static final String READER_CLOSED = "Reader closed";
1:c16a2d0:     /** Maximum size in number of chars for the internal character buffer. */
1:c16a2d0:     private static final int MAXIMUM_BUFFER_SIZE = 8*1024; // 8 KB
1:eac0369: 
1:48152c2:     /** The underlying data stream. */
1:ebb8b8b:     private InputStream in;
1:7672693:     /** Stream that can reposition itself on request (may be {@code null}). */
1:910b77f:     private final PositionedStream positionedIn;
1:7672693:     /**
1:7672693:      * Store the last visited position in the store stream, if it is capable of
1:7672693:      * repositioning itself ({@code positionedIn != null}).
1:7672693:      */
1:f839f5e:     private long rawStreamPos = 0L;
1:7672693:     /** Number of bytes read from the stream, including any header bytes. */
1:fe27d9d:     private long       utfCount;        // bytes
1:48152c2:     /** Number of characters read from the stream. */
1:fe27d9d:     private long       readerCharCount; // characters
1:eac0369: 
1:48152c2:     /** Internal character buffer storing characters read from the stream. */
1:c16a2d0:     private final char[]   buffer;
1:48152c2:     /** The number of characters in the internal buffer. */
1:fe27d9d:     private int            charactersInBuffer; // within buffer
1:48152c2:     /** The position of the next character to read in the internal buffer. */
1:ebb8b8b:     private int            readPositionInBuffer;
1:eac0369: 
1:48152c2:     /** Tells if this reader has been closed. */
1:fe27d9d:     private boolean noMoreReads;
1:eac0369: 
1:48152c2:     /** 
1:48152c2:      * A reference to the parent object of the stream.
1:48152c2:      * <p>
1:48152c2:      * The reference is kept so that the parent object can't get
1:48152c2:      * garbage collected until we are done with the stream.
1:48152c2:      */
1:fe27d9d:     private ConnectionChild parent;
1:eac0369: 
1:48152c2:     /**
1:910b77f:      * Descriptor containing information about the stream.
1:910b77f:      * Except for the current positions, the information in this object is
1:910b77f:      * considered permanent and valid for the life-time of the stream.
1:910b77f:      */
1:910b77f:     private final CharacterStreamDescriptor csd;
1:910b77f: 
1:910b77f:     /**
1:a694c19:      * Constructs a reader on top of the source UTF-8 encoded stream.
1:910b77f:      *
1:a694c19:      * @param csd a description of and reference to the source stream
1:a694c19:      * @param conChild the parent object / connection child
1:a694c19:      * @param sync synchronization object used when accessing the underlying
1:a694c19:      *      data stream
1:48152c2:      * @throws IOException if reading from the underlying stream fails
1:48152c2:      */
1:910b77f:     public UTF8Reader(CharacterStreamDescriptor csd, ConnectionChild conChild,
1:7672693:             Object sync)
1:7672693:             throws IOException {
1:910b77f:         super(sync);
1:910b77f:         this.csd = csd;
1:910b77f:         this.positionedIn =
1:910b77f:                 (csd.isPositionAware() ? csd.getPositionedStream() : null);
1:910b77f:         this.parent = conChild;
1:f839f5e: 
1:910b77f:         int buffersize = calculateBufferSize(csd);
1:910b77f:         this.buffer = new char[buffersize];
1:910b77f: 
1:7672693:         if (csd.isPositionAware()) {
1:7672693:             // Check and save the stream state.
1:7672693:             if (SanityManager.DEBUG) {
1:910b77f:                 SanityManager.ASSERT(
1:910b77f:                         csd.getCurBytePos() == positionedIn.getPosition());
1:910b77f:             }
1:7672693:             this.rawStreamPos = positionedIn.getPosition();
1:7672693:             // Make sure we start at the first data byte, not in the header.
1:7672693:             // The position will be changed on the next buffer fill.
1:7672693:             if (rawStreamPos < csd.getDataOffset()) {
1:7672693:                 rawStreamPos = csd.getDataOffset();
1:7672693:             }
1:7672693:         } else {
1:7672693:             // Skip the header if required.
1:7672693:             if (csd.getCurBytePos() < csd.getDataOffset()) {
1:7672693:                 csd.getStream().skip(csd.getDataOffset() - csd.getCurBytePos());
1:7672693:             }
1:910b77f:         }
1:910b77f: 
1:910b77f:         // Buffer stream for improved performance, if appropriate.
1:910b77f:         if (csd.isBufferable()) {
1:910b77f:             this.in = new BufferedInputStream(csd.getStream(), buffersize);
1:910b77f:         } else {
1:910b77f:             this.in = csd.getStream();
1:910b77f:         }
1:7672693:         // Add the header portion to the utfCount.
1:7672693:         utfCount = csd.getDataOffset();
1:c16a2d0:     }
1:ab2037f: 
1:ebb8b8b:     /*
1:48152c2:      * Reader implemention.
1:c16a2d0:      */
1:c16a2d0: 
1:ab2037f:     /**
1:48152c2:      * Reads a single character from the stream.
1:910b77f:      * 
1:48152c2:      * @return A character or <code>-1</code> if end of stream has been reached.
1:48152c2:      * @throws IOException if the stream has been closed, or an exception is
1:48152c2:      *      raised while reading from the underlying stream
1:48152c2:      */
1:ebb8b8b:     public int read() throws IOException
1:ebb8b8b:     {
1:ebb8b8b:         synchronized (lock) {
1:fe27d9d: 
1:ebb8b8b:             // check if closed..
1:ebb8b8b:             if (noMoreReads)
1:2dce4ab:                 throw new IOException(READER_CLOSED);
1:e5b15ce: 
1:ebb8b8b:             if (readPositionInBuffer >= charactersInBuffer) {
1:ebb8b8b:                 if (fillBuffer()) {
1:ebb8b8b:                     return -1;
1:c16a2d0:                 }
1:c16a2d0:             }
1:e5b15ce: 
1:ebb8b8b:             return buffer[readPositionInBuffer++];
1:ebb8b8b:         }
1:ebb8b8b:     }
1:e1fc783: 
1:c16a2d0:     /**
1:48152c2:      * Reads characters into an array.
1:c16a2d0:      * 
1:48152c2:      * @return The number of characters read, or <code>-1</code> if the end of
1:48152c2:      *      the stream has been reached.
1:48152c2:      */ 
1:ebb8b8b:     public int read(char[] cbuf, int off, int len) throws IOException
1:ebb8b8b:     {
1:ebb8b8b:         synchronized (lock) {
1:ebb8b8b:             // check if closed..
1:ebb8b8b:             if (noMoreReads)
1:2dce4ab:                 throw new IOException(READER_CLOSED);
1:e1fc783: 
1:ebb8b8b:             if (readPositionInBuffer >= charactersInBuffer) {
1:ebb8b8b:                 if (fillBuffer()) {
1:ebb8b8b:                     return -1;
1:ebb8b8b:                 }
1:ebb8b8b:             }
1:eac0369: 
1:ebb8b8b:             int remainingInBuffer = charactersInBuffer - readPositionInBuffer;
1:eac0369: 
1:ebb8b8b:             if (len > remainingInBuffer)
1:ebb8b8b:                 len = remainingInBuffer;
1:eac0369: 
1:ebb8b8b:             System.arraycopy(buffer, readPositionInBuffer, cbuf, off, len);
1:ebb8b8b:             readPositionInBuffer += len;
1:eac0369: 
1:ebb8b8b:             return len;
1:ebb8b8b:         }
1:ebb8b8b:     }
1:fe27d9d: 
1:48152c2:     /**
1:48152c2:      * Skips characters.
1:48152c2:      * 
1:48152c2:      * @param len the numbers of characters to skip
1:48152c2:      * @return The number of characters actually skipped.
1:48152c2:      * @throws IllegalArgumentException if the number of characters to skip is
1:48152c2:      *      negative
1:48152c2:      * @throws IOException if accessing the underlying stream fails
1:48152c2:      */
1:ebb8b8b:     public long skip(long len) throws IOException {
1:ebb8b8b:         if (len < 0) {
1:ebb8b8b:             throw new IllegalArgumentException(
1:fe27d9d:                 "Number of characters to skip must be positive: " + len);
1:ebb8b8b:         }
1:ebb8b8b:         synchronized (lock) {
1:ebb8b8b:             // check if closed..
1:ebb8b8b:             if (noMoreReads)
1:2dce4ab:                 throw new IOException(READER_CLOSED);
1:eac0369: 
1:ebb8b8b:             if (readPositionInBuffer >= charactersInBuffer) {
1:ebb8b8b:                 // do somthing
1:ebb8b8b:                 if (fillBuffer()) {
1:ebb8b8b:                     return 0L;
1:ebb8b8b:                 }
1:ebb8b8b:             }
1:eac0369: 
1:ebb8b8b:             int remainingInBuffer = charactersInBuffer - readPositionInBuffer;
1:eac0369: 
1:ebb8b8b:             if (len > remainingInBuffer)
1:ebb8b8b:                 len = remainingInBuffer;
1:eac0369: 
1:ebb8b8b:             readPositionInBuffer += len;
1:eac0369: 
1:ebb8b8b:             return len;
1:ebb8b8b:         }
1:eac0369: 
1:ebb8b8b:     }
1:eac0369: 
1:48152c2:     /**
1:48152c2:      * Close the reader, disallowing further reads.
1:48152c2:      */
1:ebb8b8b:     public void close()
1:ebb8b8b:     {
1:ebb8b8b:         synchronized (lock) {
2:ebb8b8b:             closeIn();
1:48152c2:             parent = null;
2:ebb8b8b:             noMoreReads = true;
1:ebb8b8b:         }
1:ebb8b8b:     }
1:eac0369: 
1:ebb8b8b:     /*
1:48152c2:      * Methods just for Derby's JDBC driver
1:48152c2:      */
1:48152c2: 
1:48152c2:     /**
1:48152c2:      * Reads characters from the stream.
1:ab2037f:      * <p>
1:48152c2:      * Due to internal buffering a smaller number of characters than what is
1:48152c2:      * requested might be returned. To ensure that the request is fulfilled,
1:48152c2:      * call this method in a loop until the requested number of characters is
1:48152c2:      * read or <code>-1</code> is returned.
1:48152c2:      * 
1:48152c2:      * @param sb the destination buffer
1:48152c2:      * @param len maximum number of characters to read
1:48152c2:      * @return The number of characters read, or <code>-1</code> if the end of
1:48152c2:      *      the stream is reached.
1:48152c2:      */
1:ebb8b8b:     public int readInto(StringBuffer sb, int len) throws IOException {
1:eac0369: 
1:ebb8b8b:         synchronized (lock) {
1:ebb8b8b:             if (readPositionInBuffer >= charactersInBuffer) {
1:ebb8b8b:                 if (fillBuffer()) {
1:ebb8b8b:                     return -1;
1:ebb8b8b:                 }
1:ebb8b8b:             }
1:eac0369: 
1:ebb8b8b:             int remainingInBuffer = charactersInBuffer - readPositionInBuffer;
1:eac0369: 
1:ebb8b8b:             if (len > remainingInBuffer)
1:ebb8b8b:                 len = remainingInBuffer;
1:ebb8b8b:             sb.append(buffer, readPositionInBuffer, len);
1:eac0369: 
1:ebb8b8b:             readPositionInBuffer += len;
1:eac0369: 
1:ebb8b8b:             return len;
1:ebb8b8b:         }
1:ebb8b8b:     }
1:eac0369: 
1:48152c2:     /**
1:48152c2:      * Reads characters into an array as ASCII characters.
1:c16a2d0:      * <p>
1:48152c2:      * Due to internal buffering a smaller number of characters than what is
1:48152c2:      * requested might be returned. To ensure that the request is fulfilled,
1:48152c2:      * call this method in a loop until the requested number of characters is
1:48152c2:      * read or <code>-1</code> is returned.
1:48152c2:      * <p>
1:48152c2:      * Characters outside the ASCII range are replaced with an out of range
1:48152c2:      * marker.
1:48152c2:      * 
1:48152c2:      * @param abuf the buffer to read into
1:48152c2:      * @param off the offset into the destination buffer
1:48152c2:      * @param len maximum number of characters to read
1:48152c2:      * @return The number of characters read, or <code>-1</code> if the end of
1:48152c2:      *      the stream is reached.
1:48152c2:      */
1:ebb8b8b:     int readAsciiInto(byte[] abuf, int off, int len) throws IOException {
1:eac0369: 
1:ebb8b8b:         synchronized (lock) {
1:ebb8b8b:             if (readPositionInBuffer >= charactersInBuffer) {
1:ebb8b8b:                 if (fillBuffer()) {
1:ebb8b8b:                     return -1;
1:ebb8b8b:                 }
1:ebb8b8b:             }
1:eac0369: 
1:ebb8b8b:             int remainingInBuffer = charactersInBuffer - readPositionInBuffer;
1:eac0369: 
1:ebb8b8b:             if (len > remainingInBuffer)
1:ebb8b8b:                 len = remainingInBuffer;
1:eac0369: 
1:ebb8b8b:             char[] lbuffer = buffer;
1:ebb8b8b:             for (int i = 0; i < len; i++) {
1:ebb8b8b:                 char c = lbuffer[readPositionInBuffer + i];
1:ebb8b8b:                 byte cb;
1:ebb8b8b:                 if (c <= 255)
1:ebb8b8b:                     cb = (byte) c;
1:ebb8b8b:                 else
1:ebb8b8b:                     cb = (byte) '?'; // Question mark - out of range character.
1:eac0369: 
1:ebb8b8b:                 abuf[off + i] = cb;
1:ebb8b8b:             }
1:eac0369: 
1:ebb8b8b:             readPositionInBuffer += len;
1:eac0369: 
1:ebb8b8b:             return len;
1:ebb8b8b:         }
1:ebb8b8b:     }
1:eac0369: 
1:ebb8b8b:     /*
1:48152c2:      * internal implementation
1:48152c2:      */
1:eac0369: 
1:48152c2:     /**
1:48152c2:      * Close the underlying stream if it is open.
1:48152c2:      */
1:ebb8b8b:     private void closeIn() {
1:ebb8b8b:         if (in != null) {
1:ebb8b8b:             try {
1:ebb8b8b:                 in.close();
1:ebb8b8b:             } catch (IOException ioe) {
1:48152c2:                 // Ignore exceptions thrown on close.
1:48152c2:                 // [TODO] Maybe we should log these?
1:ebb8b8b:             } finally {
1:ebb8b8b:                 in = null;
1:ebb8b8b:             }
1:ebb8b8b:         }
1:ebb8b8b:     }
1:eac0369: 
1:48152c2:     /**
1:48152c2:      * Convenience method generating an {@link UTFDataFormatException} and
1:48152c2:      * cleaning up the reader state.
2:48152c2:      */
1:ebb8b8b:     private IOException utfFormatException(String s) {
1:ebb8b8b:         noMoreReads = true;
1:ebb8b8b:         closeIn();
1:ebb8b8b:         return new UTFDataFormatException(s);
1:ebb8b8b:     }
1:eac0369: 
1:48152c2:     /**
1:48152c2:      * Fills the internal character buffer by decoding bytes from the stream.
1:48152c2:      * 
1:48152c2:      * @return <code>true</code> if the end of the stream is reached,
1:48152c2:      *      <code>false</code> if there is apparently more data to be read.
1:48152c2:      */
1:f839f5e:     //@GuardedBy("lock")
1:ebb8b8b:     private boolean fillBuffer() throws IOException
1:ebb8b8b:     {
1:ebb8b8b:         if (in == null)
1:ebb8b8b:             return true;
1:eac0369: 
1:ebb8b8b:         charactersInBuffer = 0;
1:95d725a:         readPositionInBuffer = 0;
1:ebb8b8b: 
1:ebb8b8b:         try {
1:ebb8b8b:         try {
1:ebb8b8b:             parent.setupContextStack();
1:f839f5e:             // If we are operating on a positioned stream, reposition it to
1:f839f5e:             // continue reading at the position we stopped last time.
1:f839f5e:             if (this.positionedIn != null) {
2:f839f5e:                 try {
1:f839f5e:                     this.positionedIn.reposition(this.rawStreamPos);
1:f839f5e:                 } catch (StandardException se) {
1:f839f5e:                     throw Util.generateCsSQLException(se);
1:ebb8b8b:                 }
1:ebb8b8b:             }
1:910b77f:             // Keep track of how much we are allowed to read.
1:7672693:             final long utfLen = csd.getByteLength();
1:7672693:             final long maxFieldSize = csd.getMaxCharLength();
1:eac0369: readChars:
1:ebb8b8b:         while (
1:ebb8b8b:                 (charactersInBuffer < buffer.length) &&
1:ebb8b8b:                 ((utfCount < utfLen) || (utfLen == 0)) &&
1:ebb8b8b:                 ((maxFieldSize == 0) || (readerCharCount < maxFieldSize))
1:ebb8b8b:               )
1:ebb8b8b:         {
1:ebb8b8b:             int c = in.read();
1:ebb8b8b:             if (c == -1) {
1:ebb8b8b:                 if (utfLen == 0) {
1:910b77f:                     // Close the stream if it cannot be reset.
1:910b77f:                     if (!csd.isPositionAware()) {
1:910b77f:                         closeIn();
1:910b77f:                     }
1:ebb8b8b:                     break readChars;
1:ebb8b8b:                 }
1:2dce4ab:                 throw utfFormatException("Reached EOF prematurely, " +
1:2dce4ab:                     "read " + utfCount + " out of " + utfLen + " bytes");
1:ebb8b8b:             }
1:eac0369: 
1:ebb8b8b:             int finalChar;
1:fe27d9d:             switch (c >> 4) {
1:ebb8b8b:                 case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
1:ebb8b8b:                     // 0xxxxxxx
1:ebb8b8b:                     utfCount++;
1:ebb8b8b:                     finalChar = c;
1:ebb8b8b:                     break;
1:eac0369: 
1:ebb8b8b:                 case 12: case 13:
1:ebb8b8b:                     {
1:ebb8b8b:                     // 110x xxxx   10xx xxxx
1:ebb8b8b:                     utfCount += 2;
1:ebb8b8b:                     int char2 = in.read();
1:ebb8b8b:                     if (char2 == -1)
1:2dce4ab:                         throw utfFormatException("Reached EOF when reading " +
1:2dce4ab:                             "second byte in a two byte character encoding; " +
1:2dce4ab:                             "byte/char position " + utfCount + "/" +
1:2dce4ab:                             readerCharCount);
1:eac0369: 
1:ebb8b8b:                     if ((char2 & 0xC0) != 0x80)
1:2dce4ab:                         throw utfFormatException("Second byte in a two byte" +
1:2dce4ab:                             "character encoding invalid: (int)" + char2 +
1:2dce4ab:                             ", byte/char pos " + utfCount + "/" +
1:2dce4ab:                             readerCharCount);
1:ebb8b8b:                     finalChar = (((c & 0x1F) << 6) | (char2 & 0x3F));
1:ebb8b8b:                     break;
1:ebb8b8b:                     }
1:eac0369: 
1:ebb8b8b:                 case 14:
1:ebb8b8b:                     {
1:ebb8b8b:                     // 1110 xxxx  10xx xxxx  10xx xxxx
1:ebb8b8b:                     utfCount += 3;
1:ebb8b8b:                     int char2 = in.read();
1:ebb8b8b:                     int char3 = in.read();
1:ebb8b8b:                     if (char2 == -1 || char3 == -1)
1:2dce4ab:                         throw utfFormatException("Reached EOF when reading " +
1:2dce4ab:                             "second/third byte in a three byte character " +
1:2dce4ab:                             "encoding; byte/char position " + utfCount + "/" +
1:2dce4ab:                             readerCharCount);
1:eac0369: 
1:ebb8b8b:                     if ((c == 0xE0) && (char2 == 0) && (char3 == 0))
1:ebb8b8b:                     {
1:ebb8b8b:                         if (utfLen == 0) {
1:ebb8b8b:                             // we reached the end of a long string,
1:ebb8b8b:                             // that was terminated with
1:ebb8b8b:                             // (11100000, 00000000, 00000000)
1:910b77f:                             // Close the stream if it cannot be reset.
1:910b77f:                             if (!csd.isPositionAware()) {
1:910b77f:                                 closeIn();
1:910b77f:                             }
1:ebb8b8b:                             break readChars;
1:ebb8b8b:                         }
1:2dce4ab:                         throw utfFormatException("Internal error: Derby-" +
1:2dce4ab:                             "specific EOF marker read");
1:ebb8b8b:                     }
1:eac0369: 
1:ebb8b8b:                     if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80))
1:2dce4ab:                         throw utfFormatException("Second/third byte in a " +
1:2dce4ab:                             "three byte character encoding invalid: (int)" +
1:2dce4ab:                             char2 + "/" + char3 + ", byte/char pos " +
1:2dce4ab:                             utfCount + "/" + readerCharCount);
1:eac0369: 
1:ebb8b8b:                     finalChar = (((c & 0x0F) << 12) |
1:ebb8b8b:                                ((char2 & 0x3F) << 6) |
1:ebb8b8b:                                ((char3 & 0x3F) << 0));
1:ebb8b8b:                     }
1:ebb8b8b:                     break;
1:eac0369: 
1:ebb8b8b:                 default:
1:ebb8b8b:                     // 10xx xxxx,  1111 xxxx
1:2dce4ab:                     throw utfFormatException("Invalid UTF encoding at " +
1:2dce4ab:                         "byte/char position " + utfCount + "/" +
1:2dce4ab:                         readerCharCount + ": (int)" + c);
1:ebb8b8b:             }
1:eac0369: 
1:ebb8b8b:             buffer[charactersInBuffer++] = (char) finalChar;
1:ebb8b8b:             readerCharCount++;
1:ebb8b8b:         }
1:fe27d9d:         if (utfLen != 0 && utfCount > utfLen)
1:2dce4ab:             throw utfFormatException("Incorrect encoded length in stream, " +
1:2dce4ab:                 "expected " + utfLen + ", have " + utfCount + " bytes");
1:eac0369: 
1:f839f5e:         if (charactersInBuffer != 0) {
1:f839f5e:             if (this.positionedIn != null) {
1:f839f5e:                 // Save the last visisted position so we can start reading where
1:f839f5e:                 // we let go the next time we fill the buffer.
1:ab2037f:                 this.rawStreamPos = this.positionedIn.getPosition();
1:ebb8b8b:             }
1:ebb8b8b:             return false;
1:910b77f:         }
1:eac0369: 
1:910b77f:         // Close the stream if it cannot be reset.
1:910b77f:         if (!csd.isPositionAware()) {
1:910b77f:             closeIn();
3:ebb8b8b:         }
1:ebb8b8b:         return true;
1:ebb8b8b:         } finally {
1:56a7b39:             ConnectionChild.restoreIntrFlagIfSeen(true, parent.getEmbedConnection());
1:ebb8b8b:             parent.restoreContextStack();
1:c16a2d0:         }
1:ebb8b8b:         } catch (SQLException sqle) {
1:ed0be21:             throw Util.newIOException(sqle);
1:ebb8b8b:         }
1:ebb8b8b:     }
1:eac0369: 
2:48152c2:     /**
1:ab2037f:      * Resets the reader.
1:48152c2:      * <p>
1:ab2037f:      * This method is used internally to achieve better performance.
1:ab2037f:      * @see #reposition(long)
1:ab2037f:      *
1:ab2037f:      * @throws IOException if resetting or reading from the stream fails
1:ab2037f:      * @throws StandardException if resetting the stream fails
1:ab2037f:      */
1:ab2037f:     private void resetUTF8Reader()
1:ab2037f:             throws IOException, StandardException {
1:910b77f:         // Skip the length encoding bytes.
1:910b77f:         this.positionedIn.reposition(csd.getDataOffset());
1:7672693:         this.utfCount = this.rawStreamPos = this.positionedIn.getPosition();
1:910b77f:         // If bufferable, discard buffered stream and create a new one.
1:910b77f:         if (csd.isBufferable()) {
1:910b77f:             this.in = new BufferedInputStream(csd.getStream(), buffer.length);
1:910b77f:         }
1:7672693:         this.readerCharCount = 0L;
1:ab2037f:         this.charactersInBuffer = this.readPositionInBuffer = 0;
1:ab2037f:     }
1:ab2037f: 
1:ab2037f:     /**
1:ab2037f:      * Repositions the stream so that the next character read will be the
1:ab2037f:      * character at the requested position.
1:ab2037f:      * <p>
1:ab2037f:      * There are three types of repositioning, ordered after increasing cost:
1:ab2037f:      * <ol> <li>Reposition within current character buffer (small hops forwards
1:ab2037f:      *          and potentially backwards - in range 1 char to
1:ab2037f:      *          {@code MAXIMUM_BUFFER_SIZE} chars)</li>
1:ab2037f:      *      <li>Forward stream from current position (hops forwards)</li>
1:ab2037f:      *      <li>Reset stream and skip data (hops backwards)</li>
1:ab2037f:      * </ol>
1:ab2037f:      *
1:ab2037f:      * @param requestedCharPos 1-based requested character position
1:ab2037f:      * @throws IOException if resetting or reading from the stream fails
1:ab2037f:      * @throws StandardException if resetting the stream fails
1:ab2037f:      */
1:ab2037f:     void reposition(long requestedCharPos)
1:ab2037f:             throws IOException, StandardException {
1:910b77f:         if (SanityManager.DEBUG) {
1:ab2037f:             SanityManager.ASSERT(this.positionedIn != null);
1:ab2037f:             SanityManager.ASSERT(requestedCharPos > 0);
1:ab2037f:         }
1:925b07b:         if (requestedCharPos <= readerCharCount - charactersInBuffer) {
1:925b07b:             // The stream must be reset, because the requested position is
1:925b07b:             // before the current lower buffer boundary.
1:925b07b:             resetUTF8Reader();
1:925b07b:         }
1:925b07b: 
1:925b07b:         long currentCharPos =
1:925b07b:             readerCharCount - charactersInBuffer + readPositionInBuffer;
1:925b07b:         long difference = (requestedCharPos - 1) - currentCharPos;
1:925b07b: 
1:925b07b:         if (difference <= 0) {
1:925b07b:             // Move back in the buffer.
1:925b07b:             readPositionInBuffer += difference;
2:ab2037f:         } else {
1:925b07b:             // Skip forward.
1:925b07b:             persistentSkip(difference);
1:ab2037f:         }
1:ab2037f:     }
1:ab2037f: 
1:ab2037f:     /**
1:910b77f:      * Calculates an optimized buffer size.
1:910b77f:      * <p>
1:910b77f:      * The maximum size allowed is returned if the specified values don't give
1:910b77f:      * enough information to say a smaller buffer size is preferable.
1:910b77f:      *
1:910b77f:      * @param csd stream descriptor
1:910b77f:      * @return An (sub)optimal buffer size.
1:910b77f:      */
1:910b77f:     private final int calculateBufferSize(CharacterStreamDescriptor csd) {
1:910b77f:         // Using the maximum buffer size will be optimal,
1:910b77f:         // unless the data is smaller than the maximum buffer.
1:910b77f:         int bufferSize = MAXIMUM_BUFFER_SIZE;
1:910b77f:         long knownLength = csd.getCharLength();
1:910b77f:         long maxCharLength = csd.getMaxCharLength();
1:910b77f:         if (knownLength < 1) {
1:910b77f:             // Unknown char length, use byte count instead (might be zero too).
1:910b77f:             knownLength = csd.getByteLength();
1:910b77f:         }
1:910b77f:         if (knownLength > 0 && knownLength < bufferSize) {
1:910b77f:             bufferSize = (int)knownLength;
1:910b77f:         }
1:910b77f:         if (maxCharLength > 0 && maxCharLength < bufferSize) {
1:910b77f:             bufferSize = (int)maxCharLength;
1:910b77f:         }
1:910b77f:         return bufferSize;
1:910b77f:     }
1:910b77f: 
1:910b77f:     /**
1:ab2037f:      * Skips the requested number of characters.
1:ab2037f:      *
1:ab2037f:      * @param toSkip number of characters to skip
1:ab2037f:      * @throws EOFException if there are too few characters in the stream
1:ab2037f:      * @throws IOException if reading from the stream fails
1:ab2037f:      */
1:ab2037f:     private final void persistentSkip(long toSkip)
1:ab2037f:             throws IOException {
1:ab2037f:         long remaining = toSkip;
1:ab2037f:         while (remaining > 0) {
1:ab2037f:             long skipped = skip(remaining);
1:ab2037f:             if (skipped == 0) {
1:ab2037f:                 if (SanityManager.DEBUG) {
1:ab2037f:                     // Add details to the exception in sane builds.
1:ab2037f:                     throw new EOFException("Reached end-of-stream after " +
1:ab2037f:                         readerCharCount + " characters, " + remaining +
1:ab2037f:                         " remaining to skip");
1:ab2037f:                 }
1:ab2037f:                 throw new EOFException();
1:ab2037f:             }
1:ab2037f:             remaining -= skipped;
1:ab2037f:         }
1:ab2037f:     }
1:ab2037f: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Lily Wei
-------------------------------------------------------------------------------
commit:56a7b39
/////////////////////////////////////////////////////////////////////////
1:             ConnectionChild.restoreIntrFlagIfSeen(true, parent.getEmbedConnection());
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3a6f4cf
/////////////////////////////////////////////////////////////////////////
0:             parent.restoreIntrFlagIfSeen(true, parent.getEmbedConnection());
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4987173
/////////////////////////////////////////////////////////////////////////
commit:a694c19
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Constructs a reader on top of the source UTF-8 encoded stream.
1:      * @param csd a description of and reference to the source stream
1:      * @param conChild the parent object / connection child
1:      * @param sync synchronization object used when accessing the underlying
1:      *      data stream
/////////////////////////////////////////////////////////////////////////
commit:7672693
/////////////////////////////////////////////////////////////////////////
1:     /** Stream that can reposition itself on request (may be {@code null}). */
1:     /**
1:      * Store the last visited position in the store stream, if it is capable of
1:      * repositioning itself ({@code positionedIn != null}).
1:      */
1:     /** Number of bytes read from the stream, including any header bytes. */
/////////////////////////////////////////////////////////////////////////
0:                 positionAware(positionedIn != null).
0:                 byteLength(utfLen == 0 ? 0 : utfLen +2). // Add header bytes
0:         utfCount = 2;
1:             Object sync)
1:             throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         if (csd.isPositionAware()) {
1:             // Check and save the stream state.
1:             if (SanityManager.DEBUG) {
1:             this.rawStreamPos = positionedIn.getPosition();
1:             // Make sure we start at the first data byte, not in the header.
1:             // The position will be changed on the next buffer fill.
1:             if (rawStreamPos < csd.getDataOffset()) {
1:                 rawStreamPos = csd.getDataOffset();
1:             }
1:         } else {
1:             // Skip the header if required.
1:             if (csd.getCurBytePos() < csd.getDataOffset()) {
1:                 csd.getStream().skip(csd.getDataOffset() - csd.getCurBytePos());
1:             }
/////////////////////////////////////////////////////////////////////////
1:         // Add the header portion to the utfCount.
1:         utfCount = csd.getDataOffset();
/////////////////////////////////////////////////////////////////////////
1:             final long utfLen = csd.getByteLength();
1:             final long maxFieldSize = csd.getMaxCharLength();
/////////////////////////////////////////////////////////////////////////
1:         this.utfCount = this.rawStreamPos = this.positionedIn.getPosition();
1:         this.readerCharCount = 0L;
commit:910b77f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.CharacterStreamDescriptor;
1: import org.apache.derby.iapi.types.PositionedStream;
/////////////////////////////////////////////////////////////////////////
0:     /** Stream that can reposition itself on request. */
1:     private final PositionedStream positionedIn;
/////////////////////////////////////////////////////////////////////////
1:      * Descriptor containing information about the stream.
1:      * Except for the current positions, the information in this object is
1:      * considered permanent and valid for the life-time of the stream.
1:      */
1:     private final CharacterStreamDescriptor csd;
1: 
1:     /**
0:      * TODO: This constructor will be removed! Is is currently retrofitted to
0:      *  use a CharacterStreamDescriptor.
1:      *
/////////////////////////////////////////////////////////////////////////
0:         long utfLen = 0;
/////////////////////////////////////////////////////////////////////////
0:                         ((Resetable)this.positionedIn).resetStream();
0:                 utfLen = readUnsignedShort();
/////////////////////////////////////////////////////////////////////////
0:         this.csd = new CharacterStreamDescriptor.Builder().
0:                 bufferable(positionedIn == null).
0:                 positionAware(positionedIn != null).byteLength(utfLen).
0:                 dataOffset(2).curBytePos(2).stream(in).
0:                 build();
1:     public UTF8Reader(CharacterStreamDescriptor csd, ConnectionChild conChild,
0:             Object sync) {
1:         super(sync);
1:         this.csd = csd;
1:         this.positionedIn =
1:                 (csd.isPositionAware() ? csd.getPositionedStream() : null);
1:         this.parent = conChild;
1:         int buffersize = calculateBufferSize(csd);
1:         this.buffer = new char[buffersize];
1: 
0:         // Check and save the stream state.
1:         if (SanityManager.DEBUG) { 
0:             if (csd.isPositionAware()) {
1:                 SanityManager.ASSERT(
1:                         csd.getCurBytePos() == positionedIn.getPosition());
1:             }
0:         this.rawStreamPos = positionedIn.getPosition();
0:         // Make sure we start at the first data byte, not in the header.
0:         if (rawStreamPos < csd.getDataOffset()) {
0:             rawStreamPos = csd.getDataOffset();
1:         }
1: 
1:         // Buffer stream for improved performance, if appropriate.
1:         if (csd.isBufferable()) {
1:             this.in = new BufferedInputStream(csd.getStream(), buffersize);
1:         } else {
1:             this.in = csd.getStream();
1:         }
/////////////////////////////////////////////////////////////////////////
1:             // Keep track of how much we are allowed to read.
0:             long utfLen = csd.getByteLength();
0:             long maxFieldSize = csd.getMaxCharLength();
/////////////////////////////////////////////////////////////////////////
1:                     // Close the stream if it cannot be reset.
1:                     if (!csd.isPositionAware()) {
1:                         closeIn();
1:                     }
/////////////////////////////////////////////////////////////////////////
1:                             // Close the stream if it cannot be reset.
1:                             if (!csd.isPositionAware()) {
1:                                 closeIn();
1:                             }
/////////////////////////////////////////////////////////////////////////
1:         // Close the stream if it cannot be reset.
1:         if (!csd.isPositionAware()) {
1:             closeIn();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         // Skip the length encoding bytes.
1:         this.positionedIn.reposition(csd.getDataOffset());
1:         // If bufferable, discard buffered stream and create a new one.
1:         if (csd.isBufferable()) {
1:             this.in = new BufferedInputStream(csd.getStream(), buffer.length);
1:         }
/////////////////////////////////////////////////////////////////////////
0:      * TODO: Remove this when CSD is fully integrated.
1:      *
/////////////////////////////////////////////////////////////////////////
1:      * Calculates an optimized buffer size.
1:      * <p>
1:      * The maximum size allowed is returned if the specified values don't give
1:      * enough information to say a smaller buffer size is preferable.
1:      *
1:      * @param csd stream descriptor
1:      * @return An (sub)optimal buffer size.
1:      */
1:     private final int calculateBufferSize(CharacterStreamDescriptor csd) {
1:         // Using the maximum buffer size will be optimal,
1:         // unless the data is smaller than the maximum buffer.
1:         int bufferSize = MAXIMUM_BUFFER_SIZE;
1:         long knownLength = csd.getCharLength();
1:         long maxCharLength = csd.getMaxCharLength();
1:         if (knownLength < 1) {
1:             // Unknown char length, use byte count instead (might be zero too).
1:             knownLength = csd.getByteLength();
1:         }
1:         if (knownLength > 0 && knownLength < bufferSize) {
1:             bufferSize = (int)knownLength;
1:         }
1:         if (maxCharLength > 0 && maxCharLength < bufferSize) {
1:             bufferSize = (int)maxCharLength;
1:         }
1:         return bufferSize;
1:     }
1: 
1:     /**
commit:925b07b
/////////////////////////////////////////////////////////////////////////
1:         if (requestedCharPos <= readerCharCount - charactersInBuffer) {
1:             // The stream must be reset, because the requested position is
1:             // before the current lower buffer boundary.
1:             resetUTF8Reader();
1:         }
1: 
1:         long currentCharPos =
1:             readerCharCount - charactersInBuffer + readPositionInBuffer;
1:         long difference = (requestedCharPos - 1) - currentCharPos;
1: 
1:         if (difference <= 0) {
1:             // Move back in the buffer.
1:             readPositionInBuffer += difference;
1:             // Skip forward.
1:             persistentSkip(difference);
commit:ab2037f
/////////////////////////////////////////////////////////////////////////
1:      * Resets the reader.
1:      * <p>
1:      * This method is used internally to achieve better performance.
1:      * @see #reposition(long)
1:      *
1:      * @throws IOException if resetting or reading from the stream fails
1:      * @throws StandardException if resetting the stream fails
1:      */
1:     private void resetUTF8Reader()
1:             throws IOException, StandardException {
0:         // 2L to skip the length encoding bytes.
0:         this.positionedIn.reposition(2L);
1:         this.rawStreamPos = this.positionedIn.getPosition();
0:         this.in = this.positionedIn;
0:         this.readerCharCount = this.utfCount = 0L;
1:         this.charactersInBuffer = this.readPositionInBuffer = 0;
1:     }
1: 
1:     /**
1:      * Repositions the stream so that the next character read will be the
1:      * character at the requested position.
1:      * <p>
1:      * There are three types of repositioning, ordered after increasing cost:
1:      * <ol> <li>Reposition within current character buffer (small hops forwards
1:      *          and potentially backwards - in range 1 char to
1:      *          {@code MAXIMUM_BUFFER_SIZE} chars)</li>
1:      *      <li>Forward stream from current position (hops forwards)</li>
1:      *      <li>Reset stream and skip data (hops backwards)</li>
1:      * </ol>
1:      *
1:      * @param requestedCharPos 1-based requested character position
1:      * @throws IOException if resetting or reading from the stream fails
1:      * @throws StandardException if resetting the stream fails
1:      */
1:     void reposition(long requestedCharPos)
1:             throws IOException, StandardException {
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(this.positionedIn != null);
1:             SanityManager.ASSERT(requestedCharPos > 0);
1:         }
0:         // See if we can continue reading, or do nothing at all, to get to the
0:         // right position.
0:         if (requestedCharPos > readerCharCount) {
0:             // The second part corrects for the internal buffer position.
0:             long toSkip = (requestedCharPos - readerCharCount) +
0:                     (charactersInBuffer - readPositionInBuffer) -1;
0:             persistentSkip(toSkip);
1:         } else {
0:             // See if the requested position is within the current buffer.
0:             long lowerBufferBorder = readerCharCount - charactersInBuffer;
0:             if (requestedCharPos <= lowerBufferBorder) {
0:                 // Have to reset and start from scratch.
0:                 resetUTF8Reader();
0:                 persistentSkip(requestedCharPos -1);
1:             } else {
0:                 // We have the requested position in the buffer already.
0:                 readPositionInBuffer =
0:                         (int)(requestedCharPos - lowerBufferBorder -1);
1:             }
1:         }
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Skips the requested number of characters.
1:      *
1:      * @param toSkip number of characters to skip
1:      * @throws EOFException if there are too few characters in the stream
1:      * @throws IOException if reading from the stream fails
1:      */
1:     private final void persistentSkip(long toSkip)
1:             throws IOException {
1:         long remaining = toSkip;
1:         while (remaining > 0) {
1:             long skipped = skip(remaining);
1:             if (skipped == 0) {
0:                 if (SanityManager.DEBUG) {
1:                     // Add details to the exception in sane builds.
1:                     throw new EOFException("Reached end-of-stream after " +
1:                         readerCharCount + " characters, " + remaining +
1:                         " remaining to skip");
1:                 }
1:                 throw new EOFException();
1:             }
1:             remaining -= skipped;
1:         }
1:     }
commit:95d725a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         readPositionInBuffer = 0;
commit:c16a2d0
/////////////////////////////////////////////////////////////////////////
1:     /** Maximum size in number of chars for the internal character buffer. */
1:     private static final int MAXIMUM_BUFFER_SIZE = 8*1024; // 8 KB
/////////////////////////////////////////////////////////////////////////
1:     private final char[]   buffer;
/////////////////////////////////////////////////////////////////////////
0:                 this.in = in; // Note the possible reassignment below.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // Setup buffering.
0:         int bufferSize = calculateBufferSize(utfLen, maxFieldSize);
0:         this.buffer = new char[bufferSize];
0:         if (this.positionedIn == null) {
0:             // Buffer this for improved performance.
0:             // Note that the stream buffers bytes, whereas the internal buffer
0:             // buffers characters. In worst case, the stream buffer must be
0:             // filled three times to fill the internal character buffer.
0:             this.in = new BufferedInputStream(in, bufferSize);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         int bufferSize = calculateBufferSize(streamSize, maxFieldSize);
0:         this.buffer = new char[bufferSize];
0:         // Note that the stream buffers bytes, whereas the internal buffer
0:         // buffers characters. In worst case, the stream buffer must be filled
0:         // three times to fill the internal character buffer.
0:         this.in = new BufferedInputStream(in, bufferSize);
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Calculates an optimized buffer size.
1:      * <p>
0:      * The maximum size allowed is returned if the specified values don't give
0:      * enough information to say a smaller buffer size is preferable.
1:      *
0:      * @param encodedSize data length in bytes
0:      * @param maxFieldSize maximum data length in bytes
0:      * @return An (sub)optimal buffer size.
1:      */
0:     private final int calculateBufferSize(long encodedSize, long maxFieldSize) {
0:         int bufferSize = MAXIMUM_BUFFER_SIZE;
0:         if (encodedSize > 0 && encodedSize < bufferSize) {
0:             bufferSize = (int)encodedSize;
1:         }
0:         if (maxFieldSize > 0 && maxFieldSize < bufferSize) {
0:             bufferSize = (int)maxFieldSize;
1:         }
0:         return bufferSize;
1:     }
commit:48152c2
/////////////////////////////////////////////////////////////////////////
1:  * Class for reading characters from streams encoded in the modified UTF-8
1:  * format.
1:  * <p>
1:  * Note that we often operate on a special Derby stream.
1:  * A Derby stream is possibly different from a "normal" stream in two ways;
1:  * an encoded length is inserted at the head of the stream, and if the encoded
1:  * length is <code>0</code> a Derby-specific end of stream marker is appended
1:  * to the data.
1:  * <p>
1:  * If the underlying stream is capable of repositioning itself on request,
1:  * this class supports multiple readers on the same source stream in such a way
1:  * that the various readers do not interfere with each other (except for
1:  * serializing access). Each reader instance will have its own pointer into the
1:  * stream, and request that the stream repositions itself before calling
1:  * read/skip on the stream.
1:  *
1:  * @see PositionedStoreStream
1:  */
1:     /** The underlying data stream. */
0:     /** Store stream that can reposition itself on request. */
1:     /**
0:      * The expected number of bytes in the stream, if known.
1:      * <p>
0:      * A value of <code>0<code> means the length is unknown, and that the end
0:      * of the stream is marked with a Derby-specific end of stream marker.
1:      */
0:     /** Number of bytes read from the stream. */
1:     /** Number of characters read from the stream. */
1:     /** 
0:      * The maximum number of characters allowed for the column
0:      * represented by the passed stream.
1:      * <p>
0:      * A value of <code>0</code> means there is no associated maximum length.
1:      */
1:     /** Internal character buffer storing characters read from the stream. */
0:     private final char[]   buffer = new char[8 * 1024];
1:     /** The number of characters in the internal buffer. */
1:     /** The position of the next character to read in the internal buffer. */
1:     /** Tells if this reader has been closed. */
1:     /** 
1:      * A reference to the parent object of the stream.
1:      * <p>
1:      * The reference is kept so that the parent object can't get
1:      * garbage collected until we are done with the stream.
1:      */
1:     /**
0:      * Constructs a reader and consumes the encoded length bytes from the
0:      * stream.
1:      * <p>
0:      * The encoded length bytes either state the number of bytes in the stream,
0:      * or it is <code>0</code> which informs us the length is unknown or could
0:      * not be represented and that we have to look for the Derby-specific
0:      * end of stream marker.
1:      * 
0:      * @param in the underlying stream
0:      * @param maxFieldSize the maximum allowed column length in characters
0:      * @param parent the parent object / connection child
0:      * @param synchronization synchronization object used when accessing the
0:      *      underlying data stream
1:      * 
1:      * @throws IOException if reading from the underlying stream fails
0:      * @throws SQLException if setting up or restoring the context stack fails
1:      */
/////////////////////////////////////////////////////////////////////////
0:                 // stream is passed in after a ResultSet.getXXXStream method.
/////////////////////////////////////////////////////////////////////////
0:             Object synchronization) {
/////////////////////////////////////////////////////////////////////////
1:      * Reader implemention.
1:      */
1: 
1:     /**
1:      * Reads a single character from the stream.
1:      * 
1:      * @return A character or <code>-1</code> if end of stream has been reached.
1:      * @throws IOException if the stream has been closed, or an exception is
1:      *      raised while reading from the underlying stream
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Reads characters into an array.
1:      * 
1:      * @return The number of characters read, or <code>-1</code> if the end of
1:      *      the stream has been reached.
1:      */ 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Skips characters.
0:      * 
1:      * @param len the numbers of characters to skip
1:      * @return The number of characters actually skipped.
1:      * @throws IllegalArgumentException if the number of characters to skip is
1:      *      negative
1:      * @throws IOException if accessing the underlying stream fails
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Close the reader, disallowing further reads.
1:      */
1:             parent = null;
1:      * Methods just for Derby's JDBC driver
1:      */
1: 
1:     /**
1:      * Reads characters from the stream.
0:      * <p>
1:      * Due to internal buffering a smaller number of characters than what is
1:      * requested might be returned. To ensure that the request is fulfilled,
1:      * call this method in a loop until the requested number of characters is
1:      * read or <code>-1</code> is returned.
0:      * 
1:      * @param sb the destination buffer
1:      * @param len maximum number of characters to read
1:      * @return The number of characters read, or <code>-1</code> if the end of
1:      *      the stream is reached.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Reads characters into an array as ASCII characters.
0:      * <p>
1:      * Due to internal buffering a smaller number of characters than what is
1:      * requested might be returned. To ensure that the request is fulfilled,
1:      * call this method in a loop until the requested number of characters is
1:      * read or <code>-1</code> is returned.
0:      * <p>
1:      * Characters outside the ASCII range are replaced with an out of range
1:      * marker.
0:      * 
1:      * @param abuf the buffer to read into
1:      * @param off the offset into the destination buffer
1:      * @param len maximum number of characters to read
1:      * @return The number of characters read, or <code>-1</code> if the end of
1:      *      the stream is reached.
1:      */
/////////////////////////////////////////////////////////////////////////
1:      * internal implementation
1:      */
1:     /**
1:      * Close the underlying stream if it is open.
1:      */
1:                 // Ignore exceptions thrown on close.
1:                 // [TODO] Maybe we should log these?
1:     /**
1:      * Convenience method generating an {@link UTFDataFormatException} and
1:      * cleaning up the reader state.
1:      */
/////////////////////////////////////////////////////////////////////////
1:      * Fills the internal character buffer by decoding bytes from the stream.
0:      * 
1:      * @return <code>true</code> if the end of the stream is reached,
1:      *      <code>false</code> if there is apparently more data to be read.
0:      */
/////////////////////////////////////////////////////////////////////////
0:     /**
0:      * Decode the length encoded in the stream.
0:      * 
0:      * This method came from {@link java.io.DataInputStream}
0:      * 
0:      * @return The number of bytes in the stream, or <code>0</code> if the
0:      *      length is unknown and the end of stream must be marked by the
0:      *      Derby-specific end of stream marker.
0:      */
commit:2dce4ab
/////////////////////////////////////////////////////////////////////////
1:     private static final String READER_CLOSED = "Reader closed";
/////////////////////////////////////////////////////////////////////////
0:     private final long maxFieldSize;    // characters
/////////////////////////////////////////////////////////////////////////
1:                 throw new IOException(READER_CLOSED);
/////////////////////////////////////////////////////////////////////////
1:                 throw new IOException(READER_CLOSED);
/////////////////////////////////////////////////////////////////////////
1:                 throw new IOException(READER_CLOSED);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 throw utfFormatException("Reached EOF prematurely, " +
1:                     "read " + utfCount + " out of " + utfLen + " bytes");
/////////////////////////////////////////////////////////////////////////
1:                         throw utfFormatException("Reached EOF when reading " +
1:                             "second byte in a two byte character encoding; " +
1:                             "byte/char position " + utfCount + "/" +
1:                             readerCharCount);
1:                         throw utfFormatException("Second byte in a two byte" +
1:                             "character encoding invalid: (int)" + char2 +
1:                             ", byte/char pos " + utfCount + "/" +
1:                             readerCharCount);
/////////////////////////////////////////////////////////////////////////
1:                         throw utfFormatException("Reached EOF when reading " +
1:                             "second/third byte in a three byte character " +
1:                             "encoding; byte/char position " + utfCount + "/" +
1:                             readerCharCount);
/////////////////////////////////////////////////////////////////////////
1:                         throw utfFormatException("Internal error: Derby-" +
1:                             "specific EOF marker read");
1:                         throw utfFormatException("Second/third byte in a " +
1:                             "three byte character encoding invalid: (int)" +
1:                             char2 + "/" + char3 + ", byte/char pos " +
1:                             utfCount + "/" + readerCharCount);
/////////////////////////////////////////////////////////////////////////
1:                     throw utfFormatException("Invalid UTF encoding at " +
1:                         "byte/char position " + utfCount + "/" +
1:                         readerCharCount + ": (int)" + c);
1:             throw utfFormatException("Incorrect encoded length in stream, " +
1:                 "expected " + utfLen + ", have " + utfCount + " bytes");
/////////////////////////////////////////////////////////////////////////
0:             throw new EOFException("Reached EOF when reading" +
0:                                    "encoded length bytes");
commit:fe27d9d
/////////////////////////////////////////////////////////////////////////
0:     private final long utfLen;          // bytes
1:     private long       utfCount;        // bytes
1:     private long       readerCharCount; // characters
0:     private long       maxFieldSize;    // characeters
0:     private char[]         buffer = new char[8 * 1024];
1:     private int            charactersInBuffer; // within buffer
1:     private boolean noMoreReads;
0:     // maintain a reference to the parent object so that it can't get
1:     private ConnectionChild parent;
0:         InputStream in,
0:         long maxFieldSize,
0:         ConnectionChild parent,
0:         Object synchronization)
0:             throws IOException, SQLException
/////////////////////////////////////////////////////////////////////////
0:             InputStream in,
0:             long maxFieldSize,
0:             long streamSize,
0:             ConnectionChild parent,
0:             Object synchronization)
/////////////////////////////////////////////////////////////////////////
1:                 "Number of characters to skip must be positive: " + len);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             switch (c >> 4) {
/////////////////////////////////////////////////////////////////////////
0:                         throw utfFormatException();
/////////////////////////////////////////////////////////////////////////
0:                         throw utfFormatException();
/////////////////////////////////////////////////////////////////////////
0:                     throw utfFormatException();
1:         if (utfLen != 0 && utfCount > utfLen)
0:             throw utfFormatException("utfCount " + utfCount + " utfLen " + utfLen);
/////////////////////////////////////////////////////////////////////////
commit:ebb8b8b
/////////////////////////////////////////////////////////////////////////
1:     private InputStream in;
0:     private final long         utfLen;    // bytes
0:     private long        utfCount;        // bytes
0:     private long        readerCharCount; // characters
0:     private long        maxFieldSize;    // characeters
0:     private char[]        buffer = new char[8 * 1024];
0:     private int            charactersInBuffer;    // within buffer
1:     private int            readPositionInBuffer;
0:     private boolean        noMoreReads;
0:     public UTF8Reader(
0:     long maxFieldSize,
0:     Object synchronization) 
1:     {
0:         super(synchronization);
0:         this.maxFieldSize = maxFieldSize;
0:         this.parent = parent;
/////////////////////////////////////////////////////////////////////////
1:     }
/////////////////////////////////////////////////////////////////////////
1:     /*
0:     ** Reader implemention.
0:     */
1:     public int read() throws IOException
1:     {
1:         synchronized (lock) {
1:             // check if closed..
1:             if (noMoreReads)
0:                 throw new IOException();
1:             if (readPositionInBuffer >= charactersInBuffer) {
1:                 if (fillBuffer()) {
1:                     return -1;
1:                 }
0:                 readPositionInBuffer = 0;
1:             }
1:             return buffer[readPositionInBuffer++];
1:         }
1:     }
1:     public int read(char[] cbuf, int off, int len) throws IOException
1:     {
1:         synchronized (lock) {
1:             // check if closed..
1:             if (noMoreReads)
0:                 throw new IOException();
1:             if (readPositionInBuffer >= charactersInBuffer) {
1:                 if (fillBuffer()) {
1:                     return -1;
1:                 }
0:                 readPositionInBuffer = 0;
1:             }
1:             int remainingInBuffer = charactersInBuffer - readPositionInBuffer;
1:             if (len > remainingInBuffer)
1:                 len = remainingInBuffer;
1:             System.arraycopy(buffer, readPositionInBuffer, cbuf, off, len);
1:             readPositionInBuffer += len;
1:             return len;
1:         }
1:     }
1:     public long skip(long len) throws IOException {
1:         if (len < 0) {
1:             throw new IllegalArgumentException(
0:                 "Number of characters to skip must be positive:" + len);
1:         }
1:         synchronized (lock) {
1:             // check if closed..
1:             if (noMoreReads)
0:                 throw new IOException();
1:             if (readPositionInBuffer >= charactersInBuffer) {
1:                 // do somthing
1:                 if (fillBuffer()) {
1:                     return 0L;
1:                 }
0:                 readPositionInBuffer = 0;
1:             }
1:             int remainingInBuffer = charactersInBuffer - readPositionInBuffer;
1:             if (len > remainingInBuffer)
1:                 len = remainingInBuffer;
1:             readPositionInBuffer += len;
1:             return len;
1:         }
1:     }
1:     public void close()
1:     {
1:         synchronized (lock) {
1:             closeIn();
0:             parent  = null;
1:             noMoreReads = true;
1:         }
1:     }
1:     /*
0:     ** Methods just for Derby's JDBC driver
0:     */
1:     public int readInto(StringBuffer sb, int len) throws IOException {
1:         synchronized (lock) {
1:             if (readPositionInBuffer >= charactersInBuffer) {
1:                 if (fillBuffer()) {
1:                     return -1;
1:                 }
0:                 readPositionInBuffer = 0;
1:             }
1:             int remainingInBuffer = charactersInBuffer - readPositionInBuffer;
1:             if (len > remainingInBuffer)
1:                 len = remainingInBuffer;
1:             sb.append(buffer, readPositionInBuffer, len);
1:             readPositionInBuffer += len;
1:             return len;
1:         }
1:     }
1:     int readAsciiInto(byte[] abuf, int off, int len) throws IOException {
1:         synchronized (lock) {
1:             if (readPositionInBuffer >= charactersInBuffer) {
1:                 if (fillBuffer()) {
1:                     return -1;
1:                 }
0:                 readPositionInBuffer = 0;
1:             }
1:             int remainingInBuffer = charactersInBuffer - readPositionInBuffer;
1:             if (len > remainingInBuffer)
1:                 len = remainingInBuffer;
1:             char[] lbuffer = buffer;
1:             for (int i = 0; i < len; i++) {
1:                 char c = lbuffer[readPositionInBuffer + i];
1:                 byte cb;
1:                 if (c <= 255)
1:                     cb = (byte) c;
1:                 else
1:                     cb = (byte) '?'; // Question mark - out of range character.
1:                 abuf[off + i] = cb;
1:             }
1:             readPositionInBuffer += len;
1:             return len;
1:         }
1:     }
1:     /*
0:     ** internal implementation
0:     */
1:     private void closeIn() {
1:         if (in != null) {
1:             try {
1:                 in.close();
1:             } catch (IOException ioe) {
1:             } finally {
1:                 in = null;
1:             }
1:         }
1:     }
1:     private IOException utfFormatException(String s) {
1:         noMoreReads = true;
1:         closeIn();
1:         return new UTFDataFormatException(s);
1:     }
0:     private IOException utfFormatException() {
1:         noMoreReads = true;
1:         closeIn();
0:         return new UTFDataFormatException();
1:     }
0:     /**
0:         Fill the buffer, return true if eof has been reached.
0:     */
1:     private boolean fillBuffer() throws IOException
1:     {
1:         if (in == null)
1:             return true;
1:         charactersInBuffer = 0;
1:         try {
1:         try {
1:         
1:             parent.setupContextStack();
/////////////////////////////////////////////////////////////////////////
1:         while (
1:                 (charactersInBuffer < buffer.length) &&
1:                 ((utfCount < utfLen) || (utfLen == 0)) &&
1:                 ((maxFieldSize == 0) || (readerCharCount < maxFieldSize))
1:               )
1:         {
1:             int c = in.read();
1:             if (c == -1) {
1:                 if (utfLen == 0) {
0:                     closeIn();
1:                     break readChars;
1:                 }
0:                 throw utfFormatException();
1:             }
1:             int finalChar;
0:             switch (c >> 4) { 
1:                 case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
1:                     // 0xxxxxxx
1:                     utfCount++;
1:                     finalChar = c;
1:                     break;
1:                 case 12: case 13:
1:                     {
1:                     // 110x xxxx   10xx xxxx
1:                     utfCount += 2;
1:                     int char2 = in.read();
1:                     if (char2 == -1)
0:                         throw utfFormatException();
1:                     if ((char2 & 0xC0) != 0x80)
0:                         throw utfFormatException();          
1:                     finalChar = (((c & 0x1F) << 6) | (char2 & 0x3F));
1:                     break;
1:                     }
1:                 case 14:
1:                     {
1:                     // 1110 xxxx  10xx xxxx  10xx xxxx
1:                     utfCount += 3;
1:                     int char2 = in.read();
1:                     int char3 = in.read();
1:                     if (char2 == -1 || char3 == -1)
0:                         throw utfFormatException();
1:                     if ((c == 0xE0) && (char2 == 0) && (char3 == 0))
1:                     {
1:                         if (utfLen == 0) {
1:                             // we reached the end of a long string,
1:                             // that was terminated with
1:                             // (11100000, 00000000, 00000000)
0:                             closeIn();
1:                             break readChars;
1:                         }
0:                         throw utfFormatException();
1:                     }
1:                     if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80))
0:                         throw utfFormatException();    
1:                     finalChar = (((c & 0x0F) << 12) |
1:                                ((char2 & 0x3F) << 6) |
1:                                ((char3 & 0x3F) << 0));
1:                     }
1:                     break;
1:                 default:
1:                     // 10xx xxxx,  1111 xxxx
0:                     throw utfFormatException();          
1:             }
1:             buffer[charactersInBuffer++] = (char) finalChar;
1:             readerCharCount++;
1:         }
0:         if (utfLen != 0 && utfCount > utfLen) 
0:             throw utfFormatException("utfCount " + utfCount + " utfLen " + utfLen);          
/////////////////////////////////////////////////////////////////////////
1:             return false;
0:         closeIn();
1:         return true;
1:         } finally {
1:             parent.restoreContextStack();
1:         }
1:         } catch (SQLException sqle) {
1:         }
1:     }
0:     // this method came from java.io.DataInputStream
0:         int ch1 = in.read();
0:         int ch2 = in.read();
0:         if ((ch1 | ch2) < 0)
0:             throw new EOFException();
0:         return (ch1 << 8) + (ch2 << 0);
1:     }
commit:f839f5e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.types.Resetable;
1: 
0:     /** Stream store that can reposition itself on request. */
0:     private final PositionedStoreStream positionedIn;
0:     /** Store last visited position in the store stream. */
1:     private long rawStreamPos = 0L;
/////////////////////////////////////////////////////////////////////////
0:         throws IOException, SQLException
0:         parent.setupContextStack();
1:         try {
0:             synchronized (lock) { // Synchronize access to store.
0:                 if (in instanceof PositionedStoreStream) {
0:                     this.positionedIn = (PositionedStoreStream)in;
0:                     // This stream is already buffered, and buffering it again
0:                     // this high up complicates the handling a lot. Must
0:                     // implement a special buffered reader to buffer again.
0:                     // Note that buffering this UTF8Reader again, does not
0:                     // cause any trouble...
0:                     this.in = in;
1:                     try {
0:                         this.positionedIn.resetStream();
1:                     } catch (StandardException se) {
0:                         IOException ioe = new IOException(se.getMessage());
0:                         ioe.initCause(se);
0:                         throw ioe;
0:                     }
0:                 } else {
0:                     this.positionedIn = null;
0:                     // Buffer this for improved performance.
0:                     this.in = new BufferedInputStream (in);
0:                 }
0:                 this.utfLen = readUnsignedShort();
0:                 // Even if we are reading the encoded length, the stream may
0:                 // not be a positioned stream. This is currently true when a
0:                 // stream is passed in after a ResetSet.getXXXStream method.
1:                 if (this.positionedIn != null) {
0:                     this.rawStreamPos = this.positionedIn.getPosition();
0:                 }
0:             } // End synchronized block
0:         } finally {
0:             parent.restoreContextStack();
0:         }
/////////////////////////////////////////////////////////////////////////
0:         this.positionedIn = null;
1: 
0:         if (SanityManager.DEBUG) {
0:             // Do not allow the inputstream here to be a Resetable, as this
0:             // means (currently, not by design...) that the length is encoded in
0:             // the stream and we can't pass that out as data to the user.
0:             SanityManager.ASSERT(!(in instanceof Resetable));
0:         }
0:         // Buffer this for improved performance.
0:         this.in = new BufferedInputStream(in);
/////////////////////////////////////////////////////////////////////////
1:     //@GuardedBy("lock")
/////////////////////////////////////////////////////////////////////////
1:             // If we are operating on a positioned stream, reposition it to
1:             // continue reading at the position we stopped last time.
1:             if (this.positionedIn != null) {
0:                 try {
1:                     this.positionedIn.reposition(this.rawStreamPos);
0:                 } catch (StandardException se) {
1:                     throw Util.generateCsSQLException(se);
0:                 }
0:             }
/////////////////////////////////////////////////////////////////////////
1:         if (charactersInBuffer != 0) {
0:             if (this.positionedIn != null) {
1:                 // Save the last visisted position so we can start reading where
1:                 // we let go the next time we fill the buffer.
0:                 this.rawStreamPos = this.positionedIn.getPosition();
0:             }
0:         }
/////////////////////////////////////////////////////////////////////////
0:             IOException ioe =
0:                 new IOException(sqle.getSQLState() + ": " + sqle.getMessage());
0:             ioe.initCause(sqle);
0:             throw ioe;
commit:fe1130b
/////////////////////////////////////////////////////////////////////////
0: 		if (len < 0) {
0: 			throw new IllegalArgumentException(
0: 				"Number of characters to skip must be positive:" + len);
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 					return 0L;
commit:e5b15ce
/////////////////////////////////////////////////////////////////////////
1: 
0:      * Constructs a <code>UTF8Reader</code> using a stream.
0:      * <p>
0:      * This consturctor accepts the stream size as parameter and doesn't
0:      * attempt to read the length from the stream.
0:      *
0:      * @param in the underlying stream
0:      * @param maxFieldSize the maximum allowed length for the associated column
0:      * @param streamSize size of the underlying stream in bytes
0:      * @param parent the connection child this stream is associated with
0:     public UTF8Reader(
0:                 ConnectionChild parent,
0:         super(synchronization);
1: 
0:         this.in = new BufferedInputStream(in);
0:         this.maxFieldSize = maxFieldSize;
0:         this.parent = parent;
0:         this.utfLen = streamSize;
0:     }
commit:e1fc783
/////////////////////////////////////////////////////////////////////////
1:         
0:     /**
0:      * Constructs a UTF8Reader using a stream. This consturctor accepts 
0:      * the stream size as paramater and doesn't attempts to read the lenght 
0:      * from the stream.
0:      * @param in InputStream
0:      * @param maxFieldSize 
0:      * @param streamSize size of the stream
0:      * @param parent connectionChild this stream is associated with
0:      * @param synchronization object to synchronize on
0:      * @throws IOException
0:      */
0:         public UTF8Reader(
0:                 InputStream in,
0:                 long maxFieldSize,
0:                 long streamSize,
0:                 ConnectionChild      parent,                
0:                 Object synchronization)
0:                 throws IOException {
0:             super(synchronization);
1:             
0:             this.in     = in;
0:             this.maxFieldSize = maxFieldSize;
0:             this.parent = parent;
0:             this.utfLen = streamSize;
0:         }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:ed0be21
/////////////////////////////////////////////////////////////////////////
0:                         throw Util.newIOException(se);
/////////////////////////////////////////////////////////////////////////
1:             throw Util.newIOException(sqle);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1315d5e
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedInputStream;
/////////////////////////////////////////////////////////////////////////
0: 		this.in     = new BufferedInputStream (in);
/////////////////////////////////////////////////////////////////////////
0:             this.in     = new BufferedInputStream (in);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.jdbc.UTF8Reader
1: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
0:  */
1: 
1: package org.apache.derby.impl.jdbc;
1: 
1: import java.io.InputStream;
1: import java.io.Reader;
1: import java.io.IOException;
1: import java.io.UTFDataFormatException;
1: import java.io.EOFException;
1: import java.sql.SQLException;
1: 
0: /**
0: */
1: public final class UTF8Reader extends Reader
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
1: 
0: 	private InputStream in;
0: 	private final long         utfLen;	// bytes
0: 	private long        utfCount;		// bytes
0: 	private long		readerCharCount; // characters
0: 	private long		maxFieldSize;	// characeters
1: 
0: 	private char[]		buffer = new char[8 * 1024];
0: 	private int			charactersInBuffer;	// within buffer
0: 	private int			readPositionInBuffer;
1: 
0: 	private boolean		noMoreReads;
1: 
0:     // maintain a reference to the parent object so that it can't get 
0:     // garbage collected until we are done with the stream.
0:     private ConnectionChild      parent;
1: 
0: 	public UTF8Reader(
0:     InputStream in,
0: 	long maxFieldSize,
0:     ConnectionChild      parent,
0: 	Object synchronization) 
0:         throws IOException
0: 	{
0: 		super(synchronization);
1: 
0: 		this.in     = in;
0: 		this.maxFieldSize = maxFieldSize;
0: 		this.parent = parent;
1: 
0: 		synchronized (lock) {
0: 			this.utfLen = readUnsignedShort();
0: 		}
0: 	}
1: 
1: 	/*
0: 	** Reader implemention.
0: 	*/
0: 	public int read() throws IOException
0: 	{
0: 		synchronized (lock) {
1: 
0: 			// check if closed..
0: 			if (noMoreReads)
0: 				throw new IOException();
1: 
0: 			if (readPositionInBuffer >= charactersInBuffer) {
0: 				if (fillBuffer()) {
0: 					return -1;
0: 				}
0: 				readPositionInBuffer = 0;
0: 			}
1: 
0: 			return buffer[readPositionInBuffer++];
0: 		}
0: 	}
1: 
0: 	public int read(char[] cbuf, int off, int len) throws IOException
0: 	{
0: 		synchronized (lock) {
0: 			// check if closed..
0: 			if (noMoreReads)
0: 				throw new IOException();
1: 
0: 			if (readPositionInBuffer >= charactersInBuffer) {
0: 				if (fillBuffer()) {
0: 					return -1;
0: 				}
0: 				readPositionInBuffer = 0;
0: 			}
1: 
0: 			int remainingInBuffer = charactersInBuffer - readPositionInBuffer;
1: 
0: 			if (len > remainingInBuffer)
0: 				len = remainingInBuffer;
1: 
0: 			System.arraycopy(buffer, readPositionInBuffer, cbuf, off, len);
0: 			readPositionInBuffer += len;
1: 
0: 			return len;
0: 		}
0: 	}
1: 
0: 	public long skip(long len) throws IOException {
0: 		synchronized (lock) {
0: 			// check if closed..
0: 			if (noMoreReads)
0: 				throw new IOException();
1: 
0: 			if (readPositionInBuffer >= charactersInBuffer) {
0: 				// do somthing
0: 				if (fillBuffer()) {
0: 					return -1;
0: 				}
0: 				readPositionInBuffer = 0;
0: 			}
1: 
0: 			int remainingInBuffer = charactersInBuffer - readPositionInBuffer;
1: 
0: 			if (len > remainingInBuffer)
0: 				len = remainingInBuffer;
1: 
0: 			readPositionInBuffer += len;
1: 
0: 			return len;
0: 		}
1: 
0: 	}
1: 
0: 	public void close()
0: 	{
0: 		synchronized (lock) {
0: 			closeIn();
0: 			parent  = null;
0: 			noMoreReads = true;
0: 		}
0: 	}
1: 
1: 	/*
0: 	** Methods just for Cloudscape's JDBC driver
0: 	*/
1: 
0: 	public int readInto(StringBuffer sb, int len) throws IOException {
1: 
0: 		synchronized (lock) {
0: 			if (readPositionInBuffer >= charactersInBuffer) {
0: 				if (fillBuffer()) {
0: 					return -1;
0: 				}
0: 				readPositionInBuffer = 0;
0: 			}
1: 
0: 			int remainingInBuffer = charactersInBuffer - readPositionInBuffer;
1: 
0: 			if (len > remainingInBuffer)
0: 				len = remainingInBuffer;
0: 			sb.append(buffer, readPositionInBuffer, len);
1: 
0: 			readPositionInBuffer += len;
1: 
0: 			return len;
0: 		}
0: 	}
0: 	int readAsciiInto(byte[] abuf, int off, int len) throws IOException {
1: 
0: 		synchronized (lock) {
0: 			if (readPositionInBuffer >= charactersInBuffer) {
0: 				if (fillBuffer()) {
0: 					return -1;
0: 				}
0: 				readPositionInBuffer = 0;
0: 			}
1: 
0: 			int remainingInBuffer = charactersInBuffer - readPositionInBuffer;
1: 
0: 			if (len > remainingInBuffer)
0: 				len = remainingInBuffer;
1: 
0: 			char[] lbuffer = buffer;
0: 			for (int i = 0; i < len; i++) {
0: 				char c = lbuffer[readPositionInBuffer + i];
0: 				byte cb;
0: 				if (c <= 255)
0: 					cb = (byte) c;
0: 				else
0: 					cb = (byte) '?'; // Question mark - out of range character.
1: 
0: 				abuf[off + i] = cb;
0: 			}
1: 
0: 			readPositionInBuffer += len;
1: 
0: 			return len;
0: 		}
0: 	}
1: 
1: 	/*
0: 	** internal implementation
0: 	*/
1: 
1: 
0: 	private void closeIn() {
0: 		if (in != null) {
0: 			try {
0: 				in.close();
0: 			} catch (IOException ioe) {
0: 			} finally {
0: 				in = null;
0: 			}
0: 		}
0: 	}
0: 	private IOException utfFormatException(String s) {
0: 		noMoreReads = true;
0: 		closeIn();
0: 		return new UTFDataFormatException(s);
0: 	}
1: 
0: 	private IOException utfFormatException() {
0: 		noMoreReads = true;
0: 		closeIn();
0: 		return new UTFDataFormatException();
0: 	}
1: 
0: 	/**
0: 		Fill the buffer, return true if eof has been reached.
0: 	*/
0: 	private boolean fillBuffer() throws IOException
0: 	{
0: 		if (in == null)
0: 			return true;
1: 
0: 		charactersInBuffer = 0;
1: 
0: 		try {
0: 		try {
1: 		
0: 			parent.setupContextStack();
1: 
1: readChars:
0: 		while (
0: 				(charactersInBuffer < buffer.length) &&
0: 			    ((utfCount < utfLen) || (utfLen == 0)) &&
0: 				((maxFieldSize == 0) || (readerCharCount < maxFieldSize))
0: 			  )
0: 		{
0: 			int c = in.read();
0: 			if (c == -1) {
0: 				if (utfLen == 0) {
0: 					closeIn();
0: 					break readChars;
0: 				}
0: 				throw utfFormatException();
0: 			}
1: 
0: 			int finalChar;
0: 			switch (c >> 4) { 
0: 				case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
0: 					// 0xxxxxxx
0: 					utfCount++;
0: 					finalChar = c;
0: 					break;
1: 
0: 				case 12: case 13:
0: 					{
0: 					// 110x xxxx   10xx xxxx
0: 					utfCount += 2;
0: 					int char2 = in.read();
0: 					if (char2 == -1)
0: 						throw utfFormatException();
1: 
0: 					if ((char2 & 0xC0) != 0x80)
0: 						throw utfFormatException();		  
0: 					finalChar = (((c & 0x1F) << 6) | (char2 & 0x3F));
0: 					break;
0: 					}
1: 
0: 				case 14:
0: 					{
0: 					// 1110 xxxx  10xx xxxx  10xx xxxx
0: 					utfCount += 3;
0: 					int char2 = in.read();
0: 					int char3 = in.read();
0: 					if (char2 == -1 || char3 == -1)
0: 						throw utfFormatException();
1: 
0: 					if ((c == 0xE0) && (char2 == 0) && (char3 == 0))
0: 					{
0: 						if (utfLen == 0) {
0: 							// we reached the end of a long string,
0: 							// that was terminated with
0: 							// (11100000, 00000000, 00000000)
0: 							closeIn();
0: 							break readChars;
0: 						}
0: 						throw utfFormatException();
0: 					}
1: 
0: 					if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80))
0: 						throw utfFormatException();	
1: 
0: 					finalChar = (((c & 0x0F) << 12) |
0: 							   ((char2 & 0x3F) << 6) |
0: 							   ((char3 & 0x3F) << 0));
0: 					}
0: 					break;
1: 
0: 				default:
0: 					// 10xx xxxx,  1111 xxxx
0: 					throw utfFormatException();		  
0: 			}
1: 
0: 			buffer[charactersInBuffer++] = (char) finalChar;
0: 			readerCharCount++;
0: 		}
0: 		if (utfLen != 0 && utfCount > utfLen) 
0: 			throw utfFormatException("utfCount " + utfCount + " utfLen " + utfLen);		  
1: 
0: 		if (charactersInBuffer != 0)
0: 			return false;
1: 
0: 		closeIn();
0: 		return true;
0: 		} finally {
0: 			parent.restoreContextStack();
0: 		}
0: 		} catch (SQLException sqle) {
0: 			throw new IOException(sqle.getSQLState() + ":" + sqle.getMessage());
0: 		}
0: 	}
1: 
1: 
0: 	// this method came from java.io.DataInputStream
0:     private final int readUnsignedShort() throws IOException {
0: 		int ch1 = in.read();
0: 		int ch2 = in.read();
0: 		if ((ch1 | ch2) < 0)
0: 			throw new EOFException();
1: 
0: 		return (ch1 << 8) + (ch2 << 0);
0: 	}
0: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
0: 	** Methods just for Derby's JDBC driver
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:88a3cb9
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Tomohito Nakayama
-------------------------------------------------------------------------------
commit:da10c02
/////////////////////////////////////////////////////////////////////////
0: */
/////////////////////////////////////////////////////////////////////////
0: 	public void close()
/////////////////////////////////////////////////////////////////////////
0: 	private void closeIn() {
0: 			} catch (IOException ioe) {
0: 	private IOException utfFormatException(String s) {
0: 	private IOException utfFormatException() {
commit:ce0c6c4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.Resetable;
0: import org.apache.derby.iapi.error.StandardException;
0:     
0:  *
0:  * If source InputStream of this class is Resetable, close method of this class reset the source instead of close it,
0:  * because the source InputStream can be shared.
0:  *
0:  */
/////////////////////////////////////////////////////////////////////////
0: 	public void close() throws IOException
/////////////////////////////////////////////////////////////////////////
0: 	private void closeIn() throws IOException {
0: 			    
0: 			    if(in instanceof Resetable){
0: 				((Resetable) in).resetStream();
0: 				
0: 			    }else{
0: 			    }
0: 			    
0: 			} catch (StandardException e) {
0: 			    e.printStackTrace();
0: 			    throw new IOException(e.getMessage());
0: 			    
0: 	private IOException utfFormatException(String s) throws IOException {
0: 	private IOException utfFormatException() throws IOException {
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.jdbc;
0: 
0: import java.io.InputStream;
0: import java.io.Reader;
0: import java.io.IOException;
0: import java.io.UTFDataFormatException;
0: import java.io.EOFException;
0: import java.sql.SQLException;
0: 
0: /**
0: */
0: public final class UTF8Reader extends Reader
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
0: 
0: 	private InputStream in;
0: 	private final long         utfLen;	// bytes
0: 	private long        utfCount;		// bytes
0: 	private long		readerCharCount; // characters
0: 	private long		maxFieldSize;	// characeters
0: 
0: 	private char[]		buffer = new char[8 * 1024];
0: 	private int			charactersInBuffer;	// within buffer
0: 	private int			readPositionInBuffer;
0: 
0: 	private boolean		noMoreReads;
0: 
0:     // maintain a reference to the parent object so that it can't get 
0:     // garbage collected until we are done with the stream.
0:     private ConnectionChild      parent;
0: 
0: 	public UTF8Reader(
0:     InputStream in,
0: 	long maxFieldSize,
0:     ConnectionChild      parent,
0: 	Object synchronization) 
0:         throws IOException
0: 	{
0: 		super(synchronization);
0: 
0: 		this.in     = in;
0: 		this.maxFieldSize = maxFieldSize;
0: 		this.parent = parent;
0: 
0: 		synchronized (lock) {
0: 			this.utfLen = readUnsignedShort();
0: 		}
0: 	}
0: 
0: 	/*
0: 	** Reader implemention.
0: 	*/
0: 	public int read() throws IOException
0: 	{
0: 		synchronized (lock) {
0: 
0: 			// check if closed..
0: 			if (noMoreReads)
0: 				throw new IOException();
0: 
0: 			if (readPositionInBuffer >= charactersInBuffer) {
0: 				if (fillBuffer()) {
0: 					return -1;
0: 				}
0: 				readPositionInBuffer = 0;
0: 			}
0: 
0: 			return buffer[readPositionInBuffer++];
0: 		}
0: 	}
0: 
0: 	public int read(char[] cbuf, int off, int len) throws IOException
0: 	{
0: 		synchronized (lock) {
0: 			// check if closed..
0: 			if (noMoreReads)
0: 				throw new IOException();
0: 
0: 			if (readPositionInBuffer >= charactersInBuffer) {
0: 				if (fillBuffer()) {
0: 					return -1;
0: 				}
0: 				readPositionInBuffer = 0;
0: 			}
0: 
0: 			int remainingInBuffer = charactersInBuffer - readPositionInBuffer;
0: 
0: 			if (len > remainingInBuffer)
0: 				len = remainingInBuffer;
0: 
0: 			System.arraycopy(buffer, readPositionInBuffer, cbuf, off, len);
0: 			readPositionInBuffer += len;
0: 
0: 			return len;
0: 		}
0: 	}
0: 
0: 	public long skip(long len) throws IOException {
0: 		synchronized (lock) {
0: 			// check if closed..
0: 			if (noMoreReads)
0: 				throw new IOException();
0: 
0: 			if (readPositionInBuffer >= charactersInBuffer) {
0: 				// do somthing
0: 				if (fillBuffer()) {
0: 					return -1;
0: 				}
0: 				readPositionInBuffer = 0;
0: 			}
0: 
0: 			int remainingInBuffer = charactersInBuffer - readPositionInBuffer;
0: 
0: 			if (len > remainingInBuffer)
0: 				len = remainingInBuffer;
0: 
0: 			readPositionInBuffer += len;
0: 
0: 			return len;
0: 		}
0: 
0: 	}
0: 
0: 	public void close()
0: 	{
0: 		synchronized (lock) {
0: 			closeIn();
0: 			parent  = null;
0: 			noMoreReads = true;
0: 		}
0: 	}
0: 
0: 	/*
0: 	** Methods just for Cloudscape's JDBC driver
0: 	*/
0: 
0: 	public int readInto(StringBuffer sb, int len) throws IOException {
0: 
0: 		synchronized (lock) {
0: 			if (readPositionInBuffer >= charactersInBuffer) {
0: 				if (fillBuffer()) {
0: 					return -1;
0: 				}
0: 				readPositionInBuffer = 0;
0: 			}
0: 
0: 			int remainingInBuffer = charactersInBuffer - readPositionInBuffer;
0: 
0: 			if (len > remainingInBuffer)
0: 				len = remainingInBuffer;
0: 			sb.append(buffer, readPositionInBuffer, len);
0: 
0: 			readPositionInBuffer += len;
0: 
0: 			return len;
0: 		}
0: 	}
0: 	int readAsciiInto(byte[] abuf, int off, int len) throws IOException {
0: 
0: 		synchronized (lock) {
0: 			if (readPositionInBuffer >= charactersInBuffer) {
0: 				if (fillBuffer()) {
0: 					return -1;
0: 				}
0: 				readPositionInBuffer = 0;
0: 			}
0: 
0: 			int remainingInBuffer = charactersInBuffer - readPositionInBuffer;
0: 
0: 			if (len > remainingInBuffer)
0: 				len = remainingInBuffer;
0: 
0: 			char[] lbuffer = buffer;
0: 			for (int i = 0; i < len; i++) {
0: 				char c = lbuffer[readPositionInBuffer + i];
0: 				byte cb;
0: 				if (c <= 255)
0: 					cb = (byte) c;
0: 				else
0: 					cb = (byte) '?'; // Question mark - out of range character.
0: 
0: 				abuf[off + i] = cb;
0: 			}
0: 
0: 			readPositionInBuffer += len;
0: 
0: 			return len;
0: 		}
0: 	}
0: 
0: 	/*
0: 	** internal implementation
0: 	*/
0: 
0: 
0: 	private void closeIn() {
0: 		if (in != null) {
0: 			try {
0: 				in.close();
0: 			} catch (IOException ioe) {
0: 			} finally {
0: 				in = null;
0: 			}
0: 		}
0: 	}
0: 	private IOException utfFormatException(String s) {
0: 		noMoreReads = true;
0: 		closeIn();
0: 		return new UTFDataFormatException(s);
0: 	}
0: 
0: 	private IOException utfFormatException() {
0: 		noMoreReads = true;
0: 		closeIn();
0: 		return new UTFDataFormatException();
0: 	}
0: 
0: 	/**
0: 		Fill the buffer, return true if eof has been reached.
0: 	*/
0: 	private boolean fillBuffer() throws IOException
0: 	{
0: 		if (in == null)
0: 			return true;
0: 
0: 		charactersInBuffer = 0;
0: 
0: 		try {
0: 		try {
0: 		
0: 			parent.setupContextStack();
0: 
0: readChars:
0: 		while (
0: 				(charactersInBuffer < buffer.length) &&
0: 			    ((utfCount < utfLen) || (utfLen == 0)) &&
0: 				((maxFieldSize == 0) || (readerCharCount < maxFieldSize))
0: 			  )
0: 		{
0: 			int c = in.read();
0: 			if (c == -1) {
0: 				if (utfLen == 0) {
0: 					closeIn();
0: 					break readChars;
0: 				}
0: 				throw utfFormatException();
0: 			}
0: 
0: 			int finalChar;
0: 			switch (c >> 4) { 
0: 				case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
0: 					// 0xxxxxxx
0: 					utfCount++;
0: 					finalChar = c;
0: 					break;
0: 
0: 				case 12: case 13:
0: 					{
0: 					// 110x xxxx   10xx xxxx
0: 					utfCount += 2;
0: 					int char2 = in.read();
0: 					if (char2 == -1)
0: 						throw utfFormatException();
0: 
0: 					if ((char2 & 0xC0) != 0x80)
0: 						throw utfFormatException();		  
0: 					finalChar = (((c & 0x1F) << 6) | (char2 & 0x3F));
0: 					break;
0: 					}
0: 
0: 				case 14:
0: 					{
0: 					// 1110 xxxx  10xx xxxx  10xx xxxx
0: 					utfCount += 3;
0: 					int char2 = in.read();
0: 					int char3 = in.read();
0: 					if (char2 == -1 || char3 == -1)
0: 						throw utfFormatException();
0: 
0: 					if ((c == 0xE0) && (char2 == 0) && (char3 == 0))
0: 					{
0: 						if (utfLen == 0) {
0: 							// we reached the end of a long string,
0: 							// that was terminated with
0: 							// (11100000, 00000000, 00000000)
0: 							closeIn();
0: 							break readChars;
0: 						}
0: 						throw utfFormatException();
0: 					}
0: 
0: 					if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80))
0: 						throw utfFormatException();	
0: 
0: 					finalChar = (((c & 0x0F) << 12) |
0: 							   ((char2 & 0x3F) << 6) |
0: 							   ((char3 & 0x3F) << 0));
0: 					}
0: 					break;
0: 
0: 				default:
0: 					// 10xx xxxx,  1111 xxxx
0: 					throw utfFormatException();		  
0: 			}
0: 
0: 			buffer[charactersInBuffer++] = (char) finalChar;
0: 			readerCharCount++;
0: 		}
0: 		if (utfLen != 0 && utfCount > utfLen) 
0: 			throw utfFormatException("utfCount " + utfCount + " utfLen " + utfLen);		  
0: 
0: 		if (charactersInBuffer != 0)
0: 			return false;
0: 
0: 		closeIn();
0: 		return true;
0: 		} finally {
0: 			parent.restoreContextStack();
0: 		}
0: 		} catch (SQLException sqle) {
0: 			throw new IOException(sqle.getSQLState() + ":" + sqle.getMessage());
0: 		}
0: 	}
0: 
0: 
0: 	// this method came from java.io.DataInputStream
0:     private final int readUnsignedShort() throws IOException {
0: 		int ch1 = in.read();
0: 		int ch2 = in.read();
0: 		if ((ch1 | ch2) < 0)
0: 			throw new EOFException();
0: 
0: 		return (ch1 << 8) + (ch2 << 0);
0: 	}
0: }
============================================================================