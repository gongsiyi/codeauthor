1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.compile.JoinStrategy
1:7ecc1f2: 
1:d4580ab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:d4580ab:    contributor license agreements.  See the NOTICE file distributed with
1:d4580ab:    this work for additional information regarding copyright ownership.
1:d4580ab:    The ASF licenses this file to you under the Apache License, Version 2.0
1:d4580ab:    (the "License"); you may not use this file except in compliance with
1:d4580ab:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
3:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.sql.compile;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
3:eac0369: /**
1:eac0369:  * A JoinStrategy represents a strategy like nested loop, hash join,
1:eac0369:  * merge join, etc.  It tells the optimizer whether the strategy is
1:eac0369:  * feasible in a given situation, how much the strategy costs, whether
1:eac0369:  * the strategy requires the data from the source result sets to be ordered,
1:eac0369:  * etc.
1:eac0369:  */
1:eac0369: 
1:eac0369: public interface JoinStrategy {
1:eac0369: 	/**
1:eac0369: 	 * Is this join strategy feasible under the circumstances?
1:eac0369: 	 *
1:eac0369: 	 * @param innerTable	The inner table of the join
1:eac0369: 	 * @param predList		The predicateList for the join
1:eac0369: 	 * @param optimizer		The optimizer to use
1:eac0369: 	 *
1:eac0369: 	 * @return	true means the strategy is feasible, false means it isn't
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	boolean feasible(Optimizable innerTable,
1:eac0369: 					 OptimizablePredicateList predList,
1:eac0369: 					 Optimizer optimizer
1:eac0369: 					 )
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is it OK to use bulk fetch with this join strategy?
1:eac0369: 	 */
1:eac0369: 	boolean bulkFetchOK();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Should we just ignore bulk fetch with this join strategy?
1:eac0369: 	 */
1:eac0369: 	boolean ignoreBulkFetch();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns true if the base cost of scanning the conglomerate should be
1:eac0369: 	 * multiplied by the number of outer rows.
1:eac0369: 	 */
1:eac0369: 	boolean multiplyBaseCostByOuterRows();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the base predicates for this join strategy.  The base predicates
1:eac0369: 	 * are the ones that can be used while scanning the table.  For some
1:eac0369: 	 * join strategies (for example, nested loop), all predicates are base
1:eac0369: 	 * predicates.  For other join strategies (for example, hash join),
1:eac0369: 	 * the base predicates are those that involve comparisons with constant
1:eac0369: 	 * expressions.
1:eac0369: 	 *
1:eac0369: 	 * Also, order the base predicates according to the order in the
1:eac0369: 	 * proposed conglomerate descriptor for the inner table.
1:eac0369: 	 *
1:eac0369: 	 * @param predList	The predicate list to pull from.
1:eac0369: 	 * @param basePredicates	The list to put the base predicates in.
1:eac0369: 	 * @param innerTable	The inner table of the join
1:eac0369: 	 *
1:eac0369: 	 * @return	The base predicate list.  If no predicates are pulled,
1:eac0369: 	 *			it may return the source predList without doing anything.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	OptimizablePredicateList getBasePredicates(
1:eac0369: 								OptimizablePredicateList predList,
1:eac0369: 								OptimizablePredicateList basePredicates,
1:eac0369: 								Optimizable innerTable)
1:eac0369: 						throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the extra selectivity of the non-base predicates (those that were
1:eac0369: 	 * left in the predicate list by getBasePredicates() that are not
1:eac0369: 	 * applied to the scan of the base conglomerate.
1:eac0369: 	 *
1:eac0369: 	 * NOTE: For some types of join strategy, it may not remove any predicates
1:eac0369: 	 * from the original predicate list.  The join strategy is expected to
1:eac0369: 	 * know when it does this, and to return 1.0 as the extra selectivity
1:eac0369: 	 * in these cases.
1:eac0369: 	 *
1:eac0369: 	 * @param innerTable	The inner table of the join.
1:eac0369: 	 * @param predList	The original predicate list that was passed to
1:eac0369: 	 *					getBasePredicates(), from which some base predicates
1:eac0369: 	 *					may have been pulled.
1:eac0369: 	 *
1:eac0369: 	 * @return	The extra selectivity due to non-base predicates
1:eac0369: 	 */
1:eac0369: 	double nonBasePredicateSelectivity(Optimizable innerTable,
1:d5bc20f: 										OptimizablePredicateList predList)
1:d5bc20f: 	throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Put back and base predicates that were removed from the list by
1:eac0369: 	 * getBasePredicates (see above).
1:eac0369: 	 *
1:eac0369: 	 * NOTE: Those join strategies that treat all predicates as base
1:eac0369: 	 *		 predicates may treat the get and put methods as no-ops.
1:eac0369: 	 *
1:eac0369: 	 * @param predList	The list of predicates to put the base predicates
1:eac0369: 	 *					back in.
1:eac0369: 	 * @param basePredicates	The base predicates to put back in the list.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void putBasePredicates(OptimizablePredicateList predList,
1:eac0369: 							OptimizablePredicateList basePredicates)
1:eac0369: 					throws StandardException;
1:eac0369: 	/**
1:eac0369: 	 * Get the estimated cost for the join.
1:eac0369: 	 *
1:eac0369: 	 * @param predList		The predicate list for the join
1:eac0369: 	 * @param innerTable	The inner table to join with
1:eac0369: 	 * @param cd			The conglomerate descriptor (if appropriate) to get
1:eac0369: 	 *						the cost of
1:eac0369: 	 * @param outerCost		The estimated cost of the part of the plan outer
1:eac0369: 	 *						to the inner table
1:eac0369: 	 * @param optimizer		The optimizer to use to help estimate the cost
1:eac0369: 	 * @param costEstimate	The estimated cost of doing a single scan of the
1:eac0369: 	 *						inner table, to be filled in with the cost of
1:eac0369: 	 *						doing the join.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void estimateCost(Optimizable innerTable,
1:eac0369: 						OptimizablePredicateList predList,
1:eac0369: 						ConglomerateDescriptor cd,
1:eac0369: 						CostEstimate outerCost,
1:eac0369: 						Optimizer optimizer,
1:eac0369: 						CostEstimate costEstimate)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:b223f72:     /**
1:b223f72:      * @param userSpecifiedCapacity
1:b223f72:      * @param maxMemoryPerTable maximum number of bytes per table
1:b223f72:      * @param perRowUsage number of bytes per row
1:b223f72:      *
1:b223f72:      * @return The maximum number of rows that can be handled by this join strategy
1:b223f72:      */
1:b223f72:     public int maxCapacity( int userSpecifiedCapacity,
1:b223f72:                             int maxMemoryPerTable,
1:b223f72:                             double perRowUsage);
1:b223f72:     
1:eac0369: 	/** Get the name of this join strategy */
1:eac0369: 	String getName();
1:eac0369: 
1:eac0369: 	/** Get the costing type, for use with StoreCostController.getScanCost */
1:eac0369: 	int scanCostType();
1:eac0369: 
1:b6cc9d7:     /** Get the operator symbol used to represent this join strategy in optimizer traces */
1:b6cc9d7:     String  getOperatorSymbol();
1:b6cc9d7: 
1:eac0369: 	/**
1:eac0369: 	 * Get the name of the result set method for base table scans
1:eac0369: 	 *
1:cbdc90c: 	 * @param bulkFetch True means bulk fetch is being done on the inner table
1:cbdc90c: 	 * @param multiprobe True means we are probing the inner table for rows
1:cbdc90c: 	 *  matching a specified list of values.
1:af1c18c:      * @param validatingCheckConstraint True of this is a special scan to
1:af1c18c:      *        validate a check constraint.
1:eac0369: 	 */
1:af1c18c:     String resultSetMethodName(
1:af1c18c:         boolean bulkFetch,
1:af1c18c:         boolean multiprobe,
1:af1c18c:         boolean validatingCheckConstraint);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the name of the join result set method for the join
1:eac0369: 	 */
1:eac0369: 	String joinResultSetMethodName();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the name of the join result set method for the half outerjoin
1:eac0369: 	 */
1:eac0369: 	String halfOuterJoinResultSetMethodName();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the appropriate arguments to the scan for this type of join.
1:eac0369: 	 *
1:eac0369: 	 * @param tc	The TransactionController
1:eac0369: 	 * @param mb	The method to generate the arguments in
1:eac0369: 	 * @param innerTable	The inner table of the join
1:eac0369: 	 * @param storeRestrictionList	The predicate list to be evaluated in the
1:eac0369: 	 *								store
1:eac0369: 	 * @param nonStoreRestrictionList	The predicate list to be evaluated
1:eac0369: 	 *									outside of the store
1:eac0369: 	 * @param acb	The expression class builder for the activation class
1:eac0369: 	 *				we're building
1:eac0369: 	 * @param bulkFetch	The amount of bulk fetch to do
1:959fef2:      * @param resultRowTemplate The saved object index of a result row template
1:eac0369: 	 * @param colRefItem	The item number of the column reference bit map
1:eac0369: 	 * @param lockMode		The lock mode to use when scanning the table
1:eac0369: 	 *						(see TransactionController).
1:eac0369: 	 * @param tableLocked	Whether or not the table is marked (in sys.systables)
1:eac0369: 	 *						as always using table locking
1:eac0369: 	 * @param isolationLevel		Isolation level specified (or not) for scans
1:6b50965: 	 * @param maxMemoryPerTable	Max memory per table
1:cbdc90c: 	 * @param genInListVals Whether or not we are going to generate IN-list
1:cbdc90c: 	 *  values with which to probe the inner table.
1:eac0369: 	 *
1:eac0369: 	 * @return	Count of the expressions pushed to use as the parameters to the
1:eac0369: 	 *			result set for the inner table
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	int getScanArgs(TransactionController tc,
1:eac0369: 							MethodBuilder mb,
1:eac0369: 							Optimizable innerTable,
1:eac0369: 							OptimizablePredicateList storeRestrictionList,
1:eac0369: 							OptimizablePredicateList nonStoreRestrictionList,
1:eac0369: 							ExpressionClassBuilderInterface acb,
1:eac0369: 							int bulkFetch,
1:959fef2: 							int resultRowTemplate,
1:eac0369: 							int colRefItem,
1:eac0369: 							int indexColItem,
1:eac0369: 							int lockMode,
1:eac0369: 							boolean tableLocked,
1:cbdc90c: 							int isolationLevel,
1:cbdc90c: 							int maxMemoryPerTable,
1:cbdc90c: 							boolean genInListVals
1:eac0369: 							)
1:eac0369: 					throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Divide up the predicates into different lists for different phases
1:eac0369: 	 * of the operation. When this method is called, all of the predicates
1:eac0369: 	 * will be in restrictionList.  The effect of this method is to
1:eac0369: 	 * remove all of the predicates from restrictionList except those that
1:eac0369: 	 * will be pushed down to the store as start/stop predicates or
1:eac0369: 	 * Qualifiers.  The remaining predicates will be put into
1:eac0369: 	 * nonBaseTableRestrictionList.
1:eac0369: 	 *
1:eac0369: 	 * All predicate lists will be ordered as necessary for use with
1:eac0369: 	 * the conglomerate.
1:eac0369: 	 *
1:eac0369: 	 * Some operations (like hash join) materialize results, and so
1:eac0369: 	 * require requalification of rows when doing a non-covering index
1:eac0369: 	 * scan.  The predicates to use for requalification are copied into
1:eac0369: 	 * baseTableRestrictionList.
1:eac0369: 	 *
1:eac0369: 	 * @param innerTable	The inner table of the join
1:eac0369: 	 * @param originalRestrictionList	Initially contains all predicates.
1:eac0369: 	 *									This method removes predicates from
1:eac0369: 	 *									this list and moves them to other
1:eac0369: 	 *									lists, as appropriate.
1:eac0369: 	 * @param storeRestrictionList	To be filled in with predicates to
1:eac0369: 	 *								be pushed down to store.
1:eac0369: 	 * @param nonStoreRestrictionList	To be filled in with predicates
1:eac0369: 	 *									that are not pushed down to the
1:eac0369: 	 *									store.
1:eac0369: 	 * @param requalificationRestrictionList	Copy of predicates used to
1:eac0369: 	 *											re-qualify rows, if necessary.
1:eac0369: 	 * @param dd			The DataDictionary
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void divideUpPredicateLists(
1:eac0369: 						Optimizable innerTable,
1:eac0369: 						OptimizablePredicateList originalRestrictionList,
1:eac0369: 						OptimizablePredicateList storeRestrictionList,
1:eac0369: 						OptimizablePredicateList nonStoreRestrictionList,
1:eac0369: 						OptimizablePredicateList requalificationRestrictionList,
1:eac0369: 						DataDictionary			 dd)
1:eac0369: 				throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this a form of hash join?
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not this strategy is a form
1:eac0369: 	 * of hash join.
1:eac0369: 	 */
1:eac0369: 	public boolean isHashJoin();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is materialization built in to the join strategy?
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not materialization is built in to the join strategy
1:eac0369: 	 */
1:eac0369: 	public boolean doesMaterialization();
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:      * @param validatingCheckConstraint True of this is a special scan to
1:      *        validate a check constraint.
1:     String resultSetMethodName(
1:         boolean bulkFetch,
1:         boolean multiprobe,
1:         boolean validatingCheckConstraint);
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:b6cc9d7
/////////////////////////////////////////////////////////////////////////
1:     /** Get the operator symbol used to represent this join strategy in optimizer traces */
1:     String  getOperatorSymbol();
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:959fef2
/////////////////////////////////////////////////////////////////////////
1:      * @param resultRowTemplate The saved object index of a result row template
/////////////////////////////////////////////////////////////////////////
1: 							int resultRowTemplate,
author:Army
-------------------------------------------------------------------------------
commit:cbdc90c
/////////////////////////////////////////////////////////////////////////
1: 	 * @param bulkFetch True means bulk fetch is being done on the inner table
1: 	 * @param multiprobe True means we are probing the inner table for rows
1: 	 *  matching a specified list of values.
0: 	String resultSetMethodName(boolean bulkFetch, boolean multiprobe);
/////////////////////////////////////////////////////////////////////////
1: 	 * @param genInListVals Whether or not we are going to generate IN-list
1: 	 *  values with which to probe the inner table.
/////////////////////////////////////////////////////////////////////////
1: 							int isolationLevel,
1: 							int maxMemoryPerTable,
1: 							boolean genInListVals
author:David Van Couvering
-------------------------------------------------------------------------------
commit:d4580ab
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param maxMemoryPerTable	Max memory per table
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
1: 										OptimizablePredicateList predList)
1: 	throws StandardException;
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b223f72
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @param userSpecifiedCapacity
1:      * @param maxMemoryPerTable maximum number of bytes per table
1:      * @param perRowUsage number of bytes per row
1:      *
1:      * @return The maximum number of rows that can be handled by this join strategy
1:      */
1:     public int maxCapacity( int userSpecifiedCapacity,
1:                             int maxMemoryPerTable,
1:                             double perRowUsage);
1:     
/////////////////////////////////////////////////////////////////////////
0:                             int isolationLevel,
0:                             int maxMemoryPerTable
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.compile.JoinStrategy
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.compile;
1: 
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: 
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: /**
1:  * A JoinStrategy represents a strategy like nested loop, hash join,
1:  * merge join, etc.  It tells the optimizer whether the strategy is
1:  * feasible in a given situation, how much the strategy costs, whether
1:  * the strategy requires the data from the source result sets to be ordered,
1:  * etc.
1:  */
1: 
1: public interface JoinStrategy {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	/**
1: 	 * Is this join strategy feasible under the circumstances?
1: 	 *
1: 	 * @param innerTable	The inner table of the join
1: 	 * @param predList		The predicateList for the join
1: 	 * @param optimizer		The optimizer to use
1: 	 *
1: 	 * @return	true means the strategy is feasible, false means it isn't
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	boolean feasible(Optimizable innerTable,
1: 					 OptimizablePredicateList predList,
1: 					 Optimizer optimizer
1: 					 )
1: 			throws StandardException;
1: 
1: 	/**
1: 	 * Is it OK to use bulk fetch with this join strategy?
1: 	 */
1: 	boolean bulkFetchOK();
1: 
1: 	/**
1: 	 * Should we just ignore bulk fetch with this join strategy?
1: 	 */
1: 	boolean ignoreBulkFetch();
1: 
1: 	/**
1: 	 * Returns true if the base cost of scanning the conglomerate should be
1: 	 * multiplied by the number of outer rows.
1: 	 */
1: 	boolean multiplyBaseCostByOuterRows();
1: 
1: 	/**
1: 	 * Get the base predicates for this join strategy.  The base predicates
1: 	 * are the ones that can be used while scanning the table.  For some
1: 	 * join strategies (for example, nested loop), all predicates are base
1: 	 * predicates.  For other join strategies (for example, hash join),
1: 	 * the base predicates are those that involve comparisons with constant
1: 	 * expressions.
1: 	 *
1: 	 * Also, order the base predicates according to the order in the
1: 	 * proposed conglomerate descriptor for the inner table.
1: 	 *
1: 	 * @param predList	The predicate list to pull from.
1: 	 * @param basePredicates	The list to put the base predicates in.
1: 	 * @param innerTable	The inner table of the join
1: 	 *
1: 	 * @return	The base predicate list.  If no predicates are pulled,
1: 	 *			it may return the source predList without doing anything.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	OptimizablePredicateList getBasePredicates(
1: 								OptimizablePredicateList predList,
1: 								OptimizablePredicateList basePredicates,
1: 								Optimizable innerTable)
1: 						throws StandardException;
1: 
1: 	/**
1: 	 * Get the extra selectivity of the non-base predicates (those that were
1: 	 * left in the predicate list by getBasePredicates() that are not
1: 	 * applied to the scan of the base conglomerate.
1: 	 *
1: 	 * NOTE: For some types of join strategy, it may not remove any predicates
1: 	 * from the original predicate list.  The join strategy is expected to
1: 	 * know when it does this, and to return 1.0 as the extra selectivity
1: 	 * in these cases.
1: 	 *
1: 	 * @param innerTable	The inner table of the join.
1: 	 * @param predList	The original predicate list that was passed to
1: 	 *					getBasePredicates(), from which some base predicates
1: 	 *					may have been pulled.
1: 	 *
1: 	 * @return	The extra selectivity due to non-base predicates
1: 	 */
1: 	double nonBasePredicateSelectivity(Optimizable innerTable,
0: 										OptimizablePredicateList predList);
1: 
1: 	/**
1: 	 * Put back and base predicates that were removed from the list by
1: 	 * getBasePredicates (see above).
1: 	 *
1: 	 * NOTE: Those join strategies that treat all predicates as base
1: 	 *		 predicates may treat the get and put methods as no-ops.
1: 	 *
1: 	 * @param predList	The list of predicates to put the base predicates
1: 	 *					back in.
1: 	 * @param basePredicates	The base predicates to put back in the list.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void putBasePredicates(OptimizablePredicateList predList,
1: 							OptimizablePredicateList basePredicates)
1: 					throws StandardException;
1: 	/**
1: 	 * Get the estimated cost for the join.
1: 	 *
1: 	 * @param predList		The predicate list for the join
1: 	 * @param innerTable	The inner table to join with
1: 	 * @param cd			The conglomerate descriptor (if appropriate) to get
1: 	 *						the cost of
1: 	 * @param outerCost		The estimated cost of the part of the plan outer
1: 	 *						to the inner table
1: 	 * @param optimizer		The optimizer to use to help estimate the cost
1: 	 * @param costEstimate	The estimated cost of doing a single scan of the
1: 	 *						inner table, to be filled in with the cost of
1: 	 *						doing the join.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void estimateCost(Optimizable innerTable,
1: 						OptimizablePredicateList predList,
1: 						ConglomerateDescriptor cd,
1: 						CostEstimate outerCost,
1: 						Optimizer optimizer,
1: 						CostEstimate costEstimate)
1: 		throws StandardException;
1: 
1: 	/**
0: 	 * Get the estimated memory usage for this join strategy, given
0: 	 * the number of rows and the memory usage per row.
1: 	 */
0: 	double memoryUsage(double memoryPerRow, double rowCount);
1: 
1: 	/** Get the name of this join strategy */
1: 	String getName();
1: 
1: 	/** Get the costing type, for use with StoreCostController.getScanCost */
1: 	int scanCostType();
1: 
1: 	/**
1: 	 * Get the name of the result set method for base table scans
1: 	 *
0: 	 * @param bulkFetch		True means bulk fetch is being done on the inner
0: 	 *						table
1: 	 */
0: 	String resultSetMethodName(boolean bulkFetch);
1: 
1: 	/**
1: 	 * Get the name of the join result set method for the join
1: 	 */
1: 	String joinResultSetMethodName();
1: 
1: 	/**
1: 	 * Get the name of the join result set method for the half outerjoin
1: 	 */
1: 	String halfOuterJoinResultSetMethodName();
1: 
1: 	/**
1: 	 * Get the appropriate arguments to the scan for this type of join.
1: 	 *
1: 	 * @param tc	The TransactionController
1: 	 * @param mb	The method to generate the arguments in
1: 	 * @param innerTable	The inner table of the join
1: 	 * @param storeRestrictionList	The predicate list to be evaluated in the
1: 	 *								store
1: 	 * @param nonStoreRestrictionList	The predicate list to be evaluated
1: 	 *									outside of the store
1: 	 * @param acb	The expression class builder for the activation class
1: 	 *				we're building
1: 	 * @param bulkFetch	The amount of bulk fetch to do
0: 	 * @param resultRowAllocator	A completed method to allocate the result row
1: 	 * @param colRefItem	The item number of the column reference bit map
1: 	 * @param lockMode		The lock mode to use when scanning the table
1: 	 *						(see TransactionController).
1: 	 * @param tableLocked	Whether or not the table is marked (in sys.systables)
1: 	 *						as always using table locking
1: 	 * @param isolationLevel		Isolation level specified (or not) for scans
0: 	 * @param closeMethodArgument	An Expression that evaluates to a method
0: 	 *								to call when the result set is closed.
1: 	 *
1: 	 * @return	Count of the expressions pushed to use as the parameters to the
1: 	 *			result set for the inner table
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	int getScanArgs(TransactionController tc,
1: 							MethodBuilder mb,
1: 							Optimizable innerTable,
1: 							OptimizablePredicateList storeRestrictionList,
1: 							OptimizablePredicateList nonStoreRestrictionList,
1: 							ExpressionClassBuilderInterface acb,
1: 							int bulkFetch,
0: 							MethodBuilder resultRowAllocator,
1: 							int colRefItem,
1: 							int indexColItem,
1: 							int lockMode,
1: 							boolean tableLocked,
0: 							int isolationLevel
1: 							)
1: 					throws StandardException;
1: 
1: 	/**
1: 	 * Divide up the predicates into different lists for different phases
1: 	 * of the operation. When this method is called, all of the predicates
1: 	 * will be in restrictionList.  The effect of this method is to
1: 	 * remove all of the predicates from restrictionList except those that
1: 	 * will be pushed down to the store as start/stop predicates or
1: 	 * Qualifiers.  The remaining predicates will be put into
1: 	 * nonBaseTableRestrictionList.
1: 	 *
1: 	 * All predicate lists will be ordered as necessary for use with
1: 	 * the conglomerate.
1: 	 *
1: 	 * Some operations (like hash join) materialize results, and so
1: 	 * require requalification of rows when doing a non-covering index
1: 	 * scan.  The predicates to use for requalification are copied into
1: 	 * baseTableRestrictionList.
1: 	 *
1: 	 * @param innerTable	The inner table of the join
1: 	 * @param originalRestrictionList	Initially contains all predicates.
1: 	 *									This method removes predicates from
1: 	 *									this list and moves them to other
1: 	 *									lists, as appropriate.
1: 	 * @param storeRestrictionList	To be filled in with predicates to
1: 	 *								be pushed down to store.
1: 	 * @param nonStoreRestrictionList	To be filled in with predicates
1: 	 *									that are not pushed down to the
1: 	 *									store.
1: 	 * @param requalificationRestrictionList	Copy of predicates used to
1: 	 *											re-qualify rows, if necessary.
1: 	 * @param dd			The DataDictionary
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void divideUpPredicateLists(
1: 						Optimizable innerTable,
1: 						OptimizablePredicateList originalRestrictionList,
1: 						OptimizablePredicateList storeRestrictionList,
1: 						OptimizablePredicateList nonStoreRestrictionList,
1: 						OptimizablePredicateList requalificationRestrictionList,
1: 						DataDictionary			 dd)
1: 				throws StandardException;
1: 
1: 	/**
1: 	 * Is this a form of hash join?
1: 	 *
1: 	 * @return Whether or not this strategy is a form
1: 	 * of hash join.
1: 	 */
1: 	public boolean isHashJoin();
1: 
1: 	/**
1: 	 * Is materialization built in to the join strategy?
1: 	 *
1: 	 * @return Whether or not materialization is built in to the join strategy
1: 	 */
1: 	public boolean doesMaterialization();
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: /**
0:  * A JoinStrategy represents a strategy like nested loop, hash join,
0:  * merge join, etc.  It tells the optimizer whether the strategy is
0:  * feasible in a given situation, how much the strategy costs, whether
0:  * the strategy requires the data from the source result sets to be ordered,
0:  * etc.
0:  */
0: 
0: public interface JoinStrategy {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	/**
0: 	 * Is this join strategy feasible under the circumstances?
0: 	 *
0: 	 * @param innerTable	The inner table of the join
0: 	 * @param predList		The predicateList for the join
0: 	 * @param optimizer		The optimizer to use
0: 	 *
0: 	 * @return	true means the strategy is feasible, false means it isn't
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	boolean feasible(Optimizable innerTable,
0: 					 OptimizablePredicateList predList,
0: 					 Optimizer optimizer
0: 					 )
0: 			throws StandardException;
0: 
0: 	/**
0: 	 * Is it OK to use bulk fetch with this join strategy?
0: 	 */
0: 	boolean bulkFetchOK();
0: 
0: 	/**
0: 	 * Should we just ignore bulk fetch with this join strategy?
0: 	 */
0: 	boolean ignoreBulkFetch();
0: 
0: 	/**
0: 	 * Returns true if the base cost of scanning the conglomerate should be
0: 	 * multiplied by the number of outer rows.
0: 	 */
0: 	boolean multiplyBaseCostByOuterRows();
0: 
0: 	/**
0: 	 * Get the base predicates for this join strategy.  The base predicates
0: 	 * are the ones that can be used while scanning the table.  For some
0: 	 * join strategies (for example, nested loop), all predicates are base
0: 	 * predicates.  For other join strategies (for example, hash join),
0: 	 * the base predicates are those that involve comparisons with constant
0: 	 * expressions.
0: 	 *
0: 	 * Also, order the base predicates according to the order in the
0: 	 * proposed conglomerate descriptor for the inner table.
0: 	 *
0: 	 * @param predList	The predicate list to pull from.
0: 	 * @param basePredicates	The list to put the base predicates in.
0: 	 * @param innerTable	The inner table of the join
0: 	 *
0: 	 * @return	The base predicate list.  If no predicates are pulled,
0: 	 *			it may return the source predList without doing anything.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	OptimizablePredicateList getBasePredicates(
0: 								OptimizablePredicateList predList,
0: 								OptimizablePredicateList basePredicates,
0: 								Optimizable innerTable)
0: 						throws StandardException;
0: 
0: 	/**
0: 	 * Get the extra selectivity of the non-base predicates (those that were
0: 	 * left in the predicate list by getBasePredicates() that are not
0: 	 * applied to the scan of the base conglomerate.
0: 	 *
0: 	 * NOTE: For some types of join strategy, it may not remove any predicates
0: 	 * from the original predicate list.  The join strategy is expected to
0: 	 * know when it does this, and to return 1.0 as the extra selectivity
0: 	 * in these cases.
0: 	 *
0: 	 * @param innerTable	The inner table of the join.
0: 	 * @param predList	The original predicate list that was passed to
0: 	 *					getBasePredicates(), from which some base predicates
0: 	 *					may have been pulled.
0: 	 *
0: 	 * @return	The extra selectivity due to non-base predicates
0: 	 */
0: 	double nonBasePredicateSelectivity(Optimizable innerTable,
0: 										OptimizablePredicateList predList);
0: 
0: 	/**
0: 	 * Put back and base predicates that were removed from the list by
0: 	 * getBasePredicates (see above).
0: 	 *
0: 	 * NOTE: Those join strategies that treat all predicates as base
0: 	 *		 predicates may treat the get and put methods as no-ops.
0: 	 *
0: 	 * @param predList	The list of predicates to put the base predicates
0: 	 *					back in.
0: 	 * @param basePredicates	The base predicates to put back in the list.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void putBasePredicates(OptimizablePredicateList predList,
0: 							OptimizablePredicateList basePredicates)
0: 					throws StandardException;
0: 	/**
0: 	 * Get the estimated cost for the join.
0: 	 *
0: 	 * @param predList		The predicate list for the join
0: 	 * @param innerTable	The inner table to join with
0: 	 * @param cd			The conglomerate descriptor (if appropriate) to get
0: 	 *						the cost of
0: 	 * @param outerCost		The estimated cost of the part of the plan outer
0: 	 *						to the inner table
0: 	 * @param optimizer		The optimizer to use to help estimate the cost
0: 	 * @param costEstimate	The estimated cost of doing a single scan of the
0: 	 *						inner table, to be filled in with the cost of
0: 	 *						doing the join.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void estimateCost(Optimizable innerTable,
0: 						OptimizablePredicateList predList,
0: 						ConglomerateDescriptor cd,
0: 						CostEstimate outerCost,
0: 						Optimizer optimizer,
0: 						CostEstimate costEstimate)
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * Get the estimated memory usage for this join strategy, given
0: 	 * the number of rows and the memory usage per row.
0: 	 */
0: 	double memoryUsage(double memoryPerRow, double rowCount);
0: 
0: 	/** Get the name of this join strategy */
0: 	String getName();
0: 
0: 	/** Get the costing type, for use with StoreCostController.getScanCost */
0: 	int scanCostType();
0: 
0: 	/**
0: 	 * Get the name of the result set method for base table scans
0: 	 *
0: 	 * @param bulkFetch		True means bulk fetch is being done on the inner
0: 	 *						table
0: 	 */
0: 	String resultSetMethodName(boolean bulkFetch);
0: 
0: 	/**
0: 	 * Get the name of the join result set method for the join
0: 	 */
0: 	String joinResultSetMethodName();
0: 
0: 	/**
0: 	 * Get the name of the join result set method for the half outerjoin
0: 	 */
0: 	String halfOuterJoinResultSetMethodName();
0: 
0: 	/**
0: 	 * Get the appropriate arguments to the scan for this type of join.
0: 	 *
0: 	 * @param tc	The TransactionController
0: 	 * @param mb	The method to generate the arguments in
0: 	 * @param innerTable	The inner table of the join
0: 	 * @param storeRestrictionList	The predicate list to be evaluated in the
0: 	 *								store
0: 	 * @param nonStoreRestrictionList	The predicate list to be evaluated
0: 	 *									outside of the store
0: 	 * @param acb	The expression class builder for the activation class
0: 	 *				we're building
0: 	 * @param bulkFetch	The amount of bulk fetch to do
0: 	 * @param resultRowAllocator	A completed method to allocate the result row
0: 	 * @param colRefItem	The item number of the column reference bit map
0: 	 * @param lockMode		The lock mode to use when scanning the table
0: 	 *						(see TransactionController).
0: 	 * @param tableLocked	Whether or not the table is marked (in sys.systables)
0: 	 *						as always using table locking
0: 	 * @param isolationLevel		Isolation level specified (or not) for scans
0: 	 * @param closeMethodArgument	An Expression that evaluates to a method
0: 	 *								to call when the result set is closed.
0: 	 *
0: 	 * @return	Count of the expressions pushed to use as the parameters to the
0: 	 *			result set for the inner table
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	int getScanArgs(TransactionController tc,
0: 							MethodBuilder mb,
0: 							Optimizable innerTable,
0: 							OptimizablePredicateList storeRestrictionList,
0: 							OptimizablePredicateList nonStoreRestrictionList,
0: 							ExpressionClassBuilderInterface acb,
0: 							int bulkFetch,
0: 							MethodBuilder resultRowAllocator,
0: 							int colRefItem,
0: 							int indexColItem,
0: 							int lockMode,
0: 							boolean tableLocked,
0: 							int isolationLevel
0: 							)
0: 					throws StandardException;
0: 
0: 	/**
0: 	 * Divide up the predicates into different lists for different phases
0: 	 * of the operation. When this method is called, all of the predicates
0: 	 * will be in restrictionList.  The effect of this method is to
0: 	 * remove all of the predicates from restrictionList except those that
0: 	 * will be pushed down to the store as start/stop predicates or
0: 	 * Qualifiers.  The remaining predicates will be put into
0: 	 * nonBaseTableRestrictionList.
0: 	 *
0: 	 * All predicate lists will be ordered as necessary for use with
0: 	 * the conglomerate.
0: 	 *
0: 	 * Some operations (like hash join) materialize results, and so
0: 	 * require requalification of rows when doing a non-covering index
0: 	 * scan.  The predicates to use for requalification are copied into
0: 	 * baseTableRestrictionList.
0: 	 *
0: 	 * @param innerTable	The inner table of the join
0: 	 * @param originalRestrictionList	Initially contains all predicates.
0: 	 *									This method removes predicates from
0: 	 *									this list and moves them to other
0: 	 *									lists, as appropriate.
0: 	 * @param storeRestrictionList	To be filled in with predicates to
0: 	 *								be pushed down to store.
0: 	 * @param nonStoreRestrictionList	To be filled in with predicates
0: 	 *									that are not pushed down to the
0: 	 *									store.
0: 	 * @param requalificationRestrictionList	Copy of predicates used to
0: 	 *											re-qualify rows, if necessary.
0: 	 * @param dd			The DataDictionary
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void divideUpPredicateLists(
0: 						Optimizable innerTable,
0: 						OptimizablePredicateList originalRestrictionList,
0: 						OptimizablePredicateList storeRestrictionList,
0: 						OptimizablePredicateList nonStoreRestrictionList,
0: 						OptimizablePredicateList requalificationRestrictionList,
0: 						DataDictionary			 dd)
0: 				throws StandardException;
0: 
0: 	/**
0: 	 * Is this a form of hash join?
0: 	 *
0: 	 * @return Whether or not this strategy is a form
0: 	 * of hash join.
0: 	 */
0: 	public boolean isHashJoin();
0: 
0: 	/**
0: 	 * Is materialization built in to the join strategy?
0: 	 *
0: 	 * @return Whether or not materialization is built in to the join strategy
0: 	 */
0: 	public boolean doesMaterialization();
0: }
============================================================================