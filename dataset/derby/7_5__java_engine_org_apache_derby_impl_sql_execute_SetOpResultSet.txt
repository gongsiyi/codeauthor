1:aaea357: /*
3:aaea357: 
1:aaea357:    Derby - Class org.apache.derby.impl.sql.execute.SetOpResultSet
1:aaea357: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:aaea357: 
1:aaea357:       http://www.apache.org/licenses/LICENSE-2.0
1:aaea357: 
1:aaea357:    Unless required by applicable law or agreed to in writing, software
1:aaea357:    distributed under the License is distributed on an "AS IS" BASIS,
1:aaea357:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:aaea357:    See the License for the specific language governing permissions and
1:aaea357:    limitations under the License.
1:aaea357: 
1:aaea357:  */
1:aaea357: 
1:aaea357: package org.apache.derby.impl.sql.execute;
1:aaea357: 
1:aaea357: import org.apache.derby.iapi.error.StandardException;
1:aaea357: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:aaea357: 
1:aaea357: import org.apache.derby.iapi.sql.Activation;
1:aaea357: 
1:aaea357: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:aaea357: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1:aaea357: import org.apache.derby.iapi.sql.execute.ExecRow;
1:aaea357: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:aaea357: 
1:aaea357: import org.apache.derby.iapi.types.DataValueDescriptor;
1:aaea357: import org.apache.derby.iapi.types.Orderable;
1:aaea357: import org.apache.derby.iapi.types.RowLocation;
1:aaea357: 
1:aaea357: import org.apache.derby.impl.sql.compile.IntersectOrExceptNode;
1:aaea357: 
1:aaea357: /**
1:aaea357:  * Takes the result set produced by an ordered UNION ALL of two tagged result sets and produces
1:aaea357:  * the INTERSECT or EXCEPT of the two input result sets. This also projects out the tag, the last column
1:aaea357:  * of the input rows.
1:aaea357:  */
1:f77f36d: class SetOpResultSet extends NoPutResultSetImpl
1:aaea357:     implements CursorResultSet
1:aaea357: {
1:aaea357:     private final NoPutResultSet leftSource;
1:aaea357:     private final NoPutResultSet rightSource;
1:aaea357:     private final Activation activation;
1:aaea357:     private final int opType;
1:aaea357:     private final boolean all;
1:aaea357:     private final int resultSetNumber;
1:aaea357:     private DataValueDescriptor[] prevCols; /* Used to remove duplicates in the EXCEPT DISTINCT case.
1:aaea357:                                              * It is equal to the previously output columns.
1:aaea357:                                              */
1:aaea357:     private ExecRow leftInputRow;
1:aaea357:     private ExecRow rightInputRow;
1:aaea357: 
1:aaea357:     private final int[] intermediateOrderByColumns;
1:aaea357:     private final int[] intermediateOrderByDirection;
1:cc30c0c:     private final boolean[] intermediateOrderByNullsLow;
1:aaea357: 
1:6f2391f:     /* Run time statistics variables */
1:6f2391f:     private int rowsSeenLeft;
1:6f2391f:     private int rowsSeenRight;
1:6f2391f:     private int rowsReturned;
1:6f2391f: 
1:aaea357:     SetOpResultSet( NoPutResultSet leftSource,
1:aaea357:                     NoPutResultSet rightSource,
1:aaea357:                     Activation activation, 
1:aaea357:                     int resultSetNumber,
1:aaea357:                     long optimizerEstimatedRowCount,
1:aaea357:                     double optimizerEstimatedCost,
1:aaea357:                     int opType,
1:aaea357:                     boolean all,
1:aaea357:                     int intermediateOrderByColumnsSavedObject,
1:cc30c0c:                     int intermediateOrderByDirectionSavedObject,
1:cc30c0c:                     int intermediateOrderByNullsLowSavedObject)
1:aaea357:     {
1:aaea357: 		super(activation, resultSetNumber, 
1:aaea357: 			  optimizerEstimatedRowCount, optimizerEstimatedCost);
1:aaea357:         this.leftSource = leftSource;
1:aaea357:         this.rightSource = rightSource;
1:aaea357:         this.activation = activation;
1:aaea357:         this.resultSetNumber = resultSetNumber;
1:aaea357:         this.opType = opType;
1:aaea357:         this.all = all;
1:f77f36d: 
1:aaea357:         ExecPreparedStatement eps = activation.getPreparedStatement();
1:aaea357:         intermediateOrderByColumns = (int[]) eps.getSavedObject(intermediateOrderByColumnsSavedObject);
1:aaea357:         intermediateOrderByDirection = (int[]) eps.getSavedObject(intermediateOrderByDirectionSavedObject);
1:cc30c0c:         intermediateOrderByNullsLow = (boolean[]) eps.getSavedObject(intermediateOrderByNullsLowSavedObject);
1:7008b63:         recordConstructorTime();
1:aaea357:     }
1:4e784bb: 
1:aaea357: 	/**
1:aaea357:      * open the first source.
1:aaea357:  	 *	@exception StandardException thrown on failure
1:aaea357:      */
1:aaea357: 	public void	openCore() throws StandardException 
1:aaea357: 	{
1:aaea357: 		beginTime = getCurrentTimeMillis();
1:aaea357: 		if (SanityManager.DEBUG)
1:6f2391f: 	    	SanityManager.ASSERT( ! isOpen, "SetOpResultSet already open");
1:6f2391f: 
1:aaea357:         leftSource.openCore();
1:0a6a846: 
1:0a6a846:         try {
1:0a6a846:             rightSource.openCore();
1:0a6a846:             rightInputRow = rightSource.getNextRowCore();
1:0a6a846:         } catch (StandardException e) {
1:0a6a846:             // DERBY-4330 Result set tree must be atomically open or
1:0a6a846:             // closed for reuse to work (after DERBY-827).
1:0a6a846:             isOpen = true; // to make close work:
1:0a6a846:             try { close(); } catch (StandardException ee) {}
1:0a6a846:             throw e;
1:0a6a846:         }
1:0a6a846: 
1:6f2391f:         if (rightInputRow != null)
1:6f2391f:         {
1:6f2391f:             rowsSeenRight++;
1:6f2391f:         }
1:6f2391f: 
1:0a6a846:         isOpen = true;
1:aaea357: 		numOpens++;
1:aaea357: 
1:aaea357: 		openTime += getElapsedMillis(beginTime);
1:aaea357: 	} // end of openCore
1:aaea357: 
1:aaea357: 	/**
1:aaea357:      * @return the next row of the intersect or except, null if there is none
1:aaea357:  	 *	@exception StandardException thrown on failure
1:aaea357: 	 */
1:aaea357: 	public ExecRow	getNextRowCore() throws StandardException
1:aaea357:     {
1:2a4654b: 		if( isXplainOnlyMode() )
1:2a4654b: 			return null;
1:2a4654b: 
1:aaea357: 		beginTime = getCurrentTimeMillis();
1:aaea357: 	    if ( isOpen )
1:aaea357:         {
1:aaea357:             while( (leftInputRow = leftSource.getNextRowCore()) != null)
1:aaea357:             {
1:6f2391f:                 rowsSeenLeft++;
1:6f2391f: 
1:aaea357:                 DataValueDescriptor[] leftColumns = leftInputRow.getRowArray();
1:aaea357:                 if( !all)
1:aaea357:                 {
1:aaea357:                     if( isDuplicate( leftColumns))
1:aaea357:                         continue; // Get the next left row
1:aaea357:                     prevCols = leftInputRow.getRowArrayClone();
1:aaea357:                 }
1:aaea357:                 int compare = 0;
1:aaea357:                 // Advance the right until there are no more right rows or leftRow <= rightRow
1:6f2391f:                 while ( rightInputRow != null && (compare = compare(leftColumns, rightInputRow.getRowArray())) > 0)
1:6f2391f:                 {
2:aaea357:                     rightInputRow = rightSource.getNextRowCore();
1:6f2391f:                     if (rightInputRow != null)
1:6f2391f:                     {
1:6f2391f:                         rowsSeenRight++;
1:6f2391f:                     }
1:6f2391f:                 }
1:6f2391f: 
1:aaea357:                 if( rightInputRow == null || compare < 0)
1:aaea357:                 {
1:aaea357:                     // The left row is not in the right source.
1:aaea357:                     if( opType == IntersectOrExceptNode.EXCEPT_OP)
1:aaea357:                         // Output this row
1:aaea357:                         break;
1:aaea357:                 }
1:aaea357:                 else
1:aaea357:                 {
1:aaea357:                     // The left and right rows are the same
1:aaea357:                     if( SanityManager.DEBUG)
1:aaea357:                         SanityManager.ASSERT( rightInputRow != null && compare == 0,
1:6f2391f:                                               "Intersect/Except execution has gotten confused.");
1:6f2391f:                     if ( all)
1:6f2391f:                     {
1:aaea357:                         // Just advance the right input by one row.
1:aaea357:                         rightInputRow = rightSource.getNextRowCore();
1:6f2391f:                         if (rightInputRow != null)
1:6f2391f:                         {
1:6f2391f:                             rowsSeenRight++;
1:6f2391f:                         }
1:6f2391f:                     }
1:6f2391f: 
1:aaea357:                     // If !all then we will skip past duplicates on the left at the top of this loop,
1:aaea357:                     // which will then force us to skip past any right duplicates.
1:aaea357:                     if( opType == IntersectOrExceptNode.INTERSECT_OP)
1:aaea357:                         break; // output this row
1:aaea357: 
1:aaea357:                     // opType == IntersectOrExceptNode.EXCEPT_OP
1:aaea357:                     // This row should not be ouput
1:aaea357:                 }
1:aaea357:             }
1:aaea357:         }
1:aaea357: 
1:4e784bb:         setCurrentRow(leftInputRow);
1:aaea357: 
1:6f2391f:         if (currentRow != null) {
1:6f2391f:            rowsReturned++;
1:6f2391f:         }
1:6f2391f: 
1:aaea357:         nextTime += getElapsedMillis(beginTime);
1:aaea357:         return currentRow;
1:aaea357:     } // end of getNextRowCore
1:aaea357: 
1:aaea357:     private void advanceRightPastDuplicates( DataValueDescriptor[] leftColumns)
1:aaea357:         throws StandardException
1:aaea357:     {
1:6f2391f:         while ((rightInputRow = rightSource.getNextRowCore()) != null)
1:6f2391f:         {
1:6f2391f:             rowsSeenRight++;
1:6f2391f: 
1:6f2391f:             if (compare(leftColumns, rightInputRow.getRowArray()) == 0) 
1:6f2391f:                 continue;
1:6f2391f:         }
1:aaea357:     } // end of advanceRightPastDuplicates
1:aaea357:         
1:aaea357:     private int compare( DataValueDescriptor[] leftCols, DataValueDescriptor[] rightCols)
1:aaea357:         throws StandardException
1:aaea357:     {
1:aaea357:         for( int i = 0; i < intermediateOrderByColumns.length; i++)
1:aaea357:         {
1:aaea357:             int colIdx = intermediateOrderByColumns[i];
1:aaea357:             if( leftCols[colIdx].compare( Orderable.ORDER_OP_LESSTHAN,
1:aaea357:                                           rightCols[colIdx],
1:cc30c0c:                                           true, // nulls should be ordered
1:cc30c0c:                                           intermediateOrderByNullsLow[i],
1:aaea357:                                           false))
1:aaea357:                 return -1 * intermediateOrderByDirection[i];
1:aaea357:             if( ! leftCols[colIdx].compare( Orderable.ORDER_OP_EQUALS,
1:aaea357:                                             rightCols[colIdx],
1:cc30c0c:                                             true, // nulls should be ordered
1:cc30c0c:                                             intermediateOrderByNullsLow[i],
1:aaea357:                                             false))
1:aaea357:                 return intermediateOrderByDirection[i];
1:aaea357:         }
1:aaea357:         return 0;
1:aaea357:     } // end of compare
1:aaea357:     
1:aaea357:     private boolean isDuplicate( DataValueDescriptor[] curColumns)
1:aaea357:         throws StandardException
1:aaea357:     {
1:aaea357:         if( prevCols == null)
1:aaea357:             return false;
1:aaea357:         /* Note that intermediateOrderByColumns.length can be less than prevCols.length if we know that a
1:aaea357:          * subset of the columns is a unique key. In that case we only need to look at the unique key.
1:aaea357:          */
1:aaea357:         for( int i = 0; i < intermediateOrderByColumns.length; i++)
1:aaea357:         {
1:aaea357:             int colIdx = intermediateOrderByColumns[i];
1:aaea357:             if( ! curColumns[colIdx].compare( Orderable.ORDER_OP_EQUALS, prevCols[colIdx], true, false))
1:aaea357:                 return false;
1:aaea357:         }
1:aaea357:         return true;
1:aaea357:     }
1:aaea357: 
1:aaea357: 	public ExecRow getCurrentRow()
1:aaea357:     {
1:aaea357:         return currentRow;
1:aaea357:     }
1:aaea357:     
1:aaea357: 	/**
1:aaea357: 	 * If the result set has been opened,
1:aaea357: 	 * close the currently open source.
1:aaea357: 	 *
1:aaea357: 	 * @exception StandardException thrown on error
1:aaea357: 	 */
1:aaea357: 	public void	close() throws StandardException
1:aaea357: 	{
1:aaea357: 		beginTime = getCurrentTimeMillis();
1:aaea357: 		if ( isOpen )
1:aaea357:         {
1:aaea357: 	    	clearCurrentRow();
1:aaea357:             prevCols = null;
1:aaea357:             leftSource.close();
1:aaea357:             rightSource.close();
1:aaea357:             super.close();
1:aaea357:         }
1:aaea357: 		else
1:aaea357: 			if (SanityManager.DEBUG)
1:6f2391f: 				SanityManager.DEBUG("CloseRepeatInfo","Close of SetOpResultSet repeated");
1:aaea357: 
1:aaea357: 		closeTime += getElapsedMillis(beginTime);
1:aaea357: 	} // end of close
1:aaea357: 
1:aaea357: 	public void	finish() throws StandardException
1:aaea357: 	{
1:aaea357: 		leftSource.finish();
1:aaea357: 		rightSource.finish();
1:aaea357: 		finishAndRTS();
1:aaea357: 	}
1:aaea357: 
1:aaea357: 	/**
1:aaea357: 	 * Return the total amount of time spent in this ResultSet
1:aaea357: 	 *
1:aaea357: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1:aaea357: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1:aaea357: 	 *
1:aaea357: 	 * @return long		The total amount of time spent (in milliseconds).
1:aaea357: 	 */
1:aaea357: 	public long getTimeSpent(int type)
1:aaea357: 	{
1:aaea357: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1:aaea357: 
1:aaea357: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1:aaea357: 		{
1:aaea357: 			return	totTime - leftSource.getTimeSpent(ENTIRE_RESULTSET_TREE)
1:aaea357:               - rightSource.getTimeSpent(ENTIRE_RESULTSET_TREE);
1:aaea357: 		}
1:aaea357: 		else
1:aaea357: 		{
1:aaea357: 			return totTime;
1:aaea357: 		}
1:aaea357: 	} // end of getTimeSpent
1:aaea357: 
1:aaea357: 	/**
1:aaea357:      * @see CursorResultSet
1:aaea357: 	 *
1:aaea357:      * @return the row location of the current cursor row.
1:aaea357:      * @exception StandardException thrown on failure
1:aaea357: 	 */
1:aaea357: 	public RowLocation getRowLocation() throws StandardException
1:aaea357:     {
1:aaea357:         // RESOLVE: What is the row location of an INTERSECT supposed to be: the location from the
1:aaea357:         // left side, the right side, or null?
1:aaea357:         return ((CursorResultSet)leftSource).getRowLocation();
1:aaea357:     }
1:6f2391f: 
1:6f2391f:     /**
1:6f2391f:      * Return the set operation of this <code>SetOpResultSet</code>
1:6f2391f:      *
1:6f2391f:      * @return the set operation of this ResultSet, the value is either 
1:6f2391f:      *         <code>IntersectOrExceptNode.INTERSECT_OP</code> for 
1:6f2391f:      *         Intersect operation or <code>IntersectOrExceptNode.EXCEPT_OP
1:6f2391f:      *         </code> for Except operation
1:6f2391f:      *         
1:6f2391f:      * @see    org.apache.derby.impl.sql.compile.IntersectOrExceptNode
1:6f2391f:      */
1:6f2391f:     public int getOpType()
1:6f2391f:     {
1:6f2391f:         return opType;
1:6f2391f:     }
1:6f2391f: 
1:6f2391f:     /**
1:6f2391f:      * Return the result set number
1:6f2391f:      *
1:6f2391f:      * @return the result set number
1:6f2391f:      */
1:6f2391f:     public int getResultSetNumber()
1:6f2391f:     {
1:6f2391f:         return resultSetNumber;
1:6f2391f:     }
1:6f2391f: 
1:6f2391f:     /**
1:6f2391f:      * Return the left source input of this <code>SetOpResultSet</code>
1:6f2391f:      *
1:6f2391f:      * @return the left source input of this <code>SetOpResultSet</code>
1:6f2391f:      * @see org.apache.derby.iapi.sql.execute.NoPutResultSet
1:6f2391f:      */
1:6f2391f:     public NoPutResultSet getLeftSourceInput()
1:6f2391f:     {
1:6f2391f:         return leftSource;
1:6f2391f:     }
1:6f2391f: 
1:6f2391f:     /**
1:6f2391f:      * Return the right source input of this <code>SetOpResultSet</code>
1:6f2391f:      *
1:6f2391f:      * @return the right source input of this <code>SetOpResultSet</code>
1:6f2391f:      * @see org.apache.derby.iapi.sql.execute.NoPutResultSet
1:6f2391f:      */
1:6f2391f:     public NoPutResultSet getRightSourceInput()
1:6f2391f:     {
1:6f2391f:         return rightSource;
1:6f2391f:     }
1:6f2391f: 
1:6f2391f:     /**
1:6f2391f:      * Return the number of rows seen on the left source input
1:6f2391f:      *
1:6f2391f:      * @return the number of rows seen on the left source input
1:6f2391f:      */
1:6f2391f:     public int getRowsSeenLeft()
1:6f2391f:     {
1:6f2391f:         return rowsSeenLeft;
1:6f2391f:     }
1:6f2391f: 
1:6f2391f:     /**
1:6f2391f:      * Return the number of rows seen on the right source input
1:6f2391f:      *
1:6f2391f:      * @return the number of rows seen on the right source input
1:6f2391f:      */
1:6f2391f:     public int getRowsSeenRight()
1:6f2391f:     {
1:6f2391f:         return rowsSeenRight;
1:6f2391f:     }
1:6f2391f: 
1:6f2391f:     /**
1:6f2391f:      * Return the number of rows returned from the result set
1:6f2391f:      *
1:6f2391f:      * @return the number of rows returned from the result set
1:6f2391f:      */
1:6f2391f:     public int getRowsReturned()
1:6f2391f:     {
1:6f2391f:         return rowsReturned;
1:6f2391f:     }
1:aaea357: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:2a4654b
/////////////////////////////////////////////////////////////////////////
1: 		if( isXplainOnlyMode() )
1: 			return null;
1: 
commit:cc30c0c
/////////////////////////////////////////////////////////////////////////
1:     private final boolean[] intermediateOrderByNullsLow;
/////////////////////////////////////////////////////////////////////////
1:                     int intermediateOrderByDirectionSavedObject,
1:                     int intermediateOrderByNullsLowSavedObject)
/////////////////////////////////////////////////////////////////////////
1:         intermediateOrderByNullsLow = (boolean[]) eps.getSavedObject(intermediateOrderByNullsLowSavedObject);
/////////////////////////////////////////////////////////////////////////
1:                                           true, // nulls should be ordered
1:                                           intermediateOrderByNullsLow[i],
1:                                             true, // nulls should be ordered
1:                                             intermediateOrderByNullsLow[i],
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a280beb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0a6a846
/////////////////////////////////////////////////////////////////////////
1: 
1:         try {
1:             rightSource.openCore();
1:             rightInputRow = rightSource.getNextRowCore();
1:         } catch (StandardException e) {
1:             // DERBY-4330 Result set tree must be atomically open or
1:             // closed for reuse to work (after DERBY-827).
1:             isOpen = true; // to make close work:
1:             try { close(); } catch (StandardException ee) {}
1:             throw e;
1:         }
1: 
1:         isOpen = true;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4e784bb
/////////////////////////////////////////////////////////////////////////
1: 
1:         setCurrentRow(leftInputRow);
commit:7008b63
/////////////////////////////////////////////////////////////////////////
1:         recordConstructorTime();
commit:f77f36d
/////////////////////////////////////////////////////////////////////////
1: class SetOpResultSet extends NoPutResultSetImpl
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6f2391f
/////////////////////////////////////////////////////////////////////////
0:    Copyright 2004, 2006 The Apache Software Foundation or its licensors, as applicable.
/////////////////////////////////////////////////////////////////////////
1:     /* Run time statistics variables */
1:     private int rowsSeenLeft;
1:     private int rowsSeenRight;
1:     private int rowsReturned;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	    	SanityManager.ASSERT( ! isOpen, "SetOpResultSet already open");
1:         if (rightInputRow != null)
1:         {
1:             rowsSeenRight++;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 rowsSeenLeft++;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 while ( rightInputRow != null && (compare = compare(leftColumns, rightInputRow.getRowArray())) > 0)
1:                 {
1:                     if (rightInputRow != null)
1:                     {
1:                         rowsSeenRight++;
1:                     }
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
1:                                               "Intersect/Except execution has gotten confused.");
1:                     if ( all)
1:                     {
1:                         if (rightInputRow != null)
1:                         {
1:                             rowsSeenRight++;
1:                         }
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         setCurrentRow( currentRow );
1: 
1:         if (currentRow != null) {
1:            rowsReturned++;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         while ((rightInputRow = rightSource.getNextRowCore()) != null)
1:         {
1:             rowsSeenRight++;
1: 
1:             if (compare(leftColumns, rightInputRow.getRowArray()) == 0) 
1:                 continue;
1:         }
/////////////////////////////////////////////////////////////////////////
1: 				SanityManager.DEBUG("CloseRepeatInfo","Close of SetOpResultSet repeated");
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Return the set operation of this <code>SetOpResultSet</code>
1:      *
1:      * @return the set operation of this ResultSet, the value is either 
1:      *         <code>IntersectOrExceptNode.INTERSECT_OP</code> for 
1:      *         Intersect operation or <code>IntersectOrExceptNode.EXCEPT_OP
1:      *         </code> for Except operation
1:      *         
1:      * @see    org.apache.derby.impl.sql.compile.IntersectOrExceptNode
1:      */
1:     public int getOpType()
1:     {
1:         return opType;
1:     }
1: 
1:     /**
1:      * Return the result set number
1:      *
1:      * @return the result set number
1:      */
1:     public int getResultSetNumber()
1:     {
1:         return resultSetNumber;
1:     }
1: 
1:     /**
1:      * Return the left source input of this <code>SetOpResultSet</code>
1:      *
1:      * @return the left source input of this <code>SetOpResultSet</code>
1:      * @see org.apache.derby.iapi.sql.execute.NoPutResultSet
1:      */
1:     public NoPutResultSet getLeftSourceInput()
1:     {
1:         return leftSource;
1:     }
1: 
1:     /**
1:      * Return the right source input of this <code>SetOpResultSet</code>
1:      *
1:      * @return the right source input of this <code>SetOpResultSet</code>
1:      * @see org.apache.derby.iapi.sql.execute.NoPutResultSet
1:      */
1:     public NoPutResultSet getRightSourceInput()
1:     {
1:         return rightSource;
1:     }
1: 
1:     /**
1:      * Return the number of rows seen on the left source input
1:      *
1:      * @return the number of rows seen on the left source input
1:      */
1:     public int getRowsSeenLeft()
1:     {
1:         return rowsSeenLeft;
1:     }
1: 
1:     /**
1:      * Return the number of rows seen on the right source input
1:      *
1:      * @return the number of rows seen on the right source input
1:      */
1:     public int getRowsSeenRight()
1:     {
1:         return rowsSeenRight;
1:     }
1: 
1:     /**
1:      * Return the number of rows returned from the result set
1:      *
1:      * @return the number of rows returned from the result set
1:      */
1:     public int getRowsReturned()
1:     {
1:         return rowsReturned;
1:     }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.sql.execute.SetOpResultSet
1: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultDescription;
1: 
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.Orderable;
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.impl.sql.compile.IntersectOrExceptNode;
1: 
1: /**
1:  * Takes the result set produced by an ordered UNION ALL of two tagged result sets and produces
1:  * the INTERSECT or EXCEPT of the two input result sets. This also projects out the tag, the last column
1:  * of the input rows.
1:  */
0: public class SetOpResultSet extends NoPutResultSetImpl
1:     implements CursorResultSet
1: {
1:     private final NoPutResultSet leftSource;
1:     private final NoPutResultSet rightSource;
0:     private final GeneratedMethod closeCleanup;
1:     private final Activation activation;
1:     private final int opType;
1:     private final boolean all;
1:     private final int resultSetNumber;
1:     private DataValueDescriptor[] prevCols; /* Used to remove duplicates in the EXCEPT DISTINCT case.
1:                                              * It is equal to the previously output columns.
1:                                              */
0:     private int rightDuplicateCount; // Number of duplicates of the current row from the right input
1:     private ExecRow leftInputRow;
1:     private ExecRow rightInputRow;
1: 
1:     private final int[] intermediateOrderByColumns;
1:     private final int[] intermediateOrderByDirection;
1: 
1:     SetOpResultSet( NoPutResultSet leftSource,
1:                     NoPutResultSet rightSource,
1:                     Activation activation, 
1:                     int resultSetNumber,
1:                     long optimizerEstimatedRowCount,
1:                     double optimizerEstimatedCost,
1:                     int opType,
1:                     boolean all,
0:                     GeneratedMethod closeCleanup,
1:                     int intermediateOrderByColumnsSavedObject,
0:                     int intermediateOrderByDirectionSavedObject)
1:     {
1: 		super(activation, resultSetNumber, 
1: 			  optimizerEstimatedRowCount, optimizerEstimatedCost);
1:         this.leftSource = leftSource;
1:         this.rightSource = rightSource;
1:         this.activation = activation;
1:         this.resultSetNumber = resultSetNumber;
1:         this.opType = opType;
1:         this.all = all;
0:         this.closeCleanup = closeCleanup;
1:         ExecPreparedStatement eps = activation.getPreparedStatement();
1:         intermediateOrderByColumns = (int[]) eps.getSavedObject(intermediateOrderByColumnsSavedObject);
1:         intermediateOrderByDirection = (int[]) eps.getSavedObject(intermediateOrderByDirectionSavedObject);
0: 		constructorTime += getElapsedMillis(beginTime);
1:     }
1: 
1: 	/**
1:      * open the first source.
1:  	 *	@exception StandardException thrown on failure
1:      */
1: 	public void	openCore() throws StandardException 
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 		if (SanityManager.DEBUG)
0: 	    	SanityManager.ASSERT( ! isOpen, "SetOpProjectRestrictResultSet already open");
1: 
0:         isOpen = true;
1:         leftSource.openCore();
0:         rightSource.openCore();
1:         rightInputRow = rightSource.getNextRowCore();
1: 		numOpens++;
1: 
1: 		openTime += getElapsedMillis(beginTime);
1: 	} // end of openCore
1: 
1: 	/**
1:      * @return the next row of the intersect or except, null if there is none
1:  	 *	@exception StandardException thrown on failure
1: 	 */
1: 	public ExecRow	getNextRowCore() throws StandardException
1:     {
1: 		beginTime = getCurrentTimeMillis();
1: 	    if ( isOpen )
1:         {
1:             while( (leftInputRow = leftSource.getNextRowCore()) != null)
1:             {
1:                 DataValueDescriptor[] leftColumns = leftInputRow.getRowArray();
1:                 if( !all)
1:                 {
1:                     if( isDuplicate( leftColumns))
1:                         continue; // Get the next left row
1:                     prevCols = leftInputRow.getRowArrayClone();
1:                 }
1:                 int compare = 0;
1:                 // Advance the right until there are no more right rows or leftRow <= rightRow
0:                 while( rightInputRow != null && (compare = compare( leftColumns, rightInputRow.getRowArray())) > 0)
1:                     rightInputRow = rightSource.getNextRowCore();
1:                 
1:                 if( rightInputRow == null || compare < 0)
1:                 {
1:                     // The left row is not in the right source.
1:                     if( opType == IntersectOrExceptNode.EXCEPT_OP)
1:                         // Output this row
1:                         break;
1:                 }
1:                 else
1:                 {
1:                     // The left and right rows are the same
1:                     if( SanityManager.DEBUG)
1:                         SanityManager.ASSERT( rightInputRow != null && compare == 0,
0:                                               "Insert/Except execution has gotten confused.");
0:                     if( all)
1:                         // Just advance the right input by one row.
1:                         rightInputRow = rightSource.getNextRowCore();
1:                     // If !all then we will skip past duplicates on the left at the top of this loop,
1:                     // which will then force us to skip past any right duplicates.
1:                     if( opType == IntersectOrExceptNode.INTERSECT_OP)
1:                         break; // output this row
1: 
1:                     // opType == IntersectOrExceptNode.EXCEPT_OP
1:                     // This row should not be ouput
1:                 }
1:             }
1:         }
0:         currentRow = leftInputRow;
0:         setCurrentRow( currentRow);
1:         nextTime += getElapsedMillis(beginTime);
1:         return currentRow;
1:     } // end of getNextRowCore
1: 
1:     private void advanceRightPastDuplicates( DataValueDescriptor[] leftColumns)
1:         throws StandardException
1:     {
0:         while((rightInputRow = rightSource.getNextRowCore()) != null
0:               && compare( leftColumns, rightInputRow.getRowArray()) == 0)
0:             ;
1:     } // end of advanceRightPastDuplicates
1:         
1:     private int compare( DataValueDescriptor[] leftCols, DataValueDescriptor[] rightCols)
1:         throws StandardException
1:     {
1:         for( int i = 0; i < intermediateOrderByColumns.length; i++)
1:         {
1:             int colIdx = intermediateOrderByColumns[i];
1:             if( leftCols[colIdx].compare( Orderable.ORDER_OP_LESSTHAN,
1:                                           rightCols[colIdx],
0:                                           true, // nulls sort high
1:                                           false))
1:                 return -1 * intermediateOrderByDirection[i];
1:             if( ! leftCols[colIdx].compare( Orderable.ORDER_OP_EQUALS,
1:                                             rightCols[colIdx],
0:                                             true, // nulls sort high
1:                                             false))
1:                 return intermediateOrderByDirection[i];
1:         }
1:         return 0;
1:     } // end of compare
1:     
1:     private boolean isDuplicate( DataValueDescriptor[] curColumns)
1:         throws StandardException
1:     {
1:         if( prevCols == null)
1:             return false;
1:         /* Note that intermediateOrderByColumns.length can be less than prevCols.length if we know that a
1:          * subset of the columns is a unique key. In that case we only need to look at the unique key.
1:          */
1:         for( int i = 0; i < intermediateOrderByColumns.length; i++)
1:         {
1:             int colIdx = intermediateOrderByColumns[i];
1:             if( ! curColumns[colIdx].compare( Orderable.ORDER_OP_EQUALS, prevCols[colIdx], true, false))
1:                 return false;
1:         }
1:         return true;
1:     }
1: 
1: 	public ExecRow getCurrentRow()
1:     {
1:         return currentRow;
1:     }
1:     
1: 	/**
1: 	 * If the result set has been opened,
1: 	 * close the currently open source.
1: 	 *
1: 	 * @exception StandardException thrown on error
1: 	 */
1: 	public void	close() throws StandardException
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 		if ( isOpen )
1:         {
0: 			if (closeCleanup != null)
0: 				closeCleanup.invoke(activation); // let activation tidy up
1: 	    	clearCurrentRow();
0: 			currentRow = null;
1:             prevCols = null;
1:             leftSource.close();
1:             rightSource.close();
1:             super.close();
1:         }
1: 		else
1: 			if (SanityManager.DEBUG)
0: 				SanityManager.DEBUG("CloseRepeatInfo","Close of UnionResultSet repeated");
1: 
1: 		closeTime += getElapsedMillis(beginTime);
1: 	} // end of close
1: 
1: 	public void	finish() throws StandardException
1: 	{
1: 		leftSource.finish();
1: 		rightSource.finish();
1: 		finishAndRTS();
1: 	}
1: 
1: 	/**
1: 	 * Return the total amount of time spent in this ResultSet
1: 	 *
1: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1: 	 *
1: 	 * @return long		The total amount of time spent (in milliseconds).
1: 	 */
1: 	public long getTimeSpent(int type)
1: 	{
1: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1: 
1: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1: 		{
1: 			return	totTime - leftSource.getTimeSpent(ENTIRE_RESULTSET_TREE)
1:               - rightSource.getTimeSpent(ENTIRE_RESULTSET_TREE);
1: 		}
1: 		else
1: 		{
1: 			return totTime;
1: 		}
1: 	} // end of getTimeSpent
1: 
1: 	/**
1:      * @see CursorResultSet
1: 	 *
1:      * @return the row location of the current cursor row.
1:      * @exception StandardException thrown on failure
1: 	 */
1: 	public RowLocation getRowLocation() throws StandardException
1:     {
1:         // RESOLVE: What is the row location of an INTERSECT supposed to be: the location from the
1:         // left side, the right side, or null?
1:         return ((CursorResultSet)leftSource).getRowLocation();
1:     }
1: }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:47f9d0a
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Derby - Class org.apache.derby.impl.sql.execute.SetOpResultSet
0: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.Orderable;
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.impl.sql.compile.IntersectOrExceptNode;
0: 
0: /**
0:  * Takes the result set produced by an ordered UNION ALL of two tagged result sets and produces
0:  * the INTERSECT or EXCEPT of the two input result sets. This also projects out the tag, the last column
0:  * of the input rows.
0:  */
0: public class SetOpResultSet extends NoPutResultSetImpl
0:     implements CursorResultSet
0: {
0:     private final NoPutResultSet leftSource;
0:     private final NoPutResultSet rightSource;
0:     private final GeneratedMethod closeCleanup;
0:     private final Activation activation;
0:     private final int opType;
0:     private final boolean all;
0:     private final int resultSetNumber;
0:     private DataValueDescriptor[] prevCols; /* Used to remove duplicates in the EXCEPT DISTINCT case.
0:                                              * It is equal to the previously output columns.
0:                                              */
0:     private int rightDuplicateCount; // Number of duplicates of the current row from the right input
0:     private ExecRow leftInputRow;
0:     private ExecRow rightInputRow;
0: 
0:     private final int[] intermediateOrderByColumns;
0:     private final int[] intermediateOrderByDirection;
0: 
0:     SetOpResultSet( NoPutResultSet leftSource,
0:                     NoPutResultSet rightSource,
0:                     Activation activation, 
0:                     int resultSetNumber,
0:                     long optimizerEstimatedRowCount,
0:                     double optimizerEstimatedCost,
0:                     int opType,
0:                     boolean all,
0:                     GeneratedMethod closeCleanup,
0:                     int intermediateOrderByColumnsSavedObject,
0:                     int intermediateOrderByDirectionSavedObject)
0:     {
0: 		super(activation, resultSetNumber, 
0: 			  optimizerEstimatedRowCount, optimizerEstimatedCost);
0:         this.leftSource = leftSource;
0:         this.rightSource = rightSource;
0:         this.activation = activation;
0:         this.resultSetNumber = resultSetNumber;
0:         this.opType = opType;
0:         this.all = all;
0:         this.closeCleanup = closeCleanup;
0:         ExecPreparedStatement eps = activation.getPreparedStatement();
0:         intermediateOrderByColumns = (int[]) eps.getSavedObject(intermediateOrderByColumnsSavedObject);
0:         intermediateOrderByDirection = (int[]) eps.getSavedObject(intermediateOrderByDirectionSavedObject);
0: 		constructorTime += getElapsedMillis(beginTime);
0:     }
0: 
0: 	/**
0:      * open the first source.
0:  	 *	@exception StandardException thrown on failure
0:      */
0: 	public void	openCore() throws StandardException 
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 		if (SanityManager.DEBUG)
0: 	    	SanityManager.ASSERT( ! isOpen, "SetOpProjectRestrictResultSet already open");
0: 
0:         isOpen = true;
0:         leftSource.openCore();
0:         rightSource.openCore();
0:         rightInputRow = rightSource.getNextRowCore();
0: 		numOpens++;
0: 
0: 		openTime += getElapsedMillis(beginTime);
0: 	} // end of openCore
0: 
0: 	/**
0:      * @return the next row of the intersect or except, null if there is none
0:  	 *	@exception StandardException thrown on failure
0: 	 */
0: 	public ExecRow	getNextRowCore() throws StandardException
0:     {
0: 		beginTime = getCurrentTimeMillis();
0: 	    if ( isOpen )
0:         {
0:             while( (leftInputRow = leftSource.getNextRowCore()) != null)
0:             {
0:                 DataValueDescriptor[] leftColumns = leftInputRow.getRowArray();
0:                 if( !all)
0:                 {
0:                     if( isDuplicate( leftColumns))
0:                         continue; // Get the next left row
0:                     prevCols = leftInputRow.getRowArrayClone();
0:                 }
0:                 int compare = 0;
0:                 // Advance the right until there are no more right rows or leftRow <= rightRow
0:                 while( rightInputRow != null && (compare = compare( leftColumns, rightInputRow.getRowArray())) > 0)
0:                     rightInputRow = rightSource.getNextRowCore();
0:                 
0:                 if( rightInputRow == null || compare < 0)
0:                 {
0:                     // The left row is not in the right source.
0:                     if( opType == IntersectOrExceptNode.EXCEPT_OP)
0:                         // Output this row
0:                         break;
0:                 }
0:                 else
0:                 {
0:                     // The left and right rows are the same
0:                     if( SanityManager.DEBUG)
0:                         SanityManager.ASSERT( rightInputRow != null && compare == 0,
0:                                               "Insert/Except execution has gotten confused.");
0:                     if( all)
0:                         // Just advance the right input by one row.
0:                         rightInputRow = rightSource.getNextRowCore();
0:                     // If !all then we will skip past duplicates on the left at the top of this loop,
0:                     // which will then force us to skip past any right duplicates.
0:                     if( opType == IntersectOrExceptNode.INTERSECT_OP)
0:                         break; // output this row
0: 
0:                     // opType == IntersectOrExceptNode.EXCEPT_OP
0:                     // This row should not be ouput
0:                 }
0:             }
0:         }
0:         currentRow = leftInputRow;
0:         setCurrentRow( currentRow);
0:         nextTime += getElapsedMillis(beginTime);
0:         return currentRow;
0:     } // end of getNextRowCore
0: 
0:     private void advanceRightPastDuplicates( DataValueDescriptor[] leftColumns)
0:         throws StandardException
0:     {
0:         while((rightInputRow = rightSource.getNextRowCore()) != null
0:               && compare( leftColumns, rightInputRow.getRowArray()) == 0)
0:             ;
0:     } // end of advanceRightPastDuplicates
0:         
0:     private int compare( DataValueDescriptor[] leftCols, DataValueDescriptor[] rightCols)
0:         throws StandardException
0:     {
0:         for( int i = 0; i < intermediateOrderByColumns.length; i++)
0:         {
0:             int colIdx = intermediateOrderByColumns[i];
0:             if( leftCols[colIdx].compare( Orderable.ORDER_OP_LESSTHAN,
0:                                           rightCols[colIdx],
0:                                           true, // nulls sort high
0:                                           false))
0:                 return -1 * intermediateOrderByDirection[i];
0:             if( ! leftCols[colIdx].compare( Orderable.ORDER_OP_EQUALS,
0:                                             rightCols[colIdx],
0:                                             true, // nulls sort high
0:                                             false))
0:                 return intermediateOrderByDirection[i];
0:         }
0:         return 0;
0:     } // end of compare
0:     
0:     private boolean isDuplicate( DataValueDescriptor[] curColumns)
0:         throws StandardException
0:     {
0:         if( prevCols == null)
0:             return false;
0:         /* Note that intermediateOrderByColumns.length can be less than prevCols.length if we know that a
0:          * subset of the columns is a unique key. In that case we only need to look at the unique key.
0:          */
0:         for( int i = 0; i < intermediateOrderByColumns.length; i++)
0:         {
0:             int colIdx = intermediateOrderByColumns[i];
0:             if( ! curColumns[colIdx].compare( Orderable.ORDER_OP_EQUALS, prevCols[colIdx], true, false))
0:                 return false;
0:         }
0:         return true;
0:     }
0: 
0: 	public ExecRow getCurrentRow()
0:     {
0:         return currentRow;
0:     }
0:     
0: 	/**
0: 	 * If the result set has been opened,
0: 	 * close the currently open source.
0: 	 *
0: 	 * @exception StandardException thrown on error
0: 	 */
0: 	public void	close() throws StandardException
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 		if ( isOpen )
0:         {
0: 			if (closeCleanup != null)
0: 				closeCleanup.invoke(activation); // let activation tidy up
0: 	    	clearCurrentRow();
0: 			currentRow = null;
0:             prevCols = null;
0:             leftSource.close();
0:             rightSource.close();
0:             super.close();
0:         }
0: 		else
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.DEBUG("CloseRepeatInfo","Close of UnionResultSet repeated");
0: 
0: 		closeTime += getElapsedMillis(beginTime);
0: 	} // end of close
0: 
0: 	public void	finish() throws StandardException
0: 	{
0: 		leftSource.finish();
0: 		rightSource.finish();
0: 		finishAndRTS();
0: 	}
0: 
0: 	/**
0: 	 * Return the total amount of time spent in this ResultSet
0: 	 *
0: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
0: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
0: 	 *
0: 	 * @return long		The total amount of time spent (in milliseconds).
0: 	 */
0: 	public long getTimeSpent(int type)
0: 	{
0: 		long totTime = constructorTime + openTime + nextTime + closeTime;
0: 
0: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
0: 		{
0: 			return	totTime - leftSource.getTimeSpent(ENTIRE_RESULTSET_TREE)
0:               - rightSource.getTimeSpent(ENTIRE_RESULTSET_TREE);
0: 		}
0: 		else
0: 		{
0: 			return totTime;
0: 		}
0: 	} // end of getTimeSpent
0: 
0: 	/**
0:      * @see CursorResultSet
0: 	 *
0:      * @return the row location of the current cursor row.
0:      * @exception StandardException thrown on failure
0: 	 */
0: 	public RowLocation getRowLocation() throws StandardException
0:     {
0:         // RESOLVE: What is the row location of an INTERSECT supposed to be: the location from the
0:         // left side, the right side, or null?
0:         return ((CursorResultSet)leftSource).getRowLocation();
0:     }
0: }
============================================================================