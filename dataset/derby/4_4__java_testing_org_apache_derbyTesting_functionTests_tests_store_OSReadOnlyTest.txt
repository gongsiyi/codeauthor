1:7c33e9c: /* 
24:7c33e9c: 
1:7c33e9c:    Derby - Class org.apache.derbyTesting.functionTests.tests.store.OSReadOnlyTest
1:7c33e9c: 
1:7c33e9c:    Licensed to the Apache Software Foundation (ASF) under one or more
1:7c33e9c:    contributor license agreements.  See the NOTICE file distributed with
1:7c33e9c:    this work for additional information regarding copyright ownership.
1:7c33e9c:    The ASF licenses this file to You under the Apache License, Version 2.0
1:7c33e9c:    (the "License"); you may not use this file except in compliance with
1:7c33e9c:    the License.  You may obtain a copy of the License at
1:7c33e9c: 
1:7c33e9c:       http://www.apache.org/licenses/LICENSE-2.0
1:7c33e9c: 
1:7c33e9c:    Unless required by applicable law or agreed to in writing, software
1:7c33e9c:    distributed under the License is distributed on an "AS IS" BASIS,
1:7c33e9c:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7c33e9c:    See the License for the specific language governing permissions and
1:7c33e9c:    limitations under the License.
1:7c33e9c: 
1:7c33e9c:  */
1:7c33e9c: 
1:7c33e9c: package org.apache.derbyTesting.functionTests.tests.store;
1:7c33e9c: 
1:7c33e9c: import java.io.File;
1:2d7d37f: import java.io.FileNotFoundException;
1:7c33e9c: import java.io.FileOutputStream;
1:7c33e9c: import java.io.IOException;
1:7c33e9c: import java.security.AccessController;
1:0d6a26d: import java.security.PrivilegedAction;
1:7c33e9c: import java.sql.Connection;
1:7c33e9c: import java.sql.SQLException;
1:7c33e9c: import java.sql.Statement;
1:7c33e9c: import javax.sql.DataSource;
1:7c33e9c: import junit.framework.Test;
1:c7b3589: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1:7c33e9c: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:7c33e9c: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:7c33e9c: import org.apache.derbyTesting.junit.JDBC;
1:7c33e9c: import org.apache.derbyTesting.junit.JDBCDataSource;
1:7c33e9c: import org.apache.derbyTesting.junit.TestConfiguration;
1:7c33e9c: 
1:c7b3589: /**
1:0d6a26d:  * Simulates running Derby on a read-only media, and makes sure Derby gives a
1:0d6a26d:  * reasonable error message when the user tries to insert data into the
1:0d6a26d:  * read-only database.
1:c7b3589:  */
1:7c33e9c: public class OSReadOnlyTest extends BaseJDBCTestCase{
1:7c33e9c: 
1:7c33e9c:     public OSReadOnlyTest(String name) {
1:7c33e9c:         super(name);
30:7c33e9c:     }
1:7c33e9c:     
1:1ae02c9:     private static Test newCleanDatabase(BaseTestSuite s) {
1:7c33e9c:         return new CleanDatabaseTestSetup(s) {
1:7c33e9c:         /**
1:7c33e9c:          * Creates the database objects used in the test cases.
1:7c33e9c:          *
1:7c33e9c:          * @throws SQLException
1:7c33e9c:          */
1:7c33e9c:             /**
1:7c33e9c:              * Creates the tables used in the test cases.
1:7c33e9c:              * @exception SQLException if a database error occurs
1:7c33e9c:              */
1:7c33e9c:             protected void decorateSQL(Statement stmt) throws SQLException
24:7c33e9c:             {
1:7c33e9c:                 getConnection();
1:7c33e9c: 
1:7c33e9c:                 // create a table with some data
1:7c33e9c:                 stmt.executeUpdate(
1:7c33e9c:                     "CREATE TABLE foo (a int, b char(100))");
1:7c33e9c:                 stmt.execute("insert into foo values (1, 'hello world')");
1:7c33e9c:                 stmt.execute("insert into foo values (2, 'happy world')");
1:7c33e9c:                 stmt.execute("insert into foo values (3, 'sad world')");
1:7c33e9c:                 stmt.execute("insert into foo values (4, 'crazy world')");
1:7c33e9c:                 for (int i=0 ; i<7 ; i++)
1:7c33e9c:                     stmt.execute("insert into foo select * from foo");
1:7c33e9c:                 stmt.execute("create index fooi on foo(a, b)");
1:7c33e9c:             }
1:7c33e9c:         };
1:7c33e9c:     }
1:7c33e9c: 
1:7c33e9c:     protected static Test baseSuite(String name) 
1:7c33e9c:     {
1:1ae02c9:         BaseTestSuite readonly = new BaseTestSuite("OSReadOnly");
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:7c33e9c:         readonly.addTestSuite(OSReadOnlyTest.class);
1:7c33e9c:         suite.addTest(TestConfiguration.singleUseDatabaseDecorator(newCleanDatabase(readonly)));
1:7c33e9c:         
1:7c33e9c:         return suite;
1:7c33e9c:     }
1:7c33e9c: 
1:7c33e9c:     public static Test suite() 
1:7c33e9c:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("OSReadOnlyTest");
1:7c33e9c:         suite.addTest(baseSuite("OSReadOnlyTest:embedded"));
1:7c33e9c:         suite.addTest(TestConfiguration
1:7c33e9c:             .clientServerDecorator(baseSuite("OSReadOnlyTest:client")));
1:7c33e9c:         return suite;
1:7c33e9c:     }
1:7c33e9c:     
1:7c33e9c:     /**
1:7c33e9c:      * Test that if we make the files comprising the database read-only
1:7c33e9c:      * on OS level, the database reacts as if it's in 'ReadOnly' mode
1:7c33e9c:      */
1:7c33e9c:     public void testOSReadOnly() throws Exception {
1:2d7d37f:         if (!supportsSetReadOnly()) {
1:2d7d37f:             // If we can modify files after File.setReadOnly() has been
1:2d7d37f:             // called on them, the test database will not actually be
1:2d7d37f:             // read-only, and the test will fail. Skip the test in that
1:2d7d37f:             // case.
1:2d7d37f:             alarm("Read-only files can be modified. Skipping OSReadOnlyTest.");
1:2d7d37f:             return;
1:2d7d37f:         }
1:2d7d37f: 
1:7c33e9c:         // start with some simple checks
1:7c33e9c:         setAutoCommit(false);
1:7c33e9c:         Statement stmt = createStatement();
1:7c33e9c:         JDBC.assertFullResultSet(stmt.executeQuery(
1:7c33e9c:             "select count(*) from foo"), new String[][] {{"512"}});
1:7c33e9c:         stmt.executeUpdate("delete from foo where a = 1");
1:7c33e9c:         JDBC.assertFullResultSet(stmt.executeQuery(
1:7c33e9c:             "select count(*) from foo"), new String[][] {{"384"}});
1:7c33e9c:         rollback();
1:7c33e9c:         JDBC.assertFullResultSet(stmt.executeQuery(
1:7c33e9c:             "select count(*) from foo"), new String[][] {{"512"}});
1:7c33e9c:         stmt.executeUpdate("insert into foo select * from foo where a = 1");
1:7c33e9c:         JDBC.assertFullResultSet(stmt.executeQuery(
1:7c33e9c:             "select count(*) from foo"), new String[][] {{"640"}});
1:7c33e9c:         commit();
1:7c33e9c:         stmt.executeUpdate("delete from foo where a = 1");
1:7c33e9c:         JDBC.assertFullResultSet(stmt.executeQuery(
1:7c33e9c:             "select count(*) from foo"), new String[][] {{"384"}});
1:7c33e9c:         rollback();
1:7c33e9c:         JDBC.assertFullResultSet(stmt.executeQuery(
1:7c33e9c:             "select count(*) from foo"), new String[][] {{"640"}});
1:7c33e9c:         setAutoCommit(false);
1:7c33e9c:         
1:7c33e9c:         TestConfiguration.getCurrent().shutdownDatabase();
1:7c33e9c:         
1:7c33e9c:         // so far, we were just playing. Now for the test.
1:7c33e9c:         String phDbName = getPhysicalDbName();
1:7c33e9c:         // copy the database to one called 'readOnly'
1:c7b3589:         moveDatabaseOnOS(phDbName, "readOnly");
1:7c33e9c:         // change filePermissions on readOnly, to readonly.
1:7c33e9c:         changeFilePermissions("readOnly");
1:0d6a26d:         createDummyLockFile("readOnly");
1:7c33e9c:         
1:7c33e9c:         DataSource ds = JDBCDataSource.getDataSource();
1:7c33e9c:         JDBCDataSource.setBeanProperty(ds, 
1:7c33e9c:             "databaseName", "singleUse/readOnly");
1:7c33e9c:         assertReadDB(ds);
1:7c33e9c:         assertExpectedInsertBehaviour(ds, false, 10, "will fail");
1:7c33e9c:         shutdownDB(ds);
1:7c33e9c:         
1:7c33e9c:         // copy the database to one called 'readWrite' 
1:7c33e9c:         // this will have the default read/write permissions upon
1:7c33e9c:         // copying
1:c7b3589:         moveDatabaseOnOS("readOnly", "readWrite");
1:7c33e9c:         ds = JDBCDataSource.getDataSource();
1:7c33e9c:         JDBCDataSource.setBeanProperty(ds, "databaseName", "singleUse/readWrite");
1:7c33e9c:         assertReadDB(ds);
1:7c33e9c:         assertExpectedInsertBehaviour(ds, true, 20, "will go in");
1:7c33e9c:         shutdownDB(ds);
1:7c33e9c:         
1:7c33e9c:         // do it again...
1:c7b3589:         moveDatabaseOnOS("readWrite", "readOnly2");
1:7c33e9c:         // change filePermissions on readOnly, to readonly.
1:7c33e9c:         changeFilePermissions("readOnly2");
1:0d6a26d:         createDummyLockFile("readOnly2");
1:7c33e9c:         
1:7c33e9c:         ds = JDBCDataSource.getDataSource();
1:7c33e9c:         JDBCDataSource.setBeanProperty(ds, 
1:7c33e9c:             "databaseName", "singleUse/readOnly2");
1:7c33e9c:         assertReadDB(ds);
1:7c33e9c:         assertExpectedInsertBehaviour(ds, false, 30, "will also fail");
1:7c33e9c:         shutdownDB(ds);
1:7c33e9c:         
1:7c33e9c:         // testharness will try to remove the original db; put it back
1:c7b3589:         moveDatabaseOnOS("readOnly2", phDbName);
1:7c33e9c:     }
1:2d7d37f: 
1:2d7d37f:     /**
1:2d7d37f:      * Check if {@code File.setReadOnly()} has any effect in this environment.
1:2d7d37f:      * For example, if the test runs as a privileged user, it may be able
1:2d7d37f:      * to modify a file even if it has been made read-only. If so, it doesn't
1:2d7d37f:      * make any sense to run this test.
1:2d7d37f:      *
1:2d7d37f:      * @return {@code true} if {@code File.setReadOnly()} prevents file
1:2d7d37f:      *   modifications; otherwise, {@code false}
1:2d7d37f:      * @throws IOException if an unexpected error happens
1:2d7d37f:      */
1:2d7d37f:     private boolean supportsSetReadOnly() throws IOException {
1:2d7d37f:         File tmp = PrivilegedFileOpsForTests.createTempFile(
1:2d7d37f:                 "tmp", null, currentDirectory());
1:2d7d37f:         PrivilegedFileOpsForTests.setReadOnly(tmp);
1:2d7d37f:         FileOutputStream fs = null;
1:2d7d37f:         try {
1:2d7d37f:             fs = PrivilegedFileOpsForTests.getFileOutputStream(tmp);
1:2d7d37f:             // Was able to open the file in read-write mode, so it's not
1:2d7d37f:             // properly read-only.
1:2d7d37f:             return false;
1:2d7d37f:         } catch (FileNotFoundException fnf) {
1:2d7d37f:             // Failed to open the file in read-write mode, so it seems like
1:2d7d37f:             // it's read-only.
1:2d7d37f:             return true;
1:2d7d37f:         } finally {
1:2d7d37f:             if (fs != null) {
1:2d7d37f:                 fs.close();
1:2d7d37f:             }
1:2d7d37f:             PrivilegedFileOpsForTests.delete(tmp);
1:2d7d37f:         }
1:2d7d37f:     }
1:2d7d37f: 
1:7c33e9c:     /*
1:7c33e9c:      * figure out the physical database name, we want to manipulate
1:7c33e9c:      * the actual files on the OS.
1:7c33e9c:      */
1:7c33e9c:     private String getPhysicalDbName() {
1:7c33e9c:         String pdbName =TestConfiguration.getCurrent().getJDBCUrl();
1:3f5c48a:         return pdbName.substring(pdbName.lastIndexOf("oneuse"));
1:7c33e9c:     }
1:7c33e9c:     
1:7c33e9c:     private void shutdownDB(DataSource ds) throws SQLException {
1:7c33e9c:         JDBCDataSource.setBeanProperty(
1:7c33e9c:             ds, "ConnectionAttributes", "shutdown=true");
1:7c33e9c:         try {
1:7c33e9c:             ds.getConnection();
1:7c33e9c:             fail("expected an sqlexception 08006");
1:7c33e9c:         } catch (SQLException sqle) {
1:7c33e9c:             assertSQLState("08006", sqle);
1:7c33e9c:         }        
1:7c33e9c:     }
1:7c33e9c:     
1:7c33e9c:     private void assertReadDB(DataSource ds) throws SQLException {
1:7c33e9c:         Connection con = ds.getConnection();
1:7c33e9c:         Statement stmt2 = con.createStatement();
1:7c33e9c:         JDBC.assertFullResultSet(
1:7c33e9c:             stmt2.executeQuery("select count(*) from foo where a=1"),
1:7c33e9c:             new String [][] {{"256"}});
1:7c33e9c:         JDBC.assertFullResultSet(
1:7c33e9c:             stmt2.executeQuery("select count(*) from foo where a=2"),
1:7c33e9c:             new String [][] {{"128"}});
1:7c33e9c:         JDBC.assertFullResultSet(
1:7c33e9c:             stmt2.executeQuery("select count(*) from foo where a=1 and b='hello world'"),
1:7c33e9c:             new String [][] {{"256"}});
1:7c33e9c:         stmt2.close();
1:7c33e9c:         con.close();
1:7c33e9c:     }
1:7c33e9c:     
1:7c33e9c:     private void assertExpectedInsertBehaviour(
1:7c33e9c:             DataSource ds, boolean expectedSuccess, 
1:7c33e9c:             int insertIntValue, String insertStringValue) 
1:7c33e9c:     throws SQLException {
1:7c33e9c:         Connection con = ds.getConnection();
1:7c33e9c:         Statement stmt = con.createStatement();
1:7c33e9c:         if (expectedSuccess)
1:7c33e9c:         {
1:7c33e9c:             stmt.executeUpdate("insert into foo values (" +
1:7c33e9c:                 insertIntValue + ", '" + insertStringValue + "')");
1:7c33e9c:             assertTrue(stmt.getUpdateCount() == 1);
1:7c33e9c:             JDBC.assertFullResultSet(
1:7c33e9c:                 stmt.executeQuery("select count(*) from foo where a=" +
1:7c33e9c:                     insertIntValue), new String [][] {{"1"}});
1:7c33e9c:         }
3:7c33e9c:         else {
1:7c33e9c:             try {
1:7c33e9c:                 stmt.executeUpdate("insert into foo values (" +
1:7c33e9c:                     insertIntValue + ", '" + insertStringValue + "')");
1:7c33e9c:                 fail("expected an error indicating the db is readonly");
1:7c33e9c:             } catch (SQLException sqle) {
1:243811f:                 if (!(sqle.getSQLState().equals("25502") || 
1:243811f:                         // on iseries / OS400 machines, when file/os 
1:243811f:                         // permissions are off, we may get error 40XD1 instead
1:243811f:                         sqle.getSQLState().equals("40XD1")))
1:243811f:                     fail("unexpected sqlstate; expected 25502 or 40XD1, got: " + sqle.getSQLState());
1:7c33e9c:             }
1:7c33e9c:         }
1:7c33e9c:         stmt.close();
1:7c33e9c:         con.close();
1:7c33e9c:     }
1:7c33e9c: 
1:7c33e9c:     /**
1:c7b3589:      * Moves the database from one location to another location.
1:c7b3589:      *
1:c7b3589:      * @param fromwhere source directory
1:c7b3589:      * @param todir destination directory
1:c7b3589:      * @throws IOException if the copy fails
1:7c33e9c:      */
1:c7b3589:     private void moveDatabaseOnOS(String fromwhere, String todir)
1:c7b3589:             throws IOException {
1:0d6a26d:         File from_dir = constructDbPath(fromwhere);
1:0d6a26d:         File to_dir = constructDbPath(todir);
1:7c33e9c: 
1:c7b3589:         PrivilegedFileOpsForTests.copy(from_dir, to_dir);
1:c7b3589:         assertDirectoryDeleted(from_dir);
1:7c33e9c:     }
1:7c33e9c: 
1:7c33e9c:     /**
1:0d6a26d:      * Creates a dummy database lock file if one doesn't exist, and sets the
1:0d6a26d:      * lock file to read-only.
1:0d6a26d:      * <p>
1:0d6a26d:      * This method is a work-around for the problem that Java cannot make a file
1:0d6a26d:      * writable before Java 6.
1:0d6a26d:      *
1:0d6a26d:      * @param dbDir the database directory where the lock file belongs
1:7c33e9c:      */
1:0d6a26d:     private void createDummyLockFile(String dbDir) {
1:0d6a26d:         final File f = new File(constructDbPath(dbDir), "db.lck");
1:3f5c48a:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:7c33e9c: 
1:3f5c48a:             public Void run() {
1:0d6a26d:                 if (!f.exists()) {
1:7c33e9c:                     try {
1:0d6a26d:                         FileOutputStream fos = new FileOutputStream(f);
1:0d6a26d:                         // Just write a dummy byte.
1:0d6a26d:                         fos.write(12);
1:0d6a26d:                         fos.close();
1:0d6a26d:                     } catch (IOException fnfe) {
1:0d6a26d:                         // Ignore
1:7c33e9c:                     }
1:7c33e9c:                 }
1:0d6a26d:                 f.setReadOnly();
1:7c33e9c:                 return null;
1:7c33e9c:             }
3:7c33e9c:         });
1:7c33e9c:     }
1:7c33e9c: 
1:7c33e9c:     public void changeFilePermissions(String dir) {
1:0d6a26d:         File dir_to_change = constructDbPath(dir);
1:7c33e9c:         assertTrue("Failed to change files in " + dir_to_change + " to ReadOnly",
1:7c33e9c:             changeDirectoryToReadOnly(dir_to_change));
1:7c33e9c:     }
1:7c33e9c: 
1:7c33e9c:     /**
1:0d6a26d:      * Constructs the path to the database base directory.
1:0d6a26d:      *
1:0d6a26d:      * @param relDbDirName the database name (relative)
1:0d6a26d:      * @return The path to the database.
1:7c33e9c:      */
1:0d6a26d:     private File constructDbPath(String relDbDirName) {
1:0d6a26d:         // Example: "readOnly" -> "<user.dir>/system/singleUse/readOnly"
1:0d6a26d:         File f = new File(getSystemProperty("user.dir"), "system");
1:0d6a26d:         f = new File(f, "singleUse");
1:0d6a26d:         return new File(f, relDbDirName);
1:7c33e9c:     }
1:7c33e9c: 
1:7c33e9c:     /**
2:7c33e9c:      * Change all of the files in a directory and its subdirectories
1:7c33e9c:      * to read only.
1:7c33e9c:      * @param directory the directory File handle to start recursing from.
2:7c33e9c:      * @return <code>true</code> for success, <code>false</code> otherwise
1:7c33e9c:      */
1:7c33e9c:     public static boolean changeDirectoryToReadOnly( File directory )
1:7c33e9c:     {
1:7c33e9c:         if( null == directory )
4:7c33e9c:             return false;
2:7c33e9c:         final File sdirectory = directory;
1:7c33e9c: 
1:3f5c48a:         return AccessController.doPrivileged(
1:3f5c48a:             new java.security.PrivilegedAction<Boolean>() {
1:3f5c48a:                 public Boolean run() {
1:7c33e9c:                     // set fail to true to start with; unless it works, we
1:7c33e9c:                     // want to specifically set the value.
1:7c33e9c:                     boolean success = true;
1:7c33e9c:                     if( !sdirectory.isDirectory() )
1:7c33e9c:                         success = false;
2:7c33e9c:                     String[] list = sdirectory.list();
2:7c33e9c:                     // Some JVMs return null for File.list() when the directory is empty
1:7c33e9c:                     if( list != null )
1:7c33e9c:                     {
2:7c33e9c:                         for( int i = 0; i < list.length; i++ )
1:7c33e9c:                         {
1:7c33e9c:                             File entry = new File( sdirectory, list[i] );
1:7c33e9c:                             if( entry.isDirectory() )
1:7c33e9c:                             {
1:7c33e9c:                                 if( !changeDirectoryToReadOnly(entry) )
1:7c33e9c:                                     success = false;
1:7c33e9c:                             }
1:7c33e9c:                             else {
1:7c33e9c:                                 if( !entry.setReadOnly() )
1:7c33e9c:                                     success = false;
1:7c33e9c:                             }
1:7c33e9c:                         }
1:7c33e9c:                     }
1:0d6a26d:                     // Before Java 6 we cannot make the directory writable
1:0d6a26d:                     // again, which means we cannot delete the directory and
1:0d6a26d:                     // its content...
1:0d6a26d:                     //success &= sdirectory.setReadOnly();
1:3f5c48a:                     return success;
1:7c33e9c:                 }
1:7c33e9c:             });        
1:7c33e9c:     }
1:7c33e9c: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:     private static Test newCleanDatabase(BaseTestSuite s) {
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite readonly = new BaseTestSuite("OSReadOnly");
1:         BaseTestSuite suite = new BaseTestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("OSReadOnlyTest");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:2d7d37f
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileNotFoundException;
/////////////////////////////////////////////////////////////////////////
1:         if (!supportsSetReadOnly()) {
1:             // If we can modify files after File.setReadOnly() has been
1:             // called on them, the test database will not actually be
1:             // read-only, and the test will fail. Skip the test in that
1:             // case.
1:             alarm("Read-only files can be modified. Skipping OSReadOnlyTest.");
1:             return;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Check if {@code File.setReadOnly()} has any effect in this environment.
1:      * For example, if the test runs as a privileged user, it may be able
1:      * to modify a file even if it has been made read-only. If so, it doesn't
1:      * make any sense to run this test.
1:      *
1:      * @return {@code true} if {@code File.setReadOnly()} prevents file
1:      *   modifications; otherwise, {@code false}
1:      * @throws IOException if an unexpected error happens
1:      */
1:     private boolean supportsSetReadOnly() throws IOException {
1:         File tmp = PrivilegedFileOpsForTests.createTempFile(
1:                 "tmp", null, currentDirectory());
1:         PrivilegedFileOpsForTests.setReadOnly(tmp);
1:         FileOutputStream fs = null;
1:         try {
1:             fs = PrivilegedFileOpsForTests.getFileOutputStream(tmp);
1:             // Was able to open the file in read-write mode, so it's not
1:             // properly read-only.
1:             return false;
1:         } catch (FileNotFoundException fnf) {
1:             // Failed to open the file in read-write mode, so it seems like
1:             // it's read-only.
1:             return true;
1:         } finally {
1:             if (fs != null) {
1:                 fs.close();
1:             }
1:             PrivilegedFileOpsForTests.delete(tmp);
1:         }
1:     }
1: 
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
1:         return pdbName.substring(pdbName.lastIndexOf("oneuse"));
/////////////////////////////////////////////////////////////////////////
1:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:             public Void run() {
/////////////////////////////////////////////////////////////////////////
1:         return AccessController.doPrivileged(
1:             new java.security.PrivilegedAction<Boolean>() {
1:                 public Boolean run() {
/////////////////////////////////////////////////////////////////////////
1:                     return success;
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:243811f
/////////////////////////////////////////////////////////////////////////
1:                 if (!(sqle.getSQLState().equals("25502") || 
1:                         // on iseries / OS400 machines, when file/os 
1:                         // permissions are off, we may get error 40XD1 instead
1:                         sqle.getSQLState().equals("40XD1")))
1:                     fail("unexpected sqlstate; expected 25502 or 40XD1, got: " + sqle.getSQLState());
commit:7c33e9c
/////////////////////////////////////////////////////////////////////////
1: /* 
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.store.OSReadOnlyTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.store;
1: 
1: import java.io.File;
0: import java.io.FileInputStream;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.security.AccessController;
1: import java.sql.Connection;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import javax.sql.DataSource;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: public class OSReadOnlyTest extends BaseJDBCTestCase{
1: 
1:     public OSReadOnlyTest(String name) {
1:         super(name);
1:     }
1:     
0:     private static Test newCleanDatabase(TestSuite s) {
1:         return new CleanDatabaseTestSetup(s) {
1:         /**
1:          * Creates the database objects used in the test cases.
1:          *
1:          * @throws SQLException
1:          */
1:             /**
1:              * Creates the tables used in the test cases.
1:              * @exception SQLException if a database error occurs
1:              */
1:             protected void decorateSQL(Statement stmt) throws SQLException
1:             {
1:                 getConnection();
1: 
1:                 // create a table with some data
1:                 stmt.executeUpdate(
1:                     "CREATE TABLE foo (a int, b char(100))");
1:                 stmt.execute("insert into foo values (1, 'hello world')");
1:                 stmt.execute("insert into foo values (2, 'happy world')");
1:                 stmt.execute("insert into foo values (3, 'sad world')");
1:                 stmt.execute("insert into foo values (4, 'crazy world')");
1:                 for (int i=0 ; i<7 ; i++)
1:                     stmt.execute("insert into foo select * from foo");
1:                 stmt.execute("create index fooi on foo(a, b)");
1:             }
1:         };
1:     }
1: 
1:     protected static Test baseSuite(String name) 
1:     {
0:         TestSuite readonly = new TestSuite("OSReadOnly");
0:         TestSuite suite = new TestSuite(name);
1:         readonly.addTestSuite(OSReadOnlyTest.class);
1:         suite.addTest(TestConfiguration.singleUseDatabaseDecorator(newCleanDatabase(readonly)));
1:         
1:         return suite;
1:     }
1: 
1:     public static Test suite() 
1:     {
0:         TestSuite suite = new TestSuite("OSReadOnlyTest");
1:         suite.addTest(baseSuite("OSReadOnlyTest:embedded"));
1:         suite.addTest(TestConfiguration
1:             .clientServerDecorator(baseSuite("OSReadOnlyTest:client")));
1:         return suite;
1:     }
1:     
1:     /**
1:      * Test that if we make the files comprising the database read-only
1:      * on OS level, the database reacts as if it's in 'ReadOnly' mode
1:      */
1:     public void testOSReadOnly() throws Exception {
1:         // start with some simple checks
1:         setAutoCommit(false);
1:         Statement stmt = createStatement();
1:         JDBC.assertFullResultSet(stmt.executeQuery(
1:             "select count(*) from foo"), new String[][] {{"512"}});
1:         stmt.executeUpdate("delete from foo where a = 1");
1:         JDBC.assertFullResultSet(stmt.executeQuery(
1:             "select count(*) from foo"), new String[][] {{"384"}});
1:         rollback();
1:         JDBC.assertFullResultSet(stmt.executeQuery(
1:             "select count(*) from foo"), new String[][] {{"512"}});
1:         stmt.executeUpdate("insert into foo select * from foo where a = 1");
1:         JDBC.assertFullResultSet(stmt.executeQuery(
1:             "select count(*) from foo"), new String[][] {{"640"}});
1:         commit();
1:         stmt.executeUpdate("delete from foo where a = 1");
1:         JDBC.assertFullResultSet(stmt.executeQuery(
1:             "select count(*) from foo"), new String[][] {{"384"}});
1:         rollback();
1:         JDBC.assertFullResultSet(stmt.executeQuery(
1:             "select count(*) from foo"), new String[][] {{"640"}});
1:         setAutoCommit(false);
1:         
1:         TestConfiguration.getCurrent().shutdownDatabase();
1:         
1:         // so far, we were just playing. Now for the test.
1:         String phDbName = getPhysicalDbName();
1:         // copy the database to one called 'readOnly'
0:         copyDatabaseOnOS(phDbName, "readOnly");
1:         // change filePermissions on readOnly, to readonly.
1:         changeFilePermissions("readOnly");
1:         
1:         DataSource ds = JDBCDataSource.getDataSource();
1:         JDBCDataSource.setBeanProperty(ds, 
1:             "databaseName", "singleUse/readOnly");
1:         assertReadDB(ds);
1:         assertExpectedInsertBehaviour(ds, false, 10, "will fail");
1:         shutdownDB(ds);
1:         
1:         // copy the database to one called 'readWrite' 
1:         // this will have the default read/write permissions upon
1:         // copying
0:         copyDatabaseOnOS("readOnly", "readWrite");
1:         ds = JDBCDataSource.getDataSource();
1:         JDBCDataSource.setBeanProperty(ds, "databaseName", "singleUse/readWrite");
1:         assertReadDB(ds);
1:         assertExpectedInsertBehaviour(ds, true, 20, "will go in");
1:         shutdownDB(ds);
1:         
1:         // do it again...
0:         copyDatabaseOnOS("readWrite", "readOnly2");
1:         // change filePermissions on readOnly, to readonly.
1:         changeFilePermissions("readOnly2");
1:         
1:         ds = JDBCDataSource.getDataSource();
1:         JDBCDataSource.setBeanProperty(ds, 
1:             "databaseName", "singleUse/readOnly2");
1:         assertReadDB(ds);
1:         assertExpectedInsertBehaviour(ds, false, 30, "will also fail");
1:         shutdownDB(ds);
1:         
1:         // testharness will try to remove the original db; put it back
0:         copyDatabaseOnOS("readOnly2", phDbName);
1:     }
1:     
1:     /*
1:      * figure out the physical database name, we want to manipulate
1:      * the actual files on the OS.
1:      */
1:     private String getPhysicalDbName() {
1:         String pdbName =TestConfiguration.getCurrent().getJDBCUrl();
0:         if (pdbName != null)
0:             pdbName=pdbName.substring(pdbName.lastIndexOf("oneuse"),pdbName.length());
1:         else {
0:             // with JSR169, we don't *have* a protocol, and so, no url, and so
0:             // we'll have had a null.
0:             // But we know the name of the db is something like system/singleUse/oneuse#
0:             // So, let's see if we can look it up, if everything's been properly
0:             // cleaned, there should be just 1...
0:             pdbName = (String) AccessController.doPrivileged(new java.security.PrivilegedAction() {
0:                 String filesep = getSystemProperty("file.separator");
0:                 public Object run() {
0:                     File dbdir = new File("system" + filesep + "singleUse");
0:                     String[] list = dbdir.list();
1:                     // Some JVMs return null for File.list() when the directory is empty
0:                     if( list != null)
1:                     {
0:                         if(list.length > 1)
1:                         {
1:                             for( int i = 0; i < list.length; i++ )
1:                             {
0:                                 if(list[i].indexOf("oneuse")<0)
0:                                     continue;
0:                                 else
1:                                 {
0:                                     return list[i];
1:                                 }
1:                             }
0:                             // give up trying to be smart, assume it's 0
0:                             return "oneuse0";
1:                         }
0:                         else
0:                             return list[0];
1:                     }
1:                     return null;
1:                 }
1:             });
1:             
1:         }
0:         return pdbName;
1:     }
1:     
1:     private void shutdownDB(DataSource ds) throws SQLException {
1:         JDBCDataSource.setBeanProperty(
1:             ds, "ConnectionAttributes", "shutdown=true");
1:         try {
1:             ds.getConnection();
1:             fail("expected an sqlexception 08006");
1:         } catch (SQLException sqle) {
1:             assertSQLState("08006", sqle);
1:         }        
1:     }
1:     
1:     private void assertReadDB(DataSource ds) throws SQLException {
1:         Connection con = ds.getConnection();
1:         Statement stmt2 = con.createStatement();
1:         JDBC.assertFullResultSet(
1:             stmt2.executeQuery("select count(*) from foo where a=1"),
1:             new String [][] {{"256"}});
1:         JDBC.assertFullResultSet(
1:             stmt2.executeQuery("select count(*) from foo where a=2"),
1:             new String [][] {{"128"}});
1:         JDBC.assertFullResultSet(
1:             stmt2.executeQuery("select count(*) from foo where a=1 and b='hello world'"),
1:             new String [][] {{"256"}});
1:         stmt2.close();
1:         con.close();
1:     }
1:     
1:     private void assertExpectedInsertBehaviour(
1:             DataSource ds, boolean expectedSuccess, 
1:             int insertIntValue, String insertStringValue) 
1:     throws SQLException {
1:         Connection con = ds.getConnection();
1:         Statement stmt = con.createStatement();
1:         if (expectedSuccess)
1:         {
1:             stmt.executeUpdate("insert into foo values (" +
1:                 insertIntValue + ", '" + insertStringValue + "')");
1:             assertTrue(stmt.getUpdateCount() == 1);
1:             JDBC.assertFullResultSet(
1:                 stmt.executeQuery("select count(*) from foo where a=" +
1:                     insertIntValue), new String [][] {{"1"}});
1:         }
1:         else {
1:             try {
1:                 stmt.executeUpdate("insert into foo values (" +
1:                     insertIntValue + ", '" + insertStringValue + "')");
1:                 fail("expected an error indicating the db is readonly");
1:             } catch (SQLException sqle) {
0:                 assertSQLState("40XD1", sqle);
1:             }
1:         }
1:         stmt.close();
1:         con.close();
1:     }
1:     
0:     private void copyDatabaseOnOS(String fromwhere, String todir) {
0:         String from_dir;
0:         String to_dir;
1:         
0:         String filesep=getSystemProperty("file.separator");
1: 
0:         String testpath=new String( getSystemProperty("user.dir") + filesep +
0:             "system" + filesep + "singleUse" + filesep);
1: 
0:         from_dir = testpath + fromwhere;
0:         to_dir = testpath + todir;
1: 
0:         assertTrue("Failed to copy directory from " + from_dir + " to " + to_dir,
0:             (copyDirectory(from_dir, to_dir)));
0:         assertTrue("Failed to remove directory: " + from_dir,
0:             (removeTemporaryDirectory(from_dir)));
1:     }
1: 
1:     public void changeFilePermissions(String dir) {
0:         String filesep=getSystemProperty("file.separator");
0:         String dir_to_change = new String(getSystemProperty("user.dir") + filesep 
0:             + "system" + filesep + "singleUse" + filesep + dir);
1:         assertTrue("Failed to change files in " + dir_to_change + " to ReadOnly",
1:             changeDirectoryToReadOnly(dir_to_change));
1:     }
1:     
1:     /**
1:      * Change all of the files in a directory and its subdirectories
0:      * to read only (atleast not writeable, depending on system for execute
0:      * permission). 
0:      * @param directory the string representation of the directory
0:      * to start recursing from.
1:      * @return <code>true</code> for success, <code>false</code> otherwise
1:      */
0:     public static boolean changeDirectoryToReadOnly( String directory )
1:     {
0:         return changeDirectoryToReadOnly( new File(directory) );
1:     }
1: 
1:     /**
1:      * Change all of the files in a directory and its subdirectories
1:      * to read only.
1:      * @param directory the directory File handle to start recursing from.
1:      * @return <code>true</code> for success, <code>false</code> otherwise
1:      */
1:     public static boolean changeDirectoryToReadOnly( File directory )
1:     {
1:         if( null == directory )
1:             return false;
1:         final File sdirectory = directory;
1: 
0:         Boolean b = (Boolean)AccessController.doPrivileged(
0:             new java.security.PrivilegedAction() {
0:                 public Object run() {
1:                     // set fail to true to start with; unless it works, we
1:                     // want to specifically set the value.
1:                     boolean success = true;
1:                     if( !sdirectory.isDirectory() )
1:                         success = false;
1:                     String[] list = sdirectory.list();
1:                     // Some JVMs return null for File.list() when the directory is empty
1:                     if( list != null )
1:                     {
1:                         for( int i = 0; i < list.length; i++ )
1:                         {
1:                             File entry = new File( sdirectory, list[i] );
1:                             if( entry.isDirectory() )
1:                             {
1:                                 if( !changeDirectoryToReadOnly(entry) )
1:                                     success = false;
1:                             }
1:                             else {
1:                                 if( !entry.setReadOnly() )
1:                                     success = false;
1:                             }
1:                         }
1:                     }
0:                     return new Boolean(success);
1:                 }
1:             });        
0:         if (b.booleanValue())
1:         {
0:             return true;
1:         }
0:         else return false;
1:     }
1: 
1:     /**
0:         Remove a directory and all of its contents.
1: 
0:         The results of executing File.delete() on a File object
0:         that represents a directory seems to be platform
0:         dependent. This method removes the directory
0:         and all of its contents.
1: 
0:         @return true if the complete directory was removed, false if it could not be.
0:         If false is returned then some of the files in the directory may have been removed.
1:     */
0:     final private static boolean removeTemporaryDirectory(File directory) {
0:         //System.out.println("removeDirectory " + directory);
1: 
0:         if (directory == null)
1:             return false;
1:         final File sdirectory = directory;
1: 
0:         Boolean b = (Boolean)AccessController.doPrivileged(
0:             new java.security.PrivilegedAction() {
0:                 public Object run() {
0:                     if (!sdirectory.exists())
0:                         return new Boolean(true);
0:                     if (!sdirectory.isDirectory())
0:                         return new Boolean(false);
1:                     String[] list = sdirectory.list();
0:                     // Some JVMs return null for File.list() when the
0:                     // directory is empty.
0:                     if (list != null) {
0:                         for (int i = 0; i < list.length; i++) {
0:                             File entry = new File(sdirectory, list[i]);
0:                             if (entry.isDirectory())
1:                             {
0:                                 if (!removeTemporaryDirectory(entry))
0:                                     return new Boolean(false);
1:                             }
0:                             else
1:                             {
0:                                 if (!entry.delete())
0:                                     return new Boolean(false);
1:                             }
1:                         }
1:                     }
0:                     return new Boolean(sdirectory.delete());
1:                 }
1:             });
0:         if (b.booleanValue())
1:         {
0:             return true;
1:         }
0:         else return false;
1:     }
1: 
0:     public static boolean removeTemporaryDirectory(String directory)
1:     {
0:         return removeTemporaryDirectory(new File(directory));
1:     }
1: 
1:     /**
0:       Copy a directory and all of its contents.
1:       */
0:     private static boolean copyDirectory(File from, File to)
1:     {
0:         return copyDirectory(from, to, (byte[])null);
1:     }
1: 
0:     private static boolean copyDirectory(String from, String to)
1:     {
0:         return copyDirectory(new File(from), new File(to));
1:     }
1: 
0:     private static boolean copyDirectory(File from, File to, byte[] buffer)
1:     {
0:         if (from == null)
1:             return false;
0:         final File sfrom = from;
0:         final File sto = to;
0:         if (buffer == null)
0:             buffer = new byte[4*4096];
0:         final byte[] sbuffer = buffer;
1:         
0:         Boolean b = (Boolean)AccessController.doPrivileged(
0:             new java.security.PrivilegedAction() {
0:                 public Object run() {
0:                     if (!sfrom.exists() || !sfrom.isDirectory() || sto.exists() || !sto.mkdirs())  
1:                     {
0:                         //can't do basic stuff, returning fail from copydir method
0:                         return new Boolean(false);
1:                     }
1:                     else {
0:                         //basic stuff succeeded, incl. makind dirs, going on...
0:                         boolean success=true;
0:                         String[] list = sfrom.list();
1: 
0:                         // Some JVMs return null for File.list() when the
0:                         // directory is empty.
0:                         if (list != null) {
0:                             for (int i = 0; i < list.length; i++) {
0:                                 File entry = new File(sfrom, list[i]);
0:                                 if (entry.isDirectory())
1:                                 {
0:                                     success = copyDirectory(entry,new File(sto,list[i]),sbuffer);
1:                                 }
0:                                 else
1:                                 {
0:                                     success = copyFile(entry,new File(sto,list[i]),sbuffer);
1:                                 }
1:                             }
1:                         }
0:                         return new Boolean(success);
1:                     }
1:                 }
1:             });
0:         if (b.booleanValue())
1:         {
0:             return true;
1:         }
0:         else return false;
1:     }       
1: 
0:     public static boolean copyFile(File from, File to)
1:     {
0:         return copyFile(from, to, (byte[])null);
1:     }
1: 
0:     public static boolean copyFile(File from, File to, byte[] buf)
1:     {
0:         if (buf == null)
0:             buf = new byte[4096*4];
0:         //
0:         //      System.out.println("Copy file ("+from+","+to+")");
0:         FileInputStream from_s = null;
0:         FileOutputStream to_s = null;
1: 
1:         try {
0:             from_s = new FileInputStream(from);
0:             to_s = new FileOutputStream(to);
1: 
0:             for (int bytesRead = from_s.read(buf);
0:                  bytesRead != -1;
0:                  bytesRead = from_s.read(buf))
0:                 to_s.write(buf,0,bytesRead);
1: 
0:             from_s.close();
0:             from_s = null;
1: 
0:             to_s.getFD().sync();
0:             to_s.close();
0:             to_s = null;
1:         }
0:         catch (IOException ioe)
1:         {
1:             return false;
1:         }
0:         finally
1:         {
0:             if (from_s != null)
1:             {
0:                 try { from_s.close(); }
0:                 catch (IOException ioe) {}
1:             }
0:             if (to_s != null)
1:             {
0:                 try { to_s.close(); }
0:                 catch (IOException ioe) {}
1:             }
1:         }
0:         return true;
1:     }    
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:c7b3589
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
/////////////////////////////////////////////////////////////////////////
1:         moveDatabaseOnOS(phDbName, "readOnly");
/////////////////////////////////////////////////////////////////////////
1:         moveDatabaseOnOS("readOnly", "readWrite");
/////////////////////////////////////////////////////////////////////////
1:         moveDatabaseOnOS("readWrite", "readOnly2");
/////////////////////////////////////////////////////////////////////////
1:         moveDatabaseOnOS("readOnly2", phDbName);
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * Moves the database from one location to another location.
1:      *
1:      * @param fromwhere source directory
1:      * @param todir destination directory
1:      * @throws IOException if the copy fails
1:      */
1:     private void moveDatabaseOnOS(String fromwhere, String todir)
1:             throws IOException {
0: 
1:         PrivilegedFileOpsForTests.copy(from_dir, to_dir);
1:         assertDirectoryDeleted(from_dir);
/////////////////////////////////////////////////////////////////////////
commit:0d6a26d
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
0: /**
1:  * Simulates running Derby on a read-only media, and makes sure Derby gives a
1:  * reasonable error message when the user tries to insert data into the
1:  * read-only database.
0:  */
/////////////////////////////////////////////////////////////////////////
1:         createDummyLockFile("readOnly");
/////////////////////////////////////////////////////////////////////////
1:         createDummyLockFile("readOnly2");
/////////////////////////////////////////////////////////////////////////
0:                 assertSQLState("25502", sqle);
/////////////////////////////////////////////////////////////////////////
1:         File from_dir = constructDbPath(fromwhere);
1:         File to_dir = constructDbPath(todir);
0:     /**
1:      * Creates a dummy database lock file if one doesn't exist, and sets the
1:      * lock file to read-only.
1:      * <p>
1:      * This method is a work-around for the problem that Java cannot make a file
1:      * writable before Java 6.
1:      *
1:      * @param dbDir the database directory where the lock file belongs
0:      */
1:     private void createDummyLockFile(String dbDir) {
1:         final File f = new File(constructDbPath(dbDir), "db.lck");
0:         AccessController.doPrivileged(new PrivilegedAction() {
0: 
0:             public Object run() {
1:                 if (!f.exists()) {
0:                     try {
1:                         FileOutputStream fos = new FileOutputStream(f);
1:                         // Just write a dummy byte.
1:                         fos.write(12);
1:                         fos.close();
1:                     } catch (IOException fnfe) {
1:                         // Ignore
0:                     }
0:                 }
1:                 f.setReadOnly();
0:                 return null;
0:             }
0:         });
0:     }
0: 
1:         File dir_to_change = constructDbPath(dir);
0: 
1:      * Constructs the path to the database base directory.
1:      *
1:      * @param relDbDirName the database name (relative)
1:      * @return The path to the database.
1:     private File constructDbPath(String relDbDirName) {
1:         // Example: "readOnly" -> "<user.dir>/system/singleUse/readOnly"
1:         File f = new File(getSystemProperty("user.dir"), "system");
1:         f = new File(f, "singleUse");
1:         return new File(f, relDbDirName);
/////////////////////////////////////////////////////////////////////////
1:                     // Before Java 6 we cannot make the directory writable
1:                     // again, which means we cannot delete the directory and
1:                     // its content...
1:                     //success &= sdirectory.setReadOnly();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: }
============================================================================