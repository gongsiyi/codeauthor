1:2bc809f: /*
3:2bc809f: 
1:2bc809f:    Derby - Class org.apache.derbyTesting.unitTests.store.T_FileSystemData
1:2bc809f: 
1:c38b841:    Licensed to the Apache Software Foundation (ASF) under one or more
1:c38b841:    contributor license agreements.  See the NOTICE file distributed with
1:c38b841:    this work for additional information regarding copyright ownership.
1:c38b841:    The ASF licenses this file to You under the Apache License, Version 2.0
1:c38b841:    (the "License"); you may not use this file except in compliance with
1:c38b841:    the License.  You may obtain a copy of the License at
1:2bc809f: 
1:2bc809f:       http://www.apache.org/licenses/LICENSE-2.0
1:2bc809f: 
1:2bc809f:    Unless required by applicable law or agreed to in writing, software
1:2bc809f:    distributed under the License is distributed on an "AS IS" BASIS,
1:2bc809f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:2bc809f:    See the License for the specific language governing permissions and
1:2bc809f:    limitations under the License.
1:2bc809f: 
1:2bc809f:  */
1:2bc809f: 
1:2bc809f: package org.apache.derbyTesting.unitTests.store;
1:2bc809f: 
1:2bc809f: import org.apache.derby.impl.store.raw.data.*;
1:2bc809f: 
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_MultiThreadedIterations;
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.services.context.ContextService;
1:2bc809f: import org.apache.derby.iapi.services.context.ContextManager;
1:2bc809f: import org.apache.derby.iapi.services.locks.*;
1:2bc809f: import org.apache.derby.iapi.services.monitor.Monitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:2bc809f: import org.apache.derby.iapi.services.io.Storable;
1:2bc809f: import org.apache.derby.iapi.services.property.PropertyUtil;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.error.StandardException;
1:2bc809f: import org.apache.derby.iapi.store.raw.*;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
1:2bc809f: import org.apache.derby.iapi.store.raw.data.RawContainerHandle;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1:2bc809f: import org.apache.derby.iapi.reference.Property;
1:2bc809f: import java.io.*;
1:56c1dc2: import java.security.PrivilegedActionException;
1:56c1dc2: import java.security.PrivilegedExceptionAction;
1:a0dbbd7: import java.security.PrivilegedAction;
1:a0dbbd7: import java.security.AccessController;
1:2bc809f: import java.util.Properties;
1:2bc809f: /**
1:2bc809f: 	An Impl unittest for rawstore data that is based on the FileSystem
1:2bc809f: */
1:2bc809f: 
1:2bc809f: public class T_FileSystemData extends T_MultiThreadedIterations {
1:2bc809f: 
1:2bc809f: 	private static final String testService = "fileSystemDataTest";
1:2bc809f: 
1:2bc809f: 	static final String REC_001 = "McLaren";
1:2bc809f: 	static final String REC_002 = "Ferrari";
1:2bc809f: 	static final String REC_003 = "Benetton";
1:2bc809f: 	static final String REC_004 = "Prost";
1:2bc809f: 	static final String REC_005 = "Tyrell";
1:2bc809f: 	static final String REC_006 = "Derby, Natscape, Goatscape, the popular names";
1:2bc809f: 	static final String REC_007 = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz";
1:2bc809f: 
1:2bc809f: 	static final String SP1 = "savepoint1";
1:2bc809f: 	static final String SP2 = "savepoint2";
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	static RawStoreFactory	factory;
1:2bc809f: 	static LockFactory lf;
1:2bc809f: 	static long commonContainer = -1;
1:2bc809f: 
1:2bc809f: 	static boolean testRollback; // initialize in start
1:2bc809f: 	static final String TEST_ROLLBACK_OFF = "derby.RawStore.RollbackTestOff";
1:2bc809f: 
1:2bc809f: 	private static ContextService contextService;
1:2bc809f: 	private T_Util t_util;
1:2bc809f: 
1:2bc809f: 	public T_FileSystemData() 
1:2bc809f: 	{
1:2bc809f: 		super();
1:2bc809f: 	}
1:2bc809f: 
1:56c1dc2: 	/**
1:2bc809f: 	  @exception StandardException cannot startup the context service
1:2bc809f: 	 */
1:2bc809f: 	public void boot(boolean create, Properties startParams)
1:2bc809f: 		 throws StandardException
1:2bc809f: 	{
1:2bc809f: 		super.boot(create, startParams);
1:a0dbbd7: 		contextService = getContextService();
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	** Methods required by T_Generic
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 	protected String getModuleToTestProtocolName() {
1:2bc809f: 		return RawStoreFactory.MODULE;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Run the tests
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Unexpected behaviour from the API
1:2bc809f: 	 */
1:2bc809f: 	protected void setupTest() throws T_Fail 
1:2bc809f: 	{
1:2bc809f: 		String rollbackOff = PropertyUtil.getSystemProperty(TEST_ROLLBACK_OFF);
1:2bc809f: 		testRollback = !Boolean.valueOf(rollbackOff).booleanValue();
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		// don't automatic boot this service if it gets left around
1:2bc809f: 		if (startParams == null) {
1:2bc809f: 			startParams = new Properties();
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		// see if we are testing encryption
1:2bc809f: 		startParams = T_Util.setEncryptionParam(startParams);
1:2bc809f: 
1:2bc809f: 		startParams.put(Property.NO_AUTO_BOOT, Boolean.TRUE.toString());
1:2bc809f: 		// remove the service directory to ensure a clean run
1:2bc809f: 		startParams.put(Property.DELETE_ON_CREATE, Boolean.TRUE.toString());
1:2bc809f: 
1:2bc809f: 		try {
1:56c1dc2: 			factory = (RawStoreFactory) createPersistentService(getModuleToTestProtocolName(),
1:2bc809f: 								testService, startParams);
1:2bc809f: 			if (factory == null) {
1:2bc809f: 				throw T_Fail.testFailMsg(getModuleToTestProtocolName() + " service not started.");
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			lf = factory.getLockFactory();
1:2bc809f: 			if (lf == null) {
1:2bc809f: 				throw T_Fail.testFailMsg("LockFactory.MODULE not found");
1:2bc809f: 			}
1:2bc809f: 		} catch (StandardException mse) {
1:2bc809f: 			throw T_Fail.exceptionFail(mse);
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		t_util = new T_Util(factory, lf, contextService);
1:2bc809f: 		commonContainer = commonContainer();
1:2bc809f: 
1:2bc809f: 		return;
1:2bc809f: 	}
1:a0dbbd7: 
1:2bc809f: 
1:a0dbbd7: 	/**
1:2bc809f: 	 * T_MultiThreadedIteration method
1:2bc809f: 	 *
1:2bc809f: 	 * @exception T_Fail Unexpected behaviour from the API
1:2bc809f: 	 */
1:2bc809f: 	protected void joinSetupTest() throws T_Fail {
1:2bc809f: 
1:2bc809f: 		T_Fail.T_ASSERT(factory != null, "raw store factory not setup ");
1:2bc809f: 		T_Fail.T_ASSERT(contextService != null, "Context service not setup ");
1:2bc809f: 		T_Fail.T_ASSERT(commonContainer != -1, "common container not setup ");
1:2bc809f: 
1:2bc809f: 		t_util = new T_Util(factory, lf, contextService);
1:2bc809f: 
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	protected T_MultiThreadedIterations newTestObject() {
1:2bc809f: 		return new T_FileSystemData();
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 	  run the test
1:2bc809f: 
1:2bc809f: 	  @exception T_Fail Unexpected behaviour from the API
1:2bc809f: 	*/
1:2bc809f: 	protected void runTestSet() throws T_Fail {
1:2bc809f: 
1:2bc809f: 		// get a utility helper
1:2bc809f: 
1:2bc809f: 		ContextManager cm1 = contextService.newContextManager();
1:2bc809f: 		contextService.setCurrentContextManager(cm1);
1:2bc809f: 
1:2bc809f: 		try {
1:2bc809f: 
1:2bc809f: 			runCostEstimationTests();
1:2bc809f: 			runAllocationTests();
1:2bc809f: 
1:2bc809f: 		} catch (StandardException se) {
1:2bc809f: 
1:4c5c16b:             //Assume database is not active. DERBY-4856 thread dump
1:4c5c16b:             cm1.cleanupOnError(se, false);
1:2bc809f: 			throw T_Fail.exceptionFail(se);
1:2bc809f: 		}
1:2bc809f: 		finally {
1:2bc809f: 
1:2bc809f: 			contextService.resetCurrentContextManager(cm1);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * create a container that all threads can use
1:2bc809f: 	 */
1:2bc809f: 	private long commonContainer() throws T_Fail
1:2bc809f: 	{
1:2bc809f: 		ContextManager cm1 = contextService.newContextManager();
1:2bc809f: 		contextService.setCurrentContextManager(cm1);
1:2bc809f: 		long cid;
1:2bc809f: 
1:2bc809f: 		try {
1:2bc809f: 			Transaction t = t_util.t_startTransaction();
1:2bc809f: 			cid = t_util.t_addContainer(t, 0);
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 			t.close();
1:2bc809f: 		}
1:2bc809f: 		catch (StandardException se) {
1:2bc809f: 
1:4c5c16b:             //Assume database is not active. DERBY-4856 thread dump
1:4c5c16b:             cm1.cleanupOnError(se, false);
1:2bc809f: 			throw T_Fail.exceptionFail(se);
1:2bc809f: 		}
1:2bc809f: 		finally {
1:2bc809f: 			contextService.resetCurrentContextManager(cm1);
1:2bc809f: 		}
1:2bc809f: 		return cid;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	protected void runCostEstimationTests() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		CostEstimationTest1();
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	protected void runAllocationTests() throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		// don't run these for > 2 threads
1:2bc809f: 		if (threadNumber < 2)
1:2bc809f: 		{
1:2bc809f: 			AllocTest1();			// test remove and reuse of page
1:2bc809f: 			AllocTest2();			// test remove and drop and rollback of remove 
1:2bc809f: 			AllocTest3();			// test multiple alloc page
1:2bc809f: 			AllocTest4();			// test preallocation
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		// can't get this test to pass consistently because it depends on
1:2bc809f: 		// timing of the cache.
1:2bc809f: 		// AllocTest5();			// test gettting 1/2 filled page for insert
1:2bc809f: 
1:2bc809f: 		AllocMTest1(commonContainer); // test multi thread access to the same container
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		@exception T_Fail Unexpected behaviour from the API
1:2bc809f: 		@exception StandardException Standard Derby error policy
1:2bc809f: 	*/
1:2bc809f: 	protected void CostEstimationTest1() throws StandardException, T_Fail 
1:2bc809f: 	{
1:2bc809f: 		// getEstimatedRowCount(0), setEstimatedRowCount(long count, int flag),
1:2bc809f: 		// getEstimatedPageCount(int flag);
1:2bc809f: 
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 		long cid = t_util.t_addContainer(t, 0);
1:2bc809f: 		t_util.t_commit(t);
1:2bc809f: 
1:2bc809f: 		ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			int numRows = 10;
1:2bc809f: 			T_RawStoreRow row = new T_RawStoreRow(REC_001);
1:2bc809f: 			RecordHandle rh[] = new RecordHandle[numRows];
1:2bc809f: 
1:2bc809f: 			// insert numRows rows into container
1:2bc809f: 			for (int i = 0; i < numRows; i++)
1:2bc809f: 				rh[i] = t_util.t_insert(c, row);
1:2bc809f: 
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 
1:2bc809f: 			c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			if ((c.getEstimatedRowCount(0) != numRows) &&
1:2bc809f: 			    (c.getEstimatedRowCount(0) != (numRows - 1)))
1:2bc809f:             {
1:2bc809f:                 // due to timing, sometimes estimate row count is 9 rather than
1:2bc809f:                 // 10.
1:2bc809f: 
1:2bc809f: 				throw T_Fail.testFailMsg(
1:2bc809f:                     "expect estimated row count to be " + (numRows - 1) + 
1:2bc809f:                     " or " + numRows +
1:2bc809f:                          ", got " + c.getEstimatedRowCount(0));
1:2bc809f:             }
1:2bc809f: 
1:2bc809f: 			// now update them that cause overflowing - expect the same row count
1:2bc809f: 			T_RawStoreRow longRow = new T_RawStoreRow(REC_007);
1:2bc809f: 			for (int i = 0; i < numRows; i++)
1:2bc809f: 				t_util.t_update(c, rh[i], longRow);
1:2bc809f: 
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 
1:2bc809f: 			c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			if (c.getEstimatedRowCount(0) != numRows)
1:2bc809f: 
1:2bc809f: 			if ((c.getEstimatedRowCount(0) != numRows) &&
1:2bc809f: 			    (c.getEstimatedRowCount(0) != (numRows - 1)))
1:2bc809f:             {
1:2bc809f:                 // due to timing, sometimes estimate row count is 9 rather than
1:2bc809f:                 // 10.
1:2bc809f:                 
1:2bc809f: 				throw T_Fail.testFailMsg(
1:2bc809f:                     "expect after update same estimated row count, but it is not." +
1:2bc809f:                     "expect estimated row count to be " + (numRows - 1) + 
1:2bc809f:                     " or " + numRows + ", got " + c.getEstimatedRowCount(0));
1:2bc809f:             }
1:2bc809f: 
1:2bc809f: 			// now focibly set the row count
1:2bc809f: 			c.setEstimatedRowCount(2*numRows, 0);
1:2bc809f: 
1:2bc809f: 			if (c.getEstimatedRowCount(0) != 2*numRows)
1:2bc809f: 				throw T_Fail.testFailMsg("forcibly setting estimated row count doesn't seem to work");
1:2bc809f: 
1:2bc809f: 			// now purge some rows, this should alter the row count.
1:2bc809f: 			Page p = null;
1:2bc809f: 			long pnum = 0;
1:2bc809f: 			long purgedCount = 0;
1:2bc809f: 			for (p = c.getFirstPage(); p != null; p = c.getNextPage(pnum)) 
1:2bc809f: 			{
1:2bc809f: 				int rcount = p.recordCount()/3;
1:2bc809f: 				pnum = p.getPageNumber();
1:2bc809f: 
1:2bc809f: 				p.deleteAtSlot(0, true, (LogicalUndo)null);
1:2bc809f: 				p.purgeAtSlot(rcount, rcount, true); // purget the middle 1/3 of the page
1:2bc809f: 				purgedCount += rcount + 1;
1:2bc809f: 
1:2bc809f: 				p.unlatch();
1:2bc809f: 			}
1:2bc809f: 		
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 
1:2bc809f: 			c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			if (c.getEstimatedRowCount(0) != (2*numRows - purgedCount))
1:2bc809f: 				throw T_Fail.testFailMsg("expect " + (2*numRows-purgedCount) + 
1:2bc809f: 										 " after purge"); 
1:2bc809f: 		
1:2bc809f: 			// now get rid of some pages to alter the row count
1:2bc809f: 			REPORT("before page delete, estRC = " + (2*numRows) + " - " + purgedCount);
1:2bc809f: 
1:2bc809f: 			for (p = c.getFirstPage(); p != null; p = c.getNextPage(pnum))
1:2bc809f: 			{
1:2bc809f: 				pnum = p.getPageNumber();
1:2bc809f: 				if ((pnum%2) == 0)
1:2bc809f: 				{
1:2bc809f: 					purgedCount += p.nonDeletedRecordCount();
1:2bc809f: 					c.removePage(p);
1:2bc809f: 				}
1:2bc809f: 				else
1:2bc809f: 					p.unlatch();
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 
1:2bc809f: 			c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			if (c.getEstimatedRowCount(0) != (2*numRows - purgedCount))
1:2bc809f: 				throw T_Fail.testFailMsg("expect " + (2*numRows-purgedCount) + 
1:2bc809f: 										 " after page remove, got " + c.getEstimatedRowCount(0)); 
1:2bc809f: 
1:2bc809f: 			PASS("CostEstimationTest1");
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 			t.close();
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	protected void AllocTest1() throws StandardException, T_Fail 
1:2bc809f: 	{
1:2bc809f: 		/**
1:2bc809f: 		  test remove and reuse of page
1:2bc809f: 		*/
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			long cid = t_util.t_addContainer(t, 0);
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 
1:2bc809f: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 
1:2bc809f: 		// create 5 pages, each insert a row into it, then remove 2 of them
1:2bc809f: 
1:2bc809f: 			Page page1 = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1:2bc809f: 			long p1 = page1.getPageNumber();
1:2bc809f: 			T_RawStoreRow row1 = new T_RawStoreRow(REC_001);
1:2bc809f: 			t_util.t_insert(page1, row1);
1:2bc809f: 
1:2bc809f: 			Page page2 = t_util.t_addPage(c);
1:2bc809f: 			long p2 = page2.getPageNumber();
1:2bc809f: 			T_RawStoreRow row2 = new T_RawStoreRow(REC_002);
1:2bc809f: 			int rid2 = t_util.t_insert(page2, row2).getId();
1:2bc809f: 
1:2bc809f: 			Page page3 = t_util.t_addPage(c);
1:2bc809f: 			long p3 = page3.getPageNumber();
1:2bc809f: 			T_RawStoreRow row3 = new T_RawStoreRow(REC_003);
1:2bc809f: 			t_util.t_insert(page3, row3);
1:2bc809f: 
1:2bc809f: 			Page page4 = t_util.t_addPage(c);
1:2bc809f: 			long p4 = page4.getPageNumber();
1:2bc809f: 			T_RawStoreRow row4 = new T_RawStoreRow(REC_004);
1:2bc809f: 			int rid4 = t_util.t_insert(page4, row4).getId();
1:2bc809f: 
1:2bc809f: 			Page page5 = t_util.t_addPage(c);
1:2bc809f: 			long p5 = page5.getPageNumber();
1:2bc809f: 			T_RawStoreRow row5 = new T_RawStoreRow(REC_005);
1:2bc809f: 			t_util.t_insert(page5, row5);
1:2bc809f: 
1:2bc809f: 			t_util.t_removePage(c, page2);
1:2bc809f: 			t_util.t_removePage(c, page4);
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 
1:2bc809f: 		// now all the pages are unlatched
1:2bc809f: 		// pages 2, 4 has been removed, pages 1, 3, 5 has not
1:2bc809f: 		// make sure pages that are removed cannot be found again
1:2bc809f: 			c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 
1:2bc809f:             if (SanityManager.DEBUG)
1:2bc809f:                 SanityManager.DEBUG("SpaceTrace", "containeropened");
1:2bc809f: 
1:2bc809f: 			Page p = c.getFirstPage();
1:2bc809f: 			if (p == null)
1:2bc809f: 				throw T_Fail.testFailMsg("get first page failed: expect " + p1 + " got null");
1:2bc809f: 			if (p.getPageNumber() != p1)
1:2bc809f: 				throw T_Fail.testFailMsg("get first page failed: expect " + p1
1:2bc809f: 										 + " got " + p.getPageNumber());
1:2bc809f: 
1:2bc809f: 			t_util.t_commit(t);		
1:2bc809f: 
1:2bc809f: 		// closing the transaction many times to see if we can get the
1:2bc809f: 		// deallocated page to free
1:2bc809f: 
1:2bc809f: 			c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			p = c.getNextPage(p1);
1:2bc809f: 			if (p == null || p.getPageNumber() != p3)
1:2bc809f: 				throw T_Fail.testFailMsg("get next page failed");
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 
1:2bc809f: 			c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			p = c.getNextPage(p3);
1:2bc809f: 			if (p == null || p.getPageNumber() != p5)
1:2bc809f: 				throw T_Fail.testFailMsg("get next page failed");
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 		
1:2bc809f: 			c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			p = t_util.t_getLastPage(c);	// make sure it skips over p5
1:2bc809f: 			if (p == null || p.getPageNumber() != p5)
1:2bc809f: 				throw T_Fail.testFailMsg("getLastPage failed");
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 
1:2bc809f: 		// see if we can get any deallocated page back in 10 attempts
1:2bc809f: 		// of add page
1:2bc809f: 			int tries = 100;
1:2bc809f: 			T_RawStoreRow row6 = new T_RawStoreRow(REC_001);
1:2bc809f: 
1:2bc809f: 			long pnums[] = new long[tries];
1:2bc809f: 			int  rids[] = new int[tries];
1:2bc809f: 			pnums[0] = p2;			// pages 2 and 4 have been removed for a long time
1:2bc809f: 			rids[0] = rid2;
1:2bc809f: 			pnums[1] = p4;
1:2bc809f: 			rids[1] = rid4;
1:2bc809f: 
1:2bc809f: 			int match = -1;
1:2bc809f: 			int i;
1:2bc809f: 			for (i = 2 ; match < 0 && i < tries; i++)
1:2bc809f: 			{
1:2bc809f: 				c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 				p = t_util.t_addPage(c);
1:2bc809f: 				pnums[i] =  p.getPageNumber();
1:2bc809f: 
1:2bc809f: 				for (int j = 0; j < i-1; j++)
1:2bc809f: 				{
1:2bc809f: 					if (pnums[j] == pnums[i])
1:2bc809f: 					{
1:2bc809f: 						match = j;
1:2bc809f: 						break;
1:2bc809f: 					}
1:2bc809f: 				}
1:2bc809f: 
1:2bc809f: 				if (match >= 0)
1:2bc809f: 				{
1:2bc809f: 					// p is a reused one, make sure it is empty
1:2bc809f: 					t_util.t_checkEmptyPage(p);
1:2bc809f: 					RecordHandle rh = t_util.t_insert(p, row6);
1:2bc809f: 					if (rh.getId() == rids[match])
1:2bc809f: 						throw T_Fail.testFailMsg("reused page recordId is not preserved");
1:2bc809f: 					break;
1:2bc809f: 				}
1:2bc809f: 				else
1:2bc809f: 					rids[i] = t_util.t_insert(p, row6).getId();
1:2bc809f: 
1:2bc809f: 				t_util.t_removePage(c, p);
1:2bc809f: 				t_util.t_commit(t);
1:2bc809f: 			}
1:2bc809f: 			t_util.t_dropContainer(t, 0, cid); // cleanup
1:2bc809f: 
1:2bc809f: 			if (match >= 0)
1:2bc809f: 				PASS("AllocTest1 success in " + i + " tries");
1:2bc809f: 			else
1:2bc809f: 				REPORT("AllocTest1 Not successful in " + i + 
1:2bc809f: 					   " tries.  This is a timing depenedent test so this is not necessarily an indication of failure.");
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 			t.close();
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	protected void AllocTest2() throws StandardException, T_Fail 
1:2bc809f: 	{
1:2bc809f: 		/**
1:2bc809f: 		  More Test remove and reuse of page
1:2bc809f: 		*/
1:2bc809f: 
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 		int numpages = 30;
1:2bc809f: 
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			long cid = t_util.t_addContainer(t, 0);
1:2bc809f: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 
1:2bc809f: 			Page[] page = new Page[numpages];
1:2bc809f: 
1:2bc809f: 			for (int i = 0; i < numpages; i++)
1:2bc809f: 			{
1:2bc809f: 				page[i] = t_util.t_addPage(c);
1:2bc809f: 				t_util.t_removePage(c, page[i]);
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			// make sure a dropped container does not cause problem for page
1:2bc809f: 			// that's been removed
1:2bc809f: 			t_util.t_dropContainer(t, 0, cid); 
1:2bc809f: 
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 
1:2bc809f: 			if (testRollback)
1:2bc809f: 			{
1:2bc809f: 				cid = t_util.t_addContainer(t, 0);
1:2bc809f: 				c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 
1:2bc809f: 				for (int i = 0; i < numpages; i++)
1:2bc809f: 				{
1:2bc809f: 					page[i] = t_util.t_addPage(c);
1:2bc809f: 					t_util.t_removePage(c, page[i]);
1:2bc809f: 				}
1:2bc809f: 
1:2bc809f: 				t_util.t_abort(t);
1:2bc809f: 			}
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 			t.close();
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		PASS("AllocTest2");
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	protected void AllocTest3() throws StandardException, T_Fail 
1:2bc809f: 	{
1:2bc809f: 		/* test multiple alloc pages */
1:2bc809f: 
1:2bc809f: 		if (!SanityManager.DEBUG)
1:2bc809f: 		{
1:2bc809f: 			REPORT("allocTest3 cannot be run on an insane server");
1:2bc809f: 			return;
1:2bc809f: 		}
1:2bc809f:         else
1:2bc809f:         {
1:2bc809f:             SanityManager.DEBUG_SET(AllocPage.TEST_MULTIPLE_ALLOC_PAGE);
1:2bc809f: 
1:2bc809f:             Transaction t = t_util.t_startTransaction();
1:2bc809f: 
1:2bc809f:             try
1:2bc809f:             {
1:2bc809f:                 long cid = t_util.t_addContainer(t, 0);
1:2bc809f:                 t_util.t_commit(t);
1:2bc809f: 
1:2bc809f:                 ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 
1:2bc809f:                 T_RawStoreRow row = new T_RawStoreRow(REC_001);
1:2bc809f:                 int numrows = 10; // create 10 pages with 1 row each
1:2bc809f:                 
1:2bc809f:                 String threadName = Thread.currentThread().getName();
1:2bc809f: 
1:2bc809f:                 Page page;
1:2bc809f:                 for (int i = 0; i < numrows; i++)
1:2bc809f:                 {
1:2bc809f:                     page = t_util.t_addPage(c);
1:2bc809f:                     t_util.t_insert(page, row);
1:2bc809f:                     page.unlatch();
1:2bc809f:                 }
1:2bc809f: 
1:2bc809f:                 int checkrows = 0;
1:2bc809f:                 long pnum;
1:2bc809f:                 for (page = c.getFirstPage();
1:2bc809f:                      page != null;
1:2bc809f:                      page = c.getNextPage(pnum))
1:2bc809f:                 {
1:2bc809f:                     pnum = page.getPageNumber();
1:2bc809f:                     if (page.recordCount() > 0)
1:2bc809f:                     {
1:2bc809f:                         t_util.t_checkFetchFirst(page, REC_001);
1:2bc809f:                         checkrows++;
1:2bc809f:                     }
1:2bc809f:                     page.unlatch();
1:2bc809f:                 }
1:2bc809f:                 if (checkrows != numrows)
1:2bc809f:                     throw T_Fail.testFailMsg("number of rows differ");
1:2bc809f: 
1:2bc809f:                 t.setSavePoint(SP1, null);
1:2bc809f: 
1:2bc809f:                 // now remove 1/2 of the pages and check results
1:2bc809f:                 int removedPages = 0;
1:2bc809f:                 for (page = c.getFirstPage();
1:2bc809f:                      page != null;
1:2bc809f:                      page = c.getNextPage(pnum))
1:2bc809f:                 {
1:2bc809f:                     pnum = page.getPageNumber();
1:2bc809f:                     if ((pnum % 2) == 0)
1:2bc809f:                     {
1:2bc809f:                         t_util.t_removePage(c, page);
1:2bc809f:                         removedPages++;
1:2bc809f:                     }
1:2bc809f:                     else
1:2bc809f:                         page.unlatch();
1:2bc809f:                 }
1:2bc809f: 
1:2bc809f:                 checkrows = 0;
1:2bc809f:                 for (page = c.getFirstPage();
1:2bc809f:                      page != null;
1:2bc809f:                      page = c.getNextPage(pnum))
1:2bc809f:                 {
1:2bc809f:                     pnum = page.getPageNumber();
1:2bc809f:                     if (page.recordCount() > 0)
1:2bc809f:                     {
1:2bc809f:                         t_util.t_checkFetchFirst(page, REC_001);
1:2bc809f:                         checkrows++;
1:2bc809f:                     }
1:2bc809f:                     page.unlatch();
1:2bc809f:                 }
1:2bc809f:                 if (checkrows != numrows - removedPages)
1:2bc809f:                     throw T_Fail.testFailMsg("number of rows differ");
1:2bc809f: 
1:2bc809f:                 // remove every page backwards
1:2bc809f:                 long lastpage = ContainerHandle.INVALID_PAGE_NUMBER;
1:2bc809f:                 while((page = t_util.t_getLastPage(c)) != null)	// remove the last page
1:2bc809f:                 {
1:2bc809f:                     if (lastpage == page.getPageNumber())
1:2bc809f:                         throw T_Fail.testFailMsg("got a removed last page");
1:2bc809f: 
1:2bc809f:                     lastpage = page.getPageNumber();
1:2bc809f:                     t_util.t_removePage(c, page);
1:2bc809f:                 }
1:2bc809f: 
1:2bc809f:                 if (c.getFirstPage() != null)
1:2bc809f:                     throw T_Fail.testFailMsg("get last page returns null but get fisrt page retuns a page");
1:2bc809f: 
1:2bc809f:                 t.rollbackToSavePoint(SP1, null);	// roll back removes
1:2bc809f:                 c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 
1:2bc809f:                 checkrows = 0;
1:2bc809f:                 for (page = c.getFirstPage();
1:2bc809f:                      page != null;
1:2bc809f:                      page = c.getNextPage(pnum))
1:2bc809f:                 {
1:2bc809f:                     pnum = page.getPageNumber();
1:2bc809f:                     if (page.recordCount() > 0)
1:2bc809f:                     {
1:2bc809f:                         t_util.t_checkFetchFirst(page, REC_001);
1:2bc809f:                         checkrows++;
1:2bc809f:                     }
1:2bc809f:                     page.unlatch();
1:2bc809f:                 }
1:2bc809f:                 if (checkrows != numrows)
1:2bc809f:                     throw T_Fail.testFailMsg(threadName + "number of rows differ expect " +
1:2bc809f:                                              numrows + " got " + checkrows);
1:2bc809f: 
1:2bc809f: 
1:2bc809f:                 t_util.t_abort(t);	// abort the whole thing, no rows left
1:2bc809f:                 c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 
1:2bc809f:                 int countPages = 0;
1:2bc809f:                 for (page = c.getFirstPage();
1:2bc809f:                      page != null;
1:2bc809f:                      page = c.getNextPage(pnum))
1:2bc809f:                 {
1:2bc809f:                     countPages++;
1:2bc809f:                     pnum = page.getPageNumber();
1:2bc809f:                     if (page.nonDeletedRecordCount() > 0)
1:2bc809f:                     {
1:2bc809f:                         throw T_Fail.testFailMsg("failed to remove everything " +
1:2bc809f:                                                  page.nonDeletedRecordCount() + 
1:2bc809f:                                                  " rows left on page " + pnum);
1:2bc809f:                     }
1:2bc809f:                     page.unlatch();
1:2bc809f:                 }			
1:2bc809f: 
1:2bc809f:                 if (countPages < numrows)
1:2bc809f:                     throw T_Fail.testFailMsg("rollback of user transaction should not remove allocated pages");
1:2bc809f: 
1:2bc809f:                 t_util.t_dropContainer(t, 0, cid); 
1:2bc809f: 
1:2bc809f:             }
1:2bc809f:             finally
1:2bc809f:             {
1:2bc809f:                 SanityManager.DEBUG_CLEAR(AllocPage.TEST_MULTIPLE_ALLOC_PAGE);
1:2bc809f:                 t_util.t_commit(t);
1:2bc809f:                 t.close();
1:2bc809f:             }
1:2bc809f:             PASS("AllocTest3");
1:2bc809f:         }
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	protected void AllocTest4() throws StandardException, T_Fail
1:2bc809f: 	{
1:2bc809f: 		if (!SanityManager.DEBUG)
1:2bc809f: 		{
1:2bc809f: 			REPORT("allocTest3 cannot be run on an insane server");
1:2bc809f: 			return;
1:2bc809f: 		}
1:2bc809f:         else
1:2bc809f:         {
1:2bc809f: 
1:2bc809f:             SanityManager.DEBUG_SET(AllocPage.TEST_MULTIPLE_ALLOC_PAGE);
1:2bc809f:             Transaction t = t_util.t_startTransaction();
1:2bc809f: 
1:2bc809f:             try
1:2bc809f:             {
1:2bc809f:                 ////////////////////////////////////////////////////////
1:2bc809f:                 // first test preallocation large table
1:2bc809f:                 ////////////////////////////////////////////////////////
1:2bc809f:                 Properties tableProperties = new Properties();
1:2bc809f:                 tableProperties.put(Property.PAGE_SIZE_PARAMETER, Integer.toString(1024));
1:2bc809f:                 tableProperties.put(RawStoreFactory.CONTAINER_INITIAL_PAGES, Integer.toString(100));
1:2bc809f: 
1:2bc809f:                 long cid1 = 
1:2bc809f:                     t.addContainer(
1:2bc809f:                         0, ContainerHandle.DEFAULT_ASSIGN_ID, 
1:2bc809f:                         ContainerHandle.MODE_DEFAULT, tableProperties, 0);
1:2bc809f: 
1:2bc809f:                 if (cid1 < 0)
1:2bc809f:                     throw T_Fail.testFailMsg("addContainer");
1:2bc809f: 
1:2bc809f:                 ContainerHandle c1 = t_util.t_openContainer(t, 0, cid1, true);
1:2bc809f: 
1:2bc809f:                 Page p1 = c1.getFirstPage();
1:2bc809f:                 if (p1.getPageNumber() != ContainerHandle.FIRST_PAGE_NUMBER)
1:2bc809f:                     throw T_Fail.testFailMsg("expect first page to have FIRST_PAGE_NUMBER");
1:2bc809f:                 p1.unlatch();
1:2bc809f: 
1:2bc809f:                 if (c1.getNextPage(ContainerHandle.FIRST_PAGE_NUMBER) != null)
1:2bc809f:                     throw T_Fail.testFailMsg("expect to have only 1 page allocated");
1:2bc809f: 
1:2bc809f:                 t_util.t_commit(t);
1:2bc809f: 
1:2bc809f:                 REPORT("AllocTest4 - create preallocated container " + cid1);
1:2bc809f: 
1:2bc809f:                 ////////////////////////////////////////////////////////
1:2bc809f:                 // next test special addpage interface
1:2bc809f:                 ////////////////////////////////////////////////////////
1:2bc809f:                 long cid2 = t_util.t_addContainer(t, 0, 1024, 0, 1, false);
1:2bc809f:                 t_util.t_commit(t);
1:2bc809f: 
1:2bc809f:                 ContainerHandle c2 = t_util.t_openContainer(t, 0, cid2, true);
1:2bc809f: 
1:2bc809f:                 // add page for bulk load
1:2bc809f:                 p1 = c2.addPage(ContainerHandle.ADD_PAGE_BULK);	
1:2bc809f:                 long pnum1 = p1.getPageNumber();
1:2bc809f:                 p1.unlatch();
1:2bc809f: 
1:2bc809f:                 // since the interface does not guarentee that anything special will
1:2bc809f:                 // actually happen, can't really test that. Just make sure that
1:2bc809f:                 // everything else works
1:2bc809f:                 Page p2 = c2.addPage();
1:2bc809f:                 long pnum2 = p2.getPageNumber();
1:2bc809f:                 p2.unlatch();
1:2bc809f: 
1:2bc809f:                 Page p3 = c2.addPage(ContainerHandle.ADD_PAGE_BULK);	
1:2bc809f:                 long pnum3 = p3.getPageNumber();
1:2bc809f:                 p3.unlatch();
1:2bc809f: 
1:2bc809f:                 Page p = c2.getFirstPage(); // this is the first page that came with the
1:2bc809f:                                        // container when it was created
1:2bc809f: 
1:2bc809f:                 try
1:2bc809f:                 {
1:2bc809f:                     long pnum0 = p.getPageNumber();
1:2bc809f:                     p.unlatch();
1:2bc809f:                     p = c2.getNextPage(pnum0);
1:2bc809f:                     if (p.getPageNumber() != pnum1)
1:2bc809f:                         throw T_Fail.testFailMsg("expected pagenum " + pnum1 + " got " + p.getPageNumber());
1:2bc809f:                     p.unlatch();
1:2bc809f:                     p = null;
1:2bc809f: 
1:2bc809f:                     p = c2.getNextPage(pnum1);
1:2bc809f:                     if (p.getPageNumber() != pnum2)
1:2bc809f:                         throw T_Fail.testFailMsg("expected pagenum " + pnum2 + " got " + p.getPageNumber());
1:2bc809f:                     p.unlatch();
1:2bc809f:                     p = null;
1:2bc809f: 
1:2bc809f:                     p = c2.getNextPage(pnum2);
1:2bc809f:                     if (p.getPageNumber() != pnum3)
1:2bc809f:                         throw T_Fail.testFailMsg("expected pagenum " + pnum3 + " got " + p.getPageNumber());
1:2bc809f:                     p.unlatch();
1:2bc809f:                     p = null;
1:2bc809f: 
1:2bc809f:                     p = c2.getNextPage(pnum3);
1:2bc809f:                     if (p != null)
1:2bc809f:                         throw T_Fail.testFailMsg("expected null page after " + pnum3 +
1:2bc809f:                                              " got " + p.getPageNumber());
1:2bc809f: 
1:2bc809f:                     // make sure rollback is unaffected
1:2bc809f:                     if (testRollback)
1:2bc809f:                     {
1:2bc809f:                         t_util.t_abort(t);
1:2bc809f:                         c2 = t_util.t_openContainer(t, 0, cid2, true);
1:2bc809f:                         p = t_util.t_getPage(c2, pnum0);
1:2bc809f:                         t_util.t_checkEmptyPage(p);
1:2bc809f:                         p.unlatch();
1:2bc809f:                         p = null;
1:2bc809f:                 
1:2bc809f:                         p = t_util.t_getPage(c2, pnum1);
1:2bc809f:                         t_util.t_checkEmptyPage(p);
1:2bc809f:                         p.unlatch();
1:2bc809f:                         p = null;
1:2bc809f: 
1:2bc809f:                         p = t_util.t_getPage(c2, pnum2);
1:2bc809f:                         t_util.t_checkEmptyPage(p);
1:2bc809f:                         p.unlatch();
1:2bc809f:                         p = null;
1:2bc809f: 
1:2bc809f:                         p = t_util.t_getPage(c2, pnum3);
1:2bc809f:                         t_util.t_checkEmptyPage(p);
1:2bc809f:                         p.unlatch();
1:2bc809f:                         p = null;
1:2bc809f: 
1:2bc809f:                         p = t_util.t_getLastPage(c2);
1:2bc809f:                         if (p.getPageNumber() != pnum3)
1:2bc809f:                             throw T_Fail.testFailMsg("expect last page to be " + pnum3
1:2bc809f:                                                  + " got " + p.getPageNumber());
1:2bc809f:                         p.unlatch();
1:2bc809f:                         p = null;
1:2bc809f:                     }
1:2bc809f:                 }
1:2bc809f:                 finally
1:2bc809f:                 {
1:2bc809f:                     if (p != null)
1:2bc809f:                         p.unlatch();
1:2bc809f:                     p = null;
1:2bc809f:                 }
1:2bc809f:                 REPORT("AllocTest4 - special addPage interface " + cid2);
1:2bc809f: 
1:2bc809f: 
1:2bc809f:                 ////////////////////////////////////////////////////////
1:2bc809f:                 // next test preallocate interface
1:2bc809f:                 ////////////////////////////////////////////////////////			
1:2bc809f:                 long cid3 = t_util.t_addContainer(t, 0, 1024);
1:2bc809f:                 ContainerHandle c3 = t_util.t_openContainer(t, 0, cid3, true);
1:2bc809f: 
1:2bc809f:                 // now preallocate 10 pages
1:2bc809f:                 c3.preAllocate(10);
1:2bc809f: 
1:2bc809f:                 p1 = c3.getFirstPage();
1:2bc809f:                 if (p1.getPageNumber() != ContainerHandle.FIRST_PAGE_NUMBER)
1:2bc809f:                     throw T_Fail.testFailMsg("expect first page to have FIRST_PAGE_NUMBER");
1:2bc809f:                 p1.unlatch();
1:2bc809f: 
1:2bc809f:                 if (c3.getNextPage(ContainerHandle.FIRST_PAGE_NUMBER) != null)
1:2bc809f:                     throw T_Fail.testFailMsg("expect to have only 1 page allocated");
1:2bc809f: 
1:2bc809f:                 REPORT("AllocTest4 - preallocate interface " + cid3);
1:2bc809f: 
1:2bc809f:                 PASS("AllocTest4 ");
1:2bc809f: 
1:2bc809f:             }
1:2bc809f:             finally
1:2bc809f:             {
1:2bc809f:                 SanityManager.DEBUG_CLEAR(AllocPage.TEST_MULTIPLE_ALLOC_PAGE);
1:2bc809f:                 t_util.t_commit(t);
1:2bc809f:                 t.close();
1:2bc809f:             }
1:2bc809f:         }
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	protected void AllocTest5() throws StandardException, T_Fail
1:2bc809f: 	{
1:2bc809f: 		// first create 10 1/2 filled pages with various degree of fillness
1:2bc809f: 		Transaction t = t_util.t_startTransaction();
1:2bc809f: 
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			long cid = t_util.t_addContainer(t, 0, 1024, 0, 90, false);
1:2bc809f: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 			Page p;
1:2bc809f: 
1:2bc809f: 			// the number of rows that is expected to fit into one page
1:2bc809f: 			// secret raw store calculation for 1 column rows
1:2bc809f: 			int numRows = (1024-60)/(95+8);
1:2bc809f: 
1:2bc809f: 			T_RawStoreRow rows[] = new T_RawStoreRow[numRows];
1:2bc809f: 
1:2bc809f: 			for (int j = 0; j < numRows; j++)
1:2bc809f: 				rows[j] = new T_RawStoreRow("row " + j);
1:2bc809f: 
1:2bc809f: 			for (int i = 0; i < numRows; i++)
1:2bc809f: 			{
1:2bc809f: 				p = t_util.t_addPage(c);
1:2bc809f: 
1:2bc809f: 				// validate allocation cache by getting the first page
1:2bc809f: 				t_util.t_getPage(c, 1).unlatch();
1:2bc809f: 
1:2bc809f: 				// insert different number of rows into these pages
1:2bc809f: 				for (int j = 0; j <= i; j++)
1:2bc809f: 				{
1:2bc809f: 					if (t_util.t_insert(p, rows[j]) == null)
1:2bc809f: 						throw T_Fail.testFailMsg("failed to insert " + (j+1) +
1:2bc809f: 												 " rows into page " + p);
1:2bc809f: 				}
1:2bc809f: 
1:2bc809f: 				p.unlatch();
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			// page 1 has 0 row
1:2bc809f: 			// page 2 has 1 row
1:2bc809f: 			// page 3 has 2 rows
1:2bc809f: 			// page 4 has 3 rows
1:2bc809f: 			// page 5 has 4 rows
1:2bc809f: 			// page 6 has 5 rows (filled)
1:2bc809f: 			// page 7 has 6 rows (filled)
1:2bc809f: 			// page 8 has 7 rows (filled)
1:2bc809f: 			// page 9 has 8 rows (filled)
1:2bc809f: 			// page 10 has 9 rows (filled)
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 			// these pages should be accounted for correctly because each
1:2bc809f: 			// subsequent page has > 1/8 for all the records in the container
1:2bc809f: 
1:2bc809f: 			// now go thru and use up all the space
1:2bc809f: 			p =  c.getPageForInsert(0);
1:2bc809f: 			if (p != null)
1:2bc809f: 				throw T_Fail.testFailMsg("Expect last page to be full");
1:2bc809f: 
1:2bc809f: 			// now go thru and use up all the space - since we skipped page 1
1:2bc809f: 			// on the first loop, it won't know it is a 1/2 filled page.
1:2bc809f: 			for (int i = 2; i < 6; i++)
1:2bc809f: 			{
1:2bc809f: 				p = c.getPageForInsert(ContainerHandle.GET_PAGE_UNFILLED);
1:2bc809f: 				if (p == null)
1:2bc809f: 					throw T_Fail.testFailMsg("Expect next unfilled page to be " + i);
1:2bc809f: 
1:2bc809f: 				if (p.getPageNumber() != i)
1:2bc809f: 					throw T_Fail.testFailMsg("Expect next unfilled page to be "
1:2bc809f: 											 + i + ", it is " + p.getPageNumber());
1:2bc809f: 
1:2bc809f: 				t_util.t_insert(p, rows[i]);
1:2bc809f: 				p.unlatch();
1:2bc809f: 
1:2bc809f: 				// we should keep getting the same page back until it is full
1:2bc809f: 				while ((p = c.getPageForInsert(0)) != null)
1:2bc809f: 				{
1:2bc809f: 					if (p.getPageNumber() != i)
1:2bc809f: 						throw T_Fail.testFailMsg("Don't expect page number to change from " +
1:2bc809f: 												 i + " to " + p.getPageNumber());
1:2bc809f: 					t_util.t_insert(p, rows[i]);
1:2bc809f: 					p.unlatch();
1:2bc809f: 				}
1:2bc809f: 
1:2bc809f: 			}
1:2bc809f: 		
1:2bc809f: 			p = c.getPageForInsert(ContainerHandle.GET_PAGE_UNFILLED);
1:2bc809f: 			if (p != null)
1:2bc809f: 				throw T_Fail.testFailMsg("don't expect any more pages to be found");
1:2bc809f: 
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			t_util.t_commit(t);
1:2bc809f: 			t.close();
1:2bc809f: 		}
1:2bc809f: 		PASS("AllocTest5 ");
1:2bc809f: 
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * MT tests on  the same container
1:2bc809f: 	 */
1:2bc809f: 	protected void AllocMTest1(long cid) throws StandardException, T_Fail 
1:2bc809f: 	{
1:2bc809f:         if (SanityManager.DEBUG)
1:2bc809f:         {
1:2bc809f:             SanityManager.DEBUG_SET(AllocPage.TEST_MULTIPLE_ALLOC_PAGE);
1:2bc809f: 
1:2bc809f:             // each thread will add N pages and remove N pages and still finds
1:2bc809f:             // its own pages.  Do that serveral times.
1:2bc809f:             int N = 20;
1:2bc809f: 
1:2bc809f:             RecordHandle rh[] = new RecordHandle[N];
1:2bc809f: 
1:2bc809f:             Transaction t = t_util.t_startTransaction();
1:2bc809f: 
1:2bc809f:             try
1:2bc809f:             {
1:2bc809f:                 T_RawStoreRow row = new T_RawStoreRow(REC_002);
1:2bc809f:                 ContainerHandle c;
1:2bc809f:                 Page p;
1:2bc809f: 
1:2bc809f:                 for (int iteration = 0; iteration < 5; iteration++)
1:2bc809f:                 {
1:2bc809f:                     for (int i = 0; i < N; i++)
1:2bc809f:                     {
1:2bc809f:                         c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f: 
1:2bc809f:                         p = t_util.t_addPage(c);
1:2bc809f:                         rh[i] = t_util.t_insert(p, row);
1:2bc809f:                         p.unlatch();
1:2bc809f: 
1:2bc809f:                         t_util.t_commit(t);
1:2bc809f:                     }
1:2bc809f: 
1:2bc809f:                     for (int i = 0; i < N; i++)
1:2bc809f:                     {
1:2bc809f:                         c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f:                         t_util.t_checkFetch(c, rh[i], REC_002);
1:2bc809f: 
1:2bc809f:                         t.setSavePoint(SP1, null);
1:2bc809f: 
1:2bc809f:                         p = t_util.t_getPage(c, rh[i].getPageNumber());
1:2bc809f:                         t_util.t_removePage(c, p);
1:2bc809f: 
1:2bc809f:                         if ((iteration%3) == 1)
1:2bc809f:                         {
1:2bc809f:                             t.rollbackToSavePoint(SP1, null);
1:2bc809f:                         }
1:2bc809f: 
1:2bc809f:                         // sometimes commit sometimes abort
1:2bc809f:                         if (iteration % 2 == 0)
1:2bc809f:                             t_util.t_abort(t);
1:2bc809f:                         else
1:2bc809f:                             t_util.t_commit(t);
1:2bc809f:                     }
1:2bc809f: 
1:2bc809f:                     // if I aborted, remove them now
1:2bc809f:                     if ((iteration % 2) == 0 ||
1:2bc809f:                         (iteration % 3) == 1)
1:2bc809f:                     {
1:2bc809f:                         for (int i = 0; i < N; i++)
1:2bc809f:                         {
1:2bc809f:                             c = t_util.t_openContainer(t, 0, cid, true);
1:2bc809f:                             t_util.t_checkFetch(c, rh[i], REC_002);
1:2bc809f: 
1:2bc809f:                             p = t_util.t_getPage(c, rh[i].getPageNumber());
1:2bc809f:                             t_util.t_removePage(c, p);
1:2bc809f:                             t_util.t_commit(t);
1:2bc809f:                         }
1:2bc809f:                     }
1:2bc809f: 
1:2bc809f:                     // at any given time, there should be <= (N*numthread)+1 pages
1:2bc809f:                     int max = (N*getNumThreads())+1;
1:2bc809f: 
1:2bc809f:                     c = t_util.t_openContainer(t, 0, cid, false);
1:2bc809f:                     long pnum = 0;
1:2bc809f:                     int countPages = 0;
1:2bc809f: 
1:2bc809f:                     for (p = c.getFirstPage();
1:2bc809f:                          p != null;
1:2bc809f:                          p = c.getNextPage(pnum))
1:2bc809f:                     {
1:2bc809f:                         countPages++;
1:2bc809f:                         pnum = p.getPageNumber();
1:2bc809f:                         p.unlatch();
1:2bc809f:                         t_util.t_commit(t);	// release container lock
1:2bc809f: 
1:2bc809f:                         c = t_util.t_openContainer(t, 0, cid, false);
1:2bc809f:                     }
1:2bc809f: 
1:2bc809f:                     t_util.t_commit(t);	// release container lock
1:2bc809f: 
1:2bc809f:                     if (countPages > max)
1:2bc809f:                         throw T_Fail.testFailMsg("some pages may not be reused, expect " +
1:2bc809f:                                                  max + " got " + countPages);
1:2bc809f:                     else
1:2bc809f:                         REPORT("AllocMTest1 got " + countPages );
1:2bc809f:                 }
1:2bc809f:                 
1:2bc809f:             }
1:2bc809f:             finally
1:2bc809f:             {
1:2bc809f:                 SanityManager.DEBUG_CLEAR(AllocPage.TEST_MULTIPLE_ALLOC_PAGE);
1:2bc809f:                 t_util.t_commit(t);
1:2bc809f:                 t.close();
1:2bc809f:             }
1:2bc809f: 
1:2bc809f:             PASS("AllocMTest1");
1:2bc809f:         }
1:2bc809f:         else
1:2bc809f:         {
1:2bc809f: 			REPORT("AllocMTest1 cannot be run on an insane server");
1:2bc809f: 			return;
1:2bc809f:         }
1:2bc809f: 	}
1:2bc809f:     
1:2bc809f:     /**
1:a0dbbd7:      * Privileged lookup of the ContextService. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  ContextService    getContextService()
1:a0dbbd7:     {
1:a0dbbd7:         if ( System.getSecurityManager() == null )
1:a0dbbd7:         {
1:a0dbbd7:             return ContextService.getFactory();
1:a0dbbd7:         }
1:a0dbbd7:         else
1:a0dbbd7:         {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:a0dbbd7:                  new PrivilegedAction<ContextService>()
1:a0dbbd7:                  {
1:a0dbbd7:                      public ContextService run()
1:a0dbbd7:                      {
1:a0dbbd7:                          return ContextService.getFactory();
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:a0dbbd7: 
1:2bc809f:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object createPersistentService( final String factoryInterface, final String serviceName, final Properties properties ) 
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.createPersistentService( factoryInterface, serviceName, properties );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:2bc809f: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1: 			factory = (RawStoreFactory) createPersistentService(getModuleToTestProtocolName(),
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object createPersistentService( final String factoryInterface, final String serviceName, final Properties properties ) 
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.createPersistentService( factoryInterface, serviceName, properties );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
1: import java.security.AccessController;
/////////////////////////////////////////////////////////////////////////
1: 		contextService = getContextService();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged lookup of the ContextService. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ContextService    getContextService()
1:     {
1:         if ( System.getSecurityManager() == null )
1:         {
1:             return ContextService.getFactory();
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedAction<ContextService>()
1:                  {
1:                      public ContextService run()
1:                      {
1:                          return ContextService.getFactory();
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Lily Wei
-------------------------------------------------------------------------------
commit:4c5c16b
/////////////////////////////////////////////////////////////////////////
1:             //Assume database is not active. DERBY-4856 thread dump
1:             cm1.cleanupOnError(se, false);
/////////////////////////////////////////////////////////////////////////
1:             //Assume database is not active. DERBY-4856 thread dump
1:             cm1.cleanupOnError(se, false);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:c38b841
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:2bc809f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.unitTests.store.T_FileSystemData
1: 
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.unitTests.store;
1: 
1: import org.apache.derby.impl.store.raw.data.*;
1: 
1: import org.apache.derbyTesting.unitTests.harness.T_MultiThreadedIterations;
1: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1: 
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.locks.*;
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.io.Storable;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.store.raw.*;
1: 
1: import org.apache.derby.iapi.store.raw.xact.RawTransaction;
1: import org.apache.derby.iapi.store.raw.data.RawContainerHandle;
1: 
1: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: import org.apache.derby.iapi.reference.Property;
1: 
1: import java.io.*;
1: import java.util.Properties;
1: /**
1: 	An Impl unittest for rawstore data that is based on the FileSystem
1: */
1: 
1: public class T_FileSystemData extends T_MultiThreadedIterations {
1: 
1: 	private static final String testService = "fileSystemDataTest";
1: 
1: 	static final String REC_001 = "McLaren";
1: 	static final String REC_002 = "Ferrari";
1: 	static final String REC_003 = "Benetton";
1: 	static final String REC_004 = "Prost";
1: 	static final String REC_005 = "Tyrell";
1: 	static final String REC_006 = "Derby, Natscape, Goatscape, the popular names";
1: 	static final String REC_007 = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz";
1: 
1: 	static final String SP1 = "savepoint1";
1: 	static final String SP2 = "savepoint2";
1: 
1: 
1: 	static RawStoreFactory	factory;
1: 	static LockFactory lf;
1: 	static long commonContainer = -1;
1: 
1: 	static boolean testRollback; // initialize in start
1: 	static final String TEST_ROLLBACK_OFF = "derby.RawStore.RollbackTestOff";
1: 
1: 	private static ContextService contextService;
1: 	private T_Util t_util;
1: 
1: 	public T_FileSystemData() 
1: 	{
1: 		super();
1: 	}
1: 
1: 	/**
1: 	  @exception StandardException cannot startup the context service
1: 	 */
1: 	public void boot(boolean create, Properties startParams)
1: 		 throws StandardException
1: 	{
1: 		super.boot(create, startParams);
0: 		contextService = ContextService.getFactory();
1: 	}
1: 
1: 
1: 	/*
1: 	** Methods required by T_Generic
1: 	*/
1: 
1: 	protected String getModuleToTestProtocolName() {
1: 		return RawStoreFactory.MODULE;
1: 	}
1: 
1: 
1: 	/**
1: 		Run the tests
1: 
1: 		@exception T_Fail Unexpected behaviour from the API
1: 	 */
1: 	protected void setupTest() throws T_Fail 
1: 	{
1: 		String rollbackOff = PropertyUtil.getSystemProperty(TEST_ROLLBACK_OFF);
1: 		testRollback = !Boolean.valueOf(rollbackOff).booleanValue();
1: 
1: 
1: 		// don't automatic boot this service if it gets left around
1: 		if (startParams == null) {
1: 			startParams = new Properties();
1: 		}
1: 
1: 		// see if we are testing encryption
1: 		startParams = T_Util.setEncryptionParam(startParams);
1: 
1: 		startParams.put(Property.NO_AUTO_BOOT, Boolean.TRUE.toString());
1: 		// remove the service directory to ensure a clean run
1: 		startParams.put(Property.DELETE_ON_CREATE, Boolean.TRUE.toString());
1: 
1: 		try {
0: 			factory = (RawStoreFactory) Monitor.createPersistentService(getModuleToTestProtocolName(),
1: 								testService, startParams);
1: 			if (factory == null) {
1: 				throw T_Fail.testFailMsg(getModuleToTestProtocolName() + " service not started.");
1: 			}
1: 
1: 			lf = factory.getLockFactory();
1: 			if (lf == null) {
1: 				throw T_Fail.testFailMsg("LockFactory.MODULE not found");
1: 			}
1: 		} catch (StandardException mse) {
1: 			throw T_Fail.exceptionFail(mse);
1: 		}
1: 
1: 		t_util = new T_Util(factory, lf, contextService);
1: 		commonContainer = commonContainer();
1: 
1: 		return;
1: 	}
1: 
1: 
1: 	/**
1: 	 * T_MultiThreadedIteration method
1: 	 *
1: 	 * @exception T_Fail Unexpected behaviour from the API
1: 	 */
1: 	protected void joinSetupTest() throws T_Fail {
1: 
1: 		T_Fail.T_ASSERT(factory != null, "raw store factory not setup ");
1: 		T_Fail.T_ASSERT(contextService != null, "Context service not setup ");
1: 		T_Fail.T_ASSERT(commonContainer != -1, "common container not setup ");
1: 
1: 		t_util = new T_Util(factory, lf, contextService);
1: 
1: 	}
1: 
1: 	protected T_MultiThreadedIterations newTestObject() {
1: 		return new T_FileSystemData();
1: 	}
1: 
1: 	/**
1: 	  run the test
1: 
1: 	  @exception T_Fail Unexpected behaviour from the API
1: 	*/
1: 	protected void runTestSet() throws T_Fail {
1: 
1: 		// get a utility helper
1: 
1: 		ContextManager cm1 = contextService.newContextManager();
1: 		contextService.setCurrentContextManager(cm1);
1: 
1: 		try {
1: 
1: 			runCostEstimationTests();
1: 			runAllocationTests();
1: 
1: 		} catch (StandardException se) {
1: 
0: 			cm1.cleanupOnError(se);
1: 			throw T_Fail.exceptionFail(se);
1: 		}
1: 		finally {
1: 
1: 			contextService.resetCurrentContextManager(cm1);
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * create a container that all threads can use
1: 	 */
1: 	private long commonContainer() throws T_Fail
1: 	{
1: 		ContextManager cm1 = contextService.newContextManager();
1: 		contextService.setCurrentContextManager(cm1);
1: 		long cid;
1: 
1: 		try {
1: 			Transaction t = t_util.t_startTransaction();
1: 			cid = t_util.t_addContainer(t, 0);
1: 			t_util.t_commit(t);
1: 			t.close();
1: 		}
1: 		catch (StandardException se) {
1: 
0: 			cm1.cleanupOnError(se);
1: 			throw T_Fail.exceptionFail(se);
1: 		}
1: 		finally {
1: 			contextService.resetCurrentContextManager(cm1);
1: 		}
1: 		return cid;
1: 	}
1: 
1: 	protected void runCostEstimationTests() throws T_Fail, StandardException
1: 	{
1: 		CostEstimationTest1();
1: 	}
1: 
1: 	protected void runAllocationTests() throws T_Fail, StandardException
1: 	{
1: 		// don't run these for > 2 threads
1: 		if (threadNumber < 2)
1: 		{
1: 			AllocTest1();			// test remove and reuse of page
1: 			AllocTest2();			// test remove and drop and rollback of remove 
1: 			AllocTest3();			// test multiple alloc page
1: 			AllocTest4();			// test preallocation
1: 		}
1: 
1: 		// can't get this test to pass consistently because it depends on
1: 		// timing of the cache.
1: 		// AllocTest5();			// test gettting 1/2 filled page for insert
1: 
1: 		AllocMTest1(commonContainer); // test multi thread access to the same container
1: 	}
1: 
1: 	/**
1: 		@exception T_Fail Unexpected behaviour from the API
1: 		@exception StandardException Standard Derby error policy
1: 	*/
1: 	protected void CostEstimationTest1() throws StandardException, T_Fail 
1: 	{
1: 		// getEstimatedRowCount(0), setEstimatedRowCount(long count, int flag),
1: 		// getEstimatedPageCount(int flag);
1: 
1: 		Transaction t = t_util.t_startTransaction();
1: 		long cid = t_util.t_addContainer(t, 0);
1: 		t_util.t_commit(t);
1: 
1: 		ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 
1: 		try
1: 		{
1: 			int numRows = 10;
1: 			T_RawStoreRow row = new T_RawStoreRow(REC_001);
1: 			RecordHandle rh[] = new RecordHandle[numRows];
1: 
1: 			// insert numRows rows into container
1: 			for (int i = 0; i < numRows; i++)
1: 				rh[i] = t_util.t_insert(c, row);
1: 
1: 			t_util.t_commit(t);
1: 
1: 			c = t_util.t_openContainer(t, 0, cid, true);
1: 			if ((c.getEstimatedRowCount(0) != numRows) &&
1: 			    (c.getEstimatedRowCount(0) != (numRows - 1)))
1:             {
1:                 // due to timing, sometimes estimate row count is 9 rather than
1:                 // 10.
1: 
1: 				throw T_Fail.testFailMsg(
1:                     "expect estimated row count to be " + (numRows - 1) + 
1:                     " or " + numRows +
1:                          ", got " + c.getEstimatedRowCount(0));
1:             }
1: 
1: 			// now update them that cause overflowing - expect the same row count
1: 			T_RawStoreRow longRow = new T_RawStoreRow(REC_007);
1: 			for (int i = 0; i < numRows; i++)
1: 				t_util.t_update(c, rh[i], longRow);
1: 
1: 			t_util.t_commit(t);
1: 
1: 			c = t_util.t_openContainer(t, 0, cid, true);
1: 			if (c.getEstimatedRowCount(0) != numRows)
1: 
1: 			if ((c.getEstimatedRowCount(0) != numRows) &&
1: 			    (c.getEstimatedRowCount(0) != (numRows - 1)))
1:             {
1:                 // due to timing, sometimes estimate row count is 9 rather than
1:                 // 10.
1:                 
1: 				throw T_Fail.testFailMsg(
1:                     "expect after update same estimated row count, but it is not." +
1:                     "expect estimated row count to be " + (numRows - 1) + 
1:                     " or " + numRows + ", got " + c.getEstimatedRowCount(0));
1:             }
1: 
1: 			// now focibly set the row count
1: 			c.setEstimatedRowCount(2*numRows, 0);
1: 
1: 			if (c.getEstimatedRowCount(0) != 2*numRows)
1: 				throw T_Fail.testFailMsg("forcibly setting estimated row count doesn't seem to work");
1: 
1: 			// now purge some rows, this should alter the row count.
1: 			Page p = null;
1: 			long pnum = 0;
1: 			long purgedCount = 0;
1: 			for (p = c.getFirstPage(); p != null; p = c.getNextPage(pnum)) 
1: 			{
1: 				int rcount = p.recordCount()/3;
1: 				pnum = p.getPageNumber();
1: 
1: 				p.deleteAtSlot(0, true, (LogicalUndo)null);
1: 				p.purgeAtSlot(rcount, rcount, true); // purget the middle 1/3 of the page
1: 				purgedCount += rcount + 1;
1: 
1: 				p.unlatch();
1: 			}
1: 		
1: 			t_util.t_commit(t);
1: 
1: 			c = t_util.t_openContainer(t, 0, cid, true);
1: 			if (c.getEstimatedRowCount(0) != (2*numRows - purgedCount))
1: 				throw T_Fail.testFailMsg("expect " + (2*numRows-purgedCount) + 
1: 										 " after purge"); 
1: 		
1: 			// now get rid of some pages to alter the row count
1: 			REPORT("before page delete, estRC = " + (2*numRows) + " - " + purgedCount);
1: 
1: 			for (p = c.getFirstPage(); p != null; p = c.getNextPage(pnum))
1: 			{
1: 				pnum = p.getPageNumber();
1: 				if ((pnum%2) == 0)
1: 				{
1: 					purgedCount += p.nonDeletedRecordCount();
1: 					c.removePage(p);
1: 				}
1: 				else
1: 					p.unlatch();
1: 			}
1: 
1: 			t_util.t_commit(t);
1: 
1: 			c = t_util.t_openContainer(t, 0, cid, true);
1: 			if (c.getEstimatedRowCount(0) != (2*numRows - purgedCount))
1: 				throw T_Fail.testFailMsg("expect " + (2*numRows-purgedCount) + 
1: 										 " after page remove, got " + c.getEstimatedRowCount(0)); 
1: 
1: 			PASS("CostEstimationTest1");
1: 		}
1: 		finally
1: 		{
1: 			t_util.t_commit(t);
1: 			t.close();
1: 		}
1: 
1: 
1: 	}
1: 
1: 	protected void AllocTest1() throws StandardException, T_Fail 
1: 	{
1: 		/**
1: 		  test remove and reuse of page
1: 		*/
1: 		Transaction t = t_util.t_startTransaction();
1: 
1: 		try
1: 		{
1: 			long cid = t_util.t_addContainer(t, 0);
1: 			t_util.t_commit(t);
1: 
1: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 
1: 		// create 5 pages, each insert a row into it, then remove 2 of them
1: 
1: 			Page page1 = t_util.t_getPage(c, ContainerHandle.FIRST_PAGE_NUMBER);
1: 			long p1 = page1.getPageNumber();
1: 			T_RawStoreRow row1 = new T_RawStoreRow(REC_001);
1: 			t_util.t_insert(page1, row1);
1: 
1: 			Page page2 = t_util.t_addPage(c);
1: 			long p2 = page2.getPageNumber();
1: 			T_RawStoreRow row2 = new T_RawStoreRow(REC_002);
1: 			int rid2 = t_util.t_insert(page2, row2).getId();
1: 
1: 			Page page3 = t_util.t_addPage(c);
1: 			long p3 = page3.getPageNumber();
1: 			T_RawStoreRow row3 = new T_RawStoreRow(REC_003);
1: 			t_util.t_insert(page3, row3);
1: 
1: 			Page page4 = t_util.t_addPage(c);
1: 			long p4 = page4.getPageNumber();
1: 			T_RawStoreRow row4 = new T_RawStoreRow(REC_004);
1: 			int rid4 = t_util.t_insert(page4, row4).getId();
1: 
1: 			Page page5 = t_util.t_addPage(c);
1: 			long p5 = page5.getPageNumber();
1: 			T_RawStoreRow row5 = new T_RawStoreRow(REC_005);
1: 			t_util.t_insert(page5, row5);
1: 
1: 			t_util.t_removePage(c, page2);
1: 			t_util.t_removePage(c, page4);
1: 			t_util.t_commit(t);
1: 
1: 		// now all the pages are unlatched
1: 		// pages 2, 4 has been removed, pages 1, 3, 5 has not
1: 		// make sure pages that are removed cannot be found again
1: 			c = t_util.t_openContainer(t, 0, cid, true);
1: 
1:             if (SanityManager.DEBUG)
1:                 SanityManager.DEBUG("SpaceTrace", "containeropened");
1: 
1: 			Page p = c.getFirstPage();
1: 			if (p == null)
1: 				throw T_Fail.testFailMsg("get first page failed: expect " + p1 + " got null");
1: 			if (p.getPageNumber() != p1)
1: 				throw T_Fail.testFailMsg("get first page failed: expect " + p1
1: 										 + " got " + p.getPageNumber());
1: 
1: 			t_util.t_commit(t);		
1: 
1: 		// closing the transaction many times to see if we can get the
1: 		// deallocated page to free
1: 
1: 			c = t_util.t_openContainer(t, 0, cid, true);
1: 			p = c.getNextPage(p1);
1: 			if (p == null || p.getPageNumber() != p3)
1: 				throw T_Fail.testFailMsg("get next page failed");
1: 			t_util.t_commit(t);
1: 
1: 			c = t_util.t_openContainer(t, 0, cid, true);
1: 			p = c.getNextPage(p3);
1: 			if (p == null || p.getPageNumber() != p5)
1: 				throw T_Fail.testFailMsg("get next page failed");
1: 			t_util.t_commit(t);
1: 		
1: 			c = t_util.t_openContainer(t, 0, cid, true);
1: 			p = t_util.t_getLastPage(c);	// make sure it skips over p5
1: 			if (p == null || p.getPageNumber() != p5)
1: 				throw T_Fail.testFailMsg("getLastPage failed");
1: 			t_util.t_commit(t);
1: 
1: 		// see if we can get any deallocated page back in 10 attempts
1: 		// of add page
1: 			int tries = 100;
1: 			T_RawStoreRow row6 = new T_RawStoreRow(REC_001);
1: 
1: 			long pnums[] = new long[tries];
1: 			int  rids[] = new int[tries];
1: 			pnums[0] = p2;			// pages 2 and 4 have been removed for a long time
1: 			rids[0] = rid2;
1: 			pnums[1] = p4;
1: 			rids[1] = rid4;
1: 
1: 			int match = -1;
1: 			int i;
1: 			for (i = 2 ; match < 0 && i < tries; i++)
1: 			{
1: 				c = t_util.t_openContainer(t, 0, cid, true);
1: 				p = t_util.t_addPage(c);
1: 				pnums[i] =  p.getPageNumber();
1: 
1: 				for (int j = 0; j < i-1; j++)
1: 				{
1: 					if (pnums[j] == pnums[i])
1: 					{
1: 						match = j;
1: 						break;
1: 					}
1: 				}
1: 
1: 				if (match >= 0)
1: 				{
1: 					// p is a reused one, make sure it is empty
1: 					t_util.t_checkEmptyPage(p);
1: 					RecordHandle rh = t_util.t_insert(p, row6);
1: 					if (rh.getId() == rids[match])
1: 						throw T_Fail.testFailMsg("reused page recordId is not preserved");
1: 					break;
1: 				}
1: 				else
1: 					rids[i] = t_util.t_insert(p, row6).getId();
1: 
1: 				t_util.t_removePage(c, p);
1: 				t_util.t_commit(t);
1: 			}
1: 			t_util.t_dropContainer(t, 0, cid); // cleanup
1: 
1: 			if (match >= 0)
1: 				PASS("AllocTest1 success in " + i + " tries");
1: 			else
1: 				REPORT("AllocTest1 Not successful in " + i + 
1: 					   " tries.  This is a timing depenedent test so this is not necessarily an indication of failure.");
1: 		}
1: 		finally
1: 		{
1: 			t_util.t_commit(t);
1: 			t.close();
1: 		}
1: 
1: 	}
1: 
1: 	protected void AllocTest2() throws StandardException, T_Fail 
1: 	{
1: 		/**
1: 		  More Test remove and reuse of page
1: 		*/
1: 
1: 		Transaction t = t_util.t_startTransaction();
1: 		int numpages = 30;
1: 
1: 		try
1: 		{
1: 			long cid = t_util.t_addContainer(t, 0);
1: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 
1: 			Page[] page = new Page[numpages];
1: 
1: 			for (int i = 0; i < numpages; i++)
1: 			{
1: 				page[i] = t_util.t_addPage(c);
1: 				t_util.t_removePage(c, page[i]);
1: 			}
1: 
1: 			// make sure a dropped container does not cause problem for page
1: 			// that's been removed
1: 			t_util.t_dropContainer(t, 0, cid); 
1: 
1: 			t_util.t_commit(t);
1: 
1: 			if (testRollback)
1: 			{
1: 				cid = t_util.t_addContainer(t, 0);
1: 				c = t_util.t_openContainer(t, 0, cid, true);
1: 
1: 				for (int i = 0; i < numpages; i++)
1: 				{
1: 					page[i] = t_util.t_addPage(c);
1: 					t_util.t_removePage(c, page[i]);
1: 				}
1: 
1: 				t_util.t_abort(t);
1: 			}
1: 		}
1: 		finally
1: 		{
1: 			t_util.t_commit(t);
1: 			t.close();
1: 		}
1: 
1: 
1: 		PASS("AllocTest2");
1: 	}
1: 
1: 	protected void AllocTest3() throws StandardException, T_Fail 
1: 	{
1: 		/* test multiple alloc pages */
1: 
1: 		if (!SanityManager.DEBUG)
1: 		{
1: 			REPORT("allocTest3 cannot be run on an insane server");
1: 			return;
1: 		}
1:         else
1:         {
1:             SanityManager.DEBUG_SET(AllocPage.TEST_MULTIPLE_ALLOC_PAGE);
1: 
1:             Transaction t = t_util.t_startTransaction();
1: 
1:             try
1:             {
1:                 long cid = t_util.t_addContainer(t, 0);
1:                 t_util.t_commit(t);
1: 
1:                 ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 
1:                 T_RawStoreRow row = new T_RawStoreRow(REC_001);
1:                 int numrows = 10; // create 10 pages with 1 row each
1:                 
1:                 String threadName = Thread.currentThread().getName();
1: 
1:                 Page page;
1:                 for (int i = 0; i < numrows; i++)
1:                 {
1:                     page = t_util.t_addPage(c);
1:                     t_util.t_insert(page, row);
1:                     page.unlatch();
1:                 }
1: 
1:                 int checkrows = 0;
1:                 long pnum;
1:                 for (page = c.getFirstPage();
1:                      page != null;
1:                      page = c.getNextPage(pnum))
1:                 {
1:                     pnum = page.getPageNumber();
1:                     if (page.recordCount() > 0)
1:                     {
1:                         t_util.t_checkFetchFirst(page, REC_001);
1:                         checkrows++;
1:                     }
1:                     page.unlatch();
1:                 }
1:                 if (checkrows != numrows)
1:                     throw T_Fail.testFailMsg("number of rows differ");
1: 
1:                 t.setSavePoint(SP1, null);
1: 
1:                 // now remove 1/2 of the pages and check results
1:                 int removedPages = 0;
1:                 for (page = c.getFirstPage();
1:                      page != null;
1:                      page = c.getNextPage(pnum))
1:                 {
1:                     pnum = page.getPageNumber();
1:                     if ((pnum % 2) == 0)
1:                     {
1:                         t_util.t_removePage(c, page);
1:                         removedPages++;
1:                     }
1:                     else
1:                         page.unlatch();
1:                 }
1: 
1:                 checkrows = 0;
1:                 for (page = c.getFirstPage();
1:                      page != null;
1:                      page = c.getNextPage(pnum))
1:                 {
1:                     pnum = page.getPageNumber();
1:                     if (page.recordCount() > 0)
1:                     {
1:                         t_util.t_checkFetchFirst(page, REC_001);
1:                         checkrows++;
1:                     }
1:                     page.unlatch();
1:                 }
1:                 if (checkrows != numrows - removedPages)
1:                     throw T_Fail.testFailMsg("number of rows differ");
1: 
1:                 // remove every page backwards
1:                 long lastpage = ContainerHandle.INVALID_PAGE_NUMBER;
1:                 while((page = t_util.t_getLastPage(c)) != null)	// remove the last page
1:                 {
1:                     if (lastpage == page.getPageNumber())
1:                         throw T_Fail.testFailMsg("got a removed last page");
1: 
1:                     lastpage = page.getPageNumber();
1:                     t_util.t_removePage(c, page);
1:                 }
1: 
1:                 if (c.getFirstPage() != null)
1:                     throw T_Fail.testFailMsg("get last page returns null but get fisrt page retuns a page");
1: 
1:                 t.rollbackToSavePoint(SP1, null);	// roll back removes
1:                 c = t_util.t_openContainer(t, 0, cid, true);
1: 
1:                 checkrows = 0;
1:                 for (page = c.getFirstPage();
1:                      page != null;
1:                      page = c.getNextPage(pnum))
1:                 {
1:                     pnum = page.getPageNumber();
1:                     if (page.recordCount() > 0)
1:                     {
1:                         t_util.t_checkFetchFirst(page, REC_001);
1:                         checkrows++;
1:                     }
1:                     page.unlatch();
1:                 }
1:                 if (checkrows != numrows)
1:                     throw T_Fail.testFailMsg(threadName + "number of rows differ expect " +
1:                                              numrows + " got " + checkrows);
1: 
1: 
1:                 t_util.t_abort(t);	// abort the whole thing, no rows left
1:                 c = t_util.t_openContainer(t, 0, cid, true);
1: 
1:                 int countPages = 0;
1:                 for (page = c.getFirstPage();
1:                      page != null;
1:                      page = c.getNextPage(pnum))
1:                 {
1:                     countPages++;
1:                     pnum = page.getPageNumber();
1:                     if (page.nonDeletedRecordCount() > 0)
1:                     {
1:                         throw T_Fail.testFailMsg("failed to remove everything " +
1:                                                  page.nonDeletedRecordCount() + 
1:                                                  " rows left on page " + pnum);
1:                     }
1:                     page.unlatch();
1:                 }			
1: 
1:                 if (countPages < numrows)
1:                     throw T_Fail.testFailMsg("rollback of user transaction should not remove allocated pages");
1: 
1:                 t_util.t_dropContainer(t, 0, cid); 
1: 
1:             }
1:             finally
1:             {
1:                 SanityManager.DEBUG_CLEAR(AllocPage.TEST_MULTIPLE_ALLOC_PAGE);
1:                 t_util.t_commit(t);
1:                 t.close();
1:             }
1:             PASS("AllocTest3");
1:         }
1: 	}
1: 
1: 	protected void AllocTest4() throws StandardException, T_Fail
1: 	{
1: 		if (!SanityManager.DEBUG)
1: 		{
1: 			REPORT("allocTest3 cannot be run on an insane server");
1: 			return;
1: 		}
1:         else
1:         {
1: 
1:             SanityManager.DEBUG_SET(AllocPage.TEST_MULTIPLE_ALLOC_PAGE);
1:             Transaction t = t_util.t_startTransaction();
1: 
1:             try
1:             {
1:                 ////////////////////////////////////////////////////////
1:                 // first test preallocation large table
1:                 ////////////////////////////////////////////////////////
1:                 Properties tableProperties = new Properties();
1:                 tableProperties.put(Property.PAGE_SIZE_PARAMETER, Integer.toString(1024));
1:                 tableProperties.put(RawStoreFactory.CONTAINER_INITIAL_PAGES, Integer.toString(100));
1: 
1:                 long cid1 = 
1:                     t.addContainer(
1:                         0, ContainerHandle.DEFAULT_ASSIGN_ID, 
1:                         ContainerHandle.MODE_DEFAULT, tableProperties, 0);
1: 
1:                 if (cid1 < 0)
1:                     throw T_Fail.testFailMsg("addContainer");
1: 
1:                 ContainerHandle c1 = t_util.t_openContainer(t, 0, cid1, true);
1: 
1:                 Page p1 = c1.getFirstPage();
1:                 if (p1.getPageNumber() != ContainerHandle.FIRST_PAGE_NUMBER)
1:                     throw T_Fail.testFailMsg("expect first page to have FIRST_PAGE_NUMBER");
1:                 p1.unlatch();
1: 
1:                 if (c1.getNextPage(ContainerHandle.FIRST_PAGE_NUMBER) != null)
1:                     throw T_Fail.testFailMsg("expect to have only 1 page allocated");
1: 
1:                 t_util.t_commit(t);
1: 
1:                 REPORT("AllocTest4 - create preallocated container " + cid1);
1: 
1:                 ////////////////////////////////////////////////////////
1:                 // next test special addpage interface
1:                 ////////////////////////////////////////////////////////
1:                 long cid2 = t_util.t_addContainer(t, 0, 1024, 0, 1, false);
1:                 t_util.t_commit(t);
1: 
1:                 ContainerHandle c2 = t_util.t_openContainer(t, 0, cid2, true);
1: 
1:                 // add page for bulk load
1:                 p1 = c2.addPage(ContainerHandle.ADD_PAGE_BULK);	
1:                 long pnum1 = p1.getPageNumber();
1:                 p1.unlatch();
1: 
1:                 // since the interface does not guarentee that anything special will
1:                 // actually happen, can't really test that. Just make sure that
1:                 // everything else works
1:                 Page p2 = c2.addPage();
1:                 long pnum2 = p2.getPageNumber();
1:                 p2.unlatch();
1: 
1:                 Page p3 = c2.addPage(ContainerHandle.ADD_PAGE_BULK);	
1:                 long pnum3 = p3.getPageNumber();
1:                 p3.unlatch();
1: 
1:                 Page p = c2.getFirstPage(); // this is the first page that came with the
1:                                        // container when it was created
1: 
1:                 try
1:                 {
1:                     long pnum0 = p.getPageNumber();
1:                     p.unlatch();
1:                     p = c2.getNextPage(pnum0);
1:                     if (p.getPageNumber() != pnum1)
1:                         throw T_Fail.testFailMsg("expected pagenum " + pnum1 + " got " + p.getPageNumber());
1:                     p.unlatch();
1:                     p = null;
1: 
1:                     p = c2.getNextPage(pnum1);
1:                     if (p.getPageNumber() != pnum2)
1:                         throw T_Fail.testFailMsg("expected pagenum " + pnum2 + " got " + p.getPageNumber());
1:                     p.unlatch();
1:                     p = null;
1: 
1:                     p = c2.getNextPage(pnum2);
1:                     if (p.getPageNumber() != pnum3)
1:                         throw T_Fail.testFailMsg("expected pagenum " + pnum3 + " got " + p.getPageNumber());
1:                     p.unlatch();
1:                     p = null;
1: 
1:                     p = c2.getNextPage(pnum3);
1:                     if (p != null)
1:                         throw T_Fail.testFailMsg("expected null page after " + pnum3 +
1:                                              " got " + p.getPageNumber());
1: 
1:                     // make sure rollback is unaffected
1:                     if (testRollback)
1:                     {
1:                         t_util.t_abort(t);
1:                         c2 = t_util.t_openContainer(t, 0, cid2, true);
1:                         p = t_util.t_getPage(c2, pnum0);
1:                         t_util.t_checkEmptyPage(p);
1:                         p.unlatch();
1:                         p = null;
1:                 
1:                         p = t_util.t_getPage(c2, pnum1);
1:                         t_util.t_checkEmptyPage(p);
1:                         p.unlatch();
1:                         p = null;
1: 
1:                         p = t_util.t_getPage(c2, pnum2);
1:                         t_util.t_checkEmptyPage(p);
1:                         p.unlatch();
1:                         p = null;
1: 
1:                         p = t_util.t_getPage(c2, pnum3);
1:                         t_util.t_checkEmptyPage(p);
1:                         p.unlatch();
1:                         p = null;
1: 
1:                         p = t_util.t_getLastPage(c2);
1:                         if (p.getPageNumber() != pnum3)
1:                             throw T_Fail.testFailMsg("expect last page to be " + pnum3
1:                                                  + " got " + p.getPageNumber());
1:                         p.unlatch();
1:                         p = null;
1:                     }
1:                 }
1:                 finally
1:                 {
1:                     if (p != null)
1:                         p.unlatch();
1:                     p = null;
1:                 }
1:                 REPORT("AllocTest4 - special addPage interface " + cid2);
1: 
1: 
1:                 ////////////////////////////////////////////////////////
1:                 // next test preallocate interface
1:                 ////////////////////////////////////////////////////////			
1:                 long cid3 = t_util.t_addContainer(t, 0, 1024);
1:                 ContainerHandle c3 = t_util.t_openContainer(t, 0, cid3, true);
1: 
1:                 // now preallocate 10 pages
1:                 c3.preAllocate(10);
1: 
1:                 p1 = c3.getFirstPage();
1:                 if (p1.getPageNumber() != ContainerHandle.FIRST_PAGE_NUMBER)
1:                     throw T_Fail.testFailMsg("expect first page to have FIRST_PAGE_NUMBER");
1:                 p1.unlatch();
1: 
1:                 if (c3.getNextPage(ContainerHandle.FIRST_PAGE_NUMBER) != null)
1:                     throw T_Fail.testFailMsg("expect to have only 1 page allocated");
1: 
1:                 REPORT("AllocTest4 - preallocate interface " + cid3);
1: 
1:                 PASS("AllocTest4 ");
1: 
1:             }
1:             finally
1:             {
1:                 SanityManager.DEBUG_CLEAR(AllocPage.TEST_MULTIPLE_ALLOC_PAGE);
1:                 t_util.t_commit(t);
1:                 t.close();
1:             }
1:         }
1: 	}
1: 
1: 	protected void AllocTest5() throws StandardException, T_Fail
1: 	{
1: 		// first create 10 1/2 filled pages with various degree of fillness
1: 		Transaction t = t_util.t_startTransaction();
1: 
1: 		try
1: 		{
1: 			long cid = t_util.t_addContainer(t, 0, 1024, 0, 90, false);
1: 			ContainerHandle c = t_util.t_openContainer(t, 0, cid, true);
1: 			Page p;
1: 
1: 			// the number of rows that is expected to fit into one page
1: 			// secret raw store calculation for 1 column rows
1: 			int numRows = (1024-60)/(95+8);
1: 
1: 			T_RawStoreRow rows[] = new T_RawStoreRow[numRows];
1: 
1: 			for (int j = 0; j < numRows; j++)
1: 				rows[j] = new T_RawStoreRow("row " + j);
1: 
1: 			for (int i = 0; i < numRows; i++)
1: 			{
1: 				p = t_util.t_addPage(c);
1: 
1: 				// validate allocation cache by getting the first page
1: 				t_util.t_getPage(c, 1).unlatch();
1: 
1: 				// insert different number of rows into these pages
1: 				for (int j = 0; j <= i; j++)
1: 				{
1: 					if (t_util.t_insert(p, rows[j]) == null)
1: 						throw T_Fail.testFailMsg("failed to insert " + (j+1) +
1: 												 " rows into page " + p);
1: 				}
1: 
1: 				p.unlatch();
1: 			}
1: 
1: 			// page 1 has 0 row
1: 			// page 2 has 1 row
1: 			// page 3 has 2 rows
1: 			// page 4 has 3 rows
1: 			// page 5 has 4 rows
1: 			// page 6 has 5 rows (filled)
1: 			// page 7 has 6 rows (filled)
1: 			// page 8 has 7 rows (filled)
1: 			// page 9 has 8 rows (filled)
1: 			// page 10 has 9 rows (filled)
1: 
1: 
1: 			// these pages should be accounted for correctly because each
1: 			// subsequent page has > 1/8 for all the records in the container
1: 
1: 			// now go thru and use up all the space
1: 			p =  c.getPageForInsert(0);
1: 			if (p != null)
1: 				throw T_Fail.testFailMsg("Expect last page to be full");
1: 
1: 			// now go thru and use up all the space - since we skipped page 1
1: 			// on the first loop, it won't know it is a 1/2 filled page.
1: 			for (int i = 2; i < 6; i++)
1: 			{
1: 				p = c.getPageForInsert(ContainerHandle.GET_PAGE_UNFILLED);
1: 				if (p == null)
1: 					throw T_Fail.testFailMsg("Expect next unfilled page to be " + i);
1: 
1: 				if (p.getPageNumber() != i)
1: 					throw T_Fail.testFailMsg("Expect next unfilled page to be "
1: 											 + i + ", it is " + p.getPageNumber());
1: 
1: 				t_util.t_insert(p, rows[i]);
1: 				p.unlatch();
1: 
1: 				// we should keep getting the same page back until it is full
1: 				while ((p = c.getPageForInsert(0)) != null)
1: 				{
1: 					if (p.getPageNumber() != i)
1: 						throw T_Fail.testFailMsg("Don't expect page number to change from " +
1: 												 i + " to " + p.getPageNumber());
1: 					t_util.t_insert(p, rows[i]);
1: 					p.unlatch();
1: 				}
1: 
1: 			}
1: 		
1: 			p = c.getPageForInsert(ContainerHandle.GET_PAGE_UNFILLED);
1: 			if (p != null)
1: 				throw T_Fail.testFailMsg("don't expect any more pages to be found");
1: 
1: 		}
1: 		finally
1: 		{
1: 			t_util.t_commit(t);
1: 			t.close();
1: 		}
1: 		PASS("AllocTest5 ");
1: 
1: 	}
1: 
1: 	/*
1: 	 * MT tests on  the same container
1: 	 */
1: 	protected void AllocMTest1(long cid) throws StandardException, T_Fail 
1: 	{
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.DEBUG_SET(AllocPage.TEST_MULTIPLE_ALLOC_PAGE);
1: 
1:             // each thread will add N pages and remove N pages and still finds
1:             // its own pages.  Do that serveral times.
1:             int N = 20;
1: 
1:             RecordHandle rh[] = new RecordHandle[N];
1: 
1:             Transaction t = t_util.t_startTransaction();
1: 
1:             try
1:             {
1:                 T_RawStoreRow row = new T_RawStoreRow(REC_002);
1:                 ContainerHandle c;
1:                 Page p;
1: 
1:                 for (int iteration = 0; iteration < 5; iteration++)
1:                 {
1:                     for (int i = 0; i < N; i++)
1:                     {
1:                         c = t_util.t_openContainer(t, 0, cid, true);
1: 
1:                         p = t_util.t_addPage(c);
1:                         rh[i] = t_util.t_insert(p, row);
1:                         p.unlatch();
1: 
1:                         t_util.t_commit(t);
1:                     }
1: 
1:                     for (int i = 0; i < N; i++)
1:                     {
1:                         c = t_util.t_openContainer(t, 0, cid, true);
1:                         t_util.t_checkFetch(c, rh[i], REC_002);
1: 
1:                         t.setSavePoint(SP1, null);
1: 
1:                         p = t_util.t_getPage(c, rh[i].getPageNumber());
1:                         t_util.t_removePage(c, p);
1: 
1:                         if ((iteration%3) == 1)
1:                         {
1:                             t.rollbackToSavePoint(SP1, null);
1:                         }
1: 
1:                         // sometimes commit sometimes abort
1:                         if (iteration % 2 == 0)
1:                             t_util.t_abort(t);
1:                         else
1:                             t_util.t_commit(t);
1:                     }
1: 
1:                     // if I aborted, remove them now
1:                     if ((iteration % 2) == 0 ||
1:                         (iteration % 3) == 1)
1:                     {
1:                         for (int i = 0; i < N; i++)
1:                         {
1:                             c = t_util.t_openContainer(t, 0, cid, true);
1:                             t_util.t_checkFetch(c, rh[i], REC_002);
1: 
1:                             p = t_util.t_getPage(c, rh[i].getPageNumber());
1:                             t_util.t_removePage(c, p);
1:                             t_util.t_commit(t);
1:                         }
1:                     }
1: 
1:                     // at any given time, there should be <= (N*numthread)+1 pages
1:                     int max = (N*getNumThreads())+1;
1: 
1:                     c = t_util.t_openContainer(t, 0, cid, false);
1:                     long pnum = 0;
1:                     int countPages = 0;
1: 
1:                     for (p = c.getFirstPage();
1:                          p != null;
1:                          p = c.getNextPage(pnum))
1:                     {
1:                         countPages++;
1:                         pnum = p.getPageNumber();
1:                         p.unlatch();
1:                         t_util.t_commit(t);	// release container lock
1: 
1:                         c = t_util.t_openContainer(t, 0, cid, false);
1:                     }
1: 
1:                     t_util.t_commit(t);	// release container lock
1: 
1:                     if (countPages > max)
1:                         throw T_Fail.testFailMsg("some pages may not be reused, expect " +
1:                                                  max + " got " + countPages);
1:                     else
1:                         REPORT("AllocMTest1 got " + countPages );
1:                 }
1:                 
1:             }
1:             finally
1:             {
1:                 SanityManager.DEBUG_CLEAR(AllocPage.TEST_MULTIPLE_ALLOC_PAGE);
1:                 t_util.t_commit(t);
1:                 t.close();
1:             }
1: 
1:             PASS("AllocMTest1");
1:         }
1:         else
1:         {
1: 			REPORT("AllocMTest1 cannot be run on an insane server");
1: 			return;
1:         }
1: 	}
1: }
============================================================================