1:33776ff: /*
41:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.net.NetXAConnectionReply
1:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:33776ff: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.net;
1:33776ff: 
1:0326967: import java.util.ArrayList;
1:43fb59e: import java.util.HashMap;
1:0326967: import java.util.List;
1:69e3d06: import javax.transaction.xa.XAException;
1:70f7692: import javax.transaction.xa.XAResource;
1:70f7692: import javax.transaction.xa.Xid;
1:b13b17c: import org.apache.derby.client.ClientXid;
1:70f7692: 
1:33776ff: import org.apache.derby.client.am.ConnectionCallbackInterface;
1:70f7692: import org.apache.derby.client.am.DisconnectException;
1:33776ff: 
1:0326967: class NetXAConnectionReply extends NetResultSetReply {
1:70f7692:     NetXAConnectionReply(NetAgent netAgent, int bufferSize) {
1:70f7692:         super(netAgent, bufferSize);
33:33776ff:     }
1:70f7692:     //----------------------------- entry points ---------------------------------
1:33776ff: 
1:33776ff: 
1:70f7692:     public void readLocalXAStart(ConnectionCallbackInterface connection) throws DisconnectException {
1:70f7692:     }
1:33776ff: 
1:70f7692:     public void readLocalXACommit(ConnectionCallbackInterface connection) throws DisconnectException {
1:33776ff: 
1:70f7692:         startSameIdChainParse();
1:70f7692:         parseSYNCCTLreply(connection);
1:70f7692:         endOfSameIdChainData();
1:33776ff: 
1:70f7692:         NetXACallInfo callInfo =
1:70f7692:                 netAgent_.netConnection_.xares_.callInfoArray_[netAgent_.netConnection_.currXACallInfoOffset_];
1:70f7692:         connection.completeLocalCommit();
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void readLocalXARollback(ConnectionCallbackInterface connection) throws DisconnectException {
1:70f7692:         startSameIdChainParse();
1:70f7692:         parseSYNCCTLreply(connection);
1:70f7692:         endOfSameIdChainData();
1:70f7692:         connection.completeLocalRollback();
1:70f7692:     }
1:70f7692: 
1:0326967:     void readXaStartUnitOfWork(NetConnection conn) throws DisconnectException {
1:70f7692:         startSameIdChainParse();
1:70f7692:         parseSYNCCTLreply(conn);
1:2f3d052:         // If we are joining or resuming a global transaction, we let the
1:2f3d052:         // server set the transcation isolation state for us.
1:2f3d052:         // Otherwise we do a normal reset.
1:2f3d052:         NetXACallInfo callInfo =
1:2f3d052:                 conn.xares_.callInfoArray_[conn.currXACallInfoOffset_];
1:2f3d052:         boolean keep = callInfo.xaFlags_ == XAResource.TMJOIN ||
1:2f3d052:                 callInfo.xaFlags_ == XAResource.TMRESUME;
1:2f3d052:         conn.xares_.setKeepCurrentIsolationLevel(keep);
1:70f7692:         endOfSameIdChainData();
1:70f7692:     }
1:70f7692: 
1:0326967:     int readXaEndUnitOfWork(NetConnection conn) throws DisconnectException {
1:2f3d052:         // We have ended the XA unit of work, the next logical connection
1:2f3d052:         // should be reset using the normal procedure.
1:2f3d052:         conn.xares_.setKeepCurrentIsolationLevel(false);
2:70f7692:         NetXACallInfo callInfo = conn.xares_.callInfoArray_[conn.currXACallInfoOffset_];
1:70f7692:         int xaFlags = callInfo.xaFlags_;
1:70f7692: 
1:70f7692:         startSameIdChainParse();
1:70f7692:         parseSYNCCTLreply(conn);
1:70f7692:         endOfSameIdChainData();
1:70f7692:         if (xaFlags == XAResource.TMFAIL) {
1:69e3d06:             return XAException.XA_RBROLLBACK;
1:70f7692:         }
1:69e3d06:         return XAResource.XA_OK;
1:70f7692:     }
1:70f7692: 
1:0326967:     int readXaPrepare(NetConnection conn) throws DisconnectException {
1:70f7692:         startSameIdChainParse();
1:70f7692:         int synctype = parseSYNCCTLreply(conn);
1:70f7692:         endOfSameIdChainData();
1:70f7692: 
1:70f7692:         return synctype;
1:70f7692:     }
1:70f7692: 
1:0326967:     void readXaCommit(NetConnection conn) throws DisconnectException {
1:70f7692:         startSameIdChainParse();
1:70f7692:         parseSYNCCTLreply(conn);
1:70f7692:         endOfSameIdChainData();
1:70f7692: 
1:70f7692:         NetXACallInfo callInfo = conn.xares_.callInfoArray_[conn.currXACallInfoOffset_];
1:70f7692:         conn.completeLocalCommit();
1:70f7692:     }
1:70f7692: 
1:0326967:     int readXaRollback(NetConnection conn) throws DisconnectException {
1:70f7692:         startSameIdChainParse();
1:70f7692:         parseSYNCCTLreply(conn);
1:70f7692:         endOfSameIdChainData();
1:70f7692: 
1:70f7692:         NetXACallInfo callInfo = conn.xares_.callInfoArray_[conn.currXACallInfoOffset_];
1:70f7692:         conn.completeLocalRollback();
1:70f7692: 
1:69e3d06:         return XAResource.XA_OK;
1:70f7692:     }
1:70f7692: 
1:0326967:     void readXaRecover(NetConnection conn) throws DisconnectException {
1:70f7692:         startSameIdChainParse();
1:70f7692:         parseSYNCCTLreply(conn);
1:70f7692:         endOfSameIdChainData();
1:70f7692:     }
1:70f7692: 
1:0326967:     void readXaForget(NetConnection conn) throws DisconnectException {
1:70f7692:         startSameIdChainParse();
1:70f7692:         parseSYNCCTLreply(conn);
1:70f7692:         endOfSameIdChainData();
1:70f7692:     }
1:70f7692:     //----------------------helper methods----------------------------------------
1:70f7692: 
1:70f7692:     //--------------------- parse DDM Reply Data--------------------------------------
1:33776ff: 
1:33776ff: 
1:33776ff:     // The SYNCCRD Reply Mesage
1:70f7692:     //
1:70f7692:     // Returned from Server:
1:70f7692:     //   XARETVAL - required
1:70f7692:     int parseSYNCCRD(ConnectionCallbackInterface connection) throws DisconnectException {
1:70f7692:         boolean svrcodReceived = false;
1:70f7692:         int svrcod = CodePoint.SVRCOD_INFO;
1:70f7692:         int xaretval = 0;
1:70f7692:         int synctype = 0;
1:70f7692:         NetConnection conn = netAgent_.netConnection_;
1:33776ff: 
1:70f7692:         parseLengthAndMatchCodePoint(CodePoint.SYNCCRD);
1:70f7692:         pushLengthOnCollectionStack();
2:70f7692:         int peekCP = peekCodePoint();
1:33776ff: 
1:70f7692:         while (peekCP != Reply.END_OF_COLLECTION) {
1:33776ff: 
1:70f7692:             boolean foundInPass = false;
1:33776ff: 
1:70f7692:             if (peekCP == CodePoint.SVRCOD) {
1:70f7692:                 foundInPass = true;
1:70f7692:                 svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);
1:70f7692:                 svrcod = parseSVRCOD(CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_ERROR);
1:70f7692:                 peekCP = peekCodePoint();
1:70f7692:             }
1:70f7692: 
1:70f7692:             if (peekCP == CodePoint.XARETVAL) {
1:70f7692:                 foundInPass = true;
1:70f7692:                 xaretval = parseXARETVAL();
1:70f7692:                 conn.xares_.callInfoArray_[conn.currXACallInfoOffset_].xaRetVal_ =
1:70f7692:                         xaretval;
1:70f7692:                 peekCP = peekCodePoint();
1:70f7692:             }
1:70f7692: 
1:70f7692:             if (peekCP == CodePoint.SYNCTYPE) {
1:70f7692:                 foundInPass = true;
1:70f7692:                 synctype = parseSYNCTYPE();
1:70f7692:                 peekCP = peekCodePoint();
1:70f7692:             }
1:70f7692: 
1:70f7692:             if (peekCP == CodePoint.PRPHRCLST) {
1:70f7692:                 foundInPass = true;
1:4772c7e:                 conn.setIndoubtTransactions(parseIndoubtList());
1:70f7692:                 peekCP = peekCodePoint();
1:70f7692:             }
1:70f7692: 
1:70f7692:             if (!foundInPass) {
1:70f7692:                 doPrmnsprmSemantics(peekCP);
1:70f7692:             }
1:70f7692:         }
1:70f7692:         popCollectionStack();
1:70f7692: 
1:70f7692: 
1:70f7692:         return xaretval;
1:70f7692: 
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Process XA return value
1:0326967:     int parseXARETVAL() throws DisconnectException {
1:70f7692:         parseLengthAndMatchCodePoint(CodePoint.XARETVAL);
1:70f7692:         return readInt();
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Process XA return value
1:0326967:     byte parseSYNCTYPE() throws DisconnectException {
1:70f7692:         parseLengthAndMatchCodePoint(CodePoint.SYNCTYPE);
1:70f7692:         return readByte();
1:70f7692:     }
1:70f7692: 
1:70f7692:     // This method handles the parsing of all command replies and reply data
1:70f7692:     // for the SYNNCTL command.
1:0326967:     int parseSYNCCTLreply(ConnectionCallbackInterface connection)
1:0326967:             throws DisconnectException {
1:70f7692:         int peekCP = peekCodePoint();
1:70f7692: 
1:70f7692:         if (peekCP != CodePoint.SYNCCRD) {
1:70f7692:             parseSYNCCTLError(peekCP);
1:70f7692:             return -1;
1:70f7692:         }
1:0326967:         int retval = parseSYNCCRD(connection);
1:70f7692: 
9:33776ff:         peekCP = peekCodePoint();
1:70f7692:         while (peekCP == CodePoint.SQLSTT) {
1:70f7692:             String s = parseSQLSTT();
1:70f7692:             //JCFTMP, need to null out the client list?
1:70f7692:             peekCP = peekCodePoint();
1:70f7692:         }
1:c6c4d4d:         if (peekCP == CodePoint.PBSD) {
1:c6c4d4d:             parsePBSD();
1:c6c4d4d:         }
1:33776ff: 
1:70f7692:         return retval;
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     //------------------------parse DDM Scalars-----------------------------
1:70f7692: 
1:70f7692: 
1:70f7692: 
1:70f7692: 
1:70f7692:     private String parseSQLSTT() throws DisconnectException {
1:70f7692:         parseLengthAndMatchCodePoint(CodePoint.SQLSTT);
1:70f7692:         return parseSQLSTTGRPNOCMorNOCS();
1:70f7692:     }
1:70f7692: 
1:70f7692:     private String parseSQLSTTGRPNOCMorNOCS() throws DisconnectException {
1:70f7692:         int mixedNullInd = readUnsignedByte();
1:70f7692:         int singleNullInd = 0;
1:70f7692:         String sqlsttString = null;
1:70f7692:         int stringLength = 0;
1:70f7692: 
1:70f7692:         if (mixedNullInd == CodePoint.NULLDATA) {
1:70f7692:             singleNullInd = readUnsignedByte();
1:70f7692:             if (singleNullInd == CodePoint.NULLDATA) {
1:70f7692:                 // throw DTAMCHRM
1:70f7692:                 doDtamchrmSemantics();
1:70f7692:             }
1:70f7692:             // read 4-byte length
1:70f7692:             stringLength = readInt();
1:70f7692:             // read sqlstt string
1:70f7692:             sqlsttString = readString(stringLength, netAgent_.targetTypdef_.getCcsidSbcEncoding());
1:70f7692:         } else {
1:70f7692:             // read 4-byte length
1:70f7692:             stringLength = readInt();
1:70f7692:             // read sqlstt string
1:70f7692:             sqlsttString = readString(stringLength, netAgent_.targetTypdef_.getCcsidMbcEncoding());
1:70f7692:             // read null indicator
1:70f7692:             singleNullInd = readUnsignedByte();
1:70f7692:         }
1:70f7692:         return sqlsttString;
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:0326967:     int parseXIDCNT() throws DisconnectException {
1:70f7692:         parseLengthAndMatchCodePoint(CodePoint.XIDCNT);
1:70f7692:         return readUnsignedShort();
1:70f7692:     }
1:70f7692: 
1:0326967:     Xid parseXID() throws DisconnectException {
1:70f7692:         parseLengthAndMatchCodePoint(CodePoint.XID);
1:70f7692:         int formatId = readInt();
1:70f7692:         int gtridLen = readInt();
1:70f7692:         int bqualLen = readInt();
1:70f7692:         byte[] gtrid = readBytes(gtridLen);
1:70f7692:         byte[] bqual = readBytes(bqualLen);
1:70f7692: 
1:b13b17c:         return new ClientXid(formatId, gtrid, bqual);
1:70f7692:     }
1:70f7692: 
1:0326967:     List<Xid> parseIndoubtList()
1:43fb59e:             throws DisconnectException {
1:43fb59e:         peekCodePoint();
1:70f7692:         parseLengthAndMatchCodePoint(CodePoint.PRPHRCLST);
1:43fb59e:         int peekCP = peekCodePoint();
1:70f7692:         if (peekCP == CodePoint.XIDCNT) {
1:0326967:             parseXIDCNT(); // unused
1:70f7692:             peekCP = peekCodePoint();
1:70f7692:         }
1:33776ff: 
1:0326967:         List<Xid> indoubtTransactions =
1:0326967:                 new ArrayList<Xid>();
1:70f7692:         while (peekCP == CodePoint.XID) {
1:70f7692:             Xid xid = parseXID();
1:0326967:             indoubtTransactions.add(xid);
1:70f7692:             peekCP = peekCodePoint();
1:70f7692:         }
1:33776ff: 
1:70f7692:         return indoubtTransactions;
1:33776ff:     }
1:33776ff: 
1:33776ff: }
1:33776ff: 
1:33776ff: 
1:33776ff: 
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0326967
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1: class NetXAConnectionReply extends NetResultSetReply {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     void readXaStartUnitOfWork(NetConnection conn) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     int readXaEndUnitOfWork(NetConnection conn) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     int readXaPrepare(NetConnection conn) throws DisconnectException {
1:     void readXaCommit(NetConnection conn) throws DisconnectException {
1:     int readXaRollback(NetConnection conn) throws DisconnectException {
1:     void readXaRecover(NetConnection conn) throws DisconnectException {
1:     void readXaForget(NetConnection conn) throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     int parseXARETVAL() throws DisconnectException {
1:     byte parseSYNCTYPE() throws DisconnectException {
1:     int parseSYNCCTLreply(ConnectionCallbackInterface connection)
1:             throws DisconnectException {
1:         int retval = parseSYNCCRD(connection);
/////////////////////////////////////////////////////////////////////////
1:     int parseXIDCNT() throws DisconnectException {
1:     Xid parseXID() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     List<Xid> parseIndoubtList()
1:             parseXIDCNT(); // unused
1:         List<Xid> indoubtTransactions =
1:                 new ArrayList<Xid>();
1:             indoubtTransactions.add(xid);
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import javax.transaction.xa.XAException;
/////////////////////////////////////////////////////////////////////////
1:             return XAException.XA_RBROLLBACK;
1:         return XAResource.XA_OK;
/////////////////////////////////////////////////////////////////////////
1:         return XAResource.XA_OK;
/////////////////////////////////////////////////////////////////////////
0:         HashMap<Xid, NetIndoubtTransaction> indoubtTransactions =
0:                 new HashMap<Xid, NetIndoubtTransaction>();
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.ClientXid;
/////////////////////////////////////////////////////////////////////////
1:         return new ClientXid(formatId, gtrid, bqual);
commit:43fb59e
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
0:     protected HashMap<Xid, NetIndoubtTransaction> parseIndoubtList()
1:             throws DisconnectException {
1:         peekCodePoint();
1:         int peekCP = peekCodePoint();
0:             int numXid = parseXIDCNT();
0:         java.util.HashMap<Xid, NetIndoubtTransaction> indoubtTransactions =
0:                 new java.util.HashMap<Xid, NetIndoubtTransaction>();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4772c7e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 conn.setIndoubtTransactions(parseIndoubtList());
/////////////////////////////////////////////////////////////////////////
0:         java.util.Hashtable<Xid, NetIndoubtTransaction> indoubtTransactions =
0:                 new java.util.Hashtable<Xid, NetIndoubtTransaction>();
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:2f3d052
/////////////////////////////////////////////////////////////////////////
1:         // If we are joining or resuming a global transaction, we let the
1:         // server set the transcation isolation state for us.
1:         // Otherwise we do a normal reset.
1:         NetXACallInfo callInfo =
1:                 conn.xares_.callInfoArray_[conn.currXACallInfoOffset_];
1:         boolean keep = callInfo.xaFlags_ == XAResource.TMJOIN ||
1:                 callInfo.xaFlags_ == XAResource.TMRESUME;
1:         conn.xares_.setKeepCurrentIsolationLevel(keep);
1:         // We have ended the XA unit of work, the next logical connection
1:         // should be reset using the normal procedure.
1:         conn.xares_.setKeepCurrentIsolationLevel(false);
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:c6c4d4d
/////////////////////////////////////////////////////////////////////////
1:         if (peekCP == CodePoint.PBSD) {
1:             parsePBSD();
1:         }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:d5ba8a8
/////////////////////////////////////////////////////////////////////////
0:         if (synctype == XAResource.XA_RDONLY) { // xaretval of read-only, make sure flag agrees
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1: import javax.transaction.xa.XAResource;
1: import javax.transaction.xa.Xid;
1: 
1: import org.apache.derby.client.am.DisconnectException;
0: public class NetXAConnectionReply extends NetResultSetReply {
1:     NetXAConnectionReply(NetAgent netAgent, int bufferSize) {
1:         super(netAgent, bufferSize);
1:     //----------------------------- entry points ---------------------------------
1:     public void readLocalXAStart(ConnectionCallbackInterface connection) throws DisconnectException {
1:     public void readLocalXACommit(ConnectionCallbackInterface connection) throws DisconnectException {
1:         startSameIdChainParse();
1:         parseSYNCCTLreply(connection);
1:         endOfSameIdChainData();
1:         NetXACallInfo callInfo =
1:                 netAgent_.netConnection_.xares_.callInfoArray_[netAgent_.netConnection_.currXACallInfoOffset_];
0:         callInfo.xaInProgress_ = false;
0:         callInfo.xaWasSuspended = false;
1:         connection.completeLocalCommit();
1:     }
1: 
1:     public void readLocalXARollback(ConnectionCallbackInterface connection) throws DisconnectException {
1:         startSameIdChainParse();
1:         parseSYNCCTLreply(connection);
1:         endOfSameIdChainData();
1:         connection.completeLocalRollback();
1:     }
1: 
0:     protected void readXaStartUnitOfWork(NetConnection conn) throws DisconnectException {
1:         startSameIdChainParse();
1:         parseSYNCCTLreply(conn);
1:         endOfSameIdChainData();
1:     }
1: 
0:     protected int readXaEndUnitOfWork(NetConnection conn) throws DisconnectException {
1:         NetXACallInfo callInfo = conn.xares_.callInfoArray_[conn.currXACallInfoOffset_];
1:         int xaFlags = callInfo.xaFlags_;
1: 
1:         startSameIdChainParse();
1:         parseSYNCCTLreply(conn);
1:         endOfSameIdChainData();
1:         if (xaFlags == XAResource.TMFAIL) {
0:             return javax.transaction.xa.XAException.XA_RBROLLBACK;
1:         }
0:         return javax.transaction.xa.XAResource.XA_OK;
1:     }
1: 
0:     protected int readXaPrepare(NetConnection conn) throws DisconnectException {
1:         startSameIdChainParse();
1:         int synctype = parseSYNCCTLreply(conn);
1:         endOfSameIdChainData();
1: 
1:         NetXACallInfo callInfo = conn.xares_.callInfoArray_[conn.currXACallInfoOffset_];
0:         if (synctype == NetXAResource.XARETVAL_XARDONLY) { // xaretval of read-only, make sure flag agrees
0:             callInfo.setReadOnlyTransactionFlag(true);
0:         } else { // xaretval NOT read-only, make sure flag agrees
0:             callInfo.setReadOnlyTransactionFlag(false);
1:         }
1:         return synctype;
1:     }
1: 
0:     protected void readXaCommit(NetConnection conn) throws DisconnectException {
1:         startSameIdChainParse();
1:         parseSYNCCTLreply(conn);
1:         endOfSameIdChainData();
1: 
1:         NetXACallInfo callInfo = conn.xares_.callInfoArray_[conn.currXACallInfoOffset_];
0:         callInfo.xaInProgress_ = false;
1:         conn.completeLocalCommit();
1:     }
1: 
0:     protected int readXaRollback(NetConnection conn) throws DisconnectException {
1:         startSameIdChainParse();
1:         parseSYNCCTLreply(conn);
1:         endOfSameIdChainData();
1: 
1:         NetXACallInfo callInfo = conn.xares_.callInfoArray_[conn.currXACallInfoOffset_];
0:         callInfo.xaInProgress_ = false;
0:         callInfo.xaWasSuspended = false;
1:         conn.completeLocalRollback();
1: 
0:         return javax.transaction.xa.XAResource.XA_OK;
1:     }
1: 
0:     protected void readXaRecover(NetConnection conn) throws DisconnectException {
1:         startSameIdChainParse();
1:         parseSYNCCTLreply(conn);
1:         endOfSameIdChainData();
1:     }
1: 
0:     protected void readXaForget(NetConnection conn) throws DisconnectException {
1:         startSameIdChainParse();
1:         parseSYNCCTLreply(conn);
1:         endOfSameIdChainData();
1:     }
1:     //----------------------helper methods----------------------------------------
1: 
1:     //--------------------- parse DDM Reply Data--------------------------------------
1:     //
1:     // Returned from Server:
1:     //   XARETVAL - required
1:     int parseSYNCCRD(ConnectionCallbackInterface connection) throws DisconnectException {
1:         boolean svrcodReceived = false;
1:         int svrcod = CodePoint.SVRCOD_INFO;
1:         int xaretval = 0;
1:         int synctype = 0;
0:         java.util.Hashtable indoubtTransactions = null;
1:         NetConnection conn = netAgent_.netConnection_;
1:         parseLengthAndMatchCodePoint(CodePoint.SYNCCRD);
1:         pushLengthOnCollectionStack();
1:         int peekCP = peekCodePoint();
1:         while (peekCP != Reply.END_OF_COLLECTION) {
1:             boolean foundInPass = false;
1:             if (peekCP == CodePoint.SVRCOD) {
1:                 foundInPass = true;
1:                 svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);
1:                 svrcod = parseSVRCOD(CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_ERROR);
1:                 peekCP = peekCodePoint();
1:             }
1: 
1:             if (peekCP == CodePoint.XARETVAL) {
1:                 foundInPass = true;
1:                 xaretval = parseXARETVAL();
1:                 conn.xares_.callInfoArray_[conn.currXACallInfoOffset_].xaRetVal_ =
1:                         xaretval;
1:                 peekCP = peekCodePoint();
1:             }
1: 
1:             if (peekCP == CodePoint.SYNCTYPE) {
1:                 foundInPass = true;
1:                 synctype = parseSYNCTYPE();
1:                 peekCP = peekCodePoint();
1:             }
1: 
1:             if (peekCP == CodePoint.PRPHRCLST) {
1:                 foundInPass = true;
0:                 indoubtTransactions = parseIndoubtList();
0:                 conn.setIndoubtTransactions(indoubtTransactions);
1:                 peekCP = peekCodePoint();
1:             }
1: 
1:             if (!foundInPass) {
1:                 doPrmnsprmSemantics(peekCP);
1:             }
1:         }
1:         popCollectionStack();
1: 
1: 
1:         return xaretval;
1: 
1:     }
1: 
1:     // Process XA return value
0:     protected int parseXARETVAL() throws DisconnectException {
1:         parseLengthAndMatchCodePoint(CodePoint.XARETVAL);
1:         return readInt();
1:     }
1: 
1:     // Process XA return value
0:     protected byte parseSYNCTYPE() throws DisconnectException {
1:         parseLengthAndMatchCodePoint(CodePoint.SYNCTYPE);
1:         return readByte();
1:     }
1: 
1:     // This method handles the parsing of all command replies and reply data
1:     // for the SYNNCTL command.
0:     protected int parseSYNCCTLreply(ConnectionCallbackInterface connection) throws DisconnectException {
0:         int retval = 0;
1:         int peekCP = peekCodePoint();
1: 
1:         if (peekCP != CodePoint.SYNCCRD) {
1:             parseSYNCCTLError(peekCP);
1:             return -1;
1:         }
0:         retval = parseSYNCCRD(connection);
1: 
1:         while (peekCP == CodePoint.SQLSTT) {
1:             String s = parseSQLSTT();
1:             //JCFTMP, need to null out the client list?
0:             netAgent_.netConnection_.xares_.addSpecialRegisters(s);
1:             peekCP = peekCodePoint();
1:         }
1:         return retval;
1:     }
1: 
1: 
1:     //------------------------parse DDM Scalars-----------------------------
1: 
1: 
1: 
1: 
1:     private String parseSQLSTT() throws DisconnectException {
1:         parseLengthAndMatchCodePoint(CodePoint.SQLSTT);
1:         return parseSQLSTTGRPNOCMorNOCS();
1:     }
1: 
1:     private String parseSQLSTTGRPNOCMorNOCS() throws DisconnectException {
1:         int mixedNullInd = readUnsignedByte();
1:         int singleNullInd = 0;
1:         String sqlsttString = null;
1:         int stringLength = 0;
1: 
1:         if (mixedNullInd == CodePoint.NULLDATA) {
1:             singleNullInd = readUnsignedByte();
1:             if (singleNullInd == CodePoint.NULLDATA) {
1:                 // throw DTAMCHRM
1:                 doDtamchrmSemantics();
1:             }
1:             // read 4-byte length
1:             stringLength = readInt();
1:             // read sqlstt string
1:             sqlsttString = readString(stringLength, netAgent_.targetTypdef_.getCcsidSbcEncoding());
1:         } else {
1:             // read 4-byte length
1:             stringLength = readInt();
1:             // read sqlstt string
1:             sqlsttString = readString(stringLength, netAgent_.targetTypdef_.getCcsidMbcEncoding());
1:             // read null indicator
1:             singleNullInd = readUnsignedByte();
1:         }
1:         return sqlsttString;
1:     }
1: 
1: 
0:     protected int parseXIDCNT() throws DisconnectException {
1:         parseLengthAndMatchCodePoint(CodePoint.XIDCNT);
1:         return readUnsignedShort();
1:     }
1: 
0:     protected Xid parseXID() throws DisconnectException {
1:         parseLengthAndMatchCodePoint(CodePoint.XID);
1:         int formatId = readInt();
1:         int gtridLen = readInt();
1:         int bqualLen = readInt();
1:         byte[] gtrid = readBytes(gtridLen);
1:         byte[] bqual = readBytes(bqualLen);
1: 
0:         return new org.apache.derby.client.ClientXid(formatId, gtrid, bqual);
1:     }
1: 
0:     protected java.util.Hashtable parseIndoubtList() throws DisconnectException {
0:         boolean found = false;
0:         int port = 0;
0:         int numXid = 0;
0:         String sIpAddr = null;
1:         int peekCP = peekCodePoint();
1:         parseLengthAndMatchCodePoint(CodePoint.PRPHRCLST);
1:         if (peekCP == CodePoint.XIDCNT) {
0:             found = true;
0:             numXid = parseXIDCNT();
1:             peekCP = peekCodePoint();
1:         }
0:         java.util.Hashtable indoubtTransactions = new java.util.Hashtable();
1:         while (peekCP == CodePoint.XID) {
1:             Xid xid = parseXID();
0:             indoubtTransactions.put(xid, new NetIndoubtTransaction(xid, null, null, null, sIpAddr, port));
1:             peekCP = peekCodePoint();
1:         }
1:         return indoubtTransactions;
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.net.NetXAConnectionReply
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.client.net;
1: 
0: import org.apache.derby.client.am.DisconnectException;
1: import org.apache.derby.client.am.ConnectionCallbackInterface;
0: import javax.transaction.xa.*;
1: 
0: public class NetXAConnectionReply extends NetResultSetReply
0: {
0:   NetXAConnectionReply (NetAgent netAgent, int bufferSize)
0:   {
0:     super (netAgent, bufferSize);
1:   }
0:   //----------------------------- entry points ---------------------------------
1: 
1: 
0:   public void readLocalXAStart (ConnectionCallbackInterface connection) throws DisconnectException
0:   {
1:   }
1: 
0:   public void readLocalXACommit (ConnectionCallbackInterface connection) throws DisconnectException
0:   {
1: 
0:     startSameIdChainParse();
0:     parseSYNCCTLreply(connection);
0:     endOfSameIdChainData();
1: 
0:     NetXACallInfo callInfo =
0:       netAgent_.netConnection_.xares_.callInfoArray_[netAgent_.netConnection_.currXACallInfoOffset_];
0:     callInfo.xaInProgress_ = false;
0:     callInfo.xaWasSuspended = false;
0:     connection.completeLocalCommit();
1:   }
1: 
0:   public void readLocalXARollback (ConnectionCallbackInterface connection) throws DisconnectException
0:   {
0:     startSameIdChainParse();
0:     parseSYNCCTLreply(connection);
0:     endOfSameIdChainData();
0:     connection.completeLocalRollback();
1:   }
1: 
0:   protected void readXaStartUnitOfWork(NetConnection conn) throws DisconnectException
0:   {
0:     startSameIdChainParse();
0:     parseSYNCCTLreply(conn);
0:     endOfSameIdChainData();
1:   }
1: 
0:   protected int readXaEndUnitOfWork(NetConnection conn) throws DisconnectException
0:   {
0:     NetXACallInfo callInfo = conn.xares_.callInfoArray_[conn.currXACallInfoOffset_];
0:     int xaFlags = callInfo.xaFlags_;
1: 
0:     startSameIdChainParse();
0:     parseSYNCCTLreply(conn);
0:     endOfSameIdChainData();
0:     if (xaFlags == XAResource.TMFAIL)
0:       return javax.transaction.xa.XAException.XA_RBROLLBACK;
0:     return javax.transaction.xa.XAResource.XA_OK;
1:   }
1: 
0:   protected int readXaPrepare(NetConnection conn) throws DisconnectException
0:   {
0:     startSameIdChainParse();
0:     int synctype = parseSYNCCTLreply(conn);
0:     endOfSameIdChainData();
1: 
0:     NetXACallInfo callInfo = conn.xares_.callInfoArray_[conn.currXACallInfoOffset_];
0:     if( synctype == NetXAResource.XARETVAL_XARDONLY )
0:     { // xaretval of read-only, make sure flag agrees
0:       callInfo.setReadOnlyTransactionFlag( true );
1:     }
0:     else
0:     { // xaretval NOT read-only, make sure flag agrees
0:       callInfo.setReadOnlyTransactionFlag( false );
1:     }
0:     return synctype;
1:   }
1: 
0:   protected void readXaCommit(NetConnection conn) throws DisconnectException
0:   {
0:     startSameIdChainParse();
0:     parseSYNCCTLreply(conn);
0:     endOfSameIdChainData();
1: 
0:     NetXACallInfo callInfo = conn.xares_.callInfoArray_[conn.currXACallInfoOffset_];
0:     callInfo.xaInProgress_ = false;
0:     conn.completeLocalCommit();
1:   }
1: 
0:   protected int readXaRollback(NetConnection conn) throws DisconnectException
0:   {
0:     startSameIdChainParse();
0:     parseSYNCCTLreply(conn);
0:     endOfSameIdChainData();
1: 
0:     NetXACallInfo callInfo = conn.xares_.callInfoArray_[conn.currXACallInfoOffset_];
0:     callInfo.xaInProgress_ = false;
0:     callInfo.xaWasSuspended = false;
0:     conn.completeLocalRollback();
1: 
0:     return javax.transaction.xa.XAResource.XA_OK;
1:     }
1: 
0:   protected void readXaRecover(NetConnection conn) throws DisconnectException
0:   {
0:     startSameIdChainParse();
0:     parseSYNCCTLreply(conn);
0:     endOfSameIdChainData();
1:   }
1: 
0:   protected void readXaForget(NetConnection conn) throws DisconnectException
0:   {
0:     startSameIdChainParse();
0:     parseSYNCCTLreply(conn);
0:     endOfSameIdChainData();
1:   }
0:   //----------------------helper methods----------------------------------------
1: 
0:   //--------------------- parse DDM Reply Data--------------------------------------
1: 
1: 
1:     // The SYNCCRD Reply Mesage
0:   //
0:   // Returned from Server:
0:   //   XARETVAL - required
0:   int parseSYNCCRD (ConnectionCallbackInterface connection) throws DisconnectException
0:   {
0:     boolean svrcodReceived = false;
0:     int svrcod = CodePoint.SVRCOD_INFO;
0:     int xaretval = 0;
0:     int synctype = 0;
0:     java.util.Hashtable indoubtTransactions = null;
0:     NetConnection conn = netAgent_.netConnection_;
1: 
0:     parseLengthAndMatchCodePoint (CodePoint.SYNCCRD);
0:     pushLengthOnCollectionStack();
0:     int peekCP = peekCodePoint();
1: 
0:     while (peekCP != Reply.END_OF_COLLECTION) {
1: 
0:       boolean foundInPass = false;
1: 
0:       if (peekCP == CodePoint.SVRCOD) {
0:         foundInPass = true;
0:         svrcodReceived = checkAndGetReceivedFlag (svrcodReceived);
0:         svrcod = parseSVRCOD (CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_ERROR);
1:         peekCP = peekCodePoint();
1:       }
1: 
0:       if (peekCP == CodePoint.XARETVAL) {
0:         foundInPass = true;
0:         xaretval = parseXARETVAL();
0:         conn.xares_.callInfoArray_[conn.currXACallInfoOffset_].xaRetVal_ =
0:             xaretval;
1:         peekCP = peekCodePoint();
1:       }
1: 
0:       if (peekCP == CodePoint.SYNCTYPE) {
0:         foundInPass = true;
0:         synctype = parseSYNCTYPE();
1:         peekCP = peekCodePoint();
1:       }
1: 
0:       if (peekCP == CodePoint.PRPHRCLST) {
0:         foundInPass = true;
0:         indoubtTransactions = parseIndoubtList();
0:         conn.setIndoubtTransactions(indoubtTransactions);
1:         peekCP = peekCodePoint();
1:       }
1: 
0:       if (!foundInPass)
0:         doPrmnsprmSemantics (peekCP);
1:     }
0:     popCollectionStack();
1: 
1: 
0:     return xaretval;
1: 
1:   }
1: 
0:   // Process XA return value
0:   protected int parseXARETVAL() throws DisconnectException
0:   {
0:     parseLengthAndMatchCodePoint (CodePoint.XARETVAL);
0:     return readInt();
1:   }
1: 
0:   // Process XA return value
0:   protected byte parseSYNCTYPE() throws DisconnectException
0:   {
0:     parseLengthAndMatchCodePoint (CodePoint.SYNCTYPE);
0:     return readByte();
1:   }
1: 
0:   // This method handles the parsing of all command replies and reply data
0:   // for the SYNNCTL command.
0:   protected int parseSYNCCTLreply (ConnectionCallbackInterface connection) throws DisconnectException
0:   {
0:     int retval = 0;
0:     int peekCP = peekCodePoint();
1: 
0:     if (peekCP != CodePoint.SYNCCRD) {
0:       parseSYNCCTLError (peekCP);
0:       return -1;
1:     }
0:     retval =  parseSYNCCRD (connection);
1: 
1:     peekCP = peekCodePoint();
0:     while (peekCP == CodePoint.SQLSTT) {
0:       String s = parseSQLSTT ();
0:       //JCFTMP, need to null out the client list?
0:       netAgent_.netConnection_.xares_.addSpecialRegisters(s);
1:       peekCP = peekCodePoint();
1:     }
1: 
0:     return retval;
1:   }
1: 
1: 
0:   //------------------------parse DDM Scalars-----------------------------
1: 
1: 
1: 
1: 
0:   private String parseSQLSTT () throws DisconnectException {
0:     parseLengthAndMatchCodePoint (CodePoint.SQLSTT);
0:       return parseSQLSTTGRPNOCMorNOCS ();
1:   }
1: 
0:   private String parseSQLSTTGRPNOCMorNOCS () throws DisconnectException
0:   {
0:     int mixedNullInd = readUnsignedByte();
0:     int singleNullInd = 0;
0:     String sqlsttString = null;
0:     int stringLength = 0;
1: 
0:     if (mixedNullInd == CodePoint.NULLDATA) {
0:       singleNullInd = readUnsignedByte();
0:       if (singleNullInd == CodePoint.NULLDATA) {
0:         // throw DTAMCHRM
0:         doDtamchrmSemantics();
1:       }
0:       // read 4-byte length
0:       stringLength = readInt();
0:       // read sqlstt string
0:       sqlsttString = readString (stringLength, netAgent_.targetTypdef_.getCcsidSbcEncoding());
1:     }
0:     else {
0:       // read 4-byte length
0:       stringLength = readInt();
0:       // read sqlstt string
0:       sqlsttString = readString (stringLength, netAgent_.targetTypdef_.getCcsidMbcEncoding());
0:       // read null indicator
0:       singleNullInd = readUnsignedByte();
1:     }
0:     return sqlsttString;
1:   }
1: 
1: 
0:   protected int parseXIDCNT () throws DisconnectException
0:   {
0:     parseLengthAndMatchCodePoint (CodePoint.XIDCNT);
0:     return readUnsignedShort();
1:   }
1: 
0:   protected Xid parseXID () throws DisconnectException
0:   {
0:     parseLengthAndMatchCodePoint (CodePoint.XID);
0:     int formatId = readInt();
0:     int gtridLen = readInt();
0:     int bqualLen = readInt();
0:     byte[] gtrid = readBytes(gtridLen);
0:     byte[] bqual = readBytes(bqualLen);
1: 
0:     return new org.apache.derby.client.ClientXid(formatId, gtrid, bqual);
1:   }
1: 
0:   protected java.util.Hashtable parseIndoubtList() throws DisconnectException
0:   {
0:     boolean found = false;
0:     int port = 0;
0:     int numXid = 0;
0:     String sIpAddr = null;
0:     int peekCP = peekCodePoint();
0:     parseLengthAndMatchCodePoint (CodePoint.PRPHRCLST);
1:     peekCP = peekCodePoint();
0:     if (peekCP == CodePoint.XIDCNT) {
0:       found = true;
0:       numXid = parseXIDCNT();
1:       peekCP = peekCodePoint();
1:     }
1: 
0:     java.util.Hashtable indoubtTransactions = new java.util.Hashtable();
0:     while( peekCP == CodePoint.XID )
0:     {
0:       Xid xid = parseXID();
0:       indoubtTransactions.put(xid, new NetIndoubtTransaction(xid, null, null, null, sIpAddr, port));
1:       peekCP = peekCodePoint();
1:     }
1: 
0:     return indoubtTransactions;
1:   }
1: 
1: }
1: 
1: 
1: 
============================================================================