1:b0db140: /*
1:b0db140:  *
1:b0db140:  * Derby - Class org.apache.derbyTesting.functionTests.tests.lang.SysDiagVTIMappingTest
1:b0db140:  *
1:b0db140:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:b0db140:  * contributor license agreements.  See the NOTICE file distributed with
1:b0db140:  * this work for additional information regarding copyright ownership.
1:b0db140:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:b0db140:  * (the "License"); you may not use this file except in compliance with
1:b0db140:  * the License.  You may obtain a copy of the License at
1:b0db140:  *
1:b0db140:  *    http://www.apache.org/licenses/LICENSE-2.0
1:b0db140:  *
1:b0db140:  * Unless required by applicable law or agreed to in writing, 
1:b0db140:  * software distributed under the License is distributed on an 
1:b0db140:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:b0db140:  * either express or implied. See the License for the specific 
1:b0db140:  * language governing permissions and limitations under the License.
2:b0db140:  */
1:b0db140: package org.apache.derbyTesting.functionTests.tests.lang;
4:b0db140: 
1:b0db140: import java.sql.CallableStatement;
1:1ae02c9: import java.sql.Connection;
1:b0db140: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.ResultSet;
1:b0db140: import java.sql.SQLException;
1:1ae02c9: import java.sql.Statement;
1:70ff9b0: import java.sql.Timestamp;
1:70ff9b0: import java.text.SimpleDateFormat;
1:38586ad: import java.util.Locale;
1:70ff9b0: import java.util.Properties;
1:1ae02c9: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:b0db140: 
1:b0db140: public final class SysDiagVTIMappingTest extends BaseJDBCTestCase {
1:b0db140: 
1:b0db140:     // Name of the log file to use when testing VTIs that expect one.
1:b0db140:     private static final String testLogFile = "sys_vti_test_derby.tstlog";
1:b0db140: 
1:271e7dd:     private static  final   String[]    ALL_SPACE_TABLE_COLUMNS =
1:271e7dd:     {
1:271e7dd:         "CONGLOMERATENAME", "ISINDEX", "NUMALLOCATEDPAGES", "NUMFREEPAGES",
1:271e7dd:         "NUMUNFILLEDPAGES", "PAGESIZE", "ESTIMSPACESAVING", "TABLEID"
1:271e7dd:     };
1:271e7dd: 
1:3c065e9:     private static  final   String  BAD_FROM_LIST_JOIN = "42ZB7";
1:3c065e9: 
1:b0db140:     /**
1:b0db140:      * Public constructor required for running test as standalone JUnit.
1:96fe058:      */
1:b0db140:     public SysDiagVTIMappingTest(String name)
1:b0db140:     {
1:b0db140:         super(name);
1:b0db140:     }
1:b0db140: 
1:b0db140:     public static Test suite()
1:271e7dd:     {
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite("Diagnostic VTI Table Mappings");
1:b0db140: 
1:70ff9b0:         Test    defaultSetup = TestConfiguration.defaultSuite( SysDiagVTIMappingTest.class );
1:70ff9b0: 
1:70ff9b0:         // turn on statement logging so there will be something in the error log
1:70ff9b0:         // to run these vtis against
1:70ff9b0:         Properties sysprops = new Properties();
1:70ff9b0:         sysprops.put( "derby.language.logStatementText", "true" );
1:70ff9b0:         Test    verboseTest = new SystemPropertyTestSetup ( defaultSetup, sysprops );
1:70ff9b0: 
1:70ff9b0:         suite.addTest( verboseTest );
1:70ff9b0: 
1:70ff9b0:          /* Some of the VTIs that are tested in this class require a derby.log
1:b0db140:          * file.  We have a test log file stored in the tests/lang directory,
1:b0db140:          * and since the VTIs are going to try to read it, the test log file
1:b0db140:          * must be in a directory for which Derby has read access.  By
1:b0db140:          * using a SupportFilesSetup wrapper, we copy the test log file to
1:b0db140:          * the "extin" directory, which has the required permissions.
1:271e7dd:          */
1:b0db140:         return SecurityManagerSetup.noSecurityManager(
1:b0db140:             new SupportFilesSetup(suite,
1:b0db140:                 new String [] {
1:b0db140:                     "functionTests/tests/lang/" + testLogFile
1:b0db140:                 }));
1:b0db140:     }
1:b0db140: 
1:b0db140:     public void setUp() throws Exception
1:b0db140:     {
1:98ceb6f:         Statement stmt = createStatement();
1:98ceb6f:         stmt.execute("create table app.t1 (i int, c varchar(10))");
1:98ceb6f:         stmt.execute("insert into app.t1 values (1, 'one'), "
1:b0db140:             + "(2, 'two'), (4, 'four')");
1:98ceb6f:         stmt.close();
1:b0db140:     }
1:b0db140: 
1:b0db140:     public void tearDown() throws Exception
1:b0db140:     {
1:98ceb6f:         Statement stmt = createStatement();
1:98ceb6f:         stmt.execute("drop table app.t1");
1:98ceb6f:         stmt.close();
1:98ceb6f:         super.tearDown();
1:b0db140:     }
1:b0db140: 
1:b0db140:     /**
1:b0db140:      * We use the SpaceTable VTI as our primary test VTI to verify that
1:b0db140:      * that VTI table mappings in general are working as expected.  So
1:b0db140:      * this method does a lot more than the other VTI test methods;
1:b0db140:      * the other test methods just do sanity checks to make sure that
1:b0db140:      * the mapping from "SYSCS_DIAG.<vti_table>" to the actual VTI
1:b0db140:      * class names in question is working correctly.
1:b0db140:      */
1:b0db140:     public void testSpaceTable() throws Exception
1:b0db140:     {
1:b0db140:         Statement st = createStatement();
1:b0db140:         st.executeUpdate("set schema APP");
1:b0db140:         
1:b0db140:         // Should fail because SPACE_TABLE is not defined in APP 
1:b0db140:         // schema.
1:b0db140:         
1:4aef9b0:         assertStatementError("42ZB4", st,
1:b0db140:             "select * from TABLE(SPACE_TABLE('APP')) x");
1:b0db140:         
1:4aef9b0:         assertStatementError("42ZB4", st,
1:b0db140:             "select * from TABLE(APP.SPACE_TABLE('APP', 'T1')) x");
1:b0db140:         
1:b0db140:         // Should fail due to extra "TABLE" keyword.
1:b0db140:         
1:b0db140:         assertStatementError("42X01", st,
1:b0db140:             "select * from TABLE TABLE(SYSCS_DIAG.SPACE_TABLE('T1')) x");
1:b0db140:         
1:b0db140:         assertStatementError("42X01", st,
1:b0db140:             "select * from TABLE TABLE (select * from t1) x");
1:b0db140:         
1:b0db140:         // Should fail because the specified schema does not exist.
1:b0db140:         
1:b0db140:         assertStatementError("42Y07", st,
1:b0db140:             "select * from TABLE(SYSCS_DIAG.SPACE_TABLE('T1', 'APP')) x");
1:b0db140:         
1:b0db140:         assertStatementError("42Y07", st,
1:b0db140:             "select * from "
1:b0db140:             + "TABLE(SYSCS_DIAG.SPACE_TABLE('NOTTHERE', 'T1')) x");
1:b0db140:         
1:b0db140:         // Should fail because SPACE_TABLE is not defined in APP schema.
1:b0db140:         
1:b0db140:         st.executeUpdate("set schema SYSCS_DIAG");
1:4aef9b0:         assertStatementError("42ZB4", st,
1:b0db140:             "select * from TABLE(APP.SPACE_TABLE('APP', 'T1')) x");
1:b0db140:         
1:b0db140:         // All remaining test cases in this method should succeed.
1:b0db140:         
1:b0db140:         st.executeUpdate("set schema APP");
1:b0db140: 
1:01c7acb:         // get table id
1:01c7acb:         ResultSet   rs1 = st.executeQuery
1:01c7acb:             (
1:01c7acb:              "select t.tableid from sys.systables t, sys.sysschemas s\n" +
1:01c7acb:              "where t.schemaid = s.schemaid\n" +
1:01c7acb:              "and s.schemaname = 'APP'\n" +
1:01c7acb:              "and t.tablename = 'T1'"
1:271e7dd:              );
1:01c7acb:         rs1.next();
1:01c7acb:         String      tableID = rs1.getString( 1 );
1:01c7acb:         rs1.close();
1:01c7acb: 
1:b0db140:         // These should all return 1 row for APP.T1.
1:b0db140:         
1:b0db140:         // Two-argument direct call.
1:b0db140:         ResultSet rs = st.executeQuery(
1:b0db140:             "select * from TABLE(SYSCS_DIAG.SPACE_TABLE('APP', 'T1')) x");
1:b0db140:         
1:271e7dd:         String [] expColNames = ALL_SPACE_TABLE_COLUMNS;
3:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         
1:b0db140:         String [][] expRS = new String [][]
1:b0db140:         {
1:01c7acb:             {"T1", "0", "1", "0", "1", "4096", "0", tableID}
1:b0db140:         };
1:b0db140:         
1:b0db140:         JDBC.assertFullResultSet(rs, expRS, true);
1:271e7dd:         
1:b0db140:         // Single-argument direct execution.
1:b0db140:         rs = st.executeQuery(
1:b0db140:             " select * from TABLE(SYSCS_DIAG.SPACE_TABLE('T1')) x");
1:b0db140:         
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         
1:b0db140:         expRS = new String [][]
1:b0db140:         {
1:01c7acb:             {"T1", "0", "1", "0", "1", "4096", "0", tableID}
1:b0db140:         };
1:b0db140:         
1:b0db140:         JDBC.assertFullResultSet(rs, expRS, true);
1:b0db140:         
1:b0db140:         // Two-argument prepare and execute.
1:b0db140:         PreparedStatement pSt = prepareStatement(
1:b0db140:             "select * from TABLE(SYSCS_DIAG.SPACE_TABLE(?, ?)) x");
1:b0db140: 
1:b0db140:         pSt.setString(1, "APP");
1:b0db140:         pSt.setString(2, "T1");
1:b0db140: 
1:b0db140:         rs = pSt.executeQuery();
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         
1:b0db140:         expRS = new String [][]
1:b0db140:         {
1:01c7acb:             {"T1", "0", "1", "0", "1", "4096", "0", tableID}
1:b0db140:         };
1:b0db140:         
1:b0db140:         JDBC.assertFullResultSet(rs, expRS, true);
1:b0db140:         
1:b0db140:         // Single-argument prepare and execute.
1:b0db140:         pSt = prepareStatement(
1:b0db140:             "select * from TABLE(SYSCS_DIAG.SPACE_TABLE(?)) x");
1:b0db140: 
1:b0db140:         pSt.setString(1, "T1");
1:b0db140: 
1:b0db140:         rs = pSt.executeQuery();
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         
1:b0db140:         expRS = new String [][]
1:b0db140:         {
1:01c7acb:             {"T1", "0", "1", "0", "1", "4096", "0", tableID}
1:b0db140:         };
1:b0db140:         
1:b0db140:         JDBC.assertFullResultSet(rs, expRS, true);
1:b0db140:         
1:b0db140:         // Statment should succeed but there will be no rows 
1:b0db140:         // because the tables do not exist.
1:b0db140:         
1:b0db140:         rs = st.executeQuery(
1:b0db140:             "select * from TABLE(SYSCS_DIAG.SPACE_TABLE('APP')) x");
1:b0db140:         
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         JDBC.assertDrainResults(rs, 0);
1:b0db140:         
1:b0db140:         rs = st.executeQuery(
1:b0db140:             "select * from TABLE(SYSCS_DIAG.SPACE_TABLE('APP', "
1:b0db140:             + "'NOTTHERE')) x");
1:b0db140:         
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         JDBC.assertDrainResults(rs, 0);
1:b0db140:         
1:b0db140:         rs = st.executeQuery(
1:b0db140:             "select * from "
1:b0db140:             + "TABLE(SYSCS_DIAG.SPACE_TABLE('SYSCS_DIAG', 'NOTTHERE')) x");
1:b0db140:         
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         JDBC.assertDrainResults(rs, 0);
1:b0db140:         
1:b0db140:         // Should see zero rows since LOCK_TABLE does not exist as 
1:b0db140:         // an actual base table (it's another VTI).
1:b0db140:         
1:b0db140:         rs = st.executeQuery(
1:b0db140:             "select * from "
1:b0db140:             + "TABLE(SYSCS_DIAG.SPACE_TABLE('SYSCS_DIAG', 'LOCK_TABLE')) x");
1:b0db140:         
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         JDBC.assertDrainResults(rs, 0);
1:b0db140:         
1:b0db140:         // Similar tests but in the SYSCS_DIAG schema, in which 
1:b0db140:         // case the schema-name for SPACE_TABLE should not be required.
1:b0db140:         
1:b0db140:         st.executeUpdate("set schema syscs_diag");
1:b0db140:         
1:b0db140:         // Should see 1 row for APP.T1.
1:b0db140:         
1:b0db140:         pSt = prepareStatement(
1:b0db140:             "select * from TABLE(SPACE_TABLE(?, ?)) x");
1:b0db140:         
1:b0db140:         pSt.setString(1, "APP");
1:b0db140:         pSt.setString(2, "T1");
1:b0db140: 
1:b0db140:         rs = pSt.executeQuery();
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         
1:b0db140:         expRS = new String [][]
1:b0db140:         {
1:01c7acb:             {"T1", "0", "1", "0", "1", "4096", "0", tableID}
1:b0db140:         };
1:b0db140:         
1:b0db140:         JDBC.assertFullResultSet(rs, expRS, true);
1:b0db140:         
1:b0db140:         // Should see zero rows since T1 does not exist within 
1:b0db140:         // schema "SYSCS_DIAG".
1:b0db140:         
1:b0db140:         pSt = prepareStatement("select * from TABLE(SPACE_TABLE(?)) x");
1:b0db140:         pSt.setString(1, "T1");
1:b0db140: 
1:b0db140:         rs = pSt.executeQuery();
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         JDBC.assertDrainResults(rs, 0);
1:b0db140:         
1:b0db140:         // Should see zero rows since LOCK_TABLE does not exist as 
1:b0db140:         // an actual base table (it's another VTI).
1:b0db140:         
1:b0db140:         rs = st.executeQuery(
1:b0db140:             "select * from TABLE(SPACE_TABLE('LOCK_TABLE')) x");
1:b0db140:         
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         JDBC.assertDrainResults(rs, 0);
1:b0db140:         
1:b0db140:         // Simple check to ensure that we we can join with the VTI.
1:b0db140:         
1:b0db140:         st.executeUpdate("set schema app");
1:b0db140:         rs = st.executeQuery(
1:b0db140:             "select cast (conglomeratename as varchar(30)), t1.* from"
1:b0db140:             + "  TABLE(SYSCS_DIAG.SPACE_TABLE('APP', 'T1')) x,"
1:b0db140:             + "  t1"
1:b0db140:             + " where x.conglomeratename is not null");
1:b0db140:         
1:b0db140:         expColNames = new String [] {"1", "I", "C"};
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         
1:b0db140:         expRS = new String [][]
1:b0db140:         {
1:b0db140:             {"T1", "1", "one"},
1:b0db140:             {"T1", "2", "two"},
1:b0db140:             {"T1", "4", "four"}
1:b0db140:         };
1:b0db140:         
1:b0db140:         JDBC.assertFullResultSet(rs, expRS, true);
1:b0db140: 
1:b0db140:         // Make sure old way of calling still works until it is 
1:b0db140:         // deprecated.
1:b0db140:         
1:b0db140:         st.executeUpdate("set schema APP");
1:b0db140:         rs = st.executeQuery(
1:b0db140:             "SELECT * FROM NEW org.apache.derby.diag.SpaceTable('T1') as x");
1:b0db140:         
1:271e7dd:         JDBC.assertColumnNames(rs, ALL_SPACE_TABLE_COLUMNS);
1:60dc440:         
1:b0db140:         expRS = new String [][]
1:b0db140:         {
1:01c7acb:             {"T1", "0", "1", "0", "1", "4096", "0", tableID}
1:b0db140:         };
1:b0db140:         
1:b0db140:         JDBC.assertFullResultSet(rs, expRS, true);
1:b0db140:         
1:b0db140:         rs = st.executeQuery(
1:b0db140:             "SELECT * FROM NEW "
1:b0db140:             + "org.apache.derby.diag.SpaceTable('APP', 'T1') as x");
1:b0db140:         
1:271e7dd:         JDBC.assertColumnNames(rs, ALL_SPACE_TABLE_COLUMNS);
1:b0db140:         
1:b0db140:         expRS = new String [][]
1:b0db140:         {
1:01c7acb:             {"T1", "0", "1", "0", "1", "4096", "0", tableID}
1:b0db140:         };
1:b0db140:         
1:b0db140:         JDBC.assertFullResultSet(rs, expRS, true);
1:b0db140: 
1:271e7dd:         // verify the syntax showcased in the Reference Guide section on SPACE_TABLE
1:271e7dd:         // (after the changes introduced by DERBY-5554)
1:271e7dd: 
1:271e7dd:         rs = st.executeQuery
1:271e7dd:             (
1:271e7dd:              "select t2.*\n" +
1:271e7dd:              "    from\n" +
1:271e7dd:              "        sys.systables systabs,\n" +
1:271e7dd:              "        table (syscs_diag.space_table()) as t2\n" +
1:271e7dd:              "    where systabs.tabletype = 'T'\n" +
1:271e7dd:              "    and systabs.tableid = t2.tableid\n"
1:3468143:              );        
1:3468143:         JDBC.assertColumnNames(rs, ALL_SPACE_TABLE_COLUMNS);
1:3468143:         JDBC.assertFullResultSet(rs, expRS, true);
1:3468143: 
1:3468143:         rs = st.executeQuery
1:3468143:             (
1:3468143:              "select t1.*\n" +
1:3468143:              "    from\n" +
1:3468143:              "        sys.systables systabs1,\n" +
1:3468143:              "        table (syscs_diag.space_table( systabs1.tablename )) as t1\n" +
1:3468143:              "    where systabs1.tabletype = 'T'\n" +
1:3468143:              "union\n" +
1:3468143:              "select t2.*\n" +
1:3468143:              "    from\n" +
1:3468143:              "        sys.systables systabs2,\n" +
1:3468143:              "        table (syscs_diag.space_table( systabs2.tablename )) as t2\n" +
1:3468143:              "    where systabs2.tabletype = 'T'\n"
1:3468143:              );        
1:271e7dd:         JDBC.assertColumnNames(rs, ALL_SPACE_TABLE_COLUMNS);
1:271e7dd:         JDBC.assertFullResultSet(rs, expRS, true);
1:271e7dd: 
1:60dc440:         // verify the fix to DERBY-5554: joins to VTIs in the FROM list still
1:60dc440:         // work when there are more than 1 base tables in the FROM list and
1:60dc440:         // they join in the WHERE clause
1:b0db140:         
1:60dc440:         rs = st.executeQuery
1:60dc440:             (
1:60dc440:              "select t2.*\n" +
1:60dc440:              "    from\n" +
1:60dc440:              "        sys.systables systabs,\n" +
1:60dc440:              "        table (syscs_diag.space_table(systabs.tablename)) as t2,\n" +
1:60dc440:              "        sys.sysconglomerates syscgs\n" +
1:60dc440:              "    where systabs.tabletype = 'T' and systabs.tableid = syscgs.tableid\n"
1:60dc440:              );        
1:60dc440:         JDBC.assertColumnNames(rs, ALL_SPACE_TABLE_COLUMNS);
1:60dc440:         JDBC.assertFullResultSet(rs, expRS, true);
1:60dc440: 
1:60dc440:         rs = st.executeQuery
1:60dc440:             (
1:60dc440:              "select t2.*\n" +
1:60dc440:              "    from\n" +
1:60dc440:              "        sys.sysconglomerates syscgs,\n" +
1:60dc440:              "        table (syscs_diag.space_table(systabs.tablename)) as t2,\n" +
1:60dc440:              "        sys.systables systabs\n" +
1:60dc440:              "    where systabs.tabletype = 'T' and systabs.tableid = syscgs.tableid\n"
1:60dc440:              );        
1:60dc440:         JDBC.assertColumnNames(rs, ALL_SPACE_TABLE_COLUMNS);
1:60dc440:         JDBC.assertFullResultSet(rs, expRS, true);
1:60dc440: 
1:b0db140:         // Now do some sanity checking to make sure SPACE_TABLE cannot be
1:b0db140:         // used in any illegal ways.        
1:b0db140: 
1:b0db140:         checkIllegalUses(st, "space_table", "SpaceTable",
1:b0db140:             "('APP', 'T1')", "conglomeratename");
1:b0db140: 
1:b0db140:         // Clean-up.
1:b0db140:         getConnection().rollback();
1:b0db140:         st.close();
1:b0db140:     }
1:3bbcfab: 
1:7cbf021:     /**
1:271e7dd:      * Test the 0-arg constructor of the SPACE_TABLE vti. See DERBY-5554.
1:7cbf021:      */
1:271e7dd:     public void testSpaceTable_0argConstructor() throws Exception
1:7cbf021:     {
1:271e7dd:         Statement st = createStatement();
1:271e7dd:         ResultSet   rs = st.executeQuery
1:271e7dd:             (
1:271e7dd:              "select conglomeratename, isindex, pagesize, tableid\n" +
1:271e7dd:              "from table(syscs_diag.space_table()) x\n" +
1:271e7dd:              "where conglomeratename like 'SYS%'\n" +
1:271e7dd:              "order by conglomeratename"
1:271e7dd:              );
1:271e7dd: 
1:271e7dd:         String[]  columnNames =
1:271e7dd:         {
1:271e7dd:             "CONGLOMERATENAME", "ISINDEX", "PAGESIZE", "TABLEID"
1:271e7dd:         };
1:271e7dd:         JDBC.assertColumnNames( rs, columnNames );
1:271e7dd:         
1:271e7dd:         String[][]  expRS = new String [][]
1:271e7dd:         {
1:271e7dd:             { "SYSALIASES", "0", "4096", "c013800d-00d7-ddbd-08ce-000a0a411400" },
1:271e7dd:             { "SYSALIASES_INDEX1", "1", "4096", "c013800d-00d7-ddbd-08ce-000a0a411400" },
1:271e7dd:             { "SYSALIASES_INDEX2", "1", "4096", "c013800d-00d7-ddbd-08ce-000a0a411400" },
1:271e7dd:             { "SYSALIASES_INDEX3", "1", "4096", "c013800d-00d7-ddbd-08ce-000a0a411400" },
1:271e7dd:             { "SYSCHECKS", "0", "4096", "80000056-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSCHECKS_INDEX1", "1", "4096", "80000056-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSCOLPERMS", "0", "4096", "286cc01e-0103-0e39-b8e7-00000010f010" },
1:271e7dd:             { "SYSCOLPERMS_INDEX1", "1", "4096", "286cc01e-0103-0e39-b8e7-00000010f010" },
1:271e7dd:             { "SYSCOLPERMS_INDEX2", "1", "4096", "286cc01e-0103-0e39-b8e7-00000010f010" },
1:271e7dd:             { "SYSCOLPERMS_INDEX3", "1", "4096", "286cc01e-0103-0e39-b8e7-00000010f010" },
1:271e7dd:             { "SYSCOLUMNS", "0", "4096", "8000001e-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSCOLUMNS_INDEX1", "1", "4096", "8000001e-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSCOLUMNS_INDEX2", "1", "4096", "8000001e-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSCONGLOMERATES", "0", "4096", "80000010-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSCONGLOMERATES_INDEX1", "1", "4096", "80000010-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSCONGLOMERATES_INDEX2", "1", "4096", "80000010-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSCONGLOMERATES_INDEX3", "1", "4096", "80000010-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSCONSTRAINTS", "0", "4096", "8000002f-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSCONSTRAINTS_INDEX1", "1", "4096", "8000002f-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSCONSTRAINTS_INDEX2", "1", "4096", "8000002f-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSCONSTRAINTS_INDEX3", "1", "4096", "8000002f-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSDEPENDS", "0", "4096", "8000003e-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSDEPENDS_INDEX1", "1", "4096", "8000003e-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSDEPENDS_INDEX2", "1", "4096", "8000003e-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSDUMMY1", "0", "4096", "c013800d-00f8-5b70-bea3-00000019ed88" },
1:271e7dd:             { "SYSFILES", "0", "4096", "80000000-00d3-e222-873f-000a0a0b1900" },
1:271e7dd:             { "SYSFILES_INDEX1", "1", "4096", "80000000-00d3-e222-873f-000a0a0b1900" },
1:271e7dd:             { "SYSFILES_INDEX2", "1", "4096", "80000000-00d3-e222-873f-000a0a0b1900" },
1:271e7dd:             { "SYSFOREIGNKEYS", "0", "4096", "8000005b-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSFOREIGNKEYS_INDEX1", "1", "4096", "8000005b-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSFOREIGNKEYS_INDEX2", "1", "4096", "8000005b-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSKEYS", "0", "4096", "80000039-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSKEYS_INDEX1", "1", "4096", "80000039-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSPERMS", "0", "4096", "9810800c-0121-c5e1-a2f5-00000043e718" },
1:271e7dd:             { "SYSPERMS_INDEX1", "1", "4096", "9810800c-0121-c5e1-a2f5-00000043e718" },
1:271e7dd:             { "SYSPERMS_INDEX2", "1", "4096", "9810800c-0121-c5e1-a2f5-00000043e718" },
1:271e7dd:             { "SYSPERMS_INDEX3", "1", "4096", "9810800c-0121-c5e1-a2f5-00000043e718" },
1:271e7dd:             { "SYSROLES", "0", "4096", "e03f4017-0115-382c-08df-ffffe275b270" },
1:271e7dd:             { "SYSROLES_INDEX1", "1", "4096", "e03f4017-0115-382c-08df-ffffe275b270" },
1:271e7dd:             { "SYSROLES_INDEX2", "1", "4096", "e03f4017-0115-382c-08df-ffffe275b270" },
1:271e7dd:             { "SYSROLES_INDEX3", "1", "4096", "e03f4017-0115-382c-08df-ffffe275b270" },
1:271e7dd:             { "SYSROUTINEPERMS", "0", "4096", "2057c01b-0103-0e39-b8e7-00000010f010" },
1:271e7dd:             { "SYSROUTINEPERMS_INDEX1", "1", "4096", "2057c01b-0103-0e39-b8e7-00000010f010" },
1:271e7dd:             { "SYSROUTINEPERMS_INDEX2", "1", "4096", "2057c01b-0103-0e39-b8e7-00000010f010" },
1:271e7dd:             { "SYSROUTINEPERMS_INDEX3", "1", "4096", "2057c01b-0103-0e39-b8e7-00000010f010" },
1:271e7dd:             { "SYSSCHEMAS", "0", "4096", "80000022-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSSCHEMAS_INDEX1", "1", "4096", "80000022-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSSCHEMAS_INDEX2", "1", "4096", "80000022-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSSEQUENCES", "0", "4096", "9810800c-0121-c5e2-e794-00000043e718" },
1:271e7dd:             { "SYSSEQUENCES_INDEX1", "1", "4096", "9810800c-0121-c5e2-e794-00000043e718" },
1:271e7dd:             { "SYSSEQUENCES_INDEX2", "1", "4096", "9810800c-0121-c5e2-e794-00000043e718" },
1:271e7dd:             { "SYSSTATEMENTS", "0", "4096", "80000000-00d1-15f7-ab70-000a0a0b1500" },
1:271e7dd:             { "SYSSTATEMENTS_INDEX1", "1", "4096", "80000000-00d1-15f7-ab70-000a0a0b1500" },
1:271e7dd:             { "SYSSTATEMENTS_INDEX2", "1", "4096", "80000000-00d1-15f7-ab70-000a0a0b1500" },
1:271e7dd:             { "SYSSTATISTICS", "0", "4096", "f81e0010-00e3-6612-5a96-009e3a3b5e00" },
1:271e7dd:             { "SYSSTATISTICS_INDEX1", "1", "4096", "f81e0010-00e3-6612-5a96-009e3a3b5e00" },
1:271e7dd:             { "SYSTABLEPERMS", "0", "4096", "b8450018-0103-0e39-b8e7-00000010f010" },
1:271e7dd:             { "SYSTABLEPERMS_INDEX1", "1", "4096", "b8450018-0103-0e39-b8e7-00000010f010" },
1:271e7dd:             { "SYSTABLEPERMS_INDEX2", "1", "4096", "b8450018-0103-0e39-b8e7-00000010f010" },
1:271e7dd:             { "SYSTABLEPERMS_INDEX3", "1", "4096", "b8450018-0103-0e39-b8e7-00000010f010" },
1:271e7dd:             { "SYSTABLES", "0", "4096", "80000018-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSTABLES_INDEX1", "1", "4096", "80000018-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSTABLES_INDEX2", "1", "4096", "80000018-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSTRIGGERS", "0", "4096", "c013800d-00d7-c025-4809-000a0a411200" },
1:271e7dd:             { "SYSTRIGGERS_INDEX1", "1", "4096", "c013800d-00d7-c025-4809-000a0a411200" },
1:271e7dd:             { "SYSTRIGGERS_INDEX2", "1", "4096", "c013800d-00d7-c025-4809-000a0a411200" },
1:271e7dd:             { "SYSTRIGGERS_INDEX3",  "1", "4096", "c013800d-00d7-c025-4809-000a0a411200" },
1:271e7dd:             { "SYSUSERS", "0", "4096", "9810800c-0134-14a5-40c1-000004f61f90" },
1:271e7dd:             { "SYSUSERS_INDEX1", "1", "4096", "9810800c-0134-14a5-40c1-000004f61f90" },
1:271e7dd:             { "SYSVIEWS", "0", "4096", "8000004d-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:             { "SYSVIEWS_INDEX1", "1", "4096", "8000004d-00d0-fd77-3ed8-000a0a0b1900" },
1:271e7dd:         };
1:271e7dd:         
1:271e7dd:         JDBC.assertFullResultSet(rs, expRS, true);
1:271e7dd:     }
1:271e7dd:     
1:271e7dd:     /**
1:3c065e9:      * Verify that you can't join diagnostic VTIs to one another in the FROM list. See DERBY-5554.
1:3c065e9:      */
1:3c065e9:     public void test_vti2vtiJoinInFromList() throws Exception
1:3c065e9:     {
1:3c065e9:         Connection  conn = getConnection();
1:3c065e9:         Statement st = createStatement();
1:3c065e9: 
1:3c065e9:         // joins to real tables are ok
1:3c065e9:         conn.prepareStatement
1:3c065e9:             (
1:3c065e9:              "select t1.*\n" +
1:3c065e9:              "from \n" +
1:3c065e9:              "    sys.systables systabs,\n" +
1:3c065e9:              "    table ( syscs_diag.space_table( systabs.tablename ) ) as t1\n" +
1:3c065e9:              "where systabs.tabletype = 'T'\n"
1:3c065e9:              );
1:3c065e9:         conn.prepareStatement
1:3c065e9:             (
1:3c065e9:              "select t1.*\n" +
1:3c065e9:              "from \n" +
1:3c065e9:              "    table ( syscs_diag.space_table( systabs.tablename ) ) as t1,\n" +
1:3c065e9:              "    sys.systables systabs\n" +
1:3c065e9:              "where systabs.tabletype = 'T'\n"
1:3c065e9:              );
1:3c065e9: 
1:3c065e9:         // can't join VTIs to one another in the FROM list
1:3c065e9:         assertStatementError
1:3c065e9:             (
1:3c065e9:              BAD_FROM_LIST_JOIN,
1:3c065e9:              st,
1:3c065e9:              "select t1.*, t2.*\n" +
1:3c065e9:              "from \n" +
1:3c065e9:              "    sys.systables systabs,\n" +
1:3c065e9:              "    table ( syscs_diag.space_table( systabs.tablename ) ) as t1,\n" +
1:3c065e9:              "    table ( syscs_diag.space_table( t1.conglomeratename ) ) as t2\n" +
1:3c065e9:              "where systabs.tabletype = 'T'\n"
1:3c065e9:              );
1:3c065e9:         assertStatementError
1:3c065e9:             (
1:3c065e9:              "42X04",
1:3c065e9:              st,
1:3c065e9:              "select t1.*, t2.*\n" +
1:3c065e9:              "from \n" +
1:3c065e9:              "    sys.systables systabs,\n" +
1:3c065e9:              "    table ( syscs_diag.space_table( t1.conglomeratename ) ) as t2,\n" +
1:3c065e9:              "    table ( syscs_diag.space_table( systabs.tablename ) ) as t1\n" +
1:3c065e9:              "where systabs.tabletype = 'T'\n"
1:3c065e9:              );
1:3c065e9: 
1:3c065e9:     }
1:3c065e9:     
1:3c065e9:     /**
1:b0db140:      * Just run a couple of sanity checks to makes sure the table
1:b0db140:      * mapping for org.apache.derby.diag.StatementDuration() works
1:b0db140:      * correctly and fails where it is supposed to.
1:b0db140:      */
1:b0db140:     public void testStatementDuration() throws Exception
1:b0db140:     {
1:b0db140:         Statement st = createStatement();
1:b0db140:         st.executeUpdate("set schema APP");
1:cf530d5: 
1:b0db140:         // Do a simple check to make sure the VTI mapping works.
1:b0db140:         
1:b0db140:         java.net.URL logURL = SupportFilesSetup.getReadOnlyURL(testLogFile);
1:b0db140:         String vtiArg = "('" + logURL.getFile() + "')";
1:b0db140:         ResultSet rs = st.executeQuery(
1:b0db140:             "select * from "
1:b0db140:             + "TABLE(SYSCS_DIAG.STATEMENT_DURATION" + vtiArg + ") x");
1:b0db140:         
2:b0db140:         String [] expColNames = new String [] {
1:b0db140:             "TS", "THREADID", "XID", "LCCID", "LOGTEXT", "DURATION"};
1:b0db140: 
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         String [][] expRS = new String [][]
1:b0db140:         {
1:70ff9b0:             {"2006-12-15 16:14:58.280 GMT", "main,5,main", "1111", "0",
1:b0db140:                 "(DATABASE = ugh), (DRDAID = null), Cleanup action starting",
1:b0db140:                 "0"}
1:b0db140:         };
1:b0db140:         
1:b0db140:         JDBC.assertFullResultSet(rs, expRS, true);
1:b0db140: 
1:b0db140:         // Make sure old way of calling still works until it is 
1:b0db140:         // deprecated.
1:b0db140:         
1:b0db140:         rs = st.executeQuery(
1:b0db140:             "SELECT * FROM NEW "
1:b0db140:             + "org.apache.derby.diag.StatementDuration" + vtiArg + " as x");
1:b0db140:         
13:b0db140:         expColNames = new String [] {
1:b0db140:             "TS", "THREADID", "XID", "LCCID", "LOGTEXT", "DURATION"};
1:b0db140: 
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         expRS = new String [][]
1:b0db140:         {
1:70ff9b0:             {"2006-12-15 16:14:58.280 GMT", "main,5,main", "1111", "0",
1:b0db140:                 "(DATABASE = ugh), (DRDAID = null), Cleanup action starting",
1:b0db140:                 "0"}
1:b0db140:         };
1:b0db140:         
1:b0db140:         JDBC.assertFullResultSet(rs, expRS, true);
1:b0db140: 
1:b0db140:         // And finally, do the usual checks for invalid uses.
1:b0db140: 
1:b0db140:         checkIllegalUses(st, "statement_duration", "StatementDuration",
1:b0db140:             vtiArg, "logtext");
1:b0db140:     }
1:b0db140: 
1:70ff9b0:     /**
1:b0db140:      * Just run a couple of sanity checks to makes sure the table
1:b0db140:      * mapping for org.apache.derby.diag.ErrorLogReader() works
1:b0db140:      * correctly and fails where it is supposed to.
1:b0db140:      */
1:b0db140:     public void testErrorLogReader() throws Exception
1:b0db140:     {
1:b0db140:         Statement st = createStatement();
1:b0db140:         st.executeUpdate("set schema APP");
1:b0db140: 
1:b0db140:         // Do a simple check to make sure the VTI mapping works.
1:b0db140:         
1:b0db140:         java.net.URL logURL = SupportFilesSetup.getReadOnlyURL(testLogFile);
1:b0db140:         String vtiArg = "('" + logURL.getFile() + "')";
1:b0db140:         ResultSet rs = st.executeQuery(
1:b0db140:             " select * from "
1:b0db140:             + "TABLE(SYSCS_DIAG.ERROR_LOG_READER" + vtiArg + ") x");
1:b0db140:         
1:b0db140:         String [] expColNames = new String [] {
1:b0db140:             "TS", "THREADID", "XID", "LCCID", "DATABASE", "DRDAID", "LOGTEXT"};
1:b0db140: 
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         String [][] expRS = new String [][]
1:b0db140:         {
1:70ff9b0:             {"2006-12-15 16:14:58.280 GMT", "main,5,main", "1111", "0", "ugh",
1:b0db140:                 "null", "Cleanup action starting"},
1:70ff9b0:             {"2006-12-15 16:14:58.280 GMT", "main,5,main", "1111", "0", "ugh",
1:b0db140:                 "null", "Failed Statement is: select * from oops"}
1:b0db140:         };
1:b0db140:         
1:b0db140:         JDBC.assertFullResultSet(rs, expRS, true);
1:b0db140: 
1:b0db140:         // Make sure old way of calling still works until it is 
1:b0db140:         // deprecated.
1:b0db140:         
1:b0db140:         rs = st.executeQuery(
1:b0db140:             "SELECT * FROM NEW" +
1:b0db140:             " org.apache.derby.diag.ErrorLogReader" + vtiArg + " as x");
1:b0db140:         
1:b0db140:         expColNames = new String [] {
1:b0db140:             "TS", "THREADID", "XID", "LCCID", "DATABASE", "DRDAID", "LOGTEXT"};
1:b0db140: 
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         expRS = new String [][]
1:b0db140:         {
1:70ff9b0:             {"2006-12-15 16:14:58.280 GMT", "main,5,main", "1111", "0", "ugh",
1:b0db140:                 "null", "Cleanup action starting"},
1:70ff9b0:             {"2006-12-15 16:14:58.280 GMT", "main,5,main", "1111", "0", "ugh",
1:b0db140:                 "null", "Failed Statement is: select * from oops"}
1:b0db140:         };
1:b0db140: 
1:b0db140:         JDBC.assertFullResultSet(rs, expRS, true);
1:b0db140: 
1:b0db140:         // And finally, do the usual checks for invalid uses.
1:b0db140: 
1:b0db140:         checkIllegalUses(st, "error_log_reader", "ErrorLogReader",
1:b0db140:             vtiArg, "logtext");
1:b0db140:     }
1:b0db140: 
1:3bbcfab:     /**
1:b0db140:      * Tests to make sure that attempts to use the TABLE constructor
1:b0db140:      * with things other than the VTI diagnostic table functions
1:b0db140:      * do not work (with the exception of SELECT and VALUES queries,
1:b0db140:      * which should work as normal).
1:b0db140:      */
1:b0db140:     public void testInvalidTableFunctions() throws Exception
1:b0db140:     {
1:b0db140:         // Sanity check: make sure SELECT and VALUES clauses still  work.
1:b0db140:         
1:b0db140:         Statement st = createStatement();
1:b0db140:         st.executeUpdate("set schema APP");
1:b0db140: 
1:b0db140:         ResultSet rs = st.executeQuery(
1:b0db140:             "select * from table (select * from t1) x");
1:b0db140:         
1:b0db140:         String [] expColNames = new String [] {"I", "C"};
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         
1:b0db140:         String [][] expRS = new String [][]
1:b0db140:         {
1:b0db140:             {"1", "one"},
1:b0db140:             {"2", "two"},
1:b0db140:             {"4", "four"}
1:b0db140:         };
1:b0db140:         
1:b0db140:         JDBC.assertFullResultSet(rs, expRS, true);
1:b0db140:         
1:b0db140:         rs = st.executeQuery(
1:b0db140:             " select * from table (values (1, 2), (2, 3)) x");
1:b0db140:         
1:b0db140:         expColNames = new String [] {"1", "2"};
1:b0db140:         JDBC.assertColumnNames(rs, expColNames);
1:b0db140:         
1:b0db140:         expRS = new String [][]
1:b0db140:         {
1:b0db140:             {"1", "2"},
1:b0db140:             {"2", "3"}
1:b0db140:         };
1:b0db140:         
1:b0db140:         JDBC.assertFullResultSet(rs, expRS, true);
1:b0db140:         
1:b0db140:         // Use of TABLE constructor with regular tables should fail.
1:b0db140: 
1:b0db140:         assertStatementError("42X01", st, "select * from table (app.t1) x");
1:4aef9b0:         assertStatementError("42ZB4", st, "select * from table (app.t1()) x");
1:b0db140: 
1:b0db140:         // Use of TABLE constructor with VTI tables (as opposed to VTI
1:b0db140:         // table *functions*) should fail.
1:b0db140: 
1:b0db140:         assertStatementError("42X01", st,
1:b0db140:             "select * from table (syscs_diag.lock_table) x");
1:b0db140: 
4:b0db140:         assertStatementError("42Y03", st,
1:b0db140:             "select * from table (syscs_diag.lock_table()) x");
1:b0db140: 
1:b0db140:         assertStatementError("42X01", st,
1:b0db140:             "select * from table (syscs_diag.transaction_table) x");
1:b0db140: 
1:b0db140:         assertStatementError("42Y03", st,
1:b0db140:             "select * from table (syscs_diag.transaction_table()) x");
1:b0db140: 
1:b0db140:         assertStatementError("42X01", st,
1:b0db140:             "select * from table (syscs_diag.statement_cache) x");
1:b0db140: 
1:b0db140:         assertStatementError("42Y03", st,
1:b0db140:             "select * from table (syscs_diag.statement_cache()) x");
1:b0db140: 
1:b0db140:         assertStatementError("42X01", st,
1:b0db140:             "select * from table (syscs_diag.error_messages) x");
1:b0db140: 
1:b0db140:         assertStatementError("42Y03", st,
1:b0db140:             "select * from table (syscs_diag.error_messages()) x");
1:b0db140: 
1:b0db140:         // Clean-up.
1:b0db140:         getConnection().rollback();
1:b0db140:         st.close();
1:b0db140:     }
1:b0db140: 
1:cf530d5:     /**
1:cf530d5:      * Test that diagnostic VTIs will work correctly when an ORDER BY
1:cf530d5:      * clause appears and/or sort elimination occurs.  DERBY-2805.
1:cf530d5:      */
1:cf530d5:     public void testOrderBy() throws SQLException
1:cf530d5:     {
1:cf530d5:         Statement st = createStatement();
1:cf530d5:         st.executeUpdate("set schema APP");
1:cf530d5: 
1:cf530d5:         // Create a single testing table for this fixture only.
1:cf530d5: 
1:cf530d5:         st.execute("create table ob_t1 (i int, c char(250))");
1:cf530d5:         st.execute("create index i_ix on ob_t1 (i)");
1:cf530d5:         st.execute("create index c_ix on ob_t1 (c desc)");
1:cf530d5: 
1:cf530d5:         /* Several queries to make sure ORDER BY actually takes effect.
1:cf530d5:          * First execute with just the ORDER BY, then execute with the
1:cf530d5:          * ORDER BY *and* a DISTINCT. The latter leads to sort elimination
1:cf530d5:          * but should still run without error and return the same results
1:cf530d5:          * (prior to the fix for DERBY-2805 the sort elimination would
1:cf530d5:          * lead to an ASSERT failure with sane builds).
1:cf530d5:          */
1:cf530d5: 
1:cf530d5:         String [][] expRS = new String [][]
1:cf530d5:         {
1:cf530d5:             {"C_IX", "1", "0"},
1:cf530d5:             {"I_IX", "1", "0"},
1:cf530d5:             {"OB_T1", "0", "0"},
1:cf530d5:         };
1:cf530d5: 
1:cf530d5:         ResultSet rs = st.executeQuery(
1:cf530d5:             "select CONGLOMERATENAME, ISINDEX, NUMFREEPAGES from " +
1:cf530d5:             "table(syscs_diag.space_table('OB_T1')) X order by 1");
1:cf530d5: 
1:cf530d5:         JDBC.assertFullResultSet(rs, expRS);
1:cf530d5: 
1:cf530d5:         rs = st.executeQuery(
1:cf530d5:             "select distinct CONGLOMERATENAME, ISINDEX, NUMFREEPAGES from " +
1:cf530d5:             "table(syscs_diag.space_table('OB_T1')) X order by 1");
1:cf530d5: 
1:cf530d5:         JDBC.assertFullResultSet(rs, expRS);
1:cf530d5: 
1:cf530d5:         expRS = new String [][]
1:cf530d5:         {
1:cf530d5:             {"OB_T1", "0", "0"},
1:cf530d5:             {"C_IX", "1", "0"},
1:cf530d5:             {"I_IX", "1", "0"},
1:cf530d5:         };
1:cf530d5: 
1:cf530d5:         rs = st.executeQuery(
1:cf530d5:             "select CONGLOMERATENAME, ISINDEX, NUMFREEPAGES from " +
1:cf530d5:             "table(syscs_diag.space_table('OB_T1')) X order by 2, 1");
1:cf530d5: 
1:cf530d5:         JDBC.assertFullResultSet(rs, expRS);
1:cf530d5: 
1:cf530d5:         rs = st.executeQuery(
1:cf530d5:             "select distinct CONGLOMERATENAME, ISINDEX, NUMFREEPAGES from " +
1:cf530d5:             "table(syscs_diag.space_table('OB_T1')) X order by 2, 1");
1:cf530d5: 
1:cf530d5:         JDBC.assertFullResultSet(rs, expRS);
1:cf530d5:         expRS = new String [][]
1:cf530d5:         {
1:cf530d5:             {"OB_T1", "0", "0"},
1:cf530d5:             {"I_IX", "1", "0"},
1:cf530d5:             {"C_IX", "1", "0"},
1:cf530d5:         };
1:cf530d5: 
1:cf530d5:         rs = st.executeQuery(
1:cf530d5:             "select CONGLOMERATENAME, ISINDEX, NUMFREEPAGES from " +
1:cf530d5:             "table(syscs_diag.space_table('OB_T1')) X order by 2, 1 desc");
1:cf530d5: 
1:cf530d5:         JDBC.assertFullResultSet(rs, expRS);
1:cf530d5: 
1:cf530d5:         rs = st.executeQuery(
1:cf530d5:             "select distinct CONGLOMERATENAME, ISINDEX, NUMFREEPAGES from " +
1:cf530d5:             "table(syscs_diag.space_table('OB_T1')) X order by 2, 1 desc");
1:cf530d5: 
1:cf530d5:         JDBC.assertFullResultSet(rs, expRS);
1:b0db140: 
1:cf530d5:         // Cleanup.
1:cf530d5: 
1:cf530d5:         st.execute("drop table ob_t1");
1:cf530d5:         st.close();
1:cf530d5:     }
1:cf530d5: 
1:b0db140:     /**
1:3bbcfab:      * Test that diagnostic VTIs will work correctly when they
1:3bbcfab:      * are invoked in a subquery with correlated references to
1:3bbcfab:      * outer query blocks.  DERBY-3138.
1:3bbcfab:      */
1:3bbcfab:     public void testCorrelatedReferences() throws SQLException
1:3bbcfab:     {
1:7cbf021:         Statement   st = createStatement();
1:3bbcfab:         String      [][] expRS = new String [][] {};
1:7cbf021: 
1:7cbf021:         ResultSet rs = st.executeQuery
1:3bbcfab:             (
1:3bbcfab:              "select s.schemaname, t.tableName\n" +
1:3bbcfab:              "from sys.sysschemas s, sys.systables t\n" +
1:3bbcfab:              "where t.schemaid=s.schemaid\n" +
1:3bbcfab:              "and exists\n" +
1:3bbcfab:              "(\n" +
1:3bbcfab:              "  select vti.*\n" +
1:3bbcfab:              "  from table( syscs_diag.space_table( s.schemaname, t.tableName ) ) as vti\n" +
1:3bbcfab:              "  where vti.numfreepages < -1\n" +
1:3bbcfab:              ")\n"
1:01c7acb:              );
1:7cbf021:         
1:3bbcfab:         JDBC.assertFullResultSet(rs, expRS);
1:3bbcfab: 
1:3bbcfab:         rs.close();
1:3bbcfab:         st.close();
1:3bbcfab:     }
1:3bbcfab: 
1:b0db140:     /**
1:2d3c23a:      * Basic sanity test for SYSCS_DIAG.CONTAINED_ROLES. See also the
1:2d3c23a:      * tools/ij_show_roles.sql test for a test that actually defines and uses
1:2d3c23a:      * roles with this VTI.
1:b0db140:      */
1:2d3c23a:     public void testContainedRoles() throws SQLException
1:b0db140:     {
1:3bbcfab:         Statement   st = createStatement();
1:3bbcfab: 
1:2d3c23a:         // 2-arg version
1:3bbcfab:         ResultSet rs = st.executeQuery
1:2d3c23a:             ("select * from table(syscs_diag.contained_roles(null, 0))t");
1:2d3c23a: 
1:2d3c23a:         JDBC.assertEmpty(rs);
1:2d3c23a: 
1:2d3c23a:         // 1-arg version
1:2d3c23a:         rs = st.executeQuery
1:2d3c23a:             ("select * from table(syscs_diag.contained_roles(null))t");
1:7cbf021: 
1:7cbf021:         JDBC.assertEmpty(rs);
1:7cbf021: 
1:7cbf021:         rs.close();
1:7cbf021:         st.close();
1:7cbf021:     }
1:b0db140: 
1:b0db140:     /**
1:70ff9b0:      * Test date formatting in the vtis which read the error log. This attempts
1:70ff9b0:      * to keep us from breaking these vtis if the format of logged timestamps
1:70ff9b0:      * changes. See DERBY-5391.
1:70ff9b0:      */
1:70ff9b0:     public  void    test_5391() throws Exception
1:70ff9b0:     {
1:70ff9b0:         Statement   st = createStatement();
1:70ff9b0: 
1:70ff9b0:         ResultSet   rs1 = st.executeQuery( "select * from table (syscs_diag.error_log_reader( )) as t1" );
1:70ff9b0:         vetTimestamp( rs1 );
1:70ff9b0:         rs1.close();
1:70ff9b0: 
1:70ff9b0:         ResultSet   rs2 = st.executeQuery( "select * from table (syscs_diag.statement_duration()) as t1" );
1:70ff9b0:         vetTimestamp( rs2 );
1:70ff9b0:         rs2.close();
1:70ff9b0: 
1:70ff9b0:         st.close();
1:70ff9b0:     }
1:70ff9b0:     private void    vetTimestamp( ResultSet rs ) throws Exception
1:70ff9b0:     {
1:70ff9b0:         assertTrue( rs.next() );
1:70ff9b0: 
1:70ff9b0:         String  timestampString = rs.getString( 1 ).trim();
1:70ff9b0: 
1:38586ad:         SimpleDateFormat sdf =
1:38586ad:             new SimpleDateFormat("EEE MMM dd HH:mm:ss zzz yyyy", Locale.US);
1:70ff9b0:         Timestamp   timestamp = new Timestamp( sdf.parse( timestampString ).getTime() );
1:70ff9b0: 
1:70ff9b0:         println( timestamp.toString() );
1:70ff9b0:     }
1:70ff9b0: 
1:b0db140:     /* All statements in this method should fail because a VTI table-
1:b0db140:      * mapping that takes arguments can only be used as part of the TABLE 
1:b0db140:      * constructor.  Any other uses of, or attempts to modify, such a
1:b0db140:      * VTI table should throw an appropriate error.
1:b0db140:      */
1:b0db140:     private void checkIllegalUses(Statement st, String vtiTableName,
1:b0db140:         String vtiMethodName, String args, String colName) throws SQLException
1:b0db140:     {
1:b0db140:         assertStatementError("42X05", st,
1:b0db140:             "select * from syscs_diag." + vtiTableName);
1:b0db140:         
1:b0db140:         assertStatementError("42X01", st,
1:b0db140:             "select * from syscs_diag." + vtiTableName + args + " x");
1:b0db140:         
1:b0db140:         assertStatementError("42X01", st,
1:b0db140:             "select * from (syscs_diag." + vtiTableName + args + ") x");
1:b0db140:         
1:b0db140:         assertStatementError("42Y55", st,
1:b0db140:             "drop table syscs_diag." + vtiTableName);
1:b0db140:         
1:b0db140:         assertStatementError("42X01", st,
1:b0db140:             "drop table syscs_diag." + vtiTableName + args);
1:b0db140:         
1:b0db140:         assertStatementError("42X62", st,
1:b0db140:             "drop function syscs_diag." + vtiTableName);
1:b0db140:         
1:b0db140:         assertStatementError("42X01", st,
1:b0db140:             "drop function syscs_diag." + vtiTableName + args);
1:b0db140:         
1:b0db140:         assertStatementError("42X62", st,
1:b0db140:             "alter table syscs_diag." + vtiTableName + " add column bad int");
1:b0db140:         
1:b0db140:         assertStatementError("42X01", st,
1:b0db140:             "alter table syscs_diag." + vtiTableName + args
1:b0db140:             + " add column bad int");
1:b0db140:         
1:b0db140:         assertStatementError("42X05", st,
1:b0db140:             "update syscs_diag." + vtiTableName
1:b0db140:             + " set " + colName + " = NULL");
1:b0db140:         
1:b0db140:         assertStatementError("42X01", st,
1:b0db140:             "update syscs_diag." + vtiTableName + args + " set "
1:b0db140:             + colName + "  = NULL");
1:b0db140:         
1:b0db140:         assertStatementError("42X05", st,
1:b0db140:             "delete from syscs_diag." + vtiTableName + " where 1 = 1");
1:b0db140:         
1:b0db140:         assertStatementError("42X01", st,
1:b0db140:             "delete from syscs_diag." + vtiTableName + args + " where 1 = 1");
1:b0db140:         
1:b0db140:         assertStatementError("42X05", st,
1:b0db140:             "insert into syscs_diag." + vtiTableName + " values('bad')");
1:b0db140:         
1:b0db140:         assertStatementError("42X05", st,
1:b0db140:             "insert into syscs_diag." + vtiTableName + " (" + colName
1:b0db140:             + ") values('bad')");
1:b0db140:         
1:b0db140:         assertStatementError("42X01", st,
1:b0db140:             "insert into syscs_diag." + vtiTableName + args
1:b0db140:             + " values('bad')");
1:b0db140:         
1:b0db140:         CallableStatement cSt = prepareCall(
1:b0db140:             "call SYSCS_UTIL.SYSCS_COMPRESS_TABLE(?, ?, 1)");
1:b0db140:         cSt.setString(1, "SYSCS_DIAG");
1:b0db140:         cSt.setString(2, vtiTableName.toUpperCase());
1:96fe058: 
1:de3b108:         assertStatementError("42X62", cSt);
1:b0db140:         
1:b0db140:         cSt = prepareCall(
1:b0db140:             "call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?, ?, 1, 1, 1)");
1:b0db140:         cSt.setString(1, "SYSCS_DIAG");
1:b0db140:         cSt.setString(2, vtiTableName.toUpperCase());
1:818fd27:         assertStatementError("42Y55", cSt);
1:b0db140: 
1:b0db140:         assertStatementError("42X08", st,
1:b0db140:             "update new org.apache.derby.diag." + vtiMethodName + args
1:b0db140:             + " set " + colName + " = NULL");
1:b0db140:         
1:b0db140:         assertStatementError("42X08", st,
1:b0db140:             "delete from new org.apache.derby.diag." + vtiMethodName + args
1:b0db140:             + " where 1 = 0");
1:b0db140: 
1:b0db140:         // Simple check to verify same restrictions hold true if current
1:b0db140:         // schema is "SYSCS_DIAG".
1:b0db140: 
1:b0db140:         st.execute("set schema syscs_diag");
1:b0db140:         assertStatementError("42X01", st,
1:b0db140:             "select * from " + vtiTableName + args + " x");
1:b0db140:         
1:b0db140:         assertStatementError("42X01", st,
1:b0db140:             "select * from (" + vtiTableName + args + ") x");
1:b0db140: 
1:b0db140:         st.execute("set schema app");
1:b0db140:     }
1:b0db140: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
1: import java.sql.ResultSet;
1: import java.sql.Statement;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite("Diagnostic VTI Table Mappings");
commit:2d3c23a
/////////////////////////////////////////////////////////////////////////
1:      * Basic sanity test for SYSCS_DIAG.CONTAINED_ROLES. See also the
1:      * tools/ij_show_roles.sql test for a test that actually defines and uses
1:      * roles with this VTI.
1:     public void testContainedRoles() throws SQLException
1:         // 2-arg version
1:             ("select * from table(syscs_diag.contained_roles(null, 0))t");
1: 
1:         JDBC.assertEmpty(rs);
1: 
1:         // 1-arg version
1:         rs = st.executeQuery
1:             ("select * from table(syscs_diag.contained_roles(null))t");
commit:7cbf021
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Basic sanity test for SYSCS_DIAG.ENABLED_ROLES. See also the
0:      * tools/ij_show_roles.sql test for a test that actually defines roles.
1:      */
0:     public void testEnabledRoles() throws SQLException
1:     {
1:         Statement   st = createStatement();
1: 
1:         ResultSet rs = st.executeQuery
0:             ("select * from syscs_diag.enabled_roles");
1: 
1:         JDBC.assertEmpty(rs);
1: 
1:         rs.close();
1:         st.close();
1:     }
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:3468143
/////////////////////////////////////////////////////////////////////////
1:              );        
1:         JDBC.assertColumnNames(rs, ALL_SPACE_TABLE_COLUMNS);
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         rs = st.executeQuery
1:             (
1:              "select t1.*\n" +
1:              "    from\n" +
1:              "        sys.systables systabs1,\n" +
1:              "        table (syscs_diag.space_table( systabs1.tablename )) as t1\n" +
1:              "    where systabs1.tabletype = 'T'\n" +
1:              "union\n" +
1:              "select t2.*\n" +
1:              "    from\n" +
1:              "        sys.systables systabs2,\n" +
1:              "        table (syscs_diag.space_table( systabs2.tablename )) as t2\n" +
1:              "    where systabs2.tabletype = 'T'\n"
1:              );        
commit:60dc440
/////////////////////////////////////////////////////////////////////////
1: 
1:         // verify the fix to DERBY-5554: joins to VTIs in the FROM list still
1:         // work when there are more than 1 base tables in the FROM list and
1:         // they join in the WHERE clause
1:         rs = st.executeQuery
1:             (
1:              "select t2.*\n" +
1:              "    from\n" +
1:              "        sys.systables systabs,\n" +
1:              "        table (syscs_diag.space_table(systabs.tablename)) as t2,\n" +
1:              "        sys.sysconglomerates syscgs\n" +
1:              "    where systabs.tabletype = 'T' and systabs.tableid = syscgs.tableid\n"
1:              );        
1:         JDBC.assertColumnNames(rs, ALL_SPACE_TABLE_COLUMNS);
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         rs = st.executeQuery
1:             (
1:              "select t2.*\n" +
1:              "    from\n" +
1:              "        sys.sysconglomerates syscgs,\n" +
1:              "        table (syscs_diag.space_table(systabs.tablename)) as t2,\n" +
1:              "        sys.systables systabs\n" +
1:              "    where systabs.tabletype = 'T' and systabs.tableid = syscgs.tableid\n"
1:              );        
1:         JDBC.assertColumnNames(rs, ALL_SPACE_TABLE_COLUMNS);
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
commit:3c065e9
/////////////////////////////////////////////////////////////////////////
0: import java.sql.Connection;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  BAD_FROM_LIST_JOIN = "42ZB7";
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Verify that you can't join diagnostic VTIs to one another in the FROM list. See DERBY-5554.
1:      */
1:     public void test_vti2vtiJoinInFromList() throws Exception
1:     {
1:         Connection  conn = getConnection();
1:         Statement st = createStatement();
1: 
1:         // joins to real tables are ok
1:         conn.prepareStatement
1:             (
1:              "select t1.*\n" +
1:              "from \n" +
1:              "    sys.systables systabs,\n" +
1:              "    table ( syscs_diag.space_table( systabs.tablename ) ) as t1\n" +
1:              "where systabs.tabletype = 'T'\n"
1:              );
1:         conn.prepareStatement
1:             (
1:              "select t1.*\n" +
1:              "from \n" +
1:              "    table ( syscs_diag.space_table( systabs.tablename ) ) as t1,\n" +
1:              "    sys.systables systabs\n" +
1:              "where systabs.tabletype = 'T'\n"
1:              );
1: 
1:         // can't join VTIs to one another in the FROM list
1:         assertStatementError
1:             (
1:              BAD_FROM_LIST_JOIN,
1:              st,
1:              "select t1.*, t2.*\n" +
1:              "from \n" +
1:              "    sys.systables systabs,\n" +
1:              "    table ( syscs_diag.space_table( systabs.tablename ) ) as t1,\n" +
1:              "    table ( syscs_diag.space_table( t1.conglomeratename ) ) as t2\n" +
1:              "where systabs.tabletype = 'T'\n"
1:              );
1:         assertStatementError
1:             (
1:              "42X04",
1:              st,
1:              "select t1.*, t2.*\n" +
1:              "from \n" +
1:              "    sys.systables systabs,\n" +
1:              "    table ( syscs_diag.space_table( t1.conglomeratename ) ) as t2,\n" +
1:              "    table ( syscs_diag.space_table( systabs.tablename ) ) as t1\n" +
1:              "where systabs.tabletype = 'T'\n"
1:              );
1: 
1:     }
1:     
1:     /**
commit:271e7dd
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String[]    ALL_SPACE_TABLE_COLUMNS =
1:     {
1:         "CONGLOMERATENAME", "ISINDEX", "NUMALLOCATEDPAGES", "NUMFREEPAGES",
1:         "NUMUNFILLEDPAGES", "PAGESIZE", "ESTIMSPACESAVING", "TABLEID"
1:     };
1: 
/////////////////////////////////////////////////////////////////////////
1:         String [] expColNames = ALL_SPACE_TABLE_COLUMNS;
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertColumnNames(rs, ALL_SPACE_TABLE_COLUMNS);
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertColumnNames(rs, ALL_SPACE_TABLE_COLUMNS);
/////////////////////////////////////////////////////////////////////////
1: 
1:         // verify the syntax showcased in the Reference Guide section on SPACE_TABLE
1:         // (after the changes introduced by DERBY-5554)
1: 
1:         rs = st.executeQuery
1:             (
1:              "select t2.*\n" +
1:              "    from\n" +
1:              "        sys.systables systabs,\n" +
1:              "        table (syscs_diag.space_table()) as t2\n" +
1:              "    where systabs.tabletype = 'T'\n" +
1:              "    and systabs.tableid = t2.tableid\n"
1:              );
1:         
1:         JDBC.assertColumnNames(rs, ALL_SPACE_TABLE_COLUMNS);
1:         JDBC.assertFullResultSet(rs, expRS, true);
/////////////////////////////////////////////////////////////////////////
1:      * Test the 0-arg constructor of the SPACE_TABLE vti. See DERBY-5554.
1:      */
1:     public void testSpaceTable_0argConstructor() throws Exception
1:     {
1:         Statement st = createStatement();
1:         ResultSet   rs = st.executeQuery
1:             (
1:              "select conglomeratename, isindex, pagesize, tableid\n" +
1:              "from table(syscs_diag.space_table()) x\n" +
1:              "where conglomeratename like 'SYS%'\n" +
1:              "order by conglomeratename"
1:              );
1: 
1:         String[]  columnNames =
1:         {
1:             "CONGLOMERATENAME", "ISINDEX", "PAGESIZE", "TABLEID"
1:         };
1:         JDBC.assertColumnNames( rs, columnNames );
1:         
1:         String[][]  expRS = new String [][]
1:         {
1:             { "SYSALIASES", "0", "4096", "c013800d-00d7-ddbd-08ce-000a0a411400" },
1:             { "SYSALIASES_INDEX1", "1", "4096", "c013800d-00d7-ddbd-08ce-000a0a411400" },
1:             { "SYSALIASES_INDEX2", "1", "4096", "c013800d-00d7-ddbd-08ce-000a0a411400" },
1:             { "SYSALIASES_INDEX3", "1", "4096", "c013800d-00d7-ddbd-08ce-000a0a411400" },
1:             { "SYSCHECKS", "0", "4096", "80000056-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSCHECKS_INDEX1", "1", "4096", "80000056-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSCOLPERMS", "0", "4096", "286cc01e-0103-0e39-b8e7-00000010f010" },
1:             { "SYSCOLPERMS_INDEX1", "1", "4096", "286cc01e-0103-0e39-b8e7-00000010f010" },
1:             { "SYSCOLPERMS_INDEX2", "1", "4096", "286cc01e-0103-0e39-b8e7-00000010f010" },
1:             { "SYSCOLPERMS_INDEX3", "1", "4096", "286cc01e-0103-0e39-b8e7-00000010f010" },
1:             { "SYSCOLUMNS", "0", "4096", "8000001e-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSCOLUMNS_INDEX1", "1", "4096", "8000001e-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSCOLUMNS_INDEX2", "1", "4096", "8000001e-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSCONGLOMERATES", "0", "4096", "80000010-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSCONGLOMERATES_INDEX1", "1", "4096", "80000010-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSCONGLOMERATES_INDEX2", "1", "4096", "80000010-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSCONGLOMERATES_INDEX3", "1", "4096", "80000010-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSCONSTRAINTS", "0", "4096", "8000002f-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSCONSTRAINTS_INDEX1", "1", "4096", "8000002f-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSCONSTRAINTS_INDEX2", "1", "4096", "8000002f-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSCONSTRAINTS_INDEX3", "1", "4096", "8000002f-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSDEPENDS", "0", "4096", "8000003e-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSDEPENDS_INDEX1", "1", "4096", "8000003e-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSDEPENDS_INDEX2", "1", "4096", "8000003e-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSDUMMY1", "0", "4096", "c013800d-00f8-5b70-bea3-00000019ed88" },
1:             { "SYSFILES", "0", "4096", "80000000-00d3-e222-873f-000a0a0b1900" },
1:             { "SYSFILES_INDEX1", "1", "4096", "80000000-00d3-e222-873f-000a0a0b1900" },
1:             { "SYSFILES_INDEX2", "1", "4096", "80000000-00d3-e222-873f-000a0a0b1900" },
1:             { "SYSFOREIGNKEYS", "0", "4096", "8000005b-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSFOREIGNKEYS_INDEX1", "1", "4096", "8000005b-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSFOREIGNKEYS_INDEX2", "1", "4096", "8000005b-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSKEYS", "0", "4096", "80000039-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSKEYS_INDEX1", "1", "4096", "80000039-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSPERMS", "0", "4096", "9810800c-0121-c5e1-a2f5-00000043e718" },
1:             { "SYSPERMS_INDEX1", "1", "4096", "9810800c-0121-c5e1-a2f5-00000043e718" },
1:             { "SYSPERMS_INDEX2", "1", "4096", "9810800c-0121-c5e1-a2f5-00000043e718" },
1:             { "SYSPERMS_INDEX3", "1", "4096", "9810800c-0121-c5e1-a2f5-00000043e718" },
1:             { "SYSROLES", "0", "4096", "e03f4017-0115-382c-08df-ffffe275b270" },
1:             { "SYSROLES_INDEX1", "1", "4096", "e03f4017-0115-382c-08df-ffffe275b270" },
1:             { "SYSROLES_INDEX2", "1", "4096", "e03f4017-0115-382c-08df-ffffe275b270" },
1:             { "SYSROLES_INDEX3", "1", "4096", "e03f4017-0115-382c-08df-ffffe275b270" },
1:             { "SYSROUTINEPERMS", "0", "4096", "2057c01b-0103-0e39-b8e7-00000010f010" },
1:             { "SYSROUTINEPERMS_INDEX1", "1", "4096", "2057c01b-0103-0e39-b8e7-00000010f010" },
1:             { "SYSROUTINEPERMS_INDEX2", "1", "4096", "2057c01b-0103-0e39-b8e7-00000010f010" },
1:             { "SYSROUTINEPERMS_INDEX3", "1", "4096", "2057c01b-0103-0e39-b8e7-00000010f010" },
1:             { "SYSSCHEMAS", "0", "4096", "80000022-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSSCHEMAS_INDEX1", "1", "4096", "80000022-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSSCHEMAS_INDEX2", "1", "4096", "80000022-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSSEQUENCES", "0", "4096", "9810800c-0121-c5e2-e794-00000043e718" },
1:             { "SYSSEQUENCES_INDEX1", "1", "4096", "9810800c-0121-c5e2-e794-00000043e718" },
1:             { "SYSSEQUENCES_INDEX2", "1", "4096", "9810800c-0121-c5e2-e794-00000043e718" },
1:             { "SYSSTATEMENTS", "0", "4096", "80000000-00d1-15f7-ab70-000a0a0b1500" },
1:             { "SYSSTATEMENTS_INDEX1", "1", "4096", "80000000-00d1-15f7-ab70-000a0a0b1500" },
1:             { "SYSSTATEMENTS_INDEX2", "1", "4096", "80000000-00d1-15f7-ab70-000a0a0b1500" },
1:             { "SYSSTATISTICS", "0", "4096", "f81e0010-00e3-6612-5a96-009e3a3b5e00" },
1:             { "SYSSTATISTICS_INDEX1", "1", "4096", "f81e0010-00e3-6612-5a96-009e3a3b5e00" },
1:             { "SYSTABLEPERMS", "0", "4096", "b8450018-0103-0e39-b8e7-00000010f010" },
1:             { "SYSTABLEPERMS_INDEX1", "1", "4096", "b8450018-0103-0e39-b8e7-00000010f010" },
1:             { "SYSTABLEPERMS_INDEX2", "1", "4096", "b8450018-0103-0e39-b8e7-00000010f010" },
1:             { "SYSTABLEPERMS_INDEX3", "1", "4096", "b8450018-0103-0e39-b8e7-00000010f010" },
1:             { "SYSTABLES", "0", "4096", "80000018-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSTABLES_INDEX1", "1", "4096", "80000018-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSTABLES_INDEX2", "1", "4096", "80000018-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSTRIGGERS", "0", "4096", "c013800d-00d7-c025-4809-000a0a411200" },
1:             { "SYSTRIGGERS_INDEX1", "1", "4096", "c013800d-00d7-c025-4809-000a0a411200" },
1:             { "SYSTRIGGERS_INDEX2", "1", "4096", "c013800d-00d7-c025-4809-000a0a411200" },
1:             { "SYSTRIGGERS_INDEX3",  "1", "4096", "c013800d-00d7-c025-4809-000a0a411200" },
1:             { "SYSUSERS", "0", "4096", "9810800c-0134-14a5-40c1-000004f61f90" },
1:             { "SYSUSERS_INDEX1", "1", "4096", "9810800c-0134-14a5-40c1-000004f61f90" },
1:             { "SYSVIEWS", "0", "4096", "8000004d-00d0-fd77-3ed8-000a0a0b1900" },
1:             { "SYSVIEWS_INDEX1", "1", "4096", "8000004d-00d0-fd77-3ed8-000a0a0b1900" },
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:     }
1:     
1:     /**
commit:01c7acb
/////////////////////////////////////////////////////////////////////////
1:         // get table id
1:         ResultSet   rs1 = st.executeQuery
1:             (
1:              "select t.tableid from sys.systables t, sys.sysschemas s\n" +
1:              "where t.schemaid = s.schemaid\n" +
1:              "and s.schemaname = 'APP'\n" +
1:              "and t.tablename = 'T1'"
1:              );
1:         rs1.next();
1:         String      tableID = rs1.getString( 1 );
1:         rs1.close();
1: 
0:         String [] allColNames = new String [] {
0:             "NUMUNFILLEDPAGES", "PAGESIZE", "ESTIMSPACESAVING", "TABLEID" };
0:         String [] expColNames = allColNames;
1:             {"T1", "0", "1", "0", "1", "4096", "0", tableID}
/////////////////////////////////////////////////////////////////////////
1:             {"T1", "0", "1", "0", "1", "4096", "0", tableID}
/////////////////////////////////////////////////////////////////////////
1:             {"T1", "0", "1", "0", "1", "4096", "0", tableID}
/////////////////////////////////////////////////////////////////////////
1:             {"T1", "0", "1", "0", "1", "4096", "0", tableID}
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             {"T1", "0", "1", "0", "1", "4096", "0", tableID}
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         JDBC.assertColumnNames(rs, allColNames);
1:             {"T1", "0", "1", "0", "1", "4096", "0", tableID}
/////////////////////////////////////////////////////////////////////////
0:         JDBC.assertColumnNames(rs, allColNames);
1:             {"T1", "0", "1", "0", "1", "4096", "0", tableID}
commit:70ff9b0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Timestamp;
1: import java.text.SimpleDateFormat;
1: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
1:         Test    defaultSetup = TestConfiguration.defaultSuite( SysDiagVTIMappingTest.class );
1: 
1:         // turn on statement logging so there will be something in the error log
1:         // to run these vtis against
1:         Properties sysprops = new Properties();
1:         sysprops.put( "derby.language.logStatementText", "true" );
1:         Test    verboseTest = new SystemPropertyTestSetup ( defaultSetup, sysprops );
1: 
1:         suite.addTest( verboseTest );
1: 
1:          /* Some of the VTIs that are tested in this class require a derby.log
/////////////////////////////////////////////////////////////////////////
1:             {"2006-12-15 16:14:58.280 GMT", "main,5,main", "1111", "0",
/////////////////////////////////////////////////////////////////////////
1:             {"2006-12-15 16:14:58.280 GMT", "main,5,main", "1111", "0",
/////////////////////////////////////////////////////////////////////////
1:             {"2006-12-15 16:14:58.280 GMT", "main,5,main", "1111", "0", "ugh",
1:             {"2006-12-15 16:14:58.280 GMT", "main,5,main", "1111", "0", "ugh",
/////////////////////////////////////////////////////////////////////////
1:             {"2006-12-15 16:14:58.280 GMT", "main,5,main", "1111", "0", "ugh",
1:             {"2006-12-15 16:14:58.280 GMT", "main,5,main", "1111", "0", "ugh",
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test date formatting in the vtis which read the error log. This attempts
1:      * to keep us from breaking these vtis if the format of logged timestamps
1:      * changes. See DERBY-5391.
1:      */
1:     public  void    test_5391() throws Exception
1:     {
1:         Statement   st = createStatement();
1: 
1:         ResultSet   rs1 = st.executeQuery( "select * from table (syscs_diag.error_log_reader( )) as t1" );
1:         vetTimestamp( rs1 );
1:         rs1.close();
1: 
1:         ResultSet   rs2 = st.executeQuery( "select * from table (syscs_diag.statement_duration()) as t1" );
1:         vetTimestamp( rs2 );
1:         rs2.close();
1: 
1:         st.close();
1:     }
1:     private void    vetTimestamp( ResultSet rs ) throws Exception
1:     {
1:         assertTrue( rs.next() );
1: 
1:         String  timestampString = rs.getString( 1 ).trim();
1: 
0:         SimpleDateFormat    sdf = new SimpleDateFormat( "EEE MMM dd HH:mm:ss zzz yyyy" );
1:         Timestamp   timestamp = new Timestamp( sdf.parse( timestampString ).getTime() );
1: 
1:         println( timestamp.toString() );
1:     }
1: 
commit:3bbcfab
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that diagnostic VTIs will work correctly when they
1:      * are invoked in a subquery with correlated references to
1:      * outer query blocks.  DERBY-3138.
1:      */
1:     public void testCorrelatedReferences() throws SQLException
1:     {
1:         Statement   st = createStatement();
1:         String      [][] expRS = new String [][] {};
1: 
1:         ResultSet rs = st.executeQuery
1:             (
1:              "select s.schemaname, t.tableName\n" +
1:              "from sys.sysschemas s, sys.systables t\n" +
1:              "where t.schemaid=s.schemaid\n" +
1:              "and exists\n" +
1:              "(\n" +
1:              "  select vti.*\n" +
1:              "  from table( syscs_diag.space_table( s.schemaname, t.tableName ) ) as vti\n" +
1:              "  where vti.numfreepages < -1\n" +
1:              ")\n"
0:              );
1:         
1:         JDBC.assertFullResultSet(rs, expRS);
1: 
1:         rs.close();
1:         st.close();
1:     }
1: 
commit:4aef9b0
/////////////////////////////////////////////////////////////////////////
1:         assertStatementError("42ZB4", st,
1:         assertStatementError("42ZB4", st,
/////////////////////////////////////////////////////////////////////////
1:         assertStatementError("42ZB4", st,
/////////////////////////////////////////////////////////////////////////
1:         assertStatementError("42ZB4", st, "select * from table (app.t1()) x");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:38586ad
/////////////////////////////////////////////////////////////////////////
1: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
1:         SimpleDateFormat sdf =
1:             new SimpleDateFormat("EEE MMM dd HH:mm:ss zzz yyyy", Locale.US);
commit:98ceb6f
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement();
1:         stmt.execute("create table app.t1 (i int, c varchar(10))");
1:         stmt.execute("insert into app.t1 values (1, 'one'), "
1:         stmt.close();
1:         Statement stmt = createStatement();
1:         stmt.execute("drop table app.t1");
1:         stmt.close();
1:         super.tearDown();
commit:de3b108
/////////////////////////////////////////////////////////////////////////
1:         assertStatementError("42X62", cSt);
commit:96fe058
/////////////////////////////////////////////////////////////////////////
1: 
0:         /* Currently BaseJDBCTestCase.assertSQLState() is unable
0:          * to find nested SQLSTATEs with 1.6 JVMs, so we have to
0:          * check for the top-level SQLSTATE in that case.  When
0:          * that changes the "JDBC.vmSupportsJDBC4()" call can be
0:          * removed from the following line.  DERBY-1440.
1:          */
0:         assertStatementError(JDBC.vmSupportsJDBC4() ? "38000" : "42X62", cSt);
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:818fd27
/////////////////////////////////////////////////////////////////////////
1:         assertStatementError("42Y55", cSt);
author:Army
-------------------------------------------------------------------------------
commit:cf530d5
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that diagnostic VTIs will work correctly when an ORDER BY
1:      * clause appears and/or sort elimination occurs.  DERBY-2805.
1:      */
1:     public void testOrderBy() throws SQLException
1:     {
1:         Statement st = createStatement();
1:         st.executeUpdate("set schema APP");
1: 
1:         // Create a single testing table for this fixture only.
1: 
1:         st.execute("create table ob_t1 (i int, c char(250))");
1:         st.execute("create index i_ix on ob_t1 (i)");
1:         st.execute("create index c_ix on ob_t1 (c desc)");
1: 
1:         /* Several queries to make sure ORDER BY actually takes effect.
1:          * First execute with just the ORDER BY, then execute with the
1:          * ORDER BY *and* a DISTINCT. The latter leads to sort elimination
1:          * but should still run without error and return the same results
1:          * (prior to the fix for DERBY-2805 the sort elimination would
1:          * lead to an ASSERT failure with sane builds).
1:          */
1: 
1:         String [][] expRS = new String [][]
1:         {
1:             {"C_IX", "1", "0"},
1:             {"I_IX", "1", "0"},
1:             {"OB_T1", "0", "0"},
1:         };
1: 
1:         ResultSet rs = st.executeQuery(
1:             "select CONGLOMERATENAME, ISINDEX, NUMFREEPAGES from " +
1:             "table(syscs_diag.space_table('OB_T1')) X order by 1");
1: 
1:         JDBC.assertFullResultSet(rs, expRS);
1: 
1:         rs = st.executeQuery(
1:             "select distinct CONGLOMERATENAME, ISINDEX, NUMFREEPAGES from " +
1:             "table(syscs_diag.space_table('OB_T1')) X order by 1");
1: 
1:         JDBC.assertFullResultSet(rs, expRS);
1: 
1:         expRS = new String [][]
1:         {
1:             {"OB_T1", "0", "0"},
1:             {"C_IX", "1", "0"},
1:             {"I_IX", "1", "0"},
1:         };
1: 
1:         rs = st.executeQuery(
1:             "select CONGLOMERATENAME, ISINDEX, NUMFREEPAGES from " +
1:             "table(syscs_diag.space_table('OB_T1')) X order by 2, 1");
1: 
1:         JDBC.assertFullResultSet(rs, expRS);
1: 
1:         rs = st.executeQuery(
1:             "select distinct CONGLOMERATENAME, ISINDEX, NUMFREEPAGES from " +
1:             "table(syscs_diag.space_table('OB_T1')) X order by 2, 1");
1: 
1:         JDBC.assertFullResultSet(rs, expRS);
1:         expRS = new String [][]
1:         {
1:             {"OB_T1", "0", "0"},
1:             {"I_IX", "1", "0"},
1:             {"C_IX", "1", "0"},
1:         };
1: 
1:         rs = st.executeQuery(
1:             "select CONGLOMERATENAME, ISINDEX, NUMFREEPAGES from " +
1:             "table(syscs_diag.space_table('OB_T1')) X order by 2, 1 desc");
1: 
1:         JDBC.assertFullResultSet(rs, expRS);
1: 
1:         rs = st.executeQuery(
1:             "select distinct CONGLOMERATENAME, ISINDEX, NUMFREEPAGES from " +
1:             "table(syscs_diag.space_table('OB_T1')) X order by 2, 1 desc");
1: 
1:         JDBC.assertFullResultSet(rs, expRS);
1: 
1:         // Cleanup.
1: 
1:         st.execute("drop table ob_t1");
1:         st.close();
1:     }
1: 
commit:b0db140
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class org.apache.derbyTesting.functionTests.tests.lang.SysDiagVTIMappingTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.SecurityManagerSetup;
0: import org.apache.derbyTesting.junit.SupportFilesSetup;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
0: import java.sql.ResultSet;
0: import java.sql.Statement;
1: import java.sql.CallableStatement;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
1: 
1: public final class SysDiagVTIMappingTest extends BaseJDBCTestCase {
1: 
1:     // Name of the log file to use when testing VTIs that expect one.
1:     private static final String testLogFile = "sys_vti_test_derby.tstlog";
1: 
1:     /**
1:      * Public constructor required for running test as standalone JUnit.
1:      */
1:     public SysDiagVTIMappingTest(String name)
1:     {
1:         super(name);
1:     }
1: 
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite("Diagnostic VTI Table Mappings");
0:         suite.addTest(TestConfiguration.
0:             defaultSuite(SysDiagVTIMappingTest.class));
1: 
0:         /* Some of the VTIs that are tested in this class require a derby.log
1:          * file.  We have a test log file stored in the tests/lang directory,
1:          * and since the VTIs are going to try to read it, the test log file
1:          * must be in a directory for which Derby has read access.  By
1:          * using a SupportFilesSetup wrapper, we copy the test log file to
1:          * the "extin" directory, which has the required permissions.
1:          */
1:         return SecurityManagerSetup.noSecurityManager(
1:             new SupportFilesSetup(suite,
1:                 new String [] {
1:                     "functionTests/tests/lang/" + testLogFile
1:                 }));
1:     }
1: 
1:     public void setUp() throws Exception
1:     {
0:         createStatement().execute("create table app.t1 (i int, c varchar(10))");
0:         createStatement().execute("insert into app.t1 values (1, 'one'), "
1:             + "(2, 'two'), (4, 'four')");
1:     }
1: 
1:     public void tearDown() throws Exception
1:     {
0:         createStatement().execute("drop table app.t1");
1:     }
1: 
1:     /**
1:      * We use the SpaceTable VTI as our primary test VTI to verify that
1:      * that VTI table mappings in general are working as expected.  So
1:      * this method does a lot more than the other VTI test methods;
1:      * the other test methods just do sanity checks to make sure that
1:      * the mapping from "SYSCS_DIAG.<vti_table>" to the actual VTI
1:      * class names in question is working correctly.
1:      */
1:     public void testSpaceTable() throws Exception
1:     {
1:         Statement st = createStatement();
1:         st.executeUpdate("set schema APP");
1:         
1:         // Should fail because SPACE_TABLE is not defined in APP 
1:         // schema.
1:         
1:         assertStatementError("42Y03", st,
1:             "select * from TABLE(SPACE_TABLE('APP')) x");
1:         
1:         assertStatementError("42Y03", st,
1:             "select * from TABLE(APP.SPACE_TABLE('APP', 'T1')) x");
1:         
1:         // Should fail due to extra "TABLE" keyword.
1:         
1:         assertStatementError("42X01", st,
1:             "select * from TABLE TABLE(SYSCS_DIAG.SPACE_TABLE('T1')) x");
1:         
1:         assertStatementError("42X01", st,
1:             "select * from TABLE TABLE (select * from t1) x");
1:         
1:         // Should fail because the specified schema does not exist.
1:         
1:         assertStatementError("42Y07", st,
1:             "select * from TABLE(SYSCS_DIAG.SPACE_TABLE('T1', 'APP')) x");
1:         
1:         assertStatementError("42Y07", st,
1:             "select * from "
1:             + "TABLE(SYSCS_DIAG.SPACE_TABLE('NOTTHERE', 'T1')) x");
1:         
1:         // Should fail because SPACE_TABLE is not defined in APP schema.
1:         
1:         st.executeUpdate("set schema SYSCS_DIAG");
1:         assertStatementError("42Y03", st,
1:             "select * from TABLE(APP.SPACE_TABLE('APP', 'T1')) x");
1:         
1:         // All remaining test cases in this method should succeed.
1:         
1:         st.executeUpdate("set schema APP");
1: 
1:         // These should all return 1 row for APP.T1.
1:         
1:         // Two-argument direct call.
1:         ResultSet rs = st.executeQuery(
1:             "select * from TABLE(SYSCS_DIAG.SPACE_TABLE('APP', 'T1')) x");
1:         
1:         String [] expColNames = new String [] {
0:             "CONGLOMERATENAME", "ISINDEX", "NUMALLOCATEDPAGES", "NUMFREEPAGES",
0:             "NUMUNFILLEDPAGES", "PAGESIZE", "ESTIMSPACESAVING"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         String [][] expRS = new String [][]
1:         {
0:             {"T1", "0", "1", "0", "1", "4096", "0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // Single-argument direct execution.
1:         rs = st.executeQuery(
1:             " select * from TABLE(SYSCS_DIAG.SPACE_TABLE('T1')) x");
1:         
1:         expColNames = new String [] {
0:             "CONGLOMERATENAME", "ISINDEX", "NUMALLOCATEDPAGES", "NUMFREEPAGES",
0:             "NUMUNFILLEDPAGES", "PAGESIZE", "ESTIMSPACESAVING"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
0:             {"T1", "0", "1", "0", "1", "4096", "0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // Two-argument prepare and execute.
1:         PreparedStatement pSt = prepareStatement(
1:             "select * from TABLE(SYSCS_DIAG.SPACE_TABLE(?, ?)) x");
1: 
1:         pSt.setString(1, "APP");
1:         pSt.setString(2, "T1");
1: 
1:         rs = pSt.executeQuery();
1:         expColNames = new String [] {
0:             "CONGLOMERATENAME", "ISINDEX", "NUMALLOCATEDPAGES", "NUMFREEPAGES",
0:              "NUMUNFILLEDPAGES", "PAGESIZE", "ESTIMSPACESAVING"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
0:             {"T1", "0", "1", "0", "1", "4096", "0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // Single-argument prepare and execute.
1:         pSt = prepareStatement(
1:             "select * from TABLE(SYSCS_DIAG.SPACE_TABLE(?)) x");
1: 
1:         pSt.setString(1, "T1");
1: 
1:         rs = pSt.executeQuery();
1:         expColNames = new String [] {
0:             "CONGLOMERATENAME", "ISINDEX", "NUMALLOCATEDPAGES", "NUMFREEPAGES",
0:             "NUMUNFILLEDPAGES", "PAGESIZE", "ESTIMSPACESAVING"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
0:             {"T1", "0", "1", "0", "1", "4096", "0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // Statment should succeed but there will be no rows 
1:         // because the tables do not exist.
1:         
1:         rs = st.executeQuery(
1:             "select * from TABLE(SYSCS_DIAG.SPACE_TABLE('APP')) x");
1:         
1:         expColNames = new String [] {
0:             "CONGLOMERATENAME", "ISINDEX", "NUMALLOCATEDPAGES", "NUMFREEPAGES",
0:             "NUMUNFILLEDPAGES", "PAGESIZE", "ESTIMSPACESAVING"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         JDBC.assertDrainResults(rs, 0);
1:         
1:         rs = st.executeQuery(
1:             "select * from TABLE(SYSCS_DIAG.SPACE_TABLE('APP', "
1:             + "'NOTTHERE')) x");
1:         
1:         expColNames = new String [] {
0:             "CONGLOMERATENAME", "ISINDEX", "NUMALLOCATEDPAGES", "NUMFREEPAGES",
0:             "NUMUNFILLEDPAGES", "PAGESIZE", "ESTIMSPACESAVING"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         JDBC.assertDrainResults(rs, 0);
1:         
1:         rs = st.executeQuery(
1:             "select * from "
1:             + "TABLE(SYSCS_DIAG.SPACE_TABLE('SYSCS_DIAG', 'NOTTHERE')) x");
1:         
1:         expColNames = new String [] {
0:             "CONGLOMERATENAME", "ISINDEX", "NUMALLOCATEDPAGES", "NUMFREEPAGES",
0:             "NUMUNFILLEDPAGES", "PAGESIZE", "ESTIMSPACESAVING"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         JDBC.assertDrainResults(rs, 0);
1:         
1:         // Should see zero rows since LOCK_TABLE does not exist as 
1:         // an actual base table (it's another VTI).
1:         
1:         rs = st.executeQuery(
1:             "select * from "
1:             + "TABLE(SYSCS_DIAG.SPACE_TABLE('SYSCS_DIAG', 'LOCK_TABLE')) x");
1:         
1:         expColNames = new String [] {
0:             "CONGLOMERATENAME", "ISINDEX", "NUMALLOCATEDPAGES", "NUMFREEPAGES",
0:             "NUMUNFILLEDPAGES", "PAGESIZE", "ESTIMSPACESAVING"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         JDBC.assertDrainResults(rs, 0);
1:         
1:         // Similar tests but in the SYSCS_DIAG schema, in which 
1:         // case the schema-name for SPACE_TABLE should not be required.
1:         
1:         st.executeUpdate("set schema syscs_diag");
1:         
1:         // Should see 1 row for APP.T1.
1:         
1:         pSt = prepareStatement(
1:             "select * from TABLE(SPACE_TABLE(?, ?)) x");
1:         
1:         pSt.setString(1, "APP");
1:         pSt.setString(2, "T1");
1: 
1:         rs = pSt.executeQuery();
1:         expColNames = new String [] {
0:             "CONGLOMERATENAME", "ISINDEX", "NUMALLOCATEDPAGES", "NUMFREEPAGES",
0:             "NUMUNFILLEDPAGES", "PAGESIZE", "ESTIMSPACESAVING"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
0:             {"T1", "0", "1", "0", "1", "4096", "0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // Should see zero rows since T1 does not exist within 
1:         // schema "SYSCS_DIAG".
1:         
1:         pSt = prepareStatement("select * from TABLE(SPACE_TABLE(?)) x");
1:         pSt.setString(1, "T1");
1: 
1:         rs = pSt.executeQuery();
1:         expColNames = new String [] {
0:             "CONGLOMERATENAME", "ISINDEX", "NUMALLOCATEDPAGES", "NUMFREEPAGES",
0:             "NUMUNFILLEDPAGES", "PAGESIZE", "ESTIMSPACESAVING"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         JDBC.assertDrainResults(rs, 0);
1:         
1:         // Should see zero rows since LOCK_TABLE does not exist as 
1:         // an actual base table (it's another VTI).
1:         
1:         rs = st.executeQuery(
1:             "select * from TABLE(SPACE_TABLE('LOCK_TABLE')) x");
1:         
1:         expColNames = new String [] {
0:             "CONGLOMERATENAME", "ISINDEX", "NUMALLOCATEDPAGES", "NUMFREEPAGES",
0:             "NUMUNFILLEDPAGES", "PAGESIZE", "ESTIMSPACESAVING"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         JDBC.assertDrainResults(rs, 0);
1:         
1:         // Simple check to ensure that we we can join with the VTI.
1:         
1:         st.executeUpdate("set schema app");
1:         rs = st.executeQuery(
1:             "select cast (conglomeratename as varchar(30)), t1.* from"
1:             + "  TABLE(SYSCS_DIAG.SPACE_TABLE('APP', 'T1')) x,"
1:             + "  t1"
1:             + " where x.conglomeratename is not null");
1:         
1:         expColNames = new String [] {"1", "I", "C"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"T1", "1", "one"},
1:             {"T1", "2", "two"},
1:             {"T1", "4", "four"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // Make sure old way of calling still works until it is 
1:         // deprecated.
1:         
1:         st.executeUpdate("set schema APP");
1:         rs = st.executeQuery(
1:             "SELECT * FROM NEW org.apache.derby.diag.SpaceTable('T1') as x");
1:         
1:         expColNames = new String [] {
0:             "CONGLOMERATENAME", "ISINDEX", "NUMALLOCATEDPAGES", "NUMFREEPAGES",
0:             "NUMUNFILLEDPAGES", "PAGESIZE", "ESTIMSPACESAVING"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
0:             {"T1", "0", "1", "0", "1", "4096", "0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             "SELECT * FROM NEW "
1:             + "org.apache.derby.diag.SpaceTable('APP', 'T1') as x");
1:         
1:         expColNames = new String [] {
0:             "CONGLOMERATENAME", "ISINDEX", "NUMALLOCATEDPAGES", "NUMFREEPAGES",
0:             "NUMUNFILLEDPAGES", "PAGESIZE", "ESTIMSPACESAVING"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
0:             {"T1", "0", "1", "0", "1", "4096", "0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // Now do some sanity checking to make sure SPACE_TABLE cannot be
1:         // used in any illegal ways.        
1: 
1:         checkIllegalUses(st, "space_table", "SpaceTable",
1:             "('APP', 'T1')", "conglomeratename");
1: 
1:         // Clean-up.
1:         getConnection().rollback();
1:         st.close();
1:     }
1: 
1:     /**
1:      * Just run a couple of sanity checks to makes sure the table
1:      * mapping for org.apache.derby.diag.StatementDuration() works
1:      * correctly and fails where it is supposed to.
1:      */
1:     public void testStatementDuration() throws Exception
1:     {
1:         Statement st = createStatement();
1:         st.executeUpdate("set schema APP");
1: 
1:         // Do a simple check to make sure the VTI mapping works.
1:         
1:         java.net.URL logURL = SupportFilesSetup.getReadOnlyURL(testLogFile);
1:         String vtiArg = "('" + logURL.getFile() + "')";
1:         ResultSet rs = st.executeQuery(
1:             "select * from "
1:             + "TABLE(SYSCS_DIAG.STATEMENT_DURATION" + vtiArg + ") x");
1:         
1:         String [] expColNames = new String [] {
1:             "TS", "THREADID", "XID", "LCCID", "LOGTEXT", "DURATION"};
1: 
1:         JDBC.assertColumnNames(rs, expColNames);
1:         String [][] expRS = new String [][]
1:         {
0:             {"2006-12-15 16:14:58.280", "main,5,main", "1111", "0",
1:                 "(DATABASE = ugh), (DRDAID = null), Cleanup action starting",
1:                 "0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // Make sure old way of calling still works until it is 
1:         // deprecated.
1:         
1:         rs = st.executeQuery(
1:             "SELECT * FROM NEW "
1:             + "org.apache.derby.diag.StatementDuration" + vtiArg + " as x");
1:         
1:         expColNames = new String [] {
1:             "TS", "THREADID", "XID", "LCCID", "LOGTEXT", "DURATION"};
1: 
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]
1:         {
0:             {"2006-12-15 16:14:58.280", "main,5,main", "1111", "0",
1:                 "(DATABASE = ugh), (DRDAID = null), Cleanup action starting",
1:                 "0"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // And finally, do the usual checks for invalid uses.
1: 
1:         checkIllegalUses(st, "statement_duration", "StatementDuration",
1:             vtiArg, "logtext");
1:     }
1: 
1:     /**
1:      * Just run a couple of sanity checks to makes sure the table
1:      * mapping for org.apache.derby.diag.ErrorLogReader() works
1:      * correctly and fails where it is supposed to.
1:      */
1:     public void testErrorLogReader() throws Exception
1:     {
1:         Statement st = createStatement();
1:         st.executeUpdate("set schema APP");
1: 
1:         // Do a simple check to make sure the VTI mapping works.
1:         
1:         java.net.URL logURL = SupportFilesSetup.getReadOnlyURL(testLogFile);
1:         String vtiArg = "('" + logURL.getFile() + "')";
1:         ResultSet rs = st.executeQuery(
1:             " select * from "
1:             + "TABLE(SYSCS_DIAG.ERROR_LOG_READER" + vtiArg + ") x");
1:         
1:         String [] expColNames = new String [] {
1:             "TS", "THREADID", "XID", "LCCID", "DATABASE", "DRDAID", "LOGTEXT"};
1: 
1:         JDBC.assertColumnNames(rs, expColNames);
1:         String [][] expRS = new String [][]
1:         {
0:             {"2006-12-15 16:14:58.280", "main,5,main", "1111", "0", "ugh",
1:                 "null", "Cleanup action starting"},
0:             {"2006-12-15 16:14:58.280", "main,5,main", "1111", "0", "ugh",
1:                 "null", "Failed Statement is: select * from oops"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // Make sure old way of calling still works until it is 
1:         // deprecated.
1:         
1:         rs = st.executeQuery(
1:             "SELECT * FROM NEW" +
1:             " org.apache.derby.diag.ErrorLogReader" + vtiArg + " as x");
1:         
1:         expColNames = new String [] {
1:             "TS", "THREADID", "XID", "LCCID", "DATABASE", "DRDAID", "LOGTEXT"};
1: 
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]
1:         {
0:             {"2006-12-15 16:14:58.280", "main,5,main", "1111", "0", "ugh",
1:                 "null", "Cleanup action starting"},
0:             {"2006-12-15 16:14:58.280", "main,5,main", "1111", "0", "ugh",
1:                 "null", "Failed Statement is: select * from oops"}
1:         };
1: 
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // And finally, do the usual checks for invalid uses.
1: 
1:         checkIllegalUses(st, "error_log_reader", "ErrorLogReader",
1:             vtiArg, "logtext");
1:     }
1: 
1:     /**
1:      * Tests to make sure that attempts to use the TABLE constructor
1:      * with things other than the VTI diagnostic table functions
1:      * do not work (with the exception of SELECT and VALUES queries,
1:      * which should work as normal).
1:      */
1:     public void testInvalidTableFunctions() throws Exception
1:     {
1:         // Sanity check: make sure SELECT and VALUES clauses still  work.
1:         
1:         Statement st = createStatement();
1:         st.executeUpdate("set schema APP");
1: 
1:         ResultSet rs = st.executeQuery(
1:             "select * from table (select * from t1) x");
1:         
1:         String [] expColNames = new String [] {"I", "C"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         String [][] expRS = new String [][]
1:         {
1:             {"1", "one"},
1:             {"2", "two"},
1:             {"4", "four"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         rs = st.executeQuery(
1:             " select * from table (values (1, 2), (2, 3)) x");
1:         
1:         expColNames = new String [] {"1", "2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         
1:         expRS = new String [][]
1:         {
1:             {"1", "2"},
1:             {"2", "3"}
1:         };
1:         
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         // Use of TABLE constructor with regular tables should fail.
1: 
1:         assertStatementError("42X01", st, "select * from table (app.t1) x");
0:         assertStatementError("42Y03", st, "select * from table (app.t1()) x");
1: 
1:         // Use of TABLE constructor with VTI tables (as opposed to VTI
1:         // table *functions*) should fail.
1: 
1:         assertStatementError("42X01", st,
1:             "select * from table (syscs_diag.lock_table) x");
1: 
1:         assertStatementError("42Y03", st,
1:             "select * from table (syscs_diag.lock_table()) x");
1: 
1:         assertStatementError("42X01", st,
1:             "select * from table (syscs_diag.transaction_table) x");
1: 
1:         assertStatementError("42Y03", st,
1:             "select * from table (syscs_diag.transaction_table()) x");
1: 
1:         assertStatementError("42X01", st,
1:             "select * from table (syscs_diag.statement_cache) x");
1: 
1:         assertStatementError("42Y03", st,
1:             "select * from table (syscs_diag.statement_cache()) x");
1: 
1:         assertStatementError("42X01", st,
1:             "select * from table (syscs_diag.error_messages) x");
1: 
1:         assertStatementError("42Y03", st,
1:             "select * from table (syscs_diag.error_messages()) x");
1: 
1:         // Clean-up.
1:         getConnection().rollback();
1:         st.close();
1:     }
1: 
1:     /* All statements in this method should fail because a VTI table-
1:      * mapping that takes arguments can only be used as part of the TABLE 
1:      * constructor.  Any other uses of, or attempts to modify, such a
1:      * VTI table should throw an appropriate error.
1:      */
1:     private void checkIllegalUses(Statement st, String vtiTableName,
1:         String vtiMethodName, String args, String colName) throws SQLException
1:     {
1:         assertStatementError("42X05", st,
1:             "select * from syscs_diag." + vtiTableName);
1:         
1:         assertStatementError("42X01", st,
1:             "select * from syscs_diag." + vtiTableName + args + " x");
1:         
1:         assertStatementError("42X01", st,
1:             "select * from (syscs_diag." + vtiTableName + args + ") x");
1:         
1:         assertStatementError("42Y55", st,
1:             "drop table syscs_diag." + vtiTableName);
1:         
1:         assertStatementError("42X01", st,
1:             "drop table syscs_diag." + vtiTableName + args);
1:         
1:         assertStatementError("42X62", st,
1:             "drop function syscs_diag." + vtiTableName);
1:         
1:         assertStatementError("42X01", st,
1:             "drop function syscs_diag." + vtiTableName + args);
1:         
1:         assertStatementError("42X62", st,
1:             "alter table syscs_diag." + vtiTableName + " add column bad int");
1:         
1:         assertStatementError("42X01", st,
1:             "alter table syscs_diag." + vtiTableName + args
1:             + " add column bad int");
1:         
1:         assertStatementError("42X05", st,
1:             "update syscs_diag." + vtiTableName
1:             + " set " + colName + " = NULL");
1:         
1:         assertStatementError("42X01", st,
1:             "update syscs_diag." + vtiTableName + args + " set "
1:             + colName + "  = NULL");
1:         
1:         assertStatementError("42X05", st,
1:             "delete from syscs_diag." + vtiTableName + " where 1 = 1");
1:         
1:         assertStatementError("42X01", st,
1:             "delete from syscs_diag." + vtiTableName + args + " where 1 = 1");
1:         
1:         assertStatementError("42X05", st,
1:             "insert into syscs_diag." + vtiTableName + " values('bad')");
1:         
1:         assertStatementError("42X05", st,
1:             "insert into syscs_diag." + vtiTableName + " (" + colName
1:             + ") values('bad')");
1:         
1:         assertStatementError("42X01", st,
1:             "insert into syscs_diag." + vtiTableName + args
1:             + " values('bad')");
1:         
1:         CallableStatement cSt = prepareCall(
1:             "call SYSCS_UTIL.SYSCS_COMPRESS_TABLE(?, ?, 1)");
1:         cSt.setString(1, "SYSCS_DIAG");
1:         cSt.setString(2, vtiTableName.toUpperCase());
0:         assertStatementError("42X62", cSt);
1:         
1:         cSt = prepareCall(
1:             "call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?, ?, 1, 1, 1)");
1:         cSt.setString(1, "SYSCS_DIAG");
1:         cSt.setString(2, vtiTableName.toUpperCase());
0:         assertStatementError("42X05", cSt);
1: 
1:         assertStatementError("42X08", st,
1:             "update new org.apache.derby.diag." + vtiMethodName + args
1:             + " set " + colName + " = NULL");
1:         
1:         assertStatementError("42X08", st,
1:             "delete from new org.apache.derby.diag." + vtiMethodName + args
1:             + " where 1 = 0");
1: 
1:         // Simple check to verify same restrictions hold true if current
1:         // schema is "SYSCS_DIAG".
1: 
1:         st.execute("set schema syscs_diag");
1:         assertStatementError("42X01", st,
1:             "select * from " + vtiTableName + args + " x");
1:         
1:         assertStatementError("42X01", st,
1:             "select * from (" + vtiTableName + args + ") x");
1: 
1:         st.execute("set schema app");
1:     }
1: }
============================================================================