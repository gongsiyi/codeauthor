1:b7730e4: /*
11:b7730e4: 
1:b7730e4:    Derby - Class org.apache.derby.impl.sql.compile.PrivilegeNode
1:b7730e4: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:b7730e4: 
1:b7730e4:       http://www.apache.org/licenses/LICENSE-2.0
1:b7730e4: 
1:b7730e4:    Unless required by applicable law or agreed to in writing, software
1:b7730e4:    distributed under the License is distributed on an "AS IS" BASIS,
1:b7730e4:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b7730e4:    See the License for the specific language governing permissions and
1:b7730e4:    limitations under the License.
1:b7730e4: 
1:b7730e4:  */
1:b7730e4: 
1:b7730e4: package	org.apache.derby.impl.sql.compile;
1:b7730e4: 
1:b7730e4: import java.util.HashMap;
1:4f5dc7d: import java.util.List;
1:3bb140c: import org.apache.derby.catalog.AliasInfo;
1:3bb140c: import org.apache.derby.catalog.TypeDescriptor;
1:3bb140c: import org.apache.derby.catalog.types.RoutineAliasInfo;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:69f8afa: import org.apache.derby.iapi.sql.compile.Visitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.depend.Provider;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.PrivilegedSQLObject;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:3bb140c: import org.apache.derby.impl.sql.execute.GenericPrivilegeInfo;
1:3bb140c: import org.apache.derby.impl.sql.execute.PrivilegeInfo;
1:b7730e4: 
1:b7730e4: /**
1:b7730e4:  * This node represents a set of privileges that are granted or revoked on one object.
1:b7730e4:  */
1:3bb140c: class PrivilegeNode extends QueryTreeNode
3:b7730e4: {
1:b7730e4:     // Privilege object type
1:b7730e4:     public static final int TABLE_PRIVILEGES = 0;
1:b7730e4:     public static final int ROUTINE_PRIVILEGES = 1;
1:98c7520:     public static final int SEQUENCE_PRIVILEGES = 2;
1:98c7520:     public static final int UDT_PRIVILEGES = 3;
1:f3c6217:     public static final int AGGREGATE_PRIVILEGES = 4;
1:b7730e4: 
1:98c7520:     //
1:98c7520:     // State initialized when the node is instantiated
1:98c7520:     //
1:b7730e4:     private int objectType;
1:66d9f5a:     private TableName objectName;
1:66d9f5a:     private TablePrivilegesNode specificPrivileges; // Null for routine and usage privs
1:66d9f5a:     private RoutineDesignator routineDesignator; // null for table and usage privs
1:b7730e4: 
1:98c7520:     private String privilege;  // E.g., PermDescriptor.USAGE_PRIV
1:98c7520:     private boolean restrict;
1:98c7520: 
1:98c7520:     //
1:98c7520:     // State which is filled in by the bind() logic.
1:98c7520:     //
1:98c7520:     private Provider dependencyProvider;
1:98c7520:     
1:b7730e4:     /**
1:98c7520:      * Initialize a PrivilegeNode for use against SYS.SYSTABLEPERMS and SYS.SYSROUTINEPERMS.
2:b7730e4:      *
1:3bb140c:      * @param objectType
1:3bb140c:      * @param objectOfPrivilege  (a TableName or RoutineDesignator)
1:98c7520:      * @param specificPrivileges null for routines and usage
1:3bb140c:      * @param cm                 the context manager
1:b7730e4:      */
1:3bb140c:     PrivilegeNode(int                 objectType,
1:3bb140c:                   Object              objectOfPrivilege,
1:3bb140c:                   TablePrivilegesNode specificPrivileges,
1:3bb140c:                   ContextManager      cm) throws StandardException {
1:3bb140c:         super(cm);
1:3bb140c:         this.objectType = objectType;
1:3bb140c: 
1:3bb140c:         if ( SanityManager.DEBUG)
1:b7730e4:         {
1:b7730e4:             SanityManager.ASSERT( objectOfPrivilege != null,
1:b7730e4:                                   "null privilge object");
1:4e119ab:         }
1:3bb140c: 
1:4e119ab:         switch( this.objectType)
1:4e119ab:         {
1:4e119ab:         case TABLE_PRIVILEGES:
3:4e119ab:             if( SanityManager.DEBUG)
1:b7730e4:             {
1:b7730e4:                 SanityManager.ASSERT( specificPrivileges != null,
1:b7730e4:                                       "null specific privileges used with table privilege");
1:4e119ab:             }
1:4e119ab:             objectName = (TableName) objectOfPrivilege;
1:3bb140c:             this.specificPrivileges = specificPrivileges;
1:4e119ab:             break;
1:4e119ab:             
1:4e119ab:         case ROUTINE_PRIVILEGES:
1:535acbd:             if( SanityManager.DEBUG)
1:4e119ab:             {
1:b7730e4:                 SanityManager.ASSERT( specificPrivileges == null,
1:b7730e4:                                       "non-null specific privileges used with execute privilege");
1:4e119ab:             }
1:4e119ab:             routineDesignator = (RoutineDesignator) objectOfPrivilege;
1:4e119ab:             objectName = routineDesignator.name;
1:4e119ab:             break;
1:4e119ab:             
1:4e119ab:         default:
1:98c7520:             throw unimplementedFeature();
1:535acbd:         }
1:4e119ab:     }
1:d78ad2e: 
1:b7730e4:     /**
1:3bb140c:      * Constructor a PrivilegeNode for use against SYS.SYSPERMS.
1:98c7520:      *
1:98c7520:      * @param objectType E.g., SEQUENCE
1:98c7520:      * @param objectName A possibles schema-qualified name
1:3bb140c:      * @param privilege  A PermDescriptor privilege, e.g.
1:3bb140c:      *                   {@code PermDescriptor.USAGE_PRIV}
1:3bb140c:      * @param restrict   True if this is a REVOKE...RESTRICT action
1:3bb140c:      * @param cm         The context manager
1:98c7520:      */
1:3bb140c:     PrivilegeNode(int            objectType,
1:3bb140c:                   TableName      objectName,
1:3bb140c:                   String         privilege,
1:3bb140c:                   boolean        restrict,
1:3bb140c:                   ContextManager cm)
1:98c7520:     {
1:3bb140c:         super(cm);
1:3bb140c:         this.objectType = objectType;
1:3bb140c:         this.objectName = objectName;
1:3bb140c:         this.privilege = privilege;
1:3bb140c:         this.restrict = restrict;
1:98c7520:     }
1:98c7520:     
1:98c7520:     /**
1:b7730e4:      * Bind this GrantNode. Resolve all table, column, and routine references. Register
1:b7730e4:      * a dependency on the object of the privilege if it has not already been done
1:b7730e4:      *
1:6b50965:      * @param dependencies The list of privilege objects that this statement has already seen.
1:b7730e4:      *               If the object of this privilege is not in the list then this statement is registered
1:b7730e4:      *               as dependent on the object.
1:4f5dc7d:      * @param grantees The list of grantees
1:17f7626:      * @param isGrant grant if true; revoke if false
1:b7730e4:      * @return the bound node
1:b7730e4:      *
1:b7730e4:      * @exception StandardException	Standard error policy.
1:b7730e4:      */
1:3bb140c:     public QueryTreeNode bind(
1:3bb140c:             HashMap<Provider,Provider> dependencies,
1:3bb140c:             List<String> grantees,
1:3bb140c:             boolean isGrant ) throws StandardException
1:535acbd: 	{
1:92dc6b8:         // The below code handles the case where objectName.getSchemaName()
1:92dc6b8:         // returns null, in which case we'll fetch the schema descriptor for
1:92dc6b8:         // the current compilation schema (see getSchemaDescriptor).
1:66d9f5a:         SchemaDescriptor sd = getSchemaDescriptor( objectName.getSchemaName(), true);
1:66d9f5a:         objectName.setSchemaName( sd.getSchemaName() );
1:66d9f5a:         
1:66d9f5a:         // Can not grant/revoke permissions from self
1:66d9f5a:         if (grantees.contains(sd.getAuthorizationId()))
1:4e119ab:         {
1:66d9f5a:             throw StandardException.newException
1:66d9f5a:                 (SQLState.AUTH_GRANT_REVOKE_NOT_ALLOWED, objectName.getFullTableName());
1:66d9f5a:         }
1:66d9f5a: 
1:b7730e4:         switch( objectType)
1:66d9f5a:         {
2:b7730e4:         case TABLE_PRIVILEGES:
1:66d9f5a: 
1:66d9f5a:             // can't grant/revoke privileges on system tables
1:d78ad2e:             if (sd.isSystemSchema())
1:66d9f5a:             {
1:66d9f5a:                 throw StandardException.newException(SQLState.AUTH_GRANT_REVOKE_NOT_ALLOWED, objectName.getFullTableName());
1:66d9f5a:             }
1:66d9f5a:             
1:66d9f5a:             TableDescriptor td = getTableDescriptor( objectName.getTableName(), sd);
1:b7730e4:             if( td == null)
1:66d9f5a:             {
1:66d9f5a:                 throw StandardException.newException( SQLState.LANG_TABLE_NOT_FOUND, objectName);
1:66d9f5a:             }
1:4f5dc7d: 
1:eb8b3a2:             // Don't allow authorization on SESSION schema tables. Causes confusion if
1:eb8b3a2:             // a temporary table is created later with same name.
1:eb8b3a2:             if (isSessionSchema(sd.getSchemaName()))
1:66d9f5a:             {
1:eb8b3a2:                 throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
1:66d9f5a:             }
1:4f5dc7d: 
1:2d2e717:             if (td.getTableType() != TableDescriptor.BASE_TABLE_TYPE &&
1:2d2e717:             		td.getTableType() != TableDescriptor.VIEW_TYPE)
1:66d9f5a:             {
1:66d9f5a:                 throw StandardException.newException(SQLState.AUTH_GRANT_REVOKE_NOT_ALLOWED, objectName.getFullTableName());
1:66d9f5a:             }
1:4f5dc7d: 
1:17f7626:             specificPrivileges.bind( td, isGrant);
1:b7730e4:             dependencyProvider = td;
3:b7730e4:             break;
1:eb8b3a2: 
2:b7730e4:         case ROUTINE_PRIVILEGES:
1:d78ad2e:             if (!sd.isSchemaWithGrantableRoutines())
1:66d9f5a:             {
1:66d9f5a:                 throw StandardException.newException(SQLState.AUTH_GRANT_REVOKE_NOT_ALLOWED, objectName.getFullTableName());
1:66d9f5a:             }
1:d78ad2e: 				
1:b7730e4:             AliasDescriptor proc = null;
1:3bb140c:             List<AliasDescriptor> list = getDataDictionary().getRoutineList(
1:3bb140c:                 sd.getUUID().toString(),
1:3bb140c:                 objectName.getTableName(),
1:3bb140c:                 routineDesignator.isFunction ?
1:3bb140c:                     AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR :
1:3bb140c:                     AliasInfo.ALIAS_NAME_SPACE_PROCEDURE_AS_CHAR);
1:b7730e4: 
1:66d9f5a:             if( routineDesignator.paramTypeList == null)
1:b7730e4:             {
1:b7730e4:                 // No signature was specified. Make sure that there is exactly one routine with that name.
1:b7730e4:                 if( list.size() > 1)
1:66d9f5a:                 {
1:66d9f5a:                     throw StandardException.newException( ( routineDesignator.isFunction ? SQLState.LANG_AMBIGUOUS_FUNCTION_NAME
1:b7730e4:                                                             : SQLState.LANG_AMBIGUOUS_PROCEDURE_NAME),
1:66d9f5a:                                                           objectName.getFullTableName());
1:66d9f5a:                 }
1:7585584:                 if( list.size() != 1) {
1:66d9f5a:                     if (routineDesignator.isFunction) {
1:7585584:                         throw StandardException.newException(SQLState.LANG_NO_SUCH_FUNCTION, 
1:66d9f5a:                                 objectName.getFullTableName());
1:7585584:                     } else {
1:7585584:                         throw StandardException.newException(SQLState.LANG_NO_SUCH_PROCEDURE, 
1:66d9f5a:                                 objectName.getFullTableName());
1:7585584:                     }
1:7585584:                 }
1:3bb140c:                 proc = list.get(0);
2:b7730e4:             }
1:b7730e4:             else
1:b7730e4:             {
1:b7730e4:                 // The full signature was specified
1:b7730e4:                 boolean found = false;
1:b7730e4:                 for (int i = list.size() - 1; (!found) && i >= 0; i--)
1:b7730e4:                 {
1:3bb140c:                     proc = list.get(i);
1:b7730e4: 
1:3bb140c:                     RoutineAliasInfo
1:3bb140c:                         routineInfo = (RoutineAliasInfo) proc.getAliasInfo();
1:b7730e4:                     int parameterCount = routineInfo.getParameterCount();
1:66d9f5a:                     if (parameterCount != routineDesignator.paramTypeList.size())
1:b7730e4:                         continue;
1:b7730e4:                     TypeDescriptor[] parameterTypes = routineInfo.getParameterTypes();
1:b7730e4:                     found = true;
1:b7730e4:                     for( int parmIdx = 0; parmIdx < parameterCount; parmIdx++)
1:b7730e4:                     {
1:66d9f5a:                         if( ! parameterTypes[parmIdx].equals( routineDesignator.paramTypeList.get( parmIdx)))
1:b7730e4:                         {
1:b7730e4:                             found = false;
1:b7730e4:                             break;
1:b7730e4:                         }
1:b7730e4:                     }
1:b7730e4:                 }
1:b7730e4:                 if( ! found)
1:b7730e4:                 {
1:b7730e4:                     // reconstruct the signature for the error message
1:3bb140c:                     StringBuilder sb =
1:3bb140c:                             new StringBuilder(objectName.getFullTableName());
1:b7730e4:                     sb.append( "(");
1:66d9f5a:                     for( int i = 0; i < routineDesignator.paramTypeList.size(); i++)
1:b7730e4:                     {
1:b7730e4:                         if( i > 0)
1:b7730e4:                             sb.append(",");
1:66d9f5a:                         sb.append( routineDesignator.paramTypeList.get(i).toString());
1:b7730e4:                     }
1:b7730e4:                     throw StandardException.newException(SQLState.LANG_NO_SUCH_METHOD_ALIAS, sb.toString());
1:b7730e4:                 }
1:b7730e4:             }
1:66d9f5a:             routineDesignator.setAliasDescriptor( proc);
1:b7730e4:             dependencyProvider = proc;
1:b7730e4:             break;
1:66d9f5a: 
1:f3c6217:         case AGGREGATE_PRIVILEGES:
1:f3c6217:             
1:f3c6217:             dependencyProvider = getDataDictionary().getAliasDescriptor
1:f3c6217:                 ( sd.getUUID().toString(), objectName.getTableName(), AliasInfo.ALIAS_NAME_SPACE_AGGREGATE_AS_CHAR  );
1:f3c6217:             if ( dependencyProvider == null )
1:f3c6217:             {
1:f3c6217:                 throw StandardException.newException
1:f3c6217:                     (SQLState.LANG_OBJECT_NOT_FOUND, "DERBY AGGREGATE", objectName.getFullTableName());
1:f3c6217:             }
1:f3c6217:             break;
1:f3c6217:             
1:98c7520:         case SEQUENCE_PRIVILEGES:
1:98c7520:             
1:98c7520:             dependencyProvider = getDataDictionary().getSequenceDescriptor( sd, objectName.getTableName() );
1:98c7520:             if ( dependencyProvider == null )
1:b7730e4:             {
1:98c7520:                 throw StandardException.newException(SQLState.LANG_OBJECT_NOT_FOUND, "SEQUENCE", objectName.getFullTableName());
1:b7730e4:             }
1:98c7520:             break;
1:98c7520:             
1:98c7520:         case UDT_PRIVILEGES:
1:98c7520:             
1:98c7520:             dependencyProvider = getDataDictionary().getAliasDescriptor
1:98c7520:                 ( sd.getUUID().toString(), objectName.getTableName(), AliasInfo.ALIAS_NAME_SPACE_UDT_AS_CHAR  );
1:98c7520:             if ( dependencyProvider == null )
1:98c7520:             {
1:98c7520:                 throw StandardException.newException(SQLState.LANG_OBJECT_NOT_FOUND, "TYPE", objectName.getFullTableName());
1:98c7520:             }
1:98c7520:             break;
1:98c7520:             
1:98c7520:         default:
1:98c7520:             throw unimplementedFeature();
1:b7730e4:         }
1:4f5dc7d: 
1:b7730e4:         if( dependencyProvider != null)
1:b7730e4:         {
1:b7730e4:             if( dependencies.get( dependencyProvider) == null)
1:b7730e4:             {
1:b7730e4:                 getCompilerContext().createDependency( dependencyProvider);
1:b7730e4:                 dependencies.put( dependencyProvider, dependencyProvider);
1:b7730e4:             }
1:b7730e4:         }
1:b7730e4:         return this;
1:b7730e4:     } // end of bind
1:98c7520: 
1:b7730e4: 
1:b7730e4:     /**
1:b7730e4:      * @return PrivilegeInfo for this node
1:b7730e4:      */
1:98c7520:     PrivilegeInfo makePrivilegeInfo() throws StandardException
1:b7730e4:     {
1:b7730e4:         switch( objectType)
1:b7730e4:         {
1:b7730e4:         case TABLE_PRIVILEGES:
1:b7730e4:             return specificPrivileges.makePrivilegeInfo();
1:b7730e4: 
1:b7730e4:         case ROUTINE_PRIVILEGES:
1:66d9f5a:             return routineDesignator.makePrivilegeInfo();
1:98c7520: 
1:f3c6217:         case AGGREGATE_PRIVILEGES:
1:98c7520:         case SEQUENCE_PRIVILEGES:
1:98c7520:         case UDT_PRIVILEGES:
1:98c7520:             return new GenericPrivilegeInfo( (PrivilegedSQLObject) dependencyProvider, privilege, restrict );
1:98c7520: 
1:98c7520:         default:
1:98c7520:             throw unimplementedFeature();
1:98c7520:         }
1:b7730e4:     }
1:98c7520: 
1:98c7520:     /** Report an unimplemented feature */
1:98c7520:     private StandardException unimplementedFeature()
1:98c7520:     {
1:98c7520:         return StandardException.newException( SQLState.BTREE_UNIMPLEMENTED_FEATURE );
1:b7730e4:     }
1:69f8afa: 
1:69f8afa:     @Override
1:69f8afa:     void acceptChildren(Visitor v) throws StandardException {
1:69f8afa:         super.acceptChildren(v);
1:69f8afa: 
1:69f8afa:         if (objectName != null) {
1:69f8afa:             objectName = (TableName) objectName.accept(v);
1:69f8afa:         }
1:69f8afa:     }
1:b7730e4: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:69f8afa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     void acceptChildren(Visitor v) throws StandardException {
1:         super.acceptChildren(v);
1: 
1:         if (objectName != null) {
1:             objectName = (TableName) objectName.accept(v);
1:         }
1:     }
commit:7585584
/////////////////////////////////////////////////////////////////////////
1:                 if( list.size() != 1) {
0:                     if (rd.isFunction) {
1:                         throw StandardException.newException(SQLState.LANG_NO_SUCH_FUNCTION, 
0:                                 rd.name.getFullTableName());
1:                     } else {
1:                         throw StandardException.newException(SQLState.LANG_NO_SUCH_PROCEDURE, 
0:                                 rd.name.getFullTableName());
1:                     }
1:                 }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.AliasInfo;
1: import org.apache.derby.catalog.TypeDescriptor;
1: import org.apache.derby.catalog.types.RoutineAliasInfo;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.depend.Provider;
1: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.PrivilegedSQLObject;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.impl.sql.execute.GenericPrivilegeInfo;
1: import org.apache.derby.impl.sql.execute.PrivilegeInfo;
1: class PrivilegeNode extends QueryTreeNode
/////////////////////////////////////////////////////////////////////////
1:      * @param objectType
1:      * @param objectOfPrivilege  (a TableName or RoutineDesignator)
1:      * @param cm                 the context manager
1:     PrivilegeNode(int                 objectType,
1:                   Object              objectOfPrivilege,
1:                   TablePrivilegesNode specificPrivileges,
1:                   ContextManager      cm) throws StandardException {
1:         super(cm);
0:         setNodeType(C_NodeTypes.PRIVILEGE_NODE);
1:         this.objectType = objectType;
1: 
1:         if ( SanityManager.DEBUG)
1: 
/////////////////////////////////////////////////////////////////////////
1:             this.specificPrivileges = specificPrivileges;
/////////////////////////////////////////////////////////////////////////
1:      * Constructor a PrivilegeNode for use against SYS.SYSPERMS.
1:      * @param privilege  A PermDescriptor privilege, e.g.
1:      *                   {@code PermDescriptor.USAGE_PRIV}
1:      * @param restrict   True if this is a REVOKE...RESTRICT action
1:      * @param cm         The context manager
1:     PrivilegeNode(int            objectType,
1:                   TableName      objectName,
1:                   String         privilege,
1:                   boolean        restrict,
1:                   ContextManager cm)
1:         super(cm);
0:         setNodeType(C_NodeTypes.PRIVILEGE_NODE);
1:         this.objectType = objectType;
1:         this.objectName = objectName;
1:         this.privilege = privilege;
1:         this.restrict = restrict;
/////////////////////////////////////////////////////////////////////////
1:     public QueryTreeNode bind(
1:             HashMap<Provider,Provider> dependencies,
1:             List<String> grantees,
1:             boolean isGrant ) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:             List<AliasDescriptor> list = getDataDictionary().getRoutineList(
1:                 sd.getUUID().toString(),
1:                 objectName.getTableName(),
1:                 routineDesignator.isFunction ?
1:                     AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR :
1:                     AliasInfo.ALIAS_NAME_SPACE_PROCEDURE_AS_CHAR);
/////////////////////////////////////////////////////////////////////////
1:                 proc = list.get(0);
/////////////////////////////////////////////////////////////////////////
1:                     proc = list.get(i);
1:                     RoutineAliasInfo
1:                         routineInfo = (RoutineAliasInfo) proc.getAliasInfo();
/////////////////////////////////////////////////////////////////////////
1:                     StringBuilder sb =
1:                             new StringBuilder(objectName.getFullTableName());
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:274c5ba
/////////////////////////////////////////////////////////////////////////
0: 	public QueryTreeNode bind( HashMap<Provider,Provider> dependencies, List grantees, boolean isGrant ) throws StandardException
commit:f3c6217
/////////////////////////////////////////////////////////////////////////
1:     public static final int AGGREGATE_PRIVILEGES = 4;
/////////////////////////////////////////////////////////////////////////
1:         case AGGREGATE_PRIVILEGES:
1:             
1:             dependencyProvider = getDataDictionary().getAliasDescriptor
1:                 ( sd.getUUID().toString(), objectName.getTableName(), AliasInfo.ALIAS_NAME_SPACE_AGGREGATE_AS_CHAR  );
1:             if ( dependencyProvider == null )
1:             {
1:                 throw StandardException.newException
1:                     (SQLState.LANG_OBJECT_NOT_FOUND, "DERBY AGGREGATE", objectName.getFullTableName());
1:             }
1:             break;
1:             
/////////////////////////////////////////////////////////////////////////
1:         case AGGREGATE_PRIVILEGES:
commit:98c7520
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.dictionary.PrivilegedSQLObject;
0: import org.apache.derby.impl.sql.execute.GenericPrivilegeInfo;
/////////////////////////////////////////////////////////////////////////
1:     public static final int SEQUENCE_PRIVILEGES = 2;
1:     public static final int UDT_PRIVILEGES = 3;
1:     //
1:     // State initialized when the node is instantiated
1:     //
1:     private String privilege;  // E.g., PermDescriptor.USAGE_PRIV
1:     private boolean restrict;
1: 
1:     //
1:     // State which is filled in by the bind() logic.
1:     //
1:     private Provider dependencyProvider;
1:     
1:      * Initialize a PrivilegeNode for use against SYS.SYSTABLEPERMS and SYS.SYSROUTINEPERMS.
1:      * @param specificPrivileges null for routines and usage
0:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:             throw unimplementedFeature();
0:      * Initialize a PrivilegeNode for use against SYS.SYSPERMS.
1:      *
1:      * @param objectType E.g., SEQUENCE
1:      * @param objectName A possibles schema-qualified name
0:      * @param privilege A PermDescriptor privilege, e.g. PermDescriptor.USAGE_PRIV
0:      * @param restrict True if this is a REVOKE...RESTRICT action
1:      */
0:     public void init( Object objectType, Object objectName, Object privilege, Object restrict )
1:     {
0:         this.objectType = ((Integer) objectType).intValue();
0:         this.objectName = (TableName) objectName;
0:         this.privilege = (String) privilege;
0:         this.restrict = ((Boolean) restrict).booleanValue();
1:     }
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         case SEQUENCE_PRIVILEGES:
1:             
1:             dependencyProvider = getDataDictionary().getSequenceDescriptor( sd, objectName.getTableName() );
1:             if ( dependencyProvider == null )
1:                 throw StandardException.newException(SQLState.LANG_OBJECT_NOT_FOUND, "SEQUENCE", objectName.getFullTableName());
1:             break;
1:             
1:         case UDT_PRIVILEGES:
1:             
1:             dependencyProvider = getDataDictionary().getAliasDescriptor
1:                 ( sd.getUUID().toString(), objectName.getTableName(), AliasInfo.ALIAS_NAME_SPACE_UDT_AS_CHAR  );
1:             if ( dependencyProvider == null )
1:             {
1:                 throw StandardException.newException(SQLState.LANG_OBJECT_NOT_FOUND, "TYPE", objectName.getFullTableName());
1:             }
1:             break;
1:             
1:         default:
1:             throw unimplementedFeature();
/////////////////////////////////////////////////////////////////////////
1: 
1:     PrivilegeInfo makePrivilegeInfo() throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 
1:         case SEQUENCE_PRIVILEGES:
1:         case UDT_PRIVILEGES:
1:             return new GenericPrivilegeInfo( (PrivilegedSQLObject) dependencyProvider, privilege, restrict );
1: 
1:         default:
1:             throw unimplementedFeature();
1:     }
1: 
1:     /** Report an unimplemented feature */
1:     private StandardException unimplementedFeature()
1:     {
1:         return StandardException.newException( SQLState.BTREE_UNIMPLEMENTED_FEATURE );
commit:535acbd
/////////////////////////////////////////////////////////////////////////
1:             if( SanityManager.DEBUG)
1:             {
1:             }
commit:4e119ab
/////////////////////////////////////////////////////////////////////////
1:         }
1:         switch( this.objectType)
1:         {
1:         case TABLE_PRIVILEGES:
1:             if( SanityManager.DEBUG)
1:             }
1:             objectName = (TableName) objectOfPrivilege;
0:             this.specificPrivileges = (TablePrivilegesNode) specificPrivileges;
1:             break;
1:             
1:         case ROUTINE_PRIVILEGES:
1:             if( SanityManager.DEBUG)
1:             {
1:             }
1:             routineDesignator = (RoutineDesignator) objectOfPrivilege;
1:             objectName = routineDesignator.name;
1:             break;
1:             
1:         default:
1:             if( SanityManager.DEBUG)
1:             {
1:     }
commit:66d9f5a
/////////////////////////////////////////////////////////////////////////
1:     private TableName objectName;
1:     private TablePrivilegesNode specificPrivileges; // Null for routine and usage privs
1:     private RoutineDesignator routineDesignator; // null for table and usage privs
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 objectName = (TableName) objectOfPrivilege;
0:                 this.specificPrivileges = (TablePrivilegesNode) specificPrivileges;
0:                 routineDesignator = (RoutineDesignator) objectOfPrivilege;
0:                 objectName = routineDesignator.name;
/////////////////////////////////////////////////////////////////////////
1:         SchemaDescriptor sd = getSchemaDescriptor( objectName.getSchemaName(), true);
1:         objectName.setSchemaName( sd.getSchemaName() );
1:         
1:         // Can not grant/revoke permissions from self
1:         if (grantees.contains(sd.getAuthorizationId()))
1:         {
1:             throw StandardException.newException
1:                 (SQLState.AUTH_GRANT_REVOKE_NOT_ALLOWED, objectName.getFullTableName());
1:         }
1: 
1: 
1:             // can't grant/revoke privileges on system tables
1:             {
1:                 throw StandardException.newException(SQLState.AUTH_GRANT_REVOKE_NOT_ALLOWED, objectName.getFullTableName());
1:             }
1:             
1:             TableDescriptor td = getTableDescriptor( objectName.getTableName(), sd);
1:             {
1:                 throw StandardException.newException( SQLState.LANG_TABLE_NOT_FOUND, objectName);
1:             }
1:             {
1:             }
1:             {
1:                 throw StandardException.newException(SQLState.AUTH_GRANT_REVOKE_NOT_ALLOWED, objectName.getFullTableName());
1:             }
1:             {
1:                 throw StandardException.newException(SQLState.AUTH_GRANT_REVOKE_NOT_ALLOWED, objectName.getFullTableName());
1:             }
0:                 sd.getUUID().toString(), objectName.getTableName(),
0:                 routineDesignator.isFunction ? AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR : AliasInfo.ALIAS_NAME_SPACE_PROCEDURE_AS_CHAR
1:             if( routineDesignator.paramTypeList == null)
1:                 {
1:                     throw StandardException.newException( ( routineDesignator.isFunction ? SQLState.LANG_AMBIGUOUS_FUNCTION_NAME
1:                                                           objectName.getFullTableName());
1:                 }
1:                     if (routineDesignator.isFunction) {
1:                                 objectName.getFullTableName());
1:                                 objectName.getFullTableName());
/////////////////////////////////////////////////////////////////////////
1:                     if (parameterCount != routineDesignator.paramTypeList.size())
1:                         if( ! parameterTypes[parmIdx].equals( routineDesignator.paramTypeList.get( parmIdx)))
/////////////////////////////////////////////////////////////////////////
0:                     StringBuffer sb = new StringBuffer( objectName.getFullTableName());
1:                     for( int i = 0; i < routineDesignator.paramTypeList.size(); i++)
1:                         sb.append( routineDesignator.paramTypeList.get(i).toString());
1:             routineDesignator.setAliasDescriptor( proc);
1: 
0:         default:
0:                 SanityManager.THROWASSERT( "Invalid privilege objectType: " + this.objectType);
/////////////////////////////////////////////////////////////////////////
1:             return routineDesignator.makePrivilegeInfo();
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:92dc6b8
/////////////////////////////////////////////////////////////////////////
1:         // The below code handles the case where objectName.getSchemaName()
1:         // returns null, in which case we'll fetch the schema descriptor for
1:         // the current compilation schema (see getSchemaDescriptor).
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:17f7626
/////////////////////////////////////////////////////////////////////////
1:      * @param isGrant grant if true; revoke if false
0: 	public QueryTreeNode bind( HashMap dependencies, List grantees, boolean isGrant ) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:             specificPrivileges.bind( td, isGrant);
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
0:             // GrantRevoke TODO: Disable grant on VTIs and Synonyms
1:             if (td.getTableType() != TableDescriptor.BASE_TABLE_TYPE &&
1:             		td.getTableType() != TableDescriptor.VIEW_TYPE)
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:4f5dc7d
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:      * @param grantees The list of grantees
0: 	public QueryTreeNode bind( HashMap dependencies, List grantees ) throws StandardException
1: 		
/////////////////////////////////////////////////////////////////////////
0: 			// Can not grant/revoke permissions from self
0: 			if (grantees.contains(sd.getAuthorizationId()))
0: 				throw StandardException.newException(SQLState.AUTH_GRANT_REVOKE_NOT_ALLOWED,
0: 						 td.getQualifiedName());
1: 
/////////////////////////////////////////////////////////////////////////
0: 			// Can not grant/revoke permissions from self
0: 			if (grantees.contains(sd.getAuthorizationId()))
0: 				throw StandardException.newException(SQLState.AUTH_GRANT_REVOKE_NOT_ALLOWED,
0: 						 rd.name.getFullTableName());
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:eb8b3a2
/////////////////////////////////////////////////////////////////////////
1:             // Don't allow authorization on SESSION schema tables. Causes confusion if
1:             // a temporary table is created later with same name.
1:             if (isSessionSchema(sd.getSchemaName()))
1:                 throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
1: 
0:             // GrantRevoke TODO: Need to enable for views later. Disable for now.
0:             // Disable grant on VTIs and Synonyms
0:             if (td.getTableType() != TableDescriptor.BASE_TABLE_TYPE)
0:                 throw StandardException.newException(SQLState.AUTH_GRANT_REVOKE_NOT_ALLOWED, tableName.getFullTableName());
commit:d78ad2e
/////////////////////////////////////////////////////////////////////////
1:             if (sd.isSystemSchema())
0:                 throw StandardException.newException(SQLState.AUTH_GRANT_REVOKE_NOT_ALLOWED, tableName.getFullTableName());
1: 				
/////////////////////////////////////////////////////////////////////////
1:             if (!sd.isSchemaWithGrantableRoutines())
0:                 throw StandardException.newException(SQLState.AUTH_GRANT_REVOKE_NOT_ALLOWED, rd.name.getFullTableName());
1: 				
commit:b7730e4
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.sql.compile.PrivilegeNode
1: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
0: import org.apache.derby.catalog.types.RoutineAliasInfo;
0: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.impl.sql.execute.PrivilegeInfo;
0: import org.apache.derby.catalog.TypeDescriptor;
1: 
1: import java.util.HashMap;
1: 
1: /**
1:  * This node represents a set of privileges that are granted or revoked on one object.
1:  */
0: public class PrivilegeNode extends QueryTreeNode
1: {
1:     // Privilege object type
1:     public static final int TABLE_PRIVILEGES = 0;
1:     public static final int ROUTINE_PRIVILEGES = 1;
1: 
1:     private int objectType;
0:     private Object objectOfPrivilege;
0:     private TablePrivilegesNode specificPrivileges; // Null for routines
1: 
1:     /**
0:      * initialize a PrivilegesNode
1:      *
0:      * @param objectType (an Integer)
0:      * @param objectOfPrivilege (a TableName or RoutineDesignator)
0:      * @param specificPrivileges null for routines
1:      */
0:     public void init( Object objectType, Object objectOfPrivilege, Object specificPrivileges)
1:     {
0:         this.objectType = ((Integer) objectType).intValue();
0:         this.objectOfPrivilege = objectOfPrivilege;
0:         this.specificPrivileges = (TablePrivilegesNode) specificPrivileges;
0:         if( SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT( objectOfPrivilege != null,
1:                                   "null privilge object");
0:             switch( this.objectType)
1:             {
1:             case TABLE_PRIVILEGES:
0:                 SanityManager.ASSERT( objectOfPrivilege instanceof TableName,
0:                                       "incorrect name type, " + objectOfPrivilege.getClass().getName()
0:                                       + ", used with table privilege");
1:                 SanityManager.ASSERT( specificPrivileges != null,
1:                                       "null specific privileges used with table privilege");
1:                 break;
1: 
1:             case ROUTINE_PRIVILEGES:
0:                 SanityManager.ASSERT( objectOfPrivilege instanceof RoutineDesignator,
0:                                       "incorrect name type, " + objectOfPrivilege.getClass().getName()
0:                                       + ", used with table privilege");
1:                 SanityManager.ASSERT( specificPrivileges == null,
1:                                       "non-null specific privileges used with execute privilege");
1:                 break;
1: 
0:             default:
0:                 SanityManager.THROWASSERT( "Invalid privilege objectType: " + this.objectType);
1:             }
1:         }
0:     } // end of init
1: 
1:     /**
1:      * Bind this GrantNode. Resolve all table, column, and routine references. Register
1:      * a dependency on the object of the privilege if it has not already been done
1:      *
0:      * @dependencies The list of privilege objects that this statement has already seen.
1:      *               If the object of this privilege is not in the list then this statement is registered
1:      *               as dependent on the object.
1:      *
1:      * @return the bound node
1:      *
1:      * @exception StandardException	Standard error policy.
1:      */
0: 	public QueryTreeNode bind( HashMap dependencies ) throws StandardException
1: 	{
0:         Provider dependencyProvider = null;
0:         SchemaDescriptor sd = null;
1:         
1:         switch( objectType)
1:         {
1:         case TABLE_PRIVILEGES:
0:             TableName tableName = (TableName) objectOfPrivilege;
0:             sd = getSchemaDescriptor( tableName.getSchemaName(), true);
0:             TableDescriptor td = getTableDescriptor( tableName.getTableName(), sd);
1:             if( td == null)
0:                 throw StandardException.newException( SQLState.LANG_TABLE_NOT_FOUND, tableName);
1: 
0: 			// Don't allow authorization on SESSION schema tables. Causes confusion if
0: 			// a temporary table is created later with same name.
0: 			if (isSessionSchema(sd.getSchemaName()))
0: 				throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
1: 
0:             specificPrivileges.bind( td);
1:             dependencyProvider = td;
1:             break;
1: 
1:         case ROUTINE_PRIVILEGES:
0:             RoutineDesignator rd = (RoutineDesignator) objectOfPrivilege;
0:             sd = getSchemaDescriptor( rd.name.getSchemaName(), true);
1: 
1:             AliasDescriptor proc = null;
0:             RoutineAliasInfo routineInfo = null;
0:             java.util.List list = getDataDictionary().getRoutineList(
0:                 sd.getUUID().toString(), rd.name.getTableName(),
0:                 rd.isFunction ? AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR : AliasInfo.ALIAS_NAME_SPACE_PROCEDURE_AS_CHAR
0:                 );
1: 
0:             if( rd.paramTypeList == null)
1:             {
1:                 // No signature was specified. Make sure that there is exactly one routine with that name.
1:                 if( list.size() > 1)
0:                     throw StandardException.newException( ( rd.isFunction ? SQLState.LANG_AMBIGUOUS_FUNCTION_NAME
1:                                                             : SQLState.LANG_AMBIGUOUS_PROCEDURE_NAME),
0:                                                           rd.name.getFullTableName());
0:                 if( list.size() != 1)
0:                     throw StandardException.newException(SQLState.LANG_NO_SUCH_METHOD_ALIAS, rd.name.getFullTableName());
0:                 proc = (AliasDescriptor) list.get(0);
1:             }
1:             else
1:             {
1:                 // The full signature was specified
1:                 boolean found = false;
1:                 for (int i = list.size() - 1; (!found) && i >= 0; i--)
1:                 {
0:                     proc = (AliasDescriptor) list.get(i);
1: 
0:                     routineInfo = (RoutineAliasInfo) proc.getAliasInfo();
1:                     int parameterCount = routineInfo.getParameterCount();
0:                     if (parameterCount != rd.paramTypeList.size())
1:                         continue;
1:                     TypeDescriptor[] parameterTypes = routineInfo.getParameterTypes();
1:                     found = true;
1:                     for( int parmIdx = 0; parmIdx < parameterCount; parmIdx++)
1:                     {
0:                         if( ! parameterTypes[parmIdx].equals( rd.paramTypeList.get( parmIdx)))
1:                         {
1:                             found = false;
1:                             break;
1:                         }
1:                     }
1:                 }
1:                 if( ! found)
1:                 {
1:                     // reconstruct the signature for the error message
0:                     StringBuffer sb = new StringBuffer( rd.name.getFullTableName());
1:                     sb.append( "(");
0:                     for( int i = 0; i < rd.paramTypeList.size(); i++)
1:                     {
1:                         if( i > 0)
1:                             sb.append(",");
0:                         sb.append( rd.paramTypeList.get(i).toString());
1:                     }
1:                     throw StandardException.newException(SQLState.LANG_NO_SUCH_METHOD_ALIAS, sb.toString());
1:                 }
1:             }
0:             rd.setAliasDescriptor( proc);
1:             dependencyProvider = proc;
1:             break;
1:         }
1:         if( dependencyProvider != null)
1:         {
1:             if( dependencies.get( dependencyProvider) == null)
1:             {
1:                 getCompilerContext().createDependency( dependencyProvider);
1:                 dependencies.put( dependencyProvider, dependencyProvider);
1:             }
1:         }
1:         return this;
1:     } // end of bind
1: 
1:     /**
1:      * @return PrivilegeInfo for this node
1:      */
0:     PrivilegeInfo makePrivilegeInfo()
1:     {
1:         switch( objectType)
1:         {
1:         case TABLE_PRIVILEGES:
1:             return specificPrivileges.makePrivilegeInfo();
1: 
1:         case ROUTINE_PRIVILEGES:
0:             return ((RoutineDesignator) objectOfPrivilege).makePrivilegeInfo();
1:         }
0:         return null;
1:     }
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1:      * @param dependencies The list of privilege objects that this statement has already seen.
============================================================================