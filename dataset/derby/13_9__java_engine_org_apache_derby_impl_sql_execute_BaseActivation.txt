10:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.BaseActivation
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
62:eac0369: 
19:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:1e2aae0: 
1:56c1dc2: import java.security.AccessController;
1:56c1dc2: import java.security.PrivilegedAction;
1:eac0369: import java.sql.Connection;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.SQLWarning;
1:eac0369: import java.util.ArrayList;
1:706f2eb: import java.util.Enumeration;
1:eac0369: import java.util.HashSet;
1:1e2aae0: import java.util.Hashtable;
1:508a010: import java.util.Stack;
1:1e2aae0: import java.util.Vector;
1:0c5bc3a: import org.apache.derby.catalog.Dependable;
1:0c5bc3a: import org.apache.derby.catalog.DependableFinder;
1:e4caed2: import org.apache.derby.catalog.UUID;
1:1e2aae0: import org.apache.derby.iapi.error.StandardException;
1:1e2aae0: import org.apache.derby.iapi.jdbc.ConnectionContext;
1:1e2aae0: import org.apache.derby.iapi.reference.Property;
1:1e2aae0: import org.apache.derby.iapi.reference.SQLState;
1:1e2aae0: import org.apache.derby.iapi.services.context.Context;
1:1e2aae0: import org.apache.derby.iapi.services.context.ContextManager;
1:706f2eb: import org.apache.derby.iapi.services.io.ArrayUtil;
1:1e2aae0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:1e2aae0: import org.apache.derby.iapi.services.loader.GeneratedByteCode;
1:1e2aae0: import org.apache.derby.iapi.services.loader.GeneratedClass;
1:1e2aae0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1:56c1dc2: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:0c5bc3a: import org.apache.derby.iapi.services.monitor.Monitor;
1:1e2aae0: import org.apache.derby.iapi.services.property.PropertyUtil;
1:0c5bc3a: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1:1e2aae0: import org.apache.derby.iapi.sql.Activation;
1:1e2aae0: import org.apache.derby.iapi.sql.ParameterValueSet;
1:0c5bc3a: import org.apache.derby.iapi.sql.PreparedStatement;
1:1e2aae0: import org.apache.derby.iapi.sql.ResultDescription;
1:1e2aae0: import org.apache.derby.iapi.sql.ResultSet;
1:c533cd2: import org.apache.derby.iapi.sql.Row;
1:1e2aae0: import org.apache.derby.iapi.sql.compile.Optimizer;
1:1e2aae0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:6950a39: import org.apache.derby.iapi.sql.conn.SQLSessionContext;
1:1e2aae0: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:0c5bc3a: import org.apache.derby.iapi.sql.depend.Provider;
1:1e2aae0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:1e2aae0: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:1e2aae0: import org.apache.derby.iapi.sql.execute.CursorActivation;
1:1e2aae0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:1e2aae0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1:1e2aae0: import org.apache.derby.iapi.sql.execute.ExecRow;
1:1e2aae0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1:1e2aae0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:1e2aae0: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
1:eac0369: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
1:1e2aae0: import org.apache.derby.iapi.store.access.ConglomerateController;
1:1e2aae0: import org.apache.derby.iapi.store.access.Qualifier;
1:1e2aae0: import org.apache.derby.iapi.store.access.ScanController;
1:1e2aae0: import org.apache.derby.iapi.store.access.TransactionController;
1:1e2aae0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:1e2aae0: import org.apache.derby.iapi.types.DataValueDescriptor;
1:1e2aae0: import org.apache.derby.iapi.types.DataValueFactory;
1:1e2aae0: import org.apache.derby.iapi.types.NumberDataValue;
1:1e2aae0: import org.apache.derby.iapi.types.RowLocation;
1:139ca85: import org.apache.derby.iapi.types.StringDataValue;
1:0c5bc3a: import org.apache.derby.shared.common.sanity.SanityManager;
1:e4caed2: 
7:eac0369: /**
1:eac0369:  * BaseActivation
1:eac0369:  * provides the fundamental support we expect all activations to have.
1:eac0369:  * Doesn't actually implement any of the activation interface,
1:eac0369:  * expects the subclasses to do that.
1:eac0369:  */
1:eac0369: public abstract class BaseActivation implements CursorActivation, GeneratedByteCode
1:eac0369: 
19:eac0369: {
1:6c000e8: 	private	LanguageConnectionContext	lcc;
1:eac0369: 	protected ContextManager			cm;
1:eac0369: 
1:eac0369: 	protected ExecPreparedStatement preStmt;
1:eac0369: 	protected ResultSet resultSet;
1:eac0369: 	protected ResultDescription resultDescription;
1:eac0369: 	protected boolean closed;
1:eac0369: 	private String cursorName;
1:eac0369: 	
1:eac0369: 	protected int numSubqueries;
1:eac0369: 
1:eac0369: 	private boolean singleExecution;
1:68c8e7d: 
1:68c8e7d: 	// This flag is declared volatile to ensure it is 
1:68c8e7d: 	// visible when it has been modified by the finalizer thread.
1:68c8e7d: 	private volatile boolean inUse;
1:eac0369: 
1:eac0369: 	private java.sql.ResultSet targetVTI;
1:eac0369: 	private SQLWarning warnings;
1:eac0369: 
1:eac0369: 	private GeneratedClass gc;	// my Generated class object.
1:eac0369: 
1:eac0369: 	private boolean checkRowCounts;
1:71c8e86: 	private HashSet<Integer> rowCountsCheckedThisExecution = new HashSet<Integer>(4, 0.9f);
1:eac0369: 
1:eac0369: 	private static final long MAX_SQRT = (long) Math.sqrt(Long.MAX_VALUE);
1:eac0369: 
1:eac0369: 	// When the row count exceeds this number, we should recompile if
1:eac0369: 	// the difference in row counts is greater than 10%.  If it's less
1:eac0369: 	// than this number, we use an entirely different technique to check
1:eac0369: 	// for recompilation.  See comments below, in informOfRowCount()
1:eac0369: 	private static final int TEN_PERCENT_THRESHOLD = 400;
1:eac0369: 
1:eac0369: 	/* Performance optimization for update/delete - only
1:eac0369: 	 * open heap ConglomerateController once when doing
1:eac0369: 	 * index row to base row on search
1:eac0369: 	 */
1:eac0369: 	private ConglomerateController  updateHeapCC;
1:eac0369: 	private ScanController			indexSC;
1:eac0369: 	private long					indexConglomerateNumber = -1;
1:eac0369: 
1:eac0369: 	private TableDescriptor ddlTableDescriptor;
1:eac0369: 
1:47a8183: 	private long maxRows = -1L;
1:eac0369: 	private boolean			forCreateTable;
1:eac0369: 
1:eac0369: 	private boolean			scrollable;
1:eac0369: 
1:eac0369:   	private boolean resultSetHoldability;
1:eac0369: 
1:eac0369: 	//beetle 3865: updateable cursor using index.  A way of communication
1:eac0369: 	//between cursor activation and update activation.
1:eac0369: 	private CursorResultSet forUpdateIndexScan;
1:eac0369: 
1:eac0369: 	//Following three are used for JDBC3.0 auto-generated keys feature.
1:eac0369: 	//autoGeneratedKeysResultSetMode will be set true if at the time of statement execution,
1:eac0369: 	//either Statement.RETURN_GENERATED_KEYS was passed or an array of (column positions or
1:eac0369: 	//column names) was passed
1:eac0369: 	private boolean autoGeneratedKeysResultSetMode;
1:eac0369: 	private int[] autoGeneratedKeysColumnIndexes ;
1:eac0369: 	private String[] autoGeneratedKeysColumnNames ;
1:eac0369: 
1:6950a39: 	/**
1:e4caed2: 	 * By setting isValid to false, we can force a new activation to be used
1:e4caed2: 	 * even if the prepared statement is still valid. This is used when
1:e4caed2: 	 * modifying the current role for a session, which may (if the statement
1:e4caed2: 	 * relies on privileges obtained via the current role) require rechecking
1:e4caed2: 	 * of privileges. The checking normally only happens the first time the
1:e4caed2: 	 * prepared statement is used in a session, when the activation is
1:e4caed2: 	 * constructed. Forcing creation of a new activation achieves the purpose
1:e4caed2: 	 * of getting the check performed over again and is cheaper than
1:e4caed2: 	 * invalidating the prepared statement itself. Also, the latter would
1:e4caed2: 	 * impact other sessions, forcing them to recreate their activations.
1:e4caed2: 	 */
1:e4caed2: 	private boolean isValid;
1:e4caed2: 
1:e4caed2: 	/**
1:e4caed2: 	 * For dependency tracking
1:e4caed2: 	 */
1:e4caed2: 	protected String UUIDString;
1:e4caed2: 
1:e4caed2: 	/**
1:e4caed2: 	 * For dependency tracking
1:e4caed2: 	 */
1:e4caed2: 	protected UUID   UUIDValue;
1:e4caed2: 
1:e4caed2: 	/**
1:e3883f5: 	 * The 'parentActivation' of an activation of a statement executing in
1:6950a39: 	 * the root connection is null.
1:6950a39: 	 *
1:e3883f5: 	 * A non-null 'parentActivation' represents the activation of the calling
1:e3883f5: 	 * statement (if we are in a nested connection of a stored routine), or the
1:0c5bc3a:      * activation of the parent statement (if we are executing a sub-statement)
1:6950a39: 	 *
1:e3883f5: 	 * 'parentActivation' is set when this activation is created (@see
1:0c5bc3a:      * PreparedStatement#getActivation) based on the top of the
1:6950a39: 	 * dynamic call stack of execution, which is tracked by
1:6950a39: 	 * StatementContext. The nested SQL session context is initialized
1:e3883f5: 	 * by code generated for the call, after parameters are evaluated
1:0c5bc3a:      * or just sub-statement execution starts.
1:0c5bc3a:      * @see org.apache.derby.impl.sql.compile.StaticMethodCallNode#generatePushNestedSessionContext
1:0c5bc3a:      * @see PreparedStatement#executeSubStatement
1:6950a39: 	 *
1:6950a39: 	 */
1:e3883f5: 	private Activation parentActivation;
1:6950a39: 
1:6950a39: 	/**
1:e3883f5: 	 * The SQL session context to be used inside a nested connection in a
1:e3883f5: 	 * stored routine or in a substatement. In the latter case, it is an alias
1:e3883f5: 	 * to the superstatement's session context.
1:6950a39: 	 */
1:e3883f5: 	private SQLSessionContext sqlSessionContextForChildren;
1:6950a39: 
1:508a010:     /**
1:508a010:      * Stack of ConstantActions.
1:508a010:      */
1:508a010:     private Stack<ConstantAction>   constantActionStack = new Stack<ConstantAction>();
1:508a010: 
1:eac0369: 	//Following is the position of the session table names list in savedObjects in compiler context
1:eac0369: 	//This is updated to be the correct value at cursor generate time if the cursor references any session table names.
1:eac0369: 	//If the cursor does not reference any session table names, this will stay negative
1:eac0369: 	protected int indexOfSessionTableNamesInSavedObjects = -1;
1:eac0369: 
1:eac0369: 	// WARNING: these fields are accessed by code generated in the 
1:eac0369: 	// ExpressionClassBuilder: don't change them unless you 
1:eac0369: 	// make the appropriate changes there.
1:eac0369: 	protected ExecRow[] row;
1:eac0369: 	protected ParameterValueSet pvs;
1:eac0369: 
1:99d7d8b: 	//
1:eac0369: 	// constructors
1:99d7d8b: 	//
1:99d7d8b: 
1:eac0369: 	protected BaseActivation()
1:eac0369: 	{
1:eac0369: 		super();
27:eac0369: 	}
1:0393775: 
1:68c8e7d: 	public final void initFromContext(Context context) 
1:68c8e7d: 		throws StandardException {
1:0393775: 
4:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(context!=null, "NULL context passed to BaseActivation.initFromContext");
1:0393775: 		}
1:eac0369: 		this.cm = context.getContextManager();
1:0393775: 
1:eac0369: 		lcc = (LanguageConnectionContext) cm.getContext(LanguageConnectionContext.CONTEXT_ID);
1:99d7d8b: 
1:e3883f5: 		if (SanityManager.DEBUG) {
1:eac0369: 			if (lcc == null)
1:eac0369: 				SanityManager.THROWASSERT("lcc is null in activation type " + getClass());
1:0393775: 		}
1:99d7d8b: 
1:eac0369: 		// mark in use
1:eac0369: 		inUse = true;
1:99d7d8b: 		
1:eac0369: 		// add this activation to the pool for the connection.
1:eac0369: 		lcc.addActivation(this);
1:e4caed2: 
1:e4caed2: 		isValid = true;
1:e4caed2: 
1:e4caed2: 		/* Get the UUID for this activation */
1:e4caed2: 		UUIDFactory uuidFactory =
1:56c1dc2: 			getMonitor().getUUIDFactory();
1:e4caed2: 
1:e4caed2: 		UUIDValue = uuidFactory.createUUID();
1:e4caed2: 		UUIDString = UUIDValue.toString();
1:99d7d8b: 	}
1:99d7d8b: 
1:99d7d8b: 
1:99d7d8b: 	//
1:eac0369: 	// Activation interface
1:99d7d8b: 	//
1:eac0369: 
1:edb7fcc:     public final ResultSet execute() throws StandardException {
1:edb7fcc:         throwIfClosed("execute");
1:edb7fcc: 
1:edb7fcc:         // Determine if we should check row counts during this execution.
1:edb7fcc:         checkRowCounts = shouldWeCheckRowCounts();
1:edb7fcc: 
1:edb7fcc:         // If we are to check row counts, clear the hash table of row counts
1:edb7fcc:         // we have checked.
1:edb7fcc:         if (checkRowCounts) {
1:edb7fcc:             rowCountsCheckedThisExecution.clear();
1:edb7fcc:         }
1:edb7fcc: 
1:d11ed08:         // Reinitialize data structures in the generated class before
1:d11ed08:         // each execution.
1:d11ed08:         reinit();
1:d11ed08: 
1:d11ed08:         // Create the result set tree on the first execution.
1:d11ed08:         if (resultSet == null) {
1:dd9ad07:              resultSet = decorateResultSet();
1:d11ed08:         }
1:d11ed08: 
1:d11ed08:         return resultSet;
1:d11ed08:     }
1:edb7fcc: 
1:edb7fcc:     /**
1:dd9ad07:      * Create the ResultSet tree for this statement, and possibly perform
1:dd9ad07:      * extra checks or initialization required by specific sub-classes.
1:dd9ad07:      * @return the root of the ResultSet tree for this statement
1:dd9ad07:      */
1:dd9ad07:     ResultSet decorateResultSet() throws StandardException {
1:dd9ad07:         return createResultSet();
1:dd9ad07:     }
1:dd9ad07: 
1:dd9ad07:     /**
1:d11ed08:      * Create the ResultSet tree for this statement.
1:d11ed08:      * @return the root of the ResultSet tree for this statement
1:0c5bc3a:      * @throws StandardException standard error policy
1:edb7fcc:      */
1:d11ed08:     protected abstract ResultSet createResultSet() throws StandardException;
1:d11ed08: 
1:d11ed08:     /**
1:d11ed08:      * Reinitialize data structures added by the sub-classes before each
1:d11ed08:      * execution of the statement. The default implementation does nothing.
1:d11ed08:      * Sub-classes should override this method if they need to perform
1:d11ed08:      * operations before each execution.
1:0c5bc3a:      * @throws org.apache.derby.iapi.error.StandardException
1:d11ed08:      */
1:d11ed08:     protected void reinit() throws StandardException {
1:d11ed08:         // Do nothing by default. Overridden by sub-classes that need it.
1:d11ed08:     }
1:edb7fcc: 
1:eac0369: 	public final ExecPreparedStatement getPreparedStatement() {
1:eac0369: 		return preStmt;
1:edb7fcc: 	}
1:eac0369: 
1:508a010:     public  ConstantAction    pushConstantAction( ConstantAction newConstantAction )
1:508a010:     {
1:508a010:         return constantActionStack.push( newConstantAction );
1:508a010:     }
1:508a010: 
1:508a010:     public  ConstantAction    popConstantAction()
1:508a010:     {
1:508a010:         return constantActionStack.pop();
1:508a010:     }
1:508a010: 
1:508a010: 	public ConstantAction getConstantAction()
1:508a010:     {
1:508a010:         if ( constantActionStack.size() > 0 )
1:508a010:         {
1:508a010:             return constantActionStack.peek();
1:508a010:         }
1:508a010:         else { return preStmt.getConstantAction(); }
1:99d7d8b: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public final void checkStatementValidity() throws StandardException {
1:eac0369: 
1:6832893: 		if (preStmt == null || preStmt.upToDate(gc))
2:eac0369: 			return;
1:eac0369: 
1:eac0369: 		StandardException se = StandardException.newException(SQLState.LANG_STATEMENT_NEEDS_RECOMPILE);
1:eac0369: 		se.setReport(StandardException.REPORT_NEVER);
1:eac0369: 		throw se;
1:99d7d8b: 	}
1:eac0369: 
1:0393775: 	/**
1:0c5bc3a:      * Link this activation with its PreparedStatement.
1:0c5bc3a:      * It can be called with null to break the link with the
1:0c5bc3a:      * PreparedStatement.
1:0c5bc3a:      * @param ps prepared statement
1:0c5bc3a:      * @param scrollable activation for a scrollable result set
1:0c5bc3a:      * @throws StandardException standard error policy
1:0393775:      */
1:dbfbecb: 	public final void setupActivation(ExecPreparedStatement ps, boolean scrollable) 
1:dbfbecb: 	throws StandardException {
1:eac0369: 		preStmt = ps;
1:7736829: 				
1:eac0369: 		if (ps != null) {
1:eac0369: 			// get the result set description
1:eac0369:    			resultDescription = ps.getResultDescription();
1:eac0369: 			this.scrollable = scrollable;
1:7736829: 			
1:7736829: 			// Initialize the parameter set to have allocated
1:7736829: 			// DataValueDescriptor objects for each parameter.
1:7736829: 			if (pvs != null && pvs.getParameterCount() != 0)
1:7736829: 				pvs.initialize(ps.getParameterTypes());
1:7736829: 
1:eac0369: 		} else {
1:eac0369: 			resultDescription = null;
1:eac0369: 			this.scrollable = false;
1:99d7d8b: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public ResultSet getResultSet() {
1:eac0369: 		return resultSet;
1:eac0369: 	}
1:eac0369: 
1:0393775: 	/**
1:eac0369: 		Get the saved RowLocation.
1:eac0369: 
1:eac0369: 		@param itemNumber	The saved item number.
1:eac0369: 
1:eac0369: 		@return	A RowLocation template for the conglomerate
1:0393775: 	 */
1:eac0369: 	public RowLocation getRowLocationTemplate(int itemNumber)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(itemNumber >= 0,
1:eac0369: 				"itemNumber expected to be >= 0");
1:eac0369: 			if (! (getPreparedStatement().getSavedObject(itemNumber) instanceof RowLocation))
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"getPreparedStatement().getSavedObject(itemNumber) expected to be " +
2:eac0369: 					"instance of RowLocation, not " +
1:eac0369: 					getPreparedStatement().getSavedObject(itemNumber).getClass().getName() +
2:eac0369: 					", query is " + getPreparedStatement().getSource());
1:a8bc217: 			}
1:eac0369:         }
1:a8bc217:         RowLocation rl = (RowLocation)
1:a8bc217:                 getPreparedStatement().getSavedObject(itemNumber);
1:a8bc217:         /* We have to return a clone of the saved RowLocation due
1:a8bc217:          * to the shared cache of SPSs.
1:0393775:          */
1:854dd10:         Object rlClone = rl.cloneValue(false);
1:a8bc217:         if (SanityManager.DEBUG) {
1:a8bc217:             if (! (rlClone instanceof RowLocation))
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:a8bc217:                     "rl.getClone() expected to be " +
1:a8bc217:                     "instance of RowLocation, not " +
1:a8bc217:                     rlClone.getClass().getName() + ", query is " +
1:a8bc217:                     getPreparedStatement().getSource());
1:eac0369: 			}
1:eac0369: 		}
1:a8bc217:         return (RowLocation)rlClone;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:0c5bc3a: 	 */
1:eac0369: 	public ResultDescription getResultDescription() {
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 	    	SanityManager.ASSERT(resultDescription != null, "Must have a result description");
1:eac0369: 	   	    return resultDescription;
1:eac0369: 	}
1:eac0369: 
1:0393775: 	/**
1:eac0369: 		This is a partial implementation of reset.
1:eac0369: 		Subclasses will want to reset information
1:eac0369: 		they are aware of, such as parameters.
1:eac0369: 		<p>
1:eac0369: 		All subclasses must call super.reset() and
1:eac0369: 		then do their cleanup.
1:eac0369: 		<p>
1:eac0369: 		The execute call must set the resultSet field
1:eac0369: 		to be the resultSet that it has returned.
1:eac0369: 
1:eac0369: 		@exception StandardException on error
1:99d7d8b: 	 */
1:eac0369: 	public void reset() throws StandardException
1:eac0369: 	{
1:cbc650d: 		if (resultSet != null) 
1:cbc650d: 			resultSet.close();
1:cbc650d: 		
1:eac0369: 		updateHeapCC = null;
1:eac0369: 		// REMIND: do we need to get them to stop input as well?
1:eac0369: 
1:eac0369: 		if (!isSingleExecution())
1:eac0369: 			clearWarnings();
1:eac0369: 	}
1:eac0369: 
1:99d7d8b: 	/**
1:eac0369: 		Closing an activation marks it as unusable. Any other
1:eac0369: 		requests made on it will fail.  An activation should be
1:eac0369: 		marked closed when it is expected to not be used any longer,
1:eac0369: 		i.e. when the connection for it is closed, or it has suffered some
1:eac0369: 		sort of severe error.
1:eac0369: 
1:eac0369: 		This should also remove it from the language connection context.
1:eac0369: 
1:eac0369: 		@exception StandardException on error
1:99d7d8b: 	 */
1:eac0369: 	public final void close() throws StandardException 
1:eac0369: 	{
1:eac0369: 		if (! closed) {	
1:eac0369: 			
1:eac0369: 			// markUnused();
1:eac0369: 
1:eac0369: 			// we call reset so that if the actual type of "this"
1:eac0369: 			// is a subclass of BaseActivation, its cleanup will
1:eac0369: 			// also happen -- reset in the actual type is called,
1:eac0369: 			// not reset in BaseActivation.  Subclass reset's
1:eac0369: 			// are supposed to call super.reset() as well.
1:eac0369: 			reset(); // get everything related to executing released
1:eac0369: 
1:fbf1381: 			if (resultSet != null)
1:fbf1381: 			{
1:fbf1381: 				// Finish the resultSet, it will never be used again.
1:fbf1381: 				resultSet.finish();
1:fbf1381: 				resultSet = null;
1:fbf1381: 			}
1:fbf1381: 
1:eac0369: 			closed = true;
1:eac0369: 
1:f7ce263:             // Remove all the dependencies this activation has. It won't need
1:f7ce263:             // them after it's closed, so let's free up the memory in the
1:f7ce263:             // dependency manager. (DERBY-4571)
1:f7ce263:             DependencyManager dm =
1:f7ce263:                     lcc.getDataDictionary().getDependencyManager();
1:f7ce263:             dm.clearDependencies(lcc, this);
1:f7ce263: 
1:eac0369: 			lcc.removeActivation(this);
1:eac0369: 			if (preStmt != null) {
1:eac0369: 				preStmt.finish(lcc);
1:eac0369: 				preStmt = null;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			try {
1:eac0369: 				closeActivationAction();
1:eac0369: 			} catch (Throwable e) {
1:eac0369: 				throw StandardException.plainWrapException(e);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 	}
1:eac0369: 
1:99d7d8b: 	/**
1:0c5bc3a:      * A generated class can create its own closeActivationAction
1:0c5bc3a:      * method to invoke special logic when the activation is closed.
1:0c5bc3a:      * @throws java.lang.Exception error
1:0c5bc3a:      */
1:eac0369: 	protected void closeActivationAction() throws Exception {
1:eac0369: 		// no code to be added here as generated code
1:eac0369: 		// will not call super.closeActivationAction()
1:eac0369: 	}
1:eac0369: 
1:99d7d8b: 	/**
1:eac0369: 		Find out if the activation closed or not.
1:eac0369: 		@return true if the prepared statement has been closed.
1:99d7d8b: 	 */
1:eac0369: 	public boolean isClosed() {
1:eac0369: 		return closed;
1:eac0369: 	}
1:eac0369: 
1:99d7d8b: 	/**
1:eac0369: 		Set this Activation for a single execution.
1:eac0369: 
1:eac0369: 		@see Activation#setSingleExecution
1:99d7d8b: 	*/
1:eac0369: 	public void setSingleExecution() {
1:eac0369: 		singleExecution = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Returns true if this Activation is only going to be used for
1:eac0369: 		one execution.
1:eac0369: 
1:eac0369: 		@see Activation#isSingleExecution
1:a8bc217: 	*/
1:eac0369: 	public boolean isSingleExecution() {
1:eac0369: 		return singleExecution;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the number of subqueries in the entire query.
1:eac0369: 		@return int	 The number of subqueries in the entire query.
1:eac0369: 	 */
1:eac0369: 	public int getNumSubqueries() {
1:eac0369: 		return numSubqueries;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#isCursorActivation
1:eac0369: 	 */
1:eac0369: 	public boolean isCursorActivation()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
5:eac0369: 	//
1:eac0369: 	// GeneratedByteCode interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	public final void setGC(GeneratedClass gc) {
1:eac0369: 		this.gc = gc;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final GeneratedClass getGC() {
1:eac0369: 
2:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			if (gc == null)
1:eac0369: 				SanityManager.THROWASSERT("move code requiring GC to postConstructor() method!!");
1:eac0369: 		}
1:eac0369: 		return gc;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final GeneratedMethod getMethod(String methodName) throws StandardException {
1:eac0369: 
1:eac0369: 		return getGC().getMethod(methodName);
1:eac0369: 	}
1:eac0369: 	public Object e0() throws StandardException { return null; } 
1:eac0369: 	public Object e1() throws StandardException { return null; }
1:eac0369: 	public Object e2() throws StandardException { return null; }
1:eac0369: 	public Object e3() throws StandardException { return null; }
1:eac0369: 	public Object e4() throws StandardException { return null; } 
1:eac0369: 	public Object e5() throws StandardException { return null; }
1:eac0369: 	public Object e6() throws StandardException { return null; }
1:eac0369: 	public Object e7() throws StandardException { return null; }
1:eac0369: 	public Object e8() throws StandardException { return null; } 
1:eac0369: 	public Object e9() throws StandardException { return null; }
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// class interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Temporary tables can be declared with ON COMMIT DELETE ROWS. But if the table has a held curosr open at
1:eac0369: 	 * commit time, data should not be deleted from the table. This method, (gets called at commit time) checks if this
1:eac0369: 	 * activation held cursor and if so, does that cursor reference the passed temp table name.
1:0393775: 	 *
1:eac0369: 	 * @return	true if this activation has held cursor and if it references the passed temp table name
1:eac0369: 	 */
1:eac0369: 	public boolean checkIfThisActivationHasHoldCursor(String tableName)
1:eac0369: 	{
1:eac0369: 		if (!inUse)
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		if (resultSetHoldability == false) //if this activation is not held over commit, do not need to worry about it
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		if (indexOfSessionTableNamesInSavedObjects == -1) //if this activation does not refer to session schema tables, do not need to worry about it
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		/* is there an open result set? */
1:eac0369: 		if ((resultSet != null) && !resultSet.isClosed() && resultSet.returnsRows())
1:eac0369: 		{
1:eac0369: 			//If we came here, it means this activation is held over commit and it reference session table names
1:eac0369: 			//Now let's check if it referneces the passed temporary table name which has ON COMMIT DELETE ROWS defined on it.
1:eac0369: 			return ((ArrayList)getPreparedStatement().getSavedObject(indexOfSessionTableNamesInSavedObjects)).contains(tableName);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	   remember the cursor name
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public void	setCursorName(String cursorName)
1:eac0369: 	{
1:eac0369: 		if (isCursorActivation())
1:eac0369: 			this.cursorName = cursorName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  get the cursor name.  For something that isn't
1:eac0369: 	  a cursor, this is used as a string name of the
1:eac0369: 	  result set for messages from things like the
1:eac0369: 	  dependency manager.
1:eac0369: 	  <p>
1:eac0369: 	  Activations that do support cursors will override
1:eac0369: 	  this.	
1:eac0369: 	*/
1:eac0369: 	public String getCursorName() {
1:eac0369: 
1:eac0369: 		return isCursorActivation() ? cursorName : null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setResultSetHoldability(boolean resultSetHoldability)
1:eac0369: 	{
1:eac0369: 		this.resultSetHoldability = resultSetHoldability;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public boolean getResultSetHoldability()
1:eac0369: 	{
1:eac0369: 		return resultSetHoldability;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Activation#setAutoGeneratedKeysResultsetInfo */
1:eac0369: 	public void setAutoGeneratedKeysResultsetInfo(int[] columnIndexes, String[] columnNames)
1:eac0369: 	{
1:eac0369: 		autoGeneratedKeysResultSetMode = true;
1:706f2eb: 		autoGeneratedKeysColumnIndexes = ArrayUtil.copy( columnIndexes );
1:706f2eb: 		autoGeneratedKeysColumnNames = ArrayUtil.copy( columnNames );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Activation#getAutoGeneratedKeysResultsetMode */
1:eac0369: 	public boolean getAutoGeneratedKeysResultsetMode()
1:eac0369: 	{
1:eac0369: 		return autoGeneratedKeysResultSetMode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Activation#getAutoGeneratedKeysColumnIndexes */
1:eac0369: 	public int[] getAutoGeneratedKeysColumnIndexes()
1:eac0369: 	{
1:706f2eb: 		return ArrayUtil.copy( autoGeneratedKeysColumnIndexes );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Activation#getAutoGeneratedKeysColumnNames */
1:eac0369: 	public String[] getAutoGeneratedKeysColumnNames()
1:eac0369: 	{
1:706f2eb: 		return ArrayUtil.copy( autoGeneratedKeysColumnNames );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// class implementation
1:eac0369: 	//
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Used in the execute method of activations for
1:eac0369: 		generating the result sets that they concatenate together.
1:eac0369: 	 */
1:6c000e8: 	public final ResultSetFactory getResultSetFactory() {
1:6c000e8: 		return getExecutionFactory().getResultSetFactory();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Used in activations for generating rows.
1:eac0369: 	 */
1:6c000e8: 	public final ExecutionFactory getExecutionFactory() {
1:6c000e8: 		return getLanguageConnectionContext().
1:6c000e8:             getLanguageConnectionFactory().getExecutionFactory();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Used in CurrentOfResultSet to get to the target result set
1:eac0369: 		for a cursor. Overridden by activations generated for
1:eac0369: 		updatable cursors.  Those activations capture the target
1:eac0369: 		result set in a field in their execute() method, and then
1:eac0369: 		return the value of that field in their version of this method.
1:eac0369: 
1:eac0369: 		@return null.
1:eac0369: 	 */
1:eac0369: 	public CursorResultSet getTargetResultSet() {
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.THROWASSERT("Must be overridden to be used.");
2:eac0369: 		return null;
1:eac0369: 	}
1:e4caed2: 
1:3334bff: 	/**
1:eac0369: 	 * Called by generated code to compute the next autoincrement value.
1:6950a39: 	 * 
1:eac0369: 	 * @return The next autoincrement value which should be inserted.
1:eac0369: 	 * returns the correct number datatype.
1:eac0369: 	 */
1:eac0369: 	protected DataValueDescriptor 
1:eac0369: 		getSetAutoincrementValue(int columnPosition, long increment)
1:92268ac: 	       throws StandardException
1:eac0369: 	{
1:eac0369: 		DataValueDescriptor l =
1:a826375: 			((DMLWriteGeneratedColumnsResultSet)resultSet).getSetAutoincrementValue(columnPosition, increment);
1:eac0369: 		return l;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:bb4cfe9: 	 * Called by generated code to get the next number in an ANSI/ISO sequence
1:bb4cfe9:      * and advance the sequence. Raises an exception if the sequence was declared
1:139ca85:      * NO CYCLE and its range is exhausted.
1:139ca85: 	 *
1:bb4cfe9:      * @param sequenceUUIDstring The string value of the sequence's UUID
1:139ca85:      * @param typeFormatID The format id of the data type to be returned. E.g., StoredFormatIds.SQL_INTEGER_ID.
1:139ca85:      *
1:139ca85: 	 * @return The next number in the sequence
1:139ca85: 	 */
1:a180287: 	public NumberDataValue getCurrentValueAndAdvance
1:bb4cfe9:         ( String sequenceUUIDstring, int typeFormatID )
1:139ca85: 	       throws StandardException
1:139ca85: 	{
1:139ca85:         NumberDataValue ndv = (NumberDataValue) getDataValueFactory().getNull( typeFormatID, StringDataValue.COLLATION_TYPE_UCS_BASIC );
1:139ca85: 
1:bb4cfe9:         lcc.getDataDictionary().getCurrentValueAndAdvance( sequenceUUIDstring, ndv );
1:139ca85: 
1:139ca85:         return ndv;
1:139ca85: 	}
1:139ca85: 
1:139ca85: 	/**
1:eac0369: 		Used in CurrentOfResultSet to get to the cursor result set
1:eac0369: 		for a cursor.  Overridden by activations generated for
1:eac0369: 		updatable cursors.  Those activations capture the cursor
1:eac0369: 		result set in a field in their execute() method, and then
1:eac0369: 		return the value of that field in their version of this method.
1:eac0369: 
1:eac0369: 		@return null
1:eac0369: 	 */
1:eac0369: 	public CursorResultSet getCursorResultSet() {
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.THROWASSERT("Must be overridden to be used.");
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Various activation methods need to disallow their
1:eac0369: 		invocation if the activation is closed. This lets them
1:eac0369: 		check and throw without generating alot of code.
1:eac0369: 		<p>
1:eac0369: 		The code to write to generate the call to this is approximately:
1:eac0369: 		<verbatim>
1:eac0369: 			// jf is a JavaFactory
1:eac0369: 			CallableExpression ce = jf.newMethodCall(
1:eac0369: 				jf.thisExpression(),
1:eac0369: 				BaseActivation.CLASS_NAME,
1:eac0369: 				"throwIfClosed",
1:eac0369: 				"void",
1:eac0369: 				acb.exprArray(jf.newStringLiteral(...some literal here...)));
1:eac0369: 
1:eac0369: 			//mb is a MethodBuilder
1:eac0369: 			mb.addStatement(jf.newStatement(ce));
1:eac0369: 		</verbatim>
1:eac0369: 		The java code to write to call this is:
1:eac0369: 		<verbatim>
1:eac0369: 			this.throwIfClosed(...some literal here...);
1:eac0369: 		</verbatim>
1:eac0369: 		In both cases, "...some literal here..." gets replaced with
1:eac0369: 		an expression of type String that evaluates to the name
1:eac0369: 		of the operation that is being checked, like "execute" or
1:eac0369: 		"reset".
1:eac0369: 
1:eac0369: 		@exception StandardException thrown if closed
1:eac0369: 	 */
1:eac0369: 	public void throwIfClosed(String op) throws StandardException {
1:eac0369: 		if (closed)
1:eac0369: 			throw StandardException.newException(SQLState.LANG_ACTIVATION_CLOSED, op);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set a column position in an array of column positions.
1:99d7d8b: 	 *
1:eac0369: 	 * @param columnPositions	The array of column positions
1:eac0369: 	 * @param positionToSet		The place to put the column position
1:eac0369: 	 * @param column			The column position
1:eac0369: 	 */
1:eac0369: 	public static void setColumnPosition(
1:eac0369: 							int[] columnPositions,
1:eac0369: 							int positionToSet,
1:eac0369: 							int column)
1:eac0369: 	{
1:eac0369: 		columnPositions[positionToSet] = column;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Allocate an array of qualifiers and initialize in Qualifier[][]
1:99d7d8b: 	 *
1:eac0369: 	 * @param qualifiers	The array of Qualifier arrays.
1:eac0369: 	 * @param position		The position in the array to set
1:eac0369: 	 * @param length		The array length of the qualifier array to allocate.
1:eac0369: 	 */
1:eac0369: 	public static void allocateQualArray(
1:eac0369:     Qualifier[][]   qualifiers,
1:eac0369:     int             position,
1:eac0369:     int             length)
1:eac0369: 	{
1:eac0369:         qualifiers[position] = new Qualifier[length];
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set a Qualifier in a 2 dimensional array of Qualifiers.
1:99d7d8b:      *
1:eac0369:      * Set a single Qualifier into one slot of a 2 dimensional array of 
1:eac0369:      * Qualifiers.  @see Qualifier for detailed description of layout of
1:eac0369:      * the 2-d array.
1:99d7d8b: 	 *
1:eac0369: 	 * @param qualifiers	The array of Qualifiers
1:eac0369: 	 * @param qualifier		The Qualifier
2:eac0369: 	 * @param position_1    The Nth array index into qualifiers[N][M]
1:6b50965: 	 * @param position_2    The Nth array index into qualifiers[N][M]
1:eac0369: 	 */
1:eac0369: 	public static void setQualifier(
1:eac0369:     Qualifier[][]   qualifiers,
1:eac0369:     Qualifier	    qualifier,
1:eac0369:     int			    position_1,
1:eac0369:     int             position_2)
1:eac0369: 	{
1:eac0369: 		qualifiers[position_1][position_2] = qualifier;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Reinitialize all Qualifiers in an array of Qualifiers.
6:eac0369: 	 *
1:eac0369: 	 * @param qualifiers	The array of Qualifiers
1:eac0369: 	 */
1:eac0369: 	public static void reinitializeQualifiers(Qualifier[][] qualifiers)
1:eac0369: 	{
1:eac0369: 		if (qualifiers != null)
1:eac0369: 		{
1:eac0369:             for (int term = 0; term < qualifiers.length; term++)
1:eac0369:             {
1:eac0369:                 for (int i = 0; i < qualifiers[term].length; i++)
1:eac0369:                 {
1:eac0369:                     qualifiers[term][i].reinitialize();
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark the activation as unused.  
1:eac0369: 	 */
1:eac0369: 	public final void markUnused()
1:eac0369: 	{
1:68c8e7d: 		if(isInUse()) {
1:68c8e7d: 			inUse = false;
1:68c8e7d: 			lcc.notifyUnusedActivation();
1:68c8e7d: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is the activation in use?
1:eac0369: 	 *
1:eac0369: 	 * @return true/false
1:eac0369: 	 */
1:eac0369: 	public final boolean isInUse()
1:eac0369: 	{
1:eac0369: 		return inUse;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see org.apache.derby.iapi.sql.Activation#addWarning
1:eac0369: 	  */
1:eac0369: 	public void addWarning(SQLWarning w)
1:eac0369: 	{
1:eac0369: 		if (warnings == null)
1:eac0369: 			warnings = w;
4:eac0369: 		else
1:eac0369: 			warnings.setNextWarning(w);
1:0393775: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see org.apache.derby.iapi.sql.Activation#getWarnings
1:eac0369: 	  */
1:eac0369: 	public SQLWarning getWarnings()
1:eac0369: 	{
1:eac0369: 		return warnings;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see org.apache.derby.iapi.sql.Activation#clearWarnings
1:eac0369: 	  */
1:eac0369: 	public void clearWarnings()
1:eac0369: 	{
1:eac0369: 		warnings = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	protected static void nullToPrimitiveTest(DataValueDescriptor dvd, String primitiveType)
2:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (dvd.isNull())
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_NULL_TO_PRIMITIVE_PARAMETER, primitiveType);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see Activation#informOfRowCount
1:eac0369: 		@exception StandardException	Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void informOfRowCount(NoPutResultSet resultSet, long currentRowCount)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		/* Do we want to check the row counts during this execution? */
2:eac0369: 		if (checkRowCounts)
1:eac0369: 		{
1:eac0369: 			boolean significantChange = false;
1:eac0369: 
1:eac0369: 			int resultSetNumber = resultSet.resultSetNumber();
1:eac0369: 
1:eac0369: 			/* Check each result set only once per execution */
1:bb5be6f: 			if (rowCountsCheckedThisExecution.add(resultSetNumber))
1:eac0369: 			{
1:f542632:                 long n1 = getPreparedStatement()
1:f542632:                         .getInitialRowCount(resultSetNumber, currentRowCount);
1:eac0369: 
1:f542632:                 /*
1:f542632:                 ** Has the row count changed significantly?
1:f542632:                 */
1:f542632:                 if (currentRowCount != n1)
1:f542632:                 {
1:f542632:                     if (n1 >= TEN_PERCENT_THRESHOLD)
1:f542632:                     {
1:f542632:                         /*
1:f542632:                         ** For tables with more than
1:f542632:                         ** TEN_PERCENT_THRESHOLD rows, the
1:f542632:                         ** threshold is 10% of the size of the table.
1:f542632:                         */
1:f542632:                         long changeFactor = n1 / (currentRowCount - n1);
1:f542632:                         if (Math.abs(changeFactor) <= 10) {
1:f542632:                             significantChange = true;
1:f542632:                         }
1:eac0369:                     }
1:f542632:                     else
1:f542632:                     {
1:f542632:                         /*
1:f542632:                         ** For tables with less than
1:f542632:                         ** TEN_PERCENT_THRESHOLD rows, the threshold
1:f542632:                         ** is non-linear.  This is because we want
1:f542632:                         ** recompilation to happen sooner for small
1:f542632:                         ** tables that change size.  This formula
1:f542632:                         ** is for a second-order equation (a parabola).
1:f542632:                         ** The derivation is:
1:f542632:                         **
1:f542632:                         **   c * n1 = (difference in row counts) ** 2
1:f542632:                         **				- or -
1:f542632:                         **   c * n1 = (currentRowCount - n1) ** 2
1:f542632:                         **
1:f542632:                         ** Solving this for currentRowCount, we get:
1:f542632:                         **
1:f542632:                         **   currentRowCount = n1 + sqrt(c * n1)
1:f542632:                         **
1:f542632:                         **				- or -
1:f542632:                         **
1:f542632:                         **   difference in row counts = sqrt(c * n1)
1:f542632:                         **
1:f542632:                         **				- or -
1:f542632:                         **
1:f542632:                         **   (difference in row counts) ** 2 =
1:f542632:                         **					c * n1
1:f542632:                         **
1:f542632:                         ** Which means that we should recompile when
1:f542632:                         ** the current row count exceeds n1 (the first
1:f542632:                         ** row count) by sqrt(c * n1), or when the
1:f542632:                         ** square of the difference exceeds c * n1.
1:f542632:                         ** A good value for c seems to be 4.
1:f542632:                         **
1:f542632:                         ** We don't use this formula when c is greater
1:f542632:                         ** than TEN_PERCENT_THRESHOLD because we never
1:f542632:                         ** want to recompile unless the number of rows
1:f542632:                         ** changes by more than 10%, and this formula
1:f542632:                         ** is more sensitive than that for values of
1:f542632:                         ** n1 greater than TEN_PERCENT_THRESHOLD.
1:f542632:                         */
1:f542632:                         long changediff = currentRowCount - n1;
1:eac0369: 
1:f542632:                         /*
1:f542632:                         ** Square changediff rather than take the square
1:f542632:                         ** root of (4 * n1), because multiplying is
1:f542632:                         ** faster than taking a square root.  Also,
1:f542632:                         ** check to be sure that squaring changediff
1:f542632:                         ** will not cause an overflow by comparing it
1:f542632:                         ** with the square root of the maximum value
1:f542632:                         ** for a long (this square root is taken only
1:f542632:                         ** once, when the class is loaded, or during
1:f542632:                         ** compilation if the compiler is smart enough).
1:f542632:                         */
1:f542632:                         if (Math.abs(changediff) <= MAX_SQRT)
1:f542632:                         {
1:f542632:                             if ((changediff * changediff) >
1:f542632:                                                     Math.abs(4 * n1))
1:f542632:                             {
1:f542632:                                 significantChange = true;
1:f542632:                             }
1:f542632:                         }
1:f542632:                     }
1:f542632:                 }
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* Invalidate outside of the critical section */
1:eac0369: 			if (significantChange)
1:eac0369: 			{
1:eac0369: 				preStmt.makeInvalid(DependencyManager.INTERNAL_RECOMPILE_REQUEST, lcc);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getHeapConglomerateController
1:eac0369: 	 */
1:eac0369: 	public ConglomerateController getHeapConglomerateController()
1:eac0369: 	{
1:eac0369: 		return updateHeapCC;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#setHeapConglomerateController
1:eac0369: 	 */
1:eac0369: 	public void setHeapConglomerateController(ConglomerateController updateHeapCC)
1:eac0369: 	{
1:eac0369: 		this.updateHeapCC = updateHeapCC;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#clearHeapConglomerateController
1:eac0369: 	 */
1:eac0369: 	public void clearHeapConglomerateController()
1:eac0369: 	{
1:eac0369: 		updateHeapCC = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getIndexScanController
1:eac0369: 	 */
1:eac0369: 	public ScanController getIndexScanController()
1:eac0369: 	{
1:eac0369: 		return indexSC;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#setIndexScanController
1:eac0369: 	 */
1:eac0369: 	public void setIndexScanController(ScanController indexSC)
1:eac0369: 	{
1:eac0369: 		this.indexSC = indexSC;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getIndexConglomerateNumber
1:eac0369: 	 */
1:eac0369: 	public long getIndexConglomerateNumber()
1:eac0369: 	{
1:eac0369: 		return indexConglomerateNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#setIndexConglomerateNumber
1:eac0369: 	 */
1:eac0369: 	public void setIndexConglomerateNumber(long indexConglomerateNumber)
1:eac0369: 	{
1:eac0369: 		this.indexConglomerateNumber = indexConglomerateNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#clearIndexScanInfo
1:eac0369: 	 */
1:eac0369: 	public void clearIndexScanInfo()
1:eac0369: 	{
1:eac0369: 		indexSC = null;
1:eac0369: 		indexConglomerateNumber = -1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#setForCreateTable()
1:eac0369: 	 */
1:eac0369: 	public void setForCreateTable()
1:eac0369: 	{
1:eac0369: 		forCreateTable = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getForCreateTable()
1:eac0369: 	 */
1:eac0369: 	public boolean getForCreateTable()
1:eac0369: 	{
1:eac0369: 		return forCreateTable;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#setDDLTableDescriptor
1:eac0369: 	 */
1:eac0369: 	public void setDDLTableDescriptor(TableDescriptor td)
1:eac0369: 	{
1:eac0369: 		ddlTableDescriptor = td;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getDDLTableDescriptor
1:eac0369: 	 */
1:eac0369: 	public TableDescriptor getDDLTableDescriptor()
1:eac0369: 	{
1:eac0369: 		return ddlTableDescriptor;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#setMaxRows
1:eac0369: 	 */
1:47a8183: 	public void setMaxRows(long maxRows)
1:eac0369: 	{
1:eac0369: 		this.maxRows = maxRows;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Activation#getMaxRows
1:eac0369: 	 */
1:47a8183: 	public long getMaxRows()
1:eac0369: 	{
1:eac0369: 		return maxRows;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setTargetVTI(java.sql.ResultSet targetVTI)
1:eac0369: 	{
1:eac0369: 		this.targetVTI = targetVTI;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public java.sql.ResultSet getTargetVTI()
1:eac0369: 	{
1:eac0369: 		return targetVTI;
1:eac0369: 	}
1:eac0369: 
1:0393775:     /**
1:0393775:      * Find out if it's time to check the row counts of the tables involved
1:0393775:      * in this query.
1:0393775:      * @return true if the row counts should be checked, false otherwise
1:0393775:      */
1:0393775: 	protected boolean shouldWeCheckRowCounts() throws StandardException
1:eac0369: 	{
1:f542632:         final ExecPreparedStatement ps = getPreparedStatement();
1:0393775: 
1:eac0369: 		/*
1:eac0369: 		** Check the row count only every N executions.  OK to check this
1:eac0369: 		** without synchronization, since the value of this number is not
1:eac0369: 		** critical.  The value of N is determined by the property
1:eac0369: 		** derby.language.stalePlanCheckInterval.
1:eac0369: 		*/
1:f542632:         int executionCount = ps.incrementExecutionCount();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Always check row counts the first time, to establish the
1:eac0369: 		** row counts for each result set.  After that, don't check
1:eac0369: 		** if the execution count is below the minimum row count check
1:eac0369: 		** interval.  This saves us from checking a database property
1:eac0369: 		** when we don't have to (checking involves querying the store,
1:eac0369: 		** which can be expensive).
1:eac0369: 		*/
1:eac0369: 
1:eac0369: 		if (executionCount == 1)
1:eac0369: 		{
1:0393775:             return true;
1:eac0369: 		}
1:eac0369: 		else if (executionCount <
1:eac0369: 								Property.MIN_LANGUAGE_STALE_PLAN_CHECK_INTERVAL)
1:eac0369: 		{
1:0393775:             return false;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:f542632:             int stalePlanCheckInterval = ps.getStalePlanCheckInterval();
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Only query the database property once.  We can tell because
1:eac0369: 			** the minimum value of the property is greater than zero.
1:eac0369: 			*/
1:eac0369: 			if (stalePlanCheckInterval == 0)
1:eac0369: 			{
1:eac0369: 				TransactionController tc = getTransactionController();
1:eac0369: 
1:eac0369: 				stalePlanCheckInterval =
1:eac0369: 						PropertyUtil.getServiceInt(
1:eac0369: 							tc,
1:eac0369: 							Property.LANGUAGE_STALE_PLAN_CHECK_INTERVAL,
1:eac0369: 							Property.MIN_LANGUAGE_STALE_PLAN_CHECK_INTERVAL,
1:eac0369: 							Integer.MAX_VALUE,
1:eac0369: 							Property.DEFAULT_LANGUAGE_STALE_PLAN_CHECK_INTERVAL
2:eac0369: 							);
1:f542632: 
1:f542632:                 ps.setStalePlanCheckInterval(stalePlanCheckInterval);
1:eac0369: 			}
1:eac0369: 
1:0393775:             return (executionCount % stalePlanCheckInterval) == 1;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final boolean getScrollable() {
1:eac0369: 		return scrollable;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected final void setParameterValueSet(int paramCount, boolean hasReturnParam) {
1:eac0369: 
1:eac0369: 		pvs = lcc.getLanguageFactory().newParameterValueSet(
1:eac0369: 			lcc.getLanguageConnectionFactory().getClassFactory().getClassInspector(),
1:eac0369: 			paramCount, hasReturnParam);
1:7736829: 		}
1:eac0369: 	
1:eac0369: 	/**
1:7ab414c: 	 * This method can help reduce the amount of generated code by changing
1:7ab414c: 	 * instances of this.pvs.getParameter(position) to this.getParameter(position) 
1:7ab414c: 	 * @param position
1:7ab414c: 	 * @throws StandardException
1:eac0369: 	 */
1:7ab414c: 	protected final DataValueDescriptor getParameter(int position) throws StandardException { 
1:7ab414c: 		return pvs.getParameter(position); 
1:eac0369: 		} 
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 return the parameters.
1:eac0369: 	 */
1:eac0369: 	public ParameterValueSet	getParameterValueSet() 
1:eac0369: 	{ 
1:eac0369: 		if (pvs == null)
1:eac0369: 			setParameterValueSet(0, false); 
1:eac0369: 		return pvs; 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// how do we do/do we want any sanity checking for
1:eac0369: 	// the number of parameters expected?
1:eac0369: 	public void	setParameters(ParameterValueSet parameterValues, DataTypeDescriptor[] parameterTypes) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (!isClosed())
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			if (this.pvs == null || parameterTypes == null) {
1:eac0369: 				pvs = parameterValues;
1:eac0369: 				return;
1:eac0369: 
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			DataTypeDescriptor[]	newParamTypes = preStmt.getParameterTypes();
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** If there are old parameters but not new ones,
1:eac0369: 			** they aren't compatible.
1:eac0369: 			*/
1:eac0369: 			boolean match = false;
1:eac0369: 			if (newParamTypes != null) {
1:eac0369: 
1:eac0369: 				if (newParamTypes.length == parameterTypes.length) {
1:eac0369: 
1:eac0369: 					/* Check each parameter */
1:eac0369: 					match = true;
1:eac0369: 					for (int i = 0; i < parameterTypes.length; i++)
1:eac0369: 					{
1:eac0369: 						DataTypeDescriptor	oldType = parameterTypes[i];
1:eac0369: 						DataTypeDescriptor	newType	= newParamTypes[i];
1:eac0369: 
1:eac0369: 						if (!oldType.isExactTypeAndLengthMatch(newType)) {
1:eac0369: 							match = false;
1:eac0369: 							break;
1:eac0369: 						}
1:eac0369: 						/*
1:eac0369: 						** We could probably get away without checking nullability,
1:eac0369: 						** since parameters are always nullable.
1:eac0369: 						*/
1:eac0369: 						if (oldType.isNullable() != newType.isNullable()) {
1:eac0369: 							match = false;
1:eac0369: 							break;
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (!match)
1:eac0369: 				throw StandardException.newException(SQLState.LANG_OBSOLETE_PARAMETERS);
1:eac0369: 
1:eac0369: 
1:eac0369: 			parameterValues.transferDataValues(pvs);
1:eac0369: 
1:eac0369: 		}
1:eac0369: 		else if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT("isClosed() is expected to return false");
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 	Throw an exception if any parameters are uninitialized.
1:eac0369: 
1:eac0369: 		@exception StandardException	Thrown if any parameters
1:eac0369: 												are unitialized
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public void throwIfMissingParms() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (pvs != null && !pvs.allAreSet())
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_MISSING_PARMS);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remember the row for the specified ResultSet.
1:eac0369: 	 */
1:eac0369: 	public void setCurrentRow(ExecRow currentRow, int resultSetNumber)
1:c533cd2: 	{
1:eac0369: 		if (SanityManager.DEBUG) 
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(!isClosed(), "closed");
1:eac0369: 			if (row != null)
1:eac0369: 			{
1:eac0369: 				if (!(resultSetNumber >=0 && resultSetNumber < row.length))
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT("resultSetNumber = " + resultSetNumber +
1:eac0369: 								 ", expected to be between 0 and " + row.length);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		if (row != null)
1:eac0369: 		{
1:eac0369: 			row[resultSetNumber] = currentRow;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Clear the current row for the specified ResultSet.
1:eac0369: 	 */
1:eac0369: 	public void clearCurrentRow(int resultSetNumber)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (row != null)
1:eac0369: 			{
1:eac0369: 				if (!(resultSetNumber >=0 && resultSetNumber < row.length))
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT("resultSetNumber = " + resultSetNumber +
1:eac0369: 								 ", expected to be between 0 and " + row.length);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		if (row != null)
1:eac0369: 		{
1:eac0369: 			row[resultSetNumber] = null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:c533cd2: 	 * Get the current row at the given index.
1:c533cd2: 	 */
1:c533cd2: 	public Row getCurrentRow(int resultSetNumber)
1:c533cd2: 	{
1:c533cd2:         return row[resultSetNumber];
1:c533cd2: 	}
1:c533cd2: 
1:c533cd2: 	/**
1:c533cd2: 	 * Return the current SQL session context for all immediately
1:c533cd2: 	 * nested connections stemming from the call or function
1:c533cd2: 	 * invocation of the statement corresponding to this activation.
1:1eeea61:      * <p/>
1:1eeea61:      * Substatements (e.g. used in rs.updateRow), inherit the SQL session
1:1eeea61:      * context via its parent activation.
1:e3883f5: 	 * @see org.apache.derby.iapi.sql.Activation#getSQLSessionContextForChildren
1:eac0369: 	 */
1:e3883f5: 	public SQLSessionContext getSQLSessionContextForChildren() {
1:e3883f5: 		return sqlSessionContextForChildren;
1:6950a39: 	}
1:6950a39: 
1:eac0369: 	/**
1:e3883f5: 	 * @see org.apache.derby.iapi.sql.Activation#setupSQLSessionContextForChildren
1:eac0369: 	 */
1:e3883f5: 	public SQLSessionContext setupSQLSessionContextForChildren(boolean push) {
1:e3883f5: 
1:e3883f5: 		if (push) {
1:e3883f5: 			// Nested connection, so need to push a new context: SQL 2003,
1:e3883f5: 			// 4.37.1: "An SQL-session is associated with an
1:e3883f5: 			// SQL-connection.
1:e3883f5: 			sqlSessionContextForChildren = lcc.createSQLSessionContext();
1:e3883f5: 		} else {
1:e3883f5: 			// Substatement, so use current one
1:e3883f5: 			if (parentActivation != null) {
1:e3883f5: 				// The parent statement performing the substatement is
1:e3883f5: 				// itself inside a nested connection (stored routine)
1:e3883f5: 				sqlSessionContextForChildren =
1:e3883f5: 					parentActivation.getSQLSessionContextForChildren();
1:e3883f5: 			} else {
1:e3883f5: 				// The parent statement performing the substatement is on
1:e3883f5: 				// top level
1:e3883f5: 				sqlSessionContextForChildren =
1:e3883f5: 					lcc.getTopLevelSQLSessionContext();
1:e3883f5: 			}
1:e3883f5: 		}
1:e3883f5: 
1:e3883f5: 		return sqlSessionContextForChildren;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:e3883f5: 	 * This activation is created in a dynamic call context or a substatement
1:e3883f5: 	 * execution context, make note of its parent statements activation (a).
1:eac0369: 	 *
1:e3883f5: 	 * @param a The caller's or superstatement's activation
1:eac0369: 	 */
1:e3883f5: 	public void setParentActivation(Activation a) {
1:e3883f5: 		parentActivation = a;
1:e3883f5: 	}
1:e3883f5: 
1:e3883f5: 	/**
1:e3883f5: 	 * Get the activation of the calling statement or parent statement.
1:e3883f5: 	 *
1:e3883f5: 	 * @return The parent's activation
1:e3883f5: 	 */
1:e3883f5: 	public Activation getParentActivation() {
1:e3883f5: 		return parentActivation;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	protected final DataValueDescriptor getColumnFromRow(int rsNumber, int colId)
1:eac0369: 		throws StandardException {
1:eac0369: 
1:d9dd1e5:         if (row[rsNumber] == null) {
1:d9dd1e5:             /* This actually happens. NoPutResultSetImpl.clearOrderableCache
1:d9dd1e5:              * attempts to prefetch invariant values into a cache. This fails
1:d9dd1e5:              * in some deeply nested joins. See Beetle 4736 and 4880.*/
1:d9dd1e5: 
1:d9dd1e5:             /*
1:d9dd1e5:              * Update: DERBY-4798 shows a query for which we get an NPE unless
1:d9dd1e5:              * this escape is in place (once removed by DERBY-3097, but
1:d9dd1e5:              * reintroduced by DERBY-4798 until we understand how we can get
1:d9dd1e5:              * rid of this anomaly). Thus, for now,
1:d9dd1e5:              * OuterJoinTest#testDerby_4798_NPE will provoke an NPE if this
1:d9dd1e5:              * code is removed.
1:d9dd1e5:              */
1:d9dd1e5:             return null;
1:d9dd1e5:         }
1:d9dd1e5: 
1:d9dd1e5:         return row[rsNumber].getColumn(colId);
1:eac0369: 	}
1:eac0369: 
1:7777dbd:     /**
1:7777dbd:      * Check that a positioned statement is executing against a cursor
1:7777dbd:      * from the same PreparedStatement (plan) that the positioned
1:7777dbd:      * statement was original compiled against.
1:7777dbd:      * 
1:7777dbd:      * Only called from generated code for positioned UPDATE and DELETE
1:7777dbd:      * statements. See CurrentOfNode.
1:7777dbd:      * 
1:7777dbd:      * @param cursorName Name of the cursor
1:7777dbd:      * @param psName Object name of the PreparedStatement.
1:7777dbd:      * @throws StandardException
1:7777dbd:      */
1:eac0369: 	protected void checkPositionedStatement(String cursorName, String psName)
1:eac0369: 		throws StandardException {
1:eac0369: 
1:eac0369: 		ExecPreparedStatement ps = getPreparedStatement();
1:eac0369: 		if (ps == null)
1:eac0369: 			return;
1:eac0369: 			
1:eac0369: 		CursorActivation cursorActivation = lcc.lookupCursorActivation(cursorName);
1:eac0369: 
1:eac0369: 		if (cursorActivation != null)
1:eac0369: 		{
1:eac0369: 			// check we are compiled against the correct cursor
1:eac0369: 			if (!psName.equals(cursorActivation.getPreparedStatement().getObjectName())) {
1:eac0369: 
1:eac0369: 				// our prepared statement is now invalid since there
1:eac0369: 				// exists another cursor with the same name but a different
1:eac0369: 				// statement.
1:eac0369: 				ps.makeInvalid(DependencyManager.CHANGED_CURSOR, lcc);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* This method is used to materialize a resultset if can actually fit in the memory
1:eac0369: 	 * specified by "maxMemoryPerTable" system property.  It converts the result set into
1:eac0369: 	 * union(union(union...(union(row, row), row), ...row), row).  It returns this
1:eac0369: 	 * in-memory converted resultset, or the original result set if not converted.
1:eac0369: 	 * See beetle 4373 for details.
1:eac0369: 	 *
1:f18825a: 	 * Optimization implemented as part of Beetle: 4373 can cause severe stack overflow
1:f18825a: 	 * problems. See JIRA entry DERBY-634. With default MAX_MEMORY_PER_TABLE of 1MG, it is
1:f18825a: 	 * possible that this optimization could attempt to cache upto 250K rows as nested
1:f18825a: 	 * union results. At runtime, this would cause stack overflow.
1:eac0369: 	 *
1:f18825a: 	 * As Jeff mentioned in DERBY-634, right way to optimize original problem would have been
1:f18825a: 	 * to address subquery materialization during optimization phase, through hash joins.
1:f18825a: 	 * Recent Army's optimizer work through DEBRY-781 and related work introduced a way to
1:f18825a: 	 * materialize subquery results correctly and needs to be extended to cover this case.
1:f18825a: 	 * While his optimization needs to be made more generic and stable, I propose to avoid
1:f18825a: 	 * this regression by limiting size of the materialized resultset created here to be
1:f18825a: 	 * less than MAX_MEMORY_PER_TABLE and MAX_DYNAMIC_MATERIALIZED_ROWS.
1:eac0369: 	 *
1:eac0369: 	 *	@param	rs	input result set
1:eac0369: 	 *	@return	materialized resultset, or original rs if it can't be materialized
1:eac0369: 	 */
1:801cf0d:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:eac0369: 	public NoPutResultSet materializeResultSetIfPossible(NoPutResultSet rs)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		rs.openCore();
1:71c8e86: 		Vector<ExecRow> rowCache = new Vector<ExecRow>();
1:eac0369: 		ExecRow aRow;
1:eac0369: 		int cacheSize = 0;
1:eac0369: 		FormatableBitSet toClone = null;
1:eac0369: 
1:eac0369: 		int maxMemoryPerTable = getLanguageConnectionContext().getOptimizerFactory().getMaxMemoryPerTable();
1:eac0369: 
1:eac0369: 		aRow = rs.getNextRowCore();
1:eac0369: 		if (aRow != null)
1:eac0369: 		{
1:eac0369: 			toClone = new FormatableBitSet(aRow.nColumns() + 1);
1:eac0369: 			toClone.set(1);
1:eac0369: 		}
1:eac0369: 		while (aRow != null)
1:eac0369: 		{
1:eac0369: 			cacheSize += aRow.getColumn(1).getLength();
1:f18825a: 			if (cacheSize > maxMemoryPerTable ||
1:f18825a: 					rowCache.size() > Optimizer.MAX_DYNAMIC_MATERIALIZED_ROWS)
1:eac0369: 				break;
1:eac0369: 			rowCache.addElement(aRow.getClone(toClone));
1:eac0369: 			aRow = rs.getNextRowCore();
1:eac0369: 		}
1:eac0369: 		rs.close();
1:eac0369: 
1:eac0369: 		if (aRow == null)
1:eac0369: 		{
1:eac0369: 			int rsNum = rs.resultSetNumber();
1:eac0369: 
1:eac0369: 			int numRows = rowCache.size();
1:eac0369: 			if (numRows == 0)
1:eac0369: 			{
1:eac0369: 				return new RowResultSet(
1:eac0369: 										this,
1:eac0369: 										(ExecRow) null,
1:eac0369: 										true,
1:eac0369: 										rsNum,
4:eac0369: 										0,
1:f77f36d: 										0);
1:eac0369: 			}
1:eac0369: 			RowResultSet[] rrs = new RowResultSet[numRows];
1:eac0369: 			UnionResultSet[] urs = new UnionResultSet[numRows - 1];
1:eac0369: 
1:eac0369: 			for (int i = 0; i < numRows; i++)
1:eac0369: 			{
1:eac0369: 				rrs[i] = new RowResultSet(
1:eac0369: 										this,
1:801cf0d:                                         rowCache.elementAt(i),
1:eac0369: 										true,
1:eac0369: 										rsNum,
1:eac0369: 										1,
1:f77f36d: 										0);
1:eac0369: 				if (i > 0)
1:eac0369: 				{
1:eac0369: 					urs[i - 1] = new UnionResultSet (
1:eac0369: 										(i > 1) ? (NoPutResultSet)urs[i - 2] : (NoPutResultSet)rrs[0],
1:eac0369: 										rrs[i],
1:eac0369: 										this,
1:eac0369: 										rsNum,
1:eac0369: 										i + 1,
1:f77f36d: 										0);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			rs.finish();
1:eac0369: 
1:eac0369: 			if (numRows == 1)
1:eac0369: 				return rrs[0];
1:eac0369: 			else
1:eac0369: 				return urs[urs.length - 1];
1:eac0369: 		}
1:eac0369: 		return rs;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	//WARNING : this field name is referred in the DeleteNode generate routines.
1:eac0369: 	protected CursorResultSet[] raParentResultSets;
1:eac0369: 
1:eac0369: 
1:eac0369: 	// maintain hash table of parent result set vector
1:eac0369: 	// a table can have more than one parent source.
1:801cf0d:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:71c8e86: 	protected Hashtable<String,Vector<TemporaryRowHolder>> parentResultSets;
1:801cf0d: 
1:801cf0d:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:801cf0d:     public void setParentResultSet(TemporaryRowHolder rs, String resultSetId)
1:eac0369: 	{
1:71c8e86: 		Vector<TemporaryRowHolder>  rsVector;
1:eac0369: 		if(parentResultSets == null)
1:71c8e86: 			parentResultSets = new Hashtable<String,Vector<TemporaryRowHolder>>();
1:801cf0d:         rsVector = parentResultSets.get(resultSetId);
1:801cf0d: 
1:eac0369: 		if(rsVector == null)
1:eac0369: 		{
1:71c8e86: 			rsVector = new Vector<TemporaryRowHolder>();
1:eac0369: 			rsVector.addElement(rs);
1:eac0369: 		}else
1:eac0369: 		{
1:eac0369: 			rsVector.addElement(rs);
1:eac0369: 		}
1:eac0369: 		parentResultSets.put(resultSetId , rsVector);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * get the reference to parent table ResultSets, that will be needed by the 
1:eac0369: 	 * referential action dependent table scans.
1:eac0369: 	 */
1:801cf0d:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:71c8e86: 	public Vector<TemporaryRowHolder> getParentResultSet(String resultSetId)
1:eac0369: 	{
1:801cf0d:         return parentResultSets.get(resultSetId);
1:eac0369: 	}
1:eac0369: 
1:71c8e86: 	public Enumeration<String> getParentResultSetKeys()
1:eac0369: 	{
1:706f2eb: 		return parentResultSets.keys();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 ** prepared statement use the same activation for
1:eac0369: 	 ** multiple execution. For each excution we create new
1:eac0369: 	 ** set of temporary resultsets, we should clear this hash table.
1:eac0369: 	 ** otherwise we will refer to the released resources.
1:eac0369: 	 */
1:eac0369: 	public void clearParentResultSets()
1:eac0369: 	{
1:eac0369: 		if(parentResultSets != null)
1:eac0369: 			parentResultSets.clear();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * beetle 3865: updateable cursor using index.  A way of communication
1:eac0369: 	 * between cursor activation and update activation.
1:eac0369: 	 */
1:eac0369: 	public void setForUpdateIndexScan(CursorResultSet forUpdateIndexScan)
1:eac0369: 	{
1:eac0369: 		this.forUpdateIndexScan = forUpdateIndexScan;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public CursorResultSet getForUpdateIndexScan()
1:eac0369: 	{
1:eac0369: 		return forUpdateIndexScan;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private java.util.Calendar cal;
1:eac0369: 	/**
1:eac0369: 		Return a calendar for use by this activation.
1:eac0369: 		Calendar objects are not thread safe, the one returned
1:eac0369: 		is purely for use by this activation and it is assumed
1:eac0369: 		that is it single threded through the single active
1:eac0369: 		thread in a connection model.
1:eac0369: 	*/
1:eac0369: 	protected java.util.Calendar getCalendar() {
1:eac0369: 		if (cal == null)
1:eac0369: 			cal = new java.util.GregorianCalendar();
1:eac0369: 		return cal;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Code originally in the parent class BaseExpressionActivation
1:eac0369: 	*/
1:eac0369: 	/**
1:eac0369: 	    Get the language connection factory associated with this connection
1:eac0369: 	  */
1:eac0369: 	public final LanguageConnectionContext	getLanguageConnectionContext()
1:eac0369: 	{
1:eac0369: 		return	lcc;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final TransactionController getTransactionController()
1:eac0369: 	{
1:eac0369: 		return lcc.getTransactionExecute();
1:eac0369: 	}
1:eac0369: 			
1:eac0369: 	/**
1:eac0369: 	 * Get the Current ContextManager.
1:eac0369: 	 *
1:eac0369: 	 * @return Current ContextManager
1:eac0369: 	 */
1:eac0369: 	public ContextManager getContextManager()
1:eac0369: 	{
1:eac0369: 		return cm;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Used by activations to generate data values.  Most DML statements
1:eac0369: 		will use this method.  Possibly some DDL statements will, as well.
1:eac0369: 	 */
1:eac0369: 	public DataValueFactory getDataValueFactory()
1:eac0369: 	{
1:6c000e8: 		return getLanguageConnectionContext().getDataValueFactory();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Used to get a proxy for the current connection.
1:eac0369: 	 *
1:eac0369: 	 * @exception SQLException		Thrown on failure to get connection
1:eac0369: 	 */
1:eac0369: 	public Connection getCurrentConnection() throws SQLException {
1:eac0369: 
1:eac0369: 		ConnectionContext cc = 
1:6c000e8: 			(ConnectionContext) getContextManager().getContext(ConnectionContext.CONTEXT_ID);
1:eac0369: 
1:eac0369: 		return cc.getNestedConnection(true);
1:eac0369: 	}	
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Real implementations of this method are provided by a generated class.
1:eac0369: 	*/
1:eac0369: 	public java.sql.ResultSet[][] getDynamicResults() {
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 		Real implementations of this method are provided by a generated class.
1:eac0369: 	*/
1:eac0369: 	public int getMaxDynamicResults() {
1:eac0369: 		return 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Compute the DB2 compatible length of a value.
1:eac0369:      *
1:eac0369:      * @param value
1:eac0369:      * @param constantLength The length, if it is a constant modulo null/not null. -1 if the length is not constant
1:eac0369:      * @param reUse If non-null then re-use this as a container for the length
1:eac0369:      *
1:eac0369:      * @return the DB2 compatible length, set to null if value is null.
1:eac0369:      */
1:eac0369:     public NumberDataValue getDB2Length( DataValueDescriptor value,
1:eac0369:                                          int constantLength,
1:eac0369:                                          NumberDataValue reUse)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         if( reUse == null)
1:eac0369:             reUse = getDataValueFactory().getNullInteger( null);
1:eac0369:         if( value.isNull())
1:eac0369:             reUse.setToNull();
1:eac0369:         else
1:eac0369:         {
1:eac0369:             if( constantLength >= 0)
1:eac0369:                 reUse.setValue( constantLength);
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 reUse.setValue(value.getLength());
1:eac0369:             }
1:eac0369:         }
1:eac0369:         return reUse;
1:eac0369:     } // end of getDB2Length
1:e4caed2: 
1:e4caed2: 
1:e4caed2: 	/* Dependable interface implementation */
1:e4caed2: 
1:e4caed2: 	/**
1:e4caed2: 	 * @see Dependable#getDependableFinder
1:e4caed2: 	 */
1:e4caed2: 	public DependableFinder getDependableFinder()
1:e4caed2: 	{
1:e4caed2: 	    return null;
1:e4caed2: 	}
1:e4caed2: 
1:e4caed2: 
1:e4caed2: 	/**
1:e4caed2: 	 * @see Dependable#getObjectName
1:e4caed2: 	 */
1:e4caed2: 	public String getObjectName()
1:e4caed2: 	{
1:e4caed2: 		return UUIDString;
1:e4caed2: 	}
1:e4caed2: 
1:e4caed2: 
1:e4caed2: 	/**
1:e4caed2: 	 * @see Dependable#getObjectID
1:e4caed2: 	 */
1:e4caed2: 	public UUID getObjectID()
1:e4caed2: 	{
1:e4caed2: 		return UUIDValue;
1:e4caed2: 	}
1:e4caed2: 
1:e4caed2: 
1:e4caed2: 	/**
1:e4caed2: 	 * @see Dependable#getClassType
1:e4caed2: 	 */
1:e4caed2: 	public String getClassType()
1:e4caed2: 	{
1:e4caed2: 		return Dependable.ACTIVATION;
1:e4caed2: 	}
1:e4caed2: 
1:e4caed2: 
1:e4caed2: 	/**
1:e4caed2: 	 * @see Dependable#isPersistent
1:e4caed2: 	 */
1:e4caed2: 	public boolean isPersistent()
1:e4caed2: 	{
1:e4caed2: 		/* activations are not persistent */
1:e4caed2: 		return false;
1:e4caed2: 	}
1:e4caed2: 
1:e4caed2: 
1:e4caed2: 	/* Dependent interface implementation */
1:e4caed2: 
1:e4caed2: 	/**
1:88d10d4: 	 * @see org.apache.derby.iapi.sql.depend.Dependent#isValid
1:e4caed2: 	 */
1:e4caed2: 	public boolean isValid() {
1:e4caed2: 		return isValid;
1:e4caed2: 	}
1:e4caed2: 
1:e4caed2: 	/**
1:88d10d4: 	 * @see org.apache.derby.iapi.sql.depend.Dependent#makeInvalid
1:e4caed2: 	 */
1:e4caed2: 	public void makeInvalid(int action,
1:e4caed2: 							LanguageConnectionContext lcc)
1:e4caed2: 			throws StandardException {
1:56c1dc2: 
1:e4caed2: 		switch (action) {
1:e4caed2: 		case DependencyManager.RECHECK_PRIVILEGES:
1:e4caed2: 			// Make ourselves invalid.
1:e4caed2: 			isValid = false;
1:e4caed2: 			/* Clear out the old dependencies on this activation as we
1:e4caed2: 			 * will die shortly.
1:e4caed2: 			 */
1:e4caed2: 			DependencyManager dm =
1:e4caed2: 				lcc.getDataDictionary().getDependencyManager();
1:e4caed2: 			dm.clearDependencies(lcc, this);
1:e4caed2: 
1:e4caed2: 			break;
1:e4caed2: 		case DependencyManager.REVOKE_ROLE:
1:e4caed2: 			// Used by persistent objects (views, triggers, constraints)
1:e4caed2: 			break;
1:e4caed2: 		case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
1:e4caed2: 			// Used to recompile prepared statements
1:e4caed2: 			break;
1:e4caed2: 		default:
1:e4caed2: 			if (SanityManager.DEBUG) {
1:e4caed2: 				SanityManager.DEBUG_PRINT("BaseActivation", "action=" + action);
1:e4caed2: 				SanityManager.NOTREACHED();
1:e4caed2: 			}
1:e4caed2: 		}
1:e4caed2: 
1:e4caed2: 	}
1:e4caed2: 
1:56c1dc2: 	/**
1:88d10d4: 	 * @see org.apache.derby.iapi.sql.depend.Dependent#prepareToInvalidate
1:e4caed2: 	 */
1:e4caed2: 	public void prepareToInvalidate(Provider p, int action,
1:e4caed2: 							 LanguageConnectionContext lcc)
1:e4caed2: 			throws StandardException {
1:e4caed2: 	}
1:eac0369:     
1:e4caed2:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be package private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:bb5be6f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			if (rowCountsCheckedThisExecution.add(resultSetNumber))
commit:f542632
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 long n1 = getPreparedStatement()
1:                         .getInitialRowCount(resultSetNumber, currentRowCount);
1:                 /*
1:                 ** Has the row count changed significantly?
1:                 */
1:                 if (currentRowCount != n1)
1:                 {
1:                     if (n1 >= TEN_PERCENT_THRESHOLD)
1:                     {
1:                         /*
1:                         ** For tables with more than
1:                         ** TEN_PERCENT_THRESHOLD rows, the
1:                         ** threshold is 10% of the size of the table.
1:                         */
1:                         long changeFactor = n1 / (currentRowCount - n1);
1:                         if (Math.abs(changeFactor) <= 10) {
1:                             significantChange = true;
1:                     }
1:                     else
1:                     {
1:                         /*
1:                         ** For tables with less than
1:                         ** TEN_PERCENT_THRESHOLD rows, the threshold
1:                         ** is non-linear.  This is because we want
1:                         ** recompilation to happen sooner for small
1:                         ** tables that change size.  This formula
1:                         ** is for a second-order equation (a parabola).
1:                         ** The derivation is:
1:                         **
1:                         **   c * n1 = (difference in row counts) ** 2
1:                         **				- or -
1:                         **   c * n1 = (currentRowCount - n1) ** 2
1:                         **
1:                         ** Solving this for currentRowCount, we get:
1:                         **
1:                         **   currentRowCount = n1 + sqrt(c * n1)
1:                         **
1:                         **				- or -
1:                         **
1:                         **   difference in row counts = sqrt(c * n1)
1:                         **
1:                         **				- or -
1:                         **
1:                         **   (difference in row counts) ** 2 =
1:                         **					c * n1
1:                         **
1:                         ** Which means that we should recompile when
1:                         ** the current row count exceeds n1 (the first
1:                         ** row count) by sqrt(c * n1), or when the
1:                         ** square of the difference exceeds c * n1.
1:                         ** A good value for c seems to be 4.
1:                         **
1:                         ** We don't use this formula when c is greater
1:                         ** than TEN_PERCENT_THRESHOLD because we never
1:                         ** want to recompile unless the number of rows
1:                         ** changes by more than 10%, and this formula
1:                         ** is more sensitive than that for values of
1:                         ** n1 greater than TEN_PERCENT_THRESHOLD.
1:                         */
1:                         long changediff = currentRowCount - n1;
1:                         /*
1:                         ** Square changediff rather than take the square
1:                         ** root of (4 * n1), because multiplying is
1:                         ** faster than taking a square root.  Also,
1:                         ** check to be sure that squaring changediff
1:                         ** will not cause an overflow by comparing it
1:                         ** with the square root of the maximum value
1:                         ** for a long (this square root is taken only
1:                         ** once, when the class is loaded, or during
1:                         ** compilation if the compiler is smart enough).
1:                         */
1:                         if (Math.abs(changediff) <= MAX_SQRT)
1:                         {
1:                             if ((changediff * changediff) >
1:                                                     Math.abs(4 * n1))
1:                             {
1:                                 significantChange = true;
1:                             }
1:                         }
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
1:         final ExecPreparedStatement ps = getPreparedStatement();
/////////////////////////////////////////////////////////////////////////
1:         int executionCount = ps.incrementExecutionCount();
/////////////////////////////////////////////////////////////////////////
1:             int stalePlanCheckInterval = ps.getStalePlanCheckInterval();
/////////////////////////////////////////////////////////////////////////
1: 
1:                 ps.setStalePlanCheckInterval(stalePlanCheckInterval);
commit:dd9ad07
/////////////////////////////////////////////////////////////////////////
1:              resultSet = decorateResultSet();
1:      * Create the ResultSet tree for this statement, and possibly perform
1:      * extra checks or initialization required by specific sub-classes.
1:      * @return the root of the ResultSet tree for this statement
1:      */
1:     ResultSet decorateResultSet() throws StandardException {
1:         return createResultSet();
1:     }
1: 
1:     /**
commit:d11ed08
/////////////////////////////////////////////////////////////////////////
1:         // Reinitialize data structures in the generated class before
1:         // each execution.
1:         reinit();
1: 
1:         // Create the result set tree on the first execution.
1:         if (resultSet == null) {
0:              resultSet = createResultSet();
0:              if (isCursorActivation()) {
0:                  ((NoPutResultSet) resultSet).markAsTopResultSet();
1:              }
1:         }
1: 
1:         return resultSet;
1:      * Create the ResultSet tree for this statement.
1:      * @return the root of the ResultSet tree for this statement
1:     protected abstract ResultSet createResultSet() throws StandardException;
1: 
1:     /**
1:      * Reinitialize data structures added by the sub-classes before each
1:      * execution of the statement. The default implementation does nothing.
1:      * Sub-classes should override this method if they need to perform
1:      * operations before each execution.
1:      */
1:     protected void reinit() throws StandardException {
1:         // Do nothing by default. Overridden by sub-classes that need it.
1:     }
commit:edb7fcc
/////////////////////////////////////////////////////////////////////////
1:     public final ResultSet execute() throws StandardException {
1:         throwIfClosed("execute");
1: 
1:         // Determine if we should check row counts during this execution.
1:         checkRowCounts = shouldWeCheckRowCounts();
1: 
1:         // If we are to check row counts, clear the hash table of row counts
1:         // we have checked.
1:         if (checkRowCounts) {
1:             rowCountsCheckedThisExecution.clear();
1:         }
1: 
0:         return doExecute();
1:     }
1: 
1:     /**
0:      * Abstract method overridden by generated classes, containing the
0:      * body of the {@link #execute()} method.
1:      */
0:     protected abstract ResultSet doExecute() throws StandardException;
1: 
/////////////////////////////////////////////////////////////////////////
commit:0393775
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * This class holds row count statistics for a query.
1:      */
0:     protected static class RowCountStats {
1:         /**
0:          * Stale plan check interval tells how often the row counts should be
0:          * checked. Cached here so that we don't need to query the database
0:          * properties on each execution.
1:          */
0:         private int stalePlanCheckInterval;
0:         /** The number of times this query has been executed. */
0:         private int executionCount;
0:         /** List with row count estimates for each table in the query. */
0:         private final List rowCounts;
1: 
0:         public RowCountStats() {
0:             rowCounts = new ArrayList();
1:         }
1:     }
1: 
1:     /**
0:      * Get the object holding row count statistics for this activation.
1:      *
0:      * It may return {@code null} if row count statistics are not maintained
0:      * for the activation. In that case, {@link #shouldWeCheckRowCounts()}
0:      * must return {@code false}.
1:      */
0:     protected abstract RowCountStats getRowCountStats();
1: 
/////////////////////////////////////////////////////////////////////////
0:                 final RowCountStats stats = getRowCountStats();
0:                 synchronized (stats)
0:                     final List rowCountCheckVector = stats.rowCounts;
/////////////////////////////////////////////////////////////////////////
0:                             (Long) rowCountCheckVector.get(resultSetNumber);
0:                         int newSize = resultSetNumber + 1;
0:                         while (rowCountCheckVector.size() < newSize) {
0:                             rowCountCheckVector.add(null);
1:                         }
/////////////////////////////////////////////////////////////////////////
0:                         rowCountCheckVector.set(
0:                             resultSetNumber, new Long(currentRowCount));
/////////////////////////////////////////////////////////////////////////
0:         checkRowCounts = shouldWeCheckRowCounts();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Find out if it's time to check the row counts of the tables involved
1:      * in this query.
1:      * @return true if the row counts should be checked, false otherwise
1:      */
1: 	protected boolean shouldWeCheckRowCounts() throws StandardException
0:         final RowCountStats stats = getRowCountStats();
1: 
0:         int executionCount = ++stats.executionCount;
/////////////////////////////////////////////////////////////////////////
1:             return true;
1:             return false;
0:             int stalePlanCheckInterval = stats.stalePlanCheckInterval;
/////////////////////////////////////////////////////////////////////////
0:                 stats.stalePlanCheckInterval = stalePlanCheckInterval;
1:             return (executionCount % stalePlanCheckInterval) == 1;
commit:f7ce263
/////////////////////////////////////////////////////////////////////////
1:             // Remove all the dependencies this activation has. It won't need
1:             // them after it's closed, so let's free up the memory in the
1:             // dependency manager. (DERBY-4571)
1:             DependencyManager dm =
1:                     lcc.getDataDictionary().getDependencyManager();
1:             dm.clearDependencies(lcc, this);
1: 
commit:6832893
/////////////////////////////////////////////////////////////////////////
1: 		if (preStmt == null || preStmt.upToDate(gc))
commit:fbf1381
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			if (resultSet != null)
1: 			{
1: 				// Finish the resultSet, it will never be used again.
1: 				resultSet.finish();
1: 				resultSet = null;
1: 			}
1: 
commit:3334bff
/////////////////////////////////////////////////////////////////////////
1: 	/**
commit:68c8e7d
/////////////////////////////////////////////////////////////////////////
1: 
1: 	// This flag is declared volatile to ensure it is 
1: 	// visible when it has been modified by the finalizer thread.
1: 	private volatile boolean inUse;
/////////////////////////////////////////////////////////////////////////
1: 	public final void initFromContext(Context context) 
1: 		throws StandardException {
/////////////////////////////////////////////////////////////////////////
1: 		if(isInUse()) {
1: 			inUse = false;
1: 			lcc.notifyUnusedActivation();
1: 		}
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
/////////////////////////////////////////////////////////////////////////
1: 			getMonitor().getUUIDFactory();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged Monitor lookup. Must be package private so that user code
1:      * can't call this entry point.
1:      */
1:     static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
1:     }
1: 
commit:a180287
/////////////////////////////////////////////////////////////////////////
1: 	public NumberDataValue getCurrentValueAndAdvance
commit:508a010
/////////////////////////////////////////////////////////////////////////
1: import java.util.Stack;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Stack of ConstantActions.
1:      */
1:     private Stack<ConstantAction>   constantActionStack = new Stack<ConstantAction>();
1: 
/////////////////////////////////////////////////////////////////////////
1:     public  ConstantAction    pushConstantAction( ConstantAction newConstantAction )
1:     {
1:         return constantActionStack.push( newConstantAction );
1:     }
1: 
1:     public  ConstantAction    popConstantAction()
1:     {
1:         return constantActionStack.pop();
1:     }
1: 
1: 	public ConstantAction getConstantAction()
1:     {
1:         if ( constantActionStack.size() > 0 )
1:         {
1:             return constantActionStack.peek();
1:         }
1:         else { return preStmt.getConstantAction(); }
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1: 	private HashSet<Integer> rowCountsCheckedThisExecution = new HashSet<Integer>(4, 0.9f);
/////////////////////////////////////////////////////////////////////////
1: 		Vector<ExecRow> rowCache = new Vector<ExecRow>();
/////////////////////////////////////////////////////////////////////////
1: 	protected Hashtable<String,Vector<TemporaryRowHolder>> parentResultSets;
1: 		Vector<TemporaryRowHolder>  rsVector;
1: 			parentResultSets = new Hashtable<String,Vector<TemporaryRowHolder>>();
0: 		rsVector = (Vector<TemporaryRowHolder>) parentResultSets.get(resultSetId);
1: 			rsVector = new Vector<TemporaryRowHolder>();
/////////////////////////////////////////////////////////////////////////
1: 	public Vector<TemporaryRowHolder> getParentResultSet(String resultSetId)
0: 		return (Vector<TemporaryRowHolder>) parentResultSets.get(resultSetId);
1: 	public Enumeration<String> getParentResultSetKeys()
commit:706f2eb
/////////////////////////////////////////////////////////////////////////
1: import java.util.Enumeration;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.ArrayUtil;
/////////////////////////////////////////////////////////////////////////
1: 		autoGeneratedKeysColumnIndexes = ArrayUtil.copy( columnIndexes );
1: 		autoGeneratedKeysColumnNames = ArrayUtil.copy( columnNames );
/////////////////////////////////////////////////////////////////////////
1: 		return ArrayUtil.copy( autoGeneratedKeysColumnIndexes );
1: 		return ArrayUtil.copy( autoGeneratedKeysColumnNames );
/////////////////////////////////////////////////////////////////////////
0: 	public Enumeration getParentResultSetKeys()
1: 		return parentResultSets.keys();
commit:47a8183
/////////////////////////////////////////////////////////////////////////
1: 	private long maxRows = -1L;
/////////////////////////////////////////////////////////////////////////
1: 	public void setMaxRows(long maxRows)
/////////////////////////////////////////////////////////////////////////
1: 	public long getMaxRows()
commit:bb4cfe9
/////////////////////////////////////////////////////////////////////////
1: 	 * Called by generated code to get the next number in an ANSI/ISO sequence
1:      * and advance the sequence. Raises an exception if the sequence was declared
1:      * @param sequenceUUIDstring The string value of the sequence's UUID
1:         ( String sequenceUUIDstring, int typeFormatID )
1:         lcc.getDataDictionary().getCurrentValueAndAdvance( sequenceUUIDstring, ndv );
commit:9495437
/////////////////////////////////////////////////////////////////////////
commit:92268ac
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
commit:729be57
/////////////////////////////////////////////////////////////////////////
0: 	 * Called by generated code to get the next number in an identity or sequence generator
0:      * and advance the generator. Raises an exception if the generator was declared
0:      * @param catalogNumber SYSCOLUMNS_CATALOG_NUM or SYSSEQUENCES_CATALOG_NUM, depending on the kind of generator
0:      * @param uuidString The string value of the generator's uuid (table uuid for identity generators and sequence uuid for sequence generators)
0:         ( int catalogNumber, String uuidString, int typeFormatID )
0:         lcc.getDataDictionary().getCurrentValueAndAdvance( catalogNumber, uuidString, ndv );
commit:139ca85
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
0: 	 * Called by generated code to get the next number in an ANSI/ISO sequence
0:      * and advance the sequence. Raises an exception if the sequence was declared
1:      * NO CYCLE and its range is exhausted.
1: 	 *
0:      * @param sequenceUUIDstring The string value of the sequence's UUID
1:      * @param typeFormatID The format id of the data type to be returned. E.g., StoredFormatIds.SQL_INTEGER_ID.
1:      *
1: 	 * @return The next number in the sequence
1: 	 */
0: 	protected NumberDataValue getCurrentValueAndAdvance
0:         ( String sequenceUUIDstring, int typeFormatID )
1: 	       throws StandardException
1: 	{
1:         NumberDataValue ndv = (NumberDataValue) getDataValueFactory().getNull( typeFormatID, StringDataValue.COLLATION_TYPE_UCS_BASIC );
1: 
0:         lcc.getDataDictionary().getCurrentValueAndAdvance( sequenceUUIDstring, ndv );
1: 
1:         return ndv;
1: 	}
1: 
1: 	/**
commit:c533cd2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.Row;
/////////////////////////////////////////////////////////////////////////
1: 	{
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the current row at the given index.
1: 	 */
1: 	public Row getCurrentRow(int resultSetNumber)
1: 	{
1:         return row[resultSetNumber];
1: 	}
1: 
1: 	/**
1: 	 * Return the current SQL session context for all immediately
1: 	 * nested connections stemming from the call or function
1: 	 * invocation of the statement corresponding to this activation.
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:a826375
/////////////////////////////////////////////////////////////////////////
1: 			((DMLWriteGeneratedColumnsResultSet)resultSet).getSetAutoincrementValue(columnPosition, increment);
commit:cbc650d
/////////////////////////////////////////////////////////////////////////
1: 		if (resultSet != null) 
1: 			resultSet.close();
1: 		
commit:dbfbecb
/////////////////////////////////////////////////////////////////////////
1: 	public final void setupActivation(ExecPreparedStatement ps, boolean scrollable) 
1: 	throws StandardException {
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.Dependable;
1: import org.apache.derby.catalog.DependableFinder;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: import org.apache.derby.iapi.sql.PreparedStatement;
0: import org.apache.derby.iapi.sql.Row;
1: import org.apache.derby.iapi.sql.depend.Provider;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:      * activation of the parent statement (if we are executing a sub-statement)
1:      * PreparedStatement#getActivation) based on the top of the
1:      * or just sub-statement execution starts.
1:      * @see org.apache.derby.impl.sql.compile.StaticMethodCallNode#generatePushNestedSessionContext
1:      * @see PreparedStatement#executeSubStatement
/////////////////////////////////////////////////////////////////////////
1:      * @throws StandardException standard error policy
/////////////////////////////////////////////////////////////////////////
1:      * @throws org.apache.derby.iapi.error.StandardException
/////////////////////////////////////////////////////////////////////////
1:      * Link this activation with its PreparedStatement.
1:      * It can be called with null to break the link with the
1:      * PreparedStatement.
1:      * @param ps prepared statement
1:      * @param scrollable activation for a scrollable result set
1:      * @throws StandardException standard error policy
1:      */
/////////////////////////////////////////////////////////////////////////
1:      * A generated class can create its own closeActivationAction
1:      * method to invoke special logic when the activation is closed.
1:      * @throws java.lang.Exception error
1:      */
/////////////////////////////////////////////////////////////////////////
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("UseOfObsoleteCollectionType")
/////////////////////////////////////////////////////////////////////////
1:                                         rowCache.elementAt(i),
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("UseOfObsoleteCollectionType")
1: 
1:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:     public void setParentResultSet(TemporaryRowHolder rs, String resultSetId)
1:         rsVector = parentResultSets.get(resultSetId);
1: 
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:         return parentResultSets.get(resultSetId);
commit:1eeea61
/////////////////////////////////////////////////////////////////////////
1:      * <p/>
1:      * Substatements (e.g. used in rs.updateRow), inherit the SQL session
1:      * context via its parent activation.
commit:d9dd1e5
/////////////////////////////////////////////////////////////////////////
1:         if (row[rsNumber] == null) {
1:             /* This actually happens. NoPutResultSetImpl.clearOrderableCache
1:              * attempts to prefetch invariant values into a cache. This fails
1:              * in some deeply nested joins. See Beetle 4736 and 4880.*/
1: 
1:             /*
1:              * Update: DERBY-4798 shows a query for which we get an NPE unless
1:              * this escape is in place (once removed by DERBY-3097, but
1:              * reintroduced by DERBY-4798 until we understand how we can get
1:              * rid of this anomaly). Thus, for now,
1:              * OuterJoinTest#testDerby_4798_NPE will provoke an NPE if this
1:              * code is removed.
1:              */
1:             return null;
1:         }
1: 
1:         return row[rsNumber].getColumn(colId);
commit:e3883f5
/////////////////////////////////////////////////////////////////////////
1: 	 * The 'parentActivation' of an activation of a statement executing in
1: 	 * A non-null 'parentActivation' represents the activation of the calling
1: 	 * statement (if we are in a nested connection of a stored routine), or the
0: 	 * activation of the parent statement (if we are executing a substatement)
1: 	 * 'parentActivation' is set when this activation is created (@see
1: 	 * by code generated for the call, after parameters are evaluated
0: 	 * or just substatement execution starts.
0: 	 * @see org.apache.derby.impl.sql.GenericPreparedStatement#executeSubStatement
1: 	private Activation parentActivation;
1: 	 * The SQL session context to be used inside a nested connection in a
1: 	 * stored routine or in a substatement. In the latter case, it is an alias
1: 	 * to the superstatement's session context.
1: 	private SQLSessionContext sqlSessionContextForChildren;
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.sql.Activation#getSQLSessionContextForChildren
1: 	public SQLSessionContext getSQLSessionContextForChildren() {
1: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT
0: 				(sqlSessionContextForChildren != null,
0: 				 "Expected sqlSessionContextForChildren to be non-null");
1: 		return sqlSessionContextForChildren;
1: 	 * @see org.apache.derby.iapi.sql.Activation#setupSQLSessionContextForChildren
1: 	public SQLSessionContext setupSQLSessionContextForChildren(boolean push) {
1: 
1: 		if (push) {
1: 			// Nested connection, so need to push a new context: SQL 2003,
1: 			// 4.37.1: "An SQL-session is associated with an
1: 			// SQL-connection.
1: 			sqlSessionContextForChildren = lcc.createSQLSessionContext();
1: 		} else {
1: 			// Substatement, so use current one
1: 			if (parentActivation != null) {
1: 				// The parent statement performing the substatement is
1: 				// itself inside a nested connection (stored routine)
1: 				sqlSessionContextForChildren =
1: 					parentActivation.getSQLSessionContextForChildren();
1: 			} else {
1: 				// The parent statement performing the substatement is on
1: 				// top level
1: 				sqlSessionContextForChildren =
1: 					lcc.getTopLevelSQLSessionContext();
1: 			}
1: 		}
1: 
1: 		return sqlSessionContextForChildren;
1: 	 * This activation is created in a dynamic call context or a substatement
1: 	 * execution context, make note of its parent statements activation (a).
1: 	 * @param a The caller's or superstatement's activation
1: 	public void setParentActivation(Activation a) {
1: 		parentActivation = a;
1: 	}
1: 
1: 	/**
1: 	 * Get the activation of the calling statement or parent statement.
1: 	 *
1: 	 * @return The parent's activation
1: 	 */
1: 	public Activation getParentActivation() {
1: 		return parentActivation;
commit:88d10d4
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.sql.depend.Dependent#isValid
1: 	 * @see org.apache.derby.iapi.sql.depend.Dependent#makeInvalid
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.sql.depend.Dependent#prepareToInvalidate
commit:e4caed2
/////////////////////////////////////////////////////////////////////////
0: import	org.apache.derby.catalog.Dependable;
0: import	org.apache.derby.catalog.DependableFinder;
1: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.sql.depend.Provider;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 * By setting isValid to false, we can force a new activation to be used
1: 	 * even if the prepared statement is still valid. This is used when
1: 	 * modifying the current role for a session, which may (if the statement
1: 	 * relies on privileges obtained via the current role) require rechecking
1: 	 * of privileges. The checking normally only happens the first time the
1: 	 * prepared statement is used in a session, when the activation is
1: 	 * constructed. Forcing creation of a new activation achieves the purpose
1: 	 * of getting the check performed over again and is cheaper than
1: 	 * invalidating the prepared statement itself. Also, the latter would
1: 	 * impact other sessions, forcing them to recreate their activations.
1: 	 */
1: 	private boolean isValid;
1: 
1: 	/**
1: 	 * For dependency tracking
1: 	 */
1: 	protected String UUIDString;
1: 
1: 	/**
1: 	 * For dependency tracking
1: 	 */
1: 	protected UUID   UUIDValue;
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 
1: 		isValid = true;
1: 
1: 		/* Get the UUID for this activation */
1: 		UUIDFactory uuidFactory =
0: 			Monitor.getMonitor().getUUIDFactory();
1: 
1: 		UUIDValue = uuidFactory.createUUID();
1: 		UUIDString = UUIDValue.toString();
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	/* Dependable interface implementation */
1: 
1: 	/**
1: 	 * @see Dependable#getDependableFinder
1: 	 */
1: 	public DependableFinder getDependableFinder()
1: 	{
1: 	    return null;
1: 	}
1: 
1: 
1: 	/**
1: 	 * @see Dependable#getObjectName
1: 	 */
1: 	public String getObjectName()
1: 	{
1: 		return UUIDString;
1: 	}
1: 
1: 
1: 	/**
1: 	 * @see Dependable#getObjectID
1: 	 */
1: 	public UUID getObjectID()
1: 	{
1: 		return UUIDValue;
1: 	}
1: 
1: 
1: 	/**
1: 	 * @see Dependable#getClassType
1: 	 */
1: 	public String getClassType()
1: 	{
1: 		return Dependable.ACTIVATION;
1: 	}
1: 
1: 
1: 	/**
1: 	 * @see Dependable#isPersistent
1: 	 */
1: 	public boolean isPersistent()
1: 	{
1: 		/* activations are not persistent */
1: 		return false;
1: 	}
1: 
1: 
1: 	/* Dependent interface implementation */
1: 
1: 	/**
0: 	 * @see Dependent#isValid
1: 	 */
1: 	public boolean isValid() {
1: 		return isValid;
1: 	}
1: 
1: 	/**
0: 	 * @see Dependent#makeInvalid
1: 	 */
1: 	public void makeInvalid(int action,
1: 							LanguageConnectionContext lcc)
1: 			throws StandardException {
1: 
1: 		switch (action) {
1: 		case DependencyManager.RECHECK_PRIVILEGES:
1: 			// Make ourselves invalid.
1: 			isValid = false;
1: 			/* Clear out the old dependencies on this activation as we
1: 			 * will die shortly.
1: 			 */
1: 			DependencyManager dm =
1: 				lcc.getDataDictionary().getDependencyManager();
1: 			dm.clearDependencies(lcc, this);
1: 
1: 			break;
1: 		case DependencyManager.REVOKE_ROLE:
1: 			// Used by persistent objects (views, triggers, constraints)
1: 			break;
1: 		case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
1: 			// Used to recompile prepared statements
1: 			break;
1: 		default:
1: 			if (SanityManager.DEBUG) {
1: 				SanityManager.DEBUG_PRINT("BaseActivation", "action=" + action);
1: 				SanityManager.NOTREACHED();
1: 			}
1: 		}
1: 
1: 	}
1: 
1: 	/**
0: 	 * @see Dependent#prepareToInvalidate
1: 	 */
1: 	public void prepareToInvalidate(Provider p, int action,
1: 							 LanguageConnectionContext lcc)
1: 			throws StandardException {
1: 	}
commit:6950a39
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.SQLSessionContext;
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * The 'callActivation' of an activation of a statement executing in
1: 	 * the root connection is null.
1: 	 *
0: 	 * A non-null 'callActivation' represents the activation of the
0: 	 * calling statement.
1: 	 *
0: 	 * That is, if we are executing an SQL statement ('this'
0: 	 * activation) inside a stored procedure or function in a nested
0: 	 * connection, then 'callActivation' will be non-null.
1: 	 *
0: 	 * 'callActivation' is set when this activation is created (@see
0: 	 * GenericPreparedStatement#getActivation) based on the top of the
1: 	 * dynamic call stack of execution, which is tracked by
1: 	 * StatementContext. The nested SQL session context is initialized
0: 	 * by code generated for the call, after parsameters are evaluated
0: 	 * @see org.apache.derby.impl.sql.compile.StaticMethodCallNode#generateSetupNestedSessionContext
1: 	 *
1: 	 */
1: 
1: 	/**
0: 	 * The SQL session context of a call is kept here. Also, @see
0: 	 * BaseActivation#callActivation.
1: 
0: 	 * A nested execution maintains its session context,
0: 	 * nestedSQLSessionContext, in the activation of the calling
0: 	 * statement's activation ('this'). While not inside a stored
0: 	 * procedure or function, SQL session state state is held by the
0: 	 * LanguageConnectionContext.
1: 	 */
0: 	private SQLSessionContext nestedSQLSessionContext;
/////////////////////////////////////////////////////////////////////////
0: 	 * Return the current SQL session context for all immediately
0: 	 * nested connections stemming from the call or function
0: 	 * invocation of the statement corresponding to this activation.
0: 	public SQLSessionContext getNestedSQLSessionContext() {
0: 		if (nestedSQLSessionContext == null) {
0: 			nestedSQLSessionContext = lcc.createSQLSessionContext();
1: 		}
1: 
0: 		return nestedSQLSessionContext;
commit:f04dc44
/////////////////////////////////////////////////////////////////////////
0: 	 * @param role The name of the current role
/////////////////////////////////////////////////////////////////////////
0: 	 * @param a The caller's activation
commit:99d7d8b
/////////////////////////////////////////////////////////////////////////
0: 	// Authorization stack frame, cf. SQL 2003 4.31.1.1 and 4.27.3 is
0: 	// implemented as follows: Statements at root connection level
0: 	// (not executed within a stored procedure), maintain the current
0: 	// role in the lcc.  In this case, 'callActivation' is null.  If
0: 	// we are executing SQL inside a stored procedure (nested
0: 	// connection), then 'callActivation' will be non-null, and we
0: 	// maintain the current role in the activation of the calling
0: 	// statement, see 'setNestedCurrentRole'. The current role of a call
0: 	// context is kept in the field 'nestedCurrentRole'.
1: 	//
0: 	// 'callActivation' is set when activation is created (see
0: 	// GenericPreparedStatement#getActivation based on the top of the
0: 	// dynamic call stack of activation, see
0: 	// GenericLanguageConnectionContext#getCaller.
1: 	//
0: 	// Corner case: When a dynamic result set references current role,
0: 	// the value retrieved will always be that of the current role
0: 	// when the statement is executed (inside), not the current value
0: 	// when the result set is accessed outside the stored procedure.
1: 	//
0: 	// Consequence of this implementation: If more than one nested
0: 	// connection is used inside a shared procedure, they will share
0: 	// the current role setting. Since the same dynamic call context
0: 	// is involved, this seems correct.
1: 	//
0: 	private Activation callActivation;
0: 	private String nestedCurrentRole;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * Set the current role name of the dynamic call context stemming
0: 	 * from this activation (which must be a stored
0: 	 * procedure/function call).
1: 	 *
0: 	 * @arg role The name of the current role
1: 	 */
0: 	public void setNestedCurrentRole(String role) {
0: 		nestedCurrentRole = role;
1: 	}
1: 
1: 	/**
0: 	 * Get the current role name of the dynamic call context stemming
0: 	 * from this activation (which must be a stored
0: 	 * procedure/function call).
1: 	 *
0: 	 * @return The name of the current role
1: 	 */
0: 	public String getNestedCurrentRole() {
0: 		return nestedCurrentRole;
1: 	}
1: 
1: 	/**
0: 	 * This activation is created in a dynamic call context, remember
0: 	 * its caller's activation.
1: 	 *
0: 	 * @arg a The caller's activation
1: 	 */
0: 	public void setCallActivation(Activation a) {
0: 		callActivation = a;
1: 	}
1: 
1: 	/**
0: 	 * This activation is created in a dynamic call context, get its
0: 	 * caller's activation.
1: 	 *
0: 	 * @return The caller's activation
1: 	 */
0: 	public Activation getCallActivation() {
0: 		return callActivation;
1: 	}
1: 
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.sanity.SanityManager;
commit:17af76d
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:854dd10
/////////////////////////////////////////////////////////////////////////
1:         Object rlClone = rl.cloneValue(false);
commit:a8bc217
/////////////////////////////////////////////////////////////////////////
1:         }
1:         RowLocation rl = (RowLocation)
1:                 getPreparedStatement().getSavedObject(itemNumber);
1:         /* We have to return a clone of the saved RowLocation due
1:          * to the shared cache of SPSs.
1:          */
0:         Object rlClone = rl.getClone();
1:         if (SanityManager.DEBUG) {
1:             if (! (rlClone instanceof RowLocation))
1:                     "rl.getClone() expected to be " +
1:                     "instance of RowLocation, not " +
1:                     rlClone.getClass().getName() + ", query is " +
1:                     getPreparedStatement().getSource());
1:         return (RowLocation)rlClone;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:b31849d
/////////////////////////////////////////////////////////////////////////
commit:6c000e8
/////////////////////////////////////////////////////////////////////////
1: 	private	LanguageConnectionContext	lcc;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	public final ResultSetFactory getResultSetFactory() {
1: 		return getExecutionFactory().getResultSetFactory();
1: 	public final ExecutionFactory getExecutionFactory() {
1: 		return getLanguageConnectionContext().
1:             getLanguageConnectionFactory().getExecutionFactory();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		return getLanguageConnectionContext().getDataValueFactory();
/////////////////////////////////////////////////////////////////////////
1: 			(ConnectionContext) getContextManager().getContext(ConnectionContext.CONTEXT_ID);
commit:7777dbd
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check that a positioned statement is executing against a cursor
1:      * from the same PreparedStatement (plan) that the positioned
1:      * statement was original compiled against.
1:      * 
1:      * Only called from generated code for positioned UPDATE and DELETE
1:      * statements. See CurrentOfNode.
1:      * 
1:      * @param cursorName Name of the cursor
1:      * @param psName Object name of the PreparedStatement.
1:      * @throws StandardException
1:      */
commit:1e2aae0
/////////////////////////////////////////////////////////////////////////
1: import java.util.Hashtable;
1: import java.util.Vector;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.jdbc.ConnectionContext;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.Context;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.services.loader.GeneratedByteCode;
1: import org.apache.derby.iapi.services.loader.GeneratedClass;
1: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.ParameterValueSet;
1: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.sql.compile.Optimizer;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.sql.execute.CursorActivation;
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.DataValueFactory;
1: import org.apache.derby.iapi.types.NumberDataValue;
1: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.util.ReuseFactory;
commit:f77f36d
/////////////////////////////////////////////////////////////////////////
1: 										0);
/////////////////////////////////////////////////////////////////////////
1: 										0);
/////////////////////////////////////////////////////////////////////////
1: 										0);
commit:7736829
/////////////////////////////////////////////////////////////////////////
1: 				
1: 			
1: 			// Initialize the parameter set to have allocated
1: 			// DataValueDescriptor objects for each parameter.
1: 			if (pvs != null && pvs.getParameterCount() != 0)
1: 				pvs.initialize(ps.getParameterTypes());
1: 
/////////////////////////////////////////////////////////////////////////
1: 		}
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.BaseActivation
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:bff3c2e
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.context.Context;
1: 
1: 
0: import org.apache.derby.iapi.jdbc.ConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.Activation;
1: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.execute.CursorActivation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: import org.apache.derby.iapi.sql.ResultDescription;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.RowLocation;
1: 
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.context.ContextService;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: import org.apache.derby.iapi.services.loader.GeneratedByteCode;
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
1: 
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
1: 
1: import java.sql.Connection;
0: import java.sql.DriverManager;
1: import java.sql.SQLException;
1: import java.sql.SQLWarning;
1: 
1: import java.util.ArrayList;
0: import java.util.Enumeration;
0: import java.util.Vector;
0: import java.util.Hashtable;
1: import java.util.HashSet;
0: import org.apache.derby.iapi.util.ReuseFactory;
1: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
1: 
1: /**
1:  * BaseActivation
1:  * provides the fundamental support we expect all activations to have.
1:  * Doesn't actually implement any of the activation interface,
1:  * expects the subclasses to do that.
1:  */
1: public abstract class BaseActivation implements CursorActivation, GeneratedByteCode
1: 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
0: 	protected ResultSetFactory rsFactory;
0: 	protected ExecutionFactory exFactory;
0: 	protected	DataValueFactory			dvFactory;
0: 	protected	LanguageConnectionContext	lcc;
1: 	protected ContextManager			cm;
0: 	protected /*private*/ ExecutionContext			ec;
1: 
1: 
1: 	protected ExecPreparedStatement preStmt;
1: 	protected ResultSet resultSet;
1: 	protected ResultDescription resultDescription;
1: 	protected boolean closed;
1: 	private String cursorName;
1: 	
1: 	protected int numSubqueries;
1: 
1: 	private boolean singleExecution;
0: 	private boolean inUse;
1: 
1: 	private java.sql.ResultSet targetVTI;
1: 	private SQLWarning warnings;
1: 
1: 	private GeneratedClass gc;	// my Generated class object.
1: 
1: 	private boolean checkRowCounts;
0: 	private HashSet rowCountsCheckedThisExecution = new HashSet(4, 0.9f);
1: 
1: 	private static final long MAX_SQRT = (long) Math.sqrt(Long.MAX_VALUE);
1: 
1: 	// When the row count exceeds this number, we should recompile if
1: 	// the difference in row counts is greater than 10%.  If it's less
1: 	// than this number, we use an entirely different technique to check
1: 	// for recompilation.  See comments below, in informOfRowCount()
1: 	private static final int TEN_PERCENT_THRESHOLD = 400;
1: 
1: 	/* Performance optimization for update/delete - only
1: 	 * open heap ConglomerateController once when doing
1: 	 * index row to base row on search
1: 	 */
1: 	private ConglomerateController  updateHeapCC;
1: 	private ScanController			indexSC;
1: 	private long					indexConglomerateNumber = -1;
1: 
1: 	private TableDescriptor ddlTableDescriptor;
1: 
0: 	private int maxRows = -1;
1: 	private boolean			forCreateTable;
1: 
1: 	private boolean			scrollable;
1: 
1:   	private boolean resultSetHoldability;
1: 
1: 	//beetle 3865: updateable cursor using index.  A way of communication
1: 	//between cursor activation and update activation.
1: 	private CursorResultSet forUpdateIndexScan;
1: 
1: 	//Following three are used for JDBC3.0 auto-generated keys feature.
1: 	//autoGeneratedKeysResultSetMode will be set true if at the time of statement execution,
1: 	//either Statement.RETURN_GENERATED_KEYS was passed or an array of (column positions or
1: 	//column names) was passed
1: 	private boolean autoGeneratedKeysResultSetMode;
1: 	private int[] autoGeneratedKeysColumnIndexes ;
1: 	private String[] autoGeneratedKeysColumnNames ;
1: 
1: 	//Following is the position of the session table names list in savedObjects in compiler context
1: 	//This is updated to be the correct value at cursor generate time if the cursor references any session table names.
1: 	//If the cursor does not reference any session table names, this will stay negative
1: 	protected int indexOfSessionTableNamesInSavedObjects = -1;
1: 
1: 	// WARNING: these fields are accessed by code generated in the 
1: 	// ExpressionClassBuilder: don't change them unless you 
1: 	// make the appropriate changes there.
1: 	protected ExecRow[] row;
1: 	protected ParameterValueSet pvs;
1: 
1: 	//
1: 	// constructors
1: 	//
1: 
1: 	protected BaseActivation()
1: 	{
1: 		super();
1: 	}
1: 
0: 	public final void initFromContext(Context context) {
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(context!=null, "NULL context passed to BaseActivation.initFromContext");
1: 		}
1: 		this.cm = context.getContextManager();
1: 
1: 		lcc = (LanguageConnectionContext) cm.getContext(LanguageConnectionContext.CONTEXT_ID);
1: 
1: 		if (SanityManager.DEBUG) {
1: 			if (lcc == null)
1: 				SanityManager.THROWASSERT("lcc is null in activation type " + getClass());
1: 		}
1: 
0: 		dvFactory = lcc.getDataValueFactory();
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(dvFactory != null,
0: 								 "No data value factory in getDataValueFactory");
1: 		}
1: 
0: 		ec = lcc.getExecutionContext();
1: 
0: 		// look for the execution context and
0: 		// get our result set factory from it.
0: 		rsFactory = ec.getResultSetFactory();
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(rsFactory!=null, "Unable to find ResultSetFactory");
1: 		}
1: 
0: 		exFactory = ec.getExecutionFactory();
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(exFactory!=null, "Unable to find ExecutionFactory");
1: 		}		
1: 
1: 		// mark in use
1: 		inUse = true;
1: 		
1: 		// add this activation to the pool for the connection.
1: 		lcc.addActivation(this);
1: 	}
1: 
1: 
1: 	//
1: 	// Activation interface
1: 	//
1: 
1: 	public final ExecPreparedStatement getPreparedStatement() {
1: 		return preStmt;
1: 	}
1: 
0: 	public ConstantAction getConstantAction() {
0: 		return preStmt.getConstantAction();
1: 	}
1: 
1: 
1: 	public final void checkStatementValidity() throws StandardException {
1: 
0: 		if (preStmt == null)
1: 			return;
1: 
0: 		synchronized (preStmt) {
1: 
0: 			if ((gc == preStmt.getActivationClass()) && preStmt.upToDate())
1: 				return;
1: 		}
1: 
1: 		StandardException se = StandardException.newException(SQLState.LANG_STATEMENT_NEEDS_RECOMPILE);
1: 		se.setReport(StandardException.REPORT_NEVER);
1: 		throw se;
1: 	}
1: 
1: 	/**
0: 		Link this activation with its PreparedStatement.
0: 		It can be called with null to break the link with the
0: 		PreparedStatement.
1: 
1: 	*/
0: 	public final void setupActivation(ExecPreparedStatement ps, boolean scrollable) {
1: 		preStmt = ps;
1: 
1: 		if (ps != null) {
1: 			// get the result set description
1:    			resultDescription = ps.getResultDescription();
1: 			this.scrollable = scrollable;
1: 		} else {
1: 			resultDescription = null;
1: 			this.scrollable = false;
1: 		}
1: 	}
1: 
1: 	public ResultSet getResultSet() {
1: 		return resultSet;
1: 	}
1: 
0: 	public void clearResultSet() {
0: 		resultSet = null;
1: 	}
1: 
1: 	/**
1: 		Get the saved RowLocation.
1: 
1: 		@param itemNumber	The saved item number.
1: 
1: 		@return	A RowLocation template for the conglomerate
1: 	 */
1: 	public RowLocation getRowLocationTemplate(int itemNumber)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(itemNumber >= 0,
1: 				"itemNumber expected to be >= 0");
1: 			if (! (getPreparedStatement().getSavedObject(itemNumber) instanceof RowLocation))
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"getPreparedStatement().getSavedObject(itemNumber) expected to be " +
1: 					"instance of RowLocation, not " +
1: 					getPreparedStatement().getSavedObject(itemNumber).getClass().getName() +
1: 					", query is " + getPreparedStatement().getSource());
1: 			}
0: 			RowLocation rl = (RowLocation) getPreparedStatement().getSavedObject(itemNumber);
0: 			if (! (rl.cloneObject() instanceof RowLocation))
1: 			{
1: 				SanityManager.THROWASSERT(
0: 					"rl.cloneObject() expected to be " +
1: 					"instance of RowLocation, not " +
0: 					rl.getClass().getName() +
1: 					", query is " + getPreparedStatement().getSource());
1: 			}
1: 		}
0: 		/* We have to return a clone of the saved RowLocation due
0: 		 * to the shared cache of SPSs.
1: 		 */
0: 		return (RowLocation)
0: 			((RowLocation)(getPreparedStatement().getSavedObject(itemNumber))).cloneObject();
1: 	}
1: 
1: 	/*
1: 	 */
1: 	public ResultDescription getResultDescription() {
1: 		if (SanityManager.DEBUG)
1: 	    	SanityManager.ASSERT(resultDescription != null, "Must have a result description");
1: 	   	    return resultDescription;
1: 	}
1: 
1: 	/**
1: 		This is a partial implementation of reset.
1: 		Subclasses will want to reset information
1: 		they are aware of, such as parameters.
1: 		<p>
1: 		All subclasses must call super.reset() and
1: 		then do their cleanup.
1: 		<p>
1: 		The execute call must set the resultSet field
1: 		to be the resultSet that it has returned.
1: 
1: 		@exception StandardException on error
1: 	 */
1: 	public void reset() throws StandardException
1: 	{
0: 		// if resultset holdability after commit is false, close it
0: 		if (resultSet != null && (!resultSetHoldability || !resultSet.returnsRows())) {
0: 			// would really like to check if it is open,
0: 			// this is as close as we can approximate that.
0: 			resultSet.close();
0: 			resultSet = null; // forget about it, prepare for next exec.
1: 
1: 		}
1: 		updateHeapCC = null;
1: 		// REMIND: do we need to get them to stop input as well?
1: 
1: 		if (!isSingleExecution())
1: 			clearWarnings();
1: 	}
1: 
1: 	/**
1: 		Closing an activation marks it as unusable. Any other
1: 		requests made on it will fail.  An activation should be
1: 		marked closed when it is expected to not be used any longer,
1: 		i.e. when the connection for it is closed, or it has suffered some
1: 		sort of severe error.
1: 
1: 		This should also remove it from the language connection context.
1: 
1: 		@exception StandardException on error
1: 	 */
1: 	public final void close() throws StandardException 
1: 	{
1: 		if (! closed) {	
1: 			
1: 			// markUnused();
1: 
0: 			// we finish the result set before we call reset
0: 			// because reset will set it to null.
0: 			if (resultSet != null)
1: 			{
0: 				resultSet.finish();
0: 				resultSet = null;
1: 			}
1: 
1: 			// we call reset so that if the actual type of "this"
1: 			// is a subclass of BaseActivation, its cleanup will
1: 			// also happen -- reset in the actual type is called,
1: 			// not reset in BaseActivation.  Subclass reset's
1: 			// are supposed to call super.reset() as well.
1: 			reset(); // get everything related to executing released
1: 
1: 			closed = true;
1: 
0: 			LanguageConnectionContext lcc = getLanguageConnectionContext();
1: 
1: 			lcc.removeActivation(this);
1: 			if (preStmt != null) {
1: 				preStmt.finish(lcc);
1: 				preStmt = null;
1: 			}
1: 
1: 			try {
1: 				closeActivationAction();
1: 			} catch (Throwable e) {
1: 				throw StandardException.plainWrapException(e);
1: 			}
1: 
1: 		}
1: 		
1: 	}
1: 
1: 	/**
0: 		A generated class can create its own closeActivationAction
0: 		method to invoke special logic when the activation is closed.
1: 	*/
1: 	protected void closeActivationAction() throws Exception {
1: 		// no code to be added here as generated code
1: 		// will not call super.closeActivationAction()
1: 	}
1: 
1: 	/**
1: 		Find out if the activation closed or not.
1: 		@return true if the prepared statement has been closed.
1: 	 */
1: 	public boolean isClosed() {
1: 		return closed;
1: 	}
1: 
1: 	/**
1: 		Set this Activation for a single execution.
1: 
1: 		@see Activation#setSingleExecution
1: 	*/
1: 	public void setSingleExecution() {
1: 		singleExecution = true;
1: 	}
1: 
1: 	/**
1: 		Returns true if this Activation is only going to be used for
1: 		one execution.
1: 
1: 		@see Activation#isSingleExecution
1: 	*/
1: 	public boolean isSingleExecution() {
1: 		return singleExecution;
1: 	}
1: 
1: 	/**
1: 		Get the number of subqueries in the entire query.
1: 		@return int	 The number of subqueries in the entire query.
1: 	 */
1: 	public int getNumSubqueries() {
1: 		return numSubqueries;
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#isCursorActivation
1: 	 */
1: 	public boolean isCursorActivation()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	//
1: 	// GeneratedByteCode interface
1: 	//
1: 
1: 	public final void setGC(GeneratedClass gc) {
1: 		this.gc = gc;
1: 	}
1: 
1: 	public final GeneratedClass getGC() {
1: 
1: 		if (SanityManager.DEBUG) {
1: 			if (gc == null)
1: 				SanityManager.THROWASSERT("move code requiring GC to postConstructor() method!!");
1: 		}
1: 		return gc;
1: 	}
1: 
1: 	public final GeneratedMethod getMethod(String methodName) throws StandardException {
1: 
1: 		return getGC().getMethod(methodName);
1: 	}
1: 	public Object e0() throws StandardException { return null; } 
1: 	public Object e1() throws StandardException { return null; }
1: 	public Object e2() throws StandardException { return null; }
1: 	public Object e3() throws StandardException { return null; }
1: 	public Object e4() throws StandardException { return null; } 
1: 	public Object e5() throws StandardException { return null; }
1: 	public Object e6() throws StandardException { return null; }
1: 	public Object e7() throws StandardException { return null; }
1: 	public Object e8() throws StandardException { return null; } 
1: 	public Object e9() throws StandardException { return null; }
1: 
1: 	//
1: 	// class interface
1: 	//
1: 
1: 	/**
1: 	 * Temporary tables can be declared with ON COMMIT DELETE ROWS. But if the table has a held curosr open at
1: 	 * commit time, data should not be deleted from the table. This method, (gets called at commit time) checks if this
1: 	 * activation held cursor and if so, does that cursor reference the passed temp table name.
1: 	 *
1: 	 * @return	true if this activation has held cursor and if it references the passed temp table name
1: 	 */
1: 	public boolean checkIfThisActivationHasHoldCursor(String tableName)
1: 	{
1: 		if (!inUse)
1: 			return false;
1: 
1: 		if (resultSetHoldability == false) //if this activation is not held over commit, do not need to worry about it
1: 			return false;
1: 
1: 		if (indexOfSessionTableNamesInSavedObjects == -1) //if this activation does not refer to session schema tables, do not need to worry about it
1: 			return false;
1: 
1: 		/* is there an open result set? */
1: 		if ((resultSet != null) && !resultSet.isClosed() && resultSet.returnsRows())
1: 		{
1: 			//If we came here, it means this activation is held over commit and it reference session table names
1: 			//Now let's check if it referneces the passed temporary table name which has ON COMMIT DELETE ROWS defined on it.
1: 			return ((ArrayList)getPreparedStatement().getSavedObject(indexOfSessionTableNamesInSavedObjects)).contains(tableName);
1: 		}
1: 
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	   remember the cursor name
1: 	 */
1: 
1: 	public void	setCursorName(String cursorName)
1: 	{
1: 		if (isCursorActivation())
1: 			this.cursorName = cursorName;
1: 	}
1: 
1: 
1: 	/**
1: 	  get the cursor name.  For something that isn't
1: 	  a cursor, this is used as a string name of the
1: 	  result set for messages from things like the
1: 	  dependency manager.
1: 	  <p>
1: 	  Activations that do support cursors will override
1: 	  this.	
1: 	*/
1: 	public String getCursorName() {
1: 
1: 		return isCursorActivation() ? cursorName : null;
1: 	}
1: 
1: 	public void setResultSetHoldability(boolean resultSetHoldability)
1: 	{
1: 		this.resultSetHoldability = resultSetHoldability;
1: 	}
1: 
1: 	public boolean getResultSetHoldability()
1: 	{
1: 		return resultSetHoldability;
1: 	}
1: 
1: 	/** @see Activation#setAutoGeneratedKeysResultsetInfo */
1: 	public void setAutoGeneratedKeysResultsetInfo(int[] columnIndexes, String[] columnNames)
1: 	{
1: 		autoGeneratedKeysResultSetMode = true;
0: 		autoGeneratedKeysColumnIndexes = columnIndexes;
0: 		autoGeneratedKeysColumnNames = columnNames;
1: 	}
1: 
1: 	/** @see Activation#getAutoGeneratedKeysResultsetMode */
1: 	public boolean getAutoGeneratedKeysResultsetMode()
1: 	{
1: 		return autoGeneratedKeysResultSetMode;
1: 	}
1: 
1: 	/** @see Activation#getAutoGeneratedKeysColumnIndexes */
1: 	public int[] getAutoGeneratedKeysColumnIndexes()
1: 	{
0: 		return autoGeneratedKeysColumnIndexes;
1: 	}
1: 
1: 	/** @see Activation#getAutoGeneratedKeysColumnNames */
1: 	public String[] getAutoGeneratedKeysColumnNames()
1: 	{
0: 		return autoGeneratedKeysColumnNames;
1: 	}
1: 
1: 	//
1: 	// class implementation
1: 	//
1: 
1: 
1: 	/**
1: 		Used in the execute method of activations for
1: 		generating the result sets that they concatenate together.
1: 	 */
0: 	public ResultSetFactory getResultSetFactory() {
0: 		return rsFactory;
1: 	}
1: 
1: 	/**
1: 		Used in activations for generating rows.
1: 	 */
0: 	public ExecutionFactory getExecutionFactory() {
0: 		return exFactory;
1: 	}
1: 
1: 
1: 	/**
1: 		Used in CurrentOfResultSet to get to the target result set
1: 		for a cursor. Overridden by activations generated for
1: 		updatable cursors.  Those activations capture the target
1: 		result set in a field in their execute() method, and then
1: 		return the value of that field in their version of this method.
1: 
1: 		@return null.
1: 	 */
1: 	public CursorResultSet getTargetResultSet() {
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.THROWASSERT("Must be overridden to be used.");
1: 		return null;
1: 	}
1: 
1: 	/*
1: 	 * Called by generated code to compute the next autoincrement value.
1: 	 * 
1: 	 * @return The next autoincrement value which should be inserted.
1: 	 * returns the correct number datatype.
1: 	 */
1: 	protected DataValueDescriptor 
1: 		getSetAutoincrementValue(int columnPosition, long increment)
1: 	       throws StandardException
1: 	{
1: 		DataValueDescriptor l =
0: 			((InsertResultSet)resultSet).getSetAutoincrementValue(columnPosition, increment);
1: 		return l;
1: 
1: 	}
1: 
1: 	/**
1: 		Used in CurrentOfResultSet to get to the cursor result set
1: 		for a cursor.  Overridden by activations generated for
1: 		updatable cursors.  Those activations capture the cursor
1: 		result set in a field in their execute() method, and then
1: 		return the value of that field in their version of this method.
1: 
1: 		@return null
1: 	 */
1: 	public CursorResultSet getCursorResultSet() {
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.THROWASSERT("Must be overridden to be used.");
1: 		return null;
1: 	}
1: 
1: 	/**
1: 		Various activation methods need to disallow their
1: 		invocation if the activation is closed. This lets them
1: 		check and throw without generating alot of code.
1: 		<p>
1: 		The code to write to generate the call to this is approximately:
1: 		<verbatim>
1: 			// jf is a JavaFactory
1: 			CallableExpression ce = jf.newMethodCall(
1: 				jf.thisExpression(),
1: 				BaseActivation.CLASS_NAME,
1: 				"throwIfClosed",
1: 				"void",
1: 				acb.exprArray(jf.newStringLiteral(...some literal here...)));
1: 
1: 			//mb is a MethodBuilder
1: 			mb.addStatement(jf.newStatement(ce));
1: 		</verbatim>
1: 		The java code to write to call this is:
1: 		<verbatim>
1: 			this.throwIfClosed(...some literal here...);
1: 		</verbatim>
1: 		In both cases, "...some literal here..." gets replaced with
1: 		an expression of type String that evaluates to the name
1: 		of the operation that is being checked, like "execute" or
1: 		"reset".
1: 
1: 		@exception StandardException thrown if closed
1: 	 */
1: 	public void throwIfClosed(String op) throws StandardException {
1: 		if (closed)
1: 			throw StandardException.newException(SQLState.LANG_ACTIVATION_CLOSED, op);
1: 	}
1: 
1: 	/**
1: 	 * Set a column position in an array of column positions.
1: 	 *
1: 	 * @param columnPositions	The array of column positions
1: 	 * @param positionToSet		The place to put the column position
1: 	 * @param column			The column position
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 	public static void setColumnPosition(
1: 							int[] columnPositions,
1: 							int positionToSet,
1: 							int column)
1: 	{
1: 		columnPositions[positionToSet] = column;
1: 	}
1: 
1: 	/**
1: 	 * Allocate an array of qualifiers and initialize in Qualifier[][]
1: 	 *
1: 	 * @param qualifiers	The array of Qualifier arrays.
1: 	 * @param position		The position in the array to set
1: 	 * @param length		The array length of the qualifier array to allocate.
1: 	 */
1: 	public static void allocateQualArray(
1:     Qualifier[][]   qualifiers,
1:     int             position,
1:     int             length)
1: 	{
1:         qualifiers[position] = new Qualifier[length];
1: 	}
1: 
1: 
1: 	/**
1: 	 * Set a Qualifier in a 2 dimensional array of Qualifiers.
1:      *
1:      * Set a single Qualifier into one slot of a 2 dimensional array of 
1:      * Qualifiers.  @see Qualifier for detailed description of layout of
1:      * the 2-d array.
1: 	 *
1: 	 * @param qualifiers	The array of Qualifiers
1: 	 * @param qualifier		The Qualifier
1: 	 * @param position_1    The Nth array index into qualifiers[N][M]
1: 	 * @param position_1    The Nth array index into qualifiers[N][M]
1: 	 */
1: 	public static void setQualifier(
1:     Qualifier[][]   qualifiers,
1:     Qualifier	    qualifier,
1:     int			    position_1,
1:     int             position_2)
1: 	{
1: 		qualifiers[position_1][position_2] = qualifier;
1: 	}
1: 
1: 	/**
1: 	 * Reinitialize all Qualifiers in an array of Qualifiers.
1: 	 *
1: 	 * @param qualifiers	The array of Qualifiers
1: 	 */
1: 	public static void reinitializeQualifiers(Qualifier[][] qualifiers)
1: 	{
1: 		if (qualifiers != null)
1: 		{
1:             for (int term = 0; term < qualifiers.length; term++)
1:             {
1:                 for (int i = 0; i < qualifiers[term].length; i++)
1:                 {
1:                     qualifiers[term][i].reinitialize();
1:                 }
1:             }
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Mark the activation as unused.  
1: 	 */
1: 	public final void markUnused()
1: 	{
0: 		inUse = false;
1: 	}
1: 
1: 	/**
1: 	 * Is the activation in use?
1: 	 *
1: 	 * @return true/false
1: 	 */
1: 	public final boolean isInUse()
1: 	{
1: 		return inUse;
1: 	}
1: 
1: 	/**
1: 	  @see org.apache.derby.iapi.sql.Activation#addWarning
1: 	  */
1: 	public void addWarning(SQLWarning w)
1: 	{
1: 		if (warnings == null)
1: 			warnings = w;
1: 		else
1: 			warnings.setNextWarning(w);
1: 	}
1: 
1: 	/**
1: 	  @see org.apache.derby.iapi.sql.Activation#getWarnings
1: 	  */
1: 	public SQLWarning getWarnings()
1: 	{
1: 		return warnings;
1: 	}
1: 
1: 	/**
1: 	  @see org.apache.derby.iapi.sql.Activation#clearWarnings
1: 	  */
1: 	public void clearWarnings()
1: 	{
1: 		warnings = null;
1: 	}
1: 
1: 	/**
1: 	 * @exception StandardException on error
1: 	 */
1: 	protected static void nullToPrimitiveTest(DataValueDescriptor dvd, String primitiveType)
1: 		throws StandardException
1: 	{
1: 		if (dvd.isNull())
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_NULL_TO_PRIMITIVE_PARAMETER, primitiveType);
1: 		}
1: 	}
1: 
1: 	/**
1: 		@see Activation#informOfRowCount
1: 		@exception StandardException	Thrown on error
1: 	 */
1: 	public void informOfRowCount(NoPutResultSet resultSet, long currentRowCount)
1: 					throws StandardException
1: 	{
1: 
1: 		/* Do we want to check the row counts during this execution? */
1: 		if (checkRowCounts)
1: 		{
1: 			boolean significantChange = false;
1: 
1: 			int resultSetNumber = resultSet.resultSetNumber();
0: 			Integer rsn = ReuseFactory.getInteger(resultSetNumber);
1: 
1: 			/* Check each result set only once per execution */
0: 			if (rowCountsCheckedThisExecution.add(rsn))
1: 			{
0: 				synchronized (getPreparedStatement())
1: 				{
0: 					Vector rowCountCheckVector = getRowCountCheckVector();
1: 
0: 					if (rowCountCheckVector == null) {
0: 						rowCountCheckVector = new Vector();
0: 						setRowCountCheckVector(rowCountCheckVector);
1: 					}
1: 
0: 					Long firstRowCount = null;
1: 
1: 					/*
0: 					** Check whether this resultSet has been seen yet.
1: 					*/
0: 					if (resultSetNumber < rowCountCheckVector.size())
1: 					{
0: 						firstRowCount =
0: 							(Long) rowCountCheckVector.elementAt(resultSetNumber);
1: 					}
1: 					else
1: 					{
0: 						rowCountCheckVector.setSize(resultSetNumber + 1);
1: 					}
1: 
0: 					if (firstRowCount != null)
1: 					{
1: 						/*
0: 						** This ResultSet has been seen - has the row count
0: 						** changed significantly?
1: 						*/
0: 						long n1 = firstRowCount.longValue();
1: 
0: 						if (currentRowCount != n1)
1: 						{
0: 							if (n1 >= TEN_PERCENT_THRESHOLD)
1: 							{
1: 								/*
0: 								** For tables with more than
0: 								** TEN_PERCENT_THRESHOLD rows, the
0: 								** threshold is 10% of the size of the table.
1: 								*/
0: 								long changeFactor = n1 / (currentRowCount - n1);
0: 								if (Math.abs(changeFactor) <= 10)
0: 									significantChange = true;
1: 							}
1: 							else
1: 							{
1: 								/*
0: 								** For tables with less than
0: 								** TEN_PERCENT_THRESHOLD rows, the threshold
0: 								** is non-linear.  This is because we want
0: 								** recompilation to happen sooner for small
0: 								** tables that change size.  This formula
0: 								** is for a second-order equation (a parabola).
0: 								** The derivation is:
0: 								**
0: 								**   c * n1 = (difference in row counts) ** 2
0: 								**				- or - 
0: 								**   c * n1 = (currentRowCount - n1) ** 2
0: 								**
0: 								** Solving this for currentRowCount, we get:
0: 								**
0: 								**   currentRowCount = n1 + sqrt(c * n1)
0: 								**
0: 								**				- or -
0: 								**
0: 								**   difference in row counts = sqrt(c * n1)
0: 								**
0: 								**				- or -
0: 								**
0: 								**   (difference in row counts) ** 2 =
0: 								**					c * n1
0: 								**
0: 								** Which means that we should recompile when
0: 								** the current row count exceeds n1 (the first
0: 								** row count) by sqrt(c * n1), or when the
0: 								** square of the difference exceeds c * n1.
0: 								** A good value for c seems to be 4.
0: 								**
0: 								** We don't use this formula when c is greater
0: 								** than TEN_PERCENT_THRESHOLD because we never
0: 								** want to recompile unless the number of rows
0: 								** changes by more than 10%, and this formula
0: 								** is more sensitive than that for values of
0: 								** n1 greater than TEN_PERCENT_THRESHOLD.
1: 								*/
0: 								long changediff = currentRowCount - n1;
1: 
1: 								/*
0: 								** Square changediff rather than take the square
0: 								** root of (4 * n1), because multiplying is
0: 								** faster than taking a square root.  Also,
0: 								** check to be sure that squaring changediff
0: 								** will not cause an overflow by comparing it
0: 								** with the square root of the maximum value
0: 								** for a long (this square root is taken only
0: 								** once, when the class is loaded, or during
0: 								** compilation if the compiler is smart enough).
1: 								*/
0: 								if (Math.abs(changediff) <= MAX_SQRT)
1: 								{
0: 									if ((changediff * changediff) >
0: 															Math.abs(4 * n1))
1: 									{
0: 										significantChange = true;
1: 									}
1: 								}
1: 							}
1: 						}
1: 					}
1: 					else
1: 					{
0: 						firstRowCount = new Long(currentRowCount);
0: 						rowCountCheckVector.setElementAt(
0: 														firstRowCount,
0: 														resultSetNumber
1: 														);
1: 
1: 					}
1: 				}
1: 			}
1: 
1: 			/* Invalidate outside of the critical section */
1: 			if (significantChange)
1: 			{
1: 				preStmt.makeInvalid(DependencyManager.INTERNAL_RECOMPILE_REQUEST, lcc);
1: 			}
1: 		}
1: 
1: 	}
1: 
1: 	/**
0: 	 * The subclass calls this method when it begins an execution.
1: 	 *
0: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void startExecution() throws StandardException
1: 	{
0: 		// determine if we should check row counts during this execution
0: 		shouldWeCheckRowCounts();
1: 
0: 		// If we are to check row counts, clear the hash table of row counts
0: 		// we have checked.
1: 		if (checkRowCounts)
0: 			rowCountsCheckedThisExecution.clear();
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getHeapConglomerateController
1: 	 */
1: 	public ConglomerateController getHeapConglomerateController()
1: 	{
1: 		return updateHeapCC;
1: 	}
1: 
1: 
1: 	/**
1: 	 * @see Activation#setHeapConglomerateController
1: 	 */
1: 	public void setHeapConglomerateController(ConglomerateController updateHeapCC)
1: 	{
1: 		this.updateHeapCC = updateHeapCC;
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#clearHeapConglomerateController
1: 	 */
1: 	public void clearHeapConglomerateController()
1: 	{
1: 		updateHeapCC = null;
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getIndexScanController
1: 	 */
1: 	public ScanController getIndexScanController()
1: 	{
1: 		return indexSC;
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#setIndexScanController
1: 	 */
1: 	public void setIndexScanController(ScanController indexSC)
1: 	{
1: 		this.indexSC = indexSC;
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getIndexConglomerateNumber
1: 	 */
1: 	public long getIndexConglomerateNumber()
1: 	{
1: 		return indexConglomerateNumber;
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#setIndexConglomerateNumber
1: 	 */
1: 	public void setIndexConglomerateNumber(long indexConglomerateNumber)
1: 	{
1: 		this.indexConglomerateNumber = indexConglomerateNumber;
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#clearIndexScanInfo
1: 	 */
1: 	public void clearIndexScanInfo()
1: 	{
1: 		indexSC = null;
1: 		indexConglomerateNumber = -1;
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#setForCreateTable()
1: 	 */
1: 	public void setForCreateTable()
1: 	{
1: 		forCreateTable = true;
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getForCreateTable()
1: 	 */
1: 	public boolean getForCreateTable()
1: 	{
1: 		return forCreateTable;
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#setDDLTableDescriptor
1: 	 */
1: 	public void setDDLTableDescriptor(TableDescriptor td)
1: 	{
1: 		ddlTableDescriptor = td;
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getDDLTableDescriptor
1: 	 */
1: 	public TableDescriptor getDDLTableDescriptor()
1: 	{
1: 		return ddlTableDescriptor;
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#setMaxRows
1: 	 */
0: 	public void setMaxRows(int maxRows)
1: 	{
1: 		this.maxRows = maxRows;
1: 	}
1: 
1: 	/**
1: 	 * @see Activation#getMaxRows
1: 	 */
0: 	public int getMaxRows()
1: 	{
1: 		return maxRows;
1: 	}
1: 
1: 	public void setTargetVTI(java.sql.ResultSet targetVTI)
1: 	{
1: 		this.targetVTI = targetVTI;
1: 	}
1: 
1: 	public java.sql.ResultSet getTargetVTI()
1: 	{
1: 		return targetVTI;
1: 	}
1: 
0: 	private void shouldWeCheckRowCounts() throws StandardException
1: 	{
1: 		/*
1: 		** Check the row count only every N executions.  OK to check this
1: 		** without synchronization, since the value of this number is not
1: 		** critical.  The value of N is determined by the property
1: 		** derby.language.stalePlanCheckInterval.
1: 		*/
0: 		int executionCount = getExecutionCount() + 1;
1: 
1: 		/*
1: 		** Always check row counts the first time, to establish the
1: 		** row counts for each result set.  After that, don't check
1: 		** if the execution count is below the minimum row count check
1: 		** interval.  This saves us from checking a database property
1: 		** when we don't have to (checking involves querying the store,
1: 		** which can be expensive).
1: 		*/
1: 
1: 		if (executionCount == 1)
1: 		{
0: 			checkRowCounts = true;
1: 		}
1: 		else if (executionCount <
1: 								Property.MIN_LANGUAGE_STALE_PLAN_CHECK_INTERVAL)
1: 		{
0: 			checkRowCounts = false;
1: 		}
1: 		else
1: 		{
0: 			int stalePlanCheckInterval = getStalePlanCheckInterval();
1: 
1: 			/*
1: 			** Only query the database property once.  We can tell because
1: 			** the minimum value of the property is greater than zero.
1: 			*/
1: 			if (stalePlanCheckInterval == 0)
1: 			{
1: 				TransactionController tc = getTransactionController();
1: 
1: 				stalePlanCheckInterval =
1: 						PropertyUtil.getServiceInt(
1: 							tc,
1: 							Property.LANGUAGE_STALE_PLAN_CHECK_INTERVAL,
1: 							Property.MIN_LANGUAGE_STALE_PLAN_CHECK_INTERVAL,
1: 							Integer.MAX_VALUE,
1: 							Property.DEFAULT_LANGUAGE_STALE_PLAN_CHECK_INTERVAL
1: 							);
0: 				setStalePlanCheckInterval(stalePlanCheckInterval);
1: 			}
1: 
0: 			checkRowCounts = (executionCount % stalePlanCheckInterval) == 1;
1: 
1: 
1: 		}
1: 
0: 		setExecutionCount(executionCount);
1: 	}
1: 
1: 	/*
0: 	** These accessor methods are provided by the sub-class to help figure
0: 	** out whether to check row counts during this execution.
1: 	*/
0: 	abstract protected int getExecutionCount();
1: 
0: 	abstract protected void setExecutionCount(int newValue); 
1: 
1: 	/*
0: 	** These accessor methods are provided by the sub-class to help figure
0: 	** out whether the row count for a particular result set has changed
0: 	** enough to force recompilation.
1: 	*/
0: 	abstract protected Vector getRowCountCheckVector();
1: 
0: 	abstract protected void setRowCountCheckVector(Vector newValue);
1: 
1: 	/*
0: 	** These accessor methods are provided by the sub-class to remember the
0: 	** value of the stale plan check interval property, so that we only
0: 	** have to query the database properties once (there is heavyweight
0: 	** synchronization around the database properties).
1: 	*/
0: 	abstract protected int getStalePlanCheckInterval();
1: 
0: 	abstract protected void setStalePlanCheckInterval(int newValue);
1: 
1: 	public final boolean getScrollable() {
1: 		return scrollable;
1: 	}
1: 
1: 	protected final void setParameterValueSet(int paramCount, boolean hasReturnParam) {
1: 
1: 		pvs = lcc.getLanguageFactory().newParameterValueSet(
1: 			lcc.getLanguageConnectionFactory().getClassFactory().getClassInspector(),
1: 			paramCount, hasReturnParam);
1: 	}
1: 
1: 	/**
1: 	 return the parameters.
1: 	 */
1: 	public ParameterValueSet	getParameterValueSet() 
1: 	{ 
1: 		if (pvs == null)
1: 			setParameterValueSet(0, false); 
1: 		return pvs; 
1: 	}
1: 
1: 	// how do we do/do we want any sanity checking for
1: 	// the number of parameters expected?
1: 	public void	setParameters(ParameterValueSet parameterValues, DataTypeDescriptor[] parameterTypes) throws StandardException
1: 	{
1: 		if (!isClosed())
1: 		{
1: 
1: 			if (this.pvs == null || parameterTypes == null) {
1: 				pvs = parameterValues;
1: 				return;
1: 
1: 			}
1: 
1: 			DataTypeDescriptor[]	newParamTypes = preStmt.getParameterTypes();
1: 
1: 			/*
1: 			** If there are old parameters but not new ones,
1: 			** they aren't compatible.
1: 			*/
1: 			boolean match = false;
1: 			if (newParamTypes != null) {
1: 
1: 				if (newParamTypes.length == parameterTypes.length) {
1: 
1: 					/* Check each parameter */
1: 					match = true;
1: 					for (int i = 0; i < parameterTypes.length; i++)
1: 					{
1: 						DataTypeDescriptor	oldType = parameterTypes[i];
1: 						DataTypeDescriptor	newType	= newParamTypes[i];
1: 
1: 						if (!oldType.isExactTypeAndLengthMatch(newType)) {
1: 							match = false;
1: 							break;
1: 						}
1: 						/*
1: 						** We could probably get away without checking nullability,
1: 						** since parameters are always nullable.
1: 						*/
1: 						if (oldType.isNullable() != newType.isNullable()) {
1: 							match = false;
1: 							break;
1: 						}
1: 					}
1: 				}
1: 
1: 			}
1: 
1: 			if (!match)
1: 				throw StandardException.newException(SQLState.LANG_OBSOLETE_PARAMETERS);
1: 
1: 
1: 			parameterValues.transferDataValues(pvs);
1: 
1: 		}
1: 		else if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT("isClosed() is expected to return false");
1: 		}
1: 	}
1: 
1: 	/**
1: 	 	Throw an exception if any parameters are uninitialized.
1: 
0: 		@return		Nothing
1: 
1: 		@exception StandardException	Thrown if any parameters
1: 												are unitialized
1: 	 */
1: 
1: 	public void throwIfMissingParms() throws StandardException
1: 	{
1: 		if (pvs != null && !pvs.allAreSet())
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_MISSING_PARMS);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Remember the row for the specified ResultSet.
1: 	 */
1: 	public void setCurrentRow(ExecRow currentRow, int resultSetNumber)
1: 	{ 
1: 		if (SanityManager.DEBUG) 
1: 		{
1: 			SanityManager.ASSERT(!isClosed(), "closed");
1: 			if (row != null)
1: 			{
1: 				if (!(resultSetNumber >=0 && resultSetNumber < row.length))
1: 				{
1: 					SanityManager.THROWASSERT("resultSetNumber = " + resultSetNumber +
1: 								 ", expected to be between 0 and " + row.length);
1: 				}
1: 			}
1: 		}
1: 		if (row != null)
1: 		{
1: 			row[resultSetNumber] = currentRow;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Clear the current row for the specified ResultSet.
1: 	 */
1: 	public void clearCurrentRow(int resultSetNumber)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (row != null)
1: 			{
1: 				if (!(resultSetNumber >=0 && resultSetNumber < row.length))
1: 				{
1: 					SanityManager.THROWASSERT("resultSetNumber = " + resultSetNumber +
1: 								 ", expected to be between 0 and " + row.length);
1: 				}
1: 			}
1: 		}
1: 		if (row != null)
1: 		{
1: 			row[resultSetNumber] = null;
1: 		}
1: 	}
1: 
1: 	protected final DataValueDescriptor getColumnFromRow(int rsNumber, int colId)
1: 		throws StandardException {
1: 
0:         if( row[rsNumber] == null)
1:         {
0:             /* This actually happens. NoPutResultSetImpl.clearOrderableCache attempts to prefetch invariant values
0:              * into a cache. This fails in some deeply nested joins. See Beetle 4736 and 4880.
1:              */
1:             return null;
1:         }
0: 		return row[rsNumber].getColumn(colId);
1: 	}
1: 
1: 	protected void checkPositionedStatement(String cursorName, String psName)
1: 		throws StandardException {
1: 
1: 		ExecPreparedStatement ps = getPreparedStatement();
1: 		if (ps == null)
1: 			return;
1: 			
0: 		LanguageConnectionContext lcc = getLanguageConnectionContext();
1: 
1: 		CursorActivation cursorActivation = lcc.lookupCursorActivation(cursorName);
1: 
1: 		if (cursorActivation != null)
1: 		{
1: 			// check we are compiled against the correct cursor
1: 			if (!psName.equals(cursorActivation.getPreparedStatement().getObjectName())) {
1: 
1: 				// our prepared statement is now invalid since there
1: 				// exists another cursor with the same name but a different
1: 				// statement.
1: 				ps.makeInvalid(DependencyManager.CHANGED_CURSOR, lcc);
1: 			}
1: 		}
1: 	}
1: 
1: 	/* This method is used to materialize a resultset if can actually fit in the memory
1: 	 * specified by "maxMemoryPerTable" system property.  It converts the result set into
1: 	 * union(union(union...(union(row, row), row), ...row), row).  It returns this
1: 	 * in-memory converted resultset, or the original result set if not converted.
1: 	 * See beetle 4373 for details.
1: 	 *
1: 	 *	@param	rs	input result set
1: 	 *	@return	materialized resultset, or original rs if it can't be materialized
1: 	 */
1: 	public NoPutResultSet materializeResultSetIfPossible(NoPutResultSet rs)
1: 		throws StandardException
1: 	{
1: 		rs.openCore();
0: 		Vector rowCache = new Vector();
1: 		ExecRow aRow;
1: 		int cacheSize = 0;
1: 		FormatableBitSet toClone = null;
1: 
1: 		int maxMemoryPerTable = getLanguageConnectionContext().getOptimizerFactory().getMaxMemoryPerTable();
1: 
1: 		aRow = rs.getNextRowCore();
1: 		if (aRow != null)
1: 		{
1: 			toClone = new FormatableBitSet(aRow.nColumns() + 1);
1: 			toClone.set(1);
1: 		}
1: 		while (aRow != null)
1: 		{
1: 			cacheSize += aRow.getColumn(1).getLength();
0: 			if (cacheSize > maxMemoryPerTable)
1: 				break;
1: 			rowCache.addElement(aRow.getClone(toClone));
1: 			aRow = rs.getNextRowCore();
1: 		}
1: 		rs.close();
1: 
1: 		if (aRow == null)
1: 		{
1: 			int rsNum = rs.resultSetNumber();
1: 
1: 			int numRows = rowCache.size();
1: 			if (numRows == 0)
1: 			{
1: 				return new RowResultSet(
1: 										this,
1: 										(ExecRow) null,
1: 										true,
1: 										rsNum,
1: 										0,
1: 										0,
0: 										null);
1: 			}
1: 			RowResultSet[] rrs = new RowResultSet[numRows];
1: 			UnionResultSet[] urs = new UnionResultSet[numRows - 1];
1: 
1: 			for (int i = 0; i < numRows; i++)
1: 			{
1: 				rrs[i] = new RowResultSet(
1: 										this,
0: 										(ExecRow) rowCache.elementAt(i),
1: 										true,
1: 										rsNum,
1: 										1,
1: 										0,
0: 										null);
1: 				if (i > 0)
1: 				{
1: 					urs[i - 1] = new UnionResultSet (
1: 										(i > 1) ? (NoPutResultSet)urs[i - 2] : (NoPutResultSet)rrs[0],
1: 										rrs[i],
1: 										this,
1: 										rsNum,
1: 										i + 1,
1: 										0,
0: 										null);
1: 				}
1: 			}
1: 
1: 			rs.finish();
1: 
1: 			if (numRows == 1)
1: 				return rrs[0];
1: 			else
1: 				return urs[urs.length - 1];
1: 		}
1: 		return rs;
1: 	}
1: 
1: 
1: 
1: 	//WARNING : this field name is referred in the DeleteNode generate routines.
1: 	protected CursorResultSet[] raParentResultSets;
1: 
1: 
1: 	// maintain hash table of parent result set vector
1: 	// a table can have more than one parent source.
0: 	protected Hashtable parentResultSets;
0: 	public void setParentResultSet(TemporaryRowHolder rs, String resultSetId)
1: 	{
0: 		Vector  rsVector;
1: 		if(parentResultSets == null)
0: 			parentResultSets = new Hashtable();
0: 		rsVector = (Vector) parentResultSets.get(resultSetId);
1: 		if(rsVector == null)
1: 		{
0: 			rsVector = new Vector();
1: 			rsVector.addElement(rs);
1: 		}else
1: 		{
1: 			rsVector.addElement(rs);
1: 		}
1: 		parentResultSets.put(resultSetId , rsVector);
1: 	}
1: 
1: 	/**
1: 	 * get the reference to parent table ResultSets, that will be needed by the 
1: 	 * referential action dependent table scans.
1: 	 */
0: 	public Vector getParentResultSet(String resultSetId)
1: 	{
0: 		return (Vector) parentResultSets.get(resultSetId);
1: 	}
1: 
0: 	public Hashtable getParentResultSets()
1: 	{
0: 		return parentResultSets;
1: 	}
1: 
1: 	/**
1: 	 ** prepared statement use the same activation for
1: 	 ** multiple execution. For each excution we create new
1: 	 ** set of temporary resultsets, we should clear this hash table.
1: 	 ** otherwise we will refer to the released resources.
1: 	 */
1: 	public void clearParentResultSets()
1: 	{
1: 		if(parentResultSets != null)
1: 			parentResultSets.clear();
1: 	}
1: 
1: 	/**
1: 	 * beetle 3865: updateable cursor using index.  A way of communication
1: 	 * between cursor activation and update activation.
1: 	 */
1: 	public void setForUpdateIndexScan(CursorResultSet forUpdateIndexScan)
1: 	{
1: 		this.forUpdateIndexScan = forUpdateIndexScan;
1: 	}
1: 
1: 	public CursorResultSet getForUpdateIndexScan()
1: 	{
1: 		return forUpdateIndexScan;
1: 	}
1: 
1: 	private java.util.Calendar cal;
1: 	/**
1: 		Return a calendar for use by this activation.
1: 		Calendar objects are not thread safe, the one returned
1: 		is purely for use by this activation and it is assumed
1: 		that is it single threded through the single active
1: 		thread in a connection model.
1: 	*/
1: 	protected java.util.Calendar getCalendar() {
1: 		if (cal == null)
1: 			cal = new java.util.GregorianCalendar();
1: 		return cal;
1: 
1: 	}
1: 
1: 
1: 	/*
1: 	** Code originally in the parent class BaseExpressionActivation
1: 	*/
1: 	/**
1: 	    Get the language connection factory associated with this connection
1: 	  */
1: 	public final LanguageConnectionContext	getLanguageConnectionContext()
1: 	{
1: 		return	lcc;
1: 	}
1: 
1: 	public final TransactionController getTransactionController()
1: 	{
1: 		return lcc.getTransactionExecute();
1: 	}
1: 			
1: 	/**
0: 	 * Get the ExecutionContext.
1: 	 */
0: 	ExecutionContext getExecutionContext()
1: 	{
0: 		return ec;
1: 	}
1: 
1: 	/**
1: 	 * Get the Current ContextManager.
1: 	 *
1: 	 * @return Current ContextManager
1: 	 */
1: 	public ContextManager getContextManager()
1: 	{
1: 		return cm;
1: 	}
1: 
1: 	/**
1: 		Used by activations to generate data values.  Most DML statements
1: 		will use this method.  Possibly some DDL statements will, as well.
1: 	 */
1: 	public DataValueFactory getDataValueFactory()
1: 	{
0: 		return dvFactory;
1: 	}
1: 
1: 	/**
1: 	 * Used to get a proxy for the current connection.
1: 	 *
1: 	 * @exception SQLException		Thrown on failure to get connection
1: 	 */
1: 	public Connection getCurrentConnection() throws SQLException {
1: 
1: 		ConnectionContext cc = 
0: 			(ConnectionContext) cm.getContext(ConnectionContext.CONTEXT_ID);
1: 
1: 		return cc.getNestedConnection(true);
1: 	}	
1: 
1: 	/**
1: 		Real implementations of this method are provided by a generated class.
1: 	*/
1: 	public java.sql.ResultSet[][] getDynamicResults() {
1: 		return null;
1: 	}
1: 	/**
1: 		Real implementations of this method are provided by a generated class.
1: 	*/
1: 	public int getMaxDynamicResults() {
1: 		return 0;
1: 	}
1: 
1:     /**
1:      * Compute the DB2 compatible length of a value.
1:      *
1:      * @param value
1:      * @param constantLength The length, if it is a constant modulo null/not null. -1 if the length is not constant
1:      * @param reUse If non-null then re-use this as a container for the length
1:      *
1:      * @return the DB2 compatible length, set to null if value is null.
1:      */
1:     public NumberDataValue getDB2Length( DataValueDescriptor value,
1:                                          int constantLength,
1:                                          NumberDataValue reUse)
1:         throws StandardException
1:     {
1:         if( reUse == null)
1:             reUse = getDataValueFactory().getNullInteger( null);
1:         if( value.isNull())
1:             reUse.setToNull();
1:         else
1:         {
1:             if( constantLength >= 0)
1:                 reUse.setValue( constantLength);
1:             else
1:             {
1:                 reUse.setValue(value.getLength());
1:             }
1:         }
1:         return reUse;
1:     } // end of getDB2Length
1: }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:f18825a
/////////////////////////////////////////////////////////////////////////
1: 	 * Optimization implemented as part of Beetle: 4373 can cause severe stack overflow
1: 	 * problems. See JIRA entry DERBY-634. With default MAX_MEMORY_PER_TABLE of 1MG, it is
1: 	 * possible that this optimization could attempt to cache upto 250K rows as nested
1: 	 * union results. At runtime, this would cause stack overflow.
0: 	 *
1: 	 * As Jeff mentioned in DERBY-634, right way to optimize original problem would have been
1: 	 * to address subquery materialization during optimization phase, through hash joins.
1: 	 * Recent Army's optimizer work through DEBRY-781 and related work introduced a way to
1: 	 * materialize subquery results correctly and needs to be extended to cover this case.
1: 	 * While his optimization needs to be made more generic and stable, I propose to avoid
1: 	 * this regression by limiting size of the materialized resultset created here to be
1: 	 * less than MAX_MEMORY_PER_TABLE and MAX_DYNAMIC_MATERIALIZED_ROWS.
0: 	 *
/////////////////////////////////////////////////////////////////////////
1: 			if (cacheSize > maxMemoryPerTable ||
1: 					rowCache.size() > Optimizer.MAX_DYNAMIC_MATERIALIZED_ROWS)
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param position_2    The Nth array index into qualifiers[N][M]
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:9634cd2
/////////////////////////////////////////////////////////////////////////
0: 		if (resultSet != null) {
0: 			if (!resultSetHoldability || !resultSet.returnsRows()) {			
0: 				// would really like to check if it is open,
0: 				// this is as close as we can approximate that.
0: 				resultSet.close();
0: 				resultSet = null; // forget about it, prepare for next exec.
0: 			} else if (resultSet.returnsRows()) {
0: 				resultSet.clearCurrentRow();
0: 			}
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:7ab414c
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	/**
1: 	 * This method can help reduce the amount of generated code by changing
1: 	 * instances of this.pvs.getParameter(position) to this.getParameter(position) 
1: 	 * @param position
0: 	 * @return
1: 	 * @throws StandardException
0: 	 */
1: 	protected final DataValueDescriptor getParameter(int position) throws StandardException { 
1: 		return pvs.getParameter(position); 
0: 		} 
0: 	
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.context.Context;
0: 
0: 
0: import org.apache.derby.iapi.jdbc.ConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.execute.CursorActivation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.ResultSetFactory;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: import org.apache.derby.iapi.services.loader.GeneratedByteCode;
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: 
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
0: 
0: import java.sql.Connection;
0: import java.sql.DriverManager;
0: import java.sql.SQLException;
0: import java.sql.SQLWarning;
0: 
0: import java.util.ArrayList;
0: import java.util.Enumeration;
0: import java.util.Vector;
0: import java.util.Hashtable;
0: import java.util.HashSet;
0: import org.apache.derby.iapi.util.ReuseFactory;
0: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
0: 
0: /**
0:  * BaseActivation
0:  * provides the fundamental support we expect all activations to have.
0:  * Doesn't actually implement any of the activation interface,
0:  * expects the subclasses to do that.
0:  */
0: public abstract class BaseActivation implements CursorActivation, GeneratedByteCode
0: 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	protected ResultSetFactory rsFactory;
0: 	protected ExecutionFactory exFactory;
0: 	protected	DataValueFactory			dvFactory;
0: 	protected	LanguageConnectionContext	lcc;
0: 	protected ContextManager			cm;
0: 	protected /*private*/ ExecutionContext			ec;
0: 
0: 
0: 	protected ExecPreparedStatement preStmt;
0: 	protected ResultSet resultSet;
0: 	protected ResultDescription resultDescription;
0: 	protected boolean closed;
0: 	private String cursorName;
0: 	
0: 	protected int numSubqueries;
0: 
0: 	private boolean singleExecution;
0: 	private boolean inUse;
0: 
0: 	private java.sql.ResultSet targetVTI;
0: 	private SQLWarning warnings;
0: 
0: 	private GeneratedClass gc;	// my Generated class object.
0: 
0: 	private boolean checkRowCounts;
0: 	private HashSet rowCountsCheckedThisExecution = new HashSet(4, 0.9f);
0: 
0: 	private static final long MAX_SQRT = (long) Math.sqrt(Long.MAX_VALUE);
0: 
0: 	// When the row count exceeds this number, we should recompile if
0: 	// the difference in row counts is greater than 10%.  If it's less
0: 	// than this number, we use an entirely different technique to check
0: 	// for recompilation.  See comments below, in informOfRowCount()
0: 	private static final int TEN_PERCENT_THRESHOLD = 400;
0: 
0: 	/* Performance optimization for update/delete - only
0: 	 * open heap ConglomerateController once when doing
0: 	 * index row to base row on search
0: 	 */
0: 	private ConglomerateController  updateHeapCC;
0: 	private ScanController			indexSC;
0: 	private long					indexConglomerateNumber = -1;
0: 
0: 	private TableDescriptor ddlTableDescriptor;
0: 
0: 	private int maxRows = -1;
0: 	private boolean			forCreateTable;
0: 
0: 	private boolean			scrollable;
0: 
0:   	private boolean resultSetHoldability;
0: 
0: 	//beetle 3865: updateable cursor using index.  A way of communication
0: 	//between cursor activation and update activation.
0: 	private CursorResultSet forUpdateIndexScan;
0: 
0: 	//Following three are used for JDBC3.0 auto-generated keys feature.
0: 	//autoGeneratedKeysResultSetMode will be set true if at the time of statement execution,
0: 	//either Statement.RETURN_GENERATED_KEYS was passed or an array of (column positions or
0: 	//column names) was passed
0: 	private boolean autoGeneratedKeysResultSetMode;
0: 	private int[] autoGeneratedKeysColumnIndexes ;
0: 	private String[] autoGeneratedKeysColumnNames ;
0: 
0: 	//Following is the position of the session table names list in savedObjects in compiler context
0: 	//This is updated to be the correct value at cursor generate time if the cursor references any session table names.
0: 	//If the cursor does not reference any session table names, this will stay negative
0: 	protected int indexOfSessionTableNamesInSavedObjects = -1;
0: 
0: 	// WARNING: these fields are accessed by code generated in the 
0: 	// ExpressionClassBuilder: don't change them unless you 
0: 	// make the appropriate changes there.
0: 	protected ExecRow[] row;
0: 	protected ParameterValueSet pvs;
0: 
0: 	//
0: 	// constructors
0: 	//
0: 
0: 	protected BaseActivation()
0: 	{
0: 		super();
0: 	}
0: 
0: 	public final void initFromContext(Context context) {
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(context!=null, "NULL context passed to BaseActivation.initFromContext");
0: 		}
0: 		this.cm = context.getContextManager();
0: 
0: 		lcc = (LanguageConnectionContext) cm.getContext(LanguageConnectionContext.CONTEXT_ID);
0: 
0: 		if (SanityManager.DEBUG) {
0: 			if (lcc == null)
0: 				SanityManager.THROWASSERT("lcc is null in activation type " + getClass());
0: 		}
0: 
0: 		dvFactory = lcc.getDataValueFactory();
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(dvFactory != null,
0: 								 "No data value factory in getDataValueFactory");
0: 		}
0: 
0: 		ec = lcc.getExecutionContext();
0: 
0: 		// look for the execution context and
0: 		// get our result set factory from it.
0: 		rsFactory = ec.getResultSetFactory();
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(rsFactory!=null, "Unable to find ResultSetFactory");
0: 		}
0: 
0: 		exFactory = ec.getExecutionFactory();
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(exFactory!=null, "Unable to find ExecutionFactory");
0: 		}		
0: 
0: 		// mark in use
0: 		inUse = true;
0: 		
0: 		// add this activation to the pool for the connection.
0: 		lcc.addActivation(this);
0: 	}
0: 
0: 
0: 	//
0: 	// Activation interface
0: 	//
0: 
0: 	public final ExecPreparedStatement getPreparedStatement() {
0: 		return preStmt;
0: 	}
0: 
0: 	public ConstantAction getConstantAction() {
0: 		return preStmt.getConstantAction();
0: 	}
0: 
0: 
0: 	public final void checkStatementValidity() throws StandardException {
0: 
0: 		if (preStmt == null)
0: 			return;
0: 
0: 		synchronized (preStmt) {
0: 
0: 			if ((gc == preStmt.getActivationClass()) && preStmt.upToDate())
0: 				return;
0: 		}
0: 
0: 		StandardException se = StandardException.newException(SQLState.LANG_STATEMENT_NEEDS_RECOMPILE);
0: 		se.setReport(StandardException.REPORT_NEVER);
0: 		throw se;
0: 	}
0: 
0: 	/**
0: 		Link this activation with its PreparedStatement.
0: 		It can be called with null to break the link with the
0: 		PreparedStatement.
0: 
0: 	*/
0: 	public final void setupActivation(ExecPreparedStatement ps, boolean scrollable) {
0: 		preStmt = ps;
0: 
0: 		if (ps != null) {
0: 			// get the result set description
0:    			resultDescription = ps.getResultDescription();
0: 			this.scrollable = scrollable;
0: 		} else {
0: 			resultDescription = null;
0: 			this.scrollable = false;
0: 		}
0: 	}
0: 
0: 	public ResultSet getResultSet() {
0: 		return resultSet;
0: 	}
0: 
0: 	public void clearResultSet() {
0: 		resultSet = null;
0: 	}
0: 
0: 	/**
0: 		Get the saved RowLocation.
0: 
0: 		@param itemNumber	The saved item number.
0: 
0: 		@return	A RowLocation template for the conglomerate
0: 	 */
0: 	public RowLocation getRowLocationTemplate(int itemNumber)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(itemNumber >= 0,
0: 				"itemNumber expected to be >= 0");
0: 			if (! (getPreparedStatement().getSavedObject(itemNumber) instanceof RowLocation))
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"getPreparedStatement().getSavedObject(itemNumber) expected to be " +
0: 					"instance of RowLocation, not " +
0: 					getPreparedStatement().getSavedObject(itemNumber).getClass().getName() +
0: 					", query is " + getPreparedStatement().getSource());
0: 			}
0: 			RowLocation rl = (RowLocation) getPreparedStatement().getSavedObject(itemNumber);
0: 			if (! (rl.cloneObject() instanceof RowLocation))
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"rl.cloneObject() expected to be " +
0: 					"instance of RowLocation, not " +
0: 					rl.getClass().getName() +
0: 					", query is " + getPreparedStatement().getSource());
0: 			}
0: 		}
0: 		/* We have to return a clone of the saved RowLocation due
0: 		 * to the shared cache of SPSs.
0: 		 */
0: 		return (RowLocation)
0: 			((RowLocation)(getPreparedStatement().getSavedObject(itemNumber))).cloneObject();
0: 	}
0: 
0: 	/*
0: 	 */
0: 	public ResultDescription getResultDescription() {
0: 		if (SanityManager.DEBUG)
0: 	    	SanityManager.ASSERT(resultDescription != null, "Must have a result description");
0: 	   	    return resultDescription;
0: 	}
0: 
0: 	/**
0: 		This is a partial implementation of reset.
0: 		Subclasses will want to reset information
0: 		they are aware of, such as parameters.
0: 		<p>
0: 		All subclasses must call super.reset() and
0: 		then do their cleanup.
0: 		<p>
0: 		The execute call must set the resultSet field
0: 		to be the resultSet that it has returned.
0: 
0: 		@exception StandardException on error
0: 	 */
0: 	public void reset() throws StandardException
0: 	{
0: 		// if resultset holdability after commit is false, close it
0: 		if (resultSet != null && (!resultSetHoldability || !resultSet.returnsRows())) {
0: 			// would really like to check if it is open,
0: 			// this is as close as we can approximate that.
0: 			resultSet.close();
0: 			resultSet = null; // forget about it, prepare for next exec.
0: 
0: 		}
0: 		updateHeapCC = null;
0: 		// REMIND: do we need to get them to stop input as well?
0: 
0: 		if (!isSingleExecution())
0: 			clearWarnings();
0: 	}
0: 
0: 	/**
0: 		Closing an activation marks it as unusable. Any other
0: 		requests made on it will fail.  An activation should be
0: 		marked closed when it is expected to not be used any longer,
0: 		i.e. when the connection for it is closed, or it has suffered some
0: 		sort of severe error.
0: 
0: 		This should also remove it from the language connection context.
0: 
0: 		@exception StandardException on error
0: 	 */
0: 	public final void close() throws StandardException 
0: 	{
0: 		if (! closed) {	
0: 			
0: 			// markUnused();
0: 
0: 			// we finish the result set before we call reset
0: 			// because reset will set it to null.
0: 			if (resultSet != null)
0: 			{
0: 				resultSet.finish();
0: 				resultSet = null;
0: 			}
0: 
0: 			// we call reset so that if the actual type of "this"
0: 			// is a subclass of BaseActivation, its cleanup will
0: 			// also happen -- reset in the actual type is called,
0: 			// not reset in BaseActivation.  Subclass reset's
0: 			// are supposed to call super.reset() as well.
0: 			reset(); // get everything related to executing released
0: 
0: 			closed = true;
0: 
0: 			LanguageConnectionContext lcc = getLanguageConnectionContext();
0: 
0: 			lcc.removeActivation(this);
0: 			if (preStmt != null) {
0: 				preStmt.finish(lcc);
0: 				preStmt = null;
0: 			}
0: 
0: 			try {
0: 				closeActivationAction();
0: 			} catch (Throwable e) {
0: 				throw StandardException.plainWrapException(e);
0: 			}
0: 
0: 		}
0: 		
0: 	}
0: 
0: 	/**
0: 		A generated class can create its own closeActivationAction
0: 		method to invoke special logic when the activation is closed.
0: 	*/
0: 	protected void closeActivationAction() throws Exception {
0: 		// no code to be added here as generated code
0: 		// will not call super.closeActivationAction()
0: 	}
0: 
0: 	/**
0: 		Find out if the activation closed or not.
0: 		@return true if the prepared statement has been closed.
0: 	 */
0: 	public boolean isClosed() {
0: 		return closed;
0: 	}
0: 
0: 	/**
0: 		Set this Activation for a single execution.
0: 
0: 		@see Activation#setSingleExecution
0: 	*/
0: 	public void setSingleExecution() {
0: 		singleExecution = true;
0: 	}
0: 
0: 	/**
0: 		Returns true if this Activation is only going to be used for
0: 		one execution.
0: 
0: 		@see Activation#isSingleExecution
0: 	*/
0: 	public boolean isSingleExecution() {
0: 		return singleExecution;
0: 	}
0: 
0: 	/**
0: 		Get the number of subqueries in the entire query.
0: 		@return int	 The number of subqueries in the entire query.
0: 	 */
0: 	public int getNumSubqueries() {
0: 		return numSubqueries;
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#isCursorActivation
0: 	 */
0: 	public boolean isCursorActivation()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	//
0: 	// GeneratedByteCode interface
0: 	//
0: 
0: 	public final void setGC(GeneratedClass gc) {
0: 		this.gc = gc;
0: 	}
0: 
0: 	public final GeneratedClass getGC() {
0: 
0: 		if (SanityManager.DEBUG) {
0: 			if (gc == null)
0: 				SanityManager.THROWASSERT("move code requiring GC to postConstructor() method!!");
0: 		}
0: 		return gc;
0: 	}
0: 
0: 	public final GeneratedMethod getMethod(String methodName) throws StandardException {
0: 
0: 		return getGC().getMethod(methodName);
0: 	}
0: 	public Object e0() throws StandardException { return null; } 
0: 	public Object e1() throws StandardException { return null; }
0: 	public Object e2() throws StandardException { return null; }
0: 	public Object e3() throws StandardException { return null; }
0: 	public Object e4() throws StandardException { return null; } 
0: 	public Object e5() throws StandardException { return null; }
0: 	public Object e6() throws StandardException { return null; }
0: 	public Object e7() throws StandardException { return null; }
0: 	public Object e8() throws StandardException { return null; } 
0: 	public Object e9() throws StandardException { return null; }
0: 
0: 	//
0: 	// class interface
0: 	//
0: 
0: 	/**
0: 	 * Temporary tables can be declared with ON COMMIT DELETE ROWS. But if the table has a held curosr open at
0: 	 * commit time, data should not be deleted from the table. This method, (gets called at commit time) checks if this
0: 	 * activation held cursor and if so, does that cursor reference the passed temp table name.
0: 	 *
0: 	 * @return	true if this activation has held cursor and if it references the passed temp table name
0: 	 */
0: 	public boolean checkIfThisActivationHasHoldCursor(String tableName)
0: 	{
0: 		if (!inUse)
0: 			return false;
0: 
0: 		if (resultSetHoldability == false) //if this activation is not held over commit, do not need to worry about it
0: 			return false;
0: 
0: 		if (indexOfSessionTableNamesInSavedObjects == -1) //if this activation does not refer to session schema tables, do not need to worry about it
0: 			return false;
0: 
0: 		/* is there an open result set? */
0: 		if ((resultSet != null) && !resultSet.isClosed() && resultSet.returnsRows())
0: 		{
0: 			//If we came here, it means this activation is held over commit and it reference session table names
0: 			//Now let's check if it referneces the passed temporary table name which has ON COMMIT DELETE ROWS defined on it.
0: 			return ((ArrayList)getPreparedStatement().getSavedObject(indexOfSessionTableNamesInSavedObjects)).contains(tableName);
0: 		}
0: 
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	   remember the cursor name
0: 	 */
0: 
0: 	public void	setCursorName(String cursorName)
0: 	{
0: 		if (isCursorActivation())
0: 			this.cursorName = cursorName;
0: 	}
0: 
0: 
0: 	/**
0: 	  get the cursor name.  For something that isn't
0: 	  a cursor, this is used as a string name of the
0: 	  result set for messages from things like the
0: 	  dependency manager.
0: 	  <p>
0: 	  Activations that do support cursors will override
0: 	  this.	
0: 	*/
0: 	public String getCursorName() {
0: 
0: 		return isCursorActivation() ? cursorName : null;
0: 	}
0: 
0: 	public void setResultSetHoldability(boolean resultSetHoldability)
0: 	{
0: 		this.resultSetHoldability = resultSetHoldability;
0: 	}
0: 
0: 	public boolean getResultSetHoldability()
0: 	{
0: 		return resultSetHoldability;
0: 	}
0: 
0: 	/** @see Activation#setAutoGeneratedKeysResultsetInfo */
0: 	public void setAutoGeneratedKeysResultsetInfo(int[] columnIndexes, String[] columnNames)
0: 	{
0: 		autoGeneratedKeysResultSetMode = true;
0: 		autoGeneratedKeysColumnIndexes = columnIndexes;
0: 		autoGeneratedKeysColumnNames = columnNames;
0: 	}
0: 
0: 	/** @see Activation#getAutoGeneratedKeysResultsetMode */
0: 	public boolean getAutoGeneratedKeysResultsetMode()
0: 	{
0: 		return autoGeneratedKeysResultSetMode;
0: 	}
0: 
0: 	/** @see Activation#getAutoGeneratedKeysColumnIndexes */
0: 	public int[] getAutoGeneratedKeysColumnIndexes()
0: 	{
0: 		return autoGeneratedKeysColumnIndexes;
0: 	}
0: 
0: 	/** @see Activation#getAutoGeneratedKeysColumnNames */
0: 	public String[] getAutoGeneratedKeysColumnNames()
0: 	{
0: 		return autoGeneratedKeysColumnNames;
0: 	}
0: 
0: 	//
0: 	// class implementation
0: 	//
0: 
0: 
0: 	/**
0: 		Used in the execute method of activations for
0: 		generating the result sets that they concatenate together.
0: 	 */
0: 	public ResultSetFactory getResultSetFactory() {
0: 		return rsFactory;
0: 	}
0: 
0: 	/**
0: 		Used in activations for generating rows.
0: 	 */
0: 	public ExecutionFactory getExecutionFactory() {
0: 		return exFactory;
0: 	}
0: 
0: 
0: 	/**
0: 		Used in CurrentOfResultSet to get to the target result set
0: 		for a cursor. Overridden by activations generated for
0: 		updatable cursors.  Those activations capture the target
0: 		result set in a field in their execute() method, and then
0: 		return the value of that field in their version of this method.
0: 
0: 		@return null.
0: 	 */
0: 	public CursorResultSet getTargetResultSet() {
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.THROWASSERT("Must be overridden to be used.");
0: 		return null;
0: 	}
0: 
0: 	/*
0: 	 * Called by generated code to compute the next autoincrement value.
0: 	 * 
0: 	 * @return The next autoincrement value which should be inserted.
0: 	 * returns the correct number datatype.
0: 	 */
0: 	protected DataValueDescriptor 
0: 		getSetAutoincrementValue(int columnPosition, long increment)
0: 	       throws StandardException
0: 	{
0: 		DataValueDescriptor l =
0: 			((InsertResultSet)resultSet).getSetAutoincrementValue(columnPosition, increment);
0: 		return l;
0: 
0: 	}
0: 
0: 	/**
0: 		Used in CurrentOfResultSet to get to the cursor result set
0: 		for a cursor.  Overridden by activations generated for
0: 		updatable cursors.  Those activations capture the cursor
0: 		result set in a field in their execute() method, and then
0: 		return the value of that field in their version of this method.
0: 
0: 		@return null
0: 	 */
0: 	public CursorResultSet getCursorResultSet() {
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.THROWASSERT("Must be overridden to be used.");
0: 		return null;
0: 	}
0: 
0: 	/**
0: 		Various activation methods need to disallow their
0: 		invocation if the activation is closed. This lets them
0: 		check and throw without generating alot of code.
0: 		<p>
0: 		The code to write to generate the call to this is approximately:
0: 		<verbatim>
0: 			// jf is a JavaFactory
0: 			CallableExpression ce = jf.newMethodCall(
0: 				jf.thisExpression(),
0: 				BaseActivation.CLASS_NAME,
0: 				"throwIfClosed",
0: 				"void",
0: 				acb.exprArray(jf.newStringLiteral(...some literal here...)));
0: 
0: 			//mb is a MethodBuilder
0: 			mb.addStatement(jf.newStatement(ce));
0: 		</verbatim>
0: 		The java code to write to call this is:
0: 		<verbatim>
0: 			this.throwIfClosed(...some literal here...);
0: 		</verbatim>
0: 		In both cases, "...some literal here..." gets replaced with
0: 		an expression of type String that evaluates to the name
0: 		of the operation that is being checked, like "execute" or
0: 		"reset".
0: 
0: 		@exception StandardException thrown if closed
0: 	 */
0: 	public void throwIfClosed(String op) throws StandardException {
0: 		if (closed)
0: 			throw StandardException.newException(SQLState.LANG_ACTIVATION_CLOSED, op);
0: 	}
0: 
0: 	/**
0: 	 * Set a column position in an array of column positions.
0: 	 *
0: 	 * @param columnPositions	The array of column positions
0: 	 * @param positionToSet		The place to put the column position
0: 	 * @param column			The column position
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 	public static void setColumnPosition(
0: 							int[] columnPositions,
0: 							int positionToSet,
0: 							int column)
0: 	{
0: 		columnPositions[positionToSet] = column;
0: 	}
0: 
0: 	/**
0: 	 * Allocate an array of qualifiers and initialize in Qualifier[][]
0: 	 *
0: 	 * @param qualifiers	The array of Qualifier arrays.
0: 	 * @param position		The position in the array to set
0: 	 * @param length		The array length of the qualifier array to allocate.
0: 	 */
0: 	public static void allocateQualArray(
0:     Qualifier[][]   qualifiers,
0:     int             position,
0:     int             length)
0: 	{
0:         qualifiers[position] = new Qualifier[length];
0: 	}
0: 
0: 
0: 	/**
0: 	 * Set a Qualifier in a 2 dimensional array of Qualifiers.
0:      *
0:      * Set a single Qualifier into one slot of a 2 dimensional array of 
0:      * Qualifiers.  @see Qualifier for detailed description of layout of
0:      * the 2-d array.
0: 	 *
0: 	 * @param qualifiers	The array of Qualifiers
0: 	 * @param qualifier		The Qualifier
0: 	 * @param position_1    The Nth array index into qualifiers[N][M]
0: 	 * @param position_1    The Nth array index into qualifiers[N][M]
0: 	 */
0: 	public static void setQualifier(
0:     Qualifier[][]   qualifiers,
0:     Qualifier	    qualifier,
0:     int			    position_1,
0:     int             position_2)
0: 	{
0: 		qualifiers[position_1][position_2] = qualifier;
0: 	}
0: 
0: 	/**
0: 	 * Reinitialize all Qualifiers in an array of Qualifiers.
0: 	 *
0: 	 * @param qualifiers	The array of Qualifiers
0: 	 */
0: 	public static void reinitializeQualifiers(Qualifier[][] qualifiers)
0: 	{
0: 		if (qualifiers != null)
0: 		{
0:             for (int term = 0; term < qualifiers.length; term++)
0:             {
0:                 for (int i = 0; i < qualifiers[term].length; i++)
0:                 {
0:                     qualifiers[term][i].reinitialize();
0:                 }
0:             }
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Mark the activation as unused.  
0: 	 */
0: 	public final void markUnused()
0: 	{
0: 		inUse = false;
0: 	}
0: 
0: 	/**
0: 	 * Is the activation in use?
0: 	 *
0: 	 * @return true/false
0: 	 */
0: 	public final boolean isInUse()
0: 	{
0: 		return inUse;
0: 	}
0: 
0: 	/**
0: 	  @see org.apache.derby.iapi.sql.Activation#addWarning
0: 	  */
0: 	public void addWarning(SQLWarning w)
0: 	{
0: 		if (warnings == null)
0: 			warnings = w;
0: 		else
0: 			warnings.setNextWarning(w);
0: 	}
0: 
0: 	/**
0: 	  @see org.apache.derby.iapi.sql.Activation#getWarnings
0: 	  */
0: 	public SQLWarning getWarnings()
0: 	{
0: 		return warnings;
0: 	}
0: 
0: 	/**
0: 	  @see org.apache.derby.iapi.sql.Activation#clearWarnings
0: 	  */
0: 	public void clearWarnings()
0: 	{
0: 		warnings = null;
0: 	}
0: 
0: 	/**
0: 	 * @exception StandardException on error
0: 	 */
0: 	protected static void nullToPrimitiveTest(DataValueDescriptor dvd, String primitiveType)
0: 		throws StandardException
0: 	{
0: 		if (dvd.isNull())
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_NULL_TO_PRIMITIVE_PARAMETER, primitiveType);
0: 		}
0: 	}
0: 
0: 	/**
0: 		@see Activation#informOfRowCount
0: 		@exception StandardException	Thrown on error
0: 	 */
0: 	public void informOfRowCount(NoPutResultSet resultSet, long currentRowCount)
0: 					throws StandardException
0: 	{
0: 
0: 		/* Do we want to check the row counts during this execution? */
0: 		if (checkRowCounts)
0: 		{
0: 			boolean significantChange = false;
0: 
0: 			int resultSetNumber = resultSet.resultSetNumber();
0: 			Integer rsn = ReuseFactory.getInteger(resultSetNumber);
0: 
0: 			/* Check each result set only once per execution */
0: 			if (rowCountsCheckedThisExecution.add(rsn))
0: 			{
0: 				synchronized (getPreparedStatement())
0: 				{
0: 					Vector rowCountCheckVector = getRowCountCheckVector();
0: 
0: 					if (rowCountCheckVector == null) {
0: 						rowCountCheckVector = new Vector();
0: 						setRowCountCheckVector(rowCountCheckVector);
0: 					}
0: 
0: 					Long firstRowCount = null;
0: 
0: 					/*
0: 					** Check whether this resultSet has been seen yet.
0: 					*/
0: 					if (resultSetNumber < rowCountCheckVector.size())
0: 					{
0: 						firstRowCount =
0: 							(Long) rowCountCheckVector.elementAt(resultSetNumber);
0: 					}
0: 					else
0: 					{
0: 						rowCountCheckVector.setSize(resultSetNumber + 1);
0: 					}
0: 
0: 					if (firstRowCount != null)
0: 					{
0: 						/*
0: 						** This ResultSet has been seen - has the row count
0: 						** changed significantly?
0: 						*/
0: 						long n1 = firstRowCount.longValue();
0: 
0: 						if (currentRowCount != n1)
0: 						{
0: 							if (n1 >= TEN_PERCENT_THRESHOLD)
0: 							{
0: 								/*
0: 								** For tables with more than
0: 								** TEN_PERCENT_THRESHOLD rows, the
0: 								** threshold is 10% of the size of the table.
0: 								*/
0: 								long changeFactor = n1 / (currentRowCount - n1);
0: 								if (Math.abs(changeFactor) <= 10)
0: 									significantChange = true;
0: 							}
0: 							else
0: 							{
0: 								/*
0: 								** For tables with less than
0: 								** TEN_PERCENT_THRESHOLD rows, the threshold
0: 								** is non-linear.  This is because we want
0: 								** recompilation to happen sooner for small
0: 								** tables that change size.  This formula
0: 								** is for a second-order equation (a parabola).
0: 								** The derivation is:
0: 								**
0: 								**   c * n1 = (difference in row counts) ** 2
0: 								**				- or - 
0: 								**   c * n1 = (currentRowCount - n1) ** 2
0: 								**
0: 								** Solving this for currentRowCount, we get:
0: 								**
0: 								**   currentRowCount = n1 + sqrt(c * n1)
0: 								**
0: 								**				- or -
0: 								**
0: 								**   difference in row counts = sqrt(c * n1)
0: 								**
0: 								**				- or -
0: 								**
0: 								**   (difference in row counts) ** 2 =
0: 								**					c * n1
0: 								**
0: 								** Which means that we should recompile when
0: 								** the current row count exceeds n1 (the first
0: 								** row count) by sqrt(c * n1), or when the
0: 								** square of the difference exceeds c * n1.
0: 								** A good value for c seems to be 4.
0: 								**
0: 								** We don't use this formula when c is greater
0: 								** than TEN_PERCENT_THRESHOLD because we never
0: 								** want to recompile unless the number of rows
0: 								** changes by more than 10%, and this formula
0: 								** is more sensitive than that for values of
0: 								** n1 greater than TEN_PERCENT_THRESHOLD.
0: 								*/
0: 								long changediff = currentRowCount - n1;
0: 
0: 								/*
0: 								** Square changediff rather than take the square
0: 								** root of (4 * n1), because multiplying is
0: 								** faster than taking a square root.  Also,
0: 								** check to be sure that squaring changediff
0: 								** will not cause an overflow by comparing it
0: 								** with the square root of the maximum value
0: 								** for a long (this square root is taken only
0: 								** once, when the class is loaded, or during
0: 								** compilation if the compiler is smart enough).
0: 								*/
0: 								if (Math.abs(changediff) <= MAX_SQRT)
0: 								{
0: 									if ((changediff * changediff) >
0: 															Math.abs(4 * n1))
0: 									{
0: 										significantChange = true;
0: 									}
0: 								}
0: 							}
0: 						}
0: 					}
0: 					else
0: 					{
0: 						firstRowCount = new Long(currentRowCount);
0: 						rowCountCheckVector.setElementAt(
0: 														firstRowCount,
0: 														resultSetNumber
0: 														);
0: 
0: 					}
0: 				}
0: 			}
0: 
0: 			/* Invalidate outside of the critical section */
0: 			if (significantChange)
0: 			{
0: 				preStmt.makeInvalid(DependencyManager.INTERNAL_RECOMPILE_REQUEST, lcc);
0: 			}
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * The subclass calls this method when it begins an execution.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void startExecution() throws StandardException
0: 	{
0: 		// determine if we should check row counts during this execution
0: 		shouldWeCheckRowCounts();
0: 
0: 		// If we are to check row counts, clear the hash table of row counts
0: 		// we have checked.
0: 		if (checkRowCounts)
0: 			rowCountsCheckedThisExecution.clear();
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getHeapConglomerateController
0: 	 */
0: 	public ConglomerateController getHeapConglomerateController()
0: 	{
0: 		return updateHeapCC;
0: 	}
0: 
0: 
0: 	/**
0: 	 * @see Activation#setHeapConglomerateController
0: 	 */
0: 	public void setHeapConglomerateController(ConglomerateController updateHeapCC)
0: 	{
0: 		this.updateHeapCC = updateHeapCC;
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#clearHeapConglomerateController
0: 	 */
0: 	public void clearHeapConglomerateController()
0: 	{
0: 		updateHeapCC = null;
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getIndexScanController
0: 	 */
0: 	public ScanController getIndexScanController()
0: 	{
0: 		return indexSC;
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#setIndexScanController
0: 	 */
0: 	public void setIndexScanController(ScanController indexSC)
0: 	{
0: 		this.indexSC = indexSC;
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getIndexConglomerateNumber
0: 	 */
0: 	public long getIndexConglomerateNumber()
0: 	{
0: 		return indexConglomerateNumber;
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#setIndexConglomerateNumber
0: 	 */
0: 	public void setIndexConglomerateNumber(long indexConglomerateNumber)
0: 	{
0: 		this.indexConglomerateNumber = indexConglomerateNumber;
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#clearIndexScanInfo
0: 	 */
0: 	public void clearIndexScanInfo()
0: 	{
0: 		indexSC = null;
0: 		indexConglomerateNumber = -1;
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#setForCreateTable()
0: 	 */
0: 	public void setForCreateTable()
0: 	{
0: 		forCreateTable = true;
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getForCreateTable()
0: 	 */
0: 	public boolean getForCreateTable()
0: 	{
0: 		return forCreateTable;
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#setDDLTableDescriptor
0: 	 */
0: 	public void setDDLTableDescriptor(TableDescriptor td)
0: 	{
0: 		ddlTableDescriptor = td;
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getDDLTableDescriptor
0: 	 */
0: 	public TableDescriptor getDDLTableDescriptor()
0: 	{
0: 		return ddlTableDescriptor;
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#setMaxRows
0: 	 */
0: 	public void setMaxRows(int maxRows)
0: 	{
0: 		this.maxRows = maxRows;
0: 	}
0: 
0: 	/**
0: 	 * @see Activation#getMaxRows
0: 	 */
0: 	public int getMaxRows()
0: 	{
0: 		return maxRows;
0: 	}
0: 
0: 	public void setTargetVTI(java.sql.ResultSet targetVTI)
0: 	{
0: 		this.targetVTI = targetVTI;
0: 	}
0: 
0: 	public java.sql.ResultSet getTargetVTI()
0: 	{
0: 		return targetVTI;
0: 	}
0: 
0: 	private void shouldWeCheckRowCounts() throws StandardException
0: 	{
0: 		/*
0: 		** Check the row count only every N executions.  OK to check this
0: 		** without synchronization, since the value of this number is not
0: 		** critical.  The value of N is determined by the property
0: 		** derby.language.stalePlanCheckInterval.
0: 		*/
0: 		int executionCount = getExecutionCount() + 1;
0: 
0: 		/*
0: 		** Always check row counts the first time, to establish the
0: 		** row counts for each result set.  After that, don't check
0: 		** if the execution count is below the minimum row count check
0: 		** interval.  This saves us from checking a database property
0: 		** when we don't have to (checking involves querying the store,
0: 		** which can be expensive).
0: 		*/
0: 
0: 		if (executionCount == 1)
0: 		{
0: 			checkRowCounts = true;
0: 		}
0: 		else if (executionCount <
0: 								Property.MIN_LANGUAGE_STALE_PLAN_CHECK_INTERVAL)
0: 		{
0: 			checkRowCounts = false;
0: 		}
0: 		else
0: 		{
0: 			int stalePlanCheckInterval = getStalePlanCheckInterval();
0: 
0: 			/*
0: 			** Only query the database property once.  We can tell because
0: 			** the minimum value of the property is greater than zero.
0: 			*/
0: 			if (stalePlanCheckInterval == 0)
0: 			{
0: 				TransactionController tc = getTransactionController();
0: 
0: 				stalePlanCheckInterval =
0: 						PropertyUtil.getServiceInt(
0: 							tc,
0: 							Property.LANGUAGE_STALE_PLAN_CHECK_INTERVAL,
0: 							Property.MIN_LANGUAGE_STALE_PLAN_CHECK_INTERVAL,
0: 							Integer.MAX_VALUE,
0: 							Property.DEFAULT_LANGUAGE_STALE_PLAN_CHECK_INTERVAL
0: 							);
0: 				setStalePlanCheckInterval(stalePlanCheckInterval);
0: 			}
0: 
0: 			checkRowCounts = (executionCount % stalePlanCheckInterval) == 1;
0: 
0: 
0: 		}
0: 
0: 		setExecutionCount(executionCount);
0: 	}
0: 
0: 	/*
0: 	** These accessor methods are provided by the sub-class to help figure
0: 	** out whether to check row counts during this execution.
0: 	*/
0: 	abstract protected int getExecutionCount();
0: 
0: 	abstract protected void setExecutionCount(int newValue); 
0: 
0: 	/*
0: 	** These accessor methods are provided by the sub-class to help figure
0: 	** out whether the row count for a particular result set has changed
0: 	** enough to force recompilation.
0: 	*/
0: 	abstract protected Vector getRowCountCheckVector();
0: 
0: 	abstract protected void setRowCountCheckVector(Vector newValue);
0: 
0: 	/*
0: 	** These accessor methods are provided by the sub-class to remember the
0: 	** value of the stale plan check interval property, so that we only
0: 	** have to query the database properties once (there is heavyweight
0: 	** synchronization around the database properties).
0: 	*/
0: 	abstract protected int getStalePlanCheckInterval();
0: 
0: 	abstract protected void setStalePlanCheckInterval(int newValue);
0: 
0: 	public final boolean getScrollable() {
0: 		return scrollable;
0: 	}
0: 
0: 	protected final void setParameterValueSet(int paramCount, boolean hasReturnParam) {
0: 
0: 		pvs = lcc.getLanguageFactory().newParameterValueSet(
0: 			lcc.getLanguageConnectionFactory().getClassFactory().getClassInspector(),
0: 			paramCount, hasReturnParam);
0: 	}
0: 
0: 	/**
0: 	 return the parameters.
0: 	 */
0: 	public ParameterValueSet	getParameterValueSet() 
0: 	{ 
0: 		if (pvs == null)
0: 			setParameterValueSet(0, false); 
0: 		return pvs; 
0: 	}
0: 
0: 	// how do we do/do we want any sanity checking for
0: 	// the number of parameters expected?
0: 	public void	setParameters(ParameterValueSet parameterValues, DataTypeDescriptor[] parameterTypes) throws StandardException
0: 	{
0: 		if (!isClosed())
0: 		{
0: 
0: 			if (this.pvs == null || parameterTypes == null) {
0: 				pvs = parameterValues;
0: 				return;
0: 
0: 			}
0: 
0: 			DataTypeDescriptor[]	newParamTypes = preStmt.getParameterTypes();
0: 
0: 			/*
0: 			** If there are old parameters but not new ones,
0: 			** they aren't compatible.
0: 			*/
0: 			boolean match = false;
0: 			if (newParamTypes != null) {
0: 
0: 				if (newParamTypes.length == parameterTypes.length) {
0: 
0: 					/* Check each parameter */
0: 					match = true;
0: 					for (int i = 0; i < parameterTypes.length; i++)
0: 					{
0: 						DataTypeDescriptor	oldType = parameterTypes[i];
0: 						DataTypeDescriptor	newType	= newParamTypes[i];
0: 
0: 						if (!oldType.isExactTypeAndLengthMatch(newType)) {
0: 							match = false;
0: 							break;
0: 						}
0: 						/*
0: 						** We could probably get away without checking nullability,
0: 						** since parameters are always nullable.
0: 						*/
0: 						if (oldType.isNullable() != newType.isNullable()) {
0: 							match = false;
0: 							break;
0: 						}
0: 					}
0: 				}
0: 
0: 			}
0: 
0: 			if (!match)
0: 				throw StandardException.newException(SQLState.LANG_OBSOLETE_PARAMETERS);
0: 
0: 
0: 			parameterValues.transferDataValues(pvs);
0: 
0: 		}
0: 		else if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("isClosed() is expected to return false");
0: 		}
0: 	}
0: 
0: 	/**
0: 	 	Throw an exception if any parameters are uninitialized.
0: 
0: 		@return		Nothing
0: 
0: 		@exception StandardException	Thrown if any parameters
0: 												are unitialized
0: 	 */
0: 
0: 	public void throwIfMissingParms() throws StandardException
0: 	{
0: 		if (pvs != null && !pvs.allAreSet())
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_MISSING_PARMS);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Remember the row for the specified ResultSet.
0: 	 */
0: 	public void setCurrentRow(ExecRow currentRow, int resultSetNumber)
0: 	{ 
0: 		if (SanityManager.DEBUG) 
0: 		{
0: 			SanityManager.ASSERT(!isClosed(), "closed");
0: 			if (row != null)
0: 			{
0: 				if (!(resultSetNumber >=0 && resultSetNumber < row.length))
0: 				{
0: 					SanityManager.THROWASSERT("resultSetNumber = " + resultSetNumber +
0: 								 ", expected to be between 0 and " + row.length);
0: 				}
0: 			}
0: 		}
0: 		if (row != null)
0: 		{
0: 			row[resultSetNumber] = currentRow;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Clear the current row for the specified ResultSet.
0: 	 */
0: 	public void clearCurrentRow(int resultSetNumber)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (row != null)
0: 			{
0: 				if (!(resultSetNumber >=0 && resultSetNumber < row.length))
0: 				{
0: 					SanityManager.THROWASSERT("resultSetNumber = " + resultSetNumber +
0: 								 ", expected to be between 0 and " + row.length);
0: 				}
0: 			}
0: 		}
0: 		if (row != null)
0: 		{
0: 			row[resultSetNumber] = null;
0: 		}
0: 	}
0: 
0: 	protected final DataValueDescriptor getColumnFromRow(int rsNumber, int colId)
0: 		throws StandardException {
0: 
0:         if( row[rsNumber] == null)
0:         {
0:             /* This actually happens. NoPutResultSetImpl.clearOrderableCache attempts to prefetch invariant values
0:              * into a cache. This fails in some deeply nested joins. See Beetle 4736 and 4880.
0:              */
0:             return null;
0:         }
0: 		return row[rsNumber].getColumn(colId);
0: 	}
0: 
0: 	protected void checkPositionedStatement(String cursorName, String psName)
0: 		throws StandardException {
0: 
0: 		ExecPreparedStatement ps = getPreparedStatement();
0: 		if (ps == null)
0: 			return;
0: 			
0: 		LanguageConnectionContext lcc = getLanguageConnectionContext();
0: 
0: 		CursorActivation cursorActivation = lcc.lookupCursorActivation(cursorName);
0: 
0: 		if (cursorActivation != null)
0: 		{
0: 			// check we are compiled against the correct cursor
0: 			if (!psName.equals(cursorActivation.getPreparedStatement().getObjectName())) {
0: 
0: 				// our prepared statement is now invalid since there
0: 				// exists another cursor with the same name but a different
0: 				// statement.
0: 				ps.makeInvalid(DependencyManager.CHANGED_CURSOR, lcc);
0: 			}
0: 		}
0: 	}
0: 
0: 	/* This method is used to materialize a resultset if can actually fit in the memory
0: 	 * specified by "maxMemoryPerTable" system property.  It converts the result set into
0: 	 * union(union(union...(union(row, row), row), ...row), row).  It returns this
0: 	 * in-memory converted resultset, or the original result set if not converted.
0: 	 * See beetle 4373 for details.
0: 	 *
0: 	 *	@param	rs	input result set
0: 	 *	@return	materialized resultset, or original rs if it can't be materialized
0: 	 */
0: 	public NoPutResultSet materializeResultSetIfPossible(NoPutResultSet rs)
0: 		throws StandardException
0: 	{
0: 		rs.openCore();
0: 		Vector rowCache = new Vector();
0: 		ExecRow aRow;
0: 		int cacheSize = 0;
0: 		FormatableBitSet toClone = null;
0: 
0: 		int maxMemoryPerTable = getLanguageConnectionContext().getOptimizerFactory().getMaxMemoryPerTable();
0: 
0: 		aRow = rs.getNextRowCore();
0: 		if (aRow != null)
0: 		{
0: 			toClone = new FormatableBitSet(aRow.nColumns() + 1);
0: 			toClone.set(1);
0: 		}
0: 		while (aRow != null)
0: 		{
0: 			cacheSize += aRow.getColumn(1).getLength();
0: 			if (cacheSize > maxMemoryPerTable)
0: 				break;
0: 			rowCache.addElement(aRow.getClone(toClone));
0: 			aRow = rs.getNextRowCore();
0: 		}
0: 		rs.close();
0: 
0: 		if (aRow == null)
0: 		{
0: 			int rsNum = rs.resultSetNumber();
0: 
0: 			int numRows = rowCache.size();
0: 			if (numRows == 0)
0: 			{
0: 				return new RowResultSet(
0: 										this,
0: 										(ExecRow) null,
0: 										true,
0: 										rsNum,
0: 										0,
0: 										0,
0: 										null);
0: 			}
0: 			RowResultSet[] rrs = new RowResultSet[numRows];
0: 			UnionResultSet[] urs = new UnionResultSet[numRows - 1];
0: 
0: 			for (int i = 0; i < numRows; i++)
0: 			{
0: 				rrs[i] = new RowResultSet(
0: 										this,
0: 										(ExecRow) rowCache.elementAt(i),
0: 										true,
0: 										rsNum,
0: 										1,
0: 										0,
0: 										null);
0: 				if (i > 0)
0: 				{
0: 					urs[i - 1] = new UnionResultSet (
0: 										(i > 1) ? (NoPutResultSet)urs[i - 2] : (NoPutResultSet)rrs[0],
0: 										rrs[i],
0: 										this,
0: 										rsNum,
0: 										i + 1,
0: 										0,
0: 										null);
0: 				}
0: 			}
0: 
0: 			rs.finish();
0: 
0: 			if (numRows == 1)
0: 				return rrs[0];
0: 			else
0: 				return urs[urs.length - 1];
0: 		}
0: 		return rs;
0: 	}
0: 
0: 
0: 
0: 	//WARNING : this field name is referred in the DeleteNode generate routines.
0: 	protected CursorResultSet[] raParentResultSets;
0: 
0: 
0: 	// maintain hash table of parent result set vector
0: 	// a table can have more than one parent source.
0: 	protected Hashtable parentResultSets;
0: 	public void setParentResultSet(TemporaryRowHolder rs, String resultSetId)
0: 	{
0: 		Vector  rsVector;
0: 		if(parentResultSets == null)
0: 			parentResultSets = new Hashtable();
0: 		rsVector = (Vector) parentResultSets.get(resultSetId);
0: 		if(rsVector == null)
0: 		{
0: 			rsVector = new Vector();
0: 			rsVector.addElement(rs);
0: 		}else
0: 		{
0: 			rsVector.addElement(rs);
0: 		}
0: 		parentResultSets.put(resultSetId , rsVector);
0: 	}
0: 
0: 	/**
0: 	 * get the reference to parent table ResultSets, that will be needed by the 
0: 	 * referential action dependent table scans.
0: 	 */
0: 	public Vector getParentResultSet(String resultSetId)
0: 	{
0: 		return (Vector) parentResultSets.get(resultSetId);
0: 	}
0: 
0: 	public Hashtable getParentResultSets()
0: 	{
0: 		return parentResultSets;
0: 	}
0: 
0: 	/**
0: 	 ** prepared statement use the same activation for
0: 	 ** multiple execution. For each excution we create new
0: 	 ** set of temporary resultsets, we should clear this hash table.
0: 	 ** otherwise we will refer to the released resources.
0: 	 */
0: 	public void clearParentResultSets()
0: 	{
0: 		if(parentResultSets != null)
0: 			parentResultSets.clear();
0: 	}
0: 
0: 	/**
0: 	 * beetle 3865: updateable cursor using index.  A way of communication
0: 	 * between cursor activation and update activation.
0: 	 */
0: 	public void setForUpdateIndexScan(CursorResultSet forUpdateIndexScan)
0: 	{
0: 		this.forUpdateIndexScan = forUpdateIndexScan;
0: 	}
0: 
0: 	public CursorResultSet getForUpdateIndexScan()
0: 	{
0: 		return forUpdateIndexScan;
0: 	}
0: 
0: 	private java.util.Calendar cal;
0: 	/**
0: 		Return a calendar for use by this activation.
0: 		Calendar objects are not thread safe, the one returned
0: 		is purely for use by this activation and it is assumed
0: 		that is it single threded through the single active
0: 		thread in a connection model.
0: 	*/
0: 	protected java.util.Calendar getCalendar() {
0: 		if (cal == null)
0: 			cal = new java.util.GregorianCalendar();
0: 		return cal;
0: 
0: 	}
0: 
0: 
0: 	/*
0: 	** Code originally in the parent class BaseExpressionActivation
0: 	*/
0: 	/**
0: 	    Get the language connection factory associated with this connection
0: 	  */
0: 	public final LanguageConnectionContext	getLanguageConnectionContext()
0: 	{
0: 		return	lcc;
0: 	}
0: 
0: 	public final TransactionController getTransactionController()
0: 	{
0: 		return lcc.getTransactionExecute();
0: 	}
0: 			
0: 	/**
0: 	 * Get the ExecutionContext.
0: 	 */
0: 	ExecutionContext getExecutionContext()
0: 	{
0: 		return ec;
0: 	}
0: 
0: 	/**
0: 	 * Get the Current ContextManager.
0: 	 *
0: 	 * @return Current ContextManager
0: 	 */
0: 	public ContextManager getContextManager()
0: 	{
0: 		return cm;
0: 	}
0: 
0: 	/**
0: 		Used by activations to generate data values.  Most DML statements
0: 		will use this method.  Possibly some DDL statements will, as well.
0: 	 */
0: 	public DataValueFactory getDataValueFactory()
0: 	{
0: 		return dvFactory;
0: 	}
0: 
0: 	/**
0: 	 * Used to get a proxy for the current connection.
0: 	 *
0: 	 * @exception SQLException		Thrown on failure to get connection
0: 	 */
0: 	public Connection getCurrentConnection() throws SQLException {
0: 
0: 		ConnectionContext cc = 
0: 			(ConnectionContext) cm.getContext(ConnectionContext.CONTEXT_ID);
0: 
0: 		return cc.getNestedConnection(true);
0: 	}	
0: 
0: 	/**
0: 		Real implementations of this method are provided by a generated class.
0: 	*/
0: 	public java.sql.ResultSet[][] getDynamicResults() {
0: 		return null;
0: 	}
0: 	/**
0: 		Real implementations of this method are provided by a generated class.
0: 	*/
0: 	public int getMaxDynamicResults() {
0: 		return 0;
0: 	}
0: 
0:     /**
0:      * Compute the DB2 compatible length of a value.
0:      *
0:      * @param value
0:      * @param constantLength The length, if it is a constant modulo null/not null. -1 if the length is not constant
0:      * @param reUse If non-null then re-use this as a container for the length
0:      *
0:      * @return the DB2 compatible length, set to null if value is null.
0:      */
0:     public NumberDataValue getDB2Length( DataValueDescriptor value,
0:                                          int constantLength,
0:                                          NumberDataValue reUse)
0:         throws StandardException
0:     {
0:         if( reUse == null)
0:             reUse = getDataValueFactory().getNullInteger( null);
0:         if( value.isNull())
0:             reUse.setToNull();
0:         else
0:         {
0:             if( constantLength >= 0)
0:                 reUse.setValue( constantLength);
0:             else
0:             {
0:                 reUse.setValue(value.getLength());
0:             }
0:         }
0:         return reUse;
0:     } // end of getDB2Length
0: }
============================================================================