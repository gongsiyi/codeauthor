1:cdda215: /*
7:cdda215: 
1:cdda215: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.Changes10_2
1:ca1a8f2: 
1:cdda215: Licensed to the Apache Software Foundation (ASF) under one or more
1:cdda215: contributor license agreements.  See the NOTICE file distributed with
1:cdda215: this work for additional information regarding copyright ownership.
1:cdda215: The ASF licenses this file to You under the Apache License, Version 2.0
1:cdda215: (the "License"); you may not use this file except in compliance with
1:cdda215: the License.  You may obtain a copy of the License at
1:cdda215: 
1:cdda215:    http://www.apache.org/licenses/LICENSE-2.0
1:cdda215: 
1:cdda215: Unless required by applicable law or agreed to in writing, software
1:cdda215: distributed under the License is distributed on an "AS IS" BASIS,
1:cdda215: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:cdda215: See the License for the specific language governing permissions and
1:cdda215: limitations under the License.
1:cdda215: 
2:cdda215: */
1:cdda215: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
1:cdda215: 
1:cdda215: import java.sql.PreparedStatement;
1:cdda215: import java.sql.ResultSet;
1:cdda215: import java.sql.SQLException;
1:cdda215: import java.sql.Statement;
1:ca1a8f2: import javax.sql.DataSource;
1:cdda215: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:cdda215: import org.apache.derbyTesting.junit.JDBC;
1:ca1a8f2: import org.apache.derbyTesting.junit.JDBCDataSource;
1:cdda215: 
2:cdda215: /**
1:cdda215:  * Upgrade test cases for changes made in 10.2.
1:daf5fa3:  * If the old version is 10.2 or later then these tests
1:daf5fa3:  * will not be run.
1:daf5fa3: 
1:cdda215:  * <BR>
1:cdda215:  * 10.2 Upgrade issues
1:cdda215:  * <UL>
1:cdda215:  * <LI> testTriggerInternalVTI - Check internal re-write of triggers
1:cdda215:  * does not break triggers in soft upgrade mode.
1:cdda215:  * <LI> testReusableRecordIdSequenceNumber - Test reuseable record
1:cdda215:  * identifiers does not cause issues in soft upgrade
1:daf5fa3:  * <LI> testGrantRevokeStatements - Check G/R not allowed in soft upgrade.
1:daf5fa3:  * <LI> testDatabaseOwner - test that on a hard upgrade database owner is set.
1:cdda215:  * </UL>
1:cdda215:  */
1:cdda215: public class Changes10_2 extends UpgradeChange {
1:cdda215:     
1:cdda215:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("Upgrade changes for 10.2");
1:cdda215:         
1:cdda215:         suite.addTestSuite(Changes10_2.class);
1:cdda215:         
1:c5571df:         // Encryption only support on J2SE or higher.
1:c5571df:         if (JDBC.vmSupportsJDBC3())
1:c5571df:         {
1:c5571df:             suite.addTest(new Changes10_2("changeEncryptionFromNone"));
1:c5571df:             suite.addTest(new Changes10_2("changeEncryptionFromEncryptedDatabase"));
1:c5571df:         }
1:c5571df:         
1:cdda215:         return suite;
3:cdda215:     }
1:cdda215: 
1:cdda215:     public Changes10_2(String name) {
1:cdda215:         super(name);
1:cdda215:     }
1:cdda215:     
1:daf5fa3:     /**
1:cdda215:      * Triger (internal) VTI
1:cdda215:      * 10.2 - Check that a statement trigger created in 10.0
1:cdda215:      * or 10.1 can be executed in 10.2 and that a statement
1:cdda215:      * trigger created in soft upgrade in 10.2 can be used
1:cdda215:      * in older releases.
2:cdda215:      * 
1:cdda215:      * The VTI implementing statement triggers changed in
1:cdda215:      * 10.2 from implementations of ResultSet to implementations
1:cdda215:      * of PreparedStatement. See DERBY-438. The internal
1:cdda215:      * api for the re-written action statement remains the
1:cdda215:      * same. The re-compile of the trigger on version changes
1:cdda215:      * should automatically switch between the two implementations.
1:cdda215:      *
1:daf5fa3:      * @throws SQLException
1:cdda215:      */
1:cdda215:     public void testTriggerInternalVTI()
1:cdda215:                                     throws SQLException {
1:cdda215:                 
1:cdda215:         
1:cdda215:         Statement s = createStatement();
1:cdda215: 
1:cdda215:         boolean modeDb2SqlOptional = oldAtLeast(10, 3);
1:cdda215: 
1:cdda215:         switch (getPhase()) {
1:cdda215:         case PH_CREATE:
1:cdda215:             s.execute("CREATE TABLE D438.T438(a int, b varchar(20), c int)");
1:cdda215:             s.execute("INSERT INTO D438.T438 VALUES(1, 'DERBY-438', 2)");
1:cdda215:             s.execute("CREATE TABLE D438.T438_T1(a int, b varchar(20))");
1:cdda215:             s.execute("CREATE TABLE D438.T438_T2(a int, c int)");
1:cdda215:             s.execute(
1:cdda215:                "create trigger D438.T438_ROW_1 after UPDATE on D438.T438 " +
1:cdda215:                "referencing new as n old as o " + 
1:cdda215:                "for each row "+ 
1:cdda215:                (modeDb2SqlOptional?"":"mode db2sql ") +
1:cdda215:                "insert into D438.T438_T1(a, b) values (n.a, n.b || '_ROW')");
1:cdda215:             s.executeUpdate(
1:cdda215:                "create trigger D438.T438_STMT_1 after UPDATE on D438.T438 " +
1:cdda215:                "referencing new_table as n " + 
1:cdda215:                "for each statement "+ 
1:cdda215:                (modeDb2SqlOptional?"":"mode db2sql ") +
1:cdda215:                "insert into D438.T438_T1(a, b) select n.a, n.b || '_STMT' from n"); 
1:cdda215:             
1:cdda215:             commit();
1:cdda215:             break;
1:ca1a8f2:             
1:cdda215:         case PH_SOFT_UPGRADE:
1:cdda215:             s.execute(
1:cdda215:                "create trigger D438.T438_ROW_2 after UPDATE on D438.T438 " +
1:cdda215:                "referencing new as n old as o " + 
1:cdda215:                "for each row "+ 
1:cdda215:                (modeDb2SqlOptional?"":"mode db2sql ") +
1:cdda215:                "insert into D438.T438_T2(a, c) values (n.a, n.c + 100)");
1:cdda215:              s.executeUpdate(
1:cdda215:                 "create trigger D438.T438_STMT_2 after UPDATE on D438.T438 " +
1:cdda215:                 "referencing new_table as n " + 
1:cdda215:                 "for each statement "+ 
1:cdda215:                (modeDb2SqlOptional?"":"mode db2sql ") +
1:cdda215:                 "insert into D438.T438_T2(a, c) select n.a, n.c + 4000 from n"); 
1:ca1a8f2:                  
1:cdda215:             commit();
1:cdda215:             break;
1:cdda215:         case PH_POST_SOFT_UPGRADE:
1:cdda215:             break;
2:cdda215:         case PH_HARD_UPGRADE:
1:cdda215:            break;
1:ca1a8f2:         }
1:ca1a8f2:         
1:cdda215:         // Test the firing of the triggers
1:cdda215:         s.executeUpdate("UPDATE D438.T438 set c = c + 1");
1:cdda215:         commit();
1:daf5fa3:         
1:cdda215:         ResultSet rs = s.executeQuery("SELECT a,b from D438.T438_T1 ORDER BY 2");
1:cdda215:         JDBC.assertFullResultSet(rs, new String[][]
1:cdda215:                 {{"1", "DERBY-438_ROW"},
1:cdda215:                 {"1", "DERBY-438_STMT"}});
1:cdda215:         rs.close();
1:cdda215:         
1:cdda215:         rs = s.executeQuery("SELECT a,c from D438.T438_T2 ORDER BY 2");
1:cdda215:         if (getPhase() == PH_CREATE)
1:e6cce75:         {
1:cdda215:             // expect no rows since the trigger that populates
1:cdda215:             // the table is defined in soft upgrade.
1:cdda215:             assertFalse(rs.next());
1:cdda215:         }
1:cdda215:         else
1:ca1a8f2:         {
1:cdda215:             JDBC.assertFullResultSet(rs, new String[][] {
1:cdda215:                     {"1", Integer.toString(2 + 100 + getPhase() + 1)},
1:cdda215:                     {"1", Integer.toString(2 + 4000 + getPhase() + 1)}});
1:cdda215:             
1:cdda215:         }
1:cdda215:         rs.close();
1:cdda215:             
1:cdda215:         s.executeUpdate("DELETE FROM D438.T438_T1");
1:cdda215:         s.executeUpdate("DELETE FROM D438.T438_T2");
1:cdda215:         commit();
1:cdda215:        
1:cdda215:         s.close();
1:cdda215:     }
1:cdda215:     
1:918e8b0:     /**
1:cdda215:      * In 10.2: We will write a ReusableRecordIdSequenceNumber in the 
1:cdda215:      * header of a FileContaienr.
1:ca1a8f2:      * 
1:cdda215:      * Verify here that a 10.1 Database does not malfunction from this.
1:cdda215:      * 10.1 Databases should ignore the field.
1:ca1a8f2:      */
1:cdda215:     public void testReusableRecordIdSequenceNumber()
1:cdda215:         throws SQLException
3:cdda215:     {
1:cdda215:         boolean runCompress = oldAtLeast(10, 1);
1:cdda215: 
1:cdda215:         switch(getPhase()) {
1:cdda215:         case PH_CREATE: {
1:cdda215:             Statement s = createStatement();
1:cdda215:             s.execute("create table CT1(id int)");
1:cdda215:             s.execute("insert into CT1 values 1,2,3,4,5,6,7,8,9,10");
1:cdda215:             s.close();
1:cdda215:             commit();
1:cdda215:             break;
1:cdda215:         }
1:cdda215:         case PH_SOFT_UPGRADE:
1:cdda215:             if (runCompress) {
1:cdda215:                 PreparedStatement ps = prepareStatement
1:cdda215:                     ("call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?,?,?,?,?)");
1:cdda215:                 ps.setString(1, "APP"); // schema
1:cdda215:                 ps.setString(2, "CT1");  // table name
1:cdda215:                 ps.setInt(3, 1); // purge
1:cdda215:                 ps.setInt(4, 1); // defragment rows
1:cdda215:                 ps.setInt(5, 1); // truncate end
1:cdda215:                 ps.executeUpdate();
1:cdda215:                 ps.close();
1:cdda215:                commit();
1:cdda215:             }
1:cdda215:             break;
1:cdda215:         case PH_POST_SOFT_UPGRADE: {
1:cdda215:             // We are now back to i.e 10.1
1:cdda215:             Statement s = createStatement();
1:cdda215:             ResultSet rs = s.executeQuery("select * from CT1");
1:cdda215:             while (rs.next()) {
1:cdda215:                 rs.getInt(1);
1:cdda215:             }
1:cdda215:             s.execute("insert into CT1 values 11,12,13,14,15,16,17,18,19");
1:cdda215:             s.close();
1:cdda215:             commit();
1:cdda215:             break;
1:cdda215:         }
1:daf5fa3:         case PH_HARD_UPGRADE:
1:cdda215:             break;
1:cdda215:         }
1:cdda215:     }
1:cdda215:     
1:ca1a8f2:     /**
1:daf5fa3:      * Simple test of if GRANT/REVOKE statements are handled
1:daf5fa3:      * correctly in terms of being allowed in soft upgrade.
1:ca1a8f2:      * @throws SQLException 
1:daf5fa3:      *
1:daf5fa3:      */
1:daf5fa3:     public void testGrantRevokeStatements() throws SQLException
1:daf5fa3:     {
1:daf5fa3:         Statement s = createStatement();
1:daf5fa3:         switch(getPhase()) {
1:daf5fa3:         // 
1:daf5fa3:         case PH_CREATE:
1:daf5fa3:         case PH_POST_SOFT_UPGRADE:
1:daf5fa3:             // was syntax error in 10.0,10.1
1:daf5fa3:             assertStatementError("42X01", s,
1:daf5fa3:                 "GRANT SELECT ON TABLE1 TO USER1");
1:daf5fa3:             assertStatementError("42X01", s,
1:daf5fa3:                 "REVOKE SELECT ON TABLE1 FROM USER1");
1:daf5fa3: 
1:daf5fa3:             break;
1:daf5fa3:             
1:daf5fa3:         case PH_SOFT_UPGRADE:
1:daf5fa3:             // require hard upgrade
1:daf5fa3:             assertStatementError(SQLSTATE_NEED_UPGRADE, s,
1:daf5fa3:                 "GRANT SELECT ON TABLE1 TO USER1");
1:daf5fa3:             assertStatementError(SQLSTATE_NEED_UPGRADE, s,
1:daf5fa3:                 "REVOKE SELECT ON TABLE1 FROM USER1");
1:daf5fa3: 
1:daf5fa3:             break;
1:daf5fa3:             
1:daf5fa3:         case PH_HARD_UPGRADE:
1:daf5fa3:             // not supported because SQL authorization not set
1:daf5fa3:             assertStatementError("42Z60", s,
1:daf5fa3:                 "GRANT SELECT ON TABLE1 TO USER1");
1:daf5fa3:             assertStatementError("42Z60", s,
1:daf5fa3:                 "REVOKE SELECT ON TABLE1 FROM USER1");
1:daf5fa3:             break;
1:daf5fa3:         }
1:daf5fa3:         s.close();
1:daf5fa3:     }
1:daf5fa3:     
1:ca1a8f2:     /**
1:daf5fa3:      * This method lists the schema names and authorization ids in 
1:daf5fa3:      * SYS.SCHEMAS table. This is to test that the owner of system schemas is 
1:daf5fa3:      * changed from pseudo user "DBA" to the user invoking upgrade. 
1:daf5fa3:      * 
1:daf5fa3:      * @throws SQLException
1:daf5fa3:      */
1:daf5fa3:     public void testDatabaseOwnerChange() throws SQLException
1:daf5fa3:     {
1:daf5fa3:         switch (getPhase())
1:daf5fa3:         {
1:daf5fa3:         case PH_CREATE:
1:daf5fa3:         case PH_SOFT_UPGRADE:
1:daf5fa3:         case PH_POST_SOFT_UPGRADE:
1:daf5fa3:             checkSystemSchemasOwner("DBA");
1:daf5fa3:             break;
1:daf5fa3: 
1:ca1a8f2:         case PH_HARD_UPGRADE:
1:daf5fa3:             checkSystemSchemasOwner(getTestConfiguration().getUserName());
1:daf5fa3:             break;
1:daf5fa3:         }
1:daf5fa3:     }
1:daf5fa3:     
1:daf5fa3:     private void checkSystemSchemasOwner(String name) throws SQLException
1:daf5fa3:     {
1:daf5fa3:         Statement s = createStatement();
1:daf5fa3:         ResultSet rs = s.executeQuery(
1:daf5fa3:                 "select AUTHORIZATIONID, SCHEMANAME from SYS.SYSSCHEMAS " +
1:daf5fa3:                    "WHERE SCHEMANAME LIKE 'SYS%' OR " +
1:daf5fa3:                    "SCHEMANAME IN ('NULLID', 'SQLJ')");
1:daf5fa3:         
1:daf5fa3:         while (rs.next()) {
1:daf5fa3:             assertEquals("AUTHORIZATIONID not valid for " + rs.getString(2),
1:daf5fa3:                     name, rs.getString(1));
1:daf5fa3:         }
1:daf5fa3:         
1:daf5fa3:         rs.close();
1:daf5fa3:         s.close();
1:daf5fa3:     }
1:daf5fa3:     
1:daf5fa3:     /**
1:daf5fa3:      * This method checks that some system routines are granted public access 
1:daf5fa3:      * after a full upgrade.
1:daf5fa3:      * 
1:daf5fa3:      * @throws SQLException
1:daf5fa3:      */
1:daf5fa3:     public void testSystemRoutinePermissions() throws SQLException
1:daf5fa3:     {
1:daf5fa3:         switch (getPhase())
1:daf5fa3:         {
1:daf5fa3:         case PH_CREATE:
1:daf5fa3:         case PH_SOFT_UPGRADE:
1:daf5fa3:         case PH_POST_SOFT_UPGRADE:
1:daf5fa3:             break;
1:daf5fa3: 
1:daf5fa3:         case PH_HARD_UPGRADE:
1:daf5fa3:             Statement s = createStatement();
1:daf5fa3:             ResultSet rs = s.executeQuery("select A.ALIAS FROM " +
1:daf5fa3:                     "SYS.SYSROUTINEPERMS R, SYS.SYSALIASES A " +
1:daf5fa3:                     "WHERE R.ALIASID = A.ALIASID AND " +
1:daf5fa3:                     "R.GRANTEE = 'PUBLIC' AND " +
1:daf5fa3:                     "R.GRANTOR = '"
1:daf5fa3:                         + getTestConfiguration().getUserName() + "'" +
1:daf5fa3:                     " ORDER BY 1");
1:daf5fa3:             JDBC.assertFullResultSet(rs, new String[][]
1:daf5fa3:                     {{"SYSCS_COMPRESS_TABLE"},
1:a6a0733:                     {"SYSCS_DROP_STATISTICS"},
1:314a19a:                     {"SYSCS_GET_DATABASE_NAME"},
1:daf5fa3:                     {"SYSCS_GET_RUNTIMESTATISTICS"},
1:daf5fa3:                     {"SYSCS_INPLACE_COMPRESS_TABLE"},
1:b4c4ee0:                     {"SYSCS_MODIFY_PASSWORD"},
1:7fd0c6e:                     {"SYSCS_PEEK_AT_IDENTITY"},
1:8e352d6:                     {"SYSCS_PEEK_AT_SEQUENCE"},
1:daf5fa3:                     {"SYSCS_SET_RUNTIMESTATISTICS"},
1:963d9f4:                     {"SYSCS_SET_STATISTICS_TIMING"},
1:963d9f4:                     {"SYSCS_UPDATE_STATISTICS"}}
1:daf5fa3:                     );
1:daf5fa3: 
1:daf5fa3:             rs.close();
1:daf5fa3:             s.close();
1:daf5fa3:             break;
1:daf5fa3:         }
1:daf5fa3:     }
1:daf5fa3:     
1:daf5fa3:     /**
1:918e8b0:      * Run the change encryption test against a
1:918e8b0:      * non-encrypted database. Test that changing the encryption
1:918e8b0:      * is only allowed if the database has been hard-upgraded. 
1:ca1a8f2:      * This test assumes it has its own single use database, which
1:ca1a8f2:      * will not be booted by the general upgrade test setup.
1:ca1a8f2:      * @throws SQLException
1:ca1a8f2:      */
1:918e8b0: 
1:c5571df:     public void changeEncryptionFromNone() throws SQLException
1:ca1a8f2:     {
1:918e8b0:         DataSource ds = JDBCDataSource.getDataSourceLogical("NO_ENCRYPT_10_2");
1:ca1a8f2:         
1:ca1a8f2:         switch (getPhase())
1:ca1a8f2:         {
1:ca1a8f2:         case PH_CREATE:
1:ca1a8f2:             // create the database if it was not already created.
1:ca1a8f2:             JDBCDataSource.setBeanProperty(ds, "createDatabase", "create");
1:ca1a8f2:             ds.getConnection().close();
1:ca1a8f2:             break;
1:ca1a8f2:         case PH_SOFT_UPGRADE:
1:e6cce75:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:ca1a8f2:                     "dataEncryption=true;bootPassword=xyz1234abc");
1:ca1a8f2:             
1:ca1a8f2:             try {
1:ca1a8f2:                 ds.getConnection();
1:ca1a8f2:                 fail("open re-encrypted connection in soft upgrade");
1:ca1a8f2:             } catch (SQLException e) {
1:ca1a8f2:                 assertSQLState("XJ040", e);
1:ca1a8f2:                 e = e.getNextException();
1:ca1a8f2:                 assertNotNull(e);
1:ca1a8f2:                 assertSQLState("XCL47", e);
1:e6cce75:             }
1:ca1a8f2:             break;
1:918e8b0:             
1:ca1a8f2:             
1:ca1a8f2:         case PH_POST_SOFT_UPGRADE:
1:ca1a8f2:             // Should be able to successfully connect to it
1:ca1a8f2:             // using the old setup.
1:ca1a8f2:             ds.getConnection().close();
1:ca1a8f2:             break;
1:e6cce75:             
1:e6cce75:         case PH_HARD_UPGRADE:
1:e6cce75:             // On hard upgrade should be able to connect to it
1:e6cce75:             // changing the encryption.
1:e6cce75:             // Note we have to explicitly upgrade additional databases.
1:e6cce75:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:e6cce75:             "upgrade=true;dataEncryption=true;bootPassword=haRD1234upGrAde");
1:e6cce75:             ds.getConnection().close();
1:e6cce75:             
1:e6cce75:             // Shutdown the database.
1:e6cce75:             JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
1:e6cce75:             JDBCDataSource.shutdownDatabase(ds);
1:e6cce75:             
1:e6cce75:             // Reboot with no boot password, should fail
1:e6cce75:             try {
1:e6cce75:                 ds.getConnection();
1:e6cce75:                 fail("open re-encrypted connection without password");
1:e6cce75:             } catch (SQLException e) {
1:e6cce75:                 assertSQLState("XJ040", e);
1:e6cce75:                 e = e.getNextException();
1:e6cce75:                 assertNotNull(e);
1:e6cce75:                 assertSQLState("XBM06", e);
1:e6cce75:             }
1:e6cce75:             
1:e6cce75:             // And connect successfully.
1:e6cce75:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:e6cce75:                        "bootPassword=haRD1234upGrAde");
1:e6cce75:             ds.getConnection().close();
1:e6cce75:             break;
1:ca1a8f2:         }
1:ca1a8f2:     }
1:cdda215:     /**
1:ca1a8f2:      * Run the change encryption test against a
1:918e8b0:      * encrypted database. Test that changing the encryption
1:918e8b0:      * is only allowed if the database has been hard-upgraded. 
1:918e8b0:      * This test assumes it has its own single use database, which
1:918e8b0:      * will not be booted by the general upgrade test setup.
1:918e8b0:      * @throws SQLException
1:918e8b0:      */
1:918e8b0: 
1:c5571df:     public void changeEncryptionFromEncryptedDatabase() throws SQLException
1:918e8b0:     {
1:918e8b0:         DataSource ds = JDBCDataSource.getDataSourceLogical("ENCRYPT_10_2");
1:918e8b0:         
1:918e8b0:         switch (getPhase())
1:918e8b0:         {
1:918e8b0:         case PH_CREATE:
1:918e8b0:             // create the database encrypted
1:918e8b0:             JDBCDataSource.setBeanProperty(ds, "createDatabase", "create");
1:918e8b0:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:918e8b0:                  "dataEncryption=true;bootPassword=old862phRase");
1:918e8b0:             ds.getConnection().close();
1:918e8b0:             break;
1:918e8b0:         case PH_SOFT_UPGRADE:
1:918e8b0:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:918e8b0:                     "bootPassword=old862phRase;newBootPassword=new902pHrAse");
1:918e8b0:             
1:918e8b0:             try {
1:918e8b0:                 ds.getConnection();
1:918e8b0:                 fail("open re-encrypted connection in soft upgrade");
1:918e8b0:             } catch (SQLException e) {
1:918e8b0:                 assertSQLState("XJ040", e);
1:918e8b0:                 e = e.getNextException();
1:918e8b0:                 assertNotNull(e);
1:918e8b0:                 assertSQLState("XCL47", e);
1:918e8b0:             }
1:918e8b0:             break;
1:918e8b0:             
1:918e8b0:             
1:918e8b0:         case PH_POST_SOFT_UPGRADE:
1:918e8b0:             // Should be able to successfully connect to it
1:918e8b0:             // using the old setup.
1:918e8b0:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:918e8b0:                  "bootPassword=old862phRase");
1:918e8b0:             ds.getConnection().close();
1:918e8b0:             break;
1:918e8b0:             
1:918e8b0:         case PH_HARD_UPGRADE:
1:918e8b0:             // On hard upgrade should be able to connect to it
1:918e8b0:             // changing the encryption.
1:918e8b0:             // Note we have to explicitly upgrade additional databases.
1:918e8b0:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:918e8b0:             "upgrade=true;bootPassword=old862phRase;newBootPassword=hard924pHrAse");
1:918e8b0:             ds.getConnection().close();
1:918e8b0:             
1:918e8b0:             // Shutdown the database.
1:918e8b0:             JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
1:918e8b0:             JDBCDataSource.shutdownDatabase(ds);
1:918e8b0:             
1:918e8b0:             // Reboot with no boot password, should fail
1:918e8b0:             try {
1:918e8b0:                 ds.getConnection();
1:918e8b0:                 fail("open re-encrypted connection without password");
1:918e8b0:             } catch (SQLException e) {
1:918e8b0:                 assertSQLState("XJ040", e);
1:918e8b0:                 e = e.getNextException();
1:918e8b0:                 assertNotNull(e);
1:918e8b0:                 assertSQLState("XBM06", e);
1:918e8b0:             }
1:ca1a8f2:             
1:918e8b0:             // And connect successfully.
1:918e8b0:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:918e8b0:                        "bootPassword=hard924pHrAse");
1:918e8b0:             ds.getConnection().close();
1:918e8b0:             break;
1:918e8b0:         }
1:918e8b0:     }
1:ca1a8f2: }
============================================================================
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:314a19a
/////////////////////////////////////////////////////////////////////////
1:                     {"SYSCS_GET_DATABASE_NAME"},
commit:a6a0733
/////////////////////////////////////////////////////////////////////////
1:                     {"SYSCS_DROP_STATISTICS"},
commit:963d9f4
/////////////////////////////////////////////////////////////////////////
1:                     {"SYSCS_SET_STATISTICS_TIMING"},
1:                     {"SYSCS_UPDATE_STATISTICS"}}
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("Upgrade changes for 10.2");
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:7fd0c6e
/////////////////////////////////////////////////////////////////////////
1:                     {"SYSCS_PEEK_AT_IDENTITY"},
commit:8e352d6
/////////////////////////////////////////////////////////////////////////
1:                     {"SYSCS_PEEK_AT_SEQUENCE"},
commit:b4c4ee0
/////////////////////////////////////////////////////////////////////////
1:                     {"SYSCS_MODIFY_PASSWORD"},
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:c5571df
/////////////////////////////////////////////////////////////////////////
1:         // Encryption only support on J2SE or higher.
1:         if (JDBC.vmSupportsJDBC3())
1:         {
1:             suite.addTest(new Changes10_2("changeEncryptionFromNone"));
1:             suite.addTest(new Changes10_2("changeEncryptionFromEncryptedDatabase"));
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:     public void changeEncryptionFromNone() throws SQLException
/////////////////////////////////////////////////////////////////////////
1:     public void changeEncryptionFromEncryptedDatabase() throws SQLException
commit:918e8b0
/////////////////////////////////////////////////////////////////////////
1:      * non-encrypted database. Test that changing the encryption
1:      * is only allowed if the database has been hard-upgraded. 
1: 
0:     public void testChangeEncryptionFromNone() throws SQLException
1:         DataSource ds = JDBCDataSource.getDataSourceLogical("NO_ENCRYPT_10_2");
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Run the change encryption test against a
1:      * encrypted database. Test that changing the encryption
1:      * is only allowed if the database has been hard-upgraded. 
1:      * This test assumes it has its own single use database, which
1:      * will not be booted by the general upgrade test setup.
1:      * @throws SQLException
1:      */
1: 
0:     public void testChangeEncryptionFromEncryptedDatabase() throws SQLException
1:     {
1:         DataSource ds = JDBCDataSource.getDataSourceLogical("ENCRYPT_10_2");
1:         
1:         switch (getPhase())
1:         {
1:         case PH_CREATE:
1:             // create the database encrypted
1:             JDBCDataSource.setBeanProperty(ds, "createDatabase", "create");
1:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:                  "dataEncryption=true;bootPassword=old862phRase");
1:             ds.getConnection().close();
1:             break;
1:         case PH_SOFT_UPGRADE:
1:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:                     "bootPassword=old862phRase;newBootPassword=new902pHrAse");
1:             
1:             try {
1:                 ds.getConnection();
1:                 fail("open re-encrypted connection in soft upgrade");
1:             } catch (SQLException e) {
1:                 assertSQLState("XJ040", e);
1:                 e = e.getNextException();
1:                 assertNotNull(e);
1:                 assertSQLState("XCL47", e);
1:             }
1:             break;
1:             
1:             
1:         case PH_POST_SOFT_UPGRADE:
1:             // Should be able to successfully connect to it
1:             // using the old setup.
1:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:                  "bootPassword=old862phRase");
1:             ds.getConnection().close();
1:             break;
1:             
1:         case PH_HARD_UPGRADE:
1:             // On hard upgrade should be able to connect to it
1:             // changing the encryption.
1:             // Note we have to explicitly upgrade additional databases.
1:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:             "upgrade=true;bootPassword=old862phRase;newBootPassword=hard924pHrAse");
1:             ds.getConnection().close();
1:             
1:             // Shutdown the database.
1:             JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
1:             JDBCDataSource.shutdownDatabase(ds);
1:             
1:             // Reboot with no boot password, should fail
1:             try {
1:                 ds.getConnection();
1:                 fail("open re-encrypted connection without password");
1:             } catch (SQLException e) {
1:                 assertSQLState("XJ040", e);
1:                 e = e.getNextException();
1:                 assertNotNull(e);
1:                 assertSQLState("XBM06", e);
1:             }
1:             
1:             // And connect successfully.
1:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:                        "bootPassword=hard924pHrAse");
1:             ds.getConnection().close();
1:             break;
1:         }
1:     }
commit:e6cce75
/////////////////////////////////////////////////////////////////////////
0:         changeEncryption("NO_ENCRYPT_10_2", false);
/////////////////////////////////////////////////////////////////////////
0:     private void changeEncryption(String logicalDBName,
0:             boolean encryptOldDB) throws SQLException
/////////////////////////////////////////////////////////////////////////
0:             if (encryptOldDB)
1:             {
1:                 JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
0:                     "dataEncryption=true;bootPassword=old1234dbPhraSe");
1:             }
/////////////////////////////////////////////////////////////////////////
1:             
1:         case PH_HARD_UPGRADE:
1:             // On hard upgrade should be able to connect to it
1:             // changing the encryption.
1:             // Note we have to explicitly upgrade additional databases.
1:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:             "upgrade=true;dataEncryption=true;bootPassword=haRD1234upGrAde");
1:             ds.getConnection().close();
1:             
1:             // Shutdown the database.
1:             JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
1:             JDBCDataSource.shutdownDatabase(ds);
1:             
1:             // Reboot with no boot password, should fail
1:             try {
1:                 ds.getConnection();
1:                 fail("open re-encrypted connection without password");
1:             } catch (SQLException e) {
1:                 assertSQLState("XJ040", e);
1:                 e = e.getNextException();
1:                 assertNotNull(e);
1:                 assertSQLState("XBM06", e);
1:             }
1:             
1:             // And connect successfully.
1:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:                        "bootPassword=haRD1234upGrAde");
1:             ds.getConnection().close();
1:             break;
commit:ca1a8f2
/////////////////////////////////////////////////////////////////////////
1: import javax.sql.DataSource;
1: 
1: import org.apache.derbyTesting.junit.JDBCDataSource;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Run the change encryption test against a
0:      * non-encrypted database.
1:      * 
1:      * @throws SQLException
1:      */
0:     public void testChangeEncryptionFromNone() throws SQLException
1:     {
0:         changeEncryption("NO_ENCRYPT_10_2");
1:     }
1:     
1:     
1:     /**
0:      * Test that changing the encryption is only allowed if
0:      * the database has been hard-upgraded. This test can
0:      * work against an existing encrypted or un-encrypted database.
1:      * This test assumes it has its own single use database, which
1:      * will not be booted by the general upgrade test setup.
1:      * @throws SQLException
1:      */
0:     private void changeEncryption(String logicalDBName) throws SQLException
1:     {
0:         DataSource ds = JDBCDataSource.getDataSourceLogical(logicalDBName);
1:         
1:         switch (getPhase())
1:         {
1:         case PH_CREATE:
1:             // create the database if it was not already created.
1:             JDBCDataSource.setBeanProperty(ds, "createDatabase", "create");
1:             ds.getConnection().close();
1:             break;
1:         case PH_SOFT_UPGRADE:
0:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:                     "dataEncryption=true;bootPassword=xyz1234abc");
1:             
1:             try {
1:                 ds.getConnection();
1:                 fail("open re-encrypted connection in soft upgrade");
1:             } catch (SQLException e) {
1:                 assertSQLState("XJ040", e);
1:                 e = e.getNextException();
1:                 assertNotNull(e);
1:                 assertSQLState("XCL47", e);
1:             }
1:             break;
1:             
1:             
1:         case PH_POST_SOFT_UPGRADE:
1:         case PH_HARD_UPGRADE:
1:             // Should be able to successfully connect to it
1:             // using the old setup.
1:             ds.getConnection().close();
1:             break;
1:         }
1:     }
commit:daf5fa3
/////////////////////////////////////////////////////////////////////////
1:  * If the old version is 10.2 or later then these tests
1:  * will not be run.
1: 
/////////////////////////////////////////////////////////////////////////
1:  * <LI> testGrantRevokeStatements - Check G/R not allowed in soft upgrade.
1:  * <LI> testDatabaseOwner - test that on a hard upgrade database owner is set.
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Simple test of if GRANT/REVOKE statements are handled
1:      * correctly in terms of being allowed in soft upgrade.
1:      * @throws SQLException 
1:      *
1:      */
1:     public void testGrantRevokeStatements() throws SQLException
1:     {
1:         Statement s = createStatement();
1:         switch(getPhase()) {
1:         // 
1:         case PH_CREATE:
1:         case PH_POST_SOFT_UPGRADE:
1:             // was syntax error in 10.0,10.1
1:             assertStatementError("42X01", s,
1:                 "GRANT SELECT ON TABLE1 TO USER1");
1:             assertStatementError("42X01", s,
1:                 "REVOKE SELECT ON TABLE1 FROM USER1");
1: 
1:             break;
1:             
1:         case PH_SOFT_UPGRADE:
1:             // require hard upgrade
1:             assertStatementError(SQLSTATE_NEED_UPGRADE, s,
1:                 "GRANT SELECT ON TABLE1 TO USER1");
1:             assertStatementError(SQLSTATE_NEED_UPGRADE, s,
1:                 "REVOKE SELECT ON TABLE1 FROM USER1");
1: 
1:             break;
1:             
1:         case PH_HARD_UPGRADE:
1:             // not supported because SQL authorization not set
1:             assertStatementError("42Z60", s,
1:                 "GRANT SELECT ON TABLE1 TO USER1");
1:             assertStatementError("42Z60", s,
1:                 "REVOKE SELECT ON TABLE1 FROM USER1");
1:             break;
1:         }
1:         s.close();
1:     }
1:     
1:     /**
1:      * This method lists the schema names and authorization ids in 
1:      * SYS.SCHEMAS table. This is to test that the owner of system schemas is 
1:      * changed from pseudo user "DBA" to the user invoking upgrade. 
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testDatabaseOwnerChange() throws SQLException
1:     {
1:         switch (getPhase())
1:         {
1:         case PH_CREATE:
1:         case PH_SOFT_UPGRADE:
1:         case PH_POST_SOFT_UPGRADE:
1:             checkSystemSchemasOwner("DBA");
1:             break;
1: 
1:         case PH_HARD_UPGRADE:
1:             checkSystemSchemasOwner(getTestConfiguration().getUserName());
1:             break;
1:         }
1:     }
1:     
1:     private void checkSystemSchemasOwner(String name) throws SQLException
1:     {
1:         Statement s = createStatement();
1:         ResultSet rs = s.executeQuery(
1:                 "select AUTHORIZATIONID, SCHEMANAME from SYS.SYSSCHEMAS " +
1:                    "WHERE SCHEMANAME LIKE 'SYS%' OR " +
1:                    "SCHEMANAME IN ('NULLID', 'SQLJ')");
1:         
1:         while (rs.next()) {
1:             assertEquals("AUTHORIZATIONID not valid for " + rs.getString(2),
1:                     name, rs.getString(1));
1:         }
1:         
1:         rs.close();
1:         s.close();
1:     }
1:     
1:     /**
1:      * This method checks that some system routines are granted public access 
1:      * after a full upgrade.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testSystemRoutinePermissions() throws SQLException
1:     {
1:         switch (getPhase())
1:         {
1:         case PH_CREATE:
1:         case PH_SOFT_UPGRADE:
1:         case PH_POST_SOFT_UPGRADE:
1:             break;
1: 
1:         case PH_HARD_UPGRADE:
1:             Statement s = createStatement();
1:             ResultSet rs = s.executeQuery("select A.ALIAS FROM " +
1:                     "SYS.SYSROUTINEPERMS R, SYS.SYSALIASES A " +
1:                     "WHERE R.ALIASID = A.ALIASID AND " +
1:                     "R.GRANTEE = 'PUBLIC' AND " +
1:                     "R.GRANTOR = '"
1:                         + getTestConfiguration().getUserName() + "'" +
1:                     " ORDER BY 1");
1:             
1:             JDBC.assertFullResultSet(rs, new String[][]
1:                     {{"SYSCS_COMPRESS_TABLE"},
1:                     {"SYSCS_GET_RUNTIMESTATISTICS"},
1:                     {"SYSCS_INPLACE_COMPRESS_TABLE"},
1:                     {"SYSCS_SET_RUNTIMESTATISTICS"},
0:                     {"SYSCS_SET_STATISTICS_TIMING"}}
1:                     );
1: 
1:             rs.close();
1:             s.close();
1:             break;
1:         }
1:     }
commit:cdda215
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.Changes10_2
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1:    http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
1: 
0: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.JDBC;
1: 
1: /**
1:  * Upgrade test cases for changes made in 10.2.
1:  * <BR>
1:  * 10.2 Upgrade issues
1:  * <UL>
1:  * <LI> testTriggerInternalVTI - Check internal re-write of triggers
1:  * does not break triggers in soft upgrade mode.
1:  * <LI> testReusableRecordIdSequenceNumber - Test reuseable record
1:  * identifiers does not cause issues in soft upgrade
1:  * </UL>
1:  */
1: public class Changes10_2 extends UpgradeChange {
1:     
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("Upgrade changes for 10.2");
1:         
1:         suite.addTestSuite(Changes10_2.class);
1:         
1:         return suite;
1:     }
1: 
1:     public Changes10_2(String name) {
1:         super(name);
1:     }
1:     
1:     /**
1:      * Triger (internal) VTI
1:      * 10.2 - Check that a statement trigger created in 10.0
1:      * or 10.1 can be executed in 10.2 and that a statement
1:      * trigger created in soft upgrade in 10.2 can be used
1:      * in older releases.
1:      * 
1:      * The VTI implementing statement triggers changed in
1:      * 10.2 from implementations of ResultSet to implementations
1:      * of PreparedStatement. See DERBY-438. The internal
1:      * api for the re-written action statement remains the
1:      * same. The re-compile of the trigger on version changes
1:      * should automatically switch between the two implementations.
1:      *
0:      * @param conn Connection
0:      * @param phase Upgrade test phase
0:      * @param dbMajor Major version of old release 
0:      * @param dbMinor Minor version of old release
0:      * @return true, if the test passes
0:      * @throws SQLException
1:      */
1:     public void testTriggerInternalVTI()
1:                                     throws SQLException {
1:                 
1:         
1:         Statement s = createStatement();
1: 
1:         boolean modeDb2SqlOptional = oldAtLeast(10, 3);
1: 
1:         switch (getPhase()) {
1:         case PH_CREATE:
1:             s.execute("CREATE TABLE D438.T438(a int, b varchar(20), c int)");
1:             s.execute("INSERT INTO D438.T438 VALUES(1, 'DERBY-438', 2)");
1:             s.execute("CREATE TABLE D438.T438_T1(a int, b varchar(20))");
1:             s.execute("CREATE TABLE D438.T438_T2(a int, c int)");
1:             s.execute(
1:                "create trigger D438.T438_ROW_1 after UPDATE on D438.T438 " +
1:                "referencing new as n old as o " + 
1:                "for each row "+ 
1:                (modeDb2SqlOptional?"":"mode db2sql ") +
1:                "insert into D438.T438_T1(a, b) values (n.a, n.b || '_ROW')");
1:             s.executeUpdate(
1:                "create trigger D438.T438_STMT_1 after UPDATE on D438.T438 " +
1:                "referencing new_table as n " + 
1:                "for each statement "+ 
1:                (modeDb2SqlOptional?"":"mode db2sql ") +
1:                "insert into D438.T438_T1(a, b) select n.a, n.b || '_STMT' from n"); 
1:             
1:             commit();
1:             break;
1:             
1:         case PH_SOFT_UPGRADE:
1:             s.execute(
1:                "create trigger D438.T438_ROW_2 after UPDATE on D438.T438 " +
1:                "referencing new as n old as o " + 
1:                "for each row "+ 
1:                (modeDb2SqlOptional?"":"mode db2sql ") +
1:                "insert into D438.T438_T2(a, c) values (n.a, n.c + 100)");
1:              s.executeUpdate(
1:                 "create trigger D438.T438_STMT_2 after UPDATE on D438.T438 " +
1:                 "referencing new_table as n " + 
1:                 "for each statement "+ 
1:                (modeDb2SqlOptional?"":"mode db2sql ") +
1:                 "insert into D438.T438_T2(a, c) select n.a, n.c + 4000 from n"); 
1:                  
1:             commit();
1:             break;
1:         case PH_POST_SOFT_UPGRADE:
1:             break;
1:         case PH_HARD_UPGRADE:
1:            break;
1:         }
1:         
1:         // Test the firing of the triggers
1:         s.executeUpdate("UPDATE D438.T438 set c = c + 1");
1:         commit();
1:         
1:         ResultSet rs = s.executeQuery("SELECT a,b from D438.T438_T1 ORDER BY 2");
1:         JDBC.assertFullResultSet(rs, new String[][]
1:                 {{"1", "DERBY-438_ROW"},
1:                 {"1", "DERBY-438_STMT"}});
1:         rs.close();
1:         
1:         rs = s.executeQuery("SELECT a,c from D438.T438_T2 ORDER BY 2");
1:         if (getPhase() == PH_CREATE)
1:         {
1:             // expect no rows since the trigger that populates
1:             // the table is defined in soft upgrade.
1:             assertFalse(rs.next());
1:         }
1:         else
1:         {
1:             JDBC.assertFullResultSet(rs, new String[][] {
1:                     {"1", Integer.toString(2 + 100 + getPhase() + 1)},
1:                     {"1", Integer.toString(2 + 4000 + getPhase() + 1)}});
1:             
1:         }
1:         rs.close();
1:             
1:         s.executeUpdate("DELETE FROM D438.T438_T1");
1:         s.executeUpdate("DELETE FROM D438.T438_T2");
1:         commit();
1:        
1:         s.close();
1:     }
1:     
1:     /**
1:      * In 10.2: We will write a ReusableRecordIdSequenceNumber in the 
1:      * header of a FileContaienr.
1:      * 
1:      * Verify here that a 10.1 Database does not malfunction from this.
1:      * 10.1 Databases should ignore the field.
1:      */
1:     public void testReusableRecordIdSequenceNumber()
1:         throws SQLException
1:     {
1:         boolean runCompress = oldAtLeast(10, 1);
1: 
1:         switch(getPhase()) {
1:         case PH_CREATE: {
1:             Statement s = createStatement();
1:             s.execute("create table CT1(id int)");
1:             s.execute("insert into CT1 values 1,2,3,4,5,6,7,8,9,10");
1:             s.close();
1:             commit();
1:             break;
1:         }
1:         case PH_SOFT_UPGRADE:
1:             if (runCompress) {
1:                 PreparedStatement ps = prepareStatement
1:                     ("call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?,?,?,?,?)");
1:                 ps.setString(1, "APP"); // schema
1:                 ps.setString(2, "CT1");  // table name
1:                 ps.setInt(3, 1); // purge
1:                 ps.setInt(4, 1); // defragment rows
1:                 ps.setInt(5, 1); // truncate end
1:                 ps.executeUpdate();
1:                 ps.close();
1:                commit();
1:             }
1:             break;
1:         case PH_POST_SOFT_UPGRADE: {
1:             // We are now back to i.e 10.1
1:             Statement s = createStatement();
1:             ResultSet rs = s.executeQuery("select * from CT1");
1:             while (rs.next()) {
1:                 rs.getInt(1);
1:             }
1:             s.execute("insert into CT1 values 11,12,13,14,15,16,17,18,19");
1:             s.close();
1:             commit();
1:             break;
1:         }
1:         case PH_HARD_UPGRADE:
1:             break;
1:         }
1:     }
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
============================================================================